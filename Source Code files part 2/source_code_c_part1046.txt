unking mode
            try_return(Status = STATUS_NOT_IMPLEMENTED);
        }
#else
        // If we're in 32 bit (e.g. call above isn't available), use unchanged functionality
        // i.e. pure new-64-bit == pure old-32-bit == homogeneous environment. Thus, set to FALSE.
        fThunk32bit = FALSE;
#endif


        //
        //  The input buffer is either in Irp->AssociatedIrp.SystemBuffer, or
        //  in the Type3InputBuffer for type 3 IRP's.
        //

        InputBuffer = Irp->AssociatedIrp.SystemBuffer;

        //
        //  The lengths of the various buffers are easy to find, they're in the
        //  Irp stack location.
        //

        OutputBufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

        InputBufferLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

        //
        // Input buffer length sanity
        //  * Wow64 -- support 32 bit clients on 64 bit systems (see bug 454130)
        //

        if ( InputBufferLength != 0 ) {
            // use 32 bit struct
            if ( fThunk32bit ) {
                 if ( InputBufferLength < offsetof( LMDR_REQUEST_PACKET32,Parameters ) ) {
                    dlog(DPRT_FSCTL, ("IoControlFile: input buffer too short %d (32 bit)\n",
                                      InputBufferLength));
                    try_return(Status = STATUS_INVALID_PARAMETER);
                 }

                 //
                 // Convert buffer to 64 presentation
                 //
                 if (InputBuffer) {
#if DBG
//
// Temporary:
// We're not aware of any such cases where there are 32 bit ioctl conversions
// in FSP. Print out a debug notice for debugging/tracing.
//
                     DbgPrint("[mrxsmb!fsctl.c] Converting 32 bit ioctl 0x%x in FSP\n",
                              IoControlCode);
#endif
                     // sanity on buffer
                     ENSURE_BUFFER_BOUNDARIES(InputBuffer, &(((PLMDR_REQUEST_PACKET32)InputBuffer)->TransportName));
                     ENSURE_BUFFER_BOUNDARIES(InputBuffer, &(((PLMDR_REQUEST_PACKET32)InputBuffer)->EmulatedDomainName));

                     // convert buffer
                     OriginalInputBuffer = (LPBYTE)InputBuffer;
                     InputBuffer = (PVOID)RequestPacket32to64(
                                            (PLMDR_REQUEST_PACKET32)InputBuffer,
                                            &ReqPacketBuffer);
                     // fix length
                     InputBufferLength += sizeof(LMDR_REQUEST_PACKET) - sizeof(LMDR_REQUEST_PACKET32);
                 }

            }

            // use homogeneous environment struct
            if (InputBufferLength < offsetof( LMDR_REQUEST_PACKET,Parameters ) ) {
                dlog(DPRT_FSCTL, ("IoControlFile: input buffer too short %d\n", InputBufferLength));
                try_return(Status = STATUS_INVALID_PARAMETER);
            }
        }           // inputbufferlength != 0

        //
        //  If we are in the FSD, then the input buffer is in Type3InputBuffer
        //  on type 3 api's, not in SystemBuffer.
        //
        // Capture the type 3 buffer.
        //

        if (InputBuffer == NULL &&
            InputBufferLength != 0) {

            //
            //  This had better be a type 3 IOCTL.
            //


            if ((IoControlCode & 3) == METHOD_NEITHER) {
                PLMDR_REQUEST_PACKET RequestPacket;

                //
                // Capture the input buffer.
                //

                OriginalInputBuffer = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

                Status = BowserConvertType3IoControlToType2IoControl( Irp, IrpSp);

                if ( !NT_SUCCESS(Status) ) {
                    try_return( Status );
                }

                //
                // Relocate all the pointers in the input buffer.
                //  (Don't validate the pointers here.  Not all function codes
                //  initialize these fields.  For such function codes,
                //  this "relocation" may be changing the uninitialized garbage.)
                //
                RequestPacket = Irp->AssociatedIrp.SystemBuffer;

                //
                // Protect against callers that didn't specify an input buffer.
                //

                if ( RequestPacket == NULL ) {
                    try_return(Status = STATUS_INVALID_PARAMETER);
                }

                if (fThunk32bit) {

                    // convert buffer
                    RequestPacket = (PVOID)RequestPacket32to64(
                                                (PLMDR_REQUEST_PACKET32)RequestPacket,
                                                &ReqPacketBuffer);
                    // fix length
                    InputBufferLength += sizeof(LMDR_REQUEST_PACKET) - sizeof(LMDR_REQUEST_PACKET32);
                    // remark: sanity on buffers is done immediately below.
                    //         (cannot apply ENSURE_BUFFER_BOUNDARIES test to type3 ioctl)
                }
                //
                // Initialize the embedded unicode strings to NULL for IOCTLs which
                //   don't reference them.  The user-mode components don't always
                //   initialize buffers to zero.
                //

                if (IoControlCode == IOCTL_LMDR_START ||
                    IoControlCode == IOCTL_LMDR_STOP) {
                    RtlInitUnicodeString(&RequestPacket->EmulatedDomainName,NULL);
                    RtlInitUnicodeString(&RequestPacket->TransportName,NULL);
                }


                if (RequestPacket->Version == LMDR_REQUEST_PACKET_VERSION_DOM ||
                    RequestPacket->Version == LMDR_REQUEST_PACKET_VERSION) {

                    //
                    //  Relocate the transport name associated with this request.
                    //

                    if (RequestPacket->TransportName.Length != 0) {
                        PCHAR BufferStart = (PCHAR)RequestPacket->TransportName.Buffer;
                        PCHAR BufferEnd   = ((PCHAR)RequestPacket->TransportName.Buffer)+
                                            RequestPacket->TransportName.Length;

                        //
                        // Verify that the entire buffer indicated is contained within the input buffer.
                        //

                        if ((BufferStart < OriginalInputBuffer) ||
                            (BufferStart > OriginalInputBuffer + InputBufferLength) ||
                            (BufferEnd < OriginalInputBuffer) ||
                            (BufferEnd > OriginalInputBuffer + InputBufferLength)) {

                           //
                           // An invalid input string was specified.
                           //

                           try_return(Status = STATUS_INVALID_PARAMETER);

                        }

                        //
                        //  The name in within bounds, so convert it.
                        //

                        RequestPacket->TransportName.Buffer = (PWSTR)
                                    (((ULONG_PTR)Irp->AssociatedIrp.SystemBuffer)+
                                        (((ULONG_PTR)BufferStart) -
                                         ((ULONG_PTR)OriginalInputBuffer)));
                    } else {
                        RequestPacket->TransportName.MaximumLength = 0;
                        RequestPacket->TransportName.Buffer        = NULL;
                    }

                    //
                    //  Relocate the EmulatedDomain name associated with this request.
                    //

                    if (RequestPacket->EmulatedDomainName.Length != 0 &&
                        RequestPacket->Version != LMDR_REQUEST_PACKET_VERSION) {
                        PCHAR BufferStart = (PCHAR)RequestPacket->EmulatedDomainName.Buffer;
                        PCHAR BufferEnd   = ((PCHAR)RequestPacket->EmulatedDomainName.Buffer)+
                                            RequestPacket->EmulatedDomainName.Length;

                        //
                        // Verify that the entire buffer indicated is contained within the input buffer.
                        //

                        if ((BufferStart < OriginalInputBuffer) ||
                            (BufferStart > OriginalInputBuffer + InputBufferLength) ||
                            (BufferEnd < OriginalInputBuffer) ||
                            (BufferEnd > OriginalInputBuffer + InputBufferLength)) {

                           //
                           // An invalid input string was specified.
                           //

                           try_return(Status = STATUS_INVALID_PARAMETER);

                        }

                        //
                        //  The name in within bounds, so convert it.
                        //

                        RequestPacket->EmulatedDomainName.Buffer = (PWSTR)
                                    (((ULONG_PTR)Irp->AssociatedIrp.SystemBuffer)+
                                        (((ULONG_PTR)BufferStart) -
                                         ((ULONG_PTR)OriginalInputBuffer)));
                    } else {
                        RequestPacket->EmulatedDomainName.MaximumLength = 0;
                        RequestPacket->EmulatedDomainName.Buffer        = NULL;
                    }
                } else {
                    try_return(Status = STATUS_INVALID_PARAMETER);
                }

                //
                // Use the newly allocated input buffer from now on
                //
                InputBuffer = RequestPacket;

            } else {
                try_return(Status = STATUS_INVALID_PARAMETER);
            }
        }

        //
        //  Probe/lock the output buffer in memory, or is
        //  available in the input buffer.
        //

        try {
            PLMDR_REQUEST_PACKET RequestPacket = InputBuffer;

            if (OutputBufferLength != 0) {
                BowserMapUsersBuffer(Irp, &OutputBuffer, OutputBufferLength);
                if (OutputBuffer == NULL)
                {
                    //
                    // Error: Could not map user buffer (out of resources?)
                    //
                    try_return (Status = STATUS_INSUFFICIENT_RESOURCES);
                }
            }

            //
            // Convert old version requests to new version requests.
            //

            if (RequestPacket != NULL) {
                if (InputBufferLength < offsetof( LMDR_REQUEST_PACKET,Parameters )) {
                    ExRaiseStatus (STATUS_INVALID_PARAMETER);
                }
                if (RequestPacket->Version == LMDR_REQUEST_PACKET_VERSION ) {
                    RtlInitUnicodeString( &RequestPacket->EmulatedDomainName, NULL );
                    RequestPacket->Version = LMDR_REQUEST_PACKET_VERSION_DOM;
                }
            }

        } except (BR_EXCEPTION) {
            try_return (Status = GetExceptionCode());
        }

        switch (MinorFunction) {

            //
            //  The NT redirector does not support local physical media, all
            //  such IoControlFile requests are unsupported.
            //

            case IRP_MN_USER_FS_REQUEST:

                //
                // If we're not starting the bowser,
                //  make sure it is started.
                //

                ExAcquireResourceSharedLite(&BowserDataResource, TRUE);
                if ( IoControlCode != IOCTL_LMDR_START ) {

                    if (BowserData.Initialized != TRUE) {
                        dlog(DPRT_FSCTL, ("Bowser not started.\n"));
                        ExReleaseResourceLite(&BowserDataResource);
                        Status = STATUS_REDIRECTOR_NOT_STARTED;
                        break;
                    }
                }

                //
                // Ensure a IOCTL_LMDR_STOP doesn't come in while
                //  we're working.
                //
                InterlockedIncrement( &BowserOperationCount );

                ExReleaseResourceLite(&BowserDataResource);

                switch (IoControlCode) {

                case IOCTL_LMDR_START:
                    Status = StartBowser(Wait, InFsd, DeviceObject, InputBuffer, InputBufferLength);
                    break;

                case IOCTL_LMDR_STOP:
                    Status = StopBowser(Wait, InFsd, DeviceObject,  InputBuffer, InputBufferLength);
                    break;

                case IOCTL_LMDR_BIND_TO_TRANSPORT:
                case IOCTL_LMDR_BIND_TO_TRANSPORT_DOM:
                    BOWSECURITYCHECK ( Irp, IrpSp, Status );
                    Status = BowserBindToTransport(Wait, InFsd, InputBuffer, InputBufferLength);
                    break;

                case IOCTL_LMDR_UNBIND_FROM_TRANSPORT:
                case IOCTL_LMDR_UNBIND_FROM_TRANSPORT_DOM:
                    Status = UnbindFromTransport(Wait, InFsd, InputBuffer, InputBufferLength);
                    break;

                case IOCTL_LMDR_ENUMERATE_TRANSPORTS:
                    Status = BowserEnumTransports(Wait, InFsd,
                                                  InputBuffer, &InputBufferLength,
                                                  OutputBuffer, OutputBufferLength,
                                                  (PUCHAR)OutputBuffer - (PUCHAR)Irp->UserBuffer);
                    CopyEnumResultsToCaller = TRUE;
                    break;

                case IOCTL_LMDR_ENUMERATE_NAMES:
                    Status = EnumNames(Wait, InFsd,
                                       InputBuffer, &InputBufferLength,
                                       OutputBuffer, OutputBufferLength,
                                       (PUCHAR)OutputBuffer - (PUCHAR)Irp->UserBuffer);
                    CopyEnumResultsToCaller = TRUE;
                    break;

                case IOCTL_LMDR_ADD_NAME:
                case IOCTL_LMDR_ADD_NAME_DOM:
                    BOWSECURITYCHECK(Irp, IrpSp, Status);
                    Status = AddBowserName(Wait, InFsd, InputBuffer, InputBufferLength);
                    break;

                case IOCTL_LMDR_DELETE_NAME:
                case IOCTL_LMDR_DELETE_NAME_DOM:
                    Status = DeleteName (Wait, InFsd, InputBuffer, InputBufferLength);
                    break;

                case IOCTL_LMDR_ENUMERATE_SERVERS:
                    Status = EnumServers(Wait, InFsd,
                                         InputBuffer, &InputBufferLength,
                                         OutputBuffer, OutputBufferLength,
                                         (PUCHAR)OutputBuffer - (PUCHAR)Irp->UserBuffer);
                    CopyEnumResultsToCaller = TRUE;
                    break;

                case IOCTL_LMDR_GET_BROWSER_SERVER_LIST:
                    Status = GetBrowserServerList(Irp, Wait, InFsd,
                                                  InputBuffer, &InputBufferLength,
                                                  OutputBuffer, OutputBufferLength,
                                                  (PUCHAR)OutputBuffer - (PUCHAR)Irp->UserBuffer);
                    CopyEnumResultsToCaller = TRUE;
                    break;


                case IOCTL_LMDR_GET_MASTER_NAME:
                    Status = GetMasterName(Irp, Wait, InFsd,
                                            InputBuffer, InputBufferLength );
                    break;

                case IOCTL_LMDR_BECOME_BACKUP:
                    Status = HandleBecomeBackup(Irp, InputBuffer, InputBufferLength);
                    break;

                case IOCTL_LMDR_BECOME_MASTER:
                    Status = BecomeMaster(Irp, InputBuffer, InputBufferLength);
                    break;

                case IOCTL_LMDR_WAIT_FOR_MASTER_ANNOUNCE:
                    Status = WaitForMasterAnnounce(Irp, InputBuffer, InputBufferLength);
                    break;

                case IOCTL_LMDR_WRITE_MAILSLOT:
                    Status = WriteMailslot(Irp, InputBuffer, InputBufferLength, OutputBuffer, OutputBufferLength);
                    break;

                case IOCTL_LMDR_UPDATE_STATUS:
                    BOWSECURITYCHECK(Irp, IrpSp, Status);
                    Status = UpdateStatus(Irp, InFsd, InputBuffer, InputBufferLength );
                    break;

                case IOCTL_LMDR_CHANGE_ROLE:
                    Status = WaitForBrowserRoleChange(Irp, InputBuffer, InputBufferLength );
                    break;

                case IOCTL_LMDR_NEW_MASTER_NAME:
                    Status = WaitForNewMaster(Irp, InputBuffer, InputBufferLength);
                    break;

                case IOCTL_LMDR_QUERY_STATISTICS:
                    Status = QueryStatistics(Irp, OutputBuffer, &OutputBufferLength);
                    InputBufferLength = OutputBufferLength;
                    break;

                case IOCTL_LMDR_RESET_STATISTICS:
                    Status = ResetStatistics();
                    break;

                case IOCTL_LMDR_NETLOGON_MAILSLOT_READ:
                    Status = BowserReadPnp( Irp, OutputBufferLength, NETLOGON_PNP );
                    break;

                case IOCTL_LMDR_NETLOGON_MAILSLOT_ENABLE:
                    BOWSECURITYCHECK ( Irp, IrpSp, Status );

                    if (InputBufferLength <
                        (ULONG)FIELD_OFFSET(LMDR_REQUEST_PACKET,Parameters)+sizeof(DWORD)) {
                        Status = STATUS_INVALID_PARAMETER;
                    } else  {
                        Status = BowserEnablePnp( InputBuffer, NETLOGON_PNP );
                    }
                    break;

                case IOCTL_LMDR_IP_ADDRESS_CHANGED:
                    BOWSECURITYCHECK(Irp, IrpSp, Status);
                    Status = BowserIpAddressChanged( InputBuffer );
                    break;

                case IOCTL_LMDR_ENABLE_DISABLE_TRANSPORT:
                    Status = EnableDisableTransport( InputBuffer, InputBufferLength );
                    break;

                case IOCTL_LMDR_BROWSER_PNP_READ:
                    Status = BowserReadPnp( Irp, OutputBufferLength, BROWSER_PNP );
                    break;

                case IOCTL_LMDR_BROWSER_PNP_ENABLE:
                    if (InputBufferLength <
                        (ULONG)FIELD_OFFSET(LMDR_REQUEST_PACKET,Parameters)+sizeof(DWORD)) {
                       Status = STATUS_INVALID_PARAMETER;
                    } else  {
                       Status = BowserEnablePnp( InputBuffer, BROWSER_PNP );
                    }
                    break;

                case IOCTL_LMDR_RENAME_DOMAIN:
                    BOWSECURITYCHECK(Irp, IrpSp, Status);
                    Status = BowserRenameDomain( InputBuffer, InputBufferLength );
                    break;

#if DBG
                case IOCTL_LMDR_DEBUG_CALL:
                    Status = BowserDebugCall(InputBuffer, InputBufferLength);
                    break;
#endif

                default:
                    dlog(DPRT_FSCTL, ("Unknown IoControlFile %d\n", MinorFunction));
                    Status = STATUS_NOT_IMPLEMENTED;
                    break;
                }

                //
                // Allow IOCTL_LMDR_STOP
                //
                InterlockedDecrement( &BowserOperationCount );

                break;

            //
            //  All other IoControlFile API's
            //

            default:
                dlog(DPRT_FSCTL, ("Unknown IoControlFile %d\n", MinorFunction));
                Status = STATUS_NOT_IMPLEMENTED;
                break;
        }

        if (Status != STATUS_PENDING) {
            //
            //  Return the size of the input buffer to the caller.
            //      (But never more than the output buffer size).
            //

            Irp->IoStatus.Information = min(InputBufferLength, OutputBufferLength);

            //
            // If the input buffer needs to be copied back to the caller,
            //  do so now.
            //

            if ( CopyEnumResultsToCaller && OriginalInputBuffer != NULL ) {
                try {
                    if (Irp->RequestorMode != KernelMode) {
                        ProbeForWrite( OriginalInputBuffer,
                                       InputBufferLength,
                                       sizeof(DWORD) );
                    }

                    //
                    // Copy the enumeration results to the caller.
                    //
                    // Don't copy the entire request packet back to the caller.
                    // It has other modified fields (e.g., relocated pointers)
                    //
                    if ( fThunk32bit ) {
                        // typecast to 32bit buffer
                        ((PLMDR_REQUEST_PACKET32)OriginalInputBuffer)->Parameters.EnumerateNames.EntriesRead =
                            ((PLMDR_REQUEST_PACKET)InputBuffer)->Parameters.EnumerateNames.EntriesRead;
                        ((PLMDR_REQUEST_PACKET32)OriginalInputBuffer)->Parameters.EnumerateNames.TotalEntries =
                            ((PLMDR_REQUEST_PACKET)InputBuffer)->Parameters.EnumerateNames.TotalEntries;
                        ((PLMDR_REQUEST_PACKET32)OriginalInputBuffer)->Parameters.EnumerateNames.TotalBytesNeeded =
                            ((PLMDR_REQUEST_PACKET)InputBuffer)->Parameters.EnumerateNames.TotalBytesNeeded;
                        ((PLMDR_REQUEST_PACKET32)OriginalInputBuffer)->Parameters.EnumerateNames.ResumeHandle =
                            ((PLMDR_REQUEST_PACKET)InputBuffer)->Parameters.EnumerateNames.ResumeHandle;
                    }
                    else{
                        // native mode
                        ((PLMDR_REQUEST_PACKET)OriginalInputBuffer)->Parameters.EnumerateNames.EntriesRead =
                            ((PLMDR_REQUEST_PACKET)InputBuffer)->Parameters.EnumerateNames.EntriesRead;
                        ((PLMDR_REQUEST_PACKET)OriginalInputBuffer)->Parameters.EnumerateNames.TotalEntries =
                            ((PLMDR_REQUEST_PACKET)InputBuffer)->Parameters.EnumerateNames.TotalEntries;
                        ((PLMDR_REQUEST_PACKET)OriginalInputBuffer)->Parameters.EnumerateNames.TotalBytesNeeded =
                            ((PLMDR_REQUEST_PACKET)InputBuffer)->Parameters.EnumerateNames.TotalBytesNeeded;
                        ((PLMDR_REQUEST_PACKET)OriginalInputBuffer)->Parameters.EnumerateNames.ResumeHandle =
                            ((PLMDR_REQUEST_PACKET)InputBuffer)->Parameters.EnumerateNames.ResumeHandle;
                    }

                } except (BR_EXCEPTION) {
                    try_return (Status = GetExceptionCode());
                }
            }
        }


try_exit:NOTHING;
    } finally {

        if (Status == STATUS_PENDING) {

            //
            //  If this is one of the longterm FsControl APIs, they are
            //  not to be processed in the FSP, they should just be returned
            //  to the caller with STATUS_PENDING.
            //

            if ((MinorFunction == IRP_MN_USER_FS_REQUEST) &&
                ((IoControlCode == IOCTL_LMDR_GET_MASTER_NAME) ||
                 (IoControlCode == IOCTL_LMDR_BECOME_BACKUP) ||
                 (IoControlCode == IOCTL_LMDR_BECOME_MASTER) ||
                 (IoControlCode == IOCTL_LMDR_CHANGE_ROLE) ||
                 (IoControlCode == IOCTL_LMDR_NEW_MASTER_NAME) ||
                 (IoControlCode == IOCTL_LMDR_WAIT_FOR_MASTER_ANNOUNCE) ||
                 (IoControlCode == IOCTL_LMDR_NETLOGON_MAILSLOT_READ) ||
                 (IoControlCode == IOCTL_LMDR_BROWSER_PNP_READ))) {
                //  return Status;

            //
            // If this call is to be processed in the FSP,
            //  do it.
            //
            // The input buffer has already been captured and relocated.
            //

            } else {
                Status = BowserFsdPostToFsp(DeviceObject, Irp);

                if (Status != STATUS_PENDING) {
                    BowserCompleteRequest(Irp, Status);
                }
            }

        } else {
            BowserCompleteRequest(Irp, Status);
        }
    }

    dlog(DPRT_FSCTL, ("Returning status: %X\n", Status));

#undef BOWSECURITYCHECK

    return Status;
}

NTSTATUS
StartBowser (
    IN BOOLEAN Wait,
    IN BOOLEAN InFsd,
    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    )

/*++

Routine Description:

    This routine adds a reference to a file object created with .

Arguments:

    IN BOOLEAN Wait, - True IFF redirector can block callers thread on request
    IN BOOLEAN InFsd, - True IFF this request is initiated from the FSD.

Return Value:

NTSTATUS

--*/

{
    NTSTATUS Status;

    PAGED_CODE();

    dlog(DPRT_FSCTL, ("NtDeviceIoControlFile: Initialize request\n"));

    if (!ExAcquireResourceExclusiveLite(&BowserDataResource, Wait)) {
        return STATUS_PENDING;
    }

    try {

        if (BowserData.Initialized == TRUE) {
            dlog(DPRT_FSCTL, ("Bowser already started\n"));
            try_return(Status = STATUS_REDIRECTOR_STARTED);
        }

        //
        // Load a pointer to the users input buffer into InputBuffer
        //

        if (InputBufferLength != sizeof(LMDR_REQUEST_PACKET)) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }

        if (InputBuffer->Version != LMDR_REQUEST_PACKET_VERSION_DOM) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }

        BowserFspProcess = RxGetRDBSSProcess();

        BowserData.IllegalDatagramThreshold = InputBuffer->Parameters.Start.IllegalDatagramThreshold;
        BowserData.EventLogResetFrequency = InputBuffer->Parameters.Start.EventLogResetFrequency;

        BowserData.NumberOfMailslotBuffers = InputBuffer->Parameters.Start.NumberOfMailslotBuffers;
        BowserData.NumberOfServerAnnounceBuffers = InputBuffer->Parameters.Start.NumberOfServerAnnounceBuffers;

        BowserLogElectionPackets = InputBuffer->Parameters.Start.LogElectionPackets;
        BowserData.IsLanmanNt = InputBuffer->Parameters.Start.IsLanManNt;

#ifdef ENABLE_PSEUDO_BROWSER
        BowserData.PseudoServerLevel = BROWSER_NON_PSEUDO;
#endif

        Status = BowserpInitializeAnnounceTable();

        if (!NT_SUCCESS(Status)) {
            try_return(Status);
        }

        BowserData.Initialized = TRUE;

        //
        //  Now that we know the browser parameters, we can kick off the
        //  browser timer...
        //

        IoStartTimer((PDEVICE_OBJECT )DeviceObject);


        KeQuerySystemTime(&BowserStartTime);

        RtlZeroMemory(&BowserStatistics, sizeof(BOWSER_STATISTICS));

        KeQuerySystemTime(&BowserStatistics.StartTime);

        KeInitializeSpinLock(&BowserStatisticsLock);

        try_return(Status = STATUS_SUCCESS);
try_exit:NOTHING;

    } finally {
        ExReleaseResourceLite(&BowserDataResource);
    }

    return Status;
    UNREFERENCED_PARAMETER(Wait);
    UNREFERENCED_PARAMETER(InFsd);
}



NTSTATUS
StopBowser (
    IN BOOLEAN Wait,
    IN BOOLEAN InFsd,
    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    )

/*++

Routine Description:

    This routine sets the username for the NT redirector.

Arguments:

    IN BOOLEAN Wait, - True IFF redirector can block callers thread on request
    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject, - Device object of destination of Irp
    IN PIRP Irp, - Io Request Packet for request
    IN PIO_STACK_LOCATION IrpSp - Current I/O Stack location for request

Return Value:

NTSTATUS

--*/

{
    NTSTATUS Status;

    PAGED_CODE();

    dlog(DPRT_FSCTL, ("NtDeviceIoControlFile: Initialize request\n"));

    if (!ExAcquireResourceExclusiveLite(&BowserDataResource, Wait)) {
        return STATUS_PENDING;
    }


    try {

        if (BowserData.Initialized != TRUE) {
            try_return(Status = STATUS_REDIRECTOR_NOT_STARTED);
        }

        //
        // Load a pointer to the users input buffer into InputBuffer
        //

        if (InputBufferLength != sizeof(LMDR_REQUEST_PACKET)) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }

        if (InputBuffer->Version != LMDR_REQUEST_PACKET_VERSION_DOM) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }

        if (InFsd) {
            try_return(Status = STATUS_PENDING);
        }

        //
        // Prevent any new callers.
        //
        BowserData.Initialized = FALSE;

        //
        // Loop until our caller has the last outstanding reference.
        //

        while ( InterlockedDecrement( &BowserOperationCount ) != 0 ) {
            LARGE_INTEGER Interval;
            InterlockedIncrement( &BowserOperationCount );

            // Don't hold the resource while we're waiting.
            ExReleaseResourceLite(&BowserDataResource);

            // Sleep to relinquish the CPU
            Interval.QuadPart = -1000*10000; // .1 second
            KeDelayExecutionThread( KernelMode, FALSE, &Interval );

            ExAcquireResourceExclusiveLite(&BowserDataResource, TRUE);
        }
        InterlockedIncrement( &BowserOperationCount );


        //
        // Finally stop the bowser now that we know we have exclusive access
        //

        Status = BowserUnbindFromAllTransports();

        if (!NT_SUCCESS(Status)) {
            dlog(DPRT_FSCTL, ("StopBowser: Failed to Unbind transports <0x%x>\n", Status));
            // Fall through to continue cleanup regardless.
        }

        Status = BowserpUninitializeAnnounceTable();

        if (!NT_SUCCESS(Status)) {
            dlog(DPRT_FSCTL, ("StopBowser: Failed to Uninitialize AnnounceTable <0x%x>\n", Status));
            // Fall through to continue cleanup regardless.
        }

        //
        //  Now that we know the browser parameters, we can kick off the
        //  browser timer...
        //

        IoStopTimer((PDEVICE_OBJECT )DeviceObject);

        try_return(Status = STATUS_SUCCESS);
try_exit:NOTHING;

    } finally {

        ExReleaseResourceLite(&BowserDataResource);
    }

    return Status;

    UNREFERENCED_PARAMETER(Wait);
    UNREFERENCED_PARAMETER(InFsd);
}


NTSTATUS
BowserBindToTransport (
    IN BOOLEAN Wait,
    IN BOOLEAN InFsd,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    )

/*++

Routine Description:

    This routine adds a reference to a file object created with .

Arguments:

    IN BOOLEAN Wait, - True IFF redirector can block callers thread on request
    IN BOOLEAN InFsd, - True IFF this request is initiated from the FSD.

Return Value:

NTSTATUS

--*/

{
    NTSTATUS Status;
    UNICODE_STRING TransportName;
    UNICODE_STRING EmulatedComputerName;
    UNICODE_STRING EmulatedDomainName;
    BOOLEAN ProcessAttached = FALSE;
    KAPC_STATE ApcState;


    PAGED_CODE();

    if (IoGetCurrentProcess() != BowserFspProcess) {
        KeStackAttachProcess(BowserFspProcess, &ApcState );

        ProcessAttached = TRUE;
    }

    try {
        //
        // Check some fields in the input buffer.
        //

        if (InputBufferLength < (ULONG)FIELD_OFFSET(LMDR_REQUEST_PACKET,Parameters.Bind.TransportName)) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }

        if (InputBuffer->Version != LMDR_REQUEST_PACKET_VERSION_DOM) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }


        //
        // Get the transport name from the input buffer.
        //

        TransportName.MaximumLength = TransportName.Length = (USHORT )
                                                InputBuffer->Parameters.Bind.TransportNameLength;
        TransportName.Buffer = InputBuffer->Parameters.Bind.TransportName;
        ENSURE_IN_INPUT_BUFFER( &TransportName, FALSE, FALSE );

        //
        // Ignore the new NetbiosSmb transport
        //

        {
            UNICODE_STRING NetbiosSmb;
            RtlInitUnicodeString( &NetbiosSmb, L"\\Device\\NetbiosSmb" );
            if ( RtlEqualUnicodeString(&TransportName, &NetbiosSmb, TRUE )) {
                try_return(Status = STATUS_SUCCESS);
            }
        }

        //
        // Get & verify emulated domain name
        //

        EmulatedDomainName = InputBuffer->EmulatedDomainName;
        ENSURE_IN_INPUT_BUFFER( &EmulatedDomainName, FALSE, FALSE );


        //
        // Get the emulated computer name from the input buffer.
        //  (Callers that don't want us to do the add names don't pass the computername)
        //

        if ( InputBuffer->Level ) {
            ENSURE_IN_INPUT_BUFFER_STR( (LPWSTR)((PCHAR)TransportName.Buffer+TransportName.Length) );
            RtlInitUnicodeString( &EmulatedComputerName,
                                  (LPWSTR)((PCHAR)TransportName.Buffer+TransportName.Length) );
        } else {
            RtlInitUnicodeString( &EmulatedComputerName, NULL );
        }

        //
        // Fail if either EmulatedDomainName or EmulatedComputerName is missing.
        //

        if ( EmulatedDomainName.Length == 0 || EmulatedComputerName.Length == 0 ) {
            try_return(Status = STATUS_INVALID_COMPUTER_NAME);
        }


        dlog(DPRT_FSCTL,
             ("%wZ: %wZ: %wZ: NtDeviceIoControlFile: Bind to transport\n",
             &EmulatedDomainName,
             &EmulatedComputerName,
             &TransportName ));

        Status = BowserTdiAllocateTransport( &TransportName,
                                             &EmulatedDomainName,
                                             &EmulatedComputerName );



        try_return(Status);

try_exit:NOTHING;
    } finally {

        if (ProcessAttached) {
            KeUnstackDetachProcess( &ApcState );
        }
    }
    return Status;

    UNREFERENCED_PARAMETER(Wait);
    UNREFERENCED_PARAMETER(InputBufferLength);
}


NTSTATUS
UnbindFromTransport (
    IN BOOLEAN Wait,
    IN BOOLEAN InFsd,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    )

/*++

Routine Description:

    This routine adds a reference to a file object created with .

Arguments:

    IN BOOLEAN Wait, - True IFF redirector can block callers thread on request
    IN BOOLEAN InFsd, - True IFF this request is initiated from the FSD.

Return Value:

NTSTATUS

--*/

{
    NTSTATUS Status;
    UNICODE_STRING TransportName;
    BOOLEAN ProcessAttached = FALSE;
    KAPC_STATE ApcState;


    PAGED_CODE();

    if (IoGetCurrentProcess() != BowserFspProcess) {
        KeStackAttachProcess(BowserFspProcess, &ApcState );

        ProcessAttached = TRUE;
    }

    dlog(DPRT_FSCTL, ("NtDeviceIoControlFile: Unbind from transport\n"));

    try {

        //
        // Check some fields in the input buffer.
        //

        if (InputBufferLength < (ULONG)FIELD_OFFSET(LMDR_REQUEST_PACKET,Parameters.Unbind.TransportName)) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }

        if (InputBuffer->Version != LMDR_REQUEST_PACKET_VERSION_DOM) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }


        //
        // Capture transport name.
        //
        TransportName.MaximumLength = TransportName.Length = (USHORT )
                                                InputBuffer->Parameters.Unbind.TransportNameLength;
        TransportName.Buffer = InputBuffer->Parameters.Unbind.TransportName;
        ENSURE_IN_INPUT_BUFFER( &TransportName, FALSE, FALSE );
        dlog(DPRT_FSCTL, ("\"%wZ\"", &TransportName));
        ENSURE_IN_INPUT_BUFFER( &InputBuffer->EmulatedDomainName, TRUE, FALSE );

        Status = BowserFreeTransportByName(&TransportName, &InputBuffer->EmulatedDomainName );

        try_return(Status);

try_exit:NOTHING;
    } finally {

        if (ProcessAttached) {
            KeUnstackDetachProcess( &ApcState );
        }
    }

    return Status;

    UNREFERENCED_PARAMETER(Wait);
    UNREFERENCED_PARAMETER(InputBufferLength);
}

NTSTATUS
BowserEnumTransports (
    IN BOOLEAN Wait,
    IN BOOLEAN InFsd,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN PULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    IN OUT ULONG OutputBufferLength,
    IN ULONG_PTR OutputBufferDisplacement
    )

/*++

Routine Description:

    This routine enumerates the transports bound into the bowser.

Arguments:

    IN BOOLEAN Wait, - True IFF redirector can block callers thread on request
    IN BOOLEAN InFsd, - True IFF this request is initiated from the FSD.
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    IN OUT PULONG OutputBufferLength

Return Value:

    NTSTATUS - Status of operation.

--*/

{
    NTSTATUS Status;

    PAGED_CODE();

    dlog(DPRT_FSCTL, ("NtDeviceIoControlFile: EnumerateTransports\n"));


    //
    // Check some fields in the input buffer.
    //

    if (*InputBufferLength < sizeof(LMDR_REQUEST_PACKET)) {
        Status = STATUS_INVALID_PARAMETER;
        goto ReturnStatus;
    }

    if (InputBuffer->Version != LMDR_REQUEST_PACKET_VERSION_DOM) {
        Status = STATUS_INVALID_PARAMETER;
        goto ReturnStatus;
    }

    if (InputBuffer->Type != EnumerateXports) {
        Status = STATUS_INVALID_PARAMETER;
        goto ReturnStatus;
    }

    if (OutputBufferLength < sizeof(LMDR_TRANSPORT_LIST)) {
        Status = STATUS_BUFFER_TOO_SMALL;
        goto ReturnStatus;
    }

    Status = BowserEnumerateTransports(OutputBuffer,
                    OutputBufferLength,
                    &InputBuffer->Parameters.EnumerateTransports.EntriesRead,
                    &InputBuffer->Parameters.EnumerateTransports.TotalEntries,
                    &InputBuffer->Parameters.EnumerateTransports.TotalBytesNeeded,
                    OutputBufferDisplacement);

    *InputBufferLength = sizeof(LMDR_REQUEST_PACKET);

ReturnStatus:
    return Status;

    UNREFERENCED_PARAMETER(Wait);
    UNREFERENCED_PARAMETER(InFsd);
}

NTSTATUS
EnumNames (
    IN BOOLEAN Wait,
    IN BOOLEAN InFsd,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN PULONG RetInputBufferLength,
    OUT PVOID OutputBuffer,
    IN OUT ULONG OutputBufferLength,
    IN ULONG_PTR OutputBufferDisplacement
    )

/*++

Routine Description:

    This routine enumerates the names bound into the bowser.

Arguments:

    IN BOOLEAN Wait, - True IFF redirector can block callers thread on request
    IN BOOLEAN InFsd, - True IFF this request is initiated from the FSD.
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    IN OUT PULONG OutputBufferLength

Return Value:

    NTSTATUS - Status of operation.

--*/

{
    NTSTATUS Status;
    PDOMAIN_INFO DomainInfo = NULL;
    PTRANSPORT Transport = NULL;
    ULONG InputBufferLength = *RetInputBufferLength;

    PAGED_CODE();

    dlog(DPRT_FSCTL, ("NtDeviceIoControlFile: EnumerateNames\n"));

    try {

        //
        // Check some fields in the input buffer.
        //

        if (InputBufferLength < sizeof(LMDR_REQUEST_PACKET)) {
            try_return (Status = STATUS_INVALID_PARAMETER);
        }

        if (InputBuffer->Version != LMDR_REQUEST_PACKET_VERSION_DOM) {
            try_return (Status = STATUS_INVALID_PARAMETER);
        }

        if (InputBuffer->Type != EnumerateNames) {
            try_return (Status = STATUS_INVALID_PARAMETER);
        }

        if (OutputBufferLength < sizeof(DGRECEIVE_NAMES)) {
            try_return (Status = STATUS_BUFFER_TOO_SMALL);
        }

        //
        // Find the emulated domain the names are to be enumerated for
        //

        ENSURE_IN_INPUT_BUFFER( &InputBuffer->EmulatedDomainName, TRUE, FALSE );
        DomainInfo = BowserFindDomain( &InputBuffer->EmulatedDomainName );

        if ( DomainInfo == NULL ) {
            try_return (Status = STATUS_OBJECT_NAME_NOT_FOUND);
        }


        //
        // If we want to limit our search to a particular transport,
        //  lookup that transport.
        //

        if ( InputBuffer->TransportName.Length != 0 ) {

            ENSURE_IN_INPUT_BUFFER( &InputBuffer->TransportName, FALSE, FALSE );
            Transport = BowserFindTransport ( &InputBuffer->TransportName,
                                              &InputBuffer->EmulatedDomainName );
            dprintf(DPRT_REF, ("Called Find transport %lx from EnumNames.\n", Transport));

            if ( Transport == NULL ) {
                try_return (Status = STATUS_OBJECT_NAME_NOT_FOUND);
            }
        }

        Status = BowserEnumerateNamesInDomain(
                        DomainInfo,
                        Transport,
                        OutputBuffer,
                        OutputBufferLength,
                        &InputBuffer->Parameters.EnumerateTransports.EntriesRead,
                        &InputBuffer->Parameters.EnumerateTransports.TotalEntries,
                        &InputBuffer->Parameters.EnumerateTransports.TotalBytesNeeded,
                        OutputBufferDisplacement);

        *RetInputBufferLength = sizeof(LMDR_REQUEST_PACKET);

try_exit:NOTHING;
    } finally {
        if ( DomainInfo != NULL ) {
            BowserDereferenceDomain( DomainInfo );
        }

        if ( Transport != NULL ) {
            BowserDereferenceTransport( Transport );
        }
    }
    return Status;

    UNREFERENCED_PARAMETER(Wait);
    UNREFERENCED_PARAMETER(InFsd);
}


NTSTATUS
DeleteName (
    IN BOOLEAN Wait,
    IN BOOLEAN InFsd,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    )

/*++

Routine Description:

    This routine adds a reference to a file object created with .

Arguments:

    IN BOOLEAN Wait, - True IFF redirector can block callers thread on request
    IN BOOLEAN InFsd, - True IFF this request is initiated from the FSD.

Return Value:

NTSTATUS

--*/

{
    NTSTATUS Status;
    UNICODE_STRING Name;
    PDOMAIN_INFO DomainInfo = NULL;
    BOOLEAN ProcessAttached = FALSE;
    KAPC_STATE ApcState;


    PAGED_CODE();

    if (IoGetCurrentProcess() != BowserFspProcess) {
        KeStackAttachProcess(BowserFspProcess, &ApcState );

        ProcessAttached = TRUE;
    }

    dlog(DPRT_FSCTL, ("NtDeviceIoControlFile: Delete Name\n"));

    try {

        //
        // Check some fields in the input buffer.
        //

        if (InputBufferLength < (ULONG)FIELD_OFFSET(LMDR_REQUEST_PACKET,Parameters.AddDelName.Name)) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }

        if (InputBuffer->Version != LMDR_REQUEST_PACKET_VERSION_DOM) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }


        // NULL name means to delete all names of that name type.
        Name.MaximumLength = Name.Length = (USHORT )
                      InputBuffer->Parameters.AddDelName.DgReceiverNameLength;
        Name.Buffer = InputBuffer->Parameters.AddDelName.Name;
        ENSURE_IN_INPUT_BUFFER( &Name, TRUE, FALSE );

        //
        // Find the emulated domain the name is to be deleted for
        //

        ENSURE_IN_INPUT_BUFFER( &InputBuffer->EmulatedDomainName, TRUE, FALSE );
        DomainInfo = BowserFindDomain( &InputBuffer->EmulatedDomainName );

        if ( DomainInfo == NULL ) {
            try_return(Status = STATUS_OBJECT_NAME_NOT_FOUND);
        }

        dlog(DPRT_FSCTL, ("Deleting \"%wZ\"", &Name));

        Status = BowserDeleteNameByName(DomainInfo, &Name, InputBuffer->Parameters.AddDelName.Type);

        try_return(Status);

try_exit:NOTHING;
    } finally {

        if ( DomainInfo != NULL ) {
            BowserDereferenceDomain( DomainInfo );
        }

        if (ProcessAttached) {
            KeUnstackDetachProcess( &ApcState );
        }
    }

    return Status;

    UNREFERENCED_PARAMETER(Wait);
    UNREFERENCED_PARAMETER(InputBufferLength);
}


NTSTATUS
EnumServers (
    IN BOOLEAN Wait,
    IN BOOLEAN InFsd,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN PULONG RetInputBufferLength,
    OUT PVOID OutputBuffer,
    IN OUT ULONG OutputBufferLength,
    IN ULONG_PTR OutputBufferDisplacement
    )

/*++

Routine Description:

    This routine adds a reference to a file object created with .

Arguments:

    IN BOOLEAN Wait, - True IFF redirector can block callers thread on request
    IN BOOLEAN InFsd, - True IFF this request is initiated from the FSD.
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    IN OUT PULONG OutputBufferLength

Return Value:

    NTSTATUS - Status of operation.

--*/

{
    NTSTATUS Status;
    UNICODE_STRING DomainName;
    ULONG InputBufferLength = *RetInputBufferLength;

    PAGED_CODE();

    dlog(DPRT_FSCTL, ("NtDeviceIoControlFile: EnumerateServers\n"));

    //
    // Check some fields in the input buffer.
    //

    try {

        if (InputBufferLength < sizeof(LMDR_REQUEST_PACKET)) {
            try_return (Status = STATUS_INVALID_PARAMETER);
        }

        if (InputBuffer->Version != LMDR_REQUEST_PACKET_VERSION_DOM) {
            try_return (Status = STATUS_INVALID_PARAMETER);
        }

        if (InputBuffer->Type != EnumerateServers) {
            try_return (Status = STATUS_INVALID_PARAMETER);
        }

        if (InputBuffer->Level != 100 && InputBuffer->Level != 101) {
            try_return (Status = STATUS_INVALID_LEVEL);
        }

        if (OutputBufferLength < sizeof(SERVER_INFO_100)) {
            try_return (Status = STATUS_BUFFER_TOO_SMALL);
        }

        if (InputBuffer->Level == 101 && OutputBufferLength < sizeof(SERVER_INFO_101)) {
            try_return (Status = STATUS_BUFFER_TOO_SMALL);
        }

        if (InputBuffer->Parameters.EnumerateServers.DomainNameLength != 0) {
            DomainName.Buffer = InputBuffer->Parameters.EnumerateServers.DomainName;
            DomainName.Length = DomainName.MaximumLength =
                (USHORT )InputBuffer->Parameters.EnumerateServers.DomainNameLength;
            ENSURE_IN_INPUT_BUFFER( &DomainName, FALSE, FALSE );

        }

        ENSURE_IN_INPUT_BUFFER( &InputBuffer->EmulatedDomainName, FALSE, FALSE );
        ENSURE_IN_INPUT_BUFFER( &InputBuffer->TransportName, TRUE, FALSE );
        Status = BowserEnumerateServers( InputBuffer->Level, &InputBuffer->LogonId,
                        &InputBuffer->Parameters.EnumerateServers.ResumeHandle,
                        InputBuffer->Parameters.EnumerateServers.ServerType,
                        (InputBuffer->TransportName.Length != 0 ? &InputBuffer->TransportName : NULL),
                        &InputBuffer->EmulatedDomainName,
                        (InputBuffer->Parameters.EnumerateServers.DomainNameLength != 0 ? &DomainName : NULL),
                        OutputBuffer,
                        OutputBufferLength,
                        &InputBuffer->Parameters.EnumerateServers.EntriesRead,
                        &InputBuffer->Parameters.EnumerateServers.TotalEntries,
                        &InputBuffer->Parameters.EnumerateServers.TotalBytesNeeded,
                        OutputBufferDisplacement);

        *RetInputBufferLength = sizeof(LMDR_REQUEST_PACKET);

try_exit:NOTHING;
    } finally {
    }
    return Status;

    UNREFERENCED_PARAMETER(Wait);
    UNREFERENCED_PARAMETER(InFsd);
}



NTSTATUS
AddBowserName (
    IN BOOLEAN Wait,
    IN BOOLEAN InFsd,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    )

/*++

Routine Description:

    This routine adds a reference to a file object created with .

Arguments:

    IN BOOLEAN Wait, - True IFF redirector can block callers thread on request
    IN BOOLEAN InFsd, - True IFF this request is initiated from the FSD.

Return Value:

NTSTATUS

--*/

{
    NTSTATUS Status;
    UNICODE_STRING Name;
    PTRANSPORT Transport = NULL;
    PDOMAIN_INFO DomainInfo = NULL;
    BOOLEAN ProcessAttached = FALSE;
    KAPC_STATE ApcState;


    PAGED_CODE();

    if (IoGetCurrentProcess() != BowserFspProcess) {
        KeStackAttachProcess(BowserFspProcess, &ApcState );

        ProcessAttached = TRUE;
    }

    dlog(DPRT_FSCTL, ("NtDeviceIoControlFile: Bind to transport\n"));

    try {
        //
        // Check some fields in the input buffer.
        //

        if (InputBufferLength < (ULONG)FIELD_OFFSET(LMDR_REQUEST_PACKET,Parameters.AddDelName.Name)) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }

        if (InputBuffer->Version != LMDR_REQUEST_PACKET_VERSION_DOM) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }


        Name.MaximumLength = Name.Length = (USHORT )
                           InputBuffer->Parameters.AddDelName.DgReceiverNameLength;
        Name.Buffer = InputBuffer->Parameters.AddDelName.Name;
        ENSURE_IN_INPUT_BUFFER( &Name, FALSE, FALSE );

        dlog(DPRT_FSCTL, ("\"%wZ\"", &Name));

        //
        // If the transport was specified,
        //  just add the name on that transport.
        //
        ENSURE_IN_INPUT_BUFFER( &InputBuffer->EmulatedDomainName, TRUE, FALSE );
        if (InputBuffer->TransportName.Length != 0) {
            ENSURE_IN_INPUT_BUFFER( &InputBuffer->TransportName, FALSE, FALSE );
            Transport = BowserFindTransport(&InputBuffer->TransportName, &InputBuffer->EmulatedDomainName );
            dprintf(DPRT_REF, ("Called Find transport %lx from AddBowserName.\n", Transport));

            if (Transport == NULL) {
                try_return(Status = STATUS_OBJECT_NAME_NOT_FOUND);
            }

        //
        // If the transport wasn't specified,
        //  just add the name on the specified domain.
        //
        // It doesn't make sense to add the name on ALL transports. Either the domain name
        // or the transport name must be specified.
        //

        } else {
            DomainInfo = BowserFindDomain( &InputBuffer->EmulatedDomainName );

            if ( DomainInfo == NULL ) {
                try_return(Status = STATUS_OBJECT_NAME_NOT_FOUND);
            }


        }

        Status = BowserAllocateName(&Name,
                                    InputBuffer->Parameters.AddDelName.Type,
                                    Transport,
                                    DomainInfo );

        try_return(Status);

try_exit:NOTHING;
    } finally {
        if (Transport != NULL) {
            BowserDereferenceTransport(Transport);
        }
        if ( DomainInfo != NULL ) {
            BowserDereferenceDomain( DomainInfo );
        }

        if (ProcessAttached) {
            KeUnstackDetachProcess( &ApcState );
        }
    }

    return Status;

    UNREFERENCED_PARAMETER(Wait);
    UNREFERENCED_PARAMETER(InputBufferLength);

}

NTSTATUS
GetBrowserServerList(
    IN PIRP Irp,
    IN BOOLEAN Wait,
    IN BOOLEAN InFsd,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN OUT PULONG RetInputBufferLength,
    IN PVOID OutputBuffer,
    IN ULONG OutputBufferLength,
    IN ULONG_PTR OutputBufferDisplacement
    )

/*++

Routine Description:

    This routine will return the list of browser servers for the specified
    net on the specified domain.

Arguments:

    IN BOOLEAN Wait, - True IFF redirector can block callers thread on request
    IN BOOLEAN InFsd, - True IFF this request is initiated from the FSD.
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    IN OUT PULONG OutputBufferLength

Return Value:

    NTSTATUS - Status of operation.

--*/
{

    NTSTATUS Status;
    UNICODE_STRING DomainName;
    PTRANSPORT Transport = NULL;
    ULONG BrowserServerListLength;
    PWSTR *BrowserServerList;
    BOOLEAN IsPrimaryDomain = FALSE;
    BOOLEAN TransportBrowserListAcquired = FALSE;
    PVOID OutputBufferEnd = (PCHAR)OutputBuffer + OutputBufferLength;
    PPAGED_TRANSPORT PagedTransport;
    ULONG InputBufferLength = *RetInputBufferLength;
    BOOLEAN fThunk32bit;

    PAGED_CODE();

    dlog(DPRT_FSCTL, ("NtDeviceIoControlFile: GetBrowserServerList\n"));

    try {

        //
        // Check some fields in the input buffer.
        //


        if (InputBufferLength < sizeof(LMDR_REQUEST_PACKET)) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }

        if (InputBuffer->Version != LMDR_REQUEST_PACKET_VERSION_DOM) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }

        if (InputBuffer->TransportName.Length == 0 ||
            InputBuffer->TransportName.Buffer == NULL) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }


#ifdef _WIN64
        fThunk32bit = IoIs32bitProcess(Irp);
#else
        // If we're in 32 bit (e.g. call above isn't available), use unchanged functionality
        // i.e. pure new-64-bit == pure old-32-bit == homogeneous environment. Thus, set to FALSE.
        fThunk32bit = FALSE;
#endif


        if (InputBuffer->Parameters.GetBrowserServerList.DomainNameLength != 0) {
            DomainName.Buffer = InputBuffer->Parameters.GetBrowserServerList.DomainName;
            DomainName.Length = DomainName.MaximumLength =
                (USHORT)InputBuffer->Parameters.GetBrowserServerList.DomainNameLength;
            ENSURE_IN_INPUT_BUFFER( &DomainName, FALSE, fThunk32bit );
        } else {
            DomainName.Length = 0;
            DomainName.Buffer = NULL;
        }

        //
        // See if the specified domain is an emulated domain.
        //

        ENSURE_IN_INPUT_BUFFER( &InputBuffer->TransportName, FALSE, fThunk32bit );
        Transport = BowserFindTransport(&InputBuffer->TransportName, &DomainName );
        dprintf(DPRT_REF, ("Called Find transport %lx from GetBrowserServerList.\n", Transport));

        if (Transport == NULL) {

            //
            // Otherwise simply use the primary domain transport
            //

            Transport = BowserFindTransport(&InputBuffer->TransportName, NULL );
            dprintf(DPRT_REF, ("Called Find transport %lx from GetBrowserServerList (2).\n", Transport));

            if ( Transport == NULL ) {
                try_return(Status = STATUS_OBJECT_NAME_NOT_FOUND);
            }
        }

        PagedTransport = Transport->PagedTransport;

        if (!ExAcquireResourceSharedLite(&Transport->BrowserServerListResource, Wait)) {
            try_return(Status = STATUS_PENDING);
        }

        TransportBrowserListAcquired = TRUE;

        //
        //  If this request is for the primary domain and there are no entries
        //  in the cached list, or if it is not for the primary domain, or
        //  if we are supposed to force a rescan of the list, get the list
        //  from the master for that domain..
        //

        if ((DomainName.Length == 0) ||
             RtlEqualUnicodeString(&DomainName, &Transport->DomainInfo->DomUnicodeDomainName, TRUE)) {
            IsPrimaryDomain = TRUE;

            BrowserServerList = PagedTransport->BrowserServerListBuffer;

            BrowserServerListLength = PagedTransport->BrowserServerListLength;
        }


        if ((IsPrimaryDomain &&
             (BrowserServerListLength == 0))

                ||

            !IsPrimaryDomain

                ||

            (InputBuffer->Parameters.GetBrowserServerList.ForceRescan)) {

            //
            //  We need to re-gather the transport list.
            //  Re-acquire the BrowserServerList resource for exclusive access.
            //

            ExReleaseResourceLite(&Transport->BrowserServerListResource);

            TransportBrowserListAcquired = FALSE;

            if (!ExAcquireResourceExclusiveLite(&Transport->BrowserServerListResource, Wait)) {
                try_return(Status = STATUS_PENDING);
            }

            TransportBrowserListAcquired = TRUE;

            //
            //  If we are being asked to rescan the list, free it up.
            //

            if (InputBuffer->Parameters.GetBrowserServerList.ForceRescan &&
                PagedTransport->BrowserServerListBuffer != NULL) {

                BowserFreeBrowserServerList(PagedTransport->BrowserServerListBuffer,
                                        PagedTransport->BrowserServerListLength);

                PagedTransport->BrowserServerListLength = 0;

                PagedTransport->BrowserServerListBuffer = NULL;

            }

            //
            //  If there are still no servers in the list, get the list.
            //

            Status = BowserGetBrowserServerList(Irp,
                                                 Transport,
                                                 (DomainName.Length == 0 ?
                                                        NULL :
                                                        &DomainName),
                                                 &BrowserServerList,
                                                 &BrowserServerListLength);
            if (!NT_SUCCESS(Status)) {
                try_return(Status);
            }

            if (IsPrimaryDomain) {

                //
                // Save away the list of servers retreived in the transport.
                //
                if (PagedTransport->BrowserServerListBuffer != NULL) {
                    BowserFreeBrowserServerList(
                       PagedTransport->BrowserServerListBuffer,
                       PagedTransport->BrowserServerListLength);
                }

                PagedTransport->BrowserServerListBuffer = BrowserServerList;
                PagedTransport->BrowserServerListLength = BrowserServerListLength;
            }

        }

        //
        //  If there any servers in the browser server list, we want to
        //  pick the first 3 of them and return them to the caller.
        //


        if (BrowserServerListLength != 0) {
            ULONG    i;
            PWSTR   *ServerList      = OutputBuffer;
            BOOLEAN  BufferRemaining = TRUE;

            InputBuffer->Parameters.GetBrowserServerList.TotalEntries = 0;

            InputBuffer->Parameters.GetBrowserServerList.EntriesRead = 0;

            InputBuffer->Parameters.GetBrowserServerList.TotalBytesNeeded = 0;

            //
            //  Now pick the first 3 entries from the list to return.
            //

            for ( i = 0 ; i < min(3, BrowserServerListLength) ; i ++ ) {
                PWSTR Temp;

                InputBuffer->Parameters.GetBrowserServerList.TotalEntries += 1;

                InputBuffer->Parameters.GetBrowserServerList.TotalBytesNeeded += wcslen(BrowserServerList[i])*sizeof(WCHAR);

                Temp = BrowserServerList[i];

                dlog(DPRT_CLIENT, ("Packing server name %ws into buffer...", Temp));

                //
                //  Pack the entry into the users buffer.
                //

                if (BufferRemaining &&
                    BowserPackUnicodeString(&Temp,
                            wcslen(Temp)*sizeof(WCHAR),
                            OutputBufferDisplacement,
                            &ServerList[i+1],
                            &OutputBufferEnd) != 0) {
                    ServerList[i] = Temp;
                    InputBuffer->Parameters.GetBrowserServerList.EntriesRead += 1;
                } else {
                    BufferRemaining = FALSE;
                }


            }
        }

        //
        //  Set the number of bytes to copy on return.
        //

        *RetInputBufferLength = sizeof(LMDR_REQUEST_PACKET);

        try_return(Status = STATUS_SUCCESS);

try_exit:NOTHING;
    } finally {
        if (Transport != NULL) {

            if (TransportBrowserListAcquired) {
                ExReleaseResourceLite(&Transport->BrowserServerListResource);
            }

            BowserDereferenceTransport(Transport);
        }

        if (NT_SUCCESS(Status) && !IsPrimaryDomain) {
            BowserFreeBrowserServerList(BrowserServerList,
                                BrowserServerListLength);

        }

    }

    return(Status);

    UNREFERENCED_PARAMETER(Irp);

    UNREFERENCED_PARAMETER(InFsd);

}

NTSTATUS
HandleBecomeBackup (
    IN PIRP Irp,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    )

/*++

Routine Description:

    This routine will queue a request that will complete when a request
    to make the workstation become a backup browser is received.

Arguments:

    IN PIRP Irp - I/O request packet describing request.

Return Value:

    Status of operation.

Please note that this IRP is cancelable.


--*/

{
    NTSTATUS Status;
    PTRANSPORT Transport = NULL;

    PAGED_CODE();

    dlog(DPRT_FSCTL, ("NtDeviceIoControlFile: %wZ: Get Announce Request\n", &InputBuffer->TransportName ));

    try {
        WCHAR TransportNameBuffer[MAX_PATH+1];
        WCHAR DomainNameBuffer[DNLEN+1];

        if (InputBufferLength < sizeof(LMDR_REQUEST_PACKET)) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }

        CAPTURE_UNICODE_STRING( &InputBuffer->TransportName, TransportNameBuffer );
        CAPTURE_UNICODE_STRING( &InputBuffer->EmulatedDomainName, DomainNameBuffer );
        Transport = BowserFindTransport(&InputBuffer->TransportName, &InputBuffer->EmulatedDomainName );
        dprintf(DPRT_REF, ("Called Find transport %lx from HandleBecomeBackup.\n", Transport));

        if (Transport == NULL) {
            try_return (Status = STATUS_OBJECT_NAME_NOT_FOUND);
        }

        Status = BowserQueueNonBufferRequest(Irp,
                                             &Transport->BecomeBackupQueue,
                                             BowserCancelQueuedRequest
                                             );

try_exit:NOTHING;
    } finally {
        if ( Transport != NULL ) {
            BowserDereferenceTransport(Transport);
        }
    }

    return Status;

}

NTSTATUS
BecomeMaster (
    IN PIRP Irp,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    )

/*++

Routine Description:

    This routine will queue a request that will complete when the workstation
    becomes a master browser server.

Arguments:

    IN PIRP Irp - I/O request packet describing request.

Return Value:

    Status of operation.

Please note that this IRP is cancelable.


--*/

{
    NTSTATUS Status;
    PTRANSPORT Transport = NULL;

    PAGED_CODE();

    dlog(DPRT_FSCTL, ("NtDeviceIoControlFile: BecomeMaster\n"));

    try {
        WCHAR TransportNameBuffer[MAX_PATH+1];
        WCHAR DomainNameBuffer[DNLEN+1];

        if (InputBufferLength < sizeof(LMDR_REQUEST_PACKET)) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }

        CAPTURE_UNICODE_STRING( &InputBuffer->TransportName, TransportNameBuffer );
        CAPTURE_UNICODE_STRING( &InputBuffer->EmulatedDomainName, DomainNameBuffer );
        Transport = BowserFindTransport(&InputBuffer->TransportName, &InputBuffer->EmulatedDomainName );
        dprintf(DPRT_REF, ("Called Find transport %lx from BecomeMaster.\n", Transport));

        if (Transport == NULL) {
            try_return (Status = STATUS_OBJECT_NAME_NOT_FOUND);
        }

        LOCK_TRANSPORT (Transport);

        if (Transport->ElectionState == DeafToElections) {
            Transport->ElectionState = Idle;
        }

        UNLOCK_TRANSPORT (Transport);

        Status = BowserQueueNonBufferRequest(Irp,
                                             &Transport->BecomeMasterQueue,
                                             BowserCancelQueuedRequest
                                             );

try_exit:NOTHING;
    } finally {
        if ( Transport != NULL ) {
            BowserDereferenceTransport(Transport);
        }
    }

    return Status;

}

NTSTATUS
WaitForMasterAnnounce (
    IN PIRP Irp,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    )

/*++

Routine Description:

    This routine will queue a request that will complete when the workstation
    becomes a master browser server.

Arguments:

    IN PIRP Irp - I/O request packet describing request.

Return Value:

    Status of operation.

Please note that this IRP is cancelable.


--*/

{
    NTSTATUS           Status;
    PTRANSPORT         Transport = NULL;
    PIO_STACK_LOCATION IrpSp     = IoGetCurrentIrpStackLocation(Irp);

    PAGED_CODE();

    dlog(DPRT_FSCTL, ("NtDeviceIoControlFile: WaitForMasterAnnounce\n"));

    try {
        WCHAR TransportNameBuffer[MAX_PATH+1];
        WCHAR DomainNameBuffer[DNLEN+1];

        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
            (ULONG)FIELD_OFFSET(LMDR_REQUEST_PACKET, Parameters.WaitForMasterAnnouncement.Name)) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }

        if (InputBufferLength < sizeof(LMDR_REQUEST_PACKET)) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }

        if ( (InputBuffer->TransportName.Length & 1) != 0 ) {
            // invalid unicode string. bug 55448.
            try_return(Status = STATUS_INVALID_PARAMETER);
        }

        CAPTURE_UNICODE_STRING( &InputBuffer->TransportName, TransportNameBuffer );
        CAPTURE_UNICODE_STRING( &InputBuffer->EmulatedDomainName, DomainNameBuffer );
        Transport = BowserFindTransport(&InputBuffer->TransportName, &InputBuffer->EmulatedDomainName );
        dprintf(DPRT_REF, ("Called Find transport %lx from WaitForMasterAnnounce.\n", Transport));

        if (Transport == NULL) {
            try_return (Status = STATUS_OBJECT_NAME_NOT_FOUND);
        }

        Status = BowserQueueNonBufferRequest(Irp,
                                             &Transport->WaitForMasterAnnounceQueue,
                                             BowserCancelQueuedRequest
                                             );

try_exit:NOTHING;
    } finally {
        if ( Transport != NULL ) {
            BowserDereferenceTransport(Transport);
        }
    }

    return Status;

}


NTSTATUS
UpdateStatus(
    IN PIRP Irp,
    IN BOOLEAN InFsd,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PTRANSPORT Transport = NULL;
    ULONG NewStatus;
    BOOLEAN TransportLocked = FALSE;
    PPAGED_TRANSPORT PagedTransport;
    BOOLEAN ProcessAttached = FALSE;
    KAPC_STATE ApcState;


    PAGED_CODE();

    dlog(DPRT_FSCTL, ("NtDeviceIoControlFile: Update status\n"));

    if (IoGetCurrentProcess() != BowserFspProcess) {
        KeStackAttachProcess(BowserFspProcess, &ApcState );

        ProcessAttached = TRUE;
    }

    try {

        if (InputBufferLength <
            (ULONG)FIELD_OFFSET(LMDR_REQUEST_PACKET,Parameters)+sizeof(InputBuffer->Parameters.UpdateStatus)) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }

        if (InputBuffer->Version != LMDR_REQUEST_PACKET_VERSION_DOM) {
            try_return (Status = STATUS_INVALID_PARAMETER);
        }

        ENSURE_IN_INPUT_BUFFER( &InputBuffer->TransportName, FALSE, FALSE );
        ENSURE_IN_INPUT_BUFFER( &InputBuffer->EmulatedDomainName, TRUE, FALSE );

        Transport = BowserFindTransport(&InputBuffer->TransportName, &InputBuffer->EmulatedDomainName );
        dprintf(DPRT_REF, ("Called Find transport %lx from UpdateStatus.\n", Transport));

        if (Transport == NULL) {
            try_return (Status = STATUS_OBJECT_NAME_NOT_FOUND);
        }

        PagedTransport = Transport->PagedTransport;

        NewStatus = InputBuffer->Parameters.UpdateStatus.NewStatus;

        BowserData.MaintainServerList = InputBuffer->Parameters.UpdateStatus.MaintainServerList;

        BowserData.IsLanmanNt = InputBuffer->Parameters.UpdateStatus.IsLanmanNt;


#ifdef ENABLE_PSEUDO_BROWSER
        BowserData.PseudoServerLevel = (DWORD)InputBuffer->Parameters.UpdateStatus.PseudoServerLevel;
#endif

        LOCK_TRANSPORT(Transport);

        TransportLocked = TRUE;


        //
        //  We are being called to update our state.  There are several
        //  actions that should be performed on the state change:
        //
        //  New Role |               Previous Role
        //           |  Potential Browser | Backup Browser | Master Browser
        // ----------+--------------------+----------------+----------------
        //           |                    |                |
        // Potential |    N/A             |      N/A       |     N/A
        //           |                    |                |
        // ----------+--------------------+----------------+----------------
        //           |                    |                |
        // Backup    |  Update role       |      N/A       |     N/A
        //           |                    |                |
        // ----------+--------------------+----------------+----------------
        //           |                    |                |
        // Master    |  Update role       |  Update role   |     N/A
        //           |                    |                |
        // ----------+--------------------+----------------+----------------
        //           |                    |                |
        // None      |  Remove elect      |  Remove elect  | Remove all names
        //           |                    |                |
        // ----------+--------------------+----------------+----------------
        //

        dlog(DPRT_BROWSER,
             ("%s: %ws: Update status to %lx\n",
             Transport->DomainInfo->DomOemDomainName,
             PagedTransport->TransportName.Buffer,
             NewStatus));

        PagedTransport->ServiceStatus = NewStatus;

        //
        // If the caller says we should have the 1E name registered,
        //  and we don't.
        //  Do so now.
        //

        if ( PagedTransport->Role == None &&
            (NewStatus & SV_TYPE_POTENTIAL_BROWSER) != 0 ) {

            dlog(DPRT_BROWSER,
                 ("%s: %ws: New status indicates we are a potential browser, but we're not\n",
                 Transport->DomainInfo->DomOemDomainName,
                 PagedTransport->TransportName.Buffer ));

            PagedTransport->Role = PotentialBackup;

            UNLOCK_TRANSPORT(Transport);

            TransportLocked = FALSE;

            Status = BowserAllocateName(
                                &Transport->DomainInfo->DomUnicodeDomainName,
                                BrowserElection,
                                Transport,
                                Transport->DomainInfo );

            if (!NT_SUCCESS(Status)) {
                try_return(Status);
            }

            LOCK_TRANSPORT(Transport);

            TransportLocked = TRUE;
        }


        //
        //  If we are a master, then update appropriately.
        //

        if (PagedTransport->Role == Master) {

            PagedTransport->NumberOfServersInTable = InputBuffer->Parameters.UpdateStatus.NumberOfServersInTable;

            //
            //  If the new status doesn't indicate that we should be a master
            //  browser, flag it as such.
            //

            if (!(NewStatus & SV_TYPE_MASTER_BROWSER)) {
                dlog(DPRT_BROWSER,
                     ("%s: %ws: New status indicates we are not a master browser\n",
                      Transport->DomainInfo->DomOemDomainName,
                      PagedTransport->TransportName.Buffer ));

                //
                //  We must be a backup now, if we're not a master.
                //

                PagedTransport->Role = Backup;

                //
                //  Stop processing announcements on this transport.
                //

                Status = BowserForEachTransportName(Transport, BowserStopProcessingAnnouncements, NULL);

                UNLOCK_TRANSPORT(Transport);

                TransportLocked = FALSE;

                Status = BowserDeleteTransportNameByName(Transport, NULL, MasterBrowser);

                if (!NT_SUCCESS(Status)) {
                    dlog(DPRT_BROWSER,
                         ("%s: %ws: Unable to remove master name: %X\n",
                         Transport->DomainInfo->DomOemDomainName,
                         PagedTransport->TransportName.Buffer,
                         Status));
                }

                Status = BowserDeleteTransportNameByName(Transport, NULL,
                                DomainAnnouncement);

                if (!NT_SUCCESS(Status)) {

                    dlog(DPRT_BROWSER,
                         ("%s: %ws: Unable to delete domain announcement name: %X\n",
                         Transport->DomainInfo->DomOemDomainName,
                         PagedTransport->TransportName.Buffer,
                         Status));
                }


                if (!(NewStatus & SV_TYPE_BACKUP_BROWSER)) {

                    //
                    //  We've stopped being a master browser, and we're not
                    //  going to be a backup browser. We want to toss our
                    //  cached browser server list just in case we're on the
                    //  list.
                    //

                    ExAcquireResourceExclusiveLite(&Transport->BrowserServerListResource, TRUE);

                    if (PagedTransport->BrowserServerListBuffer != NULL) {
                        BowserFreeBrowserServerList(PagedTransport->BrowserServerListBuffer,
                                                    PagedTransport->BrowserServerListLength);

                        PagedTransport->BrowserServerListLength = 0;

                        PagedTransport->BrowserServerListBuffer = NULL;

                    }

                    ExReleaseResourceLite(&Transport->BrowserServerListResource);

                }

                LOCK_TRANSPORT(Transport);

                TransportLocked = TRUE;

            }
        } else if (NewStatus & SV_TYPE_MASTER_BROWSER) {
            dlog(DPRT_BROWSER | DPRT_MASTER,
                 ("%s: %ws: New status indicates we should be master, but we're not.\n",
                 Transport->DomainInfo->DomOemDomainName,
                 PagedTransport->TransportName.Buffer ));

            UNLOCK_TRANSPORT(Transport);

            TransportLocked = FALSE;

            Status = BowserBecomeMaster (Transport);

            LOCK_TRANSPORT(Transport);

            dlog(DPRT_BROWSER | DPRT_MASTER,
                 ("%s: %ws: Master promotion status: %lX.\n",
                 Transport->DomainInfo->DomOemDomainName,
                 PagedTransport->TransportName.Buffer,
                 Status));

            TransportLocked = TRUE;

            ASSERT ((PagedTransport->Role == Master) || !NT_SUCCESS(Status));

        }

        if (!NT_SUCCESS(Status) || PagedTransport->Role == Master) {
            try_return(Status);
        }


        //
        //  If we are a backup, then update appropriately.
        //

        if (PagedTransport->Role == Backup) {

            if (!(NewStatus & SV_TYPE_BACKUP_BROWSER)) {
                dlog(DPRT_BROWSER,
                     ("%s: %ws: New status indicates we are not a backup browser\n",
                     Transport->DomainInfo->DomOemDomainName,
                     PagedTransport->TransportName.Buffer ));

                PagedTransport->Role = PotentialBackup;

                //
                //  We've stopped being a browser. We want to toss our cached
                //  browser list in case we're on the list.
                //

                ExAcquireResourceExclusiveLite(&Transport->BrowserServerListResource, TRUE);

                if (PagedTransport->BrowserServerListBuffer != NULL) {
                    BowserFreeBrowserServerList(PagedTransport->BrowserServerListBuffer,
                                                PagedTransport->BrowserServerListLength);

                    PagedTransport->BrowserServerListLength = 0;

                    PagedTransport->BrowserServerListBuffer = NULL;
                }

                ExReleaseResourceLite(&Transport->BrowserServerListResource);

            }

        } else if (NewStatus & SV_TYPE_BACKUP_BROWSER) {

            dlog(DPRT_BROWSER,
                 ("%s: %ws: New status indicates we are a backup, but we think we are not\n",
                 Transport->DomainInfo->DomOemDomainName,
                 PagedTransport->TransportName.Buffer ));

            PagedTransport->Role = Backup;

            Status = STATUS_SUCCESS;

        }

        if (!NT_SUCCESS(Status) || PagedTransport->Role == Backup) {
            try_return(Status);
        }

        //
        //  If we are a potential backup, then update appropriately.
        //

        if (PagedTransport->Role == PotentialBackup) {

            if (!(NewStatus & SV_TYPE_POTENTIAL_BROWSER)) {
                dlog(DPRT_BROWSER,
                     ("%s: %ws: New status indicates we are not a potential browser\n",
                     Transport->DomainInfo->DomOemDomainName,
                     PagedTransport->TransportName.Buffer ));

                UNLOCK_TRANSPORT(Transport);

                TransportLocked = FALSE;

                Status = BowserDeleteTransportNameByName(Transport, NULL,
                                BrowserElection);

                if (!NT_SUCCESS(Status)) {
                    dlog(DPRT_BROWSER,
                         ("%s: %ws: Unable to remove election name: %X\n",
                         Transport->DomainInfo->DomOemDomainName,
                         PagedTransport->TransportName.Buffer,
                         Status));

                    try_return(Status);
                }

                LOCK_TRANSPORT(Transport);
                TransportLocked = TRUE;

                PagedTransport->Role = None;

            }

        }

        try_return(Status);

try_exit:NOTHING;
    } finally {
        if (TransportLocked) {
            UNLOCK_TRANSPORT(Transport);
        }

        if (Transport != NULL) {
            BowserDereferenceTransport(Transport);
        }

        if (ProcessAttached) {
            KeUnstackDetachProcess( &ApcState );
        }
    }

    return Status;
}

NTSTATUS
BowserStopProcessingAnnouncements(
    IN PTRANSPORT_NAME TransportName,
    IN PVOID Context
    )
{
    PAGED_CODE();

    ASSERT (TransportName->Signature == STRUCTURE_SIGNATURE_TRANSPORTNAME);

    ASSERT (TransportName->NameType == TransportName->PagedTransportName->Name->NameType);

    if ((TransportName->NameType == OtherDomain) ||
        (TransportName->NameType == MasterBrowser) ||
        (TransportName->NameType == PrimaryDomain) ||
        (TransportName->NameType == BrowserElection) ||
        (TransportName->NameType == DomainAnnouncement)) {

        if (TransportName->ProcessHostAnnouncements) {

            BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );

            TransportName->ProcessHostAnnouncements = FALSE;
        }
    }

    return(STATUS_SUCCESS);

    UNREFERENCED_PARAMETER(Context);
}

NTSTATUS
WaitForBrowserRoleChange (
    IN PIRP Irp,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    )

/*++

Routine Description:

    This routine will queue a request that will complete when a request
    to make the workstation become a backup browser is received.

Arguments:

    IN PIRP Irp - I/O request packet describing request.

Return Value:

    Status of operation.

Please note that this IRP is cancelable.


--*/

{
    NTSTATUS Status;
    PTRANSPORT Transport = NULL;

    PAGED_CODE();

    dlog(DPRT_FSCTL, ("NtDeviceIoControlFile: WaitForMasterRoleChange\n"));

    try {
        WCHAR TransportNameBuffer[MAX_PATH+1];
        WCHAR DomainNameBuffer[DNLEN+1];

        if (InputBufferLength < sizeof(LMDR_REQUEST_PACKET)) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }

        CAPTURE_UNICODE_STRING( &InputBuffer->TransportName, TransportNameBuffer );
        CAPTURE_UNICODE_STRING( &InputBuffer->EmulatedDomainName, DomainNameBuffer );
        Transport = BowserFindTransport(&InputBuffer->TransportName, &InputBuffer->EmulatedDomainName );
        dprintf(DPRT_REF, ("Called Find transport %lx from WaitForBrowserRoleChange.\n", Transport));

        if (Transport == NULL) {
            try_return (Status = STATUS_OBJECT_NAME_NOT_FOUND);
        }

        Status = BowserQueueNonBufferRequest(Irp,
                                             &Transport->ChangeRoleQueue,
                                             BowserCancelQueuedRequest
                                             );

try_exit:NOTHING;
    } finally {
        if (Transport != NULL) {
            BowserDereferenceTransport(Transport);
        }
    }

    return Status;

}


NTSTATUS
WriteMailslot (
    IN PIRP Irp,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength,
    IN PVOID OutputBuffer,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    This routine will announce the primary domain to the world

Arguments:

    IN PIRP Irp - I/O request packet describing request.

Return Value:

    Status of operation.

Please note that this IRP is cancelable.


--*/

{
    NTSTATUS Status;
    PTRANSPORT Transport = NULL;
    UNICODE_STRING DestinationName;

    PAGED_CODE();

    dlog(DPRT_FSCTL, ("NtDeviceIoControlFile: %wZ: Write Mailslot\n", &InputBuffer->TransportName ));

    try {

        ANSI_STRING MailslotName;

        if (InputBufferLength < (ULONG)FIELD_OFFSET(LMDR_REQUEST_PACKET,Parameters.SendDatagram.Name) ||
            OutputBufferLength < 1) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }

        if (InputBuffer->Version != LMDR_REQUEST_PACKET_VERSION_DOM) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }

        ENSURE_IN_INPUT_BUFFER( &InputBuffer->TransportName, FALSE, FALSE );
        ENSURE_IN_INPUT_BUFFER( &InputBuffer->EmulatedDomainName, TRUE, FALSE );

        Transport = BowserFindTransport(&InputBuffer->TransportName, &InputBuffer->EmulatedDomainName );
        dprintf(DPRT_REF, ("Called Find transport %lx from WriteMailslot.\n", Transport));

        if (Transport == NULL) {
            try_return(Status = STATUS_OBJECT_NAME_NOT_FOUND);
        }

        DestinationName.Length = DestinationName.MaximumLength =
            (USHORT)InputBuffer->Parameters.SendDatagram.NameLength;
        DestinationName.Buffer = InputBuffer->Parameters.SendDatagram.Name;
        if ( DestinationName.Length == 0  ) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }
        ENSURE_IN_INPUT_BUFFER( &DestinationName, TRUE, FALSE );

        if (InputBuffer->Parameters.SendDatagram.MailslotNameLength != 0) {

            MailslotName.Buffer = ((PCHAR)InputBuffer->Parameters.SendDatagram.Name)+
                            InputBuffer->Parameters.SendDatagram.NameLength;
            MailslotName.MaximumLength = (USHORT)
                InputBuffer->Parameters.SendDatagram.MailslotNameLength;
            MailslotName.Length = MailslotName.MaximumLength - 1;
            ENSURE_IN_INPUT_BUFFER( &MailslotName, FALSE, FALSE );
            if ( MailslotName.Buffer[MailslotName.Length] != '\0' ) {
                try_return(Status = STATUS_INVALID_PARAMETER);
            }

        } else {
            MailslotName.Buffer = MAILSLOT_BROWSER_NAME;
        }


        Status = BowserSendSecondClassMailslot(Transport,
                        &DestinationName,
                        InputBuffer->Parameters.SendDatagram.DestinationNameType,
                        OutputBuffer,
                        OutputBufferLength,
                        TRUE,
                        MailslotName.Buffer,
                        NULL);

try_exit:NOTHING;
    } finally {
        if (Transport != NULL) {
            BowserDereferenceTransport(Transport);
        }
    }

    return Status;

}

NTSTATUS
WaitForNewMaster (
    IN PIRP Irp,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    )

/*++

Routine Description:

    This routine will queue a request that will complete when a new workstation
    becomes the master browser server.

Arguments:

    IN PIRP Irp - I/O request packet describing request.

Return Value:

    Status of operation.

Please note that this IRP is cancelable.


--*/

{
    NTSTATUS           Status;
    PTRANSPORT         Transport           = NULL;
    UNICODE_STRING     ExistingMasterName;
    PIO_STACK_LOCATION IrpSp               = IoGetCurrentIrpStackLocation(Irp);

    PAGED_CODE();

    dlog(DPRT_FSCTL, ("NtDeviceIoControlFile: WaitForNewMaster\n"));

    try {
        WCHAR TransportNameBuffer[MAX_PATH+1];
        WCHAR DomainNameBuffer[DNLEN+1];
        WCHAR ExistingMasterNameBuffer[CNLEN+1];

        if (InputBufferLength < (ULONG)FIELD_OFFSET(LMDR_REQUEST_PACKET,Parameters.GetMasterName.Name)) {
           try_return(Status = STATUS_INVALID_PARAMETER);
        }

        ExistingMasterName.Buffer = InputBuffer->Parameters.GetMasterName.Name;
        ExistingMasterName.Length = ExistingMasterName.MaximumLength = (USHORT)InputBuffer->Parameters.GetMasterName.MasterNameLength;
        ENSURE_IN_INPUT_BUFFER(&ExistingMasterName, FALSE, FALSE);

        CAPTURE_UNICODE_STRING( &InputBuffer->TransportName, TransportNameBuffer );
        CAPTURE_UNICODE_STRING( &InputBuffer->EmulatedDomainName, DomainNameBuffer );
        Transport = BowserFindTransport(&InputBuffer->TransportName, &InputBuffer->EmulatedDomainName );
        dprintf(DPRT_REF, ("Called Find transport %lx from WaitForNewMaster.\n", Transport));

        if (Transport == NULL) {
            try_return (Status = STATUS_OBJECT_NAME_NOT_FOUND);
        }

        if (Transport->PagedTransport->Flags & DIRECT_HOST_IPX) {
            try_return (Status = STATUS_NOT_SUPPORTED);
        }

        if (Transport->PagedTransport->MasterName.Length != 0) {
            UNICODE_STRING ExistingMasterNameCopy;
            WCHAR MasterNameBuffer[CNLEN+1];

            ExistingMasterNameCopy.Buffer = MasterNameBuffer;
            ExistingMasterNameCopy.MaximumLength = sizeof(MasterNameBuffer);

            Status = RtlUpcaseUnicodeString(&ExistingMasterNameCopy, &ExistingMasterName, FALSE);

            if (!NT_SUCCESS(Status)) {
                try_return (Status);
            }

            //
            //  If the name the application passed in was not the same as the
            //  name we have stored locally, we complete the request immediately,
            //  since the name changed between when we last determined the name
            //  and now.
            //

            LOCK_TRANSPORT(Transport);

            if (!RtlEqualUnicodeString(&ExistingMasterNameCopy, &Transport->PagedTransport->MasterName, FALSE)) {

                RtlCopyUnicodeString(&ExistingMasterNameCopy, &Transport->PagedTransport->MasterName);

                UNLOCK_TRANSPORT(Transport);

                if (InputBufferLength <
                    ((ULONG)FIELD_OFFSET(LMDR_REQUEST_PACKET,Parameters.GetMasterName.Name)+
                    ExistingMasterNameCopy.Length+3*sizeof(WCHAR))) {
                   try_return(Status = STATUS_BUFFER_TOO_SMALL);
                }

                InputBuffer->Parameters.GetMasterName.Name[0] = L'\\';

                InputBuffer->Parameters.GetMasterName.Name[1] = L'\\';

                RtlCopyMemory(&InputBuffer->Parameters.GetMasterName.Name[2], ExistingMasterNameCopy.Buffer,
                    ExistingMasterNameCopy.Length);

                InputBuffer->Parameters.GetMasterName.MasterNameLength = ExistingMasterNameCopy.Length+2*sizeof(WCHAR);

                InputBuffer->Parameters.GetMasterName.Name[2+(ExistingMasterNameCopy.Length/sizeof(WCHAR))] = UNICODE_NULL;

                Irp->IoStatus.Information = FIELD_OFFSET(LMDR_REQUEST_PACKET, Parameters.GetMasterName.Name) +
                    ExistingMasterNameCopy.Length+3*sizeof(WCHAR);;

                try_return (Status = STATUS_SUCCESS);
            }

            UNLOCK_TRANSPORT(Transport);
        }

        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
            (ULONG)FIELD_OFFSET(LMDR_REQUEST_PACKET,Parameters.GetMasterName.Name)+3*sizeof(WCHAR)) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }

        Status = BowserQueueNonBufferRequest(Irp,
                                             &Transport->WaitForNewMasterNameQueue,
                                             BowserCancelQueuedRequest
                                             );

try_exit:NOTHING;
    } finally {
        if ( Transport != NULL ) {
            BowserDereferenceTransport(Transport);
        }
    }

    return Status;

}

NTSTATUS
QueryStatistics(
    IN PIRP Irp,
    OUT PBOWSER_STATISTICS OutputBuffer,
    IN OUT PULONG OutputBufferLength
    )
{
    KIRQL OldIrql;

    if (*OutputBufferLength != sizeof(BOWSER_STATISTICS)) {
        *OutputBufferLength = 0;
        return STATUS_BUFFER_TOO_SMALL;
    }

    BowserReferenceDiscardableCode( BowserDiscardableCodeSection );

    DISCARDABLE_CODE( BowserDiscardableCodeSection );

    ACQUIRE_SPIN_LOCK(&BowserStatisticsLock, &OldIrql);

    RtlCopyMemory(OutputBuffer, &BowserStatistics, sizeof(BOWSER_STATISTICS));

    RELEASE_SPIN_LOCK(&BowserStatisticsLock, OldIrql);

    BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );

    return STATUS_SUCCESS;
}

NTSTATUS
ResetStatistics(
    VOID
    )
{
    KIRQL OldIrql;

    BowserReferenceDiscardableCode( BowserDiscardableCodeSection );

    DISCARDABLE_CODE( BowserDiscardableCodeSection );

    ACQUIRE_SPIN_LOCK(&BowserStatisticsLock, &OldIrql);

    RtlZeroMemory(&BowserStatistics, sizeof(BOWSER_STATISTICS));

    KeQuerySystemTime(&BowserStatistics.StartTime);

    RELEASE_SPIN_LOCK(&BowserStatisticsLock, OldIrql);

    BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );

    return STATUS_SUCCESS;

}



NTSTATUS
BowserIpAddressChanged(
    IN PLMDR_REQUEST_PACKET InputBuffer
    )

/*++

Routine Description:

    This routine is called whenever the IP address of a transport changes.
    NetBt uses the IP address to associate it's transport endpoint with the
    appropriate NDIS driver.  As such, it can't return NDIS specific information,
    until the IP address is defined.

Arguments:

    InputBuffer - Buffer specifying the name of the transport whose address
        has changed.

Return Value:

NTSTATUS

--*/

{
    NTSTATUS Status;
    PAGED_CODE();

    dlog(DPRT_FSCTL, ("NtDeviceIoControlFile: BowserIpAddressChanged: Calling dead code!!\n"));

    //
    // Nobody should call into us here. This is dead code.
    //
    ASSERT(FALSE);

    //
    // The no longer need notification of address changes.
    // The redir gets PNP bind and unbind notifications when the IP address
    // changes.  The redir passes those along to us.
    //
    return STATUS_SUCCESS;

#ifdef notdef

    //
    // Check some fields in the input buffer.
    //

    if (InputBuffer->Version != LMDR_REQUEST_PACKET_VERSION_DOM) {
        Status = STATUS_INVALID_PARAMETER;
        goto ReturnStatus;
    }

    if (InputBuffer->TransportName.Length == 0) {
        Status = STATUS_INVALID_PARAMETER;
        goto ReturnStatus;
    }


    //
    // Handle each transport (in each emulated domain) that has this transport name.
    //

    ENSURE_IN_INPUT_BUFFER( &InputBuffer->TransportName, FALSE, FALSE );
    Status = BowserForEachTransport( BowserIpAddressChangedWorker,
                                     &InputBuffer->TransportName );


ReturnStatus:
    return Status;
#endif // notdef

}

#ifdef notdef
NTSTATUS
BowserIpAddressChangedWorker(
    PTRANSPORT Transport,
    PVOID Context
    )
/*++

Routine Description:

    This routine is the worker routine for BowserIpAddressChanged.

    This routine is called whenever the IP address of a transport changes.

Arguments:

    Transport - Current transport being handled.

    Context - Name of transport to search for

Return Value:

    Status of the operation.

--*/

{
    PUNICODE_STRING TransportName = (PUNICODE_STRING) Context;

    PAGED_CODE();

    try {

        //
        // If the TransportName of the transport matches the one passed in,
        //  update the information from the NDIS driver.
        //

        if (RtlEqualUnicodeString(TransportName,
                                  &Transport->PagedTransport->TransportName, TRUE)) {

            //
            // Notify services that the IP address changed for this transport.
            //

            BowserSendPnp(
                NlPnpNewIpAddress,
                NULL,    // All hosted domains
                &Transport->PagedTransport->TransportName,
                BowserTransportFlags(Transport->PagedTransport) );

            //
            // Update bowser information about the provider.

            (VOID) BowserUpdateProviderInformation( Transport->PagedTransport );

        }

    } finally {
    }

    return STATUS_SUCCESS;
}
#endif // notdef



NTSTATUS
EnableDisableTransport (
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    )

/*++

Routine Description:

    This routine Implements the IOCTL to enable or disable a transport.

Arguments:

    InputBuffer - Buffer indicating whether we should enable or disable the
        transport.

Return Value:

    Status of operation.


--*/

{
    NTSTATUS Status;
    PTRANSPORT Transport = NULL;
    PPAGED_TRANSPORT PagedTransport;

    PAGED_CODE();

    try {
        WCHAR TransportNameBuffer[MAX_PATH+1];
        WCHAR DomainNameBuffer[DNLEN+1];

        if (InputBufferLength <
            (ULONG)FIELD_OFFSET(LMDR_REQUEST_PACKET,Parameters) +
            sizeof(InputBuffer->Parameters.EnableDisableTransport)) {
           try_return(Status = STATUS_INVALID_PARAMETER);
        }

        CAPTURE_UNICODE_STRING( &InputBuffer->TransportName, TransportNameBuffer );
        CAPTURE_UNICODE_STRING( &InputBuffer->EmulatedDomainName, DomainNameBuffer );

        //
        // Check some fields in the input buffer.
        //

        if (InputBuffer->Version != LMDR_REQUEST_PACKET_VERSION_DOM) {
            try_return (Status = STATUS_INVALID_PARAMETER);
        }

        if (InputBuffer->TransportName.Length == 0) {
            try_return (Status = STATUS_INVALID_PARAMETER);
        }


        //
        // Find the transport whose address has changed.
        //

        dlog( DPRT_FSCTL,
              ("NtDeviceIoControlFile: %wZ: Enable/Disable transport &ld\n",
              &InputBuffer->TransportName,
              InputBuffer->Parameters.EnableDisableTransport.EnableTransport ));
        Transport = BowserFindTransport(&InputBuffer->TransportName, &InputBuffer->EmulatedDomainName );
        dprintf(DPRT_REF, ("Called Find transport %lx from EnableDisableTransport.\n", Transport));

        if (Transport == NULL) {
            try_return (Status = STATUS_OBJECT_NAME_NOT_FOUND);
        }

        PagedTransport = Transport->PagedTransport;

        //
        // Set the disabled bit correctly.
        //

        InputBuffer->Parameters.EnableDisableTransport.PreviouslyEnabled =
            !PagedTransport->DisabledTransport;

        if ( InputBuffer->Parameters.EnableDisableTransport.EnableTransport ) {
            PagedTransport->DisabledTransport = FALSE;

            //
            // If the transport was previously disabled and this is an NTAS server,
            //  force an election.
            //

            if ( (!InputBuffer->Parameters.EnableDisableTransport.PreviouslyEnabled) &&
                 BowserData.IsLanmanNt ) {
                BowserStartElection( Transport );
            }

        } else {
            PagedTransport->DisabledTransport = TRUE;

            //
            // If we're disabling a previously enabled transport,
            //  ensure we're not the master browser.
            //

            BowserLoseElection( Transport );
        }

        Status = STATUS_SUCCESS;

try_exit:NOTHING;
    } finally {
        if (Transport != NULL) {
            BowserDereferenceTransport(Transport);
        }
    }

    return Status;

}


NTSTATUS
BowserRenameDomain (
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    )

/*++

Routine Description:

    This routine renames an emulated domain.

Arguments:

    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength,

Return Value:

    NTSTATUS - Status of operation.

--*/

{
    NTSTATUS Status;
    PDOMAIN_INFO DomainInfo = NULL;

    WCHAR OldDomainNameBuffer[DNLEN+1];
    UNICODE_STRING OldDomainName;
    CHAR OemDomainName[DNLEN+1];
    DWORD OemDomainNameLength;
    UNICODE_STRING NewDomainName;

    PAGED_CODE();

    dlog(DPRT_FSCTL, ("NtDeviceIoControlFile: RenameDomain\n"));

    try {

        //
        // Check some fields in the input buffer.
        //

        if (InputBufferLength < offsetof(LMDR_REQUEST_PACKET, Parameters.DomainRename.DomainName)) {
            try_return (Status = STATUS_INVALID_PARAMETER);
        }

        if (InputBuffer->Version != LMDR_REQUEST_PACKET_VERSION_DOM) {
            try_return (Status = STATUS_INVALID_PARAMETER);
        }

        ENSURE_IN_INPUT_BUFFER( &InputBuffer->EmulatedDomainName, TRUE, FALSE );

        //
        // Find the emulated domain to rename
        //

        DomainInfo = BowserFindDomain( &InputBuffer->EmulatedDomainName );

        if ( DomainInfo == NULL ) {
            try_return (Status = STATUS_OBJECT_NAME_NOT_FOUND);
        }

        //
        // Make a copy of the old domain name for use throughout the routine.
        //

        wcscpy( OldDomainNameBuffer, DomainInfo->DomUnicodeDomainNameBuffer );
        RtlInitUnicodeString( &OldDomainName, OldDomainNameBuffer );


        //
        // If the old and new names are the same,
        //  we're done.
        //

        NewDomainName.MaximumLength = NewDomainName.Length = (USHORT )
                      InputBuffer->Parameters.DomainRename.DomainNameLength;
        NewDomainName.Buffer = InputBuffer->Parameters.DomainRename.DomainName;
        ENSURE_IN_INPUT_BUFFER( &NewDomainName, FALSE, FALSE );

        if ( RtlEqualUnicodeString( &OldDomainName, &NewDomainName, TRUE) ) {
            try_return (Status = STATUS_SUCCESS);
        }


        //
        // Register the new default names with the new domain name.
        //

        Status = BowserForEachTransportInDomain(DomainInfo, BowserAddDefaultNames, &NewDomainName );

        if ( !NT_SUCCESS(Status) || InputBuffer->Parameters.DomainRename.ValidateOnly ) {
            NTSTATUS TempStatus;

            //
            // Delete any names that did get registered.
            //

            (VOID) BowserForEachTransportInDomain(DomainInfo, BowserDeleteDefaultDomainNames, &NewDomainName );


        } else {


            //
            // Store the new domain name into the domain structure
            //

            Status = BowserSetDomainName( DomainInfo, &NewDomainName );

            if ( !NT_SUCCESS(Status)) {
                //
                // Delete any names that did get registered.
                //

                (VOID) BowserForEachTransportInDomain(DomainInfo, BowserDeleteDefaultDomainNames, &NewDomainName );
            } else {

                //
                // Delete the old names.
                //

                (VOID) BowserForEachTransportInDomain(DomainInfo, BowserDeleteDefaultDomainNames, &OldDomainName );

                //
                // Tell Netlogon and the Browser service about this domain rename.
                //

                BowserSendPnp( NlPnpDomainRename,
                               &OldDomainName,
                               NULL,    // Affects all transports
                               0 );
            }
        }

try_exit:NOTHING;
    } finally {
        if ( DomainInfo != NULL ) {
            BowserDereferenceDomain( DomainInfo );
        }

    }
    return Status;
}


PLMDR_REQUEST_PACKET
RequestPacket32to64 (
    IN      PLMDR_REQUEST_PACKET32  RequestPacket32,
    IN  OUT PLMDR_REQUEST_PACKET    RequestPacket)
/*++

Routine Description:

    Converts a 32 bit request packet into supplied native (64 bit)
    packet format. (see bug 454130)


Arguments:

    RequestPacket32 -- Buffer containing request packet packet by a 32 bit client

    ReqestPacket -- Native (64 bit) request packet buffer



Return Value:

    a pointer to converted buffer (ReqestPacket arg)



Remarks:
    No checks assumed at this point (this is a convinience function). It is assumed
    that the conversion is needed at this point


--*/
{

    PAGED_CODE();

    ASSERT(RequestPacket32);

    //
    // The following code depends on the request packet structure contents.
    //  1. copy everything before the 2 unicode strings  TransportName & EmulatedDomainName.
    //  2. convert the string structs.
    //  3. copy the rest.
    //

    RequestPacket->Type = RequestPacket32->Type;
    RequestPacket->Version = RequestPacket32->Version;
    RequestPacket->Level = RequestPacket32->Level;
    RequestPacket->LogonId = RequestPacket32->LogonId;


    // convert strings.
    RequestPacket->TransportName.Length = RequestPacket32->TransportName.Length;
    RequestPacket->TransportName.MaximumLength = RequestPacket32->TransportName.MaximumLength;
    // note: this line is the reason for all of this
    RequestPacket->TransportName.Buffer = (WCHAR * POINTER_32) RequestPacket32->TransportName.Buffer;

    RequestPacket->EmulatedDomainName.Length = RequestPacket32->EmulatedDomainName.Length;
    RequestPacket->EmulatedDomainName.MaximumLength = RequestPacket32->EmulatedDomainName.MaximumLength;
    // note: this line is the reason for all of this
    RequestPacket->EmulatedDomainName.Buffer = (WCHAR * POINTER_32) RequestPacket32->EmulatedDomainName.Buffer;

    RtlCopyMemory((PBYTE)RequestPacket + (SIZE_T)FIELD_OFFSET(LMDR_REQUEST_PACKET,Parameters),
                  (PBYTE)RequestPacket32 + (SIZE_T)FIELD_OFFSET(LMDR_REQUEST_PACKET32,Parameters),
                  sizeof(LMDR_REQUEST_PACKET32) - (SIZE_T)FIELD_OFFSET(LMDR_REQUEST_PACKET32,Parameters));

    return RequestPacket;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\bowser\fileinfo.c ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    fileinfo.c

Abstract:

    This module implements the NtQueryInformationFile and
NtQueryVolumeInformationFile API's for the NT datagram receiver (bowser).


Author:

    Larry Osterman (larryo) 6-May-1991

Revision History:

    6-May-1991  larryo

        Created

--*/

#include "precomp.h"
#pragma hdrstop

NTSTATUS
BowserCommonQueryVolumeInformationFile (
    IN BOOLEAN Wait,
    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
BowserCommonQueryInformationFile (
    IN BOOLEAN Wait,
    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, BowserFspQueryVolumeInformationFile)
#pragma alloc_text(PAGE, BowserFsdQueryVolumeInformationFile)
#pragma alloc_text(PAGE, BowserCommonQueryVolumeInformationFile)
#pragma alloc_text(PAGE, BowserFspQueryInformationFile)
#pragma alloc_text(PAGE, BowserFsdQueryInformationFile)
#pragma alloc_text(PAGE, BowserCommonQueryInformationFile)
#endif


NTSTATUS
BowserFspQueryVolumeInformationFile (
    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called when the last handle to the NT Bowser device
    driver is closed.

Arguments:

    IN PDEVICE_OBJECT DeviceObject - Supplies a device object for the request.
    IN PIRP Irp - Supplies an IRP for the create request.

Return Value:

    NTSTATUS - Final Status of operation

--*/
{
    NTSTATUS Status;
    PAGED_CODE();
    Status = BowserCommonQueryVolumeInformationFile (TRUE,
                                        DeviceObject,
                                        Irp);
    return Status;

}

NTSTATUS
BowserFsdQueryVolumeInformationFile (
    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called when the last handle to the NT Bowser device
    driver is closed.

Arguments:

    IN PDEVICE_OBJECT DeviceObject - Supplies a device object for the request.
    IN PIRP Irp - Supplies an IRP for the create request.

Return Value:

    NTSTATUS - Final Status of operation

--*/
{
    NTSTATUS Status;

    PAGED_CODE();
    Status = BowserCommonQueryVolumeInformationFile (IoIsOperationSynchronous(Irp),
                                        DeviceObject,
                                        Irp);
    return Status;


}

NTSTATUS
BowserCommonQueryVolumeInformationFile (
    IN BOOLEAN Wait,
    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called when the last handle to the NT Bowser device
    driver is closed.

Arguments:

    IN PDEVICE_OBJECT DeviceObject - Supplies a device object for the request.
    IN PIRP Irp - Supplies an IRP for the create request.

Return Value:

    NTSTATUS - Final Status of operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();
    BowserCompleteRequest(Irp, Status);

    return Status;

    DBG_UNREFERENCED_PARAMETER(Wait);
    UNREFERENCED_PARAMETER(DeviceObject);

}

NTSTATUS
BowserFspQueryInformationFile (
    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called when the last handle to the NT Bowser device
    driver is closed.

Arguments:

    IN PDEVICE_OBJECT DeviceObject - Supplies a device object for the request.
    IN PIRP Irp - Supplies an IRP for the create request.

Return Value:

    NTSTATUS - Final Status of operation

--*/
{
    NTSTATUS Status;

    PAGED_CODE();
    Status = BowserCommonQueryInformationFile (TRUE,
                                        DeviceObject,
                                        Irp);
    return Status;

}

NTSTATUS
BowserFsdQueryInformationFile (
    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called when the last handle to the NT Bowser device
    driver is closed.

Arguments:

    IN PDEVICE_OBJECT DeviceObject - Supplies a device object for the request.
    IN PIRP Irp - Supplies an IRP for the create request.

Return Value:

    NTSTATUS - Final Status of operation

--*/
{
    NTSTATUS Status;

    PAGED_CODE();
    Status = BowserCommonQueryInformationFile(IoIsOperationSynchronous(Irp),
                                        DeviceObject,
                                        Irp);
    return Status;


}

NTSTATUS
BowserCommonQueryInformationFile (
    IN BOOLEAN Wait,
    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called when the last handle to the NT Bowser device
    driver is closed.

Arguments:

    IN PDEVICE_OBJECT DeviceObject - Supplies a device object for the request.
    IN PIRP Irp - Supplies an IRP for the create request.

Return Value:

    NTSTATUS - Final Status of operation

--*/
{
    //
    // Return an error until we figure out valid information to return.
    NTSTATUS Status = STATUS_NOT_IMPLEMENTED;

    PAGED_CODE();

    BowserCompleteRequest(Irp, Status);

    return Status;

    DBG_UNREFERENCED_PARAMETER(Wait);

    UNREFERENCED_PARAMETER(DeviceObject);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\bowser\fsddisp.c ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    fsddisp.c

Abstract:

    This module implements the FSD dispatching routines for the NT datagram
    browser (the Bowser).


Author:

    Larry Osterman (larryo) 6-May-1991

Revision History:

    6-May-1991  larryo

        Created

--*/

#include "precomp.h"
#pragma hdrstop

//KSPIN_LOCK
//BowserRefcountInterlock = {0};

NTSTATUS
BowserStopBrowser(
    IN PTRANSPORT Transport,
    IN PVOID Context
    );

NTSTATUS
BowserCancelRequestsOnTransport(
    IN PTRANSPORT Transport,
    IN PVOID Context
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, BowserFsdCreate)
#pragma alloc_text(PAGE, BowserFsdClose)
#pragma alloc_text(PAGE, BowserFsdCleanup)
#pragma alloc_text(PAGE, BowserCancelRequestsOnTransport)
#pragma alloc_text(PAGE, BowserStopBrowser)
#pragma alloc_text(INIT, BowserInitializeFsd)
#endif

NTSTATUS
BowserFsdCreate (
    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine processes an NtCreateFile of the NT Bowser device driver.

Arguments:

    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject - Supplies a device object for the request.
    IN PIRP Irp - Supplies an IRP for the create request.

Return Value:

    NTSTATUS - Final Status of operation

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    InterlockedIncrement(&BowserNumberOfOpenFiles);

    BowserCompleteRequest(Irp, Status);

    return Status;

    UNREFERENCED_PARAMETER(DeviceObject);

}

NTSTATUS
BowserFsdClose (
    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called when the last reference to a handle to the NT Bowser
    device driver is removed.

Arguments:

    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject - Supplies a device object for the request.
    IN PIRP Irp - Supplies an IRP for the create request.

Return Value:

    NTSTATUS - Final Status of operation

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    BowserCompleteRequest(Irp, Status);

    return Status;

    UNREFERENCED_PARAMETER(DeviceObject);

}

NTSTATUS
BowserFsdCleanup (
    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called when the last handle to the NT Bowser device
    driver is closed.

Arguments:

    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject - Supplies a device object for the request.
    IN PIRP Irp - Supplies an IRP for the create request.

Return Value:

    NTSTATUS - Final Status of operation

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    FsRtlEnterFileSystem();

    BowserForEachTransport(BowserCancelRequestsOnTransport, Irp->Tail.Overlay.OriginalFileObject);

    if (InterlockedDecrement(&BowserNumberOfOpenFiles) == 0) {
        //
        //  There are no longer any handles open to the browser.
        //
        //  Make sure we aren't a browser on any of our networks now.
        //

        BowserForEachTransport(BowserStopBrowser, NULL);
    }

    FsRtlExitFileSystem();

    BowserCompleteRequest(Irp, Status);

    return Status;

    UNREFERENCED_PARAMETER(DeviceObject);
}

NTSTATUS
BowserCancelRequestsOnTransport(
    IN PTRANSPORT Transport,
    IN PVOID Context
    )
{
    PFILE_OBJECT FileObject = Context;

    PAGED_CODE();

    BowserCancelQueuedIoForFile(&Transport->BecomeBackupQueue, FileObject);
    BowserCancelQueuedIoForFile(&Transport->BecomeMasterQueue, FileObject);
    BowserCancelQueuedIoForFile(&Transport->FindMasterQueue, FileObject);
    BowserCancelQueuedIoForFile(&Transport->WaitForMasterAnnounceQueue, FileObject);
    BowserCancelQueuedIoForFile(&Transport->ChangeRoleQueue, FileObject);
    BowserCancelQueuedIoForFile(&Transport->WaitForNewMasterNameQueue, FileObject);

    return STATUS_SUCCESS;
}

NTSTATUS
BowserStopBrowser(
    IN PTRANSPORT Transport,
    IN PVOID Context
    )
{
    PPAGED_TRANSPORT PagedTransport = Transport->PagedTransport;
    PAGED_CODE();
    LOCK_TRANSPORT(Transport);

    //
    //  Make sure that we cannot possibly participate in an election.
    //

    PagedTransport->Role = None;

    PagedTransport->ServiceStatus &= ~(SV_TYPE_BACKUP_BROWSER | SV_TYPE_MASTER_BROWSER | SV_TYPE_POTENTIAL_BROWSER);

    BowserForEachTransportName(Transport, BowserStopProcessingAnnouncements, NULL);

    BowserStopTimer(&Transport->ElectionTimer);

    BowserStopTimer(&Transport->FindMasterTimer);

    UNLOCK_TRANSPORT(Transport);

    //
    //  Delete the names associated with being a browser.
    //

    BowserDeleteTransportNameByName(Transport,
                                NULL,
                                MasterBrowser);

    BowserDeleteTransportNameByName(Transport,
                                NULL,
                                DomainAnnouncement);

    BowserDeleteTransportNameByName(Transport,
                                NULL,
                                BrowserElection);

    return(STATUS_SUCCESS);


}


VOID
BowserInitializeFsd(
    VOID
    )
{
//    KeInitializeSpinLock(&BowserRefcountInterlock);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\bowser\fsddisp.h ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    fspdisp.h

Abstract:

    This module defines the routines prototypes used for the bowser FSD.


Author:

    Larry Osterman (LarryO) 13-Aug-1990

Revision History:

    13-Aug-1990 LarryO

        Created

--*/
#ifndef _FSDDISP_
#define _FSDDISP_

NTSTATUS
BowserFsdCreate (
    IN struct _BOWSER_FS_DEVICE_OBJECT *DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
BowserFsdClose (
    IN struct _BOWSER_FS_DEVICE_OBJECT *DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
BowserFsdQueryInformationFile (
    IN struct _BOWSER_FS_DEVICE_OBJECT *DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
BowserFsdQueryVolumeInformationFile (
    IN struct _BOWSER_FS_DEVICE_OBJECT *DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
BowserFsdCleanup (
    IN struct _BOWSER_FS_DEVICE_OBJECT *DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
BowserFsdDeviceIoControlFile (
    IN struct _BOWSER_FS_DEVICE_OBJECT *DeviceObject,
    IN PIRP Irp
    );


#endif  // _FSDDISP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\bowser\fspdisp.h ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    fspdisp.h

Abstract:

    This module defines the data structures and routines used for the FSP
    dispatching code.


Author:

    Larry Osterman (LarryO) 13-Aug-1990

Revision History:

    13-Aug-1990 LarryO

        Created

--*/
#ifndef _FSPDISP_
#define _FSPDISP_


//
// Define communications data area between FSD and FSP.  This is done through
// the use of a Device Object.  This model allows one device object to be
// created for each volume that is/has been mounted in the system.  That is,
// each time a volume is mounted, the file system creates a device object to
// represent it so that the I/O system can vector directly to the proper file
// system.  The file system then uses information in the device object and in
// the file object to locate and synchronize access to its database of open
// file data structures (often called File Control Blocks - or, FCBs), Volume
// Control Blocks (VCBs), Map Control Blocks (MCBs), etc.
//
// The event and spinlock will be used to control access to the queue of IRPs.
// The IRPs are passed from the FSD to the FSP by inserting them onto the work
// queue in an interlocked manner and then setting the event to the Signaled
// state.  The event is an autoclearing type so the FSP simply wakes up when
// the event is Signaled and begins processing entries in the queue.
//
// Other data in this record should contain any information which both the FSD
// and the FSP need to share.  For example, a list of all of the open files
// might be something that both should be able to see.  Notice that all data
// placed in this area must be allocated from paged or non-paged pool.
//

typedef struct _BOWSER_FS_DEVICE_OBJECT {
    DEVICE_OBJECT DeviceObject;

} BOWSER_FS_DEVICE_OBJECT, *PBOWSER_FS_DEVICE_OBJECT;


NTSTATUS
BowserpInitializeFsp(
    PDRIVER_OBJECT BowserDriverObject
    );

VOID
BowserpUninitializeFsp (
    VOID
    );

VOID
BowserWorkerDispatch (
    PVOID Context
    );

NTSTATUS
BowserFsdPostToFsp(
    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
BowserFspQueryInformationFile (
    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
BowserFspQueryVolumeInformationFile (
    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
BowserFspDeviceIoControlFile (
    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
BowserIdleTimer (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    );

#endif  // _FSPDISP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\bowser\mailslot.c ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    mailslot.c

Abstract:

    This module implements the routines needed to process incoming mailslot
    requests.



Author:

    Larry Osterman (larryo) 18-Oct-1991

Revision History:

    18-Oct-1991  larryo

        Created

--*/
#include "precomp.h"
#pragma hdrstop
#include <netlogon.h>
#define _INC_WINDOWS 1
#include <winsock2.h>


// Free list of 512-byte buffers.
LIST_ENTRY
BowserMailslotBufferList = {0};

KSPIN_LOCK
BowserMailslotSpinLock = {0};

// Largest "typical" datagram size
#define BOWSER_MAX_DATAGRAM_SIZE 512

// Total number of mailslot buffers currently allocated.
LONG
BowserNumberOfMailslotBuffers = {0};

// Number of 512-byte buffers currently allocated.
LONG
BowserNumberOfMaxSizeMailslotBuffers = {0};

// Number of 512-byte buffers currently in the free list.
LONG
BowserNumberOfFreeMailslotBuffers = {0};

#if DBG
ULONG
BowserMailslotCacheHitCount = 0;

ULONG
BowserMailslotCacheMissCount = 0;
#endif // DBG


//
// Variables describing bowser support for handling netlogon mailslot messages and
//  PNP messages to Netlogon service or BrowserService.

typedef struct _BROWSER_PNP_STATE {

    // Queue of mailslot messages.
    LIST_ENTRY MailslotMessageQueue;


    // Maximum queue length
    ULONG MaxMessageCount;

    // Current queue length
    ULONG CurrentMessageCount;

    // Queue of IRPs used to read the queues
    IRP_QUEUE IrpQueue;

    // Queue of PNP events
    LIST_ENTRY PnpQueue;

} BROWSER_PNP_STATE, *PBROWSER_PNP_STATE;

//
// There is one BROWSER_PNP_STATE for the Netlogon service and one for the
// Browser service.
//

BROWSER_PNP_STATE BowserPnp[BOWSER_PNP_COUNT];


//
// Queue of PNP notifications to netlogon or browser service
//
typedef struct _BR_PNP_MESSAGE {
    LIST_ENTRY Next;                    // List of all queued entries.

    NETLOGON_PNP_OPCODE NlPnpOpcode;    // Operation to be notified

    ULONG TransportFlags;               // Flags describing transport

    UNICODE_STRING TransportName;       // Transport operation happened on

    UNICODE_STRING HostedDomainName;    // Hosted domain operation happened on

} BR_PNP_MESSAGE, *PBR_PNP_MESSAGE;



//
// Forwards for the alloc_text
//

NTSTATUS
BowserNetlogonCopyMessage(
    IN PIRP Irp,
    IN PMAILSLOT_BUFFER MailslotBuffer
    );

NTSTATUS
BowserCopyPnp(
    IN PIRP Irp,
    IN NETLOGON_PNP_OPCODE NlPnpOpcode,
    IN PUNICODE_STRING HostedDomainName,
    IN PUNICODE_STRING TransportName,
    IN ULONG TransportFlags
    );

VOID
BowserTrimMessageQueue (
    PBROWSER_PNP_STATE BrPnp
    );

BOOLEAN
BowserProcessNetlogonMailslotWrite(
    IN PMAILSLOT_BUFFER MailslotBuffer
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE5NETLOGON, BowserNetlogonCopyMessage)
#pragma alloc_text(PAGE4BROW, BowserCopyPnp)
#pragma alloc_text(PAGE4BROW, BowserTrimMessageQueue)
#pragma alloc_text(PAGE5NETLOGON, BowserNetlogonDeleteTransportFromMessageQueue )
#pragma alloc_text(PAGE5NETLOGON, BowserProcessNetlogonMailslotWrite)
#pragma alloc_text(PAGE4BROW, BowserSendPnp)
#pragma alloc_text(PAGE4BROW, BowserEnablePnp )
#pragma alloc_text(PAGE4BROW, BowserReadPnp )
#pragma alloc_text(PAGE, BowserProcessMailslotWrite)
#pragma alloc_text(PAGE4BROW, BowserFreeMailslotBuffer)
#pragma alloc_text(INIT, BowserpInitializeMailslot)
#pragma alloc_text(PAGE, BowserpUninitializeMailslot)
#endif

NTSTATUS
BowserNetlogonCopyMessage(
    IN PIRP Irp,
    IN PMAILSLOT_BUFFER MailslotBuffer
    )
/*++

Routine Description:

    This routine copies the data from the specified MailslotBuffer into the
    IRP for the netlogon request.

    This routine unconditionally frees the passed in Mailslot Buffer.

Arguments:

    Irp - IRP for the IOCTL from the netlogon service.

    MailslotBuffer - Buffer describing the mailslot message.

Return Value:

    Status of the operation.

    The caller should complete the I/O operation with this status code.

--*/
{
    NTSTATUS Status;

    PSMB_HEADER SmbHeader;
    PSMB_TRANSACT_MAILSLOT MailslotSmb;
    PUCHAR MailslotData;
    OEM_STRING MailslotNameA;
    UNICODE_STRING MailslotNameU;
    UNICODE_STRING TransportName;
    UNICODE_STRING DestinationName;
    USHORT DataCount;

    PNETLOGON_MAILSLOT NetlogonMailslot;
    PUCHAR Where;

    PIO_STACK_LOCATION IrpSp;

    BowserReferenceDiscardableCode( BowserNetlogonDiscardableCodeSection );

    DISCARDABLE_CODE( BowserNetlogonDiscardableCodeSection );

    //
    // Extract the name of the mailslot and address/size of mailslot message
    //  from SMB.
    //

    SmbHeader = (PSMB_HEADER )MailslotBuffer->Buffer;
    MailslotSmb = (PSMB_TRANSACT_MAILSLOT)(SmbHeader+1);
    MailslotData = (((PCHAR )SmbHeader) + SmbGetUshort(&MailslotSmb->DataOffset));
    RtlInitString(&MailslotNameA, MailslotSmb->Buffer );
    DataCount = SmbGetUshort(&MailslotSmb->DataCount);

    //
    // Get the name of the transport and netbios name the mailslot message arrived on.
    //

    TransportName =
        MailslotBuffer->TransportName->Transport->PagedTransport->TransportName;
    DestinationName =
        MailslotBuffer->TransportName->PagedTransportName->Name->Name;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    try {

        //
        // Convert mailslot name to unicode for return.
        //

        Status = RtlOemStringToUnicodeString(&MailslotNameU, &MailslotNameA, TRUE);

        if (!NT_SUCCESS(Status)) {
            BowserLogIllegalName( Status, MailslotNameA.Buffer, MailslotNameA.Length );
            MailslotNameU.Buffer = NULL;
            try_return( NOTHING );
        }

        //
        // Ensure the data fits in the user's output buffer.
        //

        if ( IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
             sizeof(NETLOGON_MAILSLOT) +    // Header structure
             DataCount +                    // Actual mailslot message
             sizeof(DWORD) +                // alignment for socket address
             sizeof(SOCKADDR_IN) +          // Client Socket Address
             sizeof(WCHAR) +                // alignment of unicode strings
             TransportName.Length +         // TransportName
             sizeof(WCHAR) +                // zero terminator
             MailslotNameU.Length +         // Mailslot name
             sizeof(WCHAR) +                // zero terminator
             DestinationName.Length +       // Destination name
             sizeof(WCHAR) ) {              // zero terminator

            try_return( Status = STATUS_BUFFER_TOO_SMALL );
        }


        //
        // Get the address of Netlogon's buffer and fill in common portion.
        //
        NetlogonMailslot = MmGetSystemAddressForMdl( Irp->MdlAddress );

        if ( NULL == NetlogonMailslot ) {
            try_return( Status = STATUS_NO_MEMORY );
        }

        if (!POINTER_IS_ALIGNED( NetlogonMailslot, ALIGN_DWORD) ) {
            try_return( Status = STATUS_INVALID_PARAMETER );            
        }

        Where = (PUCHAR) (NetlogonMailslot+1);

        NetlogonMailslot->TimeReceived = MailslotBuffer->TimeReceived;

        //
        // Copy the datagram to the buffer
        //

        NetlogonMailslot->MailslotMessageSize = DataCount;
        NetlogonMailslot->MailslotMessageOffset = (ULONG)(Where - (PUCHAR)NetlogonMailslot);
        RtlCopyMemory( Where, MailslotData, DataCount );

        Where += DataCount;

        //
        // Copy Client IpAddress to buffer.
        //
        if ( MailslotBuffer->ClientIpAddress != 0 ) {
            PSOCKADDR_IN SockAddrIn;

            *Where = 0;
            *(Where+1) = 0;
            *(Where+2) = 0;
            Where = ROUND_UP_POINTER( Where, ALIGN_DWORD );

            NetlogonMailslot->ClientSockAddrSize = sizeof(SOCKADDR_IN);
            NetlogonMailslot->ClientSockAddrOffset = (ULONG)(Where - (PUCHAR)NetlogonMailslot);

            SockAddrIn = (PSOCKADDR_IN) Where;
            RtlZeroMemory( SockAddrIn, sizeof(SOCKADDR_IN) );
            SockAddrIn->sin_family = AF_INET;
            SockAddrIn->sin_addr.S_un.S_addr = MailslotBuffer->ClientIpAddress;

            Where += sizeof(SOCKADDR_IN);

        } else {
            NetlogonMailslot->ClientSockAddrSize = 0;
            NetlogonMailslot->ClientSockAddrOffset = 0;
        }

        //
        // Copy the transport name to the buffer
        //

        *Where = 0;
        Where = ROUND_UP_POINTER( Where, ALIGN_WCHAR );
        NetlogonMailslot->TransportNameSize = TransportName.Length;
        NetlogonMailslot->TransportNameOffset = (ULONG)(Where - (PUCHAR)NetlogonMailslot);

        RtlCopyMemory( Where, TransportName.Buffer, TransportName.Length );
        Where += TransportName.Length;
        *((PWCH)Where) = L'\0';
        Where += sizeof(WCHAR);

        //
        // Copy the mailslot name to the buffer
        //

        NetlogonMailslot->MailslotNameSize = MailslotNameU.Length;
        NetlogonMailslot->MailslotNameOffset = (ULONG)(Where - (PUCHAR)NetlogonMailslot);

        RtlCopyMemory( Where, MailslotNameU.Buffer, MailslotNameU.Length );
        Where += MailslotNameU.Length;
        *((PWCH)Where) = L'\0';
        Where += sizeof(WCHAR);


        //
        // Copy the destination netbios name to the buffer
        //

        NetlogonMailslot->DestinationNameSize = DestinationName.Length;
        NetlogonMailslot->DestinationNameOffset = (ULONG)(Where - (PUCHAR)NetlogonMailslot);

        RtlCopyMemory( Where, DestinationName.Buffer, DestinationName.Length );
        Where += DestinationName.Length;
        *((PWCH)Where) = L'\0';
        Where += sizeof(WCHAR);


        Status = STATUS_SUCCESS;

try_exit:NOTHING;
    } finally {


        //
        // Free Locally allocated buffers
        //

        RtlFreeUnicodeString(&MailslotNameU);

        //
        // Always free the incoming mailslot message
        //

        BowserFreeMailslotBuffer( MailslotBuffer );

    }

    BowserDereferenceDiscardableCode( BowserNetlogonDiscardableCodeSection );
    return Status;
}

NTSTATUS
BowserCopyPnp(
    IN PIRP Irp,
    IN NETLOGON_PNP_OPCODE NlPnpOpcode,
    IN PUNICODE_STRING HostedDomainName,
    IN PUNICODE_STRING TransportName,
    IN ULONG TransportFlags
    )
/*++

Routine Description:

    This routine copies the data for a PNP notification into the
    IRP for the I/O request.

Arguments:

    Irp - IRP for the IOCTL from the service.

    NlPnpOpcode - Opcode describing the event being notified.

    HostedDomainName - Name of the hosted domain this event applies to

    TransportName - Name of transport being affected.

    TransportFlags - Flags describing the transport

Return Value:

    Status of the operation.

    The caller should complete the I/O operation with this status code.

--*/
{
    NTSTATUS Status;

    PNETLOGON_MAILSLOT NetlogonMailslot;
    PUCHAR Where;

    PIO_STACK_LOCATION IrpSp;

    BowserReferenceDiscardableCode( BowserDiscardableCodeSection );

    DISCARDABLE_CODE( BowserDiscardableCodeSection );


    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    try {

        //
        // Ensure the data fits in the user's output buffer.
        //

        if ( IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
             sizeof(NETLOGON_MAILSLOT) +             // Header structure
             TransportName->Length + sizeof(WCHAR) + // TransportName
             HostedDomainName->Length + sizeof(WCHAR) + // DomainName
             1 ) {           // possible rounding requirement

            try_return( Status = STATUS_BUFFER_TOO_SMALL );
        }


        //
        // Get the address of service's buffer and fill in common portion.
        //

        NetlogonMailslot = MmGetSystemAddressForMdl( Irp->MdlAddress );

        if ( NULL == NetlogonMailslot ) {
            try_return( Status = STATUS_NO_MEMORY );
        }

        if (!POINTER_IS_ALIGNED( NetlogonMailslot, ALIGN_DWORD) ) {
            try_return( Status = STATUS_INVALID_PARAMETER );            
        }

        RtlZeroMemory( NetlogonMailslot, sizeof(NETLOGON_MAILSLOT));

        //
        // Copy the opcode
        //

        NetlogonMailslot->MailslotNameOffset = NlPnpOpcode;

        //
        // Copy the transport flags.
        //

        NetlogonMailslot->MailslotMessageOffset = TransportFlags;

        //
        // Copy the transport name to the buffer
        //

        Where = (PUCHAR) (NetlogonMailslot+1);
        *Where = 0;
        Where = ROUND_UP_POINTER( Where, ALIGN_WCHAR );

        NetlogonMailslot->TransportNameSize = TransportName->Length;
        NetlogonMailslot->TransportNameOffset = (ULONG)(Where - (PUCHAR)NetlogonMailslot);

        RtlCopyMemory( Where, TransportName->Buffer, TransportName->Length );
        Where += TransportName->Length;
        *((PWCH)Where) = L'\0';
        Where += sizeof(WCHAR);

        //
        // Copy the hosted domain name to the buffer
        //

        NetlogonMailslot->DestinationNameSize = HostedDomainName->Length;
        NetlogonMailslot->DestinationNameOffset = (ULONG)(Where - (PUCHAR)NetlogonMailslot);

        RtlCopyMemory( Where, HostedDomainName->Buffer, HostedDomainName->Length );
        Where += HostedDomainName->Length;
        *((PWCH)Where) = L'\0';
        Where += sizeof(WCHAR);


        Status = STATUS_SUCCESS;

try_exit:NOTHING;
    } finally {

        BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );

    }
    return Status;
}


VOID
BowserTrimMessageQueue (
    PBROWSER_PNP_STATE BrPnp
    )

/*++

Routine Description:

    This routines ensures there are not too many mailslot messages in
    the message queue.  Any excess messages are deleted.

Arguments:

    BrPnp - Indicates which message queue to trim

Return Value:

    None.

--*/

{
    KIRQL OldIrql;

    dprintf(DPRT_NETLOGON, ("Bowser: trim message queue to %ld\n", BrPnp->MaxMessageCount ));

    //
    //
    BowserReferenceDiscardableCode( BowserDiscardableCodeSection );

    DISCARDABLE_CODE( BowserDiscardableCodeSection );

    //
    // If too many messages are queued,
    //  delete the oldest messages.
    //

    ACQUIRE_SPIN_LOCK(&BowserMailslotSpinLock, &OldIrql);
    while ( BrPnp->CurrentMessageCount > BrPnp->MaxMessageCount){
        PLIST_ENTRY Entry;
        PMAILSLOT_BUFFER MailslotBuffer;

        Entry = RemoveHeadList(&BrPnp->MailslotMessageQueue);
        BrPnp->CurrentMessageCount--;
        MailslotBuffer = CONTAINING_RECORD(Entry, MAILSLOT_BUFFER, Overlay.NextBuffer);

        RELEASE_SPIN_LOCK(&BowserMailslotSpinLock, OldIrql);
        BowserFreeMailslotBuffer( MailslotBuffer );
        ACQUIRE_SPIN_LOCK(&BowserMailslotSpinLock, &OldIrql);

    }

    //
    // If absolutely no queued messages are allowed,
    //  delete the queued PNP messages, too.
    //  (Either netlogon or the bowser is shutting down.)
    //
    if ( BrPnp->MaxMessageCount == 0 ) {
        while ( !IsListEmpty(&BrPnp->PnpQueue) ) {
            PLIST_ENTRY ListEntry;
            PBR_PNP_MESSAGE PnpMessage;

            ListEntry = RemoveHeadList(&BrPnp->PnpQueue);

            PnpMessage = CONTAINING_RECORD(ListEntry, BR_PNP_MESSAGE, Next);

            RELEASE_SPIN_LOCK(&BowserMailslotSpinLock, OldIrql);
            FREE_POOL(PnpMessage);
            ACQUIRE_SPIN_LOCK(&BowserMailslotSpinLock, &OldIrql);
        }
    }
    RELEASE_SPIN_LOCK(&BowserMailslotSpinLock, OldIrql);
    BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );

}


VOID
BowserNetlogonDeleteTransportFromMessageQueue (
    PTRANSPORT Transport
    )

/*++

Routine Description:

    This routines removes queued mailslot messages that arrived on the specified
    transport.

Arguments:

    Transport - Transport who's mailslot messages are to be deleted.

Return Value:

    None.

--*/

{
    KIRQL OldIrql;
    PLIST_ENTRY ListEntry;
    PBROWSER_PNP_STATE BrPnp=&BowserPnp[NETLOGON_PNP];

    dprintf(DPRT_NETLOGON, ("Bowser: remove messages queued by transport %lx\n", Transport ));

    //
    //
    BowserReferenceDiscardableCode( BowserNetlogonDiscardableCodeSection );

    DISCARDABLE_CODE( BowserNetlogonDiscardableCodeSection );

    //
    // Loop through all of the queued messages.
    //

    ACQUIRE_SPIN_LOCK(&BowserMailslotSpinLock, &OldIrql);
    for ( ListEntry = BrPnp->MailslotMessageQueue.Flink;
          ListEntry != &BrPnp->MailslotMessageQueue;
          ) {

        PMAILSLOT_BUFFER MailslotBuffer;

        //
        // If the message wasn't queued by this transport,
        //  go on to the next entry.
        //

        MailslotBuffer = CONTAINING_RECORD(ListEntry, MAILSLOT_BUFFER, Overlay.NextBuffer);

        if ( MailslotBuffer->TransportName->Transport != Transport ) {
            ListEntry = ListEntry->Flink;

        //
        // Otherwise,
        //  delete the entry.
        //

        } else {

            dprintf(DPRT_ALWAYS, ("Bowser: removing message %lx queued by transport %lx\n", MailslotBuffer, Transport ));
            RemoveEntryList( ListEntry );
            BrPnp->CurrentMessageCount--;

            RELEASE_SPIN_LOCK(&BowserMailslotSpinLock, OldIrql);
            BowserFreeMailslotBuffer( MailslotBuffer );
            ACQUIRE_SPIN_LOCK(&BowserMailslotSpinLock, &OldIrql);

            //
            // Start over at the beginning of the list since we dropped the spinlock.
            //

            ListEntry = BrPnp->MailslotMessageQueue.Flink;

        }

    }
    RELEASE_SPIN_LOCK(&BowserMailslotSpinLock, OldIrql);
    BowserDereferenceDiscardableCode( BowserNetlogonDiscardableCodeSection );

}

BOOLEAN
BowserProcessNetlogonMailslotWrite(
    IN PMAILSLOT_BUFFER MailslotBuffer
    )
/*++

Routine Description:

    This routine checks to see if the described mailslot message is destined
    to the Netlogon service and if the Bowser is currently handling such
    messages

Arguments:

    MailslotBuffer - Buffer describing the mailslot message.

Return Value:

    TRUE - iff the mailslot message was successfully queued to the netlogon
        service.

--*/
{
    KIRQL OldIrql;
    NTSTATUS Status;

    PSMB_HEADER SmbHeader;
    PSMB_TRANSACT_MAILSLOT MailslotSmb;
    BOOLEAN TrimIt;
    BOOLEAN ReturnValue;
    PBROWSER_PNP_STATE BrPnp=&BowserPnp[NETLOGON_PNP];

    PIRP Irp;

    BowserReferenceDiscardableCode( BowserNetlogonDiscardableCodeSection );

    DISCARDABLE_CODE( BowserNetlogonDiscardableCodeSection );

    //
    // If this message isn't destined to the Netlogon service,
    //  just return.
    //

    SmbHeader = (PSMB_HEADER )MailslotBuffer->Buffer;
    MailslotSmb = (PSMB_TRANSACT_MAILSLOT)(SmbHeader+1);

    if ( _stricmp( MailslotSmb->Buffer, NETLOGON_LM_MAILSLOT_A ) != 0 &&
         _stricmp( MailslotSmb->Buffer, NETLOGON_NT_MAILSLOT_A ) != 0 ) {

        ReturnValue = FALSE;

    //
    // The mailslot message is destined to netlogon.
    //

    } else {

        //
        // Check to ensure we're queuing messages to Netlogon
        //

        ACQUIRE_SPIN_LOCK(&BowserMailslotSpinLock, &OldIrql);
        if ( BrPnp->MaxMessageCount == 0 ) {
            RELEASE_SPIN_LOCK(&BowserMailslotSpinLock, OldIrql);
            ReturnValue = FALSE;

        //
        // Queueing to netlogon is enabled.
        //

        } else {

            //
            // If there already is an IRP from netlogon queued,
            //  return this mailslot message to netlogon now.
            //
            //  This routine locks BowserIrpQueueSpinLock so watch the spin lock
            //  locking order.
            //

            ReturnValue = TRUE;

            Irp = BowserDequeueQueuedIrp( &BrPnp->IrpQueue );

            if ( Irp != NULL ) {

                ASSERT( IsListEmpty( &BrPnp->MailslotMessageQueue ) );
                dprintf(DPRT_NETLOGON, ("Bowser: found already queued netlogon IRP\n"));

                RELEASE_SPIN_LOCK(&BowserMailslotSpinLock, OldIrql);

                Status = BowserNetlogonCopyMessage( Irp, MailslotBuffer );

                BowserCompleteRequest( Irp, Status );

            } else {

                //
                // Queue the mailslot message for netlogon to pick up later.
                //

                InsertTailList( &BrPnp->MailslotMessageQueue,
                                &MailslotBuffer->Overlay.NextBuffer);

                BrPnp->CurrentMessageCount++;

                TrimIt =
                    (BrPnp->CurrentMessageCount > BrPnp->MaxMessageCount);


                RELEASE_SPIN_LOCK(&BowserMailslotSpinLock, OldIrql);

                //
                // If there are too many messages queued,
                //  trim entries from the front.
                //

                if ( TrimIt ) {
                    BowserTrimMessageQueue(BrPnp);
                }
            }
        }
    }

    BowserDereferenceDiscardableCode( BowserNetlogonDiscardableCodeSection );
    return ReturnValue;
}

VOID
BowserSendPnp(
    IN NETLOGON_PNP_OPCODE NlPnpOpcode,
    IN PUNICODE_STRING HostedDomainName OPTIONAL,
    IN PUNICODE_STRING TransportName OPTIONAL,
    IN ULONG TransportFlags
    )
/*++

Routine Description:

    This routine sends a PNP notification to the Netlogon service.

Arguments:

    NlPnpOpcode - Opcode describing the event being notified.

    HostedDomainName - Hosted domain name
        NULL - if the operation affects all hosted domains

    TransportName - Name of transport being affected.
        NULL - if the operation affects all transports

    TransportFlags - Flags describing the transport

Return Value:

    None.

--*/
{
    KIRQL OldIrql;
    NTSTATUS Status;

    PIRP Irp;
    PBR_PNP_MESSAGE PnpMessage = NULL;
    PBROWSER_PNP_STATE BrPnp;
    UNICODE_STRING NullUnicodeString = { 0, 0, NULL };

    BowserReferenceDiscardableCode( BowserDiscardableCodeSection );
    DISCARDABLE_CODE( BowserDiscardableCodeSection );

    //
    // Initialization.
    //

    if ( TransportName == NULL ) {
        TransportName = &NullUnicodeString;
    }

    if ( HostedDomainName == NULL ) {
        HostedDomainName = &NullUnicodeString;
    }


    //
    // Send the PNP message to each service that wants it.
    //

    for ( BrPnp=&BowserPnp[0];
          BrPnp<&BowserPnp[BOWSER_PNP_COUNT];
          BrPnp++) {

        //
        // If this service doesn't want notification,
        //  skip it.
        //

        if ( BrPnp->MaxMessageCount == 0 ) {
            continue;
        }



        //
        // Preallocate the buffer since we can't do it under the spinlock.
        //

        if ( PnpMessage == NULL ) {
            PnpMessage = ALLOCATE_POOL( NonPagedPool,
                                    sizeof(BR_PNP_MESSAGE) +
                                        TransportName->Length +
                                        HostedDomainName->Length,
                                    POOL_NETLOGON_BUFFER);

            //
            // Copy the parameters into the newly allocated buffer.
            //

            if ( PnpMessage != NULL ) {
                LPBYTE Where;
                PnpMessage->NlPnpOpcode = NlPnpOpcode;
                PnpMessage->TransportFlags = TransportFlags;
                Where = (LPBYTE)(PnpMessage + 1);

                // Copy the TransportName
                PnpMessage->TransportName.MaximumLength =
                    PnpMessage->TransportName.Length = TransportName->Length;
                PnpMessage->TransportName.Buffer = (LPWSTR) Where;
                RtlCopyMemory( Where,
                               TransportName->Buffer,
                               TransportName->Length );
                Where += TransportName->Length;

                // Copy the HostedDomainName
                PnpMessage->HostedDomainName.MaximumLength =
                    PnpMessage->HostedDomainName.Length = HostedDomainName->Length;
                PnpMessage->HostedDomainName.Buffer = (LPWSTR) Where;
                RtlCopyMemory( Where,
                               HostedDomainName->Buffer,
                               HostedDomainName->Length );
                Where += HostedDomainName->Length;
            }

        }

        //
        // Check to ensure we're queuing messages to this service.
        //

        ACQUIRE_SPIN_LOCK(&BowserMailslotSpinLock, &OldIrql);
        if ( BrPnp->MaxMessageCount == 0 ) {
            RELEASE_SPIN_LOCK(&BowserMailslotSpinLock, OldIrql);

        //
        // Queueing to service is enabled.
        //

        } else {

            //
            // If there already is an IRP from the service queued,
            //  return this PNP message to the service now.
            //
            //  This routine locks BowserIrpQueueSpinLock so watch the spin lock
            //  locking order.
            //

            Irp = BowserDequeueQueuedIrp( &BrPnp->IrpQueue );

            if ( Irp != NULL ) {

                ASSERT( IsListEmpty( &BrPnp->MailslotMessageQueue ) );
                dprintf(DPRT_NETLOGON, ("Bowser: found already queued netlogon IRP\n"));

                RELEASE_SPIN_LOCK(&BowserMailslotSpinLock, OldIrql);

                Status = BowserCopyPnp( Irp, NlPnpOpcode, HostedDomainName, TransportName, TransportFlags );

                BowserCompleteRequest( Irp, Status );

            } else {

                //
                // Queue the mailslot message for the service to pick up later.
                //  (Drop notification on the floor if there is no memory.)
                //

                if ( PnpMessage != NULL ) {
                    InsertTailList( &BrPnp->PnpQueue, &PnpMessage->Next );
                    PnpMessage = NULL;
                }

                RELEASE_SPIN_LOCK(&BowserMailslotSpinLock, OldIrql);
            }
        }
    }

    //
    // Free the PnpMessage buffer if we didn't need it.
    //

    if ( PnpMessage != NULL ) {
        FREE_POOL(PnpMessage);
    }

    BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );
    return;
}

NTSTATUS
BowserEnablePnp (
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG ServiceIndex
    )

/*++

Routine Description:

    This routine processes an IOCTL from the netlogon service to enable or
    disable the queueing of netlogon mailslot messages.

Arguments:

    InputBuffer - Specifies the number of mailslot messages to queue.
        Zero disables queuing.

    ServiceIndex - Index of service to set queue size for.

Return Value:

    Status of operation.

Please note that this IRP is cancelable.

--*/

{
    KIRQL OldIrql;
    NTSTATUS Status;
    ULONG MaxMessageCount;
    PBROWSER_PNP_STATE BrPnp=&BowserPnp[ServiceIndex];

    BowserReferenceDiscardableCode( BowserDiscardableCodeSection );

    DISCARDABLE_CODE( BowserDiscardableCodeSection );


    try {

        MaxMessageCount = InputBuffer->Parameters.NetlogonMailslotEnable.MaxMessageCount;
        dprintf(DPRT_NETLOGON,
                ("NtDeviceIoControlFile: Netlogon enable %ld\n",
                MaxMessageCount ));

        //
        // Set the new size of the message queue
        //

        ACQUIRE_SPIN_LOCK(&BowserMailslotSpinLock, &OldIrql);
        BrPnp->MaxMessageCount = MaxMessageCount;
        RELEASE_SPIN_LOCK(&BowserMailslotSpinLock, OldIrql);

        //
        // Trim the message queue to the new size.
        //
        BowserTrimMessageQueue(BrPnp);

        try_return(Status = STATUS_SUCCESS);

try_exit:NOTHING;
    } finally {
        BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );

    }

    return Status;

}


NTSTATUS
BowserReadPnp (
    IN PIRP Irp,
    IN ULONG OutputBufferLength,
    IN ULONG ServiceIndex
    )

/*++

Routine Description:

    This routine processes an IOCTL from the netlogon service to get the next
    mailslot message.

Arguments:

    Irp - I/O request packet describing request.

    ServiceIndex - Index of service to set queue size for.

Return Value:

    Status of operation.

Please note that this IRP is cancelable.


--*/

{
    KIRQL OldIrql;
    NTSTATUS Status;
    PBROWSER_PNP_STATE BrPnp=&BowserPnp[ServiceIndex];

    //
    // If this is Netlogon,
    //  page in BowserNetlogonCopyMessage.
    //

    if ( ServiceIndex == NETLOGON_PNP ) {
        BowserReferenceDiscardableCode( BowserNetlogonDiscardableCodeSection );
        DISCARDABLE_CODE( BowserNetlogonDiscardableCodeSection );
    }

    //
    // Reference the discardable code of this routine and
    //  BowserQueueNonBufferRequestReferenced()
    //

    BowserReferenceDiscardableCode( BowserDiscardableCodeSection );
    DISCARDABLE_CODE( BowserDiscardableCodeSection );

    //
    // Ensure service has asked the browser to queue messages
    //

    ACQUIRE_SPIN_LOCK(&BowserMailslotSpinLock, &OldIrql);
    if ( BrPnp->MaxMessageCount == 0 ) {
        dprintf(DPRT_NETLOGON, ("Bowser called from Netlogon when not enabled\n"));
        RELEASE_SPIN_LOCK(&BowserMailslotSpinLock, OldIrql);
        Status = STATUS_NOT_SUPPORTED;

    //
    // If there already is a PNP message queued,
    //  just return it to netlogon immediately.
    //

    } else if ( !IsListEmpty( &BrPnp->PnpQueue )) {
        PBR_PNP_MESSAGE PnpMessage;
        PLIST_ENTRY ListEntry;

        dprintf(DPRT_NETLOGON, ("Bowser found netlogon PNP message already queued\n"));

        ListEntry = RemoveHeadList(&BrPnp->PnpQueue);

        PnpMessage = CONTAINING_RECORD(ListEntry, BR_PNP_MESSAGE, Next);

        RELEASE_SPIN_LOCK(&BowserMailslotSpinLock, OldIrql);

        Status = BowserCopyPnp( Irp,
                                PnpMessage->NlPnpOpcode,
                                &PnpMessage->HostedDomainName,
                                &PnpMessage->TransportName,
                                PnpMessage->TransportFlags );

        FREE_POOL(PnpMessage);

    //
    // If there already is a mailslot message queued,
    //  just return it to netlogon immediately.
    //

    } else if ( ServiceIndex == NETLOGON_PNP &&
                !IsListEmpty( &BrPnp->MailslotMessageQueue )) {
        PMAILSLOT_BUFFER MailslotBuffer;
        PLIST_ENTRY ListEntry;

        dprintf(DPRT_NETLOGON, ("Bowser found netlogon mailslot message already queued\n"));

        ListEntry = RemoveHeadList(&BrPnp->MailslotMessageQueue);
        BrPnp->CurrentMessageCount--;

        MailslotBuffer = CONTAINING_RECORD(ListEntry, MAILSLOT_BUFFER, Overlay.NextBuffer);

        RELEASE_SPIN_LOCK(&BowserMailslotSpinLock, OldIrql);

        Status = BowserNetlogonCopyMessage( Irp, MailslotBuffer );

    //
    // Otherwise, save this IRP until a mailslot message arrives.
    //  This routine locks BowserIrpQueueSpinLock so watch the spin lock
    //  locking order.
    //

    } else {

        dprintf(DPRT_NETLOGON, ("Bowser: queue netlogon mailslot irp\n"));

        Status = BowserQueueNonBufferRequestReferenced(
                    Irp,
                    &BrPnp->IrpQueue,
                    BowserCancelQueuedRequest );

        RELEASE_SPIN_LOCK(&BowserMailslotSpinLock, OldIrql);
    }

    if ( ServiceIndex == NETLOGON_PNP ) {
        BowserDereferenceDiscardableCode( BowserNetlogonDiscardableCodeSection );
    }
    BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );

    return Status;

}

VOID
BowserProcessMailslotWrite(
    IN PVOID Context
    )
/*++

Routine Description:

    This routine performs all the task time operations to perform a mailslot
    write.

    It will open the mailslot, write the specified data into the mailslot,
    and close the mailslot.

Arguments:

    IN PWORK_HEADER WorkHeader - Specifies the mailslot buffer holding the
                                    mailslot write


Return Value:

    None.

--*/
{
    PSMB_HEADER SmbHeader;
    PSMB_TRANSACT_MAILSLOT MailslotSmb;
    PMAILSLOT_BUFFER MailslotBuffer = Context;
    PUCHAR MailslotData;
    HANDLE MailslotHandle = NULL;
    OBJECT_ATTRIBUTES ObjAttr;
    OEM_STRING MailslotNameA;
    UNICODE_STRING MailslotNameU;
    IO_STATUS_BLOCK IoStatusBlock;
    CHAR MailslotName[MAXIMUM_FILENAME_LENGTH+1];
    NTSTATUS Status;
    ULONG DataCount;
    ULONG TotalDataCount;

    PAGED_CODE();

    ASSERT (MailslotBuffer->Signature == STRUCTURE_SIGNATURE_MAILSLOT_BUFFER);

    SmbHeader = (PSMB_HEADER )MailslotBuffer->Buffer;

    ASSERT (SmbHeader->Command == SMB_COM_TRANSACTION);

    MailslotSmb = (PSMB_TRANSACT_MAILSLOT)(SmbHeader+1);

    ASSERT (MailslotSmb->WordCount == 17);

    ASSERT (MailslotSmb->Class == 2);

    MailslotData = (((PCHAR )SmbHeader) + SmbGetUshort(&MailslotSmb->DataOffset));

    DataCount = (ULONG)SmbGetUshort(&MailslotSmb->DataCount);

    TotalDataCount = (ULONG)SmbGetUshort(&MailslotSmb->TotalDataCount);

    //
    //  Verify that all of the data was received and that the indicated data doesn't
    //     overflow the received buffer.
    //

    if (TotalDataCount != DataCount ||
        (MailslotData > MailslotBuffer->Buffer + MailslotBuffer->ReceiveLength) ||
        (DataCount + SmbGetUshort(&MailslotSmb->DataOffset) > MailslotBuffer->ReceiveLength )) {

        BowserLogIllegalDatagram(MailslotBuffer->TransportName,
                                 SmbHeader,
                                 (USHORT)MailslotBuffer->ReceiveLength,
                                 MailslotBuffer->ClientAddress,
                                 0);

        BowserFreeMailslotBuffer(MailslotBuffer);
        return;
    }

    MailslotNameU.MaximumLength = MAXIMUM_FILENAME_LENGTH*sizeof(WCHAR)+sizeof(WCHAR);

#define DEVICE_PREFIX_LENGTH 7
    strcpy(MailslotName, "\\Device");

    strncpy( MailslotName+DEVICE_PREFIX_LENGTH,
             MailslotSmb->Buffer,
             sizeof(MailslotName)-DEVICE_PREFIX_LENGTH);
    MailslotName[sizeof(MailslotName)-1] = '\0';

    RtlInitString(&MailslotNameA, MailslotName);

    //
    // Handle netlogon mailslot messages specially.
    //  Don't call the discardable code at all if netlogon isn't running
    //

    if ( BowserPnp[NETLOGON_PNP].MaxMessageCount != 0 &&
         BowserProcessNetlogonMailslotWrite( MailslotBuffer ) ) {
        return;
    }

    //
    // Write the mailslot message to the mailslot
    //

    try {
        Status = RtlOemStringToUnicodeString(&MailslotNameU, &MailslotNameA, TRUE);

        if (!NT_SUCCESS(Status)) {
            BowserLogIllegalName( Status, MailslotNameA.Buffer, MailslotNameA.Length );
            try_return(NOTHING);
        }

        InitializeObjectAttributes(&ObjAttr,
                                &MailslotNameU,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL);

        Status = NtCreateFile(&MailslotHandle, // Handle
                                GENERIC_WRITE | SYNCHRONIZE,
                                &ObjAttr, // Object Attributes
                                &IoStatusBlock, // Final I/O status block
                                NULL,           // Allocation Size
                                FILE_ATTRIBUTE_NORMAL, // Normal attributes
                                FILE_SHARE_READ|FILE_SHARE_WRITE,// Sharing attributes
                                FILE_OPEN, // Create disposition
                                0,      // CreateOptions
                                NULL,   // EA Buffer
                                0);     // EA Length


        RtlFreeUnicodeString(&MailslotNameU);

        //
        //  If the mailslot doesn't exist, ditch the request -
        //
        if (!NT_SUCCESS(Status)) {
            BowserStatistics.NumberOfFailedMailslotOpens += 1;

            try_return(NOTHING);
        }

        //
        //  Now that the mailslot is opened, write the mailslot data into
        //  the mailslot.
        //

        Status = NtWriteFile(MailslotHandle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatusBlock,
                            MailslotData,
                            DataCount,
                            NULL,
                            NULL);

        if (!NT_SUCCESS(Status)) {
            BowserStatistics.NumberOfFailedMailslotWrites += 1;
        } else {
            BowserStatistics.NumberOfMailslotWrites += 1;
        }

try_exit:NOTHING;
    } finally {

        //
        //  If we opened the mailslot, close it.
        //

        if (MailslotHandle != NULL) {
            ZwClose(MailslotHandle);
        }

        //
        //  Free the mailslot buffer holding this mailslot.
        //

        BowserFreeMailslotBuffer(MailslotBuffer);

    }
}


PMAILSLOT_BUFFER
BowserAllocateMailslotBuffer(
    IN PTRANSPORT_NAME TransportName,
    IN ULONG RequestedBufferSize
    )
/*++

Routine Description:

    This routine will allocate a mailslot buffer from the mailslot buffer pool.

    If it is unable to allocate a buffer, it will allocate the buffer from
    non-paged pool (up to the maximum configured by the user).


Arguments:

    TransportName - The transport name for this request.

    RequestedBufferSize - Minimum size of buffer to allocate.

Return Value:

    MAILSLOT_BUFFER - The allocated buffer.

--*/
{
    KIRQL OldIrql;
    PMAILSLOT_BUFFER Buffer     = NULL;
    ULONG BufferSize;
    BOOLEAN AllocatingMaxBuffer = FALSE;



    //
    // If the request fits into a cached buffer,
    //  and there is a cache buffer available,
    //  use it.
    //

    ACQUIRE_SPIN_LOCK(&BowserMailslotSpinLock, &OldIrql);
    if ( RequestedBufferSize <= BOWSER_MAX_DATAGRAM_SIZE &&
         !IsListEmpty(&BowserMailslotBufferList)) {
        PMAILSLOT_BUFFER Buffer;
        PLIST_ENTRY Entry;

        Entry = RemoveHeadList(&BowserMailslotBufferList);
        BowserNumberOfFreeMailslotBuffers --;

        Buffer = CONTAINING_RECORD(Entry, MAILSLOT_BUFFER, Overlay.NextBuffer);

#if DBG
        BowserMailslotCacheHitCount++;
#endif // DBG
        RELEASE_SPIN_LOCK(&BowserMailslotSpinLock, OldIrql);

        Buffer->TransportName = TransportName;
        BowserReferenceTransportName(TransportName);
        BowserReferenceTransport( TransportName->Transport );

        return Buffer;
    }

    //
    // If we've got too many buffers allocated,
    //  don't allocate any more.
    //
    // BowserData.NumberOfMailslotBuffers is the maximum number we're allowed to have
    //  in the cache at once.  It defaults to 3.
    //
    // BrPnp[NETLOGON].MaxMessageCount is the number of buffers the netlogon service may
    //  have queued at any one point in time.  It may be zero when netlogon isn't
    //  running or if we're running on a non-DC.  On DC's it defaults to 500.
    //
    // Add 50, to ensure we don't limit it by too much.
    //

    if ( (ULONG)BowserNumberOfMailslotBuffers >=
         max( (ULONG)BowserData.NumberOfMailslotBuffers, BowserPnp[NETLOGON_PNP].MaxMessageCount+50 )) {

        BowserStatistics.NumberOfMissedMailslotDatagrams += 1;
        BowserNumberOfMissedMailslotDatagrams += 1;
        RELEASE_SPIN_LOCK(&BowserMailslotSpinLock, OldIrql);
        return NULL;
    }

    //
    // The first few buffers we allocate should be maximum size so we can keep a preallocated
    //  cache of huge buffers.
    //

    if ( BowserNumberOfMaxSizeMailslotBuffers < BowserData.NumberOfMailslotBuffers &&
         RequestedBufferSize <= BOWSER_MAX_DATAGRAM_SIZE ) {
        BufferSize = FIELD_OFFSET(MAILSLOT_BUFFER, Buffer) + BOWSER_MAX_DATAGRAM_SIZE;
        AllocatingMaxBuffer = TRUE;
        BowserNumberOfMaxSizeMailslotBuffers += 1;
    } else {
        BufferSize = FIELD_OFFSET(MAILSLOT_BUFFER, Buffer) + RequestedBufferSize;
    }

    BowserNumberOfMailslotBuffers += 1;

    ASSERT ( (BufferSize - FIELD_OFFSET(MAILSLOT_BUFFER, Buffer)) <= 0xffff);

#if DBG
    BowserMailslotCacheMissCount++;
#endif // DBG

    RELEASE_SPIN_LOCK(&BowserMailslotSpinLock, OldIrql);

    Buffer = ALLOCATE_POOL(NonPagedPool, BufferSize, POOL_MAILSLOT_BUFFER);

    //
    //  If we couldn't allocate the buffer from non paged pool, give up.
    //

    if (Buffer == NULL) {
        ACQUIRE_SPIN_LOCK(&BowserMailslotSpinLock, &OldIrql);

        ASSERT (BowserNumberOfMailslotBuffers);

        BowserNumberOfMailslotBuffers -= 1;
        if ( AllocatingMaxBuffer ) {
            BowserNumberOfMaxSizeMailslotBuffers -= 1;
        }

        RELEASE_SPIN_LOCK(&BowserMailslotSpinLock, OldIrql);

        BowserStatistics.NumberOfFailedMailslotAllocations += 1;

        //
        //  Since we couldn't allocate this buffer, we've effectively missed
        //  this mailslot request.
        //

        BowserStatistics.NumberOfMissedMailslotDatagrams += 1;
        BowserNumberOfMissedMailslotDatagrams += 1;

        return NULL;
    }

    Buffer->Signature = STRUCTURE_SIGNATURE_MAILSLOT_BUFFER;

    Buffer->Size = FIELD_OFFSET(MAILSLOT_BUFFER, Buffer);

    Buffer->BufferSize = BufferSize - FIELD_OFFSET(MAILSLOT_BUFFER, Buffer);

    Buffer->TransportName = TransportName;
    BowserReferenceTransportName(TransportName);
    BowserReferenceTransport( TransportName->Transport );

    return Buffer;
}

VOID
BowserFreeMailslotBuffer(
    IN PMAILSLOT_BUFFER Buffer
    )
/*++

Routine Description:

    This routine will return a mailslot buffer to the view buffer pool.

    If the buffer was allocated from must-succeed pool, it is freed back
    to pool.  In addition, if the buffer is smaller than the current
    max view buffer size, we free it.

Arguments:

    IN PVIEW_BUFFER Buffer - Supplies the buffer to free

Return Value:

    None.

--*/
{
    KIRQL OldIrql;
    PTRANSPORT Transport;

    BowserReferenceDiscardableCode( BowserDiscardableCodeSection );

    DISCARDABLE_CODE( BowserDiscardableCodeSection );

    Transport = Buffer->TransportName->Transport;
    (VOID) BowserDereferenceTransportName( Buffer->TransportName );
    BowserDereferenceTransport( Transport);

    ACQUIRE_SPIN_LOCK(&BowserMailslotSpinLock, &OldIrql);

    //
    //  Also, if a new transport was added that is larger than this buffer,
    //  we want to free the buffer.
    //

    //
    //  If we have more mailslot buffers than the size of our lookaside list,
    //  free it, don't stick it on our lookaside list.
    //

    if (Buffer->BufferSize != BOWSER_MAX_DATAGRAM_SIZE ||
        BowserNumberOfFreeMailslotBuffers > BowserData.NumberOfMailslotBuffers) {

        //
        //  Since we're returning this buffer to pool, we shouldn't count it
        //  against our total number of mailslot buffers.
        //

        BowserNumberOfMailslotBuffers -= 1;

        ASSERT (BowserNumberOfMailslotBuffers >= 0);

        RELEASE_SPIN_LOCK(&BowserMailslotSpinLock, OldIrql);

        FREE_POOL(Buffer);

        BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );

        return;
    }

    InsertTailList(&BowserMailslotBufferList, &Buffer->Overlay.NextBuffer);
    BowserNumberOfFreeMailslotBuffers ++;

    RELEASE_SPIN_LOCK(&BowserMailslotSpinLock, OldIrql);

    BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );
}

VOID
BowserFreeMailslotBufferHighIrql(
    IN PMAILSLOT_BUFFER Buffer
    )
/*++

Routine Description:

    This routine will return a mailslot buffer to the view buffer pool if the
    caller is at raised irql.

Arguments:

    Buffer - Supplies the buffer to free

Return Value:

    None.

--*/
{
    //
    // Queue the request to a worker routine.
    //
    ExInitializeWorkItem(&Buffer->Overlay.WorkHeader,
                         (PWORKER_THREAD_ROUTINE) BowserFreeMailslotBuffer,
                         Buffer);

    BowserQueueDelayedWorkItem( &Buffer->Overlay.WorkHeader );
}




VOID
BowserpInitializeMailslot (
    VOID
    )
/*++

Routine Description:

    This routine will allocate a transport descriptor and bind the bowser
    to the transport.

Arguments:

    None


Return Value:

    None

--*/
{
    PBROWSER_PNP_STATE BrPnp;

    KeInitializeSpinLock(&BowserMailslotSpinLock);

    InitializeListHead(&BowserMailslotBufferList);

    for ( BrPnp=&BowserPnp[0];
          BrPnp<&BowserPnp[BOWSER_PNP_COUNT];
          BrPnp++) {
        InitializeListHead(&BrPnp->MailslotMessageQueue);
        InitializeListHead(&BrPnp->PnpQueue);

        BowserInitializeIrpQueue( &BrPnp->IrpQueue );
    }

}

VOID
BowserpUninitializeMailslot (
    VOID
    )
/*++

Routine Description:


Arguments:

    None


Return Value:

    None

--*/
{
    PBROWSER_PNP_STATE BrPnp;
    PAGED_CODE();

    //
    // Trim the netlogon message queue to zero entries.
    //

    for ( BrPnp=&BowserPnp[0];
          BrPnp<&BowserPnp[BOWSER_PNP_COUNT];
          BrPnp++) {
        BrPnp->MaxMessageCount = 0;
        BowserTrimMessageQueue(BrPnp);
        BowserUninitializeIrpQueue( &BrPnp->IrpQueue );
    }

    //
    // Free the mailslot buffers.

    while (!IsListEmpty(&BowserMailslotBufferList)) {
        PLIST_ENTRY Entry;
        PMAILSLOT_BUFFER Buffer;

        Entry = RemoveHeadList(&BowserMailslotBufferList);
        Buffer = CONTAINING_RECORD(Entry, MAILSLOT_BUFFER, Overlay.NextBuffer);

        FREE_POOL(Buffer);

    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\bowser\init.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    init.c

Abstract:

    This module contains the initialization code of the NT browser
    File System Driver (FSD) and File System Process (FSP).


Author:

    Larry Osterman (larryo) 24-May-1990

Environment:

    Kernel mode, FSD, and FSP

Revision History:

    30-May-1990 LarryO

        Created

--*/

//
// Include modules
//

#include "precomp.h"
#pragma hdrstop

HANDLE
BowserServerAnnouncementEventHandle = {0};

PKEVENT
BowserServerAnnouncementEvent = {0};

PDOMAIN_INFO BowserPrimaryDomainInfo = NULL;


// External functions

//(fsctl.c)
NTSTATUS
StopBowser (
    IN BOOLEAN Wait,
    IN BOOLEAN InFsd,
    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    );


// Local functions

VOID
BowserReadBowserConfiguration(
    PUNICODE_STRING RegistryPath
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, BowserDriverEntry)
#pragma alloc_text(PAGE, BowserUnload)
#pragma alloc_text(INIT, BowserReadBowserConfiguration)
#endif

NTSTATUS
BowserDriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the initialization routine for the file system.  It is invoked once
    when the driver is loaded into the system.  Its job is to initialize all
    the structures which will be used by the FSD and the FSP.  It also creates
    the process from which all of the file system threads will be executed.  It
    then registers the file system with the I/O system as a valid file system
    resident in the system.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    UNICODE_STRING unicodeEventName;
    UNICODE_STRING DummyDomain;

    PDEVICE_OBJECT DeviceObject;
    OBJECT_ATTRIBUTES obja;

    PAGED_CODE();

#if DBG
    BowserInitializeTraceLog();
#endif

    //
    // Create the device object for this file system.
    //

    RtlInitUnicodeString( &BowserNameString, DD_BROWSER_DEVICE_NAME_U );

    dlog(DPRT_INIT, ("Creating device %wZ\n", &BowserNameString));


#if DBG
#define BOWSER_LOAD_BP 0
#if BOWSER_LOAD_BP
    dlog(DPRT_INIT, ("DebugBreakPoint...\n"));
    DbgBreakPoint();
#endif
#endif

    dlog(DPRT_INIT, ("DriverObject at %08lx\n", DriverObject));

    Status = IoCreateDevice( DriverObject,
              sizeof(BOWSER_FS_DEVICE_OBJECT) - sizeof(DEVICE_OBJECT),
              &BowserNameString,
              FILE_DEVICE_NETWORK_BROWSER,
              0,
              FALSE,
              &DeviceObject );

    if (!NT_SUCCESS(Status)) {
        InternalError(("Unable to create redirector device"));
    }

    dlog(DPRT_INIT, ("Device created at %08lx\n", DeviceObject));



    Status = BowserInitializeSecurity(DeviceObject);

    if (!NT_SUCCESS(Status)) {
        InternalError(("Unable to initialize security."));
    }

    dlog(DPRT_INIT, ("Initialized Browser security at %p\n", g_pBowSecurityDescriptor));


    ExInitializeResourceLite( &BowserDataResource );

    //
    // Save the device object address for this file system driver.
    //

    BowserDeviceObject = (PBOWSER_FS_DEVICE_OBJECT )DeviceObject;

    BowserReadBowserConfiguration(RegistryPath);

    DeviceObject->StackSize = (CCHAR)BowserIrpStackSize;

    dlog(DPRT_INIT, ("Stacksize is %d\n",DeviceObject->StackSize));

    //
    // Initialize the TDI package
    //

    BowserpInitializeTdi();

    //
    // Initialize the datagram buffer structures
    //

    BowserpInitializeMailslot();

    BowserInitializeFsd();

    BowserpInitializeIrpQueue();

    //
    //  Initialize the code to receive a browser server list.
    //

    BowserpInitializeGetBrowserServerList();

    //
    //  Initialize the bowser FSP.
    //

    if (!NT_SUCCESS(Status = BowserpInitializeFsp(DriverObject))) {
        return Status;
    }

    if (!NT_SUCCESS(Status = BowserpInitializeNames())) {
        return Status;
    }

#if DBG
    //
    //  If we have a preconfigured trace level, open the browser trace log
    //  right away.
    //

    if (BowserDebugLogLevel != 0) {
        BowserOpenTraceLogFile(L"\\SystemRoot\\Bowser.Log");
    }
#endif

//    //
//    //  Set up the browsers unload routine.
//    //
//
//    DriverObject->DriverUnload = BowserUnload;

    BowserInitializeDiscardableCode();


    //
    //  Set the timer up for the idle timer.
    //

    IoInitializeTimer((PDEVICE_OBJECT )BowserDeviceObject, BowserIdleTimer,
                                                NULL);



    RtlInitUnicodeString( &unicodeEventName, SERVER_ANNOUNCE_EVENT_W );
    InitializeObjectAttributes( &obja, &unicodeEventName, OBJ_OPENIF, NULL, NULL );

    Status = ZwCreateEvent(
                 &BowserServerAnnouncementEventHandle,
                 SYNCHRONIZE | EVENT_QUERY_STATE | EVENT_MODIFY_STATE,
                 &obja,
                 SynchronizationEvent,
                 FALSE
                 );

    if (NT_SUCCESS(Status)) {
        Status = ObReferenceObjectByHandle(BowserServerAnnouncementEventHandle,
                                            EVENT_MODIFY_STATE,
                                            NULL,
                                            KernelMode,
                                            &BowserServerAnnouncementEvent,
                                            NULL);
    }

    //
    // Always create a domain structure for the primary domain.
    //
    RtlInitUnicodeString( &DummyDomain, NULL );
    BowserPrimaryDomainInfo = BowserCreateDomain( &DummyDomain, &DummyDomain );

    return Status;

}


VOID
BowserUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

     This is the unload routine for the bowser device.

Arguments:

     DriverObject - pointer to the driver object for the browser driver

Return Value:

     None

--*/

{
    PAGED_CODE();

    if ( BowserData.Initialized ){

        //
        // StopBowser was never called (mem cleanup skipped etc).
        // Call it before exiting (see bug 359407).
        //

        // Fake (unused) paramters
        BOWSER_FS_DEVICE_OBJECT fsDevice;
        LMDR_REQUEST_PACKET InputBuffer;

        fsDevice.DeviceObject = *DriverObject->DeviceObject;

        // set fake input buffer. It is unused (except param check) in
        // StopBowser
        InputBuffer.Version = LMDR_REQUEST_PACKET_VERSION_DOM;


        ASSERT ((IoGetCurrentProcess() == BowserFspProcess));
        (VOID) StopBowser(
                   TRUE,
                   TRUE,
                   &fsDevice,
                   &InputBuffer,
                   sizeof(LMDR_REQUEST_PACKET) );

    }

    //
    // Ditch the global reference to the primary domain.
    //

    if ( BowserPrimaryDomainInfo != NULL ) {
        // break if we're leaking memory. StopBowser should
        // have cleaned all references.
        ASSERT ( BowserPrimaryDomainInfo->ReferenceCount == 1 );
        BowserDereferenceDomain( BowserPrimaryDomainInfo );
    }

    //
    //  Uninitialize the bowser name structures.
    //

    BowserpUninitializeNames();

    //
    //  Uninitialize the bowser FSP.
    //

    BowserpUninitializeFsp();

    //
    //  Uninitialize the routines involved in retrieving browser server lists.
    //

    BowserpUninitializeGetBrowserServerList();

    //
    //  Uninitialize the mailslot related functions.
    //

    BowserpUninitializeMailslot();

    //
    //  Uninitialize the TDI related functions.
    //

    BowserpUninitializeTdi();

    //
    //  Delete the resource protecting the bowser global data.
    //

    ExDeleteResourceLite(&BowserDataResource);

    ObDereferenceObject(BowserServerAnnouncementEvent);

    ZwClose(BowserServerAnnouncementEventHandle);

#if DBG
    BowserUninitializeTraceLog();
#endif

    //
    //  Delete the browser device object.
    //

    IoDeleteDevice((PDEVICE_OBJECT)BowserDeviceObject);

    BowserUninitializeDiscardableCode();

    return;
}

VOID
BowserReadBowserConfiguration(
    PUNICODE_STRING RegistryPath
    )
{
    ULONG Storage[256];
    UNICODE_STRING UnicodeString;
    HANDLE RedirConfigHandle;
    HANDLE ParametersHandle;
    NTSTATUS Status;
    ULONG BytesRead;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PBOWSER_CONFIG_INFO ConfigEntry;
    PKEY_VALUE_FULL_INFORMATION Value = (PKEY_VALUE_FULL_INFORMATION)Storage;

    PAGED_CODE();

    InitializeObjectAttributes(
        &ObjectAttributes,
        RegistryPath,               // name
        OBJ_CASE_INSENSITIVE,       // attributes
        NULL,                       // root
        NULL                        // security descriptor
        );

    Status = ZwOpenKey (&RedirConfigHandle, KEY_READ, &ObjectAttributes);

    if (!NT_SUCCESS(Status)) {
        BowserWriteErrorLogEntry (
            EVENT_BOWSER_CANT_READ_REGISTRY,
            Status,
            NULL,
            0,
            0
            );

        return;
    }

    RtlInitUnicodeString(&UnicodeString, BOWSER_CONFIG_PARAMETERS);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &UnicodeString,
        OBJ_CASE_INSENSITIVE,
        RedirConfigHandle,
        NULL
        );


    Status = ZwOpenKey (&ParametersHandle, KEY_READ, &ObjectAttributes);

    if (!NT_SUCCESS(Status)) {
        BowserWriteErrorLogEntry (
            EVENT_BOWSER_CANT_READ_REGISTRY,
            Status,
            NULL,
            0,
            0
            );

        ZwClose(RedirConfigHandle);

        return;
    }

    for (ConfigEntry = BowserConfigEntries;
         ConfigEntry->ConfigParameterName != NULL;
         ConfigEntry += 1) {

        RtlInitUnicodeString(&UnicodeString, ConfigEntry->ConfigParameterName);

        Status = ZwQueryValueKey(ParametersHandle,
                            &UnicodeString,
                            KeyValueFullInformation,
                            Value,
                            sizeof(Storage),
                            &BytesRead);


        if (NT_SUCCESS(Status)) {

            if (Value->DataLength != 0) {

                if (ConfigEntry->ConfigValueType == REG_BOOLEAN) {
                    if (Value->Type != REG_DWORD ||
                        Value->DataLength != REG_BOOLEAN_SIZE) {
                        BowserWriteErrorLogEntry (
                            EVENT_BOWSER_CANT_READ_REGISTRY,
                            STATUS_INVALID_PARAMETER,
                            ConfigEntry->ConfigParameterName,
                            (USHORT)(wcslen(ConfigEntry->ConfigParameterName)*sizeof(WCHAR)),
                            0
                            );

                    } else {
                        ULONG_PTR ConfigValue = (ULONG_PTR)((PCHAR)Value)+Value->DataOffset;

                        *(PBOOLEAN)(ConfigEntry->ConfigValue) = (BOOLEAN)(*((PULONG)ConfigValue) != 0);
                    }

                } else if (Value->Type != ConfigEntry->ConfigValueType ||
                    Value->DataLength != ConfigEntry->ConfigValueSize) {

                    BowserWriteErrorLogEntry (
                        EVENT_BOWSER_CANT_READ_REGISTRY,
                        STATUS_INVALID_PARAMETER,
                        ConfigEntry->ConfigParameterName,
                        (USHORT)(wcslen(ConfigEntry->ConfigParameterName)*sizeof(WCHAR)),
                        0
                        );

                } else {

                    RtlCopyMemory(ConfigEntry->ConfigValue, ((PCHAR)Value)+Value->DataOffset, Value->DataLength);
                }
            } else {
                BowserWriteErrorLogEntry (
                        EVENT_BOWSER_CANT_READ_REGISTRY,
                        STATUS_INVALID_PARAMETER,
                        ConfigEntry->ConfigParameterName,
                        (USHORT)(wcslen(ConfigEntry->ConfigParameterName)*sizeof(WCHAR)),
                        0
                        );
            }
        }

    }


    ZwClose(ParametersHandle);

    ZwClose(RedirConfigHandle);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\bowser\fspdisp.c ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    fspdisp.c

Abstract:

    This file provides the main FSP dispatch routine for the NT browser.

    It mostly provides a switch statement that calls the appropriate BowserFsp
    routine and returns that status to the caller.

Notes:
    There are two classes of browser FSP worker threads.  The first
    are what are called FSP worker threads.  These threads are responsible
    for processing NT Irp's passed onto the browser's main work thread.

    In addition to this pool of threads, there is a small pool of "generic"
    worker threads whose sole purpose is to process generic request
    operations.  These are used for processing such operations as close
    behind, etc.


Author:

    Larry Osterman (LarryO) 31-May-1990

Revision History:

    31-May-1990 LarryO

        Created

--*/

#include "precomp.h"
#pragma hdrstop


//
//  This defines the granularity of the scavenger timer.  If it is set
//  to 30 (for example), the scavenger thread will fire every 30 seconds.
//

#define SCAVENGER_TIMER_GRANULARITY 30
#define UNEXPECTED_TIMER_GRANULARITY (60 * 60 / SCAVENGER_TIMER_GRANULARITY)

//
// This counter is used to control kicking the scavenger thread.
//
ULONG
BowserTimerCounter = SCAVENGER_TIMER_GRANULARITY;


KSPIN_LOCK
BowserTimeSpinLock = {0};

VOID
BowserFspDispatch (
    IN PVOID WorkHeader
    );

VOID
BowserScavenger (
    IN PVOID WorkHeader
    );

VOID
BowserLogUnexpectedEvents(
    VOID
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, BowserFsdPostToFsp)
#pragma alloc_text(PAGE, BowserFspDispatch)
#pragma alloc_text(PAGE, BowserLogUnexpectedEvents)
#pragma alloc_text(PAGE, BowserScavenger)
#pragma alloc_text(PAGE, BowserpUninitializeFsp)
#pragma alloc_text(INIT, BowserpInitializeFsp)
#endif

NTSTATUS
BowserFsdPostToFsp(
    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine passes the IRP specified onto the FSP work queue, and kicks
    an FSP thread.   This routine accepts an I/O Request Packet (IRP) and a
    work queue and passes the request to the appropriate request queue.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.


--*/

{
    PIRP_CONTEXT IrpContext;

    PAGED_CODE();

    IrpContext = BowserAllocateIrpContext();

    if ( IrpContext == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  Mark this I/O request as being pending.
    //

    IoMarkIrpPending(Irp);

    //
    //  Queue the request to a generic worker thread.
    //

    IrpContext->Irp = Irp;

    IrpContext->DeviceObject = DeviceObject;

    ExInitializeWorkItem(&IrpContext->WorkHeader, BowserFspDispatch, IrpContext);

    ExQueueWorkItem(&IrpContext->WorkHeader, DelayedWorkQueue);

    return STATUS_PENDING;

}


VOID
BowserFspDispatch (
    IN PVOID WorkHeader
    )

/*++

Routine Description:

    BowserFspDispatch is the main dispatch routine for the NT browser's
    FSP.  It will process worker requests as queued.

Arguments:

    DeviceObject - A pointer to the browser DeviceObject

Return Value:

    None.

--*/

{
    PIRP_CONTEXT IrpContext = WorkHeader;
    PIRP Irp = IrpContext->Irp;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS Status;
    PBOWSER_FS_DEVICE_OBJECT DeviceObject = IrpContext->DeviceObject;

    PAGED_CODE();

    //
    //  We no longer need the IRP context, free it as soon as possible.
    //

    BowserFreeIrpContext(IrpContext);

    dlog(DPRT_FSPDISP, ("BowserFspDispatch: Got request, Irp = %08lx, "
            "Function = %d Aux buffer = %08lx\n", Irp, IrpSp->MajorFunction,
                                           Irp->Tail.Overlay.AuxiliaryBuffer));

    switch (IrpSp->MajorFunction) {

    case IRP_MJ_DEVICE_CONTROL:
        Status =  BowserFspDeviceIoControlFile (DeviceObject, Irp);
        break;

    case IRP_MJ_QUERY_INFORMATION:
        Status =  BowserFspQueryInformationFile (DeviceObject, Irp);
        break;

    case IRP_MJ_QUERY_VOLUME_INFORMATION:
        Status =  BowserFspQueryVolumeInformationFile (DeviceObject, Irp);
        break;

    case IRP_MJ_FILE_SYSTEM_CONTROL:
    case IRP_MJ_CREATE:
    case IRP_MJ_CLEANUP:
    case IRP_MJ_READ:
    case IRP_MJ_WRITE:
    case IRP_MJ_DIRECTORY_CONTROL:
    case IRP_MJ_SET_INFORMATION:
    case IRP_MJ_LOCK_CONTROL:
    case IRP_MJ_FLUSH_BUFFERS:
    case IRP_MJ_QUERY_EA:
    case IRP_MJ_CREATE_NAMED_PIPE:
    case IRP_MJ_CLOSE:
        Status = STATUS_INVALID_DEVICE_REQUEST;
        BowserCompleteRequest(Irp, Status);
        break;

    default:
        InternalError(("Unimplemented function %d\n", IrpSp->MajorFunction));
        Status = STATUS_NOT_IMPLEMENTED;
        BowserCompleteRequest(Irp, Status);
        break;
    }

    return;
}


VOID
BowserIdleTimer (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine implements the NT redirector's scavenger thread timer.
    It basically waits for the timer granularity and kicks the scavenger
    thread.


Arguments:

    IN PDEVICE_OBJECT DeviceObject - Supplies the device object for the timer
    IN PVOID Context - Ignored in this routine.

Return Value:

    None.

--*/

{
    KIRQL OldIrql;

    ACQUIRE_SPIN_LOCK(&BowserTimeSpinLock, &OldIrql);

    //
    //  Bump the current time counter.
    //

    BowserCurrentTime++;

    if (BowserEventLogResetFrequency != -1) {
        BowserEventLogResetFrequency -= 1;

        if (BowserEventLogResetFrequency < 0) {
            BowserEventLogResetFrequency = BowserData.EventLogResetFrequency;

            BowserIllegalDatagramCount = BowserData.IllegalDatagramThreshold;
            BowserIllegalDatagramThreshold = FALSE;

            BowserIllegalNameCount = BowserData.IllegalDatagramThreshold;
            BowserIllegalNameThreshold = FALSE;
        }
    }


    //
    //  We use the redirector's time spinlock as a convenient spinlock here.
    //

    if (BowserTimerCounter != 0) {

        BowserTimerCounter -= 1;

        if (BowserTimerCounter == 0) {
            PWORK_QUEUE_ITEM WorkHeader;

            RELEASE_SPIN_LOCK(&BowserTimeSpinLock, OldIrql);

            WorkHeader = ALLOCATE_POOL(NonPagedPool, sizeof(WORK_QUEUE_ITEM), POOL_WORKITEM);

            //
            //  If the allocation of pool fails, we simply don't queue this
            //  request to the scavenger.  The scavenger is low priority,
            //  thus it isn't a big deal to fail this request.
            //

            if (WorkHeader != NULL) {

                ExInitializeWorkItem(WorkHeader, BowserScavenger, WorkHeader);

                //
                // Due to bug 245645 we need to queue in delayed worker queue rather then execute timed tasks.
                // OLD WAY: ExQueueWorkItem(WorkHeader, DelayedWorkQueue);
                //
                BowserQueueDelayedWorkItem( WorkHeader );


            }

            //
            //  Re-acquire the spin lock to make the exit path cleaner.
            //

            ACQUIRE_SPIN_LOCK(&BowserTimeSpinLock, &OldIrql);
        }
    }

    RELEASE_SPIN_LOCK(&BowserTimeSpinLock, OldIrql);

    return;

    UNREFERENCED_PARAMETER(DeviceObject);
    UNREFERENCED_PARAMETER(Context);
}

LONG
UnexpectedEventTimer = UNEXPECTED_TIMER_GRANULARITY;

VOID
BowserLogUnexpectedEvents(
    VOID
    )
{
    LONG TimerSign;
    PAGED_CODE();

    TimerSign = InterlockedDecrement( &UnexpectedEventTimer );

    if ( TimerSign == 0) {

        if (BowserNumberOfMissedMailslotDatagrams > BowserMailslotDatagramThreshold) {
            BowserWriteErrorLogEntry(EVENT_BOWSER_MAILSLOT_DATAGRAM_THRESHOLD_EXCEEDED, STATUS_INSUFFICIENT_RESOURCES, NULL, 0, 0);
            BowserNumberOfMissedMailslotDatagrams = 0;
        }

        if (BowserNumberOfMissedGetBrowserServerListRequests > BowserGetBrowserListThreshold) {
            BowserWriteErrorLogEntry(EVENT_BOWSER_GETBROWSERLIST_THRESHOLD_EXCEEDED, STATUS_INSUFFICIENT_RESOURCES, NULL, 0, 0);
            BowserNumberOfMissedGetBrowserServerListRequests = 0;
        }

        InterlockedExchangeAdd(&UnexpectedEventTimer, UNEXPECTED_TIMER_GRANULARITY );
    }
}

VOID
BowserScavenger (
    IN PVOID Context
    )

/*++

Routine Description:

    This function implements the NT browsers's scavenger thread.  It
    performs all idle time operations such as closing out dormant connections
    etc.


Arguments:

    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject - Supplies the device object associated
            with this request.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    dlog(DPRT_SCAVTHRD, ("BowserScavenger\n"));

    //
    //  Deallocate the pool used for the work context header - we're done with
    //  it.
    //

    FREE_POOL(Context);

    //
    //  Remove old entries from the announcetable.
    //

    BowserAgeServerAnnouncements();

    //
    //  Log if any of our thresholds have been exceeded.
    //

    BowserLogUnexpectedEvents();

    //
    //  Time out any outstanding find master requests if they have taken too
    //  long.
    //

    BowserTimeoutFindMasterRequests();

    //
    //  Reset the timer counter back to the appropriate value
    //  once we have finished processing these requests.
    //

    ExInterlockedAddUlong(&BowserTimerCounter, SCAVENGER_TIMER_GRANULARITY, &BowserTimeSpinLock);

}


NTSTATUS
BowserpInitializeFsp (
    PDRIVER_OBJECT BowserDriverObject
    )

/*++

Routine Description:

    This routine initializes the FSP specific components and dispatch
    routines.

Arguments:

    None.

Return Value:

    None.

--*/

{
#if 0
    USHORT i;

    //
    // Initialize the driver object with this driver's entry points.
    //
    // By default, pass all requests to the FSD.
    //

    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {
        BowserDriverObject->MajorFunction[i] = (PDRIVER_DISPATCH)BowserFsdPostToFsp;
    }

    //
    //  Initialize those request that are to be performed in the FSD, not
    //  in the FSP.
    //

    BowserDriverObject->MajorFunction[IRP_MJ_CREATE] =
            (PDRIVER_DISPATCH )BowserFsdCreate;

    BowserDriverObject->MajorFunction[IRP_MJ_CLOSE] =
            (PDRIVER_DISPATCH )BowserFsdClose;

    BowserDriverObject->MajorFunction[IRP_MJ_CLEANUP] =
            (PDRIVER_DISPATCH )BowserFsdCleanup;

    BowserDriverObject->MajorFunction[IRP_MJ_QUERY_INFORMATION] =
            (PDRIVER_DISPATCH )BowserFsdQueryInformationFile;

    BowserDriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] =
            (PDRIVER_DISPATCH )BowserFsdDeviceIoControlFile;

#endif

    BowserInitializeIrpContext();

    KeInitializeSpinLock(&BowserTimeSpinLock);

    return STATUS_SUCCESS;

}

VOID
BowserpUninitializeFsp (
    VOID
    )

/*++

Routine Description:

    This routine initializes the FSP specific components and dispatch
    routines.

Arguments:

    None.

Return Value:

    None.

--*/

{

    PAGED_CODE();

    BowserpUninitializeIrpContext();

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\bowser\precomp.h ===
#include <ntifs.h>

#define FlagOn(Flags,SingleFlag)        ((Flags) & (SingleFlag))

#include "bowser.h"
#include <align.h>
#include <ctype.h>
#include <netevent.h>
#include <stdarg.h>
#include <stdio.h>
#include <tstr.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\bowser\mailslot.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    mailslot.c

Abstract:

    This module implements the routines needed to process incoming mailslot
    requests.



Author:

    Larry Osterman (larryo) 18-Oct-1991

Revision History:

    18-Oct-1991  larryo

        Created

--*/
#ifndef _MAILSLOT_
#define _MAILSLOT_

//
//  The MAILSLOTBUFFER structure is a structure that is prepended to a mailslot
//  message to facilitate the transfer of the data between the FSD and the FSP.
//

typedef struct _MAILSLOT_BUFFER {
    CSHORT  Signature;
    CSHORT  Size;
    union {
        LIST_ENTRY  NextBuffer;                 // Pointer to next buffer.
        WORK_QUEUE_ITEM WorkHeader;             // Executive Worker item header.
    } Overlay;
    ULONG   BufferSize;

    LARGE_INTEGER TimeReceived;                 // Time message was received

    ULONG ClientIpAddress;                      // IP Address of client sending datagram

    PTRANSPORT_NAME TransportName;              // Transport address receiving DG

    CHAR ClientAddress[max(NETBIOS_NAME_LEN, SMB_IPX_NAME_LENGTH)]; // Name of client initiating receive.

    ULONG ReceiveLength;                        // # of bytes received.

    CHAR Buffer[1];                             // Buffer
} MAILSLOT_BUFFER, *PMAILSLOT_BUFFER;

extern ULONG BowserNetlogonMaxMessageCount;

//
// Two services get their PNP messages through the bowser.
//

#define BROWSER_PNP         0
#define NETLOGON_PNP        1
#define BOWSER_PNP_COUNT    2


NTSTATUS
BowserEnablePnp (
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG ServiceIndex
    );

NTSTATUS
BowserReadPnp (
    IN PIRP Irp,
    IN ULONG OutputBufferLength,
    IN ULONG ServiceIndex
    );

VOID
BowserSendPnp(
    IN NETLOGON_PNP_OPCODE NlPnpOpcode,
    IN PUNICODE_STRING HostedDomainName OPTIONAL,
    IN PUNICODE_STRING TransportName,
    IN ULONG TransportFlags
    );

VOID
BowserNetlogonDeleteTransportFromMessageQueue (
    PTRANSPORT Transport
    );

VOID
BowserProcessMailslotWrite (
    IN PVOID WorkHeader
    );

PMAILSLOT_BUFFER
BowserAllocateMailslotBuffer(
    IN PTRANSPORT_NAME TransportName,
    IN ULONG BufferSize
    );

VOID
BowserFreeMailslotBuffer(
    IN PMAILSLOT_BUFFER Buffer
    );

VOID
BowserFreeMailslotBufferHighIrql(
    IN PMAILSLOT_BUFFER Buffer
    );

VOID
BowserpInitializeMailslot (
    VOID
    );


VOID
BowserpUninitializeMailslot (
    VOID
    );

#endif          // _MAILSLOT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\bowser\workque.h ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    workque.h

Abstract:

    This module defines the data structures and routines used for the FSP
    dispatching code.


Author:

    Larry Osterman (LarryO) 13-Aug-1990

Revision History:

    13-Aug-1990 LarryO

        Created

--*/
#ifndef _WORKQUE_
#define _WORKQUE_


typedef struct _IRP_QUEUE {
    LIST_ENTRY Queue;               //  Queue itself.
} IRP_QUEUE, *PIRP_QUEUE;


struct _BOWSER_FS_DEVICE_OBJECT;

//
//  IRP Context.
//
//  The IRP context is a wrapper that used when passing an IRP from the
//  redirectors FSD to its FSP.
//

typedef
struct _IRP_CONTEXT {
    WORK_QUEUE_ITEM WorkHeader;
    PIRP Irp;
    struct _BOWSER_FS_DEVICE_OBJECT *DeviceObject;
} IRP_CONTEXT, *PIRP_CONTEXT;

VOID
BowserQueueCriticalWorkItem (
    IN PWORK_QUEUE_ITEM WorkItem
    );

VOID
BowserQueueDelayedWorkItem (
    IN PWORK_QUEUE_ITEM WorkItem
    );

PIRP_CONTEXT
BowserAllocateIrpContext(
    VOID
    );

VOID
BowserFreeIrpContext(
    PIRP_CONTEXT IrpContext
    );

VOID
BowserInitializeIrpQueue(
    PIRP_QUEUE Queue
    );

VOID
BowserUninitializeIrpQueue(
    PIRP_QUEUE Queue
    );

VOID
BowserCancelQueuedRequest(
    IN PDEVICE_OBJECT DeviceObject OPTIONAL,
    IN PIRP Irp
    );

VOID
BowserCancelQueuedIoForFile(
    IN PIRP_QUEUE Queue,
    IN PFILE_OBJECT FileObject
    );

NTSTATUS
BowserQueueNonBufferRequest(
    IN PIRP Irp,
    IN PIRP_QUEUE Queue,
    IN PDRIVER_CANCEL CancelRoutine
    );

NTSTATUS
BowserQueueNonBufferRequestReferenced(
    IN PIRP Irp,
    IN PIRP_QUEUE Queue,
    IN PDRIVER_CANCEL CancelRoutine
    );

VOID
BowserTimeoutQueuedIrp(
    IN PIRP_QUEUE Queue,
    IN ULONG NumberOfSecondsToTimeOut
    );

PIRP
BowserDequeueQueuedIrp(
    IN PIRP_QUEUE Queue
    );

VOID
BowserInitializeIrpContext(
    VOID
    );

VOID
BowserpUninitializeIrpContext(
    VOID
    );

VOID
BowserpInitializeIrpQueue(
    VOID
    );

//
//  Returns TRUE if there are no entries in the IRP queue.
//

#define BowserIsIrpQueueEmpty(IrpQueue) IsListEmpty(&(IrpQueue)->Queue)


#endif  // _WORKQUE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\bowser\receive.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    receive.h

Abstract:

    This module describes the public routines in receive.c


Author:

    Larry Osterman (larryo) 6-May-1991

Revision History:

    6-May-1991  larryo

    Created

--*/

#ifndef _RECEIVE_
#define _RECEIVE_

#define DATAGRAM_HANDLER(RoutineName)           \
NTSTATUS                                        \
RoutineName (                                   \
    IN struct _TRANSPORT_NAME *TransportName,   \
    IN PVOID Buffer,                            \
    IN ULONG BytesAvailable,                    \
    IN OUT PULONG BytesTaken,                   \
    IN PVOID SourceAddress,                     \
    IN ULONG SourceAddressLength,               \
    IN PVOID SourceName,                        \
    IN ULONG SourceNameLength,                  \
    IN ULONG ReceiveFlags                       \
    )                                           \

typedef
(*PDATAGRAM_HANDLER)(
    IN struct _TRANSPORT_NAME *TransportName,
    IN PVOID Buffer,
    IN ULONG BytesAvailable,
    IN OUT PULONG BytesTaken,
    IN PVOID SourceAddress,
    IN ULONG SourceAddressLength,
    IN PVOID SourceName,
    IN ULONG SourceNameLength,
    IN ULONG ReceiveFlags
    );

LONG BowserPostedDatagramCount;
LONG BowserPostedCriticalDatagramCount;

typedef struct _POST_DATAGRAM_CONTEXT {
    WORK_QUEUE_ITEM WorkItem;
    PTRANSPORT_NAME TransportName;
    PVOID           Buffer;
    ULONG           BytesAvailable;
    int             ClientNameLength;
    CHAR            ClientName[NETBIOS_NAME_LEN];
    int             ClientAddressLength;
    CHAR            TdiClientAddress[1];
} POST_DATAGRAM_CONTEXT, *PPOST_DATAGRAM_CONTEXT;

NTSTATUS
BowserTdiReceiveDatagramHandler (
    IN PVOID TdiEventContext,       // the event context
    IN LONG SourceAddressLength,    // length of the originator of the datagram
    IN PVOID SourceAddress,         // string describing the originator of the datagram
    IN LONG OptionsLength,          // options for the receive
    IN PVOID Options,               //
    IN ULONG ReceiveDatagramFlags,  //
    IN ULONG BytesIndicated,        // number of bytes this indication
    IN ULONG BytesAvailable,        // number of bytes in complete Tsdu
    OUT ULONG *BytesTaken,          // number of bytes used
    IN PVOID Tsdu,                  // pointer describing this TSDU, typically a lump of bytes
    OUT PIRP *IoRequestPacket        // TdiReceive IRP if MORE_PROCESSING_REQUIRED.
    );

VOID
BowserCancelAnnounceRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
BowserCopyOemComputerName(
    PCHAR OutputComputerName,
    PCHAR NetbiosName,
    ULONG NetbiosNameLength,
    IN ULONG ReceiveFlags
    );

VOID
BowserLogIllegalDatagram(
    IN PTRANSPORT_NAME TransportName,
    IN PVOID IncomingBuffer,
    IN USHORT BufferSize,
    IN PCHAR ClientAddress,
    IN ULONG ReceiveFlags
    );

NTSTATUS
BowserPostDatagramToWorkerThread(
    IN PTRANSPORT_NAME TransportName,
    IN PVOID Datagram,
    IN ULONG Length,
    OUT PULONG BytesTaken,
    IN PVOID OriginatorsAddress,
    IN ULONG OriginatorsAddressLength,
    IN PVOID OriginatorsName,
    IN ULONG OriginatorsNameLength,
    IN PWORKER_THREAD_ROUTINE Handler,
    IN POOL_TYPE PoolType,
    IN WORK_QUEUE_TYPE QueueType,
    IN ULONG ReceiveFlags,
    IN BOOLEAN PostToRdrWorkerThread
    );

MAILSLOTTYPE
BowserClassifyIncomingDatagram(
    IN PVOID Buffer,
    IN ULONG BufferLength,
    OUT PVOID *DatagramData,
    OUT PULONG DatagramDataSize
    );

extern
PDATAGRAM_HANDLER
BowserDatagramHandlerTable[];

NTSTATUS
BowserHandleMailslotTransaction (
    IN PTRANSPORT_NAME TransportName,
    IN PCHAR ClientName,
    IN ULONG ClientIpAddress,
    IN ULONG SmbOffset,
    IN DWORD ReceiveFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP *Irp
    );

NTSTATUS
BowserHandleShortBrowserPacket(
    IN PTRANSPORT_NAME TransportName,
    IN PVOID EventContext,
    IN int SourceAddressLength,
    IN PVOID SourceAddress,
    IN int OptionsLength,
    IN PVOID Options,
    IN ULONG ReceiveDatagramFlags,
    IN ULONG BytesAvailable,
    IN ULONG *BytesTaken,
    IN PIRP *Irp,
    PTDI_IND_RECEIVE_DATAGRAM Handler
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\bowser\receive.c ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    receive.c

Abstract:

    This module implements the routines needed to process TDI receive
indication requests.


Author:

    Larry Osterman (larryo) 6-May-1991

Revision History:

    6-May-1991  LarryO

        Created

--*/
#include "precomp.h"
#pragma hdrstop

//
// Keep track of the number of datagram queued to worker threads.
//  Keep a separate count of critical versus non-critical to ensure non-critical
//  datagrams don't starve critical ones.
//

LONG BowserPostedDatagramCount;
LONG BowserPostedCriticalDatagramCount;
#define BOWSER_MAX_POSTED_DATAGRAMS 100

#define INCLUDE_SMB_TRANSACTION

typedef struct _PROCESS_MASTER_ANNOUNCEMENT_CONTEXT {
    WORK_QUEUE_ITEM WorkItem;
    PTRANSPORT Transport;
    ULONG   ServerType;
    ULONG   ServerElectionVersion;
    UCHAR   MasterName[NETBIOS_NAME_LEN];
    ULONG   MasterAddressLength;
    UCHAR   Buffer[1];
} PROCESS_MASTER_ANNOUNCEMENT_CONTEXT, *PPROCESS_MASTER_ANNOUNCEMENT_CONTEXT;

typedef struct _ILLEGAL_DATAGRAM_CONTEXT {
    WORK_QUEUE_ITEM WorkItem;
    PTRANSPORT_NAME TransportName;
    NTSTATUS EventStatus;
    USHORT   BufferSize;
    UCHAR    SenderName[max(NETBIOS_NAME_LEN, SMB_IPX_NAME_LENGTH)];
    UCHAR    Buffer[1];
} ILLEGAL_DATAGRAM_CONTEXT, *PILLEGAL_DATAGRAM_CONTEXT;

VOID
BowserLogIllegalDatagramWorker(
    IN PVOID Ctx
    );

VOID
BowserProcessMasterAnnouncement(
    IN PVOID Ctx
    );


DATAGRAM_HANDLER(
    HandleLocalMasterAnnouncement
    );

DATAGRAM_HANDLER(
    HandleAnnounceRequest
    );

NTSTATUS
CompleteReceiveMailslot (
    IN PDEVICE_OBJECT TransportDevice,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
CompleteShortBrowserPacket (
    IN PDEVICE_OBJECT TransportDevice,
    IN PIRP Irp,
    IN PVOID Ctx
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, BowserLogIllegalDatagramWorker)
#pragma alloc_text(PAGE, BowserProcessMasterAnnouncement)
#endif


PDATAGRAM_HANDLER
BowserDatagramHandlerTable[] = {
    NULL,                           // 0 - Illegal (no opcode for this).
    BowserHandleServerAnnouncement, // 1 - HostAnnouncement
    HandleAnnounceRequest,          // 2 - AnnouncementRequest
    NULL,                           // 3 - InterrogateInfoRequest
    NULL,                           // 4 - RelogonRequest
    NULL,                           // 5
    NULL,                           // 6
    NULL,                           // 7
    BowserHandleElection,           // 8 - Election
    BowserGetBackupListRequest,     // 9 - GetBackupListReq
    BowserGetBackupListResponse,    // a - GetBackupListResp
    BowserHandleBecomeBackup,       // b - BecomeBackupServer
    BowserHandleDomainAnnouncement, // c - WkGroupAnnouncement,
    BowserMasterAnnouncement,       // d - MasterAnnouncement,
    BowserResetState,               // e - ResetBrowserState
    HandleLocalMasterAnnouncement   // f - LocalMasterAnnouncement
};

NTSTATUS
BowserTdiReceiveDatagramHandler (
    IN PVOID TdiEventContext,       // the event context
    IN LONG SourceAddressLength,    // length of the originator of the datagram
    IN PVOID SourceAddress,         // string describing the originator of the datagram
    IN LONG OptionsLength,           // options for the receive
    IN PVOID Options,               //
    IN ULONG ReceiveDatagramFlags,  //
    IN ULONG BytesIndicated,        // number of bytes this indication
    IN ULONG BytesAvailable,        // number of bytes in complete Tsdu
    OUT ULONG *BytesTaken,          // number of bytes used
    IN PVOID Tsdu,                  // pointer describing this TSDU, typically a lump of bytes
    OUT PIRP *IoRequestPacket        // TdiReceive IRP if MORE_PROCESSING_REQUIRED.
    )

/*++

Routine Description:

    This routine will process receive datagram indication messages, and
    process them as appropriate.

Arguments:

    IN PVOID TdiEventContext    - the event context
    IN int SourceAddressLength  - length of the originator of the datagram
    IN PVOID SourceAddress,     - string describing the originator of the datagram
    IN int OptionsLength,       - options for the receive
    IN PVOID Options,           -
    IN ULONG BytesIndicated,    - number of bytes this indication
    IN ULONG BytesAvailable,    - number of bytes in complete Tsdu
    OUT ULONG *BytesTaken,      - number of bytes used
    IN PVOID Tsdu,              - pointer describing this TSDU, typically a lump of bytes
    OUT PIRP *IoRequestPacket   - TdiReceive IRP if MORE_PROCESSING_REQUIRED.


Return Value:

    NTSTATUS - Status of operation.

--*/


{
    PVOID DatagramData;
    PINTERNAL_TRANSACTION InternalTransaction = NULL;
    ULONG DatagramDataSize;
    PTRANSPORT_NAME TransportName = TdiEventContext;
    MAILSLOTTYPE Opcode;
    TA_NETBIOS_ADDRESS ClientNetbiosAddress;
    ULONG ClientNetbiosAddressSize;

    if (BytesAvailable > ((PTRANSPORT_NAME)TdiEventContext)->Transport->DatagramSize) {
        return STATUS_REQUEST_NOT_ACCEPTED;
    }

    if (NULL == TransportName->DeviceObject) {
        //
        // The transport isn't ready yet to process receives (probably
        // we're still processing the transport bind call).
        // Drop this receive.
        //
        return STATUS_REQUEST_NOT_ACCEPTED;
    }

    //
    // Make a copy of the SourceAddress that just has the netbios address
    //  (We could pass the second address along, but there are many
    //  places that expect just a single source address.)
    //

    if ( SourceAddressLength < sizeof(TA_NETBIOS_ADDRESS)) {
        return STATUS_REQUEST_NOT_ACCEPTED;
    }

    TdiCopyLookaheadData( &ClientNetbiosAddress, SourceAddress, sizeof(TA_NETBIOS_ADDRESS), ReceiveDatagramFlags);

    if ( ClientNetbiosAddress.Address[0].AddressType != TDI_ADDRESS_TYPE_NETBIOS ) {
        return STATUS_REQUEST_NOT_ACCEPTED;
    }
    ClientNetbiosAddressSize = sizeof(TA_NETBIOS_ADDRESS);

    ClientNetbiosAddress.TAAddressCount = 1;


    //
    //  Classify the incoming packet according to it's type.  Depending on
    //  the type, either process it as:
    //
    //  1) A server announcement
    //  2) An incoming mailslot
    //

    Opcode = BowserClassifyIncomingDatagram(Tsdu, BytesIndicated,
                                            &DatagramData,
                                            &DatagramDataSize);
    if (Opcode == MailslotTransaction) {

        //
        // Grab the IP address of the client.
        //
        PTA_NETBIOS_ADDRESS OrigNetbiosAddress = SourceAddress;
        ULONG ClientIpAddress = 0;
        if ( OrigNetbiosAddress->TAAddressCount > 1 ) {
            TA_ADDRESS * TaAddress = (TA_ADDRESS *)
                (((LPBYTE)&OrigNetbiosAddress->Address[0].Address[0]) +
                    OrigNetbiosAddress->Address[0].AddressLength);

            if ( TaAddress->AddressLength >= sizeof(TDI_ADDRESS_IP) &&
                 TaAddress->AddressType == TDI_ADDRESS_TYPE_IP ) {
                TDI_ADDRESS_IP UNALIGNED * TdiAddressIp = (TDI_ADDRESS_IP UNALIGNED *) (TaAddress->Address);

                ClientIpAddress = TdiAddressIp->in_addr;
            }

        }

        return BowserHandleMailslotTransaction(
                    TransportName,
                    ClientNetbiosAddress.Address[0].Address->NetbiosName,
                    ClientIpAddress,
                    0,      // SMB offset into TSDU
                    ReceiveDatagramFlags,
                    BytesIndicated,
                    BytesAvailable,
                    BytesTaken,
                    Tsdu,
                    IoRequestPacket );

    } else if (Opcode == Illegal) {
        BowserLogIllegalDatagram(TdiEventContext,
                                    Tsdu,
                                    (USHORT)(BytesIndicated & 0xffff),
                                    ClientNetbiosAddress.Address[0].Address->NetbiosName,
                                    ReceiveDatagramFlags);
        return STATUS_REQUEST_NOT_ACCEPTED;
    } else {

        if (BowserDatagramHandlerTable[Opcode] == NULL) {
            return STATUS_SUCCESS;
        }

        //
        //  If this isn't the full packet, post a receive for it and
        //  handle it when we finally complete the receive.
        //

        if (BytesIndicated < BytesAvailable) {
            return BowserHandleShortBrowserPacket(TransportName,
                                                    TdiEventContext,
                                                    ClientNetbiosAddressSize,
                                                    &ClientNetbiosAddress,
                                                    OptionsLength,
                                                    Options,
                                                    ReceiveDatagramFlags,
                                                    BytesAvailable,
                                                    BytesTaken,
                                                    IoRequestPacket,
                                                    BowserTdiReceiveDatagramHandler
                                                    );
        }

        InternalTransaction = DatagramData;

        if (((Opcode == WkGroupAnnouncement) ||
             (Opcode == HostAnnouncement)) && !TransportName->ProcessHostAnnouncements) {
            return STATUS_REQUEST_NOT_ACCEPTED;
        }

        ASSERT (DatagramDataSize == (BytesIndicated - ((PCHAR)InternalTransaction - (PCHAR)Tsdu)));

        ASSERT (FIELD_OFFSET(INTERNAL_TRANSACTION, Union.Announcement) == FIELD_OFFSET(INTERNAL_TRANSACTION, Union.BrowseAnnouncement));
        ASSERT (FIELD_OFFSET(INTERNAL_TRANSACTION, Union.Announcement) == FIELD_OFFSET(INTERNAL_TRANSACTION, Union.RequestElection));
        ASSERT (FIELD_OFFSET(INTERNAL_TRANSACTION, Union.Announcement) == FIELD_OFFSET(INTERNAL_TRANSACTION, Union.BecomeBackup));
        ASSERT (FIELD_OFFSET(INTERNAL_TRANSACTION, Union.Announcement) == FIELD_OFFSET(INTERNAL_TRANSACTION, Union.GetBackupListRequest));
        ASSERT (FIELD_OFFSET(INTERNAL_TRANSACTION, Union.Announcement) == FIELD_OFFSET(INTERNAL_TRANSACTION, Union.GetBackupListResp));
        ASSERT (FIELD_OFFSET(INTERNAL_TRANSACTION, Union.Announcement) == FIELD_OFFSET(INTERNAL_TRANSACTION, Union.ResetState));
        ASSERT (FIELD_OFFSET(INTERNAL_TRANSACTION, Union.Announcement) == FIELD_OFFSET(INTERNAL_TRANSACTION, Union.MasterAnnouncement));

        return BowserDatagramHandlerTable[Opcode](TdiEventContext,
                                            &InternalTransaction->Union.Announcement,
                                            BytesIndicated-(ULONG)((PCHAR)&InternalTransaction->Union.Announcement - (PCHAR)Tsdu),
                                            BytesTaken,
                                            &ClientNetbiosAddress,
                                            ClientNetbiosAddressSize,
                                            ClientNetbiosAddress.Address[0].Address->NetbiosName,
                                            NETBIOS_NAME_LEN,
                                            ReceiveDatagramFlags);
    }

    return STATUS_SUCCESS;

    UNREFERENCED_PARAMETER(OptionsLength);
    UNREFERENCED_PARAMETER(Options);
    UNREFERENCED_PARAMETER(ReceiveDatagramFlags);
}

VOID
BowserLogIllegalDatagram(
    IN PTRANSPORT_NAME TransportName,
    IN PVOID IncomingBuffer,
    IN USHORT BufferSize,
    IN PCHAR ClientName,
    IN ULONG ReceiveFlags
    )
{
    KIRQL OldIrql;
    NTSTATUS ErrorStatus = STATUS_SUCCESS;

    ExInterlockedAddLargeStatistic(&BowserStatistics.NumberOfIllegalDatagrams, 1);

    ACQUIRE_SPIN_LOCK(&BowserTimeSpinLock, &OldIrql);

    if (BowserIllegalDatagramCount > 0) {
        BowserIllegalDatagramCount -= 1;

        ErrorStatus = EVENT_BOWSER_ILLEGAL_DATAGRAM;

    } else if (!BowserIllegalDatagramThreshold) {
        BowserIllegalDatagramThreshold = TRUE;
        ErrorStatus = EVENT_BOWSER_ILLEGAL_DATAGRAM_THRESHOLD;
    }

    RELEASE_SPIN_LOCK(&BowserTimeSpinLock, OldIrql);

//    if (!memcmp(TransportName->Transport->ComputerName->Name->NetbiosName.Address[0].Address->NetbiosName, ClientAddress->Address[0].Address->NetbiosName, CNLEN)) {
//        DbgBreakPoint();
//    }

    if (ErrorStatus != STATUS_SUCCESS) {
        PILLEGAL_DATAGRAM_CONTEXT Context = NULL;

        Context = ALLOCATE_POOL(NonPagedPool, sizeof(ILLEGAL_DATAGRAM_CONTEXT)+BufferSize, POOL_ILLEGALDGRAM);

        if (Context != NULL) {
            Context->EventStatus = ErrorStatus;
            Context->TransportName = TransportName;
            Context->BufferSize = BufferSize;

            TdiCopyLookaheadData(&Context->Buffer, IncomingBuffer, BufferSize, 0);

            BowserCopyOemComputerName( Context->SenderName,
                                       ClientName,
                                       sizeof(Context->SenderName),
                                       ReceiveFlags);

            ExInitializeWorkItem(&Context->WorkItem, BowserLogIllegalDatagramWorker, Context);

            BowserQueueDelayedWorkItem( &Context->WorkItem );
        }

    }
}

VOID
BowserCopyOemComputerName(
    PCHAR OutputComputerName,
    PCHAR NetbiosName,
    ULONG NetbiosNameLength,
    IN ULONG ReceiveFlags
    )
{
    ULONG i;

    //
    //  Since this routine can be called at indication time, we need to use
    //  TdiCopyLookaheadData
    //

    TdiCopyLookaheadData(OutputComputerName, NetbiosName, NetbiosNameLength, ReceiveFlags);

    for (i = NetbiosNameLength-2; i ; i -= 1) {

        if ((OutputComputerName[i] != ' ') &&
            (OutputComputerName[i] != '\0')) {
            OutputComputerName[i+1] = '\0';
            break;
        }
    }
}


VOID
BowserLogIllegalDatagramWorker(
    IN PVOID Ctx
    )
{
    PILLEGAL_DATAGRAM_CONTEXT Context = Ctx;
    NTSTATUS EventContext = Context->EventStatus;
    LPWSTR TransportNamePointer = &Context->TransportName->Transport->PagedTransport->TransportName.Buffer[(sizeof(L"\\Device\\") / sizeof(WCHAR))-1];
    LPWSTR NamePointer = Context->TransportName->PagedTransportName->Name->Name.Buffer;
    UNICODE_STRING ClientNameU;
    OEM_STRING ClientNameO;
    NTSTATUS Status;

    PAGED_CODE();

    RtlInitAnsiString(&ClientNameO, Context->SenderName);

    Status = RtlOemStringToUnicodeString(&ClientNameU, &ClientNameO, TRUE);

    if (!NT_SUCCESS(Status)) {
        BowserLogIllegalName( Status, ClientNameO.Buffer, ClientNameO.Length );
    }
    else {

        BowserWriteErrorLogEntry(EventContext, STATUS_REQUEST_NOT_ACCEPTED,
                                                Context->Buffer,
                                                Context->BufferSize,
                                                3, ClientNameU.Buffer,
                                                NamePointer,
                                                TransportNamePointer);
        RtlFreeUnicodeString(&ClientNameU);
    }

    FREE_POOL(Context);

}


CHAR BowserMinimumDatagramSize[] = {
    (CHAR)0xff,                   // 0 - Illegal (no opcode for this).
    (CHAR)FIELD_OFFSET(INTERNAL_TRANSACTION, Union.Announcement.NameComment), // HostAnnouncement
    (CHAR)0xff,                   // AnnouncementRequest
    (CHAR)0xff,                   // InterrogateInfoRequest
    (CHAR)0xff,                   // RelogonRequest
    (CHAR)0xff,                   // 5
    (CHAR)0xff,                   // 6
    (CHAR)0xff,                   // 7
    (CHAR)FIELD_OFFSET(INTERNAL_TRANSACTION, Union.RequestElection.ServerName),// Election
    (CHAR)FIELD_OFFSET(INTERNAL_TRANSACTION, Union.GetBackupListRequest.Token),// GetBackupListReq
    (CHAR)FIELD_OFFSET(INTERNAL_TRANSACTION, Union.GetBackupListResp.Token),   // GetBackupListResp
    (CHAR)FIELD_OFFSET(INTERNAL_TRANSACTION, Union.BecomeBackup.BrowserToPromote), // BecomeBackupServer
    (CHAR)FIELD_OFFSET(INTERNAL_TRANSACTION, Union.BrowseAnnouncement.Comment), // WkGroupAnnouncement,
    (CHAR)FIELD_OFFSET(INTERNAL_TRANSACTION, Union.ResetState.Options),        // ResetBrowserState
    (CHAR)FIELD_OFFSET(INTERNAL_TRANSACTION, Union.MasterAnnouncement.MasterName), // MasterAnnouncement,
    (CHAR)FIELD_OFFSET(INTERNAL_TRANSACTION, Union.Announcement.NameComment) // LocalMasterAnnouncement
};

MAILSLOTTYPE
BowserClassifyIncomingDatagram(
    IN PVOID Buffer,
    IN ULONG BufferLength,
    OUT PVOID *DatagramData,
    OUT PULONG DatagramDataSize
    )
/*++

Routine Description:

    This routine will classify an incoming datagram into its type - either
    Illegal, ServerAnnouncement, or MailslotRequest.

Arguments:

    IN PVOID Buffer,      - pointer describing this TSDU, typically a lump of bytes
    IN ULONG BufferLength - number of bytes in complete Tsdu

Return Value:

    NTSTATUS - Status of operation.

--*/
{
    PSMB_HEADER Header = Buffer;
    PSMB_TRANSACT_MAILSLOT Transaction = (PSMB_TRANSACT_MAILSLOT) (Header+1);
    PSZ MailslotName = Transaction->Buffer;
    PINTERNAL_TRANSACTION InternalTransaction;
    BOOLEAN MailslotLanman = FALSE;
    BOOLEAN MailslotBrowse = FALSE;
    ULONG i;
    ULONG MaxMailslotNameLength;

    ASSERT (sizeof(BowserMinimumDatagramSize) == MaximumMailslotType);

    //
    //  We only know things that start with an SMB header.
    //

    if ((BufferLength < sizeof(SMB_HEADER)) ||

        (SmbGetUlong(((PULONG )Header->Protocol)) != (ULONG)SMB_HEADER_PROTOCOL) ||

    //
    //  All mailslots and server announcements go via the transaction SMB
    //  protocol.
    //
        (Header->Command != SMB_COM_TRANSACTION) ||

    //
    //  The buffer has to be big enough to hold a mailslot transaction.
    //

        (BufferLength <= (FIELD_OFFSET(SMB_TRANSACT_MAILSLOT, Buffer)  + sizeof(SMB_HEADER)) + SMB_MAILSLOT_PREFIX_LENGTH) ||

    //
    //  The word count for a transaction SMB is 17 (14+3 setup words).
    //

        (Transaction->WordCount != 17) ||

    //
    //  There must be 3 setup words.
    //

        (Transaction->SetupWordCount != 3) ||

//    //
//    //  Mailslot and server announcements expect no response.
//    //
//
//        (!(SmbGetUshort(&Transaction->Flags) & SMB_TRANSACTION_NO_RESPONSE)) ||

    //
    //  There are no parameter bytes for a mailslot write.
    //

        (SmbGetUshort(&Transaction->TotalParameterCount) != 0) ||

    //
    //  This must be a mailslot write command.
    //

        (SmbGetUshort(&Transaction->Opcode) != TRANS_MAILSLOT_WRITE) ||

    //
    //  And it must be a second class mailslot write.
    //

        (SmbGetUshort(&Transaction->Class) != 2) ||

        _strnicmp(MailslotName, SMB_MAILSLOT_PREFIX,
                 min(SMB_MAILSLOT_PREFIX_LENGTH,
                     BufferLength-(ULONG)((PCHAR)MailslotName-(PCHAR)Buffer)))) {

        return Illegal;
    }


    //
    // Ensure there's a zero byte in the mailslotname
    //

    MaxMailslotNameLength =
                min( MAXIMUM_FILENAME_LENGTH-7,   // \Device
                BufferLength-(ULONG)((PCHAR)MailslotName-(PCHAR)Buffer));

    for ( i = SMB_MAILSLOT_PREFIX_LENGTH; i < MaxMailslotNameLength; i++ ) {
        if ( MailslotName[i] == '\0' ) {
            break;
        }
    }

    if ( i == MaxMailslotNameLength ) {
        return Illegal;
    }


    //
    //  We now know this is a mailslot of some kind.  Now check what type
    //  of mailslot it is.
    //
    //
    //  There are two special mailslot names we understand, \MAILSLOT\LANMAN,
    //  and \MAILSLOT\BROWSE
    //

    if (_strnicmp(MailslotName, MAILSLOT_LANMAN_NAME, min(sizeof(MAILSLOT_LANMAN_NAME)-1, BufferLength-(ULONG)((PCHAR)Buffer-(PCHAR)MailslotName)))) {

        if (_strnicmp(MailslotName, MAILSLOT_BROWSER_NAME, min(sizeof(MAILSLOT_BROWSER_NAME)-1, BufferLength-(ULONG)((PCHAR)Buffer-(PCHAR)MailslotName)))) {
            return MailslotTransaction;
        }
    }

//
//  CLEANUP - Not necessary with code below commented out.
//
//          else {
//            MailslotBrowse = TRUE;
//        }
//
//    } else {
//        MailslotLanman = TRUE;
//    }
//

    //
    //  This mailslot write is to the special mailslot \MAILSLOT\LANMAN (or \MAILSLOT\MSBROWSE).
    //

    //
    //  Check that the data is within the supplied buffer, and ensure that the one
    //     byte Type field is within the buffer since we need to dereference it below
    //     to do the overall size check (this is the reason for BufferLength - 1).
    //

    if (SmbGetUshort(&Transaction->DataOffset) > BufferLength - 1) {
       return Illegal;
    }

    //
    //  Verify that the supplied data size exceeds the minimum for this type of
    //     transaction.
    //

    *DatagramData       = (((PCHAR)Header) + SmbGetUshort(&Transaction->DataOffset));
    InternalTransaction = *DatagramData;
    *DatagramDataSize   = (BufferLength - (ULONG)((PCHAR)InternalTransaction - (PCHAR)Buffer));

    if (InternalTransaction->Type >= MaximumMailslotType) {
        return Illegal;
    }

    if (((LONG)*DatagramDataSize) < BowserMinimumDatagramSize[InternalTransaction->Type]) {
        return Illegal;
    }

//    //
//    //  Figure out what type of mailslot it is by looking at the
//    //  data in the message.
//    //
//
//
//    //
//    //  Depending on which special mailslot this is, certain types of requests
//    //  are illegal.
//    //
//    switch (InternalTransaction->Type) {
//    case InterrogateInfoRequest:
//    case RelogonRequest:
//        if (MailslotBrowse) {
//            return Illegal;
//        }
//        break;
//
//    case GetBackupListReq:
//    case GetBackupListResp:
//    case BecomeBackupServer:
//    case WkGroupAnnouncement:
//    case MasterAnnouncement:
//    case Election:
//        if (MailslotLanman) {
//            return Illegal;
//        }
//        break;
//    }
//

    //
    //  The type of this request is the first UCHAR inside the transaction
    //  data.
    //

    return (MAILSLOTTYPE )InternalTransaction->Type;

}

DATAGRAM_HANDLER(
    HandleLocalMasterAnnouncement
    )
/*++

Routine Description:

    This routine will process receive datagram indication messages, and
    process them as appropriate.

Arguments:

    IN PTRANSPORT Transport     - The transport provider for this request.
    IN ULONG BytesAvailable     - number of bytes in complete Tsdu
    IN PHOST_ANNOUNCE_PACKET_1 HostAnnouncement - the server announcement.
    IN ULONG BytesAvailable     - The number of bytes in the announcement.
    OUT ULONG *BytesTaken       - number of bytes used
    IN UCHAR Opcode             - the mailslot write opcode.

Return Value:

    NTSTATUS - Status of operation.

--*/
{
    PPROCESS_MASTER_ANNOUNCEMENT_CONTEXT Context = NULL;
    PBROWSE_ANNOUNCE_PACKET_1 BrowseAnnouncement = Buffer;

    if (BytesAvailable < FIELD_OFFSET(BROWSE_ANNOUNCE_PACKET_1, Comment)) {
        return(STATUS_REQUEST_NOT_ACCEPTED);
    }

    //
    // Ensure we've not consumed too much memory
    //

    InterlockedIncrement( &BowserPostedDatagramCount );

    if ( BowserPostedDatagramCount > BOWSER_MAX_POSTED_DATAGRAMS ) {
        InterlockedDecrement( &BowserPostedDatagramCount );
        return STATUS_REQUEST_NOT_ACCEPTED;
    }

    Context = ALLOCATE_POOL(NonPagedPool, sizeof(PROCESS_MASTER_ANNOUNCEMENT_CONTEXT) + SourceAddressLength, POOL_MASTERANNOUNCE);

    //
    //  If we couldn't allocate the pool from non paged pool, just give up,
    //  the master will announce within 15 minutes anyway.
    //

    if (Context == NULL) {
        InterlockedDecrement( &BowserPostedDatagramCount );
        return STATUS_SUCCESS;
    }

    ExInitializeWorkItem(&Context->WorkItem, BowserProcessMasterAnnouncement, Context);

    BowserReferenceTransport( TransportName->Transport );
    Context->Transport = TransportName->Transport;

    Context->ServerType = SmbGetUlong(&BrowseAnnouncement->Type);
    Context->ServerElectionVersion = SmbGetUlong(&BrowseAnnouncement->CommentPointer);

    RtlCopyMemory(Context->MasterName, BrowseAnnouncement->ServerName, sizeof(Context->MasterName)-1);
    Context->MasterName[sizeof(Context->MasterName)-1] = '\0';

    Context->MasterAddressLength = SourceAddressLength;

    TdiCopyLookaheadData(Context->Buffer, SourceAddress, SourceAddressLength, ReceiveFlags);

    BowserQueueDelayedWorkItem( &Context->WorkItem );

    //
    //  If we are not processing host announcements for this
    //  transport, ignore this request.
    //

    if (!TransportName->ProcessHostAnnouncements) {
        return STATUS_REQUEST_NOT_ACCEPTED;
    }

    DISCARDABLE_CODE( BowserDiscardableCodeSection );

    return BowserHandleServerAnnouncement(TransportName,
                                            Buffer,
                                            BytesAvailable,
                                            BytesTaken,
                                            SourceAddress,
                                            SourceAddressLength,
                                            SourceName,
                                            SourceNameLength,
                                            ReceiveFlags);

}




VOID
BowserProcessMasterAnnouncement(
    IN PVOID Ctx
    )
/*++

Routine Description:

    This routine will process browser master announcements.

Arguments:

    IN PVOID Context    - Context block containing master name.

Return Value:

    None.

--*/
{
    PPROCESS_MASTER_ANNOUNCEMENT_CONTEXT Context = Ctx;
    PTRANSPORT Transport = Context->Transport;
    UNICODE_STRING MasterName;
    OEM_STRING AnsiMasterName;
    WCHAR MasterNameBuffer[LM20_CNLEN+1];

    PAGED_CODE();

    try {
        NTSTATUS Status;
        PPAGED_TRANSPORT PagedTransport = Transport->PagedTransport;

        LOCK_TRANSPORT(Transport);

        MasterName.Buffer = MasterNameBuffer;
        MasterName.MaximumLength = sizeof(MasterNameBuffer);

        //
        //  If we are currently running an election, ignore this announcement.
        //

        if (Transport->ElectionState == RunningElection) {
            try_return(NOTHING);
        }

        RtlInitAnsiString(&AnsiMasterName, Context->MasterName);

        Status = RtlOemStringToUnicodeString(&MasterName, &AnsiMasterName, FALSE);

        if (!NT_SUCCESS(Status)) {
            BowserLogIllegalName( Status, AnsiMasterName.Buffer, AnsiMasterName.Length );
            try_return(NOTHING);
        }

        //
        //  We've found our master - stop our timers - there's a master,
        //  and any find masters we have outstanding will be completed.
        //

        PagedTransport->ElectionCount = 0;

        Transport->ElectionState = Idle;

        BowserStopTimer(&Transport->ElectionTimer);

        BowserStopTimer(&Transport->FindMasterTimer);

        //
        //  If this address doesn't match the address we have for the master,
        //  then use the new address.
        //

        if (Context->MasterAddressLength != PagedTransport->MasterBrowserAddress.Length ||
            RtlCompareMemory(PagedTransport->MasterBrowserAddress.Buffer, Context->Buffer, Context->MasterAddressLength) != Context->MasterAddressLength) {

            ASSERT (Context->MasterAddressLength <= PagedTransport->MasterBrowserAddress.MaximumLength);

            if (Context->MasterAddressLength <= PagedTransport->MasterBrowserAddress.MaximumLength) {
                PagedTransport->MasterBrowserAddress.Length = (USHORT)Context->MasterAddressLength;
                RtlCopyMemory(PagedTransport->MasterBrowserAddress.Buffer, Context->Buffer, Context->MasterAddressLength);
            }

        }

        //
        //  We got a master announcement from someone else.  Remember the
        //  transport address of the master.
        //

        if (!RtlEqualUnicodeString(&Transport->DomainInfo->DomUnicodeComputerName, &MasterName, TRUE)) {
            BOOLEAN sendElection = FALSE;

            //
            //  If we're a master, and we receive this from someone else,
            //  stop being a master and force an election.
            //

            if (PagedTransport->Role == Master) {

                BowserStatistics.NumberOfDuplicateMasterAnnouncements += 1;


                //
                // Log this event.
                //  But avoid logging another one on this transport for the next
                //  60 seconds.
                //
                if ( PagedTransport->OtherMasterTime < BowserCurrentTime ) {
                    PagedTransport->OtherMasterTime = BowserCurrentTime + BowserData.EventLogResetFrequency;

                    BowserWriteErrorLogEntry(EVENT_BOWSER_OTHER_MASTER_ON_NET,
                                                STATUS_SUCCESS,
                                                NULL,
                                                0,
                                                2,
                                                MasterName.Buffer,
                                                &Transport->PagedTransport->TransportName.Buffer[(sizeof(L"\\Device\\") / sizeof(WCHAR))-1]);
                }

                if (!(PagedTransport->Flags & ELECT_LOST_LAST_ELECTION)) {

                    //
                    //  If we're the PDC, and we didn't lose the last election (ie.
                    //  we SHOULD be the browse master),then send a dummy election
                    //  packet to get the other guy to shut up.
                    //

                    if (PagedTransport->IsPrimaryDomainController) {

                        sendElection = TRUE;

                    //
                    //  If we're not an NTAS machine, or if we just lost the
                    //  last election, or if the guy announcing is a DC of some
                    //  kind, stop being the master and reset our state.
                    //

                    } else if (!BowserData.IsLanmanNt ||
                        (Context->ServerType & (SV_TYPE_DOMAIN_BAKCTRL | SV_TYPE_DOMAIN_CTRL))) {

                        //
                        //  If we're not the PDC, then we want to simply inform
                        //  the browser service that someone else is the master
                        //  and let things sort themselves out when it's done.
                        //

                        BowserResetStateForTransport(Transport, RESET_STATE_STOP_MASTER);
                    }

                } else {

                    //
                    //  If we lost the last election, then we want to shut down
                    //  the browser regardless of what state the other browser
                    //  is in.
                    //

                    BowserResetStateForTransport(Transport, RESET_STATE_STOP_MASTER);
                }
            }

            //
            //  If this guy is a WfW machine, we must force an election to move
            //  mastery off of the WfW machine.
            //

            if (Context->ServerType & SV_TYPE_WFW) {
                sendElection = TRUE;
            }

            //
            // If this guy is running an older version of the browser than we are,
            //  and we didn't lose last election,
            //  then force an election to try to become master.
            //
            // We check to see if we lost the last election to prevent us from
            // constantly forcing an election when the older version is still
            // a better browse master than we are.
            //

            if ((Context->ServerElectionVersion >> 16) == 0xaa55 &&
                 (Context->ServerElectionVersion & 0xffff) <
                    (BROWSER_VERSION_MAJOR << 8) + BROWSER_VERSION_MINOR &&
                !(PagedTransport->Flags & ELECT_LOST_LAST_ELECTION)) {

                sendElection = TRUE;
            }


            //
            //  if we're an NTAS server, and the guy announcing as a master
            //  isn't an NTAS server, and we won the last election, force an
            //  election.  This will tend mastership towards DC's.
            //

            if (BowserData.IsLanmanNt &&
                !(PagedTransport->Flags & ELECT_LOST_LAST_ELECTION)) {

                if (PagedTransport->IsPrimaryDomainController) {

                    //
                    //  If we're the PDC and we didn't send the announcement,
                    //  force an election.
                    //

                    sendElection = TRUE;

                } else if (!(Context->ServerType & (SV_TYPE_DOMAIN_BAKCTRL | SV_TYPE_DOMAIN_CTRL))) {
                    //
                    //  Otherwise, if the guy who announced isn't a DC, and we
                    //  are, force an election.
                    //

                    sendElection = TRUE;
                }
            }

            if (sendElection) {
                //
                //  Send a dummy election packet.  This will cause the
                //  othe browser to stop being the master and will
                //  allow the correct machine to become the master.
                //

                BowserSendElection(&Transport->DomainInfo->DomUnicodeDomainName,
                                        BrowserElection,
                                        Transport,
                                        FALSE);

            }

            //
            //  We know who the master is, complete any find master request
            //  outstanding now.
            //

            BowserCompleteFindMasterRequests(Transport, &MasterName, STATUS_SUCCESS);

        } else {

            if (PagedTransport->Role == Master) {
                BowserCompleteFindMasterRequests(Transport, &MasterName, STATUS_MORE_PROCESSING_REQUIRED);

            } else {

                //
                // If the transport is disabled,
                //  we know this transport isn't really the master,
                //  this datagram is probably just a datagram leaked from another
                //  enabled transport on the same wire.
                //
                if ( !PagedTransport->DisabledTransport ) {
                    BowserWriteErrorLogEntry(EVENT_BOWSER_NON_MASTER_MASTER_ANNOUNCE,
                                                STATUS_SUCCESS,
                                                NULL,
                                                0,
                                                1,
                                                MasterName.Buffer);
                    //
                    //  Make sure that the service realizes it is out of sync
                    //  with the driver.
                    //

                    BowserResetStateForTransport(Transport, RESET_STATE_STOP_MASTER);
                }

            }
        }
try_exit:NOTHING;
    } finally {

        UNLOCK_TRANSPORT(Transport);
        BowserDereferenceTransport( Transport );


        InterlockedDecrement( &BowserPostedDatagramCount );
        FREE_POOL(Context);

    }
}



NTSTATUS
BowserHandleMailslotTransaction (
    IN PTRANSPORT_NAME TransportName,
    IN PCHAR ClientName,
    IN ULONG ClientIpAddress,
    IN ULONG SmbOffset,
    IN DWORD ReceiveFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP *Irp
    )
/*++

Routine Description:

    This routine will process receive datagram indication messages, and
    process them as appropriate.

Arguments:

    TransportName - The transport name for this request.

    ClientIpAddress - IP Address of the client that sent the datagram.
        0: Not an IP transport.

    BytesAvailable  - number of bytes in complete Tsdu

    Irp - I/O request packet used to complete the request

    SmbOffset - Offset from the beginning of the indicated data to the SMB

    BytesIndicated - Number of bytes currently available in the TSDU

    BytesTaken - Returns the number of bytes of TSDU already consumed

    Tsdu - The datagram itself.

Return Value:

    NTSTATUS - Status of operation.

--*/
{
    PMAILSLOT_BUFFER Buffer;
    PDEVICE_OBJECT DeviceObject;
    PFILE_OBJECT FileObject;
    PTRANSPORT Transport = TransportName->Transport;
    ULONG BytesToReceive = BytesAvailable - SmbOffset;

    ASSERT (TransportName->Signature == STRUCTURE_SIGNATURE_TRANSPORTNAME);

    ASSERT (BytesAvailable <= TransportName->Transport->DatagramSize);

    //
    //  We must ignore all mailslot requests coming to any names domains
    //  other than the primary domain, the computer name, and the LanMan/NT
    //  domain name.
    //

    if ((TransportName->NameType != ComputerName) &&
        (TransportName->NameType != AlternateComputerName) &&
        (TransportName->NameType != DomainName) &&
        (TransportName->NameType != PrimaryDomain) &&
        (TransportName->NameType != PrimaryDomainBrowser) ) {
        return STATUS_SUCCESS;
    }

    //
    //  Now allocate a buffer to hold the data.
    //

    Buffer = BowserAllocateMailslotBuffer( TransportName, BytesToReceive );

    if (Buffer == NULL) {

        //
        //  We couldn't allocate a buffer to hold the data - ditch the request.
        //

        return(STATUS_REQUEST_NOT_ACCEPTED);
    }

    ASSERT (Buffer->BufferSize >= BytesToReceive);
    KeQuerySystemTime( &Buffer->TimeReceived );
    Buffer->ClientIpAddress = ClientIpAddress;

    //
    //  Save away the name of the client
    //  just in case the datagram turns out to be illegal.
    //

    TdiCopyLookaheadData(Buffer->ClientAddress, ClientName, max(NETBIOS_NAME_LEN, SMB_IPX_NAME_LENGTH), ReceiveFlags);

    //
    // If the entire datagram has been indicated (or already received as a short packet),
    //  just copy the data into the Mailslot buffer directly.
    //

    if ( BytesAvailable == BytesIndicated ) {

        //
        //  Copy the data into the mailslot buffer
        //

        Buffer->ReceiveLength = BytesToReceive;
        TdiCopyLookaheadData( Buffer->Buffer,
                              ((LPBYTE)(Tsdu)) + SmbOffset,
                              BytesToReceive,
                              ReceiveFlags);


        //
        // Queue the request to the worker routine.
        //
        ExInitializeWorkItem(&Buffer->Overlay.WorkHeader,
                             BowserProcessMailslotWrite,
                             Buffer);

        BowserQueueDelayedWorkItem( &Buffer->Overlay.WorkHeader );

        return STATUS_SUCCESS;
    }

    //
    //  We rely on the fact that the device object is NULL for
    //  IPX transport names.
    //

    if (TransportName->DeviceObject == NULL) {

        ASSERT (Transport->IpxSocketDeviceObject != NULL);

        ASSERT (Transport->IpxSocketFileObject != NULL);

        ASSERT (TransportName->FileObject == NULL);

        DeviceObject = Transport->IpxSocketDeviceObject;
        FileObject = Transport->IpxSocketFileObject;
    } else {
        ASSERT (Transport->IpxSocketDeviceObject == NULL);

        ASSERT (Transport->IpxSocketFileObject == NULL);

        DeviceObject = TransportName->DeviceObject;
        FileObject = TransportName->FileObject;
    }

    //
    //  Now allocate an IRP to hold the incoming mailslot.
    //

    *Irp = IoAllocateIrp(DeviceObject->StackSize, FALSE);

    if (*Irp == NULL) {
        BowserFreeMailslotBufferHighIrql(Buffer);

        BowserStatistics.NumberOfFailedMailslotReceives += 1;

        return STATUS_REQUEST_NOT_ACCEPTED;
    }

    (*Irp)->MdlAddress = IoAllocateMdl(Buffer->Buffer, BytesToReceive, FALSE, FALSE, NULL);

    //
    //  If we were unable to allocate the MDL, ditch the datagram.
    //

    if ((*Irp)->MdlAddress == NULL) {
        IoFreeIrp(*Irp);

        BowserFreeMailslotBufferHighIrql(Buffer);

        BowserStatistics.NumberOfFailedMailslotReceives += 1;

        return STATUS_REQUEST_NOT_ACCEPTED;

    }

    MmBuildMdlForNonPagedPool((*Irp)->MdlAddress);

    //
    //  Build the receive datagram IRP.
    //

    TdiBuildReceiveDatagram((*Irp),
                            DeviceObject,
                            FileObject,
                            CompleteReceiveMailslot,
                            Buffer,
                            (*Irp)->MdlAddress,
                            BytesToReceive,
                            NULL,
                            NULL,
                            0);



    //
    //  This gets kinda wierd.
    //
    //  Since this IRP is going to be completed by the transport without
    //  ever going to IoCallDriver, we have to update the stack location
    //  to make the transports stack location the current stack location.
    //
    //  Please note that this means that any transport provider that uses
    //  IoCallDriver to re-submit it's requests at indication time will
    //  break badly because of this code....
    //

    IoSetNextIrpStackLocation(*Irp);

    //
    // Indicate we've already handled everything before the SMB
    //

    *BytesTaken = SmbOffset;

    //
    //  And return to the caller indicating we want to receive this stuff.
    //

    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
CompleteReceiveMailslot (
    IN PDEVICE_OBJECT TransportDevice,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine handles completion of a mailslot write operation.

Arguments:

    IN PDEVICE_OBJECT TransportDevice - Device object for transport.
    IN PIRP Irp - I/O request packet to complete.
    IN PVOID Context - Context for request (transport name).


Return Value:

    NTSTATUS - Status of operation.

--*/
{
    PMAILSLOT_BUFFER Buffer = Context;
    NTSTATUS Status = Irp->IoStatus.Status;

    ASSERT (MmGetSystemAddressForMdl(Irp->MdlAddress) == Buffer->Buffer);

    //
    //  Save away the number of bytes we received.
    //

    Buffer->ReceiveLength = (ULONG)Irp->IoStatus.Information;

    //
    //  Release the MDL, we're done with it.
    //

    IoFreeMdl(Irp->MdlAddress);

    //
    //  And free the IRP, we're done with it as well.
    //

    IoFreeIrp(Irp);

    if (NT_SUCCESS(Status)) {

        ExInitializeWorkItem(&Buffer->Overlay.WorkHeader,
                             BowserProcessMailslotWrite,
                             Buffer);

        BowserQueueDelayedWorkItem( &Buffer->Overlay.WorkHeader );

    } else {

        BowserStatistics.NumberOfFailedMailslotReceives += 1;
        BowserFreeMailslotBufferHighIrql(Buffer);

    }


    //
    //  Short circuit I/O completion for this request.
    //

    return STATUS_MORE_PROCESSING_REQUIRED;

    UNREFERENCED_PARAMETER(TransportDevice);

}

typedef struct _SHORT_ANNOUNCEMENT_CONTEXT {
    PVOID   EventContext;
    int     SourceAddressLength;
    PVOID   SourceAddress;
    int     OptionsLength;
    PVOID   Options;
    ULONG   ReceiveDatagramFlags;
    PVOID   Buffer;
    PTDI_IND_RECEIVE_DATAGRAM ReceiveDatagramHandler;
    CHAR    Data[1];
} SHORT_ANNOUNCEMENT_CONTEXT, *PSHORT_ANNOUNCEMENT_CONTEXT;


NTSTATUS
BowserHandleShortBrowserPacket(
    IN PTRANSPORT_NAME TransportName,
    IN PVOID EventContext,
    IN int SourceAddressLength,
    IN PVOID SourceAddress,
    IN int OptionsLength,
    IN PVOID Options,
    IN ULONG ReceiveDatagramFlags,
    IN ULONG BytesAvailable,
    IN ULONG *BytesTaken,
    IN PIRP *Irp,
    PTDI_IND_RECEIVE_DATAGRAM Handler
    )
/*++

Routine Description:

    This routine will process receive datagram indication messages, and
    process them as appropriate.

Arguments:

    IN PTRANSPORT_NAME TransportName - The transport name for this request.
    IN ULONG BytesAvailable  - number of bytes in complete Tsdu
    OUT PIRP *BytesTaken,    - I/O request packet used to complete the request


Return Value:

    NTSTATUS - Status of operation.

--*/
{
    PDEVICE_OBJECT DeviceObject;
    PFILE_OBJECT FileObject;
    PTRANSPORT Transport = TransportName->Transport;
    PSHORT_ANNOUNCEMENT_CONTEXT Context;


    ASSERT (TransportName->Signature == STRUCTURE_SIGNATURE_TRANSPORTNAME);

    ASSERT (BytesAvailable <= TransportName->Transport->DatagramSize);

    //
    //  Now allocate a buffer to hold the data.
    //

    Context = ALLOCATE_POOL(NonPagedPool, sizeof(SHORT_ANNOUNCEMENT_CONTEXT) + SourceAddressLength + OptionsLength + BytesAvailable, POOL_SHORT_CONTEXT);

    if (Context == NULL) {

        //
        //  We couldn't allocate a buffer to hold the data - ditch the request.
        //

        return(STATUS_REQUEST_NOT_ACCEPTED);
    }

    //
    //  Save away the name of the client and which transport this was received
    //  on just in case the datagram turns out to be illegal.
    //


    Context->SourceAddress = ((PCHAR)Context + FIELD_OFFSET(SHORT_ANNOUNCEMENT_CONTEXT, Data));

    Context->Options = ((PCHAR)Context + FIELD_OFFSET(SHORT_ANNOUNCEMENT_CONTEXT, Data) + SourceAddressLength);

    Context->Buffer = ((PCHAR)Context + FIELD_OFFSET(SHORT_ANNOUNCEMENT_CONTEXT, Data) + SourceAddressLength + OptionsLength);

    TdiCopyLookaheadData(Context->SourceAddress, SourceAddress, SourceAddressLength, ReceiveDatagramFlags);

    Context->SourceAddressLength = SourceAddressLength;

    TdiCopyLookaheadData(Context->Options, Options, OptionsLength, ReceiveDatagramFlags);

    Context->OptionsLength = OptionsLength;

    Context->ReceiveDatagramFlags = ReceiveDatagramFlags;

    Context->EventContext = EventContext;

    Context->ReceiveDatagramHandler = Handler;

    //
    //  We rely on the fact that the device object is NULL for
    //  IPX transport names.
    //

    if (TransportName->DeviceObject == NULL) {

        ASSERT (Transport->IpxSocketDeviceObject != NULL);

        ASSERT (Transport->IpxSocketFileObject != NULL);

        ASSERT (TransportName->FileObject == NULL);

        DeviceObject = Transport->IpxSocketDeviceObject;

        FileObject = Transport->IpxSocketFileObject;
    } else {
        ASSERT (Transport->IpxSocketDeviceObject == NULL);

        ASSERT (Transport->IpxSocketFileObject == NULL);

        DeviceObject = TransportName->DeviceObject;
        FileObject = TransportName->FileObject;
    }

    //
    //  Now allocate an IRP to hold the incoming mailslot.
    //

    *Irp = IoAllocateIrp(DeviceObject->StackSize, FALSE);

    if (*Irp == NULL) {
        FREE_POOL(Context);

        BowserStatistics.NumberOfFailedMailslotReceives += 1;

        return STATUS_REQUEST_NOT_ACCEPTED;
    }

    (*Irp)->MdlAddress = IoAllocateMdl(Context->Buffer, BytesAvailable, FALSE, FALSE, NULL);

    //
    //  If we were unable to allocate the MDL, ditch the datagram.
    //

    if ((*Irp)->MdlAddress == NULL) {
        IoFreeIrp(*Irp);

        FREE_POOL(Context);

        BowserStatistics.NumberOfFailedMailslotReceives += 1;

        return STATUS_REQUEST_NOT_ACCEPTED;

    }

    MmBuildMdlForNonPagedPool((*Irp)->MdlAddress);

    //
    //  Build the receive datagram IRP.
    //

    TdiBuildReceiveDatagram((*Irp),
                            DeviceObject,
                            FileObject,
                            CompleteShortBrowserPacket,
                            Context,
                            (*Irp)->MdlAddress,
                            BytesAvailable,
                            NULL,
                            NULL,
                            0);



    //
    //  This gets kinda wierd.
    //
    //  Since this IRP is going to be completed by the transport without
    //  ever going to IoCallDriver, we have to update the stack location
    //  to make the transports stack location the current stack location.
    //
    //  Please note that this means that any transport provider that uses
    //  IoCallDriver to re-submit it's requests at indication time will
    //  break badly because of this code....
    //

    IoSetNextIrpStackLocation(*Irp);

    *BytesTaken = 0;

    //
    //  And return to the caller indicating we want to receive this stuff.
    //

    return STATUS_MORE_PROCESSING_REQUIRED;

}

NTSTATUS
CompleteShortBrowserPacket (
    IN PDEVICE_OBJECT TransportDevice,
    IN PIRP Irp,
    IN PVOID Ctx
    )
/*++

Routine Description:

    This routine handles completion of a mailslot write operation.

Arguments:

    IN PDEVICE_OBJECT TransportDevice - Device object for transport.
    IN PIRP Irp - I/O request packet to complete.
    IN PVOID Context - Context for request (transport name).


Return Value:

    NTSTATUS - Status of operation.

--*/
{
    PSHORT_ANNOUNCEMENT_CONTEXT Context = Ctx;
    NTSTATUS Status = Irp->IoStatus.Status;
    ULONG ReceiveLength;
    ULONG BytesTaken;
    //
    //  Save away the number of bytes we received.
    //

    ReceiveLength = (ULONG)Irp->IoStatus.Information;

    //
    //  Release the MDL, we're done with it.
    //

    IoFreeMdl(Irp->MdlAddress);

    //
    //  And free the IRP, we're done with it as well.
    //

    IoFreeIrp(Irp);

    if (NT_SUCCESS(Status)) {

        Status = Context->ReceiveDatagramHandler(Context->EventContext,
                                        Context->SourceAddressLength,
                                        Context->SourceAddress,
                                        Context->OptionsLength,
                                        Context->Options,
                                        Context->ReceiveDatagramFlags,
                                        ReceiveLength,
                                        ReceiveLength,
                                        &BytesTaken,
                                        Context->Buffer,
                                        &Irp);
        ASSERT (Status != STATUS_MORE_PROCESSING_REQUIRED);

    }

    FREE_POOL(Context);

    //
    //  Short circuit I/O completion for this request.
    //

    return STATUS_MORE_PROCESSING_REQUIRED;

    UNREFERENCED_PARAMETER(TransportDevice);

}


DATAGRAM_HANDLER(
    HandleAnnounceRequest
    )
/*++

Routine Description:

    This routine will process receive datagram indication messages for announce
    requests.


Arguments:

    None.

Return Value:

    NTSTATUS - Status of operation.

--*/
{
    //
    //  If we're running an election, ignore announce requests.
    //

    if (TransportName->Transport->ElectionState != RunningElection) {

        if ((TransportName->NameType == BrowserElection) ||
            (TransportName->NameType == MasterBrowser) ||
            (TransportName->NameType == PrimaryDomain)) {

            //
            //  This one's easy - simply set the servers announcement event to the
            //  signalled state.  If the server is running, this will force an
            //  announcement
            //

            KeSetEvent(BowserServerAnnouncementEvent, IO_NETWORK_INCREMENT, FALSE);
        } else if (TransportName->NameType == DomainAnnouncement) {
            //
            //  Old comment: NEED TO HANDLE REQUEST ANNOUNCEMENT OF DOMAIN REQUEST.
            //  PhaseOut: we did so wonderfully so far. we won't be handling anything else
            //  due to browser phase out.
            //  Announcement requests are handled by the srvsvc. It determines what to announce
            //  based on the server state.
            //
        }

    }

    return STATUS_SUCCESS;
}

NTSTATUS
BowserPostDatagramToWorkerThread(
    IN PTRANSPORT_NAME TransportName,
    IN PVOID Datagram,
    IN ULONG Length,
    OUT PULONG BytesTaken,
    IN PVOID OriginatorsAddress,
    IN ULONG OriginatorsAddressLength,
    IN PVOID OriginatorsName,
    IN ULONG OriginatorsNameLength,
    IN PWORKER_THREAD_ROUTINE Handler,
    IN POOL_TYPE PoolType,
    IN WORK_QUEUE_TYPE QueueType,
    IN ULONG ReceiveFlags,
    IN BOOLEAN PostToRdrWorkerThread
    )
/*++

Routine Description:

    Queue a datagram to a worker thread.

    This routine increment the reference count on the Transport and TransportName.
    The Handler routine is expected to dereference them.

Arguments:

    Many.

Return Value:

    NTSTATUS - Status of operation.

--*/
{
    PPOST_DATAGRAM_CONTEXT Context;
    PTA_NETBIOS_ADDRESS NetbiosAddress = OriginatorsAddress;

    ASSERT (NetbiosAddress->TAAddressCount == 1);

    ASSERT ((NetbiosAddress->Address[0].AddressType == TDI_ADDRESS_TYPE_NETBIOS) ||
            (NetbiosAddress->Address[0].AddressType == TDI_ADDRESS_TYPE_IPX));

    Context = ALLOCATE_POOL(PoolType, sizeof(POST_DATAGRAM_CONTEXT) + Length + OriginatorsAddressLength, POOL_POSTDG_CONTEXT);

    if (Context == NULL) {
        return STATUS_REQUEST_NOT_ACCEPTED;
    }

    Context->TransportName = TransportName;

    Context->Buffer = ((PCHAR)(Context+1))+OriginatorsAddressLength;

    Context->BytesAvailable = Length;

    TdiCopyLookaheadData(Context->Buffer, Datagram, Length, ReceiveFlags);

    Context->ClientAddressLength = OriginatorsAddressLength;

    TdiCopyLookaheadData(Context->TdiClientAddress, OriginatorsAddress, OriginatorsAddressLength, ReceiveFlags);

    //
    //  Copy over the client name into the buffer.
    //

    Context->ClientNameLength = NETBIOS_NAME_LEN;

    BowserCopyOemComputerName(Context->ClientName,
                              OriginatorsName,
                              OriginatorsNameLength,
                              ReceiveFlags);

    *BytesTaken = Length;

    ExInitializeWorkItem(&Context->WorkItem, Handler, Context);

    if ( QueueType == CriticalWorkQueue ) {

        //
        // Ensure we've not consumed too much memory
        //

        InterlockedIncrement( &BowserPostedCriticalDatagramCount );

        if ( BowserPostedCriticalDatagramCount > BOWSER_MAX_POSTED_DATAGRAMS ) {
            InterlockedDecrement( &BowserPostedCriticalDatagramCount );
            FREE_POOL( Context );
            return STATUS_REQUEST_NOT_ACCEPTED;
        }

        //
        // Reference the Transport and TransportName to ensure they aren't deleted.   The
        // Handler routine is expected to dereference them.
        //
        BowserReferenceTransportName(TransportName);
        dprintf(DPRT_REF, ("Call Reference transport %lx from BowserPostDatagramToWorkerThread %lx.\n", TransportName->Transport, Handler ));
        BowserReferenceTransport( TransportName->Transport );

        //
        // Queue the workitem.
        //
        BowserQueueCriticalWorkItem( &Context->WorkItem );
    } else {

        //
        // Ensure we've not consumed too much memory
        //

        InterlockedIncrement( &BowserPostedDatagramCount );

        if ( BowserPostedDatagramCount > BOWSER_MAX_POSTED_DATAGRAMS ) {
            InterlockedDecrement( &BowserPostedDatagramCount );
            FREE_POOL( Context );
            return STATUS_REQUEST_NOT_ACCEPTED;
        }

        //
        // Reference the Transport and TransportName to ensure they aren't deleted.   The
        // Handler routine is expected to dereference them.
        //
        BowserReferenceTransportName(TransportName);
        dprintf(DPRT_REF, ("Call Reference transport %lx from BowserPostDatagramToWorkerThread %lx (2).\n", TransportName->Transport, Handler ));
        BowserReferenceTransport( TransportName->Transport );

        //
        // Queue the workitem.
        //
        BowserQueueDelayedWorkItem( &Context->WorkItem );
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\inc\csc_bmpc.h ===
/*++

    Copyright (c) 2000 Microsoft Corporation

Module Name:

    csc_bmpc.h

Abstract:

    Common header file for csc bitmap code

    Client Side Bitmap common header for both kernel mode code and user
    mode code. The 'c' in the filename means 'Common header'

Author:

    Nigel Choi [t-nigelc]  Sept 3, 1999

--*/


#ifndef _CSC_BMPC_H_
#define _CSC_BMPC_H_

typedef struct CscBmpFileHdr {
    DWORD magicnum;
    BYTE  inuse;  // a BOOL
    BYTE  valid;  // a BOOL
    DWORD sizeinbits;
    DWORD numDWORDs;
} CscBmpFileHdr;

#define BLOCKSIZE 4096 // # bytes per bitmapped block

#define MAGICNUM 0xAA55FF0D /* to be placed in the begining of the
			       bitmap file. For checking validity of bitmap
			       as well as version. Change if bitmap file
			       format changes, or that one bit represents
			       different number of bytes.
			     */

#define STRMNAME ":cscbmp"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\bowser\workque.c ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    workque.c

Abstract:

    This module handles the communication between the NT redirector
    FSP and the NT redirector FSD.

    It defines routines that queue requests to the FSD, and routines
    that remove requests from the FSD work queue.


Author:

    Larry Osterman (LarryO) 30-May-1990

Revision History:

    30-May-1990 LarryO

        Created

--*/

#include "precomp.h"
#pragma hdrstop

VOID
BowserCriticalThreadWorker(
    IN PVOID Ctx
    );

VOID
BowserDelayedThreadWorker(
    IN PVOID Ctx
    );

KSPIN_LOCK
BowserIrpContextInterlock = {0};

LIST_ENTRY
BowserIrpContextList = {0};

KSPIN_LOCK
BowserIrpQueueSpinLock = {0};

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, BowserAllocateIrpContext)
#pragma alloc_text(PAGE, BowserFreeIrpContext)
#pragma alloc_text(PAGE, BowserInitializeIrpContext)
#pragma alloc_text(PAGE, BowserpUninitializeIrpContext)
#pragma alloc_text(PAGE, BowserInitializeIrpQueue)
#pragma alloc_text(PAGE, BowserQueueNonBufferRequest)
#pragma alloc_text(INIT, BowserpInitializeIrpQueue)
#pragma alloc_text(PAGE4BROW, BowserUninitializeIrpQueue)
#pragma alloc_text(PAGE4BROW, BowserQueueNonBufferRequestReferenced)
#pragma alloc_text(PAGE4BROW, BowserCancelQueuedIoForFile)
#pragma alloc_text(PAGE4BROW, BowserTimeoutQueuedIrp)
#endif

//
// Variables describing browsers use of a Critical system thread.
//

BOOLEAN BowserCriticalThreadRunning = FALSE;

LIST_ENTRY BowserCriticalThreadQueue;

WORK_QUEUE_ITEM BowserCriticalThreadWorkItem;



VOID
BowserQueueCriticalWorkItem (
    IN PWORK_QUEUE_ITEM WorkItem
    )

/*++

Routine Description:

    This routine queues an item onto the critical work queue.

    This routine ensures that at most one critical system thread is consumed
    by the browser by actually queing this item onto a browser specific queue
    then enqueing a critical work queue item that processes that queue.

Arguments:

    WorkItem -- Work item to be processed on the critical work queue.

Return Value:

    NONE

--*/


{
    KIRQL OldIrql;

    //
    // Insert the queue entry into the browser specific queue.
    //
    ACQUIRE_SPIN_LOCK(&BowserIrpQueueSpinLock, &OldIrql);
    InsertTailList( &BowserCriticalThreadQueue, &WorkItem->List );

    //
    // If the browser doesn't have a critical system thread running,
    //  start one now.
    //

    if ( !BowserCriticalThreadRunning ) {

        //
        // Mark that the thread is running now
        //
        BowserCriticalThreadRunning = TRUE;
        RELEASE_SPIN_LOCK(&BowserIrpQueueSpinLock, OldIrql);

        ExInitializeWorkItem( &BowserCriticalThreadWorkItem,
                              BowserCriticalThreadWorker,
                              NULL );

        ExQueueWorkItem(&BowserCriticalThreadWorkItem, CriticalWorkQueue );

    } else {
        RELEASE_SPIN_LOCK(&BowserIrpQueueSpinLock, OldIrql);
    }

}

VOID
BowserCriticalThreadWorker(
    IN PVOID Ctx
    )
/*++

Routine Description:

    This routine processes critical browser workitems.

    This routine runs in a critical system thread.  It is the only critical
    system thread used by the browser.

Arguments:

    Ctx - Not used

Return Value:

    NONE

--*/

{
    KIRQL OldIrql;
    PLIST_ENTRY Entry;
    PWORK_QUEUE_ITEM WorkItem;

    UNREFERENCED_PARAMETER( Ctx );

    //
    // Loop processing work items
    //

    while( TRUE ) {

        //
        // If the queue is empty,
        //  indicate that this thread is no longer running.
        //  return.
        //

        ACQUIRE_SPIN_LOCK(&BowserIrpQueueSpinLock, &OldIrql);

        if ( IsListEmpty( &BowserCriticalThreadQueue ) ) {
            BowserCriticalThreadRunning = FALSE;
            RELEASE_SPIN_LOCK(&BowserIrpQueueSpinLock, OldIrql);
            return;
        }

        //
        // Remove an entry from the queue.
        //

        Entry = RemoveHeadList( &BowserCriticalThreadQueue );
        RELEASE_SPIN_LOCK(&BowserIrpQueueSpinLock, OldIrql);

        WorkItem = CONTAINING_RECORD(Entry, WORK_QUEUE_ITEM, List);

        //
        // Call the queued routine
        //

        (*WorkItem->WorkerRoutine)(WorkItem->Parameter);

    }
}



//
// Variables describing browsers use of a Delayed system thread.
//

BOOLEAN BowserDelayedThreadRunning = FALSE;

LIST_ENTRY BowserDelayedThreadQueue;

WORK_QUEUE_ITEM BowserDelayedThreadWorkItem;



VOID
BowserQueueDelayedWorkItem (
    IN PWORK_QUEUE_ITEM WorkItem
    )

/*++

Routine Description:

    This routine queues an item onto the Delayed work queue.

    This routine ensures that at most one Delayed system thread is consumed
    by the browser by actually queing this item onto a browser specific queue
    then enqueing a Delayed work queue item that processes that queue.

Arguments:

    WorkItem -- Work item to be processed on the Delayed work queue.

Return Value:

    NONE

--*/


{
    KIRQL OldIrql;

    //
    // Insert the queue entry into the browser specific queue.
    //
    ACQUIRE_SPIN_LOCK(&BowserIrpQueueSpinLock, &OldIrql);
    InsertTailList( &BowserDelayedThreadQueue, &WorkItem->List );

    //
    // If the browser doesn't have a Delayed system thread running,
    //  start one now.
    //

    if ( !BowserDelayedThreadRunning ) {

        //
        // Mark that the thread is running now
        //
        BowserDelayedThreadRunning = TRUE;
        RELEASE_SPIN_LOCK(&BowserIrpQueueSpinLock, OldIrql);

        ExInitializeWorkItem( &BowserDelayedThreadWorkItem,
                              BowserDelayedThreadWorker,
                              NULL );

        ExQueueWorkItem(&BowserDelayedThreadWorkItem, DelayedWorkQueue );

    } else {
        RELEASE_SPIN_LOCK(&BowserIrpQueueSpinLock, OldIrql);
    }

}

VOID
BowserDelayedThreadWorker(
    IN PVOID Ctx
    )
/*++

Routine Description:

    This routine processes Delayed browser workitems.

    This routine runs in a Delayed system thread.  It is the only Delayed
    system thread used by the browser.

Arguments:

    Ctx - Not used

Return Value:

    NONE

--*/

{
    KIRQL OldIrql;
    PLIST_ENTRY Entry;
    PWORK_QUEUE_ITEM WorkItem;

    UNREFERENCED_PARAMETER( Ctx );

    //
    // Loop processing work items
    //

    while( TRUE ) {

        //
        // If the queue is empty,
        //  indicate that this thread is no longer running.
        //  return.
        //

        ACQUIRE_SPIN_LOCK(&BowserIrpQueueSpinLock, &OldIrql);

        if ( IsListEmpty( &BowserDelayedThreadQueue ) ) {
            BowserDelayedThreadRunning = FALSE;
            RELEASE_SPIN_LOCK(&BowserIrpQueueSpinLock, OldIrql);
            return;
        }

        //
        // Remove an entry from the queue.
        //

        Entry = RemoveHeadList( &BowserDelayedThreadQueue );
        RELEASE_SPIN_LOCK(&BowserIrpQueueSpinLock, OldIrql);

        WorkItem = CONTAINING_RECORD(Entry, WORK_QUEUE_ITEM, List);

        //
        // Call the queued routine
        //

        (*WorkItem->WorkerRoutine)(WorkItem->Parameter);

    }
}



PIRP_CONTEXT
BowserAllocateIrpContext (
    VOID
    )
/*++

Routine Description:

    Initialize a work queue structure, allocating all structures used for it.

Arguments:

    None


Return Value:

    PIRP_CONTEXT - Newly allocated Irp Context.

--*/
{
    PIRP_CONTEXT IrpContext;
    PAGED_CODE();

    if ((IrpContext = (PIRP_CONTEXT )ExInterlockedRemoveHeadList(&BowserIrpContextList, &BowserIrpContextInterlock)) == NULL) {

        //
        //  If there are no IRP contexts in the "zone",  allocate a new
        //  Irp context from non paged pool.
        //

        IrpContext = ALLOCATE_POOL(NonPagedPool, sizeof(IRP_CONTEXT), POOL_IRPCONTEXT);

        if (IrpContext == NULL) {
            InternalError(("Could not allocate pool for IRP context\n"));
        }

        return IrpContext;
    }

    return IrpContext;
}

VOID
BowserFreeIrpContext (
    PIRP_CONTEXT IrpContext
    )
/*++

Routine Description:

    Initialize a work queue structure, allocating all structures used for it.

Arguments:

    PIRP_CONTEXT IrpContext - Irp Context to free.
    None


Return Value:


--*/
{
    PAGED_CODE();

    //
    //  We use the first two longwords of the IRP context as a list entry
    //  when we free it to the zone.
    //

    ExInterlockedInsertTailList(&BowserIrpContextList, (PLIST_ENTRY )IrpContext,
                                                        &BowserIrpContextInterlock);
}


VOID
BowserInitializeIrpContext (
    VOID
    )
/*++

Routine Description:

    Initialize the Irp Context system

Arguments:

    None.


Return Value:
    None.

--*/
{
    PAGED_CODE();

    KeInitializeSpinLock(&BowserIrpContextInterlock);
    InitializeListHead(&BowserIrpContextList);
}

VOID
BowserpUninitializeIrpContext(
    VOID
    )
{
    PAGED_CODE();

    while (!IsListEmpty(&BowserIrpContextList)) {
        PIRP_CONTEXT IrpContext = (PIRP_CONTEXT)RemoveHeadList(&BowserIrpContextList);

        FREE_POOL(IrpContext);
    }
}


VOID
BowserInitializeIrpQueue(
    PIRP_QUEUE Queue
    )
{
    PAGED_CODE();

    InitializeListHead(&Queue->Queue);

}

VOID
BowserUninitializeIrpQueue(
    PIRP_QUEUE Queue
    )
{
    KIRQL               OldIrql, CancelIrql;
    PDRIVER_CANCEL      pDriverCancel;
    PLIST_ENTRY         Entry;
    PIRP                Request;

    BowserReferenceDiscardableCode( BowserDiscardableCodeSection );

    DISCARDABLE_CODE( BowserDiscardableCodeSection );

    //
    //  Now remove this IRP from the request chain.
    //

    ACQUIRE_SPIN_LOCK(&BowserIrpQueueSpinLock, &OldIrql);

    while (!IsListEmpty(&Queue->Queue)) {

        Entry = RemoveHeadList(&Queue->Queue);

        Request = CONTAINING_RECORD(Entry, IRP, Tail.Overlay.ListEntry);

        // clear cancel routine
        Request->IoStatus.Information = 0;
        Request->Cancel = FALSE;
        pDriverCancel = IoSetCancelRoutine(Request, NULL);

        // Set to NULL in the cancel routine under BowserIrpQueueSpinLock protection.
        if ( pDriverCancel ) {
            RELEASE_SPIN_LOCK(&BowserIrpQueueSpinLock, OldIrql);
            BowserCompleteRequest(Request, STATUS_CANCELLED);
            ACQUIRE_SPIN_LOCK(&BowserIrpQueueSpinLock, &OldIrql);
        }
        // otherwise the cancel routine is running at the moment.
    }

    ASSERT (IsListEmpty(&Queue->Queue));

    //
    //  Make sure no more entries are inserted on this queue.
    //

    Queue->Queue.Flink = NULL;
    Queue->Queue.Blink = NULL;

    RELEASE_SPIN_LOCK(&BowserIrpQueueSpinLock, OldIrql);

    BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );

}

VOID
BowserCancelQueuedRequest(
    IN PDEVICE_OBJECT DeviceObject OPTIONAL,
    IN PIRP Irp
    )
/*++

Routine Description:
    This routine will cancel a queued IRP.

Arguments:
    IN PIRP Irp - Supplies the IRP to cancel.

    IN PKSPIN_LOCK SpinLock - Supplies a pointer to the spin lock protecting the
                    queue

    IN PLIST_ENTRY Queue - Supplies a pointer to the head of the queue.

Note: See bug history for more: 294055, 306281, 124178, 124180, 131773...
--*/

{
    KIRQL OldIrql;
    PLIST_ENTRY Entry, NextEntry;
    PIRP Request;
    PIRP_QUEUE Queue;
    PIO_STACK_LOCATION NextStack = IoGetNextIrpStackLocation(Irp);
    LIST_ENTRY         CancelList;

    ASSERT ( Irp->CancelRoutine == NULL );

    InitializeListHead(&CancelList);

    //
    // Release IOmgr set cancel IRP spinlock & acquire the local
    // queue protection spinlock.
    //

    IoReleaseCancelSpinLock( Irp->CancelIrql );
    ACQUIRE_SPIN_LOCK(&BowserIrpQueueSpinLock, &OldIrql);

    //
    //  Now remove this IRP from the request chain.
    //


    //
    //  A pointer to the queue is stored in the next stack location.
    //

    Queue = (PIRP_QUEUE)NextStack->Parameters.Others.Argument4;

    if (Queue != NULL && Queue->Queue.Flink != NULL) {

        for (Entry = Queue->Queue.Flink ;
             Entry != &Queue->Queue ;
             Entry = NextEntry) {

            Request = CONTAINING_RECORD(Entry, IRP, Tail.Overlay.ListEntry);

            if (Request->Cancel) {
                // we're in a cancel routine so the global cancel spinlock is locked

                NextEntry = Entry->Flink;
                RemoveEntryList(Entry);

                Request->IoStatus.Information = 0;
                Request->IoStatus.Status = STATUS_CANCELLED;
                IoSetCancelRoutine(Request, NULL);

                InsertTailList(&CancelList,Entry);

            } else {
                NextEntry = Entry->Flink;
            }

        }
    }


    RELEASE_SPIN_LOCK(&BowserIrpQueueSpinLock, OldIrql);

    while (!IsListEmpty(&CancelList)) {
        Entry = RemoveHeadList(&CancelList);
        Request = CONTAINING_RECORD(Entry, IRP, Tail.Overlay.ListEntry);
        BowserCompleteRequest(Request, Request->IoStatus.Status);
    }

    UNREFERENCED_PARAMETER(DeviceObject);

}

NTSTATUS
BowserQueueNonBufferRequest(
    IN PIRP Irp,
    IN PIRP_QUEUE Queue,
    IN PDRIVER_CANCEL CancelRoutine
    )
/*++

Routine Description:

    Queue an IRP in the specified queue.

    This routine cannot be called at an IRQ level above APC_LEVEL.

Arguments:

    Irp - Supplies the IRP to queue.

    Queue - Supplies a pointer to the head of the queue.

    CancelRoutine - Address of routine to call if the IRP is cancelled.
--*/

{
    NTSTATUS Status;

    //
    // This routine itself is paged code which calls the discardable code
    // in BowserQueueNonBufferRequestReferenced().
    //
    PAGED_CODE();

    BowserReferenceDiscardableCode( BowserDiscardableCodeSection );
    DISCARDABLE_CODE( BowserDiscardableCodeSection );

    Status = BowserQueueNonBufferRequestReferenced( Irp,
                                                    Queue,
                                                    CancelRoutine );

    BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );

    return Status;
}

NTSTATUS
BowserQueueNonBufferRequestReferenced(
    IN PIRP Irp,
    IN PIRP_QUEUE Queue,
    IN PDRIVER_CANCEL CancelRoutine
    )
/*++

Routine Description:

    Queue an IRP in the specified queue.

    This routine can only be called if the BowserDiscardableCodeSection
    is already referenced.  It can be called at any IRQ level.

Arguments:

    Irp - Supplies the IRP to queue.

    Queue - Supplies a pointer to the head of the queue.

    CancelRoutine - Address of routine to call if the IRP is cancelled.
--*/

{
    KIRQL OldIrql, CancelIrql;
    LARGE_INTEGER CurrentTickCount;
    PIO_STACK_LOCATION NextStackLocation;
    BOOL bReleaseSpinlocks;

    DISCARDABLE_CODE( BowserDiscardableCodeSection );


//    DbgPrint("Queue IRP %lx to queue %lx\n", Irp, Queue);

    //
    //  Insert the request into the request announcement list.
    //

    ACQUIRE_SPIN_LOCK(&BowserIrpQueueSpinLock, &OldIrql);

    if (Queue->Queue.Flink == NULL) {

        ASSERT (Queue->Queue.Blink == NULL);
        RELEASE_SPIN_LOCK(&BowserIrpQueueSpinLock, OldIrql);

        return(STATUS_CANCELLED);
    }

    //
    //  Flag that this request is going to be pending.
    //

    IoMarkIrpPending(Irp);

    InsertTailList(&Queue->Queue, &Irp->Tail.Overlay.ListEntry);

    //
    //  Make sure there's room enough in the stack location for this.
    //

    ASSERT (Irp->CurrentLocation <= Irp->StackCount);

    NextStackLocation = IoGetNextIrpStackLocation(Irp);

    //
    //  Stick the current tick count into the next IRP stack location
    //  for this IRP.  This allows us to figure out if these IRP's have been
    //  around for "too long".
    //
    // Beware:the IRP stack location is unaligned.
    //

    KeQueryTickCount( &CurrentTickCount );
    *((LARGE_INTEGER UNALIGNED *)&NextStackLocation->Parameters.Others.Argument1) =
        CurrentTickCount;


    //
    //  Link the queue into the IRP.
    //

    NextStackLocation->Parameters.Others.Argument4 = (PVOID)Queue;

    // WARNING: double spinlock condition
    IoAcquireCancelSpinLock(&CancelIrql);
    bReleaseSpinlocks = TRUE;

    if (Irp->Cancel) {

        //
        // The Irp is in cancellable state:
        // if CancelRoutine == NULL, the routine is currently running
        // Otherwise, we need to cancel it ourselves
        //
        if ( Irp->CancelRoutine ) {
            // cacelable:
            //   - rm is valid since we're still holding BowserIrpQueueSpinLock
            RemoveEntryList( &Irp->Tail.Overlay.ListEntry );

            // release spinlocks before completing the request
            IoReleaseCancelSpinLock(CancelIrql);
            RELEASE_SPIN_LOCK(&BowserIrpQueueSpinLock, OldIrql);
            bReleaseSpinlocks = FALSE;

            // complete.
            BowserCompleteRequest ( Irp, STATUS_CANCELLED );
        }
        // else CancelRoutine is running
    } else {

        IoSetCancelRoutine(Irp, CancelRoutine);
    }

    if ( bReleaseSpinlocks ) {
        // release spinlocks
        IoReleaseCancelSpinLock(CancelIrql);
        RELEASE_SPIN_LOCK(&BowserIrpQueueSpinLock, OldIrql);
    }

    return STATUS_PENDING;

}

VOID
BowserTimeoutQueuedIrp(
    IN PIRP_QUEUE Queue,
    IN ULONG NumberOfSecondsToTimeOut
    )
/*++

Routine Description:
    This routine will scan an IRP queue and time out any requests that have
    been on the queue for "too long"

Arguments:
    IN PIRP_QUEUE Queue - Supplies the Queue to scan.
    IN ULONG NumberOfSecondsToTimeOut - Supplies the number of seconds a request
                                            should remain on the queue.

Return Value:
    None

    This routine will also complete any canceled queued requests it finds (on
    general principles).

--*/

{
    PIRP Irp;
    KIRQL OldIrql, CancelIrql;
    PDRIVER_CANCEL pDriverCancel;
    PLIST_ENTRY Entry, NextEntry;
    LARGE_INTEGER Timeout;
    LIST_ENTRY    CancelList;

    BowserReferenceDiscardableCode( BowserDiscardableCodeSection );

    DISCARDABLE_CODE( BowserDiscardableCodeSection );

    InitializeListHead(&CancelList);

    //
    //  Compute the timeout time into 100ns units.
    //

    Timeout.QuadPart = (LONGLONG)NumberOfSecondsToTimeOut * (LONGLONG)(10000*1000);

    //
    //  Now convert the timeout into a number of ticks.
    //

    Timeout.QuadPart = Timeout.QuadPart / (LONGLONG)KeQueryTimeIncrement();

    ASSERT (Timeout.HighPart == 0);

//    DbgPrint("Dequeue irp from queue %lx...", Queue);

    ACQUIRE_SPIN_LOCK(&BowserIrpQueueSpinLock, &OldIrql);


    for (Entry = Queue->Queue.Flink ;
         Entry != &Queue->Queue ;
         Entry = NextEntry) {

        Irp = CONTAINING_RECORD(Entry, IRP, Tail.Overlay.ListEntry);

        //
        //  If the request was canceled, this is a convenient time to cancel
        //  it.
        //

        if (Irp->Cancel) {

            NextEntry = Entry->Flink;

            pDriverCancel = IoSetCancelRoutine(Irp, NULL);

            // Set to NULL in the cancel routine under BowserIrpQueueSpinLock protection.
            if ( pDriverCancel ) {

                Irp->IoStatus.Information = 0;
                Irp->IoStatus.Status      = STATUS_CANCELLED;

                RemoveEntryList(Entry);

                InsertTailList(&CancelList,Entry);
            }
            // otherwise the cancel routine is running at the moment.



        //
        //  Now check to see if this request is "too old".  If it is, complete
        //  it with an error.
        //

        } else {
            PIO_STACK_LOCATION NextIrpStackLocation;
            LARGE_INTEGER CurrentTickCount;
            LARGE_INTEGER RequestTime;
            LARGE_INTEGER Temp;

            NextIrpStackLocation = IoGetNextIrpStackLocation(Irp);

            //
            //  Snapshot the current tickcount.
            //

            KeQueryTickCount(&CurrentTickCount);

            //
            //  Figure out how many seconds this request has been active for
            //

            Temp.LowPart = (*((LARGE_INTEGER UNALIGNED *)&NextIrpStackLocation->Parameters.Others.Argument1)).LowPart;
            Temp.HighPart= (*((LARGE_INTEGER UNALIGNED *)&NextIrpStackLocation->Parameters.Others.Argument1)).HighPart;
            RequestTime.QuadPart = CurrentTickCount.QuadPart - Temp.QuadPart;

            ASSERT (RequestTime.HighPart == 0);

            //
            //  If this request has lasted "too long", then time it
            //  out.
            //

            if (RequestTime.LowPart > Timeout.LowPart) {


                NextEntry = Entry->Flink;

                pDriverCancel = IoSetCancelRoutine(Irp, NULL);

                // Set to NULL in the cancel routine under BowserIrpQueueSpinLock protection.
                if ( pDriverCancel ) {

                    Irp->IoStatus.Information = 0;
                    Irp->IoStatus.Status      = STATUS_IO_TIMEOUT;

                    RemoveEntryList(Entry);

                    InsertTailList(&CancelList,Entry);
                }
                // otherwise it the cancel routine is running


            } else {
                NextEntry = Entry->Flink;
            }
        }

    }

    RELEASE_SPIN_LOCK(&BowserIrpQueueSpinLock, OldIrql);

    while (!IsListEmpty(&CancelList)) {
        Entry = RemoveHeadList(&CancelList);
        Irp = CONTAINING_RECORD(Entry, IRP, Tail.Overlay.ListEntry);
        BowserCompleteRequest(Irp, Irp->IoStatus.Status);
    }

    BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );

//    DbgPrint("%lx.\n", Irp);


}

PIRP
BowserDequeueQueuedIrp(
    IN PIRP_QUEUE Queue
    )
{
    PIRP Irp;
    KIRQL OldIrql;
    PLIST_ENTRY IrpEntry;

//    DbgPrint("Dequeue irp from queue %lx...", Queue);

    ACQUIRE_SPIN_LOCK(&BowserIrpQueueSpinLock, &OldIrql);

    if (IsListEmpty(&Queue->Queue)) {
        //
        //  There are no waiting request announcement FsControls, so
        //  return success.
        //

        RELEASE_SPIN_LOCK(&BowserIrpQueueSpinLock, OldIrql);

//        DbgPrint("No entry found.\n");
        return NULL;
    }

    IrpEntry = RemoveHeadList(&Queue->Queue);

    Irp = CONTAINING_RECORD(IrpEntry, IRP, Tail.Overlay.ListEntry);

    IoAcquireCancelSpinLock(&Irp->CancelIrql);

    //
    //  Remove the cancel request for this IRP.
    //

    Irp->Cancel = FALSE;

    IoSetCancelRoutine(Irp, NULL);

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    RELEASE_SPIN_LOCK(&BowserIrpQueueSpinLock, OldIrql);

//    DbgPrint("%lx.\n", Irp);
    return Irp;
}


VOID
BowserCancelQueuedIoForFile(
    IN PIRP_QUEUE Queue,
    IN PFILE_OBJECT FileObject
    )
{
    KIRQL OldIrql;
    PLIST_ENTRY Entry, NextEntry;
    PDRIVER_CANCEL pDriverCancel;
    PIRP Request;
    LIST_ENTRY CancelList;

    BowserReferenceDiscardableCode( BowserDiscardableCodeSection );

    DISCARDABLE_CODE( BowserDiscardableCodeSection );

    InitializeListHead(&CancelList);

    //
    //  Walk the outstanding IRP list for this
    //

    ACQUIRE_SPIN_LOCK(&BowserIrpQueueSpinLock, &OldIrql);

    for (Entry = Queue->Queue.Flink ;
         Entry != &Queue->Queue ;
         Entry = NextEntry) {

        Request = CONTAINING_RECORD(Entry, IRP, Tail.Overlay.ListEntry);

        //
        //  If the request was canceled, blow it away.
        //

        if (Request->Cancel) {

            NextEntry = Entry->Flink;

            // This is the cancel routine setting of cancel routine ptr to NULL.
            pDriverCancel = IoSetCancelRoutine(Request, NULL);

            // Set to NULL in the cancel routine under BowserIrpQueueSpinLock protection.
            if ( pDriverCancel ) {

                RemoveEntryList(Entry);
                Request->IoStatus.Information = 0;
                Request->IoStatus.Status      = STATUS_CANCELLED;

                InsertTailList(&CancelList,Entry);
            }
            // otherwise the cancel routine is running currently.

        //
        //  If the request was for this file object, blow it away.
        //

        } else if (Request->Tail.Overlay.OriginalFileObject == FileObject) {

            NextEntry = Entry->Flink;

            // This is the cancel routine setting of cancel routine ptr to NULL.
            pDriverCancel = IoSetCancelRoutine(Request, NULL);

            // Set to NULL in the cancel routine under BowserIrpQueueSpinLock protection.
            if ( pDriverCancel ) {

                RemoveEntryList(Entry);

                Request->IoStatus.Information = 0;
                Request->IoStatus.Status      = STATUS_FILE_CLOSED;

                InsertTailList(&CancelList,Entry);
            }
            // otherwise the cancel routine is running currently.

        } else {
            NextEntry = Entry->Flink;
        }

    }

    RELEASE_SPIN_LOCK(&BowserIrpQueueSpinLock, OldIrql);

    while (!IsListEmpty(&CancelList)) {
        Entry = RemoveHeadList(&CancelList);
        Request = CONTAINING_RECORD(Entry, IRP, Tail.Overlay.ListEntry);
        BowserCompleteRequest(Request, Request->IoStatus.Status);
    }

    BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );
}


VOID
BowserpInitializeIrpQueue(
    VOID
    )
{
    KeInitializeSpinLock(&BowserIrpQueueSpinLock);
    InitializeListHead( &BowserCriticalThreadQueue );
    InitializeListHead( &BowserDelayedThreadQueue );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\inc\generr.h ===
//
// err.h: Declares data, defines and struct types for error handling
//          module.
//
//

#ifndef __GENERR_H__
#define __GENERR_H__

// Requires comm.h to be included prior to this
//

/////////////////////////////////////////////////////  INCLUDES
/////////////////////////////////////////////////////  DEFINES

#ifdef DEBUG

// Dump flags used in g_uDumpFlags
//
#define DF_RECLIST      0x0001
#define DF_RECITEM      0x0002
#define DF_RECNODE      0x0004
#define DF_CREATETWIN   0x0008
#define DF_ATOMS        0x0010
#define DF_CRL          0x0020
#define DF_CBS          0x0040
#define DF_CPATH        0x0080
#define DF_PATHS        0x0100
#define DF_UPDATECOUNT  0x0200
#define DF_TWINPAIR     0x0400
#define DF_FOLDERTWIN   0x0800
#define DF_CHOOSESIDE   0x1000

// Break flags used in g_uBreakFlags
//
#define BF_ONOPEN       0x0001
#define BF_ONCLOSE      0x0002
#define BF_ONRUNONCE    0x0004
#define BF_ONVALIDATE   0x0010
#define BF_ONTHREADATT  0x0100
#define BF_ONTHREADDET  0x0200
#define BF_ONPROCESSATT 0x0400
#define BF_ONPROCESSDET 0x0800

#endif

// Trace flags used in g_uTraceFlags (defined in retail on purpose)
//
#define TF_ALWAYS       0x0000
#define TF_WARNING      0x0001
#define TF_ERROR        0x0002
#define TF_GENERAL      0x0004      // Standard briefcase trace messages
#define TF_FUNC         0x0008      // Trace function calls
#define TF_CACHE        0x0010      // Cache-specific trace messages
#define TF_ATOM         0x0020      // Atom-specific trace messages
#define TF_PROGRESS     0x0040      // Progress bar deltas

//---------------------------------------------------------------------------
// HRESULT error codes
//---------------------------------------------------------------------------

// Map a TWINRESULT error value into a HRESULT
// Note: TR_SUCCESS should not be mapped
// Note: This assumes that TWINRESULT errors fall in the range -32k to 32k.
//
#define TR_DELTAVALUE           1000
#define FACILITY_TR             0x018a          // magic number

#define HRESULT_FROM_TR(x)      (TR_SUCCESS == (x) ? NOERROR : \
                                                   ((HRESULT) ((((x) + TR_DELTAVALUE) & 0x0000FFFF) | (FACILITY_TR << 16) | 0x80000000)))
#define IS_ENGINE_ERROR(hr)     IsFlagSet(hr, ((FACILITY_TR << 16) | 0x80000000))
#define GET_TR(hr)              ((TWINRESULT)((hr) & 0x0000FFFF) - TR_DELTAVALUE)

HRESULT PUBLIC MapToOfficialHresult(HRESULT hres);

// SCODE values that correspond to TWINRESULT values
#define E_TR_RH_LOAD_FAILED         MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_RH_LOAD_FAILED)
#define E_TR_SRC_OPEN_FAILED        MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_SRC_OPEN_FAILED)
#define E_TR_SRC_READ_FAILED        MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_SRC_READ_FAILED)
#define E_TR_DEST_OPEN_FAILED       MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_DEST_OPEN_FAILED)
#define E_TR_DEST_WRITE_FAILED      MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_DEST_WRITE_FAILED)
#define E_TR_ABORT                  MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_ABORT)
#define E_TR_UNAVAILABLE_VOLUME     MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_UNAVAILABLE_VOLUME)
#define E_TR_OUT_OF_MEMORY          MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_OUT_OF_MEMORY)
#define E_TR_FILE_CHANGED           MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_FILE_CHANGED)
#define E_TR_DUPLICATE_TWIN         MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_DUPLICATE_TWIN)
#define E_TR_DELETED_TWIN           MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_DELETED_TWIN)
#define E_TR_HAS_FOLDER_TWIN_SRC    MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_HAS_FOLDER_TWIN_SRC)
#define E_TR_INVALID_PARAMETER      MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_INVALID_PARAMETER)
#define E_TR_SAME_FOLDER            MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_SAME_FOLDER)
#define E_TR_SUBTREE_CYCLE_FOUND    MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_SUBTREE_CYCLE_FOUND)
#define E_TR_NO_MERGE_HANDLER       MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_NO_MERGE_HANDLER)
#define E_TR_MERGE_INCOMPLETE       MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_MERGE_INCOMPLETE)
#define E_TR_TOO_DIFFERENT          MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_TOO_DIFFERENT)
#define E_TR_BRIEFCASE_LOCKED       MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_BRIEFCASE_LOCKED)
#define E_TR_BRIEFCASE_OPEN_FAILED  MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_BRIEFCASE_OPEN_FAILED)
#define E_TR_BRIEFCASE_READ_FAILED  MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_BRIEFCASE_READ_FAILED)
#define E_TR_BRIEFCASE_WRITE_FAILED MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_BRIEFCASE_WRITE_FAILED)
#define E_TR_CORRUPT_BRIEFCASE      MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_CORRUPT_BRIEFCASE)
#define E_TR_NEWER_BRIEFCASE        MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_NEWER_BRIEFCASE)
#define E_TR_NO_MORE                MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_NO_MORE)

/////////////////////////////////////////////////////  MACROS

// Error table for lookup strings.  Usually an array of these
// structures is created and placed in the readonly data segment.
//
typedef struct _SETbl
    {
    HRESULT hres;       // standard result
    UINT    ids;        // String ID of message
    UINT    uStyle;     // MB_ flags
    } SETbl, * PSETBL;

typedef SETbl const *  PCSETBL;

int PUBLIC SEMsgBox(HWND hwnd, UINT idsCaption, SCODE sc, PCSETBL pseTable, UINT cArraySize);


// Retry loop
//
#define RETRY_BEGIN(bInit)      {BOOL bMyRetry; do { bMyRetry = (bInit);
#define RETRY_END()             } while (bMyRetry); }
#define RETRY_SET()             bMyRetry = TRUE
#define RETRY_CLEAR()           bMyRetry = FALSE


// Debugging macros
//

#ifdef DEBUG

#define DEBUG_CASE_STRING(x)    case x: return #x

#define ASSERTSEG

// Use this macro to declare message text that will be placed
// in the CODE segment (useful if DS is getting full)
//
// Ex: DEBUGTEXT(szMsg, "Invalid whatever: %d");
//
#define DEBUGTEXT(sz, msg)	/* ;Internal */ \
    static const char ASSERTSEG sz[] = msg;

void PUBLIC BrfAssertFailed(LPCSTR szFile, int line);
void CPUBLIC BrfAssertMsg(BOOL f, LPCSTR pszMsg, ...);
void CPUBLIC GenErrDebugMsg(UINT mask, LPCSTR pszMsg, ...);

// ASSERT(f)  -- Generate "assertion failed in line x of file.c"
//               message if f is NOT true.
//
#define ASSERT(f)                                                       \
    {                                                                   \
        DEBUGTEXT(szFile, __FILE__);                                    \
        if (!(f))                                                       \
            BrfAssertFailed(szFile, __LINE__);                          \
    }
#define ASSERT_E(f)  ASSERT(f)

// ASSERT_MSG(f, msg, args...)  -- Generate wsprintf-formatted msg w/params
//                          if f is NOT true.
//
#define ASSERT_MSG   BrfAssertMsg

// DEBUG_MSG(mask, msg, args...) - Generate wsprintf-formatted msg using
//                          specified debug mask.  System debug mask
//                          governs whether message is output.
//
#define DEBUG_MSG    GenErrDebugMsg
#define TRACE_MSG    DEBUG_MSG

// VERIFYSZ(f, msg, arg)  -- Generate wsprintf-formatted msg w/ 1 param
//                          if f is NOT true 
//
#define VERIFYSZ(f, szFmt, x)   ASSERT_MSG(f, szFmt, x)


// VERIFYSZ2(f, msg, arg1, arg2)  -- Generate wsprintf-formatted msg w/ 2
//                          param if f is NOT true 
//
#define VERIFYSZ2(f, szFmt, x1, x2)   ASSERT_MSG(f, szFmt, x1, x2)



// DBG_ENTER(szFn)  -- Generates a function entry debug spew for
//                          a function 
//
#define DBG_ENTER(szFn)                  \
    TRACE_MSG(TF_FUNC, " > " szFn "()")


// DBG_ENTER_SZ(szFn, sz)  -- Generates a function entry debug spew for
//                          a function that accepts a string as one of its
//                          parameters.
//
#define DBG_ENTER_SZ(szFn, sz)                  \
    TRACE_MSG(TF_FUNC, " > " szFn "(..., \"%s\",...)", Dbg_SafeStr(sz))


// DBG_ENTER_DTOBJ(szFn, pdtobj, szBuf)  -- Generates a function entry 
//                          debug spew for a function that accepts a 
//                          string as one of its parameters.
//
#define DBG_ENTER_DTOBJ(szFn, pdtobj, szBuf) \
    TRACE_MSG(TF_FUNC, " > " szFn "(..., %s,...)", Dbg_DataObjStr(pdtobj, szBuf))


// DBG_ENTER_RIID(szFn, riid)  -- Generates a function entry debug spew for
//                          a function that accepts an riid as one of its
//                          parameters.
//
#define DBG_ENTER_RIID(szFn, riid)                  \
    TRACE_MSG(TF_FUNC, " > " szFn "(..., %s,...)", Dbg_GetRiidName(riid))


// DBG_EXIT(szFn)  -- Generates a function exit debug spew 
//
#define DBG_EXIT(szFn)                              \
        TRACE_MSG(TF_FUNC, " < " szFn "()")

// DBG_EXIT_US(szFn, us)  -- Generates a function exit debug spew for
//                          functions that return a USHORT.
//
#define DBG_EXIT_US(szFn, us)                       \
        TRACE_MSG(TF_FUNC, " < " szFn "() with %#x", (USHORT)us)

// DBG_EXIT_UL(szFn, ul)  -- Generates a function exit debug spew for
//                          functions that return a ULONG.
//
#define DBG_EXIT_UL(szFn, ul)                   \
        TRACE_MSG(TF_FUNC, " < " szFn "() with %#lx", (ULONG)ul)

// DBG_EXIT_PTR(szFn, pv)  -- Generates a function exit debug spew for
//                          functions that return a pointer.
//
#define DBG_EXIT_PTR(szFn, pv)                   \
        TRACE_MSG(TF_FUNC, " < " szFn "() with %#lx", (LPVOID)pv)

// DBG_EXIT_HRES(szFn, hres)  -- Generates a function exit debug spew for
//                          functions that return an HRESULT.
//
#define DBG_EXIT_HRES(szFn, hres)                   \
        TRACE_MSG(TF_FUNC, " < " szFn "() with %s", Dbg_GetScode(hres))


#else

#define ASSERT(f)
#define ASSERT_E(f)      (f)
#define ASSERT_MSG   1 ? (void)0 : (void)
#define DEBUG_MSG    1 ? (void)0 : (void)
#define TRACE_MSG    1 ? (void)0 : (void)

#define VERIFYSZ(f, szFmt, x)     (f)

#define DBG_ENTER(szFn)
#define DBG_ENTER_SZ(szFn, sz)
#define DBG_ENTER_DTOBJ(szFn, pdtobj, sz)
#define DBG_ENTER_RIID(szFn, riid)   

#define DBG_EXIT(szFn)                            
#define DBG_EXIT_US(szFn, us)
#define DBG_EXIT_UL(szFn, ul)
#define DBG_EXIT_PTR(szFn, ptr)                            
#define DBG_EXIT_HRES(szFn, hres)   

#endif

/////////////////////////////////////////////////////  TYPEDEFS

/////////////////////////////////////////////////////  EXPORTED DATA

/////////////////////////////////////////////////////  PUBLIC PROTOTYPES

#ifdef DEBUG

void PUBLIC DEBUG_BREAK(UINT flag);

LPCSTR PUBLIC Dbg_GetRiidName(REFIID riid);
LPCSTR PUBLIC Dbg_GetScode(HRESULT hres);
LPCSTR PUBLIC Dbg_SafeStr(LPCSTR psz);
LPCSTR PUBLIC Dbg_DataObjStr(LPDATAOBJECT pdtobj, LPSTR pszBuf);

#endif

#endif // __ERR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\inc\assert.h ===
#ifndef __ASSERT_H__
#define __ASSERT_H__
/* Routines for debugging and error messages. */


#ifdef DEBUG
#define VERIFY(f) {if(!(f)) AssertFn(szError, szFileAssert,__LINE__);}
#else
#define VERIFY(f)
#endif

#ifdef VxD

#define AssertFn  IFSMgr_AssertFailed
#define PrintFn   IFSMgr_Printf

#else

#define AssertFn  AssertFn
#define PrintFn   PrintFn

#endif

#ifdef DEBUG

#define AssertData static char szFileAssert[] = __FILE__;
#define AssertError static char szError[] = "Error";
#define Assert(f)  do {if (!(f)) AssertFn(szError, szFileAssert, __LINE__);} while(0)
#define AssertSz(f, sz)  do {if (!(f)) AssertFn(sz, szFileAssert, __LINE__);} while(0)
#define DEBUG_PRINT(_x_)  PrintFn _x_
#else

#define Assert(f)
#define AssertData
#define AssertError
#define AssertSz(f, sz)
#define DEBUG_PRINT(_X_)

#endif


#ifdef VxD
void IFSMgr_AssertFailed(PSZ pMsg, PSZ pFile, unsigned long uLine);
void IFSMgr_Printf(PSZ pFmt, ...);
#else
VOID __cdecl AssertFn(LPSTR lpMsg, LPSTR lpFile, ULONG uLine);
VOID __cdecl PrintFn(LPSTR lpFmt, ...);
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\inc\lib3.h ===
#ifndef __LIB3_H__
#define __LIB3_H__

#ifdef __cplusplus
extern "C" {
#endif

#undef VxD



#include "shdcom.h"

#ifndef __COPYCHUNKCONTEXT__
#define __COPYCHUNKCONTEXT__
typedef struct tagCOPYCHUNKCONTEXT
{
    DWORD    dwFlags;
    ULONG    LastAmountRead;
    ULONG    TotalSizeBeforeThisRead;
    HANDLE   handle;
    ULONG    ChunkSize;
    ULONG    Context[1];
}
COPYCHUNKCONTEXT;
#endif

/* lib3.c */

#ifdef UNICODE

#define GetShadow                           GetShadowW
#define GetShadowEx                         GetShadowExW
#define CreateShadow                        CreateShadowW
#define GetShadowInfo                       GetShadowInfoW
#define GetShadowInfoEx                     GetShadowInfoExW
#define SetShadowInfo                       SetShadowInfoW
#define GetUNCPath                          GetUNCPathW
#define FindOpenShadow                      FindOpenShadowW
#define FindNextShadow                      FindNextShadowW
#define AddHint                             AddHintW
#define DeleteHint                          DeleteHintW
#define GetShareInfo                       GetShareInfoW
#define ChkUpdtStatus                       ChkUpdtStatusW
#define FindOpenHint                        FindOpenHintW
#define FindNextHint                        FindNextHintW
#define LpAllocCopyParams                   LpAllocCopyParamsW
#define FreeCopyParams                      FreeCopyParamsW
#define CopyShadow                          CopyShadowW
#define GetShadowDatabaseLocation           GetShadowDatabaseLocationW
#define GetNameOfServerGoingOffline         GetNameOfServerGoingOfflineW
#else

#define GetShadow                           GetShadowA
#define GetShadowEx                         GetShadowExA
#define CreateShadow                        CreateShadowA
#define GetShadowInfo                       GetShadowInfoA
#define GetShadowInfoEx                     GetShadowInfoExA
#define SetShadowInfo                       SetShadowInfoA
#define GetUNCPath                          GetUNCPathA
#define FindOpenShadow                      FindOpenShadowA
#define FindNextShadow                      FindNextShadowA
#define AddHint                             AddHintA
#define DeleteHint                          DeleteHintA
#define GetShareInfo                       GetShareInfoA
#define ChkUpdtStatus                       ChkUpdtStatusA
#define FindOpenHint                        FindOpenHintA
#define FindNextHint                        FindNextHintA
#define LpAllocCopyParams                   LpAllocCopyParamsA
#define FreeCopyParams                      FreeCopyParamsA
#define CopyShadow                          CopyShadowA
#define GetShadowDatabaseLocation           GetShadowDatabaseLocationA
#endif



HANDLE __OpenShadowDatabaseIO(ULONG WaitForDriver);
#define  OpenShadowDatabaseIO() (__OpenShadowDatabaseIO(0))
/*++

Routine Description:

    This routine is called by the callers in usermode using "APIs" in this file
    in order to establish a means of communicating with redir in the kernel mode. All
    the APIs are wrappers to various device IO controls to the redir in order to accomplish
    the appropriate task

Arguments:

    None. The waitfordriver argument is a temporary hack which will be removed soon.
    All callers should call OpenShadowDatabaseIO().


Returns:
    If suuccessful, it returns a handle to the redir (actually a symbolic link called shadow)
    Returns IMVALID_HANDLE_VALUE if it fails. GetLastError() gives the error value.

Notes:

    This is a wrapper function that does CreateFile on the "Shadow" deviceobject.

--*/



void CloseShadowDatabaseIO(HANDLE hShadowDB);
/*++

Routine Description:

    Closes the handle opened for communicating with the redir.

Arguments:

    Handle returned from a successful OpenShadowDatabaseIO call.

Returns:

    Nothing.

Notes:

    It is important to have a matching CloseShadowDatabaseIO call for every successful open
    call, otherwise the redir may not be able to stop in the net stop redir command.

--*/



int GetShadow(HANDLE hShadowDB, HSHADOW hDir, LPHSHADOW lphShadow, LPWIN32_FIND_DATA lpFind32, unsigned long *lpuStatus);
/*++

Routine Description:
    Given the directory Inode and a name of an entry within that directory, returns the
    WIN32 strucutre for the entry and it's current status. For definition of status bits
    refer to shdcom.h.

Arguments:

    hShadowDB   Handle to the shadow database as obtained from OpenShadowDatabaseIO.
                if INVALID_HANDLE_VALUE is passed in, the API, opens the shadow database,
                issues the corresponding ioctl, and closes it before returning.

    hDir        The directory Inode value obtained from either a FindOpen/FindNext call or
                from an earlier call to a GetShadow(Ex)/CreateShadow routine.

                If hDir is 0, then the name in the lpFind32 strucutre must be a UNC name
                of a share in \\server\share form.

    lphShadow   returns the Inode number for the entry in the shadow database. If hDir is 0,
                the indoe is that of the root of this share.

    lpFind32    InOut parameter. Contains the name of the entry in cFileName member. On return
                all the elements of the find strucutre are filled up. These represent the
                find32 info as obtained from the server, with any subsequent local modifications if any.

                The only significant timestamp is ftLastWriteTime. ftLastCreateTime is set to 0.
                ftLastAccessTime contains the timestamp of the original file/directory as
                returned by the server.

                If this is a root inode of a share, the info in the Find32 strucutre is cooked up.


    lpuStatus   returns the status of the entry, such as partially filled (sparse), locally modified
                etc. See SHADOW_xxx in shdcom.h

                If value returned in lphShadow is the root inode of a share, (ie if hDir is 0)
                then the status bits are SHARE_xxx as defined in shdcom.h. eg. the bits
                indicate whether the share is connected right now, whether it has any outstanding
                opens, whether it is operating in disconnected state etc.

Returns:

    1 if successful, 0 otherwise. GetlastError() gives the error of unsuccessful.

Notes:

--*/



int GetShadowEx(HANDLE hShadowDB, HSHADOW hDir, LPWIN32_FIND_DATA lpFind32, LPSHADOWINFO lpSI);
/*++

Routine Description:

    Given the directory Inode and a name of an entry within that directory, returns the
    WIN32 strucutre for the entry and all it's metadata maintained by the shadowing database.
    For a defintion of SHADOWINFO structure refer to shdcom.h


Arguments:

    hShadowDB   Handle to the shadow database as obtained from OpenShadowDatabaseIO.
                if INVALID_HANDLE_VALUE is passed in, the API, opens the shadow database,
                issues the corresponding ioctl, and closes it before returning.

    hDir        The directory Inode value obtained from either a FindOpen/FindNext call or
                from an earlier call to a GetShadow(Ex)/CreateShadow routine

                If hDir is 0, then the name in the lpFind32 strucutre must be a UNC name
                of a share in \\server\share form.

    lphShadow   returns the Inode number for the entry in the shadow database

    lpFind32    InOut parameter. Contains the name of the entry in cFileName member. On return
                all the elements of the find strucutre are filled up. These represent the
                find32 info as obtained from the server, with any subsequent local modifications if any.

                The only significant timestamp is ftLastWriteTime. ftLastCreateTime is set to 0.
                ftLastAccessTime contains the timestamp of the original file/directory as
                returned by the server.

                When the object is in ssync, both the local and remote timestamps are identical.

                If this is a root inode of a share, the info in the Find32 strucutre is cooked up.

    lpSI        returns all the information about the entry maintained by the CSC database.


                If value returned in lphShadow is the root inode of a share, (ie if hDir is 0)
                then the status bits in lpSI->uStatus are SHARE_xxx as defined in shdcom.h.
                eg. the bits indicate whether the share is connected right now, whether it has
                any outstanding opens, whether it is operating in disconnected state etc.

Returns:

    1 if successful, 0 otherwise. GetlastError() gives the error of unsuccessful.

Notes:

    GetShadowEx is a superset of GetShadow and should be preferred.

--*/



int CreateShadow(HANDLE hShadowDB, HSHADOW hDir, LPWIN32_FIND_DATA lpFind32, unsigned long uStatus, LPHSHADOW lphShadow);
/*++

Routine Description:

                Given the directory Inode and WIN32 strucutre for a file/directory, creates an
                Inode for the same.

Arguments:

    hShadowDB   Handle to the shadow database as obtained from OpenShadowDatabaseIO.
                if INVALID_HANDLE_VALUE is passed in, the API, opens the shadow database,
                issues the corresponding ioctl, and closes it before returning.

    hDir        The directory Inode value obtained from either a FindOpen/FindNext call or
                from an earlier call to a GetShadow(Ex)/CreateShadow routine, or 0 which
                indicates the root inode of a share.


    lpFind32    Should contain all the elements of the find32 info as obtained from the server.
                Only the ftLastWriteTime timestamp is used, other timestamps are ignored.

                If hDir is 0, then the name in the lpFind32 strucutre must be a UNC name
                of a share in \\server\share form. All other elements of the strucutre are ignored


    uStatus     the initial status of the entry to be created, such as partially filled (sparse)
                etc. See SHADOW_xxx in shdcom.h

    lphShadow   returns the Inode number for the entry in the shadow database

Returns:

    1 if successful, 0 otherwise. GetlastError() gives the error of unsuccessful.

Notes:

    For non-root entries, if the shadow already exists, the routine works just like SetShadowInfo.

--*/




int DeleteShadow(HANDLE hShadowDB, HSHADOW hDir, HSHADOW hShadow);
/*++

Routine Description:

    Deletes an entry from the shadow database.

Arguments:

    hShadowDB   Handle to the shadow database as obtained from OpenShadowDatabaseIO.
                if INVALID_HANDLE_VALUE is passed in, the API, opens the shadow database,
                issues the corresponding ioctl, and closes it before returning.

    hDir        The directory Inode value obtained from either a FindOpen/FindNext call or
                from an earlier call to a GetShadow(Ex)/CreateShadow routine, or 0 which
                indicates the root inode of a share.



    hShadow     Inode value obtained from either a FindOpen/FindNext call or
                from an earlier call to a GetShadow(Ex)/CreateShadow routine. This
                inode represents a child of the directory represented by hDir.


Returns:

    1 if successful, 0 if failed. (Error reporting is not very good here)

Notes:

    The routine failes if hShadow is a directory and has descendents of it's own.
    If hDir is 0, then the root of the share is deleted. This would cause the share to
    be inaccessible in disconnected state, because it would have gone from the
    CSC database.

--*/




int GetShadowInfo(HANDLE hShadowDB, HSHADOW hDir, HSHADOW hShadow, LPWIN32_FIND_DATA lpFind32, unsigned long *lpuStatus);
/*++

Routine Description:

    Given the directory Inode and an inode within that directory, returns the
    WIN32 strucutre for the entry and it's current status. For definition of status bits
    refer to shdcom.h.

Arguments:

    hShadowDB   Handle to the shadow database as obtained from OpenShadowDatabaseIO.
                if INVALID_HANDLE_VALUE is passed in, the API, opens the shadow database,
                issues the corresponding ioctl, and closes it before returning.

    hDir        The directory Inode value obtained from either a FindOpen/FindNext call or
                from an earlier call to a GetShadow(Ex)/CreateShadow routine, or 0 which
                indicates the root inode of a share.


    hShadow     Inode value obtained from either a FindOpen/FindNext call or
                from an earlier call to a GetShadow(Ex)/CreateShadow routine. This
                inode represents a child of the directory represented by hDir.

    lpFind32    Can be NULL. If non-NULL on return all the elements of the find strucutre
                are filled up. These represent the find32 info as obtained from the server,
                with any subsequent local modifications if any.

                The only significant timestamp is ftLastWriteTime. ftLastCreateTime is set to 0.
                ftLastAccessTime contains the timestamp of the original file/directory as
                returned by the server.

                If this is a root inode of a share, the info in the Find32 strucutre is cooked up.


    lpuStatus   returns the status of the entry, such as partially filled (sparse), locally modified
                etc. See SHADOW_xxx in shdcom.h

                If hShadow is the root inode of a share, (ie if hDir is 0) then the status bits
                are SHARE_xxx as defined in shdcom.h. eg. the bits indicate whether the
                share is connected right now, whether it has any outstanding opens, whether
                it is operating in disconnected state etc.

Returns:

    1 if successful, 0 otherwise. GetlastError() gives the error of unsuccessful.

Notes:

--*/



int GetShadowInfoEx(HANDLE hShadowDB, HSHADOW hDir, HSHADOW hShadow, LPWIN32_FIND_DATA lpFind32, LPSHADOWINFO lpSI);
/*++

Routine Description:

    Given the directory Inode and an inode within that directory, returns the
    WIN32 strucutre for the entry and it's current status. For definition of status bits
    refer to shdcom.h.

Arguments:

    hShadowDB   Handle to the shadow database as obtained from OpenShadowDatabaseIO.
                if INVALID_HANDLE_VALUE is passed in, the API, opens the shadow database,
                issues the corresponding ioctl, and closes it before returning.

    hDir        The directory Inode value obtained from either a FindOpen/FindNext call or
                from an earlier call to a GetShadow(Ex)/CreateShadow routine, or 0 which
                indicates the root inode of a share.


    hShadow     Inode value obtained from either a FindOpen/FindNext call or
                from an earlier call to a GetShadow(Ex)/CreateShadow routine. This
                inode represents a child of the directory represented by hDir.

    lpFind32    Can be NULL. If non NULL, on return all the elements of the find strucutre are
                filled up. These represent the find32 info as obtained from the server.

                The only significant timestamp is ftLastWriteTime. ftLastCreateTime is set to 0.
                ftLastAccessTime contains the timestamp of the original file/directory as
                returned by the server.

                If this is a root inode of a share, the info in the Find32 strucutre is cooked up.

    lpSI        returns all the information about the entry maintained by the CSC database.

                If hShadow a root inode of a share, (ie if hDir is 0) then the status bits in lpSI->uStatus
                are SHARE_xxx as defined in shdcom.h. eg. the bits indicate whether the
                share is connected right now, whether it has ant outstanding opens, whether
                it is operating in disconnected state etc.
Returns:

    1 if successful, 0 otherwise. GetlastError() gives the error of unsuccessful.

Notes:

    GetShadowInfoEx is a superset of GetShadowInfo and should be preferred.

--*/




int SetShadowInfo(HANDLE hShadowDB, HSHADOW hDir, HSHADOW hShadow, LPWIN32_FIND_DATA lpFind32, unsigned long uStatus, unsigned long uOp);
/*++

Routine Description:

    Given the directory Inode and an inode within that directory, sets the WIN32 strucutre
    for the entry and it's current status. For definition of status bits refer to shdcom.h.


Arguments:

    hShadowDB   Handle to the shadow database as obtained from OpenShadowDatabaseIO.
                if INVALID_HANDLE_VALUE is passed in, the API, opens the shadow database,
                issues the corresponding ioctl, and closes it before returning.

    hDir        The directory Inode value obtained from either a FindOpen/FindNext call or
                from an earlier call to a GetShadow(Ex)/CreateShadow routine, or 0 which
                indicates the root inode.

    hShadow     Inode value obtained from either a FindOpen/FindNext call or
                from an earlier call to a GetShadow(Ex)/CreateShadow routine. This
                inode represents a child of the directory represented by hDir.


    lpFind32    If Non-NULL, should contain all the elements of the find32 info as obtained from the server.
                Only the ftLastWriteTime timestamp is used.

                If NULL, no modification is done to the find data strucutre.


    uStatus     the initial status of the entry to be created, such as partially filled (sparse)
                etc. See SHADOW_xxx in shdcom.h

    uOp         specifies operation SHADOW_FLAGS_ASSIGN, SHADOW_FLAGS_AND or SHADOW_FLAGS_OR
                to do the corresponding operation between the existing status bits and the
                one passed in the uStatus parameter.

Returns:

    1 if successful 0 if failed. The routine failes if hDir is 0, ie. there is no way to set
    info on the root of a share.

Notes:

--*/



int GetUNCPath(HANDLE hShadowDB, HSHARE hShare, HSHADOW hDir, HSHADOW hShadow, LPCOPYPARAMS lpCP);
/*++

Routine Description:

    This routine returns the path of the remote file with respect to it's root, the UNC string
    of ths share and the fully qualified path of the local replica.

Arguments:

    hShadowDB   Handle to the shadow database as obtained from OpenShadowDatabaseIO.
                if INVALID_HANDLE_VALUE is passed in, the API, opens the shadow database,
                issues the corresponding ioctl, and closes it before returning.

    hShare     The share ID on which this shadow lives. (not really necessary)

    hDir        The directory Inode value obtained from either a FindOpen/FindNext call or
                from an earlier call to a GetShadow(Ex)/CreateShadow routine, or 0 which
                indicates the root inode.

    hShadow     Inode value obtained from either a FindOpen/FindNext call or
                from an earlier call to a GetShadow(Ex)/CreateShadow routine. This
                inode represents a child of the directory represented by hDir.

    lpCP        COPYPARAMS structure as defined in shdcom.h. The buffer should be big enough to
                hold two MAX_PATH size elements and one MAX_SHARE_PATH element. On return the
                appropriate entires are filled up.


Returns:

    1 if successful 0 if failed

Notes:

--*/


int GetGlobalStatus(HANDLE hShadowDB, LPGLOBALSTATUS lpGS);
/*++

Routine Description:

    Returns the status of the entire CSC database, such as the maximum size, the current size
    etc.

Arguments:

    hShadowDB   Handle to the shadow database as obtained from OpenShadowDatabaseIO.
                if INVALID_HANDLE_VALUE is passed in, the API, opens the shadow database,
                issues the corresponding ioctl, and closes it before returning.

    lpGS        GLOBALSTATUS structure returned by the API. Refer to shdcom.h for
                the strucutre definition.

Returns:

    1 if successful 0 if failed

Notes:

--*/



int FindOpenShadow(HANDLE hShadowDB, HSHADOW hDir, unsigned uOp, LPWIN32_FIND_DATA lpFind32, LPSHADOWINFO lpSI);
/*++

Routine Description:

    This API allows callers to begin enumeration of all entries in a directory in the CSC database.
    Does wildcard pattern matching.

Arguments:

    hShadowDB   Handle to the shadow database as obtained from OpenShadowDatabaseIO.
                This API does not allow passing in INVALID_HANDLE_VALUE.

    hDir        The directory Inode value obtained from either a FindOpen/FindNext call or
                from an earlier call to a GetShadow(Ex)/CreateShadow routine, or 0 which
                indicates the root inode of a share.

    uOp         Bitfield indicating which type of entries to enumerate. The alternatives are

                a) All normal entries when FINDINFO_SHADOWINFO_NORMAL is set
                b) All sparse entries when FINDINFO_SHADOWINFO_SPARSE is set
                c) All entries marked deleted when FINDINFO_SHADOWINFO_DELETED is set

                Setting FINDOPEN_SHADOWINFO_ALL enumerates all the three kind.

    lpFind32    InOut parameter. Contains the name of the entry in cFileName member, the name can
                cotain wildcard characters. On return all the elements of the find strucutre are
                filled up. These represent the find32 info as obtained from the server, with any
                subsequent local modifications if any.

                The only significant timestamp is ftLastWriteTime. ftLastCreateTime is set to 0.
                ftLastAccessTime contains the timestamp of the original file/directory as
                returned by the server.

                If this is the root inode of a share, the info in the Find32 strucutre is cooked up.

    lpSI        returns all the information about the entry maintained by the CSC database.

                If hShadow a root inode of a share, (ie if hDir is 0) then the status bits in lpSI->uStatus
                are SHARE_xxx as defined in shdcom.h. eg. the bits indicate whether the
                share is connected right now, whether it has ant outstanding opens, whether
                it is operating in disconnected state etc.


                lpSI->uEmumCookie contains the enumeration handle that should be used in
                subsequent FindNext calls.
Returns:

    1 if successful 0 if failed


Notes:

        The wildcard matching is done on both Long File Name and Short File name of an entry
        and if either one matches, the entry is returned.

--*/



int FindNextShadow(HANDLE hShadowDB, CSC_ENUMCOOKIE uEnumCookie, LPWIN32_FIND_DATA lpFind32, LPSHADOWINFO lpSI);
/*++

Routine Description:

    This API allows callers to continue enumeration of entries in a directory in the CSC database
    begun by a FindOpenHSHADOW API call. The restrictions specified by the FindOpenHSHADOW call
    such as the wildcard pattern etc. apply to this API.


Arguments:

    hShadowDB   Handle to the shadow database as obtained from OpenShadowDatabaseIO.
                This API does not allow passing in INVALID_HANDLE_VALUE.

    ulEnumCookie    The enumeration handle returned in lpSI->uEnumCOokie after a successful
                    FindOpenHSHADOW call.


    lpFind32    Output parameter. On return all the elements of the find strucutre are
                filled up. These represent the find32 info as obtained from the server, with any
                subsequent local modifications if any.

                The only significant timestamp is ftLastWriteTime. ftLastCreateTime is set to 0.
                ftLastAccessTime contains the timestamp of the original file/directory as
                returned by the server.

                If this is the root inode of a share, the info in the Find32 strucutre is cooked up.

    lpSI        returns all the information about the entry maintained by the CSC database.

                If hShadow a root inode of a share, (ie if hDir is 0) then the status bits in lpSI->uStatus
                are SHARE_xxx as defined in shdcom.h. eg. the bits indicate whether the
                share is connected right now, whether it has ant outstanding opens, whether
                it is operating in disconnected state etc.


Returns:

    1 if successful 0 if either the enumeration completed or some error happened. 

Notes:



--*/



int FindCloseShadow(HANDLE hShadowDB, CSC_ENUMCOOKIE uEnumCookie);
/*++

Routine Description:

    This API frees up the resources associated with an enumeration initiated by FindOpenHSHADOW.

Arguments:

    hShadowDB   Handle to the shadow database as obtained from OpenShadowDatabaseIO.
                This API does not allow appssing in INVALID_HANDLE_VALUE.

    ulEnumCookie    The enumeration handle returned in lpSI->uEnumCookie after a successful
                    FindOpenHSHADOW call.


Returns:


Notes:

--*/



int AddHint(HANDLE hShadowDB, HSHADOW hDir, TCHAR *cFileName, LPHSHADOW lphShadow, unsigned long ulHintFlags, unsigned long ulHintPri);
/*++

Routine Description:

    This API allows callers to set pincount and other flags on a database entry

Arguments:

    hShadowDB   Handle to the shadow database as obtained from OpenShadowDatabaseIO.
                if INVALID_HANDLE_VALUE is passed in, the API, opens the shadow database,
                issues the corresponding ioctl, and closes it before returning.

    hDir        The directory Inode value obtained from either a FindOpen/FindNext call or
                from an earlier call to a GetShadow(Ex)/CreateShadow routine, or 0 which
                indicates the root inode.

    cFileName   The name of the element on which to set the pincount.

    lphShadow   returns the Inode.

    ulHintFlags Misc flags to be set on the entry

    ulHintPri   Pincount increment. Called hintpri for historical reasons.


Returns:

    1 if successful 0 if failed

Notes:

    In the current implementation, the max pin count per entry is 255.

--*/



int DeleteHint(HANDLE hShadowDB, HSHADOW hDir, TCHAR *cFileName, BOOL fClearAll);
/*++

Routine Description:

    This API allows callers to decrement/remove pincount on a CSC database entry.

Arguments:

    hShadowDB   Handle to the shadow database as obtained from OpenShadowDatabaseIO.
                if INVALID_HANDLE_VALUE is passed in, the API, opens the shadow database,
                issues the corresponding ioctl, and closes it before returning.

    hDir        The directory Inode value obtained from either a FindOpen/FindNext call or
                from an earlier call to a GetShadow(Ex)/CreateShadow routine, or 0 which
                indicates the root inode.

    cFileName   The name of the element on which to set the pincount.

    fClearAll   if TRUE, clears all pincounts and flags on the entry.

Returns:

    1 if successful 0 if failed

Notes:


--*/






int SetMaxShadowSpace(HANDLE hShadowDB, long nFileSizeHigh, long nFileSizeLow);
/*++

Routine Description:

    Sets the maximum size of the shadow database

Arguments:

    hShadowDB   Handle to the shadow database as obtained from OpenShadowDatabaseIO.
                if INVALID_HANDLE_VALUE is passed in, the API, opens the shadow database,
                issues the corresponding ioctl, and closes it before returning.

    nFileSizeHigh   The high order value of the space size

    nFileSizeLow    The Low order value of the space size

Returns:

    1 if successful 0 otherwise

Notes:

    Used by control panel shell extension to set the max space

--*/

int FreeShadowSpace(HANDLE hShadowDB, long nFileSizeHigh, long nFileSizeLow, BOOL fClearAll);
/*++

Routine Description:

    Allows the caller to free the requisite amount of space from the CSC database

Arguments:

    hShadowDB   Handle to the shadow database as obtained from OpenShadowDatabaseIO.
                if INVALID_HANDLE_VALUE is passed in, the API, opens the shadow database,
                issues the corresponding ioctl, and closes it before returning.

    nFileSizeHigh   The high order value of the space size to be cleared

    nFileSizeLow    The Low order value of the space size to be cleared

    fClearAll   Clear the entire database, to the extent possible. 


Returns:

    1 on success 0 on failure

Notes:

--*/



int SetShareStatus(HANDLE hShadowDB, HSHARE hShare, unsigned long uStatus, unsigned long uOp);
/*++

Routine Description:

    This API allwos the caller to set the status bits on a share.

Arguments:

    hShadowDB   Handle to the shadow database as obtained from OpenShadowDatabaseIO.
                if INVALID_HANDLE_VALUE is passed in, the API, opens the shadow database,
                issues the corresponding ioctl, and closes it before returning.

    hShare     Represents a share in the flat name space. hShare should have been
                obtained from lpSI->hShare of a successful call to GetShadowInfoEx
                or FindOpenHShadow/FindnextHShadow

    uStatus     should have SHARE_xxx.

    uOp         specifies operation SHADOW_FLAGS_ASSIGN, SHADOW_FLAGS_AND or SHADOW_FLAGS_OR
                to do the corresponding operation between the existing status bits and the
                one passed in the uStatus parameter.

Returns:

    1 if successful 0 if failed

Notes:

    This should be used only for setting or clearing dirty bit on a share

--*/



int GetShareStatus(HANDLE hShadowDB, HSHARE hShare, unsigned long *lpulStatus);
/*++

Routine Description:

    This API allwos the caller to get the status bits set on a share.

Arguments:

    hShadowDB   Handle to the shadow database as obtained from OpenShadowDatabaseIO.
                if INVALID_HANDLE_VALUE is passed in, the API, opens the shadow database,
                issues the corresponding ioctl, and closes it before returning.

    hShare     Represents a share in the flat name space. hShare should have been
                obtained from lpSI->hShare of a successful call to GetShadowInfoEx
                or FindOpenHShadow/FindnextHShadow

    lpuStatus   Contains SHARE_xxx on return

Returns:

    1 if successful 0 if failed

Notes:

--*/



int GetShareInfo(HANDLE hShadowDB, HSHARE hShare, LPSHAREINFO lpSVRI, unsigned long *lpulStatus);
/*++

Routine Description:

    This API allwos the caller to get the status bits set on a share as well at info about
    the filesystem it runs etc.

Arguments:

    hShadowDB   Handle to the shadow database as obtained from OpenShadowDatabaseIO.
                if INVALID_HANDLE_VALUE is passed in, the API, opens the shadow database,
                issues the corresponding ioctl, and closes it before returning.

    hShare     Represents a share in the flat name space. hShare should have been
                obtained from lpSI->hShare of a successful call to GetShadowInfoEx
                or FindOpenHShadow/FindnextHShadow

    lpSVRI      Info about the filesystem the share is running. Refer to shdcom.h

    lpuStatus   Contains SHARE_xxx on return

Returns:

    1 if successful 0 if failed

Notes:

--*/







/**************** Routines below this line for the agent and the NP ************************/


int BeginInodeTransactionHSHADOW(
    VOID
    );
/*++

Routine Description:



Arguments:


Returns:


Notes:

--*/

int EndInodeTransactionHSHADOW(
    VOID
    );
/*++

Routine Description:



Arguments:


Returns:


Notes:

--*/
int ShadowSwitches(HANDLE hShadowDB, unsigned long * lpuSwitches, unsigned long uOp);
/*++

Routine Description:



Arguments:


Returns:


Notes:

--*/



int BeginPQEnum(HANDLE hShadowDB, LPPQPARAMS lpPQP);
/*++

Routine Description:

    Begin priority Q enumeration

Arguments:

    hShadowDB   Handle to the shadow database as obtained from OpenShadowDatabaseIO.
                This API does not allow appssing in INVALID_HANDLE_VALUE.


    lpPQ        if successful, lpPQ->uEnumCookie containes the handle for enumeration


Returns:

    1 if successful 0 otherwise

Notes:

--*/



int NextPriShadow(HANDLE hShadowDB, LPPQPARAMS lpPQP);
/*++

Routine Description:

    Gets the next entry from the priority queue in the order of priority

Arguments:

    hShadowDB   Handle to the shadow database as obtained from OpenShadowDatabaseIO.
                This API does not allow appssing in INVALID_HANDLE_VALUE.


    lpPQ        Input: Must be the same lpPQ that was used in an earlier BeginPQEnum/NextPriShadow

                Output: If successful and lpPQ->hShadow is nono-zero then the lpPQ contains
                        the next priority queue entry. If lpPQ->hShadow is 0, then we are at
                        the end of the enumeration.

Returns:

    1 if successful 0 otherwise

Notes:


--*/



int PrevPriShadow(HANDLE hShadowDB, LPPQPARAMS lpPQP);
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/



int EndPQEnum(HANDLE hShadowDB, LPPQPARAMS lpPQP);
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/




int ChkUpdtStatus(HANDLE hShadowDB, unsigned long hDir, unsigned long hShadow, LPWIN32_FIND_DATA lpFind32, unsigned long *lpulShadowStatus);
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/



int CopyChunk(HANDLE hShadowDB,  LPSHADOWINFO lpSI, struct tagCOPYCHUNKCONTEXT FAR *CopyChunkContext);
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/


// APIs for copying inward on NT, used only by the agent
int OpenFileWithCopyChunkIntent(HANDLE hShadowDB, LPCWSTR lpFileName,
                                struct tagCOPYCHUNKCONTEXT FAR *CopyChunkContext,
                                int ChunkSize);
int CloseFileWithCopyChunkIntent(HANDLE hShadowDB, struct tagCOPYCHUNKCONTEXT FAR *CopyChunkContext);


int BeginReint(HSHARE hShare, BOOL fBlockingReint, LPVOID *lplpReintContext);
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/



int EndReint(HSHARE hShare, LPVOID lpReintContext);
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/




int RegisterAgent(HANDLE hShadowDB, HWND hwndAgent, HANDLE hEvent);
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/



int UnregisterAgent(HANDLE hShadowDB, HWND hwndAgent);
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/


int DisableShadowingForThisThread(HANDLE hShadowDB);
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/



int EnableShadowingForThisThread(HANDLE hShadowDB);
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/



int ReinitShadowDatabase(
    HANDLE  hShadowDB,
    LPCSTR  lpszDatabaseLocation,    // location of the shadowing directory
    LPCSTR  lpszUserName,            // name of the user
    DWORD   dwDefDataSizeHigh,        // cache size if being created for the first time
    DWORD   dwDefDataSizeLow,
    DWORD   dwClusterSize
    );

/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/



int EnableShadowing(
    HANDLE  hShadowDB,
    LPCSTR  lpszDatabaseLocation,    // location of the shadowing directory
    LPCSTR  lpszUserName,            // user name
    DWORD   dwDefDataSizeHigh,        // cache size if being created for the first time
    DWORD   dwDefDataSizeLow,
    DWORD   dwClusterSize,          // clustersize for rounding database space
    BOOL    fReformat
);
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/

int FindOpenHint(HANDLE hShadowDB, HSHADOW hDir, LPWIN32_FIND_DATA lpFind32, CSC_ENUMCOOKIE *lpuEnumCookie, HSHADOW *hShadow, unsigned long *lpulHintFlags, unsigned long *lpulHintPri);
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/



int FindNextHint(HANDLE hShadowDB, CSC_ENUMCOOKIE uEnumCookie, LPWIN32_FIND_DATA lpFind32, HSHADOW *hShadow, unsigned long *lpulHintFlags, unsigned long *lpulHintPri);
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/



int FindCloseHint(HANDLE hShadowDB, CSC_ENUMCOOKIE uEnumCookie);
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/



AddHintFromInode(
    HANDLE          hShadowDB,
    HSHADOW         hDir,
    HSHADOW         hShadow,
    unsigned    long    *lpulPinCount,
    unsigned    long    *lpulHintFlags
    );

/*++

Routine Description:

    The routine allows the caller to OR hintflags and increment one pincount, either for
    the system or for the user.

Arguments:

    hShadowDB   Handle to the shadow database as obtained from OpenShadowDatabaseIO.
                if INVALID_HANDLE_VALUE is passed in, the API, opens the shadow database,
                issues the corresponding ioctl, and closes it before returning.

    hDir        Directory Inode

    hShadow     Shadow on which the hintflags are to be applied

    lpulPinCount    pincount on exit

    lpulHintFlags   inout filed, contains flags to be ORed, returns the flags on the entry
                    on a successful operation

Returns:

    1 if successful 0 if failed. It fails, if a) the pin count is about to go over MAX_PRI or
    b) it is attempting to pin it for the user but is already pinned for the user

Notes:

    Mainly for CSCPinFile's use
--*/

DeleteHintFromInode(
    HANDLE  hShadowDB,
    HSHADOW hDir,
    HSHADOW hShadow,
    unsigned    long    *lpulPinCount,
    unsigned    long    *lpulHintFlags
    );

/*++

Routine Description:

    The routine allows the caller to AND ~ of hintflags and decrement one pincount, either for
    the system or for the user.

Arguments:

    hShadowDB   Handle to the shadow database as obtained from OpenShadowDatabaseIO.
                if INVALID_HANDLE_VALUE is passed in, the API, opens the shadow database,
                issues the corresponding ioctl, and closes it before returning.

    hDir        Directory Inode

    hShadow     Shadow on which the hintflags are to be applied

    lpulPinCount    pincount on exit

    lpulHintFlags   inout filed, contains flags whose ~ is to be ANDed, returns the flags on the entry
                    on a successful operation

Returns:

    1 if successful 0 if failed. It fails, if a) the pin count is about to go below MIN_PRI or
    b) it is attempting to unpin it for the user but isn't pinned for the user

Notes:

    Mainly for CSCPinFile's use
--*/

int DoShadowMaintenance(HANDLE hShadowDB, unsigned long uOp);
/*++

Routine Description:

    The routine allows the caller to perform various maitenance tasks.

Arguments:

    hShadowDB   Handle to the shadow database as obtained from OpenShadowDatabaseIO.
                if INVALID_HANDLE_VALUE is passed in, the API, opens the shadow database,
                issues the corresponding ioctl, and closes it before returning.

    uOp         Various operations to perform.



Returns:

    1 if successful 0 if failed

Notes:

    Mainly for agents purposes, shouldn't be used by UI
--*/


BOOL
IsNetDisconnected(
    DWORD dwErrorCode
);
/*++

Routine Description:

    The routine checks from the errocode whether the net is disconnected

Arguments:

    dwErrorCode one of the codes defined in winerror.h

Returns:

    TRUE if net is disconnected, FALSE otherwise

Notes:

    A central place for all CSC users of lib3, to know whether net is disconnected

--*/

BOOL
PurgeUnpinnedFiles(
    HANDLE hShadowDB,
    LONG Timeout,
    PULONG pnFiles,
    PULONG pnYoungFiles);

BOOL
ShareIdToShareName(
    HANDLE hShadowDB,
    ULONG ShareId,
    PBYTE pBuffer,
    PDWORD pBufSize);

BOOL
CopyShadow(
    HANDLE  hShadowDB,
    HSHADOW hDir,
    HSHADOW hShadow,
    TCHAR   *lpFileName
);
/*++

Routine Description:

    The routine makes a copy of an inode file in the CSC database

Arguments:

    hDir        Directory Inode

    hShadow     Inode whose copy is wanted

    lpFileName  Fully qualified local path of the filename to be given to the copy

Returns:

    TRUE if the copy succeeded.

Notes:

    Useful for backup/dragdrop etc.

--*/


LPCOPYPARAMSW
LpAllocCopyParamsW(
    VOID
);

VOID
FreeCopyParamsW(
    LPCOPYPARAMSW lpCP
);

LPCOPYPARAMSA
LpAllocCopyParamsA(
    VOID
);

VOID
FreeCopyParamsA(
    LPCOPYPARAMSA lpCP
);

int
GetSecurityInfoForCSC(
    HANDLE          hShadowDB,
    HSHADOW         hDir,
    HSHADOW         hShadow,
    LPSECURITYINFO  lpSecurityInfo,
    DWORD           *lpdwBufferSize
    );

int
FindCreatePrincipalIDFromSID(
    HANDLE  hShadowDB,
    LPVOID  lpSidBuffer,
    ULONG   cbSidLength,
    ULONG   *lpuPrincipalID,
    BOOL    fCreate
    );

BOOL
SetExclusionList(
    HANDLE  hShadowDB,
    LPWSTR  lpwList,
    DWORD   cbSize
    );

BOOL
SetBandwidthConservationList(
    HANDLE  hShadowDB,
    LPWSTR  lpwList,
    DWORD   cbSize
    );

BOOL
TransitionShareToOffline(
    HANDLE  hShadowDB,
    HSHARE hShare,
    BOOL    fTransition
    );
BOOL
TransitionShareToOnline(
    HANDLE   hShadowDB,
    HSHARE   hShare
    );

BOOL
IsServerOfflineW(
    HANDLE  hShadowDB,
    LPCWSTR lptzServer,
    BOOL    *lpfOffline
    );

BOOL
IsServerOfflineA(
    HANDLE  hShadowDB,
    LPCSTR  lptzServer,
    BOOL    *lpfOffline
    );

int GetShadowDatabaseLocation(
    HANDLE              hShadowDB,
    WIN32_FIND_DATA    *lpFind32
    );

int
GetSpaceStats(
    HANDLE  hShadowDB,
    SHADOWSTORE *lpsST
);

BOOL
GetNameOfServerGoingOfflineW(
    HANDLE      hShadowDB,
    LPBYTE      lpBuffer,
    LPDWORD     lpdwSize
    );

BOOL
RenameShadow(
    HANDLE  hShadowDB,
    HSHADOW hDirFrom,
    HSHADOW hShadowFrom,
    HSHADOW hDirTo,
    LPWIN32_FIND_DATAW   lpFind32,
    BOOL    fReplaceFileIfExists,
    HSHADOW *lphShadowTo
    );

BOOL
GetSparseStaleDetectionCounter(
    HANDLE  hShadowDB,
    LPDWORD lpdwCounter
    );

BOOL
GetManualFileDetectionCounter(
    HANDLE  hShadowDB,
    LPDWORD lpdwCounter
    );

int EnableShadowingForUser(
    HANDLE    hShadowDB,
    LPCSTR    lpszDatabaseLocation,    // location of the shadowing directory
    LPCSTR    lpszUserName,            // name of the user
    DWORD    dwDefDataSizeHigh,        // cache size if being created for the first time
    DWORD    dwDefDataSizeLow,
    DWORD   dwClusterSize,
    BOOL    fReformat
);

int DisableShadowingForUser(
    HANDLE    hShadowDB
);

HANDLE
OpenShadowDatabaseIOex(
    ULONG WaitForDriver, 
    DWORD dwFlags);

BOOL
RecreateShadow(
    HANDLE  hShadowDB,
    HSHADOW hDir,
    HSHADOW hShadow,
    ULONG   ulAttrib
    );

BOOL
SetDatabaseStatus(
    HANDLE  hShadowDB,
    ULONG   ulStatus,
    ULONG   uMask
    );
    
#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\inc\cscapi.h ===
#ifndef _INC_CSCAPI
#define _INC_CSCAPI

#ifdef  __cplusplus
extern "C" {
#endif
// flags returned in the status field for files and folders.
// NB!!!! these bit definitions match exactly with those in shdcom.h


#define  FLAG_CSC_COPY_STATUS_DATA_LOCALLY_MODIFIED     0x0001
#define  FLAG_CSC_COPY_STATUS_ATTRIB_LOCALLY_MODIFIED   0x0002
#define  FLAG_CSC_COPY_STATUS_TIME_LOCALLY_MODIFIED     0x0004
#define  FLAG_CSC_COPY_STATUS_STALE                     0x0008
#define  FLAG_CSC_COPY_STATUS_LOCALLY_DELETED           0x0010
#define  FLAG_CSC_COPY_STATUS_SPARSE                    0x0020

#define  FLAG_CSC_COPY_STATUS_ORPHAN                    0x0100
#define  FLAG_CSC_COPY_STATUS_SUSPECT                   0x0200
#define  FLAG_CSC_COPY_STATUS_LOCALLY_CREATED           0x0400

#define  FLAG_CSC_COPY_STATUS_IS_FILE                   0x80000000
#define  FLAG_CSC_COPY_STATUS_FILE_IN_USE               0x40000000

// Flags returned in the status field for shares

#define FLAG_CSC_SHARE_STATUS_MODIFIED_OFFLINE          0x0001
#define FLAG_CSC_SHARE_STATUS_CONNECTED                 0x0800
#define FLAG_CSC_SHARE_STATUS_FILES_OPEN                0x0400
#define FLAG_CSC_SHARE_STATUS_FINDS_IN_PROGRESS         0x0200
#define FLAG_CSC_SHARE_STATUS_DISCONNECTED_OP           0x8000
#define FLAG_CSC_SHARE_MERGING                          0x4000

#define FLAG_CSC_SHARE_STATUS_MANUAL_REINT              0x0000  // No automatic file by file reint  (Persistent)
#define FLAG_CSC_SHARE_STATUS_AUTO_REINT                0x0040  // File by file reint is OK         (Persistent)
#define FLAG_CSC_SHARE_STATUS_VDO                       0x0080  // no need to flow opens            (Persistent)
#define FLAG_CSC_SHARE_STATUS_NO_CACHING                0x00c0  // client should not cache this share (Persistent)

#define FLAG_CSC_SHARE_STATUS_CACHING_MASK              0x00c0  // type of caching

#define FLAG_CSC_ACCESS_MASK                            0x003F0000
#define FLAG_CSC_USER_ACCESS_MASK                       0x00030000
#define FLAG_CSC_GUEST_ACCESS_MASK                      0x000C0000
#define FLAG_CSC_OTHER_ACCESS_MASK                      0x00300000

#define FLAG_CSC_USER_ACCESS_SHIFT_COUNT                16
#define FLAG_CSC_GUEST_ACCESS_SHIFT_COUNT               18
#define FLAG_CSC_OTHER_ACCESS_SHIFT_COUNT               20

#define FLAG_CSC_READ_ACCESS                            0x00000001
#define FLAG_CSC_WRITE_ACCESS                           0x00000002

// Hint flags Definitions:
#define FLAG_CSC_HINT_PIN_USER                  0x01    // When this bit is set, the item is being pinned for the user
                                                        // Note that there is only one pincount allotted for user.
#define FLAG_CSC_HINT_PIN_INHERIT_USER          0x02    // When this flag is set on a folder, all  descendents subsequently
                                                        // Created in this folder get pinned for the user
#define FLAG_CSC_HINT_PIN_INHERIT_SYSTEM        0x04    // When this flag is set on a folder, all descendents
                                                        // Subsequently  created in this folder get pinned for the
                                                        // system
#define FLAG_CSC_HINT_CONSERVE_BANDWIDTH        0x08    // When this flag is set on a folder,  for executables and
                                                        // Other related file, CSC tries to conserver bandwidth
                                                        // By not flowing opens when these files are fully


#define FLAG_CSC_HINT_PIN_SYSTEM                0x10    // This flag indicates it is pinned for the system

#define FLAG_CSC_HINT_COMMAND_MASK                      0xf0000000
#define FLAG_CSC_HINT_COMMAND_ALTER_PIN_COUNT           0x80000000  // Increments/decrements pin count


// Database status bits

#define FLAG_DATABASESTATUS_DIRTY                   0x00000001

#define FLAG_DATABASESTATUS_ENCRYPTION_MASK         0x00000006

#define FLAG_DATABASESTATUS_UNENCRYPTED             0x00000000 // new fileinodes will NOT be encrypted
#define FLAG_DATABASESTATUS_PARTIALLY_UNENCRYPTED   0x00000004

#define FLAG_DATABASESTATUS_ENCRYPTED               0x00000002 // new fileinodes will be encrypted
#define FLAG_DATABASESTATUS_PARTIALLY_ENCRYPTED     0x00000006


// definitions for callback reason

#define CSCPROC_REASON_BEGIN        1
#define CSCPROC_REASON_MORE_DATA    2
#define CSCPROC_REASON_END          3


// Definitions for callback return values:

#define CSCPROC_RETURN_CONTINUE         1
#define CSCPROC_RETURN_SKIP             2
#define CSCPROC_RETURN_ABORT            3
#define CSCPROC_RETURN_FORCE_INWARD     4        // applies only while merging
#define CSCPROC_RETURN_FORCE_OUTWARD    5    // applies only while merging
#define CSCPROC_RETURN_RETRY            6



typedef DWORD   (WINAPI *LPCSCPROCW)(
                LPCWSTR             lpszName,
                DWORD               dwStatus,
                DWORD               dwHintFlags,
                DWORD               dwPinCount,
                WIN32_FIND_DATAW    *lpFind32,
                DWORD               dwReason,
                DWORD               dwParam1,
                DWORD               dwParam2,
                DWORD_PTR           dwContext
                );

typedef DWORD   (WINAPI *LPCSCPROCA)(
                LPCSTR              lpszName,
                DWORD               dwStatus,
                DWORD               dwHintFlags,
                DWORD               dwPinCount,
                WIN32_FIND_DATAA    *lpFind32,
                DWORD               dwReason,
                DWORD               dwParam1,
                DWORD               dwParam2,
                DWORD_PTR           dwContext
                );



BOOL
WINAPI
CSCIsCSCEnabled(
    VOID
);


BOOL
WINAPI
CSCFindClose(
    IN  HANDLE    hFind
);

BOOL
WINAPI
CSCPinFileA(
    IN  LPCSTR      lpszFileName,
    IN  DWORD       dwHintFlags,
    OUT LPDWORD     lpdwStatus,
    OUT LPDWORD     lpdwPinCount,
    OUT LPDWORD     lpdwHintFlags
    );

BOOL
WINAPI
CSCUnpinFileA(
    IN  LPCSTR  lpszFileName,
    IN  DWORD   dwHintFlags,
    OUT LPDWORD lpdwStatus,
    OUT LPDWORD lpdwPinCount,
    OUT LPDWORD lpdwHintFlags
    );

BOOL
WINAPI
CSCQueryFileStatusA(
    IN  LPCSTR  lpszFileName,
    OUT LPDWORD lpdwStatus,
    OUT LPDWORD lpdwPinCount,
    OUT LPDWORD lpdwHintFlags
);

BOOL
WINAPI
CSCQueryFileStatusExA(
    IN  LPCSTR  lpszFileName,
    OUT LPDWORD lpdwStatus,
    OUT LPDWORD lpdwPinCount,
    OUT LPDWORD lpdwHintFlags,
    OUT LPDWORD lpdwUserPerms,
    OUT LPDWORD lpdwOtherPerms
);

BOOL
WINAPI
CSCQueryShareStatusA(
    IN  LPCSTR  lpszFileName,
    OUT LPDWORD lpdwStatus,
    OUT LPDWORD lpdwPinCount,
    OUT LPDWORD lpdwHintFlags,
    OUT LPDWORD lpdwUserPerms,
    OUT LPDWORD lpdwOtherPerms
);

HANDLE
WINAPI
CSCFindFirstFileA(
    IN  LPCSTR          lpszFileName,    // if NULL, returns the shares cached
    OUT WIN32_FIND_DATA *lpFind32,
    OUT LPDWORD         lpdwStatus,        // returns FLAG_CSC_SHARE_STATUS_XXX for shares
                                            // FLAG_CSC_STATUS_XXX for the rest
    OUT LPDWORD         lpdwPinCount,
    OUT LPDWORD         lpdwHintFlags,
    OUT FILETIME        *lpOrgFileTime
);

BOOL
WINAPI
CSCFindNextFileA(
    IN  HANDLE          hFind,
    OUT WIN32_FIND_DATA *lpFind32,
    OUT LPDWORD         lpdwStatus,
    OUT LPDWORD         lpdwPinCount,
    OUT LPDWORD         lpdwHintFlags,
    OUT FILETIME        *lpOrgFileTime
);

BOOL
WINAPI
CSCDeleteA(
    IN  LPCSTR    lpszFileName
);


BOOL
WINAPI
CSCFillSparseFilesA(
    IN    LPCSTR        lpszShareName,
    IN    BOOL          fFullSync,
    IN    LPCSCPROCA    lpprocFillProgress,
    IN    DWORD_PTR     dwContext
);



BOOL
WINAPI
CSCMergeShareA(
    IN  LPCSTR      lpszShareName,
    IN  LPCSCPROCA  lpfnMergeProgress,
    IN  DWORD_PTR   dwContext
);


BOOL
WINAPI
CSCCopyReplicaA(
    IN  LPCSTR  lpszFullPath,
    OUT LPSTR   *lplpszLocalName
);


BOOL
WINAPI
CSCEnumForStatsA(
    IN  LPCSTR      lpszShareName,
    IN  LPCSCPROCA  lpfnEnumProgress,
    IN  DWORD_PTR   dwContext
);

BOOL
WINAPI
CSCEnumForStatsExA(
    IN  LPCSTR      lpszShareName,
    IN  LPCSCPROCA  lpfnEnumProgress,
    IN  DWORD_PTR   dwContext
);

BOOL
WINAPI
CSCPinFileW(
    LPCWSTR     lpszFileName,
    DWORD       dwHintFlags,
    LPDWORD     lpdwStatus,
    LPDWORD     lpdwPinCount,
    LPDWORD     lpdwHintFlags
);

BOOL
WINAPI
CSCUnpinFileW(
    LPCWSTR     lpszFileName,
    DWORD       dwHintFlags,
    LPDWORD     lpdwStatus,
    LPDWORD     lpdwPinCount,
    LPDWORD     lpdwHintFlags
    );

BOOL
WINAPI
CSCQueryFileStatusW(
    LPCWSTR lpszFileName,
    LPDWORD lpdwStatus,
    LPDWORD lpdwPinCount,
    LPDWORD lpdwHintFlags
);

BOOL
WINAPI
CSCQueryFileStatusExW(
    LPCWSTR lpszFileName,
    LPDWORD lpdwStatus,
    LPDWORD lpdwPinCount,
    LPDWORD lpdwHintFlags,
    LPDWORD lpdwUserPerms,
    LPDWORD lpdwOtherPerms
);

BOOL
WINAPI
CSCQueryShareStatusW(
    LPCWSTR lpszFileName,
    LPDWORD lpdwStatus,
    LPDWORD lpdwPinCount,
    LPDWORD lpdwHintFlags,
    LPDWORD lpdwUserPerms,
    LPDWORD lpdwOtherPerms
);

HANDLE
WINAPI
CSCFindFirstFileW(
    LPCWSTR             lpszFileName,
    WIN32_FIND_DATAW    *lpFind32,
    LPDWORD             lpdwStatus,
    LPDWORD             lpdwPinCount,
    LPDWORD             lpdwHintFlags,
    FILETIME            *lpOrgFileTime
);

HANDLE
WINAPI
CSCFindFirstFileForSidW(
    LPCWSTR             lpszFileName,
    PSID                pSid,
    WIN32_FIND_DATAW    *lpFind32,
    LPDWORD             lpdwStatus,
    LPDWORD             lpdwPinCount,
    LPDWORD             lpdwHintFlags,
    FILETIME            *lpOrgFileTime
);
BOOL
WINAPI
CSCFindNextFileW(
    HANDLE              hFind,
    WIN32_FIND_DATAW    *lpFind32,
    LPDWORD             lpdwStatus,
    LPDWORD             lpdwPinCount,
    LPDWORD             lpdwHintFlags,
    FILETIME            *lpOrgFileTime
);

BOOL
WINAPI
CSCDeleteW(
    IN  LPCWSTR    lpszFileName
);

BOOL
WINAPI
CSCFillSparseFilesW(
    IN    LPCWSTR       lpszShareName,
    IN    BOOL          fFullSync,
    IN    LPCSCPROCW    lpprocFillProgress,
    IN    DWORD_PTR     dwContext
);



BOOL
WINAPI
CSCMergeShareW(
    IN  LPCWSTR         lpszShareName,
    IN  LPCSCPROCW      lpfnMergeProgress,
    IN  DWORD_PTR       dwContext
);


BOOL
WINAPI
CSCCopyReplicaW(
    IN  LPCWSTR lpszFullPath,
    OUT LPWSTR  *lplpszLocalName
);

BOOL
WINAPI
CSCEnumForStatsW(
    IN  LPCWSTR     lpszShareName,
    IN  LPCSCPROCW  lpfnEnumProgress,
    IN  DWORD_PTR   dwContext
);

BOOL
WINAPI
CSCEnumForStatsExW(
    IN  LPCWSTR     lpszShareName,
    IN  LPCSCPROCW  lpfnEnumProgress,
    IN  DWORD_PTR   dwContext
);

BOOL
WINAPI
CSCFreeSpace(
    DWORD   nFileSizeHigh,
    DWORD   nFileSizeLow
    );

BOOL
WINAPI
CSCIsServerOfflineA(
    IN  LPCSTR     lpszServerName,
    OUT BOOL        *lpfOffline
    );

BOOL
WINAPI
CSCIsServerOfflineW(
    IN  LPCWSTR     lpszServerName,
    OUT BOOL        *lpfOffline
    );

BOOL
WINAPI
CSCGetSpaceUsageA(
    OUT LPSTR   lptzLocation,
    IN  DWORD   dwSize,
    OUT LPDWORD lpdwMaxSpaceHigh,
    OUT LPDWORD lpdwMaxSpaceLow,
    OUT LPDWORD lpdwCurrentSpaceHigh,
    OUT LPDWORD lpdwCurrentSpaceLow,
    OUT LPDWORD lpcntTotalFiles,
    OUT LPDWORD lpcntTotalDirs
);

BOOL
WINAPI
CSCGetSpaceUsageW(
    OUT LPWSTR  lptzLocation,
    IN  DWORD   dwSize,
    OUT LPDWORD lpdwMaxSpaceHigh,
    OUT LPDWORD lpdwMaxSpaceLow,
    OUT LPDWORD lpdwCurrentSpaceHigh,
    OUT LPDWORD lpdwCurrentSpaceLow,
    OUT LPDWORD lpcntTotalFiles,
    OUT LPDWORD lpcntTotalDirs
);

BOOL
WINAPI
CSCSetMaxSpace(
    DWORD   nFileSizeHigh,
    DWORD   nFileSizeLow
);

BOOL
WINAPI
CSCTransitionServerOnlineW(
    IN  LPCWSTR     lpszServerName
    );

BOOL
WINAPI
CSCTransitionServerOnlineA(
    IN  LPCSTR     lpszServerName
    );

BOOL
WINAPI
CSCCheckShareOnlineW(
    IN  LPCWSTR     lpszShareName
    );

BOOL
WINAPI
CSCCheckShareOnlineExW(
    IN  LPCWSTR     lpszShareName,
    IN  DWORD       *lpdwSpeed
    );

BOOL
WINAPI
CSCCheckShareOnlineA(
    IN  LPCSTR     lpszShareName
    );

BOOL
WINAPI
CSCDoLocalRenameW(
    IN  LPCWSTR     lpszSource,
    IN  LPCWSTR     lpszDestination,
    IN  BOOL        fReplaceFile
    );

BOOL
WINAPI
CSCDoLocalRenameA(
    IN  LPCSTR      lpszSource,
    IN  LPCSTR      lpszDestination,
    IN  BOOL        fReplaceFile
    );

BOOL
WINAPI
CSCDoLocalRenameExA(
    IN  LPCSTR     lpszSource,
    IN  LPCSTR     lpszDestination,
    IN  WIN32_FIND_DATAA    *lpFin32,
    IN  BOOL        fMarkAsLocal,
    IN  BOOL        fReplaceFileIfExists
    );

BOOL
WINAPI
CSCDoLocalRenameExW(
    IN  LPCWSTR     lpszSource,
    IN  LPCWSTR     lpszDestination,
    IN  WIN32_FIND_DATAW    *lpFin32,
    IN  BOOL        fMarkAsLocal,
    IN  BOOL        fReplaceFileIfExists
    );

BOOL
WINAPI
CSCDoEnableDisable(
    BOOL    fEnable
    );


BOOL
WINAPI
CSCBeginSynchronizationW(
    IN  LPCWSTR     lpszShareName,
    LPDWORD         lpdwSpeed,
    LPDWORD         lpdwContext
    );


BOOL
WINAPI
CSCEndSynchronizationW(
    IN  LPCWSTR     lpszShareName,
    DWORD           dwContext
    );

BOOL
WINAPI
CSCEncryptDecryptDatabase(
    IN  BOOL        fEncrypt,
    IN  LPCSCPROCW  lpfnEnumProgress,
    IN  DWORD_PTR   dwContext
    );

BOOL
WINAPI
CSCQueryDatabaseStatus(
    ULONG   *pulStatus,
    ULONG   *pulErrors
    );

BOOL
WINAPI
CSCPurgeUnpinnedFiles(
    ULONG   Timeout,
    ULONG   *pulnFiles,
    ULONG   *pulnYoungFiles
    );

BOOL
WINAPI
CSCShareIdToShareName(
    ULONG ShareId,
    PBYTE Buffer,
    PDWORD pdwBufSize
    );

#ifdef UNICODE

#define CSCPinFile          CSCPinFileW
#define CSCUnpinFile        CSCUnpinFileW
#define CSCQueryFileStatus  CSCQueryFileStatusW
#define CSCQueryFileStatusEx  CSCQueryFileStatusExW
#define CSCQueryShareStatus  CSCQueryShareStatusW
#define CSCFindFirstFile    CSCFindFirstFileW
#define CSCFindFirstFileForSid    CSCFindFirstFileForSidW
#define CSCFindNextFile     CSCFindNextFileW
#define CSCDelete           CSCDeleteW
#define CSCFillSparseFiles  CSCFillSparseFilesW
#define CSCMergeShare       CSCMergeShareW
#define CSCCopyReplica      CSCCopyReplicaW
#define CSCEnumForStats     CSCEnumForStatsW
#define CSCIsServerOffline  CSCIsServerOfflineW
#define LPCSCPROC           LPCSCPROCW
#define CSCGetSpaceUsage    CSCGetSpaceUsageW
#define CSCTransitionServerOnline   CSCTransitionServerOnlineW
#define CSCCheckShareOnline         CSCCheckShareOnlineW
#define CSCCheckShareOnlineEx         CSCCheckShareOnlineExW
#define CSCDoLocalRename            CSCDoLocalRenameW
#define CSCDoLocalRenameEx            CSCDoLocalRenameExW
#define CSCEnumForStatsEx     CSCEnumForStatsExW
#define CSCBeginSynchronization    CSCBeginSynchronizationW
#define CSCEndSynchronization   CSCEndSynchronizationW
#else

#define CSCPinFile          CSCPinFileA
#define CSCUnpinFile        CSCUnpinFileA
#define CSCQueryFileStatus  CSCQueryFileStatusA
#define CSCQueryFileStatusEx  CSCQueryFileStatusExA
#define CSCQueryShareStatus  CSCQueryShareStatusA
#define CSCFindFirstFile    CSCFindFirstFileA
#define CSCFindFirstFileForSid    CSCFindFirstFileForSidA
#define CSCFindNextFile     CSCFindNextFileA
#define CSCDelete           CSCDeleteA
#define CSCFillSparseFiles  CSCFillSparseFilesA
#define CSCMergeShare       CSCMergeShareA
#define CSCCopyReplica      CSCCopyReplicaA
#define CSCEnumForStats     CSCEnumForStatsA
#define CSCIsServerOffline  CSCIsServerOfflineA
#define LPCSCPROC           LPCSCPROCA
#define CSCGetSpaceUsage    CSCGetSpaceUsageA
#define CSCTransitionServerOnline   CSCTransitionServerOnlineA
#define CSCCheckShareOnline        CSCCheckShareOnlineA
#define CSCCheckShareOnlineEx         CSCCheckShareOnlineExA
#define CSCDoLocalRename            CSCDoLocalRenameA
#define CSCEnumForStatsEx     CSCEnumForStatsExA
#define CSCDoLocalRenameEx            CSCDoLocalRenameExA
#endif

#ifdef __cplusplus
}   /* ... extern "C" */
#endif


#endif  // _INC_CSCAPI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\inc\logdat.h ===
#define  VFNLOG_DELETE        0
#define  VFNLOG_CREATE_DIR    1
#define  VFNLOG_DELETE_DIR    2
#define  VFNLOG_CHECK_DIR     3
#define  VFNLOG_GET_ATTRB     4
#define  VFNLOG_SET_ATTRB     5
#define  VFNLOG_FLUSH         6
#define  VFNLOG_GETDISKINFO   7
#define  VFNLOG_GETDISKPARAMS 8
#define  VFNLOG_OPEN          9
#define  VFNLOG_RENAME        10
#define  VFNLOG_SRCHFRST      11
#define  VFNLOG_SRCHNEXT      12
#define  VFNLOG_QUERY0        13
#define  VFNLOG_QUERY1        14
#define  VFNLOG_QUERY2        15
#define  VFNLOG_CONNECT       16
#define  VFNLOG_DISCONNECT    17
#define  VFNLOG_UNCPIPEREQ    18
#define  VFNLOG_IOCTL16DRV    19
#define  VFNLOG_DASDIO        20
#define  VFNLOG_FINDOPEN      21
#define  HFNLOG_FINDNEXT      22
#define  HFNLOG_FINDCLOSE     23
#define  HFNLOG_READ          24
#define  HFNLOG_WRITE         25
#define  HFNLOG_CLOSE         26
#define  HFNLOG_SEEK          27
#define  HFNLOG_COMMIT        28
#define  HFNLOG_FLOCK         29
#define  HFNLOG_FUNLOCK       30
#define  HFNLOG_GET_TIME      31
#define  HFNLOG_SET_TIME      32
#define  HFNLOG_GET_LATIME    33
#define  HFNLOG_SET_LATIME    34
#define  HFNLOG_PIPEREQ       35
#define  HFNLOG_HANDLEINFO    36
#define  HFNLOG_ENUMHANDLE    37
#define  VFNLOG_QUERY83_DIR   38
#define  VFNLOG_QUERYLONG_DIR 39

#define  TIME_PRINT_PRINT_FORMAT %02d:%02d:%02.2d
#define  DATE_PRINT_FORMAT       %02d-%02d-%02d
#define  TIME_DATE_PRINT_FORMAT  %02d:%02d:%02.2d;%02d-%02d-%02d

typedef struct tagLOGCMD
   {
   LPSTR lpCmd;
   LPSTR lpFmt;
   }
LOGCMD;

char szCR[] = "\r";
char szTimeDateFormat[] = "%02d:%02d:%02.2d %02d-%02d-%02d";
char szTimeFormat[] = "%02d:%02d:%02.2d";
char szPreFmt[]="%s %02d:%02d:%02.2d err=%d %s ";
char szDummy[]="XX";
char szLog[] = "C:\\shadow.log";


LOGCMD rgsLogCmd[] =
   {
     "Del     "   ,szCR
   , "Mkdir   "   ,szCR
   , "Rmdir   "   ,szCR
   , "Chkdir  "   ,szCR
   , "GetAttrb"   ,"Atrb=%xh\r"
   , "SetAttrb"   ,"Atrb=%xh\r"
   , "Flush   "   ,szCR
   , "GetDiskI"   ,szCR
   , "GetDiskP"   ,szCR
   , "Open    "   ,"AccsShr=%xh Action=%xh Attr=%xh Size=%d Time="
   , "Ren     "   ,"To %s\r"
   , "Srchfrst"   ,"Atrb=%xh %s \r"
   , "Srchnext"   ,"%s \r"
   , "Query   "   ,szCR
   , "Query   "   ,"Status=%xh\r"
   , "Query   "   ,"Status=%xh MaxPath = %d MaxFileName = %d\r"
   , "Connect "   ,"ResType=%d\r"
   , "Disconn "   ,szCR
   , "UncPpRq "   ,szCR
   , "Ioctl16D"   ,szCR
   , "Dasdio  "   ,szCR
   , "FindOpen"   ,"Options=%xh %s\r"
   , "FindNext"   ,"%s\r"
   , "FindCls "   ,szCR
   , "Read    "   ,"p=%d l=%d\r"
   , "Write   "   ,"p=%d l=%d\r"
   , "Close   "   ,"Type=%d\r"
   , "Seek    "   ,"p=%d type=%d\r"
   , "Commit  "   ,szCR
   , "LockF   "   ,"p=%d l=%d\r"
   , "UnlockF "   ,"p=%d l=%d\r"
   , "GetFtime"   ,szCR
   , "SetFtime"   ,szCR
   , "GetLaTim"   ,szCR
   , "SetLaTim"   ,szCR
   , "Pipereq "   ,szCR
   , "HndlInfo"   ,szCR
   , "EnumHndl"   ,"type = %d \r"
   , "Query83"    ,szCR
   , "QueryLong"  ,szCR
   };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\inc\makefile.inc ===
$(PROJECT_INC_PATH)\cscapi.h : cscapi.h
    $(PUBLISH_CMD) {$?=$@}

$(PROJECT_INC_PATH)\shdcom.h : shdcom.h
    $(PUBLISH_CMD) {$?=$@}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\record.mgr\clregs.h ===
/********************************************************************/
/**                     Microsoft Windows                          **/
/**               Copyright(c) Microsoft Corp., 1990-1992          **/
/********************************************************************/
/* :ts=4 */

#ifndef CSC_RECORDMANAGER_WINNT
typedef	union UserRegs UserRegs, *pUserRegs, *PUSERREGS;
union UserRegs {
	struct Client_Reg_Struc			r;	// DWord register layout
	struct Client_Word_Reg_Struc	w;	// Access word registers
	struct Client_Byte_Reg_Struc	b;	// Access byte registers
};	/* UserRegs */

#endif //ifndef CSC_RECORDMANAGER_WINNT

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\inc\port32.h ===
#ifdef WIN32

// Shouldn't be using these things.
#define _huge
#define _export
#define _loadds
#define SELECTOROF(x)   ((UINT)(x))
#define OFFSETOF(x)     ((UINT)(x))
#define ISLPTR(pv)      ((BOOL)pv)
#define MAKELP(hmem,off) ((LPVOID)((LPBYTE)hmem+off))
#define MAKELRESULTFROMUINT(i)  ((LRESULT)i)
#define ISVALIDHINSTANCE(hinst) ((BOOL)hinst)

#define DATASEG_READONLY
#define DATASEG_PERINSTANCE
#define DATASEG_SHARED

#define GetWindowInt    GetWindowLong
#define SetWindowInt    SetWindowLong
#define SetWindowID(hwnd,id)    SetWindowLong(hwnd, GWL_ID, id)

#define CopyIcon(hInst, hIcon)                 CopyIcon(hIcon)
#define LOADICONEX(hInst, hInst2, a, b, c, d)  LoadIconEx(hInst2, a, b, c, d)
#define SHELLEXECUTE(a, b, c, d, e, f)         ShellExecuteEx(a, b, c, d, e, NULL, f)

#define ISVALIDLIBRARY(hLib)            (hLib != NULL)

#else  // WIN32

#define ISLPTR(pv)      (SELECTOROF(pv))
#define MAKELRESULTFROMUINT(i)  MAKELRESULT(i,0)
#define ISVALIDHINSTANCE(hinst) ((UINT)hinst>=(UINT)HINSTANCE_ERROR)

#define DATASEG_READONLY    "_TEXT"
#define DATASEG_PERINSTANCE
#define DATASEG_SHARED

#define GetWindowInt    GetWindowWord
#define SetWindowInt    SetWindowWord
#define SetWindowID(hwnd,id)    SetWindowWord(hwnd, GWW_ID, id)

#define MAKEPOINTS(l)     (*((POINTS FAR*)&(l)))

#define LOADICONEX(hInst, hInst2, a, b, c, d)  LoadIconEx(hInst, hInst2, a, b, c, d)
#define SHELLEXECUTE(a, b, c, d, e, f)         ShellExecute(a, b, c, d, e, f)

#define ISVALIDLIBRARY(hLib)            (hLib >= HINSTANCE_ERROR)

#endif // WIN32

#ifdef WIN32

/*****************************************************************************\
* PWIN32.H - PORTABILITY MAPPING HEADER FILE
*
* This file provides macros to map portable windows code to its 32 bit form.
\*****************************************************************************/

/*-----------------------------------USER------------------------------------*/

/* HELPER MACROS */

#define MAPVALUE(v16, v32)              (v32)
#define MAPTYPE(v16, v32)               v32
#define MAKEMPOINT(l)                   (*((MPOINT *)&(l)))
#define MPOINT2POINT(mpt,pt)            ((pt).x = (mpt).x, (pt).y = (mpt).y)
#define POINT2MPOINT(pt, mpt)           ((mpt).x = (SHORT)(pt).x, (mpt).y = (SHORT)(pt).y)
#define LONG2POINT(l, pt)               ((pt).x = (SHORT)LOWORD(l), (pt).y = (SHORT)HIWORD(l))

#define SETWINDOWUINT(hwnd, index, ui)  (UINT)SetWindowLong(hwnd, index, (LONG)(ui))
#define GETWINDOWUINT(hwnd, index)      (UINT)GetWindowLong(hwnd, index)
#define SETCLASSUINT(hwnd, index, ui)   (UINT)SetClassLong(hwnd, index, (LONG)(ui))
#define GETCLASSUINT(hwnd, index)       (UINT)GetClassLong(hwnd, index)

#define GETCBCLSEXTRA(hwnd)             GETCLASSUINT(hwnd, GCL_CBCLSEXTRA)
#define SETCBCLSEXTRA(hwnd, cb)         SETCLASSUINT(hwnd, GCL_CBCLSEXTRA, cb)
#define GETCBWNDEXTRA(hwnd)             GETCLASSUINT(hwnd, GCL_CBWNDEXTRA)     
#define SETCBWNDEXTRA(hwnd, cb)         SETCLASSUINT(hwnd, GCL_CBWNDEXTRA, cb) 
#define GETCLASSBRBACKGROUND(hwnd)      (HBRUSH)GETCLASSUINT(hwnd, GCL_HBRBACKGROUND)
#define SETCLASSBRBACKGROUND(hwnd, h)   (HBRUSH)SETCLASSUINT(hwnd, GCL_HBRBACKGROUND, h)
#define GETCLASSCURSOR(hwnd)            (HCURSOR)GETCLASSUINT(hwnd, GCL_HCURSOR)
#define SETCLASSCURSOR(hwnd, h)         (HCURSOR)SETCLASSUINT(hwnd, GCL_HCURSOR, h)
#define GETCLASSHMODULE(hwnd)           (HMODULE)GETCLASSUINT(hwnd, GCL_HMODULE)            
#define SETCLASSHMODULE(hwnd, h)        (HMODULE)SETCLASSUINT(hwnd, GCL_HMODULE, h) 
#define GETCLASSICON(hwnd)              (HICON)GETCLASSUINT((hwnd), GCL_HICON)
#define SETCLASSICON(hwnd, h)           (HICON)SETCLASSUINT((hwnd), GCL_HICON, h)
#define GETCLASSSTYLE(hwnd)             GETCLASSUINT((hwnd), GCL_STYLE)            
#define SETCLASSSTYLE(hwnd, style)      SETCLASSUINT((hwnd), GCL_STYLE, style) 
#define GETHWNDINSTANCE(hwnd)           (HINSTANCE)GETWINDOWUINT((hwnd), GWL_HINSTANCE)
#define SETHWNDINSTANCE(hwnd, h)        (HINSTANCE)SETWINDOWUINT((hwnd), GWL_HINSTANCE, h)
#define GETHWNDPARENT(hwnd)             (HWND)GETWINDOWUINT((hwnd), GWL_HWNDPARENT)
#define SETHWNDPARENT(hwnd, h)          (HWND)SETWINDOWUINT((hwnd), GWL_HWNDPARENT, h)
#define GETWINDOWID(hwnd)               GETWINDOWUINT((hwnd), GWL_ID)            
#define SETWINDOWID(hwnd, id)           SETWINDOWUINT((hwnd), GWL_ID, id) 

#else

/*****************************************************************************\
* PWIN16.H - PORTABILITY MAPPING HEADER FILE
*
* This file provides macros to map portable windows code to its 16 bit form.
\*****************************************************************************/

/*-----------------------------------USER------------------------------------*/
 
/* HELPER MACROS */

#define MAPVALUE(v16, v32)              (v16)
#define MAPTYPE(v16, v32)               v16
#define MAKEMPOINT(l)                   (*((MPOINT FAR *)&(l)))
#define MPOINT2POINT(mpt, pt)           (pt = *(POINT FAR *)&(mpt))
#define POINT2MPOINT(pt, mpt)           (mpt = *(MPOINT FAR *)&(pt))
#define LONG2POINT(l, pt)               ((pt).x = (INT)LOWORD(l), (pt).y = (INT)HIWORD(l))

#define GETWINDOWUINT(hwnd, index)      (UINT)GetWindowWord(hwnd, index)
#define SETWINDOWUINT(hwnd, index, ui)  (UINT)SetWindowWord(hwnd, index, (WORD)(ui))
#define SETCLASSUINT(hwnd, index, ui)   (UINT)SetClassWord(hwnd, index, (WORD)(ui))
#define GETCLASSUINT(hwnd, index)       (UINT)GetClassWord(hwnd, index)

#define GETCBCLSEXTRA(hwnd)             GETCLASSUINT(hwnd, GCW_CBCLSEXTRA)
#define SETCBCLSEXTRA(hwnd, cb)         SETCLASSUINT(hwnd, GCW_CBCLSEXTRA, cb)
#define GETCBWNDEXTRA(hwnd)             GETCLASSUINT(hwnd, GCW_CBWNDEXTRA)     
#define SETCBWNDEXTRA(hwnd, cb)         SETCLASSUINT(hwnd, GCW_CBWNDEXTRA, cb) 
#define GETCLASSBRBACKGROUND(hwnd)      (HBRUSH)GETCLASSUINT(hwnd, GCW_HBRBACKGROUND)
#define SETCLASSBRBACKGROUND(hwnd, h)   (HBRUSH)SETCLASSUINT(hwnd, GCW_HBRBACKGROUND, h)
#define GETCLASSCURSOR(hwnd)            (HCURSOR)GETCLASSUINT(hwnd, GCW_HCURSOR)
#define SETCLASSCURSOR(hwnd, h)         (HCURSOR)SETCLASSUINT(hwnd, GCW_HCURSOR, h)
#define GETCLASSHMODULE(hwnd)           (HMODULE)GETCLASSUINT(hwnd, GCW_HMODULE)            
#define SETCLASSHMODULE(hwnd, h)        (HMODULE)SETCLASSUINT(hwnd, GCW_HMODULE, h) 
#define GETCLASSICON(hwnd)              (HICON)GETCLASSUINT((hwnd), GCW_HICON)
#define SETCLASSICON(hwnd, h)           (HICON)SETCLASSUINT((hwnd), GCW_HICON, h)
#define GETCLASSSTYLE(hwnd)             GETCLASSUINT((hwnd), GCW_STYLE)            
#define SETCLASSSTYLE(hwnd, style)      SETCLASSUINT((hwnd), GCW_STYLE, style) 
#define GETHWNDINSTANCE(hwnd)           (HMODULE)GETWINDOWUINT((hwnd), GWW_HINSTANCE)
#define SETHWNDINSTANCE(hwnd, h)        (HMODULE)SETWINDOWUINT((hwnd), GWW_HINSTANCE, h)
#define GETHWNDPARENT(hwnd)             (HWND)GETWINDOWUINT((hwnd), GWW_HWNDPARENT)
#define SETHWNDPARENT(hwnd, h)          (HWND)SETWINDOWUINT((hwnd), GWW_HWNDPARENT, h)
#define GETWINDOWID(hwnd)               GETWINDOWUINT((hwnd), GWW_ID)            
#define SETWINDOWID(hwnd, id)           SETWINDOWUINT((hwnd), GWW_ID, id) 

#endif // WIN32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\inc\shdcom.h ===
#ifndef __SHDCOM_H__
#define __SHDCOM_H__

/* Common definitions, needed by Ring0 and Ring3 code */

#define CSC_DATABASE_VERSION    0x00010005  // major # in higher WORD, minor # in lower word

#define MIN_SPARSEFILL_PRI   1
#define MAX_SERVER_SHARE_NAME_FOR_CSC   64


#ifndef  WM_USER
#define  WM_USER                 0x400
#endif

#define  WM_FILE_OPENS           (WM_USER+1)
#define  WM_SHADOW_ADDED         (WM_USER+2)
#define  WM_SHADOW_DELETED       (WM_USER+3)
#define  WM_SHARE_DISCONNECTED  (WM_USER+4)


#define  WM_DIRTY    WM_USER+100
#define  WM_STALE    WM_USER+101
#define  WM_SPARSE   WM_USER+102

#ifndef IOCTL_RDR_BASE
#define IOCTL_RDR_BASE                  FILE_DEVICE_NETWORK_FILE_SYSTEM
#endif //ifndef IOCTL_RDR_BASE

#define SHADOW_IOCTL_ENUM_BASE 1000
#define _SHADOW_IOCTL_CODE(__enum) \
                CTL_CODE(IOCTL_RDR_BASE,SHADOW_IOCTL_ENUM_BASE+__enum, METHOD_NEITHER, FILE_ANY_ACCESS)

#define  IOCTL_SHADOW_GETVERSION                (_SHADOW_IOCTL_CODE(0))

#define  IOCTL_SHADOW_REGISTER_AGENT            (_SHADOW_IOCTL_CODE(1))
#define  IOCTL_SHADOW_UNREGISTER_AGENT          (_SHADOW_IOCTL_CODE(2))
#define  IOCTL_SHADOW_GET_UNC_PATH              (_SHADOW_IOCTL_CODE(3))
#define  IOCTL_SHADOW_BEGIN_PQ_ENUM             (_SHADOW_IOCTL_CODE(4))
#define  IOCTL_SHADOW_END_PQ_ENUM               (_SHADOW_IOCTL_CODE(5))
#define  IOCTL_SHADOW_NEXT_PRI_SHADOW           (_SHADOW_IOCTL_CODE(6))
#define  IOCTL_SHADOW_PREV_PRI_SHADOW           (_SHADOW_IOCTL_CODE(7))
#define  IOCTL_SHADOW_GET_SHADOW_INFO           (_SHADOW_IOCTL_CODE(8))
#define  IOCTL_SHADOW_SET_SHADOW_INFO           (_SHADOW_IOCTL_CODE(9))
#define  IOCTL_SHADOW_CHK_UPDT_STATUS           (_SHADOW_IOCTL_CODE(10))
#define  IOCTL_DO_SHADOW_MAINTENANCE            (_SHADOW_IOCTL_CODE(11))
#define  IOCTL_SHADOW_COPYCHUNK                 (_SHADOW_IOCTL_CODE(12))
#define  IOCTL_SHADOW_BEGIN_REINT               (_SHADOW_IOCTL_CODE(13))
#define  IOCTL_SHADOW_END_REINT                 (_SHADOW_IOCTL_CODE(14))
#define  IOCTL_SHADOW_CREATE                    (_SHADOW_IOCTL_CODE(15))
#define  IOCTL_SHADOW_DELETE                    (_SHADOW_IOCTL_CODE(16))
#define  IOCTL_GET_SHARE_STATUS                 (_SHADOW_IOCTL_CODE(17))
#define  IOCTL_SET_SHARE_STATUS                 (_SHADOW_IOCTL_CODE(18))
#define  IOCTL_ADDUSE                           (_SHADOW_IOCTL_CODE(19))
#define  IOCTL_DELUSE                           (_SHADOW_IOCTL_CODE(20))
#define  IOCTL_GETUSE                           (_SHADOW_IOCTL_CODE(21))
#define  IOCTL_SWITCHES                         (_SHADOW_IOCTL_CODE(22))
#define  IOCTL_GETSHADOW                        (_SHADOW_IOCTL_CODE(23))
#define  IOCTL_GETGLOBALSTATUS                  (_SHADOW_IOCTL_CODE(24))
#define  IOCTL_FINDOPEN_SHADOW                  (_SHADOW_IOCTL_CODE(25))
#define  IOCTL_FINDNEXT_SHADOW                  (_SHADOW_IOCTL_CODE(26))
#define  IOCTL_FINDCLOSE_SHADOW                 (_SHADOW_IOCTL_CODE(27))
#define  IOCTL_GETPRIORITY_SHADOW               (_SHADOW_IOCTL_CODE(28))
#define  IOCTL_SETPRIORITY_SHADOW               (_SHADOW_IOCTL_CODE(29))
#define  IOCTL_ADD_HINT                         (_SHADOW_IOCTL_CODE(30))
#define  IOCTL_DELETE_HINT                      (_SHADOW_IOCTL_CODE(31))
#define  IOCTL_FINDOPEN_HINT                    (_SHADOW_IOCTL_CODE(32))
#define  IOCTL_FINDNEXT_HINT                    (_SHADOW_IOCTL_CODE(33))
#define  IOCTL_FINDCLOSE_HINT                   (_SHADOW_IOCTL_CODE(34))
#define  IOCTL_GET_IH_PRIORITY                  (_SHADOW_IOCTL_CODE(35))
#define  IOCTL_GETALIAS_HSHADOW                 (_SHADOW_IOCTL_CODE(36))
#define  IOCTL_GET_DEBUG_INFO                   (_SHADOW_IOCTL_CODE(37))

// the following are only used on NT but there's no harm in defining them for win9x as well
#define  IOCTL_OPENFORCOPYCHUNK                 (_SHADOW_IOCTL_CODE(40))
#define  IOCTL_CLOSEFORCOPYCHUNK                (_SHADOW_IOCTL_CODE(41))

#define IOCTL_IS_SERVER_OFFLINE                 (_SHADOW_IOCTL_CODE(42))
#define IOCTL_TRANSITION_SERVER_TO_ONLINE       (_SHADOW_IOCTL_CODE(43))
#define IOCTL_TRANSITION_SERVER_TO_OFFLINE      (_SHADOW_IOCTL_CODE(44))
#define IOCTL_NAME_OF_SERVER_GOING_OFFLINE      (_SHADOW_IOCTL_CODE(45))
#define IOCTL_TAKE_SERVER_OFFLINE               (_SHADOW_IOCTL_CODE(46))
#define IOCTL_SHAREID_TO_SHARENAME              (_SHADOW_IOCTL_CODE(47))

#define  CSC_IOCTL_MIN      IOCTL_SHADOW_GETVERSION
#define  CSC_IOCTL_MAX_W9X  IOCTL_GETALIAS_HSHADOW
#define  CSC_IOCTL_MAX_NT   IOCTL_SHAREID_TO_SHARENAME


// Sub operations for IOCTL_DO_SHADOW_MAINTENATCE

#define SHADOW_MAKE_SPACE               1
#define SHADOW_REDUCE_REFPRI            2
#define SHADOW_ADD_SPACE                3
#define SHADOW_FREE_SPACE               4
#define SHADOW_GET_SPACE_STATS          5
#define SHADOW_SET_MAX_SPACE            6
#define SHADOW_PER_THREAD_DISABLE       7
#define SHADOW_PER_THREAD_ENABLE        8
#define SHADOW_REINIT_DATABASE          9
#define SHADOW_ADDHINT_FROM_INODE       10
#define SHADOW_DELETEHINT_FROM_INODE    11
#define SHADOW_COPY_INODE_FILE          12
#define SHADOW_BEGIN_INODE_TRANSACTION  13
#define SHADOW_END_INODE_TRANSACTION    14
#define SHADOW_FIND_CREATE_PRINCIPAL_ID 15
#define SHADOW_GET_SECURITY_INFO        16
#define SHADOW_SET_EXCLUSION_LIST       17
#define SHADOW_SET_BW_CONSERVE_LIST     18
#define SHADOW_TRANSITION_SERVER_TO_OFFLINE 19
#define SHADOW_CHANGE_HANDLE_CACHING_STATE  20
#define SHADOW_RECREATE                     21
#define SHADOW_RENAME                       22
#define SHADOW_SPARSE_STALE_DETECTION_COUNTER   23
#define SHADOW_ENABLE_CSC_FOR_USER              24
#define SHADOW_DISABLE_CSC_FOR_USER             25
#define SHADOW_SET_DATABASE_STATUS              26
#define SHADOW_PURGE_UNPINNED_FILES             27
#define SHADOW_MANUAL_FILE_DETECTION_COUNTER    28

// persistent status flags on files/directories in the CSC database

#define  SHADOW_DIRTY               0x0001   // Contents of file/dir modified while offline

#define  SHADOW_ATTRIB_CHANGE       0x0002  // attributes have been changed offline

#define  SHADOW_TIME_CHANGE         0x0004  // lastmodtime changed offline

#define  SHADOW_STALE               0x0008  // file/dir replic is not in sync with server copy

#define  SHADOW_DELETED             0x0010  // file/dir was deleted in an offline operation

#define  SHADOW_SPARSE              0x0020  // file/dir is not completely filled up

#define  SHADOW_BUSY                0x0040  //

#define  SHADOW_REUSED              0x0080  // A replica name has been reused during an offline
                                            // operation of delete follwed by a create

#define  SHADOW_ORPHAN              0x0100  // used to be a replica but the original has vanished
                                            // from the server

#define  SHADOW_SUSPECT             0x0200  // writes failed on this shadow


#define  SHADOW_LOCALLY_CREATED     0x0400  // File/directory created offline


#define  SHADOW_LOCAL_INODE         0x4000  // This has meaning only for an inode,
                                            // it means that the inode was created while offline

#define  SHADOW_NOT_FSOBJ           0x8000  // This is only a hint


//not used...incorrect #define  mShadowIsFsObj(uStatus)    (((uStatus) & SHADOW_FILESYSTEM_OBJECT)==0)
#define  mShadowHintType(uStatus)   ((uStatus) & SHADOW_HINT_MASK)
#define  mSetHintType(uStatus, type)         ((uStatus) = ((uStatus) & ~SHADOW_HINT_MASK) | ((type) & SHADOW_HINT_MASK))

#define  SHADOW_IS_FILE             0x80000000   // flag ored at runtime for PQ enumeration
#define  SHADOW_FILE_IS_OPEN        0x40000000   // flag ored at runtime for dir enumeration


#define  SHADOW_MODFLAGS         (SHADOW_DIRTY|SHADOW_TIME_CHANGE|SHADOW_ATTRIB_CHANGE|SHADOW_LOCALLY_CREATED|SHADOW_DELETED|SHADOW_REUSED)



// Flags defined for a share entry in the CSC database

#define SHARE_REINT                0x0001  // Needs reintegration (persistent)
#define SHARE_CONFLICTS            0x0002  // Conflicts while merging (Persistent)
#define SHARE_ERRORS               0x0004  // Database errors (Persistent)
//                                  0x0008  // free
#define SHARE_PRESERVES_CASE       0x0010  // (Persistent) may be expendable
#define SHARE_SUPPORTS_LFN         0x0020  // (Persistent) may be expendable

// share caching types (derived from the SMB spec).
// These are set by the admin on the server side.

#define SHARE_MANUAL_REINT          0x0000  // No automatic file by file reint  (Persistent)
#define SHARE_AUTO_REINT            0x0040  // File by file reint is OK         (Persistent)
#define SHARE_VDO                   0x0080  // no need to flow opens            (Persistent)
#define SHARE_NO_CACHING            0x00c0  // client should not cache this share (Persistent)

#define SHARE_CACHING_MASK         0x00c0  // type of caching


// in memory flags
#define  SHARE_FINDS_IN_PROGRESS   0x0200  // has finds in progress
#define  SHARE_FILES_OPEN          0x0400  // has files open
#define  SHARE_CONNECTED           0x0800  // Share is connected right now
#define  SHARE_SHADOWNP            0x1000  // A shadow connection
#define  SHARE_PINNED_OFFLINE      0x2000  // Don't auto-reconnect
#define  SHARE_MERGING             0x4000  // free
#define  SHARE_DISCONNECTED_OP     0x8000  // Disconnected operation in progress




// NB these are identical to
#define  mShadowLocallyCreated(uFlags) ((uFlags) & SHADOW_LOCALLY_CREATED)
#define  mShadowStale(uFlags)          ((uFlags) & SHADOW_STALE)
#define  mShadowDirty(uFlags)          ((uFlags) & SHADOW_DIRTY)
#define  mShadowTimeChange(uFlags)     ((uFlags) & SHADOW_TIME_CHANGE)
#define  mShadowAttribChange(uFlags)   ((uFlags) & SHADOW_ATTRIB_CHANGE)
#define  mShadowSparse(uFlags)         ((uFlags) & SHADOW_SPARSE)
#define  mShadowBusy(uFlags)           ((uFlags) & SHADOW_BUSY)
#define  mShadowSuspect(uFlags)        ((uFlags) & SHADOW_SUSPECT)
#define  mShadowDeleted(uFlags)        ((uFlags) & SHADOW_DELETED)
#define  mShadowReused(uFlags)         ((uFlags) & SHADOW_REUSED)
#define  mShadowOrphan(uFlags)         ((uFlags) & SHADOW_ORPHAN)

#define  mShadowNeedReint(uFlags)      ((uFlags) & (SHADOW_MODFLAGS))
#define  mShadowConflict(uFlags)       (((uFlags) & SHADOW_STALE) && ((uFlags) & SHADOW_MODFLAGS))
#define  mShadowUsable(uFlags)         (!((uFlags) & (SHADOW_STALE|SHADOW_SUSPECT)))

#define  mShadowIsFile(uFlags)         ((uFlags) & SHADOW_IS_FILE)

#define  SHADOW_FLAGS_BITOP_MASK    0xf
#define  SHADOW_FLAGS_ASSIGN        0
#define  SHADOW_FLAGS_AND           1
#define  SHADOW_FLAGS_OR            2

#define  SHADOW_OBJECT_FINDFIRST    3
#define  SHADOW_OBJECT_FINDNEXT     4
#define  SHADOW_OBJECT_FINDCLOSE    5

#define  SHADOW_HINT_FINDFIRST      6
#define  SHADOW_HINT_FINDNEXT       7
#define  SHADOW_HINT_FINDCLOSE      8

#define  SHADOW_HINT_ADD            9
#define  SHADOW_DELETE_HINT         10

#define SHADOW_FLAGS_COMMAND_MASK        0xff00
#define SHADOW_FLAGS_DONT_UPDATE_ORGTIME 0x1000
#define SHADOW_FLAGS_TRUNCATE_DATA       0x2000
#define SHADOW_FLAGS_FORCE_RELINK        0x4000 // forces the entry at the top of PQ even if
                                                // it's current priority is MAX_PRI and all
                                                // it's predecessors are MAX_PRI
#define SHADOW_FLAGS_CHANGE_83NAME       0x8000 // applicable to setshadowinfo
#define SHADOW_FLAGS_SET_REFRESH_TIME    0x0100 // setshadowinfo will update lastrefreshed time

#define  mBitOpShadowFlags(uOp)  ((uOp) & SHADOW_FLAGS_BITOP_MASK)
#define  mOrShadowFlags(uOp)  (((uOp) & SHADOW_FLAGS_BITOP_MASK)==SHADOW_FLAGS_OR)
#define  mAndShadowFlags(uOp)  (((uOp) & SHADOW_FLAGS_BITOP_MASK)==SHADOW_FLAGS_AND)
#define  mAssignShadowFlags(uOp)  (((uOp) & SHADOW_FLAGS_BITOP_MASK)==SHADOW_FLAGS_ASSIGN)

#define  mSetShadowFlagsOp(uVar, uOp)  (((uVar) &= ~SHADOW_FLAGS_BITOP_MASK), (uVar) |= (uOp))
#define  mSetSetShadowCommand(uVar, uCommand)   (((uVar) &= ~SHADOW_FLAGS_COMMAND_MASK), (uVar) |= uCommand)

#define  mDontUpdateOrgTime(uOp)    ((uOp) & SHADOW_FLAGS_DONT_UPDATE_ORGTIME)
#define  mTruncateDataCommand(uOp)  ((uOp) & SHADOW_FLAGS_TRUNCATE_DATA)
#define  mForceRelink(uOp)          ((uOp) & SHADOW_FLAGS_FORCE_RELINK)
#define  mChange83Name(uOp)         ((uOp) & SHADOW_FLAGS_CHANGE_83NAME)
#define  mSetLastRefreshTime(uOp)   ((uOp) & SHADOW_FLAGS_SET_REFRESH_TIME)

#define  SHADOW_SWITCH_SHADOWING        0x0001
#define  SHADOW_SWITCH_LOGGING          0x0002
#define  SHADOW_SWITCH_SHADOWFIND       0x0004
#define  SHADOW_SWITCH_SPEAD_OPTIMIZE   0x0008
#define  SHADOW_SWITCH_REMOTE_BOOT      0x0010

#define  SHADOW_SWITCH_OFF             1
#define  SHADOW_SWITCH_ON              2
#define  SHADOW_SWITCH_GET_STATE       3

#define  mSetBits(uFlags, uBits)    ((uFlags) |= (uBits))
#define  mClearBits(uFlags, uBits)  ((uFlags) &= ~(uBits))
#define  mQueryBits(uFlags, uBits)      ((uFlags) & (uBits))

#ifndef CSC_ON_NT
#define FlagOn(uFlags, uBit)    (mQueryBits(uFlags, uBit) != 0)
#endif

#define RETAIN_VALUE                0xffffffff

// pin flags
// NTRAID#455275-shishirp-1/31/2000, we ended up replicating these in cscapi.h

#define FLAG_CSC_HINT_PIN_USER                  0x01
#define FLAG_CSC_HINT_PIN_INHERIT_USER          0x02
#define FLAG_CSC_HINT_PIN_INHERIT_SYSTEM        0x04
#define FLAG_CSC_HINT_CONSERVE_BANDWIDTH        0x08
#define FLAG_CSC_HINT_PIN_SYSTEM                0x10

#define FLAG_CSC_HINT_COMMAND_ALTER_PIN_COUNT   0x80000000
#define FLAG_CSC_HINT_COMMAND_MASK              0xf0000000
#define FLAG_CSC_HINT_INHERIT_MASK               (FLAG_CSC_HINT_PIN_INHERIT_USER|FLAG_CSC_HINT_PIN_INHERIT_SYSTEM)

#define mPinFlags(ulHintFlags)          ((ulHintFlags) & (FLAG_CSC_HINT_PIN_USER|FLAG_CSC_HINT_PIN_SYSTEM))
#define mPinInheritFlags(ulHintFlags)   ((ulHintFlags) & (FLAG_CSC_HINT_PIN_INHERIT_USER|FLAG_CSC_HINT_PIN_INHERIT_SYSTEM))
#define mPinCommand(ulHintFlags)        ((ulHintFlags) & FLAG_CSC_HINT_COMMAND_MASK)
#define mPinAlterCount(ulHintFlags)     ((ulHintFlags) & FLAG_CSC_HINT_COMMAND_ALTER_PIN_COUNT)

// These defines are here for historical reasons, they are not used anymore
// Hint, Hint
#define  HINT_FLAG_TYPE_MASK        0x03
#define  HINT_EXCLUSION             0x04
#define  HINT_WILDCARD              0x08

#define  HINT_TYPE_FILE             1
#define  HINT_TYPE_FOLDER           2
#define  HINT_TYPE_SUBTREE          3
//
#define  mNotFsobj(uStatus)         ((uStatus) & SHADOW_NOT_FSOBJ)
#define  mIsHint(uHF)               ((uHF) & HINT_FLAG_TYPE_MASK)
#define  mHintSubtree(uHF)          (((uHF) & HINT_FLAG_TYPE_MASK)==HINT_TYPE_SUBTREE)
#define  mHintExclude(uHF)          ((uHF) & HINT_EXCLUSION)
#define  mHintWildcard(uHF)         ((uHF) & HINT_WILDCARD)



#ifdef  VxD
typedef _WIN32_FIND_DATA   WIN32_FIND_DATA, *PFIND32, far *LPFIND32;
typedef _FILETIME   FILETIME;
#else
typedef LPWIN32_FIND_DATAW   LPFIND32;
#endif

#ifdef CSC_RECORDMANAGER_WINNT
typedef _FILETIME   FILETIME;
#endif

typedef  ULONG  HSERVER;
typedef  ULONG  HSHADOW;
typedef  ULONG  HSHARE;

typedef  ULONG  *PHSHARE;
typedef  ULONG  *PHSERVER;
typedef  ULONG  *PHSHADOW;

#ifdef  VxD
typedef USHORT  wchar_t;
#endif
typedef wchar_t *PWCHAR;
typedef wchar_t *LPWCH, *PWCH;
typedef CONST wchar_t *LPCWCH, *PCWCH;
typedef wchar_t *NWPSTR;
typedef wchar_t *LPWSTR, *PWSTR;

typedef CONST wchar_t *LPCWSTR, *PCWSTR;

//
// ANSI (Multi-byte Character) types
//
typedef CHAR *PCHAR;
typedef CHAR *LPCH, *PCH;

typedef CONST CHAR *LPCCH, *PCCH;
typedef CHAR *NPSTR;
typedef CHAR *LPSTR, *PSTR;
typedef CONST CHAR *LPCSTR, *PCSTR;
typedef VOID    *CSC_ENUMCOOKIE;

typedef struct tagSTOREDATA
{
    ULONG   ulSize;           // Max shadow data size
    ULONG   ucntDirs;         // Current count of dirs
    ULONG   ucntFiles;        // Current count of files
}
STOREDATA;


#ifndef __COPYCHUNKCONTEXT__
#define __COPYCHUNKCONTEXT__
typedef struct tagCOPYCHUNKCONTEXT
{
    DWORD   dwFlags;
    ULONG   LastAmountRead;
    ULONG   TotalSizeBeforeThisRead;
    HANDLE  handle;
    ULONG   ChunkSize;
    ULONG   Context[1];
}
COPYCHUNKCONTEXT;
#endif

#define COPYCHUNKCONTEXT_FLAG_IS_AGENT_OPEN 0x00000001

typedef struct tagSHADOWSTORE
{
    ULONG       uFlags;
    STOREDATA   sMax;
    STOREDATA   sCur;
}
SHADOWSTORE;


typedef struct tagCOPYPARAMSA
{
    union
    {
        DWORD   dwError;
        struct
        {
            ULONG    uOp;
            HSHARE   hShare;
            HSHADOW  hDir;
            HSHADOW  hShadow;
            LPSTR    lpLocalPath;
            LPSTR    lpRemotePath;
            LPSTR    lpSharePath;
        };
    };
}
COPYPARAMSA;

typedef struct tagCOPYPARAMSW
{
    union
    {
        DWORD   dwError;
        struct
        {
            ULONG       uOp;
            HSHARE      hShare;
            HSHADOW     hDir;
            HSHADOW     hShadow;
            LPWSTR      lpLocalPath;
            LPWSTR      lpRemotePath;
            LPWSTR      lpSharePath;
        };
    };
}
COPYPARAMSW;

typedef struct tagPQPARAMS
{
    union
    {
        DWORD   dwError;
        struct
        {
            HSHARE      hShare;
            HSHADOW     hDir;
            HSHADOW     hShadow;
            ULONG       ulStatus;
            ULONG       ulRefPri;
            ULONG       ulIHPri;
            ULONG       ulHintFlags;
            ULONG       ulHintPri;
            CSC_ENUMCOOKIE       uEnumCookie;
            ULONG       uPos;
            DWORD       dwPQVersion;
        };
    };
}
PQPARAMS;

typedef struct tagSHADOWINFO
{
    union
    {
        DWORD   dwError;
        struct
        {
            HSHARE     hShare;            // share ID
            HSHADOW     hDir;               // directory inode
            HSHADOW     hShadow;            // inode for the item
            union
            {
                HSHADOW     hShadowOrg;         // original inode, applies only to a replica
                HSHADOW     hDirTo;             // input for renaming hShadowFrom into hDirTo
            };
            FILETIME    ftOrgTime;          // the timestamp of a replica as obtained
            FILETIME    ftLastRefreshTime;  // last time a replica was refreshed
            union
            {
                LPFIND32    lpFind32;
                LPVOID      lpBuffer;
            };

            ULONG       uStatus;            // status of the item in the database

            ULONG       ulRefPri;

            union
            {
                ULONG       ulPrincipalID;
                ULONG       ulIHPri;
                ULONG       uRootStatus;
            };

            ULONG       ulHintFlags;

            ULONG       ulHintPri;

            union
            {
                ULONG       uOp;
                ULONG       uSubOperation;
            };

            CSC_ENUMCOOKIE  uEnumCookie;
            ULONG       cbBufferSize;
            DWORD       dwNameSpaceVersion;
        };

    };
}
SHADOWINFO;

#define  FINDOPEN_SHADOWINFO_NORMAL   0x1
#define  FINDOPEN_SHADOWINFO_SPARSE   0x2
#define  FINDOPEN_SHADOWINFO_DELETED  0x4
#define  FINDOPEN_SHADOWINFO_ALL      0x7

typedef struct tagSHAREINFOW
{
    union
    {
        DWORD   dwError;

        struct
        {
            HSHARE  hShare;
            USHORT usCaps;        // Type of resource
            USHORT usState;       // State of the resource (connected/paused etc.)
            unsigned    short rgSharePath[MAX_SERVER_SHARE_NAME_FOR_CSC];    // name of the path
            unsigned    short rgFileSystem[16];    // name of the file system
        };
    };
}
SHAREINFOW;

typedef struct tagSHAREINFOA
{
    union
    {
        DWORD   dwError;

        struct
        {
            HSHARE  hShare;
            USHORT usCaps;        // Type of resource
            USHORT usState;       // State of the resource (connected/paused etc.)
            char rgSharePath[MAX_SERVER_SHARE_NAME_FOR_CSC];    // name of the path
            char rgFileSystem[16];    // name of the file system
        };
    };
}
SHAREINFOA;


typedef struct tagGLOBALSTATUS
{
    union
    {
        DWORD   dwError;
        struct
        {
            ULONG       uFlagsEvents;     // Reports the latest events noted
            ULONG       uDatabaseErrorFlags;
            SHADOWSTORE sST;
            HSHADOW     hShadowAdded;
            HSHADOW     hDirAdded;
            HSHADOW     hShadowDeleted;
            HSHADOW     hDirDeleted;
            int         cntFileOpen;   // Count of file opens
            HSHARE     hShareDisconnected;
        };
    };
}
GLOBALSTATUS, *LPGLOBALSTATUS;

typedef struct  tagSECURITYINFO
{
    ULONG   ulPrincipalID;      // identifier of the principal
    ULONG   ulPermissions;      // permissions mask
}
SECURITYINFO, *LPSECURITYINFO;

// achtung, these should match with those in the cscsec.h

#define CSC_MAXIMUM_NUMBER_OF_CACHED_PRINCIPAL_IDS (0x4)
#define CSC_GUEST_PRINCIPAL_ID           (0xfffe)
#define CSC_INVALID_PRINCIPAL_ID         (0x0)


#define FLAG_GLOBALSTATUS_SHADOW_ADDED          0x0001
#define FLAG_GLOBALSTATUS_SHADOW_DELETED        0x0002
#define FLAG_GLOBALSTATUS_FILE_OPENS            0x0004
#define FLAG_GLOBALSTATUS_SHADOW_SPACE          0x0008
#define FLAG_GLOBALSTATUS_SHARE_DISCONNECTED    0x0010
#define FLAG_GLOBALSTATUS_STOP                  0x0020
#define FLAG_GLOBALSTATUS_START                 0x0040
#define FLAG_GLOBALSTATUS_NO_NET                0x0080
#define FLAG_GLOBALSTATUS_GOT_NET               0x0100
#define FLAG_GLOBALSTATUS_INVOKE_AUTODIAL       0x0200
#define FLAG_GLOBALSTATUS_INVOKE_FREESPACE      0x0400

#define FLAG_DATABASESTATUS_DIRTY                   0x00000001
#define FLAG_DATABASESTATUS_ENCRYPTION_MASK         0x00000006
#define FLAG_DATABASESTATUS_UNENCRYPTED             0x00000000 // new inodes will NOT be encrypted
#define FLAG_DATABASESTATUS_PARTIALLY_UNENCRYPTED   0x00000004
#define FLAG_DATABASESTATUS_ENCRYPTED               0x00000002 // new fileinodes will be encrypted
#define FLAG_DATABASESTATUS_PARTIALLY_ENCRYPTED     0x00000006

#define mDatabaseEncryptionEnabled(ulGlobalStatus)  ((ulGlobalStatus) & 0x00000002)

#define mDatabasePartiallyEncrypted(ulGlobalStatus) (((ulGlobalStatus) & FLAG_DATABASESTATUS_ENCRYPTION_MASK)==FLAG_DATABASESTATUS_PARTIALLY_ENCRYPTED)
#define mDatabasePartiallyUnencrypted(ulGlobalStatus) (((ulGlobalStatus) & FLAG_DATABASESTATUS_ENCRYPTION_MASK)==FLAG_DATABASESTATUS_PARTIALLY_UNENCRYPTED)

//
// Neutral ANSI/UNICODE types and macros
//
#ifndef _TCHAR_DEFINED

#ifdef  UNICODE                     // r_winnt

typedef wchar_t TCHAR, *PTCHAR;
typedef wchar_t TBYTE , *PTBYTE ;

typedef LPWSTR LPTCH, PTCH;
typedef LPWSTR PTSTR, LPTSTR;
typedef LPCWSTR LPCTSTR;
typedef LPWSTR LP;
#define _TEXT(quote) L##quote      // r_winnt

#else   /* UNICODE */               // r_winnt

typedef char TCHAR, *PTCHAR;
typedef unsigned char TBYTE , *PTBYTE ;

typedef LPSTR LPTCH, PTCH;
typedef LPSTR PTSTR, LPTSTR;
typedef LPCSTR LPCTSTR;
#define _TEXT(quote) quote      // r_winnt

#endif /* UNICODE */                // r_winnt

#define _TCHAR_DEFINED
#endif /* !_TCHAR_DEFINED */

#ifdef VXD

#define UNICODE

#endif

#ifdef  UNICODE

#define COPYPARAMS      COPYPARAMSW
#define SHAREINFO      SHAREINFOW
#define LPCOPYPARAMS    LPCOPYPARAMSW
#define LPSHAREINFO    LPSHAREINFOW
#else

#define COPYPARAMS  COPYPARAMSA
#define SHAREINFO  SHAREINFOA
#define LPCOPYPARAMS    LPCOPYPARAMSA
#define LPSHAREINFO    LPSHAREINFOA
#endif

#ifdef   VxD
typedef HSHARE       *LPHSHARE;
typedef HSHADOW      *LPHSHADOW;
typedef SHADOWSTORE  *LPSHADOWSTORE;
typedef SHADOWINFO   *LPSHADOWINFO;
typedef STOREDATA    *LPSTOREDATA;
typedef PQPARAMS     *LPPQPARAMS;
typedef COPYPARAMSA  *LPCOPYPARAMSA;
typedef SHAREINFOA  *LPSHAREINFOA;
typedef COPYPARAMSW  *LPCOPYPARAMSW;
typedef SHAREINFOW  *LPSHAREINFOW;
#else
typedef HSHARE       FAR *LPHSHARE;
typedef HSHADOW      FAR *LPHSHADOW;
typedef SHADOWSTORE  FAR *LPSHADOWSTORE;
typedef SHADOWINFO   FAR *LPSHADOWINFO;
typedef STOREDATA    FAR *LPSTOREDATA;
typedef PQPARAMS     FAR *LPPQPARAMS;
typedef COPYPARAMS   FAR *LPCOPYPARAMS;
typedef COPYPARAMSA  FAR *LPCOPYPARAMSA;
typedef SHAREINFOA  FAR *LPSHAREINFOA;
typedef COPYPARAMSW  FAR *LPCOPYPARAMSW;
typedef SHAREINFOW  FAR *LPSHAREINFOW;
#endif



// UNICODE versions of registry key/value names

// kept for hist(y)rical reasons
#define REG_KEY_IEXPLORER                       _TEXT("Software\\Microsoft\\Internet Explorer\\Main")
#define REG_KEY_SHADOW                          _TEXT("System\\CurrentControlSet\\Services\\VxD\\Shadow")

// settings exclusively used by cscdll.dll

#define REG_KEY_CSC_SETTINGS                    _TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\CSCSettings")
#define REG_STRING_DATABASE_LOCATION            _TEXT("DatabaseLocation")
#define REG_VALUE_DATABASE_SIZE                 _TEXT("DatabaseSizePercent")
#define REG_VALUE_ENABLED                       _TEXT("Enabled")


// settings defined by UI and policy

#define REG_STRING_POLICY_NETCACHE_KEY          _TEXT("Software\\Policies\\Microsoft\\Windows\\NetCache")
#define REG_STRING_NETCACHE_KEY                 _TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\NetCache")
#define REG_STRING_EXCLUSION_LIST               _TEXT("ExcludeExtensions")
#define REG_STRING_BANDWIDTH_CONSERVATION_LIST  _TEXT("BandwidthConservationList")
#define REG_VALUE_FORMAT_DATABASE               _TEXT("FormatDatabase")

// ANSI versions of registry key/value names

// kept for hist(y)rical reasons
#define REG_KEY_IEXPLORER_A                     "Software\\Microsoft\\Internet Explorer\\Main"
#define REG_KEY_SHADOW_A                        "System\\CurrentControlSet\\Services\\VxD\\Shadow"

// settings exclusively used by cscdll.dll

#define REG_KEY_CSC_SETTINGS_A                  "Software\\Microsoft\\Windows\\CurrentVersion\\CSCSettings"
#define REG_STRING_DATABASE_LOCATION_A          "DatabaseLocation"
#define REG_VALUE_DATABASE_SIZE_A               "DatabaseSizePercent"
#define REG_VALUE_ENABLED_A                     "Enabled"

// settings defined by UI and policy

#define REG_STRING_POLICY_NETCACHE_KEY_A        "Software\\Policies\\Microsoft\\Windows\\NetCache"
#define REG_STRING_NETCACHE_KEY_A               "Software\\Microsoft\\Windows\\CurrentVersion\\NetCache"
#define REG_STRING_EXCLUSION_LIST_A             "ExcludeExtensions"
#define REG_STRING_BANDWIDTH_CONSERVATION_LIST_A "BandwidthConservationList"
#define REG_STRING_ENCRYPTED_A                  "Encrypted"
#define REG_STRING_ENCRYPT_DECRYPT_A            "EcDc"

#define REG_VALUE_FORMAT_DATABASE_A             "FormatDatabase"

#define SESSION_EVENT_NAME_NT L"\\BaseNamedObjects\\jjCSCSessEvent_UM_KM"
#define SHARED_FILL_EVENT_NAME_NT L"\\BaseNamedObjects\\jjCSCSharedFillEvent_UM_KM"
#define IFNOT_CSC_RECORDMANAGER_WINNT if(FALSE)
#define IF_CSC_RECORDMANAGER_WINNT if(TRUE)
#define WINNT_DOIT(x__) x__

int ShadowLog(
    LPSTR lpFmt,
    ...
    );

#define DoCSCLog(__x)   ShadowLog __x

extern DWORD    dwDebugLogVector;

#define DEBUG_LOG(__bits, __x) {\
    if (((DEBUG_LOG_BIT_##__bits)==0) || FlagOn(dwDebugLogVector,(DEBUG_LOG_BIT_##__bits))){\
            DoCSCLog(__x); \
        }\
    }

#define DEBUG_LOG_BIT_RECORD    0x00000001
#define DEBUG_LOG_BIT_CSHADOW   0x00000002

#endif //#ifndef __SHDCOM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\inc\timelog.h ===
#define TIMELOG_EditRecordEx                    0
#define TIMELOG_AddFileRecordFR                 1
#define TIMELOG_DeleteFileRecFromInode          2
#define TIMELOG_FindFileRecord                  3
#define TIMELOG_UpdateFileRecordFR              4
#define TIMELOG_AddPriQRecord                   5
#define TIMELOG_DeletePriQRecord                6
#define TIMELOG_FindPriQRecordInternal          7
#define TIMELOG_SetPriorityForInode             8

#define TIMELOG_CreateShadowInternal            9
#define TIMELOG_GetShadow                       10
#define TIMELOG_GetShadowInfo                   11
#define TIMELOG_SetShadowInfoInternal           12
#define TIMELOG_ChangePriEntryStatusHSHADOW     13
#define TIMELOG_MRxSmbCscCreateShadowFromPath   14
#define TIMELOG_MRxSmbGetFileInfoFromServer     15
#define TIMELOG_EditRecordEx_OpenFileLocal      16
#define TIMELOG_EditRecordEx_Lookup             17
#define TIMELOG_KeAttachProcess_R0Open          18
#define TIMELOG_IoCreateFile_R0Open             19
#define TIMELOG_KeDetachProcess_R0Open          20
#define TIMELOG_KeAttachProcess_R0Read          21
#define TIMELOG_R0ReadWrite                     22
#define TIMELOG_KeDetachProcess_R0Read          23
#define TIMELOG_FindQRecordInsertionPoint_Addq  24
#define TIMELOG_LinkQRecord_Addq                25
#define TIMELOG_UnlinkQRecord_Addq              26
#define TIMELOG_FindQRecordInsertionPoint_Addq_dir  27
#define TIMELOG_EditRecordEx_ValidateHeader                  28
#define TIMELOG_EditRecordEx_Data                29

#define TIMELOG_MAX                             30


#ifdef DEBUG

#ifdef CSC_RECORDMANAGER_WINNT
#define BEGIN_TIMING(indx)  {LARGE_INTEGER   llTimeBegin;\
                             KeQuerySystemTime(&llTimeBegin);\
                             rgllTimeArray[TIMELOG_##indx] -= llTimeBegin.QuadPart;}

#define END_TIMING(indx)    {LARGE_INTEGER   llTimeEnd;\
                             KeQuerySystemTime(&llTimeEnd);\
                             rgllTimeArray[TIMELOG_##indx] += llTimeEnd.QuadPart;}

extern  LONGLONG rgllTimeArray[TIMELOG_MAX];
#else
#define BEGIN_TIMING(indx)  ;

#define END_TIMING(indx)    ;

#endif

#else

#define BEGIN_TIMING(indx)  ;

#define END_TIMING(indx)    ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\inc\oslayeru.h ===
#define  COPY_BUFF_SIZE 4096

#define BCS_OEM     1
#define BCS_UNI     2

#define ACCESS_MODE_MASK    0x0007  /* Mask for access mode bits */
#define ACCESS_READONLY     0x0000  /* open for read-only access */
#define ACCESS_WRITEONLY    0x0001  /* open for write-only access */
#define ACCESS_READWRITE    0x0002  /* open for read and write access */
#define ACCESS_EXECUTE      0x0003  /* open for execute access */

#define SHARE_MODE_MASK     0x0070  /* Mask for share mode bits */
#define SHARE_COMPATIBILITY 0x0000  /* open in compatability mode */
#define SHARE_DENYREADWRITE 0x0010  /* open for exclusive access */
#define SHARE_DENYWRITE     0x0020  /* open allowing read-only access */
#define SHARE_DENYREAD      0x0030  /* open allowing write-only access */
#define SHARE_DENYNONE      0x0040  /* open allowing other processes access */
#define SHARE_FCB           0x0070  /* FCB mode open */

/** Values for ir_options for VFN_OPEN: */

#define ACTION_MASK             0xff    /* Open Actions Mask */
#define ACTION_OPENEXISTING     0x01    /* open an existing file */
#define ACTION_REPLACEEXISTING  0x02    /* open existing file and set length */
#define ACTION_CREATENEW        0x10    /* create a new file, fail if exists */
#define ACTION_OPENALWAYS       0x11    /* open file, create if does not exist */
#define ACTION_CREATEALWAYS     0x12    /* create a new file, even if it exists */

/** Alternate method: bit assignments for the above values: */

#define ACTION_EXISTS_OPEN  0x01    // BIT: If file exists, open file
#define ACTION_TRUNCATE     0x02    // BIT: Truncate file
#define ACTION_NEXISTS_CREATE   0x10    // BIT: If file does not exist, create


#define OPEN_FLAGS_NOINHERIT                    0x0080
//#define OPEN_FLAGS_NO_CACHE       R0_NO_CACHE  /* 0x0100 */
#define OPEN_FLAGS_NO_COMPRESS                  0x0200
#define OPEN_FLAGS_ALIAS_HINT                   0x0400
#define OPEN_FLAGS_REOPEN                       0x0800
#define OPEN_FLAGS_RSVD_1                       0x1000 /* NEVER #define this */
#define OPEN_FLAGS_NOCRITERR                    0x2000
#define OPEN_FLAGS_COMMIT                       0x4000
#define OPEN_FLAGS_RSVD_2                       0x8000 /* NEVER #define this */
#define OPEN_FLAGS_EXTENDED_SIZE            0x00010000
#define OPEN_FLAGS_RAND_ACCESS_HINT         0x00020000
#define OPEN_FLAGS_SEQ_ACCESS_HINT          0x00040000
#define OPEN_EXT_FLAGS_MASK                 0x00FF0000
#define  ATTRIB_DEL_ANY     0x0007   // Attrib passed to ring0 delete


#define FLAG_RW_OSLAYER_INSTRUMENT      0x00000001
#define FLAG_RW_OSLAYER_PAGED_BUFFER    0x00000002

typedef HANDLE   CSCHFILE;
typedef int (*PATHPROC)(USHORT *, USHORT *, LPVOID);

#define CSCHFILE_NULL   0

//typedef USHORT        USHORT;
//typedef ULONG     ULONG;

#define _FILETIME           FILETIME
#define _WIN32_FIND_DATA    WIN32_FIND_DATA
#define string_t            unsigned short *

#define FILE_ATTRIBUTE_ALL (FILE_ATTRIBUTE_READONLY| FILE_ATTRIBUTE_HIDDEN \
                           | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_DIRECTORY \
                           | FILE_ATTRIBUTE_ARCHIVE)

#define  IsFile(dwAttr) (!((dwAttr) & (FILE_ATTRIBUTE_DIRECTORY|FILE_ATTRIBUTE_DEVICE)))

#define CheckHeap(a) {;}

#define GetLastErrorLocal() GetLastError()
#define SetLastErrorLocal(X) SetLastError(X)

#ifndef KdPrint
#ifdef DEBUG
#define KdPrint(X)  PrintFn X
#else
#define KdPrint(X)
#endif
#endif

CSCHFILE CreateFileLocal(LPSTR lpName);
CSCHFILE OpenFileLocal(LPSTR lpName);
int DeleteFileLocal(LPSTR lpName, USHORT usAttrib);
int FileExists (LPSTR lpName);
long ReadFileLocal (CSCHFILE handle, ULONG pos, LPVOID lpBuff,  long lCount);
long WriteFileLocal (CSCHFILE handle, ULONG pos, LPVOID lpBuff, long lCount);
long WriteFileInContextLocal (CSCHFILE, ULONG, LPVOID, long);
ULONG CloseFileLocal (CSCHFILE handle);
ULONG CloseFileLocalFromHandleCache (CSCHFILE handle);
int GetFileSizeLocal (CSCHFILE, PULONG);
int GetDiskFreeSpaceLocal(int indx
   , ULONG *lpuSectorsPerCluster
   , ULONG *lpuBytesPerSector
   , ULONG *lpuFreeClusters
   , ULONG *lpuTotalClusters
   );

int GetAttributesLocal (LPSTR, ULONG *);
int GetAttributesLocalEx (LPSTR lpPath, BOOL fFile, ULONG *lpuAttr);
int SetAttributesLocal (LPSTR, ULONG);
int RenameFileLocal (LPSTR, LPSTR);
int FileLockLocal(CSCHFILE, ULONG, ULONG, ULONG, BOOL);

LPVOID AllocMem (ULONG uSize);
VOID FreeMem (LPVOID lpBuff);
//VOID CheckHeap(LPVOID lpBuff);
LPVOID AllocMemPaged (ULONG uSize);
VOID FreeMemPaged(LPVOID lpBuff);

CSCHFILE R0OpenFile (USHORT usOpenFlags, UCHAR bAction, LPSTR lpPath);

CSCHFILE OpenFileLocalEx(LPSTR lpPath, BOOL fInstrument);
long ReadFileLocalEx
    (
    CSCHFILE handle,
    ULONG pos,
    LPVOID pBuff,
    long  lCount,
    BOOL    fInstrument
    );
long WriteFileLocalEx(CSCHFILE handle, ULONG pos, LPVOID lpBuff, long lCount, BOOL fInstrument);
CSCHFILE R0OpenFileEx
    (
    USHORT  usOpenFlags,
    UCHAR   bAction,
    ULONG   ulAttr,
    LPSTR   lpPath,
    BOOL    fInstrument
    );
long ReadFileLocalEx2(CSCHFILE handle, ULONG pos, LPVOID lpBuff, long lCount, ULONG flags);
long WriteFileLocalEx2(CSCHFILE handle, ULONG pos, LPVOID lpBuff, long lCount, ULONG flags);

int HexToA(ULONG ulHex, LPSTR lpBuff, int count);
ULONG AtoHex(LPSTR lpBuff, int count);
int wstrnicmp(const USHORT *, const USHORT *, ULONG);
ULONG strmcpy(LPSTR, LPSTR, ULONG);
int DosToWin32FileSize(ULONG, int *, int *);
int Win32ToDosFileSize(int, int, ULONG *);
int CompareTimes(_FILETIME, _FILETIME);
int CompareSize(long nHighDst, long nLowDst, long nHighSrc, long nLowSrc);
LPSTR mystrpbrk(LPSTR, LPSTR);

int CompareTimesAtDosTimePrecision( _FILETIME ftDst,
   _FILETIME ftSrc
   );

VOID
IncrementFileTime(
    _FILETIME *lpft
    );
unsigned int
UniToBCS (
     unsigned char  *pStr,
     unsigned short *pUni,
     unsigned int length,
     unsigned int maxLength,
     int charSet
);
unsigned int
BCSToUni (
     unsigned short *pUni,
     unsigned char  *pStr,
     unsigned int length,
     int charSet
);

ULONG wstrlen(
     USHORT *lpuStr
     );

int
PUBLIC
mystrnicmp(
    LPCSTR pStr1,
    LPCSTR pStr2,
    unsigned count
    );


int CreateDirectoryLocal(
    LPSTR   lpszPath
    );


ULONG
GetTimeInSecondsSince1970(
    VOID
    );

BOOL
IterateOnUNCPathElements(
    USHORT  *lpuPath,
    PATHPROC lpfn,
    LPVOID  lpCookie
    );

BOOL
IsPathUNC(
    USHORT      *lpuPath,
    int         cntMaxChars
    );


#define JOE_DECL_PROGRESS()
#define JOE_INIT_PROGRESS(counter,nearargs)
#define JOE_PROGRESS(bit)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\record.mgr\assert.h ===
/* Routines for debugging and error messages. */

#ifdef VxD
#define AssertFn  IFSMgr_AssertFailed
#define PrintFn   IFSMgr_Printf
#else
#define AssertFn  AssertFn
#define PrintFn   PrintFn
#endif

#ifdef DEBUG


#define AssertData static char szFileAssert[] = __FILE__;
#define AssertError static char szError[] = "Error";
#define Assert(f)  do {if (!(f)) AssertFn(szError, szFileAssert, __LINE__);} while(0)
#define AssertSz(f, sz)  do {if (!(f)) AssertFn(sz, szFileAssert, __LINE__);} while(0)
//BUGBUG this way of handling dbgprint is not very good....it can cause side effects in some cases.
//also, it doesn't work at all for NT. the whole of the sources should be munged-->KdPrint
//also, this is just cookie cutter code......since it's in the vxd directory it's unlikely to be called
//without defined(VxD)
#define DbgPrint  PrintFn
#else

#define Assert(f)
#define AssertData
#define AssertError
#define AssertSz(f, sz)
//BUGBUG see above
#define DbgPrint
#endif


#ifdef Vxd
void IFSMgr_AssertFailed(PCHAR pMsg, PCHAR pFile, ULONG uLine);
void IFSMgr_Printf(PCHAR pFmt, ...);
#else
VOID AssertFn(PCHAR pMsg, PCHAR pFile, ULONG uLine);
VOID PrintFn(PCHAR pFmt, ...);
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\inc\shdsys.h ===
/*

	Copyright 1991-1993 Microsoft Corporation.  All rights reserved.
	Microsoft Confidential.

	Common macros - internal use only; subincludes several .h files

*/

#ifndef _INCLUDE_SHDSYSH
#define _INCLUDE_SHDSYSH

/******************* Controlling Defines ************************************/
// define DEBUG unless explicitly asked not to:

#ifndef NONDEBUG
#ifndef DEBUG
#define DEBUG
#endif //DEBUG
#endif //NONDEBUG

#define VSZDD					// add vszDDxx strings in DDErr

/******************* Includes ***********************************************/
#ifndef _INC_WINDOWS
#include <windows.h>
#endif //_INC_WINDOWS

#include <stdlib.h>
#include <string.h>			// for string macros
#include <limits.h>			// implementation dependent values


/******************* Defines ************************************************/
#define cbSzTMax				256	// size of temp string buffers
#define cbSzRcMax				256	// max size of RC strings
#define cbSzNameMax			32		// max size of app name, class names, etc

#ifdef CHICAGO
#define cbSzFileMax			260	// max size of file names for Chicago
#else	// WIN31
#define cbSzFileMax			128	// max size of file names
#endif //CHICAGO

#ifndef TRUE
#define TRUE					1
#endif //TRUE

#ifndef FALSE
#define FALSE					0
#endif //FALSE

#define fTrue					TRUE	// alias
#define fFalse					FALSE	// alias
#define wDontCare				1
#define lDontCare				1L
#define lpszNull				((LPSTR)NULL)

/******************* Calling Conventions ************************************/

/* Exported functions: FAR PASCAL, LOADDS if BUILDDLL is defined

	WINAPI		Documented API (see windows.h)
	CALLBACK		DlgProc, WndProc, DriverProc, ResultsFunction (see windows.h)
	EXPORT		Internal system entry point (e.g. PenAboutBoxFn)
*/

#define EXPORT					WINAPI


/*	Internal functions, not exported:

	PUBLIC		FAR PASCAL (NEAR if SMALL)
					Called internally from several functional areas

	FASTPUBLIC	FAR _fastcall (NEAR if SMALL)
					Called internally from several functional areas;
					few arguments, no far ptrs, NOT exported

	FARPRIVATE	FAR PASCAL
					Called internally from one or few functional areas
		
	PRIVATE		NEAR PASCAL
					Called internally from same file

	FASTPRIVATE	NEAR _fastcall
					Called internally from same file;
					few arguments, no far ptrs, NOT exported

	IWINAPI		FAR PASCAL [LOADDS]
					For exclusive use by parameter validation layer;
					this is NOT exported (e.g. ITPtoDP)
*/

#ifdef SMALL
#ifndef PUBLIC
#define PUBLIC					NEAR PASCAL
#endif
#define FASTPUBLIC			NEAR _fastcall

#else // !SMALL
#ifndef PUBLIC
#define PUBLIC					FAR PASCAL
#endif
#define FASTPUBLIC			FAR _fastcall

#endif //SMALL

#define FARPRIVATE			FAR PASCAL
#ifndef PRIVATE
#define PRIVATE				NEAR PASCAL
#endif
#define FASTPRIVATE			NEAR _fastcall

#define IWINAPI				WINAPI

// for compatability only, in DLLs compiled without -Gw:
#define DLLEXPORT				FAR PASCAL _loadds


/******************* Generic Macros *****************************************/

#ifndef RC_INVOKED			// BLOCK is used in .rc version stamping
#define BLOCK
#endif //!RC_INVOKED

#define NOREF
#define Unref(var)			var;

#undef SetFlag
#undef ToggleFlag
#undef ResetFlag

// flag setting and testing (multiple flags ok):
#define SetFlag(w, flags)		do {(w) |= (flags);} while (0)
#define ToggleFlag(w, flags)	do {(w) ^= (flags);} while (0)
#define ResetFlag(w, flags)		do {(w) &= ~(flags);} while (0)

// tests: FFlag is common (T if any flag), FExactFlag is rare (all flags req):
#define FFlag(w, flags)			(BOOL)(((w) & (flags)) != 0)
#define FExactFlag(w, flags)	(BOOL)(((w) & (flags)) == (flags))

/******************* User Macros ********************************************/

/******************* Mem Macros *********************************************/

#define SG(x)					_based(_segname("_" #x))

#define CODECONST				SG(CODE)

// extra debug info: local name of function
#ifdef DEBUG
#define ThisFnIs(sz)\
	static char CODECONST szThisFn[] = sz;\
	static LPCSTR CODECONST lpszThisFn = szThisFn
#else
#define ThisFnIs(sz)	// nothing
#define lpszThisFn	NULL
#endif //DEBUG

#ifdef DEBUG
#define AssertSameSeg(x1,x2) (HIWORD((LPVOID)(x1))==HIWORD((LPVOID)(x2)))
#else
#define AssertSameSeg(x1, x2)
#endif //DEBUG

// handle from ptr (from windowsx.h):
#ifndef GlobalPtrHandle
#define GlobalPtrHandle(lp)\
	((HGLOBAL)LOWORD(GlobalHandle(SELECTOROF(lp))))
#endif

#define LocalUnlockFree(hMem) \
	do {\
	BOOL fErr = LocalUnlock(hMem);\
	HLOCAL h = LocalFree(hMem);\
	Assert(!fErr && !h);\
	hMem = (HLOCAL)NULL;\
	} while (0)

#define GlobalUnlockFree(hMem) do {\
	BOOL fErr = GlobalUnlock(hMem);\
	HGLOBAL h = GlobalFree(hMem);\
	Assert(!fErr && !h);\
	hMem = (HGLOBAL)NULL;\
	} while (0)


// mX macros return BOOL success of operation (and put dbg sz);
// for example: if (!mGlobalFree(hMem)) goto endFn;


#ifdef DEBUG
#define mGlobalAlloc(hglb, fuAlloc, cbAlloc) \
	(((HGLOBAL)hglb = GlobalAlloc(fuAlloc, cbAlloc)) != NULL \
	|| OOMSz(vszDDGlobalAlloc))

#define mGlobalReAlloc(hglbNew, hglb, cbNewSize, fuAlloc) \
	(((HGLOBAL)hglbNew = GlobalReAlloc((HGLOBAL)(hglb), cbNewSize, fuAlloc)) != NULL \
	|| OOMSz(vszDDGlobalReAlloc))

#define mGlobalLock(lpv, hglb) \
	(((LPVOID)lpv = GlobalLock((HGLOBAL)(hglb))) != NULL \
	|| PanicSz(vszDDGlobalLock))

#define mGlobalUnlock(hglb) \
	(!GlobalUnlock((HGLOBAL)(hglb)) || DbgSz(vszDDGlobalUnlock))

#define mGlobalFree(hglb) \
	(GlobalFree((HGLOBAL)(hglb)) == NULL || DbgSz(vszDDGlobalFree))


#define mLocalAlloc(hloc, fuAlloc, cbAlloc) \
	(((HLOCAL)hloc = LocalAlloc(fuAlloc, cbAlloc)) != NULL \
	|| OOMSz(vszDDLocalAlloc))

#define mLocalReAlloc(hlocNew, hloc, cbNewSize, fuAlloc) \
	(((HLOCAL)hlocNew = LocalReAlloc((HLOCAL)(hloc), cbNewSize, fuAlloc)) != NULL \
	|| OOMSz(vszDDLocalReAlloc))

#define mLocalLock(lpv, hloc) \
	(((LPVOID)lpv = LocalLock((HLOCAL)(hloc))) != NULL \
	|| PanicSz(vszDDLocalLock))

#define mLocalUnlock(hloc) \
	(!LocalUnlock((HLOCAL)(hloc)) || DbgSz(vszDDLocalUnlock))

#define mLocalFree(hloc) \
	(LocalFree((HLOCAL)(hloc)) == NULL)

#else

#define mGlobalAlloc(hglb, fuAlloc, cbAlloc) \
	(((HGLOBAL)hglb = GlobalAlloc(fuAlloc, cbAlloc)) != NULL)

#define mGlobalReAlloc(hglbNew, hglb, cbNewSize, fuAlloc) \
	(((HGLOBAL)hglbNew = GlobalReAlloc((HGLOBAL)(hglb), cbNewSize, fuAlloc)) != NULL)

#define mGlobalLock(lpv, hglb) \
	(((LPVOID)lpv = GlobalLock((HGLOBAL)(hglb))) != NULL)

#define mGlobalUnlock(hglb) \
	(!GlobalUnlock((HGLOBAL)(hglb)))

#define mGlobalFree(hglb) \
	(GlobalFree((HGLOBAL)(hglb)) == NULL)


#define mLocalAlloc(hloc, fuAlloc, cbAlloc) \
	(((HLOCAL)hloc = LocalAlloc(fuAlloc, cbAlloc)) != NULL)

#define mLocalReAlloc(hlocNew, hloc, cbNewSize, fuAlloc) \
	(((HLOCAL)hlocNew = LocalReAlloc((HLOCAL)(hloc), cbNewSize, fuAlloc)) != NULL)

#define mLocalLock(lpv, hloc) \
	(((LPVOID)lpv = LocalLock((HLOCAL)(hloc))) != NULL)

#define mLocalUnlock(hloc) \
	(!LocalUnlock((HLOCAL)(hloc)))

#define mLocalFree(hloc) \
	(LocalFree((HLOCAL)(hloc)) == NULL)

#endif //DEBUG




/******************* Gdi Macros *********************************************/

// delete GDI object if non NULL:
#define AssertDelObj(hobj) \
	do {\
	if (hobj && IsGDIObject(hobj)) {\
		BOOL fOk = DeleteObject(hobj);\
		Assert(fOk);\
	}\
	hobj = (HANDLE)0;\
	} while (0)

#define IsValidRect(lpr) \
	((lpr) \
	&& sizeof(*(lpr))==sizeof(RECT) \
	&& (lpr)->right >= (lpr)->left \
	&& (lpr)->bottom >= (lpr)->top)

#define IsValidNonemptyRect(lpr) \
	(IsValidRect(lpr) && !IsRectEmpty((CONST LPRECT)lpr))

/******************* String Macros ******************************************/
/* String macros. */

// If compiling an app small/medium model, then should use more efficient
//	near pointer version of

// this hack err... software innovation works quite well with models
// and National Language support to reduce duplication
#ifdef JAPAN
#define StrNlsPrefix()		j
#else
#define StrNlsPrefix()		
#endif //JAPAN

#ifdef SMALLSTRING
#define StrModelPrefix()	
#else
#define StrModelPrefix()	_f
#endif //SMALLSTRING

/*	These are the macros which have to have different implementations
	based on language (at least for DBCS) and model.

	These macros can be replaced transparently to deal with DBCS
	(without any changes in an app and without breaking any assuptions
	made by an app). Others such as strlen and strncmp have 2 flavors
	byte-oriented and logical character oriented. There will have
	to be new macro names defined for logical charcters since the apps
	currently assume byte orientation.
*/

#define SzStrStr(sz1,sz2)				StrModelPrefix() ##				\
	StrNlsPrefix() ## strstr(sz1, sz2)
#define SzStrCh(sz1,ch)					StrModelPrefix() ##				\
	StrNlsPrefix() ## strchr(sz1, ch)
#define SzStrTok(sz1,sz2)				StrModelPrefix() ##				\
	StrNlsPrefix() ## strtok(sz1,sz2)

/*	These macros are currently independent of language do not
	understand DBCS and are byte oriented. Refer above.
	StrModelPrefix is used here to create a single definition for
	multiple models.
*/

#define CbSizeSz(sz)						StrModelPrefix() ## strlen(sz)
#define SzCat(sz1,sz2)					StrModelPrefix() ## strcat(sz1,sz2)
#define SzNCat(sz1,sz2,n)				StrModelPrefix() ## strncat(sz1,sz2,n)
#define SzCopy(sz1,sz2)					StrModelPrefix() ## strcpy(sz2,sz1)
#define SzNCopy(sz1,sz2,n)				StrModelPrefix() ## strncpy(sz2,sz1,n)
#define FillBuf(sz,ch,c)				StrModelPrefix() ## memset(sz,ch,c)
#define FIsLpvEqualLpv(lpv1,lpv2,cb) (BOOL)(StrModelPrefix() ## 			\
	memcmp((LPVOID)(lpv1), (LPVOID)(lpv2), cb) == 0)
#define FIsSzEqualSzN(sz1,sz2,n)		(BOOL)(StrModelPrefix() ## 			\
	strnicmp(sz1,sz2,n) == 0)
#define Bltbyte(rgbSrc,rgbDest,cb)	StrModelPrefix() ## 						\
	memmove(rgbDest, rgbSrc, cb)
#define PvFindCharInBuf(pv,ch,cb)	StrModelPrefix() ## memchr(pv, ch, cb)

// model independent, language-independent (DBCS aware) macros
#define FIsSzEqualSz(sz1,sz2)			(BOOL)(lstrcmpi(sz1,sz2) == 0)
#define FIsSz1LessThanSz2(sz1,sz2)	(BOOL)(lstrcmpi(sz1,sz2) < 0)
#define FIsCaseSzEqualSz(sz1,sz2)	(BOOL)(lstrcmp(sz1,sz2) == 0)
#define SzFromInt(sz,w)					(wsprintf((LPSTR)sz, (LPSTR)"%d", w), (LPSTR)sz)
#define FLenSzLessThanCb(sz, cb)		(BOOL)(PvFindCharInBuf(sz, 0, cb) != NULL)

#ifdef SMALLSTRING
#define IntFromSz(sz)					atoi(sz)
#endif //SMALLSTRING


/******************* Typedefs ***********************************************/
typedef int						INT;	// alias
typedef int						RS;	// Resource String
typedef unsigned long      ulong;
typedef unsigned short     ushort;

#ifndef  VXD
typedef  LPSTR LPPATH;
#endif


#endif //_INCLUDE_SHDSYSH
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\record.mgr\cscsec.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    cscsec.h

Abstract:

    This module implements all security related definitions for disconnected
    operation of Client Side Caching

Revision History:

    Balan Sethu Raman     [SethuR]    6-October-1997

Notes:

--*/

#ifndef _SECURITY_H_
#define _SECURITY_H_

// The following functions are used to store/retrieve the access rights information
// for the various files/directories cached in the CSC database.

// routines to initialize/teardown the access rights infrastructure in CSC

extern DWORD
CscInitializeSecurity(
    LPVOID ShadowDatabaseName);

extern DWORD
CscTearDownSecurity(LPSTR s);

extern DWORD
CscInitializeSecurityDescriptor();

extern DWORD
CscUninitializeSecurityDescriptor();

//
// The CSC access rights database is organized around SIDs. SIDs uniquely identify
// an user across reboots, i.e., they are persistent.
//

typedef USHORT CSC_SID_INDEX, *PCSC_SID_INDEX;

extern DWORD
CscAddSidToDatabase(
    PVOID   pSid,
    ULONG   SidLength,
    PCSC_SID_INDEX pSidindex);

extern DWORD
CscRemoveSidFromDatabase(
    PVOID   pSid,
    ULONG   SidLength);

typedef struct _CSC_SID_ACCESS_RIGHTS_ {
    PVOID       pSid;
    ULONG       SidLength;
    ULONG       MaximalAccessRights;
} CSC_SID_ACCESS_RIGHTS, *PCSC_SID_ACCESS_RIGHTS;

extern DWORD
CscAddMaximalAccessRightsForSids(
    HSHADOW                 hParent,
    HSHADOW                 hShadow,
    ULONG                   NumberOfSids,
    PCSC_SID_ACCESS_RIGHTS  pSidAccessRights);

extern DWORD
CscAddMaximalAccessRightsForShare(
    HSERVER                 hServer,
    ULONG                   NumberOfSids,
    PCSC_SID_ACCESS_RIGHTS  pSidAccessRights);

extern DWORD
CscRemoveMaximalAccessRightsForSid(
    HSHADOW     hParent,
    HSHADOW     hShadow,
    PVOID       pSid,
    ULONG       SidLength);

//
// Since there are large number of files cached for a given SID the access rights
// are stored corresponding to a SID index. The SIDs are stored persistently in
// a special SID mapping file in the CSC database. Currently the SIDs are
// stored as an array and linear comparions are made. Since the number of SIDs
// will be typically less than 10 in any given system this organization suffices.
// The length of the SID is cached to facilitate quicker comparisons and avoid
// recomputation using the security API's.
//

typedef struct _CSC_SID_ {
    ULONG   SidLength;
    PVOID   pSid;
} CSC_SID, *PCSC_SID;

typedef struct _CSC_SIDS_ {
    ULONG   MaximumNumberOfSids;
    ULONG   NumberOfSids;
    CSC_SID Sids[];
} CSC_SIDS, *PCSC_SIDS;

// Two special indexes are distinguished, the CSC_GUEST_SID_INDEX which is used as
// the default access rights indicator when the SID does not map to a valid
// index and CSC_INVALID_SID_INDEX to indicate an invalid SID mapping.
//

#define CSC_GUEST_SID         (PVOID)(0x11111111)
#define CSC_GUEST_SID_LENGTH  (0x4)

// Achtung !!! these should match with those in shdcom.h
#define CSC_GUEST_SID_INDEX   (0xfffe)
#define CSC_INVALID_SID_INDEX (0x0)

// Achtung !!! this should match with that in shdcom.h
#define CSC_MAXIMUM_NUMBER_OF_CACHED_SID_INDEXES (0x4)

#define CSC_SID_QUANTUM       (0x2)

extern CSC_SID_INDEX
CscMapSidToIndex(
    PVOID   pSid,
    ULONG   SidLength);

//
// Currently access rights for upto four users are cached with any given file in
// the CSC database. This is based upon the fact that 4 DWORDs have been allocated
// for the security information in the CSC database. The file system specific
// access rights are 9 bits long ( it has been rounded off to 16 bits) and 16
// bits are used for the SID index. It is possible to increase this to 8 by
// squeezing in the SID index to the 7 bits in the 16 bits allocated for
// access rights.
//

#define MAXIMUM_NUMBER_OF_USERS (0x4)

typedef struct _ACCESS_RIGHTS_ {
    CSC_SID_INDEX SidIndex;
    USHORT        MaximalRights;
} ACCESS_RIGHTS, *PACCESS_RIGHTS;

typedef struct _CACHED_ACCESS_RIGHTS_ {
    ACCESS_RIGHTS   AccessRights[MAXIMUM_NUMBER_OF_USERS];
} CACHED_SECURITY_INFORMATION, *PCACHED_SECURITY_INFORMATION;

//
// All the global variables used in mapping/evaluating access rights are aggregated
// in the CSC_SECURITY data structure. Currently it contains the sid mapping file
// in the CSC database and the in memory data structure used.
//

typedef struct _CSC_SECURITY_ {
    CSCHFILE    hSidMappingsFile;
    PCSC_SIDS   pCscSids;
    LPVOID      ShadowDatabaseName;
} CSC_SECURITY, *PCSC_SECURITY;

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\record.mgr\csc_bmpk.h ===
/*++

    Copyright (c) 2000 Microsoft Corporation

Module Name:

    csc_bmpk.h

Abstract:

    Interface to the kernel mode utility functions of bitmaps
    associated with CSC files. The 'k' in the file name means "kernel"

Author:

    Nigel Choi [t-nigelc]  Sept 3, 1999

--*/

#ifndef _CSC_BITMAPK_H_
#define _CSC_BITMAPK_H_

#include "csc_bmpc.h" // common header for CscBmp file format

// Note: This CSC_BITMAP is different than the CSC_BITMAP in csc_bmpu.h

typedef struct _CSC_BITMAP {
    FAST_MUTEX mutex;   // synchronization
    BOOL valid;
    DWORD bitmapsize;   // size in bits. How many bits effective in the bitmap
    DWORD numDWORD;     // how many DWORDs allocated for the bitmap 
    LPDWORD bitmap;     // the bitmap itself
} CSC_BITMAP, *LPCSC_BITMAP, *PCSC_BITMAP;

extern LPSTR CscBmpAltStrmName;

LPCSC_BITMAP
CscBmpCreate(
    DWORD filesize);

VOID
CscBmpDelete(
    LPCSC_BITMAP *lplpbitmap);

// Outsiders should call CscBmpResize
BOOL
CscBmpResizeInternal(
    LPCSC_BITMAP lpbitmap,
    DWORD newfilesize,
    BOOL fAcquireMutex);

#define CscBmpResize(l, n) CscBmpResizeInternal(l, n, TRUE);

BOOL
CscBmpMark(
    LPCSC_BITMAP lpbitmap,
    DWORD fileoffset,
    DWORD bytes2Mark);

BOOL
CscBmpUnMark(
    LPCSC_BITMAP lpbitmap,
    DWORD fileoffset,
    DWORD bytes2Unmark);

BOOL
CscBmpMarkAll(
    LPCSC_BITMAP lpbitmap);

BOOL
CscBmpUnMarkAll(
    LPCSC_BITMAP lpbitmap);

int
CscBmpIsMarked(
    LPCSC_BITMAP lpbitmap,
    DWORD bitoffset);

int
CscBmpMarkInvalid(
    LPCSC_BITMAP lpbitmap);

DWORD
CscBmpGetBlockSize();

int
CscBmpGetSize(
    LPCSC_BITMAP lpbitmap);

int
CscBmpRead(
    LPCSC_BITMAP *lplpbitmap,
    LPSTR strmFname,
    DWORD filesize);

int
CscBmpWrite(
    LPCSC_BITMAP lpbitmap,
    LPSTR strmFname);

#endif // #ifndef _CSC_BMPK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\record.mgr\csc_bmpk.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    csc_bmpk.c

Abstract:

    This module implements the kernel mode utility functions of
    bitmaps associated with CSC files. CSC_BMP is an opaque
    structure. Must use the functions here to create/modify/destroy a
    CSC_BMP to ensure data integrity. The 'k' in the filename means
    "kernel mode."

Author:

    Nigel Choi [t-nigelc]  Sept 3, 1999

--*/

#include "precomp.h"
#include "csc_bmpk.h"

#if defined(BITCOPY)

LPSTR CscBmpAltStrmName = STRMNAME; /* used to append to file names */

#ifndef FlagOn
//
//  This macro returns TRUE if a flag in a set of flags is on and FALSE
//  otherwise
//
#define FlagOn(Flags,SingleFlag)        ((Flags) & (SingleFlag))
#endif

//csc_bmp dbgprint interface
#ifdef DEBUG
#define CscBmpKdPrint(__bit,__x) {\
    if (((CSCBMP_KDP_##__bit)==0) || \
    FlagOn(CscBmpKdPrintVector,(CSCBMP_KDP_##__bit))) {\
    KdPrint (__x);\
    }\
}
#define CSCBMP_KDP_ALWAYS             0x00000000
#define CSCBMP_KDP_BADERRORS          0x00000001
#define CSCBMP_KDP_IO                 0x00000002
#define CSCBMP_KDP_BITMANIP           0x00000004
#define CSCBMP_KDP_BITCHECK           0x00000008
#define CSCBMP_KDP_BITRANGE           0x00000010
#define CSCBMP_KDP_CREATEDESTROY      0x00000020
#define CSCBMP_KDP_RESIZE             0x00000040
#define CSCBMP_KDP_MUTEX              0x00000080
#define CSCBMP_KDP_READWRITE          0x00000100

#define CSCBMP_KDP_GOOD_DEFAULT (CSCBMP_KDP_BADERRORS)
#define CSCBMP_KDP_ALL 0xFFFFFFFF

// ULONG CscBmpKdPrintVector = CSCBMP_KDP_ALL;
ULONG CscBmpKdPrintVector = CSCBMP_KDP_BADERRORS;
#else
#define CscBmpKdPrint(__bit,__x)  {NOTHING;}
#endif


//
// Internally used functions
//

/*
    findBitRange

    Given a DWORD byte offset of a file and bytes to mark and number 
    of bits in CSC_BITMAP, return the start and end DWORD bit mask
    and index into the DWORD array.
    ** Does not prevent out of bounds. It's the responsibility of caller.
    Returns: last bit to mark.
*/

static DWORD
findBitRange(
    DWORD fileOffset,
    DWORD b2Mark,
    LPDWORD lpstartBitMask,
    LPDWORD lpendBitMask,
    LPDWORD lpstartDWORD,
    LPDWORD lpendDWORD)
{
    DWORD startbit; /* first bit to mark */
    DWORD endbit; /* last bit to mark */
    DWORD DWORDnumbits;
    DWORD all1s = -1;

    startbit = fileOffset/BLOCKSIZE;
    //if (startbit >= ttlNumBits) return FALSE;

    endbit = (fileOffset + b2Mark - 1)/BLOCKSIZE;
    //if (endbit >= ttlNumBits) endbit = ttlNumBits - 1;
    ASSERT(startbit <= endbit);

    DWORDnumbits = 8*sizeof(DWORD); /* sizeof returns size in bytes (8-bits) */

    *lpstartBitMask = all1s << (startbit%DWORDnumbits);
    *lpendBitMask = all1s >> (DWORDnumbits - endbit%DWORDnumbits - 1);
    *lpstartDWORD = startbit/DWORDnumbits;
    *lpendDWORD = endbit/DWORDnumbits;

    CscBmpKdPrint(
        BITRANGE,
        ("fileoffset: %u\tbytes2Mark: %u\n",
         fileOffset, b2Mark));
    CscBmpKdPrint(
        BITRANGE,
        ("startbit: %u\tendbit: %u\tstartDWORD: %u\tendDWORD: %u\n",
         startbit, endbit, *lpstartDWORD, *lpendDWORD));
    CscBmpKdPrint(
        BITRANGE,
        ("startBitMask: 0x%08x\nendBitMask: 0x%08x\n",
         *lpstartBitMask, *lpendBitMask));
    return endbit;
}

/*
    Justification of using FastMutex:

    Although we could implement a single writer/multiple reader
    synchronization mechanism, the overhead involved would not be
    justified for the operation on bitmaps. All of the operations that
    needed the mutex are short, in-memory operations. We instead use a
    simple, fast mutex to allow only one thread to read from/write to
    the lpbitmap being protected at a time.
*/

// ***Note*** check if lpbitmap is NULL before calling
#ifdef DEBUG
void
CscBmpAcquireFastMutex(
    LPCSC_BITMAP lpbitmap)
{
    CscBmpKdPrint(
        MUTEX, 
        ("CscBmpAcquireFastMutex for lpbitmap %x\n", lpbitmap));
    ExAcquireFastMutex(&(lpbitmap->mutex));
}
#else
#define CscBmpAcquireFastMutex(lpbitmap) \
               ExAcquireFastMutex(&((lpbitmap)->mutex));
#endif

// ***Note*** check if lpbitmap is NULL before calling
#ifdef DEBUG
void
CscBmpReleaseFastMutex(
    LPCSC_BITMAP lpbitmap)
{
    CscBmpKdPrint(
        MUTEX, 
        ("CscBmpReleaseFastMutex for lpbitmap %x\n", lpbitmap));
      ExReleaseFastMutex(&(lpbitmap->mutex));
}
#else
#define CscBmpReleaseFastMutex(lpbitmap) \
               ExReleaseFastMutex(&((lpbitmap)->mutex));
#endif

//
// Library Functions
//

/*++

    LPCSC_BITMAP CscBmpCreate()

    Routine Description:

       Creates a bitmap structure according to the filesize passed in. 
       Must use this function to create a CSC_BITMAP structure.

    Arguments:


    Returns:


    Notes:

--*/
LPCSC_BITMAP
CscBmpCreate(
    DWORD filesize)
{
    LPCSC_BITMAP bm;
    DWORD bitmapbytesize;
    DWORD i;

    bm = (LPCSC_BITMAP)RxAllocatePool(NonPagedPool, sizeof(CSC_BITMAP));

    if (bm == NULL)
        goto ERROROUT;

    bm->bitmapsize = filesize/BLOCKSIZE;
    if (filesize % BLOCKSIZE)
        bm->bitmapsize++;
    bm->numDWORD = bm->bitmapsize/(8*sizeof(DWORD));
    if (bm->bitmapsize % (8*sizeof(DWORD)))
        bm->numDWORD++;

    bm->bitmap = NULL;
    bm->valid = TRUE;
    bitmapbytesize = bm->numDWORD*sizeof(DWORD);
    if (bitmapbytesize) {
        bm->bitmap = (LPDWORD)RxAllocatePool(
                                NonPagedPool,
                                bitmapbytesize);
        if (bm->bitmap == NULL) {
            RxFreePool(bm);
            goto ERROROUT;
        }
        RtlZeroMemory(bm->bitmap, bitmapbytesize);
    }

    ExInitializeFastMutex(&bm->mutex);

    CscBmpKdPrint(
        CREATEDESTROY,
        ("CscBmpCreate %x: Allocated %u bytes; filesize %u; bitmapsize %u\n",
        bm,
        bitmapbytesize,
        filesize,
        bm->bitmapsize));
    CscBmpKdPrint(
        CREATEDESTROY,
        ("\tbitmap: %x\n", bm->bitmap));
    return bm;

ERROROUT:
    CscBmpKdPrint(
        BADERRORS,
        ("CscBmpCreate: Failed to allocate memory\n"));
    return NULL;
}

/*++

    CscBmpDelete(LPCSC_BITMAP * lplpbitmap)

Routine Description:

    Deletes and free up memory occupied by the bitmap structure.
    Must use this function to delete a CSC_BITMAP structure.
    Note that you have to pass in a pointer to an LPCSC_BITMAP.
    The function sets the LPCSC_BITMAP to NULL for you.

Arguments:


Returns:


Notes:

--*/
VOID
CscBmpDelete(
    LPCSC_BITMAP * lplpbitmap)
{
    if (*lplpbitmap == NULL) {
        CscBmpKdPrint(
            CREATEDESTROY,
            ("CscBmpDelete: no bitmap to delete\n"));
        return;
    }
    CscBmpKdPrint(
        CREATEDESTROY,
        ("CscBmpDelete commence %x bitmapsize: %u\n",
        *lplpbitmap,
        (*lplpbitmap)->bitmapsize));

    // Wait for all operations to get done
    CscBmpAcquireFastMutex(*lplpbitmap);
    CscBmpReleaseFastMutex(*lplpbitmap);

    if ((*lplpbitmap)->bitmap) {
        CscBmpKdPrint(
            CREATEDESTROY,
            ("CscBmpDelete: bitmap: %x\n", (*lplpbitmap)->bitmap));
        RxFreePool((*lplpbitmap)->bitmap);
    }
    RxFreePool(*lplpbitmap);
    *lplpbitmap = NULL;
    CscBmpKdPrint(
        CREATEDESTROY,
        ("CscBmpDelete: Done\n"));
}

/*++

    CscBmpResizeInternal()

Routine Description:

    Resizes a bitmap structure according to the newfilesize.
    Newly allocated bits will be marked. the param fAcquireMutex
    specifies if the mutex in lpbitmap should be acquired or not. If
    called from outside the library it should, as seen in the CscBmpResize
    macro in csc_bmpk.h . But if calling from CscBmpMark or Unmark it should
    not, because the mutex is already acquired before calling this function.
    If bitmap is marked invalid no resize is done.

Arguments:


Returns:

    FALSE if error in memory allocation, or if lpbitmap is NULL.

Notes:

--*/
BOOL
CscBmpResizeInternal(
    LPCSC_BITMAP lpbitmap,
    DWORD newfilesize,
    BOOL fAcquireMutex)
{
    LPDWORD newbitmap;
    DWORD newBitmapSize;
    DWORD newNumDWORD;
    DWORD bitMask;
    DWORD DWORDbits;
    DWORD all1s = -1;
    DWORD i;

    if (lpbitmap == NULL)
        return FALSE;

    if (!lpbitmap->valid) {
        CscBmpKdPrint(RESIZE, ("CscBmpResize: Bitmap marked invalid, done\n"));
        return TRUE;
    }

    DWORDbits = sizeof(DWORD)*8;

    newBitmapSize = newfilesize/BLOCKSIZE;
    if (newfilesize % BLOCKSIZE)
        newBitmapSize++;
    newNumDWORD = newBitmapSize/DWORDbits;
    if (newBitmapSize % DWORDbits)
        newNumDWORD++;

    // note: if new bitmap is smaller, data truncated from the old bitmap
    // will be lost, even if the bitmap is enlarged later on.

    CscBmpKdPrint(RESIZE, ("About to resize:\n"));
    CscBmpKdPrint(RESIZE, ("Old numDWORD = %u\n",lpbitmap->numDWORD));
    CscBmpKdPrint(RESIZE, ("New numDWORD = %u\n", newNumDWORD));
    CscBmpKdPrint(RESIZE, ("Old bitmap size = %u\n", lpbitmap->bitmapsize));
    CscBmpKdPrint(RESIZE, ("New bitmap size = %u\n", newBitmapSize));

    if (fAcquireMutex)
        CscBmpAcquireFastMutex(lpbitmap);

    if (newBitmapSize == lpbitmap->bitmapsize) {
        CscBmpKdPrint(
            RESIZE,
            ("new bitmap size == old bitmap size, no need to resize\n"));
    }

    if (newNumDWORD != lpbitmap->numDWORD) {
        // reallocate array of DWORD
        if (newBitmapSize != 0) {
            newbitmap = (LPDWORD)RxAllocatePool(
                                    NonPagedPool,
                                    newNumDWORD*sizeof(DWORD));
            if (!newbitmap)
                goto ERROROUT;
            ASSERT(newNumDWORD != lpbitmap->numDWORD);

            if (newNumDWORD > lpbitmap->numDWORD) {
                for (i = 0; i < lpbitmap->numDWORD; i++) {
                    newbitmap[i] = lpbitmap->bitmap[i];
            }
            for (i = lpbitmap->numDWORD; i < newNumDWORD; i++) {
                // mark all bits in the new DWORDS
                newbitmap[i] = -1;
            }
        } else {
            for (i = 0; i < newNumDWORD; i++) {
                newbitmap[i] = lpbitmap->bitmap[i];
            }
        }
    } else {
        newbitmap = NULL;
    }

    if (lpbitmap->bitmap) {
        RxFreePool(lpbitmap->bitmap);
    }
    lpbitmap->bitmap = newbitmap;
    CscBmpKdPrint(
        RESIZE,
        ("Reallocated New Bitmap: %x\n", 
        lpbitmap->bitmap));
    } else {
        CscBmpKdPrint(
            RESIZE,
            ("newNumDWORD == lpbitmap->numDWORD, no need to reallocate bitmap\n"));
    }

    if (lpbitmap->bitmap != NULL && lpbitmap->bitmapsize != 0) {
        if (newBitmapSize >= lpbitmap->bitmapsize) {
            // mark all new bits and the last bit in the last DWORD of "old" bitmap
            bitMask = all1s << ( (lpbitmap->bitmapsize%DWORDbits) - 1 );
            lpbitmap->bitmap[lpbitmap->numDWORD-1] |= bitMask;
        } else {
            // mark last bit of the "new" bitmap
            bitMask = all1s << ( (newBitmapSize%DWORDbits) - 1 );
            lpbitmap->bitmap[newNumDWORD-1] |= bitMask;
        }
        CscBmpKdPrint(RESIZE, ("Bitmask = 0x%x\n", bitMask));
        CscBmpKdPrint(RESIZE, ("Last DWORD of new bitmap= 0x%x\n",
        lpbitmap->bitmap[newNumDWORD-1]));
    }

    lpbitmap->bitmapsize = newBitmapSize;
    lpbitmap->numDWORD = newNumDWORD;

    if (fAcquireMutex)
        CscBmpReleaseFastMutex(lpbitmap);

    CscBmpKdPrint(RESIZE, ("Done Resize\n"));
    return TRUE;

ERROROUT:
    CscBmpKdPrint(
        BADERRORS,
        ("CscBmpResize: Failed to allocate memory for new bitmap\n"));
    return FALSE;
}

/*++

    CscBmpMark()

Routine Description:

   Marks the bit(s) in the bitmap according to the fileoffset
   and bytes2Mark. fileoffset is the byte offset into the file
   starting from the beginning of the file. bytes2Mark is the number
   of bytes altered in the file after and including the byte
   indicated by fileoffset. Return FALSE if lpbitmap is NULL.
   If lpbitmap is not valid do nothing and return TRUE.

Arguments:


Returns:


Notes:

--*/
BOOL
CscBmpMark(
    LPCSC_BITMAP lpbitmap,
    DWORD fileoffset,
    DWORD bytes2Mark)
{
    DWORD startbitmask;
    DWORD endbitmask;
    DWORD startDWORD;
    DWORD endDWORD;
    DWORD i;

    CscBmpKdPrint(
        BITMANIP,
        ("CscBmpMark: offset: %u bytes2Mark: %u\n",
        fileoffset, bytes2Mark));
    if (lpbitmap == NULL) {
        CscBmpKdPrint(BITMANIP, ("CscBmpMark: null bitmap, done.\n"));
        return FALSE;
    }

    if (!lpbitmap->valid) {
        CscBmpKdPrint(BITMANIP, ("CscBmpMark: bitmap marked invalid, done\n"));
        return TRUE;
    }

    CscBmpAcquireFastMutex(lpbitmap);
    // Extend bitmap if endbit is larger than existing
    if (findBitRange(
            fileoffset,
            bytes2Mark,
            &startbitmask,
            &endbitmask,
            &startDWORD,
            &endDWORD) >= lpbitmap->bitmapsize
    ) {
        CscBmpKdPrint(BITMANIP, ("CscBmpMark: have to resize\n"));
        CscBmpResizeInternal(lpbitmap, fileoffset+bytes2Mark, FALSE);
    }

    ASSERT(startDWORD <= endDWORD);
    if (startDWORD == endDWORD) {
        startbitmask &= endbitmask;
        ASSERT(startbitmask != 0);
        lpbitmap->bitmap[startDWORD] |= startbitmask;
    } else {
        for (i = (startDWORD+1); i < endDWORD; i++) {
            lpbitmap->bitmap[i] = -1; /* mark all */
        }
        lpbitmap->bitmap[startDWORD] |= startbitmask;
        lpbitmap->bitmap[endDWORD] |= endbitmask;
    }
    CscBmpReleaseFastMutex(lpbitmap);
    CscBmpKdPrint(BITMANIP, ("CscBmpMark: Done\n"));
    return TRUE;
}

/*++

    CscBmpUnMark()

Routine Description:

    Unmarks the bit(s) in the bitmap according to the fileoffset
    and bytes2Mark. fileoffset is the byte offset into the file
    starting from the beginning of the file. bytes2Unmark is the number
    of bytes altered in the file after and including the byte
    indicated by fileoffset.

Arguments:


Returns:

    Return FALSE if lpbitmap is NULL.

Notes:

--*/
BOOL
CscBmpUnMark(
    LPCSC_BITMAP lpbitmap,
    DWORD fileoffset,
    DWORD bytes2Unmark)
{
    DWORD startbitmask;
    DWORD endbitmask;
    DWORD startDWORD;
    DWORD endDWORD;
    DWORD i;

    CscBmpKdPrint(
        BITMANIP,
        ("CscBmpUnMark: offset: %u bytes2Mark: %u\n",
        fileoffset,
        bytes2Unmark));

    if (lpbitmap == NULL) {
        CscBmpKdPrint(BITMANIP, ("CscBmpUnMark: bitmap null. Done.\n"));
        return FALSE;
    }

    if (!lpbitmap->valid) {
        CscBmpKdPrint(BITMANIP, ("CscBmpUnMark: bitmap marked invalid, done\n"));
        return TRUE;
    }

    CscBmpAcquireFastMutex(lpbitmap);
    // Extend bitmap if endbit is larger than existing
    if (findBitRange(
            fileoffset,
            bytes2Unmark,
            &startbitmask,
            &endbitmask,
            &startDWORD,
            &endDWORD) >= lpbitmap->bitmapsize
    ) {
        CscBmpKdPrint(BITMANIP, ("CscBmpUnMark: have to resize\n"));
        CscBmpResizeInternal(lpbitmap, fileoffset+bytes2Unmark, FALSE);
    }

    ASSERT(startDWORD <= endDWORD);

    startbitmask = ~startbitmask;
    endbitmask = ~endbitmask;

    if (startDWORD == endDWORD) {
        startbitmask |= endbitmask;
        ASSERT(startbitmask != 0);
        lpbitmap->bitmap[startDWORD] &= startbitmask;
    } else {
        for (i = (startDWORD+1); i < endDWORD; i++) {
            lpbitmap->bitmap[i] = 0; /* unmark all */
        }
        lpbitmap->bitmap[startDWORD] &= startbitmask;
        lpbitmap->bitmap[endDWORD] &= endbitmask;
    }
    CscBmpReleaseFastMutex(lpbitmap);
    CscBmpKdPrint(BITMANIP, ("CscBmpUnMark: done\n"));
    return TRUE;
}

/*++

    CscBmpMarkAll()

Routine Description:

    Sets all bits in the bitmap to 1s.

Arguments:


Returns:

    FALSE if lpbitmap is NULL.
    TRUE otherwise.

Notes:

--*/
BOOL
CscBmpMarkAll(
    LPCSC_BITMAP lpbitmap)
{
    DWORD i;

    if (!lpbitmap) {
        CscBmpKdPrint(BITMANIP, ("CscBmpMarkAll: bitmap null\n"));
        return FALSE;
    }

    if (!lpbitmap->valid) {
        CscBmpKdPrint(BITMANIP, ("CscBmpMarkAll: bitmap marked invalid\n"));
        return TRUE;
    }

    CscBmpAcquireFastMutex(lpbitmap);
    for (i = 0; i < lpbitmap->numDWORD; i++) {
        lpbitmap->bitmap[i] = 0xFFFFFFFF;
    }
    CscBmpReleaseFastMutex(lpbitmap);
    CscBmpKdPrint(BITMANIP, ("CscBmpMarkAll: done\n"));
    return TRUE;
}

/*++
    CscBmpUnMarkAll()

Routine Description:

    Sets all bits in the bitmap to 0's.

Arguments:


Returns:

    FALSE if lpbitmap is NULL.
    TRUE otherwise.

Notes:

--*/
BOOL
CscBmpUnMarkAll(
    LPCSC_BITMAP lpbitmap)
{
    DWORD i;

    if (!lpbitmap) {
        CscBmpKdPrint(BITMANIP, ("CscBmpUnMarkAll: bitmap null\n"));    
        return FALSE;
    }

    if (!lpbitmap->valid) {
        CscBmpKdPrint(BITMANIP, ("CscBmpUnMarkAll: bitmap marked invalid\n"));
        return TRUE;
    }

    CscBmpAcquireFastMutex(lpbitmap);
        for (i = 0; i < lpbitmap->numDWORD; i++) {
        lpbitmap->bitmap[i] = 0;
    }
    CscBmpReleaseFastMutex(lpbitmap);
    CscBmpKdPrint(BITMANIP, ("CscBmpUnMarkAll: done\n"));
    return TRUE;
}

/*++

    CscBmpIsMarked()

Routine Description:

    Check if bitoffset'th bit in bitmap is marked. 

Arguments:


Returns:

    TRUE if marked
    FALSE if unmarked
        -1 if lpbitmap is NULL, or
            bitoffset is larger than the size of the bitmap, or
            bitmap is marked invalid

Notes:

    To translate from actual fileoffset to bitoffset, use
    fileoffset/CscBmpGetBlockSize();

--*/
int
CscBmpIsMarked(
    LPCSC_BITMAP lpbitmap, DWORD bitoffset)
{
    DWORD DWORDnum;
    DWORD bitpos;
    BOOL ret;

    if (lpbitmap == NULL) {
        CscBmpKdPrint(BITCHECK, ("CscBmpIsMarked: bitmap null\n"));
        return -1;
    }

    if (!lpbitmap->valid) {
        CscBmpKdPrint(BITCHECK, ("CscBmpIsMarked: bitmap is marked invalid\n"));
        return -1;
    }

    CscBmpAcquireFastMutex(lpbitmap);
    if (bitoffset >= lpbitmap->bitmapsize) {
        CscBmpKdPrint(
            BITCHECK,
            ("CscBmpIsMarked: bitoffset %u too big\n",
            bitoffset));
        CscBmpReleaseFastMutex(lpbitmap);
        return -1;
    }

    DWORDnum = bitoffset/(8*sizeof(DWORD));
    bitpos = 1 << bitoffset%(8*sizeof(DWORD));

    CscBmpKdPrint(
        BITCHECK,
        ("CscBmpIsMarked: bitoffset %u is "));
    if (lpbitmap->bitmap[DWORDnum] & bitpos) {
        CscBmpKdPrint(BITCHECK, ("marked\n"));
        ret = TRUE;
    } else {
        CscBmpKdPrint(BITCHECK, ("unmarked\n"));
        ret = FALSE;
    }
    CscBmpReleaseFastMutex(lpbitmap);
    return ret;
}

/*++

    CscBmpMarkInvalid()

Routine Description:

    Marks the bitmap invalid.

Arguments:

Returns:

    TRUE successful
    FALSE if lpbitmap is NULL

Notes:

--*/
int
CscBmpMarkInvalid(
    LPCSC_BITMAP lpbitmap)
{
    if (lpbitmap == NULL)
        return FALSE;

    lpbitmap->valid = FALSE;
    return TRUE;
}

/*++

    CscBmpGetBlockSize()

Routine Description:

    returns the pre-defined block size represented by 1 bit in the bitmap.

Arguments:

Returns:

Notes:

--*/
DWORD
CscBmpGetBlockSize()
{
  return BLOCKSIZE;
}

/*++

    CscBmpGetSize()

Routine Description:

    returns the bitmap size of the bitmap. if lpbitmap is NULL, return -1.

Arguments:

Returns:

Notes:

--*/
int
CscBmpGetSize(
    LPCSC_BITMAP lpbitmap)
{
    int ret;
    if (lpbitmap == NULL)
        return -1;

    CscBmpAcquireFastMutex(lpbitmap);
    ret = lpbitmap->bitmapsize;
    CscBmpReleaseFastMutex(lpbitmap);

    return ret;
}

/*++

    CscBmpRead()

Routine Description:

    For the bitmap file format, see csc_bmpc.c

    Reads the bitmap from the given strmFname. If file does not exist,
    create the bitmap file. Set the bitmap file into used state. One
    bitmap file can only be Read once before it is written back. Use
    file:stream format for strmFname.

    *** Remember to issue CscBmpWrite on the same file to set the bitmap
    *** file back to un-used state. ***

    if *lplpbitmap is NULL, allocate a new bitmap. The size of the
    bitmap is determined by the on-disk bitmap size. If there is no
    on-disk bitmap, the size of the new bitmap will be determined by the
    filesize argument.

    If *lplpbitmap is not NULL, the bitmap will be resized to the
    on-disk bitmap size if an on-disk bitmap exists and that it is
    larger than *lplpbitmap. If the on-disk bitmap does not exist,
    *lplpbitmap will be resize to the parameter filesize if filesize is
    larger than the size of *lplpbitmap. If both on-disk bitmap exists and
    *lplpbitmap is not NULL, the current bitmap will be merged with the
    on-disk bitmap.

    The inuse field of the file is set to TRUE once the file is open, if
    it is not already so. Otherwise, if the inuse field is already TRUE,
    the file is set to invalid since only one in-memory representation
    of the CSC_BMP can exist for one file. During synchronization, if
    the valid field or the inuse field of the file is FALSE, the bitmap
    will not be used during synchronization. The inuse field is set back
    to FALSE at CscBmpWrite (time the file closes).

    *** Note *** Check the legality of the filename before passing it in.
    The function does not check the filename.

Arguments:

    The filesize argument is used only when there are no on-disk
    bitmap. See Description above.

    strmFname is used as is. No stream name is appended. User of this
    function must append the stream name themselves. The stream name
    including the colon is defined as CscBmpAltStrmName.

Returns:

    -1 if lplpbitmap is NULL. 
    FALSE(0) if error in writing.
    1 if everything works well.

Notes:

    CODE.IMPROVEMENT better error code return

--*/
int
CscBmpRead(
    LPCSC_BITMAP *lplpbitmap,
    LPSTR strmFname,
    DWORD filesize)
{
    PNT5CSC_MINIFILEOBJECT miniFileObj;
    IO_STATUS_BLOCK ioStatusBlock;
    NTSTATUS Status;
    CscBmpFileHdr hdr;
    DWORD * bmpBuf;
    BOOL createdNew;
    BOOL corruptBmpFile = FALSE;
    DWORD bmpByteSize, i;
    int ret = 1;

    if (lplpbitmap == NULL) {
        CscBmpKdPrint(READWRITE, ("CscBmpRead: lplpbitmap == NULL\n"));
        return -1;
    }

    CscBmpKdPrint(
        READWRITE,
        ("CscBmpRead commence on lpbitmap %x file %s\n",
         *lplpbitmap, strmFname));

    try {
        miniFileObj = __Nt5CscCreateFile(NULL,
                          strmFname,
                          FLAG_CREATE_OSLAYER_OPEN_STRM, // CSCFlags
                          FILE_ATTRIBUTE_NORMAL,
                          FILE_WRITE_THROUGH|FILE_NON_DIRECTORY_FILE,
                          FILE_OPEN, // Create Disposition
                          0, // No Share Access 
                          FILE_READ_DATA |
                          FILE_WRITE_DATA|
                          SYNCHRONIZE, // DesiredAccess
                          NULL, // Continuation
                          NULL, FALSE); // Continuation Context

        Status = GetLastErrorLocal();
        CscBmpKdPrint(
                READWRITE,
                ("CscBmpRead status of (open existing ) CreateFile %u\n",
                Status));

        if (miniFileObj != NULL) {
            CscBmpKdPrint(
                READWRITE,
                ("CscBmpRead open existing bitmap %s\n", strmFname));
            createdNew = FALSE;
        } else if (Status == ERROR_FILE_NOT_FOUND) {
            // No Bitmap stream exists for the file, create new
            miniFileObj = __Nt5CscCreateFile(
                            NULL,
                            strmFname,
                            FLAG_CREATE_OSLAYER_OPEN_STRM, // CSCFlags
                            FILE_ATTRIBUTE_NORMAL,
                            FILE_WRITE_THROUGH|FILE_NON_DIRECTORY_FILE,
                            FILE_OPEN_IF, // Create Disposition
                            0, // No Share Access 
                            FILE_READ_DATA|
                            FILE_WRITE_DATA|
                            SYNCHRONIZE, // DesiredAccess
                            NULL, // Continuation
                            NULL, FALSE); // Continuation Context

            Status = GetLastErrorLocal();

            CscBmpKdPrint(
                  READWRITE,
                  ("CscBmpRead status of (create if not existing) %u\n",
                  Status));

            if (miniFileObj != NULL) {
                CscBmpKdPrint(
                    READWRITE,
                    ("CscBmpRead create new bitmap %s\n", strmFname));
                createdNew = TRUE;
            }
        }

        if (miniFileObj == NULL) {
            CscBmpKdPrint(
                BADERRORS,
                ("CscBmpRead: Can't read/create bitmap %s\n",
                strmFname));
            goto DONE;
        }

        if (*lplpbitmap && !((*lplpbitmap)->valid)) {
            corruptBmpFile = TRUE;
            goto WRITEHDR;
        }

        if (!createdNew) {
            // Read the file header
            Nt5CscReadWriteFileEx(
                R0_READFILE,
                (CSCHFILE)miniFileObj,
                0, // pos
                &hdr,
                sizeof(CscBmpFileHdr),
                0, // Flags
                &ioStatusBlock);

            if (ioStatusBlock.Status != STATUS_SUCCESS) {
                CscBmpKdPrint(
                    READWRITE,
                    ("CscBmpRead: Can't read header of bitmap file %s,Status\n",
                    strmFname,
                    ioStatusBlock.Status));
                corruptBmpFile = TRUE;
            } else if (ioStatusBlock.Information < sizeof(CscBmpFileHdr)) {
                CscBmpKdPrint(
                    READWRITE,
                    ("CscBmpRead: Can't read the whole header from %s,\n",
                    strmFname));
                CscBmpKdPrint(
                    READWRITE,
                    ("\tAssume corrupt bitmap file\n"));
                corruptBmpFile = TRUE;
            } else if (hdr.magicnum != MAGICNUM) {
                CscBmpKdPrint(
                    READWRITE,
                ("CscBmpRead: Magic Number don't match\n"));
                corruptBmpFile = TRUE;
            } else if (hdr.inuse) {
                CscBmpKdPrint(
                    READWRITE,
                    ("CscBmpRead: bitmap %s opened before this, mark corrupt\n",
                    strmFname));
                corruptBmpFile = TRUE;
            } else if (!hdr.valid) {
                CscBmpKdPrint(
                    READWRITE,
                    ("CscBmpRead: on-disk bitmap %s marked corrupt\n",
                    strmFname));
                corruptBmpFile = TRUE;
            }
            if (corruptBmpFile) {
                goto WRITEHDR;
            } else if (hdr.numDWORDs == 0) {
                if (*lplpbitmap == NULL) {
                    // size of on-disk bitmap is 0, and *lplpbitmap does not exist
                    // make a 0-sized lpbitmap
                    *lplpbitmap = CscBmpCreate(0);
                }
            } else {
                // Allocate mem for bmpBuf
                bmpByteSize = hdr.numDWORDs * sizeof(DWORD);
                bmpBuf = (DWORD *)RxAllocatePool(NonPagedPool, bmpByteSize);
                // Read the DWORD arrays into bmpBuf
                Nt5CscReadWriteFileEx(
                    R0_READFILE,
                    (CSCHFILE)miniFileObj,
                    sizeof(hdr), // pos
                    bmpBuf,
                    bmpByteSize,
                    0, // Flags
                    &ioStatusBlock);

                if (ioStatusBlock.Status != STATUS_SUCCESS) {
                    CscBmpKdPrint(
                        READWRITE,
                        ("CscBmpRead: Error reading bitmap %s, Status %u\n",
                        strmFname, ioStatusBlock.Status));
                    corruptBmpFile = TRUE;
                    goto WRITEHDR;
                } else if (ioStatusBlock.Information < bmpByteSize) {
                    CscBmpKdPrint(
                        READWRITE,
                        ("CscBmpRead: bitmap %s read != anticipated size\n",
                        strmFname));
                    corruptBmpFile = TRUE;
                    goto WRITEHDR;
                }

                // Allocate(Create)/Resize *lplpbitmap if necessary according 
                //          to size of *lplpbitmap, or size specified by header,
                //          whichever is bigger.
                if (*lplpbitmap) {
                    CscBmpAcquireFastMutex(*lplpbitmap);
                    // bitmap exists, resize if needed.
                    if ((*lplpbitmap)->bitmapsize < hdr.sizeinbits) {
                        // hdr specifies a bigger size than
                        // current *lplpbitmap size
                        CscBmpResizeInternal(*lplpbitmap,
                        hdr.sizeinbits*BLOCKSIZE,
                        FALSE);
                    }
                    CscBmpReleaseFastMutex(*lplpbitmap);
                } else {
                    // in-memory bitmap does not exist, Create it
                    *lplpbitmap = CscBmpCreate(hdr.sizeinbits*BLOCKSIZE);
                    if (!*lplpbitmap) {
                        goto DONE;
                    }
                }

                // Bitwise OR bmpBuf and (*lplpbitmap)->bitmap
                CscBmpAcquireFastMutex(*lplpbitmap);
                ASSERT((*lplpbitmap)->bitmapsize >= hdr.sizeinbits);
                for (i = 0; i < hdr.numDWORDs; i++) {
                    (*lplpbitmap)->bitmap[i] |= bmpBuf[i];
                }
                CscBmpReleaseFastMutex(*lplpbitmap);
            } // if not corrupt bitmap file
        } else { // if not created new (bitmap file exists)
            // createdNew on-disk bitmap
            // Allocate(Create)/Resize *lplpbitmap if necessary according to
            // filesize passed in, or current *lplpbitmap size, whichever is bigger.
            if (*lplpbitmap) {
                // Resize if needed
                CscBmpAcquireFastMutex(*lplpbitmap);
                if ((*lplpbitmap)->bitmapsize < filesize) {
                  CscBmpResizeInternal(*lplpbitmap, filesize, FALSE);
                }
                CscBmpReleaseFastMutex(*lplpbitmap);
            } else {
                // Create *lplpbitmap according to size information passed in
                *lplpbitmap = CscBmpCreate(filesize);
                if (!*lplpbitmap) {
                  goto DONE;
                }
            }
        }

WRITEHDR:
        // Write Header back to file, indicating:
        //   New sizes, in use, and if corruptBmpFile, invalid.
        CscBmpKdPrint(
            READWRITE,
            ("CscBmpRead: Writing back hdr to %s\n",strmFname));
        hdr.magicnum = MAGICNUM;
        hdr.inuse = (BYTE)TRUE;
        hdr.valid = (BYTE)!corruptBmpFile;
        if (hdr.valid) {
            CscBmpAcquireFastMutex(*lplpbitmap);
            hdr.sizeinbits = (*lplpbitmap)->bitmapsize;
            hdr.numDWORDs = (*lplpbitmap)->numDWORD;
            CscBmpReleaseFastMutex(*lplpbitmap);
        } else {
            hdr.sizeinbits = 0;
            hdr.numDWORDs = 0;
        }
        IF_DEBUG {
            if (corruptBmpFile)
                CscBmpKdPrint(
                    READWRITE,
                    ("CscBmpWrite: On disk bitmap %s invalid\n",
                    strmFname));
        }
        Nt5CscReadWriteFileEx(
            R0_WRITEFILE,
            (CSCHFILE)miniFileObj,
            0, // pos
            &hdr,
            sizeof(hdr),
            0, // Flags
            &ioStatusBlock);
        if (ioStatusBlock.Status != STATUS_SUCCESS) {
            CscBmpKdPrint(
                READWRITE,
                ("CscBmpRead: Error writing back hdr file to %s\n",
                strmFname));
        } else if (ioStatusBlock.Information < sizeof(hdr)) {
            CscBmpKdPrint(
                READWRITE,
                ("CscBmpRead: hdr size written to %s is incorrect\n",
                strmFname));
        }
        // Close miniFileObj
        CloseFileLocal((CSCHFILE)miniFileObj);
DONE:
        NOTHING;
    } finally {
        CscBmpKdPrint(
            READWRITE,
            ("CscBmpRead done on lpbitmap %x file %s\n",
            *lplpbitmap, strmFname));
    }

    return 1;
}

/*++

    CscBmpWrite()

    Routine Description:

        Tries to open the on-disk bitmap. If no on-disk bitmap exists,
        create one that is invalid, then bail out. The bitmap should be
        "Read," leaving a header, before "Write"

        Reads the header first from the Bitmap file. If the on-disk bitmap
        is valid, writes the bitmap to disk and set inuse to FALSE. If the
        on-disk bitmap is not valid, bail out.

        If a NULL lpbitmap is passed in, a size 0 INVALID bitmap is written
        on disk.

        *** Note *** Check the leaglity of the filename before passing it in.
        The function does not check the filename.

    Arguments:

        strmFname is used as is. No stream name is appended. User of this
        function must append the stream name themselves. The stream name
        including the colon is defined as CscBmpAltStrmName.

    Returns:

        FALSE(0) if error in writing.
        1 if everything works well.

    Notes:

--*/

int
CscBmpWrite(
    LPCSC_BITMAP lpbitmap,
    LPSTR strmFname)
{
    PNT5CSC_MINIFILEOBJECT miniFileObj;
    IO_STATUS_BLOCK ioStatusBlock;
    NTSTATUS Status;
    CscBmpFileHdr hdr;
    //BOOL createdNew;
    BOOL corruptBmpFile = FALSE;
    DWORD * bmpBuf = NULL;
    DWORD bmpByteSize;
    int iRet = 1;

    CscBmpKdPrint(
        READWRITE,
        ("++++++++++++++CscBmpWrite commence on %s\n", strmFname));

    try {
        miniFileObj = __Nt5CscCreateFile(
                            NULL,
                            strmFname,
                            FLAG_CREATE_OSLAYER_OPEN_STRM, // CSCFlags
                            FILE_ATTRIBUTE_NORMAL,
                            FILE_WRITE_THROUGH|FILE_NON_DIRECTORY_FILE,
                            FILE_OPEN, // Create Disposition
                            0, // No Share Access 
                            FILE_READ_DATA|FILE_WRITE_DATA|SYNCHRONIZE, // DesiredAccess
                            NULL, // Continuation
                            NULL, // Continuation Context
                            FALSE
                        );
        Status = GetLastErrorLocal();
        CscBmpKdPrint(
            READWRITE,
            ("CscBmpWrite status of first (open existing) CreateFile %u\n",
            Status));

        if (miniFileObj != NULL) {
            CscBmpKdPrint(
                READWRITE,
                ("CscBmpWrite open existing bitmap %s\n", strmFname));
            //createdNew = FALSE;
        } else if (Status == ERROR_FILE_NOT_FOUND) {
            corruptBmpFile = TRUE;
            // No Bitmap stream exists for the file, create new
            miniFileObj = __Nt5CscCreateFile(
                                NULL,
                                strmFname,
                                FLAG_CREATE_OSLAYER_OPEN_STRM, // CSCFlags
                                FILE_ATTRIBUTE_NORMAL,
                                FILE_WRITE_THROUGH|FILE_NON_DIRECTORY_FILE,
                                FILE_OPEN_IF, // Create Disposition
                                0, // No Share Access 
                                FILE_READ_DATA|FILE_WRITE_DATA|SYNCHRONIZE, // DesiredAccess
                                NULL, // Continuation
                                NULL, // Continuation Context
                                FALSE
                            );

            Status = GetLastErrorLocal();
            CscBmpKdPrint(
                READWRITE,
                ("CscBmpWrite status of (create if not existing) CreateFile %u\n",
                Status));

        if (miniFileObj != NULL) {
            CscBmpKdPrint(
                READWRITE,
                ("CscBmpWrite create new invalid bitmap %s\n",
                strmFname));
            }
        }

        if (miniFileObj == NULL) {
            CscBmpKdPrint(
                BADERRORS,
                ("CscBmpWrite: Can't read/create bitmap %s\n",
                strmFname));
            goto DONE;
        }

        if (lpbitmap && !(lpbitmap->valid)) {
            corruptBmpFile = TRUE;
            goto WRITEHDR;
        }

        if (!corruptBmpFile) {
            // Read the header
            Nt5CscReadWriteFileEx(
                R0_READFILE,
                (CSCHFILE)miniFileObj,
                0, // pos
                &hdr,
                sizeof(CscBmpFileHdr),
                0, // Flags
                &ioStatusBlock);

            if (ioStatusBlock.Status != STATUS_SUCCESS) {
                CscBmpKdPrint(
                    READWRITE,
                    ("CscBmpWrite: Can't read header from bitmap file %s, Status\n",
                    strmFname, ioStatusBlock.Status));
                corruptBmpFile = TRUE;
            } else if (ioStatusBlock.Information < sizeof(CscBmpFileHdr)) {
                CscBmpKdPrint(
                    READWRITE,
                    ("CscBmpWrite: Can't read the whole header from %s,\n",
                    strmFname));
                CscBmpKdPrint(READWRITE,
                    ("\tAssume corrupt bitmap file\n"));
                corruptBmpFile = TRUE;
            } else if (hdr.magicnum != MAGICNUM) {
                CscBmpKdPrint(
                    READWRITE,
                    ("CscBmpWrite: Magic Number don't match\n"));
                corruptBmpFile = TRUE;
            } else if (!hdr.valid) {
                CscBmpKdPrint(
                    READWRITE,
                    ("CscBmpWrite: Bitmap %s marked invalid\n",
                    strmFname));
                corruptBmpFile = TRUE;
            }
        } // if (!corruptBmpFile)

WRITEHDR:
        // Write Header back to file, indicating
        // new sizes, not in use, and if corruptBmpFile, invalid.
        CscBmpKdPrint(
            READWRITE,
            ("CscBmpWrite: Writing back hdr to %s\n",strmFname));
        hdr.magicnum = MAGICNUM;
        hdr.inuse = (BYTE)FALSE;
        if (!corruptBmpFile && lpbitmap) {
            CscBmpAcquireFastMutex(lpbitmap);
            hdr.sizeinbits = lpbitmap->bitmapsize;
            hdr.numDWORDs = lpbitmap->numDWORD;
            bmpByteSize = lpbitmap->numDWORD * sizeof(DWORD);
            if (bmpByteSize > 0) {
                bmpBuf = RxAllocatePool(NonPagedPool,
                bmpByteSize);
                if (!bmpBuf) {
                    CscBmpKdPrint(
                        BADERRORS,
                        ("CscBmpWrite: Error allocating buffer for writing bitmap to disk\n"));
                    corruptBmpFile = TRUE;
                } else {
                    RtlCopyMemory(bmpBuf, lpbitmap->bitmap, bmpByteSize);
                }
            }
            CscBmpReleaseFastMutex(lpbitmap);
        } else {
            hdr.sizeinbits = 0;
            hdr.numDWORDs = 0;
            corruptBmpFile = TRUE;
        }

        // Write bitmap body first, if needed
        if (!corruptBmpFile && lpbitmap && bmpBuf) {
            Nt5CscReadWriteFileEx(
                R0_WRITEFILE,
                (CSCHFILE)miniFileObj,
                sizeof(hdr), // pos
                bmpBuf,
                bmpByteSize,
                0, // Flags
                &ioStatusBlock);
            if (ioStatusBlock.Status != STATUS_SUCCESS) {
                CscBmpKdPrint(
                    BADERRORS,
                    ("CscBmpWrite: Error writing back bitmap to %s\n",
                    strmFname));
                corruptBmpFile = TRUE;
            } else if (ioStatusBlock.Information < bmpByteSize) {
                CscBmpKdPrint(
                    BADERRORS,
                    ("CscBmpWrite: bitmap size %u written to %s is incorrect\n",
                    bmpByteSize, strmFname));
                corruptBmpFile = TRUE;
            }
        }

        // Then write header, indicating if anything invalid
        hdr.valid = (BYTE)!corruptBmpFile;
        IF_DEBUG {
            if (corruptBmpFile)
                CscBmpKdPrint(
                    READWRITE,
                    ("CscBmpWrite: On disk bitmap %s invalid\n",
                    strmFname));
        }
        Nt5CscReadWriteFileEx(
            R0_WRITEFILE,
            (CSCHFILE)miniFileObj,
            0, // pos
            &hdr,
            sizeof(hdr),
            0, // Flags
            &ioStatusBlock);
        if (ioStatusBlock.Status != STATUS_SUCCESS) {
            CscBmpKdPrint(
                BADERRORS,
                ("CscBmpWrite: Error writing back hdr file to %s\n",
                strmFname));
            corruptBmpFile = TRUE;
        } else if (ioStatusBlock.Information < sizeof(hdr)) {
            CscBmpKdPrint(
                BADERRORS,
            ("CscBmpWrite: hdr size written to %s is incorrect\n",
            strmFname));
        corruptBmpFile = TRUE;
        }

        // Close miniFileObj
        CloseFileLocal((CSCHFILE)miniFileObj);

    DONE:
        NOTHING;
    } finally {
        if (bmpBuf != NULL) {
            RxFreePool(bmpBuf);
        }
    }

    CscBmpKdPrint(
        READWRITE,
        ("--------------CscBmpWrite exit 0x%x\n", iRet));

    return iRet; // to be implemented for kernel mode
}

#endif // BITCOPY
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\record.mgr\cshadow.h ===
#ifndef _CSHADOW_H_
#define _CSHADOW_H_
#if defined(BITCOPY)
#include <csc_bmpk.h>
#endif // defined(BITCOPY)

#define MAX_SERVER_STRING  32
#define MAX_DOS_NAME       255
#define MAX_SHADOW_NAME_SIZE  32
#define SRET_OK           0
#define SRET_ERROR        -1


#define  SRET_WILDCARD_HINT      1
#define  SRET_OBJECT_HINT        2


#define  RNMFLGS_MARK_SOURCE_DELETED         0x00000001
#define  RNMFLGS_USE_FIND32_TIMESTAMPS       0x00000002
#define  RNMFLGS_USE_FIND32_83NAME           0x00000004
#define  RNMFLGS_SAVE_ALIAS                  0x00000008
#define  RNMFLGS_RETAIN_ALIAS                0x00000010
#define  RNMFLGS_MARK_SOURCE_ORPHAN          0x00000020

#define  AssertInShadowCrit()    Assert(vfInShadowCrit)

typedef int (*LPDELETECALLBACK)(HSHADOW, HSHADOW);
extern LPDELETECALLBACK lpDeleteCBForIoctl;

#define CSHADOW_LIST_TYPE_EXCLUDE       0
#define CSHADOW_LIST_TYPE_CONSERVE_BW   1

#ifdef DEBUG
extern int vfInShadowCrit;
#endif


extern LPVOID lpdbShadow;

BOOL FExistsRecDB(
    LPSTR    lpszLocation
    );

BOOL FExistsShadowDB(
    LPSTR    lpszLocation
    );

int OpenShadowDB(
    LPSTR   lpszLocation,
    LPSTR   lpszUserName,
    DWORD   dwDefDataSizeHigh,
    DWORD   dwDefDataSizeLow,
    DWORD   dwClusterSize,
    BOOL    fReinit,
    BOOL    *lpfReinited
    );

int PUBLIC CloseShadowDB(VOID);

HSHADOW  HAllocShadowID(HSHADOW, BOOL);
int FreeShadowID(HSHADOW);
int GetShadowSpaceInfo(LPSHADOWSTORE);
int SetMaxShadowSpace(long nFileSizeHigh, long nFileSizeLow);
int AdjustShadowSpace(long, long, long, long, BOOL);
int AllocShadowSpace(long, long, BOOL);
int FreeShadowSpace(long, long, BOOL);
int PUBLIC GetLocalNameHSHADOW(HSHADOW, LPBYTE, int, BOOL);
int GetWideCharLocalNameHSHADOW(
    HSHADOW  hShadow,
    USHORT      *lpBuffer,
    LPDWORD     lpdwSize,
    BOOL        fExternal
    );
int PUBLIC CreateFileHSHADOW(HSHADOW);

#if defined(BITCOPY)
int OpenFileHSHADOWAndCscBmp(HSHADOW, USHORT, UCHAR, CSCHFILE far *, BOOL, DWORD, LPCSC_BITMAP *);
int OpenCscBmp(HSHADOW, LPCSC_BITMAP *);
#define OpenFileHSHADOW(a, b , c, d) OpenFileHSHADOWAndCscBmp(a, b, c, d, FALSE, 0, NULL)
#endif // defined(BITCOPY)

int GetSizeHSHADOW(HSHADOW, ULONG *, ULONG *);
int GetDosTypeSizeHSHADOW(HSHADOW, ULONG *);
int PUBLIC CreateShadow(HSHADOW hDir, LPFIND32 lpFind32, ULONG uFlags, LPHSHADOW, BOOL *lpfCreated);
BOOL PUBLIC ExcludeFromCreateShadow(USHORT  *lpuName, ULONG len, BOOL fCheckExclusionList);
BOOL PUBLIC CheckForBandwidthConservation(USHORT  *lpuName, ULONG len);
int PUBLIC CreateShadowInternal( HSHADOW  hDir, LPFIND32 lpFind32, ULONG uFlags, LPOTHERINFO lpOI, LPHSHADOW  lphNew);
int PUBLIC DeleteShadow(HSHADOW hDir, HSHADOW hShadow);
int PUBLIC TruncateDataHSHADOW (HSHADOW, HSHADOW);
int PUBLIC RenameDataHSHADOW(HSHADOW, HSHADOW);
int PUBLIC GetShadow(HSHADOW hDir, USHORT *lpName, LPHSHADOW lphShadow, LPFIND32 lpFind32, ULONG *lpuShadowStatus, LPOTHERINFO lpOI);
int PUBLIC                              // ret
GetShadowEx(                              //
    HSHADOW  hDir,
    USHORT *lpName,
    LPHSHADOW lphShadow,
    LPFIND32 lpFind32,
    ULONG far *lpuShadowStatus,
    LPOTHERINFO lpOI,
    LPVOID      lpSecurityBlob,
    LPDWORD     lpdwBlobSize
    );
int PUBLIC ChkStatusHSHADOW(HSHADOW hDir, HSHADOW hNew, LPFIND32 lpFind32, ULONG far *lpuFlags);
int PUBLIC ChkUpdtStatusHSHADOW(HSHADOW hDir, HSHADOW hNew, LPFIND32 lpFind32, ULONG far *lpuFlags);
int PUBLIC GetShadowInfo(HSHADOW hDir, HSHADOW hNew, LPFIND32 lpFind32, ULONG far *lpuFlags, LPOTHERINFO lpOI);
int PUBLIC SetShadowInfo(HSHADOW hDir, HSHADOW hNew, LPFIND32 lpFind32, ULONG uFlags, ULONG uOp);
int PUBLIC RenameShadow(HSHADOW, HSHADOW, HSHADOW, LPFIND32, ULONG, LPOTHERINFO, ULONG, LPHSHADOW);
int PUBLIC
    RenameShadowEx(
    HSHADOW     hDirFrom,
    HSHADOW     hShadowFrom,
    HSHARE     hShareTo,
    HSHADOW     hDirTo,
    LPFIND32    lpFind32To,
    ULONG       uShadowStatusTo,
    LPOTHERINFO lpOI,
    ULONG       uRenameFlags,
    LPVOID      lpSecurityBlobTo,
    LPDWORD     lpdwBlobSizeTo,
    LPHSHADOW   lphShadowTo
    );

int PUBLIC GetShadowInfoEx
    (
    HSHADOW     hDir,
    HSHADOW     hShadow,
    LPFIND32    lpFind32,
    ULONG       far *lpuStatus,
    LPOTHERINFO lpOI,
    LPVOID      lpSecurityBlob,
    LPDWORD     lpdwBlobSize
    );

int PUBLIC                              // ret
SetShadowInfoEx(                          //
    HSHADOW     hDir,
    HSHADOW     hShadow,
    LPFIND32    lpFind32,
    ULONG       uFlags,
    ULONG       uOp,
    LPOTHERINFO lpOI,
    LPVOID      lpSecurityBlob,
    LPDWORD     lpdwBlobSize
    );


int MetaMatch(HSHADOW, LPFIND32, ULONG *, LPHSHADOW, ULONG *, LPOTHERINFO, METAMATCHPROC, LPVOID);

HSHARE PUBLIC HCreateShareObj(USHORT *, LPSHADOWINFO lpSI);
int PUBLIC DestroyHSHARE(HSHARE);
int PUBLIC GetShareFromPath(USHORT *, LPSHADOWINFO);
int PUBLIC GetShareInfo(HSHARE, LPSHAREINFOW, LPSHADOWINFO);
int PUBLIC SetShareStatus(HSHARE, ULONG, ULONG);
int PUBLIC GetShareInfoEx(HSHARE, LPSHAREINFOW, LPSHADOWINFO, LPVOID, LPDWORD);
int PUBLIC SetShareStatusEx(HSHARE, ULONG, ULONG, LPVOID, LPDWORD);
int GetRenameAliasHSHADOW(HSHADOW, HSHADOW, LPHSHADOW, LPHSHADOW);
BOOL IsBusy(HSHADOW hShadow);
int PUBLIC GetAncestorsHSHADOW(HSHADOW, LPHSHADOW, LPHSHARE);
CSC_ENUMCOOKIE  PUBLIC BeginPQEnum(VOID);
int PUBLIC SetPriorityHSHADOW(HSHADOW, HSHADOW, ULONG, ULONG);
int PUBLIC GetPriorityHSHADOW(HSHADOW, HSHADOW, ULONG *, ULONG *);
int PUBLIC ChangePriEntryStatusHSHADOW(HSHADOW, HSHADOW, ULONG, ULONG, BOOL, LPOTHERINFO);
int PUBLIC EndPQEnum(CSC_ENUMCOOKIE);
int PUBLIC PrevPriSHADOW(LPVOID);
int PUBLIC NextPriSHADOW(LPVOID);


BOOL
InitializeShadowCritStructures (
    void
    );
VOID
CleanupShadowCritStructures(
    VOID
    );

#ifndef CSC_RECORDMANAGER_WINNT
int EnterShadowCrit(void);
int LeaveShadowCrit(void);
#else
#if !DBG
#define ENTERLEAVESHADOWCRIT_SIGNATURE void
#define EnterShadowCrit() {__EnterShadowCrit();}
#define LeaveShadowCrit() {__LeaveShadowCrit();}
#else
#define ENTERLEAVESHADOWCRIT_SIGNATURE PSZ FileName, ULONG LineNumber
#define EnterShadowCrit() {__EnterShadowCrit(__FILE__,__LINE__);}
#define LeaveShadowCrit() {__LeaveShadowCrit(__FILE__,__LINE__);}
#endif
int __EnterShadowCrit(ENTERLEAVESHADOWCRIT_SIGNATURE);
int __LeaveShadowCrit(ENTERLEAVESHADOWCRIT_SIGNATURE);
#endif //#ifdef CSC_RECORDMANAGER_WINNT

int LeaveShadowCritIfThisThreadOwnsIt(void);
#ifdef CSC_RECORDMANAGER_WINNT
extern BOOLEAN    MRxSmbIsCscEnabled;
#endif

int GetRootWithChecks(HSHARE, USHORT *, BOOL, LPHSHADOW, LPFIND32, ULONG *, LPOTHERINFO);
int GetShadowWithChecks(HSHADOW, USHORT *, USHORT *, BOOL, LPHSHADOW, LPFIND32, ULONG *, LPOTHERINFO);



int CreateHint(HSHADOW hShadow, LPFIND32 lpFind32, ULONG uHintFlags, ULONG uHintPri, LPHSHADOW lphHint);
int DeleteHint(HSHADOW hShadow, USHORT *lpuHintName, BOOL fClearAll);
int CreateGlobalHint(USHORT *lpuName, ULONG uHintFlags, ULONG uHintPri);
int DeleteGlobalHint(USHORT *lpuName, BOOL fClearAll);
int
FindCreateShare(
    USHORT            *lpShareName,
    BOOL            fCreate,
    LPSHADOWINFO    lpShadowInfo,
    BOOL            *lpfCreated
    );

#ifdef CSC_RECORDMANAGER_WINNT
int FindCreateShareForNt(
    PUNICODE_STRING         pShareName,
    BOOL                    fCreate,
    LPSHADOWINFO            lpSI,
    BOOL                    *lpfCreated
    );
#endif

int PUBLIC  GetSecurityBlobHSHADOW(HSHADOW  hDir, HSHADOW hShadow, LPVOID lpBuffer, LPDWORD lpdwBufferSize);
int PUBLIC  SetSecurityBlobHSHADOW(HSHADOW  hDir, HSHADOW hShadow, LPVOID lpBuffer, LPDWORD lpdwBufferSize);

#ifdef LATER
int PUBLIC GetPathSVROBJ(HSHARE, LPSTR, ULONG);
int PUBLIC GetLinkPropSVROBJ(HSHARE, LPLINKPROP);
int PUBLIC UpdateShadowHSHADOW(HSHADOW);
int PUBLIC ChangeShadowInfo(HSHADOW, LPSHADOWINFO);
#endif //LATER

//prototypes added to remove NT compile errors
CSC_ENUMCOOKIE  PUBLIC HBeginPQEnum(VOID);
int PUBLIC EndPQEnum(CSC_ENUMCOOKIE hPQEnum);
int InitOtherInfo(LPOTHERINFO lpOI);

int PathFromHShadow(
    HSHADOW  hDir,
    HSHADOW  hShadow,
    USHORT   *lpBuff,
    int      cBuff      // count of max characters that the buffer can hold
);

int CopyHSHADOW(
    HSHADOW hDir,
    HSHADOW hShadow,
    LPSTR   lpszDestinationFile,
    ULONG   ulATtrib
    );

int BeginInodeTransactionHSHADOW(
    VOID
    );

int EndInodeTransactionHSHADOW(
    VOID
    );

int
GetSecurityInfosFromBlob(
    LPVOID          lpvBlob,
    DWORD           dwBlobSize,
    LPSECURITYINFO  lpSecInfo,
    DWORD           *lpdwItemCount
    );

int SetList(
    USHORT  *lpList,
    DWORD   cbBufferSize,
    int     typeList
    );

int
GetHShareFromUNCString(
    USHORT  *lpShare,
    int     cbShare,
    int     lenSkip,
    BOOL    fIsShareName,
    HSHARE *lphShare,
    ULONG   *lpulHintFlags
    );

int
GetDatabaseLocation(
    LPSTR   lpszLocation
    );

BOOL
EnableHandleCaching(
    BOOL    fEnable
    );

int
RecreateHSHADOW(
    HSHADOW hDir,
    HSHADOW hShadow,
    ULONG   ulAttribIn
    );

VOID
QuerySparseStaleDetectionCount(
    LPDWORD lpcnt
    );

VOID
QueryManualFileDetectionCount(
    LPDWORD lpcnt
    );

ULONG
QueryDatabaseErrorFlags(
    VOID
    );

DWORD
QueryNameSpaceVersion(
    VOID
    );
    
int
HasDescendentsHShadow(
    HSHADOW hDir,
    HSHADOW hShadow,
    BOOLEAN *lpfDescendents
    );
    
int
SetDatabaseStatus(
    ULONG   ulStatus,
    ULONG   uMask
    );

int CopyOtherInfoToShadowInfo(
    LPOTHERINFO     lpOI,
    LPSHADOWINFO    lpShadowInfo
    );

#endif // #ifndef _CSHADOW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\record.mgr\defs.h ===
#ifndef BASETYPES
#define BASETYPES
typedef long   LONG;
typedef unsigned long ULONG;
typedef ULONG *PULONG;
typedef unsigned short USHORT;
typedef USHORT *PUSHORT;
typedef unsigned char UCHAR;
typedef UCHAR *PUCHAR;
typedef char *PCHAR;
// typedef void   VOID;
#endif  /* !BASETYPES */

#define MAX_PATH          260

#ifndef NULL
#ifdef __cplusplus
#define NULL	0
#else
#define NULL	((void *)0)
#endif
#endif

#ifndef FALSE
#define FALSE               0
#endif

#ifndef TRUE
#define TRUE                1
#endif

#ifndef IN
#define IN
#endif

#ifndef OUT
#define OUT
#endif

#ifndef OPTIONAL
#define OPTIONAL
#endif

#undef far
#undef near
#undef pascal

#define far
#define near
#if (_MSC_VER >= 800)
#define pascal __stdcall
#else
#define pascal
#endif

#ifdef DOSWIN32
#define cdecl _cdecl
#ifndef CDECL
#define CDECL _cdecl
#endif
#else
#define cdecl
#ifndef CDECL
#define CDECL
#endif
#endif

#if (_MSC_VER >= 800)
#define CALLBACK    __stdcall
#define WINAPI      __stdcall
#define WINAPIV     __cdecl
#define APIENTRY    WINAPI
#define APIPRIVATE  __stdcall
// #define PASCAL      __stdcall
#else
#define CALLBACK
#define WINAPI
#define WINAPIV
#define APIENTRY    WINAPI
#define APIPRIVATE
#define PASCAL      pascal
#endif

#define NEAR                near
#ifndef CONST
#define CONST               const
#endif

typedef unsigned long       DWORD;
typedef int                 BOOL;
typedef unsigned char       BYTE;
typedef unsigned short      WORD;
typedef float               FLOAT;
typedef FLOAT               *PFLOAT;
typedef BOOL near           *PBOOL;
typedef BOOL far            *LPBOOL;
typedef BYTE near           *PBYTE;
typedef BYTE far            *LPBYTE;
typedef int near            *PINT;
typedef int far             *LPINT;
typedef WORD near           *PWORD;
typedef WORD far            *LPWORD;
typedef long far            *LPLONG;
typedef DWORD near          *PDWORD;
typedef DWORD far           *LPDWORD;
typedef void far            *LPVOID, *PVOID;
typedef CONST void far      *LPCVOID;
typedef  char  far          *LPSZ, *LPSTR, *LPCHAR;
typedef int                 INT;
typedef unsigned int        UINT;
typedef unsigned int        *PUINT;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\record.mgr\cshadow.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

     CShadow.c

Abstract:

    This file implements the "cshadow" interface that is used by the redir and ioctls.
    The cshadow interface hides the actual implementation of the csc database from the
    users of the database.

    There are three persistant database types exposed

    1) The database of shares
    2) The filesystem hierarchy under any particular share
    3) The priority queue / Master File Table

    Operations for set and get are provided on the 1) and 2). 3) Is allwed to be
    enumerated. The priority queue is enumerated by the usermode agent to a) fill partially
    filled files and b) keep the space used within the specified constraints

Author:

     Shishir Pardikar      [Shishirp]        01-jan-1995

Revision History:

     Joe Linn                 [JoeLinn]         23-jan-97     Ported for use on NT

--*/

#include "precomp.h"
#pragma hdrstop

#pragma code_seg("PAGE")

#ifndef CSC_RECORDMANAGER_WINNT
#define WIN32_APIS
#include "record.h"
#include "cshadow.h"
#endif //ifndef CSC_RECORDMANAGER_WINNT

#include "string.h"
#include "stdlib.h"
#include "vxdwraps.h"

// Defines and Typedefs -------------------------------------------------------------------

#undef RxDbgTrace
#define RxDbgTrace(a,b,__d__) {qweee __d__;}

#ifdef DEBUG
//cshadow dbgprint interface
#define CShadowKdPrint(__bit,__x) {\
    if (((CSHADOW_KDP_##__bit)==0) || FlagOn(CShadowKdPrintVector,(CSHADOW_KDP_##__bit))) {\
    KdPrint (__x);\
    }\
}
#define CSHADOW_KDP_ALWAYS              0x00000000
#define CSHADOW_KDP_BADERRORS           0x00000001
#define CSHADOW_KDP_CREATESHADOWHI      0x00000002
#define CSHADOW_KDP_CREATESHADOWLO      0x00000004
#define CSHADOW_KDP_DELETESHADOWBAD     0x00000008
#define CSHADOW_KDP_DELETESHADOWHI      0x00000010
#define CSHADOW_KDP_DELETESHADOWLO      0x00000020
#define CSHADOW_KDP_RENAMESHADOWHI      0x00000040
#define CSHADOW_KDP_RENAMESHADOWLO      0x00000080
#define CSHADOW_KDP_GETSHADOWHI         0x00000100
#define CSHADOW_KDP_GETSHADOWLO         0x00000200
#define CSHADOW_KDP_SETSHADOWINFOHI     0x00000400
#define CSHADOW_KDP_SETSHADOWINFOLO     0x00000800
#define CSHADOW_KDP_READSHADOWINFOHI    0x00001000
#define CSHADOW_KDP_READSHADOWINFOLO    0x00002000
#define CSHADOW_KDP_COPYLOCAL           0x00004000
#define CSHADOW_KDP_COPYFILE            0x00008000
#define CSHADOW_KDP_FINDCREATESHARE    0x80000000
#define CSHADOW_KDP_MISC                0x00010000
#define CSHADOW_KDP_STOREDATA           0x00020000

#define CSHADOW_KDP_GOOD_DEFAULT (CSHADOW_KDP_BADERRORS         \
                | CSHADOW_KDP_CREATESHADOWHI    \
                | CSHADOW_KDP_DELETESHADOWHI    \
                | CSHADOW_KDP_RENAMESHADOWHI    \
                | CSHADOW_KDP_GETSHADOWHI       \
                | CSHADOW_KDP_SETSHADOWINFOHI   \
                | CSHADOW_KDP_FINDCREATESHARE  \
                | 0)


#define IF_HSHADOW_SPECIAL(___hshadow) if((___hshadow)==hShadowSpecial_x)
#define SET_HSHADOW_SPECIAL(___hshadow) {hShadowSpecial_x = (___hshadow);}
ULONG CShadowKdPrintVector = CSHADOW_KDP_BADERRORS;
//ULONG CShadowKdPrintVector = CSHADOW_KDP_GOOD_DEFAULT;
ULONG CShadowKdPrintVectorDef = CSHADOW_KDP_GOOD_DEFAULT;
#else
#define CShadowKdPrint(__bit,__x)  {NOTHING;}
#define IF_HSHADOW_SPECIAL(___hshadow) if(FALSE)
#define SET_HSHADOW_SPECIAL(___hshadow) {NOTHING;}
#endif

// ReadShadowInfo action flags
#define  RSI_COMPARE 0x0001
#define  RSI_GET      0x0002
#define  RSI_SET      0x0004

#define mIsDir(lpF32)           (((LPFIND32)(lpF32))->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)

#define  ENTERCRIT_SHADOW  {if (semShadow)\
                    Wait_Semaphore(semShadow, BLOCK_SVC_INTS);}
#define  LEAVECRIT_SHADOW  {if (semShadow)\
                    Signal_Semaphore(semShadow);}

#define  InuseGlobalFRExt()        (vfInuseFRExt)

#define  UseGlobalFilerecExt()  {Assert(!vfInuseFRExt);vfInuseFRExt = TRUE;memset(&vsFRExt, 0, sizeof(FILERECEXT));}
#define  UnUseGlobalFilerecExt() (vfInuseFRExt = FALSE)

#pragma intrinsic (memcmp, memcpy, memset, strcat, strcmp, strcpy, strlen)


// Global data ----------------------------------------------------------------------------

USHORT vwzRegDelimiters[] = L";, ";

USHORT  *vrgwExclusionListDef[] =
{
    L"*.SLM",
    L"*.MDB",
    L"*.LDB",
    L"*.MDW",
    L"*.MDE",
    L"*.PST",
    L"*.DB?"
};

USHORT  **vlplpExclusionList = vrgwExclusionListDef;

ULONG   vcntExclusionListEntries = (sizeof(vrgwExclusionListDef)/sizeof(USHORT *));

USHORT  *vrgwBandwidthConservationListDef[] =
{
    L"*.EXE",
    L"*.DLL",
    L"*.SYS",
    L"*.COM",
    L"*.HLP",
    L"*.CPL",
    L"*.INF"
};

USHORT  **vlplpBandwidthConservationList = vrgwBandwidthConservationListDef;

ULONG   vcntBandwidthConservationListEntries = (sizeof(vrgwBandwidthConservationListDef)/sizeof(USHORT *));

USHORT vtzExcludedCharsList[] = L":*?";

ULONG hShadowSpecial_x = -1;
VMM_SEMAPHORE  semShadow=0; // To serialize Shadow database accesses
ULONG hShadowCritOwner=0;
#ifdef DEBUG
BOOL vfInShadowCrit = FALSE;
extern BOOL vfStopHandleCaching;
#endif

char vszShadowVolume[] = "SHADOW";
USHORT  vwszFileSystemName[] = L"FAT";

FILERECEXT  vsFRExt;
BOOL vfInuseFRExt = FALSE;
LPVOID lpdbShadow = NULL;

// vdwSparseStaleDetecionCount is a tick counter used to keep track of how many stale or sparse
// file inodes were encountered by the cshadow interface during all APIs that produce
// sparse or stale files, such as CreateShadowInternal, SetShadowinfoEx and ReadShadowInfo
// The agent continues to loop through the PQ till he finds that he has looped through
// the entire PQ and hasn't encountered a single sparse or stale file at which point he
// goes in a mode where he starts to check whether any inodes have been newly sparsed
// or gone stale. If none are, then he doesn't enumerate the queue, else he goes to
// the earlier state.

// ACHTUNG: It is to be noted that a sparse or a stale entry may get counted multiple times.
// As an example, when a shadow is created the count is bumped once, then if it's
// pin data is changed it is bumped up, similarly when it is moved in the priority Q
// it is again changed because SetPriorityHSHADOW goes through SetShadowInfoEx

DWORD   vdwSparseStaleDetecionCount=0;
DWORD   vdwManualFileDetectionCount=0;

// vdwCSCNameSpaceVersion is bumped up everytime a create,rename or delete is performed on
// the local database. This is useful for quickly checking cache-coherency. When a full
// UNC name is cached, the version# of the database is obtained before caching. When using the
// cached UNC name, the version # is queried. If it has changed, the cache is thrown away.
// The version is at a very coarse granularity. It would be nice to have a finer control

DWORD   vdwCSCNameSpaceVersion=0;
DWORD   vdwPQVersion=0;

AssertData
AssertError

// a callback function that someone can set and be called when a directory delete succeeds
// this is useful only for ioctls doing finds on a directory, at the moment
// If there is a more general need for callbacks, we will extend this to be a list etc.

LPDELETECALLBACK    lpDeleteCBForIoctl = NULL;

// status of the database. Used mostly for encryption state
ULONG   vulDatabaseStatus=0;

// Local function prototypes -----------------------------------------------------------

int PRIVATE ReadShadowInfo(HSHADOW, HSHADOW, LPFIND32, ULONG far *, LPOTHERINFO, LPVOID, LPDWORD, ULONG);
int CopyFilerecToOtherInfo(LPFILERECEXT lpFR, LPOTHERINFO lpOI);
int CopyOtherInfoToFilerec(LPOTHERINFO lpOI, LPFILERECEXT lpFR);
int CreateShadowInternal(HSHADOW, LPFIND32, ULONG, LPOTHERINFO, LPHSHADOW);
int CopySharerecToFindInfo(LPSHAREREC, LPFIND32);
int CopyOtherInfoToSharerec(LPOTHERINFO, LPSHAREREC);
int CopyPQToOtherInfo(LPPRIQREC, LPOTHERINFO);
int CopyOtherInfoToPQ(LPOTHERINFO, LPPRIQREC);
int CopySharerecToShadowInfo(LPSHAREREC       lpSR, LPSHADOWINFO lpSI);
int RenameDirFileHSHADOW(HSHADOW, HSHADOW, HSHARE, HSHADOW, HSHADOW, ULONG, LPOTHERINFO, ULONG, LPFILERECEXT, LPFIND32, LPVOID, LPDWORD);
int RenameFileHSHADOW(HSHADOW, HSHADOW, HSHADOW, HSHADOW, ULONG, LPOTHERINFO, ULONG, LPFILERECEXT, LPFIND32, LPVOID, LPDWORD);
int DestroyShareInternal(LPSHAREREC);

//prototypes added to make it compile on NT
int PUBLIC SetPriorityHSHADOW(
    HSHADOW  hDir,
    HSHADOW  hShadow,
    ULONG ulRefPri,
    ULONG ulIHPri
    );

int CopySharerecToOtherInfo(LPSHAREREC lpSR, LPOTHERINFO lpOI);

int MetaMatchShare(
    HSHADOW  hDir,
    LPFIND32 lpFind32,
    ULONG *lpuCookie,
    LPHSHADOW    lphShadow,
    ULONG *lpuStatus,
    LPOTHERINFO lpOI,
    METAMATCHPROC    lpfnMMP,
    LPVOID            lpData
    );

int MetaMatchDir( HSHADOW  hDir,
    LPFIND32 lpFind32,
    ULONG *lpuCookie,
    LPHSHADOW    lphShadow,
    ULONG *lpuStatus,
    LPOTHERINFO lpOI,
    METAMATCHPROC    lpfnMMP,
    LPVOID            lpData
    );

int
DeleteShadowInternal(                           //
    HSHADOW     hDir,
    HSHADOW     hShadow,
    BOOL            fForce
    );

int
CShadowFindFilerecFromInode(
    LPVOID  lpdbID,
    HSHADOW hDir,
    HSHADOW hShadow,
    LPPRIQREC lpPQ,
    LPFILERECEXT    lpFRUse
    );

BOOL
CopySecurityContextToBuffer(
    LPRECORDMANAGER_SECURITY_CONTEXT    lpSecurityContext,
    LPVOID                              lpSecurityBlob,
    LPDWORD                             lpdwBlobSize
    );

BOOL
CopyBufferToSecurityContext(
    LPVOID                              lpSecurityBlob,
    LPDWORD                             lpdwBlobSize,
    LPRECORDMANAGER_SECURITY_CONTEXT    lpSecurityContext
    );

int CopyFindInfoToSharerec(
    LPFIND32 lpFind32,
    LPSHAREREC lpSR
    );

#ifdef DEBUG
int
ValidatePri(
    LPFILERECEXT lpFR
    );
#endif


VOID
AdjustSparseStaleDetectionCount(
    ULONG hShare,
    LPFILERECEXT    lpFRUse
    );

VOID FreeLists(
    VOID
);

VOID
CscNotifyAgentOfFullCacheIfRequired(
    VOID);


//
// From cscapi.h
//
#define FLAG_CSC_SHARE_STATUS_MANUAL_REINT              0x0000
#define FLAG_CSC_SHARE_STATUS_AUTO_REINT                0x0040
#define FLAG_CSC_SHARE_STATUS_VDO                       0x0080
#define FLAG_CSC_SHARE_STATUS_NO_CACHING                0x00c0
#define FLAG_CSC_SHARE_STATUS_CACHING_MASK              0x00c0

// Functions -------------------------------------------------------------------------------


BOOL FExistsShadowDB(
    LPSTR  lpszLocation
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    return (FExistsRecDB(lpszLocation));
}

int OpenShadowDB(
    LPSTR   lpszLocation,
    LPSTR   lpszUserName,
    DWORD   dwDefDataSizeHigh,
    DWORD   dwDefDataSizeLow,
    DWORD   dwClusterSize,
    BOOL    fReinit,
    BOOL    *lpfReinited
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    DWORD Status;
    BOOL fEncrypt;
    
    if (!semShadow)
    {
        CShadowKdPrint(ALWAYS,("OpenShadowDB:Shadow Semaphore doesn't exist, bailing out \r\n"));
        SetLastErrorLocal(ERROR_SERVICE_NOT_ACTIVE);
        return -1;
    }

    Status = CscInitializeSecurityDescriptor();

    if (Status != ERROR_SUCCESS) {
        CShadowKdPrint(BADERRORS,("Failed to initialize Security descriptor Status=%x\n",Status));
        return -1;
    }

    if (!(lpdbShadow = OpenRecDB(lpszLocation, lpszUserName, dwDefDataSizeHigh, dwDefDataSizeLow, dwClusterSize, fReinit, lpfReinited, &vulDatabaseStatus)))
    {
        return -1;
    }

    Status = CscInitializeSecurity(lpdbShadow);

    if (Status != ERROR_SUCCESS)
    {
        CloseShadowDB();
        CscUninitializeSecurityDescriptor();

        CShadowKdPrint(BADERRORS,("OpenShadowDB  %s at %s for %s with size %ld %lx \n",
               "couldn't Initialize Security %lx",
               lpszLocation, lpszUserName, dwDefDataSizeLow,Status));

        return -1;
    }

    fEncrypt = -1;
    
    if(mDatabasePartiallyEncrypted(vulDatabaseStatus))
    {
        fEncrypt = TRUE;
    }
    else if (mDatabasePartiallyUnencrypted(vulDatabaseStatus))
    {
        fEncrypt = FALSE;
    }
    // do the best we can 
    if (fEncrypt != -1)
    {
        if(EncryptDecryptDB(lpdbShadow, fEncrypt))
        {
            if (fEncrypt)
            {
                vulDatabaseStatus = ((vulDatabaseStatus & ~FLAG_DATABASESTATUS_ENCRYPTION_MASK) | FLAG_DATABASESTATUS_ENCRYPTED);
            }
            else
            {
                vulDatabaseStatus = ((vulDatabaseStatus & ~FLAG_DATABASESTATUS_ENCRYPTION_MASK) | FLAG_DATABASESTATUS_UNENCRYPTED);
            }
            
            SetDatabaseStatus(vulDatabaseStatus, FLAG_DATABASESTATUS_ENCRYPTION_MASK);
        }
    }
    

//    CSCInitLists();

    return 1;
}

int CloseShadowDB(
    VOID
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    if (!lpdbShadow)
    {
        return -1;
    }

    if(!CloseRecDB(lpdbShadow))
    {
        return -1;
    }

    CscUninitializeSecurityDescriptor();

    FreeLists();

    lpdbShadow = NULL;

    Assert(semShadow != 0);

    return (1);
}

//on NT, we allocate this statically
#ifdef CSC_RECORDMANAGER_WINNT
FAST_MUTEX Nt5CscShadowMutex;
#endif

BOOL
InitializeShadowCritStructures (
    void
    )
{
#ifndef CSC_RECORDMANAGER_WINNT
    semShadow = Create_Semaphore(1);
#else
    semShadow = &Nt5CscShadowMutex;
    ExInitializeFastMutex(semShadow);
#endif
    return (semShadow != 0);
}

VOID
CleanupShadowCritStructures(
    VOID
    )
{

//    Assert(semShadow);
#ifndef CSC_RECORDMANAGER_WINNT
    Destroy_Semaphore(semShadow);
#else
    semShadow = NULL;
#endif

}

#ifdef DEBUG
WINNT_DOIT(
    PSZ ShadowCritAcquireFile;
    ULONG ShadowCritAcquireLine;
    BOOLEAN ShadowCritDbgPrintEnable = FALSE; //TRUE;
    )
#endif

#ifndef CSC_RECORDMANAGER_WINNT
int EnterShadowCrit( void)
#else
int __EnterShadowCrit(ENTERLEAVESHADOWCRIT_SIGNATURE)
#endif
{
#ifdef CSC_RECORDMANAGER_WINNT

    if(!MRxSmbIsCscEnabled) {
        SetLastErrorLocal(ERROR_SERVICE_NOT_ACTIVE);
        DbgPrint("CSC not enabled, not asserting for semShadow\n");
        return(1);
    }
#endif
    Assert(semShadow != NULL);


    ENTERCRIT_SHADOW;


    hShadowCritOwner = GetCurThreadHandle();

#ifdef DEBUG
    ++vfInShadowCrit;
    WINNT_DOIT(
    ShadowCritAcquireFile = FileName;
    ShadowCritAcquireLine = LineNumber;
    if (ShadowCritDbgPrintEnable) {
        DbgPrint("ACQUIRESHADOWCRIT at %s %u\n",FileName,LineNumber);
    }
    )
#endif
    return 1;
}

#ifndef CSC_RECORDMANAGER_WINNT
int LeaveShadowCrit( void)
#else
int __LeaveShadowCrit(ENTERLEAVESHADOWCRIT_SIGNATURE)
#endif
{
#ifdef CSC_RECORDMANAGER_WINNT
    
    if(!MRxSmbIsCscEnabled) {
        DbgPrint("CSC not enabled, not asserting for vfInShadowCrit\n");
        SetLastErrorLocal(ERROR_SERVICE_NOT_ACTIVE);
        return(1);
    }
#endif
    Assert(vfInShadowCrit != 0);
#ifdef DEBUG
    --vfInShadowCrit;
    WINNT_DOIT(
    ShadowCritAcquireLine *= -1;
    if (ShadowCritDbgPrintEnable) {
        DbgPrint("RELEASESHADOWCRIT at %s %u\n",FileName,LineNumber);
    }
    )
#endif
    hShadowCritOwner = 0;
    LEAVECRIT_SHADOW;
    return 1;
}

int LeaveShadowCritIfThisThreadOwnsIt(
    void
    )
{
    if (hShadowCritOwner == GetCurThreadHandle())
    {
        LeaveShadowCrit();
    }

    return 1;
}

int SetList(
    USHORT  *lpList,
    DWORD   cbBufferSize,
    int     typeList
    )
/*++

Routine Description:

    This routine sets various lists that the CSHADOW interface provides. The known lists include
    the exclusion list and the bandwidth conservation list.

    The exclusion list contains wildcarded file extensions that should not be cached automatically.
    The bandwidth conservation list is the list of file types for which opens should be
    done locally if possible.

Parameters:

    lpList     A list of wide character strings terminated by a NULL string

    typeList            CSHADOW_LIST_TYPE_EXCLUDE or CSHADOW_LIST_TYPE_CONSERVE_BW

Return Value:

Notes:


--*/
{
    DWORD   dwCount=0;
    USHORT  **lplpListArray = NULL, *lpuT;
    int iRet = -1;
    BOOL    fUpdateList = FALSE;

    if (cbBufferSize)
    {
        CShadowKdPrint(MISC, (" %ws\r\n", lpList));

#if 0
        if (typeList == CSHADOW_LIST_TYPE_EXCLUDE)
        {
            DbgPrint("ExclusionList: %ws\n", lpList);
        }
        if (typeList == CSHADOW_LIST_TYPE_CONSERVE_BW)
        {
            DbgPrint("BW: %ws\n", lpList);
        }
#endif
        
        if (CreateStringArrayFromDelimitedList(lpList, vwzRegDelimiters, NULL, &dwCount))
        {
            if (dwCount)
            {
                lplpListArray = (LPWSTR *)AllocMem(dwCount * sizeof(USHORT *) + cbBufferSize);

                if (lplpListArray)
                {
                    lpuT = (USHORT *)((LPBYTE)lplpListArray + dwCount * sizeof(USHORT *));

                    // copy it while uppercasing
                    memcpy(lpuT, lpList, cbBufferSize);

                    UniToUpper(lpuT, lpuT, cbBufferSize);

                    if (CreateStringArrayFromDelimitedList( lpuT,
                                                            vwzRegDelimiters,
                                                            lplpListArray,
                                                            &dwCount))
                    {
                        fUpdateList = TRUE;

                    }

                }
            }
            else
            {
                Assert(lplpListArray == NULL);
                fUpdateList = TRUE;
            }

            if (fUpdateList)
            {
                switch (typeList)
                {
                    case CSHADOW_LIST_TYPE_EXCLUDE:

                        if(vlplpExclusionList != vrgwExclusionListDef)
                        {
                            if (vlplpExclusionList)
                            {
                                FreeMem(vlplpExclusionList);
                            }

                        }

                        vlplpExclusionList = lplpListArray;
                        vcntExclusionListEntries = dwCount;
                        iRet = 0;
                        break;
                    case CSHADOW_LIST_TYPE_CONSERVE_BW:
                        if(vlplpBandwidthConservationList != vrgwBandwidthConservationListDef)
                        {
                            if (vlplpBandwidthConservationList)
                            {
                                FreeMem(vlplpBandwidthConservationList);
                            }

                        }

                        vlplpBandwidthConservationList = lplpListArray;
                        vcntBandwidthConservationListEntries = dwCount;

                        iRet = 0;

                        break;
                    default:
                        break;
                }
            }
        }
    }

    if (iRet == -1)
    {
        if (lplpListArray)
        {
            FreeMem(lplpListArray);
        }
    }

    return (iRet);
}


VOID FreeLists(
    VOID
)
/*++

Routine Description:

    Free the user associated lists and set them back to the default

Parameters:

    None

Return Value:

    None

Notes:

    Called while shutting down the database

--*/
{
    if(vlplpExclusionList != vrgwExclusionListDef)
    {
        if (vlplpExclusionList)
        {
            FreeMem(vlplpExclusionList);
            vlplpExclusionList = NULL;
        }

        vlplpExclusionList = vrgwExclusionListDef;
        vcntExclusionListEntries = (sizeof(vrgwExclusionListDef)/sizeof(USHORT *));

    }

    if(vlplpBandwidthConservationList != vrgwBandwidthConservationListDef)
    {
        if (vlplpBandwidthConservationList)
        {
            FreeMem(vlplpBandwidthConservationList);
            vlplpBandwidthConservationList = NULL;
        }

        vcntBandwidthConservationListEntries = 0;
    }

}


int BeginInodeTransactionHSHADOW(
    VOID
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:

    This routine ensures that an inode is not reused while this is happening. It is used by various APIs so that while they
    are travesring a hierarchy, they don't end up pointing somewhere else if they refer to an inode.

--*/
{
    if (!lpdbShadow)
    {
        SetLastErrorLocal(ERROR_SERVICE_NOT_ACTIVE);
        return -1;
    }
    BeginInodeTransaction();

    return 1;
}

int EndInodeTransactionHSHADOW(
    VOID
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:

    The converse of BeginInodeTransaction. The timespan betwen the two is supposed to be very short (20 sec).

--*/
{
    if (!lpdbShadow)
    {
        SetLastErrorLocal(ERROR_SERVICE_NOT_ACTIVE);
        return -1;
    }

    EndInodeTransaction();

    return 1;

}

HSHADOW  HAllocShadowID( HSHADOW  hDir,
    BOOL      fFile
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    HSHADOW  hShadow;

    Assert(vfInShadowCrit != 0);

    hShadow = UlAllocInode(lpdbShadow, hDir, fFile);

    return (hShadow);
}

int FreeShadowID( HSHADOW  hShadow
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    return(FreeInode(lpdbShadow, hShadow));
}

int GetShadowSpaceInfo(
    LPSHADOWSTORE  lpShSt
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    SHAREHEADER sSH;

    if (ReadShareHeader(lpdbShadow, &sSH) < SRET_OK)
        return SRET_ERROR;
    lpShSt->sMax = sSH.sMax;
    lpShSt->sCur = sSH.sCur;
    lpShSt->uFlags= sSH.uFlags;
    
    return SRET_OK;
}

int SetMaxShadowSpace(
    long nFileSizeHigh,
    long nFileSizeLow
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    SHAREHEADER sSH;

    if (ReadShareHeader(lpdbShadow, &sSH) < SRET_OK)
        return SRET_ERROR;
    Win32ToDosFileSize(nFileSizeHigh, nFileSizeLow, &(sSH.sMax.ulSize));
    if (WriteShareHeader(lpdbShadow, &sSH) < SRET_OK)
        return SRET_ERROR;
    return SRET_OK;
}

int AdjustShadowSpace(
    long nFileSizeHighOld,
    long nFileSizeLowOld,
    long nFileSizeHighNew,
    long nFileSizeLowNew,
    BOOL fFile
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    DWORD dwFileSizeNew, dwFileSizeOld;
    STOREDATA sSD;
    int iRet = 0;

    memset(&sSD, 0, sizeof(STOREDATA));

    dwFileSizeNew = RealFileSize(nFileSizeLowNew);
    dwFileSizeOld = RealFileSize(nFileSizeLowOld);

    if (dwFileSizeNew > dwFileSizeOld)
    {
        sSD.ulSize = dwFileSizeNew - dwFileSizeOld;
        iRet = AddStoreData(lpdbShadow, &sSD);
    }
    else if (dwFileSizeNew < dwFileSizeOld)
    {
        sSD.ulSize = dwFileSizeOld - dwFileSizeNew;
        iRet = SubtractStoreData(lpdbShadow, &sSD);
    }

    return (iRet);
}

int AllocShadowSpace(
    long nFileSizeHigh,
    long nFileSizeLow,
    BOOL  fFile
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    STOREDATA sSD;

    memset(&sSD, 0, sizeof(STOREDATA));
    sSD.ulSize = RealFileSize(nFileSizeLow);
    AddStoreData(lpdbShadow, &sSD);

    return (0);
}

int FreeShadowSpace(
    long nFileSizeHigh,
    long nFileSizeLow,
    BOOL  fFile
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    STOREDATA sSD;

    memset(&sSD, 0, sizeof(STOREDATA));
    sSD.ulSize = RealFileSize(nFileSizeLow);
    SubtractStoreData(lpdbShadow, &sSD);

    return (0);
}

int
SetDatabaseStatus(
    ULONG   ulStatus,
    ULONG   uMask
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    SHAREHEADER sSH;


    if (ReadShareHeader(lpdbShadow, &sSH) < SRET_OK)
        return SRET_ERROR;

    sSH.uFlags &= ~uMask;
    sSH.uFlags |= ulStatus;    
    
    
    if (WriteShareHeader(lpdbShadow, &sSH) < SRET_OK)
        return SRET_ERROR;
    
    vulDatabaseStatus = sSH.uFlags;
            
    return SRET_OK;
}
    
int
GetDatabaseInfo(
    SHAREHEADER *psSH
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    if (ReadShareHeader(lpdbShadow, psSH) < SRET_OK)
        return SRET_ERROR;
    return SRET_OK;
}


int GetLocalNameHSHADOW( HSHADOW  hShadow,
    LPBYTE    lpName,
    int       cbSize,
    BOOL      fExternal
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    LPSTR   lpszName, lpT;
    int iRet = SRET_ERROR;

    lpT = lpszName = FormNameString(lpdbShadow, hShadow);

    if (!lpszName)
    {
        return (SRET_ERROR);
    }

    if (fExternal)
    {
#ifdef CSC_RECORDMANAGER_WINNT
        lpT = lpszName + (sizeof(NT_DB_PREFIX)-1);
#endif
    }

    // bad interface, caller can't know what the problem was; needed to send in a pointer to cbSize

    if (strlen(lpT) < ((ULONG)cbSize))
    {
        strcpy(lpName, lpT);
        iRet = SRET_OK;
    }

    FreeNameString(lpszName);

    return iRet;
}

int GetWideCharLocalNameHSHADOW(
    HSHADOW  hShadow,
    USHORT      *lpBuffer,
    LPDWORD     lpdwSize,
    BOOL        fExternal
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    LPSTR   lpszName, lpT;
    int iRet = SRET_ERROR;
    DWORD   dwRequiredSize;

    lpT = lpszName = FormNameString(lpdbShadow, hShadow);

    if (!lpszName)
    {
        return (SRET_ERROR);
    }

    if (fExternal)
    {
#ifdef CSC_RECORDMANAGER_WINNT
        lpT = lpszName + (sizeof(NT_DB_PREFIX)-1);
#endif
    }

    dwRequiredSize = (strlen(lpT)+1)*sizeof(USHORT);

    // bad interface, caller can't know what the problem was; needed to send in a pointer to cbSize

    if ( dwRequiredSize <= *lpdwSize)
    {
        BCSToUni(lpBuffer, lpT, dwRequiredSize/sizeof(USHORT), BCS_WANSI);
        iRet = SRET_OK;
    }
    else
    {
        SetLastErrorLocal(ERROR_MORE_DATA);
        *lpdwSize = dwRequiredSize;
    }

    FreeNameString(lpszName);

    return iRet;
}

int CreateFileHSHADOW(
    HSHADOW hShadow
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    CSCHFILE hf;
    LPSTR   lpszName;
    int iRet = SRET_ERROR;
    ULONG   ulAttrib = 0;
    
    lpszName = FormNameString(lpdbShadow, hShadow);

    if (!lpszName)
    {
        return (SRET_ERROR);
    }
    
    // Nuke it if it exists, this is a very strict semantics
    if(DeleteFileLocal(lpszName, ATTRIB_DEL_ANY) < SRET_OK)
    {
        if((GetLastErrorLocal() !=ERROR_FILE_NOT_FOUND) && 
            (GetLastErrorLocal() !=ERROR_PATH_NOT_FOUND))
        {
            FreeNameString(lpszName);
            return (SRET_ERROR);
        }
    }

    ulAttrib = ((IsLeaf(hShadow) && mDatabaseEncryptionEnabled(vulDatabaseStatus))? FILE_ATTRIBUTE_ENCRYPTED:0);
        
    if ((hf = R0OpenFileEx(ACCESS_READWRITE, ACTION_CREATEALWAYS, ulAttrib, lpszName, FALSE)))
    {
        CloseFileLocal(hf);
        iRet = SRET_OK;
    }
    
    FreeNameString(lpszName);
    return iRet;
}

#if defined(BITCOPY)
int OpenFileHSHADOWAndCscBmp(
    HSHADOW hShadow,
    USHORT usOpenFlags,
    UCHAR  bAction,
    CSCHFILE far *lphf,
    BOOL fOpenCscBmp,
    DWORD filesize, // if !fOpenCscBmp this field is ignored
    LPCSC_BITMAP * lplpbitmap
    )
#else
int OpenFileHSHADOW(
    HSHADOW hShadow,
    USHORT usOpenFlags,
    UCHAR  bAction,
    CSCHFILE far *lphf
    )
#endif // defined(BITCOPY)
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    LPSTR   lpszName = NULL;
    int iRet = SRET_ERROR;
    ULONG   ulAttrib = 0;
    
    *lphf = NULL;
    lpszName = FormNameString(lpdbShadow, hShadow);

    if (!lpszName)
        return (SRET_ERROR);


    if (!(bAction & (ACTION_NEXISTS_CREATE|ACTION_CREATEALWAYS))) {
        *lphf = OpenFileLocal(lpszName);
        if (*lphf != NULL) {
#if defined(BITCOPY)
            if (fOpenCscBmp)
                CscBmpRead(lplpbitmap, lpszName, filesize);
#endif // defined(BITCOPY)
            iRet = SRET_OK;
        }
    } else {
        // Nuke it if it exists, this is a very strict semantics
        if (DeleteFileLocal(lpszName, ATTRIB_DEL_ANY) < SRET_OK) {
            if ((GetLastErrorLocal() != ERROR_FILE_NOT_FOUND) && 
                    (GetLastErrorLocal() != ERROR_PATH_NOT_FOUND)) {
                iRet = SRET_ERROR;
                goto Cleanup;
            }
        }

        ulAttrib = 0;
        if (IsLeaf(hShadow) && mDatabaseEncryptionEnabled(vulDatabaseStatus))
            ulAttrib = FILE_ATTRIBUTE_ENCRYPTED;
        
        *lphf = R0OpenFileEx(
                        ACCESS_READWRITE,
                        ACTION_CREATEALWAYS,
                        ulAttrib,
                        lpszName,
                        FALSE);

        if (*lphf != NULL) {
#if defined(BITCOPY)
            if (fOpenCscBmp)
                CscBmpRead(lplpbitmap, lpszName, 0);
#endif // defined(BITCOPY)
            iRet = SRET_OK;
        }
    }

      
Cleanup:
    if (lpszName != NULL)
        FreeNameString(lpszName);


    return iRet;
}

#if defined(BITCOPY)
int
OpenCscBmp(
    HSHADOW hShadow,
    LPCSC_BITMAP *lplpbitmap)
{
    LPSTR strmName = NULL;
    int iRet = SRET_ERROR;
    ULONG fileSizeLow;
    ULONG fileSizeHigh;

    strmName = FormAppendNameString(lpdbShadow, hShadow, CscBmpAltStrmName);
    if (strmName == NULL)
        return (SRET_ERROR);
    
    if (GetSizeHSHADOW(hShadow, &fileSizeHigh, &fileSizeLow) < SRET_OK)
          fileSizeLow = 0; // Set the bitmap size to 0 so it can expand later on

    if (CscBmpRead(lplpbitmap, strmName, fileSizeLow) == 1)
      iRet = SRET_OK;

    FreeNameString(strmName);

    return iRet;
}
#endif // defined(BITCOPY)


int GetSizeHSHADOW( HSHADOW  hShadow,
    ULONG *lpnFileSizeHigh,
    ULONG *lpnFileSizeLow
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    ULONG uSize;
    if (GetInodeFileSize(lpdbShadow, hShadow, &uSize) < SRET_OK)
        return SRET_ERROR;
    DosToWin32FileSize(uSize, lpnFileSizeHigh, lpnFileSizeLow);
    return (0);
}

int GetDosTypeSizeHSHADOW( HSHADOW  hShadow,
    ULONG *lpFileSize
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    if (GetInodeFileSize(lpdbShadow, hShadow, lpFileSize) < SRET_OK)
        return SRET_ERROR;
    return (0);
}


BOOL PUBLIC
ExcludeFromCreateShadow(
    USHORT  *lpuName,
    ULONG   len,
    BOOL    fCheckFileTypeExclusionList
    )
/*++

Routine Description:

Parameters:

    lpuName                 File name

    len                     size

    fCheckFileTypeExclusionList if !FALSE, check exclusion list as well as the metacharacter rules
                                if FALSE check only the character exclusion rules

Return Value:

Notes:


--*/
{
    ULONG i;
    USHORT  *lpuT1;
    BOOL    fRet = FALSE;


    if (!len || (len> MAX_PATH))
    {
        return TRUE;
    }

    UseGlobalFilerecExt();

    lpuT1 = (USHORT *)&vsFRExt;

    memcpy(lpuT1, lpuName, len * sizeof(USHORT));

    lpuT1[len] = 0;

    if (!wstrpbrk(lpuT1, vtzExcludedCharsList))
    {

        //
        if (fCheckFileTypeExclusionList)
        {
            for (i=0; i< vcntExclusionListEntries; ++i)
            {
                if(IFSMgr_MetaMatch(vlplpExclusionList[i], lpuT1, UFLG_NT|UFLG_META))
                {
                    fRet = TRUE;
                    break;
                }
            }
        }
    }
    else
    {
        fRet = TRUE;    // exclude
    }

    UnUseGlobalFilerecExt();

    return fRet;
}

BOOL PUBLIC
CheckForBandwidthConservation(
    USHORT  *lpuName,
    ULONG   len
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    ULONG i;
    USHORT  *lpuT1;
    BOOL    fRet = FALSE;

    if (!len || (len> MAX_PATH))
    {
        return FALSE;
    }

    UseGlobalFilerecExt();

    lpuT1 = (USHORT *)&vsFRExt;

    memcpy(lpuT1, lpuName, len * sizeof(USHORT));

    lpuT1[len] = 0;

    for (i=0; i< vcntBandwidthConservationListEntries; ++i)
    {
        if(IFSMgr_MetaMatch(vlplpBandwidthConservationList[i], lpuT1, UFLG_NT|UFLG_META))
        {
            fRet = TRUE;
            break;
        }
    }

    UnUseGlobalFilerecExt();

    return fRet;
}

int PUBLIC                      // ret
CreateShadow(                               //
    HSHADOW  hDir,
    LPFIND32 lpFind32,
    ULONG uFlags,
    LPHSHADOW   lphNew,
    BOOL            *lpfCreated
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    ULONG uStatus;
    int iRet = SRET_ERROR;

    Assert(vfInShadowCrit != 0);

    if (lpfCreated)
    {
        *lpfCreated = FALSE;
    }

    mClearBits(uFlags, SHADOW_NOT_FSOBJ);
    if (GetShadow(hDir, lpFind32->cFileName, lphNew, NULL, &uStatus, NULL)>=SRET_OK)
    {

        if (*lphNew)
        {
            CShadowKdPrint(ALWAYS,("CreateShadow: already exists for %ws\r\n", lpFind32->cFileName));

            if (mNotFsobj(uStatus))
            {
                iRet = SRET_ERROR;
            }
            else
            {
                iRet = SetShadowInfo(hDir, *lphNew, lpFind32, uFlags, SHADOW_FLAGS_ASSIGN);
            }
        }
        else
        {
            iRet = CreateShadowInternal(hDir, lpFind32, uFlags, NULL, lphNew);

            if ((iRet >= SRET_OK) && lpfCreated)
            {
                *lpfCreated = TRUE;
            }
        }
    }
    return (iRet);
}

int PUBLIC                      // ret
CreateShadowInternal(
    HSHADOW  hDir,
    LPFIND32 lpFind32,
    ULONG uFlags,
    LPOTHERINFO lpOI,
    LPHSHADOW  lphNew
    )
/*++

Routine Description:

    Routine that creates database entries for all names other than the root of a share
    HCreateShareObj deals with createing the share entry where the root of the share gets created

Parameters:

    hDir        Directory inode in which to create the entry

    lpFind32    WIN32_FIND_DATA info to be kept in the database

    uFlags      status flags (SHADOW_XXXX in csc\inc\shdcom.h) to be assigned to this entry

    lpOI        all the rest of the metadata needed for managing the entry. May be NULL

    lphNew      out parameter, returns the inode that was created if successful

Return Value:

Notes:


--*/
{
    PRIQREC  sPQ;
    int iRet = SRET_ERROR;
    LPFILERECEXT lpFR = NULL, lpFRUse;
    HSHADOW  hNew=0, hAncestor=0;
    HSHARE hShare=0;
    ULONG ulRefPri=MAX_PRI, ulrecDirEntry=INVALID_REC, ulHintPri=0, ulHintFlags=0;
    STOREDATA sSD;

    Assert(vfInShadowCrit != 0);

    if (!(!hDir || IsDirInode(hDir)))
        return SRET_ERROR;

    BEGIN_TIMING(CreateShadowInternal);

    if (InuseGlobalFRExt())
    {
        if (!(lpFR = (LPFILERECEXT)AllocMem(sizeof(FILERECEXT))))
            goto bailout;
        lpFRUse = lpFR;
    }
    else
    {
        UseGlobalFilerecExt();
        lpFRUse = &vsFRExt;
    }

    memset(lpFRUse, 0, sizeof(FILERECEXT));

    // Don't do anything for server yet
    if (hDir)
    {

        *lphNew = hNew = UlAllocInode(lpdbShadow, hDir, IsFile(lpFind32->dwFileAttributes));

        if (!hNew)
        {
            CShadowKdPrint(BADERRORS,("Error creating shadow Inode\r\n"));
            goto bailout;
        }


        if (IsFile(lpFind32->dwFileAttributes))
        {
            if (lpFind32->nFileSizeHigh)
            {
                SetLastErrorLocal(ERROR_ONLY_IF_CONNECTED);
                goto bailout;
            }

            if(CreateFileHSHADOW(hNew) == SRET_ERROR)
            {
                CShadowKdPrint(BADERRORS,("Error creating shadow data for %x \r\n", hNew));
                goto bailout;
            }
            // start file priorities with max
            ulRefPri=MAX_PRI;
        }
        else
        {
            if(CreateDirInode(lpdbShadow, 0, hDir, hNew) < 0)
            {
                CShadowKdPrint(BADERRORS,("Error creating shadow data for %x \r\n", hNew));
                goto bailout;
            }
            // start directory priorities with MIN_PRI, this is to optimize
            // later moving
            // A better solution might be to change createshadow to take refpri and pincount
            // as parameters
            ulRefPri=MIN_PRI;
        }


        CopyFindInfoToFilerec(lpFind32, lpFRUse, CPFR_INITREC|CPFR_COPYNAME);
        //RxDbgTrace(0,Dbg,("CreateShadowInternal3 %s %s\n",
        //                          lpFRUse->sFR.rgcName, lpFRUse->sFR.rg83Name));

        lpFRUse->sFR.uchRefPri = (UCHAR)ulRefPri;
        lpFRUse->sFR.uchHintPri = (UCHAR)ulHintPri;
        lpFRUse->sFR.uchHintFlags = (UCHAR)ulHintFlags;

        // overwite filerec with any info that the user gave
        if (lpOI)
        {
            CShadowKdPrint(CREATESHADOWHI,("ulHintPri=%x ulHintFlags=%x\r\n",lpOI->ulHintPri, lpOI->ulHintFlags));
            CopyOtherInfoToFilerec(lpOI, lpFRUse);
        }

        lpFRUse->sFR.ftOrgTime = lpFRUse->sFR.ftLastWriteTime;

        CShadowKdPrint(CREATESHADOWHI,("CreateShadow: %x for %ws: loctLo=%x loctHi=%x \r\n",
                 hNew,
                 lpFRUse->sFR.rgwName,
                lpFRUse->sFR.ftOrgTime.dwLowDateTime,
                lpFRUse->sFR.ftOrgTime.dwHighDateTime));

        lpFRUse->sFR.ulidShadow = hNew;
        lpFRUse->sFR.uStatus = (USHORT)uFlags;
        lpFRUse->sFR.ulLastRefreshTime = (ULONG)IFSMgr_Get_NetTime();

        // if this entry is being created offline, then it doesn't have any original inode
        if (uFlags & SHADOW_LOCALLY_CREATED)
        {
            lpFRUse->sFR.ulidShadowOrg = 0;
        }
        else
        {
            lpFRUse->sFR.ulidShadowOrg = hNew;
        }

#ifdef DEBUG
        ValidatePri(lpFRUse);
#endif
        if(!(ulrecDirEntry = AddFileRecordFR(lpdbShadow, hDir, lpFRUse)))
        {
            // could be legit failure if we are running out of disk space
            CShadowKdPrint(CREATESHADOWHI,("Failed AddFileRecordFR for %x, %ws\r\n",
                 hNew,
                 lpFRUse->sFR.rgwName));

            goto bailout;
        }

        Assert(ulrecDirEntry != INVALID_REC);


        if(FindAncestorsFromInode(lpdbShadow, hDir, &hAncestor, &hShare) < 0)
        {
            CShadowKdPrint(CREATESHADOWHI,("Failed to find ancestor for %x, %ws\r\n",
                 hNew,
                 lpFRUse->sFR.rgwName));

            goto bailout;
        }

        // mark the inode as locally created or not
        // NB, this flag has meaning only for the inode
        // We use this information during reintegration of
        // renames and deletes

        if (uFlags & SHADOW_LOCALLY_CREATED)
        {
            uFlags |= SHADOW_LOCAL_INODE;
        }
        else
        {
            uFlags &= ~SHADOW_LOCAL_INODE;
        }

        if (AddPriQRecord(  lpdbShadow,
                            hShare,
                            hDir,
                            hNew,
                            uFlags,
                            (ULONG)(lpFRUse->sFR.uchRefPri),
                            (ULONG)(lpFRUse->sFR.uchIHPri),
                            (ULONG)(lpFRUse->sFR.uchHintPri),
                            (ULONG)(lpFRUse->sFR.uchHintFlags),
                            ulrecDirEntry) < 0)
        {
            CShadowKdPrint(CREATESHADOWHI,("Failed to AddPriQRecord for %x, %ws\r\n",
             hNew,
             lpFRUse->sFR.rgwName));
            Assert(FALSE);

            goto bailout;
        }


        // The check below was is a holdover from our now-defunct hints scheme
        if (!mNotFsobj(lpFRUse->sFR.uStatus))
        {
            memset(&sSD, 0, sizeof(STOREDATA));

            CShadowKdPrint(CREATESHADOWHI,("uchHintPri=%x uchHintFlags=%x\r\n",lpFRUse->sFR.uchHintPri, lpFRUse->sFR.uchHintFlags));

            if ((!(lpFind32->dwFileAttributes &
                                     (FILE_ATTRIBUTE_DIRECTORY|FILE_ATTRIBUTE_DEVICE))))
            {
                sSD.ucntFiles++;
                // if there is a initial pin count or special pinflags are set
                // then this files data  should not be considered for space accounting

                sSD.ulSize = (lpFRUse->sFR.uchHintPri || mPinFlags(lpFRUse->sFR.uchHintFlags))?0:RealFileSize(lpFRUse->sFR.ulFileSize);

            }
            else
            {
                sSD.ucntDirs++;

            }

            if (sSD.ulSize)
            {
                CShadowKdPrint(STOREDATA,("CreateShadowInternal: Adding %d for hDir=%x Name=%ws\r\n", sSD.ulSize, hDir, lpFind32->cFileName));
            }
            else
            {
                if ((!(lpFind32->dwFileAttributes &
                                     (FILE_ATTRIBUTE_DIRECTORY|FILE_ATTRIBUTE_DEVICE)))
                                     && RealFileSize(lpFRUse->sFR.ulFileSize)
                                     )
                {
                    Assert((lpFRUse->sFR.uchHintPri || mPinFlags(lpFRUse->sFR.uchHintFlags)));
                }
            }
            AddStoreData(lpdbShadow, &sSD);
            AdjustSparseStaleDetectionCount(hShare, lpFRUse);
        }
        
        vdwCSCNameSpaceVersion++;
        vdwPQVersion++;
        
        iRet = SRET_OK;
    }

bailout:
    if (iRet==SRET_ERROR)
    {
        if (hNew)
        {
            FreeInode(lpdbShadow, hNew);
        }
    }
    if (lpFR)
        FreeMem(lpFR);
    else
        UnUseGlobalFilerecExt();

    END_TIMING(CreateShadowInternal);

    return iRet;
}


int
DeleteShadow(
    HSHADOW     hDir,
    HSHADOW     hShadow
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    return DeleteShadowInternal(hDir, hShadow, FALSE);      // try a gentle delete
}

ULONG DelShadowInternalEntries = 0;
#define JOE_DECL_CURRENT_PROGRESS CscProgressDelShdwI
JOE_DECL_PROGRESS();

int
DeleteShadowInternal(                           //
    HSHADOW     hDir,
    HSHADOW     hShadow,
    BOOL        fForce
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    STOREDATA sSD;
    int iRet= SRET_ERROR;
    PRIQREC sPQ;
    LPFILERECEXT lpFR = NULL, lpFRUse;

    Assert(vfInShadowCrit != 0);

    DelShadowInternalEntries++;
    JOE_INIT_PROGRESS(DelShadowInternalEntries,&hDir);

    if (InuseGlobalFRExt())
    {
        if (!(lpFR = (LPFILERECEXT)AllocMem(sizeof(FILERECEXT))))
            goto bailout;
        lpFRUse = lpFR;
    }
    else
    {
        UseGlobalFilerecExt();
        lpFRUse = &vsFRExt;
    }

    if (!hDir)
    {
        if(FindSharerecFromInode(lpdbShadow, hShadow, (LPSHAREREC)lpFRUse))
        {
            if (fForce || !HasDescendents(lpdbShadow, 0, ((LPSHAREREC)lpFRUse)->ulidShadow))
            {
                iRet = DestroyShareInternal((LPSHAREREC)lpFRUse);
            }
        }
    }
    else
    {
        int iRetInner;

        //ASSERT(hShadow!=0);
        JOE_PROGRESS(2);

        if (!fForce &&  // not being forced
            !FInodeIsFile(lpdbShadow, hDir, hShadow) &&     // and it is a dir
            HasDescendents(lpdbShadow, hDir, hShadow))      // and has descendents
        {
            JOE_PROGRESS(3);
            CShadowKdPrint(DELETESHADOWBAD,("DeleteShadow: Trying to delete a directory with descendents \r\n"));
            SetLastErrorLocal(ERROR_DIR_NOT_EMPTY);
            goto bailout;
        }

        JOE_PROGRESS(4);
        if(FindPriQRecord(lpdbShadow, hDir, hShadow, &sPQ)<=0)
        {
            JOE_PROGRESS(5);
            CShadowKdPrint(DELETESHADOWBAD,("DeleteShadow: Trying to delete a noexistent inode %x \r\n", hShadow));
            SetLastErrorLocal(ERROR_FILE_NOT_FOUND);
            goto bailout;
        }

        Assert(hShadow == sPQ.ulidShadow);

        DeleteFromHandleCache(hShadow);

        iRetInner = DeleteInodeFile(lpdbShadow, hShadow);

        if(iRetInner<0){
            if (GetLastErrorLocal() != ERROR_FILE_NOT_FOUND)
            {
                CShadowKdPrint(DELETESHADOWBAD,("DeleteShadow: delete stent inode %x \r\n", hShadow));
                goto bailout;
            }
        }

        JOE_PROGRESS(6);
        if(DeleteFileRecFromInode(lpdbShadow, hDir, hShadow, sPQ.ulrecDirEntry, lpFRUse) == 0L)
        {
            JOE_PROGRESS(7);
            CShadowKdPrint(DELETESHADOWBAD,("DeleteShadow:DeleteFileRecord failed \r\n"));
            goto bailout;
        }

        JOE_PROGRESS(8);
        Assert(hShadow == lpFRUse->sFR.ulidShadow);

        JOE_PROGRESS(11);
        // No error checking is done on the following call as they
        // are benign errors.
        iRetInner = DeletePriQRecord(lpdbShadow, hDir, hShadow, &sPQ);
        if(iRetInner>=0){
            JOE_PROGRESS(12);
            CShadowKdPrint(DELETESHADOWBAD,("DeleteShadow priq %d\n", iRetInner));
        }

        JOE_PROGRESS(13);
        memset((LPVOID)&sSD, 0, sizeof(STOREDATA));

        // Let us deal with only file records for now
        if (!mNotFsobj(lpFRUse->sFR.uStatus))
        {
            if(IsFile(lpFRUse->sFR.dwFileAttrib))
            {
                sSD.ucntFiles++;
                // subtract store data only if it was accounted for in the first place
                sSD.ulSize = (lpFRUse->sFR.uchHintPri || mPinFlags(lpFRUse->sFR.uchHintFlags))
                                ? 0 : RealFileSize(lpFRUse->sFR.ulFileSize);
            }
            else
            {
                sSD.ucntDirs++;
            }

            if (sSD.ulSize)
            {
                CShadowKdPrint(STOREDATA,("DeleteShadowInternal:Deleting storedata for hDir=%x Name=%ws\r\n", hDir, lpFRUse->sFR.rgwName));
            }

            SubtractStoreData(lpdbShadow, &sSD);
        }

        if (!FInodeIsFile(lpdbShadow, hDir, hShadow) && lpDeleteCBForIoctl)
        {
            (*lpDeleteCBForIoctl)(hDir, hShadow);
        }
        // we don't care if this fails because then the worst
        // that can happen is that this inode will be permanenetly lost.
        // Checkdisk utility should recover this.

        JOE_PROGRESS(14);
        FreeInode(lpdbShadow, hShadow);


        // Yes we did delete a shadow
        iRet = SRET_OK;
        
        vdwCSCNameSpaceVersion++;
        vdwPQVersion++;
    }

bailout:
    JOE_PROGRESS(20);
#if 0 //this insert has errors.........
#if VERBOSE > 2
    if (iRet==SRET_OK)
        CShadowKdPrint(DELETESHADOWHI,("DeleteShadow: deleted shadow %x for %s\r\n", lpFRUse->sFR.ulidShadow, lpName));
    else
        CShadowKdPrint(DELETESHADOWHI,("DeleteShadow: error deleting shadow for %s\r\n", lpName));
#endif //VERBOSE > 2
#endif //if 0 for errors
    if (lpFR)
        FreeMem(lpFR);
    else
        UnUseGlobalFilerecExt();
    JOE_PROGRESS(21);
    return (iRet);
}


int TruncateDataHSHADOW(
    HSHADOW  hDir,
    HSHADOW  hShadow
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    ULONG uSize=0;
//    long nFileSizeHigh, nFileSizeLow;

    Assert(vfInShadowCrit != 0);
    Assert(!hDir || IsDirInode(hDir));

    if (FInodeIsFile(lpdbShadow, hDir, hShadow))
    {
//        GetInodeFileSize(lpdbShadow, hShadow, &uSize);
//        DosToWin32FileSize(uSize, &nFileSizeHigh, &nFileSizeLow);
        if (TruncateInodeFile(lpdbShadow, hShadow) < SRET_OK)
            return SRET_ERROR;

//        FreeShadowSpace(nFileSizeHigh, nFileSizeLow, IsLeaf(hShadow));
    }
    else
    {
        if (!HasDescendents(lpdbShadow, hDir, hShadow))
        {
            CreateDirInode(lpdbShadow, 0, hDir, hShadow);
        }
        else
        {
            SetLastErrorLocal(ERROR_ACCESS_DENIED);
            return SRET_ERROR;
        }
    }
    return(SRET_OK);
}


int PUBLIC
    RenameShadow(
    HSHADOW     hDirFrom,
    HSHADOW     hShadowFrom,
    HSHADOW     hDirTo,
    LPFIND32    lpFind32To,
    ULONG       uShadowStatusTo,
    LPOTHERINFO lpOI,
    ULONG       uRenameFlags,
    LPHSHADOW   lphShadowTo
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    return (RenameShadowEx(hDirFrom, hShadowFrom, 0, hDirTo, lpFind32To, uShadowStatusTo, lpOI, uRenameFlags, NULL, NULL, lphShadowTo));
}

int PUBLIC
    RenameShadowEx(
    HSHADOW     hDirFrom,
    HSHADOW     hShadowFrom,
    HSHARE     hShareTo,
    HSHADOW     hDirTo,
    LPFIND32    lpFind32To,
    ULONG       uShadowStatusTo,
    LPOTHERINFO lpOI,
    ULONG       uRenameFlags,
    LPVOID      lpSecurityBlobTo,
    LPDWORD     lpdwBlobSizeTo,
    LPHSHADOW   lphShadowTo
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet = SRET_ERROR;
    HSHADOW  hShadowTo;
    LPFILERECEXT lpFR = NULL, lpFRUse;
    BOOL fFile = FInodeIsFile(lpdbShadow, hDirFrom, hShadowFrom);

    Assert(vfInShadowCrit != 0);

    Assert(!hDirFrom || IsDirInode(hDirFrom));
    Assert(!hDirTo || IsDirInode(hDirTo));

    if (InuseGlobalFRExt())
    {
        if (!(lpFR = (LPFILERECEXT)AllocMem(sizeof(FILERECEXT))))
            goto bailout;
        lpFRUse = lpFR;
    }
    else
    {
        UseGlobalFilerecExt();
        lpFRUse = &vsFRExt;
    }

    // If we are keeping the renamer, we are going to have to create
    // a new inode and an empty directory/file
    if (mQueryBits(uRenameFlags, RNMFLGS_MARK_SOURCE_DELETED))
    {
        // Allocate an INODE for the new shadow
        if (!(hShadowTo = UlAllocInode(lpdbShadow, hDirFrom, IsLeaf(hShadowFrom))))
        {
            goto bailout;
        }

        Assert(IsLeaf(hShadowFrom) == IsLeaf(hShadowTo));


        if (!IsLeaf(hShadowTo))
        {
            if(CreateDirInode(lpdbShadow, 0, hDirFrom, hShadowTo) < 0)
                goto bailout;
        }
        else
        {
            if(CreateFileHSHADOW(hShadowTo) < 0)
            {
                goto bailout;
            }
        }
    }
    else
    {
        hShadowTo = 0;
    }



    iRet = RenameDirFileHSHADOW(hDirFrom, hShadowFrom, hShareTo, hDirTo, hShadowTo, uShadowStatusTo, lpOI, uRenameFlags, lpFRUse, lpFind32To, lpSecurityBlobTo, lpdwBlobSizeTo);

    if (lphShadowTo)
    {
        *lphShadowTo = (hShadowTo)?hShadowTo:hShadowFrom;
    }


bailout:
    if (lpFR)
        FreeMem(lpFR);
    else
        UnUseGlobalFilerecExt();
    return (iRet);
}


int RenameDirFileHSHADOW(
    HSHADOW         hDirFrom,
    HSHADOW         hShadowFrom,
    HSHADOW         hShareTo,
    HSHADOW         hDirTo,
    HSHADOW         hShadowTo,
    ULONG           uShadowStatusTo,
    LPOTHERINFO     lpOI,
    ULONG           uRenameFlags,
    LPFILERECEXT    lpFRUse,
    LPFIND32        lpFind32To,
    LPVOID          lpSecurityBlobTo,
    LPDWORD         lpdwBlobSizeTo
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    FILEHEADER sFH;
    PRIQREC sPQ;
    int count, iRet = SRET_ERROR;
    LPFILERECEXT lpFRDir = NULL;
    ULONG ulrecDirEntryTo, ulrecDirEntryFrom;
    BOOL fWasPinned=FALSE, fIsPinned=FALSE;

    Assert(lpFind32To);

    if(FindPriQRecord(lpdbShadow, hDirFrom, hShadowFrom, &sPQ)<=0)
    {
//        Assert(FALSE);
        goto bailout;
    }

    ulrecDirEntryFrom = sPQ.ulrecDirEntry;

    if(CShadowFindFilerecFromInode(lpdbShadow, hDirFrom, hShadowFrom, &sPQ, lpFRUse)<=0)
    {
//        Assert(FALSE);
        goto bailout;
    }

    Assert(sPQ.ulidShadow == lpFRUse->sFR.ulidShadow);

    fWasPinned = ((lpFRUse->sFR.uchHintPri || mPinFlags(lpFRUse->sFR.uchHintFlags)) != 0);

    if (mQueryBits(uRenameFlags, RNMFLGS_MARK_SOURCE_DELETED))
    {
        lpFRDir = (LPFILERECEXT)AllocMem(sizeof(FILERECEXT));
        if (!lpFRDir)
        {
            Assert(FALSE);
            goto bailout;
        }
    }


    if (lpFRDir)
    {
        Assert (mQueryBits(uRenameFlags, RNMFLGS_MARK_SOURCE_DELETED));
        // Save it's contents
        *lpFRDir = *lpFRUse;
    }

    // Change the name of hShadowFrom to the new name
    CopyNamesToFilerec(lpFind32To, lpFRUse);

    if (lpOI)
    {
        CopyOtherInfoToFilerec(lpOI, lpFRUse);
        CopyOtherInfoToPQ(lpOI, &sPQ);
    }

    fIsPinned = ((lpFRUse->sFR.uchHintPri || mPinFlags(lpFRUse->sFR.uchHintFlags)) != 0);

    // And it's status as requested by the caller
    lpFRUse->sFR.uStatus = (USHORT)uShadowStatusTo;

    if (uRenameFlags & RNMFLGS_USE_FIND32_TIMESTAMPS)
    {
        lpFRUse->sFR.ftLastWriteTime = lpFind32To->ftLastWriteTime;
        lpFRUse->sFR.ftOrgTime = lpFind32To->ftLastAccessTime;
    }

    // Both SAVE and RETAIN should never be ON
    Assert(mQueryBits(uRenameFlags, (RNMFLGS_SAVE_ALIAS|RNMFLGS_RETAIN_ALIAS))
        !=(RNMFLGS_SAVE_ALIAS|RNMFLGS_RETAIN_ALIAS));

    if (mQueryBits(uRenameFlags, RNMFLGS_SAVE_ALIAS))
    {
        Assert(!mQueryBits(uRenameFlags, RNMFLGS_RETAIN_ALIAS));
        Assert(hShadowTo != 0);
        lpFRUse->sFR.ulidShadowOrg = hShadowTo;
    }
    else if (!mQueryBits(uRenameFlags, RNMFLGS_RETAIN_ALIAS))
    {
        lpFRUse->sFR.ulidShadowOrg = 0;
    }

    // update the security context
    CopyBufferToSecurityContext(lpSecurityBlobTo, lpdwBlobSizeTo, &(lpFRUse->sFR.Security));

    // Write the record. Now hDirFrom is the renamee
    if ((ulrecDirEntryTo = AddFileRecordFR(lpdbShadow, hDirTo, lpFRUse)) <=0)
    {
        // this could happen if there is no disk space
        goto bailout;
    }

    // if this going across shares, fix up the PQ entry with the right share
    if (hShareTo)
    {
        sPQ.ulidShare = hShareTo;
    }

    sPQ.ulidDir = hDirTo;
    sPQ.ulrecDirEntry = ulrecDirEntryTo;
    sPQ.uStatus = ((USHORT)uShadowStatusTo | (sPQ.uStatus & SHADOW_LOCAL_INODE));


    if (UpdatePriQRecord(lpdbShadow, hDirTo, hShadowFrom, &sPQ)< 0)
    {
        Assert(FALSE);
        goto bailout;
    }

    // by this time a hShadowFrom has been associated with the new name
    // and is also pointing back to hDirTo
    // We still have a filerec entry which associates hShadowFrom with
    // the old name and we need to take care of it

    if (mQueryBits(uRenameFlags, RNMFLGS_MARK_SOURCE_DELETED))
    {
        // we are running in disconnected mode
        // need to keep the old name
        Assert(hShadowTo != 0);
        lpFRDir->sFR.uStatus = SHADOW_DELETED;
        lpFRDir->sFR.ulidShadow = hShadowTo;

        // update filerecord without doing any compares
        if(UpdateFileRecFromInodeEx(lpdbShadow, hDirFrom, hShadowFrom, ulrecDirEntryFrom, lpFRDir, FALSE)<=0)
        {
            Assert(FALSE);
            goto bailout;
        }

        if(AddPriQRecord(lpdbShadow, sPQ.ulidShare, hDirFrom, hShadowTo, SHADOW_DELETED
            , (ULONG)(sPQ.uchRefPri), (ULONG)(sPQ.uchIHPri)
            , (ULONG)(sPQ.uchHintPri), (ULONG)(sPQ.uchHintFlags), ulrecDirEntryFrom)<=0)
        {
            Assert(FALSE);
            goto bailout;
        }
    }
    else
    {
        if(DeleteFileRecFromInode(lpdbShadow, hDirFrom, hShadowFrom, ulrecDirEntryFrom, lpFRUse) <= 0L)
        {
            Assert(FALSE);
            goto bailout;
        }
    }

    if (IsLeaf(hShadowFrom) && (fWasPinned != fIsPinned))
    {
        CShadowKdPrint(STOREDATA,("RenameDirFileHSHADOW: hDirFrom=%x hShadowFrom=%x hDirTo=%x To=%ws\r\n", hDirFrom, hShadowFrom, hDirTo, lpFind32To->cFileName));
        CShadowKdPrint(STOREDATA,("RenameDirFileHSHADOW: WasPinned=%d IsPinned=%d\r\n", fWasPinned, fIsPinned));
        AdjustShadowSpace( 0,
                            (fWasPinned)?0:RealFileSize(lpFRUse->sFR.ulFileSize), // if it was pinned it's old size was zero for space computation
                                                                    // else it was the actual size
                            0,
                            (fWasPinned)?RealFileSize(lpFRUse->sFR.ulFileSize):0, // if it was pinned it's new size should be zero for space computation
                                                                    // else it should be the actual size

                            TRUE);
    }

    iRet = SRET_OK;
    
    vdwCSCNameSpaceVersion++;
    
bailout:
    if (lpFRDir)
    {
        FreeMem(lpFRDir);
    }
    return (iRet);
}

int PUBLIC                              // ret
GetShadow(                              //
    HSHADOW  hDir,
    USHORT *lpName,
    LPHSHADOW lphShadow,
    LPFIND32 lpFind32,
    ULONG far *lpuShadowStatus,
    LPOTHERINFO lpOI
    )                                                       //
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    return (GetShadowEx(hDir, lpName, lphShadow, lpFind32, lpuShadowStatus, lpOI, NULL, NULL));
}


int PUBLIC                              // ret
GetShadowEx(                              //
    HSHADOW  hDir,
    USHORT *lpName,
    LPHSHADOW lphShadow,
    LPFIND32 lpFind32,
    ULONG far *lpuShadowStatus,
    LPOTHERINFO lpOI,
    LPVOID      lpSecurityBlob,
    LPDWORD     lpdwBlobSize
    )                                                       //
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet=SRET_ERROR;
    LPFILERECEXT lpFR = NULL, lpFRUse;

    Assert(vfInShadowCrit != 0);

    if(!(!hDir || IsDirInode(hDir)))
    {
        return iRet;
    }

    BEGIN_TIMING(GetShadow);

    if (InuseGlobalFRExt())
    {
        if (!(lpFR = (LPFILERECEXT)AllocMem(sizeof(FILERECEXT))))
            goto bailout;
        lpFRUse = lpFR;
    }
    else
    {
        UseGlobalFilerecExt();
        lpFRUse = &vsFRExt;
    }

    *lphShadow = 0L;
    *lpuShadowStatus = 0;
    if (!hDir)
    {
        // We are looking for the root
        if(FindShareRecord(lpdbShadow, lpName, (LPSHAREREC)lpFRUse))
        {
            *lphShadow = ((LPSHAREREC)lpFRUse)->ulidShadow;

            *lpuShadowStatus = (ULONG)(((LPSHAREREC)lpFRUse)->uStatus);

            if (lpFind32)
            {
                CopySharerecToFindInfo(((LPSHAREREC)lpFRUse), lpFind32);
            }
            if (lpOI)
            {
                CopySharerecToOtherInfo((LPSHAREREC)lpFRUse, lpOI);
            }

            CopySecurityContextToBuffer(
                    &((LPSHAREREC)lpFRUse)->sShareSecurity,
                    lpSecurityBlob,
                    lpdwBlobSize);
        }
    }
    else
    {
        if (FindFileRecord(lpdbShadow, hDir, lpName, lpFRUse))
        {

            *lphShadow = lpFRUse->sFR.ulidShadow;
            if (lpFind32)
            {
                CopyFilerecToFindInfo(lpFRUse, lpFind32);
            }

            *lpuShadowStatus = lpFRUse->sFR.uStatus;

            CopySecurityContextToBuffer(&(lpFRUse->sFR.Security), lpSecurityBlob, lpdwBlobSize);

        }
        if (lpOI)
        {
            CopyFilerecToOtherInfo(lpFRUse, lpOI);
        }
    }
    iRet = SRET_OK;

    if (*lphShadow)
    {
        CShadowKdPrint(GETSHADOWHI,("GetShadow: %0lX is the shadow for %ws \r\n", *lphShadow, lpName));
        if (0) {  //keep this in case we need it again.........
            if ((lpName[0]==L'm') && (lpName[1]==L'f') && (lpName[2]==0)) {
            DbgPrint("Found mf!!!!\n");
            SET_HSHADOW_SPECIAL(*lphShadow);
            }
        }
    }
    else
    {
        CShadowKdPrint(GETSHADOWHI,("GetShadow: No shadow for %ws \r\n", lpName));
    }

bailout:
    if (lpFR)
        FreeMem(lpFR);
    else
        UnUseGlobalFilerecExt();

    END_TIMING(GetShadow);

    return iRet;
}

int PUBLIC                              // ret
ChkStatusHSHADOW(                               //
    HSHADOW      hDir,
    HSHADOW      hShadow,
    LPFIND32     lpFind32,
    ULONG     far *lpuStatus
    )                                                       //
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet;
    iRet = ReadShadowInfo(hDir, hShadow, lpFind32, lpuStatus, NULL, NULL, NULL, RSI_COMPARE);
    return(iRet);
}

int PUBLIC                              // ret
ChkUpdtStatusHSHADOW(                           //
    HSHADOW      hDir,
    HSHADOW      hShadow,
    LPFIND32     lpFind32,
    ULONG     far *lpuStatus
    )                                                       //
{
    int iRet;
    iRet = ReadShadowInfo(hDir, hShadow, lpFind32, lpuStatus, NULL, NULL, NULL, RSI_COMPARE|RSI_SET);
    return(iRet);
}

int PUBLIC GetShadowInfo
    (
    HSHADOW      hDir,
    HSHADOW      hShadow,
    LPFIND32     lpFind32,
    ULONG     far *lpuStatus,
    LPOTHERINFO lpOI
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet=SRET_ERROR;
    SHAREREC sSR;

    BEGIN_TIMING(GetShadowInfo);

    iRet = ReadShadowInfo(hDir, hShadow, lpFind32, lpuStatus, lpOI, NULL, NULL, RSI_GET);

    END_TIMING(GetShadowInfo);
    return(iRet);
}

int PUBLIC GetShadowInfoEx
    (
    HSHADOW     hDir,
    HSHADOW     hShadow,
    LPFIND32    lpFind32,
    ULONG       far *lpuStatus,
    LPOTHERINFO lpOI,
    LPVOID      lpSecurityBlob,
    LPDWORD     lpdwBlobSize
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet=SRET_ERROR;
    SHAREREC sSR;

    BEGIN_TIMING(GetShadowInfo);

    iRet = ReadShadowInfo(hDir, hShadow, lpFind32, lpuStatus, lpOI, lpSecurityBlob, lpdwBlobSize, RSI_GET);

    END_TIMING(GetShadowInfo);
    return(iRet);
}

int PUBLIC                              // ret
SetShadowInfo(                          //
    HSHADOW  hDir,
    HSHADOW  hShadow,
    LPFIND32 lpFind32,
    ULONG uFlags,
    ULONG uOp
    )                                                       //
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    return (SetShadowInfoEx(hDir, hShadow, lpFind32, uFlags, uOp, NULL, NULL, NULL));
}

int PUBLIC                              // ret
SetShadowInfoEx(                          //
    HSHADOW     hDir,
    HSHADOW     hShadow,
    LPFIND32    lpFind32,
    ULONG       uFlags,
    ULONG       uOp,
    LPOTHERINFO lpOI,
    LPVOID      lpSecurityBlob,
    LPDWORD     lpdwBlobSize
    )                                                       //
/*++

Routine Description:

    This routine is the central routine that modifies the database entry for a particular inode

Parameters:

Return Value:

Notes:


--*/
{
    int iRet = SRET_ERROR;
    LPFILERECEXT lpFR = NULL, lpFRUse;
    PRIQREC sPQ;
    ULONG   uOldSize = 0, uNewSize=0, ulOldHintPri=0, ulOldHintFlags = 0, ulOldRefPri, ulOldFlags;
    BOOL fRefPriChange = FALSE;

    Assert(vfInShadowCrit != 0);
    if(!(!hDir || IsDirInode(hDir)))
    {
        return iRet;
    }


    BEGIN_TIMING(SetShadowInfoInternal);

    if (lpFind32)
    {
        if(!( (IsLeaf(hShadow) && IsFile(lpFind32->dwFileAttributes)) ||
                (!IsLeaf(hShadow) && !IsFile(lpFind32->dwFileAttributes))))
        {
            return SRET_ERROR;
        }
    }

    if (InuseGlobalFRExt())
    {
        if (!(lpFR = (LPFILERECEXT)AllocMem(sizeof(FILERECEXT))))
            goto bailout;
            lpFRUse = lpFR;
    }
    else
    {
        UseGlobalFilerecExt();
        lpFRUse = &vsFRExt;
    }

    if (!hDir)
    {
        // We are looking for the root
        if(FindSharerecFromInode(lpdbShadow, hShadow, (LPSHAREREC)lpFRUse))
        {
            if (lpFind32)
            {
                CopyFindInfoToSharerec(lpFind32, (LPSHAREREC)lpFRUse);
            }

            if (lpOI)
            {
                CopyOtherInfoToSharerec(lpOI, (LPSHAREREC)lpFRUse);
            }

            CopyBufferToSecurityContext(    lpSecurityBlob,
                                            lpdwBlobSize,
                                            &(((LPSHAREREC)lpFRUse)->sRootSecurity));

            if (mAndShadowFlags(uOp))
            {
                ((LPSHAREREC)lpFRUse)->usRootStatus &= (USHORT)uFlags;
            }
            else if (mOrShadowFlags(uOp))
            {
                ((LPSHAREREC)lpFRUse)->usRootStatus |= (USHORT)uFlags;
            }
            else
            {
                ((LPSHAREREC)lpFRUse)->usRootStatus = (USHORT)uFlags;
            }

            iRet = SetShareRecord(lpdbShadow, ((LPSHAREREC)lpFRUse)->ulShare, (LPSHAREREC)lpFRUse);
        }
    }
    else
    {
        IF_HSHADOW_SPECIAL(hShadow) {
        //ASSERT(!"SpecialShadow in setshadinfo");
        }

        if(FindPriQRecord(lpdbShadow, hDir, hShadow, &sPQ) < 0)
        {
            goto bailout;
        }

        Assert((sPQ.ulidDir == hDir) && (sPQ.ulidShadow == hShadow));

        if (CShadowFindFilerecFromInode(lpdbShadow, hDir, hShadow, &sPQ, lpFRUse)> 0)
        {
            Assert(lpFRUse->sFR.ulidShadow == hShadow);
            uOldSize = uNewSize = lpFRUse->sFR.ulFileSize;
            ulOldFlags = lpFRUse->sFR.usStatus;



            if (lpFind32)
            {
                uNewSize = (ULONG)(lpFind32->nFileSizeLow);

                CopyFindInfoToFilerec(lpFind32, lpFRUse, (mChange83Name(uOp))?CPFR_COPYNAME:0);

                if (!mDontUpdateOrgTime(uOp))
                {
                    lpFRUse->sFR.ftOrgTime = lpFRUse->sFR.ftLastWriteTime;
                }
            }

            if (mAndShadowFlags(uOp))
            {
                lpFRUse->sFR.uStatus &= (USHORT)uFlags;
            }
            else if (mOrShadowFlags(uOp))
            {
                lpFRUse->sFR.uStatus |= (USHORT)uFlags;
            }
            else
            {
                lpFRUse->sFR.uStatus = (USHORT)uFlags;
            }

            if (mShadowNeedReint(ulOldFlags) && !mShadowNeedReint(lpFRUse->sFR.usStatus))
            {
                if(DeleteStream(lpdbShadow, hShadow, CscBmpAltStrmName) < SRET_OK)
                {
                    DbgPrint("DeleteStream failed with %x /n", GetLastErrorLocal());
                    goto bailout;
                }
            }

            if (lpOI)
            {
                // save some key old info before copying the new info

                ulOldHintPri = lpFRUse->sFR.uchHintPri;
                ulOldHintFlags = lpFRUse->sFR.uchHintFlags;
                ulOldRefPri = lpFRUse->sFR.uchRefPri;

                CopyOtherInfoToFilerec(lpOI, lpFRUse);

                CopyOtherInfoToPQ(lpOI, &sPQ);

                if (IsFile(lpFRUse->sFR.dwFileAttrib))
                {
                    if ((!ulOldHintPri && !mPinFlags(ulOldHintFlags)) &&    // was unpinned
                        (lpFRUse->sFR.uchHintPri || mPinFlags(lpFRUse->sFR.uchHintFlags)))  //is getting pinned
                    {
                        // If it went from unpinned to pinned
                        // make the new size 0
                        uNewSize = 0;
                    }
                    else if ((ulOldHintPri || mPinFlags(ulOldHintFlags)) && // was pinned
                        (!lpFRUse->sFR.uchHintPri && !mPinFlags(lpFRUse->sFR.uchHintFlags))) //is getting unpinned
                    {
                        // If it went from pinned to unpinned
                        // we must add the new size

                        uOldSize = 0;
                    }

                }

                if(mForceRelink(uOp) || ((ulOldRefPri != (ULONG)(sPQ.uchRefPri))
                    )
                  )
                {
                    fRefPriChange = TRUE;

                }

            }
            else
            {
                // if this is a pinned entry, we need to not have any space adjustment
                if(lpFRUse->sFR.uchHintPri || mPinFlags(lpFRUse->sFR.uchHintFlags))
                {
                    uOldSize = uNewSize;
                }
            }

            if (IsFile(lpFRUse->sFR.dwFileAttrib))
            {
                Assert(lpFRUse->sFR.uchRefPri == MAX_PRI);
            }
            else
            {
                Assert(sPQ.uchRefPri == MIN_PRI);
                Assert(lpFRUse->sFR.uchRefPri == MIN_PRI);
            }

            CShadowKdPrint(SETSHADOWINFOHI,("SetShadowInfo: %x %x: loctLo=%x loctHi=%x \r\n",
                 hDir,hShadow,
                 lpFRUse->sFR.ftOrgTime.dwLowDateTime,
                 lpFRUse->sFR.ftOrgTime.dwHighDateTime));

            CopyBufferToSecurityContext(lpSecurityBlob, lpdwBlobSize, &(lpFRUse->sFR.Security));

#ifdef DEBUG
            ValidatePri(lpFRUse);
#endif

            if ((ulOldFlags & SHADOW_SPARSE) && !(lpFRUse->sFR.usStatus & SHADOW_SPARSE))
            {
                CShadowKdPrint(SETSHADOWINFOHI,("SetShadowInfo: File Unsparsed\n"));
            }

            if (mSetLastRefreshTime(uOp) || ((ulOldFlags & SHADOW_STALE) && !(lpFRUse->sFR.usStatus & SHADOW_STALE)))
            {
                lpFRUse->sFR.ulLastRefreshTime = (ULONG)IFSMgr_Get_NetTime();
            }

            if (UpdateFileRecFromInode(lpdbShadow, hDir, hShadow, sPQ.ulrecDirEntry, lpFRUse) < SRET_OK)
            {
                Assert(FALSE);
                goto bailout;
            }

            if (mShadowNeedReint(ulOldFlags) && !mShadowNeedReint(lpFRUse->sFR.usStatus))
            {
                sPQ.usStatus = lpFRUse->sFR.uStatus;
 //               Assert(!(sPQ.usStatus & SHADOW_LOCAL_INODE));
                lpFRUse->sFR.ulidShadowOrg = lpFRUse->sFR.ulidShadow;
            }
            else
            {
                sPQ.usStatus = ((USHORT)(lpFRUse->sFR.uStatus) | (sPQ.usStatus & SHADOW_LOCAL_INODE));
            }

            if (fRefPriChange)
            {
                // update the record with and relinking it in the queue
                if (UpdatePriQRecordAndRelink(lpdbShadow, hDir, hShadow, &sPQ) < SRET_OK)
                {
                    Assert(FALSE);
                    goto bailout;
                }
            }
            else
            {
                // update the record without relinking
                if (UpdatePriQRecord(lpdbShadow, hDir, hShadow, &sPQ) < SRET_OK)
                {
                    Assert(FALSE);
                    goto bailout;
                }
            }

            // we do space accounting only for files
            // If the file went from pinned to upinned and viceversa

            if (IsFile(lpFRUse->sFR.dwFileAttrib) && (uOldSize != uNewSize))
            {

                CShadowKdPrint(STOREDATA,("SetShadowInfo: Size changed for hDir=%x Name=%ws\r\n", hDir, lpFRUse->sFR.rgwName));
                AdjustShadowSpace(0, uOldSize, 0, uNewSize, TRUE);
            }

            AdjustSparseStaleDetectionCount(0, lpFRUse);

            iRet = SRET_OK;

        }
    }
bailout:
    if (lpFR)
        FreeMem(lpFR);
    else
        UnUseGlobalFilerecExt();

    END_TIMING(SetShadowInfoInternal);

    return iRet;
}

int PRIVATE ReadShadowInfo(
    HSHADOW     hDir,
    HSHADOW     hShadow,
    LPFIND32    lpFind32,
    ULONG       far *lpuStatus,
    LPOTHERINFO lpOI,
    LPVOID      lpSecurityBlob,
    LPDWORD     lpdwBlobSize,
    ULONG       uFlags
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    BOOL fStale = FALSE;
    int iRet = SRET_ERROR;
    LPFILERECEXT lpFR = NULL, lpFRUse;
    PRIQREC sPQ;

    Assert(vfInShadowCrit != 0);
    if(!(!hDir || IsDirInode(hDir)))
    {
        return iRet;
    }


    if (InuseGlobalFRExt())
    {
        if (!(lpFR = (LPFILERECEXT)AllocMem(sizeof(FILERECEXT))))
            goto bailout;
        lpFRUse = lpFR;
    }
    else
    {
        UseGlobalFilerecExt();
        lpFRUse = &vsFRExt;
    }

    Assert((uFlags & (RSI_GET|RSI_SET)) != (RSI_GET|RSI_SET));

    if (!hDir)
    {
        if(FindSharerecFromInode(lpdbShadow, hShadow, (LPSHAREREC)lpFRUse))
        {
            if (lpuStatus != NULL) {
                *lpuStatus = (ULONG)(((LPSHAREREC)lpFRUse)->usRootStatus);
            }

            if (lpFind32)
            {
                CopySharerecToFindInfo((LPSHAREREC)lpFRUse, lpFind32);
            }

            if (lpOI)
            {
                CopySharerecToOtherInfo((LPSHAREREC)lpFRUse, lpOI);
            }

            CopySecurityContextToBuffer(
                &(((LPSHAREREC)lpFRUse)->sShareSecurity),
                lpSecurityBlob,
                lpdwBlobSize);

            iRet = SRET_OK;
        }

        goto bailout;
    }

    Assert(hDir);


    if(FindPriQRecord(lpdbShadow, hDir, hShadow, &sPQ) < 0)
        goto bailout;

    if(!CShadowFindFilerecFromInode(lpdbShadow, hDir, hShadow, &sPQ, lpFRUse))
    {
        CShadowKdPrint(ALWAYS,("ReadShadowInfo: !!! no filerec for pq entry Inode=%x, deleting PQ entry\r\n",
                        hShadow));
        goto bailout;
    }


    CopySecurityContextToBuffer(&(lpFRUse->sFR.Security), lpSecurityBlob, lpdwBlobSize);


    if (lpFind32)
    {
        if (uFlags & RSI_COMPARE)
        {
            // ACHTUNG!! we compare last write times. It is possible that
            // somebody might have changed the filetime on the server to
            // be something earlier than what we had when we shadowed the file
            // for the first time. We detect this case here and say that the file
            // is stale
#ifdef  CSC_RECORDMANAGER_WINNT
            fStale = ((CompareTimes(lpFind32->ftLastWriteTime, lpFRUse->sFR.ftOrgTime) != 0)||
                      (lpFind32->nFileSizeLow !=lpFRUse->sFR.ulFileSize));
#else
            fStale = (CompareTimesAtDosTimePrecision(lpFind32->ftLastWriteTime, lpFRUse->sFR.ftOrgTime) != 0);
#endif

            // If remote time > local time, copy the file
            if ((!fStale && (lpFRUse->sFR.uStatus & SHADOW_STALE))||
                (fStale && !(lpFRUse->sFR.uStatus & SHADOW_STALE)))
            {

                CShadowKdPrint(READSHADOWINFOHI,("ReadShadowInfo: %x: remtLo=%x remtHi=%x, \r\n locTLo=%x, locTHi=%x \r\n"
                ,hShadow, lpFind32->ftLastWriteTime.dwLowDateTime, lpFind32->ftLastWriteTime.dwHighDateTime
                , lpFRUse->sFR.ftOrgTime.dwLowDateTime, lpFRUse->sFR.ftOrgTime.dwHighDateTime));

                // Toggle the staleness bit
                lpFRUse->sFR.uStatus ^= SHADOW_STALE;
                sPQ.usStatus = (USHORT)(lpFRUse->sFR.uStatus) | (sPQ.usStatus & SHADOW_LOCAL_INODE);

                if (uFlags & RSI_SET)
                {
                    if (UpdateFileRecFromInode(lpdbShadow, hDir, hShadow, sPQ.ulrecDirEntry, lpFRUse) < SRET_OK)
                    {
                        Assert(FALSE);
                        goto bailout;
                    }

                    if (UpdatePriQRecord(lpdbShadow, hDir, hShadow, &sPQ) < SRET_OK)
                    {
                        // Toggle the staleness bit
                        lpFRUse->sFR.uStatus ^= SHADOW_STALE;

                        //try to undo the change
                        if (UpdateFileRecFromInode(lpdbShadow, hDir, hShadow, sPQ.ulrecDirEntry, lpFRUse) < SRET_OK)
                        {
                            Assert(FALSE);
                        }
                        goto bailout;
                    }

                    AdjustSparseStaleDetectionCount(0, lpFRUse);
                }
                iRet = 1;
            }
            else
            {
                iRet = 0;
            }
        }
        else
        {
            iRet = 0;
        }

        if (uFlags & RSI_GET)
        {
            CopyFilerecToFindInfo(lpFRUse, lpFind32);

            Assert((IsLeaf(hShadow) && IsFile(lpFind32->dwFileAttributes)) ||
                (!IsLeaf(hShadow) && !IsFile(lpFind32->dwFileAttributes)));
        }

    }
    else
    {
        iRet = 0;

    }

    if (lpOI)
    {
        CopyFilerecToOtherInfo(lpFRUse, lpOI);
    }

    if (lpuStatus != NULL) {
        *lpuStatus = lpFRUse->sFR.uStatus;
    }

bailout:
    if (lpFR)
    {
        FreeMem(lpFR);
    }
    else
    {
        UnUseGlobalFilerecExt();
    }
    return iRet;
}


HSHARE PUBLIC                  // ret
HCreateShareObj(                       //
    USHORT          *lpShare,
    LPSHADOWINFO    lpSI
    )                                                       //
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    ULONG ulidShare=0;
    HSHADOW hRoot=0;
    SHAREREC sSR;


    Assert(vfInShadowCrit != 0);

    memset(lpSI, 0, sizeof(SHADOWINFO));

    if(!InitShareRec(&sSR, lpShare,0))
    {
        return 0;
    }

    if (!(ulidShare = AllocShareRecord(lpdbShadow, lpShare)))
        return 0;

    if(!(hRoot = UlAllocInode(lpdbShadow, 0L, FALSE)))
        return 0;

    // Let us create an empty root
    if(CreateDirInode(lpdbShadow, ulidShare, 0L, hRoot) < 0L)
    {
        CShadowKdPrint(BADERRORS,("Error in creating root \r\n"));
        return 0L;
    }

    if (AddPriQRecord(lpdbShadow, ulidShare, 0, hRoot, SHADOW_SPARSE, 0, 0, 0, 0, ulidShare) < 0)
    {
        CShadowKdPrint(BADERRORS,("Error in inserting root in the priorityQ\r\n"));
        return 0L;
    }

    sSR.ulShare =      ulidShare;
    sSR.ulidShadow =    hRoot;
    sSR.uStatus =       0;
    sSR.usRootStatus =  SHADOW_SPARSE;
    sSR.dwFileAttrib =  FILE_ATTRIBUTE_DIRECTORY;

    if (sSR.ftLastWriteTime.dwLowDateTime == 0 && sSR.ftLastWriteTime.dwHighDateTime == 0) {
        KeQuerySystemTime(((PLARGE_INTEGER)(&sSR.ftLastWriteTime)));
        if (sSR.ftOrgTime.dwLowDateTime == 0 && sSR.ftOrgTime.dwHighDateTime == 0)
            sSR.ftOrgTime = sSR.ftLastWriteTime;
    }

    // there needs to be a way for passing in ftLastWriteTime, which we would
    // stamp as the ftOrgTime. We don't use the ORG time right now, but we might want to
    // in future

    // All entities have been individually created. Let us tie them up
    // in the database
    ulidShare = AddShareRecord(lpdbShadow, &sSR);

    if (ulidShare)
    {
        CopySharerecToShadowInfo(&sSR, lpSI);
        vdwCSCNameSpaceVersion++;
        vdwPQVersion++;
    }

    return ((HSHARE)ulidShare);
}


int PUBLIC                                      // ret
DestroyHSHARE(                 //
    HSHARE hShare
    )                                                       //
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
    {
    SHAREREC sSR;
    int iRet = SRET_ERROR;

    Assert(vfInShadowCrit != 0);

    if(FindSharerecFromShare(lpdbShadow, hShare, &sSR))
    {
    if (DestroyShareInternal(&sSR) >= 0)
        iRet = SRET_OK;
    }
    return (iRet);
    }

int DestroyShareInternal( LPSHAREREC lpSR
    )
{
    PRIQREC sPQ;
    int iRet = -1;

    if (!mNotFsobj(lpSR->uStatus))
    {
        if(DeletePriQRecord(lpdbShadow, 0, lpSR->ulidShadow, &sPQ) >= 0)
        {
            if (DeleteShareRecord(lpdbShadow, lpSR->ulShare))
            {
                FreeInode(lpdbShadow, lpSR->ulidShadow);
                DeleteInodeFile(lpdbShadow, lpSR->ulidShadow);
                iRet = 1;
                vdwCSCNameSpaceVersion++;
                vdwPQVersion++;
            }
            else
            {
                CShadowKdPrint(BADERRORS, ("Failed to delete record for share=%x\r\n", lpSR->ulShare));
            }
        }
    }
    return (iRet);
}


int PUBLIC                      // ret
GetShareFromPath(              //
    USHORT                      *lpShare,
    LPSHADOWINFO    lpSI
    )                                                       //
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    SHAREREC sSR;

    Assert(vfInShadowCrit != 0);

    memset(lpSI, 0, sizeof(SHADOWINFO));

    if(FindShareRecord(lpdbShadow, lpShare, &sSR))
    {
        CopySharerecToShadowInfo(&sSR, lpSI);
    }

    return SRET_OK;
}

int PUBLIC                      // ret
GetShareFromPathEx(              //
    USHORT          *lpShare,
    LPSHADOWINFO    lpSI,
    LPVOID          lpSecurityBlob,
    LPDWORD         lpdwBlobSize
    )                                                       //
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    SHAREREC sSR;

    memset(lpSI, 0, sizeof(SHADOWINFO));

    Assert(vfInShadowCrit != 0);

    if(FindShareRecord(lpdbShadow, lpShare, &sSR))
    {
        CopySharerecToShadowInfo(&sSR, lpSI);
        CopySecurityContextToBuffer(&(sSR.sShareSecurity), lpSecurityBlob, lpdwBlobSize);
    }

    return SRET_OK;
}

int PUBLIC                                      // ret
GetShareInfo(          //
    HSHARE         hShare,
    LPSHAREINFOW   lpShareInfo,
    LPSHADOWINFO    lpSI
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    return (GetShareInfoEx(hShare, lpShareInfo, lpSI, NULL, NULL));
}

int PUBLIC
GetShareInfoEx(
    HSHARE         hShare,
    LPSHAREINFOW   lpShareInfo,
    LPSHADOWINFO    lpSI,
    LPVOID          lpSecurityBlob,
    LPDWORD         lpdwBlobSize
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    SHAREREC sSR;

    Assert(vfInShadowCrit != 0);

    if (!hShare)
    {
        SetLastErrorLocal(ERROR_INVALID_PARAMETER);
        return SRET_ERROR;
    }

    if (GetShareRecord(lpdbShadow, hShare, &sSR) < SRET_OK)
    {
        return SRET_ERROR;
    }

    if (lpShareInfo)
    {
        lpShareInfo->hShare = hShare;

        memset(lpShareInfo->rgSharePath, 0, sizeof(lpShareInfo->rgSharePath));
        memcpy(lpShareInfo->rgSharePath, sSR.rgPath, wstrlen(sSR.rgPath)*sizeof(USHORT));

        memcpy(lpShareInfo->rgFileSystem, vwszFileSystemName, wstrlen(vwszFileSystemName)*sizeof(USHORT));

        lpShareInfo->usCaps = FS_CASE_IS_PRESERVED|FS_VOL_SUPPORTS_LONG_NAMES;
        lpShareInfo->usState = RESSTAT_OK;
    }
    if (lpSI)
    {
        CopySharerecToShadowInfo(&sSR, lpSI);
    }

    CopySecurityContextToBuffer(&(sSR.sShareSecurity), lpSecurityBlob, lpdwBlobSize);

    return (SRET_OK);
}


int
SetShareStatus( HSHARE  hShare,
    ULONG uStatus,
    ULONG uOp
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    return (SetShareStatusEx(hShare, uStatus, uOp, NULL, NULL));
}

int
SetShareStatusEx(
    HSHARE         hShare,
    ULONG           uStatus,
    ULONG           uOp,
    LPVOID          lpSecurityBlob,
    LPDWORD         lpdwBlobSize
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    SHAREREC sSR;

    Assert(vfInShadowCrit != 0);

    if (!hShare)
    {
        SetLastErrorLocal(ERROR_INVALID_PARAMETER);
        return SRET_ERROR;
    }

    if (GetShareRecord(lpdbShadow, hShare, &sSR) < SRET_OK)
    {
        return SRET_ERROR;
    }

    if (mAndShadowFlags(uOp))
    {
        sSR.uStatus &= (USHORT)uStatus;
    }
    else if (mOrShadowFlags(uOp))
    {
        sSR.uStatus |= (USHORT)uStatus;
    }
    else
    {
        sSR.uStatus = (USHORT)uStatus;
    }

    CopyBufferToSecurityContext(lpSecurityBlob, lpdwBlobSize, &(sSR.sShareSecurity));


    return (SetShareRecord(lpdbShadow, hShare, &sSR));
}


int PUBLIC                      // ret
GetAncestorsHSHADOW(                    //
    HSHADOW hName,
    LPHSHADOW    lphDir,
    LPHSHARE    lphShare
    )                                                       //
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    return (FindAncestorsFromInode(lpdbShadow, hName, lphDir, lphShare));
}

int PUBLIC SetPriorityHSHADOW(
    HSHADOW  hDir,
    HSHADOW  hShadow,
    ULONG ulRefPri,
    ULONG ulIHPri
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    OTHERINFO sOI;
    ULONG uOp = SHADOW_FLAGS_OR;

    Assert(vfInShadowCrit != 0);


    ulIHPri;
    InitOtherInfo(&sOI);

    // we make sure that if the new priority being set is MAX_PRI, then this
    // inode does get to the top of the PQ even if it's current priority is
    // MAX_PRI.

    if (ulRefPri == MAX_PRI)
    {
        uOp |= SHADOW_FLAGS_FORCE_RELINK;
    }
    sOI.ulRefPri = ulRefPri;
    sOI.ulIHPri = 0;

    if(SetShadowInfoEx(hDir, hShadow, NULL, 0, uOp, &sOI, NULL, NULL))
        return (SRET_ERROR);

    return (SRET_OK);
}

int PUBLIC  GetPriorityHSHADOW(
    HSHADOW  hDir,
    HSHADOW  hShadow,
    ULONG *lpulRefPri,
    ULONG *lpulIHPri
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    PRIQREC sPQ;

    Assert(vfInShadowCrit != 0);

    if((FindPriQRecord(lpdbShadow, hDir, hShadow, &sPQ) < 0)||mNotFsobj(sPQ.usStatus))
        return SRET_ERROR;

    if (lpulRefPri)
    {
        *lpulRefPri = (ULONG)(sPQ.uchRefPri);
    }
    if (lpulIHPri)
    {
        *lpulIHPri = (ULONG)(sPQ.uchIHPri);
    }
    return (SRET_OK);
}

int PUBLIC
ChangePriEntryStatusHSHADOW(
    HSHADOW  hDir,
    HSHADOW  hShadow,
    ULONG   uStatus,
    ULONG   uOp,
    BOOL    fChangeRefPri,
    LPOTHERINFO lpOI
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    PRIQREC sPQ;
    int iRet;
#ifdef DEBUG
    ULONG   ulRefPri;
#endif
    Assert(vfInShadowCrit != 0);
    Assert(!hDir || IsDirInode(hDir));

    BEGIN_TIMING(ChangePriEntryStatusHSHADOW);

    if(FindPriQRecord(lpdbShadow, hDir, hShadow, &sPQ) < 0)
        return SRET_ERROR;
#ifdef DEBUG
    ulRefPri = (ULONG)(sPQ.uchRefPri);
#endif

    if (uOp==SHADOW_FLAGS_AND)
    {
        sPQ.usStatus &= (USHORT)uStatus;
    }
    else if (uOp==SHADOW_FLAGS_OR)
    {
        sPQ.usStatus |= (USHORT)uStatus;
    }
    else
    {
        sPQ.usStatus = (USHORT)uStatus;
    }
    if (lpOI)
    {
        CopyOtherInfoToPQ(lpOI, &sPQ);
    }

    if (!fChangeRefPri)
    {
        Assert(ulRefPri == (ULONG)(sPQ.uchRefPri));
        iRet = UpdatePriQRecord(lpdbShadow, hDir, hShadow, &sPQ);
    }
    else
    {
        iRet = UpdatePriQRecordAndRelink(lpdbShadow, hDir, hShadow, &sPQ);
        vdwPQVersion++;

    }

    END_TIMING(ChangePriEntryStatusHSHADOW);

    return (iRet);

}

CSC_ENUMCOOKIE PUBLIC                    // ret
HBeginPQEnum(   //
    VOID)                                           // no params
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    Assert(vfInShadowCrit != 0);

    return ((CSC_ENUMCOOKIE)BeginSeqReadPQ(lpdbShadow));
}

int PUBLIC EndPQEnum(
    CSC_ENUMCOOKIE  hPQEnum
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    Assert(vfInShadowCrit != 0);

    return(EndSeqReadQ((CSCHFILE)hPQEnum));
}

int PUBLIC                      // ret
PrevPriSHADOW(
    LPPQPARAMS  lpPQ
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    QREC sQrec;
    int iRet=-1;

    Assert(vfInShadowCrit != 0);

    sQrec.uchType = 0;
    if (lpPQ->uPos)
    {
        sQrec.ulrecPrev = lpPQ->uPos;
        iRet = SeqReadQ(lpPQ->uEnumCookie, &sQrec, &sQrec, Q_GETPREV);
    }
    else
    {
        iRet=SeqReadQ(lpPQ->uEnumCookie, &sQrec, &sQrec, Q_GETLAST);
    }

    if (iRet>=0)
    {

        // it is possible, that as the agent is traversing the PQ,
        // the next inode he is trying to read may have already been
        // deleted. In such a case, just fail, so he will start all
        // over in due course

        if(sQrec.uchType == REC_DATA)
        {
            lpPQ->hShare = sQrec.ulidShare;
            lpPQ->hDir = sQrec.ulidDir;
            lpPQ->hShadow = sQrec.ulidShadow;
            lpPQ->ulStatus = sQrec.usStatus;
            if (FInodeIsFile(lpdbShadow, sQrec.ulidDir, sQrec.ulidShadow))
            {
                lpPQ->ulStatus |= SHADOW_IS_FILE;
            }
            lpPQ->ulRefPri = (ULONG)(sQrec.uchRefPri);
            lpPQ->ulHintPri = (ULONG)(sQrec.uchHintPri);
            lpPQ->ulHintFlags = (ULONG)(sQrec.uchHintFlags);
            lpPQ->uPos = sQrec.ulrecPrev;
            lpPQ->dwPQVersion = vdwPQVersion;
        }
        else
        {
            lpPQ->hShadow = 0;
            iRet = -1;
        }
    }
    return (iRet);
}


int PUBLIC                      // ret
NextPriSHADOW(
    LPPQPARAMS  lpPQ
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    QREC sQrec;
    int iRet=-1;

    Assert(vfInShadowCrit != 0);

    sQrec.uchType = 0;
    if (lpPQ->uPos)
    {
        sQrec.ulrecNext = lpPQ->uPos;
        iRet = SeqReadQ(lpPQ->uEnumCookie, &sQrec, &sQrec, Q_GETNEXT);
    }
    else
    {
        iRet = SeqReadQ(lpPQ->uEnumCookie, &sQrec, &sQrec, Q_GETFIRST);
    }

    if (iRet >=0)
    {
        // it is possible, that as the agent is traversing the PQ,
        // the next inode he is trying to read may have already been
        // deleted. In such a case, just fail, so he will start all
        // over in due course

        if(sQrec.uchType == REC_DATA)
        {
            lpPQ->hShare = sQrec.ulidShare;
            lpPQ->hDir = sQrec.ulidDir;
            lpPQ->hShadow = sQrec.ulidShadow;
            lpPQ->ulStatus = (sQrec.usStatus);
            if (FInodeIsFile(lpdbShadow, sQrec.ulidDir, sQrec.ulidShadow))
            {
                lpPQ->ulStatus |= SHADOW_IS_FILE;
            }
            lpPQ->ulRefPri = (ULONG)(sQrec.uchRefPri);
            lpPQ->ulHintPri = (ULONG)(sQrec.uchHintPri);
            lpPQ->ulHintFlags = (ULONG)(sQrec.uchHintFlags);
            lpPQ->uPos = sQrec.ulrecNext;
            lpPQ->dwPQVersion = vdwPQVersion;
        }
        else
        {
            lpPQ->hShadow = 0;
            iRet = -1;
        }
    }
    return (iRet);
}



int GetRenameAliasHSHADOW( HSHADOW      hShadow,
    HSHADOW      hDir,
    LPHSHADOW    lphDirFrom,
    LPHSHADOW    lphShadowFrom
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet = SRET_ERROR;
    LPFILERECEXT lpFR = NULL, lpFRUse;
    PRIQREC sPQ;

    if (InuseGlobalFRExt())
    {
        if (!(lpFR = (LPFILERECEXT)AllocMem(sizeof(FILERECEXT))))
            goto bailout;
        lpFRUse = lpFR;
    }
    else
    {
        UseGlobalFilerecExt();
        lpFRUse = &vsFRExt;
    }

    *lphShadowFrom = *lphDirFrom = 0;

    if(FindPriQRecord(lpdbShadow, hDir, hShadow, &sPQ) < 0)
    {
        goto bailout;
    }

    if(!CShadowFindFilerecFromInode(lpdbShadow, hDir, hShadow, &sPQ, lpFRUse))
        goto bailout;

    Assert(lpFRUse->sFR.ulidShadow == sPQ.ulidShadow);

    *lphShadowFrom = lpFRUse->sFR.ulidShadowOrg;
    if (*lphShadowFrom)
    {
        FindAncestorsFromInode(lpdbShadow, *lphShadowFrom, lphDirFrom, NULL);
    }
    iRet = SRET_OK;

bailout:
    if (lpFR)
        FreeMem(lpFR);
    else
        UnUseGlobalFilerecExt();
    return iRet;
}

int
CopyHSHADOW(
    HSHADOW hDir,
    HSHADOW hShadow,
    LPSTR   lpszDestinationFile,
    ULONG   ulAttrib
)
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    return (CopyFileLocal(lpdbShadow, hShadow, lpszDestinationFile, ulAttrib));
}


int RenameDataHSHADOW(
    ULONG ulidFrom,
    ULONG ulidTo
    )
{
    return (RenameInode(lpdbShadow, ulidFrom, ulidTo));
}

int MetaMatchInit(
    ULONG *lpuCookie
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    *lpuCookie = 1;
    return(0);
}

int MetaMatch(
    HSHADOW         hDir,
    LPFIND32        lpFind32,
    ULONG           *lpuCookie,
    LPHSHADOW       lphShadow,
    ULONG           *lpuStatus,
    LPOTHERINFO     lpOI,
    METAMATCHPROC   lpfnMMP,
    LPVOID          lpData
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet;

    Assert(vfInShadowCrit != 0);

    if (hDir)
    iRet = MetaMatchDir(hDir, lpFind32, lpuCookie, lphShadow, lpuStatus, lpOI, lpfnMMP, lpData);
    else
    iRet = MetaMatchShare(hDir, lpFind32, lpuCookie, lphShadow, lpuStatus, lpOI, lpfnMMP, lpData);

    return (iRet);
}

int MetaMatchShare(
    HSHADOW         hDir,
    LPFIND32        lpFind32,
    ULONG           *lpuCookie,
    LPHSHADOW       lphShadow,
    ULONG           *lpuStatus,
    LPOTHERINFO     lpOI,
    METAMATCHPROC   lpfnMMP,
    LPVOID          lpData
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet = -1, iFound=-1;
    GENERICHEADER  sGH;
    CSCHFILE hf = NULL;
    ULONG uSize, ulrecPosFound = 0;
    OTHERINFO sOI;
    SHAREREC sSR;
    BOOL    fCached;

    if (!(hf = OpenInodeFileAndCacheHandle(lpdbShadow, ULID_SHARE, ACCESS_READWRITE, &fCached)))
    {
        goto bailout;
    }

    if(ReadHeader(hf, &sGH, sizeof(FILEHEADER)) < 0)
    {
        goto bailout;
    }

    for (;*lpuCookie <=sGH.ulRecords;)
    {
        iRet = ReadRecord(hf, &sGH, *lpuCookie, (LPGENERICREC)&sSR);
        if (iRet < 0)
            goto bailout;

        // bump the record pointer
        *lpuCookie += iRet;

        if (sSR.uchType != REC_DATA)
            continue;

        CopySharerecToFindInfo(&sSR, lpFind32);
        CopySharerecToOtherInfo(&sSR, &sOI);
        if (lpOI)
        {
            *lpOI = sOI;
        }

        *lpuStatus = (ULONG)(sSR.usStatus);

        *lphShadow = sSR.ulidShadow;

        iFound = (*lpfnMMP)(lpFind32, hDir, *lphShadow, *lpuStatus, &sOI, lpData);
        if (iFound==MM_RET_FOUND_CONTINUE)
        {
            ulrecPosFound = *lpuCookie - iRet;
        }
        else if (iFound <= MM_RET_FOUND_BREAK)
        {
            break;
        }
    }

    if (ulrecPosFound || (iFound==MM_RET_FOUND_BREAK))
    {
        if (ulrecPosFound)
        {
            ReadRecord(hf, &sGH, ulrecPosFound,  (LPGENERICREC)&sSR);

            CopySharerecToFindInfo(&sSR, lpFind32);

            *lpuStatus =  (ULONG)(sSR.usStatus);
            *lphShadow = sSR.ulidShadow;
            if (lpOI)
            {
                CopySharerecToOtherInfo(&sSR, lpOI);
            }
        }
    }
    else
    {
        *lpuStatus = *lphShadow = 0;
    }

    iRet = SRET_OK;

bailout:

    if (hf && !fCached)
    {
        Assert(vfStopHandleCaching);
        CloseFileLocal(hf);
    }
    else
    {
        Assert(!hf || !vfStopHandleCaching);
    }
    return (iRet);

}

int MetaMatchDir(
    HSHADOW  hDir,
    LPFIND32        lpFind32,
    ULONG           *lpuCookie,
    LPHSHADOW       lphShadow,
    ULONG           *lpuStatus,
    LPOTHERINFO     lpOI,
    METAMATCHPROC   lpfnMMP,
    LPVOID          lpData
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet = SRET_ERROR, iFound=-1;
    GENERICHEADER  sGH;
    CSCHFILE hf = NULL;
    ULONG uSize, ulrecPosFound = 0;
    OTHERINFO sOI;
    LPFILERECEXT lpFR = NULL, lpFRUse;
    BOOL    fCached;
    PRIQREC sPQ;

    if (InuseGlobalFRExt())
    {
        if (!(lpFR = (LPFILERECEXT)AllocMem(sizeof(FILERECEXT))))
            goto bailout;
        lpFRUse = lpFR;
    }
    else
    {
        UseGlobalFilerecExt();
        lpFRUse = &vsFRExt;
    }

    if (FInodeIsFile(lpdbShadow, 0, hDir))
    {
        SetLastErrorLocal(ERROR_INVALID_PARAMETER);
        goto bailout;
    }


    if (!(hf = OpenInodeFileAndCacheHandle(lpdbShadow, hDir, ACCESS_READWRITE, &fCached)))
    {
        DWORD   dwError;
        dwError = GetLastErrorLocal();

        if(FindPriQRecordInternal(lpdbShadow, hDir, &sPQ) < 0)
        {
            SetLastErrorLocal(ERROR_INVALID_PARAMETER);
        }
        else
        {
            SetCSCDatabaseErrorFlags(CSC_DATABASE_ERROR_MISSING_INODE);
            SetLastErrorLocal(dwError);
        }

        goto bailout;
    }

    if(ReadHeader(hf, &sGH, sizeof(FILEHEADER)) < 0)
    {
        goto bailout;
    }

    for (;*lpuCookie <=sGH.ulRecords;)
    {
        iRet = ReadRecord(hf, &sGH, *lpuCookie,  (LPGENERICREC)lpFRUse);
        if (iRet < 0)
        {
            goto bailout;
        }

        // bump the record pointer
        *lpuCookie += iRet;

        if (lpFRUse->sFR.uchType != REC_DATA)
        {
            continue;
        }

        CopyFilerecToFindInfo(lpFRUse, lpFind32);

        *lphShadow = lpFRUse->sFR.ulidShadow;

        CopyFilerecToOtherInfo(lpFRUse, &sOI);
        if (lpOI)
        {
            *lpOI = sOI;
        }
        *lpuStatus = (ULONG)(lpFRUse->sFR.uStatus);
        iFound = (*lpfnMMP)(lpFind32, hDir, *lphShadow, *lpuStatus, &sOI, lpData);
        if (iFound==MM_RET_FOUND_CONTINUE)
        {
            ulrecPosFound = *lpuCookie - iRet;
        }
        else if (iFound <= MM_RET_FOUND_BREAK)
        {
            break;
        }
    }


    if (ulrecPosFound || (iFound==MM_RET_FOUND_BREAK))
    {
        if (ulrecPosFound)
        {
            ReadRecord(hf, &sGH, ulrecPosFound,  (LPGENERICREC)lpFRUse);

            CopyFilerecToFindInfo(lpFRUse, lpFind32);
            *lpuStatus =  (ULONG)(lpFRUse->sFR.uStatus);
            *lphShadow = lpFRUse->sFR.ulidShadow;
            if (lpOI)
            {
                CopyFilerecToOtherInfo(lpFRUse, lpOI);
            }
        }
    }
    else
    {
        *lpuStatus = *lphShadow = 0;
    }
    iRet = SRET_OK;
bailout:

    if (hf && !fCached)
    {
        Assert(vfStopHandleCaching);
        CloseFileLocal(hf);
    }
    else
    {
        Assert(!hf || !vfStopHandleCaching);
    }
    if (lpFR)
    {
        FreeMem(lpFR);
    }
    else
    {
        UnUseGlobalFilerecExt();
    }

    return (iRet);
}


int CreateHint(
    HSHADOW hShadow,
    LPFIND32 lpFind32,
    ULONG ulHintFlags,
    ULONG ulHintPri,
    LPHSHADOW lphHint
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet=SRET_ERROR;
    OTHERINFO sOI;
    ULONG uStatus;

    // This must be either a wildcard hint, or else it can't be without an Fsobj
    if ((GetShadow(hShadow, lpFind32->cFileName, lphHint, lpFind32, &uStatus, &sOI)>=SRET_OK)
      && (*lphHint))
    {
        Assert((FHasWildcard(lpFind32->cFileName, MAX_PATH) || !mNotFsobj(uStatus)));

        if ((sOI.ulHintPri < MAX_HINT_PRI) &&
            (ulHintPri < MAX_HINT_PRI)
            )
        {
            sOI.ulHintPri += ulHintPri;

            if (sOI.ulHintPri <= MAX_HINT_PRI)
            {
                sOI.ulHintFlags = ulHintFlags;

                mClearBits(sOI.ulHintFlags, HINT_WILDCARD);

                iRet = SetShadowInfoEx(hShadow, *lphHint, lpFind32, 0, SHADOW_FLAGS_OR, &sOI, NULL, NULL);

                if (iRet>=SRET_OK)
                {
                    iRet = SRET_OBJECT_HINT;
                }
            }
        }
    }
    else
    {
        if (FHasWildcard(lpFind32->cFileName, MAX_PATH) && (ulHintPri <= MAX_HINT_PRI))
        {
            InitOtherInfo(&sOI);
            sOI.ulHintFlags = ulHintFlags;
            sOI.ulHintPri = ulHintPri;
            // Tell him that we are creating a file shadow
            lpFind32->dwFileAttributes = FILE_ATTRIBUTE_ARCHIVE;
            iRet = CreateShadowInternal(hShadow, lpFind32, SHADOW_NOT_FSOBJ, &sOI, lphHint);
            if (iRet>=SRET_OK)
            {
                iRet = SRET_WILDCARD_HINT;
            }
        }
    }
    return (iRet);
}

int DeleteHint(
    HSHADOW hShadow,
    USHORT *lpuHintName,
    BOOL fClearAll
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    ULONG uStatus;
    HSHADOW hChild;
    int iRet=SRET_ERROR;
    OTHERINFO sOI;

    if (GetShadow(hShadow, lpuHintName, &hChild, NULL, &uStatus, &sOI)>=SRET_OK)
    {
        // Nuke if there is no filesystem object with it
        if (mNotFsobj(uStatus))
        {
            iRet = DeleteShadowInternal(hShadow, hChild, TRUE);

            if (iRet>=SRET_OK)
            {
                iRet = SRET_WILDCARD_HINT;
            }
        }
        else
        {
            BOOL fDoit = TRUE;

            if (fClearAll)
            {
                sOI.ulHintPri = 0;
                sOI.ulHintFlags = 0;
            }
            else
            {
                if (sOI.ulHintPri > 0)
                {
                    --sOI.ulHintPri;
                }
                else
                {
                    fDoit = FALSE;
                }
            }

            if (fDoit)
            {
                iRet = SetShadowInfoEx(   hShadow,
                                                hChild,
                                                NULL,
                                                uStatus,
                                                SHADOW_FLAGS_ASSIGN,
                                                &sOI,
                                                NULL,
                                                NULL
                                                );

                if (iRet>=SRET_OK)
                {
                    iRet = SRET_OBJECT_HINT;
                }
            }
        }
    }
    return (iRet);
}

int CreateGlobalHint(
    USHORT *lpuName,
    ULONG ulHintFlags,
    ULONG ulHintPri
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet = SRET_ERROR;
    SHAREREC sSR;
    ULONG ulidShare, ulT;
#if 0
    if (FindShareRecord(lpdbShadow, lpuName, &sSR))
    {
        if ((sSR.uchHintPri < MAX_HINT_PRI) &&
            (ulHintPri < MAX_HINT_PRI)
            )
        {
            ulT = (ULONG)sSR.uchHintPri + ulHintPri;

            if (ulT <= MAX_HINT_PRI)
            {
                // Setting a hint on the root of the server
                sSR.uchHintFlags = (UCHAR)(ulHintFlags);
                sSR.uchHintPri = (UCHAR)(ulT);
                mClearBits(sSR.uchHintFlags, HINT_WILDCARD);
                Assert(FHasWildcard(lpuName, MAX_PATH) || !mNotFsobj(sSR.uStatus));
                if(SetShareRecord(lpdbShadow, sSR.ulShare, &sSR) > 0)
                {
                    iRet = SRET_OBJECT_HINT;
                }
            }
        }
    }
    else
    {
        if (FHasWildcard(lpuName, MAX_SERVER_SHARE))
        {
            if (ulidShare = AllocShareRecord(lpdbShadow, lpuName))
            {
                //InitShareRec(lpuName, &sSR);
                InitShareRec(&sSR, lpuName, 0);
                sSR.ulShare = ulidShare;
                sSR.ulidShadow = 0xffffffff; // Just to fool FindOpenHSHADOW
                sSR.uchHintFlags = (UCHAR)ulHintFlags;
                sSR.uchHintPri = (UCHAR)ulHintPri;
                mSetBits(sSR.uStatus, SHADOW_NOT_FSOBJ);
                if(AddShareRecord(lpdbShadow, &sSR) > 0)
                {
                    iRet = SRET_WILDCARD_HINT;
                }
            }
        }
    }
#endif
    return (iRet);
}

int DeleteGlobalHint(
    USHORT *lpuName,
    BOOL fClearAll
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet = SRET_ERROR;
    SHAREREC sSR;
#if 0
    if (FindShareRecord(lpdbShadow, lpuName, &sSR))
    {
        if (mNotFsobj(sSR.uStatus))
        {
            iRet = DeleteShareRecord(lpdbShadow, sSR.ulShare);
        }
        else
        {
            if (fClearAll)
            {
                sSR.uchHintPri = sSR.uchHintFlags = 0;
            }
            else
            {
                if (sSR.uchHintPri > 0)
                {
                    --sSR.uchHintPri;
                }
            }
            if(SetShareRecord(lpdbShadow, sSR.ulShare, &sSR) > 0)
            {
                iRet = SRET_OK;
            }
        }
    }
#endif
    return (iRet);
}


int CopyFilerecToOtherInfo(
    LPFILERECEXT lpFR,
    LPOTHERINFO lpOI
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    lpOI->ulRefPri          = (ULONG)(lpFR->sFR.uchRefPri);
    lpOI->ulIHPri           = (ULONG)(lpFR->sFR.uchIHPri);
    lpOI->ulHintFlags       = (ULONG)(lpFR->sFR.uchHintFlags);
    lpOI->ulHintPri         = (ULONG)(lpFR->sFR.uchHintPri);
    lpOI->ftOrgTime         = lpFR->sFR.ftOrgTime;
    lpOI->ftLastRefreshTime = IFSMgr_NetToWin32Time(lpFR->sFR.ulLastRefreshTime);

    return(0);
}

int CopyOtherInfoToFilerec(
    LPOTHERINFO lpOI,
    LPFILERECEXT lpFR
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    if (lpOI->ulIHPri != RETAIN_VALUE)
    {
        lpFR->sFR.uchIHPri = (UCHAR)(lpOI->ulIHPri);
    }
    if (lpOI->ulHintPri != RETAIN_VALUE)
    {
        lpFR->sFR.uchHintPri = (UCHAR)(lpOI->ulHintPri);
    }
    if (lpOI->ulRefPri != RETAIN_VALUE)
    {
        lpFR->sFR.uchRefPri = (UCHAR)((lpOI->ulRefPri <= MAX_PRI)?lpOI->ulRefPri:MAX_PRI);
    }
    if (lpOI->ulHintFlags != RETAIN_VALUE)
    {
        lpFR->sFR.uchHintFlags = (UCHAR)(lpOI->ulHintFlags);
    }
    return(0);
}


int CopySharerecToOtherInfo(LPSHAREREC lpSR, LPOTHERINFO lpOI)
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    lpOI->ulRefPri = 0;
    lpOI->ulRootStatus = (ULONG)(lpSR->usRootStatus);
    lpOI->ulHintFlags = (ULONG)(lpSR->uchHintFlags);
    lpOI->ulHintPri = (ULONG)(lpSR->uchHintPri);
    return(0);
}


int CopyOtherInfoToSharerec(
    LPOTHERINFO lpOI,
    LPSHAREREC lpSR
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    if (lpOI->ulHintFlags != RETAIN_VALUE)
    {
        lpSR->uchHintFlags = (UCHAR)(lpOI->ulHintFlags);
    }
    if (lpOI->ulHintPri != RETAIN_VALUE)
    {
        lpSR->uchHintPri = (UCHAR)(lpOI->ulHintPri);
    }
    return(0);
}


int CopyPQToOtherInfo( LPPRIQREC lpPQ,
    LPOTHERINFO lpOI)
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    lpOI->ulRefPri = (ULONG)(lpPQ->uchRefPri);
    lpOI->ulIHPri = (ULONG)(lpPQ->uchIHPri);
    lpOI->ulHintFlags = (ULONG)(lpPQ->uchHintFlags);
    lpOI->ulHintPri = (ULONG)(lpPQ->uchHintPri);
    return(0);
}

int CopyOtherInfoToPQ( LPOTHERINFO lpOI,
    LPPRIQREC lpPQ)
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    if (lpOI->ulIHPri != RETAIN_VALUE)
    {
        lpPQ->uchIHPri = (UCHAR)(lpOI->ulIHPri);
    }
    if (lpOI->ulHintPri != RETAIN_VALUE)
    {
        lpPQ->uchHintPri = (UCHAR)(lpOI->ulHintPri);
    }
    if (lpOI->ulRefPri != RETAIN_VALUE)
    {
        lpPQ->uchRefPri = (UCHAR)((lpOI->ulRefPri <= MAX_PRI)?lpOI->ulRefPri:MAX_PRI);
    }
    if (lpOI->ulHintFlags != RETAIN_VALUE)
    {
        lpPQ->uchHintFlags = (UCHAR)(lpOI->ulHintFlags);
    }
    return(0);
}

int CopySharerecToFindInfo( LPSHAREREC lpSR,
    LPFIND32 lpFind32
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    memset(lpFind32, 0, sizeof(WIN32_FIND_DATA));
//    lpFind32->dwReserved0 = lpSR->ulShare;
//    lpFind32->dwReserved1 = lpSR->ulidShadow;
    lpFind32->dwFileAttributes = lpSR->dwFileAttrib & ~FILE_ATTRIBUTE_ENCRYPTED;
    lpFind32->ftLastWriteTime = lpSR->ftLastWriteTime;
    lpFind32->ftLastAccessTime = lpSR->ftOrgTime;
    memset(lpFind32->cFileName, 0, sizeof(lpFind32->cFileName));
    memcpy(lpFind32->cFileName, lpSR->rgPath, sizeof(lpSR->rgPath));
    return(0);
}

int CopyFindInfoToSharerec(
    LPFIND32 lpFind32,
    LPSHAREREC lpSR
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    // be paranoid and or the directory attribute bit anyway

    lpSR->dwFileAttrib = (lpFind32->dwFileAttributes | FILE_ATTRIBUTE_DIRECTORY);
    lpSR->ftLastWriteTime = lpFind32->ftLastWriteTime;

    return(0);
}


int
CopySharerecToShadowInfo(
    LPSHAREREC     lpSR,
    LPSHADOWINFO    lpSI
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    memset(lpSI, 0, sizeof(SHADOWINFO));

    lpSI->hShare = lpSR->ulShare;
    lpSI->hShadow = lpSR->ulidShadow;
    lpSI->uStatus = (ULONG)(lpSR->uStatus);

    lpSI->uRootStatus = (ULONG)(lpSR->usRootStatus);
    lpSI->ulHintFlags = (ULONG)(lpSR->uchHintFlags);
    lpSI->ulHintPri = (ULONG)(lpSR->uchHintPri);

    return 0;
}


int CopyOtherInfoToShadowInfo(
    LPOTHERINFO     lpOI,
    LPSHADOWINFO    lpShadowInfo
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    lpShadowInfo->ulHintFlags = lpOI->ulHintFlags;
    lpShadowInfo->ulHintPri = lpOI->ulHintPri;
    lpShadowInfo->ftOrgTime = lpOI->ftOrgTime;
    lpShadowInfo->ftLastRefreshTime = lpOI->ftLastRefreshTime;
    lpShadowInfo->dwNameSpaceVersion = vdwCSCNameSpaceVersion;
    
    return(0);  //stop complaining about no return value
}

int InitOtherInfo(
    LPOTHERINFO lpOI)
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    memset(lpOI, 0xff, sizeof(OTHERINFO));
    return(0);
}



int PUBLIC                      // ret
FindOpenHSHADOW(        //
    LPFINDSHADOW    lpFindShadow,
    LPHSHADOW       lphShadow,
    LPFIND32        lpFind32,
    ULONG far       *lpuShadowStatus,
    LPOTHERINFO     lpOI
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet = SRET_ERROR;

    MetaMatchInit(&(lpFindShadow->ulCookie));
    if ((lpFindShadow->uSrchFlags & FLAG_FINDSHADOW_ALLOW_NORMAL)
    && ((lpFindShadow->uAttrib & 0xff) == FILE_ATTRIBUTE_LABEL))
    {
        BCSToUni(lpFind32->cFileName, vszShadowVolume, strlen(vszShadowVolume), BCS_OEM);
        iRet = 1;
    }
    else
    {
        if (MetaMatch(lpFindShadow->hDir, lpFind32
                , &(lpFindShadow->ulCookie)
                , lphShadow, lpuShadowStatus
                , lpOI, lpFindShadow->lpfnMMProc
                , (LPVOID)lpFindShadow)==SRET_OK)
        {
            iRet = (*lphShadow)?SRET_OK:SRET_ERROR;
        }
    }
    return (iRet);
}



int PUBLIC FindNextHSHADOW(             //
    LPFINDSHADOW    lpFindShadow,
    LPHSHADOW       lphShadow,
    LPFIND32        lpFind32,
    ULONG far       *lpuShadowStatus,
    LPOTHERINFO     lpOI
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet = SRET_ERROR;

    if ((lpFindShadow->uSrchFlags & FLAG_FINDSHADOW_ALLOW_NORMAL)
    && ((lpFindShadow->uAttrib & 0xff) == FILE_ATTRIBUTE_LABEL))
    {
        BCSToUni(lpFind32->cFileName, vszShadowVolume, strlen(vszShadowVolume), BCS_OEM);
        iRet = SRET_OK;
    }
    else
    {
        if (MetaMatch(lpFindShadow->hDir, lpFind32
                , &(lpFindShadow->ulCookie), lphShadow
                , lpuShadowStatus, lpOI
                , lpFindShadow->lpfnMMProc
                , (LPVOID)lpFindShadow)==SRET_OK)
        {
            iRet = (*lphShadow)?SRET_OK:SRET_ERROR;
        }
    }

    return (iRet);
}

int PUBLIC                              // ret
FindCloseHSHADOW(               //
    LPFINDSHADOW    lpFS
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    return SRET_OK;
}


// Callback function for MetaMatch,

// Return values: -1 => not found, stop; 0 => found, stop; 1 => keep going

int FsobjMMProc(
    LPFIND32        lpFind32,
    HSHADOW         hDir,
    HSHADOW         hShadow,
    ULONG           uStatus,
    LPOTHERINFO     lpOI,
    LPFINDSHADOW    lpFSH
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int matchSem, iRet;
    BOOL fInvalid=FALSE, fIsDeleted, fIsSparse;
    USHORT rgu83[11];

    iRet = MM_RET_CONTINUE;

    if (mNotFsobj(uStatus))
    {
        return (iRet);
    }

#ifdef OFFLINE
    if ((lpFSH->uSrchFlags & FLAG_FINDSHADOW_DONT_ALLOW_INSYNC)
        && !mShadowOutofSync(uStatus))
    return (iRet);
#endif //OFFLINE

    // we are enumerating a directory
    if (hDir && !(lpFSH->uSrchFlags & FLAG_FINDSHADOW_ALL))
    {
        fIsDeleted = mShadowDeleted(uStatus);
        fIsSparse = (!mIsDir(lpFind32) && mShadowSparse(uStatus));

        fInvalid = ((!(lpFSH->uSrchFlags & FLAG_FINDSHADOW_ALLOW_DELETED)&& fIsDeleted)
                ||(!(lpFSH->uSrchFlags & FLAG_FINDSHADOW_ALLOW_SPARSE)&& fIsSparse)
                ||(!(lpFSH->uSrchFlags & FLAG_FINDSHADOW_ALLOW_NORMAL) && (!fIsDeleted && !fIsSparse)));
    }

    /* If the call came from an NT style API we will use NT
    semantics to match BOTH long names and short name with the
    given pattern.
    If it came from an old style API we will use NT style semantics
    with the short name
    */
    if (lpFSH->uSrchFlags & FLAG_FINDSHADOW_NEWSTYLE)
        matchSem = UFLG_NT;
    else
        matchSem = UFLG_DOS;

    if (lpFSH->uSrchFlags & FLAG_FINDSHADOW_META)
        matchSem |= UFLG_META;

    if (lpFSH->uSrchFlags & FLAG_FINDSHADOW_NEWSTYLE)
    {
        if(IFSMgr_MetaMatch(lpFSH->lpPattern, lpFind32->cFileName, matchSem)||
            (lpFind32->cAlternateFileName[0] && IFSMgr_MetaMatch(lpFSH->lpPattern, lpFind32->cAlternateFileName, matchSem)))
        {
            iRet = MM_RET_FOUND_BREAK;
        }
    }
    else
    {
        // Check if there is an 83name. This can happen when in disconnected state
        // we create an LFN object.
        if (lpFind32->cAlternateFileName[0])
        {
            Conv83UniToFcbUni(lpFind32->cAlternateFileName, rgu83);
            if(IFSMgr_MetaMatch(lpFSH->lpPattern, rgu83, matchSem))
            {
                // If this object has some attributes and they don't match with
                // the search attributes passed in
                if ((lpFind32->dwFileAttributes & FILE_ATTRIBUTE_EVERYTHING)
                    && !(lpFind32->dwFileAttributes & lpFSH->uAttrib))
                {
                    // If this is not a metamatch
                    if (!(lpFSH->uSrchFlags & FLAG_FINDSHADOW_META))
                    {
                    // terminate search
                    iRet = MM_RET_BREAK;
                    }
                    else
                    {
                    // metamatching is going on, let us continue
                    Assert(iRet==MM_RET_CONTINUE);
                    }
                }
                else
                {
                    iRet = MM_RET_FOUND_BREAK;
                }
            }
        }
    }
    if ((iRet==MM_RET_FOUND_BREAK) && fInvalid)
    {
        // we found this object but it is invalid, as per the flags
        // passed in
        if (!(matchSem & UFLG_META))
        {
            // We are not doing metamatching
            iRet = MM_RET_BREAK; // Say not found, and break
        }
        else
        {
            //we are doing metamatching.
            iRet = MM_RET_CONTINUE;    // ask him to keep going
        }
    }
    return (iRet);
}


int GetShadowWithChecksProc(
    LPFIND32        lpFind32,
    HSHADOW         hDir,
    HSHADOW         hShadow,
    ULONG           uStatus,
    LPOTHERINFO     lpOI,
    LPSHADOWCHECK   lpSC
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet = MM_RET_CONTINUE;
    BOOL fHintMatch=FALSE, fObjMatch=FALSE;
    ULONG ulHintFlagsThisLevel = HINT_EXCLUSION; // hint flags at this level

    // Convert the patterns to uppercase, as demanded by metamatch
    UniToUpper(lpFind32->cFileName, lpFind32->cFileName, sizeof(lpFind32->cFileName));

    // This is a filesystem object and we haven't found our match yet
    if (!mNotFsobj(uStatus) && !(lpSC->uFlagsOut & FLAG_OUT_SHADOWCHECK_FOUND))
    {
        // Is the source a name?
        if (lpSC->uFlagsIn & FLAG_IN_SHADOWCHECK_NAME)
        {
            UniToUpper(lpFind32->cAlternateFileName, lpFind32->cAlternateFileName, sizeof(lpFind32->cFileName));

            // check for normal name and it's alias
            if((IFSMgr_MetaMatch(lpFind32->cFileName, lpSC->lpuName,  UFLG_NT)||

            //ACHTUNG UFLG_NT used even for short name because
            // we are just checking from name coming down from ifsmgr as a path
            // and it is never an FCB style name
            IFSMgr_MetaMatch(lpFind32->cAlternateFileName, lpSC->lpuName, UFLG_NT)))
            {
                fObjMatch = TRUE;
            }
        }
        else  // The source is a shadow ID
        {
            fObjMatch = ((HSHADOW)(ULONG_PTR)(lpSC->lpuName)==hShadow);
        }

        if (fObjMatch)
        {
            if (lpSC->uFlagsIn & FLAG_IN_SHADOWCHECK_IGNOREHINTS)
            {
                // No hint checking needed, lets say we found it and stop
                iRet = MM_RET_FOUND_BREAK;
            }
            else
            {
                // found it, mark it as being found.
                lpSC->uFlagsOut |= FLAG_OUT_SHADOWCHECK_FOUND;
#ifdef MAYBE
                lpSC->sOI = *lpOI;
#endif //MAYBE
                if(fHintMatch = ((mIsHint(lpOI->ulHintFlags))!=0))
                {
                    // Let this guy override all previous includes, because
                    // really speaking he is at a lower level in the hierarchy
                    // and by our logic, hints at lower level in the hierarchy
                    // dominate those coming from above
                    lpSC->ulHintPri = 0;
                    lpSC->ulHintFlags = 0;
                    iRet = MM_RET_FOUND_BREAK;
                }
                else
                {
                    iRet = MM_RET_FOUND_CONTINUE;
                }
            }
        }
    }
    else if (!(lpSC->uFlagsIn & FLAG_IN_SHADOWCHECK_IGNOREHINTS) // Don't ignore hints
        && mNotFsobj(uStatus)        // This IS a hint
        && (!(lpSC->uFlagsIn & FLAG_IN_SHADOWCHECK_SUBTREE)
            ||mHintSubtree(lpOI->ulHintFlags)))
    {
        // This is a pure hint and
        // we are either at the end, so we can look at all kinds of hints
        // or we can look at only subtree hints

        if(IFSMgr_MetaMatch(lpFind32->cFileName, lpSC->lpuType, UFLG_NT|UFLG_META))
        {
            // The type matches with the hint
            fHintMatch = TRUE;
        }
    }

    if (fHintMatch)
    {
        if (mHintExclude(lpOI->ulHintFlags))
        {
            // Is this an exclusion hint, and the object has not
            // been included by a previous hint at this level, set it
            if (mHintExclude(ulHintFlagsThisLevel))
            {
//                Assert(lpOI->ulHintPri == 0);
//                lpSC->ulHintPri = lpOI->ulHintPri;
                lpSC->ulHintPri = 0;
                ulHintFlagsThisLevel = lpSC->ulHintFlags = lpOI->ulHintFlags;
            }
        }
        else
        {
            // Inclusion hint, override earlier excludes, or lower priority hints
            if (mHintExclude(lpSC->ulHintFlags) ||
                (lpSC->ulHintPri <  lpOI->ulHintPri))
            {
                lpSC->ulHintPri = lpOI->ulHintPri;
                ulHintFlagsThisLevel = lpSC->ulHintFlags = lpOI->ulHintFlags;
            }
        }
    }
    return (iRet);
}

int
FindCreateShare(
    USHORT                  *lpShareName,
    BOOL                    fCreate,
    LPSHADOWINFO            lpSI,
    BOOL                    *lpfCreated
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    ULONG       uShadowStatus, hShare;
    BOOL    fCreated = FALSE;
    int iRet = SRET_ERROR;

    Assert(vfInShadowCrit != 0);

    if (!IsPathUNC(lpShareName, MAX_SERVER_SHARE_NAME_FOR_CSC))
    {

        CShadowKdPrint(ALWAYS,("FindCreateShare: Invalid share name %ws\r\n", lpShareName));
//        Assert(FALSE);
        return (iRet);
    }
    if (lpfCreated)
    {
        *lpfCreated = FALSE;
    }


    if (GetShareFromPath(lpShareName, lpSI) <= SRET_ERROR)
    {
        CShadowKdPrint(FINDCREATESHARE,("FindCreateShare: Error creating server\r\n"));
        return SRET_ERROR;
    }

    if (lpSI->hShare)
    {
        iRet = SRET_OK;
    }
    else
    {
        if (fCreate)
        {
            if(hShare = HCreateShareObj(lpShareName, lpSI))
            {
                if (lpfCreated)
                {
                    *lpfCreated = TRUE;
                }
                iRet = SRET_OK;
            }
            else
            {
                CShadowKdPrint(FINDCREATESHARE,("FindCreateShare: Couldn't create server object \r\n"));
            }
        }
    }

    return (iRet);
}

#ifdef CSC_RECORDMANAGER_WINNT

int FindCreateShareForNt(
    PUNICODE_STRING         lpShareName,
    BOOL                    fCreate,
    LPSHADOWINFO            lpSI,
    BOOL                    *lpfCreated
    )
{
    int iRet, lenName;
    int ShareNameLengthInChars;

    Assert(vfInShadowCrit != 0);

    ShareNameLengthInChars = lpShareName->Length / sizeof(WCHAR);

    if ( ShareNameLengthInChars >= (MAX_SERVER_SHARE_NAME_FOR_CSC-1))
    {
        return SRET_ERROR;
    }

    UseGlobalFilerecExt();

    // plug the extra slash.
    vsFRExt.sFR.rgwName[0] = (USHORT)('\\');

    // append the rest of the share name
    memcpy(&(vsFRExt.sFR.rgwName[1]), lpShareName->Buffer, lpShareName->Length);

    // put in a terminating NULL
    vsFRExt.sFR.rgwName[ShareNameLengthInChars + 1] = 0;

    iRet = FindCreateShare(vsFRExt.sFR.rgwName, fCreate, lpSI, lpfCreated);

    UnUseGlobalFilerecExt();

    return iRet;
}
#endif
int
CShadowFindFilerecFromInode(
    LPVOID          lpdbID,
    HSHADOW         hDir,
    HSHADOW         hShadow,
    LPPRIQREC       lpPQ,
    LPFILERECEXT    lpFRUse
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet = 0;

    Assert(vfInShadowCrit != 0);

    if(!FindFileRecFromInode(lpdbShadow, hDir, hShadow, lpPQ->ulrecDirEntry, lpFRUse))
    {
        SetCSCDatabaseErrorFlags(CSC_DATABASE_ERROR_MISSING_INODE);
        SetLastErrorLocal(ERROR_FILE_NOT_FOUND);
        CShadowKdPrint(ALWAYS,("ReadShadowInfo: !!! no filerec for pq entry Inode=%x\r\n",
                        hShadow));
//        DeletePriQRecord(lpdbShadow, hDir, hShadow, lpPQ);
        goto bailout;
    }

    if ((lpFRUse->sFR.ulidShadow != lpPQ->ulidShadow)||(lpFRUse->sFR.ulidShadow != hShadow))
    {
        CShadowKdPrint(ALWAYS,("ReadShadowInfo: !!! mismatched filerec for pq entry Inode=%x\r\n",
                hShadow));

        // try getting it the hard way.
        if(!(lpPQ->ulrecDirEntry = FindFileRecFromInode(lpdbShadow, hDir, hShadow, INVALID_REC, lpFRUse)))
        {
            CShadowKdPrint(ALWAYS,("ReadShadowInfo: !!! no filerec for pq entry Inode=%x, deleting PQ entry\r\n",
                            hShadow));
//            DeletePriQRecord(lpdbShadow, hDir, hShadow, lpPQ);
            goto bailout;
        }
        else
        {
            // try updating this info.
            // don't check for errors, if there is a problem we will fix it on the fly
            // next time around
            UpdatePriQRecord(lpdbShadow, hDir, hShadow, lpPQ);
        }
    }

    iRet = lpPQ->ulrecDirEntry;

bailout:

    return (iRet);
}

BOOL
CopySecurityContextToBuffer(
    LPRECORDMANAGER_SECURITY_CONTEXT    lpSecurityContext,
    LPVOID                              lpSecurityBlob,
    LPDWORD                             lpdwBlobSize
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    DWORD   dwSizeCopied = 0;

    if (lpdwBlobSize)
    {
        if (lpSecurityBlob)
        {
            dwSizeCopied = min(*lpdwBlobSize, sizeof(RECORDMANAGER_SECURITY_CONTEXT));

            memcpy(lpSecurityBlob, lpSecurityContext,  dwSizeCopied);

            *lpdwBlobSize = dwSizeCopied;
        }
        else
        {
            // size needed
            *lpdwBlobSize = sizeof(RECORDMANAGER_SECURITY_CONTEXT);
        }
    }

    return ((lpSecurityBlob != NULL) && dwSizeCopied);
}


BOOL
CopyBufferToSecurityContext(
    LPVOID                              lpSecurityBlob,
    LPDWORD                             lpdwBlobSize,
    LPRECORDMANAGER_SECURITY_CONTEXT    lpSecurityContext
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    DWORD   dwSizeCopied = 0;

    if (lpdwBlobSize)
    {

        if (lpSecurityBlob)
        {
            dwSizeCopied = min(*lpdwBlobSize, sizeof(RECORDMANAGER_SECURITY_CONTEXT));
            memcpy(lpSecurityContext, lpSecurityBlob, dwSizeCopied);
            *lpdwBlobSize = dwSizeCopied;
        }
        else
        {
            // size copied
            *lpdwBlobSize = 0;
        }

    }

    // we have done some copying

    return ((lpSecurityBlob != NULL) && dwSizeCopied);
}


int PathFromHShadow(
    HSHADOW  hDir,
    HSHADOW  hShadow,
    USHORT   *lpBuff,
    int      cBuff  // # of WCHAR characters that lpBuff can fit
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int cCount, cRemain, iRet=-1;
    LPFIND32 lpFind32;
    ULONG uShadowStatus;
    HSHADOW  hTmp;

    Assert(vfInShadowCrit != 0);

    Assert(cBuff > 1);
    if (!(lpFind32 = (LPFIND32)AllocMem(sizeof(WIN32_FIND_DATA))))
    {
        KdPrint(("PathFromHSHADOW:Error Allocating memory\r\n"));
        goto bailout;
    }
    memset(lpBuff, 0, cBuff * sizeof(USHORT));
    cRemain = cBuff-1;

    // special case the root
    if (!hDir)
    {
        lpBuff[--cRemain] = (USHORT)('\\');

    }
    else
    {
        do
        {
            // If we are not dealing with the root
            if (hDir)
            {
                if(GetShadowInfo(hDir, hShadow, lpFind32, &uShadowStatus, NULL) < SRET_OK)
                    goto bailout;
                // Count of characters
                cCount = wstrlen(lpFind32->cFileName);
                // We need count+1 for prepending a backslash
                if (cCount >= cRemain)
                    goto bailout;
                // Save the ending byte which may be destroyed by UniToBCS
                // Convert
//                UniToBCS(lpBuff+cRemain-cCount, lpFind32->cFileName, sizeof(lpFind32->cFileName), cCount, BCS_WANSI);
                memcpy(lpBuff+cRemain-cCount, lpFind32->cFileName, cCount * sizeof(USHORT));
                cRemain -= cCount;
            }
            lpBuff[--cRemain] = (USHORT)('\\');
            if(GetAncestorsHSHADOW(hDir, &hTmp, NULL) < SRET_OK)
                goto bailout;
            hShadow = hDir;
            hDir = hTmp;
        }
        while (hDir);
    }

    // !!ACHTUNG!! this should work because the overlap is in the right way
    iRet = cBuff-cRemain;
    memcpy(lpBuff, lpBuff+cRemain, iRet * sizeof(USHORT));

bailout:
    if (lpFind32)
        FreeMem(lpFind32);
    return (iRet);
}

int
GetSecurityInfosFromBlob(
    LPVOID          lpvBlob,
    DWORD           dwBlobSize,
    LPSECURITYINFO  lpSecInfo,
    DWORD           *lpdwBytes
    )
/*++

Routine Description:

    Given security blob, this routine returns the information in form of an array of
    SECURITYINFO structures.

Arguments:

    lpvBlob         blob buffer that is obtained from GetShadowEx or GetShadowInfoEx

    dwBlobSize      blob buffer size obtained from GetShadowEx or GetShadowInfoEx

    lpSecInfo       Array of SECURITYINFO strucutres where to output the info

    lpdwBytes

Return Value:

    ERROR_SUCCESS if successful, otherwise appropriate error

--*/
{
    PACCESS_RIGHTS  pAccessRights = (PACCESS_RIGHTS)lpvBlob;
    DWORD   i, cnt;

    cnt = *lpdwBytes/sizeof(ACCESS_RIGHTS);
    cnt = min(cnt, CSC_MAXIMUM_NUMBER_OF_CACHED_SID_INDEXES);

    if (!lpSecInfo)
    {
        *lpdwBytes = CSC_MAXIMUM_NUMBER_OF_CACHED_SID_INDEXES * sizeof(ACCESS_RIGHTS);
        return 0;
    }

    for (i=0; i<cnt; ++i)
    {
        (lpSecInfo+i)->ulPrincipalID = (pAccessRights + i)->SidIndex;
        (lpSecInfo+i)->ulPermissions = (pAccessRights + i)->MaximalRights;
    }

    return TRUE;
}

int
GetDatabaseLocation(
    LPSTR   lpszBuff
    )
/*++

Routine Description:

    Returns the current location of the database in ANSI string.

Arguments:

    lpszBuff    buffer, must be MAX_PATH

Return Value:

    returns SRET_OK if successfull else returns SRET_ERROR

--*/
{
    return(QueryRecDB(lpszBuff, NULL, NULL, NULL, NULL) >= SRET_OK);
}

#if 0
int PUBLIC CopyFile(
    LPPATH lpSrc,
    ULONG ulidDir,
    ULONG ulidNew
    )
{
    LPSTR   lpszName = NULL;
    int iRet=-1;
    HFREMOTE hfSrc= (HFREMOTE)NULL;
    CSCHFILE hfDst= NULL;
    ULONG pos;
    LPVOID lpBuff=NULL;

    if (OpenFileRemoteEx(lpSrc, ACCESS_READONLY, ACTION_OPENEXISTING, 0, &hfSrc))
    {
        CShadowKdPrint(BADERRORS,("CopyFile: Can't open remote file\r\n"));
        goto bailout;
    }

    if (!(lpBuff = AllocMem(COPY_BUFF_SIZE)))
    {
        goto bailout;
    }

    lpszName = AllocMem(MAX_PATH);

    if (!lpszName)
    {
        goto bailout;
    }

    if(GetLocalNameHSHADOW(ulidNew, lpszName, MAX_PATH, FALSE)!=SRET_OK)
    {
        goto bailout;
    }

    // If the original file existed it would be truncated
    if ( !(hfDst = R0OpenFile(ACCESS_READWRITE, ACTION_CREATEALWAYS, lpszName)))
    {
        CShadowKdPrint(BADERRORS,("CopyFile: Can't create %s\r\n", lpszName));
        goto bailout;
    }

    CShadowKdPrint(COPYFILE,("Copying...\r\n"));
    pos = 0;

    // Both the files are correctly positioned
    while ((iRet = ReadFileRemote(hfSrc, LpIoreqFromFileInfo(hfSrc)
                , pos, lpBuff, COPY_BUFF_SIZE))>0)
    {
    if (WriteFileLocal(hfDst, pos, lpBuff, iRet) < 0)
    {
        CShadowKdPrint(BADERRORS,("CopyFile: Write Error\r\n"));
        goto bailout;
    }
    pos += iRet;
    }

    CShadowKdPrint(COPYFILE,("Copy Complete\r\n"));

    iRet = 1;
bailout:
    if (hfSrc)
    CloseFileRemote(hfSrc, NULL);
    if (hfDst)
    CloseFileLocal(hfDst);
    if (lpBuff)
    FreeMem(lpBuff);
    if ((iRet==-1) && hfDst)
    {
    DeleteFileLocal(lpszName, ATTRIB_DEL_ANY);
    }
    if (lpszName)
    {
        FreeMem(lpszName);
    }
    return iRet;
}
#endif

#ifdef DEBUG
int
ValidatePri(
    LPFILERECEXT lpFR
    )
{
    if (!(lpFR->sFR.dwFileAttrib & FILE_ATTRIBUTE_DIRECTORY))
    {
        if((lpFR->sFR.uchRefPri != MAX_PRI))
        {
            CShadowKdPrint(ALWAYS,("Bad refpri %x %ws\r\n",
                                            lpFR->sFR.uchRefPri,
                                            lpFR->sFR.rgw83Name));
            return 0;
        }
    }
    else
    {
        if((lpFR->sFR.uchRefPri != MIN_PRI))
        {
            CShadowKdPrint(ALWAYS,("Bad refpri %x %ws\r\n",
                                            lpFR->sFR.uchRefPri,
                                            lpFR->sFR.rgw83Name));
            return 0;
        }

    }
    return 1;
}
#endif


int
GetHShareFromUNCString(
    USHORT  *lpServer,
    int     cbServer,
    int     lenSkip,
    BOOL    fIsShareName,
    HSHARE *lphShare,
    ULONG   *lpulHintFlags
    )
/*++

Routine Description:


Arguments:


Return Value:

    This is the ONLY routine that is called from rdr2 code that expects the ciritcal section not to be held
    because of deadlock with FAT during paging writes, if the net goes down.
    See comments in rdr2\rdbss\smb.mrx\csc.nt5\transitn.c

--*/
{
    int iRet = -1, i;
    GENERICHEADER  sGH;
    CSCHFILE hf = NULL;
    ULONG ulRec;
    SHAREREC sSR;
    BOOL    fCached;
    USHORT  uchDelimiter=(USHORT)'\\';

    *lphShare = 0;
    *lpulHintFlags = 0;

    if ((cbServer/sizeof(USHORT)+lenSkip)>= (sizeof(sSR.rgPath)/sizeof(USHORT)))
    {
        return iRet;
    }

    if (fIsShareName)
    {
        uchDelimiter = 0;
    }

    if (!(hf = OpenInodeFileAndCacheHandle(lpdbShadow, ULID_SHARE, ACCESS_READWRITE, &fCached)))
    {
        goto bailout;
    }

    if(ReadHeader(hf, &sGH, sizeof(FILEHEADER)) < 0)
    {
        goto bailout;
    }
    

    for (ulRec=1; ulRec<=sGH.ulRecords; ulRec++)
    {
        if(ReadRecord(hf, &sGH, ulRec, (LPGENERICREC)&sSR) < 0)
        {
            goto bailout;
        }

        if (sSR.uchType != REC_DATA)
        {
            continue;
        }

        // 0 return means it matched
        if(!wstrnicmp(lpServer, sSR.rgPath + lenSkip, cbServer))
        {
            Assert(sSR.ulShare);

            if (sSR.rgPath[lenSkip+cbServer/sizeof(USHORT)] == uchDelimiter)
            {
                *lphShare = sSR.ulShare;
                *lpulHintFlags = (ULONG)(sSR.uchHintFlags);
                iRet = SRET_OK;
                break;
            }
        }

    }

    iRet = SRET_OK;

bailout:

    if (hf && !fCached)
    {
        Assert(vfStopHandleCaching);
        CloseFileLocal(hf);
    }
    else
    {
        Assert(!hf || !vfStopHandleCaching);
    }
    return (iRet);

}

BOOL
EnableHandleCaching(
    BOOL    fEnable
    )
/*++

Routine Description:


Arguments:


Return Value:

    returns previous handlecaching value

--*/
{
    BOOL    fT, fT1;
    Assert(vfInShadowCrit != 0);

    fT = EnableHandleCachingSidFile(fEnable);

    fT1 = EnableHandleCachingInodeFile(fEnable);

    Assert(fT == fT1);
    return (fT1);
}

int
RecreateHSHADOW(
    HSHADOW hDir,
    HSHADOW hShadow,
    ULONG   ulAttrib
    )
/*++

Routine Description:

    This routine recreates an inode data file. This is so that when the CSC directory is
    marked for encryption/decryption, the newly created inode file will get encrypted.

Arguments:

    hDir        Inode directory

    hShadow     Inode whose file needs to be recreated

    ulAttrib    recreate with given attributes

Return Value:


--*/
{
    return (RecreateInode(lpdbShadow, hShadow, ulAttrib));
}

VOID
AdjustSparseStaleDetectionCount(
    ULONG hShare,
    LPFILERECEXT    lpFRUse
    )
/*++

Routine Description:

    This routine deals with a monotonically increasing (that is untill it wraps around), counter
    that is essentially a tick count that indicates when was the last time the cshadow interface
    created/set a sparse or a stale file.

    This is used by the agent to decide whether to enumerate the priority Q or not.

    Added code to also check if we're creating a file on a manually-cached share, and
    if so then to start the agent so it will clean this file up later.

Arguments:

    lpFRUse     record for the file/dir

Return Value:

    None

--*/
{
    ULONG cStatus;
    SHAREREC sSR = {0};
    LONG iRet = SRET_ERROR;
    
    // DbgPrint("AdjustSparseStaleDetectionCount(hShare=0x%x)\n", hShare);

    //
    // if this is a file and is stale or sparse
    //
    if (IsFile(lpFRUse->sFR.dwFileAttrib) &&
        (lpFRUse->sFR.uStatus & (SHADOW_STALE|SHADOW_SPARSE))) {
        ++vdwSparseStaleDetecionCount;
        // DbgPrint("####Pulsing agent #2 (1)\n");
        MRxSmbCscSignalFillAgent(NULL, 0);
        goto AllDone;
    }

    if (hShare != 0) {
        //
        // If we're creating a file on a manually-cached share, let the agent know
        //
        if (IsFile(lpFRUse->sFR.dwFileAttrib)) {
            iRet = GetShareRecord(lpdbShadow, hShare, &sSR);
            if (iRet < SRET_OK) {
                // DbgPrint("AdjustSparseStaleDetectionCount exit (1) iRet = %d\n", iRet);
                goto AllDone;
            }
        }
        cStatus = sSR.uStatus & FLAG_CSC_SHARE_STATUS_CACHING_MASK;
        // DbgPrint("AdjustSparseStaleDetectionCount cStatus=0x%x\n", cStatus);
        if (cStatus == FLAG_CSC_SHARE_STATUS_MANUAL_REINT) {
            ++vdwManualFileDetectionCount;
            // DbgPrint("####Pulsing agent #2 (2)\n");
            MRxSmbCscSignalFillAgent(NULL, 0);
        }
    }

AllDone:
    return;
}

VOID
QuerySparseStaleDetectionCount(
    LPDWORD lpcnt
    )
/*++

Routine Description:

Arguments:

    lpcnt       for returning the count

Return Value:

    None

--*/
{
    *lpcnt = vdwSparseStaleDetecionCount;
}

VOID
QueryManualFileDetectionCount(
    LPDWORD lpcnt
    )
/*++

Routine Description:

Arguments:

    lpcnt       for returning the count

Return Value:

    None

--*/
{
    *lpcnt = vdwManualFileDetectionCount;
}

ULONG
QueryDatabaseErrorFlags(
    VOID
    )
/*++

Routine Description:

Arguments:

Return Value:

    None

--*/
{
    return GetCSCDatabaseErrorFlags();
}

int
HasDescendentsHShadow(
    HSHADOW hDir,
    HSHADOW hShadow,
    BOOLEAN    *lpfDescendents
    )
/*++

Routine Description:

Arguments:

Return Value:

    None

--*/
{
    *lpfDescendents = (!FInodeIsFile(lpdbShadow, hDir, hShadow) && 
                        HasDescendents(lpdbShadow, 0, hShadow));

    return 0;
}

int PUBLIC AddStoreData(
    LPTSTR    lpdbID,
    LPSTOREDATA lpSD
    )
/*++

Routine Description:

    Adds space and file/dir count to the database. This is used for purging
    unpinned data.

Parameters:

Return Value:

Notes:


--*/
{
    CSCHFILE hf;
    SHAREHEADER sSH;
    int iRet = -1;
    BOOL    fCached;

    hf = OpenInodeFileAndCacheHandle(lpdbID, ULID_SHARE, ACCESS_READWRITE, &fCached);

    if (!hf)
    {
        return -1;
    }

    if (lpSD->ulSize)
    {
        // RecordKdPrint(STOREDATA,("Adding %ld \r\n", lpSD->ulSize));

    }
    if ((iRet = ReadHeader(hf, (LPVOID)&sSH, sizeof(SHAREHEADER)))> 0)
    {
        if (lpSD->ulSize)
        {
            // RecordKdPrint(STOREDATA,("AddStoreData Before: %ld \r\n", sSH.sCur.ulSize));
        }
        sSH.sCur.ulSize += lpSD->ulSize;
        sSH.sCur.ucntDirs += lpSD->ucntDirs;
        sSH.sCur.ucntFiles += lpSD->ucntFiles;

        // ensure that the data is always in clustersizes
        Assert(!(lpSD->ulSize%(vdwClusterSizeMinusOne+1)));

        if ((iRet = WriteHeader(hf, (LPVOID)&sSH, sizeof(SHAREHEADER))) < 0)
            Assert(FALSE);

        if (lpSD->ulSize)
        {
            // RecordKdPrint(STOREDATA,("AddStoreData After: %ld \r\n", sSH.sCur.ulSize));
        }

        //
        // If we are at the full cache size, kick the agent so he'll
        // free up some space.
        //
        if (sSH.sCur.ulSize > sSH.sMax.ulSize) {
            // DbgPrint("Full cache, notifying agent...\n");
            CscNotifyAgentOfFullCacheIfRequired();
        }
    }

    if (hf && !fCached)
    {
        Assert(vfStopHandleCaching);
        CloseFileLocal(hf);
    }
    else
    {
        Assert(!hf || !vfStopHandleCaching);
    }
    return iRet;
}

int PUBLIC SubtractStoreData(
    LPTSTR    lpdbID,
    LPSTOREDATA lpSD
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    CSCHFILE hf;
    SHAREHEADER sSH;
    int iRet = -1;
    BOOL    fCached;

    hf = OpenInodeFileAndCacheHandle(lpdbID, ULID_SHARE, ACCESS_READWRITE, &fCached);

    if (!hf)
    {
        return -1;
    }

    if (lpSD->ulSize)
    {
        // RecordKdPrint(STOREDATA,("Subtracting %ld \r\n", lpSD->ulSize));

    }
    if ((iRet = ReadHeader(hf, (LPVOID)&sSH, sizeof(SHAREHEADER)))> 0)
    {
        // RecordKdPrint(STOREDATA,("SubtractStoreData Before: %ld \r\n", sSH.sCur.ulSize));
        if (sSH.sCur.ulSize >lpSD->ulSize)
        {
            sSH.sCur.ulSize -= lpSD->ulSize;
        }
        else
        {
            sSH.sCur.ulSize = 0;
        }
        if (sSH.sCur.ucntDirs > lpSD->ucntDirs)
        {
            sSH.sCur.ucntDirs -= lpSD->ucntDirs;
        }
        else
        {
            sSH.sCur.ucntDirs = 0;
        }
        if (sSH.sCur.ucntFiles > lpSD->ucntFiles)
        {
            sSH.sCur.ucntFiles -= lpSD->ucntFiles;
        }
        else
        {
            sSH.sCur.ucntFiles = 0;
        }

        // ensure that the data is always in clustersizes
        Assert(!(lpSD->ulSize%(vdwClusterSizeMinusOne+1)));

        if ((iRet = WriteHeader(hf, (LPVOID)&sSH, sizeof(SHAREHEADER)))<0)
            Assert(FALSE);
        // RecordKdPrint(STOREDATA,("SubtractStoreData After: %ld \r\n", sSH.sCur.ulSize));
    }

    if (hf && !fCached)
    {
        Assert(vfStopHandleCaching);
        CloseFileLocal(hf);
    }
    else
    {
        Assert(!hf || !vfStopHandleCaching);
    }

    return iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\record.mgr\hook.h ===
#define  MAX_SHADOW_DIR_NAME  16 // maximum string size of shadow directory

// Stolen from IFSMgr code
#define  MAX_SERVER_SHARE  (31+63+2)


/********************** Type definitions for subclassed network objects ****/

typedef struct      tagRESOURCE     *PRESOURCE;
typedef struct      tagFINDINFO     *PFINDINFO;
typedef struct      tagFILEINFO     *PFILEINFO;
typedef struct      tagFDB *PFDB,   **PPFDB;
typedef struct      tagELEM         *PELEM;
typedef PELEM       *PPELEM;
typedef PRESOURCE   *PPRESOURCE;
typedef struct      tagFINDSHADOW   FINDSHADOW;
typedef FINDSHADOW  *LPFINDSHADOW;


/******** Netowrk provider *********/

typedef struct tagNETPRO
{
    PRESOURCE   pheadResource;
    pIFSFunc    pOurConnectNet;
    pIFSFunc    pConnectNet;      // Providers connection function
} NETPRO, DISKPRO, *PNETPRO, *PDISKPRO;


/************ Resource AKA Volume AKA share *****/

typedef struct tagRESOURCE
{
    PRESOURCE   pnextResource;
    PFILEINFO   pheadFileInfo;     // list of file I/O calls on this resource
    PFINDINFO   pheadFindInfo;     // list of finds on this resource
    PFDB        pheadFdb;            // List of files being shadowed
    HSHARE     hShare;             // Handle to the server shadow
    HSHADOW     hRoot;                // Handle to the root
    USHORT      usFlags;
    USHORT      usLocalFlags;
    PNETPRO     pOurNetPro;
    rh_t        rhPro;              // Providers resource handle;
    fh_t        fhSys;              // System resource handle
    vfunc_t     pVolTab;            // Pointer to volume functions structure
    int         cntLocks;      // Count of locks on this resource
    ULONG uDriveMap;         // Drive map for this resource
    PathElement pp_elements[1];
} RESOURCE, *PRESOURCE;


/********* per open file handle ****/

typedef struct tagFILEINFO
{
    PFILEINFO    pnextFileInfo; // Next FileInfo
    PRESOURCE    pResource;      // Resource off which it is hanging
    CSCHFILE     hfShadow;        // Shadow file handle
    PFDB         pFdb;             // Info of Shadow File
    fh_t         fhProFile;      // providers file handle
    hndlfunc     hfFileHandle;  // providers file function table
    UCHAR  uchAccess;  // Acess-share flags for this open
    UCHAR  uchDummy;
    USHORT usFlags;
    USHORT usLocalFlags;
    ULONG  cbTotalRead;
    sfn_t         sfnFile;
    pid_t         pidFile;
    uid_t         userFile;
} FILEINFO, *PFILEINFO;


/////////////////////////////////////////////////////////


/**** FileDescriptionBlock. Common info for all open instances of a file**/
typedef struct tagFDB
{
    // I M P O R T A N T :  the NT code for PFindFdbFromHshadow returns a PFDB
    //         but this pointer must not be used to get/put any field except usFlags!

    PFDB              pnextFdb;  // Link to the next
    PRESOURCE        pResource;          // Back pointer to our resource
    USHORT 	usFlags;     //
    USHORT 	usCount;        // Open Count
    ULONG  	hShadow;             // Shadow handle if any
    ULONG  	hDir;
    ULONG  	dwFileSize;         // file size when first opened
    dos_time         dosFileTime;
    ULONG  	dwAttr;
    USHORT 	cntLocks;        // Total outstanding locks
    USHORT 	usLocalFlags;
	ULONG	dwRemoteFileSize;	// size of the file when first created, used in the heuristic
    ParsedPath      sppathRemoteFile;     // Parsed Path of the file
} FDB, *PFDB;



typedef struct tagOTHERINFO
{
    ULONG       ulRefPri;
    union
    {
        ULONG   ulIHPri;
        ULONG   ulRootStatus;
    };
    ULONG       ulHintFlags;
    ULONG       ulHintPri;
    HSHADOW     hShadowOrg;
    FILETIME    ftOrgTime;
    FILETIME    ftLastRefreshTime;

} OTHERINFO, *LPOTHERINFO;

typedef  int (PUBLIC *METAMATCHPROC)(LPFIND32, HSHADOW, HSHADOW, ULONG, LPOTHERINFO, LPVOID);

#define  MM_RET_FOUND_CONTINUE    2
#define  MM_RET_CONTINUE            1
#define  MM_RET_FOUND_BREAK        0
#define  MM_RET_BREAK                -1

typedef  struct    tagFINDSHADOW
{
    LPFINDSHADOW    lpFSHNext;
    ULONG           ulFlags;
    HSHADOW         hDir;
    ULONG           ulCookie;
    ULONG           uAttrib;
    ULONG           uSrchFlags;
    USHORT          *lpPattern;
    METAMATCHPROC   lpfnMMProc;
} FINDSHADOW, *LPFINDSHADOW;

typedef struct tagSHADOWCHECK
{
    USHORT  uFlagsIn;
    USHORT  uFlagsOut;
    ULONG   ulCookie;
    USHORT  *lpuName;
    USHORT  *lpuType;
    HSHADOW hShadow;
    ULONG   uStatus;
    ULONG   ulHintFlags;
    ULONG   ulHintPri;
#ifdef MAYBE
    OTHERINFO    sOI;
#endif //MAYBE
} SHADOWCHECK, *LPSHADOWCHECK;

#define  FLAG_OUT_SHADOWCHECK_FOUND      0x1


#define  FLAG_IN_SHADOWCHECK_EXCLUDE        0x0001
#define  FLAG_IN_SHADOWCHECK_NAME            0x0002
#define  FLAG_IN_SHADOWCHECK_SUBTREE        0x0004
#define  FLAG_IN_SHADOWCHECK_IGNOREHINTS  0x0008
/*************** Our version of the find handle (VfnFindOpen)******/

typedef struct tagFINDINFO
{
    PFINDINFO    pnextFindInfo; // Next FindInfo
    PRESOURCE    pResource;      // Resource off which it is hanging
    fh_t          fhProFind;      // providers find handle
    hndlfunc     hfFindHandle;  // providers find function table
    USHORT usFlags;
    USHORT usLocalFlags;
    HSHADOW      hDir;             // Directory in which the search is going on
    FINDSHADOW  sFS;
    PathElement pe_pattern[1];  // Search pattern in case of wildcard search
} FINDINFO, *PFINDINFO;

/************ Generic linked list element ****************/
typedef struct tagELEM
{
    PELEM pnextElem;
} ELEM;



/********************* Flag definitions ************************************/

/** Flags set in usLocalFlags field of FDB (FileDescriptionBlock) **/

#define FLAG_FDB_SERIALIZE                  0x0001
#define FLAG_FDB_INUSE_BY_AGENT             0x0002
#define FLAG_FDB_SHADOW_MODIFIED            0x0008
#define FLAG_FDB_DONT_SHADOW                0x0010
#define FLAG_FDB_FINAL_CLOSE_DONE           0x0020
#define FLAG_FDB_DISABLE_AGENT			    0x0040
#define FLAG_FDB_ON_CACHEABLE_SHARE         0x0080
#define FLAG_FDB_SHADOW_SNAPSHOTTED         0x0100
#define FLAG_FDB_DELETE_ON_CLOSE            0x0200  // on NT we mark this file for delete after close

/** Flags set in usLocalFlags field of FILEINFO **/

#define FLAG_FILEINFO_INUSE_BY_AGENT      0x0002
#define FLAG_FILEINFO_DUP_HANDLE            0x2000    // Duplicate handle
#define FLAG_FILEINFO_INVALID_HANDLE      0x4000
#define FLAG_FILEINFO_INTERNAL_HANDLE     0x8000    // Handle created for internal find


/** Flags set in usLocalFlags field of FINDINFO **/

#define FLAG_FINDINFO_SHADOWFIND            0x0001    // Shadow find is in progress
#define FLAG_FINDINFO_INVALID_HANDLE      0x4000
#define FLAG_FINDINFO_INTERNAL_HANDLE     0x8000    // Handle created for internal find


/** Flags set on RESOURCE ***/

#define FLAG_RESOURCE_DISCONNECTED              SHARE_DISCONNECTED_OP //0x8000
#define FLAG_RESOURCE_SHADOW_ERRORS             SHARE_ERRORS             // 0x4000
#define FLAG_RESOURCE_SHADOW_CONNECT_PENDING    0x2000
#define FLAG_RESOURCE_SHADOWNP                  SHARE_SHADOWNP            // 0x1000
#define FLAG_RESOURCE_SLOWLINK                  0x0800
#define FLAG_RESOURCE_OFFLINE_CONNECTION        0x0400
#define FLAG_RESOURCE_CSC_MASK                  0x00C0

// the following defines deal with the CSC bits as obtained from the server and
// as stored in the RESOURCE data structure

#define ResourceCscBitsToSmbCscBits(uResBits)       (((uResBits) & FLAG_RESOURCE_CSC_MASK) >> 4)
#define SmbCscBitsToResourceCscBits(uResBits)       (((uResBits) & SMB_NEW_CSC_MASK) << 4)
#define ResourceCscBitsToShareCscBits(uResBits)    ((uResBits) & FLAG_RESOURCE_CSC_MASK)

#define FLAG_RESOURCE_CSC_MANUAL_REINT      0x0000      // No automatic file by file reint
#define FLAG_RESOURCE_CSC_AUTO_REINT        0x0040      // File by file reint is OK
#define FLAG_RESOURCE_CSC_VDO               0x0080      // no need to flow opens
#define FLAG_RESOURCE_CSC_NO_CACHING        0x00C0      // client should not cache this share

/** Find types *****/

#define  FLAG_FINDSHADOW_META               0x0001  // wild card matching
#define  FLAG_FINDSHADOW_NEWSTYLE           0x0002  // NT stle matching
#define  FLAG_FINDSHADOW_ALLOW_NORMAL       0x0004  // include non-sparse, undeleted shadows
#define  FLAG_FINDSHADOW_ALLOW_SPARSE       0x0008  // include sparse shadows
#define  FLAG_FINDSHADOW_ALLOW_DELETED      0x0010  // include shadows marked deleted
#define  FLAG_FINDSHADOW_DONT_ALLOW_INSYNC  0x0020  // ??
#define  FLAG_FINDSHADOW_ALL                0x8000


/******* Findshadow flags ***********/

#define FLAG_FINDSHADOW_INVALID_DIRECTORY   0x0001  //

/************** Convenience macros ****************************/

#define mShadowErrors(pRes)                 (((PRESOURCE)(pRes))->usLocalFlags & FLAG_RESOURCE_SHADOW_ERRORS)
#define mShadowFindON(pFI)                  (((PFINDINFO)(pFI))->usLocalFlags & FLAG_FINDINFO_SHADOWFIND)
#define mSetShadowFindON(pFI)               (((PFINDINFO)(pFI))->usLocalFlags |= FLAG_FINDINFO_SHADOWFIND)
#define mResetShadowFindON(pFI)             (((PFINDINFO)(pFI))->usLocalFlags &= ~FLAG_FINDINFO_SHADOWFIND)
#define mSerialize(pFdb)                    ((pFdb)->usLocalFlags & (FLAG_FDB_SERIALIZE))
#define mSetSerialize(pFdb)                 ((pFdb)->usLocalFlags |= FLAG_FDB_SERIALIZE)
#define mClearSerialize(pFdb)               ((pFdb)->usLocalFlags &= ~FLAG_FDB_SERIALIZE)
#define mInvalidFileHandle(pFileInfo)       (((PFILEINFO)(pFileInfo))->usLocalFlags & FLAG_FILEINFO_INVALID_HANDLE)
#define mInvalidFindHandle(pFileInfo)       (((PFILEINFO)(pFileInfo))->usLocalFlags & FLAG_FINDINFO_INVALID_HANDLE)

#define mIsDisconnected(pResource)          (((PRESOURCE)(pResource))->usLocalFlags & FLAG_RESOURCE_DISCONNECTED)
#define mMarkDisconnected(pResource)        (((PRESOURCE)(pResource))->usLocalFlags |= FLAG_RESOURCE_DISCONNECTED)
#define mClearDisconnected(pResource)       (((PRESOURCE)(pResource))->usLocalFlags &= ~FLAG_RESOURCE_DISCONNECTED)
#define mIsOfflineConnection(pResource)     (((PRESOURCE)(pResource))->usLocalFlags & FLAG_RESOURCE_OFFLINE_CONNECTION)
#define mShadowConnectPending(pResource)    (((PRESOURCE)(pResource))->usLocalFlags & FLAG_RESOURCE_SHADOW_CONNECT_PENDING)
#define mClearDriveUse(pResource, drvno)    (((PRESOURCE)(pResource))->uDriveMap &= ~((1 << drvno)))
#define mSetDriveUse(pResource, drvno)      (((PRESOURCE)(pResource))->uDriveMap |= (1 << drvno))
#define mGetDriveUse(pResource, drvno)      (((PRESOURCE)(pResource))->uDriveMap & (1 << drvno))
#define mGetCSCBits(pRes)                   (((PRESOURCE)(pRes))->usLocalFlags & FLAG_RESOURCE_CSC_MASK)
#define mSetCSCBits(pRes, uBits)            ((((PRESOURCE)(pRes))->usLocalFlags &= ~FLAG_RESOURCE_CSC_MASK), (((PRESOURCE)(pRes))->usLocalFlags |= ((uBits) & FLAG_RESOURCE_CSC_MASK)))

#define mAutoReint(pRes)                    ((((PRESOURCE)(pRes))->usLocalFlags & FLAG_RESOURCE_CSC_MASK)==FLAG_RESOURCE_CSC_AUTO_REINT)
#define mNotCacheable(pRes)                 ((((PRESOURCE)(pRes))->usLocalFlags & FLAG_RESOURCE_CSC_MASK)==FLAG_RESOURCE_CSC_NO_CACHING)


#define ANY_RESOURCE        (void *)(0xFFFFFFFF)
#define ANY_FHID             (void *)(0xFFFFFFFF)
#define RH_DISCONNECTED    (void *)0
#define UseGlobalFind32()     {AssertInShadowCrit();memset(&vsFind32, 0, sizeof(vsFind32));}
#define EnterHookCrit()        Wait_Semaphore(semHook, BLOCK_SVC_INTS)
#define LeaveHookCrit()        Signal_Semaphore(semHook)
/*************************** Globals     ************************************/
/************************** Templates for exported functions ***************/

int GetDriveIndex(LPSTR lpDrive);
PFDB PFindFdbFromHShadow (HSHADOW hShadow);
int CopyChunk (HSHADOW, HSHADOW, PFILEINFO, COPYCHUNKCONTEXT *);
PRESOURCE  PFindShadowResourceFromDriveMap(int    indx);
PRESOURCE  PFindResource (LPPE lppeIn, rh_t rhPro, fh_t fhPro, ULONG uFlags, PNETPRO pNetPro);
PRESOURCE  PFindResourceFromHShare (HSHARE, USHORT, USHORT);
PRESOURCE  PFindResourceFromRoot (HSHADOW, USHORT, USHORT);
void LinkResource (PRESOURCE pResource, PNETPRO pNetPro);
PRESOURCE PUnlinkResource (PRESOURCE pResource, PNETPRO pNetPro);
PRESOURCE PCreateResource (LPPE lppeIn);
void DestroyResource (PRESOURCE pResource);
int PUBLIC FindOpenHSHADOW(LPFINDSHADOW, LPHSHADOW, LPFIND32, ULONG far *, LPOTHERINFO);
int PUBLIC FindNextHSHADOW(LPFINDSHADOW, LPHSHADOW, LPFIND32, ULONG far *, LPOTHERINFO);
int PUBLIC FindCloseHSHADOW(LPFINDSHADOW);

HSHARE
HShareFromPath(
    PRESOURCE   pResource,
    LPPE        lppeShare,
    ULONG       uFlags,
    LPFIND32    lpFind32,
    HSHADOW     *lphRoot,
    ULONG       *lpuShareStatus
    );

PFILEINFO    PFileInfoAgent(VOID);

BOOL IsDupHandle(PFILEINFO pFileInfo);
PFDB PFindFdbFromHShadow (HSHADOW);
PFINDINFO    PFindFindInfoFromHShadow(HSHADOW);

int FsobjMMProc(LPFIND32, HSHADOW, HSHADOW, ULONG, LPOTHERINFO, LPFINDSHADOW);
int GetShadowWithChecksProc (LPFIND32, HSHADOW, HSHADOW, ULONG, LPOTHERINFO, LPSHADOWCHECK);

/*  the fcb structures work very differently on NT/rdr2 from the shadow VxD.
     accordingly, we have to do things a bit differently. there are the following
     important considerations:

     1. after you find a PFDBfromHShadow, it will continue to be valid until you
         leavveshadowcrit. what we'll do is to return a pointer to the status as
         part of the lookup routine and we'll use the pointer to fetch/update the status.
         IMPORTANT>>>> what i do is to actually return a pointer so that the status is
         act the correct offset from the pointer. the pointer must not be used for anything
         else.

     2. i cannot continue to be in the shadow crit while looking up a netroot. accordingly,
         i'll have to drop the lock and reacquire it. so i get the status and the drive map at
         the same time and remember them for later.

*/


#ifndef CSC_RECORDMANAGER_WINNT
int ReportCreateDelete( HSHADOW  hShadow, BOOL fCreate);

#define SMB_NEW_CSC_MASK                        0x000C      // see below

#define SMB_NEW_CSC_CACHE_MANUAL_REINT          0x0000      // No automatic file by file reint
#define SMB_NEW_CSC_CACHE_AUTO_REINT            0x0004      // File by file reint is OK
#define SMB_NEW_CSC_CACHE_VDO                   0x0008      // no need to flow opens
#define SMB_NEW_CSC_NO_CACHING                  0x000C      // client should not cache this share

#define IFNOT_CSC_RECORDMANAGER_WINNT if(TRUE)
#define MRxSmbCscGetSavedResourceStatus() (0)
#define MRxSmbCscGetSavedResourceDriveMap() (0)
#define DeclareFindFromShadowOnNtVars()
#define PLocalFlagsFromPFdb(pFdb)  (&((pFdb)->usLocalFlags))
#else
//BUGBUG
//this comes from hook.c on win95
#define ReportCreateDelete(a,b) {NOTHING;}

#define IFNOT_CSC_RECORDMANAGER_WINNT if(FALSE)

#define DeclareFindFromShadowOnNtVars() \
          ULONG mrxsmbShareStatus,mrxsmbDriveMap;

#define PFindFindInfoFromHShadow(a) ((NULL))

PFDB MRxSmbCscFindFdbFromHShadow (
     IN HSHADOW hShadow
     );
#define PFindFdbFromHShadow(a)  MRxSmbCscFindFdbFromHShadow(a)

PRESOURCE  MRxSmbCscFindResourceFromHandlesWithModify (
     IN  HSHARE  hShare,
     IN  HSHADOW  hRoot,
     IN  USHORT usLocalFlagsIncl,
     IN  USHORT usLocalFlagsExcl,
     OUT PULONG ShareStatus,
     OUT PULONG DriveMap,
     IN  ULONG uStatus,
     IN  ULONG uOp
    );

USHORT  *
MRxSmbCscFindLocalFlagsFromFdb(
    PFDB    pFdb
    );


#define PFindResourceFromRoot(a,b,c) \
     MRxSmbCscFindResourceFromHandlesWithModify(0xffffffff,a,b,c,\
                                              &mrxsmbShareStatus, \
                                              &mrxsmbDriveMap,0,0xffffffff)
#define MRxSmbCscGetSavedResourceStatus() (mrxsmbShareStatus)
#define MRxSmbCscGetSavedResourceDriveMap() (mrxsmbDriveMap)

#define PFindResourceFromHShare(a,b,c) \
     MRxSmbCscFindResourceFromHandlesWithModify(a,0xffffffff,b,c,\
                                              &mrxsmbShareStatus, \
                                              &mrxsmbDriveMap,0,0xffffffff)
#define PSetResourceStatusFromHShare(a,b,c,d,e) \
     MRxSmbCscFindResourceFromHandlesWithModify(a,0xffffffff,b,c,\
                                              &mrxsmbShareStatus, \
                                              &mrxsmbDriveMap,d,e)
#define ClearAllResourcesOfShadowingState() \
     MRxSmbCscFindResourceFromHandlesWithModify(0xffffffff,0xffffffff,0,0,\
                                              NULL, \
                                              NULL,0,SHADOW_FLAGS_AND)

#define PLocalFlagsFromPFdb(a)  MRxSmbCscFindLocalFlagsFromFdb(a)

NTSTATUS
MRxSmbCscCachingBitsFromCompleteUNCPath(
    PWSTR   lpShareShare,
    ULONG   *lpulBits
    );

NTSTATUS
MRxSmbCscServerStateFromCompleteUNCPath(
    PWSTR   lpShareShare,
    BOOL    *lpfOnline,
    BOOL    *lpfPinnedOffline
    );


#define SIGNALAGENTFLAG_CONTINUE_FOR_NO_AGENT 0x00000001
#define SIGNALAGENTFLAG_DONT_LEAVE_CRIT_SECT  0x00000002

extern NTSTATUS
MRxSmbCscSignalAgent (
    PRX_CONTEXT RxContext OPTIONAL,
    ULONG  Controls
    );

extern NTSTATUS
MRxSmbCscSignalFillAgent (
    PRX_CONTEXT RxContext OPTIONAL,
    ULONG  Controls
    );

extern BOOL
IsCSCBusy(
    VOID
    );
    
VOID
ClearCSCStateOnRedirStructures(
    VOID
    );
    

#endif //ifndef CSC_RECORDMANAGER_WINNT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\record.mgr\log.h ===
#define  MIN_VERBOSE 1
#define  MID_VERBOSE 2
#define  MAX_VERBOSE 3

#define  STAGE_BEGIN       0
#define  STAGE_CONTINUE    1
#define  STAGE_END         2


#define  MAX_LOGFILE_SIZE      0x10000  // Default max size of a log file
#define  MIN_LOGFILE_SIZE      0x8000  // min size of a log file

void  EnterLogCrit(void);
void  LeaveLogCrit(void);
VOID _cdecl DbgPrintLog(LPSTR lpFmt, ...);
void LogVfnDelete(PIOREQ);
void LogVfnDir(PIOREQ);
void LogVfnFileAttrib(PIOREQ);
void LogVfnFlush(PIOREQ);
void LogVfnGetDiskInfo(PIOREQ);
void LogVfnOpen(PIOREQ);
void LogVfnRename(PIOREQ);
void LogVfnSearch(PIOREQ);
void LogVfnQuery(PIOREQ, USHORT);
void LogVfnDisconnect(PIOREQ);
void LogVfnUncPipereq(PIOREQ);
void LogVfnIoctl16Drive (PIOREQ);
void LogVfnGetDiskParms(PIOREQ);
void LogVfnFindOpen(PIOREQ);
void LogHfnFindNext(PIOREQ);
void LogVfnDasdIO(PIOREQ);
void LogHfnFindClose(PIOREQ);
void LogHfnRead (PIOREQ);
void LogHfnWrite (PIOREQ);
void LogHfnClose (PIOREQ, int);
void LogHfnSeek (PIOREQ);
void LogHfnCommit (PIOREQ);
void LogHfnFileLocks (PIOREQ);
void LogHfnFileTimes (PIOREQ);
void LogHfnPipeRequest(PIOREQ);
void LogHfnHandleInfo(PIOREQ);
void LogHfnEnumHandle(PIOREQ);
void LogTiming(int verbosity, int stage);


#ifdef DEBUG
extern ULONG cntVfnDelete, cntVfnCreateDir, cntVfnDeleteDir, cntVfnCheckDir, cntVfnGetAttrib;
extern ULONG cntVfnSetAttrib, cntVfnFlush, cntVfnGetDiskInfo, cntVfnOpen;
extern ULONG cntVfnRename, cntVfnSearchFirst, cntVfnSearchNext;
extern ULONG cntVfnQuery, cntVfnDisconnect, cntVfnUncPipereq, cntVfnIoctl16Drive;
extern ULONG cntVfnGetDisParms, cntVfnFindOpen, cntVfnDasdIo;

extern ULONG cntHfnFindNext, cntHfnFindClose;
extern ULONG cntHfnRead, cntHfnWrite, cntHfnSeek, cntHfnClose, cntHfnCommit;
extern ULONG cntHfnSetFileLocks, cntHfnRelFileLocks, cntHfnGetFileTimes, cntHfnSetFileTimes;
extern ULONG cntHfnPipeRequest, cntHfnHandleInfo, cntHfnEnumHandle;

extern ULONG cntReadHits, cbReadLow, cbReadHigh, cbWriteLow, cbWriteHigh;
#endif //DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\record.mgr\log.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

     Log.c

Abstract:

     none.

Author:

     Shishir Pardikar      [Shishirp]        01-jan-1995

Revision History:

     Joe Linn                 [JoeLinn]         23-jan-97     Ported for use on NT

--*/

#include "precomp.h"
#pragma hdrstop

#pragma code_seg("PAGE")

/********************************************************************/
/**                    Copyright(c) Microsoft Corp., 1990-1991             **/
/********************************************************************/

//      Hook Processing

/******************************* Include Files ******************************/

#ifndef CSC_RECORDMANAGER_WINNT
#define WIN32_APIS
#include "cshadow.h"
#endif //ifndef CSC_RECORDMANAGER_WINNT

#include <stdlib.h>
#include <ctype.h>
#include <string.h>
// #include "error.h"
#include "vxdwraps.h"
#include "logdat.h"

/******************************* defines/typedefs ***************************/
#define MAX_SHADOW_LOG_ENTRY  512
#define  MAX_LOG_SIZE    100000

#ifdef DEBUG
#define  SHADOW_TIMER_INTERVAL    30000
#define  STATS_FLUSH_COUNT         10
#endif //DEBUG

#define  ENTERCRIT_LOG  { if (!fLogInit) InitShadowLog();\
                    if (fLogInit==-1) return;  \
                    Wait_Semaphore(semLog, BLOCK_SVC_INTS);}
#define  LEAVECRIT_LOG    Signal_Semaphore(semLog);

#ifdef CSC_RECORDMANAGER_WINNT

//ntdef has already define TIME differently....fortuntely by macros....
//so we undo this for the remainder of this file. the RIGHT solution is
//to use a name like CSC_LOG_TIME.

#undef _TIME
#undef TIME
#undef PTIME

#endif //ifdef CSC_RECORDMANAGER_WINNT

typedef struct tagTIME
{
    WORD seconds;
    WORD minutes;
    WORD hours;
    WORD day;
    WORD month;
    WORD year;
}
TIME, FAR *LPTIME;
#pragma intrinsic (memcmp, memcpy, memset, strcat, strcmp, strcpy, strlen)

/******************************* Function Prototypes ************************/
int vxd_vsprintf(char * lpOut, char * lpFmt, CONST VOID * lpParms);
int PrintLog( LPSTR lpFmt,  ...);
void PrintNetTime(LONG ltime);
void PrintNetShortTime(LONG ltime);
void ExplodeTime( ULONG time, LPTIME lpTime );
void LogPreamble(int, LPSTR, int, LPSTR);
int WriteStats(BOOL);

//need this for NT
int WriteLog(void);
/******************************** Static/Global data ************************/

#ifdef CSC_RECORDMANAGER_WINNT
#define UniToBCSPath(a,b,c,d)
#define IFSMgr_DosToNetTime(a) ((0))
#endif //ifdef CSC_RECORDMANAGER_WINNT

AssertData;
AssertError;


char logpathbuff[MAX_PATH+1], rgchLogFileName[MAX_PATH];
char chLogginBuffer[COPY_BUFF_SIZE];

extern int fLog;
extern LPSTR vlpszShadowDir;
int fLogInit = FALSE;
LPSTR  lpLogBuff = chLogginBuffer;
int cBuffSize = COPY_BUFF_SIZE;
int indxCur = 0;
VMM_SEMAPHORE semLog = 0L;
#define FOURYEARS       (3*365+366)

ULONG   ulMaxLogSize=0x00020000;  // 128K log filesize by default

#ifndef CSC_RECORDMANAGER_WINNT
BOOL    fPersistLog = TRUE;
#else
BOOL    fPersistLog = FALSE;
#endif

#define DAYSECONDS      (60L*60L*24L)           // number of seconds in a day

#define BIAS_70_TO_80   0x12CEA600L

//      days in a month

int MonTab[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };

/* structure stores intl settings for datetime format */
char szCSCLog[] = "\\csc.log"; // keep this size below 8
char szCRLF[] = "\r\n";
char szBegin[] = "Begin";
char szEnd[] = "End";
char szContinue[] = "Continue";
char szEndMarker[] = "END\n";

ULONG ulMaxLogfileSize;
DWORD   dwDebugLogVector = DEBUG_LOG_BIT_RECORD|DEBUG_LOG_BIT_CSHADOW;  // by default record manager logging is on
#ifdef DEBUG
ULONG cntVfnDelete=0, cntVfnCreateDir=0, cntVfnDeleteDir=0, cntVfnCheckDir=0, cntVfnGetAttrib=0;
ULONG cntVfnSetAttrib=0, cntVfnFlush=0, cntVfnGetDiskInfo=0, cntVfnOpen=0;
ULONG cntVfnRename=0, cntVfnSearchFirst=0, cntVfnSearchNext=0;
ULONG cntVfnQuery=0, cntVfnDisconnect=0, cntVfnUncPipereq=0, cntVfnIoctl16Drive=0;
ULONG cntVfnGetDiskParms=0, cntVfnFindOpen=0, cntVfnDasdIO=0;

ULONG cntHfnFindNext=0, cntHfnFindClose=0;
ULONG cntHfnRead=0, cntHfnWrite=0, cntHfnSeek=0, cntHfnClose=0, cntHfnCommit=0;
ULONG cntHfnSetFileLocks=0, cntHfnRelFileLocks=0, cntHfnGetFileTimes=0, cntHfnSetFileTimes=0;
ULONG cntHfnPipeRequest=0, cntHfnHandleInfo=0, cntHfnEnumHandle=0;
ULONG cbReadLow=0, cbReadHigh=0, cbWriteLow=0, cbWriteHigh=0;
ULONG cntVfnConnect=0;
ULONG cntLastTotal=0;
#endif //DEBUG

/****************************************************************************/
#ifndef CSC_RECORDMANAGER_WINNT
#pragma VxD_LOCKED_CODE_SEG
#endif //ifndef CSC_RECORDMANAGER_WINNT

int InitShadowLog(
    )
{
    int iRet = -1, lenT;

    if (fLog && !fLogInit && vlpszShadowDir)
    {
        if (!(semLog = Create_Semaphore(1)))
            goto bailout;

        strcpy(rgchLogFileName, (LPSTR)vlpszShadowDir);
        strcat(rgchLogFileName, szCSCLog);

        PrintLog(szCRLF);
        PrintNetTime(IFSMgr_Get_NetTime());
        PrintLog(szCRLF);
        fLogInit = 1;
        iRet = 0;
    }
    else
    {
        iRet = 0;
    }

bailout:
    if (iRet)
    {
        if (semLog)
            Destroy_Semaphore(semLog);
        semLog = 0L;
    }
    return iRet;
}

int ShadowLog(
    LPSTR lpFmt,
    ...
    )
{
    int pos, iRet = -1;
    if (!fLogInit)
    {
        InitShadowLog();
    }

    if (fLogInit)
    {
        if ((cBuffSize-indxCur+sizeof(szEndMarker)) < MAX_SHADOW_LOG_ENTRY)
        {
            iRet = WriteLog();
#if 0
            PrintLog(szCRLF);
            PrintNetTime(IFSMgr_Get_NetTime());
            PrintLog(szCRLF);
#endif
        }
        else
        {
            indxCur += vxd_vsprintf(lpLogBuff+indxCur, lpFmt, (LPSTR)&lpFmt+sizeof(lpFmt));

            // deliberately don't move the index pointer after writing the end marker
            // so when the next real log entry is written, the endmarker will be overwritten
            memcpy(lpLogBuff+indxCur, szEndMarker, sizeof(szEndMarker)-1);
            iRet = 0;
        }
    }
    else
    {
        iRet = 0;
    }
    return (iRet);
}


int TerminateShadowLog(
    )
{
    int iRet = -1;
    if (fLogInit)
    {
        iRet = WriteLog();
        Destroy_Semaphore(semLog);
        semLog = 0L;
        fLogInit = 0;
    }
    else
    {
        iRet = 0;
    }
    return (iRet);
}

int FlushLog(
    )
{
    int iRet = 0;
    if (!fLogInit)
    {
        InitShadowLog();
    }
    if (fLogInit==1)
    {
        Wait_Semaphore(semLog, BLOCK_SVC_INTS);
        iRet = WriteLog();
        Signal_Semaphore(semLog);
    }
    else
    {
        iRet = -1;
    }
    return (iRet);
}

#ifdef DEBUG
int WriteLog(
    )
{
    int iRet = -1;
    CSCHFILE hfShadowLog = CSCHFILE_NULL;
    ULONG pos;

    if (fLogInit && vlpszShadowDir)
    {
        if (fPersistLog)
        {
            if (!(hfShadowLog = CreateFileLocal(rgchLogFileName)))
            {
                KdPrint(("WriteLog: Couldn't open log file\r\n"));
                goto bailout;
            }
            if(GetFileSizeLocal(hfShadowLog, &pos))
            {
                KdPrint(("ShadowLog: log file error\r\n"));
                goto bailout;
            }
            if ((pos+indxCur) > ulMaxLogSize)
            {
#if 0
                CloseFileLocal(hfShadowLog);
                DeleteFileLocal(lpszLogAlt, ATTRIB_DEL_ANY);
                RenameFileLocal(szLog, szLogAlt);
                if (!(hfShadowLog = CreateFileLocal(szLog)))
                {
                    KdPrint(("WriteLog: Couldn't open shadow file\r\n"));
                    goto bailout;
                }
#endif
                pos=0;  // wraparound the logfile
            }
            if (WriteFileLocal(hfShadowLog, pos, lpLogBuff, indxCur) != indxCur)
            {
                KdPrint(("ShadowLog: error writing the log at position %x \r\n", pos));
                goto bailout;
            }
        }

        iRet = 0;
    }
bailout:
    if (hfShadowLog)
    {
        CloseFileLocal(hfShadowLog);
    }

    // no matter what happens, reset the index to 0
    indxCur = 0;
    return iRet;
}
#else
int
WriteLog(
    VOID
    )
{
    // no matter what happens, reset the index to 0
    indxCur = 0;
    return 1;
}
#endif  //DEBUG

void EnterLogCrit(void)
{
    ENTERCRIT_LOG;
}

void LeaveLogCrit(void)
{
    LEAVECRIT_LOG;
}

/*
 *      PrintNetTime
 *
 *      Adds a time and a date to the end of a string.
 *      Time is seconds since 1/1/70.
 *
 */
void PrintNetTime(LONG ltime)
{
    TIME tm;
    int d1, d2, d3;

    ExplodeTime( ltime, &tm );
    d1 = tm.month; d2 = tm.day; d3 = tm.year%100;

    PrintLog(szTimeDateFormat, tm.hours, tm.minutes, tm.seconds, d1, d2, d3);
}

/*
 *      PrintNetTime
 *
 *      Adds a time and a date to the end of a string.
 *      Time is seconds since 1/1/70.
 *
 */
void PrintNetShortTime( LONG ltime
    )
{
    TIME tm;

    ExplodeTime( ltime, &tm );

    PrintLog(szTimeFormat, tm.hours, tm.minutes, tm.seconds);
}

int PrintLog(
    LPSTR lpFmt,
    ...
    )
{
    indxCur += vxd_vsprintf(lpLogBuff+indxCur, lpFmt, (LPSTR)&lpFmt+sizeof(lpFmt));
    return(0);
}

VOID
_cdecl
DbgPrintLog(
    LPSTR lpFmt,
    ...
)
{
    ENTERCRIT_LOG;
    indxCur += vxd_vsprintf(lpLogBuff+indxCur, lpFmt, (LPSTR)&lpFmt+sizeof(lpFmt));
    LEAVECRIT_LOG;
}

void ExplodeTime( ULONG time, LPTIME lpTime )
{
    ULONG date;
    WORD cLeaps;
    LONG days;
    WORD dpy;
    int i;

    time -= BIAS_70_TO_80;

    date = time / DAYSECONDS;
    time %= DAYSECONDS;

    lpTime->seconds = (WORD)(time % 60L);
    time /= 60L;
    lpTime->minutes = (WORD)(time % 60L);
    lpTime->hours = (WORD)(time / 60L);

    cLeaps = (WORD)(date / FOURYEARS);              // # of full leap years
    days = date % FOURYEARS;                // remaining days

    lpTime->year = cLeaps * 4 + 1980;       // correct year
    MonTab[1] = 29;                                 // set # days in Feb for leap years
    dpy = 366;
    days -= dpy;
    if (days >= 0) {                                // this is not a leap year
        dpy--;
        while (days >= 0) {
            lpTime->year++;
            days -= dpy;
        }
        MonTab[1] = 28;                 // set # days in Feb for non-leap years
    }

    days += dpy;                            // days = # days left in this year

    for (i=0; days >= MonTab[i]; i++)
        days -= MonTab[i];

    lpTime->month = (WORD)i + 1;                    // calculate 1-based month
    lpTime->day = (WORD)days + 1;   // calculate 1-based day
}


void LogVfnDelete( PIOREQ    pir
    )
{
    TIME tm;
#ifdef DEBUG
    ++cntVfnDelete;
#endif //DEBUG
    if (fLog)
    {
    ENTERCRIT_LOG;
    memset(logpathbuff, 0, sizeof(logpathbuff));
        UniToBCSPath(logpathbuff, &pir->ir_ppath->pp_elements[0], MAX_PATH, BCS_OEM);
    logpathbuff[MAX_PATH]=0;
    LogPreamble(VFNLOG_DELETE, logpathbuff, pir->ir_error, szCR);
    LEAVECRIT_LOG;
    }
}

void LogVfnDir( PIOREQ    pir
    )
{
#ifdef DEBUG
    if (pir->ir_flags == CREATE_DIR)
    ++cntVfnCreateDir;
    else if (pir->ir_flags == DELETE_DIR)
    ++cntVfnDeleteDir;
    else
    ++cntVfnCheckDir;
#endif //DEBUG

    if (fLog)
    {
    ENTERCRIT_LOG;
    UniToBCSPath(logpathbuff, &pir->ir_ppath->pp_elements[0], MAX_PATH, BCS_OEM);
    logpathbuff[MAX_PATH]=0;
    if (pir->ir_flags==CREATE_DIR)
        LogPreamble(VFNLOG_CREATE_DIR, logpathbuff, pir->ir_error, szCR);
    else if (pir->ir_flags==DELETE_DIR)
        LogPreamble(VFNLOG_DELETE_DIR, logpathbuff, pir->ir_error, szCR);
    else if (pir->ir_flags==CHECK_DIR)
        LogPreamble(VFNLOG_CHECK_DIR, logpathbuff, pir->ir_error, szCR);
    else if (pir->ir_flags==QUERY83_DIR)
    {
        LogPreamble(VFNLOG_QUERY83_DIR, logpathbuff, pir->ir_error, NULL);
        UniToBCSPath(logpathbuff, &pir->ir_ppath2->pp_elements[0], MAX_PATH, BCS_OEM);
        ShadowLog(" %s\r\n", logpathbuff);
    }
    else
    {
        LogPreamble(VFNLOG_QUERYLONG_DIR, logpathbuff, pir->ir_error, NULL);
        UniToBCSPath(logpathbuff, &pir->ir_ppath2->pp_elements[0], MAX_PATH, BCS_OEM);
        ShadowLog(" %s\r\n", logpathbuff);
    }

    LEAVECRIT_LOG;
    }
}


void LogVfnFileAttrib( PIOREQ    pir
    )
{
#ifdef DEBUG
    if (pir->ir_flags == GET_ATTRIBUTES)
    ++cntVfnGetAttrib;
    else
    ++cntVfnSetAttrib;

#endif //DEBUG
    if (fLog)
    {
    ENTERCRIT_LOG;
    memset(logpathbuff, 0, sizeof(logpathbuff));
        UniToBCSPath(logpathbuff, &pir->ir_ppath->pp_elements[0], MAX_PATH, BCS_OEM);

    if (pir->ir_flags == GET_ATTRIBUTES)
    {
        LogPreamble(VFNLOG_GET_ATTRB, logpathbuff, pir->ir_error, NULL);
        ShadowLog(rgsLogCmd[VFNLOG_GET_ATTRB].lpFmt, pir->ir_attr);
    }
    else
    {
        LogPreamble(VFNLOG_SET_ATTRB, logpathbuff, pir->ir_error, NULL);
        ShadowLog(rgsLogCmd[VFNLOG_SET_ATTRB].lpFmt, pir->ir_attr);
    }
    LEAVECRIT_LOG;
    }
}


void LogVfnFlush( PIOREQ    pir
    )
{

#ifdef DEBUG
    ++cntVfnFlush;
#endif //DEBUG

    if (fLog)
    {
    ENTERCRIT_LOG;
    PpeToSvr(((PRESOURCE)(pir->ir_rh))->pp_elements, logpathbuff, sizeof(logpathbuff), BCS_OEM);
    LogPreamble(VFNLOG_FLUSH, logpathbuff, pir->ir_error, szCR);
    LEAVECRIT_LOG;
    }
}


void LogVfnGetDiskInfo( PIOREQ    pir
    )
{
    if (fLog)
    {
    ENTERCRIT_LOG;
    PpeToSvr(((PRESOURCE)(pir->ir_rh))->pp_elements, logpathbuff, sizeof(logpathbuff), BCS_OEM);
    LogPreamble(VFNLOG_GETDISKINFO, logpathbuff, pir->ir_error, szCR);
    LEAVECRIT_LOG;
    }
}


void LogVfnGetDiskParms( PIOREQ    pir
    )
{
#ifdef DEBUG
    ++cntVfnGetDiskParms;
#endif //DEBUG
    if (fLog)
    {
    ENTERCRIT_LOG;
    PpeToSvr(((PRESOURCE)(pir->ir_rh))->pp_elements, logpathbuff, sizeof(logpathbuff), BCS_OEM);
    LogPreamble(VFNLOG_GETDISKPARAMS, logpathbuff, pir->ir_error, szCR);
    LEAVECRIT_LOG;
    }
}

void LogVfnOpen( PIOREQ    pir
    )
{
#ifdef DEBUG
    ++cntVfnOpen;
#endif //DEBUG
    if (fLog)
    {
    ENTERCRIT_LOG;
    memset(logpathbuff, 0, sizeof(logpathbuff));
        UniToBCSPath(logpathbuff, &pir->ir_ppath->pp_elements[0], MAX_PATH, BCS_OEM);
    logpathbuff[MAX_PATH]=0;
    LogPreamble(VFNLOG_OPEN, logpathbuff, pir->ir_error, NULL);
    ShadowLog(rgsLogCmd[VFNLOG_OPEN].lpFmt,(ULONG)(pir->ir_flags), (ULONG)(pir->ir_options)
        , (ULONG)(pir->ir_attr), (ULONG)(pir->ir_size));
    PrintNetTime(IFSMgr_DosToNetTime(pir->ir_dostime));
    ShadowLog(szCR);
    LEAVECRIT_LOG;
    }
}

void LogVfnRename( PIOREQ    pir
    )
{
#ifdef DEBUG
    ++cntVfnRename;
#endif //DEBUG
    if (fLog)
    {
    ENTERCRIT_LOG;
    memset(logpathbuff, 0, sizeof(logpathbuff));
        UniToBCSPath(logpathbuff, &pir->ir_ppath->pp_elements[0], MAX_PATH, BCS_OEM);
    logpathbuff[MAX_PATH]=0;
    LogPreamble(VFNLOG_RENAME, logpathbuff, pir->ir_error, NULL);
    UniToBCSPath(logpathbuff, &pir->ir_ppath2->pp_elements[0], MAX_PATH, BCS_OEM);
    logpathbuff[MAX_PATH]=0;
    ShadowLog(rgsLogCmd[VFNLOG_RENAME].lpFmt, logpathbuff);
    LEAVECRIT_LOG;
    }
}

void LogVfnSearch( PIOREQ    pir
    )
{
    srch_entry *pse = (srch_entry *)(pir->ir_data);
    char szName[sizeof(pse->se_name)+1];
#ifdef DEBUG
    if (pir->ir_flags == SEARCH_FIRST)
    ++cntVfnSearchFirst;
    else
    ++cntVfnSearchNext;

#endif //DEBUG

    if (fLog)
    {
    ENTERCRIT_LOG;
    // BUGBUG expand this
    memset(szName, 0, sizeof(szName));
    memcpy(logpathbuff, pse->se_name, sizeof(pse->se_name));
    if (pir->ir_flags == SEARCH_FIRST)
    {
        memset(logpathbuff, 0, sizeof(logpathbuff));
        UniToBCSPath(logpathbuff, &pir->ir_ppath->pp_elements[0], MAX_PATH, BCS_OEM);
        LogPreamble(VFNLOG_SRCHFRST, logpathbuff, pir->ir_error, NULL);
        ShadowLog(rgsLogCmd[VFNLOG_SRCHFRST].lpFmt, pir->ir_attr, szName);
    }
    else
    {
        LogPreamble(VFNLOG_SRCHNEXT, szDummy, pir->ir_error, NULL);
        ShadowLog(rgsLogCmd[VFNLOG_SRCHNEXT].lpFmt, szName);
    }
    LEAVECRIT_LOG;
    }
}

void LogVfnQuery( PIOREQ    pir,
    USHORT    options
    )
{
#ifdef DEBUG
    ++cntVfnQuery;
#endif //DEBUG
    if (fLog)
    {
    ENTERCRIT_LOG;
    memset(logpathbuff, 0, sizeof(logpathbuff));
    PpeToSvr(((PRESOURCE)(pir->ir_rh))->pp_elements, logpathbuff, sizeof(logpathbuff), BCS_OEM);
    if (options==0)
    {
        LogPreamble(VFNLOG_QUERY0, logpathbuff, pir->ir_error, szCR);
    }
    if (options==1)
    {
        LogPreamble(VFNLOG_QUERY0, logpathbuff, pir->ir_error, NULL);
        ShadowLog(rgsLogCmd[VFNLOG_QUERY1].lpFmt, (ULONG)(pir->ir_options));
    }
    else if (options==2)
    {
        LogPreamble(VFNLOG_QUERY0, logpathbuff, pir->ir_error, NULL);
        ShadowLog(rgsLogCmd[VFNLOG_QUERY2].lpFmt, (ULONG)(pir->ir_options), (ULONG)(pir->ir_length >> 16), (ULONG)(pir->ir_length & 0xffff));
    }

    LEAVECRIT_LOG;
    }
}

void LogVfnConnect( PIOREQ    pir
    )
{
#ifdef DEBUG
    ++cntVfnConnect;
#endif //DEBUG
    if (fLog)
    {
    ENTERCRIT_LOG;
    memset(logpathbuff, 0, sizeof(logpathbuff));
    UniToBCSPath(logpathbuff, &pir->ir_ppath->pp_elements[0], MAX_PATH, BCS_OEM);
    LogPreamble(VFNLOG_CONNECT, logpathbuff, pir->ir_error, NULL);
    ShadowLog(rgsLogCmd[VFNLOG_CONNECT].lpFmt, pir->ir_flags);
    LEAVECRIT_LOG;
    }
}

void LogVfnDisconnect( PIOREQ    pir
    )
{
#ifdef DEBUG
    ++cntVfnDisconnect;
#endif //DEBUG
    if (fLog)
    {
    ENTERCRIT_LOG;
    PpeToSvr(((PRESOURCE)(pir->ir_rh))->pp_elements, logpathbuff, sizeof(logpathbuff), BCS_OEM);
    LogPreamble(VFNLOG_DISCONNECT, logpathbuff, pir->ir_error, szCR);
    WriteLog();
//        TerminateShadowLog();
    LEAVECRIT_LOG;
    }
}

void LogVfnUncPipereq(
    PIOREQ    pir
    )
{
#ifdef DEBUG
    ++cntVfnUncPipereq;
#endif //DEBUG
}

void LogVfnIoctl16Drive (
    PIOREQ    pir
    )
{
#ifdef DEBUG
    ++cntVfnIoctl16Drive ;
#endif //DEBUG
}

void LogVfnDasdIO(
    PIOREQ    pir
    )
{
#ifdef DEBUG
    ++cntVfnDasdIO;
#endif //DEBUG
}


void LogVfnFindOpen( PIOREQ    pir
    )
{
#ifdef DEBUG
    ++cntVfnFindOpen;
#endif //DEBUG
    if (fLog)
    {
    ENTERCRIT_LOG;
    memset(logpathbuff, 0, sizeof(logpathbuff));
        UniToBCSPath(logpathbuff, &pir->ir_ppath->pp_elements[0], MAX_PATH, BCS_OEM);
    logpathbuff[MAX_PATH]=0;
    LogPreamble(VFNLOG_FINDOPEN, logpathbuff, pir->ir_error, NULL);
    if (!pir->ir_error)
    {
        memset(logpathbuff, 0, sizeof(logpathbuff));
        UniToBCS(logpathbuff, ((LPFIND32)(pir->ir_data))->cFileName, sizeof(((LPFIND32)(pir->ir_data))->cFileName)
            , sizeof(logpathbuff)-1, BCS_OEM);
        ShadowLog(rgsLogCmd[VFNLOG_FINDOPEN].lpFmt, pir->ir_attr, logpathbuff);
    }
    else
    {
        ShadowLog(szCR);
    }
    LEAVECRIT_LOG;
    }
}

void LogHfnFindNext( PIOREQ    pir
    )
{
#ifdef DEBUG
    ++cntHfnFindNext;
#endif //DEBUG
    if (fLog)
    {
    ENTERCRIT_LOG;
    LogPreamble(HFNLOG_FINDNEXT, szDummy, pir->ir_error, NULL);

    if (!pir->ir_error)
    {
        memset(logpathbuff, 0, sizeof(logpathbuff));
        UniToBCS(logpathbuff, ((LPFIND32)(pir->ir_data))->cFileName, sizeof(((LPFIND32)(pir->ir_data))->cFileName)
            , sizeof(logpathbuff)-1, BCS_OEM);
        ShadowLog(rgsLogCmd[HFNLOG_FINDNEXT].lpFmt, logpathbuff);
    }
    else
    {
        ShadowLog(szCR);
    }
    LEAVECRIT_LOG;
    }
}

void LogHfnFindClose( PIOREQ    pir
    )
{
#ifdef DEBUG
    ++cntHfnFindClose;
#endif //DEBUG
    if (fLog)
    {
    ENTERCRIT_LOG;
    LogPreamble(HFNLOG_FINDCLOSE, szDummy, pir->ir_error, szCR);
    LEAVECRIT_LOG;
    }
}

void LogHfnRead
    (
    PIOREQ    pir
    )
{
#ifdef DEBUG
    ++cntHfnRead;
#endif //DEBUG
#ifdef MAYBE
    Incr64Bit(cbReadHigh, cbReadLow, (ULONG)(pir->ir_length));
#endif //MAYBE
    if (fLog)
    {
    PFILEINFO pFileInfo = (PFILEINFO)(pir->ir_fh);
    ENTERCRIT_LOG;
    memset(logpathbuff, 0, sizeof(logpathbuff));
    UniToBCSPath(logpathbuff, &(pFileInfo->pFdb->sppathRemoteFile.pp_elements[0]), MAX_PATH, BCS_OEM);
    LogPreamble(HFNLOG_READ, logpathbuff, pir->ir_error, NULL);
    ShadowLog(rgsLogCmd[HFNLOG_READ].lpFmt,
                (ULONG)(pir->ir_pos)-(ULONG)(pir->ir_length),
                (ULONG)(pir->ir_length));
    LEAVECRIT_LOG;
    }
}

void LogHfnWrite
    (
    PIOREQ    pir
    )
{
#ifdef DEBUG
    ++cntHfnWrite;
#endif //DEBUG
#ifdef MAYBE
    Incr64Bit(cbWriteHigh, cbWriteLow, (ULONG)(pir->ir_length));
#endif //MAYBE
    if (fLog)
    {
    PFILEINFO pFileInfo = (PFILEINFO)(pir->ir_fh);
    ENTERCRIT_LOG;
    memset(logpathbuff, 0, sizeof(logpathbuff));
    UniToBCSPath(logpathbuff, &(pFileInfo->pFdb->sppathRemoteFile.pp_elements[0]), MAX_PATH, BCS_OEM);
    LogPreamble(HFNLOG_WRITE, logpathbuff, pir->ir_error, NULL);
    ShadowLog(rgsLogCmd[HFNLOG_WRITE].lpFmt,
                (ULONG)(pir->ir_pos)-(ULONG)(pir->ir_length),
                (ULONG)(pir->ir_length));
    LEAVECRIT_LOG;
    }
}

void LogHfnClose
    (
    PIOREQ    pir,
    int closetype
    )
{
#ifdef DEBUG
    ++cntHfnClose;
#endif //DEBUG
    if (fLog)
    {
    PFILEINFO pFileInfo = (PFILEINFO)(pir->ir_fh);
    ENTERCRIT_LOG;
    memset(logpathbuff, 0, sizeof(logpathbuff));
    UniToBCSPath(logpathbuff, &(pFileInfo->pFdb->sppathRemoteFile.pp_elements[0]), MAX_PATH, BCS_OEM);
    LogPreamble(HFNLOG_CLOSE, logpathbuff, pir->ir_error, NULL);
    ShadowLog(rgsLogCmd[HFNLOG_CLOSE].lpFmt, closetype);
    LEAVECRIT_LOG;
    }
}

void LogHfnSeek
    (
    PIOREQ    pir
    )
{
#ifdef DEBUG
    ++cntHfnSeek;
#endif //DEBUG
    if (fLog)
    {
    PFILEINFO pFileInfo = (PFILEINFO)(pir->ir_fh);
    ENTERCRIT_LOG;
    memset(logpathbuff, 0, sizeof(logpathbuff));
    UniToBCSPath(logpathbuff, &(pFileInfo->pFdb->sppathRemoteFile.pp_elements[0]), MAX_PATH, BCS_OEM);
    LogPreamble(HFNLOG_SEEK, logpathbuff, pir->ir_error, NULL);
    ShadowLog(rgsLogCmd[HFNLOG_SEEK].lpFmt, (ULONG)(pir->ir_pos), pir->ir_flags);
    LEAVECRIT_LOG;
    }
}

void LogHfnCommit
    (
    PIOREQ    pir
    )
{
#ifdef DEBUG
    ++cntHfnCommit;
#endif //DEBUG
    if (fLog)
    {
    PFILEINFO pFileInfo = (PFILEINFO)(pir->ir_fh);
    ENTERCRIT_LOG;
    memset(logpathbuff, 0, sizeof(logpathbuff));
    UniToBCSPath(logpathbuff, &(pFileInfo->pFdb->sppathRemoteFile.pp_elements[0]), MAX_PATH, BCS_OEM);
    LogPreamble(HFNLOG_COMMIT, logpathbuff, pir->ir_error, szCR);
    LEAVECRIT_LOG;
    }
}


void LogHfnFileLocks
    (
    PIOREQ    pir
    )
{
#ifdef DEBUG
    if (pir->ir_flags == LOCK_REGION)
    ++cntHfnSetFileLocks;
    else
    ++cntHfnRelFileLocks;
#endif //DEBUG
    if (fLog)
    {
    PFILEINFO pFileInfo = (PFILEINFO)(pir->ir_fh);
    ENTERCRIT_LOG;
    memset(logpathbuff, 0, sizeof(logpathbuff));
    UniToBCSPath(logpathbuff, &(pFileInfo->pFdb->sppathRemoteFile.pp_elements[0]), MAX_PATH, BCS_OEM);
    LogPreamble((pir->ir_flags==LOCK_REGION)?HFNLOG_FLOCK:HFNLOG_FUNLOCK, logpathbuff, pir->ir_error, NULL);
    if (!pir->ir_error)
    {
        ShadowLog(rgsLogCmd[HFNLOG_FLOCK].lpFmt
            , pir->ir_pos
            , pir->ir_locklen);
    }
    else
    {
        ShadowLog(szCR);
    }
    LEAVECRIT_LOG;
    }
}

void LogHfnFileTimes
    (
    PIOREQ    pir
    )
{
#ifdef DEBUG
    if ((pir->ir_flags == GET_MODIFY_DATETIME)||(pir->ir_flags == GET_LAST_ACCESS_DATETIME))
    ++cntHfnGetFileTimes;
    else
    ++cntHfnSetFileTimes;
#endif //DEBUG
    if (fLog)
    {
    PFILEINFO pFileInfo = (PFILEINFO)(pir->ir_fh);
    int indxFn = pir->ir_flags;

    if (indxFn==GET_MODIFY_DATETIME)
    {
        indxFn = HFNLOG_GET_TIME;
    }
    else if (indxFn==SET_MODIFY_DATETIME)
    {
        indxFn = HFNLOG_SET_TIME;
    }
    else if (indxFn==GET_LAST_ACCESS_DATETIME)
    {
        indxFn = HFNLOG_GET_LATIME;
    }
    else
    {
        indxFn = HFNLOG_SET_LATIME;
    }

    ENTERCRIT_LOG;
    memset(logpathbuff, 0, sizeof(logpathbuff));
    UniToBCSPath(logpathbuff, &(pFileInfo->pFdb->sppathRemoteFile.pp_elements[0]), MAX_PATH, BCS_OEM);
    LogPreamble(indxFn, logpathbuff, pir->ir_error, NULL);
    if (!pir->ir_error)
    {
        PrintNetTime(IFSMgr_DosToNetTime(pir->ir_dostime));
    }
    ShadowLog(szCR);

    LEAVECRIT_LOG;
    }
}

void LogHfnPipeRequest
    (
    PIOREQ pir
    )
{
}

void LogHfnHandleInfo(
    PIOREQ    pir
    )
{
    if (fLog)
    {
    PFILEINFO pFileInfo = (PFILEINFO)(pir->ir_fh);

    ENTERCRIT_LOG;
    memset(logpathbuff, 0, sizeof(logpathbuff));
    UniToBCSPath(logpathbuff, &(pFileInfo->pFdb->sppathRemoteFile.pp_elements[0]), MAX_PATH, BCS_OEM);
    LogPreamble(HFNLOG_ENUMHANDLE, logpathbuff, pir->ir_error, NULL);
    ShadowLog(szCR);
    LEAVECRIT_LOG;
    }
}

void LogHfnEnumHandle(
    PIOREQ    pir
    )
{
    if (fLog)
    {
    PFILEINFO pFileInfo = (PFILEINFO)(pir->ir_fh);
    ENTERCRIT_LOG;
    memset(logpathbuff, 0, sizeof(logpathbuff));
    UniToBCSPath(logpathbuff, &(pFileInfo->pFdb->sppathRemoteFile.pp_elements[0]), MAX_PATH, BCS_OEM);
    LogPreamble(HFNLOG_ENUMHANDLE, logpathbuff, pir->ir_error, NULL);
    ShadowLog(rgsLogCmd[HFNLOG_ENUMHANDLE].lpFmt, pir->ir_flags);
    LEAVECRIT_LOG;
    }
}

void LogTiming(
    int verbosity,
    int stage
    )
{
    if (fLog >= verbosity)
    {
    ShadowLog("%s: ", (stage==STAGE_BEGIN)
                ?szBegin:((stage==STAGE_END)?szEnd:szContinue));
    PrintNetShortTime(IFSMgr_Get_NetTime());
    ShadowLog(szCR);
    }
}


void LogPreamble( int    indxFn,
    LPSTR lpSubject,
    int    errCode,
    LPSTR lpPreTerm
    )
{
    TIME tm;

    ExplodeTime(IFSMgr_Get_NetTime(), &tm);
    ShadowLog(szPreFmt
            , rgsLogCmd[indxFn].lpCmd
            , tm.hours, tm.minutes, tm.seconds
            , errCode
            , lpSubject);
    if (lpPreTerm)
    {
    ShadowLog(lpPreTerm);
    }
}


#ifdef MAYBE
int Incr64Bit(
    ULONG uHigh,
    ULONG uLow,
    ULONG uIncr
    )
{
    ULONG uTemp = uLow;

    uLow += uIncr;
    if (uLow < uTemp)
    ++uHigh;
    return 1;
}
#endif //MAYBE

#ifdef DEBUG
int WriteStats( BOOL fForce)
{
    ULONG cntTotal;
    SHADOWSTORE sSS;

    cntTotal =  cntVfnDelete+ cntVfnCreateDir+ cntVfnDeleteDir+ cntVfnCheckDir+ cntVfnGetAttrib+
            cntVfnSetAttrib+ cntVfnFlush+ cntVfnGetDiskInfo+ cntVfnOpen+
            cntVfnRename+ cntVfnSearchFirst+ cntVfnSearchNext+
            cntVfnQuery+ cntVfnDisconnect+ cntVfnUncPipereq+ cntVfnIoctl16Drive+
            cntVfnGetDiskParms+ cntVfnFindOpen+ cntVfnDasdIO+
            cntHfnFindNext+ cntHfnFindClose+
            cntHfnRead+ cntHfnWrite+ cntHfnSeek+ cntHfnClose+ cntHfnCommit+
            cntHfnSetFileLocks+ cntHfnRelFileLocks+ cntHfnGetFileTimes+ cntHfnSetFileTimes+
            cntHfnPipeRequest+ cntHfnHandleInfo+ cntHfnEnumHandle;

    ShadowLog("\r!***** Stats Begin *******\r");

    PrintNetTime(IFSMgr_Get_NetTime());
    ShadowLog("\r");
    if (!fForce && (cntTotal == cntLastTotal))
    {
    KdPrint(("No new network activity \r"));
    goto bailout;
    }
    cntLastTotal = cntTotal;
    if (!cntTotal)
    {
    cntTotal = 1;
    }
    ShadowLog("Total remote operations=%d \r", cntTotal);

    GetShadowSpaceInfo(&sSS);
    ShadowLog("Space used=%d, Files=%d, Dirs=%d\r",
        sSS.sCur.ulSize, sSS.sCur.ucntFiles, sSS.sCur.ucntDirs);

    ShadowLog("\rFile Operations:\r");
    ShadowLog("Open=%d%%, Close=%d%% \r",
            (cntVfnOpen * 100/cntTotal),
            (cntHfnClose * 100/cntTotal));

    ShadowLog("Read=%d%%, Write=%d%%, Seek=%d%%\r",
            (cntHfnRead * 100/cntTotal),
            (cntHfnWrite * 100/cntTotal),
            (cntHfnSeek * 100/cntTotal));
    if (!cntHfnRead)
    {
    cntHfnRead = 1;
    }
    ShadowLog("ReadHits=%d%% of total reads\r", (cntReadHits*100)/cntHfnRead);

    ShadowLog("GetFileTime=%d%% SetFileTime=%d%%\r",
            (cntHfnGetFileTimes * 100/cntTotal),
            (cntHfnSetFileTimes * 100/cntTotal));


    ShadowLog("SetLock=%d%%, ReleaseLock=%d%% \r",
            (cntHfnSetFileLocks * 100/cntTotal),
            (cntHfnRelFileLocks * 100/cntTotal));

    ShadowLog("Directory Operations: ");
    ShadowLog("CreateDir=%d%%, DeleteDir=%d%%, CheckDir=%d%% \r",
            (cntVfnCreateDir*100/cntTotal),
            (cntVfnDeleteDir*100/cntTotal),
            (cntVfnCheckDir*100/cntTotal));

    ShadowLog("Find/Search Operations:\r");
    ShadowLog("FindOpen=%d%%, FindNext=%d%%, FindClose=%d%% \r",
            (cntVfnFindOpen * 100/cntTotal),
            (cntHfnFindNext * 100/cntTotal),
            (cntHfnFindClose * 100/cntTotal));
    ShadowLog("SearchFirst=%d%%, SearchNext=%d%%\r",
            (cntVfnSearchFirst * 100/cntTotal),
            (cntVfnSearchNext * 100/cntTotal));

    ShadowLog("Attributes: ");
    ShadowLog("SetAttributes=%d%%, GetAttributes=%d%%\r",
            (cntVfnSetAttrib * 100/cntTotal),
            (cntVfnGetAttrib * 100/cntTotal));

    ShadowLog("Name Mutations: ");
    ShadowLog("Rename=%d%%, Delete=%d%% \r",
            (cntVfnRename * 100/cntTotal),
            (cntVfnDelete * 100/cntTotal));

bailout:
    ShadowLog("\r***** Stats End ******* \r");
    return 1;
}

void ShadowRestrictedEventCallback
    (
    )
{
    FlushLog();
    ENTERCRIT_LOG;
    WriteStats(0); // Don't force him to write
    LEAVECRIT_LOG;
    FlushLog();
}
#endif //DEBUG

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\record.mgr\hookcmmn.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    HookCmmn.c

Abstract:

    The purpose of this module is to have a common source for many routines
    used by the hook on win95 and on NT. In this way, there'll be only one
    place to change even if there's some code uglyness (ifdefs, etc.)

    Initially, i (jll) have not actually removed any routines from the win95
    hook....i have just made copies of them here. accordingly, everything is
    initially under ifdef-NT. the rule that is being used is that anything that
    requires visibility of the Rx Fcb structures will not be included here;
    rather, it'll be in the minirdr part. the following are steps that need to be
    accomplished:

       1. ensure that the win95 shadow vxd can be built from these sources.
       1a. juggle the win95 vxd compile to use precomp and stdcall.
       2. juggle the record manager structs so that we'll be RISCable
       3. remove any routines from hook.h that are actually here.
       4. remove a number of other routines that i splated around from hook.c
          under NT-ifdef and place them here.

Author:

    Shishir Pardikar     [Shishirp]      01-jan-1995

Revision History:

    Joe Linn             [JoeLinn]       10-mar-97    Initial munging for NT

--*/

#include "precomp.h"
#pragma hdrstop

#pragma code_seg("PAGE")

#undef RxDbgTrace
#define RxDbgTrace(a,b,__d__) {qweee __d__;}

#ifdef DEBUG
//cshadow dbgprint interface
#define HookCmmnKdPrint(__bit,__x) {\
    if (((HOOKCMMN_KDP_##__bit)==0) || FlagOn(HookCmmnKdPrintVector,(HOOKCMMN_KDP_##__bit))) {\
        KdPrint (__x);\
    }\
}
#define HOOKCMMN_KDP_ALWAYS                 0x00000000
#define HOOKCMMN_KDP_BADERRORS              0x00000001
#define HOOKCMMN_KDP_ISSPECIALAPP           0x00000002
#define HOOKCMMN_KDP_INITDATABASE           0x00000004
#define HOOKCMMN_KDP_TUNNELING              0x00000008


#define HOOKCMMN_KDP_GOOD_DEFAULT (HOOKCMMN_KDP_BADERRORS         \
                                    | 0)

ULONG HookCmmnKdPrintVector = HOOKCMMN_KDP_GOOD_DEFAULT;
ULONG HookCmmnKdPrintVectorDef = HOOKCMMN_KDP_GOOD_DEFAULT;
#else
#define HookCmmnKdPrint(__bit,__x)  {NOTHING;}
#endif

//this is just for editing ease......
//#ifdef CSC_RECORDMANAGER_WINNT
//#endif //ifdef CSC_RECORDMANAGER_WINNT


#ifdef CSC_RECORDMANAGER_WINNT
BOOL fInitDB = FALSE;   // Database Initialized
BOOL fReadInit = FALSE; // Init values have been read
BOOL fSpeadOpt = TRUE;  // spead option, reads the cached files even when
                        // locks are set on the share
GLOBALSTATUS sGS;       // Global status used for communicating with ring3

// Semaphore used to synchronize in memory structures
VMM_SEMAPHORE  semHook;

// This strucutre is used as temporary I/O buffer only within Shadow critical
// section
WIN32_FIND_DATA   vsFind32;


// Agent Info, obtained through IoctlRegisterAgent
ULONG hthreadReint=0; // Thred ID
ULONG hwndReint=0;    // windows handle.
ULONG heventReint;

// upto 16 threads can temporarily enable and disable shadowing
ULONG rghthreadTemp[16];


// Reintegration happens one share at a time. If it is going on, then BeginReint
// in ioctl.c sets  hShareReint to the share on which we are doing reint
// if vfBlockingReint is TRUE, then all operations on that share will fail
// when the share is reintegrating.
// If vfBlockingReint is not true, then if the dwActivityCount is non-zero
// the ioctls to change any state on any of the descendents of this share fail
// causing the agent to aboort reintegration
// The acitvycount is incremented based on a trigger from the redir/hook, when
// any namespace mutating operation is performed.

HSHARE hShareReint=0;   // Share that is currently being reintegrated
BOOL    vfBlockingReint = TRUE;
DWORD   vdwActivityCount = 0;
//from shadow.asm   ---------------------------------------------------
int fShadow = 0;

#if defined(_X86_)
int fLog = 1;
#else
int fLog = 0;
#endif


//tunnel cache
SH_TUNNEL rgsTunnel[10] = {0};

#ifdef DEBUG
ULONG cntReadHits=0;
tchar pathbuff[MAX_PATH+1];
#endif



BOOL FindTempAgentHandle(
   ULONG hthread)
   {
   int i;

   for (i=0; i < (sizeof(rghthreadTemp)/sizeof(ULONG)); ++i)
      {
      if (rghthreadTemp[i]==hthread)
         {
         return TRUE;
         }
      }
   return FALSE;

   }

BOOL
RegisterTempAgent(
    VOID
)
{
    int i;
    ULONG hthread;

    hthread = GetCurThreadHandle();

    for (i=0; i< (sizeof(rghthreadTemp)/sizeof(ULONG)); ++i)
    {
        if (!rghthreadTemp[i])
        {
            rghthreadTemp[i] = hthread;
            return TRUE;
        }
    }
    return FALSE;
}

BOOL
UnregisterTempAgent(
    VOID
)
{
    int i;
    ULONG hthread;

    hthread = GetCurThreadHandle();

    for (i=0; i < (sizeof(rghthreadTemp)/sizeof(ULONG)); ++i)
    {
        if (rghthreadTemp[i]==hthread)
        {
            rghthreadTemp[i] = 0;
            return TRUE;
        }
    }

    return FALSE;
}

BOOL IsSpecialApp
   (
   VOID
   )
   {
   ULONG hthread;

   hthread = GetCurThreadHandle();
   if ((hthread==hthreadReint) || FindTempAgentHandle(hthread))
      {
      HookCmmnKdPrint(ISSPECIALAPP,("This is our Special App \r\n"));
      return TRUE;
      }
   return FALSE;
   }


#define SetHintsFromList(a,b) ((-1))
int InitShadowDB(VOID)
   {
    //for NT, we don't have all this hint stuff....just return success
    return(1);
#if 0
   VMMHKEY hKeyShadow;
   int iSize = sizeof(int), iRet = -1;
   DWORD dwType;
   extern char vszExcludeList[], vszIncludeList[];
   BOOL fOpen = FALSE;
   char rgchList[128];
   if (_RegOpenKey(HKEY_LOCAL_MACHINE, REG_KEY_SHADOW, &hKeyShadow) ==  ERROR_SUCCESS)
      {
      fOpen = TRUE;
      iSize = sizeof(rgchList);
      if (_RegQueryValueEx(hKeyShadow, vszExcludeList, NULL, &dwType, rgchList, &iSize)==ERROR_SUCCESS)
         {
         if (SetHintsFromList(rgchList, TRUE) < 0)
            goto bailout;
         }
      iSize = sizeof(rgchList);
      if (_RegQueryValueEx(hKeyShadow, vszIncludeList, NULL, &dwType, rgchList, &iSize)==ERROR_SUCCESS)
         {
         if (SetHintsFromList(rgchList, FALSE) < 0)
            goto bailout;
         }

      iRet = 1;
      }
bailout:
   if (fOpen)
      {
      _RegCloseKey(hKeyShadow);
      }
   return (iRet);
#endif //0
   }

int ReinitializeDatabase(
    LPSTR   lpszLocation,
    LPSTR   lpszUserName,
    DWORD   nFileSizeHigh,
    DWORD   nFileSizeLow,
    DWORD   dwClusterSize
    )
{
    BOOL fDBReinited = FALSE;
    if(OpenShadowDB(lpszLocation, lpszUserName, nFileSizeHigh, nFileSizeLow, dwClusterSize, TRUE, &fDBReinited) >= 0)
    {
        if (InitShadowDB() >= 0)
        {
            Assert(fDBReinited == TRUE);
            fInitDB = 1;
        }
        else
        {
            CloseShadowDB();
        }
    }
    if (fInitDB != 1)
    {
        fInitDB = -1;
        fShadow = 0;
    }

    return (fInitDB);
}

int
InitDatabase(
    LPSTR   lpszLocation,
    LPSTR   lpszUserName,
    DWORD   nFileSizeHigh,
    DWORD   nFileSizeLow,
    DWORD   dwClusterSize,
    BOOL    fReformat,
    BOOL    *lpfNew
)
{
    int iRet = 1;
    BOOL fDBReinited = FALSE;
    LPSTR PrefixedLocation = NULL;

    HookCmmnKdPrint(INITDATABASE,("Opening database at %s for %s with size %d \r\n", lpszLocation, lpszUserName, nFileSizeLow));

    //
    // When CSC is started by the kernel as part of a remote boot, the input path
    // will already be in NT format.
    //

    if (( _strnicmp(lpszLocation,"\\Device\\Harddisk",strlen("\\Device\\Harddisk")) != 0 ) &&
        ( _strnicmp(lpszLocation,"\\ArcName",strlen("\\ArcName")) != 0 )) {

        //this would be NT only..........
        PrefixedLocation = AllocMem(strlen(lpszLocation)+sizeof(NT_DB_PREFIX));

        if (!PrefixedLocation)
        {
            return -1;
        }

        strcpy(PrefixedLocation, NT_DB_PREFIX);
        strcat(PrefixedLocation, lpszLocation);
        HookCmmnKdPrint(INITDATABASE,("Opening database at %s changing to %s \r\n", lpszLocation, PrefixedLocation));

        //fortunately, this is call-by-value....so i can just overwrite the input parameter
        lpszLocation = PrefixedLocation;
    }


    // Do onetime init
    if (!fReadInit)
    {
        ReadInitValues();
        memset(rghthreadTemp, 0, sizeof(rghthreadTemp));
        fReadInit = TRUE;
    }

    // check if the database is not already initialized
    if (!fInitDB)
    {
        // open/create it
        iRet = OpenShadowDB(
                    lpszLocation,
                    lpszUserName,
                    nFileSizeHigh,
                    nFileSizeLow,
                    dwClusterSize,
                    fReformat,
                    &fDBReinited
                    );

        // open/create DB succeeded?
        if (iRet < 0)
        {
            //no
            HookCmmnKdPrint(ALWAYS,("Error Opening/Createing shadow database \r\n"));
            fInitDB = -1;
            fShadow = 0;
        }
        else
        {
            *lpfNew = fDBReinited;

            // did it exist in the first place?
            if (fDBReinited)
            {
                // no it didn't, let use create things like the filters and such
                iRet = InitShadowDB();
            }

            if (iRet >= 0)
            {
                fInitDB = 1;
            }
            else
            {
                CloseShadowDB();
            }
        }
    }

    if (PrefixedLocation)
    {
        FreeMem(PrefixedLocation);        
    }
    return (iRet);
}


int
CloseDatabase(
    VOID
    )
{
    if (fInitDB)
    {
        CloseShadowDB();
        fInitDB = FALSE;
        return (1);
    }
    return (0);
}

BOOL IsBusy
   (
   HSHADOW hShadow
   )
   {
   DeclareFindFromShadowOnNtVars()

   if (PFindFdbFromHShadow(hShadow))
      return TRUE;
   return FALSE;
   }


int PRIVATE DeleteShadowHelper
   (
   BOOL        fMarkDeleted,
   HSHADOW     hDir,
   HSHADOW     hNew
        )
        {
   int iRet = -1;

   if (!fMarkDeleted)
      {
      if (DeleteShadow(hDir, hNew) < SRET_OK)
         goto bailout;
      }
   else
      {
      if (TruncateDataHSHADOW(hDir, hNew) < SRET_OK)
            goto bailout;
      // ACHTUNG!! other people depend on status being SHADOW_DELETED
      if (SetShadowInfo(hDir, hNew, NULL, SHADOW_DELETED, SHADOW_FLAGS_OR) < SRET_OK)
         goto bailout;
      }
   iRet = 0;

bailout:

   return (iRet);
        }


/*+-------------------------------------------------------------------------*/
/*    @doc    INTERNAL HOOK
    @func    BOOL | InsertTunnelInfo | 2.0

            The <f InsertTunnelInfo> function inserts file names
            in a tunnelling table. These entries are considered
            useful only for STALE_TUNNEL_INFO seconds. Tunnelling is
            used to retain LPOTHERINFO for files that get renamed/deleted
            and some other file is renamed to it. This typically done
            by editors, spreadsheets and such while saving things.

    @parm    HSHADOW | hDir | Directory to which this guy belongs
    @parm    LPPE | lppe | PathELement for the file to be tunnelled
    @parm    LPOTHERINFO | lpOI | Info to be kept with the tunnelled entry

    @comm    >>comment_text, <p parm> etc...

    @rdesc This function returns TRUE if successful. Otherwise the
        return value is FALSE.
    @xref    >><f related_func>, <t RELATEDSTRUCT> ...
*/


BOOL InsertTunnelInfo(
    HSHADOW      hDir,
    USHORT       *lpcFileName,
    USHORT       *lpcAlternateFileName,  // assume 14 USHORTs
    LPOTHERINFO lpOI
    )
{
    int i, iHole = -1;
    ULONG uTime = IFSMgr_Get_NetTime(), cbFileName;

    cbFileName = (wstrlen(lpcFileName)+1)*sizeof(USHORT);
    ASSERT(hDir!=0);

    FreeStaleEntries();
    for (i=0;i< (sizeof(rgsTunnel)/sizeof(SH_TUNNEL)); ++i)
    {
        if (!rgsTunnel[i].hDir && (iHole < 0))
        {
            iHole = i;
        }
        if ((rgsTunnel[i].hDir==hDir)
            && (!wstrnicmp(lpcFileName, rgsTunnel[i].lpcFileName, MAX_PATH*sizeof(USHORT))||
                !wstrnicmp( lpcFileName,
                            rgsTunnel[i].cAlternateFileName,
                            sizeof(rgsTunnel[i].cAlternateFileName)))
            ) {
            FreeEntry(&rgsTunnel[i]);
            iHole = i;
            break;
        }
    }
    if (iHole >=0)
    {
        if (!(rgsTunnel[iHole].lpcFileName = (USHORT *)AllocMem(cbFileName)))
            {
                return (FALSE);
            }
            rgsTunnel[iHole].uTime = uTime;
            rgsTunnel[iHole].hDir = hDir;
            rgsTunnel[iHole].ubHintFlags = (UCHAR)(lpOI->ulHintFlags);
            rgsTunnel[iHole].ubHintPri = (UCHAR)(lpOI->ulHintPri);
            rgsTunnel[iHole].ubIHPri = (UCHAR)(lpOI->ulIHPri);
            rgsTunnel[iHole].ubRefPri = (UCHAR)(lpOI->ulRefPri);

            // copy without the NULL, we know that allocmem will have a NULL at the end
            memcpy(rgsTunnel[iHole].lpcFileName, lpcFileName, cbFileName-sizeof(USHORT));

            // assumes 14 USHORTS
            memcpy(    rgsTunnel[iHole].cAlternateFileName,
                    lpcAlternateFileName,
                    sizeof(rgsTunnel[iHole].cAlternateFileName));

            HookCmmnKdPrint(TUNNELING,("InsertTunnelInfo: Inserting %ws/%ws, Hintpri=%d, HintFlags=%d RefPri=%d \r\n",
                    lpcFileName,lpcAlternateFileName,
                    lpOI->ulHintPri,
                    lpOI->ulHintFlags,
                    lpOI->ulRefPri
                    ));

            return (TRUE);
    }
    return (FALSE);
}

/*+-------------------------------------------------------------------------*/
/*    @doc    INTERNAL HOOK
    @func    BOOL | RetrieveTunnelInfo | 2.0

            The <f RetrieveTunnelInfo> function returns to the caller
            OTHERINFO structure containing priorities and such about
            files which have been recently renamed or deleted. Entries
            which are older than STALE_TUNNEL_INFO seconds are thrown
            out.

    @parm    HSHADOW | hDir | Directory to which this guy belongs
    @parm    ushort *| lpcFileName| name of the file whose info is needed
    @parm    LPOTHERINFO | lpOI | Info to be retrieved from the tunnelled entry

    @comm    >>comment_text, <p parm> etc...

    @rdesc This function returns TRUE if successful. Otherwise the
        return value is FALSE.
    @xref    >><f related_func>, <t RELATEDSTRUCT> ...
*/


#ifndef MRXSMB_BUILD_FOR_CSC_DCON
BOOL RetrieveTunnelInfo(
#else
RETRIEVE_TUNNEL_INFO_RETURNS
RetrieveTunnelInfo(
#endif
    HSHADOW  hDir,
    USHORT    *lpcFileName,
    WIN32_FIND_DATA    *lpFind32,    // if NULL, get only otherinfo
    LPOTHERINFO lpOI
    )
{
    int i;
#ifdef MRXSMB_BUILD_FOR_CSC_DCON
    RETRIEVE_TUNNEL_INFO_RETURNS RetVal;
#endif

    ASSERT(hDir!=0);
    FreeStaleEntries();
    for (i=0;i< (sizeof(rgsTunnel)/sizeof(SH_TUNNEL)); ++i)
    {
#ifndef MRXSMB_BUILD_FOR_CSC_DCON
        if (rgsTunnel[i].hDir
            && (!wstrnicmp(lpcFileName, rgsTunnel[i].lpcFileName, MAX_PATH*sizeof(USHORT))||
                !wstrnicmp(    lpcFileName,
                            rgsTunnel[i].cAlternateFileName,
                            sizeof(rgsTunnel[i].cAlternateFileName)))
            ) {
#else
        if (rgsTunnel[i].hDir==hDir)
        {
            if (!wstrnicmp(lpcFileName,
                          rgsTunnel[i].cAlternateFileName,
                          sizeof(rgsTunnel[i].cAlternateFileName)) ) {
                RetVal = TUNNEL_RET_SHORTNAME_TUNNEL;
            } else if ( !wstrnicmp(lpcFileName, rgsTunnel[i].lpcFileName, MAX_PATH*sizeof(USHORT))  ){
                RetVal = TUNNEL_RET_LONGNAME_TUNNEL;
            } else {
                continue;
            }

#endif
            InitOtherInfo(lpOI);

            lpOI->ulHintFlags = (ULONG)(rgsTunnel[i].ubHintFlags);
            lpOI->ulHintPri = (ULONG)(rgsTunnel[i].ubHintPri);
            lpOI->ulIHPri = (ULONG)(rgsTunnel[i].ubIHPri);

// don't copy the reference priority, it is assigned by the record manager
//            lpOI->ulRefPri = (ULONG)(rgsTunnel[i].ubRefPri);

            HookCmmnKdPrint(TUNNELING,("RetrieveTunnelInfo: %ws found, Hintpri=%d, HintFlags=%d RefPri=%d \r\n",
                    lpcFileName,
                    lpOI->ulHintPri,
                    lpOI->ulHintFlags,
                    lpOI->ulRefPri
                    ));

            if (lpFind32)
            {
                memcpy( lpFind32->cFileName,
                        rgsTunnel[i].lpcFileName,
                        (wstrlen(rgsTunnel[i].lpcFileName)+1)*sizeof(USHORT)
                        );
                memcpy( lpFind32->cAlternateFileName,
                        rgsTunnel[i].cAlternateFileName,
                        sizeof(rgsTunnel[i].cAlternateFileName)
                        );
                HookCmmnKdPrint(TUNNELING,("Recovered LFN %ws/%ws \r\n",
                                          lpFind32->cFileName,
                                          lpFind32->cAlternateFileName));
            }

            FreeEntry(&rgsTunnel[i]);
#ifndef MRXSMB_BUILD_FOR_CSC_DCON
            return (TRUE);
        }
    }
    return (FALSE);
#else
            return (RetVal);
        }
    }
    return (TUNNEL_RET_NOTFOUND);
#endif
}

VOID  FreeStaleEntries()
{
    int i;
    ULONG uTime = IFSMgr_Get_NetTime();

    for (i=0;i< (sizeof(rgsTunnel)/sizeof(SH_TUNNEL)); ++i)
    {
        if (rgsTunnel[i].lpcFileName
            && ((uTime- rgsTunnel[i].uTime)>STALE_TUNNEL_INFO))
        {
            FreeEntry(&rgsTunnel[i]);
        }
    }

}

void FreeEntry(LPSH_TUNNEL lpshTunnel)
{
    FreeMem(lpshTunnel->lpcFileName);
    memset(lpshTunnel, 0, sizeof(SH_TUNNEL));
}

//got this from hook.c...not the same because w95 looks at the
//resource flags directly
BOOL IsShadowVisible(
#ifdef MRXSMB_BUILD_FOR_CSC_DCON
    BOOLEAN Disconnected,
#else
    PRESOURCE    pResource,
#endif //ifdef MRXSMB_BUILD_FOR_CSC_DCON
    DWORD         dwAttr,
    ULONG     uShadowStatus
    )
{
    BOOL fVisible = 1;

    // To a filesystem API the shadow is never visible when it is marked
    // as being deleted

    if (mShadowDeleted(uShadowStatus))
        return (0);

#ifdef MRXSMB_BUILD_FOR_CSC_DCON
    if (Disconnected)
#else
    if (mIsDisconnected(pResource))
#endif //ifdef MRXSMB_BUILD_FOR_CSC_DCON
    {
        if (IsFile(dwAttr))
        {
#ifdef OFFLINE
#ifdef CSC_RECORDMANAGER_WINNT
            ASSERT(FALSE);
#endif //ifdef CSC_RECORDMANAGER_WINNT
            if (mIsOfflineConnection(pResource))
            { // offline connection
                if (!mShadowOutofSync(uShadowStatus))
                {
                    fVisible = 0;
                }
            }
            else
#endif //OFFLINE
            {// pure disconnected state
                // ignore sparse files
                if (mShadowSparse(uShadowStatus))
                {
                    fVisible = 0;
                }
            }
        }
    }
    else
    {  // connected state, bypass all out of ssync files, doesn't include
            // stale, because we can handle staleness during open
        if (IsFile(dwAttr))
        {
            if (mShadowOutofSync(uShadowStatus))
            {
                fVisible = 0;
            }
        }
        else if (dwAttr & FILE_ATTRIBUTE_DIRECTORY)
        { // and locallycreated or orphaned directories
            if (mQueryBits(uShadowStatus, SHADOW_LOCALLY_CREATED|SHADOW_ORPHAN))
            {
                fVisible = 0;
            }
        }
    }
    return (fVisible);
}


//got this from hook.c...not the same because w95 looks at the
//resource flags directly


//CODE.IMPROVEMENT we should define a common header for RESOURCE and FDB so that most stuff
//   would just work.
int MarkShareDirty(
    PUSHORT ShareStatus,
    ULONG  hShare
    )
{

    if (!mQueryBits(*ShareStatus, SHARE_REINT))
    {
        SetShareStatus(hShare, SHARE_REINT, SHADOW_FLAGS_OR);
        mSetBits(*ShareStatus, SHARE_REINT);
    }
    return SRET_OK;
}

#endif //ifdef CSC_RECORDMANAGER_WINNT

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\record.mgr\hookcmmn.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    HookCmmn.h

Abstract:

    This module defines the routines that are in common between the win9x and nt hooks.

Author:

    JoeLinn [JoeLinn]    8-Apr-1997

Revision History:


--*/

#ifndef __INCLUDED__CSC__HOOKCMMN__
#define __INCLUDED__CSC__HOOKCMMN__

extern ULONG hthreadReint; //BUGBUG why should a thread be a ULONG????
extern ULONG hwndReint;
extern PFILEINFO pFileInfoAgent;
extern HSERVER  hShareReint;    // Share that is currently being reintegrated
extern int fShadow, fLog, fNoShadow, /*fShadowFind,*/ fSpeadOpt;
extern WIN32_FIND_DATA    vsFind32;
extern int cMacPro;
extern NETPRO rgNetPro[];
extern VMM_SEMAPHORE  semHook;
extern GLOBALSTATUS sGS;
extern ULONG proidShadow;
extern ULONG heventReint;


#define FLAG_FDB_SERIALIZE              0x0001
#define FLAG_FDB_INUSE_BY_AGENT         0x0002
#define FLAG_FDB_SHADOW_MODIFIED        0x0008
#define FLAG_FDB_DONT_SHADOW            0x0010
#define FLAG_FDB_FINAL_CLOSE_DONE       0x0020


int ReinitializeDatabase(
    LPSTR   lpszLocation,
    LPSTR   lpszUserName,
    DWORD   nFileSizeHigh,
    DWORD   nFileSizeLow,
    DWORD   dwClusterSize
    );

int
InitDatabase(
    LPSTR   lpszLocation,
    LPSTR   lpszUserName,
    DWORD   nFileSizeHigh,
    DWORD   nFileSizeLow,
    DWORD   dwClusterSize,
    BOOL    fReformat,
    BOOL    *lpfNew
);

BOOL IsShadowVisible(
#ifndef MRXSMB_BUILD_FOR_CSC_DCON
    PVOID pResource, //PRESOURCE    pResource,
#else
    BOOLEAN Disconnected,
#endif
    DWORD         dwAttr,
    ULONG     uShadowStatus
    );

int MarkShareDirty(
    PUSHORT ShareStatus,
    ULONG  hShare
    );
////////////////////////////////////////////////////////////////////////////////
/////////  T U N N E L

// Timeout in seconds for tunnelled entries
// after this many seconds a tunnelled entry is thrown away
#define  STALE_TUNNEL_INFO     45

typedef struct tagSH_TUNNEL {
    HSHADOW hDir;
    ULONG     uTime;
    UCHAR      ubHintFlags;
    UCHAR      ubRefPri;
    UCHAR      ubHintPri;
    UCHAR      ubIHPri;
    USHORT    cAlternateFileName[14];
    USHORT    *      lpcFileName;
} SH_TUNNEL, *LPSH_TUNNEL;

BOOL InsertTunnelInfo(
    HSHADOW  hDir,
    USHORT    *lpcFileName,
    USHORT    *lpcAlternateFileName,
    LPOTHERINFO lpOI
    );

#ifndef MRXSMB_BUILD_FOR_CSC_DCON
BOOL RetrieveTunnelInfo(
#else
typedef enum _RETRIEVE_TUNNEL_INFO_RETURNS {
    TUNNEL_RET_NOTFOUND = 0,
    TUNNEL_RET_SHORTNAME_TUNNEL = 'S',
    TUNNEL_RET_LONGNAME_TUNNEL = 'L'
} RETRIEVE_TUNNEL_INFO_RETURNS;

RETRIEVE_TUNNEL_INFO_RETURNS RetrieveTunnelInfo(
#endif
    HSHADOW  hDir,
    USHORT    *lpcFileName,
    WIN32_FIND_DATA    *lpFind32,
    LPOTHERINFO lpOI
    );
VOID FreeStaleEntries();
void FreeEntry(LPSH_TUNNEL lpshTunnel);
BOOL
FailModificationsToShare(
    LPSHADOWINFO   lpSI
    );
void
IncrementActivityCountForShare(
    HSERVER hShare
    );

BOOL
CSCFailUserOperation(
    HSERVER hShare
    );

// Macro used to check whether shadowing operations should be done or not
// in any given filesystem API call. The global swicth fShadow can be set/reset
// by ring3 agent through an ioctl

#define  ShadowingON()          ((fShadow != 0) && !IsSpecialApp())

#endif //ifndef __INCLUDED__CSC__HOOKCMMN__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\record.mgr\ntcsclow.h ===
typedef struct _NT5CSC_MINIFILEOBJECT {
   NODE_TYPE_CODE_AND_SIZE_NO_REFCOUNT;
   ULONG Flags;
   HANDLE NtHandle;
   PFILE_OBJECT UnderlyingFileObject;
   union {
       struct {
           //cant do this PDEVICE_OBJECT UnderlyingDeviceObject;
           FAST_MUTEX MutexForSynchronousIo; //only synchronous Io is allowed
           union {
               FILE_STANDARD_INFORMATION StandardInfo;
               FILE_BASIC_INFORMATION BasicInfo;
               FILE_FS_SIZE_INFORMATION FsSizeInfo;
               FILE_FS_FULL_SIZE_INFORMATION FsFullSizeInfo;
           };
           ULONG ReturnedLength;
       };
       struct {
           KEVENT PostEvent;
           union {
               RX_WORK_QUEUE_ITEM  WorkQueueItem;
               NTSTATUS PostReturnStatus;
           };
           //this must match the signatureof Nt5CscCreateFile
           LPSTR lpPath;
           BOOL  fInstrument;
           ULONG FileAttributes;
           ULONG CreateOptions;
           ULONG Disposition;
           ULONG ShareAccess;
           ACCESS_MASK DesiredAccess;
           PVOID Continuation; //PNT5CSC_CREATEFILE_CONTINUATION Continuation;
           PVOID ContinuationContext;
       } PostXX;
   };
} NT5CSC_MINIFILEOBJECT, *PNT5CSC_MINIFILEOBJECT;
#define NT5CSC_MINIFOBJ_FLAG_ALLOCATED_FROM_POOL 0x00000001
#define NT5CSC_MINIFOBJ_FLAG_LOUDDOWNCALLS       0x00000080

#define NT5CSC_NTC_MINIFILEOBJECT    ((USHORT)0xed34)
#define ASSERT_MINIRDRFILEOBJECT(___m) ASSERT(NodeType(___m)==NT5CSC_NTC_MINIFILEOBJECT)

//LOUD DOWNCALLS

#ifdef RX_PRIVATE_BUILD
//#define MRXSMBCSC_LOUDDOWNCALLS
#else
#undef MRXSMBCSC_LOUDDOWNCALLS
#endif

#ifdef MRXSMBCSC_LOUDDOWNCALLS

VOID
LoudCallsDbgPrint(
    PSZ Tag,
    PNT5CSC_MINIFILEOBJECT MiniFileObject,
    ULONG MajorFunction,
    ULONG lCount,
    ULONG LowPart,
    ULONG HighPart,
    ULONG Status,
    ULONG Information
    );

#define IF_LOUD_DOWNCALLS(__minifileobj) \
     if(FlagOn((__minifileobj)->Flags,NT5CSC_MINIFOBJ_FLAG_LOUDDOWNCALLS))



#define LOUD_DOWNCALLS_DECL(__x) __x
#define LOUD_DOWNCALLS_CODE(__x) __x
#define IF_BUILT_FOR_LOUD_DOWNCALLS() if(TRUE)

#else

#define LoudCallsDbgPrint(a1,a2,a3,a4,a5,a6,a7,a8) {NOTHING;}

#define IF_LOUD_DOWNCALLS(__minifileobj) if(FALSE)

#define LOUD_DOWNCALLS_DECL(__x)
#define LOUD_DOWNCALLS_CODE(__x)
#define IF_BUILT_FOR_LOUD_DOWNCALLS() if(FALSE)

#endif //#ifdef MRXSMBCSC_LOUDDOWNCALLS

//long R0ReadWriteFileEx
//    (
//    ULONG   uOper,
//    ULONG   handle,
//    ULONG   pos,
//    PVOID   pBuff,
//    long    lCount,
//    BOOL    fInstrument
//    )

#define NT5CSC_RW_FLAG_INSTRUMENTED  0x00000001
#define NT5CSC_RW_FLAG_IRP_NOCACHE   0x00000002
#define NT5CSC_RW_FLAG_PAGED_BUFFER  0x00000004
LONG
Nt5CscReadWriteFileEx (
    ULONG       uOper,
    CSCHFILE    handle,
    ULONGLONG   pos,
    PVOID       pBuff,
    long        lCount,
    ULONG       Flags,
    PIO_STATUS_BLOCK OutIoStatusBlock OPTIONAL
    );
#define R0ReadWriteFileEx(__oper,__handle,__pos,__pbuff,__lcount,__instrument) \
     (Nt5CscReadWriteFileEx(__oper, \
                            __handle, \
                            __pos, \
                            __pbuff, \
                            __lcount, \
                            (__instrument)?NT5CSC_RW_FLAG_INSTRUMENTED:0, \
                            NULL \
                            ))

#define R0ReadWriteFileEx2(__oper,__handle,__pos,__pbuff,__lcount,__flags) \
     (Nt5CscReadWriteFileEx(__oper, \
                            __handle, \
                            __pos, \
                            __pbuff, \
                            __lcount, \
                            ((__flags & FLAG_RW_OSLAYER_INSTRUMENT)?NT5CSC_RW_FLAG_INSTRUMENTED:0) \
                            | ((__flags & FLAG_RW_OSLAYER_PAGED_BUFFER)?NT5CSC_RW_FLAG_PAGED_BUFFER:0), \
                            NULL \
                            ))
extern IO_STATUS_BLOCK Nt5CscGlobalIoStatusBlock;  //used by Nt5CscReadWriteFileEx


NTSTATUS
Nt5CscXxxInformation(
    IN PCHAR xMajorFunction,
    IN PNT5CSC_MINIFILEOBJECT MiniFileObject,
    IN ULONG InformationClass,
    IN ULONG Length,
    OUT PVOID Information,
    OUT PULONG ReturnedLength
    );

BOOL
CscAmIAdmin(
    VOID
    );

typedef
NTSTATUS
(*PNT5CSC_CREATEFILE_CONTINUATION) (
    IN OUT PNT5CSC_MINIFILEOBJECT MiniFileObject,
    IN OUT PVOID ContinuationContext,
    IN     NTSTATUS CreateStatus
    );


PNT5CSC_MINIFILEOBJECT
__Nt5CscCreateFile (
    IN OUT PNT5CSC_MINIFILEOBJECT MiniFileObject OPTIONAL,
    IN     LPSTR    lpPath,
    IN     ULONG    CSCFlags,
    IN     ULONG    FileAttributes,
    IN     ULONG    CreateOptions,
    IN     ULONG    Disposition,
    IN     ULONG    ShareAccess,
    IN     ACCESS_MASK DesiredAccess,
    IN     PNT5CSC_CREATEFILE_CONTINUATION Continuation,
    IN OUT PVOID    ContinuationContext,
    IN     BOOL     PostedCall
    );

int
DeleteStream(
    LPTSTR      lpdbID,
    ULONG       ulidFile,
    LPTSTR      str2Append
    );
    
BOOL
GetFileSystemAttributes(
    CSCHFILE handle,
    ULONG *lpFileSystemAttributes
    );
    
BOOL
HasStreamSupport(
    CSCHFILE handle,
    BOOL    *lpfResult
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\record.mgr\ntcsc.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ntcsc.h

Abstract:

    The global include file including the csc record manager

Author:


Revision History:

--*/

#ifndef __NTCSC_H__
#define __NTCSC_H__

//#include "ntifs.h"
#include "rx.h"
//if this is included from smbmini, we'll need this
#include "rxpooltg.h"   // RX pool tag macros


#define WIN32_NO_STATUS
#define _WINNT_
#include "windef.h"
#include "winerror.h"

//both ntifs.h and ifs.h want to define these....sigh.......

#undef STATUS_PENDING
#undef FILE_ATTRIBUTE_READONLY
#undef FILE_ATTRIBUTE_HIDDEN
#undef FILE_ATTRIBUTE_SYSTEM
#undef FILE_ATTRIBUTE_DIRECTORY
#undef FILE_ATTRIBUTE_ARCHIVE

#include "ifs.h"


#define VxD
#define CSC_RECORDMANAGER_WINNT
#define CSC_ON_NT

// get rid of far references
#define far

//handle types
typedef ULONG DWORD;


// the VxD code likes to declare long pointers.....
typedef PVOID LPVOID;
typedef BYTE *LPBYTE;


//semaphore stuff....should be in a separate .h file
typedef PFAST_MUTEX VMM_SEMAPHORE;

INLINE
PFAST_MUTEX
Create_Semaphore (
    ULONG count
    )
{
    PFAST_MUTEX fmutex;
    ASSERT(count==1);

    fmutex =  (PFAST_MUTEX)RxAllocatePoolWithTag(
                NonPagedPool,
                sizeof(FAST_MUTEX),
                RX_MISC_POOLTAG);

    if (fmutex){
        ExInitializeFastMutex(fmutex);
    }

    //DbgPrint("fmtux=%08lx\n",fmutex);
    //ASSERT(!"here in init semaphore");

    return fmutex;
}

#define Destroy_Semaphore(__sem) { RxFreePool(__sem);}
//#define Wait_Semaphore(__sem, DUMMY___) { ExAcquireFastMutexUnsafe(__sem);}
//#define Signal_Semaphore(__sem) { ExReleaseFastMutexUnsafe(__sem);}
#define Wait_Semaphore(__sem, DUMMY___) { ExAcquireFastMutex(__sem);}
#define Signal_Semaphore(__sem) { ExReleaseFastMutex(__sem);}

//registry stuff.........again, will be a separate .h file
typedef DWORD   VMMHKEY;
typedef VMMHKEY *PVMMHKEY;
typedef DWORD   VMMREGRET;                      // return type for the REG Functions

#define MAX_VMM_REG_KEY_LEN     256     // includes the \0 terminator

#ifndef REG_SZ          // define only if not there already
#define REG_SZ          0x0001
#endif
#ifndef REG_BINARY      // define only if not there already
#define REG_BINARY      0x0003
#endif
#ifndef REG_DWORD       // define only if not there already
#define REG_DWORD       0x0004
#endif


#ifndef HKEY_LOCAL_MACHINE      // define only if not there already

#define HKEY_CLASSES_ROOT               0x80000000
#define HKEY_CURRENT_USER               0x80000001
#define HKEY_LOCAL_MACHINE              0x80000002
#define HKEY_USERS                      0x80000003
#define HKEY_PERFORMANCE_DATA           0x80000004
#define HKEY_CURRENT_CONFIG             0x80000005
#define HKEY_DYN_DATA                   0x80000006

#endif

//initially, we won't go to the registry!
#define _RegOpenKey(a,b,c) (ERROR_SUCCESS+1)
#define _RegQueryValueEx(a,b,c,d,e,f) (ERROR_SUCCESS+1)
#define _RegCloseKey(a) {NOTHING; }

// fix up the fact that stuff is conditioned on DEBUG and various...
#if DBG
#define DEBLEVEL 2
#define DEBUG
#else
#define DEBLEVEL 2
#endif
#define VERBOSE 3


// now the real includes

#define WIN32_APIS
#define UNICODE 2
#include "shdcom.h"
#include "oslayer.h"
#include "record.h"
#include "cshadow.h"
#include "utils.h"
#include "hookcmmn.h"
#include "cscsec.h"
#include "log.h"

#include "ntcsclow.h"

//we have to redefine status_pending since the win95 stuff redefines it.......
#undef STATUS_PENDING
#define STATUS_PENDING                   ((NTSTATUS)0x00000103L)    // winnt

ULONG
IFSMgr_Get_NetTime();

#ifndef MRXSMB_BUILD_FOR_CSC_DCON

//define these to passivate so that i can share some code......
#undef   mIsDisconnected
#define  mIsDisconnected(pResource)  (FALSE)
//#define  mShadowOutofSync(uShadowStatus)  (mQueryBits(uShadowStatus, SHADOW_MODFLAGS|SHADOW_ORPHAN))
#undef   mShadowOutofSync
#define  mShadowOutofSync(uShadowStatus)  (FALSE)

#else

//dont allow mIsDisconnected anymore in common code
#undef   mIsDisconnected
#define  mIsDisconnected(pResource)  (LALA)
#define  mShadowOutofSync(uShadowStatus)  (mQueryBits(uShadowStatus, SHADOW_MODFLAGS|SHADOW_ORPHAN))

#endif

#endif //ifdef __NTCSC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\record.mgr\ioctl.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

     Ioctl.c

Abstract:

    This file implements the ioctl interface to Client Side Caching facility. The interface
    is used by a) the agent b) the CSC apis and c) remote boot. The interface allows the
    callers to initialize/reinitialize the csc database, enumerate the hierarchy at any level,
    get the status of any file/directory in the hierarchy, pin/unpin files directories etc.

    There are a few ioctls which are used only by the agent. These include, enumerating the
    priority q, doing space scavenging, initiating and terminating reintegration on a share etc.


Author:

     Shishir Pardikar      [Shishirp]        01-jan-1995

Revision History:

     Joe Linn                 [JoeLinn]         23-jan-97     Ported for use on NT

--*/

#include "precomp.h"
#pragma hdrstop

#pragma code_seg("PAGE")

#ifndef CSC_RECORDMANAGER_WINNT
#define WIN32_APIS
#include "cshadow.h"
#include "record.h"
#endif //ifndef CSC_RECORDMANAGER_WINNT

#include <stdlib.h>
#include <ctype.h>
#include <string.h>
// #include "error.h"
#include "shell.h"
#include "vxdwraps.h"
#include "clregs.h"
#define  LM_3
#include "netcons.h"
#include "use.h"
#include "neterr.h"

#pragma intrinsic (memcmp, memcpy, memset, strcat, strcmp, strcpy, strlen)

#ifdef CSC_RECORDMANAGER_WINNT
#define CSC_ENABLED      (fShadow && MRxSmbIsCscEnabled)
#define OK_TO_ENABLE_CSC    (MRxSmbIsCscEnabled)
#else
#define CSC_ENABLED (fShadow)
#define OK_TO_ENABLE_CSC    (TRUE)
#endif

//
// From cscapi.h
//
#define FLAG_CSC_SHARE_STATUS_MANUAL_REINT              0x0000
#define FLAG_CSC_SHARE_STATUS_AUTO_REINT                0x0040
#define FLAG_CSC_SHARE_STATUS_VDO                       0x0080
#define FLAG_CSC_SHARE_STATUS_NO_CACHING                0x00c0
#define FLAG_CSC_SHARE_STATUS_CACHING_MASK              0x00c0

#define COPY_STRUCTFILETIME_TO_LARGEINTEGER(dest,src) {\
     (dest).LowPart = (src).dwLowDateTime;             \
     (dest).HighPart = (src).dwHighDateTime;           \
    }

//
// prototypes
//

int
HintobjMMProc(
    LPFIND32,
    HSHADOW,
    HSHADOW,
    ULONG,
    LPOTHERINFO,
    LPFINDSHADOW);

LPFINDSHADOW
LpCreateFindShadow(
    HSHADOW,
    ULONG,
    ULONG,
    USHORT *,
    METAMATCHPROC);

int
DeleteCallbackForFind(
    HSHADOW hDir,
    HSHADOW hShadow
);

int
IoctlRenameShadow(
    LPSHADOWINFO    lpSI
    );


int IoctlEnableCSCForUser(
    LPSHADOWINFO    lpSI
    );

int
IoctlDisableCSCForUser(
    LPSHADOWINFO    lpSI
    );

VOID
MRxSmbCscGenerate83NameAsNeeded(
      IN HSHADOW hDir,
      PWCHAR FileName,
      PWCHAR SFN
      );
VOID
MRxSmbCscFlushFdb(
    IN PFDB Fdb
    );

#ifdef MAYBE
int RecalcIHPri(HSHADOW, HSHADOW, LPFIND32, LPOTHERINFO);
#endif //MAYBE

BOOL RegisterTempAgent(VOID);
BOOL UnregisterTempAgent(VOID);
int PUBLIC MakeSpace(long, long, BOOL);
int PUBLIC ReduceRefPri(VOID);

int
IoctlAddDeleteHintFromInode(
    LPSHADOWINFO    lpSI,
    BOOL            fAdd
    );

LONG
PurgeUnpinnedFiles(
    ULONG     Timeout,
    PULONG    pnFiles,
    PULONG    pnYoungFiles);

BOOL HaveSpace(
    long  nFileSizeHigh,
    long  nFileSizeLow
    );

int SetResourceFlags(
    HSHARE  hShare,
    ULONG uStatus,
    ULONG uOp
    );
int DestroyFindShadow(
    LPFINDSHADOW    lpFSH
    );

int
CloseDatabase(
    VOID
    );

int
IoctlCopyShadow(
    LPSHADOWINFO    lpSI
    );

int IoctlGetSecurityInfo(
    LPSHADOWINFO    lpShadowInfo
    );
int
IoctlTransitionShareToOffline(
    LPSHADOWINFO    lpSI
    );

IoctlChangeHandleCachingState(
    LPSHADOWINFO    lpSI
    );

BOOLEAN
CscCheckForNullA(
    PUCHAR pBuf,
    ULONG Count);

BOOLEAN
CscCheckForNullW(
    PWCHAR pBuf,
    ULONG Count);

int
PUBLIC TraversePQToCheckDirtyBits(
    HSHARE hShare,
    DWORD   *lpcntDirty
    );

#ifndef CSC_RECORDMANAGER_WINNT
int ReportCreateDelete( HSHADOW  hShadow, BOOL fCreate);
#else
//BUGBUG.win9xonly this comes from hook.c on win95
#define ReportCreateDelete(a,b) {NOTHING;}
#endif //ifndef CSC_RECORDMANAGER_WINNT
BOOL
FailModificationsToShare(
    LPSHADOWINFO   lpSI
    );

extern  ULONG hthreadReint;
extern  ULONG hwndReint;
extern  PFILEINFO pFileInfoAgent;
extern  HSHARE  hShareReint;    // Share that is currently being reintegrated
extern  BOOL vfBlockingReint;
extern  DWORD vdwActivityCount;
extern  int fShadow, fLog, fNoShadow, /*fShadowFind,*/ fSpeadOpt;
extern  WIN32_FIND_DATA    vsFind32;
extern  int cMacPro;
extern  NETPRO rgNetPro[];
extern  VMM_SEMAPHORE  semHook;
extern  GLOBALSTATUS sGS;
extern  ULONG proidShadow;
extern  ULONG heventReint;
#if defined(REMOTE_BOOT)
BOOLEAN    fIsRemoteBootSystem=FALSE;
#endif // defined(REMOTE_BOOT)

// List of ongoing IOCTL finds
LPFINDSHADOW    vlpFindShadowList = NULL;
// Count of # entries on vlpFindShadowList
LONG vuFindShadowListCount = 0;
int iPQEnumCount = 0;
CSC_ENUMCOOKIE  hPQEnumCookieForIoctls = NULL;


AssertData;
AssertError;

#ifdef CSC_RECORDMANAGER_WINNT
//BUGBUG.win9xonly this stuff comes from shadow.asm on win95......
//this is a synchronization primitive used to unblock guys waiting on a server
//not yet implemented
#define _SignalID(a) {ASSERT(FALSE);}
#define IFSMgr_UseAdd(a, b, c) (-1)
#define IFSMgr_UseDel(a, b, c) (-1)

#endif //ifdef CSC_RECORDMANAGER_WINNT


int IoctlRegisterAgent(
    LPSHADOWINFO    lpSI
    )
/*++

Routine Description:

WIN9x specific    This is the way, we tell the shadwo VxD that this thread is the
                  agent thread and to bypass CSC whenever this thread comes down to make
                  calls.

Parameters:

Return Value:

Notes:


--*/
{
    if (hthreadReint)
    {
        KdPrint(("Agent Already registered Unregistering!!!!!\r\n"));

#ifndef CSC_RECORDMANAGER_WINNT

        // should never happen on win9x
        Assert(FALSE);
        // cleanup the
        if (heventReint)
        {
            // close the event handle
            CloseVxDHandle(heventReint);
        }

#endif
    }

    hthreadReint = GetCurThreadHandle();
    hwndReint = lpSI->hShare & 0xffff;    // windows handle for messages
    heventReint = lpSI->hDir;            // event handle for reporting interesting events

#if defined(REMOTE_BOOT)
    // if CSC is ON even before the agent was registered, we must be on an RB machine.
    fIsRemoteBootSystem = fShadow;
#endif // defined(REMOTE_BOOT)

    return 1;
}

int IoctlUnRegisterAgent(
    ULONG uHwnd
    )
/*++

Routine Description:

WIN9x specific

Parameters:

Return Value:

Notes:


--*/
{
    ULONG hthread;
    hthread =  GetCurThreadHandle();

    if (hthreadReint != hthread)
    {
        KdPrint(("Shadow:Someother thread Unregitsering!!!!\r\n"));
    }

    hthreadReint = 0;
    hwndReint = 0;
    if (heventReint)
    {
#ifndef CSC_RECORDMANAGER_WINNT
        // close the event handle
        CloseVxDHandle(heventReint);
        heventReint = 0;
#endif
    }
    return 1;
}

int IoctlGetUNCPath(
    LPCOPYPARAMSW lpCopyParams
    )
/*++

Routine Description:

    Given an hDir and an hShadow, this routine returns the complete UNC path for it.
    It returns it in the COPYPARAMS structure which has three embedded pointers for
    a) \\server\share b) Remote path relative to the root of the share and c) Path in
    the local database.

Parameters:

Return Value:

Notes:


--*/
{
    PFDB pFdb;
    HSHADOW hDir;
    HSHARE hShare;
    SHAREINFOW sSRI;
    int iRet = -1;
    DWORD   dwSize;

    if (!CSC_ENABLED)
    {
        lpCopyParams->dwError = ERROR_SERVICE_NOT_ACTIVE;
        return -1;
    }

    EnterShadowCrit();

    hDir = 0; hShare = 0;

    if (lpCopyParams->lpRemotePath || lpCopyParams->lpSharePath)
    {
        if (GetAncestorsHSHADOW(lpCopyParams->hShadow, &hDir, &hShare) < SRET_OK)
        {
            goto bailout;
        }
        if (lpCopyParams->lpRemotePath)
        {
            if(PathFromHShadow(hDir, lpCopyParams->hShadow, lpCopyParams->lpRemotePath, MAX_PATH)<SRET_OK)
            {
                goto bailout;
            }
        }
        if (lpCopyParams->lpSharePath)
        {
            if (GetShareInfo(hShare, &sSRI, NULL) < SRET_OK)
            {
                goto bailout;
            }

            memcpy(lpCopyParams->lpSharePath, sSRI.rgSharePath, sizeof(sSRI.rgSharePath));
        }
    }


    dwSize = MAX_PATH * sizeof(USHORT);

    GetWideCharLocalNameHSHADOW(lpCopyParams->hShadow, lpCopyParams->lpLocalPath, &dwSize, (lpCopyParams->uOp==0));

    iRet = 1;
bailout:
    IF_CSC_RECORDMANAGER_WINNT {
        if (iRet!=1) {
#if 0
            DbgPrint("Failure on nonfailable routine.....\n");
            DbgPrint("----> hShadow    %08lx\n",lpCopyParams->hShadow);
            DbgPrint("----> hDir hSrv  %08lx %08lx\n",hDir,hShare);
            DbgPrint("----> SrvPath    %08lx\n",lpCopyParams->lpSharePath);
            DbgPrint("----> RemotePath %08lx\n",lpCopyParams->lpRemotePath);
            DbgBreakPoint();
#endif
        }
    }

    if (iRet < SRET_OK)
    {
        lpCopyParams->dwError = GetLastErrorLocal();
    }

    LeaveShadowCrit();
    return(iRet);
}

int IoctlBeginPQEnum(
    LPPQPARAMS lpPQPar
    )
/*++

Routine Description:

    Priority queue enumeration begins. Typically used by agent thread to do background
    filling

Parameters:

Return Value:

Notes:


--*/
{
    int iRet = -1;

    if (!CSC_ENABLED)
    {
        lpPQPar->dwError =  ERROR_SERVICE_NOT_ACTIVE;
        return -1;
    }

    EnterShadowCrit();

#ifdef CSC_RECORDMANAGER_WINNT
    EventLogForOpenFailure = 1;
#endif //ifdef CSC_RECORDMANAGER_WINNT

    if (hPQEnumCookieForIoctls==NULL)
    {
        hPQEnumCookieForIoctls = HBeginPQEnum();
    }

    if (hPQEnumCookieForIoctls != NULL)
    {
        iRet = 1;
    }
    else
    {
        lpPQPar->dwError = GetLastErrorLocal();
    }
#ifdef CSC_RECORDMANAGER_WINNT
    EventLogForOpenFailure = 0;
#endif //ifdef CSC_RECORDMANAGER_WINNT

    LeaveShadowCrit();


    return iRet;
}

int IoctlEndPQEnum(
    LPPQPARAMS lpPQPar
    )
/*++

Routine Description:

    End priority queue enumeration

Parameters:

Return Value:

Notes:


--*/
{
    return 1;
}

int IoctlNextPriShadow(
    LPPQPARAMS lpPQPar
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    PQPARAMS sPQP;
    int iRet=-1;

    EnterShadowCrit();

    if (hPQEnumCookieForIoctls==NULL) {
        lpPQPar->dwError =  ERROR_INVALID_PARAMETER;
        goto bailout;
    }

    sPQP = *lpPQPar;

    sPQP.uEnumCookie = hPQEnumCookieForIoctls;

    iRet = NextPriSHADOW(&sPQP);
    if (iRet >= SRET_OK)
    {
        *lpPQPar = sPQP;

        if (!iRet)
            lpPQPar->hShadow = 0;
        iRet = 1;
    }
    else
    {
        lpPQPar->dwError = GetLastErrorLocal();
        iRet = -1;
        EndPQEnum(hPQEnumCookieForIoctls);
        hPQEnumCookieForIoctls = NULL;
    }

    lpPQPar->uEnumCookie = NULL;

bailout:
    LeaveShadowCrit();

    return (iRet);
}

int IoctlPrevPriShadow(
    LPPQPARAMS lpPQPar
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    PQPARAMS sPQP;
    int iRet=-1;

    EnterShadowCrit();

    if (hPQEnumCookieForIoctls==NULL) {
        lpPQPar->dwError =  ERROR_INVALID_PARAMETER;
        goto bailout;
    }

    sPQP = *lpPQPar;
    sPQP.uEnumCookie = hPQEnumCookieForIoctls;

    iRet = PrevPriSHADOW(&sPQP);
    if (iRet >= SRET_OK)
    {
        *lpPQPar = sPQP;
        if (!iRet)
            lpPQPar->hShadow = 0;
        iRet =  1;
    }
    else
    {
        lpPQPar->dwError = GetLastErrorLocal();
        iRet = -1;
        EndPQEnum(hPQEnumCookieForIoctls);
        hPQEnumCookieForIoctls = NULL;
    }

    lpPQPar->uEnumCookie = NULL;

bailout:
    LeaveShadowCrit();

    return (iRet);
}

int
IoctlGetShadowInfoInternal(
    LPSHADOWINFO    lpShadowInfo,
    LPFIND32        lpFind32,
    LPSECURITYINFO  lpSecurityInfos,
    LPDWORD         lpcbBufferSize
    )
/*++

Routine Description:

    Given an hDir and an hShadow, return all the possible info for the Inode

Parameters:

Return Value:

Notes:


--*/
{
    ULONG uStatus;
    HSHADOW hDir, hShare;
    PFDB pFdb=NULL;
    PRESOURCE  pResource=NULL;
    int iRet = -1;
    OTHERINFO    sOI;
    DWORD           dwSecurityBlobSize;
    ACCESS_RIGHTS   rgsAccessRights[CSC_MAXIMUM_NUMBER_OF_CACHED_SID_INDEXES];

    DeclareFindFromShadowOnNtVars()

    if (!CSC_ENABLED)
    {
        lpShadowInfo->dwError = ERROR_SERVICE_NOT_ACTIVE;
        return -1;
    }

    EnterShadowCrit();
    UseGlobalFind32();

    if (!(hDir = lpShadowInfo->hDir))
    {
        if (GetAncestorsHSHADOW(lpShadowInfo->hShadow, &hDir, &hShare) < 0)
            goto bailout;

        lpShadowInfo->hDir = hDir;
        lpShadowInfo->hShare = hShare;
    }

    dwSecurityBlobSize = sizeof(rgsAccessRights);

    if(GetShadowInfoEx( hDir,
                        lpShadowInfo->hShadow,
                        &vsFind32,
                        &uStatus,
                        &sOI,
                        rgsAccessRights,
                        &dwSecurityBlobSize) < SRET_OK)
        goto bailout;


    // not a root
    if (hDir)
    {
        if (!(vsFind32.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            // is a file
            uStatus |= SHADOW_IS_FILE;

            if(pFdb = PFindFdbFromHShadow(lpShadowInfo->hShadow))
            {
                uStatus |= (pFdb->usFlags | SHADOW_FILE_IS_OPEN);
            }
        }
    }
    else
    {
        pResource = PFindResourceFromRoot(lpShadowInfo->hShadow, 0xffff, 0);

        if (pResource)
        {
            IFNOT_CSC_RECORDMANAGER_WINNT
            {
                uStatus |= (
                                (pResource->usLocalFlags|SHARE_CONNECTED)|
                                ((pResource->pheadFdb)?SHARE_FILES_OPEN:0) |
                                ((pResource->pheadFindInfo) ?SHARE_FINDS_IN_PROGRESS:0));

                lpShadowInfo->uOp = pResource->uDriveMap;
            }
            else
            {
                uStatus |= MRxSmbCscGetSavedResourceStatus();
                lpShadowInfo->uOp = MRxSmbCscGetSavedResourceDriveMap();
            }
        }
        // UI expects to know whether a server is offline
        // even when a share may not be offline. So we do the following drill anyways
        {
#ifdef CSC_RECORDMANAGER_WINNT
            BOOL    fShareOnline = FALSE;
            BOOL    fPinnedOffline = FALSE;
            if (MRxSmbCscServerStateFromCompleteUNCPath(
                    vsFind32.cFileName,
                    &fShareOnline,
                    &fPinnedOffline)==STATUS_SUCCESS) {
                if (!fShareOnline)
                    uStatus |= SHARE_DISCONNECTED_OP;
                if (fPinnedOffline)
                    uStatus |= SHARE_PINNED_OFFLINE;
            }
#endif
        }

    }

    lpShadowInfo->uStatus = uStatus;
    CopyOtherInfoToShadowInfo(&sOI, lpShadowInfo);
    if (hShareReint && (lpShadowInfo->hShare == hShareReint))
    {
        lpShadowInfo->uStatus |= SHARE_MERGING;
    }

    if (lpFind32)
    {
        *(lpFind32) = vsFind32;

    }

    if (lpSecurityInfos)
    {
        Assert(lpcbBufferSize);

        iRet = GetSecurityInfosFromBlob(
            rgsAccessRights,
            dwSecurityBlobSize,
            lpSecurityInfos,
            lpcbBufferSize);

        Assert(iRet >= 0);

    }

    iRet = 1;

bailout:
    if (iRet < 0)
    {
        lpShadowInfo->dwError = GetLastErrorLocal();
    }
    LeaveShadowCrit();
    return (iRet);
}

int IoctlGetSecurityInfo(
    LPSHADOWINFO    lpShadowInfo
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    return IoctlGetShadowInfoInternal(lpShadowInfo, NULL, (LPSECURITYINFO)(lpShadowInfo->lpBuffer), &(lpShadowInfo->cbBufferSize));
}

int IoctlGetShadowInfo(
    LPSHADOWINFO    lpShadowInfo
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    return IoctlGetShadowInfoInternal(lpShadowInfo, lpShadowInfo->lpFind32, NULL, NULL);
}


int IoctlSetShadowInfo(
    LPSHADOWINFO    lpShadowInfo
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    HSHADOW hDir;
    PFDB pFdb;
    ULONG uOp = lpShadowInfo->uOp, uStatus;
    int iRet = -1;
    LPFIND32 lpFind32=NULL;

    if (!CSC_ENABLED)
    {
        lpShadowInfo->dwError = ERROR_SERVICE_NOT_ACTIVE;
        return -1;
    }

    EnterShadowCrit();
    UseGlobalFind32();

    if (FailModificationsToShare(lpShadowInfo))
    {
        goto bailout;
    }

    hDir = lpShadowInfo->hDir;
    pFdb = PFindFdbFromHShadow(lpShadowInfo->hShadow);

    if (!hDir)
    {
        if (GetAncestorsHSHADOW(lpShadowInfo->hShadow, &hDir, NULL) < 0)
            goto bailout;
        lpShadowInfo->hDir = hDir;
    }

    if (mTruncateDataCommand(uOp))
    {
        if (pFdb)
        {
            goto bailout;
        }
        if (GetShadowInfo(hDir, lpShadowInfo->hShadow, &vsFind32, &uStatus, NULL) < 0)
        {
            goto bailout;
        }
        if (uStatus & SHADOW_LOCALLY_CREATED)
        {
            goto bailout;
        }
        if (IsFile(vsFind32.dwFileAttributes))
        {
            if (TruncateDataHSHADOW(hDir, lpShadowInfo->hShadow) < SRET_OK)
            {
                goto bailout;
            }
        }

        // if we are truncating data, then the only thing possible
        // is to set all the flags to 0 and mark it as sparse
        lpShadowInfo->uStatus = SHADOW_SPARSE;
        uOp = lpShadowInfo->uOp = (SHADOW_FLAGS_ASSIGN | SHADOW_FLAGS_TRUNCATE_DATA);
    }

    if (lpShadowInfo->lpFind32)
    {
        lpFind32 = &vsFind32;

        *lpFind32 = *(lpShadowInfo->lpFind32);

//        Find32FromFind32A(lpFind32 = &vsFind32, (LPFIND32A)(lpShadowInfo->lpFind32), BCS_WANSI);

#ifndef CSC_RECORDMANAGER_WINNT

        // ensure that on win9x we set only the FAT like attributes
        lpFind32->dwFileAttributes &= FILE_ATTRIBUTE_EVERYTHING;

#endif

    }

    // strip out the ored flags
    lpShadowInfo->uStatus &= ~(SHARE_MERGING);

    if(SetShadowInfo(hDir, lpShadowInfo->hShadow
                            , lpFind32
                            , lpShadowInfo->uStatus
                            , lpShadowInfo->uOp) < SRET_OK)
    {
        goto bailout;
    }

    // if this is a file and it is open, then
    // update the in memory structures

    if (pFdb)
    {
        USHORT usFlags = (USHORT)(lpShadowInfo->uStatus);
        USHORT  usOldFlags, *pusLocalFlags = NULL;

        // we can't be truncating when a file is open
        Assert(!mTruncateDataCommand(uOp));

        usOldFlags = usFlags;

        pusLocalFlags = PLocalFlagsFromPFdb(pFdb);

        Assert(pusLocalFlags);

        if (mAndShadowFlags(uOp))
        {
            pFdb->usFlags = pFdb->usFlags & usFlags;
        }
        else if (mOrShadowFlags(uOp))
        {
            pFdb->usFlags = pFdb->usFlags | usFlags;
        }
        else
        {
            pFdb->usFlags = pFdb->usFlags | usFlags;
        }

        // if we are about to clear the reint bits
        // then also clear the snapshot bit
        // If the file has been modified after the snapshot was taken,
        // then the modified bit will have been set again

        if ((usOldFlags & SHADOW_DIRTY) && !(usFlags & SHADOW_DIRTY))
        {
            *pusLocalFlags &= ~FLAG_FDB_SHADOW_SNAPSHOTTED;
        }

    }

    iRet = 1;
bailout:
    if (iRet < 0)
    {
        lpShadowInfo->dwError = GetLastErrorLocal();
    }
    LeaveShadowCrit();
    return (iRet);
}


int IoctlChkUpdtStatus(
    LPSHADOWINFO    lpShadowInfo
    )
/*++

Routine Description:

    Check if the File represneted by the inode is out of date by and mark it as stale
    if so

Parameters:

Return Value:

Notes:


--*/
{
    HSHADOW hDir;
    PFDB pFdb;
    int iRet = -1;

    if (!CSC_ENABLED)
    {
        lpShadowInfo->dwError = ERROR_SERVICE_NOT_ACTIVE;
        return -1;
    }

    EnterShadowCrit();
    if (!(hDir = lpShadowInfo->hDir))
    {
        if (GetAncestorsHSHADOW(lpShadowInfo->hShadow, &hDir, NULL) < 0)
            goto bailout;
        lpShadowInfo->hDir = hDir;
    }
    if(ChkUpdtStatusHSHADOW(hDir, lpShadowInfo->hShadow
                            , lpShadowInfo->lpFind32
                            , &(lpShadowInfo->uStatus)
                            ) < SRET_OK)
        goto bailout;
    if(pFdb = PFindFdbFromHShadow(lpShadowInfo->hShadow))
    {
        // Update the staleness indicator in pFdb (why?)
        pFdb->usFlags ^= (lpShadowInfo->uStatus & SHADOW_STALE);

        // OR any flags such as DIRTY and SUSPECT that might
        // have occurred
        lpShadowInfo->uStatus |= pFdb->usFlags;
    }

    if (!(lpShadowInfo->lpFind32->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
    {
        // is a file
        lpShadowInfo->uStatus |= SHADOW_IS_FILE;
    }

    iRet = 1;
bailout:
    if (iRet < 0)
    {
        lpShadowInfo->dwError = GetLastErrorLocal();
    }
    LeaveShadowCrit();
    return (iRet);
}

int IoctlDoShadowMaintenance(
    LPSHADOWINFO    lpSI
    )
/*++

Routine Description:

    Catchall routine which takes a minor_number to do interesting things.
    It used to be used for maitenance purposes, but has become a funnelling
    point for many helper ioctls

Parameters:

Return Value:

Notes:


--*/
{
    int iRet = 1;
    OTHERINFO sOI;
    ULONG nFiles = 0;
    ULONG nYoungFiles = 0;

    if (lpSI->uOp == SHADOW_REINIT_DATABASE)
    {
        if (fShadow)
        {
            lpSI->dwError = ERROR_SERVICE_NOT_ACTIVE;
            return -1;
        }
        //
        // Check that cFileName and cAlternateFileName contain a NULL
        //
        if (CscCheckForNullA(((LPFIND32A)(lpSI->lpFind32))->cFileName, MAX_PATH) == FALSE) {
            lpSI->dwError = ERROR_INVALID_PARAMETER;
            return -1;
        }
        if (CscCheckForNullA(((LPFIND32A)(lpSI->lpFind32))->cAlternateFileName, 14) == FALSE) {
            lpSI->dwError = ERROR_INVALID_PARAMETER;
            return -1;
        }
        EnterShadowCrit();
        iRet = ReinitializeDatabase(
                        ((LPFIND32A)(lpSI->lpFind32))->cFileName,
                        ((LPFIND32A)(lpSI->lpFind32))->cAlternateFileName,
                        ((LPFIND32A)(lpSI->lpFind32))->nFileSizeHigh,
                        ((LPFIND32A)(lpSI->lpFind32))->nFileSizeLow,
                        ((LPFIND32A)(lpSI->lpFind32))->dwReserved1
                        );
        LeaveShadowCrit();
        if (iRet < 0) {
            lpSI->dwError = GetLastErrorLocal();
        }
        return (iRet);
    }
    else if (lpSI->uOp == SHADOW_ENABLE_CSC_FOR_USER)
    {
        if(IoctlEnableCSCForUser(lpSI) < 0) {
            lpSI->dwError = GetLastErrorLocal();
            return -1;
        } else {
            return 1;
        }
    }

    if (!CSC_ENABLED) {
        lpSI->dwError = ERROR_SERVICE_NOT_ACTIVE;
        return -1;
    }

    EnterShadowCrit();
    UseGlobalFind32();
    switch(lpSI->uOp)
    {
        case SHADOW_MAKE_SPACE:
            // Assert(lpSI->lpFind32);
            if (lpSI->lpFind32 == NULL) {
                lpSI->dwError = ERROR_INVALID_PARAMETER;
                LeaveShadowCrit();
                return -1;
            }
            MakeSpace(    lpSI->lpFind32->nFileSizeHigh,
                        lpSI->lpFind32->nFileSizeLow,
                        (lpSI->ulHintPri == 0xffffffff));
            break;
        case SHADOW_REDUCE_REFPRI:
            ReduceRefPri();
            break;
        case SHADOW_ADD_SPACE:
            // Assert(lpSI->lpFind32);
            if (lpSI->lpFind32 == NULL) {
                lpSI->dwError = ERROR_INVALID_PARAMETER;
                LeaveShadowCrit();
                return -1;
            }
            AllocShadowSpace(lpSI->lpFind32->nFileSizeHigh, lpSI->lpFind32->nFileSizeLow, TRUE);
            break;
        case SHADOW_FREE_SPACE:
            // Assert(lpSI->lpFind32);
            if (lpSI->lpFind32 == NULL) {
                lpSI->dwError = ERROR_INVALID_PARAMETER;
                LeaveShadowCrit();
                return -1;
            }
            FreeShadowSpace(lpSI->lpFind32->nFileSizeHigh, lpSI->lpFind32->nFileSizeLow, TRUE);
            break;
        case SHADOW_GET_SPACE_STATS:
            // Assert(lpSI->lpBuffer);
            // Assert(lpSI->cbBufferSize >= sizeof(SHADOWSTORE));
            if (lpSI->lpBuffer == NULL || lpSI->cbBufferSize < sizeof(SHADOWSTORE)) {
                lpSI->dwError = ERROR_INVALID_PARAMETER;
                LeaveShadowCrit();
                return -1;
            }
            if(GetShadowSpaceInfo((SHADOWSTORE *)(lpSI->lpBuffer)) >= SRET_OK) {
                iRet = 1;
            } else {
                iRet = -1;
            }
            break;
        case SHADOW_SET_MAX_SPACE:
            // Assert(lpSI->lpFind32);
            if (lpSI->lpFind32 == NULL) {
                lpSI->dwError = ERROR_INVALID_PARAMETER;
                LeaveShadowCrit();
                return -1;
            }
            SetMaxShadowSpace(lpSI->lpFind32->nFileSizeHigh, lpSI->lpFind32->nFileSizeLow);
            break;
        case SHADOW_PER_THREAD_DISABLE:
            if(!RegisterTempAgent()) {
                iRet = -1;
            }
            break;
        case SHADOW_PER_THREAD_ENABLE:
            if(!UnregisterTempAgent()) {
                iRet = -1;
            }
            break;
        case SHADOW_ADDHINT_FROM_INODE:
            iRet = IoctlAddDeleteHintFromInode(lpSI, TRUE);
            break;
        case SHADOW_DELETEHINT_FROM_INODE:
            iRet = IoctlAddDeleteHintFromInode(lpSI, FALSE);
            break;
        case SHADOW_COPY_INODE_FILE:
            iRet = IoctlCopyShadow(lpSI);

            break;
        case SHADOW_BEGIN_INODE_TRANSACTION:
            iRet = BeginInodeTransactionHSHADOW();
            break;
        case SHADOW_END_INODE_TRANSACTION:
            iRet = EndInodeTransactionHSHADOW();
            break;
        case SHADOW_FIND_CREATE_PRINCIPAL_ID:
            {
                DWORD dwError = ERROR_SUCCESS;
                CSC_SID_INDEX indx;

                if (CscCheckForNullA(lpSI->lpBuffer, lpSI->cbBufferSize) == FALSE) {
                    lpSI->dwError = ERROR_INVALID_PARAMETER;
                    LeaveShadowCrit();
                    return -1;
                }
                if (lpSI->uStatus) {
                    dwError = CscAddSidToDatabase(lpSI->lpBuffer, lpSI->cbBufferSize, &indx);
                } else {
                    indx = CscMapSidToIndex(lpSI->lpBuffer, lpSI->cbBufferSize);

                    if (indx == CSC_INVALID_PRINCIPAL_ID) {
                        dwError = ERROR_NO_SUCH_USER;
                    }
                }
                if (dwError != ERROR_SUCCESS) {
                    iRet = -1;
                    lpSI->dwError = dwError;
                } else {
                    lpSI->ulPrincipalID = (ULONG)indx;
                }
            }
            break;
        case SHADOW_GET_SECURITY_INFO:
            LeaveShadowCrit();
            iRet = IoctlGetSecurityInfo(lpSI);
            return iRet;
        case SHADOW_SET_EXCLUSION_LIST:
            if (CscCheckForNullW(lpSI->lpBuffer, lpSI->cbBufferSize/sizeof(WCHAR)) == FALSE) {
                lpSI->dwError = ERROR_INVALID_PARAMETER;
                LeaveShadowCrit();
                return -1;
            }
            iRet = SetList(lpSI->lpBuffer, lpSI->cbBufferSize, CSHADOW_LIST_TYPE_EXCLUDE);
            break;
        case SHADOW_SET_BW_CONSERVE_LIST:
            if (CscCheckForNullW(lpSI->lpBuffer, lpSI->cbBufferSize/sizeof(WCHAR)) == FALSE) {
                lpSI->dwError = ERROR_INVALID_PARAMETER;
                LeaveShadowCrit();
                return -1;
            }
            iRet = SetList(lpSI->lpBuffer, lpSI->cbBufferSize, CSHADOW_LIST_TYPE_CONSERVE_BW);
            break;
#ifdef CSC_RECORDMANAGER_WINNT
        case IOCTL_TRANSITION_SERVER_TO_OFFLINE:
            iRet = IoctlTransitionShareToOffline(lpSI);
            break;
#endif
        case SHADOW_CHANGE_HANDLE_CACHING_STATE:
            iRet = IoctlChangeHandleCachingState(lpSI);
            break;
        case SHADOW_RECREATE:
            if (!PFindFdbFromHShadow(lpSI->hShadow)) {
                if(RecreateHSHADOW(lpSI->hDir, lpSI->hShadow, lpSI->uStatus) < 0) {
                    iRet = -1;
                }
            } else {
                iRet = -1;
                SetLastErrorLocal(ERROR_SHARING_VIOLATION);
            }
            break;
        case SHADOW_SET_DATABASE_STATUS:
            if (CscAmIAdmin()) {
                if(SetDatabaseStatus(lpSI->uStatus, lpSI->ulHintFlags) < 0) {
                    iRet = -1;
                }
            } else {
                iRet = -1;
                SetLastErrorLocal(ERROR_ACCESS_DENIED);
            }
            break;
        case SHADOW_RENAME:
            iRet = IoctlRenameShadow(lpSI);
            break;
        case SHADOW_SPARSE_STALE_DETECTION_COUNTER:
            QuerySparseStaleDetectionCount(&(lpSI->dwError));
            iRet = 1;
            break;
        case SHADOW_MANUAL_FILE_DETECTION_COUNTER:
            QueryManualFileDetectionCount(&(lpSI->dwError));
            iRet = 1;
            break;
        case SHADOW_DISABLE_CSC_FOR_USER:
            iRet = IoctlDisableCSCForUser(lpSI);
            break;        
        case SHADOW_PURGE_UNPINNED_FILES:
            // Assert(lpSI->lpFind32);
            if (lpSI->lpFind32 == NULL) {
                lpSI->dwError = ERROR_INVALID_PARAMETER;
                LeaveShadowCrit();
                return -1;
            }
            iRet = PurgeUnpinnedFiles(
                        lpSI->lpFind32->nFileSizeHigh,
                        &nFiles,
                        &nYoungFiles);
            if (iRet >= SRET_OK) {
                iRet = 1;  // Copy output params
                lpSI->lpFind32->nFileSizeHigh = nFiles;
                lpSI->lpFind32->nFileSizeLow = nYoungFiles;
                // DbgPrint("IoctlDoShadowMaintenance: iRet=%d, nFiles=%d, nYoungFiles=%d\n",
                //             iRet,
                //             nFiles,
                //             nYoungFiles);
            } else {
                iRet = -1;
            }
            break;

    }
    if (iRet < 0) {
        lpSI->dwError = GetLastErrorLocal();
    }
    LeaveShadowCrit();
    return (iRet);
}

#ifndef CSC_RECORDMANAGER_WINNT
//the implementation on NT is completely different
int IoctlCopyChunk(
    LPSHADOWINFO        lpSI,
    COPYCHUNKCONTEXT    *lpCCC
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    PFILEINFO pFileInfo;
    int iRet = -1;

    if (!CSC_ENABLED)
    {
        return -1;
    }

    EnterHookCrit();
    if (pFileInfo = PFileInfoAgent())
    {
        EnterShadowCrit();
         iRet = CopyChunk(lpSI->hDir, lpSI->hShadow, pFileInfo, lpCCC);
        LeaveShadowCrit();
    }

    LeaveHookCrit();
    return (iRet);
}
#endif //ifndef CSC_RECORDMANAGER_WINNT

int IoctlBeginReint(
    LPSHADOWINFO    lpShadowInfo
    )
/*++

Routine Description:

    Puts a share in reintegration mode. The effect of this is that, all filesystem
    open calls to the share fail with ACCESS_DENIED if they come to CSC.

Parameters:

    lpShadowInfo    The significant entry is hShare, which represents the share being
                    put in disconnected state

Return Value:


Notes:

    CODE.IMPROVEMENT.ASHAMED This scheme assumes that only one share is reintegrated
    at one time. So if the multiple guys call IoctlBeginReint, then they will tromp on
    each other. We have taken care of it in the agent code which does merging. We allow
    only one guy to merge at any time by taking a global critical section.

--*/
{
    PPRESOURCE ppResource;
    int i;

    if (!CSC_ENABLED)
    {
        lpShadowInfo->dwError = ERROR_INVALID_FUNCTION;
        return -1;
    }

    if (hShareReint)
    {
        lpShadowInfo->dwError = ERROR_BUSY;
        return -1;
    }

    if (lpShadowInfo->hShare == 0)
    {
        lpShadowInfo->dwError = ERROR_INVALID_PARAMETER;
        return -1;
    }

// BUGBUG-win9xonly needs checking
#ifndef CSC_RECORDMANAGER_WINNT
    EnterHookCrit();
#endif


#ifdef CSC_RECORDMANAGER_WINNT

    EnterShadowCrit();

    hShareReint = lpShadowInfo->hShare;
    vdwActivityCount = 0;

    // if uOp is non-zero then this is a reint that should abort if the activytcount
    // is non-zero
    vfBlockingReint  = (lpShadowInfo->uOp == 0);

    LeaveShadowCrit();
    return(1);

#else
    for (i=0;i<cMacPro;++i)
    {
        for(ppResource = &(rgNetPro[i].pheadResource); *ppResource; ppResource = &((*ppResource)->pnextResource))
        {
            if ((*ppResource)->hShare == lpShadowInfo->hShare)
            {
                if ((*ppResource)->pheadFileInfo || (*ppResource)->pheadFindInfo)
                {
                    LeaveHookCrit();
                    return(-1);
                }
            }
        }
    }
#endif //ifdef CSC_RECORDMANAGER_WINNT

    hShareReint = lpShadowInfo->hShare;
    LeaveHookCrit();
    return (1);
}

int IoctlEndReint(
    LPSHADOWINFO    lpShadowInfo
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet = -1;

    EnterShadowCrit();

    if (lpShadowInfo->hShare == hShareReint)
    {
        hShareReint = 0;
#ifndef CSC_RECORDMANAGER_WINNT
        _SignalID(lpShadowInfo->hShare);
#endif
        iRet = 1;
    }
    else
    {
        lpShadowInfo->dwError = ERROR_INVALID_PARAMETER;
    }
    LeaveShadowCrit();

    return iRet;
}

int IoctlCreateShadow(
    LPSHADOWINFO lpSI
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet= SRET_ERROR;
    SHAREINFO sSRI;
    LPFIND32 lpFind32 = lpSI->lpFind32;
    BOOL fCreated = FALSE;

    if (!CSC_ENABLED)
    {
        lpSI->dwError = ERROR_SERVICE_NOT_ACTIVE;
        return -1;
    }

    EnterShadowCrit();
    UseGlobalFind32();



    vsFind32 = *(lpSI->lpFind32);

//    Find32FromFind32A(&vsFind32, (LPFIND32A)(lpSI->lpFind32), BCS_WANSI);

    if (!lpSI->hDir)
    {
        iRet = FindCreateShare(vsFind32.cFileName, TRUE, lpSI, &fCreated);

    }
    else
    {
        iRet = 0;
        if (IsFile(vsFind32.dwFileAttributes))
        {
            if (ExcludeFromCreateShadow(vsFind32.cFileName, wstrlen(vsFind32.cFileName), TRUE))
            {
                iRet = -1;
                SetLastErrorLocal(ERROR_INVALID_NAME);
            }
        }

        if (iRet == 0)
        {
            iRet = CreateShadow(lpSI->hDir, &vsFind32, lpSI->uStatus, &(lpSI->hShadow), &fCreated);
        }
    }

    if (iRet < SRET_OK)
    {
        lpSI->dwError = GetLastErrorLocal();
    }
    LeaveShadowCrit();

    iRet = (iRet>=SRET_OK)?1:-1;

    if ((iRet==1) && fCreated)
    {
        ReportCreateDelete(lpSI->hShadow, TRUE);
    }

    lpSI->lpFind32 = lpFind32;
    return (iRet);
}

int IoctlDeleteShadow(
    LPSHADOWINFO    lpSI
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet=SRET_ERROR;
    BOOL fDoit = TRUE;
    PFDB pFdb;

    DeclareFindFromShadowOnNtVars()

    if (!CSC_ENABLED)
    {
        lpSI->dwError = ERROR_SERVICE_NOT_ACTIVE;
        return -1;
    }

    EnterShadowCrit();

    if (FailModificationsToShare(lpSI))
    {
        goto bailout;
    }

    if (!lpSI->hDir)
    {
        if (PFindResourceFromRoot(lpSI->hShadow, 0xffff, 0))
        {
            fDoit = FALSE;
        }
    }
    else if (pFdb = PFindFdbFromHShadow(lpSI->hShadow))
    {
        // Issue a flush to see if the file is in delayclose list
        MRxSmbCscFlushFdb(pFdb);

        if (PFindFdbFromHShadow(lpSI->hShadow))
        {
            fDoit = FALSE;
        }
    }
    else if (PFindFindInfoFromHShadow(lpSI->hShadow))
    {
        fDoit = FALSE;
    }
    else
    {
//        DbgPrint("%x has an FCB\n", lpSI->hShadow);
//        Assert(FALSE);
    }

    // if the shadow is not busy in some transaction, delete it
    if (fDoit)
    {
        iRet = DeleteShadow(lpSI->hDir, lpSI->hShadow);
        if (iRet>=SRET_OK)
        {
            ReportCreateDelete(lpSI->hShadow, FALSE);
        }
        else
        {
//            DbgPrint("%x is open on the disk\n", lpSI->hShadow);
//            Assert(FALSE);
        }
    }
bailout:
    if (iRet < SRET_OK)
    {
        lpSI->dwError = GetLastErrorLocal();
    }
    LeaveShadowCrit();
    return ((iRet >=SRET_OK)?1:-1);
}

int IoctlGetShareStatus(
    LPSHADOWINFO    lpSI
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet;
    PRESOURCE pResource;
    SHAREINFOW *lpShareInfo = (SHAREINFOW *)(lpSI->lpFind32); // save it because, getserverinfo destory's it

    DeclareFindFromShadowOnNtVars()

    if (!CSC_ENABLED)
    {
        lpSI->dwError = ERROR_SERVICE_NOT_ACTIVE;
        return -1;
    }

    EnterShadowCrit();
    UseGlobalFind32();

    Assert(sizeof(SHAREINFOW) <= sizeof(WIN32_FIND_DATA));

    iRet = GetShareInfo(lpSI->hShare, (LPSHAREINFOW)(&vsFind32), lpSI);

    if (iRet >= SRET_OK)
    {
        if (lpShareInfo)
        {
            *lpShareInfo = *(LPSHAREINFOW)(&vsFind32);
        }

        if (pResource = PFindResourceFromHShare(lpSI->hShare, 0xffff, 0))
        {
            IFNOT_CSC_RECORDMANAGER_WINNT
            {
                lpSI->uStatus |= ((pResource->usLocalFlags|SHARE_CONNECTED)|
                              ((pResource->pheadFdb)?SHARE_FILES_OPEN:0) |
                              ((pResource->pheadFindInfo) ?SHARE_FINDS_IN_PROGRESS:0));
            }
            else
            {
                lpSI->uStatus |= MRxSmbCscGetSavedResourceStatus();
            }
        }
        // UI expects to know whether a server is offline
        // even when a share may not be offline. So we do the following drill anyways
        {
#ifdef CSC_RECORDMANAGER_WINNT
            BOOL    fShareOnline = FALSE;
            BOOL    fPinnedOffline = FALSE;
            if (MRxSmbCscServerStateFromCompleteUNCPath(
                ((LPSHAREINFOW)(&vsFind32))->rgSharePath,
                &fShareOnline,
                &fPinnedOffline)==STATUS_SUCCESS) {
                if (!fShareOnline)
                    lpSI->uStatus |= SHARE_DISCONNECTED_OP;
                if (fPinnedOffline)
                    lpSI->uStatus |= SHARE_PINNED_OFFLINE;
            }
#endif
        }
    }

    if (iRet < SRET_OK)
    {
        lpSI->dwError = GetLastErrorLocal();
    }

    LeaveShadowCrit();

    return ((iRet >=SRET_OK)?1:-1);
}

int IoctlSetShareStatus(
    LPSHADOWINFO    lpSI
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet=SRET_ERROR;
    HSHARE hShare = lpSI->hShare;
    ULONG   uStatus = lpSI->uStatus, uOp = lpSI->uOp;
    DWORD   cntDirty = 0;

    if (!CSC_ENABLED)
    {
        lpSI->dwError = ERROR_SERVICE_NOT_ACTIVE;
        return -1;
    }

    EnterShadowCrit();

    if (!FailModificationsToShare(lpSI))
    {
        iRet = SRET_OK;

        if (((uOp == SHADOW_FLAGS_ASSIGN)||(uOp == SHADOW_FLAGS_AND))&&!(uStatus & SHARE_REINT))
        {
            iRet = GetShareInfo(hShare, NULL, lpSI);

            if (iRet >= SRET_OK)
            {
                if (lpSI->uStatus & SHARE_REINT)
                {
                    iRet = TraversePQToCheckDirtyBits(hShare, &cntDirty);

                    // if the traversal failed, or there are some dirty entries
                    // then putback the dirty bit

                    if ((iRet==SRET_ERROR) || cntDirty)
                    {
                        uStatus |= SHARE_REINT;
                    }
                }
            }

        }

        if (iRet >= SRET_OK)
        {
            SetResourceFlags(hShare, uStatus, uOp);
            iRet = SetShareStatus(hShare, uStatus, uOp);
        }
    }

    if (iRet < SRET_OK)
    {
        lpSI->dwError = GetLastErrorLocal();
    }
    LeaveShadowCrit();

    return ((iRet >=SRET_OK)?1:-1);
}

#ifndef CSC_RECORDMANAGER_WINNT
int IoctlAddUse(
    LPCOPYPARAMSA lpCPA
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    struct netuse_info nu;
    struct use_info_2 ui;
    int iRet=-1;
    PRESOURCE    pResource=NULL;
    HSHADOW hRoot;
    ULONG uShareStatus;
    BOOL fAlloced = FALSE, fOfflinePath=FALSE;
    path_t ppath;
    HSHARE  hShare;

#ifdef DEBUG
    int indx = 0;
#endif //DEBUG

#ifdef MAYBE
    if (!CSC_ENABLED)
    {
        return -1;
    }

    // Don't add shadow use for the agent
    if (IsSpecialApp())
    {
        lpCPA->hDir = lpCPA->dwError = ERROR_BAD_NETPATH;
        return (-1);
    }
#endif

    memset(&ui, 0, sizeof(ui));
    if (lpCPA->lpLocalPath)
    {
        strcpy(ui.ui2_local, lpCPA->lpLocalPath);
#ifdef DEBUG
        indx = GetDriveIndex(lpCPA->lpLocalPath);
#endif //DEBUG
    }

    if (ppath = (path_t)AllocMem((strlen(lpCPA->lpRemotePath)+4)*sizeof(USHORT)))
    {
        MakePPath(ppath, lpCPA->lpRemotePath);

        if (fOfflinePath = IsOfflinePE(ppath->pp_elements))
        {
            OfflineToOnlinePath(ppath);
        }

        EnterShadowCrit();
        UseGlobalFind32();
        hShare = HShareFromPath(NULL, ppath->pp_elements, 0, &vsFind32, &hRoot, &uShareStatus);
        LeaveShadowCrit();

        if (fOfflinePath)
        {
            OnlineToOfflinePath(ppath);
        }

        // Has connect succeeded with this server in the past?
        if (hShare)
        {
            // Any resource allocated by shadow NP?
            pResource = PFindResource(ppath->pp_elements
                                                , RH_DISCONNECTED
                                                , ANY_FHID
                                                , FLAG_RESOURCE_SHADOWNP
                                                , NULL);

            if (!pResource)
            {
                pResource = PCreateResource(ppath->pp_elements);
                if (pResource)
                {
                    fAlloced = TRUE;
                    DisconnectAllByName(pResource->pp_elements);
                    pResource->usLocalFlags |=
                            (FLAG_RESOURCE_SHADOW_CONNECT_PENDING
                            | ((fOfflinePath)?FLAG_RESOURCE_OFFLINE_CONNECTION:0));
                    LinkResource(pResource, &rgNetPro[0]);
                    KdPrint(("shadow:Created pending resource %x \r\n", pResource));
                }
            }
        }
        FreeMem(ppath);
    }


    if (pResource)
    {
        // need to tell IFS about the use

        ui.ui2_remote = lpCPA->lpRemotePath;
        ui.ui2_password="";
        ui.ui2_asg_type = USE_DISKDEV;
        ui.ui2_res_type = USE_RES_UNC;
        nu.nu_data = &ui;
        nu.nu_flags = FSD_NETAPI_USEOEM;
        nu.nu_info = (int)(pResource);

        iRet = IFSMgr_UseAdd(NULL, proidShadow, &nu);

        if (iRet)
        {
            lpCPA->hDir = (ULONG)iRet;
            KdPrint(("SHADOW::IoctlAddUse: error %x \r\n", iRet));
            if (fAlloced)
            {
                PUnlinkResource(pResource, &rgNetPro[0]);
                DestroyResource(pResource);
            }
            iRet = -1;
        }
        else
        {
            // AddUse succeeded
            lpCPA->hDir = 0;
            iRet = 1;
        }
    }

bailout:
    return (iRet);
}

int IoctlDelUse(
    LPCOPYPARAMSA lpCPA
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int indx, iRet=-1;
    PRESOURCE pResource;
    struct netuse_info nu;
    struct use_info_2    ui;
    BOOL fDoit = FALSE;

    if (!CSC_ENABLED)
    {
        return -1;
    }

    if (*(lpCPA->lpRemotePath+1)==':')
    {
        indx = GetDriveIndex(lpCPA->lpRemotePath);
        if (indx  && PFindShadowResourceFromDriveMap(indx))
        {
            fDoit = TRUE;
        }
    }
    else
    {
        EnterShadowCrit();
        UseGlobalFind32();
        if (strlen(lpCPA->lpRemotePath) < (sizeof(vsFind32.cFileName)/2-2))
        {
            MakePPath((path_t)(vsFind32.cFileName), lpCPA->lpRemotePath);

            if (PFindResource(((path_t)(vsFind32.cFileName))->pp_elements, 0, ANY_FHID, FLAG_RESOURCE_DISCONNECTED, NULL))
            {
                fDoit = TRUE;
            }
        }
        LeaveShadowCrit();
    }

    if (fDoit)
    {
        memset (&ui, 0, sizeof(ui));
        strcpy (ui.ui2_local, lpCPA->lpRemotePath);
        nu.nu_data  = &ui.ui2_local;
        nu.nu_flags = FSD_NETAPI_USEOEM;
        nu.nu_info = (lpCPA->hShadow)?3:0;
        if(!(lpCPA->hDir = IFSMgr_UseDel(0, proidShadow, &nu)))
        {
            iRet = 1;
        }
    }
    else
    {
        lpCPA->hDir = ERROR_BAD_NETPATH;
    }

    return (iRet);
}

int IoctlGetUse(
    LPCOPYPARAMSA lpCPA
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int indx;
    PRESOURCE pResource;

    if (!CSC_ENABLED)
    {
        return -1;
    }

    indx = GetDriveIndex(lpCPA->lpLocalPath);
    if (!indx)
        return (-1);

    if (pResource = PFindShadowResourceFromDriveMap(indx))
    {
        if (PpeToSvr(pResource->pp_elements, lpCPA->lpRemotePath, lpCPA->hShadow, 0))
        {
            return (1);
        }
    }
    return (-1);
}
#endif //ifndef CSC_RECORDMANAGER_WINNT

int IoctlSwitches(
    LPSHADOWINFO lpSI
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    BOOL fRet = 1;


    switch (lpSI->uOp)
    {
        case SHADOW_SWITCH_GET_STATE:
        {
            lpSI->uStatus = ((fShadow)?SHADOW_SWITCH_SHADOWING:0)
                                    |((fLog)?SHADOW_SWITCH_LOGGING:0)
                                    /*|((fShadowFind)?SHADOW_SWITCH_SHADOWFIND:0)*/
                                    |((fSpeadOpt)?SHADOW_SWITCH_SPEAD_OPTIMIZE:0)
#if defined(REMOTE_BOOT)
                                    | ((fIsRemoteBootSystem)?SHADOW_SWITCH_REMOTE_BOOT:0)
#endif // defined(REMOTE_BOOT)
                                    ;
            if (lpSI->lpFind32)
            {
                if (fShadow)
                {
                    EnterShadowCrit();
                    UseGlobalFind32();

                    fRet = GetDatabaseLocation((LPSTR)(vsFind32.cFileName));

                    Assert(fRet >= 0);

                    fRet = BCSToUni( lpSI->lpFind32->cFileName,
                                (LPSTR)(vsFind32.cFileName),
                                MAX_PATH,
                                BCS_WANSI);
                    Assert(fRet > 0);
                    fRet = 1;
                    LeaveShadowCrit();
                }
                else
                {
                    fRet = -1;
                    lpSI->dwError = ERROR_INVALID_ACCESS;
                }
            }
            break;
        }
        case SHADOW_SWITCH_OFF:
        {
            if (mQueryBits(lpSI->uStatus, SHADOW_SWITCH_LOGGING))
            {
                fLog = 0;
                mClearBits(lpSI->uStatus, SHADOW_SWITCH_LOGGING);
            }
            if (mQueryBits(lpSI->uStatus, SHADOW_SWITCH_SHADOWING))
            {
                // DbgPrint("Agent closing database fShadow=%x\r\n", fShadow);

                if (fShadow)
                {
                    EnterShadowCrit();


                    if (hPQEnumCookieForIoctls != NULL)
                    {
                        EndPQEnum(hPQEnumCookieForIoctls);
                        hPQEnumCookieForIoctls = NULL;
                    }

                    CloseDatabase();

                    fShadow = 0;

                    mClearBits(lpSI->uStatus, SHADOW_SWITCH_SHADOWING);

                    LeaveShadowCrit();
                }
            }
#ifdef HISTORY
            if (mQueryBits(lpSI->uStatus, SHADOW_SWITCH_SHADOWFIND))
            {
                fShadowFind = 0;
                mClearBits(lpSI->uStatus, SHADOW_SWITCH_SHADOWFIND);
            }
#endif //HISTORY
            if (mQueryBits(lpSI->uStatus, SHADOW_SWITCH_SPEAD_OPTIMIZE))
            {
                fSpeadOpt = 0;
                mClearBits(lpSI->uStatus, SHADOW_SWITCH_SPEAD_OPTIMIZE);
            }
            break;
        }
        case SHADOW_SWITCH_ON:
        {
            if (mQueryBits(lpSI->uStatus, SHADOW_SWITCH_LOGGING))
            {
#ifdef CSC_RECORDMANAGER_WINNT
#if defined(_X86_)
                fLog = 1;
                mClearBits(lpSI->uStatus, SHADOW_SWITCH_LOGGING);
#endif
#else
                fLog = 1;
                mClearBits(lpSI->uStatus, SHADOW_SWITCH_LOGGING);
#endif

            }
            if (mQueryBits(lpSI->uStatus, SHADOW_SWITCH_SHADOWING))
            {
                if (!fShadow)
                {
                    if (OK_TO_ENABLE_CSC)
                    {
                        Assert(lpSI->lpFind32);
                        //
                        // Check that cFileName and cAlternateFileName contain a NULL
                        //
                        if (CscCheckForNullA(((LPFIND32A)(lpSI->lpFind32))->cFileName, MAX_PATH) == FALSE) {
                            lpSI->dwError = ERROR_INVALID_PARAMETER;
                            return -1;
                        }
                        if (CscCheckForNullA(((LPFIND32A)(lpSI->lpFind32))->cAlternateFileName, 14) == FALSE) {
                            lpSI->dwError = ERROR_INVALID_PARAMETER;
                            return -1;
                        }
                        // check if we can initialize the database
//                        KdPrint(("Trying to shadow....%s\n",
//                                       ((LPFIND32A)(lpSI->lpFind32))->cFileName));
                        EnterShadowCrit();
                        if(InitDatabase(
                                ((LPFIND32A)(lpSI->lpFind32))->cFileName,            // location
                                ((LPFIND32A)(lpSI->lpFind32))->cAlternateFileName,    // user
                                ((LPFIND32A)(lpSI->lpFind32))->nFileSizeHigh,        // default cache size if creating
                                ((LPFIND32A)(lpSI->lpFind32))->nFileSizeLow,
                                ((LPFIND32A)(lpSI->lpFind32))->dwReserved1, // cluster size
                                lpSI->ulRefPri,
                                &(lpSI->uOp))    // whether newly created
                                ==-1)
                        {
                            //we can't, let us quit
                            lpSI->dwError = GetLastErrorLocal();
                            fRet = -1;
                            LeaveShadowCrit();
                            break;
                        }
                        LeaveShadowCrit();

//                        KdPrint(("Starting to shadow....\n"));
                        fShadow = 1;
                    }
                    else
                    {
                        //we are not supposed to turn on csc. This happens only on NT
                        lpSI->dwError = ERROR_ACCESS_DENIED;
                        fRet = -1;
                        break;
                    }
                }

                mClearBits(lpSI->uStatus, SHADOW_SWITCH_SHADOWING);
            }
#ifdef HISTORY
            if (mQueryBits(lpSI->uStatus, SHADOW_SWITCH_SHADOWFIND))
            {
                fShadowFind = 1;
                mClearBits(lpSI->uStatus, SHADOW_SWITCH_SHADOWFIND);
            }
#endif //HISTORY
            if (mQueryBits(lpSI->uStatus, SHADOW_SWITCH_SPEAD_OPTIMIZE))
            {
                fSpeadOpt = 1;
                mClearBits(lpSI->uStatus, SHADOW_SWITCH_SPEAD_OPTIMIZE);
            }
            break;
        }
    }
    return (fRet);
}

int IoctlGetShadow(
    LPSHADOWINFO lpSI
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet=-1, iRet1;
    OTHERINFO sOI;
    PFDB pFdb=NULL;
    PRESOURCE    pResource=NULL;


    if (!CSC_ENABLED)
    {
        lpSI->dwError = ERROR_SERVICE_NOT_ACTIVE;
        return -1;
    }

    EnterShadowCrit();
    UseGlobalFind32();
    iRet1 = GetShadow(lpSI->hDir, lpSI->lpFind32->cFileName, &(lpSI->hShadow), &vsFind32, &(lpSI->uStatus), &sOI);

    // If it worked and we have a shadow ID which is a filesystem object
    if ((iRet1 >= SRET_OK)&& !mNotFsobj(lpSI->uStatus))
    {
        if (lpSI->hShadow)
        {
            if (lpSI->hDir)
            {
                if (!(vsFind32.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
                {

                    lpSI->uStatus |= SHADOW_IS_FILE;

                    if(pFdb = PFindFdbFromHShadow(lpSI->hShadow))
                    {
                        lpSI->uStatus |= (SHADOW_FILE_IS_OPEN | pFdb->usFlags);
                    }
                }
            }
            else
            {
                // this is a share

                DeclareFindFromShadowOnNtVars()
                if(pResource = PFindResourceFromRoot(lpSI->hShadow, 0xffff, 0))
                {
                    IFNOT_CSC_RECORDMANAGER_WINNT
                    {
                        lpSI->uStatus |= ((pResource->usLocalFlags|SHARE_CONNECTED)|
                                      ((pResource->pheadFdb)?SHARE_FILES_OPEN:0) |
                                      ((pResource->pheadFindInfo) ?SHARE_FINDS_IN_PROGRESS:0));
                    }
                    else
                    {
                        lpSI->uStatus |= MRxSmbCscGetSavedResourceStatus();
                    }
                }
                // UI expects to know whether a server is offline
                // even when a share may not be offline. So we do the following drill anyways
                {
#ifdef CSC_RECORDMANAGER_WINNT
                    BOOL    fShareOnline = FALSE;
                    BOOL    fPinnedOffline = FALSE;
                    if (MRxSmbCscServerStateFromCompleteUNCPath(
                            lpSI->lpFind32->cFileName,
                            &fShareOnline,
                            &fPinnedOffline)==STATUS_SUCCESS) {
                        if (!fShareOnline)
                            lpSI->uStatus |= SHARE_DISCONNECTED_OP;
                        if (fPinnedOffline)
                            lpSI->uStatus |= SHARE_PINNED_OFFLINE;
                    }
#endif
                }
            }


            CopyOtherInfoToShadowInfo(&sOI, lpSI);

            if(GetAncestorsHSHADOW(lpSI->hShadow, NULL, &(lpSI->hShare)) < SRET_OK)
            {
                goto bailout;
            }

            *(lpSI->lpFind32) = vsFind32;

        }

        iRet = 1;

        // if we couldn't find it in the database, and we are doing lookups for shares
        // then let us lookup the in-memory data strucutres
        if (!lpSI->hShadow && !lpSI->hDir)
        {
#ifndef CSC_RECORDMANAGER_WINNT
            {
                path_t ppath;

                memset((LPSTR)(vsFind32.cFileName), 0, sizeof(vsFind32.cFileName));

                UniToBCS((LPSTR)(vsFind32.cFileName),
                         lpSI->lpFind32->cFileName,
                         wstrlen(lpSI->lpFind32->cFileName)*sizeof(USHORT),
                         sizeof(vsFind32.cFileName),
                         BCS_WANSI);

                if (ppath = (path_t)AllocMem((strlen((LPSTR)(vsFind32.cFileName))+4)*sizeof(USHORT)))
                {
                    MakePPath(ppath, (LPSTR)(vsFind32.cFileName));
                    pResource = PFindResource(ppath->pp_elements
                                                        , ANY_RESOURCE
                                                        , ANY_FHID
                                                        , 0xffff
                                                        , NULL);
                    if (pResource)
                    {
                        lpSI->uStatus = ResourceCscBitsToShareCscBits(mGetCSCBits(pResource));
                        lpSI->uStatus |= SHARE_CONNECTED;
                    }

                    FreeMem(ppath);

                }
            }
#else
            {
                if(MRxSmbCscCachingBitsFromCompleteUNCPath(lpSI->lpFind32->cFileName,
                                &(lpSI->uStatus)) == STATUS_SUCCESS)
                {
                    lpSI->uStatus |= SHARE_CONNECTED;
                }
            }
#endif

        }
    }


bailout:
    if (iRet < SRET_OK)
    {
        lpSI->dwError = GetLastErrorLocal();
    }
    LeaveShadowCrit();


    return (iRet);
}


int IoctlAddHint(        // Add a new hint or change an existing hint
    LPSHADOWINFO    lpSI
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet;
    OTHERINFO    sOI;

    if (!CSC_ENABLED)
    {
        lpSI->dwError = ERROR_SERVICE_NOT_ACTIVE;
        return -1;
    }

    EnterShadowCrit();
    UseGlobalFind32();
    vsFind32 = *(lpSI->lpFind32);

//    BCSToUni(vsFind32.cFileName, (LPSTR)(lpSI->lpFind32->cFileName), MAX_PATH, BCS_WANSI);
    if (lpSI->hDir)
    {
        iRet = CreateHint(lpSI->hDir, &vsFind32, lpSI->ulHintFlags, lpSI->ulHintPri, &(lpSI->hShadow));
#ifdef MAYBE
        if (iRet == SRET_OBJECT_HINT)
        {
            if(RecalcIHPri(lpSI->hDir, lpSI->hShadow, &vsFind32, &sOI)>=SRET_OK)
            {
                SetPriorityHSHADOW(lpSI->hDir, lpSI->hShadow, RETAIN_VALUE, sOI.ulIHPri);
            }
        }
#endif //MAYBE
    }
    else
    {
        iRet = CreateGlobalHint(vsFind32.cFileName, lpSI->ulHintFlags, lpSI->ulHintPri);
    }

    if (iRet < SRET_OK)
    {
        lpSI->dwError = GetLastErrorLocal();
    }

    LeaveShadowCrit();
    return ((iRet >= SRET_OK)?1:-1);
}

int IoctlDeleteHint(    // Delete an existing hint
    LPSHADOWINFO lpSI
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet;
    BOOL fClearAll = (lpSI->ulHintPri == 0xffffffff);

    if (!CSC_ENABLED)
    {
        lpSI->dwError = ERROR_SERVICE_NOT_ACTIVE;
        return -1;
    }

    EnterShadowCrit();
    UseGlobalFind32();
    vsFind32 = *(lpSI->lpFind32);

//    BCSToUni(vsFind32.cFileName, (LPSTR)(lpSI->lpFind32->cFileName), MAX_PATH, BCS_WANSI);
    if (lpSI->hDir)
    {
        iRet = DeleteHint(lpSI->hDir, vsFind32.cFileName, fClearAll);
    }
    else
    {
        iRet = DeleteGlobalHint(vsFind32.cFileName,  fClearAll);
    }
    if (iRet < SRET_OK)
    {
        lpSI->dwError = GetLastErrorLocal();
    }
    LeaveShadowCrit();
    return ((iRet >= SRET_OK)?1:-1);
}

int IoctlGetHint(
    LPSHADOWINFO    lpSI
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet;
    OTHERINFO sOI;

    if (!CSC_ENABLED)
    {
        lpSI->dwError = ERROR_SERVICE_NOT_ACTIVE;
        return -1;
    }

    EnterShadowCrit();
    UseGlobalFind32();

    iRet = GetShadow(lpSI->hDir, lpSI->lpFind32->cFileName, &(lpSI->hShadow), &vsFind32, &(lpSI->uStatus), &sOI);

    if ((iRet>=SRET_OK) && (lpSI->hShadow) && mIsHint(sOI.ulHintFlags))
    {
        CopyOtherInfoToShadowInfo(&sOI, lpSI);
        iRet = 1;
    }
    else
    {
        SetLastErrorLocal(ERROR_INVALID_ACCESS);

        iRet = -1;
    }
    if (iRet < SRET_OK)
    {
        lpSI->dwError = GetLastErrorLocal();
    }

    LeaveShadowCrit();
    return (iRet);
}

int IoctlFindOpenHSHADOW(
    LPSHADOWINFO    lpSI
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet=-1;
    LPFINDSHADOW lpFSH;
    HSHADOW hTmp;
    ULONG uSrchFlags;
    PRESOURCE    pResource=NULL;
    OTHERINFO sOI;
    DeclareFindFromShadowOnNtVars()
    PFDB    pFdb = NULL;

    if (!CSC_ENABLED)
    {
        lpSI->dwError = ERROR_SERVICE_NOT_ACTIVE;
        return -1;
    }

    EnterShadowCrit();
    UseGlobalFind32();
    if (!lpDeleteCBForIoctl)
    {
        lpDeleteCBForIoctl = DeleteCallbackForFind;
    }
    uSrchFlags = FLAG_FINDSHADOW_META|FLAG_FINDSHADOW_NEWSTYLE
                     |((lpSI->uOp & FINDOPEN_SHADOWINFO_NORMAL)?FLAG_FINDSHADOW_ALLOW_NORMAL:0)
                     |((lpSI->uOp & FINDOPEN_SHADOWINFO_SPARSE)?FLAG_FINDSHADOW_ALLOW_SPARSE:0)
                     |((lpSI->uOp & FINDOPEN_SHADOWINFO_DELETED)?FLAG_FINDSHADOW_ALLOW_DELETED:0);

    lpFSH = LpCreateFindShadow(lpSI->hDir, lpSI->lpFind32->dwFileAttributes
                                        ,uSrchFlags
                                        ,lpSI->lpFind32->cFileName, FsobjMMProc);
    if (lpFSH)
    {
        if (FindOpenHSHADOW(lpFSH, &hTmp, &vsFind32, &(lpSI->uStatus), &sOI) >= SRET_OK)
        {
            CopyOtherInfoToShadowInfo(&sOI, lpSI);

            if(GetAncestorsHSHADOW(hTmp, &(lpSI->hDir), &(lpSI->hShare)) < SRET_OK)
            {
                goto bailout;
            }

            *(lpSI->lpFind32) = vsFind32;

            lpSI->hShadow = hTmp;
            lpSI->uEnumCookie = (CSC_ENUMCOOKIE)lpFSH;
            iRet = 1;

            // check if this is a root
            if(!lpFSH->hDir)
            {
                // the status bits we got are for the root
                lpSI->uRootStatus = sOI.ulRootStatus;

                // the server status is part of the otherinfo.
                lpSI->uStatus = lpSI->uStatus;

                if(pResource = PFindResourceFromRoot(lpSI->hShadow, 0xffff, 0))
                {
                    IFNOT_CSC_RECORDMANAGER_WINNT
                    {
                        lpSI->uStatus |= ((pResource->usLocalFlags|SHARE_CONNECTED)|
                                     ((pResource->pheadFdb)?SHARE_FILES_OPEN:0) |
                                     ((pResource->pheadFindInfo) ?SHARE_FINDS_IN_PROGRESS:0));
                        lpSI->uOp = pResource->uDriveMap;
                    }
                    else
                    {
                        lpSI->uStatus |= MRxSmbCscGetSavedResourceStatus();
                        lpSI->uOp = MRxSmbCscGetSavedResourceDriveMap();
                    }
                }
                // UI expects to know whether a server is offline
                // even when a share may not be offline. So we do the following drill anyways
                {
#ifdef CSC_RECORDMANAGER_WINNT
                    BOOL    fShareOnline = FALSE;
                    BOOL    fPinnedOffline = FALSE;
                    if (MRxSmbCscServerStateFromCompleteUNCPath(
                            lpSI->lpFind32->cFileName,
                            &fShareOnline,
                            &fPinnedOffline)==STATUS_SUCCESS) {
                        if (!fShareOnline)
                            lpSI->uStatus |= SHARE_DISCONNECTED_OP;
                        if (fPinnedOffline)
                            lpSI->uStatus |= SHARE_PINNED_OFFLINE;
                    }
#endif
                }

            }
            else
            {
                // not a root, if this is a file and it is open
                // let the caller know that
                if (!(vsFind32.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
                {
                    lpSI->uStatus |= SHADOW_IS_FILE;

                    if (pFdb = PFindFdbFromHShadow(lpSI->hShadow))
                    {
                        lpSI->uStatus |= (SHADOW_FILE_IS_OPEN | pFdb->usFlags);
                    }
                }

            }
        }
        else
        {
            DestroyFindShadow(lpFSH);
        }
    }

    if (hShareReint && (lpSI->hShare == hShareReint))
    {
        lpSI->uStatus |= SHARE_MERGING;
    }
bailout:
    if (iRet < 0)
    {
        lpSI->dwError = GetLastErrorLocal();
    }
    LeaveShadowCrit();
    return(iRet);
}

int IoctlFindNextHSHADOW(
    LPSHADOWINFO    lpSI
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int             iRet=-1;
    LPFINDSHADOW    lpFSH = (LPFINDSHADOW)(lpSI->uEnumCookie);
    LPFINDSHADOW    lpFSHtmp = NULL;
    HSHADOW         hTmp;
    PRESOURCE       pResource=NULL;
    OTHERINFO       sOI;
    PFDB    pFdb = NULL;
    DeclareFindFromShadowOnNtVars()

    if (!CSC_ENABLED)
    {
        lpSI->dwError = ERROR_SERVICE_NOT_ACTIVE;
        return -1;
    }

    EnterShadowCrit();
    UseGlobalFind32();
    if (lpFSH)
    {
        //
        // Verify that the lpFSH is in fact one we gave out; ie it is on the
        // vlpFindShadowList.
        //
        for (lpFSHtmp = vlpFindShadowList; lpFSHtmp; lpFSHtmp = lpFSHtmp->lpFSHNext) {
            if (lpFSHtmp == lpFSH) {
                break;
            }
        }
        if (lpFSHtmp != lpFSH) {
            SetLastErrorLocal(ERROR_INVALID_PARAMETER);
            iRet = -1;
            goto bailout;
        }
        // check if the directory has been deleted in the meanwhile
        if (!(lpFSH->ulFlags & FLAG_FINDSHADOW_INVALID_DIRECTORY))
        {
            if (FindNextHSHADOW(lpFSH, &hTmp, &vsFind32, &(lpSI->uStatus), &sOI) >= SRET_OK)
            {
                CopyOtherInfoToShadowInfo(&sOI, lpSI);
                if(GetAncestorsHSHADOW(hTmp, &(lpSI->hDir), &(lpSI->hShare)) < SRET_OK)
                {
                    goto bailout;
                }

                *(lpSI->lpFind32) = vsFind32;

                lpSI->hShadow = hTmp;
                iRet = 1;

                // check if this is a root
                if(!lpFSH->hDir)
                {
                    // the status bits we got are for the root
                    lpSI->uRootStatus = sOI.ulRootStatus;

                    // the server status is part of the otherinfo.
                    lpSI->uStatus = lpSI->uStatus;

                    if(pResource = PFindResourceFromRoot(lpSI->hShadow, 0xffff, 0))
                    {
                        IFNOT_CSC_RECORDMANAGER_WINNT
                        {
                            lpSI->uStatus |= ((pResource->usLocalFlags|SHARE_CONNECTED)|
                                         ((pResource->pheadFdb)?SHARE_FILES_OPEN:0) |
                                         ((pResource->pheadFindInfo) ?SHARE_FINDS_IN_PROGRESS:0));
                            lpSI->uOp = pResource->uDriveMap;
                        }
                        else
                        {
                            lpSI->uStatus |= MRxSmbCscGetSavedResourceStatus();
                            lpSI->uOp = MRxSmbCscGetSavedResourceDriveMap();
                        }
                    }
                    {
#ifdef CSC_RECORDMANAGER_WINNT
                        BOOL    fShareOnline = FALSE;
                        BOOL    fPinnedOffline = FALSE;
                        if (MRxSmbCscServerStateFromCompleteUNCPath(
                                lpSI->lpFind32->cFileName,
                                &fShareOnline,
                                &fPinnedOffline)==STATUS_SUCCESS) {
                            if (!fShareOnline)
                                lpSI->uStatus |= SHARE_DISCONNECTED_OP;
                            if (fPinnedOffline)
                                lpSI->uStatus |= SHARE_PINNED_OFFLINE;
                        }
#endif
                    }
                }
                else
                {
                    // not a root, if this is a file and it is open
                    // let the caller know that
                    if (!(vsFind32.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
                    {
                        lpSI->uStatus |= SHADOW_IS_FILE;

                        if (pFdb = PFindFdbFromHShadow(lpSI->hShadow))
                        {
                            // or in the latest known bits
                            lpSI->uStatus |= (SHADOW_FILE_IS_OPEN | pFdb->usFlags);
                        }
                    }

                }
            }
        }
    }

    if (hShareReint && (lpSI->hShare == hShareReint))
    {
        lpSI->uStatus |= SHARE_MERGING;
    }

bailout:
    if (iRet < 0)
    {
        lpSI->dwError = GetLastErrorLocal();
    }
    LeaveShadowCrit();
    return(iRet);
}


int IoctlFindCloseHSHADOW(
    LPSHADOWINFO    lpSI
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet = -1;
    LPFINDSHADOW lpFSH = (LPFINDSHADOW)(lpSI->uEnumCookie);

    if (!CSC_ENABLED)
    {
        lpSI->dwError = ERROR_SERVICE_NOT_ACTIVE;
        return -1;
    }

    EnterShadowCrit();
    if (lpFSH)
    {
        DestroyFindShadow(lpFSH);
        iRet = 1;
    }
    LeaveShadowCrit();
    return(iRet);
}

int IoctlFindOpenHint(
    LPSHADOWINFO    lpSI
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet=-1;
    LPFINDSHADOW lpFSH;
    OTHERINFO    sOI;
    HSHADOW  hTmp;

    if (!CSC_ENABLED)
    {
        return -1;
    }

    EnterShadowCrit();
    UseGlobalFind32();
    lpFSH = LpCreateFindShadow(lpSI->hDir, 0,
                                        FLAG_FINDSHADOW_META|FLAG_FINDSHADOW_NEWSTYLE,
                                        (lpSI->lpFind32->cFileName), HintobjMMProc);
    if (lpFSH)
    {
        if (FindOpenHSHADOW(lpFSH, &hTmp, &vsFind32, &(lpSI->uStatus), &sOI) >= SRET_OK)
        {
            *(lpSI->lpFind32) = vsFind32;
//            Find32AFromFind32((LPFIND32A)(lpSI->lpFind32), &vsFind32, BCS_WANSI);

            CopyOtherInfoToShadowInfo(&sOI, lpSI);
            lpSI->hShare = vsFind32.dwReserved0;
            lpSI->hShadow = hTmp;
            lpSI->uEnumCookie = (CSC_ENUMCOOKIE)lpFSH;
            iRet = 1;
        }
        else
        {
            DestroyFindShadow(lpFSH);
        }
    }
    LeaveShadowCrit();
    return(iRet);
}

int IoctlFindNextHint(
    LPSHADOWINFO    lpSI
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet=-1;
    LPFINDSHADOW lpFSH = (LPFINDSHADOW)(lpSI->uEnumCookie);
    LPFINDSHADOW lpFSHtmp = NULL;
    OTHERINFO    sOI;
    HSHADOW  hTmp;

    if (!CSC_ENABLED)
    {
        return -1;
    }

    EnterShadowCrit();
    UseGlobalFind32();
    if (lpFSH)
    {
        //
        // Verify that the lpFSH is in fact one we gave out; ie it is on the
        // vlpFindShadowList.
        //
        for (lpFSHtmp = vlpFindShadowList; lpFSHtmp; lpFSHtmp = lpFSHtmp->lpFSHNext) {
            if (lpFSHtmp == lpFSH) {
                break;
            }
        }
        if (lpFSHtmp != lpFSH) {
            iRet = -1;
            goto AllDone;
        }
        if (FindNextHSHADOW(lpFSH, &hTmp, &vsFind32, &(lpSI->uStatus), &sOI) >= SRET_OK)
        {
            *(lpSI->lpFind32) = vsFind32;
//            Find32AFromFind32((LPFIND32A)(lpSI->lpFind32), &vsFind32, BCS_WANSI);

            lpSI->hShare = 0;
            lpSI->hShadow = hTmp;
            CopyOtherInfoToShadowInfo(&sOI, lpSI);
            iRet = 1;
        }
    }
AllDone:
    LeaveShadowCrit();
    return(iRet);
}


int IoctlFindCloseHint(
    LPSHADOWINFO    lpSI
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet = -1;
    LPFINDSHADOW lpFSH = (LPFINDSHADOW)(lpSI->uEnumCookie);

    if (!CSC_ENABLED)
    {
        return -1;
    }

    EnterShadowCrit();
    if (lpFSH)
    {
        DestroyFindShadow(lpFSH);
        iRet = 1;
    }
    LeaveShadowCrit();
    return(iRet);
}


int IoctlSetPriorityHSHADOW(
    LPSHADOWINFO    lpSI
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet=SRET_ERROR;

    if (!CSC_ENABLED)
    {
        lpSI->dwError = ERROR_SERVICE_NOT_ACTIVE;
        return -1;
    }

    EnterShadowCrit();
    if (!FailModificationsToShare(lpSI))
    {
        iRet = SetPriorityHSHADOW(lpSI->hDir, lpSI->hShadow, lpSI->ulRefPri, lpSI->ulHintPri);
    }
    if (iRet < 0)
    {
        lpSI->dwError = GetLastErrorLocal();
    }
    LeaveShadowCrit();
    return ((iRet >= SRET_OK)?1:-1);
}

int IoctlGetPriorityHSHADOW(
    LPSHADOWINFO    lpSI
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet;

    if (!CSC_ENABLED)
    {
        lpSI->dwError = ERROR_SERVICE_NOT_ACTIVE;
        return -1;
    }

    EnterShadowCrit();
    iRet = GetPriorityHSHADOW(lpSI->hDir, lpSI->hShadow, &(lpSI->ulRefPri), &(lpSI->ulHintPri));
    if (iRet < 0)
    {
        lpSI->dwError = GetLastErrorLocal();
    }
    LeaveShadowCrit();
    return ((iRet >= SRET_OK)?1:-1);
}


int IoctlGetAliasHSHADOW(
    LPSHADOWINFO    lpSI
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet;
    HSHADOW hShadow, hDir;

    if (!CSC_ENABLED)
    {
        return -1;
    }


    EnterShadowCrit();
    iRet = GetRenameAliasHSHADOW(lpSI->hDir, lpSI->hShadow
                , &hDir, &hShadow);
    lpSI->hDir = hDir;
    lpSI->hShadow = hShadow;
    LeaveShadowCrit();
    return ((iRet >= SRET_OK)?1:-1);
}



LPFINDSHADOW    LpCreateFindShadow(
    HSHADOW          hDir,
    ULONG           uAttrib,
    ULONG           uSrchFlags,
    USHORT          *lpPattern,
    METAMATCHPROC   lpfnMMProc
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int len;
    LPFINDSHADOW    lpFSH;

    //
    // Limit # outstanding FindOpens/HintOpens
    //
    if (vuFindShadowListCount >= 128) {
        return NULL;
    }

    len = wstrlen(lpPattern);
    lpFSH = (LPFINDSHADOW)AllocMem(sizeof(FINDSHADOW)+(len+1)*sizeof(USHORT));
    if (lpFSH)
    {
        lpFSH->lpPattern = (USHORT *)((UCHAR *)lpFSH + sizeof(FINDSHADOW));
        memcpy(lpFSH->lpPattern, lpPattern, (len+1)*sizeof(USHORT));

//        BCSToUni(lpFSH->lpPattern, lpPattern, len, BCS_WANSI);
        // Convert the patterns to uppercase, as demanded by metamatch
        UniToUpper(lpFSH->lpPattern, lpFSH->lpPattern, len*sizeof(USHORT));
        lpFSH->hDir = hDir;
        lpFSH->uAttrib = uAttrib;
        lpFSH->uSrchFlags = uSrchFlags;
        lpFSH->lpfnMMProc = lpfnMMProc;

        // link this in the list of outstanding ioctl finds
        lpFSH->lpFSHNext = vlpFindShadowList;
        vlpFindShadowList = lpFSH;
        vuFindShadowListCount++;
        ASSERT(vuFindShadowListCount <= 128);
    }
    return (lpFSH);
}


int DestroyFindShadow(
    LPFINDSHADOW    lpFSH
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet = -1;
    LPFINDSHADOW    *lplpFSHT;

    if (lpFSH)
    {
        for (lplpFSHT = &vlpFindShadowList; *lplpFSHT; lplpFSHT = &((*lplpFSHT)->lpFSHNext))
        {
            if (*lplpFSHT == lpFSH)
            {
                *lplpFSHT = lpFSH->lpFSHNext;
                FreeMem(lpFSH);
                vuFindShadowListCount--;
                ASSERT(vuFindShadowListCount >= 0);
                iRet = 1;
                break;
            }
        }
    }
    return (iRet);
}


int
DeleteCallbackForFind(
    HSHADOW hDir,
    HSHADOW hShadow
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    LPFINDSHADOW    lpFSH;
    int iRet = 0;
    for (lpFSH = vlpFindShadowList; lpFSH ; lpFSH = lpFSH->lpFSHNext)
    {
        if (lpFSH->hDir == hShadow)
        {
            lpFSH->ulFlags |= FLAG_FINDSHADOW_INVALID_DIRECTORY;
            ++iRet;
        }
    }
    return iRet;
}

int HintobjMMProc( LPFIND32 lpFind32,
    HSHADOW  hDir,
    HSHADOW  hShadow,
    ULONG uStatus,
    LPOTHERINFO lpOI,
    LPFINDSHADOW    lpFSH
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet;
    iRet = MM_RET_CONTINUE;    // Continue


    hDir;
    if (mIsHint(lpOI->ulHintFlags)&&
        IFSMgr_MetaMatch(lpFSH->lpPattern, lpFind32->cFileName,UFLG_NT|UFLG_META))
        iRet = MM_RET_FOUND_BREAK;

    return (iRet);
}


#ifdef MAYBE
int RecalcIHPri( HSHADOW  hDir,
    HSHADOW  hShadow,
    LPFIND32 lpFind32,
    LPOTHERINFO lpOI
    )
{
    USHORT *lpuType=NULL;
    int len, iRet=SRET_ERROR;
    SHADOWCHECK sSC;
    HSHADOW  hChild, hParent;
    ULONG ulFlagsIn, uStatus;

    if (GetShadowInfo(hParent = hDir, hChild = hShadow, lpFind32, &uStatus, NULL) != SRET_OK)
        goto bailout;

    len = wstrlen(lpFind32->cFileName)*2;

    if (!(lpuType = (USHORT *)AllocMem(len+2)))
        goto bailout;

    memcpy(lpuType, lpFind32->cFileName, len);
    memset(lpOI, 0, sizeof(OTHERINFO));
    do
    {
        memset(&sSC, 0, sizeof(SHADOWCHECK));
        sSC.lpuName = (USHORT *)hChild;
        sSC.lpuType = lpuType;
        sSC.uFlagsIn = ulFlagsIn;
        MetaMatchInit(&(sSC.ulCookie));
        if (MetaMatch(hParent, lpFind32, &(sSC.ulCookie), &hChild
                        , &uStatus, NULL
                        , GetShadowWithChecksProc
                        , &sSC)!=SRET_OK)
            goto bailout;

        if (mIsHint(sSC.ulHintFlags))
        {
            if (mHintExclude(sSC.ulHintFlags) || (lpOI->ulIHPri < sSC.ulHintPri))
            {
                lpOI->ulHintFlags = sSC.ulHintFlags;
                lpOI->ulIHPri = sSC.ulHintPri;
            }
            // If we find an exclusion hint here, we need to quit
            // because this is the closest exclusion hint we got
            if (mHintExclude(sSC.ulHintFlags))
                break;
        }
        if (!hParent)
            break;
        hChild = hParent;
        GetAncestorsHSHADOW(hChild, &hParent, NULL);
        // Start checking the subtree hints
        ulFlagsIn = FLAG_IN_SHADOWCHECK_SUBTREE;
    }
    while (TRUE);

    iRet = SRET_OK;
bailout:
    if (lpuType)
    {
        FreeMem(lpuType);
    }
    return (iRet);
}
#endif //MAYBE

int SetResourceFlags(
    HSHARE  hShare,
    ULONG uStatus,
    ULONG uOp
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
#ifndef CSC_RECORDMANAGER_WINNT
    PRESOURCE    pResource;

    if(pResource = PFindResourceFromHShare(hShare, 0xffff, 0))
    {
        switch (mBitOpShadowFlags(uOp))
        {
            case SHADOW_FLAGS_ASSIGN:
                pResource->usFlags = (USHORT)uStatus;
                break;
            case SHADOW_FLAGS_OR:
                pResource->usFlags |= (USHORT)uStatus;
                break;
            case SHADOW_FLAGS_AND:
                pResource->usFlags &= (USHORT)uStatus;
                break;
        }
    }
#else
    //on NT, we just make the one call, if it can't find it, then
    //it just does nothing......
    DeclareFindFromShadowOnNtVars()

    PSetResourceStatusFromHShare(hShare, 0xffff, 0, uStatus, uOp);

#endif //ifndef CSC_RECORDMANAGER_WINNT
    return(0);  //stop complaining about no return value
}


int PUBLIC MakeSpace(
    long    nFileSizeHigh,
    long    nFileSizeLow,
    BOOL    fClearPinned
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    CSC_ENUMCOOKIE  hPQ;
    PQPARAMS sPQP;
    int iRet = SRET_ERROR;
    SHADOWSTORE sShdStr;
    ULONG uSize = 0;
    ULONG uSizeIn;
    ULONG ulStartSeconds;

    DEBUG_LOG(RECORD, ("Begin MakeSpace\r\n"));

    ulStartSeconds = GetTimeInSecondsSince1970();
    Win32ToDosFileSize(nFileSizeHigh, nFileSizeLow, &uSizeIn);

    // DbgPrint("Begin Makespace(%d)\n", uSizeIn);

    if (GetShadowSpaceInfo(&sShdStr) < SRET_OK) {
        DbgPrint("MakeSpace: GetShadowSpaceInfo error\n");
        return SRET_ERROR;
    }
    // DbgPrint("  Before cleanup, max=%d cur=%d\n",
    //                 sShdStr.sMax.ulSize,
    //                 sShdStr.sCur.ulSize);
    if (
        (sShdStr.sMax.ulSize > sShdStr.sCur.ulSize)
            &&
        ((sShdStr.sMax.ulSize - sShdStr.sCur.ulSize) > uSizeIn)
    ) {
        // DbgPrint("Makespace exit (nothing to do)\n");
        return SRET_OK;
    }

    // Open the priority q
    if (!(hPQ = HBeginPQEnum())) {
        DbgPrint("MakeSpace: Error opening Priority Q database\n");
        return SRET_ERROR;
    }
    memset(&sPQP, 0, sizeof(PQPARAMS));
    sPQP.uEnumCookie = hPQ;
    //
    // go down the Q once
    //
    do {
        if (PrevPriSHADOW(&sPQP) < SRET_OK) {
            // DbgPrint("  PQ record read error\n");
            break;
        }
        if (sPQP.hShadow == 0)
            break;
        // Nuke only the files and only those which are not open
        // and are not pinned
        if (
            !mNotFsobj(sPQP.ulStatus) // It is a file system object
                &&
            (sPQP.ulStatus & SHADOW_IS_FILE) // It is a file
                &&
            // told to clear pinned or it is not pinned
            (fClearPinned || !(sPQP.ulHintPri || mPinFlags(sPQP.ulHintFlags)))
                &&
            !mShadowNeedReint(sPQP.ulStatus)  // It is not in use or is not dirty
        ) {
            if (PFindFdbFromHShadow(sPQP.hShadow)) {
                // DbgPrint("  Skipping busy shadow (0x%x)\n", sPQP.hShadow);
                continue;
            }
            if(DeleteShadowHelper(FALSE, sPQP.hDir, sPQP.hShadow) < SRET_OK) {
                // DbgPrint("  error Deleting shadow %x\n", sPQP.hShadow);
                break;
            }
            // get the latest data on how much space there is.
            // this takes care of rounding up the size to the cluster
            if (GetShadowSpaceInfo(&sShdStr) < SRET_OK) {
                // DbgPrint("  error reading space status\n");
                break;
            }
            // DbgPrint("  Deleted shadow 0x%x Cur=%d\n",
            //             sPQP.hShadow,
            //             sShdStr.sCur.ulSize);
            if (
                (sShdStr.sMax.ulSize > sShdStr.sCur.ulSize)
                    &&
                ((sShdStr.sMax.ulSize - sShdStr.sCur.ulSize)>uSizeIn)
            ) {
                // DbgPrint("  Makespace exit (done enough)\n");
                iRet = SRET_OK;
                break;
            }
        } else {
            // DbgPrint("  Skip 0x%x\n", sPQP.hShadow);
        }

        #if 0
        if ((int)( GetTimeInSecondsSince1970() - ulStartSeconds) > 30) {
            DbgPrint("  Aborting, have been in for more than 30 seconds\r\n");
            break;
        }
        #endif

    } while (sPQP.uPos);

    if (hPQ)
        EndPQEnum(hPQ);

    DEBUG_LOG(RECORD, ("End MakeSpace\r\n"));

    // DbgPrint("Makespace alldone exit %d (Max=%d Cur=%d)\n",
    //                 iRet,
    //                 sShdStr.sMax.ulSize,
    //                 sShdStr.sCur.ulSize);
    return (iRet);
}

LONG
PurgeUnpinnedFiles(
    ULONG     Timeout,
    PULONG    pnFiles,
    PULONG    pnYoungFiles)
{
    CSC_ENUMCOOKIE hPQ;
    PQPARAMS sPQP;
    ULONG nFiles = 0;
    ULONG nYoungFiles = 0;
    int iRet = SRET_ERROR;

    // DbgPrint("Begin PurgeUnpinnedFiles(%d)\n", Timeout);

    // Open the priority q
    hPQ = HBeginPQEnum();
    if (!hPQ) {
        // DbgPrint("PurgeUnpinnedFiles: Error opening Priority Q database\n");
        return iRet;
    }
    memset(&sPQP, 0, sizeof(PQPARAMS));
    sPQP.uEnumCookie = hPQ;
    iRet = SRET_OK;
    do {
        SHAREINFO ShareInfo;
        SHADOWINFO ShadowInfo;
        OTHERINFO OtherInfo;
        WIN32_FIND_DATA Find32;
        ULONG Status;
        ULONG cStatus;
        ULONG NowSec;
        ULONG FileSec;
        LARGE_INTEGER TimeNow;
        LARGE_INTEGER FileTime;

        iRet = PrevPriSHADOW(&sPQP);
        if (iRet < SRET_OK) {
            // DbgPrint("  PQ record read error\n");
            break;
        }
        if (sPQP.hShadow == 0)
            break;
        // Nuke only the files and only those which are not open
        // and are not pinned
        if (
            mNotFsobj(sPQP.ulStatus) != 0
                ||
            mShadowIsFile(sPQP.hShadow) != SHADOW_IS_FILE
                ||
            mPinFlags(sPQP.ulHintFlags) != 0
                ||
            mShadowNeedReint(sPQP.ulStatus) != 0
        ) {
            // DbgPrint("  Skip(1) (0x%x)\n", sPQP.hShadow);
            continue;
        }
        //
        // See if on manually cached share
        //
        iRet = GetShareInfo(sPQP.hShare, &ShareInfo, &ShadowInfo);
        if (iRet != SRET_OK) {
            // DbgPrint("  GetShareInfo(0x%x) returned %d\n", sPQP.hShare, GetLastErrorLocal());
            continue;
        }
        cStatus = ShadowInfo.uStatus & FLAG_CSC_SHARE_STATUS_CACHING_MASK;
        if (cStatus != FLAG_CSC_SHARE_STATUS_MANUAL_REINT) {
            // DbgPrint("  Skip(2) (0x%x)\n", sPQP.hShadow);
            continue;
        }
        iRet = GetShadowInfo(sPQP.hDir, sPQP.hShadow, &Find32, &Status, &OtherInfo);
        if (iRet != SRET_OK) {
            // DbgPrint("  GetShadowInfo(0x%x/0x%x) returned %d\n",
            //                     sPQP.hDir,
            //                     sPQP.hShadow,
            //                     GetLastErrorLocal());
            continue;
        }
        // DbgPrint("  Name:%ws Size:0x%x Attr:0x%x  ",
        //     Find32.cFileName,
        //     Find32.nFileSizeLow,
        //     Find32.dwFileAttributes);
        KeQuerySystemTime(&TimeNow);
        COPY_STRUCTFILETIME_TO_LARGEINTEGER(FileTime, Find32.ftLastAccessTime);
        RtlTimeToSecondsSince1970(&TimeNow, &NowSec);
        RtlTimeToSecondsSince1970(&FileTime, &FileSec);
        if (
            PFindFdbFromHShadow(sPQP.hShadow) == NULL
                &&
            (Timeout == 0 || (NowSec > FileSec && (NowSec - FileSec) > Timeout))
        ) {
            // DbgPrint("  YES!!!  ");
            if (DeleteShadowHelper(FALSE, sPQP.hDir, sPQP.hShadow) >= SRET_OK) {
                // DbgPrint("-Delete succeeded\n");
                nFiles++;
            } else {
                // DbgPrint("-Error (%d) deleting shadow 0x%x/0x%x\n",
                //                 GetLastErrorLocal(),
                //                 sPQP.hDir,
                //                 sPQP.hShadow);
            }
        } else {
            // DbgPrint("  NO!!!\n");
            nYoungFiles++;
        }
    } while (sPQP.uPos);
    EndPQEnum(hPQ);
    if (iRet >= SRET_OK) {
        *pnFiles = nFiles;
        *pnYoungFiles = nYoungFiles;
    }
    // DbgPrint("PurgeUnpinnedFiles exit %d (nFiles=%d nYoungFiles=%d)\n",
    //                 iRet,
    //                 *pnFiles,
    //                 *pnYoungFiles);
    return (iRet);
}

int
PUBLIC TraversePQToCheckDirtyBits(
    HSHARE hShare,
    DWORD   *lpcntDirty
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    CSC_ENUMCOOKIE  hPQ;
    PQPARAMS sPQP;
    int iRet = SRET_ERROR;
    ULONG   ulStartSeconds;

    *lpcntDirty = 0;
    ulStartSeconds = GetTimeInSecondsSince1970();

    // Open the priority q
    if (!(hPQ = HBeginPQEnum()))
    {
        AssertSz(FALSE, "CSC.TraversePQToCheckDirty:: Error opening Priority Q database\r\n");
        return SRET_ERROR;
    }

    memset(&sPQP, 0, sizeof(PQPARAMS));
    sPQP.uEnumCookie = hPQ;

    // go down the Q once
    do
    {
        if(NextPriSHADOW(&sPQP) < SRET_OK)
        {
            AssertSz(FALSE, "CSC.TraversePQToCheckDirty:: PQ record read error\r\n");
            goto bailout;
        }

        if (!sPQP.hShadow)
        {
            continue;
        }

        if ((sPQP.hShare == hShare)   // this share
            && !mNotFsobj(sPQP.ulStatus) // It is a file system object
            )
        {
            if(sPQP.ulStatus & SHADOW_MODFLAGS)
            {
                ++*lpcntDirty;
            }
        }

        if ((int)( GetTimeInSecondsSince1970() - ulStartSeconds) > 30)
        {
            KdPrint(("CSC.TraversePQToCheckDirty: Aborting, have been in for more than 30 seconds\r\n"));
            goto bailout;
        }

    }
    while (sPQP.uPos);

    iRet = SRET_OK;

bailout:
    if (hPQ)
        EndPQEnum(hPQ);
    return (iRet);
}

int PUBLIC ReduceRefPri(
    VOID
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    CSC_ENUMCOOKIE  hPQ;
    PQPARAMS sPQP;
    int iRet = SRET_ERROR;
    OTHERINFO    sOI;

    // Open the priority q
    if (!(hPQ = HBeginPQEnum()))
    {
        // AssertSz(FALSE, "ReduceRefPri: Error opening Priority Q database\r\n");
        return SRET_ERROR;
    }

    memset(&sPQP, 0, sizeof(PQPARAMS));
    sPQP.uEnumCookie = hPQ;
    do
    {
        if(PrevPriSHADOW(&sPQP) < SRET_OK)
        {
            goto bailout;
        }

        if (!sPQP.hShadow)
            break;

        if (!mNotFsobj(sPQP.ulStatus))
        {
            if (!(sPQP.ulStatus & SHADOW_IS_FILE))
                continue;
            InitOtherInfo(&sOI);
            if (sPQP.ulRefPri > 1)
            {
                sOI.ulRefPri = sPQP.ulRefPri-1;
                ChangePriEntryStatusHSHADOW(sPQP.hDir, sPQP.hShadow, 0, SHADOW_FLAGS_OR, TRUE, &sOI);
            }
        }
    }
    while (sPQP.uPos);
    iRet = SRET_OK;

bailout:
    if (hPQ)
        EndPQEnum(hPQ);
    return (iRet);
}

BOOL HaveSpace(
    long  nFileSizeHigh,
    long  nFileSizeLow
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    SHADOWSTORE sShdStr;
    ULONG uSizeIn;

    Win32ToDosFileSize(nFileSizeHigh, nFileSizeLow, &uSizeIn);

    if (!uSizeIn)
    {
        return TRUE;
    }

    if (GetShadowSpaceInfo(&sShdStr) < SRET_OK)
    {
        return SRET_ERROR;
    }

    if (((sShdStr.sMax.ulSize - sShdStr.sCur.ulSize) >= uSizeIn))
    {
        return TRUE;
    }

    return FALSE;
}

int
IoctlAddDeleteHintFromInode(
    LPSHADOWINFO    lpSI,
    BOOL            fAdd
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    OTHERINFO sOI;
    unsigned uStatus;
    int iRet = -1;

    if(GetShadowInfo(lpSI->hDir, lpSI->hShadow, NULL, &uStatus, &sOI) >= SRET_OK)
    {
        if (fAdd)
        {
            // increment the pin count if no flags to be altered or we are supposed to alter pin count
            if (!(lpSI->ulHintFlags) || mPinAlterCount(lpSI->ulHintFlags))
            {
                sOI.ulHintPri++;
            }

            sOI.ulHintFlags |= lpSI->ulHintFlags;

            if (sOI.ulHintPri > MAX_PRI)
            {
                lpSI->dwError = ERROR_INVALID_PARAMETER;
                goto bailout;
            }
        }
        else
        {
            sOI.ulHintFlags &= (~lpSI->ulHintFlags);

            // decrement the pin count if no flags to be altered or we are supposed to alter pin count
            if (!(lpSI->ulHintFlags) || mPinAlterCount(lpSI->ulHintFlags))
            {
                if (sOI.ulHintPri == MIN_PRI)
                {
                    lpSI->dwError = ERROR_INVALID_PARAMETER;
                    goto bailout;
                }

                --sOI.ulHintPri;
            }
        }

        if (SetShadowInfoEx(lpSI->hDir, lpSI->hShadow, NULL, 0, SHADOW_FLAGS_OR, &sOI, NULL, NULL) >= SRET_OK)
        {
            lpSI->ulHintFlags = sOI.ulHintFlags;
            lpSI->ulHintPri = sOI.ulHintPri;
            iRet = 1;
        }
        else
        {
            lpSI->dwError = ERROR_WRITE_FAULT;
        }
    }

bailout:
    return (iRet);
}


int
IoctlCopyShadow(
    LPSHADOWINFO    lpSI
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    PFDB pFdb=NULL;
    USHORT  *pusLocal;
    int iRet=-1;

    // the shadowcritical section is already taken

    iRet = CopyHSHADOW(lpSI->hDir, lpSI->hShadow, ((LPFIND32A)(lpSI->lpFind32))->cFileName, lpSI->lpFind32->dwFileAttributes);

    if (iRet >= SRET_ERROR)
    {
        pFdb = PFindFdbFromHShadow(lpSI->hShadow);

        if (pFdb)
        {
            pusLocal = PLocalFlagsFromPFdb(pFdb);

            Assert(pusLocal);

            if (pFdb->usFlags & SHADOW_DIRTY)
            {
                // set the snapshotted bit.
                // If by the time the file is closed, the snapshotted bit is still set
                // it is transferred back to SHADOW_DIRTY in disconnected state.

                // it is the job of the SetShadowInfo ioctl to clear the
                // snapshotted bit when the agent is coming down to
                // clear the modified bits on the shadow after
                // reintegration

                pFdb->usFlags &= ~SHADOW_DIRTY;

                *pusLocal |= FLAG_FDB_SHADOW_SNAPSHOTTED;


            }
        }
    }
    else
    {
        lpSI->dwError = GetLastErrorLocal();
    }

    return iRet;
}

int
IoctlChangeHandleCachingState(
    LPSHADOWINFO    lpSI
    )
/*++

Routine Description:

Parameters:

    lpSI    SHADOWINFO structure pointer.

            If lpSI->uStatus is FALSE, then handle caching is disabled, else it is enabled

Return Value:

Notes:

--*/
{
    lpSI->uStatus = EnableHandleCaching(lpSI->uStatus != FALSE);
    return 1;
}

int
IoctlRenameShadow(
    LPSHADOWINFO    lpSI
    )
/*++

Routine Description:

    Given a source Inode, rename it into a destination directory. The source and the
    destination can be across shares

Parameters:

    lpSI    SHADOWINFO structure pointer.


Return Value:

Notes:

    Shadow ciritcal section is already taken

--*/
{
    int iRet=-1;
    ULONG   uStatus, uStatusDest;
    HSHARE hShare;
    HSHADOW hShadowTo;
    BOOL    fReplaceFile = (lpSI->uStatus != 0); // yuk

    UseGlobalFind32();

    lpSI->dwError = ERROR_SUCCESS;

    // get the name of the shadow
    if (GetShadowInfo(lpSI->hDir, lpSI->hShadow, &vsFind32, &uStatus, NULL) >= 0)
    {
        // if it is open, bail
        if (PFindFdbFromHShadow(lpSI->hShadow))
        {
            SetLastErrorLocal(ERROR_ACCESS_DENIED);
        }
        else
        {
            if (lpSI->lpFind32)
            {
                vsFind32 = *lpSI->lpFind32;
                vsFind32.cAlternateFileName[0] = 0;
                MRxSmbCscGenerate83NameAsNeeded(lpSI->hDirTo,vsFind32.cFileName,vsFind32.cAlternateFileName);
            }

            // check if it already exists in the destination directory
            if ((GetShadow( lpSI->hDirTo,
                            vsFind32.cFileName,
                            &hShadowTo, NULL,
                            &uStatusDest, NULL) >= 0) && hShadowTo)
            {
                // try deleting if we are supposed to replace it
                if (fReplaceFile)
                {
                    if (DeleteShadow(lpSI->hDirTo, hShadowTo)< SRET_OK)
                    {
                        lpSI->dwError = GetLastErrorLocal();
                        Assert(lpSI->dwError != ERROR_SUCCESS);
                    }
                }
                else
                {
                    SetLastErrorLocal(ERROR_FILE_EXISTS);
                }
            }

            if (lpSI->dwError == ERROR_SUCCESS)
            {
                // just in case this is a rename across shares, get the handle to the share
                if (GetAncestorsHSHADOW(lpSI->hDirTo, NULL, &hShare) >= 0)
                {
                    // do the rename
                    iRet = RenameShadowEx(
                        lpSI->hDir,
                        lpSI->hShadow,
                        hShare,
                        lpSI->hDirTo,
                        &vsFind32,
                        uStatus,
                        NULL,
                        0,
                        NULL,
                        NULL,
                        &lpSI->hShadow
                        );

                    if (iRet < 0)
                    {
                        lpSI->dwError = GetLastErrorLocal();
                    }
                }
                else
                {
                    lpSI->dwError = GetLastErrorLocal();
                }
            }
        }
    }
    else
    {
        SetLastErrorLocal(ERROR_FILE_NOT_FOUND);
    }

    return ((iRet >= SRET_OK)?1:-1);
}



int IoctlEnableCSCForUser(
    LPSHADOWINFO    lpSI
    )
/*++

Routine Description:

Parameters:

    lpSI    SHADOWINFO structure pointer. 

Return Value:

    -1

Notes:


--*/
{
    int iRet = SRET_ERROR;

    EnterShadowCrit();

    if (fShadow)
    {
        lpSI->dwError = 0;
        iRet = SRET_OK;
    }
    else
    {
        if (OK_TO_ENABLE_CSC)
        {
            Assert(lpSI->lpFind32);
            //
            // Check that cFileName and cAlternateFileName contain a NULL
            //
            if (CscCheckForNullA(((LPFIND32A)(lpSI->lpFind32))->cFileName, MAX_PATH) == FALSE) {
                lpSI->dwError = ERROR_INVALID_PARAMETER;
                LeaveShadowCrit();
                return -1;
            }
            if (CscCheckForNullA(((LPFIND32A)(lpSI->lpFind32))->cAlternateFileName, 14) == FALSE) {
                lpSI->dwError = ERROR_INVALID_PARAMETER;
                LeaveShadowCrit();
                return -1;
            }
            // check if we can initialize the database
//            KdPrint(("Trying to shadow....%s\n",
//                           ((LPFIND32A)(lpSI->lpFind32))->cFileName));
            if(InitDatabase(
                    ((LPFIND32A)(lpSI->lpFind32))->cFileName,            // location
                    ((LPFIND32A)(lpSI->lpFind32))->cAlternateFileName,    // user
                    ((LPFIND32A)(lpSI->lpFind32))->nFileSizeHigh,        // default cache size if creating
                    ((LPFIND32A)(lpSI->lpFind32))->nFileSizeLow,
                    ((LPFIND32A)(lpSI->lpFind32))->dwReserved1, // cluster size
                    lpSI->ulRefPri,
                    &(lpSI->uOp))    // whether newly created
                    ==-1)
            {
                //we can't, let us quit
                lpSI->dwError = GetLastErrorLocal();
            }
            else
            {
//                KdPrint(("Starting to shadow....\n"));
                fShadow = 1;
                iRet = SRET_OK;
                sGS.uFlagsEvents |= FLAG_GLOBALSTATUS_START;
                MRxSmbCscSignalAgent(NULL, SIGNALAGENTFLAG_DONT_LEAVE_CRIT_SECT|SIGNALAGENTFLAG_CONTINUE_FOR_NO_AGENT);
            }
        }
        else
        {
            //we are not supposed to turn on csc. This happens only on NT
            lpSI->dwError = ERROR_ACCESS_DENIED;
        }

    }
    LeaveShadowCrit();
    return iRet;
}

int
IoctlDisableCSCForUser(
    LPSHADOWINFO    lpSI
    )
/*++

Routine Description:

Parameters:

    lpSI    SHADOWINFO structure pointer. 

Return Value:

    -1

Notes:


--*/
{
    int iRet = SRET_ERROR;

    if (!fShadow)
    {
        iRet = 1;        
    }
    else
    {
        if (!IsCSCBusy() && (hShareReint == 0))
        {
            ClearCSCStateOnRedirStructures();
            CloseDatabase();
            fShadow = 0;
            iRet = 1;
                sGS.uFlagsEvents |= FLAG_GLOBALSTATUS_STOP;
                MRxSmbCscSignalAgent(NULL, SIGNALAGENTFLAG_DONT_LEAVE_CRIT_SECT|SIGNALAGENTFLAG_CONTINUE_FOR_NO_AGENT);
        }
        else
        {
            SetLastErrorLocal(ERROR_BUSY);
        }
    }
    return iRet;
}



#ifndef CSC_RECORDMANAGER_WINNT
int
IoctlTransitionShareToOffline(
    LPSHADOWINFO    lpSI
    )
/*++

Routine Description:

Parameters:

    lpSI    SHADOWINFO structure pointer. lpSI->hShare identifies the share to take offline.
            if lpSI->uStatus is 0, the online to offline transition should fail.

Return Value:

    -1

Notes:

    fails on win9x

--*/
{
    return -1;
}

BOOL
FailModificationsToShare(
    LPSHADOWINFO   lpSI
    )
{
    return FALSE;
}
#else

BOOL
FailModificationsToShare(
    LPSHADOWINFO   lpSI
    )
{
    HSHARE hShare=0;
    HSHADOW hShadow = 0;

    // if no reintegration is in progress or if there is, it is blocking kind
    // then we don't fail share modifications

    if (!hShareReint || vfBlockingReint)
    {
        return FALSE;
    }

    if (!lpSI->hShare)
    {
        hShadow = (lpSI->hDir)?lpSI->hDir:lpSI->hShadow;

        if ((GetAncestorsHSHADOW(hShadow, NULL, &hShare) < SRET_OK)||
           (hShare == hShareReint))
        {
            SetLastErrorLocal(ERROR_OPERATION_ABORTED);
            return TRUE;
        }

    }

    return FALSE;
}


void
IncrementActivityCountForShare(
    HSHARE hShare
    )
{
    if (!hShareReint || vfBlockingReint)
    {
        return;
    }

    if (hShare == hShareReint)
    {
        vdwActivityCount++;
    }
}

BOOL
CSCFailUserOperation(
    HSHARE hShare
    )
/*++

Routine Description:

Parameters:

Return Value:


Notes:

--*/
{

    if (!hShareReint || !vfBlockingReint)
    {
        return FALSE;
    }

    return(hShare == hShareReint);
}

int
IoctlTransitionShareToOffline(
    LPSHADOWINFO    lpSI
    )
/*++

Routine Description:

Parameters:

    lpSI    SHADOWINFO structure pointer. lpSI->hShare identifies the share to take offline.
            if lpSI->uStatus is 0, the online to offline transition should fail.

Return Value:

Notes:


--*/
{
    return -1;

}

#endif


BOOLEAN
CscCheckForNullA(
    PUCHAR pBuf,
    ULONG Count)
{
    ULONG i;

    for (i = 0; i < Count; i++) {
        if (pBuf[i] == '\0') {
            return TRUE;
        }
    }
    return FALSE;
}

BOOLEAN
CscCheckForNullW(
    PWCHAR pBuf,
    ULONG Count)
{
    ULONG i;

    for (i = 0; i < Count; i++) {
        if (pBuf[i] == L'\0') {
            return TRUE;
        }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\record.mgr\recchk.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    recchk.c

Abstract:

    This file implements the record database checking code. There are two types of
    persistent data structures, the priority Q (or our version of Master FIle Table)
    and the hierarchy of files and directories that starts with the superroot which
    contains all the shares connected to. The truth is considered to be in the
    hierarchy. The Priority Q is supposed to mirror some critical data from the
    hierarchy. When fixing the database, we traverse the hierarchy
    recursively and build an in memory PQ.  We then write that out as the new PQ.

    This file gets linked in the usermode and in the kernlemode so that for NT this
    can execute in kernel mode while for win9x it can execute in usermode

Author:

     Shishir Pardikar      [Shishirp]        10-30-1997

Revision History:

    split up from usermode.

--*/
#include "precomp.h"
#pragma hdrstop

#pragma code_seg("PAGE")

#include "record.h"
#include "string.h"
#include "stdlib.h"

// Record Buffer Array (RBA). This holds an entire inode file in memory
// It is made up of pointers to 1 or more Record Buffer Entries (RBE).
// Each RBE is a chunk of memory that holds an integral number of records from
// the file represented by ulidShadow entry in the structure


typedef struct tagRBA
{
    unsigned        ulErrorFlags;
    unsigned        ulidShadow;                 // Inode which is represented by this structure
    GENERICHEADER   sGH;                        // it's header
    CSCHFILE           hf;                         // open handle to the file
    DWORD           cntRBE;                     // count of buffer entries in the array
    DWORD           cntRecsPerRBE;              // #of records per buffer entry
    DWORD           cbRBE;                      // size in bytes of each buffer entry
    LPBYTE          rgRBE[];                    // Record Buffer Entry (RBE) array
}
RBA, *LPRBA;    // stands for RecordBuffArray

#define RBA_ERROR_INVALID_HEADER            0x00000001
#define RAB_ERROR_INVALID_RECORD_COUNT      0x00000002
#define RBA_ERROR_INVALID_OVF               0x00000004
#define RBA_ERROR_INVALID_ENTRY             0x00000008
#define RBA_ERROR_MISMATCHED_SIZE           0x00000010
#define RBA_ERROR_MISALIGNED_RECORD         0x00000020
#define RBA_ERROR_INVALID_INODE             0x00000040
#define RBA_ERROR_LIMIT_EXCEEDED            0x00000080


#define MAX_RECBUFF_ENTRY_SIZE  (0x10000-0x100) // max size of an RBE
#define MAX_RBES_EXPECTED       0x30    // Max number of RBEs of the above size in an RBA

// we make provision for max possible # of RBEs, even beyond what the PQ currently
// needs. The max set here is (MAX_RBES_EXPETCED * MAX_RECBUFF_ENTRY_SIZE)
// which amounts to 48 * 65280 which is around 3M which at the current size of
// QREC will hold ~100K entries in the hierarchy. This is far more than
// the # of entries we ever expect to have in our database

// As we allocate memory only as it is needed, it would'nt be a problem to
// increase MAX_RBES_EXPECTED so it handles more inodes



typedef struct tagCSE   *LPCSE;

typedef struct tagCSE   // CSC Stack Entry
{
    LPCSE       lpcseNext;
    unsigned    ulidShare; // server
    unsigned    ulidParent; // parent of the directory
    unsigned    ulidDir;    // the directory itself
    unsigned    ulRec;
    LPRBA       lpRBA;      // the contents of ulidDir
}
CSE;

#pragma intrinsic (memcmp, memcpy, memset, strcat, strcmp, strcpy, strlen)

#ifdef DEBUG
//cshadow dbgprint interface
#define RecchkKdPrint(__bit,__x) {\
    if (((RECCHK_KDP_##__bit)==0) || FlagOn(RecchkKdPrintVector,(RECCHK_KDP_##__bit))) {\
    KdPrint (__x);\
    }\
}

#define RECCHK_KDP_ALWAYS               0x00000000
#define RECCHK_KDP_BADERRORS            0x00000001
#define RECCHK_KDP_TRAVERSE             0x00000002
#define RECCHK_KDP_PQ                   0x00000004
#define RECCHK_KDP_RBA                  0x00000008


ULONG RecchkKdPrintVector = RECCHK_KDP_BADERRORS;
#else
#define RecchkKdPrint(__bit,__x) ;
#endif

#define ValidShadowID(ulidShadow)   ((ulidShadow & ~0x80000000) >=ULID_FIRST_USER_DIR)


char vszTemp[] = "csc0.tmp";
char vszTemp1[] = "csc1.tmp";

AssertData;
AssertError;


RebuildPQInRBA(
    LPRBA   lpRBA
    );

BOOL
TraverseDirectory(
    LPVOID  lpdbID,
    unsigned    ulidShare,
    unsigned    ulidParent,
    unsigned    ulidDir,
    LPRBA       lpRBAPQ,
    BOOL        fFix
    );

BOOL
AllocateRBA(
    DWORD           cntRBE,     // count of record buffer entries
    DWORD           cbRBE,      // size of each record buffer entry
    LPRBA           *lplpRBA   // result to be returned
    );

VOID
FreeRBA(
    LPRBA  lpRBA
    );

BOOL
ReadShadowInRBA(
    LPVOID          lpdbID,
    unsigned        ulidShadow,
    DWORD           cbMaxRBE,       // max size of an RBE
    DWORD           cntRBE,         // # of RBEs to be allocated, calculated if 0
    LPRBA           *lplpRBA
    );

BOOL
WriteRBA(
    LPVOID  lpdbID,
    LPRBA   lpRBA,
    LPSTR   lpszFileName
    );

LPVOID
GetRecordPointerFromRBA(
    LPRBA           lpRBA,
    unsigned        ulRec
    );

BOOL
ReadRecordFromRBA(
    LPRBA           lpRBA,
    unsigned        ulRec,
    LPGENERICREC    lpGH
    );

BOOL
WriteRecordToRBA(
    LPRBA           lpRBA,
    unsigned        ulRec,
    LPGENERICREC    lpGH,
    BOOL            fOverwrite,
    LPDWORD         lpdwError
    );


BOOL
FillupRBAUptoThisRBE(
    LPRBA   lpRBA,
    DWORD   indxRBE
    );

VOID
InitializeRBE(
    LPRBA   lpRBA,
    DWORD   indxRBE
    );

BOOL
InsertRBAPQEntryFile(
    LPRBA       lpRBAPQ,
    LPQREC      lpPQDst,
    unsigned    ulrecDst
    );

BOOL
InsertRBAPQEntryDir(
    LPRBA       lpRBAPQ,
    LPQREC      lpPQDst,
    unsigned    ulrecDst
    );

BOOL
ValidateQrecFromFilerec(
    unsigned        ulidShare,
    unsigned        ulidDir,
    LPFILERECEXT    lpFR,
    LPQREC          lpQR,
    unsigned        ulrecDirEntry
    );

BOOL
TraversePQ(
    LPVOID      lpdbID
    )
/*++

Routine Description:

    This routine traverses the priority Q and verifies the consistency of the Q by verifying
    that the backward and the forward pointers are pointing correctly

Parameters:

    lpdbID  CSC database directory

Return Value:

Notes:


--*/
{
    QREC      sQR, sPrev, sNext;
    unsigned ulRec;
    BOOL    fRet = FALSE, fValidHead=FALSE, fValidTail=FALSE;
    LPRBA   lpRBA = NULL;

    if (!ReadShadowInRBA(lpdbID, ULID_PQ, MAX_RECBUFF_ENTRY_SIZE, 0, &lpRBA))
    {
        RecchkKdPrint(BADERRORS, ("TraversePQ: Failed to read PQ in memory\r\n"));
        goto bailout;
    }

    if ((((LPQHEADER)&(lpRBA->sGH))->ulrecTail > lpRBA->sGH.ulRecords) ||
        (((LPQHEADER)&(lpRBA->sGH))->ulrecHead > lpRBA->sGH.ulRecords))
    {
        RecchkKdPrint(BADERRORS, ("Invalid head-tail pointers\r\n"));
        goto bailout;
    }

    if (!lpRBA->sGH.ulRecords)
    {
        fRet = TRUE;
        goto bailout;
    }
    for (ulRec = 1; ulRec <= lpRBA->sGH.ulRecords; ulRec++)
    {
        if(!ReadRecordFromRBA(lpRBA, ulRec, (LPGENERICREC)&sQR))
        {
            goto bailout;
        }

        if (sQR.uchType == REC_DATA)
        {
            if (sQR.ulrecNext)
            {
                if (sQR.ulrecNext > lpRBA->sGH.ulRecords)
                {
                    RecchkKdPrint(BADERRORS, ("Invalid next pointer to %d\r\n", ulRec));
                    goto bailout;
                }

                if (!ReadRecordFromRBA(lpRBA, sQR.ulrecNext, (LPGENERICREC)&sNext))
                {
                    goto bailout;
                }

                if (sNext.ulrecPrev != ulRec)
                {

                    RecchkKdPrint(BADERRORS, ("Prev pointer of %d doesn't equal %d\r\n", sNext.ulrecPrev, ulRec));
                    goto bailout;
                }
            }
            else
            {
                if (((LPQHEADER)&(lpRBA->sGH))->ulrecTail != ulRec)
                {

                    RecchkKdPrint(BADERRORS, ("Invalid tail pointer to %d\r\n", ulRec));
                    goto bailout;
                }

                fValidTail = TRUE;
            }

            if (sQR.ulrecPrev)
            {
                if (sQR.ulrecPrev > lpRBA->sGH.ulRecords)
                {
                    RecchkKdPrint(BADERRORS, ("Invalid prev pointer to %d\r\n", ulRec));
                    goto bailout;
                }

                if (!ReadRecordFromRBA(lpRBA, sQR.ulrecPrev, (LPGENERICREC)&sPrev))
                {
                    goto bailout;
                }

                if (sPrev.ulrecNext != ulRec)
                {

                    RecchkKdPrint(BADERRORS, ("Next pointer of %d doesn't equal %d\r\n", sPrev.ulrecNext, ulRec));
                    goto bailout;
                }
            }
            else
            {
                if (((LPQHEADER)&(lpRBA->sGH))->ulrecHead != ulRec)
                {

                    RecchkKdPrint(BADERRORS, ("Invalid Head pointer to %d\r\n", ulRec));
                    goto bailout;
                }

                fValidHead = TRUE;
            }
        }
    }

    if (!fValidHead || !fValidTail)
    {
        RecchkKdPrint(BADERRORS, ("Head or Tail invalid \r\n"));
        goto bailout;
    }

    fRet = TRUE;

bailout:
    if (lpRBA)
    {
        FreeRBA(lpRBA);
    }

    return (fRet);
}

BOOL
RebuildPQ(
    LPVOID      lpdbID
)
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    LPRBA   lpRBA = NULL;
    BOOL    fRet = FALSE;


    RecchkKdPrint(PQ, ("RebuildPQ: reading PQ \r\n"));

    if (!ReadShadowInRBA(lpdbID, ULID_PQ, MAX_RECBUFF_ENTRY_SIZE, 0, &lpRBA))
    {
        RecchkKdPrint(BADERRORS, ("TraversePQ: Failed to read PQ in memory\r\n"));
        goto bailout;
    }

    RecchkKdPrint(PQ, ("RebuildPQ: read PQ \r\n"));

    if (!RebuildPQInRBA(lpRBA))
    {
        RecchkKdPrint(BADERRORS, ("RebuildPQ: failed to rebuild PQ in RBA \r\n"));
        goto bailout;
    }

    RecchkKdPrint(PQ, ("RebuildPQ: writing PQ \r\n"));

    if (!WriteRBA(lpdbID, lpRBA, NULL))
    {
        RecchkKdPrint(BADERRORS, ("RebuildPQ:Failed to writeout the PQ\r\n"));
        goto bailout;
    }

    RecchkKdPrint(PQ, ("RebuildPQ: wrote PQ \r\n"));

    fRet = TRUE;

bailout:
    if (lpRBA)
    {
        FreeRBA(lpRBA);
    }

    return (fRet);
}

BOOL
RebuildPQInRBA(
    LPRBA   lpRBA
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    unsigned ulRec;
    LPQHEADER   lpQH;
    LPQREC  lpPQ;
    BOOL fRet = FALSE;

    lpQH = (LPQHEADER)&(lpRBA->sGH);

    // nuke the PQ
    lpQH->ulrecHead = lpQH->ulrecTail = 0;

    for (ulRec = 1; ulRec <= lpRBA->sGH.ulRecords; ulRec++)
    {
        if (!(lpPQ = GetRecordPointerFromRBA(lpRBA, ulRec)))
        {
            RecchkKdPrint(BADERRORS, ("InsertRBAPQEntry: failed reading q entry at %d\r\n", ulRec));
            goto bailout;
        }

        if (lpPQ->uchType != REC_DATA)
        {
            continue;
        }

        if (!(lpPQ->ulidShadow & 0x80000000))
        {
            if (!InsertRBAPQEntryDir(lpRBA, lpPQ, ulRec))
            {
                RecchkKdPrint(BADERRORS, ("RebuildPQ:Failed inserting %d \r\n", ulRec));
                goto bailout;
            }
        }
        else
        {
            if (!InsertRBAPQEntryFile(lpRBA, lpPQ, ulRec))
            {
                RecchkKdPrint(BADERRORS, ("RebuildPQ:Failed inserting %d \r\n", ulRec));
                goto bailout;
            }
        }
    }
    fRet = TRUE;

bailout:
    return fRet;
}

BOOL
TraverseHierarchy(
    LPVOID      lpdbID,
    BOOL        fFix
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    unsigned ulRec;
    BOOL fRet = FALSE;
    LPRBA   lpRBA = NULL, lpRBAPQ=NULL;
    SHAREREC   sSR;
    QREC    sQR;
    BOOL    fErrors = FALSE;
    DWORD   dwError;

    if (!ReadShadowInRBA(lpdbID, ULID_SHARE, MAX_RECBUFF_ENTRY_SIZE, 0, &lpRBA))
    {
        RecchkKdPrint(BADERRORS, ("TraverseHierarchy: Failed to read servers in memory\r\n"));
        goto bailout;
    }

    if (!fFix)
    {
        if (!ReadShadowInRBA(   lpdbID,
                                ULID_PQ,
                                MAX_RECBUFF_ENTRY_SIZE,
                                0,
                                &lpRBAPQ))
        {
            RecchkKdPrint(BADERRORS, ("TraverseHierarchy: Failed to read PQ in memory\r\n"));
            goto bailout;
        }
    }
    else
    {
        ULONG   cbCountOfTotal= ((LPSHAREHEADER)&(lpRBA->sGH))->sCur.ucntDirs+((LPSHAREHEADER)&(lpRBA->sGH))->sCur.ucntFiles;
        ULONG   cbMaxEntriesExpected,cbMaxRbesExpected;

        cbMaxEntriesExpected = (MAX_RECBUFF_ENTRY_SIZE * MAX_RBES_EXPECTED)/sizeof(QREC);
        RecchkKdPrint(BADERRORS, ("TraverseHierarchy: total count=%d\r\n",cbCountOfTotal));
        if (cbCountOfTotal >= cbMaxEntriesExpected)
        {
            fRet = TRUE;
            RecchkKdPrint(BADERRORS, ("TraverseHierarchy: Database too big skipping autocheck\r\n"));
            goto bailout;
//            cbMaxRbesExpected = (cbCountOfTotal*sizeof(QREC)/MAX_RECBUFF_ENTRY_SIZE)+1;
        }
        else
        {
            cbMaxRbesExpected = MAX_RBES_EXPECTED;
        }

        RecchkKdPrint(BADERRORS, ("TraverseHierarchy: MaxRBEs = %d\r\n",cbMaxRbesExpected));

        if (!AllocateRBA(cbMaxRbesExpected, MAX_RECBUFF_ENTRY_SIZE, &lpRBAPQ))
        {
            RecchkKdPrint(BADERRORS, ("TraverseHierarchy: Failed to Allocate PQ\r\n"));
            goto bailout;
        }

        InitQHeader((LPQHEADER)&(lpRBAPQ->sGH));

        lpRBAPQ->ulidShadow = ULID_PQ;
        lpRBAPQ->cntRecsPerRBE =  MAX_RECBUFF_ENTRY_SIZE/lpRBAPQ->sGH.uRecSize;

    }

    for (ulRec=1; ulRec<=lpRBA->sGH.ulRecords; ++ulRec)
    {
        ReadRecordFromRBA(lpRBA, ulRec, (LPGENERICREC)&sSR);

        if (sSR.uchType != REC_DATA)
        {
            continue;
        }

        if(!ValidShadowID(sSR.ulidShadow))
        {
            fErrors = TRUE;
            sSR.uchType = REC_EMPTY;
            RecchkKdPrint(BADERRORS, ("Invalid Shadow ID %xh found in %xh \r\n", sSR.ulidShadow, sSR.ulShare));
            if (fFix)
            {
                if (!WriteRecordToRBA(lpRBA, ulRec, (LPGENERICREC)&sSR, TRUE, NULL))
                {
                    RecchkKdPrint(BADERRORS, ("Couldn't write entry for Share Record %xh \r\n", sSR.ulShare));
                }
            }

            continue;

        }

        if (!fFix)
        {

            if (!ReadRecordFromRBA(lpRBAPQ, RecFromInode(sSR.ulidShadow), (LPGENERICREC)&sQR))
            {
                RecchkKdPrint(BADERRORS, ("No PQ entry for Inode %xh \r\n", sSR.ulidShadow));
            }
        }
        else
        {
            InitPriQRec(ulRec, 0, sSR.ulidShadow, SHADOW_SPARSE, 0, 0, 0, 0, ulRec, &sQR);

            if (!WriteRecordToRBA(lpRBAPQ, RecFromInode(sSR.ulidShadow), (LPGENERICREC)&sQR, FALSE, &dwError))
            {
                if (dwError == ERROR_NOT_ENOUGH_MEMORY)
                {
                    RecchkKdPrint(BADERRORS, ("Couldn't write PQ entry for Inode %xh \r\n", sSR.ulidShadow));
                }

                fErrors = TRUE;
                sSR.uchType = REC_EMPTY;
                WriteRecordToRBA(lpRBA, ulRec, (LPGENERICREC)&sSR, TRUE, NULL);
                continue;
            }
        }

        if(!TraverseDirectory(  lpdbID,
                            ulRec,  // ulidShare
                            0,  // parent inode
                            sSR.ulidShadow, // dir inode
                            lpRBAPQ,
                            fFix
                            ))
        {
            goto bailout;
        }

    }
    if (fFix)
    {
        if (fErrors)
        {
            if (!WriteRBA(lpdbID, lpRBA, NULL))
            {
                RecchkKdPrint(BADERRORS, ("TraverseHierarchy:Failed to write Shares\r\n"));
                goto bailout;
            }
        }
        RecchkKdPrint(TRAVERSE, ("Total records %d \r\n", lpRBAPQ->sGH.ulRecords));

        if (lpRBAPQ->ulErrorFlags & RBA_ERROR_LIMIT_EXCEEDED)
        {
            RecchkKdPrint(BADERRORS, ("TraverseHierarchy: skipping rewriting of new PQ\r\n"));
        }
        else
        {
            if (!RebuildPQInRBA(lpRBAPQ))
            {
                RecchkKdPrint(BADERRORS, ("TraverseHierarchy:Failed to rebuild PQ\r\n"));
                goto bailout;
            }
            if (!WriteRBA(lpdbID, lpRBAPQ, NULL))
            {
                RecchkKdPrint(BADERRORS, ("TraverseHierarchy:Failed to write PQ\r\n"));
                goto bailout;
            }
        }
    }
    fRet = TRUE;

bailout:

    if (lpRBA)
    {
        FreeRBA(lpRBA);
    }

    if (lpRBAPQ)
    {
        FreeRBA(lpRBAPQ);
    }

    return fRet;
}

BOOL
TraverseDirectory(
    LPVOID      lpdbID,
    unsigned    ulidShare,
    unsigned    ulidParent,
    unsigned    ulidDir,
    LPRBA       lpRBAPQ,
    BOOL        fFix
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    unsigned    ulDepthLevel = 0, ulidCurParent, ulidCurDir;
    BOOL        fRet = FALSE, fGoDeeper = TRUE;
    FILERECEXT  *lpFR = NULL;
    QREC        *lpQR = NULL;
    LPCSE       lpcseNextDir = NULL;
    LPCSE       lpcseHead = NULL, lpcseT;
    BOOL        fErrors = FALSE;
    DWORD       dwError;

    lpFR = AllocMemPaged(sizeof(FILERECEXT));
    lpQR = AllocMemPaged(sizeof(QREC));

    if (!lpFR || !lpQR)
    {
        RecchkKdPrint(BADERRORS, ("AllocMemPaged Failed \r\n"));
        goto bailout;
    }

    ulidCurParent = ulidParent;
    ulidCurDir = ulidDir;

    for (;;)
    {
        if (fGoDeeper)
        {
            // we are going deeper

            // allocate a stack entry for the directory which we want
            // to traverse

            lpcseT = AllocMemPaged(sizeof(CSE));

            if (!lpcseT)
            {
                RecchkKdPrint(BADERRORS, ("AllocMemPaged failed \r\n"));
                goto bailout;
            }

            // do appropriate inits

            lpcseT->ulidShare = ulidShare;
            lpcseT->ulidParent = ulidCurParent;
            lpcseT->ulidDir = ulidCurDir;
            lpcseT->ulRec = 1;  // start for record # 1
            lpcseT->lpcseNext = NULL;

            // read the entire directory in memory
            if (!ReadShadowInRBA(lpdbID, ulidCurDir, MAX_RECBUFF_ENTRY_SIZE, 0, &(lpcseT->lpRBA)))
            {
                RecchkKdPrint(BADERRORS, ("TraverseDirectory: Failed to read directory in memory\r\n"));

                if (!fFix)
                {
                    RecchkKdPrint(BADERRORS, ("TraverseDirectory: Aborting\r\n"));
                    FreeMemPaged(lpcseT);
                    goto bailout;
                }
                else
                {
                    RecchkKdPrint(TRAVERSE, ("TraverseDirectory: attempting to heal\r\n"));
                    if(CreateDirInode(lpdbID, ulidShare, ulidCurParent, ulidCurDir) < 0)
                    {
                        RecchkKdPrint(BADERRORS, ("TraverseDirectory: failed to heal\r\n"));
                    }

                    FreeMemPaged(lpcseT);
                    fGoDeeper = FALSE;

                    // continue if there are more things to do
                    // else stop
                    if (lpcseHead)
                    {
                        continue;
                    }
                    else
                    {
                        break;
                    }
                }
            }

            // put it at the head of the queue
            lpcseT->lpcseNext = lpcseHead;
            lpcseHead = lpcseT;

            ulDepthLevel++;

        }

        fGoDeeper = FALSE;

        // we always operate on the head of the list

        Assert(lpcseHead != NULL);

        RecchkKdPrint(TRAVERSE, ("Processing %x at depth %d\r\n", ulidCurDir, ulDepthLevel));

        RecchkKdPrint(TRAVERSE, ("lpcseHead = %x, lpcseHead->lpcseNext = %x \r\n", lpcseHead, lpcseHead->lpcseNext));

        for (; lpcseHead->ulRec<=lpcseHead->lpRBA->sGH.ulRecords;)
        {
            ReadRecordFromRBA(lpcseHead->lpRBA, lpcseHead->ulRec, (LPGENERICREC)lpFR);

            if (lpFR->sFR.uchType == REC_DATA)
            {
                if(!ValidShadowID(lpFR->sFR.ulidShadow))
                {
                    RecchkKdPrint(BADERRORS, ("Invalid Shadow ID %xh found in %xh \r\n", lpFR->sFR.ulidShadow, ulidCurDir));
                    lpcseHead->lpRBA->ulErrorFlags |= RBA_ERROR_INVALID_INODE;

                    if (fFix)
                    {
                        lpFR->sFR.uchType = REC_EMPTY;
                        if (!WriteRecordToRBA(lpcseHead->lpRBA, lpcseHead->ulRec, (LPGENERICREC)lpFR, TRUE, NULL))
                        {
                            RecchkKdPrint(BADERRORS, ("Couldn't write entry for dir Record #%dh in dir %xh\r\n", lpcseHead->ulRec, ulidCurDir));
                        }

                    }

                }
                else
                {
                    if (!fFix)
                    {
                        ReadRecordFromRBA(lpRBAPQ, RecFromInode(lpFR->sFR.ulidShadow), (LPGENERICREC)lpQR);

                        if (!ValidateQrecFromFilerec(lpcseHead->ulidShare, lpcseHead->ulidDir, lpFR, lpQR, lpcseHead->ulRec))
                        {
                            RecchkKdPrint(BADERRORS, ("PQ entry for Inode %xh in directory=%xh doesn't match with filerec\r\n", lpFR->sFR.ulidShadow, lpcseHead->lpRBA->ulidShadow));
                        }
                    }
                    else
                    {
                        InitPriQRec(lpcseHead->ulidShare,
                                    lpcseHead->ulidDir,
                                    lpFR->sFR.ulidShadow,
                                    lpFR->sFR.usStatus,
                                    lpFR->sFR.uchRefPri,
                                    lpFR->sFR.uchIHPri,
                                    lpFR->sFR.uchHintPri,
                                    lpFR->sFR.uchHintFlags,
                                    lpcseHead->ulRec,
                                    lpQR);

                        if (!WriteRecordToRBA(lpRBAPQ, RecFromInode(lpFR->sFR.ulidShadow), (LPGENERICREC)lpQR, FALSE, &dwError))
                        {
                            if (dwError == ERROR_NOT_ENOUGH_MEMORY)
                            {
                                RecchkKdPrint(BADERRORS, ("Couldn't write PQ entry for Inode %xh \r\n", lpFR->sFR.ulidShadow));
                            }

                            lpFR->sFR.uchType = REC_EMPTY;
                            lpcseHead->lpRBA->ulErrorFlags |= RBA_ERROR_INVALID_INODE;

                            WriteRecordToRBA(lpcseHead->lpRBA, lpcseHead->ulRec, (LPGENERICREC)lpFR, TRUE, NULL);

                            // go around one more time, when this entry will get skipped
                            continue;
                        }
                    }
                }
            }

            // point to the next record
            lpcseHead->ulRec += (OvfCount(lpFR)+1);

            if ((lpFR->sFR.uchType == REC_DATA) && !(lpFR->sFR.ulidShadow & 0x80000000))
            {
                ulidCurParent = ulidCurDir;
                ulidCurDir = lpFR->sFR.ulidShadow;
                fGoDeeper = TRUE;
                break;
            }
        }

        if (fGoDeeper)
        {
            continue;
        }
        else
        {
            // we completed processing a directory

            Assert(fGoDeeper == FALSE);
            Assert(lpcseHead);

            RecchkKdPrint(TRAVERSE, ("Unwinding \r\n"));

            if (fFix && lpcseHead->lpRBA->ulErrorFlags)
            {

                if (!WriteRBA(lpdbID, lpcseHead->lpRBA, NULL))
                {
                    RecchkKdPrint(BADERRORS, ("Cannot fix errors on %xh \n\r", lpcseHead->lpRBA->ulidShadow));

                }

            }
            // processing of a directory is complete, unwind the stack
            lpcseT = lpcseHead;
            lpcseHead = lpcseHead->lpcseNext;

            FreeRBA(lpcseT->lpRBA);
            FreeMemPaged(lpcseT);

            if (!lpcseHead)
            {
                break;
            }

            ulidCurDir = lpcseHead->ulidDir;
            ulidCurParent = lpcseHead->ulidParent;
        }
    }

    fRet = TRUE;

bailout:
    if (lpFR)
    {
        FreeMemPaged(lpFR);
    }
    if (lpQR)
    {
        FreeMemPaged(lpQR);
    }
    Assert(!(fRet && lpcseHead));

    for (;lpcseHead;)
    {
        lpcseT = lpcseHead;
        lpcseHead = lpcseHead->lpcseNext;
        FreeRBA(lpcseT->lpRBA);
        FreeMemPaged(lpcseT);
    }

    return (fRet);
}

BOOL
AllocateRBA(
    DWORD           cntRBE,     // count of record buffer entries
    DWORD           cbRBE,      // size of each record buffer entry
    LPRBA           *lplpRBA   // result to be returned
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    LPRBA   lpRBA = NULL;
    DWORD   i;


    lpRBA = (LPRBA)AllocMemPaged(sizeof(RBA)+sizeof(LPBYTE)*cntRBE);

    if (lpRBA != NULL)
    {
        // initialize the guy
        lpRBA->cntRBE = cntRBE;                 // count of record buffer entries in rgRBE
        lpRBA->cbRBE = cbRBE;                   // size in bytes of each RBE buffer
    }
    else
    {
        RecchkKdPrint(BADERRORS, ("Failed memory allocation while getting RBA\r\n"));
    }

    if (lpRBA)
    {
        *lplpRBA = lpRBA;
        return (TRUE);
    }

    return FALSE;
}

VOID
FreeRBA(
    LPRBA  lpRBA
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    DWORD   i;

    RecchkKdPrint(RBA, ("FreeRBA:cntRBE=%d cbRBE=%d lpRBA=%xh\r\n", lpRBA->cntRBE, lpRBA->cbRBE, lpRBA));

    for (i=0; i<lpRBA->cntRBE; ++i)
    {
        if (lpRBA->rgRBE[i])
        {
            FreeMemPaged(lpRBA->rgRBE[i]);
        }
    }

    if (lpRBA->hf)
    {
        CloseFileLocal(lpRBA->hf);
    }
    FreeMemPaged(lpRBA);
}

BOOL
ReadShadowInRBA(
    LPVOID          lpdbID,
    unsigned        ulidShadow,
    DWORD           cbMaxRBEIn,     // max size in bytes of an RBE
    DWORD           cntRBEIn,       // # of RBEs in this RBA, calculated if 0
    LPRBA           *lplpRBA
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    LPSTR   lpszName = NULL;
    BOOL    fRet = FALSE;
    DWORD   dwFileSize, cntRBE, cntRecsPerRBE, cbRBE, i;
    unsigned    ulRecords, ulPos, ulErrorFlags = 0;
    CSCHFILE hf = CSCHFILE_NULL;
    GENERICHEADER sGH;
    LPRBA lpRBA=NULL;

    if (lpszName = FormNameString(lpdbID, ulidShadow))
    {
        hf = OpenFileLocal(lpszName);

        if (hf)
        {
            if ((GetFileSizeLocal(hf, &dwFileSize))==0xffffffff)
            {
                RecchkKdPrint(BADERRORS, ("Failed to get filesize for %s\r\n", lpszName));
                goto bailout;
            }

            if (ReadHeader(hf, &sGH, sizeof(sGH))< 0)
            {
                RecchkKdPrint(BADERRORS, ("Failed to read header for %s\r\n", lpszName));
                goto bailout;

            }

            ulRecords = (dwFileSize-sGH.lFirstRec)/sGH.uRecSize;

            if (sGH.ulRecords != ulRecords)
            {
                RecchkKdPrint(BADERRORS, ("Count of total records inconsistent with the file size header=%d expected=%d\r\n",
                                sGH.ulRecords,
                                ulRecords
                ));

                ulErrorFlags |= RAB_ERROR_INVALID_RECORD_COUNT;

            }

            if (sGH.ulRecords > ulRecords)
            {
                sGH.ulRecords = ulRecords;
            }

            // integral # of records per RBE
            cntRecsPerRBE = cbMaxRBEIn/sGH.uRecSize;

            // corresponding size of memory allocation per RBE
            cbRBE = cntRecsPerRBE * sGH.uRecSize;

            if (!cntRBEIn)
            {
                // total count of RBEs. Add 1 to take care of partial RBE at the end
                cntRBE = sGH.ulRecords/cntRecsPerRBE + 1;
            }
            else
            {
                cntRBE = cntRBEIn;
            }


            if (!AllocateRBA(cntRBE, cbRBE, &lpRBA))
            {
                RecchkKdPrint(BADERRORS, ("Failed allocation of recbuff array of %d entries for %s\r\n", cntRBE, lpszName));
                goto bailout;
            }

            ulPos = sGH.lFirstRec;
            for (i=0; i<cntRBE; ++i)
            {
                int iRet;

                Assert(!lpRBA->rgRBE[i]);

                lpRBA->rgRBE[i] = (LPBYTE)AllocMemPaged(cbRBE);

                if (!lpRBA->rgRBE[i])
                {
                    RecchkKdPrint(BADERRORS, ("Error  allocating RBE for Inode file %s \r\n", lpszName));
                    goto bailout;
                }

                iRet = ReadFileLocalEx2(hf, ulPos, lpRBA->rgRBE[i], cbRBE, FLAG_RW_OSLAYER_PAGED_BUFFER);

                if (iRet < 0)
                {

                    RecchkKdPrint(BADERRORS, ("Error reading Inode file %s \r\n", lpszName));
                    goto bailout;
                }
                if (iRet < (int)cbRBE)
                {
                    break;
                }
                ulPos += cbRBE;
            }

            // initialize the guy
            lpRBA->ulidShadow = ulidShadow;         // Inode
            lpRBA->sGH = sGH;                       // Inode file header
            lpRBA->hf = hf;                         // file handle
            lpRBA->cntRBE = cntRBE;                 // count of record buffer entries in rgRBE
            lpRBA->cntRecsPerRBE = cntRecsPerRBE;   // count of records in each RBE buffer
            lpRBA->cbRBE = cbRBE;                   // size in bytes of each RBE buffer
            lpRBA->ulErrorFlags = ulErrorFlags;     // errors found so far

            *lplpRBA = lpRBA;

            fRet = TRUE;
        }
        else
        {
            RecchkKdPrint(BADERRORS, ("Failed to open %s \r\n", lpszName));
        }

    }
    else
    {
        RecchkKdPrint(BADERRORS, ("Failed memory allocation\r\n"));
    }
bailout:

    if (lpszName)
    {
        FreeNameString(lpszName);
    }

    if (hf)
    {
        CloseFileLocal(hf);
        if (lpRBA)
        {
            lpRBA->hf = CSCHFILE_NULL;
        }
    }

    if (!fRet)
    {
        if (lpRBA)
        {
            FreeRBA(lpRBA);
        }

    }
    return (fRet);
}


BOOL
WriteRBA(
    LPVOID  lpdbID,
    LPRBA   lpRBA,
    LPSTR   lpszFileName
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    CSCHFILE hf = CSCHFILE_NULL;
    BOOL fRet = FALSE;
    LPSTR   lpszName = NULL, lpszTempName = NULL, lpszTempName1 = NULL;
    DWORD   i, cntRecsInLastRBE, cbLastRBE, cntRBEReal;
    unsigned long   ulPos, ulT;

    if (!lpszFileName)
    {
        lpszName = FormNameString(lpdbID, lpRBA->ulidShadow);

        if (!lpszName)
        {
            RecchkKdPrint(BADERRORS, ("Failed to allocate memory\r\n"));
            goto bailout;
        }
    }
    else
    {
        lpszName = lpszFileName;
    }

    // create tempfilel names
    lpszTempName = AllocMemPaged(strlen((LPSTR)lpdbID) + strlen(vszTemp) + 4);

    if (!lpszTempName)
    {
        RecchkKdPrint(BADERRORS, ("Failed to allocate memory\r\n"));
        goto bailout;
    }

    strcpy(lpszTempName, (LPSTR)lpdbID);
    strcat(lpszTempName, "\\");
    strcat(lpszTempName, vszTemp);

    lpszTempName1 = AllocMemPaged(strlen((LPSTR)lpdbID) + strlen(vszTemp1) + 4);

    if (!lpszTempName1)
    {
        RecchkKdPrint(BADERRORS, ("Failed to allocate memory\r\n"));
        goto bailout;
    }

    strcpy(lpszTempName1, (LPSTR)lpdbID);
    strcat(lpszTempName1, "\\");
    strcat(lpszTempName1, vszTemp1);



    hf = R0OpenFileEx(ACCESS_READWRITE, ACTION_CREATEALWAYS, FILE_ATTRIBUTE_SYSTEM, lpszTempName, FALSE);

    if (!hf)
    {
        RecchkKdPrint(BADERRORS, ("Failed to open %s\r\n", lpszTempName));
        goto bailout;
    }

    // this is the real # of RBEs, there might be empty ones
    // after this

    cntRBEReal = lpRBA->sGH.ulRecords / lpRBA->cntRecsPerRBE;

    RecchkKdPrint(RBA, ("Writing %s\r\n", lpszTempName));

    // is there a partial RBE at the end?
    if (lpRBA->sGH.ulRecords % lpRBA->cntRecsPerRBE)
    {
        // yes, bump up the count of RBEs to write and caclulate the
        // # of bytes

        cntRBEReal++;
        cntRecsInLastRBE = lpRBA->sGH.ulRecords - (cntRBEReal - 1) * lpRBA->cntRecsPerRBE;
        cbLastRBE = cntRecsInLastRBE * lpRBA->sGH.uRecSize;

    }
    else
    {
        // records exactly fit in the last RBE.
        // so the stats for the last RBE are trivial

        cntRecsInLastRBE = lpRBA->cntRecsPerRBE;
        cbLastRBE = lpRBA->cbRBE;
    }


    RecchkKdPrint(RBA, ("%d RBEs, %d bytes in last RBE\r\n", cntRBEReal, cbLastRBE));

    Assert(cntRBEReal <= lpRBA->cntRBE);

    if(WriteFileLocalEx2(hf, 0, &(lpRBA->sGH), sizeof(lpRBA->sGH), FLAG_RW_OSLAYER_PAGED_BUFFER)!=((int)sizeof(lpRBA->sGH)))
    {
        RecchkKdPrint(BADERRORS, ("Failed writing header \r\n"));
        goto bailout;
    }

    ulPos = lpRBA->sGH.lFirstRec;

    for (i=0; i<cntRBEReal; ++i)
    {
        DWORD dwSize;

        // if last RBE, write the residual size calculated above
        dwSize = (((i+1)==cntRBEReal)?cbLastRBE:lpRBA->cbRBE);

        // there must be a corresponding RBE
        Assert(lpRBA->rgRBE[i]);

        if(WriteFileLocalEx2(hf, ulPos, lpRBA->rgRBE[i], dwSize, FLAG_RW_OSLAYER_PAGED_BUFFER)!=(int)dwSize)
        {
            RecchkKdPrint(BADERRORS, ("Error writing file\r\n"));
            goto bailout;
        }

        ulPos += dwSize;
    }

    CloseFileLocal(hf);
    hf = CSCHFILE_NULL;

    if((GetAttributesLocal(lpszTempName1, &ulT)>=0)
        && (DeleteFileLocal(lpszTempName1, ATTRIB_DEL_ANY) < 0))
    {
        RecchkKdPrint(BADERRORS, ("WriteRBA: failed to delete temp file %s\r\n", lpszTempName1));
        goto bailout;
    }

    if(RenameFileLocal(lpszName, lpszTempName1) < 0)
    {
        RecchkKdPrint(BADERRORS, ("WriteRBA: failed to rename original %s to temp file %s\r\n", lpszName, lpszTempName1));
        goto bailout;

    }

    if(RenameFileLocal(lpszTempName, lpszName) < 0)
    {
        RecchkKdPrint(BADERRORS, ("WriteRBA: failed to rename new file %s to the original %s\r\n", lpszTempName, lpszName));
        if(RenameFileLocal(lpszTempName1, lpszTempName) < 0)
        {
            RecchkKdPrint(BADERRORS, ("WriteRBA: failed to rename back %s to the original %s\r\n", lpszTempName1, lpszName));
            Assert(FALSE);
        }
        goto bailout;

    }

    fRet = TRUE;


bailout:

    if (hf)
    {
        CloseFileLocal(hf);
    }

    // if a name wasn't sent in, we must have allocated it
    if (!lpszFileName)
    {
        FreeNameString(lpszName);
    }

    if (lpszTempName)
    {
        FreeMemPaged(lpszTempName);
    }

    if (lpszTempName1)
    {
        FreeMemPaged(lpszTempName1);
    }

    return (fRet);
}

LPVOID
GetRecordPointerFromRBA(
    LPRBA           lpRBA,
    unsigned        ulRec
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    DWORD   indxRec, indxRBE;

    if (lpRBA->sGH.ulRecords < ulRec)
    {
        RecchkKdPrint(BADERRORS, ("GetRecordPointerFromRBA: invalid rec passed in lpRBA->ulidShadow=%xh lpRBA->sGH.ulRecords=%xh ulRec=%xh\r\n",
            lpRBA->ulidShadow, lpRBA->sGH.ulRecords, ulRec));

        return NULL;
    }

    indxRBE = (ulRec-1)/lpRBA->cntRecsPerRBE;
    indxRec = (ulRec-1)%lpRBA->cntRecsPerRBE;

    Assert(lpRBA->rgRBE[indxRBE]);

    return ((lpRBA->rgRBE[indxRBE])+indxRec*lpRBA->sGH.uRecSize);
}

BOOL
ReadRecordFromRBA(
    LPRBA           lpRBA,
    unsigned        ulRec,
    LPGENERICREC    lpGR
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    DWORD   indxRec, indxRBE, cntOvf, i;
    char uchOvfType;
    LPGENERICREC    lpGRT;


    if(lpRBA->sGH.ulRecords < ulRec)
    {
        // this must have been fixed when we read the file in
        // only in case of priority Q, where the records point
        // to each other is it possible that this could happen

        Assert(lpRBA->ulidShadow == ULID_PQ);
    }

    indxRBE = (ulRec-1)/lpRBA->cntRecsPerRBE;
    indxRec = (ulRec-1)%lpRBA->cntRecsPerRBE;

    Assert(lpRBA->rgRBE[indxRBE]);

    lpGRT = (LPGENERICREC)((lpRBA->rgRBE[indxRBE])+indxRec*lpRBA->sGH.uRecSize);

    memcpy(lpGR, (lpRBA->rgRBE[indxRBE])+indxRec*lpRBA->sGH.uRecSize, lpRBA->sGH.uRecSize);


    if ((lpGR->uchType == REC_DATA)||(lpGR->uchType == REC_EMPTY))
    {
        cntOvf = (DWORD)OvfCount(lpGR);

        uchOvfType = (lpGR->uchType == REC_DATA)?REC_OVERFLOW:REC_EMPTY;

        if (cntOvf > MAX_OVERFLOW_RECORDS)
        {
            lpRBA->ulErrorFlags |= RBA_ERROR_INVALID_OVF;
            SetOvfCount(lpGR, MAX_OVERFLOW_RECORDS);
        }
        if (cntOvf)
        {
            for (i=1; i<=cntOvf; ++i)
            {
                indxRBE = (ulRec+i-1)/lpRBA->cntRecsPerRBE;
                indxRec = (ulRec+i-1)%lpRBA->cntRecsPerRBE;
                memcpy(((LPBYTE)lpGR)+i*lpRBA->sGH.uRecSize, (lpRBA->rgRBE[indxRBE])+indxRec*lpRBA->sGH.uRecSize, lpRBA->sGH.uRecSize);
                if (((LPGENERICREC)(((LPBYTE)lpGR)+i*lpRBA->sGH.uRecSize))->uchType != uchOvfType)
                {
                    lpRBA->ulErrorFlags |= RBA_ERROR_INVALID_OVF;
                    SetOvfCount(lpGR, (i-1));
                }
            }
        }
    }
    else
    {
        lpGR->uchType = REC_EMPTY;
        SetOvfCount(lpGR, 0);

        lpGRT->uchType = REC_EMPTY;
        SetOvfCount(lpGRT, 0);

        lpRBA->ulErrorFlags |= RBA_ERROR_MISALIGNED_RECORD;
        RecchkKdPrint(BADERRORS, ("ReadRecordFromRBA: misaligned record found \r\n"));
    }

    return (TRUE);
}

BOOL
WriteRecordToRBA(
    LPRBA           lpRBA,
    unsigned        ulRec,
    LPGENERICREC    lpGR,
    BOOL            fOverwrite,
    LPDWORD         lpdwError
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{

    DWORD   indxRec, indxRBE, cntOvf, i, ulRecords;
    LPGENERICREC    lpGRT;

    indxRBE = (ulRec-1)/lpRBA->cntRecsPerRBE;
    indxRec = (ulRec-1)%lpRBA->cntRecsPerRBE;

    if (indxRBE >= MAX_RBES_EXPECTED)
    {
        lpRBA->ulErrorFlags |= RBA_ERROR_LIMIT_EXCEEDED;

        RecchkKdPrint(BADERRORS, ("WriteRecordToRBA: Limit of reached, for Inode %x, skipping\r\n", lpRBA->ulidShadow));

        if (lpdwError)
        {
            *lpdwError = ERROR_BUFFER_OVERFLOW;
        }
        return FALSE;
        
    }
    if (!lpRBA->rgRBE[indxRBE])
    {
        if (!FillupRBAUptoThisRBE(lpRBA, indxRBE))
        {
            RecchkKdPrint(BADERRORS, ("WriteRecordToRBA: failed to fillup RBA\r\n"));
            if (lpdwError)
            {
                *lpdwError = ERROR_NOT_ENOUGH_MEMORY;
            }
            return FALSE;
        }
    }

    Assert(lpRBA->rgRBE[indxRBE]);

    lpGRT = (LPGENERICREC)((lpRBA->rgRBE[indxRBE])+indxRec*lpRBA->sGH.uRecSize);

    if (!fOverwrite && ((lpGRT->uchType == REC_DATA)||(lpGRT->uchType == REC_OVERFLOW)))
    {
        RecchkKdPrint(RBA, ("Not overwriting at ulrec=%d in RBA for Inode 0x%x", ulRec, lpRBA->ulidShadow));
        if (lpdwError)
        {
            *lpdwError = ERROR_INVALID_PARAMETER;
        }
        return FALSE;
    }

    memcpy((lpRBA->rgRBE[indxRBE])+indxRec*lpRBA->sGH.uRecSize, lpGR, lpRBA->sGH.uRecSize);


    cntOvf = (DWORD)OvfCount(lpGR);
    if (cntOvf)
    {
        for (i=1; i<=cntOvf; ++i)
        {
            indxRBE = (ulRec+i-1)/lpRBA->cntRecsPerRBE;
            indxRec = (ulRec+i-1)%lpRBA->cntRecsPerRBE;
            if (!lpRBA->rgRBE[indxRBE])
            {
                RecchkKdPrint(RBA, ("Extending RBEs upto indx=%d \r\n", indxRBE));
                if (!FillupRBAUptoThisRBE(lpRBA, indxRBE))
                {
                    RecchkKdPrint(BADERRORS, ("WriteRecordToRBA: failed to fillup RBA\r\n"));
                    return FALSE;
                }
            }
            memcpy( (lpRBA->rgRBE[indxRBE])+indxRec*lpRBA->sGH.uRecSize,
                    ((LPBYTE)lpGR)+i*lpRBA->sGH.uRecSize,
                    lpRBA->sGH.uRecSize);
        }
    }

    // reflect any addition in the count of records
    // add up total records in all RBEs except the last one
    // which might be partially filled, then add the index of the
    // one we just filled in , then add one because the index is
    // 0 based

     ulRecords =  lpRBA->cntRecsPerRBE * indxRBE
                                + indxRec
                                + 1;
    if (ulRecords > lpRBA->sGH.ulRecords)
    {
        RecchkKdPrint(RBA, ("# of records got increased from %d to %d\r\n", lpRBA->sGH.ulRecords, ulRecords));
        lpRBA->sGH.ulRecords = ulRecords;
    }

    return (TRUE);
}

BOOL
FillupRBAUptoThisRBE(
    LPRBA   lpRBA,
    DWORD   indxRBE
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    DWORD   i;
    for (i=0; i<= indxRBE; ++i)
    {
        if (!lpRBA->rgRBE[i])
        {
            lpRBA->rgRBE[i] = (LPBYTE)AllocMemPaged(lpRBA->cbRBE);
            if (!lpRBA->rgRBE[i])
            {
                RecchkKdPrint(BADERRORS, ("FillupRBAUptoThisPoint:Failed memory allocation \r\n"));
                return FALSE;
            }
            InitializeRBE(lpRBA, i);
        }
    }
    return (TRUE);
}

VOID
InitializeRBE(
    LPRBA   lpRBA,
    DWORD   indxRBE
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    DWORD i;
    LPBYTE  lpT = lpRBA->rgRBE[indxRBE];

    for (i=0; i< lpRBA->cntRecsPerRBE; ++i)
    {
        Assert(((LPGENERICREC)lpT)->uchType != REC_DATA);

        ((LPGENERICREC)lpT)->uchType = REC_EMPTY;
        lpT += lpRBA->sGH.uRecSize;
    }
}

BOOL
InsertRBAPQEntryFile(
    LPRBA       lpRBAPQ,
    LPQREC      lpPQDst,
    unsigned    ulrecDst
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    LPQREC      lpPQCur, lpPQPred=NULL;
    LPQHEADER   lpQH = NULL;
    unsigned ulrecCur, ulrecPred;

    lpQH = (LPQHEADER)&(lpRBAPQ->sGH);

    if (!lpQH->ulrecHead)
    {
        Assert(!lpQH->ulrecTail);

        lpQH->ulrecHead = lpQH->ulrecTail = ulrecDst;
        lpPQDst->ulrecNext = lpPQDst->ulrecPrev = 0;
    }
    else
    {
        for(ulrecCur = lpQH->ulrecHead, lpPQPred=NULL, ulrecPred=0;;)
        {
            if (!(lpPQCur = GetRecordPointerFromRBA(lpRBAPQ, ulrecCur)))
            {
                RecchkKdPrint(BADERRORS, ("InsertRBAPQEntry: failed getting q entry at %d\r\n", ulrecCur));
                return FALSE;
            }

            // are we greater than or equal to the current one?
            if (IComparePri(lpPQDst, lpPQCur) >= 0)
            {
                // yes, insert here

                if (!lpPQPred)
                {
                    // no predecessor, must be the head of the list
                    Assert(!lpPQCur->ulrecPrev);

                    // when we become the head, we got no prev
                    lpPQDst->ulrecPrev = 0;

                    // and the current head is our next
                    lpPQDst->ulrecNext = lpQH->ulrecHead;

                    // fix up the current heads prev to point to us
                    lpPQCur->ulrecPrev = ulrecDst;

                    // and fix the current head to point to us
                    lpQH->ulrecHead = ulrecDst;
                }
                else
                {
                    // normal case, we go between lpPQPred and lpPQCur

                    Assert(ulrecPred);

                    // fix up the passed in guy first

                    lpPQDst->ulrecPrev = ulrecPred;
                    lpPQDst->ulrecNext = ulrecCur;

                    // now fix the predecessor's next and current guys prev to point to us
                    lpPQPred->ulrecNext = lpPQCur->ulrecPrev = ulrecDst;

                }
                break;
            }

            ulrecPred = ulrecCur;
            ulrecCur = lpPQCur->ulrecNext;

            if (!ulrecCur)
            {

                // Insert at the tail
                lpPQDst->ulrecNext = 0;
                lpPQDst->ulrecPrev = lpQH->ulrecTail;

                lpPQCur->ulrecNext = ulrecDst;
                lpQH->ulrecTail = ulrecDst;

                break;
            }

            lpPQPred = lpPQCur;

        }
    }

    return (TRUE);
}


BOOL
InsertRBAPQEntryDir(
    LPRBA       lpRBAPQ,
    LPQREC      lpPQDst,
    unsigned    ulrecDst
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    LPQREC      lpPQCur, lpPQSucc=NULL;
    LPQHEADER   lpQH = NULL;
    unsigned ulrecCur, ulrecSucc;

    lpQH = (LPQHEADER)&(lpRBAPQ->sGH);

    if (!lpQH->ulrecHead)
    {
        Assert(!lpQH->ulrecTail);

        lpQH->ulrecHead = lpQH->ulrecTail = ulrecDst;
        lpPQDst->ulrecNext = lpPQDst->ulrecPrev = 0;
    }
    else
    {
        for(ulrecCur = lpQH->ulrecTail, lpPQSucc=NULL, ulrecSucc=0;;)
        {
            if (!(lpPQCur = GetRecordPointerFromRBA(lpRBAPQ, ulrecCur)))
            {
                RecchkKdPrint(BADERRORS, ("InsertRBAPQEntry: failed getting q entry at %d\r\n", ulrecCur));
                return FALSE;
            }

            // are we less than or equal to the current one?
            if (IComparePri(lpPQDst, lpPQCur) <= 0)
            {
                // yes, insert here

                if (!lpPQSucc)
                {
                    // no Succecessor, must be the tail of the list
                    Assert(!lpPQCur->ulrecNext);

                    // when we become the tail, we got no next
                    lpPQDst->ulrecNext = 0;

                    // and the current tail is our prev
                    lpPQDst->ulrecPrev = lpQH->ulrecTail;

                    Assert(lpQH->ulrecTail == ulrecCur);

                    Assert(!lpPQCur->ulrecNext);

                    // fix up the current tails next to point to us
                    lpPQCur->ulrecNext = ulrecDst;

                    // and fix the current tail to point to us
                    lpQH->ulrecTail = ulrecDst;
                }
                else
                {
                    // normal case, we go between lpPQCur and lpPQSucc

                    Assert(ulrecSucc);

                    // fix up the passed in guy first

                    lpPQDst->ulrecNext = ulrecSucc;
                    lpPQDst->ulrecPrev = ulrecCur;

                    // now fix the Succecessor's prev and current guys next to point to us
                    lpPQSucc->ulrecPrev = lpPQCur->ulrecNext = ulrecDst;

                }
                break;
            }

            ulrecSucc = ulrecCur;
            ulrecCur = lpPQCur->ulrecPrev;

            if (!ulrecCur)
            {

                // Insert at the head
                lpPQDst->ulrecPrev = 0;
                lpPQDst->ulrecNext = lpQH->ulrecHead;

                lpPQCur->ulrecPrev = ulrecDst;
                lpQH->ulrecHead = ulrecDst;

                break;
            }

            lpPQSucc = lpPQCur;

        }
    }

    return (TRUE);
}


BOOL
ValidateQrecFromFilerec(
    unsigned        ulidShare,
    unsigned        ulidDir,
    LPFILERECEXT    lpFR,
    LPQREC          lpQR,
    unsigned        ulrecDirEntry
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    if (lpQR->uchType != REC_DATA)
    {
        RecchkKdPrint(BADERRORS, ("Invalid Qrec type %c \r\n", lpQR->uchType));
        return FALSE;
    }

    if ((lpQR->ulidShare != ulidShare)||
        (lpQR->ulidDir != ulidDir)||
        (lpQR->ulidShadow != lpFR->sFR.ulidShadow))
    {
        RecchkKdPrint(BADERRORS, ("Mismatched server, dir or inode \r\n"));
        return FALSE;
    }

    if ((lpQR->usStatus != lpFR->sFR.usStatus)||
        (lpQR->uchRefPri != lpFR->sFR.uchRefPri)||
        (lpQR->uchIHPri != lpFR->sFR.uchIHPri)||
        (lpQR->uchHintFlags != lpFR->sFR.uchHintFlags)||
        (lpQR->uchHintPri != lpFR->sFR.uchHintPri))
    {
        RecchkKdPrint(BADERRORS, ("Mismatched status or pincount\r\n"));
        return FALSE;
    }
    if (ulidDir && (lpQR->ulrecDirEntry != ulrecDirEntry))
    {
        RecchkKdPrint(BADERRORS, ("Mismatched ulrecDirEntry\r\n"));
        return FALSE;
    }

    return TRUE;
}

#if 0

#ifdef DEBUG
VOID
PrintShareHeader(
    LPSHAREHEADER  lpSH,
    LPFNPRINTPROC   lpfnPrintProc
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet=0;

    if (lpfnPrintProc)
    {
        iRet += wsprintfA(vchPrintBuff,"****ShareHeader****\r\n" );

        iRet+=wsprintfA(vchPrintBuff+iRet,"Header: Flags=%xh Version=%lxh Records=%ld Size=%d \r\n",
                    lpSH->uchFlags, lpSH->ulVersion, lpSH->ulRecords, lpSH->uRecSize);

        iRet+=wsprintfA(vchPrintBuff+iRet,"Store: Max=%ld Current=%ld \r\n", lpSH->sMax.ulSize, lpSH->sCur.ulSize);

        iRet+=wsprintfA(vchPrintBuff+iRet,"\r\n");

        (lpfnPrintProc)(vchPrintBuff);
    }
}

VOID
PrintPQHeader(
    LPQHEADER   lpQH,
    PRINTPROC lpfnPrintProc
    )
{
    int iRet=0;

    if (lpfnPrintProc)
    {
        iRet += wsprintfA(vchPrintBuff+iRet,"****PQHeader****\r\n" );

        iRet += wsprintfA(vchPrintBuff+iRet,"Flags=%xh Version=%lxh Records=%ld Size=%d head=%ld tail=%ld\r\n",
                    lpQH->uchFlags, lpQH->ulVersion, lpQH->ulRecords, lpQH->uRecSize, lpQH->ulrecHead, lpQH->ulrecTail);
        iRet += wsprintfA(vchPrintBuff+iRet,"\r\n");

        (lpfnPrintProc)(vchPrintBuff);
    }
}

VOID
PrintFileHeader(
    LPFILEHEADER lpFH,
    unsigned    ulSpaces,
    PRINTPROC lpfnPrintProc
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{

    int iRet=0;

    if (lpfnPrintProc)
    {
        iRet += PrintSpaces(vchPrintBuff+iRet, ulSpaces);
        iRet += wsprintfA(vchPrintBuff+iRet,"****FileHeader****\r\n" );

        iRet += PrintSpaces(vchPrintBuff+iRet, ulSpaces);
        iRet += wsprintfA(vchPrintBuff+iRet,"Flags=%xh Version=%lxh Records=%ld Size=%d\r\n",
                    lpFH->uchFlags, lpFH->ulVersion, lpFH->ulRecords, lpFH->uRecSize);

        iRet += PrintSpaces(vchPrintBuff+iRet, ulSpaces);
        iRet += wsprintfA(vchPrintBuff+iRet,"bytes=%ld entries=%d Share=%xh Dir=%xh\r\n",
                    lpFH->ulsizeShadow, lpFH->ucShadows, lpFH->ulidShare, lpFH->ulidDir);

        iRet += wsprintfA(vchPrintBuff+iRet,"\r\n");

        (lpfnPrintProc)(vchPrintBuff);
    }
}

VOID
PrintPQrec(
    unsigned    ulRec,
    LPQREC      lpQrec,
    PRINTPROC lpfnPrintProc
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet=0;

    if (lpfnPrintProc)
    {
        iRet += wsprintfA(vchPrintBuff+iRet,"rec=%xh: Srvr=%xh dir=%xh shd=%xh prev=%xh next=%xh Stts=%xh, RfPr=%d PnCnt=%x PnFlgs=%xh DrEntr=%d\r\n"
                    ,ulRec
                    , lpQrec->ulidShare
                    , lpQrec->ulidDir
                    , lpQrec->ulidShadow
                    , lpQrec->ulrecPrev
                    , lpQrec->ulrecNext
                    , (unsigned long)(lpQrec->usStatus)
                    , (unsigned long)(lpQrec->uchRefPri)
                    , (unsigned long)(lpQrec->uchHintPri)
                    , (unsigned long)(lpQrec->uchHintFlags)
                    , lpQrec->ulrecDirEntry

            );

        (lpfnPrintProc)(vchPrintBuff);
    }
}

VOID PrintShareRec(
    unsigned ulRec,
    LPSHAREREC lpSR,
    PRINTPROC lpfnPrintProc
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet=0;

    if (lpfnPrintProc)
    {
        iRet += wsprintfA(vchPrintBuff+iRet,"Type=%c Flags=%xh hShare=%lxh Root=%0lxh status=%xh Share=%s \r\n"
             , lpSR->uchType, (unsigned)lpSR->uchFlags, ulRec, lpSR->ulidShadow
             , lpSR->uStatus, lpSR->rgPath);
        iRet += wsprintfA(vchPrintBuff+iRet,"Hint: HintFlags=%xh, HintPri=%d, IHPri=%d\r\n",
                     (unsigned)(lpSR->uchHintFlags)
                     , (int)(lpSR->uchHintPri)
                     , (int)(lpSR->uchIHPri));

        iRet += wsprintfA(vchPrintBuff+iRet,"\r\n");

        (lpfnPrintProc)(vchPrintBuff+iRet);
    }
}

VOID PrintFilerec(
    unsigned ulRec,
    LPFILERECEXT    lpFR,
    unsigned    ulSpaces,
    PRINTPROC lpfnPrintProc
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int i;
    int iRet=0;

    if (lpfnPrintProc)
    {
        iRet += PrintSpaces(vchPrintBuff+iRet, ulSpaces);

        iRet += wsprintfA(vchPrintBuff+iRet,"Type=%c Flags=%xh Inode=%0lxh status=%xh 83Name=%ls size=%ld attrib=%lxh \r\n",
            lpFR->sFR.uchType, (unsigned)lpFR->sFR.uchFlags, lpFR->sFR.ulidShadow,
            lpFR->sFR.uStatus, lpFR->sFR.rgw83Name, lpFR->sFR.ulFileSize, lpFR->sFR.dwFileAttrib);

        iRet += PrintSpaces(vchPrintBuff+iRet, ulSpaces);

        iRet += wsprintfA(vchPrintBuff+iRet,"time: hi=%lxh lo=%lxh orgtime: hi=%lxh lo=%lxh\r\n"
                     , lpFR->sFR.ftLastWriteTime.dwHighDateTime,lpFR->sFR.ftLastWriteTime.dwLowDateTime
                     , lpFR->sFR.ftOrgTime.dwHighDateTime,lpFR->sFR.ftOrgTime.dwLowDateTime);

        iRet += PrintSpaces(vchPrintBuff+iRet, ulSpaces);

        iRet += wsprintfA(vchPrintBuff+iRet,"Hint: HintFlags=%xh, RefPri=%d, HintPri=%d AliasInode=%0lxh \r\n",
                     (unsigned)(lpFR->sFR.uchHintFlags)
                     , (int)(lpFR->sFR.uchRefPri)
                     , (int)(lpFR->sFR.uchHintPri)
                     , lpFR->sFR.ulidShadowFrom);

        iRet += PrintSpaces(vchPrintBuff+iRet, ulSpaces);

        iRet += wsprintfA(vchPrintBuff+iRet,"LFN=%-14ls", lpFR->sFR.rgwName);

        for(i = 0; i < OvfCount(lpFR); ++i)
        {
            iRet += wsprintfA(vchPrintBuff+iRet,"%-74s", &(lpFR->sFR.ulidShadow));
        }

        iRet += wsprintfA(vchPrintBuff+iRet,"\r\n");

        (lpfnPrintProc)(vchPrintBuff);
    }
}

int
PrintSpaces(
    LPSTR   lpBuff,
    unsigned    ulSpaces
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    unsigned i;
    int iRet=0;

    for (i=0; i< ulSpaces; ++i)
    {
        iRet += wsprintfA(lpBuff+iRet," ");
    }
    return iRet;

}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\record.mgr\oslayer.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

     OsLayer.c

Abstract: (win95)

     none.

Abstract: (NT)

     We go thru these wrapper functions but the main implementation
     is in ntcsclow.c

Author:

     Shishir Pardikar      [Shishirp]        01-jan-1995

Revision History:

     Joe Linn              [joelinn]         01-jan-1997  ported to NT
     Joe Linn              [joelinn]         22-aug-1997  moved NT stuff to ntcsclow.c


--*/

#include "precomp.h"
#pragma hdrstop

#pragma code_seg("PAGE")

#ifndef CSC_RECORDMANAGER_WINNT
#define WIN32_APIS
#include "cshadow.h"
#endif //ifndef CSC_RECORDMANAGER_WINNT

//already included by shdcom.h #include "ifs.h"


#ifdef CSC_RECORDMANAGER_WINNT
#define Dbg (DEBUG_TRACE_MRXSMBCSC_OSLAYER)
RXDT_DefineCategory(MRXSMBCSC_OSLAYER);
#endif //ifdef CSC_RECORDMANAGER_WINNT

//#define RXJOECSC_WHACKTRACE_FOR_OSLAYER
#ifdef RXJOECSC_WHACKTRACE_FOR_OSLAYER
#undef RxDbgTrace
#define RxDbgTrace(a,b,__d__) {DbgPrint __d__;}
#endif

#ifdef  CSC_BUILD_W_PROGRESS_CATCHERS
VOID
CscProgressInit (
    PCSC_PROGRESS_BLOCK ProgressBlock,
    ULONG Counter,
    PVOID NearArgs
    )
{
    ProgressBlock->Counter = Counter;
    ProgressBlock->NearTop = &NearArgs;
    ProgressBlock->NearArgs = NearArgs;
    ProgressBlock->Progress = 0x80000000;
    ProgressBlock->LastBit = 0;
    ProgressBlock->Loops = 0;
    ProgressBlock->StackRemaining = IoGetRemainingStackSize();
    ProgressBlock->RetAddrP = ((PULONG)NearArgs)-1;  //that's one ulong, boys....
    ProgressBlock->RetAddr = *(ProgressBlock->RetAddrP);
    ProgressBlock->SignatureOfEnd = '!dne';
}
VOID
CscProgress (
    PCSC_PROGRESS_BLOCK ProgressBlock,
    ULONG Bit
    )
{
    if( (*(ProgressBlock->RetAddrP)) != ProgressBlock->RetAddr ) {
        DbgPrint("Returnaddr has been trashed %08lx %08lx %08lx %08lx\n",
                    ProgressBlock,Bit,
                    (*(ProgressBlock->RetAddrP)),
                    ProgressBlock->RetAddr);
        DbgBreakPoint();
    }
    ProgressBlock->Progress |= (1<<Bit);
    if (Bit <= ProgressBlock->LastBit) {
        ProgressBlock->Loops++;
    }
    ProgressBlock->LastBit = Bit;
}
#endif //ifdef CSC_RECORDMANAGER_WINNT


/*
*/
/********************** typedefs and defines ********************************/
#ifdef HISTORY
#define R0_OPENCREATE    0xD500
#define R0_READ            0xD600
#define R0_WRITE          0xD601
#define R0_CLOSE          0xD700
#define R0_GETFILESIZE  0xD800
#define R0_RENAMEFILE    0x5600
#define R0_FILELOCK      0x5C00
#define R0_GETATTRIBUTE 0x4300
#define R0_SETATTRIBUTE 0x4301
#define R0_DELETEFILE    0x4100
#endif //HISTORY
#define R0_UNLOCKFILE    0x5C01
#define R0_SETATTRIBUTE 0x4301
#pragma intrinsic (memcmp, memcpy, memset, strcat, strcmp, strcpy, strlen)

/********************** static data *****************************************/
/********************** global data *****************************************/

AssertData;
AssertError;
/********************** function prototypes *********************************/

int Ring0Api();


/****************************************************************************/

/************************ File I/O ******************************************/

#ifndef CSC_RECORDMANAGER_WINNT
#pragma VxD_LOCKED_CODE_SEG
#endif //ifndef CSC_RECORDMANAGER_WINNT

long R0ReadWriteFile (ULONG uOper, CSCHFILE handle, ULONG pos, PVOID, long lCount);
#ifndef R0ReadWriteFileEx
long R0ReadWriteFileEx (ULONG uOper, CSCHFILE handle, ULONG pos, PVOID, long lCount, BOOL fInstrument);
#endif  //ifndef R0ReadWriteFile
#ifndef R0ReadWriteFileEx2
long R0ReadWriteFileEx2 (ULONG uOper, CSCHFILE handle, ULONG pos, PVOID, long lCount, ULONG uFlags);
#endif  //ifndef R0ReadWriteFileEx2

CSCHFILE CreateFileLocal(LPSTR lpPath)
{
    return (R0OpenFile(ACCESS_READWRITE, ACTION_OPENALWAYS, lpPath));
}

CSCHFILE OpenFileLocal(LPSTR lpPath)
{
    return (OpenFileLocalEx(lpPath, FALSE));
}
CSCHFILE OpenFileLocalEx(LPSTR lpPath, BOOL fInstrument)
{
    CSCHFILE hf;
//    unsigned uSize;

    hf = R0OpenFileEx(ACCESS_READWRITE, ACTION_OPENEXISTING, 0, lpPath, fInstrument);

#ifdef DEBUG
    if (!hf)
        KdPrint(("OpenFileLocal: error opening %s \r\n", lpPath));
#endif //DEBUG

#ifdef OBSOLETE
    // BUGBUG-win9xonly temporary kludge till fixed in IFS
    hf = R0OpenFile(ACCESS_READWRITE, ACTION_OPENALWAYS, lpPath);
    if (hf)
    {
        if ((GetFileSizeLocal(hf, &uSize) < 0 ) || !uSize)
        {
            CloseFileLocal(hf);
            hf = CSCHFILE_NULL;
        }
    }
#endif //OBSOLETE
    return (hf);
}


int FileExists
    (
    LPSTR lpPath
    )
{
    CSCHFILE hf;
    if (hf = R0OpenFile(ACCESS_READWRITE, ACTION_OPENEXISTING, lpPath))
    {
        CloseFileLocal(hf);
    }
    return (hf != CSCHFILE_NULL);
}

long ReadFileLocal
    (
    CSCHFILE handle,
    ULONG pos,
    LPVOID pBuff,
    long  lCount
    )
{
    return(R0ReadWriteFile(R0_READFILE, handle, pos, pBuff,lCount));
}

long ReadFileLocalEx
    (
    CSCHFILE handle,
    ULONG pos,
    LPVOID pBuff,
    long  lCount,
    BOOL  fInstrument
    )
{
    return(R0ReadWriteFileEx(R0_READFILE, handle, pos, pBuff,lCount, fInstrument));
}

long ReadFileLocalEx2
    (
    CSCHFILE handle,
    ULONG pos,
    LPVOID pBuff,
    long  lCount,
    ULONG   flags
    )
{
    return(R0ReadWriteFileEx2(R0_READFILE, handle, pos, pBuff, lCount, flags));
}

long WriteFileLocal
    (
    CSCHFILE handle,
    ULONG pos,
    LPVOID pBuff,
    long  lCount
    )
{
    return(R0ReadWriteFile(R0_WRITEFILE, handle, pos, pBuff, lCount));
}

long WriteFileLocalEx
    (
    CSCHFILE handle,
    ULONG pos,
    LPVOID pBuff,
    long  lCount,
    BOOL    fInstrument
    )
{
    return(R0ReadWriteFileEx(R0_WRITEFILE, handle, pos, pBuff, lCount, FALSE));
}

long WriteFileLocalEx2(
    CSCHFILE      hf,
    unsigned    long lSeek,
    LPVOID      lpBuff,
    long         cLength,
    ULONG       flags
    )
{
    return (R0ReadWriteFileEx2(R0_WRITEFILE, hf, lSeek, lpBuff, cLength, flags));
}

long ReadFileInContextLocal
    (
    CSCHFILE handle,
    ULONG pos,
    LPVOID pBuff,
    long  lCount
    )
{
    return(R0ReadWriteFile(R0_READFILE_IN_CONTEXT, handle, pos, pBuff,lCount));
}

long WriteFileInContextLocal
    (
    CSCHFILE handle,
    ULONG pos,
    LPVOID pBuff,
    long  lCount
    )
{
    return(R0ReadWriteFile(R0_WRITEFILE_IN_CONTEXT, handle, pos, pBuff, lCount));
}


#ifndef CSC_RECORDMANAGER_WINNT
ULONG CloseFileLocal
    (
    CSCHFILE handle
    )
{
    ULONG uOp = R0_CLOSEFILE;
    _asm
    {
        mov    eax,  uOp
        mov    ebx,  handle
        call  Ring0Api
        jc     error
        xor    eax,eax
error:
    }
}
#endif //ifndef CSC_RECORDMANAGER_WINNT

CSCHFILE R0OpenFile
    (
    USHORT usOpenFlags,
    UCHAR  bAction,
    LPSTR lpPath
    )
    {
        return (R0OpenFileEx(usOpenFlags, bAction, FILE_ATTRIBUTE_NORMAL, lpPath, FALSE));
    }

#ifndef CSC_RECORDMANAGER_WINNT
CSCHFILE R0OpenFileEx
    (
    USHORT  usOpenFlags,
    UCHAR   bAction,
    ULONG   ulAttr,
    LPSTR   lpPath,
    BOOL    fInstrument
    )
{
    ULONG uOper = R0_OPENCREATFILE;
    UCHAR bR0Opt = R0_SWAPPER_CALL;
    ulAttr; // ignore ulAttr on win9x
    _asm
    {
        mov    eax,  uOper
        mov    bx,    usOpenFlags
        mov    cx,    0
        mov    dl,    bAction
        mov    dh,    bR0Opt
        mov    esi,  lpPath
        call  Ring0Api
        jnc    ok
        xor    eax,eax
ok:
    }
}
#endif //ifndef CSC_RECORDMANAGER_WINNT


long R0ReadWriteFile
    (
    ULONG       uOper,
    CSCHFILE    handle,
    ULONG       pos,
    PVOID       pBuff,
    long        lCount
    )
    {
    return (R0ReadWriteFileEx(uOper, handle, pos, pBuff, lCount, FALSE));
    }

#ifndef CSC_RECORDMANAGER_WINNT
long R0ReadWriteFileEx (// YUK
    ULONG   uOper,
    CSCHFILE handle,
    ULONG   pos,
    PVOID   pBuff,
    long    lCount,
    BOOL    fInstrument // don't care
    )
{
    return (R0ReadWriteFileEx2(uOper, handle, pos, pBuff, lCount, 0));

}

long R0ReadWriteFileEx2
    (
    ULONG   uOper,
    CSCHFILE handle,
    ULONG   pos,
    PVOID   pBuff,
    long    lCount,
    ULONG   ulFlags
    )
{
    int retValue;
    if (lCount < 0 )
        return -1;
    _asm
    {
        mov    eax,  uOper
        mov    ebx,  handle
        mov    ecx,  lCount
        mov    edx,  pos
        mov    esi,  pBuff
        call  Ring0Api
        jnc     done
        mov    eax,0xffffffff

;        neg    eax        ; return negative error codes
done:
    }
}
#endif //ifndef CSC_RECORDMANAGER_WINNT

#ifndef CSC_RECORDMANAGER_WINNT
int GetFileSizeLocal
    (
    CSCHFILE handle,
    PULONG lpuSize
    )
{
    ULONG uSize;
    int iRes=0;
    _asm
    {
        mov    eax,  R0_GETFILESIZE
        mov    ebx,  handle
        call  Ring0Api
        jnc    ok
        mov    iRes,0xffffffff
ok:
        mov    uSize, eax
    }
    *lpuSize = uSize;
    return (iRes);
}
#endif //ifndef CSC_RECORDMANAGER_WINNT

#ifndef CSC_RECORDMANAGER_WINNT
int GetAttributesLocal
    (
    LPSTR lpPath,
    ULONG *lpuAttributes
    )
{
    int iRes=0;
    USHORT usAttrib=0;

    _asm
    {
        mov    eax,  R0_FILEATTRIBUTES
        mov    esi,  lpPath
        call  Ring0Api
        jnc    ok
        mov    iRes,0xffffffff
ok:
        mov    usAttrib, cx
    }
    *lpuAttributes = (ULONG)usAttrib;
    return (iRes);
}
#endif //ifndef CSC_RECORDMANAGER_WINNT

#ifndef CSC_RECORDMANAGER_WINNT
int SetAttributesLocal
    (
    LPSTR lpPath,
    ULONG uAttributes
    )
{
    int iRes=0;
    USHORT usAttrib=(USHORT)uAttributes;
    _asm
    {
        mov    eax,  R0_SETATTRIBUTE
        mov    esi,  lpPath
        mov    cx,    usAttrib
        call  Ring0Api
        jnc    ok
        mov    iRes,0xffffffff
ok:
    }
    return (iRes);
}
#endif //ifndef CSC_RECORDMANAGER_WINNT

#ifndef CSC_RECORDMANAGER_WINNT
int RenameFileLocal
    (
    LPSTR lpFrom,
    LPSTR lpTo
    )
{
    int iRes=0;
#ifdef DEBUG
    int iErr;
#endif //DEBUG

    _asm
    {
        mov    eax,  R0_RENAMEFILE
        mov    esi,  lpFrom
        mov    edx,  lpTo
        call  Ring0Api
        jnc    ok
        mov    iRes,0xffffffff
#ifdef    DEBUG
        mov    iErr,eax
#endif
ok:
    }
#ifdef DEBUG
    if (iRes == 0xffffffff)
    {
        KdPrint(("RenameFileLocal: error %d renaming %s to %s\r\n", iErr, lpFrom, lpTo));
    }
#endif //DEBUG
    return (iRes);
}
#endif //ifndef CSC_RECORDMANAGER_WINNT

#ifndef CSC_RECORDMANAGER_WINNT
int DeleteFileLocal
    (
    LPSTR lpName,
    USHORT usAttrib
    )
{
    int iRes=0;
#ifdef DEBUG
    int iErr;
#endif //DEBUG

    _asm
    {
        mov    eax,  R0_DELETEFILE
        mov    esi,  lpName
        mov    cx,    usAttrib
        call  Ring0Api
        jnc    ok
        mov    iRes,0xffffffff
#ifdef    DEBUG
        mov    iErr,eax
#endif
ok:
    }
#ifdef DEBUG
    if (iRes == 0xffffffff)
    {
        KdPrint(("DeleteFileLocal: error %d deleting %s \r\n", iErr, lpName));
    }
#endif //DEBUG
    return (iRes);
}
#endif //ifndef CSC_RECORDMANAGER_WINNT

int GetDiskFreeSpaceLocal(
    int indx,
    ULONG *lpuSectorsPerCluster,
    ULONG *lpuBytesPerSector,
    ULONG *lpuFreeClusters,
    ULONG *lpuTotalClusters
    )
{
#ifndef CSC_RECORDMANAGER_WINNT
    int iRes = 0;
    BYTE bIndx = (BYTE)indx;
    USHORT  usSPC, usBPS, usFC, usTC;
    _asm
    {
        mov    eax, R0_GETDISKFREESPACE
        mov    dl, bIndx
        call  Ring0Api
        jnc    ok
        mov    iRes, 0xffffffff
        jmp    done
ok:
        mov    usSPC, ax
        mov    usBPS, cx
        mov    usFC,  bx
        mov    usTC,  dx
done:
    }
    if (!iRes)
    {
        *lpuSectorsPerCluster = (ULONG)usSPC;
        *lpuBytesPerSector = (ULONG)usBPS;
        *lpuFreeClusters = (ULONG)usFC;
        *lpuTotalClusters = (ULONG)usTC;
    }
    return (iRes);
#else
    ASSERT(FALSE);
    return(-1);
#endif //ifndef CSC_RECORDMANAGER_WINNT
}

int FileLockLocal( CSCHFILE hf,
    ULONG offsetLock,
    ULONG lengthLock,
    ULONG idProcess,
    BOOL  fLock
    )
{
#ifndef CSC_RECORDMANAGER_WINNT
    int iRes = 0;
    ULONG uOp = (fLock)?R0_LOCKFILE:R0_UNLOCKFILE;
    _asm
    {
        mov    eax, uOp
        mov    ebx, hf
        mov    edx, offsetLock
        mov    esi, lengthLock
        mov    ecx, idProcess
        call  Ring0Api
        jnc    ok
        mov    iRes,0xffffffff
ok:
    }
    return (iRes);
#else
    ASSERT(FALSE);
    return(-1);
#endif //ifndef CSC_RECORDMANAGER_WINNT
}

int FindOpenRemote
    (
    PIOREQ pir,
    LPHFREMOTE  lphFind
    )
{
    int iRet;
    PRESOURCE pResource = pir->ir_rh;
    PFINDINFO pFindInfo;
    hndlfunc hfnSav;
    hfunc_t pSav;

    if(!(pFindInfo = (PFINDINFO)PAllocElem(SizeofFindRemote)))
    {
#if VERBOSE > 1
        KdPrint(("FindOpenRemote: Error creating FindOpen structure \r\n"));
#endif //VERBOSE > 1
        return -1;  // BUGBUG-win9xonly return proper error code
    }

    mSetBits(pFindInfo->usLocalFlags, FLAG_FINDINFO_INTERNAL_HANDLE);
    // HACK save the ioreq structure
    pFindInfo->pnextFindInfo = (PFINDINFO)pir;
    // Save it
    memcpy(LpIoreqFromFindInfo(pFindInfo), pir, sizeof(ioreq));

    pir->ir_data = LpFind32FromFindInfo(pFindInfo);
    pir->ir_attr = FILE_ATTRIBUTE_ALL;
    pir->ir_error = 0;
    pir->ir_flags = RESTYPE_DISK;
    pSav = pir->ir_hfunc;
    pir->ir_hfunc = (hfunc_t)&hfnSav;
    pir->ir_rh = pResource->rhPro;

    (*(pResource->pVolTab->vfn_func[VFN_FINDOPEN]))(pir);
    iRet = pir->ir_error;
    pir->ir_hfunc = pSav;
    pir->ir_rh = (rh_t)pResource;
    pir->ir_error = 0;

    if (!iRet)
    {
        // succeeded

        // Save his file handle
        pFindInfo->fhProFind = pir->ir_fh;

        // Save his function table
        pFindInfo->hfFindHandle = hfnSav;

        // point back to our parent
        pFindInfo->pResource = pResource;

#if VERBOSE > 1
    {

        KdPrint(("FindOpenRemote: lpFind32=%x Lowdate=%x Highdate=%x \r\n"
                    , LpFind32FromFindInfo(pFindInfo)
                    , LpFind32FromFindInfo(pFindInfo)->ftLastWriteTime.dwLowDateTime
                    , LpFind32FromFindInfo(pFindInfo)->ftLastWriteTime.dwHighDateTime));
    }
#endif //VERBOSE > 1
    }
    else
    {
        memcpy(pir, LpIoreqFromFindInfo(pFindInfo), sizeof(ioreq));
        FreeMem(pFindInfo);
#if VERBOSE < 2
        if (iRet != ERROR_NO_MORE_FILES)
#endif //VERBOSE < 2
#if    VERBOSE > 1
            KdPrint(("FindOpenRemote: Error %x \r\n", iRet));
#endif //VERBOSE > 1
        pFindInfo = NULL;
    }

    *lphFind = (HFREMOTE)pFindInfo;
    return (iRet);
}

int FindNextRemote
    (
    PFINDINFO pFindInfo,
    PIOREQ    pir
    )
{
    PRESOURCE pResource = pir->ir_rh;
    int iRet;

    if (mQueryBits(pFindInfo->usLocalFlags, FLAG_FINDINFO_INTERNAL_HANDLE))
    {
        pir = (PIOREQ)(pFindInfo->pnextFindInfo);
    }
    else
    {
        Assert(pir);
    }
    pir->ir_data = LpFind32FromFindInfo(pFindInfo);
    pir->ir_error = 0;

    pir->ir_rh = pFindInfo->pResource->rhPro;
    pir->ir_fh = pFindInfo->fhProFind;
    (*(pFindInfo->hfFindHandle.hf_read))(pir);
    iRet = pir->ir_error;
    pir->ir_rh = (rh_t)(pFindInfo->pResource);
    pir->ir_error = 0;
    return (iRet);
}

int FindCloseRemote
    (
    PFINDINFO pFindInfo,
    PIOREQ    pir
    )
{
    PRESOURCE pResource = pir->ir_rh;
    int iRet;

    if (mQueryBits(pFindInfo->usLocalFlags, FLAG_FINDINFO_INTERNAL_HANDLE))
    {
        pir = (PIOREQ)(pFindInfo->pnextFindInfo);
    }

#if VERBOSE > 1
    KdPrint(("FindCloseRemote: hfind= %x fh=%x\r\n", pFindInfo, pFindInfo->fhProFind));
#endif //VERBOSE > 1
    pir->ir_error = 0;
    pir->ir_rh = pFindInfo->pResource->rhPro;
    pir->ir_fh = pFindInfo->fhProFind;
    (*(pFindInfo->hfFindHandle.hf_misc->hm_func[HM_CLOSE]))(pir);
    iRet = pir->ir_error;
    pir->ir_rh = (rh_t)(pFindInfo->pResource);
    pir->ir_error = 0;
    if (iRet)
    {
#if VERBOSE > 1
        KdPrint(("FindCloseRemote: error hf= %x #=%x \r\n", pFindInfo, iRet));
#endif //VERBOSE > 1
    }
    if (mQueryBits(pFindInfo->usLocalFlags, FLAG_FINDINFO_INTERNAL_HANDLE))
    {
        Assert(pir == (PIOREQ)(pFindInfo->pnextFindInfo));
        memcpy(pir, LpIoreqFromFindInfo(pFindInfo), sizeof(ioreq));
        FreeMem(pFindInfo);
    }
    return (iRet);
}


int OpenFileRemote
    (
    PIOREQ    pir,
    LPHFREMOTE  lphFile
    )
{
    return (OpenFileRemoteEx(pir, ACCESS_READWRITE, ACTION_OPENEXISTING, 0, lphFile));
}

int OpenFileRemoteEx
    (
    PIOREQ    pir,
    UCHAR uchAccess,
    USHORT usOptions,
    ULONG  ulAttr,
    LPHFREMOTE  lphFile
    )
{
    PRESOURCE pResource = (PRESOURCE)(pir->ir_rh);
    PFILEINFO pFileInfo;
    hndlfunc hfnSav;
    hfunc_t pSav;

    int iRet;

    if(!(pFileInfo = (PFILEINFO)PAllocElem(SizeofFileRemote)))
    {
        KdPrint(("OpenFileRemoteEx: Error creating File structure \r\n"));
        return -1;  // BUGBUG-win9xonly return proper error code
    }

    mSetBits(pFileInfo->usLocalFlags, FLAG_FILEINFO_INTERNAL_HANDLE);

    // HACK save the ioreq structure pointer
    pFileInfo->pnextFileInfo = (PFILEINFO)pir;

    // Save it
    memcpy(LpIoreqFromFileInfo(pFileInfo), pir, sizeof(ioreq));


    pir->ir_flags = uchAccess;
    pir->ir_options = usOptions;
    pir->ir_attr = ulAttr;

     // Plug his resource handle back
    pir->ir_rh = pResource->rhPro;

    // Plug this in so servers understanding case can use it
    pir->ir_uFName = IFSLastElement(pir->ir_ppath)->pe_unichars;
    pSav = pir->ir_hfunc;
    memset((LPVOID)&hfnSav, 0, sizeof(hndlfunc));
    pir->ir_hfunc = (hfunc_t)&hfnSav;

    // and call his function
    (*(pResource->pVolTab->vfn_func[VFN_OPEN]))(pir);
    iRet = pir->ir_error;

    pir->ir_hfunc = pSav;
     // Plug our resource handle
    pir->ir_rh = (rh_t)pResource;
    pir->ir_error = 0;
    if (!iRet)
    {
        // succeeded

        // Save his file handle
        pFileInfo->fhProFile = pir->ir_fh;

        // Save his function table
        pFileInfo->hfFileHandle = hfnSav;

        // point back to our parent
        pFileInfo->pResource = pResource;

#if VERBOSE > 1
        KdPrint(("OpenFileRemote:  pFileInfo= %x fhPro=%x, read=%x write=%x\r\n"
            , pFileInfo, pFileInfo->fhProFile,
            hfnSav.hf_read, hfnSav.hf_write));
#endif //VERBOSE > 1
    }
    else
    {
        memcpy(pir, LpIoreqFromFileInfo(pFileInfo), sizeof(ioreq));
        FreeMem(pFileInfo);
#if VERBOSE > 1
        KdPrint(("OpenFileRemote: Error %x \r\n", iRet));
#endif //VERBOSE > 1
        pFileInfo = NULL;
    }

    *lphFile = (HFREMOTE)pFileInfo;
    return (iRet);
}


int ReadFileRemote(
    PFILEINFO    pFileInfo,
    PIOREQ    pir,
    ULONG pos,
    LPVOID    lpBuff,
    ULONG count
    )
{
    int iRet;

    if(mQueryBits(pFileInfo->usLocalFlags, FLAG_FILEINFO_INTERNAL_HANDLE))
    {
        pir = (PIOREQ)(pFileInfo->pnextFileInfo);
    }
    pir->ir_data = lpBuff;
    pir->ir_length = count;
    pir->ir_pos = pos;
    pir->ir_options = 0;
    pir->ir_sfn = pFileInfo->sfnFile;
    pir->ir_pid = pFileInfo->pidFile;
    pir->ir_user = pFileInfo->userFile;
    pir->ir_rh = pFileInfo->pResource->rhPro;
    pir->ir_fh = pFileInfo->fhProFile;

    (*(pFileInfo->hfFileHandle.hf_read))(pir);
    iRet = pir->ir_error;
    pir->ir_rh = (rh_t)(pFileInfo->pResource);
    return ((!iRet)?pir->ir_length:-1);
}

int WriteFileRemote(
    PFILEINFO    pFileInfo,
    PIOREQ    pir,
    ULONG pos,
    LPVOID    lpBuff,
    ULONG count
    )
{
    int iRet;

    if(mQueryBits(pFileInfo->usLocalFlags, FLAG_FILEINFO_INTERNAL_HANDLE))
    {
        pir = (PIOREQ)(pFileInfo->pnextFileInfo);
    }

    pir->ir_data = lpBuff;
    pir->ir_length = count;
    pir->ir_pos = pos;
    pir->ir_options = 0;
    pir->ir_sfn = pFileInfo->sfnFile;
    pir->ir_pid = pFileInfo->pidFile;
    pir->ir_user = pFileInfo->userFile;
    pir->ir_rh = pFileInfo->pResource->rhPro;
    pir->ir_fh = pFileInfo->fhProFile;
    (*(pFileInfo->hfFileHandle.hf_write))(pir);
    iRet = pir->ir_error;
    pir->ir_rh = (rh_t)(pFileInfo->pResource);
    return ((!iRet)?pir->ir_length:-1);
}

int TimeStampRemote(
    PFILEINFO    pFileInfo,
    LPFILETIME  lpFt,
    int            type
    )
{
    BOOL fGetType;
    ioreq ir;
    PIOREQ pir = &ir;
    int iRet;

    fGetType = ((type==GET_MODIFY_DATETIME)||
                    (type==GET_LAST_ACCESS_DATETIME)||
                    (type==GET_CREATION_DATETIME));

    pir->ir_flags = (UCHAR)type;
    pir->ir_sfn = pFileInfo->sfnFile;
    pir->ir_pid = pFileInfo->pidFile;
    pir->ir_user = pFileInfo->userFile;
    pir->ir_rh = pFileInfo->pResource->rhPro;
    pir->ir_fh = pFileInfo->fhProFile;
    pir->ir_options = 0;
    if (!fGetType)
    {
        pir->ir_dostime = IFSMgr_Win32ToDosTime(*lpFt);
    }
    (*(pFileInfo->hfFileHandle.hf_write))(pir);
    iRet = pir->ir_error;
    if (!iRet && fGetType)
    {
        *lpFt = IFSMgr_DosToWin32Time(pir->ir_dostime);
    }
    return (iRet);
}

int CloseFileRemote(
    PFILEINFO    pFileInfo,
    PIOREQ        pir
    )
{
    int iRet;

    if(mQueryBits(pFileInfo->usLocalFlags, FLAG_FILEINFO_INTERNAL_HANDLE))
    {
        pir = (PIOREQ)(pFileInfo->pnextFileInfo);
    }

    pir->ir_rh = pFileInfo->pResource->rhPro;
    pir->ir_fh = pFileInfo->fhProFile;
    pir->ir_options = 0;
    pir->ir_flags = CLOSE_FINAL;
    (*(pFileInfo->hfFileHandle.hf_misc->hm_func[HM_CLOSE]))(pir);
    iRet = pir->ir_error;
    if (iRet)
    {
        KdPrint(("CloseFileRemote: error hf= %x #=%x \r\n", pFileInfo, iRet));
    }
    else
    {
    }
    pir->ir_rh = (rh_t)(pFileInfo->pResource);

    if (mQueryBits(pFileInfo->usLocalFlags, FLAG_FILEINFO_INTERNAL_HANDLE))
    {
        memcpy((PIOREQ)(pFileInfo->pnextFileInfo), LpIoreqFromFileInfo(pFileInfo), sizeof(ioreq));
        FreeMem(pFileInfo);
    }

    return (iRet);
}


int CloseAllRemoteFiles( PRESOURCE    pResource
    )
{
    PFILEINFO pFileInfo = NULL;
    PFDB pFdb = NULL;
    ioreq sIoreq;

    for (pFileInfo = pResource->pheadFileInfo; pFileInfo; pFileInfo=pFileInfo->pnextFileInfo)
    {
        if (IsDupHandle(pFileInfo))
            continue;
        pFdb = pFileInfo->pFdb;
        if (pFileInfo->fhProFile)
        {
            // Do final close only once
            if (!(pFdb->usLocalFlags & FLAG_FDB_FINAL_CLOSE_DONE))
            {
                memset(&sIoreq, 0, sizeof(ioreq));
                CloseFileRemote(pFileInfo, &sIoreq);
                pFdb->usLocalFlags |= FLAG_FDB_FINAL_CLOSE_DONE;
            }

            pFileInfo->fhProFile = 0;
            if (pFileInfo->hfShadow)
            {
                if (mShadowSparse(pFdb->usFlags))
                {
                    CloseFileLocal(pFileInfo->hfShadow);
                    pFileInfo->hfShadow = 0;
                    mSetBits(pFileInfo->usLocalFlags, FLAG_FILEINFO_INVALID_HANDLE);
                }
            }
            else
            {
                mSetBits(pFileInfo->usLocalFlags, FLAG_FILEINFO_INVALID_HANDLE);
            }
        }
    }
    for (pFdb = pResource->pheadFdb; pFdb; pFdb = pFdb->pnextFdb)
    {
        pFdb->usLocalFlags &= ~FLAG_FDB_FINAL_CLOSE_DONE;
    }
    return SRET_OK;
}

int CloseAllRemoteFinds( PRESOURCE    pResource
    )
{
    PFINDINFO pFindInfo = NULL;
    ioreq sIoreq;

    for (pFindInfo = pResource->pheadFindInfo; pFindInfo; pFindInfo=pFindInfo->pnextFindInfo)
    {
        if (pFindInfo->fhProFind)
        {
            memset(&sIoreq, 0, sizeof(ioreq));
            FindCloseRemote(pFindInfo, &sIoreq);
            pFindInfo->fhProFind = 0;
            pFindInfo->usLocalFlags |= FLAG_FINDINFO_INVALID_HANDLE;
        }
    }
    return SRET_OK;
}


int DisconnectResource(
    PRESOURCE pResource
    )
{
#ifdef RESOURCE
    ioreq sIoreq;

    CloseAllRemoteFiles(pResource);
    CloseAllRemoteFinds(pResource);

    memset(&sIoreq, 0, sizeof(ioreq));

    Assert(pResource->rhPro);
    Assert(pResource->pVolTab);

    // Let us restore his rh
    sIoreq.ir_rh = pResource->rhPro;

    // and call his function
    (*(pResource->pVolTab->vfn_func[VFN_DISCONNECT]))(&sIoreq);

    pResource->rhPro = 0;
    pResource->pVolTab = 0;
    return(sIoreq.ir_error);
#endif //RESOURCE
    return (0);
}


#ifdef LATER

int PUBLIC CommitFile(
    CSCHFILE hf
    )
{
    return (-1);
}

#endif
/*************************** Utility Functions ******************************/
#ifndef CSC_RECORDMANAGER_WINNT

//for NT, these have been macro-ed to the appropriate Rx Functions
LPVOID AllocMem
    (
    ULONG uSize
    )
{
    LPVOID lpBuff;

    if (lpBuff = (LPVOID)FGHS(uSize))
    {
        memset(lpBuff, 0, uSize);
    }
    return (lpBuff);
}

VOID FreeMem
    (
    LPVOID lp
    )
{
//    CheckHeap(lp);

    if (lp)
    {
        RetHeap(lp);
    }
}

//for NT, these have been macro-ed to the appropriate Rx Functions
LPVOID AllocMemPaged(
    ULONG   uSize
    )
{
    return NULL;
}

//for NT, these have been macro-ed to the appropriate Rx Functions
VOID FreeMemPaged(
    LPVOID lp
    )
{
    lp;
}

int GetAttributesLocalEx
    (
    LPSTR   lpPath,
    BOOL    fFile,
    ULONG   *lpuAttributes
    )
{
    return(GetAttributesLocal(lpPath, lpuAttributes));
}

int
CreateDirectoryLocal(
    LPSTR   lpPath
    )
{
    return -1;
}
#endif //ifndef CSC_RECORDMANAGER_WINNT
#ifdef CSC_RECORDMANAGER_WINNT
PELEM PAllocElem
    (
    int cbSize
    )
{
    return ((PELEM)AllocMem(cbSize));
}

void FreeElem
    (
    PELEM p
    )
{
    FreeMem(p);
}

void LinkElem
    (
    PELEM pElem,
    PPELEM    ppHead
    )
{
    pElem->pnextElem = *ppHead;
    *ppHead = pElem;
}

PELEM PUnlinkElem
    (
    PELEM pElem,
    PPELEM    ppHead
    )
{
    PELEM p;
    for(;p = *ppHead; ppHead = &(p->pnextElem))
    {
        if (p == pElem)
        {
            // Found the guy
            *ppHead = p->pnextElem;
            return (p);
        }
    }
    return (NULL);
}

#endif //ifdef CSC_RECORDMANAGER_WINNT


#ifndef CSC_RECORDMANAGER_WINNT
VOID
GetSystemTime(
    _FILETIME *lpft
)
{
    LONG ltime = IFSMgr_Get_NetTime();

    *lpft = IFSMgr_NetToWin32Time(ltime);

}
#endif

ULONG
GetTimeInSecondsSince1970(
    VOID
    )
{
    return ((ULONG)IFSMgr_Get_NetTime());
}

BOOL
IterateOnUNCPathElements(
    USHORT  *lpuPath,
    PATHPROC lpfn,
    LPVOID  lpCookie
    )
/*++

Routine Description:

    This routine takes a unicode UNC path and iterates over each path element, calling the
    callback function. Thus for a path \\server\share\dir1\dir2\file1.txt, the function makes
    the following calls to the lpfn callback function

    (lpfn)(\\server\share, \\server\share, lpCookie)
    (lpfn)(\\server\share\dir1, dir1, lpCookie)
    (lpfn)(\\server\share\dir1\dir2, dir2, lpCookie)
    (lpfn)(\\server\share\dir1\dir2\file1, file1, lpCookie)

Arguments:

    lpuPath     NULL terminated unicode string (NOT NT style, just a plain unicode string)

    lpfn        callback function. If the function returns TRUE on a callback, the iteration
                proceeds, else it terminates

    lpCookie    context passed back on each callback

Returns:

    return TRUE if the entire iteration went through, FALSE if some error occurred or the callback
    function terminated the iteration

Notes:


--*/
{
    int cnt, cntSlashes=0, cbSize;
    USHORT  *lpuT, *lpuLastElement = NULL, *lpuCopy = NULL;
    BOOL    fRet = FALSE;

//    DEBUG_PRINT(("InterateOnUNCPathElements:Path on entry =%ws\r\n", lpuPath));

    if (!lpuPath || ((cnt = wstrlen(lpuPath)) <= 3))
    {
        return FALSE;
    }

    // check for the first two backslashes
    if (!(*lpuPath == (USHORT)'\\') && (*(lpuPath+1) == (USHORT)'\\'))
    {
        return FALSE;
    }

    // ensure that the server field is not NULL
    if (*(lpuPath+2) == (USHORT)'\\')
    {
        return FALSE;
    }

    cbSize = (wstrlen(lpuPath)+1) * sizeof(USHORT);

    lpuCopy = (USHORT *)AllocMem(cbSize);

    if (!lpuCopy)
    {
        return FALSE;
    }

    memcpy(lpuCopy, lpuPath, cbSize);

    cntSlashes = 2;

    lpuLastElement = lpuCopy;

    for (lpuT= lpuCopy+2;; ++lpuT)
    {
        if (*lpuT == (USHORT)'\\')
        {
            BOOL fContinue;

            ++cntSlashes;

            if (cntSlashes == 3)
            {
                if (lpuT == (lpuCopy+2))
                {
                    goto bailout;
                }

                continue;
            }

            *lpuT = 0;

            fContinue = (lpfn)(lpuCopy, lpuLastElement, lpCookie);

            *lpuT = (USHORT)'\\';

            if (!fContinue)
            {
                goto bailout;
            }

            lpuLastElement = (lpuT+1);
        }
        else if (!*lpuT)
        {
            (lpfn)(lpuCopy, lpuLastElement, lpCookie);
            break;
        }
    }

    fRet = TRUE;
bailout:

    if (lpuCopy)
    {
        FreeMem(lpuCopy);
    }
    return (fRet);
}

BOOL
IsPathUNC(
    USHORT      *lpuPath,
    int         cntMaxChars
    )
{
    USHORT *lpuT;
    int i, cntSlash=0;
    BOOL    fRet = FALSE;

    for(lpuT = lpuPath, i=0; (i < cntMaxChars) && *lpuT; lpuT++, ++i)
    {
        if (cntSlash <= 1)
        {
            // look for the first two backslashes
            if (*lpuT != (USHORT)'\\')
            {
                break;
            }

            ++cntSlash;
        }
        else if (cntSlash == 2)
        {
            // look for the 3rd one
            if (*lpuT == (USHORT)'\\')
            {
                if (((DWORD_PTR)lpuT - (DWORD_PTR)lpuPath) < 3)
                {
                    // NULL server field
                    break;
                }
                else
                {
                    ++cntSlash;
                }
            }
        }
        else    // all three slashes accounted for
        {
            Assert(cntSlash == 3);

            // if a non-slash character, then this path is OK
            fRet = (*lpuT != (USHORT)'\\');
            break;
        }
    }
    return (fRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\record.mgr\shadow.asm ===
PAGE 58,132
;******************************************************************************
TITLE SHADOW.ASM - Windows/386 NETBIOS SHADOW FOR REMOTE NETWORK ACCESS
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1987-1993
;
;   Title: SHADOW.ASM -
;
;
;
;   Version:
;
;   Date:
;
;   Author:
;
;------------------------------------------------------------------------------

        .386p

.XLIST

WIN40COMPAT     equ     1

        include vmm.inc
        include shell.inc
        include debug.inc
        include ifsmgr.inc
        include dosmgr.inc
        include vxdldr.inc
        include vwin32.inc
        include winnetwk.inc
	include netvxd.inc
	include vrdsvc.inc
.LIST

        extern  _ProcessRegisterNet:near
        extern  _ProcessNetFunction:near
IFDEF HOOKMOUNT
        extern  _ProcessRegisterMount:near
ENDIF
        extern  _FS_ConnectResourceShadow:near
        extern  _IoctlRegisterAgent:near
        extern  _IoctlUnRegisterAgent:near
        extern  _IoctlGetUNCPath:near
        extern  _IoctlBeginPQEnum:near
        extern  _IoctlEndPQEnum:near
        extern  _IoctlNextPriShadow:near
        extern  _IoctlPrevPriShadow:near
        extern  _IoctlGetShadowInfo:near
        extern  _IoctlSetShadowInfo:near
        extern  _IoctlCopyChunk:near
        extern  _IoctlChkUpdtStatus:near
        extern  _IoctlDoShadowMaintenance:near
        extern  _IoctlBeginReint:near
        extern  _IoctlEndReint:near
        extern  _IoctlCreateShadow:near
        extern  _IoctlDeleteShadow:near
        extern  _IoctlSetServerStatus:near
        extern  _IoctlGetServerStatus:near
        extern  _IoctlAddUse:near
        extern  _IoctlDelUse:near
        extern  _IoctlGetUse:near
        extern  _ActOnCreateVM:near
        extern  _ActOnResumeVM:near
        extern  _ActOnSetDeviceFocus:near
        extern  _TerminateHook:near
        extern  _IoctlSwitches:near
        extern  _IoctlGetShadow:near
        extern  _IoctlGetGlobalStatus:near
        extern  _IoctlFindOpenHSHADOW:near
        extern  _IoctlFindNextHSHADOW:near
        extern  _IoctlFindCloseHSHADOW:near
        extern  _IoctlGetPriorityHSHADOW:near
        extern  _IoctlSetPriorityHSHADOW:near
        extern  _IoctlAddHint:near
        extern  _IoctlDeleteHint:near
        extern  _IoctlFindOpenHint:near
        extern  _IoctlFindNextHint:near
        extern  _IoctlFindCloseHint:near
        extern  _IoctlGetAliasHSHADOW:near
        extern  _FS_FakeNetConnect:near
	extern	_ActOnTerminateThread:near

IFDEF DEBUG
        extern  _ShadowRestrictedEventCallback:near
	extern  _DebugQueryCmdStr:byte
	extern  _DebugQueryCmdStrLen:dword
        extern  _SHDDebug:near
ENDIF

Declare_Virtual_Device SHADOW, 3, 0Ah, Shadow_Control, CSC_Device_ID, IFSMgr_Init_Order+1,,Shadow_PM_Api_Handler

SHADOW_VERSION                  EQU 8287h
API_SUCCESS                     EQU 1
API_FAILURE                     EQU 0
Time_Out_Period                 EQU 1100
MAX_LANS                        EQU 16
Shadow_IOCTL_BASE               EQU 1001
Shadow_IOCTL_GENERROR           EQU 1
TRUE                            EQU 1
FALSE                           EQU 0

;SHADOW_OEM_ID                   EQU     00220000h



IFDEF   DEBUG
SHADOW_LOG_TIME_INTERVAL        EQU 60000
SHADOW_STATS_FLUSH_COUNT        EQU 10
ENDIF

VxD_DATA_SEG

IFDEF DEBUG
_NbDebug        dd 0
ENDIF
                public  OrigRegisterNetFunc
                public  _OrigNetFunction
                public  _fLog
                public  _fShadow
                public  _fShadowFind
                public  _fDiscon
                public  _fNoShadow
                public  _OrigSetupFailedConnection
                public  _proidShadow
                public  _FCBToShort
                public  _ShortToFCB
		public	_DebugMenu
		public	_GetConfigDir
                public  _Get_Sys_VM_Handle
                public  _Get_Cur_VM_Handle
		public	_Call_VM_Event
		public	_SetWin32Event
		public	_CloseVxDHandle
		public	_VRedirCSCInfoFunction
		public	_MyCheckAccessConflict


OrigRegisterNetFunc             dd      -1
_OrigNetFunction                dd      0
OrigHookDeviceService           dd      0
NextNetFunction                 dd      0
_OrigSetupFailedConnection      dd      0
_proidShadow                    dd      0
_VRedirCSCInfoFunction		dd	0

IFDEF HOOKMOUNT
                public  OrigRegisterMountFunc

OrigRegisterMountFunc     dd      -1
ENDIF

ALIGN 4
indos_ptr       dd 0

IFDEF DEBUG
Alloc_watch     dd 0
Alloc_table     dd 512 DUP (0)
Alloc_sizes     dd 512 DUP (0)
Alloc_cnt       dd 0
ENDIF

ALIGN 4
Shadow_PM_API_Table LABEL DWORD

        dd    offset32 Shadow_PM_API_Get_Version

Shadow_PM_API_Max          EQU ($-Shadow_PM_API_Table)/4

Shadow_IOCTL_Table LABEL DWORD

        dd    offset32 Shadow_PM_API_Register_Agent
        dd    offset32 Shadow_PM_API_UnRegister_Agent
        dd    offset32 Shadow_PM_API_GetUNCPath
        dd    offset32 Shadow_PM_API_BeginPQEnum
        dd    offset32 Shadow_PM_API_EndPQEnum
        dd    offset32 Shadow_PM_API_NextPriShadow
        dd    offset32 Shadow_PM_API_PrevPriShadow
        dd    offset32 Shadow_PM_API_GetShadowInfo
        dd    offset32 Shadow_PM_API_SetShadowInfo
        dd    offset32 Shadow_PM_API_ChkUpdtStatus
        dd    offset32 Shadow_PM_API_DoShadowMaintenance
        dd    offset32 Shadow_PM_API_CopyChunk
        dd    offset32 Shadow_PM_API_BeginReint
        dd    offset32 Shadow_PM_API_EndReint
        dd    offset32 Shadow_PM_API_CreateShadow
        dd    offset32 Shadow_PM_API_DeleteShadow
        dd    offset32 Shadow_PM_API_GetServerStatus
        dd    offset32 Shadow_PM_API_SetServerStatus
        dd    offset32 Shadow_PM_API_AddUse
        dd    offset32 Shadow_PM_API_DelUse
        dd    offset32 Shadow_PM_API_GetUse
        dd    offset32 Shadow_PM_API_Switches
        dd    offset32 Shadow_PM_API_GetShadow
        dd    offset32 Shadow_PM_API_GetGlobalStatus
        dd    offset32 Shadow_PM_API_FindOpenHSHADOW
        dd    offset32 Shadow_PM_API_FindNextHSHADOW
        dd    offset32 Shadow_PM_API_FindCloseHSHADOW
        dd    offset32 Shadow_PM_API_GetPriorityHSHADOW
        dd    offset32 Shadow_PM_API_SetPriorityHSHADOW
        dd    offset32 Shadow_PM_API_AddHint
        dd    offset32 Shadow_PM_API_DeleteHint
        dd    offset32 Shadow_PM_API_FindOpenHint
        dd    offset32 Shadow_PM_API_FindNextHint
        dd    offset32 Shadow_PM_API_FindCloseHint
        dd    offset32 Shadow_PM_API_GetAliasHSHADOW
Shadow_IOCTL_MAX          EQU ($-Shadow_IOCTL_Table)/4

IFDEF DEBUG

Debug_Menu LABEL DWORD
        dd  OFFSET32 MinDbg_Str,     OFFSET32 MinDbg_Debug
        dd  OFFSET32 DefaultDbg_Str, OFFSET32 DefaultDbg_Debug
        dd  OFFSET32 MaxDbg_Str,     OFFSET32 MaxDbg_Debug
        dd  OFFSET32 Alloc_Str,      OFFSET32 Alloc_Debug
        dd  OFFSET32 Heap_Str,       OFFSET32 AllocDisplay_Debug

Debug_Menu_Len equ ($ - Debug_Menu)/8
        dd  0

MinDbg_Str          db "Minimal debug output", 0
DefaultDbg_Str      db "Default debug output", 0
MaxDbg_Str          db "Maximum debug output", 0
Alloc_Str           db "Monitor memory allocations", 0
Heap_Str            db "Display current memory allocations", 0
Shadow_Str          db "Shadow",0
ENDIF ; DEBUG

_fLog               dd  0
_fShadow            dd  0
_fDiscon            dd  0
_fNoShadow          dd  0
_cntTicks           dd  0
_fShadowFind        dd  0

sz386Enh            db "386enh",0
_vszShadowOverride      db "NoShadow",0

extern _ulMaxStoreSize:DWORD

VxD_DATA_ENDS

VxD_LOCKED_DATA_SEG

VxD_LOCKED_DATA_ENDS

VxD_CODE_SEG

;******************************************************************************
;
; @doc      INTERNAL      SHADOW
;
; @api      LocalAlloc | Allocates page-locked memory.
;
; @parm     flags | ignored
;
; @parm     bytesneeded | number of bytes of memory required
;
; @rdesc    Returns address of memory if allocation succeeds
;           or zero if allocation failed.
;
;******************************************************************************

LocalAlloc proc near c public, flags:dword, bytesneeded:dword

        mov     eax, bytesneeded

        push    eax
        VxDcall IFSMgr_GetHeap
        pop     ecx                     ; Clear stack
        test    eax, eax
        jz short AH50

AH20:

IFDEF DEBUG
        jmp     AH_Debug
ENDIF
        cld
        ret

; Heap allocation failed.  Try to fill the spare if inDos not set.

AH50:

        mov     ecx, indos_ptr
        cmp     word ptr [ecx], 0
        jne     short AH20

        VxDcall IFSMgr_FillHeapSpare

        push    bytesneeded
        VxDcall IFSMgr_GetHeap
        pop     ecx                     ; Clear stack

IFDEF DEBUG
        jmp     AH_Debug
ENDIF
        cld
        ret


IFDEF DEBUG

AH_Debug:

        cld
        pushad
        test    eax, eax
        jnz     AH_GotMem
        Debug_Out "Shadow: LocalAlloc Failed"
        jmp     AH_Done

AH_GotMem:

        mov     edx, Alloc_watch
        or      edx, edx
        jz      AH_NoTrace
        mov     edx, bytesneeded
;        Trace_Out "Shadow: LocalAlloc #EDX bytes at #EAX"

AH_NoTrace:

        mov     edi, OFFSET32 Alloc_table
        mov     ecx, Alloc_cnt
        mov     [edi + ecx *4], eax
        mov     edi, OFFSET32 Alloc_sizes
        mov     edx, bytesneeded
        mov     [edi + ecx *4], edx
        inc     Alloc_cnt

AH_Done:
        popad
        ret

ENDIF


LocalAlloc endp

;******************************************************************************
;
; @doc      INTERNAL      SHADOW
;
; @api      LocalFree | Frees a previously allocated block of page-locked memory.
;
; @parm     memhandle | address of the block to be freed
;
; @rdesc    Returns zero.
;
;******************************************************************************

LocalFree proc near c public, memhandle:dword
        mov     eax, memhandle

IFDEF DEBUG

        pushad

IFDEF DEBUG
        mov     ecx, eax
        call    _ShadowCheckHeap
ENDIF

        mov     edi, OFFSET32 Alloc_table
        mov     ecx, Alloc_cnt
        cld
        repne   scasd
        jz      FH_Found
        Debug_Out "Shadow: LocalFree invalid handle"
        jmp     FH_Done

FH_Found:

        sub     edi, 4
        xor     ecx, ecx
        mov     [edi], ecx
        mov     esi, OFFSET32 Alloc_table
        mov     edx, Alloc_cnt
        dec     edx
        mov     ebx, [esi + edx * 4]
        mov     [edi], ebx
        mov     esi, OFFSET32 Alloc_sizes
        mov     ebx, [esi + edx * 4]
        sub     edi, OFFSET32 Alloc_table
        add     edi, OFFSET32 Alloc_sizes
        mov     [edi], ebx
        mov     Alloc_cnt, edx
        mov     edx, Alloc_watch
        or      edx, edx
        jz      FH_Done
;        Trace_Out "Shadow: LocalFree #EAX"

FH_Done:

        popad
ENDIF

        push    eax
        VxDcall IFSMgr_RetHeap
        pop     eax             ; Clear stack, smallest way
        cld
        xor     eax, eax
        ret
LocalFree endp


;******************************************************************************
;
; @doc      INTERNAL      SHADOW
;
; @asm      Shadow_Device_Init | This function is called when the
;           shadow is dynamically loaded.
;
; @reg      EBX | System VM Handle
;
; @reg      EBP | pointer to client regs structure
;
; @rdesc    Register values at return:
;
; @reg      FLAGS | Flags defined at return:
;
; @flag     NC | Succeeded in initializing VxD
;
; @flag     CY | Failed to initializing VxD
;
; @uses     FLAGS
;
; @xref     Shadow_Control
;
;******************************************************************************

BeginProc Shadow_Device_Init, PUBLIC
;        int     1
        xor     eax,eax
        mov     esi, OFFSET32 sz386Enh
        mov     edi, OFFSET32 _vszShadowOverride
        VMMCall Get_Profile_Decimal_Int
        jc      yes_shadow_enable
        jz      yes_shadow_enable
        Trace_Out       "Shadow: Override set"
        mov     _fNoShadow, 1
        stc
        ret

yes_shadow_enable:

	mov	esi, OFFSET32 ShadowNetFunction
	mov	eax, @@IFSMgr_NetFunction
	VMMcall	Hook_Device_Service
        jc      DevInitError
        Trace_Out       "Shadow: Hooked IFSMgr_NetFunction"
	mov	_OrigNetFunction, esi
        clc

	mov	esi, OFFSET32 ShadowHookDeviceService
	mov	eax, @@Hook_Device_Service
	VMMcall	Hook_Device_Service
        jc      DevInitError
        Trace_Out       "Shadow: Hooked Hook_Device_Service"
	mov	OrigHookDeviceService, esi
        clc

Register_Net_Func:
	mov	esi, OFFSET32 ShadowRegisterNetFunc
	mov	eax, @@IFSMgr_RegisterNet
	VMMcall	Hook_Device_Service
        jc      DevInitError
        Trace_Out       "Shadow: Hooked RegisterNet service"
	mov	OrigRegisterNetFunc, esi
        clc

        VxDCall IFSMgr_RegisterNet, <_FS_FakeNetConnect, IFSMGRVERSION, WNNC_NET_COGENT>
        cmp     eax, -1
        jz      DevInitError
        mov     _proidShadow, eax

IFDEF HOOKMOUNT
	mov	esi, OFFSET32 ShadowMountFunction
	mov	eax, @@IFSMgr_RegisterMount
	VMMcall	Hook_Device_Service
        jc      DevInitError
        Trace_Out       "Shadow: Hooked RegisterMount service"
	mov	OrigRegisterMountFunc, esi
        clc
ENDIF
IFDEF DEBUG
        mov     eax, SHADOW_LOG_TIME_INTERVAL
        mov     edx, 0
        mov     esi, OFFSET32 Shadow_Timer_Callback
        VMMCall Set_Global_Time_Out
        mov     eax,esi
        cmp     eax,0
        jne     TimerSet
        Trace_Out       "Shadow: Couldn't set the logging timer"
TimerSet:
ENDIF
	mov	esi, OFFSET32 _FS_ConnectResourceShadow
	mov	eax, @@IFSMgr_SetupFailedConnection
	VMMcall	Hook_Device_Service
        jc      SFC_Error
        Trace_Out       "Shadow: Hooked SetupFailedConnection"
	mov	_OrigSetupFailedConnection, esi
SFC_Error:
        clc
        ret
DevInitError:
        Trace_Out       "Shadow: Error Hooking services"
        mov     _fshadow, 0
        ret

EndProc Shadow_Device_Init


;******************************************************************************
;
; @doc      INTERNAL      SHADOW
;
; @asm      Shadow_Device_Exit | This function is called when the
;           VxD is dynamically unloaded.
;
; @reg      EBX | System VM Handle
;
; @reg      EBP | pointer to client regs structure
;
; @rdesc    Register values at return:
;
; @reg      FLAGS | Flags defined at return:
;
; @flag     NC | Success
;
; @flag     CY | Failure
;
; @uses     FLAGS
;
; @xref     Shadow_Control
;
;
;******************************************************************************

BeginProc Shadow_Device_Exit

        clc
        ret

EndProc Shadow_Device_Exit

;******************************************************************************
;
; @doc      INTERNAL      SHADOW
;
; @asm      Shadow_Sys_VM_Terminate | This function is called when the
;           VxD is dynamically unloaded.
;
; @reg      EBX | System VM Handle
;
; @reg      EBP | pointer to client regs structure
;
; @rdesc    Register values at return:
;
; @reg      FLAGS | Flags defined at return:
;
; @flag     NC | Success
;
; @flag     CY | Failure
;
; @uses     FLAGS
;
; @xref     Shadow_Control
;
;
;******************************************************************************

BeginProc Shadow_Sys_VM_Terminate

        call _TerminateHook
        clc
        ret

EndProc Shadow_Sys_VM_Terminate

;******************************************************************************
;
; @doc      INTERNAL      SHADOW
;
; @asm      Shadow_Control | This function dispatches VxD control messages
;
; @reg      EBX | System VM Handle
;
; @reg      EBP | pointer to client regs structure
;
; @rdesc    Register values at return:
;
; @reg      FLAGS | Flags defined at return:
;
; @flag     NC | Success
;
; @flag     CY | Failure
;
; @uses     FLAGS
;
;******************************************************************************

BeginProc Shadow_Control

        Control_Dispatch Device_Init,           Shadow_Device_Init
        Control_Dispatch System_Exit,           Shadow_Device_Exit
        Control_Dispatch Sys_VM_Terminate,      Shadow_Sys_VM_Terminate
        Control_Dispatch W32_DEVICEIOCONTROL,   Shadow_DeviceIOControl
        Control_Dispatch Create_VM,             Shadow_Create_VM
        Control_Dispatch VM_Resume,             Shadow_Resume_VM
        Control_Dispatch Set_Device_Focus,      Shadow_Set_Device_Focus
	Control_Dispatch terminate_thread,	Shadow_Terminate_Thread

IFDEF DEBUG

        Control_Dispatch Debug_Query, SHDDumpDebug

ENDIF


        clc
        ret

EndProc Shadow_Control


;******************************************************************************
;
; @doc      INTERNAL      SHADOW
;
; @asm      Shadow_DeviceIOControl | This is the single entry point for WIN32
;           Device IOCTL calls.
;
; @reg      EAX | W32_DEVICEIOCONTROL
;
; @reg      EBX | DDB
;
; @reg      ECX | dwIoControlCode
;
; @reg      ESI | Pointer to DIOCParams structure.
;
; @rdesc    Return code in EAX as follows
;
; @flag     0 | Success
;
; @flag     -1 | Asynchronous I/O in progress
;
; @falg     Other | Error code.
;
; @uses     ALL
;
;******************************************************************************

BeginProc Shadow_DeviceIOControl

        push    ebx
        push    esi
        push    edi
        cmp     ecx, DIOC_GETVERSION                    ; Q: Version IOCTL? (must be supported)
        jne     DIOC_10                                 ;   N: Continue
                                                        ;   Y: Information returned from GetVersion TBD
        xor     eax, eax                                ;      Return w/ EAX = 0 (success)
        jmp     DIOC_Done

DIOC_10:
;        cmp     ecx, DIOC_CLOSEHANDLE                   ; Q: Close IOCTL? (must be supported)
;        jne     DIOC_20                                 ;    N: Continue
;        xor     eax, eax                                ;    Y: Return w/ EAX = 0 (success)
;        jmp     DIOC_Done

DIOC_20:
        shr     ecx, 2                                	; as per winioctl.h
	and	ecx, 7ffh				; as per winioctl.h
        sub     ecx, Shadow_IOCTL_BASE
        cmp     ecx, Shadow_IOCTL_MAX                  	; Q: index in range?
        jae     SHORT DIOC_Error                        ;  N: Return error
        mov     edi, [esi.lpvInBuffer]                  ;  Y: Call appropriate API
        call    Shadow_IOCTL_Table[ecx*4]
        cmp     eax, 0
        jl      DIOC_Error
        xor     eax, eax                                ;      Return w/ EAX = 0 (success)


        ; fall-through

DIOC_Done:
        clc
        pop     edi
        pop     esi
        pop     ebx
        ret

DIOC_Error:
        mov     eax, Shadow_IOCTL_GENERROR
        jmp     DIOC_Done

EndProc Shadow_DeviceIOControl

;******************************************************************************
;
; @doc      INTERNAL      SHADOW
;
; @asm      Shadow_Create_VM | This function is called when a virtual
;            machine is created
;
; @reg      EBX | System VM Handle
;
; @reg      EBP | pointer to client regs structure
;
; @rdesc    Register values at return:
;
; @reg      FLAGS | Flags defined at return:
;
; @flag     NC | Succeeded in initializing VxD
;
; @flag     CY | Failed to initializing VxD
;
; @uses     FLAGS
;
; @xref     Shadow_Control
;
;******************************************************************************

BeginProc Shadow_Create_VM, PUBLIC
        call    _ActOnCreateVM
        clc
        ret

EndProc Shadow_Create_VM

;******************************************************************************
;
; @doc      INTERNAL      SHADOW
;
; @asm      Shadow_Resume_VM | This function is called when a virtual
;            machine is created
;
; @reg      EBX | System VM Handle
;
; @reg      EBP | pointer to client regs structure
;
; @rdesc    Register values at return:
;
; @reg      FLAGS | Flags defined at return:
;
; @flag     NC | Succeeded in initializing VxD
;
; @flag     CY | Failed to initializing VxD
;
; @uses     FLAGS
;
; @xref     Shadow_Control
;
;******************************************************************************

BeginProc Shadow_Resume_VM, PUBLIC
        call    _ActOnResumeVM
        clc
        ret

EndProc Shadow_Resume_VM

;******************************************************************************
;
; @doc      INTERNAL      SHADOW
;
; @asm      Shadow_Set_Device_Focus | This function is called when our VXD
;            gets Set_Device_Focus message
;
; @reg      EBX | System VM Handle
;
; @reg      EBP | pointer to client regs structure
;
; @rdesc    Register values at return:
;
; @reg      FLAGS | Flags defined at return:
;
; @flag     NC | Succeeded in initializing VxD
;
; @flag     CY | Failed to initializing VxD
;
; @uses     FLAGS
;
; @xref     Shadow_Control
;
;******************************************************************************

BeginProc Shadow_Set_Device_Focus, PUBLIC
        call    _ActOnSetDeviceFocus
        clc
        ret

EndProc Shadow_Set_Device_Focus

;******************************************************************************
;
; @doc      INTERNAL      SHADOW
;
; @asm      Shadow_Terminate_Thread | This function is called when our VXD
;            gets Terminate_Thread message
;
; @reg      EBX | System VM Handle
;
; @reg      EBP | pointer to client regs structure
;
; @rdesc    Register values at return:
;
; @reg      FLAGS | Flags defined at return:
;
; @flag     NC | Succeeded in initializing VxD
;
; @flag     CY | Failed to initializing VxD
;
; @uses     FLAGS
;
; @xref     Shadow_Control
;
;******************************************************************************

BeginProc Shadow_Terminate_Thread, PUBLIC
	push	edi
        call    _ActOnTerminateThread
	pop	edi
        clc
        ret

EndProc Shadow_Terminate_Thread

;******************************************************************************
;
; @doc      INTERNAL      SHADOW
;
; @asm      Shadow_PM_API_Handler | This is the single entry point for VMs
;           executing in protect-mode.
;
; @reg      EBX | Current VM Handle
;
; @reg      EBP | Pointer to Client Register Structure.
;
; @reg      CLIENT_AX | Shadow PM API Index.
;
; @reg      CLIENT_ES:CLIENT_(E)BX | API specific parameters or NULL
;
; @rdesc    Refer to specific APIs for client register values at return.
;           A return value of 0 indicates that the API succeeded, otherwise
;           an error value is returned. The version call is an exception
;
; @uses     FLAGS
;
;******************************************************************************

BeginProc Shadow_PM_API_Handler

        movzx   eax, [ebp.Client_AX]                ; Get API index

        cmp     eax, Shadow_PM_API_MAX             ; Q: index in range?
        jae     SHORT Shadow_Handler_Error         ;  N: Fail call.

        mov     [ebp.Client_AX], 1
        mov     cx,[ebp.Client_ES]                  ; Q: Null Parameters?
        or      cx,[ebp.Client_ES]                  ;  Y: Don't call map_flat
        jz      SHORT Shadow_Handler_Null_Parms

        Client_Ptr_Flat edi, es, bx                 ;  N: EDI -> parameter struc.

Shadow_Handler_Null_Parms:

        call    Shadow_PM_API_Table[eax*4]         ; Call appropriate API
        mov     [ebp.Client_AX], ax
        ret

Shadow_Handler_Error:

        mov     [ebp.Client_AX], API_FAILURE
        ret

EndProc Shadow_PM_API_Handler

;******************************************************************************
;
; @doc      INTERNAL      SHADOW    API
;
; @asm      Shadow_PM_API_Get_Version | This function returns the version
;           number of the device,
;
; @reg      EBX | Current VM Handle
;
; @reg      EBP | Pointer to Client Register Structure.
;
; @reg      CLIENT_AX | VTD API Index.
;
; @rdesc    AX contains version number
;
; @uses     FLAGS
;
; @xref     Shadow_PM_API_Handler
;
;******************************************************************************

BeginProc Shadow_PM_API_Get_Version

        mov     eax, SHADOW_VERSION
        ret

EndProc Shadow_PM_API_Get_Version



;******************************************************************************
;
; @doc      INTERNAL      SHADOW    API
;
; @asm      SHADOW_PM_API_Register_Agent | This function allows the
;           reintegartion agent to register itself
;
; @reg      EBX | Current VM Handle
;
; @reg      EBP | Pointer to Client Register Structure.
;
; @reg      EDI | Contains the window handle
;
; @rdesc    eax contains zero if API failed, else non-zero.
;
; @uses     FLAGS
;
; @xref     SHADOW_PM_API_Handler
;
;******************************************************************************
BeginProc Shadow_PM_API_Register_Agent
        push    edi
        call    _IoctlRegisterAgent
        pop     edi
        ret
EndProc Shadow_PM_API_Register_Agent

;******************************************************************************
;
; @doc      INTERNAL      SHADOW    API
;
; @asm      SHADOW_PM_API_UnRegister_Agent | This function allows the
;           reintegartion agent to unregister itself
;
; @reg      EBX | Current VM Handle
;
; @reg      EBP | Dont' Care
;
; @reg      EDI | Contains the window handle
;
; @rdesc    eax contains zero if API failed, else non-zero.
;
; @uses     FLAGS
;
; @xref     SHADOW_PM_API_Handler
;
;******************************************************************************
BeginProc Shadow_PM_API_UnRegister_Agent
        push    edi
        call    _IoctlUnRegisterAgent
        pop     edi
        ret
EndProc Shadow_PM_API_UnRegister_Agent

;******************************************************************************
;
; @doc      INTERNAL      SHADOW    API
;
; @asm      SHADOW_PM_API_Get_Copyback_Params | This function is called
;           by the Reintegration Agent. It returns the
;           name of the shadow file that has been modified and
;           the remote file that needs to be updated
;
; @reg      EBX | Current VM Handle
;
; @reg      EBP | Pointer to Client Register Structure.
;
; @reg      EDI | A pointer to a PATHS structure :
;               typedef struct tagPATHS
;                  {
;                  unsigned uCookie;  // Indicates the reintegartion ID
;                  LPVOID lpSrc;      // Name of local file
;                  int    cbSrc;      // Buffer size
;                  LPVOD  lpDst;      // Name of remote file
;                  int    cbDst;      // Buffer size
;                  }
;               PATHS;
;
; @rdesc    eax contains zero if API failed, else non-zero.
;
; @uses     FLAGS
;
; @xref     SHADOW_PM_API_Handler
;
;******************************************************************************
BeginProc Shadow_PM_API_GetUNCPath
        push    edi
        call    _IoctlGetUNCPath
        pop     edi
        ret
EndProc Shadow_PM_API_GetUNCPath


;******************************************************************************
;
; @doc      INTERNAL      SHADOW    API
;
; @asm      SHADOW_PM_API_Begin_PQ_Enum | This function is called
;           by the Reintegration Agent. It returns the
;           name of the shadow file that has been modified and
;           the remote file that needs to be updated
;
; @reg      EBX | Current VM Handle
;
; @reg      EBP | Pointer to Client Register Structure.
;
; @reg      EDI | A pointer to a unsigned long
;
; @rdesc    eax contains zero if API failed, else non-zero.
;
; @uses     FLAGS
;
; @xref     SHADOW_PM_API_Handler
;
;******************************************************************************
BeginProc Shadow_PM_API_BeginPQEnum
        push    edi
        call    _IoctlBeginPQEnum
        pop     edi
        ret
EndProc Shadow_PM_API_BeginPQEnum

;******************************************************************************
;
; @doc      INTERNAL      SHADOW    API
;
; @asm      SHADOW_PM_API_End_PQ_Enum | This function is called
;           by the Reintegration Agent. It returns the
;           name of the shadow file that has been modified and
;           the remote file that needs to be updated
;
; @reg      EBX | Current VM Handle
;
; @reg      EBP | Pointer to Client Register Structure.
;
; @reg      EDI | A pointer to a unsigned long
;
; @rdesc    eax contains zero if API failed, else non-zero.
;
; @uses     FLAGS
;
; @xref     SHADOW_PM_API_Handler
;
;******************************************************************************
BeginProc Shadow_PM_API_EndPQEnum
        push    edi
        call    _IoctlEndPQEnum
        pop     edi
        ret
EndProc Shadow_PM_API_EndPQEnum

;******************************************************************************
;
; @doc      INTERNAL      SHADOW    API
;
; @asm      SHADOW_PM_API_Next_Pri_Shadow | This function is called
;           by the Reintegration Agent. It returns the
;           name of the shadow file that has been modified and
;           the remote file that needs to be updated
;
; @reg      EBX | Current VM Handle
;
; @reg      EBP | Pointer to Client Register Structure.
;
; @reg      EDI | A pointer to a unsigned long
;
; @rdesc    eax contains zero if API failed, else non-zero.
;
; @uses     FLAGS
;
; @xref     SHADOW_PM_API_Handler
;
;******************************************************************************
BeginProc Shadow_PM_API_NextPriShadow
        push    edi
        call    _IoctlNextPriShadow
        pop     edi
        ret
EndProc Shadow_PM_API_NextPriShadow

;******************************************************************************
;
; @doc      INTERNAL      SHADOW    API
;
; @asm      SHADOW_PM_API_Prev_Pri_Shadow | This function is called
;           by the Reintegration Agent. It returns the
;           name of the shadow file that has been modified and
;           the remote file that needs to be updated
;
; @reg      EBX | Current VM Handle
;
; @reg      EBP | Pointer to Client Register Structure.
;
; @reg      EDI | A pointer to a unsigned long
;
; @rdesc    eax contains zero if API failed, else non-zero.
;
; @uses     FLAGS
;
; @xref     SHADOW_PM_API_Handler
;
;******************************************************************************
BeginProc Shadow_PM_API_PrevPriShadow
        push    edi
        call    _IoctlPrevPriShadow
        pop     edi
        ret
EndProc Shadow_PM_API_PrevPriShadow

;******************************************************************************
;
; @doc      INTERNAL      SHADOW    API
;
; @asm      SHADOW_PM_API_Get_Shadow_Info | This function is called
;           by the Reintegration Agent. It returns the
;           name of the shadow file that has been modified and
;           the remote file that needs to be updated
;
; @reg      EBX | Current VM Handle
;
; @reg      EBP | Pointer to Client Register Structure.
;
; @reg      EDI | A pointer to SHADOWINFO structure
;                {
;                HSHADOW         hShadow;
;                HSHADOW         hDir;
;                HSERVER         hServer;
;                LPFIND32        lpFind32;
;                unsigned        short usStatus;
;                }
;
; @rdesc    eax contains zero if API failed, else non-zero.
;
; @uses     FLAGS
;
; @xref     SHADOW_PM_API_Handler
;
;******************************************************************************
BeginProc Shadow_PM_API_GetShadowInfo
        push    edi
        call    _IoctlGetShadowInfo
        pop     edi
        ret
EndProc Shadow_PM_API_GetShadowInfo

;******************************************************************************
;
; @doc      INTERNAL      SHADOW    API
;
; @asm      SHADOW_PM_API_Set_Shadow_Info | This function is called
;           by the Reintegration Agent. It returns the
;           name of the shadow file that has been modified and
;           the remote file that needs to be updated
;
; @reg      EBX | Current VM Handle
;
; @reg      EBP | Pointer to Client Register Structure.
;
; @reg      EDI | A pointer to SHADOWINFO structure
;                {
;                HSHADOW         hShadow;
;                HSHADOW         hDir;
;                HSERVER         hServer;
;                LPFIND32        lpFind32;
;                unsigned        short usStatus;
;                }
;
; @rdesc    eax contains zero if API failed, else non-zero.
;
; @uses     FLAGS
;
; @xref     SHADOW_PM_API_Handler
;
;******************************************************************************
BeginProc Shadow_PM_API_SetShadowInfo
        push    edi
        call    _IoctlSetShadowInfo
        pop     edi
        ret
EndProc Shadow_PM_API_SetShadowInfo



;******************************************************************************
;
; @doc      INTERNAL      SHADOW    API
;
; @asm      SHADOW_PM_API_ChkUpdtStatus | This function is called
;           by the Reintegration Agent.
;
; @reg      EBX | Current VM Handle
;
; @reg      EBP | Pointer to Client Register Structure.
;
; @rdesc    eax contains zero if API failed, else non-zero.
;
; @uses     FLAGS
;
; @xref     SHADOW_PM_API_Handler
;
;******************************************************************************
BeginProc Shadow_PM_API_ChkUpdtStatus
        push    edi
        call    _IoctlChkUpdtStatus
        pop     edi
        ret
EndProc Shadow_PM_API_ChkUpdtStatus

;******************************************************************************
;
; @doc      INTERNAL      SHADOW    API
;
; @asm      SHADOW_PM_API_DoShadowMaintenance | This function is called
;           by the Reintegration Agent.
;
; @reg      EBX | Current VM Handle
;
; @reg      EBP | Pointer to Client Register Structure.
;
; @rdesc    eax contains zero if API failed, else non-zero.
;
; @uses     FLAGS
;
; @xref     SHADOW_PM_API_Handler
;
;******************************************************************************
BeginProc Shadow_PM_API_DoShadowMaintenance
        push    edi
        call    _IoctlDoShadowMaintenance
        pop     edi
        ret
EndProc Shadow_PM_API_DoShadowMaintenance

;******************************************************************************
;
; @doc      INTERNAL      SHADOW    API
;
; @asm      SHADOW_PM_API_CopyChunk | This function is called
;           by the Reintegration Agent.
;
; @reg      EBX | Current VM Handle
;
; @reg      EBP | Pointer to Client Register Structure.
;
; @rdesc    eax contains zero if API failed, else non-zero.
;
; @uses     FLAGS
;
; @xref     SHADOW_PM_API_Handler
;
;******************************************************************************
BeginProc Shadow_PM_API_CopyChunk
        push    ebx
        mov     ebx,[esi.lpvOutBuffer]
        push    ebx
        push    edi
        call    _IoctlCopyChunk
        pop     edi
        pop     ebx
        pop     ebx
        ret
EndProc Shadow_PM_API_CopyChunk

;******************************************************************************
;
; @doc      INTERNAL      SHADOW    API
;
; @asm      SHADOW_PM_API_BeginReint | This function is called
;           by the Reintegration Agent to start reintegration on a
;           server whose handle is in the SHADOWINFO structure
;
; @reg      EBX | Current VM Handle
;
; @reg      EBP | Pointer to Client Register Structure.
;
; @reg      EDI | A pointer to SHADOWINFO structure
;                {
;                HSHADOW         hShadow;
;                HSHADOW         hDir;
;                HSERVER         hServer;
;                LPFIND32        lpFind32;
;                unsigned        short usStatus;
;                }
;
; @rdesc    eax contains zero if API failed, else non-zero.
;
; @uses     FLAGS
;
; @xref     SHADOW_PM_API_Handler
;
;******************************************************************************
BeginProc Shadow_PM_API_BeginReint
        push    edi
        call    _IoctlBeginReint
        pop     edi
        ret
EndProc Shadow_PM_API_BeginReint

;******************************************************************************
;
; @doc      INTERNAL      SHADOW    API
;
; @asm      SHADOW_PM_API_EndReint | This function is called
;           by the Reintegration Agent to end reintegration on a
;           server whose handle is in the SHADOWINFO structure.
;           uStatus contains the server status to be set.
;           uOp contains the operation to be applied on the status(AND,OR etc.)
;
; @reg      EBX | Current VM Handle
;
; @reg      EBP | Pointer to Client Register Structure.
;
; @reg      EDI | A pointer to SHADOWINFO structure
;                {
;                HSHADOW         hShadow;
;                HSHADOW         hDir;
;                HSERVER         hServer;
;                LPFIND32        lpFind32;
;                unsigned        uStatus;
;                unsigned        uOp;
;                }
;
; @rdesc    eax contains zero if API failed, else non-zero.
;
; @uses     FLAGS
;
; @xref     SHADOW_PM_API_Handler
;
;******************************************************************************
BeginProc Shadow_PM_API_EndReint
        push    edi
        call    _IoctlEndReint
        pop     edi
        ret
EndProc Shadow_PM_API_EndReint


;******************************************************************************
;
; @doc      INTERNAL      SHADOW    API
;
; @asm      SHADOW_PM_API_CreateShadow | This function is called
;           by the Reintegration Agent to create a shadow
;
; @reg      EBX | Current VM Handle
;
; @reg      EBP | Pointer to Client Register Structure.
;
; @reg      EDI | A pointer to SHADOWINFO structure
;                {
;                HSHADOW         hShadow;
;                HSHADOW         hDir;
;                HSERVER         hServer;
;                LPFIND32        lpFind32;
;                unsigned        uStatus;
;                unsigned        uOp;
;                }
;
; @rdesc    eax contains zero if API failed, else non-zero.
;
; @uses     FLAGS
;
; @xref     SHADOW_PM_API_Handler
;
;******************************************************************************
BeginProc Shadow_PM_API_CreateShadow
        push    edi
        call    _IoctlCreateShadow
        pop     edi
        ret
EndProc Shadow_PM_API_CreateShadow




;******************************************************************************
;
; @doc      INTERNAL      SHADOW    API
;
; @asm      SHADOW_PM_API_DeleteShadow | This function is called
;           by the Reintegration Agent to delete a shadow
;
; @reg      EBX | Current VM Handle
;
; @reg      EBP | Pointer to Client Register Structure.
;
; @reg      EDI | A pointer to SHADOWINFO structure
;                {
;                HSHADOW         hShadow;
;                HSHADOW         hDir;
;                HSERVER         hServer;
;                LPFIND32        lpFind32;
;                unsigned        uStatus;
;                unsigned        uOp;
;                }
;
; @rdesc    eax contains zero if API failed, else non-zero.
;
; @uses     FLAGS
;
; @xref     SHADOW_PM_API_Handler
;
;******************************************************************************
BeginProc Shadow_PM_API_DeleteShadow
        push    edi
        call    _IoctlDeleteShadow
        pop     edi
        ret
EndProc Shadow_PM_API_DeleteShadow



;******************************************************************************
;
; @doc      INTERNAL      SHADOW    API
;
; @asm      SHADOW_PM_API_GetServerStatus | This function is called
;           by the Reintegration Agent to create a shadow
;
; @reg      EBX | Current VM Handle
;
; @reg      EBP | Pointer to Client Register Structure.
;
; @reg      EDI | A pointer to SHADOWINFO structure
;                {
;                HSHADOW         hShadow;
;                HSHADOW         hDir;
;                HSERVER         hServer;
;                LPFIND32        lpFind32;
;                unsigned        uStatus;
;                unsigned        uOp;
;                }
;
; @rdesc    eax contains zero if API failed, else non-zero.
;
; @uses     FLAGS
;
; @xref     SHADOW_PM_API_Handler
;
;******************************************************************************
BeginProc Shadow_PM_API_GetServerStatus
        push    edi
        call    _IoctlGetServerStatus
        pop     edi
        ret
EndProc Shadow_PM_API_GetServerStatus


;******************************************************************************
;
; @doc      INTERNAL      SHADOW    API
;
; @asm      SHADOW_PM_API_SetServerStatus | This function is called
;           by the Reintegration Agent to create a shadow
;
; @reg      EBX | Current VM Handle
;
; @reg      EBP | Pointer to Client Register Structure.
;
; @reg      EDI | A pointer to SHADOWINFO structure
;                {
;                HSHADOW         hShadow;
;                HSHADOW         hDir;
;                HSERVER         hServer;
;                LPFIND32        lpFind32;
;                unsigned        uStatus;
;                unsigned        uOp;
;                }
;
; @rdesc    eax contains zero if API failed, else non-zero.
;
; @uses     FLAGS
;
; @xref     SHADOW_PM_API_Handler
;
;******************************************************************************
BeginProc Shadow_PM_API_SetServerStatus
        push    edi
        call    _IoctlSetServerStatus
        pop     edi
        ret
EndProc Shadow_PM_API_SetServerStatus




;******************************************************************************
;
; @doc      INTERNAL      SHADOW    API
;
; @asm      SHADOW_PM_API_AddUse | This function is by Shadow NP
;           on detecting disconnection
;
; @reg      EBX | Current VM Handle
;
; @reg      EBP | Pointer to Client Register Structure.
;
; @reg      EDI | A pointer to COPYPARAMS structure
;               typedef struct tagCOPYPARAMS
;                   {
;                   HSERVER  hServer;
;                   HSHADOW  hDir;
;                   HSHADOW  hShadow;
;                   LPSTR    lpLocalPath;
;                   LPSTR    lpRemotePath;
;                   LPSTR    lpServerPath;
;                   }
;                COPYPARAMS;
;
; @rdesc    eax contains zero if API failed, else non-zero.
;
; @uses     FLAGS
;
; @xref     SHADOW_PM_API_Handler
;
;******************************************************************************
BeginProc Shadow_PM_API_AddUse
        push    edi
        call    _IoctlAddUse
        pop     edi
        ret
EndProc Shadow_PM_API_AddUse



;******************************************************************************
;
; @doc      INTERNAL      SHADOW    API
;
; @asm      SHADOW_PM_API_DelUse | This function is by Shadow NP
;           on detecting disconnection
;
; @reg      EBX | Current VM Handle
;
; @reg      EBP | Pointer to Client Register Structure.
;
; @reg      EDI | A pointer to COPYPARAMS structure
;               typedef struct tagCOPYPARAMS
;                   {
;                   HSERVER  hServer;
;                   HSHADOW  hDir;
;                   HSHADOW  hShadow;
;                   LPSTR    lpLocalPath;
;                   LPSTR    lpRemotePath;
;                   LPSTR    lpServerPath;
;                   }
;                COPYPARAMS;
;
; @rdesc    eax contains zero if API failed, else non-zero.
;
; @uses     FLAGS
;
; @xref     SHADOW_PM_API_Handler
;
;******************************************************************************
BeginProc Shadow_PM_API_DelUse
        push    edi
        call    _IoctlDelUse
        pop     edi
        ret
EndProc Shadow_PM_API_DelUse



;******************************************************************************
;
; @doc      INTERNAL      SHADOW    API
;
; @asm      SHADOW_PM_API_GetUse | This function is by Shadow NP
;           on detecting disconnection
;
; @reg      EBX | Current VM Handle
;
; @reg      EBP | Pointer to Client Register Structure.
;
; @reg      EDI | A pointer to COPYPARAMS structure
;               typedef struct tagCOPYPARAMS
;                   {
;                   HSERVER  hServer;
;                   HSHADOW  hDir;
;                   HSHADOW  hShadow;
;                   LPSTR    lpLocalPath;
;                   LPSTR    lpRemotePath;
;                   LPSTR    lpServerPath;
;                   }
;                COPYPARAMS;
;
; @rdesc    eax contains zero if API failed, else non-zero.
;
; @uses     FLAGS
;
; @xref     SHADOW_PM_API_Handler
;
;******************************************************************************
BeginProc Shadow_PM_API_GetUse
        push    edi
        call    _IoctlGetUse
        pop     edi
        ret
EndProc Shadow_PM_API_GetUse


;******************************************************************************
;
; @doc      INTERNAL      SHADOW    API
;
; @asm      SHADOW_PM_API_Switches | This function is called
;           by the Reintegration Agent to switch on/off shadowing, loggin etc.
;
; @reg      EBX | Current VM Handle
;
; @reg      EBP | Pointer to Client Register Structure.
;
; @reg      EDI | A pointer to SHADOWINFO structure
;                {
;                HSHADOW         hShadow;
;                HSHADOW         hDir;
;                HSERVER         hServer;
;                LPFIND32        lpFind32;
;                unsigned        uStatus;
;                unsigned        uOp;
;                }
;
; @rdesc    eax contains zero if API failed, else non-zero.
;
; @uses     FLAGS
;
; @xref     SHADOW_PM_API_Handler
;
;******************************************************************************
BeginProc Shadow_PM_API_Switches
        push    edi
        call    _IoctlSwitches
        pop     edi
        ret
EndProc Shadow_PM_API_Switches


;******************************************************************************
;
; @doc      INTERNAL      SHADOW    API
;
; @asm      SHADOW_PM_API_Get_Shadow_Info |
;                IN: hDir, name of the shadow (OEM string) in lpFind2->cFileName
;                OUT: hShadow, uStatus, lpFind32 contains the find info
;
; @reg      EBX | Current VM Handle
;
; @reg      EBP | Pointer to Client Register Structure.
;
; @reg      EDI | A pointer to SHADOWINFO structure
;                {
;                HSERVER         hServer;
;                HSHADOW         hDir;
;                HSHADOW         hShadow;
;                LPFIND32        lpFind32;
;                unsigned        uStatus;
;                unsigned        uOp;
;                }
;
; @rdesc    eax contains zero if API failed, else non-zero.
;
; @uses     FLAGS
;
; @xref     SHADOW_PM_API_Handler
;
;******************************************************************************
BeginProc Shadow_PM_API_GetShadow
        push    edi
        call    _IoctlGetShadow
        pop     edi
        ret
EndProc Shadow_PM_API_GetShadow


;******************************************************************************
;
; @doc      INTERNAL      SHADOW    API
;
; @asm      SHADOW_PM_API_Get_Space_Info |
;
; @reg      EBX | Current VM Handle
;
; @reg      EBP | Pointer to Client Register Structure.
;
; @reg      EDI | A pointer to GLOABLSTATUS structure
;
; @rdesc    eax contains zero if API failed, else non-zero.
;
; @uses     FLAGS
;
; @xref     SHADOW_PM_API_Handler
;
;******************************************************************************
BeginProc Shadow_PM_API_GetGlobalStatus
        push    edi
        call    _IoctlGetGlobalStatus
        pop     edi
        ret
EndProc Shadow_PM_API_GetGlobalStatus


BeginProc Shadow_PM_API_FindOpenHSHADOW
        push    edi
        call    _IoctlFindOpenHSHADOW
        pop     edi
        ret
EndProc Shadow_PM_API_FindOpenHSHADOW

BeginProc Shadow_PM_API_FindNextHSHADOW
        push    edi
        call    _IoctlFindNextHSHADOW
        pop     edi
        ret
EndProc Shadow_PM_API_FindNextHSHADOW

BeginProc Shadow_PM_API_FindCloseHSHADOW
        push    edi
        call    _IoctlFindCloseHSHADOW
        pop     edi
        ret
EndProc Shadow_PM_API_FindCloseHSHADOW



BeginProc Shadow_PM_API_GetPriorityHSHADOW
        push    edi
        call    _IoctlGetPriorityHSHADOW
        pop     edi
        ret
EndProc Shadow_PM_API_GetPriorityHSHADOW

BeginProc Shadow_PM_API_SetPriorityHSHADOW
        push    edi
        call    _IoctlSetPriorityHSHADOW
        pop     edi
        ret
EndProc Shadow_PM_API_SetPriorityHSHADOW




BeginProc Shadow_PM_API_AddHint
        push    edi
        call    _IoctlAddHint
        pop     edi
        ret
EndProc Shadow_PM_API_AddHint

BeginProc Shadow_PM_API_DeleteHint
        push    edi
        call    _IoctlDeleteHint
        pop     edi
        ret
EndProc Shadow_PM_API_DeleteHint




BeginProc Shadow_PM_API_FindOpenHint
        push    edi
        call    _IoctlFindOpenHint
        pop     edi
        ret
EndProc Shadow_PM_API_FindOpenHint

BeginProc Shadow_PM_API_FindNextHint
        push    edi
        call    _IoctlFindNextHint
        pop     edi
        ret
EndProc Shadow_PM_API_FindNextHint

BeginProc Shadow_PM_API_FindCloseHint
        push    edi
        call    _IoctlFindCloseHint
        pop     edi
        ret
EndProc Shadow_PM_API_FindCloseHint

BeginProc Shadow_PM_API_GetAliasHSHADOW
        push    edi
        call    _IoctlGetAliasHSHADOW
        pop     edi
        ret
EndProc Shadow_PM_API_GetAliasHSHADOW


IFDEF DEBUG
;******************************************************************************
;            D E B U G G I N G   C O D E
;******************************************************************************

BeginProc Shadow_Timer_Callback, PUBLIC

        inc     _cntTicks
        mov     eax,    _cntTicks
        cmp     eax,    SHADOW_STATS_FLUSH_COUNT
        jl      STC_Done
        mov     eax,    0
        mov     ebx,    0
        mov     ecx,    PEF_WAIT_NOT_NESTED_EXEC
        mov     edx,    0
        lea     esi,    Shadow_Restricted_Event_Callback
        VMMCall Call_Restricted_Event
        mov     _cntTicks,0
STC_Done:
        ret
EndProc Shadow_Timer_Callback


BeginProc Shadow_Restricted_Event_Callback, PUBLIC
        call    _ShadowRestrictedEventCallback
        mov     eax, SHADOW_LOG_TIME_INTERVAL
        mov     edx, 0
        mov     esi, OFFSET32 Shadow_Timer_Callback
        VMMCall Set_Global_Time_Out
        mov     eax,esi
        cmp     eax,0
        jne     TimerSet1
        Trace_Out       "Shadow: Couldn't set the logging timer again"
TimerSet1:
        ret
EndProc   Shadow_Restricted_Event_Callback

BeginProc _DebugBreak, PUBLIC
        push    [esp+4]
        VMMCall _Debug_Out_Service
        pop     eax
        ret
EndProc _DebugBreak

BeginProc MinDbg_Debug

        mov     _NbDebug, 0
        ret

EndProc MinDbg_Debug

BeginProc DefaultDbg_Debug

;        mov     _NbDebug, DEFAULT_DEBUG
        ret

EndProc DefaultDbg_Debug

BeginProc MaxDbg_Debug

        mov     _NbDebug, 0FFFFFFFFh
        ret

EndProc MaxDbg_Debug

BeginProc Alloc_Debug

        mov     eax, Alloc_watch
        not     eax
        mov     Alloc_watch, eax
        ret

EndProc Alloc_Debug

BeginProc _ShadowCheckHeap

        pushad
        push    @Line
        push    OFFSET32 Shadow_str
        push    ecx
        VxDCall IFSMgr_CheckHeap
        add     esp, 12
        or      eax, eax
        jz      GCH_10
        trace_out "Heap is fried"

GCH_10:

        popad
        ret

EndProc _ShadowCheckHeap

BeginProc _CheckHeap
	mov ecx, [esp+4]
	call _shadowCheckHeap
	ret
EndProc _Checkheap

BeginProc AllocDisplay_Debug

        mov     ecx, Alloc_cnt
        or      ecx, ecx
        jz      AD_Exit
        mov     edi, OFFSET32 Alloc_table
        mov     esi, OFFSET32 Alloc_sizes

AD_Loop:

        mov     edx, [edi]
        mov     ebx, [esi]
        Trace_Out "Memory block: #edx Size: #ebx"
        add     esi, 4
        add     edi, 4
        loop    AD_Loop

AD_Exit:

        Trace_Out " "
        call    _ShadowCheckHeap
        ret

EndProc AllocDisplay_Debug

;**	SHDDumpDebug - Dump debug information to the debugger
;

	public	SHDDumpDebug
SHDDumpDebug proc near

	xor	ebx, ebx
	mov	ax, fs
	test	ax, ax
	jz	dq1

	push	esi
	push	ds

	lea	edi, _DebugQueryCmdStr
	mov	ecx, _DebugQueryCmdStrLen
	mov	ds, ax
	cld
	rep	movsb
	xor	eax, eax
	stosb

	pop	ds
	pop	esi

	lea	ebx, _DebugQueryCmdStr

dq1:
	push	ebx
	call	_SHDDebug
	add	esp, 4
	ret
SHDDumpDebug endp

ENDIF

;** ShadowHookDeviceService - external API handler
;
;	This routine receives HookDeviceService from the IFSMgr
;
;	Entry	(TOS+4) = ioreq & user register ptr
;	Exit	none
;	Uses	C registers

BeginProc ShadowHookDeviceService, PUBLIC
;        Trace_Out       "HookDeviceService Hook Called"
        pushf
        cmp            eax, @@IFSMgr_NetFunction
        jz             SHDS_Unhook
        popf
        jmp            OrigHookDeviceService

SHDS_Unhook:
;       Someone is indeed trying to hook IFSMgr_NetFunction
;       Let us first unhook ourselves
        popf
;        Trace_Out       "Someone hooking IFSMgr_NetFunction"

        push            eax
        push            esi
        mov             esi, OFFSET32 ShadowNetFunction
        VMMCall         Unhook_Device_Service
        pop             esi
        pop             eax
        jc              SHDS_error

;       We unhooked ourselves
;       let the caller  do it
        call            OrigHookDeviceService

;       Save his result on the stack
        pushf

;       Let us hook     ourselves back in
        push            esi
        push            eax
	mov	        esi, OFFSET32 ShadowNetFunction
	mov	        eax, @@IFSMgr_NetFunction
	call	        OrigHookDeviceService
	mov	        _OrigNetFunction, esi
        pop             eax
        pop             esi
        jc              SHDS_unhook_error
        popf
        jmp             SHDS_done
SHDS_unhook_error:
        popf
        jmp             SHDS_error
SHDS_error:
        Trace_Out       "HookDeviceService Hook Error, disabling shadowing"
        mov             _fShadow, 0
SHDS_done:
        ret
EndProc ShadowHookDeviceService

;** ShadowRegisterNetFunction - external API handler
;
;	This routine receives RegisterNet from the IFSMgr
;
;	Entry	(TOS+4) = ioreq & user register ptr
;	Exit	none
;	Uses	C registers

BeginProc ShadowRegisterNetFunc, PUBLIC
;        int     1
        Trace_Out       "Hook Called"
	mov		eax, [esp+8]
	cmp		eax, IFSMGRVERSION
	jne		connect_passthrough	; if wrong ifs version, don't hook

	mov		eax, [esp+0ch]
	cmp		eax, WNNC_NET_LANMAN
	je		hooklanman			; hookit if lanman or ourselves
	mov		eax, [esp+0ch]
	cmp		eax, WNNC_NET_COGENT	; BUGBUG get us a net ID
	je		hookus
        Trace_Out       "Hook Called by some other FSD"
	jmp		connect_passthrough
hooklanman:
        Trace_Out       "Hook Called by LANMAN"
	xor		ecx, ecx		;; important step!!!
	VxDCall 	VRedir_Get_Version
	mov		_VRedirCSCInfoFunction, ecx	;; if this is a new vredir, it will give us the function
	jmp		hookit
hookus:
        Trace_Out       "Hook Called by us"
hookit:
        mov             eax, [esp+4]    ; take the pFunc from FSD

        ; Put it in our table
        push            eax

        call            _ProcessRegisterNet
        add             esp,4
        or              eax,eax
        jz              connect_passthrough
        mov             [esp+4],eax     ; replace his function with ours

connect_passthrough:
	jmp	OrigRegisterNetFunc	; pass on to IFSMgr

EndProc ShadowRegisterNetFunc

;** ShadowNetFunction - external API handler
;
;	This routine receives NetFunction from the IFSMgr
;
;	Entry	(TOS+4) = ioreq & user register ptr
;	Exit	none
;	Uses	C registers

BeginProc ShadowNetFunction, PUBLIC, HOOK_PROC, NextNetFunction
;        Trace_Out       "NetFunction Hook Called"
        call            _ProcessNetFunction
        ret
EndProc ShadowNetFunction

IFDEF HOOKMOUNT
;** ShadowMountFunction - external API handler
;
;	This routine receives RegisterMount from the IFSMgr
;
;	Entry	(TOS+4) = ioreq & user register ptr
;	Exit	none
;	Uses	C registers

BeginProc ShadowMountFunction, PUBLIC
;        int     1
        Trace_Out       "Hook Called"
        mov             eax, [esp+4]    ; take the pFunc from FSD

        ; Put it in our table
        push            eax
        call            _ProcessRegisterMount
        add             esp,4
        or              eax,eax
        jz              mount_passthrough
        mov             [esp+4],eax     ; replace his function with ours

mount_passthrough:
	jmp	OrigRegisterMountFunc	; pass on to IFSMgr

EndProc ShadowMountFunction

ENDIF

BeginProc _UniToBCSPath , PUBLIC
	int	Dyna_Link_Int
	dd	@@UniToBCSPath OR DL_Jmp_Mask
EndProc _UniToBCSPath

BeginProc _UniToBCS , PUBLIC
	int	Dyna_Link_Int
	dd	@@UniToBCS OR DL_Jmp_Mask
EndProc _UniToBCS

BeginProc _BCSToUni , PUBLIC
	int	Dyna_Link_Int
	dd	@@BCSToUni OR DL_Jmp_Mask
EndProc _BCSToUni

BeginProc _IFSMgr_MetaMatch, PUBLIC
	int	Dyna_Link_Int
	dd	@@IFSMgr_MetaMatch OR DL_Jmp_Mask
EndProc _IFSMgr_MetaMatch

BeginProc _UniToUpper, PUBLIC
	int	Dyna_Link_Int
	dd	@@UniToUpper OR DL_Jmp_Mask
EndProc _UniToUpper

BeginProc _FGHS, PUBLIC
	int	Dyna_Link_Int
	dd	@@IFSMgr_GetHeap OR DL_Jmp_Mask
EndProc _FGHS

BeginProc _RetHeap, PUBLIC
	int	Dyna_Link_Int
	dd	@@IFSMgr_RetHeap OR DL_Jmp_Mask
EndProc _RetHeap

BeginProc _IFSMgr_Printf, PUBLIC
        int     Dyna_Link_Int
        dd      @@IFSMgr_printf OR DL_Jmp_Mask
EndProc _IFSMgr_Printf

BeginProc _IFSMgr_AssertFailed, PUBLIC
        int     Dyna_Link_Int
        dd      @@IFSMgr_AssertFailed OR DL_Jmp_Mask
EndProc _IFSMgr_AssertFailed

BeginProc _Ring0Api,  PUBLIC
        int     Dyna_Link_Int
        dd      @@IFSMgr_Ring0_FileIO OR DL_Jmp_Mask
EndProc _Ring0Api

BeginProc _ParsePath,  PUBLIC
        int     Dyna_Link_Int
        dd      @@IFSMgr_ParsePath OR DL_Jmp_Mask
EndProc _ParsePath

BeginProc _IFSMgr_Win32ToDosTime,  PUBLIC
        int     Dyna_Link_Int
        dd      @@IFSMgr_Win32ToDosTime OR DL_Jmp_Mask
EndProc _IFSMgr_Win32ToDosTime

BeginProc _IFSMgr_DosToWin32Time,  PUBLIC
        int     Dyna_Link_Int
        dd      @@IFSMgr_DosToWin32Time OR DL_Jmp_Mask
EndProc _IFSMgr_DosToWin32Time

BeginProc _IFSMgr_DosToNetTime,  PUBLIC
        int     Dyna_Link_Int
        dd      @@IFSMgr_DosToNetTime OR DL_Jmp_Mask
EndProc _IFSMgr_DosToNetTime

BeginProc _IFSMgr_Get_NetTime,  PUBLIC
        int     Dyna_Link_Int
        dd      @@IFSMgr_Get_NetTime OR DL_Jmp_Mask
EndProc _IFSMgr_Get_NetTime

BeginProc _IFSMgr_NetToWin32Time,  PUBLIC
        int     Dyna_Link_Int
        dd      @@IFSMgr_NetToWin32Time OR DL_Jmp_Mask
EndProc _IFSMgr_NetToWin32Time

BeginProc _GetCurThreadHandle
        VMMCall Get_Cur_Thread_Handle
        mov     eax,edi
        ret
EndProc _GetCurThreadHandle

BeginProc _Shell_PostMessage
        int     Dyna_Link_Int
        dd      @@_Shell_PostMessage OR DL_Jmp_Mask
EndProc _Shell_PostMessage

BeginProc __BlockOnID
        int     Dyna_Link_Int
        dd      @@_BlockOnID OR DL_Jmp_Mask
EndProc __BlockOnID

BeginProc __SignalID
        int     Dyna_Link_Int
        dd      @@_SignalID OR DL_Jmp_Mask
EndProc __SignalID

BeginProc _IFSMgr_UseAdd
        int     Dyna_Link_Int
        dd      @@IFSMgr_UseAdd OR DL_Jmp_Mask
EndProc _IFSMgr_UseAdd

BeginProc _IFSMgr_UseDel
        int     Dyna_Link_Int
        dd      @@IFSMgr_UseDel OR DL_Jmp_Mask
EndProc _IFSMgr_UseDel

BeginProc _CreateBasis
        int     Dyna_Link_Int
        dd      @@CreateBasis OR DL_Jmp_Mask
EndProc _CreateBasis

BeginProc _MatchBasisName
        int     Dyna_Link_Int
        dd      @@MatchBasisName OR DL_Jmp_Mask
EndProc _MatchBasisName

BeginProc _AppendBasisTail
        int     Dyna_Link_Int
        dd      @@AppendBasisTail OR DL_Jmp_Mask
EndProc _AppendBasisTail


BeginProc _FCBToShort
        int     Dyna_Link_Int
        dd      @@FcbToShort OR DL_Jmp_Mask
EndProc _FCBToShort

BeginProc _ShortToFCB
        int     Dyna_Link_Int
        dd      @@ShortToFcb OR DL_Jmp_Mask
EndProc _ShortToFCB

BeginProc  _DebugMenu
        int     Dyna_Link_Int
        dd      @@IFSMgr_DebugMenu OR DL_Jmp_Mask
EndProc _DebugMenu


_GetConfigDir:
	push	edx
	VMMCall	Get_Config_Directory
	mov	eax, edx
	pop	edx
	ret

_Get_Sys_VM_Handle:
        push    ebx
        VMMcall Get_Sys_VM_Handle
        mov     eax, ebx
        pop     ebx
        ret

_Get_Cur_VM_Handle:
        push    ebx
        VMMcall Get_Cur_VM_Handle
        mov     eax, ebx
        pop     ebx
        ret

_Call_VM_Event:
	push 	ebx
	push	esi
	push	edx
	mov	ebx, [esp+16]	;VM handle
	mov	esi, [esp+20]	;callback function
	mov	edx, [esp+24]	; refdata
	VMMCall	Call_VM_Event
	pop	edx
	pop	esi
	pop	ebx
	ret

;***	_SetWin32Event - This function sets an event to the signaled state.
;
;	_SetWin32Event is a thunk to VWIN32_SetWin32Event.  (We make
;	sure that Win32 is loaded prior to making the call.)
;
;	BOOL = SetWin32Event( pevt );
;
;	ENTRY	[esp+4] - pointer to an event object
;
;	EXIT	eax = 0 if event was invalid, <> 0 if OK
;		The event object is set to a signaled state. If it is a
;		manual reset event, it remains in the signaled state until it
;		is explicitly reset and all threads currently blocked on this
;		event are unblocked. If it is an auto reset event, one waiting
;		thread is unblocked.
;
;	USES	EAX, ECX, EDX
;

BeginProc   _SetWin32Event
	VxDCall VWIN32_Get_Version	; Verify Win32 installation
	jc	short swe90		; Win32 not installed! (EAX)=0

	; BUGBUG - the input parameter to _VWIN32_SetWin32Event is
	; documented as being in EAX right now, but if someone comes to
	; their senses and makes this C callable, this code will still work!

	mov	eax,DWORD PTR [esp+4]	; (EAX) = event object address
	push	eax
	VxDCall _VWIN32_SetWin32Event	; Call _VWIN32_SetWin32Event
	lea	esp,[esp+4]
swe90:	ret
EndProc     _SetWin32Event


;***	_ResetWin32Event - This function sets an event to not signaled state.
;
;	_ResetWin32Event is a thunk to VWIN32_ResetWin32Event.
;	(We make sure that Win32 is loaded prior to making the call.)
;
;	BOOL = ResetWin32Event( pevt );
;
;	ENTRY	[esp+4] - pointer to an event object
;
;	EXIT	eax = 0 if event was invalid, <> 0 if OK
;		The event object is set to a not signaled state.
;
;	USES	EAX, ECX, EDX
;

BeginProc   _ResetWin32Event
	VxDCall VWIN32_Get_Version	; Verify Win32 installation
	jc	short swe91		; Win32 not installed! (EAX)=0

	; BUGBUG - the input parameter to _VWIN32_ResetWin32Event is
	; documented as being in EAX right now, but if someone comes to
	; their senses and makes this C callable, this code will still work!

	mov	eax,DWORD PTR [esp+4]	; (EAX) = event object address
	push	eax
	VxDCall _VWIN32_ResetWin32Event ; Call _VWIN32_ResetWin32Event
	lea	esp,[esp+4]
swe91:	ret
EndProc _ResetWin32Event


;***	_InSysVM - Returns boolean (Current VM == System VM) in EAX
;

BeginProc   _InSysVM
	push	ebx
	VMMCall Get_Cur_VM_Handle	; (EBX) = Current VM
	VMMCall Test_Sys_VM_Handle	; (Zero) = (Current VM == System VM)
	pop	ebx
	sete	al			; (AL)= (Current VM == System VM)
	movzx	eax,al			; EAX = (Current VM == System VM)
	ret
EndProc _InSysVM

_CloseVxDHandle:
	mov	eax, [esp+4]
	VxDcall _VWIN32_CloseVxDHandle
	ret


BeginProc _MyCheckAccessConflict
        int     Dyna_Link_Int
        dd      @@IFSMgr_CheckAccessConflict OR DL_Jmp_Mask
EndProc _MyCheckAccessConflict

;
;   SP_PutNumber
;
;   Takes an unsigned long integer and places it into a buffer, respecting
;   a buffer limit, a radix, and a case select (upper or lower, for hex).
;

SP_PutNumber proc near c public,  lpb:DWORD, n:DWORD, limit:DWORD, radix:DWORD, case:DWORD

        push    esi
        push    edi
        mov     al,'a'-'0'-10                           ; figure out conversion offset
        cmp     case,0
        jz pn_lower
        mov     al,'A'-'0'-10
pn_lower:
        mov     byte ptr case,al

        mov     eax,n                                   ; ebx=number
        mov     ecx,radix                               ; cx=radix
        mov     edi,lpb                                 ; edi->string
        mov     esi,limit                               ; cchLimit

divdown:
        xor     edx,edx
        div     ecx                                     ; edx = rem, eax = div
        xchg    eax,edx                                 ; eax = rem, edx = div
        add     al,'0'
        cmp     al,'9'
        jbe     isadig                                  ; is a digit already
        add     al,byte ptr case                        ; convert to letter

isadig:
        dec     esi                                     ; decrement cchLimit
        jz      pn_exit                                 ; go away if end of string
        stosb                                           ; stick it in
        mov     eax,edx
        or      eax,eax
        jnz     divdown                                 ; crack out next digit

pn_exit:
        mov     eax,edi
        sub     eax,dword ptr lpb[0]                    ; find number of chars output
        pop     edi
        pop     esi
        ret

SP_PutNumber EndP

;
;   SP_Reverse
;
;   Reverses a string in place
;
SP_Reverse proc near c public,  lpFirst:DWORD, lpLast:DWORD
        push    esi
        push    edi
        mov     esi,lpFirst
        mov     edi,lpLast
        mov     ecx,edi                                 ; number of character difference
        sub     ecx,esi
        inc     ecx
        shr     ecx,1                                   ; number of swaps required
        jcxz    spr_boring                              ; nuthin' to do
spr100:
        mov     ah,[edi]
        mov     al,[esi]                                ; load the two characters
        mov     [esi],ah
        mov     [edi],al                                ; swap them
        inc     esi
        dec     edi                                     ; adjust the pointers
        loop    spr100                                  ; ...until we've done 'em all
spr_boring:
        pop     edi
        pop     esi
        ret

SP_Reverse EndP


VxD_CODE_ENDS

END



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\record.mgr\recordse.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    recordse.c

Abstract:

    This module implements all security related functions for disconnected
    operation of Client Side Caching at the record level. This facilitates the
    usage of a user mode integrity checker at the record level.

Revision History:

    Balan Sethu Raman     [SethuR]    6-October-1997

Notes:

--*/

#include "precomp.h"
#pragma hdrstop

#pragma code_seg("PAGE")

#ifndef CSC_RECORDMANAGER_WINNT
#include "record.h"
#endif //ifndef CSC_RECORDMANAGER_WINNT

#define CSC_INVALID_FILE_HANDLE (0)

CSC_SECURITY CscSecurity = { CSC_INVALID_FILE_HANDLE, NULL };
BOOL    vfStopCachingSidFileHandle = FALSE;

#define CSC_NUMBER_OF_SIDS_OFFSET (0x0)
#define CSC_SID_SIZES_OFFSET      (CSC_NUMBER_OF_SIDS_OFFSET + sizeof(ULONG))

// These macros define the associated Global variables for assert macros
AssertData
AssertError

DWORD
CscLoadSidMappings(
    CSCHFILE     hSidFile,
    PCSC_SIDS *pCscSidsPointer)
/*++

Routine Description:

    This routine loads the sid mappings from the CSC database to a memory
    data structure.

Arguments:

    hSidFile -- the file for loading the mappings from.

Return Value:

    STATUS_SUCCESS - if the mappings were successfully loaded

    Other Status codes correspond to error situations.

Notes:

    There are two important considerations that need to be satisfied in the
    implementation ..

    1) During remote boot the regular API for reading/writing files are not
    available. There will be an OS layer implementation for the same.
    Consequently this routine must implement the loading in terms of the OS
    layer APIs.

    2) The data structure is geared towards the fact that there are very few
    sid to index mappings. Consequently a simple array suffices.

    The format in which the mappings are stored is as follows

        1) number of sids
        2) sizes of the various sids
        3) the sids
--*/
{
    DWORD       Status = ERROR_SUCCESS;
    ULONG       NumberOfSids;
    ULONG        BytesRead;
    ULONG       i;
    PCSC_SIDS   pCscSids = NULL;

    BytesRead = ReadFileLocal(
                    hSidFile,
                    CSC_NUMBER_OF_SIDS_OFFSET,
                    &NumberOfSids,
                    sizeof(NumberOfSids));

    if (BytesRead == sizeof(NumberOfSids)) {

        // Allocate the Sids Array
        pCscSids = (PCSC_SIDS)AllocMem(
                                  sizeof(CSC_SIDS) + sizeof(CSC_SID) * NumberOfSids);

        if (pCscSids != NULL) {
            pCscSids->MaximumNumberOfSids = NumberOfSids;
            pCscSids->NumberOfSids = NumberOfSids;

            for (i = 0; i < NumberOfSids; i++) {
                pCscSids->Sids[i].pSid = NULL;
            }

            BytesRead = ReadFileLocal(
                            hSidFile,
                            CSC_SID_SIZES_OFFSET,
                            &pCscSids->Sids,
                            sizeof(CSC_SID) * NumberOfSids);

            if (BytesRead != (sizeof(CSC_SID) * NumberOfSids)) {
                Status = ERROR_INVALID_DATA;
            }
        } else {
            Status = ERROR_NO_SYSTEM_RESOURCES;
        }

        // The array structure has been initialized correctly. Each of the
        // individual sids needs to be initialized.
        if (Status == ERROR_SUCCESS) {
            ULONG SidOffset = CSC_SID_SIZES_OFFSET +
                              sizeof(CSC_SID) * NumberOfSids;

            for (i = 0; i < NumberOfSids; i++) {
                pCscSids->Sids[i].pSid = AllocMem(pCscSids->Sids[i].SidLength);

                if (pCscSids->Sids[i].pSid != NULL) {
                    BytesRead = ReadFileLocal(
                                    hSidFile,
                                    SidOffset,
                                    pCscSids->Sids[i].pSid,
                                    pCscSids->Sids[i].SidLength);

                    if (BytesRead == pCscSids->Sids[i].SidLength) {
                        // Validate the Sid
                    } else {
                        Status = ERROR_INVALID_DATA;
                        break;
                    }
                }

                SidOffset += pCscSids->Sids[i].SidLength;
            }
        }

        if (Status != ERROR_SUCCESS) {
            if (pCscSids != NULL) {
                // There was a problem loading the SID mappings. The mapping structure
                // needs to be torn down.

                for (i=0; i < NumberOfSids; i++) {
                    if (pCscSids->Sids[i].pSid != NULL) {
                        FreeMem(pCscSids->Sids[i].pSid);
                    }
                }

                FreeMem(pCscSids);
            }

            pCscSids = NULL;
        } else {
            // The loading was successful.
            *pCscSidsPointer = pCscSids;
        }
    } else {
        Status = ERROR_INVALID_DATA;
    }

    // On exit from this routine either pCscSids must be NULL or the status
    // must be ERROR_SUCCESS

    if (!((pCscSids == NULL) || (Status == ERROR_SUCCESS))) {
        Assert(FALSE);
    }

    return Status;
}

DWORD
CscSaveSidMappings(
    CSCHFILE     hSidFile,
    PCSC_SIDS pCscSids)
/*++

Routine Description:

    This routine saves the sid mappings to the CSC database from a memory
    data structure.

Arguments:

    hSidFile -- the file for loading the mappings from.

Return Value:

    ERROR_SUCCESS - if the mappings were successfully loaded

    Other Status codes correspond to error situations.

Notes:

    Refer to CscLoadSidMappings

--*/
{
    DWORD  Status = ERROR_SUCCESS;
    ULONG  NumberOfSids,i;
    ULONG  BytesWritten;

    if (pCscSids == NULL) {
        NumberOfSids = 0;
    } else {
        NumberOfSids = pCscSids->NumberOfSids;
    }

    BytesWritten = WriteFileLocal(
                       hSidFile,
                       CSC_NUMBER_OF_SIDS_OFFSET,
                       &NumberOfSids,
                       sizeof(DWORD));

    if (BytesWritten != sizeof(DWORD)) {
        Status = ERROR_INVALID_DATA;
    }

    if ((Status == ERROR_SUCCESS) &&
        (NumberOfSids > 0)) {
        // Write out the CSC_SID data structures corresponding to the various
        // Sids

        BytesWritten = WriteFileLocal(
                           hSidFile,
                           CSC_SID_SIZES_OFFSET,
                           pCscSids->Sids,
                           sizeof(CSC_SID) * NumberOfSids);

        if (BytesWritten == (sizeof(CSC_SID) * NumberOfSids)) {
            ULONG SidOffset = CSC_SID_SIZES_OFFSET + sizeof(CSC_SID) * NumberOfSids;

            for (i = 0; i < NumberOfSids; i++) {
                BytesWritten = WriteFileLocal(
                                   hSidFile,
                                   SidOffset,
                                   pCscSids->Sids[i].pSid,
                                   pCscSids->Sids[i].SidLength);

                if (BytesWritten != pCscSids->Sids[i].SidLength) {
                    Status = ERROR_INVALID_DATA;
                    break;
                }

                SidOffset += pCscSids->Sids[i].SidLength;
            }
        }
    }

    return Status;
}

DWORD
CscInitializeSecurity(
    LPVOID  ShadowDatabaseName)
/*++

Routine Description:

    This routine initializes the infra structure required for caching SIDs/
    access rights in the CSC database.

Arguments:

    ShadowDatabaseName - the root of the shadow database

Return Value:

    STATUS_SUCCESS - if the mappings were successfully loaded

    Other Status codes correspond to error situations.

--*/
{
    DWORD   Status;
    LPTSTR  MappingsFileName;

    Assert(CscSecurity.hSidMappingsFile == CSC_INVALID_FILE_HANDLE);

#if 0
    // Initialize the ACL used with all CSC files

    Status = CscInitializeSecurityDescriptor();

    if (Status != ERROR_SUCCESS) {
        return Status;
    }
#endif

    CscSecurity.hSidMappingsFile = CSC_INVALID_FILE_HANDLE;
    CscSecurity.pCscSids = NULL;

    // A copy of the shadow database name root is kept here.
    // Currently we do not make a copy of this name
    CscSecurity.ShadowDatabaseName = ShadowDatabaseName;

    MappingsFileName = FormNameString(
                           CscSecurity.ShadowDatabaseName,
                           ULID_SID_MAPPINGS);

    if (MappingsFileName != NULL) {
        CscSecurity.hSidMappingsFile = OpenFileLocal(MappingsFileName);

        if (CscSecurity.hSidMappingsFile != CSC_INVALID_FILE_HANDLE) {
            Status = CscLoadSidMappings(
                         CscSecurity.hSidMappingsFile,
                         &CscSecurity.pCscSids);

            // if we are not supposed to cache the file handle
            // then close it
            if (vfStopCachingSidFileHandle)
            {
                CloseFileLocal(CscSecurity.hSidMappingsFile);
                CscSecurity.hSidMappingsFile = CSC_INVALID_FILE_HANDLE;
            }
        } else {
            CscSecurity.pCscSids = NULL;
            Status = ERROR_SUCCESS;
        }
    } else {
        Status = ERROR_NO_SYSTEM_RESOURCES;
    }

    FreeNameString(MappingsFileName);

    if (Status != ERROR_SUCCESS) {
        CscTearDownSecurity(NULL);
    }

    return Status;
}

DWORD
CscTearDownSecurity(LPSTR s)
/*++

Routine Description:

    This routine tears down the infrastructure required for caching SIDs/
    access rights in the CSC database.

Return Value:

    STATUS_SUCCESS - if the mappings were successfully loaded

    Other Status codes correspond to error situations.

--*/
{
    if (CscSecurity.hSidMappingsFile != CSC_INVALID_FILE_HANDLE) {
        CloseFileLocal(CscSecurity.hSidMappingsFile);
        CscSecurity.hSidMappingsFile = CSC_INVALID_FILE_HANDLE;

    }

    if (CscSecurity.pCscSids != NULL) {
        ULONG i;

        for (i = 0;i < CscSecurity.pCscSids->NumberOfSids;i++) {
            if (CscSecurity.pCscSids->Sids[i].pSid != NULL) {
                FreeMem(CscSecurity.pCscSids->Sids[i].pSid);
            }
        }

        FreeMem(CscSecurity.pCscSids);
        CscSecurity.pCscSids = NULL;
        if (CscSecurity.ShadowDatabaseName == s)
            CscSecurity.ShadowDatabaseName = NULL;
    }

#if 0
    CscUninitializeSecurityDescriptor();
#endif
    return ERROR_SUCCESS;
}

DWORD
CscWriteOutSidMappings()
/*++

Routine Description:

    This routine writes out the SID mappings onto the persistent store for the
    CSC database

Return Value:

    ERROR_SUCCESS if successful, otherwise appropriate error

--*/
{
    DWORD   Status;
    LPTSTR  TemporaryMappingsFileName;
    LPTSTR  MappingsFileName;

    TemporaryMappingsFileName = FormNameString(
                                    CscSecurity.ShadowDatabaseName,
                                    ULID_TEMPORARY_SID_MAPPINGS);

    MappingsFileName = FormNameString(
                           CscSecurity.ShadowDatabaseName,
                           ULID_SID_MAPPINGS);

    if ((TemporaryMappingsFileName != NULL) &&
        (MappingsFileName != NULL)) {
        CSCHFILE hNewSidMappingsFile;

        hNewSidMappingsFile = OpenFileLocal(TemporaryMappingsFileName);

        if (hNewSidMappingsFile == CSC_INVALID_FILE_HANDLE) {
            hNewSidMappingsFile = R0OpenFileEx(ACCESS_READWRITE, ACTION_CREATEALWAYS, FILE_ATTRIBUTE_SYSTEM, TemporaryMappingsFileName, FALSE);
        }

        if (hNewSidMappingsFile != CSC_INVALID_FILE_HANDLE) {
            Status = CscSaveSidMappings(
                        hNewSidMappingsFile,
                        CscSecurity.pCscSids);

            if (Status == ERROR_SUCCESS) {
                CloseFileLocal(hNewSidMappingsFile);
                hNewSidMappingsFile = CSC_INVALID_FILE_HANDLE;

                if (CscSecurity.hSidMappingsFile != CSC_INVALID_FILE_HANDLE) {
                    CloseFileLocal(CscSecurity.hSidMappingsFile);
                    CscSecurity.hSidMappingsFile = CSC_INVALID_FILE_HANDLE;
                }

                Status = (DWORD)RenameFileLocal(
                                    TemporaryMappingsFileName,
                                    MappingsFileName);

                if (Status == ERROR_SUCCESS) {
                    if (!vfStopCachingSidFileHandle)
                    {
                        CscSecurity.hSidMappingsFile = OpenFileLocal(MappingsFileName);

                        if (CscSecurity.hSidMappingsFile == CSC_INVALID_FILE_HANDLE) {
                            Status = ERROR_INVALID_DATA;
                        }
                    }
                }
            }
        }
    } else {
        Status = ERROR_NO_SYSTEM_RESOURCES;
    }

    if (MappingsFileName != NULL) {
        FreeNameString(MappingsFileName);
    }

    if (TemporaryMappingsFileName != NULL) {
        FreeNameString(TemporaryMappingsFileName);
    }

    return Status;
}

CSC_SID_INDEX
CscMapSidToIndex(
    PVOID   pSid,
    ULONG   SidLength)
/*++

Routine Description:

    This routine maps a sid to the appropriate index in the CSC database (
    memory data structure)

Arguments:

    pSid -- the sid which is to be mapped.

    SidLength - the length of the Sid

Return Value:

    either valid index or CSC_INVALID_SID_INDEX if none was found.

Notes:

    This routine assumes that Sids are DWORD aligned.

--*/
{
    PCSC_SIDS pCscSids = CscSecurity.pCscSids;

    CSC_SID_INDEX SidIndex = CSC_INVALID_SID_INDEX;

    if ((pSid == CSC_GUEST_SID) &&
        (SidLength == CSC_GUEST_SID_LENGTH)) {
        return CSC_GUEST_SID_INDEX;
    }

    if (pCscSids != NULL) {
        CSC_SID_INDEX i;

        for (i=0; i < pCscSids->NumberOfSids; i++) {
            if (pCscSids->Sids[i].SidLength == SidLength) {
                PBYTE  pSid1,pSid2;

                ULONG  NumberOfBytes;

                pSid1 = (PBYTE)pSid;
                pSid2 = (PBYTE)pCscSids->Sids[i].pSid;

                NumberOfBytes = SidLength;

                for (;;) {
                    if (NumberOfBytes >= sizeof(ULONG)) {
                        if (*((PULONG)pSid1) != *((PULONG)pSid2)) {
                            break;
                        }

                        pSid1 += sizeof(ULONG);
                        pSid2 += sizeof(ULONG);
                        NumberOfBytes -= sizeof(ULONG);

                        continue;
                    }

                    if (NumberOfBytes >= sizeof(USHORT)) {
                        if (*((PUSHORT)pSid1) != *((PUSHORT)pSid2)) {
                            break;
                        }

                        pSid1 += sizeof(USHORT);
                        pSid2 += sizeof(USHORT);
                        NumberOfBytes -= sizeof(USHORT);
                    }

                    if (NumberOfBytes == sizeof(BYTE)) {
                        if (*((PUSHORT)pSid1) != *((PUSHORT)pSid2)) {
                            break;
                        }

                        NumberOfBytes -= sizeof(BYTE);
                    }

                    break;
                }

                if (NumberOfBytes == 0) {
                    // Since 0 is the invalid index ensure that the valid
                    // sid indices are never zero
                    SidIndex = i + 1;
                    break;
                }
            }
        }
    }

    return SidIndex;
}

DWORD
CscAddSidToDatabase(
    PVOID           pSid,
    ULONG           SidLength,
    PCSC_SID_INDEX  pSidIndex)
/*++

Routine Description:

    This routine maps a sid to the appropriate index in the CSC database (
    memory data structure). If a mapping does not exist a new one is created

Arguments:

    pSid - the sid which is to be mapped.

    SidLength - the length of the Sid

    pSidIndex - set to the newly assingned index on exit

Return Value:

    ERROR_SUCCESS if successful, otherwise appropriate error

Notes:

    This routine assumes that Sids are DWORD aligned.

--*/
{
    DWORD Status = ERROR_SUCCESS;

    ULONG i,NumberOfSids;

    *pSidIndex = CscMapSidToIndex(
                     pSid,
                     SidLength);

    if (*pSidIndex == CSC_INVALID_SID_INDEX) {
        PCSC_SIDS pOldCscSids = NULL;
        PCSC_SIDS pCscSids    = CscSecurity.pCscSids;

        // The Sid does not exist and it needs to be added to the table
        // of mappings

        pOldCscSids = pCscSids;

        if ((pCscSids == NULL) ||
            (pCscSids->MaximumNumberOfSids == pCscSids->NumberOfSids)) {

            NumberOfSids =  (pOldCscSids != NULL)
                            ? pOldCscSids->NumberOfSids
                            : 0;

            NumberOfSids += CSC_SID_QUANTUM;

            // Allocate a new chunk of memory for the sid mapping array and
            // copy over the existing mappings before adding the new ones

            pCscSids = (PCSC_SIDS)AllocMem(
                                      sizeof(CSC_SIDS) +
                                      sizeof(CSC_SID) * NumberOfSids);

            if (pCscSids != NULL) {
                pCscSids->MaximumNumberOfSids = NumberOfSids;
                pCscSids->NumberOfSids = NumberOfSids - CSC_SID_QUANTUM;

                if (pOldCscSids != NULL) {
                    for (i = 0; i < pOldCscSids->NumberOfSids; i++) {
                        pCscSids->Sids[i] = pOldCscSids->Sids[i];
                    }
                }
            } else {
                Status = ERROR_NO_SYSTEM_RESOURCES;
            }
        }

        if ((Status == ERROR_SUCCESS) &&
            (pCscSids->MaximumNumberOfSids > pCscSids->NumberOfSids)) {
            CSC_SID_INDEX SidIndex;

            SidIndex = (CSC_SID_INDEX)pCscSids->NumberOfSids;
            pCscSids->Sids[SidIndex].pSid = AllocMem(SidLength);

            if (pCscSids->Sids[SidIndex].pSid != NULL) {
                PBYTE pSid1, pSid2;
                ULONG NumberOfBytes = SidLength;

                pSid1 = pSid;
                pSid2 = pCscSids->Sids[SidIndex].pSid;

                while (NumberOfBytes > 0) {
                    *pSid2++ = *pSid1++;
                    NumberOfBytes--;
                }

                pCscSids->Sids[SidIndex].SidLength = SidLength;

                *pSidIndex = SidIndex + 1;
                pCscSids->NumberOfSids++;
            } else {
                Status = ERROR_NO_SYSTEM_RESOURCES;
            }
        }

        if (Status == ERROR_SUCCESS) {
            CscSecurity.pCscSids = pCscSids;

            // Save the mappings
            Status = CscWriteOutSidMappings();
        }

        if (Status == ERROR_SUCCESS) {
            if (pOldCscSids != pCscSids) {
                // Walk through and free the old mappings structure
                if (pOldCscSids != NULL) {
                    FreeMem(pOldCscSids);
                }
            }
        } else {
            if ((pCscSids != NULL)&&(pCscSids != pOldCscSids)) {
                FreeMem(pCscSids);
            }

            CscSecurity.pCscSids = pOldCscSids;
        }
    }

    return Status;
}

DWORD
CscRemoveSidFromDatabase(
    PVOID   pSid,
    ULONG   SidLength)
/*++

Routine Description:

    This routine removes a mapping for a sid to the appropriate index in the CSC
    database

Arguments:

    pSid - the sid which is to be mapped.

    SidLength - the length of the Sid

Return Value:

    ERROR_SUCCESS if successful, otherwise appropriate error

Notes:

    This routine assumes that Sids are DWORD aligned.

--*/
{
    DWORD Status = ERROR_SUCCESS;
    ULONG SidIndex,i;

    SidIndex = CscMapSidToIndex(
                   pSid,
                   SidLength);

    if (SidIndex != CSC_INVALID_SID_INDEX) {
        // Slide all the Sids following this index by 1 and decrement the
        // number of sids for which mappings exist.

        for (i = SidIndex + 1; i < CscSecurity.pCscSids->NumberOfSids; i++) {
            CscSecurity.pCscSids->Sids[i-1] = CscSecurity.pCscSids->Sids[i];
        }

        CscSecurity.pCscSids->NumberOfSids -= 1;

        // Save the new mappings onto the persistent store
        Status = CscWriteOutSidMappings();
    }

    return Status;
}

BOOL
EnableHandleCachingSidFile(
    BOOL    fEnable
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    BOOL    fOldState = vfStopCachingSidFileHandle;

    if (!fEnable)
    {
        if (vfStopCachingSidFileHandle == FALSE)
        {
            if (CscSecurity.hSidMappingsFile != CSC_INVALID_FILE_HANDLE)
            {
                CloseFileLocal(CscSecurity.hSidMappingsFile);
                CscSecurity.hSidMappingsFile = CSC_INVALID_FILE_HANDLE;
            }
            vfStopCachingSidFileHandle = TRUE;
        }
    }
    else
    {
        vfStopCachingSidFileHandle = FALSE;
    }

    return fOldState;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\record.mgr\oslayer.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

oslayer.h

Abstract:

    OS layer API definition. These are the functions which the record manager uses
    to manage the CSC record database. This allows us to port the record manager
    to NT and win9x platforms without affecting the record manager code in any
    significant manner.

    Contents:

Author:
    Shishir Pardikar


Environment:

    kernel mode.

Revision History:

    1-1-94    original

--*/

//let's take this opportunity to null out the rdbss/minirdr style dbgtrace/log
//if we're not on NT

typedef void                *CSCHFILE;
#define CSCHFILE_NULL       NULL

#ifndef CSC_RECORDMANAGER_WINNT
#ifndef NOTHING
#define NOTHING
#endif
#define RxLog(Args)   {NOTHING;}
#define RxDbgTrace(INDENT,CONTROLPOINTNUM,Z)     {NOTHING;}
#define DbgBreakPoint() {NOTHING;}
#define FILE_ATTRIBUTE_NORMAL   0
#endif

#undef CSC_BUILD_W_PROGRESS_CATCHERS
#ifdef RX_PRIVATE_BUILD
#ifdef CSC_RECORDMANAGER_WINNT
#if defined(_X86_)
#define CSC_BUILD_W_PROGRESS_CATCHERS
#else
#endif
#endif
#endif

#if !DBG
#undef CSC_BUILD_W_PROGRESS_CATCHERS
#endif

#ifdef CSC_BUILD_W_PROGRESS_CATCHERS
typedef struct _CSC_PROGRESS_BLOCK {
    ULONG Counter;
    PVOID NearTop;
    PVOID NearArgs;
    ULONG Progress;
    ULONG LastBit;
    ULONG Loops;
    ULONG StackRemaining;
    PULONG RetAddrP;
    ULONG RetAddr;
    ULONG SignatureOfEnd;
} CSC_PROGRESS_BLOCK, *PCSC_PROGRESS_BLOCK;

VOID
CscProgressInit (
    PCSC_PROGRESS_BLOCK ProgressBlock,
    ULONG Counter,
    PVOID NearArgs
    );
VOID
CscProgress (
    PCSC_PROGRESS_BLOCK ProgressBlock,
    ULONG Bit
    );
extern ULONG DelShadowInternalEntries;

#define JOE_DECL_PROGRESS()  CSC_PROGRESS_BLOCK  JOE_DECL_CURRENT_PROGRESS
#define JOE_INIT_PROGRESS(counter,nearargs) \
     {CscProgressInit(&JOE_DECL_CURRENT_PROGRESS,counter,nearargs);}
#define JOE_PROGRESS(bit) \
     {CscProgress(&JOE_DECL_CURRENT_PROGRESS,bit);}
#else
#define JOE_DECL_PROGRESS()
#define JOE_INIT_PROGRESS(counter,nearargs)
#define JOE_PROGRESS(bit)
#endif

#define  PUBLIC
#define  PRIVATE
#define  COPY_BUFF_SIZE 4096
#ifndef UNICODE
#define  UNICODE  2
#endif


#define  ATTRIB_DEL_ANY     0x0007   // Attrib passed to ring0 delete

//typedef USHORT                USHORT;
//typedef ULONG         ULONG;

#ifndef CSC_RECORDMANAGER_WINNT
typedef void (PUBLIC       *FARPROC)(void);
#endif


typedef  pioreq   PIOREQ;
typedef struct ParsedPath  *PPP, far *LPPP;
typedef struct PathElement  *PPE, far *LPPE;
typedef LPVOID             HFREMOTE;
typedef  HFREMOTE far *    LPHFREMOTE;
typedef PIOREQ             LPPATH;
typedef LPSTR              LPTSTR;
typedef char               tchar;
typedef  _FILETIME         FILETIME, *LPFILETIME;

typedef struct _WIN32_FIND_DATAA _WIN32_FIND_DATAA, far *LPFIND32A;
struct _WIN32_FIND_DATAA {
        ULONG           dwFileAttributes;
        struct _FILETIME        ftCreationTime;
        struct _FILETIME        ftLastAccessTime;
        struct _FILETIME        ftLastWriteTime;
        ULONG           nFileSizeHigh;
        ULONG           nFileSizeLow;
        ULONG           dwReserved0;
        ULONG           dwReserved1;
        UCHAR           cFileName[MAX_PATH];    /* includes NUL */
        UCHAR           cAlternateFileName[14]; /* includes NUL */
};      /* _WIN32_FIND_DATAA */

#define FILE_ATTRIBUTE_ALL (FILE_ATTRIBUTE_READONLY| FILE_ATTRIBUTE_HIDDEN \
                           | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_DIRECTORY \
                           | FILE_ATTRIBUTE_ARCHIVE)

#define  IsFile(dwAttr) (!((dwAttr) & (FILE_ATTRIBUTE_DIRECTORY)))
typedef int (*PATHPROC)(USHORT *, USHORT *, LPVOID);



#define FLAG_RW_OSLAYER_INSTRUMENT      0x00000001
#define FLAG_RW_OSLAYER_PAGED_BUFFER    0x00000002

#define FLAG_CREATE_OSLAYER_INSTRUMENT      0x00000001
#define FLAG_CREATE_OSLAYER_ALL_ACCESS      0x00000002

#if defined(BITCOPY)
#define FLAG_CREATE_OSLAYER_OPEN_STRM       0x00000004
#endif // defined(BITCOPY)

#include "hook.h"


#ifdef CSC_RECORDMANAGER_WINNT
//this comes from shadow.asm on win95......
#define GetCurThreadHandle() (PtrToUlong(KeGetCurrentThread()))
#define CheckHeap(a) {NOTHING;}
extern ULONG EventLogForOpenFailure;
#endif //ifdef CSC_RECORDMANAGER_WINNT

#define SizeofFindRemote  (sizeof(FINDINFO)+sizeof(ioreq)+sizeof(WIN32_FIND_DATA))
#define LpIoreqFromFindInfo(pFindInfo)  ((PIOREQ)((LPBYTE)(pFindInfo)+sizeof(FINDINFO)))
#define LpFind32FromFindInfo(pFindInfo) ((LPFIND32)((LPBYTE)(pFindInfo)+sizeof(FINDINFO)+sizeof(ioreq)))
#define LpFind32FromHfRemote(HfRemote) ((LPFIND32)((LPBYTE)(HfRemote)+sizeof(FINDINFO)+sizeof(ioreq)))

#define SizeofFileRemote  (sizeof(FILEINFO)+sizeof(ioreq))
#define LpIoreqFromFileInfo(pFileInfo)  ((PIOREQ)((LPBYTE)(pFileInfo)+sizeof(FILEINFO)))


CSCHFILE CreateFileLocal(LPSTR lpName);
/*++

Routine Description:

    This routine creates a file on the local drive, if it doesn't exist. If it exists, it truncates
    the file.

Arguments:

    lpName  Fully qualified path name. On NT it is prefixed by \DosDevice\

Returns:

    if successful, returns a file handle that can be used in read and write calls.
    If it fails, it retruns NULL.

Notes:

    Need a scheme to return the actual error code

--*/

CSCHFILE OpenFileLocal(LPSTR lpName);
/*++

Routine Description:

    This routine opens a file on the local drive if it exists. If it doesn't exist the call fails

Arguments:

    lpName  Fully qualified path name. On NT it is prefixed by \DosDevice\

Returns:

    if successful, returns a file handle that can be used in read and write calls.
    If it fails, it retruns NULL.

Notes:

    Need a scheme to return the actual error code

--*/
int DeleteFileLocal(LPSTR lpName, USHORT usAttrib);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/
int FileExists (LPSTR lpName);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/
long ReadFileLocal (CSCHFILE handle, ULONG pos, LPVOID lpBuff,  long lCount);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/
long WriteFileLocal (CSCHFILE handle, ULONG pos, LPVOID lpBuff, long lCount);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/
long ReadFileInContextLocal (CSCHFILE, ULONG, LPVOID, long);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/
long WriteFileInContextLocal (CSCHFILE, ULONG, LPVOID, long);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/
ULONG CloseFileLocal (CSCHFILE handle);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/
int GetFileSizeLocal (CSCHFILE, PULONG);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/
int GetDiskFreeSpaceLocal(int indx
   , ULONG *lpuSectorsPerCluster
   , ULONG *lpuBytesPerSector
   , ULONG *lpuFreeClusters
   , ULONG *lpuTotalClusters
   );
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/

int CreateFileRemote(LPPATH lpPath, LPHFREMOTE);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/
int OpenFileRemote(LPPATH lpPath, LPHFREMOTE);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/
int OpenFileRemoteEx(LPPATH lpPath, UCHAR uchAccess, USHORT usAction,ULONG ulAttr, LPHFREMOTE);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/
int ReadFileRemote (HFREMOTE handle, PIOREQ pir, ULONG pos, LPVOID lpBuff,  ULONG count);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/
int WriteFileRemote (HFREMOTE handle, PIOREQ pir, ULONG pos, LPVOID lpBuff, ULONG count);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/
int CloseFileRemote (HFREMOTE handle, PIOREQ pir);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/

int GetAttributesLocal (LPSTR lpPath, ULONG *lpuAttr);
/*++

Routine Description:

    Return the attributes of the file

Arguments:

    lpPath  A fully qualified path

    lpuAttr contains the attributes on return

Returns:

    0 if successfull, < 0 otherwise

Notes:


--*/

int GetAttributesLocalEx (LPSTR lpPath, BOOL fFile, ULONG *lpuAttr);
/*++

Routine Description:

    Return the attributes of the file/directory

Arguments:

    lpPath  A fully qualified path

    fFile   if TURE, the object is a file, else it is a directory

    lpuAttr contains the attributes on return

Returns:

    0 if successfull, < 0 otherwise

Notes:


--*/


int SetAttributesLocal (LPSTR, ULONG);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/
int RenameFileLocal (LPSTR, LPSTR);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/
int FileLockLocal(CSCHFILE, ULONG, ULONG, ULONG, BOOL);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/

int FindOpenRemote (LPPATH lpPath, LPHFREMOTE);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/
int FindNextRemote (HFREMOTE handle, PIOREQ pir);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/
int FindCloseRemote (HFREMOTE handle, PIOREQ pir);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/

int CloseAllRemoteFiles(PRESOURCE);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/
int CloseAllRemoteFinds(PRESOURCE);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/

LPVOID AllocMem (ULONG uSize);
//BUGBUG.REVIEW AllocMem should distinguish between paged and nonpaged pool
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/
#ifndef CSC_RECORDMANAGER_WINNT
VOID FreeMem (LPVOID lpBuff);
VOID CheckHeap(LPVOID lpBuff);
#else
INLINE
VOID
FreeMem (
    PVOID p___
    )
{RxFreePool(p___);}
#endif //ifndef CSC_RECORDMANAGER_WINNT
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/

//BUGBUG.REVIEW this was added here because it is called from record.c
CSCHFILE R0OpenFile (USHORT usOpenFlags, UCHAR bAction, LPSTR lpPath);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/

//for the NT build these are added here AND the code is also moved from
//hook.c to oslayer.c since these routines are called from oslayer.c

PELEM PAllocElem (int cbSize);
void FreeElem (PELEM pElem);
void LinkElem (PELEM pElem, PPELEM ppheadElem);
PELEM PUnlinkElem (PELEM pElem, PPELEM ppheadElem);
int ReinitializeDatabase();
BOOL IsSpecialApp(VOID);
int DisconnectAllByName(LPPE lppeRes);
int PRIVATE DeleteShadowHelper(BOOL fMarkDeleted, HSHADOW, HSHADOW);
int InitShadowDB(VOID);

CSCHFILE OpenFileLocalEx(LPSTR lpPath, BOOL fInstrument);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/
long ReadFileLocalEx(CSCHFILE handle, ULONG pos, LPVOID pBuff, long  lCount, BOOL fInstrument);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/
long WriteFileLocalEx(CSCHFILE handle, ULONG pos, LPVOID lpBuff, long lCount, BOOL fInstrument);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/
long ReadFileLocalEx2(CSCHFILE handle, ULONG pos, LPVOID pBuff, long  lCount, ULONG flags);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/
long WriteFileLocalEx2(CSCHFILE handle, ULONG pos, LPVOID lpBuff, long lCount, ULONG flags);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/
CSCHFILE R0OpenFileEx(USHORT  usOpenFlags, UCHAR   bAction, ULONG uAttr, LPSTR   lpPath, BOOL fInstrument);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/

VOID GetSystemTime(_FILETIME *lpft);
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/

int
CreateDirectoryLocal(
    LPSTR   lpPath
);
/*++

Routine Description:

    This routine creates a directory if it doesn't exist.

Arguments:

    lpPath  Fully qualified directory path. On NT, this is of the form \DosDevice\c:\winnt\csc\d0
            On win95 the \DosDevice\ part is missing
Returns:


Notes:


--*/


LPVOID
AllocMemPaged(
    unsigned long   ulSize
    );

/*++

Routine Description:

    This routine allows allocating paged memory

Arguments:

Returns:


Notes:


--*/

VOID
FreeMemPaged(
    LPVOID  lpMemPaqged
    );

/*++

Routine Description:

    This routine allows freeing paged memory

Arguments:

Returns:


Notes:

    On win95 paged and fixed memory come from totally different allocators, so the appropriate
    deallocator has to be called for freeing it.


--*/
ULONG
GetTimeInSecondsSince1970(
    VOID
    );


BOOL
IterateOnUNCPathElements(
    USHORT  *lpuPath,
    PATHPROC lpfn,
    LPVOID  lpCookie
    );

BOOL
IsPathUNC(
    USHORT      *lpuPath,
    int         cntMaxChars
    );


VOID
SetLastErrorLocal(
    DWORD   dwError
    );

DWORD
GetLastErrorLocal(
    VOID
    );
    
int
FindNextFileLocal(
    CSCHFILE handle,
    _WIN32_FIND_DATAA   *lpFind32A
    );

CSCHFILE
FindFirstFileLocal(
    LPSTR   lpPath,
    _WIN32_FIND_DATAA   *lpFind32A
    );
    
int
FindCloseLocal(
    CSCHFILE handle
    );

BOOL
HasStreamSupport(
    CSCHFILE handle,
    BOOL    *lpfResult
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\record.mgr\record.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Record.c

Abstract:

    This is the set of definitions that describes the actual contents of the
    record manager files. Records are actually of two types: "headers" that
    describe the structural content of a file and "records" that contain the
    actual mappings.

Author:

    Shishir Pardikar     [Shishirp]      01-jan-1995

Revision History:

    Joe Linn             [JoeLinn]       20-mar-97    Ported for use on NT

--*/

#ifndef RECORD_INCLUDED
#define RECORD_INCLUDED

#define  REC_EMPTY    'E'    // Record is empty
#define  REC_DATA     'D'    // Record has valid data
#define  REC_OVERFLOW 'O'    // This is an overflow record
#define  REC_SKIP     'S'    // This is record that should be skipped

#define Q_GETFIRST      1
#define Q_GETNEXT       2
#define Q_GETLAST       3
#define Q_GETPREV       4


#define  DB_SHADOW      1
#define  DB_HINT        2

#define  IsLeaf(ulidShadow)   (((ulidShadow) & 0x80000000) != 0)
#define  OVF_MASK       0xff
#define  MODFLAG_MASK   (~OVF_MASK)

#define  ULID_SHARE            1L
#define  ULID_PQ                (ULID_SHARE+1)
#define  ULID_SID_MAPPINGS      (ULID_PQ + 1)
#define  ULID_TEMPORARY_SID_MAPPINGS (ULID_SID_MAPPINGS + 1)
#define  ULID_TEMP1             (ULID_TEMPORARY_SID_MAPPINGS + 1)
#define  ULID_TEMP2             (ULID_TEMP1 + 1)

#ifdef OLD_INODE_SCHEME
#define  ULID_INODE             (ULID_SHARE+2) // we need to phase this out
#endif // OLD_INODE_SCHEME

#define  ULID_FIRST_USER_DIR    (ULID_PQ+15)    // 14 more special inodes available

#define  INODE_STRING_LENGTH        8
#define  SUBDIR_STRING_LENGTH       2

#define  CSCDB_SUBDIR_COUNT         8
#define  CSCDbSubdirFirstChar()     'd'
#define  CSCDbSubdirSecondChar(ULID_INODE) ((char)(((ULID_INODE)>=ULID_FIRST_USER_DIR)?('1'+((ULID_INODE)&0x7)):0))

#define  MAX_HINT_PRI            0xfe
#define  MAX_PRI                ((ULONG)254)
#define  MIN_PRI                ((ULONG)0)
#define  INVALID_REC            0
#define  INVALID_SHADOW         0

#define CSC_DATABASE_ERROR_INVALID_HEADER       0x00000001
#define CSC_DATABASE_ERROR_INVALID_OVF_COUNT    0x00000002
#define CSC_DATABASE_ERROR_TRUNCATED_INODE      0x00000004
#define CSC_DATABASE_ERROR_MISSING_INODE        0x00000008


#define  OvfCount(lpGR)             (((LPGENERICREC)(lpGR))->uchFlags & OVF_MASK)
#define  ClearOvfCount(lpGR)        (((LPGENERICREC)(lpGR))->uchFlags &= ~OVF_MASK)
#define  SetOvfCount(lpGR, cOvf)    {ClearOvfCount(lpGR);\
                                     ((LPGENERICREC)(lpGR))->uchFlags |= (cOvf) & OVF_MASK;}

#define  ModFlag(lpGR)              (((LPGENERICREC)(lpGR))->uchFlags & MODFLAG_MASK)
#define  ClearModFlag(lpGR)        (((LPGENERICREC)(lpGR))->uchFlags &= ~MODFLAG_MASK)
#define  SetModFlag(lpGR, uchFlag)    {ClearModFlag(lpGR);\
                                     ((LPGENERICREC)(lpGR))->uchFlags |= (uchFlag) & MODFLAG_MASK;}

#define  HeaderModFlag(lpGH)              (((LPGENERICHEADER)(lpGH))->uchFlags & MODFLAG_MASK)
#define  ClearHeaderModFlag(lpGH)        (((LPGENERICHEADER)(lpGH))->uchFlags &= ~MODFLAG_MASK)
#define  SetHeaderModFlag(lpGH, uchFlag)    {ClearHeaderModFlag(lpGH);\
                                     ((LPGENERICHEADER)(lpGH))->uchFlags |= (uchFlag) & MODFLAG_MASK;}

#define  RealFileSize(dwFileSize)   (((dwFileSize)+vdwClusterSizeMinusOne) & vdwClusterSizeMask)

#define  STATUS_WRITING MODFLAG_MASK

// HEADER types have three things in common:
//   1) they all have the same common part (RECORDMANAGER_COMMON_HEADER)
//   2) they are all 64bytes long (GENERICHEADER)
//   3) they MAY have optional addition information in the space after the common part
// we use anonymous union and struct components to achieve this in a maintainable way

typedef struct _RECORDMANAGER_COMMON_HEADER {
   UCHAR    uchType; //
   UCHAR    uchFlags;  //
   USHORT   uRecSize;   //  Size in bytes of one record
   ULONG    ulRecords;  //  # of records in the file
   LONG     lFirstRec;  //  Position of the first record
   ULONG    ulVersion;  //  Version # of the persistent database
} RECORDMANAGER_COMMON_HEADER, *PRECORDMANAGER_COMMON_HEADER;

typedef struct tagGENERICHEADER
   {
       union {
           RECORDMANAGER_COMMON_HEADER;
           UCHAR Ensure64byteSize[64];
       };
   }
GENERICHEADER, FAR *LPGENERICHEADER;


//no additional info on a INODEHEADER

typedef struct tagINODEHEADER
   {
       GENERICHEADER;
   }
INODEHEADER, FAR *LPINODEHEADER;



// servers have a bit of extra info in the padding

typedef struct tagSHAREHEADER
   {
       union {
           GENERICHEADER;
           struct {
               RECORDMANAGER_COMMON_HEADER spacer; //move past the common part
               ULONG        uFlags;   // General flags which define the state of the database
               STOREDATA    sMax;     // Maximum allowed storage
               STOREDATA    sCur;     // Current stats
           };
       };
   }
   SHAREHEADER, FAR *LPSHAREHEADER;

#define FLAG_SHAREHEADER_DATABASE_OPEN 0x00000001  // set when the database is opened
                                                    // and cleared when closed.
#define FLAG_SHAREHEADER_DATABASE_ENCRYPTED    0x00000002


typedef struct tagFILEHEADER
   {
       union {
           GENERICHEADER;
           struct {
               RECORDMANAGER_COMMON_HEADER spacer; //move past the common part
               ULONG  ulidNextShadow;  // #  of next inode to be used
               ULONG  ulsizeShadow;    // # Bytes shadowed
               ULONG  ulidShare;      // server index,
               ULONG  ulidDir;         // directory file inode #
               USHORT ucShadows;       // # shadowed entries
           };
       };
   }
   FILEHEADER, FAR *LPFILEHEADER;

typedef struct tagQHEADER
   {
       union {
           GENERICHEADER;
           struct {
               RECORDMANAGER_COMMON_HEADER spacer; //move past the common part
               ULONG          ulrecHead;  // Head of the queue
               ULONG          ulrecTail;  // Tail of the queue
           };
       };
   }
   QHEADER, PRIQHEADER, FAR *LPQHEADER, FAR *LPPRIQHEADER;

// RECORD types are not quite as similar:
//   1) they all have the same common part (RECORDMANAGER_COMMON_RECORD)
//   2) BUT, they are not arbitrarily padded.
//   3) addition information ordinarily follows the common part
// we use anonymous union and struct components to achieve this in a maintainable way


typedef struct _RECORDMANAGER_COMMON_RECORD {
   UCHAR  uchType; //
   UCHAR  uchFlags;  //
   //one of the records calls it usStatus....others call it uStatus...sigh.....
   union {
       USHORT uStatus;          // Shadow Status
       USHORT usStatus;          // Shadow Status
   };
} RECORDMANAGER_COMMON_RECORD, *PRECORDMANAGER_COMMON_RECORD;

typedef struct _RECORDMANAGER_BOOKKEEPING_FIELDS {
   UCHAR  uchRefPri;     // Reference Priority
   UCHAR  uchIHPri;      // Inherited Hint Pri
   UCHAR  uchHintFlags;  // Flags specific to hints
   UCHAR  uchHintPri;    // Hint Priority if a hint
} RECORDMANAGER_BOOKKEEPING_FIELDS, *LPRECORDMANAGER_BOOKKEEPING_FIELDS;

typedef struct _RECORDMANAGER_SECURITY_CONTEXT {
    ULONG Context;
    ULONG Context2;
    ULONG Context3;
    ULONG Context4;
} RECORDMANAGER_SECURITY_CONTEXT, *LPRECORDMANAGER_SECURITY_CONTEXT;

typedef struct tagGENERICREC
{
    RECORDMANAGER_COMMON_RECORD;
}
GENERICREC, FAR *LPGENERICREC;


typedef struct tagINODEREC
{
    RECORDMANAGER_COMMON_RECORD;    //uStatus is not used....
    ULONG  ulidShadow; // Shadow File INODE
}
INODEREC, FAR *LPINODEREC;


// Share record format

// ACHTUNG in someplaces in cshadow.c, it is assumed that tagSHAREREC is smaller than
// tagFILERECEXT structure. This will always be true, but it is important to note
// the assumption

typedef struct tagSHAREREC
{
    RECORDMANAGER_COMMON_RECORD;            //                          4

    ULONG           ulidShadow;             // Root INODE #             8
    DWORD           dwFileAttrib;           // root inode attributes    12
    FILETIME        ftLastWriteTime;        // Last Write Time          20
    FILETIME        ftOrgTime;              // server time              28

    USHORT          usRootStatus;           //                          30
    UCHAR           uchHintFlags;           // Hint flags on the root   31
    UCHAR           uchHintPri;             // pin count for the root   32
    RECORDMANAGER_SECURITY_CONTEXT sShareSecurity;//                    48
    RECORDMANAGER_SECURITY_CONTEXT sRootSecurity;//                     64
    ULONG   Reserved;                       //                          68
    ULONG   Reserved2;                      //                          72

    ULONG  ulShare;                        //                          80
    USHORT rgPath[64];                      //                          208 MAX_SHARE_SHARE_NAME_FOR_CSC defined in shdcom.h. Both must
                   // be kept in sync.
}
SHAREREC, FAR *LPSHAREREC;
//#pragma pack()      //packing off

#define  FILEREC_LOCALLY_CREATED 0x0001
#define  FILEREC_DIRTY           0x0002   // FILEREC_XXX
#define  FILEREC_BUSY            0x0004
#define  FILEREC_SPARSE          0x0008
#define  FILEREC_SUSPECT         0x0010
#define  FILEREC_DELETED         0x0020
#define  FILEREC_STALE           0x0040


// File record format
typedef struct tagFILEREC
{
    RECORDMANAGER_COMMON_RECORD;                                        // 4

    union
    {
        struct
        {
            // INODEREC part
            ULONG           ulidShadow;       // Shadow File INODE #    // 8
            ULONG           ulFileSize;       // FileSize               // 12
            ULONG           ulidShadowOrg;    // Original Inode         // 16
            DWORD           dwFileAttrib;     // File attributes        // 20
            FILETIME        ftLastWriteTime;  // File Write Time        // 28

            RECORDMANAGER_BOOKKEEPING_FIELDS;                           // 32
            RECORDMANAGER_SECURITY_CONTEXT Security;                    // 48

            ULONG           Reserved;           // for future use       // 52
            ULONG           Reserved2;          // for future use       // 56
            ULONG           Reserved3;          // for future use       // 60
            ULONG           ulLastRefreshTime;  // time                 // 64
                                                // when this entry was
                                                // refreshed (in seconds since 1970)

            FILETIME        ftOrgTime;        // Original Time          // 72


            USHORT          rgw83Name[14];     // 83 Name               // 100
            USHORT          rgwName[14];      // LFN part               // 128
        };

        USHORT  rgwOvf[1];   // used for copying overflow records
    };
}
FILEREC, FAR *LPFILEREC;


typedef struct tagQREC
{
    RECORDMANAGER_COMMON_RECORD;
    ULONG          ulidShare;          // Share ID
    ULONG          ulidDir;             // Dir ID
    ULONG          ulidShadow;          // Shadow ID
    ULONG          ulrecDirEntry;       // rec # of the entry in directory ulidDir
    ULONG          ulrecPrev;           // Predecessor record #
    ULONG          ulrecNext;           // Successor   record #
    RECORDMANAGER_BOOKKEEPING_FIELDS;
}
QREC, PRIQREC, FAR *LPQREC, FAR *LPPRIQREC;

// ACHTUNG in someplaces in cshadow.c, it is assumed that tagSHAREREC is smaller than
// tagFILERECEXT structure. This will always be true, but it is important to note
// the assumption
typedef struct tagFILERECEXT
{
    FILEREC sFR;
    FILEREC rgsSR[4];   // fits a record with LFN of MAX_PATH unicode characters
}
FILERECEXT, FAR *LPFILERECEXT;

// # of overflow records for LFN
#define MAX_OVERFLOW_FILEREC_RECORDS    ((sizeof(FILERECEXT)/sizeof(FILEREC)) - 1)

#define MAX_OVERFLOW_RECORDS    MAX_OVERFLOW_FILEREC_RECORDS

// amount of data an overflow file record will hold
#define SIZEOF_OVERFLOW_FILEREC     (sizeof(FILEREC) - sizeof(RECORDMANAGER_COMMON_RECORD))

#define  CPFR_NONE                  0x0000
#define  CPFR_INITREC               0x0001
#define  CPFR_COPYNAME              0x0002

#define  mCheckBit(uFlags, uBit)  ((uFlags) & (uBit))
#define  mSetBits(uFlags, uBits)    ((uFlags) |= (uBits))
#define  mClearBits(uFlags, uBits)    ((uFlags) &= ~(uBits))


#define  mHintFlags(lpFind32) ((lpFind32)->dwReserved0)
#define  mHintPri(lpFind32)   ((lpFind32)->dwReserved1)

// how inodes are created
#define InodeFromRec(ulRec, fFile)  ((ulRec+ULID_FIRST_USER_DIR-1) | ((fFile)?0x80000000:0))
#define RecFromInode(hShadow)       ((hShadow & 0x7fffffff) - (ULID_FIRST_USER_DIR-1))
#define IsDirInode(hShadow)         ((!(hShadow & 0x80000000)) && ((hShadow & 0x7fffffff)>=ULID_FIRST_USER_DIR))

#define NT_DB_PREFIX "\\DosDevices\\"


typedef int (PUBLIC *EDITCMPPROC)(LPVOID, LPVOID);

extern DWORD vdwClusterSizeMinusOne, vdwClusterSizeMask;

BOOL
PUBLIC
FExistsRecDB(
    LPSTR    lpszLocation
    );

LPVOID
PUBLIC                                   // ret
OpenRecDB(                                              //
    LPSTR  lpszLocation,        // database directory
    LPSTR  lpszUserName,        // name (not valid any more)
    DWORD   dwDefDataSizeHigh,  //high dword of max size of unpinned data
    DWORD   dwDefDataSizeLow,   //low dword of max size of pinned data
    DWORD   dwClusterSize,      // clustersize of the disk, used to calculate
                                // the actual amount of disk consumed
    BOOL    fReinit,            // reinitialize, even if it exists
    BOOL    *lpfNew,            // returns whether the database was newly recreated
    ULONG   *pulGlobalStatus    // returns the current globalstatus of the database
);

int
PUBLIC
CloseRecDB(
    LPVOID    lpdbID
);

int
QueryRecDB(
    LPTSTR  lpszLocation,       // database directory, must be MAX_PATH
    LPTSTR  lpszUserName,       // name (not valid any more)
    DWORD   *lpdwDefDataSizeHigh,  //high dword of max size of unpinned data
    DWORD   *lpdwDefDataSizeLow,   //low dword of max size of pinned data
    DWORD   *lpdwClusterSize      // clustersize of the disk, used to calculate
    );

ULONG PUBLIC FindFileRecord(LPVOID, ULONG, USHORT *, LPFILERECEXT);
int PUBLIC FindFileRecFromInode(LPVOID, ULONG, ULONG, ULONG, LPFILERECEXT);
ULONG PUBLIC FindShareRecord(LPVOID, USHORT *, LPSHAREREC);
ULONG PUBLIC FindSharerecFromInode(LPVOID, ULONG, LPSHAREREC);
ULONG PUBLIC FindSharerecFromShare(LPVOID, ULONG, LPSHAREREC);
ULONG PUBLIC AddShareRecord(LPVOID, LPSHAREREC);
int PUBLIC DeleteShareRecord(LPVOID, ULONG);
int   PUBLIC GetShareRecord(LPVOID, ULONG, LPSHAREREC);
int PUBLIC SetShareRecord(LPVOID, ULONG, LPSHAREREC);
ULONG PUBLIC AddFileRecordFR(LPVOID, ULONG, LPFILERECEXT);
int PUBLIC DeleteFileRecord(LPVOID, ULONG, USHORT *, LPFILERECEXT);

int PUBLIC DeleteFileRecFromInode(LPVOID, ULONG, ULONG, ULONG, LPFILERECEXT);
int PUBLIC UpdateFileRecFromInode(
    LPVOID  lpdbID,
    ULONG   ulidDir,
    ULONG   hShadow,
    ULONG   ulrecDirEntry,
    LPFILERECEXT    lpFR
    );
int PUBLIC UpdateFileRecFromInodeEx(
    LPVOID  lpdbID,
    ULONG   ulidDir,
    ULONG   hShadow,
    ULONG   ulrecDirEntry,
    LPFILERECEXT    lpFR,
    BOOL    fCompareInodes
    );
int PUBLIC ReadFileRecord(LPVOID, ULONG, LPGENERICHEADER, ULONG, LPFILERECEXT);
int DeleteInodeFile(LPVOID, ULONG);
int TruncateInodeFile(LPVOID, ULONG);
int PUBLIC CreateDirInode(LPVOID, ULONG, ULONG, ULONG);
int SetInodeAttributes(LPVOID, ULONG, ULONG);
int GetInodeAttributes(LPVOID, ULONG, ULONG *);

CSCHFILE PUBLIC BeginSeqReadPQ(LPVOID);
int PUBLIC SeqReadQ(CSCHFILE, LPQREC, LPQREC, USHORT);
int PUBLIC EndSeqReadPQ(CSCHFILE);
int PUBLIC AddPriQRecord(LPVOID, ULONG, ULONG, ULONG, ULONG, ULONG, ULONG, ULONG, ULONG, ULONG);
int PUBLIC DeletePriQRecord(LPVOID, ULONG, ULONG, LPPRIQREC);
int PUBLIC FindPriQRecord(LPVOID, ULONG, ULONG, LPPRIQREC);
int FindPriQRecordInternal(
    LPTSTR      lpdbID,
    ULONG       ulidShadow,
    LPPRIQREC   lpSrc
    );
int PUBLIC UpdatePriQRecord(LPVOID, ULONG, ULONG, LPPRIQREC);
int PUBLIC UpdatePriQRecordAndRelink(
    LPVOID      lpdbID,
    ULONG       ulidDir,
    ULONG       ulidShadow,
    LPPRIQREC   lpPQ
    );
int PUBLIC GetInodeFileSize(LPVOID, ULONG, ULONG far *);
int PUBLIC AddStoreData(LPVOID, LPSTOREDATA);
int PUBLIC SubtractStoreData(LPVOID, LPSTOREDATA);
int PUBLIC GetStoreData(LPVOID, LPSTOREDATA);
ULONG PUBLIC UlAllocInode(LPVOID, ULONG, BOOL);
int PUBLIC FreeInode(LPVOID, ULONG);
BOOL PUBLIC FInodeIsFile(LPVOID, ULONG, ULONG);
int FindAncestorsFromInode(LPVOID, ULONG, ULONG *, ULONG *);
void  PUBLIC CopyFindInfoToFilerec(LPFIND32 lpFind32, LPFILERECEXT lpFR, ULONG uFlags);
void PUBLIC CopyNamesToFilerec(LPFIND32, LPFILERECEXT);
ULONG PUBLIC AllocFileRecord(LPVOID, ULONG, USHORT *, LPFILERECEXT);
ULONG PUBLIC AllocPQRecord(LPVOID);
ULONG AllocShareRecord(LPVOID, USHORT *);
int ReadDirHeader(LPVOID, ULONG, LPFILEHEADER);
int WriteDirHeader(LPVOID, ULONG, LPFILEHEADER);
int HasDescendents(LPVOID, ULONG, ULONG);

//prototypes added to remove NT compile errors
int PUBLIC  ReadShareHeader(
   LPVOID           lpdbID,
   LPSHAREHEADER   lpSH
   );

int PUBLIC  WriteShareHeader(
   LPVOID           lpdbID,
   LPSHAREHEADER   lpSH
   );

#if defined(BITCOPY)
LPVOID PUBLIC FormAppendNameString(LPVOID, ULONG, LPVOID);
int
DeleteStream(
    LPTSTR      lpdbID,
    ULONG       ulidFile,
    LPTSTR      str2Append
    );
#endif // defined(BITCOPY)

LPVOID PUBLIC FormNameString(LPVOID, ULONG);
VOID PUBLIC FreeNameString(LPVOID);

void PUBLIC CopyFilerecToFindInfo(
   LPFILERECEXT   lpFR,
   LPFIND32    lpFind
   );

BOOL    PUBLIC InitShareRec(LPSHAREREC, USHORT *, ULONG);

int PUBLIC EndSeqReadQ(
   CSCHFILE hf
   );

int PUBLIC ReadHeader(CSCHFILE, LPVOID, USHORT);
int PUBLIC WriteHeader(CSCHFILE, LPVOID, USHORT);
int PUBLIC CopyRecord(LPGENERICREC, LPGENERICREC, USHORT, BOOL);
int PUBLIC ReadRecord(CSCHFILE, LPGENERICHEADER, ULONG, LPGENERICREC);
int PUBLIC WriteRecord(CSCHFILE, LPGENERICHEADER, ULONG, LPGENERICREC);
int
DeleteRecord(
    CSCHFILE   hf,
    LPGENERICHEADER lpGH,
    ULONG           ulRec,
    LPGENERICREC    lpGR,   // source
    LPGENERICREC    lpDst  // optional destination record, at which a copy should be
                            // made before deleting
);
ULONG PUBLIC EditRecordEx(
    ULONG    ulidInode,
    LPGENERICREC lpSrc,
    EDITCMPPROC lpCompareFunc,
    ULONG       ulInputRec,
    ULONG uOp
    );

int PUBLIC  LinkQRecord(
    CSCHFILE     hf,           // This file
    LPQREC    lpNew,        // Insert This record
    ULONG     ulrecNew,     // This is it's location in the file
    ULONG     ulrecPrev,     // This is our Prev's location
    ULONG     ulrecNext      // This is our Next's location
    );
int PUBLIC UnlinkQRecord(CSCHFILE, ULONG, LPQREC);
void PRIVATE InitPriQRec(ULONG, ULONG, ULONG, ULONG, ULONG, ULONG, ULONG, ULONG, ULONG, LPPRIQREC);
int PUBLIC IComparePri(LPPRIQREC, LPPRIQREC);
int PUBLIC IComparePriEx(LPPRIQREC, LPPRIQREC);
int PUBLIC ICompareQInode(LPPRIQREC, LPPRIQREC);

void
InitQHeader(
    LPQHEADER lpQH
    );

int PUBLIC AddQRecord(
    LPSTR   lpQFile,
    ULONG   ulidPQ,
    LPQREC  lpSrc,
    ULONG   ulrecNew,
    EDITCMPPROC fnCmp
    );

int PUBLIC DeleteQRecord(
    LPSTR           lpQFile,
    LPQREC          lpSrc,
    ULONG           ulRec,
    EDITCMPPROC     fnCmp
    );

int PUBLIC ReadHeaderEx(
    CSCHFILE hf,
    LPGENERICHEADER lpGH,
    USHORT sizeBuff,
    BOOL    fInstrument
    );
int PUBLIC WriteHeaderEx(
    CSCHFILE hf,
    LPGENERICHEADER    lpGH,
    USHORT sizeBuff,
    BOOL    fInstrument
    );

int PUBLIC ReadRecordEx(
    CSCHFILE hf,
    LPGENERICHEADER lpGH,
    ULONG  ulRec,
    LPGENERICREC    lpSrc,
    BOOL    fInstrument
    );

int PUBLIC WriteRecordEx(
    CSCHFILE hf,
    LPGENERICHEADER lpGH,
    ULONG  ulRec,
    LPGENERICREC    lpSrc,
    BOOL    fInstrument
    );

BOOL
ReorderQ(
    LPVOID  lpdbID
    );

CSCHFILE
OpenInodeFileAndCacheHandle(
    LPVOID  lpdbID,
    ULONG   ulidInode,
    ULONG   ulOpenMode,
    BOOL    *lpfCached
);

BOOL
EnableHandleCachingInodeFile(
    BOOL    fEnable
    );

int
PUBLIC CopyFileLocal(
    LPVOID  lpdbShadow,
    ULONG   ulidFrom,
    LPSTR   lpszNameTo,
    ULONG   ulAttrib
);

void
BeginInodeTransaction(
    VOID
    );
void
EndInodeTransaction(
    VOID
    );

BOOL
TraversePQ(
    LPVOID      lpdbID
    );

BOOL
RebuildPQ(
    LPVOID      lpdbID
    );

BOOL
TraverseHierarchy(
    LPVOID      lpdbID,
    BOOL        fFix
    );

// this actually defined in recordse.c
BOOL
EnableHandleCachingSidFile(
    BOOL    fEnable
    );

int RenameInode(
    LPTSTR  lpdbID,
    ULONG   ulidFrom,
    ULONG   ulidTo
    );
int
RecreateInode(
    LPTSTR  lpdbID,
    HSHADOW hShadow,
    ULONG   ulAttribIn
    );

ULONG
GetCSCDatabaseErrorFlags(
    VOID
    );


BOOL
DeleteFromHandleCache(
    ULONG   ulidShadow
);

VOID
SetCSCDatabaseErrorFlags(
    ULONG ulFlags
);

BOOL
EncryptDecryptDB(
    LPVOID      lpdbID,
    BOOL        fEncrypt
);


#include "timelog.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\record.mgr\shadowse.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    shadowse.c

Abstract:

    This module implements all security related functions for disconnected
    operation of Client Side Caching

Revision History:

    Balan Sethu Raman     [SethuR]    6-October-1997

Notes:

    In NT ACL(Access Control lists) provide the necessary mechanism for
    denying/granting permissions to users. Each user is associated with a SID.
    The ACLs are specified in terms of SIDs associated with groups of users as
    well as individual users. Each user is associated with a token at runtime
    which details the various groups a user is a member of and this token is
    used to evaluate the ACLs. This is complicated by the fact that there are
    local groups associated with various machines. Therefore the token/context
    associated with an user varies from machine.

    In connected mode the credentials associated with a given user are shipped
    to the server where they are validated and the appropriate token created.
    This token is used subsequently in the evaluation of ACLs.

    This presents us with two options in implementing security for disconnected
    operation -- lazy evaluation and eager evaluation. In lazy evaluation the
    evaluation of ACLs is done on demand but the preparatory work for this
    evaluation is done in connected mode. On the other hand in eager evaluation
    the ACLs are evaluated and the maximal rights are stored as part of the CSC
    database. These rights are used to determine the appropriate access.

    The advantage of lazy evaluation is that the database is no longer constrained
    by previous access requirements while in eager evaluation we require that the
    user have accessed the file in connected mode in order to correctly determine
    the rights in disconnected mode. The flip side is that Lazy Evaluation is
    tougher to implement ( requires modifications in security/DS ) while the
    eager evaluation implementation is very easy.

    The current implementation corresponds to a simplified form of eager evaluation
    strategy. Appropriate encapsulation has been provided to allow us to
    swicth over to a lazy evaluation mode easily.

    There are three facets of the implementation

        1) Storing/Retreiving Access information

        2) Denying/Granting access based upon the stored access information.

        3) Persisting the SID/index mapping

    Currently associated with each file/directory in the CSC database there is a
    security blob. This blob is an in

--*/

#include "precomp.h"
#pragma hdrstop

#pragma code_seg("PAGE")

DWORD
CscUpdateCachedSecurityInformation(
    PCACHED_SECURITY_INFORMATION pCachedSecurityInformation,
    ULONG                        CachedSecurityInformationLength,
    ULONG                        NumberOfSids,
    PCSC_SID_ACCESS_RIGHTS       pSidAccessRights)
/*++

Routine Description:

    This routine updates the access rights for a given number of sids in the
    given cached security information structure. This routine centralizes the
    update process required for share level security as well as the object level
    security into a single routine since the on disk format for both these
    cases are the same. However, different APIs are required to update the
    in memory data structures.
    
    

Arguments:

    pCachedSecurityInformation - the cached security information instance

    CachedSecurityInformationLength - the length of the cached information

    NumberOfSids - the number of sids for which the access rights needs to be
                   updated

    pSidAccessRights - an array of the sids and the corresponding access rights.

Return Value:

    ERROR_SUCCESS if successful, otherwise appropriate error

Notes:

    The current implementation of this routine is based upon the assumption that
    the number of Sid mappings stored on a per file basis is very small ( 8 at most).
    If this assumption is changed this routine needs to be reworked.

--*/
{
    DWORD  Status = ERROR_SUCCESS;
    ULONG  i,j,cntNewRights=0;
    CACHED_SECURITY_INFORMATION NewSecurityInformation;

    ASSERT(CachedSecurityInformationLength == sizeof(CACHED_SECURITY_INFORMATION));

    if (NumberOfSids > CSC_MAXIMUM_NUMBER_OF_CACHED_SID_INDEXES) {
        return ERROR_BUFFER_OVERFLOW;
    } else if (NumberOfSids == 0) {
        return ERROR_SUCCESS;
    }

    // NB assumption, CSC_INVALID_INDEX is 0
    memset(&NewSecurityInformation, 0, sizeof(NewSecurityInformation));


    // from the array of new rights
    for (i = 0; i < NumberOfSids; i++) {
        CSC_SID_INDEX SidIndex;

        // map the sid to a sid index
        SidIndex = CscMapSidToIndex(
                       pSidAccessRights[i].pSid,
                       pSidAccessRights[i].SidLength);

        if (SidIndex == CSC_INVALID_SID_INDEX) {
            // Map the new sid
            Status = CscAddSidToDatabase(
                         pSidAccessRights[i].pSid,
                         pSidAccessRights[i].SidLength,
                         &SidIndex);

            if (Status != STATUS_SUCCESS)
            {
                return Status;                
            }

        }
        
        NewSecurityInformation.AccessRights[i].SidIndex = SidIndex;
        NewSecurityInformation.AccessRights[i].MaximalRights =
            (USHORT)pSidAccessRights[i].MaximalAccessRights;

        cntNewRights++;
    }

    // now copy the cached rights from old array for those sids which are not already 
    // there in the new array, till all slots in the new array are full
    // this ensures a round robin scheme

    ASSERT(cntNewRights && (cntNewRights <= CSC_MAXIMUM_NUMBER_OF_CACHED_SID_INDEXES));

    for (i=0; i<CSC_MAXIMUM_NUMBER_OF_CACHED_SID_INDEXES; ++i)
    {
        // if all slots in the new array are filled up, break
        if (cntNewRights==CSC_MAXIMUM_NUMBER_OF_CACHED_SID_INDEXES)
        {
            break;            
        }

        // if this is a valid sid index
        if (pCachedSecurityInformation->AccessRights[i].SidIndex != CSC_INVALID_SID_INDEX)
        {
            BOOLEAN fFound;
            
            fFound = FALSE;

            // check if it is already there in the new array.
            
            for (j=0; j< cntNewRights; ++j)
            {
                if (NewSecurityInformation.AccessRights[j].SidIndex == 
                    pCachedSecurityInformation->AccessRights[i].SidIndex)
                {
                    fFound = TRUE;
                    break;                                        
                }
            }
            
            // if it isn't in the new array, then we need to copy it
            if (!fFound)
            {
                NewSecurityInformation.AccessRights[cntNewRights] = 
                pCachedSecurityInformation->AccessRights[i];

                ++cntNewRights; // the new array has 
            }
        }
    }
    
    // update the cached security info and pass it back
    *pCachedSecurityInformation = NewSecurityInformation;

    return Status;
}

DWORD
CscAddMaximalAccessRightsForSids(
    HSHADOW                 hParent,
    HSHADOW                 hFile,
    ULONG                   NumberOfSids,
    PCSC_SID_ACCESS_RIGHTS  pSidAccessRights)
/*++

Routine Description:

    This routine updates the access rights for a given number of sids on the
    given file

Arguments:

    hParent - the parent directory shadow handle

    hFile   - the shadow handle

    NumberOfSids - the number of sids for which the access rights needs to be
                   updated

    pSidAccessRights - an array of the sids and the corresponding access rights.

Return Value:

    ERROR_SUCCESS if successful, otherwise appropriate error

Notes:

    The current implementation of this routine is based upon the assumption that
    the number of Sid mappings stored on a per file basis is very small ( 8 at most).
    If this assumption is changed this routine needs to be reworked.

--*/
{
    DWORD  Status = ERROR_SUCCESS;

    CACHED_SECURITY_INFORMATION CachedSecurityInformation;

    ULONG  BytesReturned, BytesWritten;

    BytesReturned = sizeof(CachedSecurityInformation);

    Status = GetShadowInfoEx(
                 hParent,
                 hFile,
                 NULL,
                 NULL,
                 NULL,
                 &CachedSecurityInformation,
                 &BytesReturned);

    if ((Status == ERROR_SUCCESS) &&
        ((BytesReturned == 0) ||
         (BytesReturned == sizeof(CachedSecurityInformation)))) {

        Status = CscUpdateCachedSecurityInformation(
                     &CachedSecurityInformation,
                     BytesReturned,
                     NumberOfSids,
                     pSidAccessRights);

        if (Status == ERROR_SUCCESS) {
            BytesWritten = sizeof(CachedSecurityInformation);

            Status = SetShadowInfoEx(
                         hParent,
                         hFile,
                         NULL,
                         0,
                         SHADOW_FLAGS_OR,
                         NULL,
                         &CachedSecurityInformation,
                         &BytesWritten);
        }
    }

    return Status;
}

DWORD
CscAddMaximalAccessRightsForShare(
    HSERVER                 hShare,
    ULONG                   NumberOfSids,
    PCSC_SID_ACCESS_RIGHTS  pSidAccessRights)
/*++

Routine Description:

    This routine updates the access rights for a given number of sids on the
    given share

Arguments:

    hShare - the parent directory shadow handle

    NumberOfSids - the number of sids for which the access rights needs to be
                   updated

    pSidAccessRights - an array of the sids and the corresponding access rights.

Return Value:

    ERROR_SUCCESS if successful, otherwise appropriate error

Notes:

    The current implementation of this routine is based upon the assumption that
    the number of Sid mappings stored on a per file basis is very small ( 8 at most).
    If this assumption is changed this routine needs to be reworked.

--*/
{
    DWORD  Status = ERROR_SUCCESS;

    CACHED_SECURITY_INFORMATION CachedSecurityInformation;

    ULONG  BytesReturned, BytesWritten;

    BytesReturned = sizeof(CachedSecurityInformation);

    Status = GetShareInfoEx(
                 hShare,
                 NULL,
                 NULL,
                 &CachedSecurityInformation,
                 &BytesReturned);

    if ((Status == ERROR_SUCCESS) &&
        ((BytesReturned == 0) ||
         (BytesReturned == sizeof(CachedSecurityInformation)))) {

        Status = CscUpdateCachedSecurityInformation(
                     &CachedSecurityInformation,
                     BytesReturned,
                     NumberOfSids,
                     pSidAccessRights);

        if (Status == ERROR_SUCCESS) {
            BytesWritten = sizeof(CachedSecurityInformation);

                if (SetShareStatusEx(
                         hShare,
                         0,
                         SHADOW_FLAGS_OR,
                         &CachedSecurityInformation,
                         &BytesWritten) >= 0)
                {
                    Status = STATUS_SUCCESS;
                }
                {
                    Status = STATUS_UNSUCCESSFUL;
                }
        }
    }

    return Status;
}

DWORD
CscRemoveMaximalAccessRightsForSid(
    HSHADOW     hParent,
    HSHADOW     hFile,
    PVOID       pSid,
    ULONG       SidLength)

/*++

Routine Description:

    This routine removes the cached access rights for a given number of sids on
    the given file

Arguments:

    hParent - the parent directory shadow handle

    hFile   - the shadow handle

    pSid    - the sid for which the cached access rights are revoked.

    SidLength - the length of the sid.

Return Value:

    ERROR_SUCCESS if successful, otherwise appropriate error

--*/
{
    DWORD   Status = ERROR_SUCCESS;
    USHORT  SidIndex;
    ULONG   BytesRead,BytesWritten,i;

    CACHED_SECURITY_INFORMATION CachedSecurityInformation;

    SidIndex = CscMapSidToIndex(
                   pSid,
                   SidLength);

    if (SidIndex != CSC_INVALID_SID_INDEX) {
        BytesRead = sizeof(CachedSecurityInformation);

        Status = GetShadowInfoEx(
                    hParent,
                    hFile,
                    NULL,
                    NULL,
                    NULL,
                    &CachedSecurityInformation,
                    &BytesRead);

        if ((Status == ERROR_SUCCESS) &&
            (BytesRead == sizeof(CachedSecurityInformation))) {
            for (i = 0; i < CSC_MAXIMUM_NUMBER_OF_CACHED_SID_INDEXES; i++) {
                if (CachedSecurityInformation.AccessRights[i].SidIndex == SidIndex) {
                    CachedSecurityInformation.AccessRights[i].SidIndex =
                        CSC_INVALID_SID_INDEX;

                    BytesWritten = sizeof(CachedSecurityInformation);

                    Status = SetShadowInfoEx(
                                 hParent,
                                 hFile,
                                 NULL,
                                 0,
                                 SHADOW_FLAGS_OR,
                                 NULL,
                                 &CachedSecurityInformation,
                                 &BytesWritten);

                    break;
                }
            }
        }
    }

    return Status;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\record.mgr\record.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

     Record.c

Abstract:

This file contains the implementation of CSC database record manager.
The database consists of files which are numbered starting from 1. The idea is similar to
an inode on unix. Inode files 1 to 0xF are special inode files.
Directories are cached in files which have inode numbers in the range 0x10 to 0x7FFFFFFFF.
Files are given Inode #s in the range 0x80000010 to 0x8FFFFFFF.


File #1 is the root inode which contains all the cached shares. It contains inode #s for
the roots of the corresponding share etc. The format SHAREREC in record.h tells the story.

Inode file #2 (Priority Q) is like a master file table for all the entries in the
database. Inode #2 also contains an MRU list for all the entries. This helps us in filling,
nuking the appropriate entries.

The PriorityQ has an entry for every FSOBJ in the hierarchy. Hence the index of the FSOBJ is
used to obtain an inode. This has the advantage of random accessing the PQ. This allows the PQ
to grow large without causing scalability problems.

Inodes 1, 2 and the directory indoes (0x10 - 0x7fffffff) have the following general format:
- each has a header, the prefix of which is of the type GENEIRCHEADER.
- each has a set of records, each record having a prefix of the type GENERICRECORD
EditRecord is a worker routine which works on all the above files based on this format.


Except for inode files 1 and 2 all others are sprinkled into 8 different directories. The formula
for sprinkling is in the routine FormNameString.


Author:

     Shishir Pardikar      [Shishirp]        01-jan-1995

Revision History:

     Joe Linn                 [JoeLinn]         23-jan-97     Ported for use on NT

--*/

#include "precomp.h"
#pragma hdrstop

#pragma code_seg("PAGE")

#if defined(BITCOPY)
#include <csc_bmpc.h>
static LPSTR CscBmpAltStrmName = STRMNAME;
#endif // defined(BITCOPY)


#ifndef CSC_RECORDMANAGER_WINNT
#include "record.h"
#endif //ifndef CSC_RECORDMANAGER_WINNT

#include <stdlib.h>
#include <direct.h>
#include <dos.h>
#include <fcntl.h>
#include <sys\types.h>
#include <sys\stat.h>
//#include <io.h>
#include <share.h>
#include <ctype.h>
#include <string.h>


#undef RxDbgTrace
#define RxDbgTrace(a,b,__d__) {qweee __d__;}

#ifdef DEBUG
//cshadow dbgprint interface
#define RecordKdPrint(__bit,__x) {\
    if (((RECORD_KDP_##__bit)==0) || FlagOn(RecordKdPrintVector,(RECORD_KDP_##__bit))) {\
    KdPrint (__x);\
    }\
}
#define RECORD_KDP_ALWAYS                 0x00000000
#define RECORD_KDP_BADERRORS              0x00000001
#define RECORD_KDP_INIT                   0x00000002
#define RECORD_KDP_STOREDATA              0x00000004
#define RECORD_KDP_FINDFILERECORD         0x00000008
#define RECORD_KDP_LFN2FILEREC            0x00000010
#define RECORD_KDP_EDITRECORDUPDDATEINFO  0x00000020
#define RECORD_KDP_PQ                     0x00000040
#define RECORD_KDP_COPYLOCAL              0x00000080

#define RECORD_KDP_GOOD_DEFAULT (RECORD_KDP_BADERRORS   \
                    | 0)

ULONG RecordKdPrintVector = RECORD_KDP_GOOD_DEFAULT;
//ULONG RecordKdPrintVector = 0xffff &~(RECORD_KDP_LFN2FILEREC);
ULONG RecordKdPrintVectorDef = RECORD_KDP_GOOD_DEFAULT;
#else
#define RecordKdPrint(__bit,__x)  {NOTHING;}
#endif



/********************** typedefs and defines ********************************/
#define SHARE_FILE_NO          1   // Inode # of the super root

#define INODE_NULL              0L

// operations performed by edit record
#define UPDATE_REC              1
#define FIND_REC                2
#define DELETE_REC              3
#define ALLOC_REC               4
#define CREATE_REC              5

#define DEFAULT_SHADOW_SPACE    0x1000000

#define COMMON_BUFF_SIZE          4096

#define ValidRec(ulRec)        (((ulRec) != INVALID_REC))
#define BYTES_PER_SECTOR        512

typedef struct tagHANDLE_CACHE_ENTRY{
    ULONG       ulidShadow;
    CSCHFILE       hf;
    ULONG       ulOpenMode;
    FILETIME    ft;
}
HANDLE_CACHE_ENTRY;
#define HANDLE_CACHE_SIZE   11
#define MAX_INODE_TRANSACTION_DURATION_IN_SECS  300 // 5 minutes


#define MAX_PATH	260	/* Maximum path length - including nul */

#define UseCommonBuff()     {Assert(!vfCommonBuffInUse); vfCommonBuffInUse = TRUE;}
#define UnUseCommonBuff()   {vfCommonBuffInUse = FALSE;}

#define  STRUCT_OFFSET(type, element)  ((ULONG)&(((type)0)->element))

#define EditRecord(ulidInode, lpSrc, lpCompareFunc, uOp) \
        EditRecordEx((ulidInode), (lpSrc), (lpCompareFunc), INVALID_REC, (uOp))


#pragma intrinsic (memcmp, memcpy, memset, strcat, strcmp, strcpy, strlen)

/********************** static data *****************************************/
/********************** global data *****************************************/

HANDLE_CACHE_ENTRY  rgHandleCache[HANDLE_CACHE_SIZE];

LPSTR   vlpszShadowDir = NULL;
int     vlenShadowDir = 0;

#ifdef CSC_RECORDMANAGER_WINNT
char vszShadowDir[MAX_SHADOW_DIR_NAME+1];
#endif

static char szBackslash[] = "\\";
#ifdef LATER
static char szStar[] = "\\*.*";
#endif //LATER
ULONG ulMaxStoreSize = 0;

#define CONDITIONALLY_NOP() ;

#ifdef DEBUG
#ifdef CSC_RECORDMANAGER_WINNT
LONGLONG    rgllTimeArray[TIMELOG_MAX];
#endif
#endif
char rgchReadBuff[COMMON_BUFF_SIZE];
LPBYTE  lpReadBuff = (LPBYTE)rgchReadBuff;
BOOL    vfCommonBuffInUse = FALSE;

DWORD vdwClusterSizeMinusOne=0, vdwClusterSizeMask=0xffffffff;
_FILETIME ftHandleCacheCurTime = {0, 0};
unsigned    cntReorderQ = 0;
unsigned    cntInodeTransactions = 0;
ULONG       ulLastInodeTransaction = 0;
BOOL        vfStopHandleCaching = FALSE;
ULONG       ulErrorFlags=0;
BOOL     fSupportsStreams = FALSE;

/********************** function prototypes *********************************/

void PRIVATE CopyNameToFilerec(LPTSTR lpName, LPFILERECEXT lpFre);
void  PRIVATE InitFileRec(LPFILERECEXT lpFre);
void  PRIVATE InitFileHeader(ULONG, ULONG, LPFILEHEADER);
ULONG PRIVATE GetNextFileInode(LPVOID, ULONG);
ULONG PRIVATE GetNextDirInode(LPVOID);
int PRIVATE InitShareDatabase(
    LPTSTR      lpdbID,
    LPTSTR  lpszUserName,
    DWORD   dwDefDataSizeHigh,
    DWORD   dwDefDataSizeLow,
    BOOL    fReinit,
    BOOL    *lpfReinited,
    BOOL    *lpfWasDirty,
    ULONG   *pulGlobalStatus
);

int PRIVATE InitPriQDatabase(LPVOID, BOOL fReinit, BOOL *lpfReinited);

int PUBLIC ICmpSameDirFileInode(LPINODEREC, LPINODEREC);
int PUBLIC ICompareDirInode(LPINODEREC, LPINODEREC);
int PUBLIC ICompareInodeRec(LPINODEREC, LPINODEREC);
int PRIVATE CreateRecordFile(LPVOID lpdbID, ULONG ulidShare, ULONG ulidDir, ULONG ulidNew);

int PUBLIC ICompareShareRec(LPSHAREREC, LPSHAREREC);
int PUBLIC ICompareShareRecId(LPSHAREREC, LPSHAREREC);
int PUBLIC ICompareShareRoot(LPSHAREREC, LPSHAREREC);
int PUBLIC ICompareFileRec(LPFILERECEXT, LPFILERECEXT);
int PUBLIC ICompareFileRecInode(LPFILERECEXT, LPFILERECEXT);


int ReadInodeHeader(
    LPTSTR  lpdbID,
    ULONG   ulidDir,
    LPGENERICHEADER lpGH,
    ULONG   ulSize
    );

ULONG PRIVATE UlFormFileInode(ULONG, ULONG);
void PRIVATE DecomposeNameString(LPTSTR, ULONG far *, ULONG far *);


#ifdef LATER
LPPATH PRIVATE LpAppendStartDotStar(LPPATH);
#endif //LATER
ULONG PRIVATE GetNormalizedPri(ULONG);
int PRIVATE ICompareFail(LPGENERICREC, LPGENERICREC);


int PRIVATE    LFNToFilerec(
    USHORT          *lpLFN,
    LPFILERECEXT    lpFR
    );

int PRIVATE    FilerecToLFN(
    LPFILERECEXT    lpFR,
    USHORT          *lpLFN
    );

int PRIVATE WriteRecordEx(CSCHFILE, LPGENERICHEADER, ULONG, LPGENERICREC, BOOL);
BOOL
InsertInHandleCache(
    ULONG   ulidShadow,
    CSCHFILE   hf
);

BOOL
InsertInHandleCacheEx(
    ULONG   ulidShadow,
    CSCHFILE   hf,
    ULONG   ulOpenMode
);

BOOL
DeleteFromHandleCache(
    ULONG   ulidShadow
);

BOOL
DeleteFromHandleCacheEx(
    ULONG   ulidShadow,
    ULONG   ulOpenMode
);

BOOL FindHandleFromHandleCache(
    ULONG   ulidShadow,
    CSCHFILE   *lphf);

BOOL FindHandleFromHandleCacheEx(
    ULONG   ulidShadow,
    ULONG   ulOpenMode,
    CSCHFILE   *lphf);

BOOL
FindHandleFromHandleCacheInternal(
    ULONG   ulidShadow,
    ULONG   ulOpenMode,
    CSCHFILE   *lphf,
    int     *lpIndx);

VOID
AgeOutHandlesFromHandleCache(
    VOID
    );

BOOL
WithinSector(
    ULONG   ulRec,
    LPGENERICHEADER lpGH
    );

BOOL
ExtendFileSectorAligned(
    CSCHFILE           hf,
    LPGENERICREC    lpDst,
    LPGENERICHEADER lpGH
    );

BOOL
ValidateGenericHeader(
    LPGENERICHEADER    lpGH
    );

int PUBLIC RelinkQRecord(
    LPTSTR  lpdbID,
    ULONG   ulidPQ,
    ULONG   ulRec,
    LPQREC  lpSrc,
    EDITCMPPROC fnCmp
    );
int PUBLIC FindQRecordInsertionPoint(
    CSCHFILE   hf,
    LPQREC  lpSrc,
    ULONG   ulrecStart,
    EDITCMPPROC fnCmp,
    ULONG   *lpulrecPrev,
    ULONG   *lpulrecNext
    );

int RealOverflowCount(
    LPGENERICREC    lpGR,
    LPGENERICHEADER lpGH,
    int             cntMaxRec
    );

#ifdef CSC_RECORDMANAGER_WINNT
BOOL
FindCreateDBDir(
    LPSTR   lpszShadowDir,
    BOOL    fCleanup,
    BOOL    *lpfCreated
    );
BOOL
TraverseHierarchy(
    LPVOID lpszLocation,
    BOOL fFix);

BOOL
CheckCSCDatabaseVersion(
    LPTSTR  lpszLocation,       // database directory
    BOOL    *lpfWasDirty
);

extern ULONG
CloseFileLocalFromHandleCache(
    CSCHFILE handle
    );

#endif

BOOL
HasStreamSupport(
    CSCHFILE handle,
    BOOL    *lpfResult
    );
    

extern int TerminateShadowLog(VOID);


BOOLEAN
IsLongFileName(
    USHORT     cFileName[MAX_PATH]
    );

/****************************************************************************/
AssertData
AssertError
/***************************************************************************/

BOOLEAN
IsLongFileName(
    USHORT     cFileName[MAX_PATH]
    )
/*++

Routine Description:

   This routine checks if it is a long file name.

Arguments:

    FileName - the file name needs to be parsed
    

Return Value:

    BOOLEAN - 

--*/
{
        USHORT          i;
        USHORT          Left = 0;
        USHORT          Right = 0;
        BOOLEAN         RightPart = FALSE;
        WCHAR           LastChar = 0;
        WCHAR           CurrentChar = 0;
        
		BOOLEAN       IsLongName = FALSE;

        

        for (i=0;i<wstrlen(cFileName);i++) {
            LastChar = CurrentChar;
            CurrentChar = cFileName[i];

            if (CurrentChar == L'\\') {
                RightPart = FALSE;
                Left = 0;
                Right = 0;
                continue;
            }

            if (CurrentChar == L'.') {
                if (RightPart) {
                    IsLongName = TRUE;
                    break;
                } else {
                    RightPart = TRUE;
                    Right = 0;
                    continue;
                }
            }

            if (CurrentChar >= L'0' && CurrentChar <= L'9' ||
                CurrentChar >= L'a' && CurrentChar <= L'z' ||
                CurrentChar >= L'A' && CurrentChar <= L'Z' ||
                CurrentChar == L'~' ||
                CurrentChar == L'_' ||
                CurrentChar == L'$' ||
                CurrentChar == L'@') {
                if (RightPart) {
                    if (++Right > 3) {
                        IsLongName = TRUE;
                        break;
                    }
                } else {
                    if (++Left > 8) {
                        IsLongName = TRUE;
                        break;
                    }
                }

                
            } else {
                // if not, an alternate name may be created by the server which will
                // be different from this name.
                IsLongName = TRUE;
                break;
            }
        }
    
    return IsLongName;
}



/***************** Database initialization operations ***********************/
BOOL PUBLIC FExistsRecDB(
    LPSTR   lpszLocation
    )
/*++

Routine Description:

    Checks whether the databas exists.

Parameters:

Return Value:

Notes:

    Mostly irrelevant now.

--*/
{
    ULONG uAttrib;
    LPTSTR  lpszName;
    BOOL fRet;

    lpszName = FormNameString(lpszLocation, ULID_SHARE);

//      CheckHeap(lpszName);

    if (!lpszName)
    {
        return FALSE;
    }

    fRet = (GetAttributesLocal(lpszName, &uAttrib)!=-1);

    FreeNameString(lpszName);

    return (fRet);
}


LPVOID
PUBLIC                                   // ret
OpenRecDBInternal(                                              //
    LPTSTR  lpszLocation,       // database directory
    LPTSTR  lpszUserName,       // name (not valid any more)
    DWORD   dwDefDataSizeHigh,  //high dword of max size of unpinned data
    DWORD   dwDefDataSizeLow,   //low dword of max size of pinned data
    DWORD   dwClusterSize,      // clustersize of the disk, used to calculate
                                // the actual amount of disk consumed
    BOOL    fReinit,            // reinitialize, even if it exists, create if it doesn't
    BOOL    fDoCheckCSC,        // whether to do CSC check
    BOOL    *lpfNew,            // returns whether the database was newly recreated
    ULONG   *pulGlobalStatus
    )
/*++

Routine Description:

    This routine initializes the database. On NT, if fReinit flag is set
    it also creates the directory strcuture that CSC expects and if the version number
    is not correct, it nukes the old database and creates the new one.



Parameters:

Return Value:

Notes:


--*/
{
    LPTSTR lpdbID = NULL;
    BOOL    fDirCreated = FALSE, fPQCreated = FALSE, fShareCreated = FALSE, fOK = FALSE;
    BOOL    fWasDirty = FALSE;

    RecordKdPrint(INIT,("OpenRecDB at %s for %s with size %d \r\n", lpszLocation, lpszUserName, dwDefDataSizeLow));

    if (fReinit)
    {
        RecordKdPrint(ALWAYS,("Reformat requested\r\n"));
    }

#ifdef CSC_RECORDMANAGER_WINNT
    if (!FindCreateDBDir(lpszLocation, fReinit, &fDirCreated))
    {
        RecordKdPrint(BADERRORS, ("CSC(OpenRecDB): couldn't create the CSC database directories \r\n"));
        return NULL;
    }

    if (!fDirCreated && !CheckCSCDatabaseVersion(lpszLocation, &fWasDirty))
    {
        if (!FindCreateDBDir(lpszLocation, TRUE, &fDirCreated))
        {
            return FALSE;
        }
        
    }
#endif

    vlpszShadowDir = AllocMem(strlen(lpszLocation)+1);

    if (!vlpszShadowDir)
    {
        return NULL;
    }

    strcpy(vlpszShadowDir, lpszLocation);
    vlenShadowDir = strlen(vlpszShadowDir);

    if (!vlpszShadowDir)
    {
#ifndef CSC_RECORDMANAGER_WINNT
        Assert(FALSE);
        return NULL;
#else
        vlpszShadowDir = vszShadowDir;
#endif
    }

    // lpdbID scheme had some genesis in multiple databases
    lpdbID = vlpszShadowDir;
    vlenShadowDir = strlen(vlpszShadowDir);

    if (InitPriQDatabase(vlpszShadowDir, fReinit, &fPQCreated) < 0)
    {
        RecordKdPrint(BADERRORS,("OpenRecDB  %s at %s for %s with size %d \r\n",
               "couldn't InitPriQDatabase",
               lpszLocation, lpszUserName, dwDefDataSizeLow));
        goto bailout;
    }

    if (fPQCreated)
    {
        fReinit = TRUE;
    }

    if (InitShareDatabase(vlpszShadowDir, lpszUserName, dwDefDataSizeHigh, dwDefDataSizeLow, fReinit, &fShareCreated, &fWasDirty, pulGlobalStatus) < 0)
    {
        RecordKdPrint(BADERRORS,("OpenRecDB  %s at %s for %s with size %d \r\n",
           "couldn't InitShareDatabase",
           lpszLocation, lpszUserName, dwDefDataSizeLow));
        return NULL;
    }


#ifdef CSC_RECORDMANAGER_WINNT
    if (!fReinit && fDoCheckCSC && fWasDirty)
    {
        RecordKdPrint(ALWAYS, ("CSC(OpenRecDB): CSC database wasn't cleanly shutdown, fixing...\r\n"));

        if (!TraverseHierarchy(lpszLocation, TRUE))
        {
            RecordKdPrint(BADERRORS, ("CSC(OpenRecDB): CSC database couldn't be fixed \r\n"));
            return NULL;
        }

        Assert(TraverseHierarchy(lpszLocation, FALSE));
    }
#endif

    if (!fPQCreated && fShareCreated)
    {
        if (InitPriQDatabase(vlpszShadowDir, TRUE, &fPQCreated) < 0)
        {
            RecordKdPrint(BADERRORS,("OpenRecDB  %s at %s for %s with size %d \r\n",
                   "couldn't recreate PriQDatabase",
                lpszLocation, lpszUserName, dwDefDataSizeLow));
            goto bailout;
        }

        Assert(fPQCreated);
    }

    Assert((fPQCreated && fShareCreated) || (!fPQCreated && !fShareCreated));

    Assert(lpReadBuff == rgchReadBuff);

    vdwClusterSizeMinusOne = dwClusterSize-1;
    vdwClusterSizeMask = ~vdwClusterSizeMinusOne;

    RecordKdPrint(INIT, ("OpenRecDB at %s for %s with size %d recreated=%d\r\n", lpszLocation, lpszUserName, dwDefDataSizeLow, fShareCreated));

    if (lpfNew)
    {
        *lpfNew = fShareCreated;
    }

    fOK = TRUE;

bailout:
    if (!fOK)
    {
        CloseRecDB(lpdbID);
    }

    return lpdbID;
}

LPVOID
PUBLIC                                   // ret
OpenRecDB(                                              //
    LPTSTR  lpszLocation,       // database directory
    LPTSTR  lpszUserName,       // name (not valid any more)
    DWORD   dwDefDataSizeHigh,  //high dword of max size of unpinned data
    DWORD   dwDefDataSizeLow,   //low dword of max size of pinned data
    DWORD   dwClusterSize,      // clustersize of the disk, used to calculate
                                // the actual amount of disk consumed
    BOOL    fReinit,            // reinitialize, even if it exists, create if it doesn't
    BOOL    *lpfNew,            // returns whether the database was newly recreated
    ULONG   *pulGlobalStatus
    )
/*++

Routine Description:

    This routine initializes the database. On NT, it also creates the directory strcuture
    that CSC expects. If the version number is not correct, it nukes the old database
    and creates the new one.

Parameters:

Return Value:

Notes:


--*/
{
    return OpenRecDBInternal(   lpszLocation,
                        lpszUserName,
                        dwDefDataSizeHigh,
                        dwDefDataSizeLow,
                        dwClusterSize,
                        fReinit,
                        TRUE,   // do csc check if necessary
                        lpfNew,
                        pulGlobalStatus
                        );
}

int
PUBLIC
CloseRecDB(
    LPTSTR  lpdbID
)
/*++

Routine Description:

    Closes the database

Parameters:

Return Value:

Notes:


--*/
{
    SHAREHEADER    sSH;

    if (vlpszShadowDir)
    {
        DEBUG_LOG(RECORD, ("CloseRecDB \r\n"));

        if (!strcmp(lpdbID, vlpszShadowDir))
        {
            DWORD Status;
#ifndef READONLY_OPS
            // if there have been no erros on the database, clear the
            // unclean shutdown bit. Otherwise, let it be set so that the next
            // time around when we enable CSC, we would run a database check 

            if (!ulErrorFlags)
            {
                if (ReadShareHeader(vlpszShadowDir, &sSH) >= 0)
                {
                    sSH.uFlags &= ~FLAG_SHAREHEADER_DATABASE_OPEN;
                
                    if(WriteShareHeader(vlpszShadowDir, &sSH) < 0)
                    {
                        RecordKdPrint(BADERRORS,("CloseRecDB  Failed to clear dirty bit"));
                    }
                }
            }
#endif // READONLY_OPS

            DeleteFromHandleCache(INVALID_SHADOW);
            TerminateShadowLog();

            FreeMem(vlpszShadowDir);
            Status = CscTearDownSecurity(vlpszShadowDir);
            vlpszShadowDir = NULL;

            if (Status == ERROR_SUCCESS) {
                return 1;
            } else {
                return -1;
            }
        }
    }
#ifdef DEBUG
#ifdef CSC_RECORDMANAGER_WINNT
    memset(rgllTimeArray, 0, sizeof(rgllTimeArray));
#endif
#endif
    SetLastErrorLocal(ERROR_INVALID_ACCESS);
    return (-1);
}

int
QueryRecDB(
    LPTSTR  lpszLocation,       // database directory, must be MAX_PATH
    LPTSTR  lpszUserName,       // name (not valid any more)
    DWORD   *lpdwDefDataSizeHigh,  //high dword of max size of unpinned data
    DWORD   *lpdwDefDataSizeLow,   //low dword of max size of pinned data
    DWORD   *lpdwClusterSize      // clustersize of the disk, used to calculate
    )
/*++

Routine Description:

    Returns the database information if it is open

Parameters:

Return Value:

    returns 1 if open else returns -1

Notes:


--*/
{
    if (!vlpszShadowDir)
    {
        SetLastErrorLocal(ERROR_INVALID_ACCESS);
        return -1;
    }

    Assert(vlenShadowDir < MAX_PATH);

    if (lpszLocation)
    {
#ifdef CSC_RECORDMANAGER_WINNT

        strcpy(lpszLocation, vlpszShadowDir+sizeof(NT_DB_PREFIX)-1);

        // check if this NT style location
        if (lpszLocation[1] != ':')
        {
            strcpy(lpszLocation, vlpszShadowDir);
        }
#else
        strcpy(lpszLocation, vlpszShadowDir);
#endif
    }

    return 1;
}

int PRIVATE InitShareDatabase(
    LPTSTR  lpdbID,
    LPTSTR  lpszUserName,
    DWORD   dwDefDataSizeHigh,
    DWORD   dwDefDataSizeLow,
    BOOL    fReinit,
    BOOL    *lpfReinited,
    BOOL    *lpfWasDirty,
    ULONG   *pulGlobalStatus
    )
/*++

Routine Description:

    Initialize the list of shares. This mostly means make sure nothing is wrong with
    the file and the header.

Parameters:

Return Value:

Notes:


--*/
{
    int iRet=-1;
    CSCHFILE hf = CSCHFILE_NULL;
    SHAREHEADER sSH;
    ULONG uSize;
    LPSTR   lpszName;
    
    lpszUserName;   // we will se what to do about this later.

    lpszName = FormNameString(lpdbID, ULID_SHARE);

    if (!lpszName)
    {
        goto bailout;
    }

    *lpfReinited = FALSE;

    // if we are not supposed to reinitialize, only then we try to open the file

    if (!fReinit && (hf = OpenFileLocal(lpszName)))
    {
        
        if(ReadFileLocal(hf, 0, (LPVOID)&sSH, sizeof(SHAREHEADER))!=sizeof(SHAREHEADER))
        {
            Assert(FALSE);
            goto bailout;
        }

        if (!HasStreamSupport(hf, &fSupportsStreams))
        {
            goto bailout;
        }
        
        *lpfWasDirty = ((sSH.uFlags & FLAG_SHAREHEADER_DATABASE_OPEN) != 0);

        if (sSH.ulVersion == CSC_DATABASE_VERSION)
        {
#ifndef READONLY_OPS
            sSH.uFlags |= FLAG_SHAREHEADER_DATABASE_OPEN;

            if(WriteHeader(hf, (LPVOID)&sSH, sizeof(SHAREHEADER))
                    != sizeof(SHAREHEADER))
            {
                Assert(FALSE);
                goto bailout;
            }
#endif // READONLY_OPS

            iRet = 1;
            *pulGlobalStatus = sSH.uFlags;
            goto bailout;
        }
        else
        {
            RecordKdPrint(BADERRORS,("different version on the superroot, recreating\n"));
        }

        CloseFileLocal(hf);
        hf = CSCHFILE_NULL;  // general paranoia
    }

    // reinitialize the database

#ifndef READONLY_OPS
    hf = R0OpenFileEx(ACCESS_READWRITE, ACTION_CREATEALWAYS, FILE_ATTRIBUTE_SYSTEM, lpszName, FALSE);

    if (!hf)
    {
        RecordKdPrint(BADERRORS,("Can't create server list file\n"));
        goto bailout;
    }
    if (GetFileSizeLocal(hf, &uSize) || uSize)
    {
        iRet = 1;
        goto bailout;
    }

    // Init the server header
    memset((LPVOID)&sSH, 0, sizeof(SHAREHEADER));
    sSH.uRecSize = sizeof(SHAREREC);
    sSH.lFirstRec = (LONG) sizeof(SHAREHEADER);
    sSH.ulVersion = CSC_DATABASE_VERSION;
    // Max size of the cache
    sSH.sMax.ulSize    = dwDefDataSizeLow; // This size is good enough right now
    sSH.uFlags |= FLAG_SHAREHEADER_DATABASE_OPEN;

    if(WriteHeader(hf, (LPVOID)&sSH, sizeof(SHAREHEADER))
            != sizeof(SHAREHEADER))
    {
        Assert(FALSE);
        goto bailout;
    }

    RecordKdPrint(STOREDATA,("InitShareDatabase: Current space used %ld \r\n", sSH.sCur.ulSize));
    iRet = 1;

    *lpfReinited = TRUE;
    *pulGlobalStatus = sSH.uFlags;
    
#endif // READONLY_OPS

bailout:
    if (hf)
    {
        CloseFileLocal(hf);
    }

    FreeNameString(lpszName);

    return (iRet);
}


int PRIVATE InitPriQDatabase(
    LPTSTR  lpdbID,
    BOOL    fReinit,
    BOOL    *lpfReinited
    )
/*++

Routine Description:
    Initialize the PQ/MFT. This mostly means make sure nothing is wrong with
    the file and the header.


Parameters:

Return Value:

Notes:


--*/
{
    int iRet=-1;
    CSCHFILE hf= CSCHFILE_NULL;
    PRIQHEADER sQH;
    ULONG uSize;
    LPSTR   lpszName;

    lpszName = FormNameString(lpdbID, ULID_PQ);
    if (!lpszName)
    {
        goto bailout;
    }

    *lpfReinited = FALSE;

    if (!fReinit && (hf = OpenFileLocal(lpszName)))
    {
        if(ReadFileLocal(hf, 0, (LPVOID)&sQH, sizeof(PRIQHEADER))!=sizeof(PRIQHEADER))
        {
            Assert(FALSE);
            goto bailout;
        }

        if (sQH.ulVersion != CSC_DATABASE_VERSION)
        {
            RecordKdPrint(BADERRORS,("different version on the PQ, recreating \n"));
            CloseFileLocal(hf);
            hf = CSCHFILE_NULL;
        }
        else
        {
            iRet = 1;
            goto bailout;
        }
    }

#ifndef READONLY_OPS
    hf = R0OpenFileEx(ACCESS_READWRITE, ACTION_CREATEALWAYS, FILE_ATTRIBUTE_SYSTEM, lpszName, FALSE);

    if (!hf)
    {
        RecordKdPrint(BADERRORS,("Can't create Priority Q databse \r\n"));
        goto bailout;
    }

    if (GetFileSizeLocal(hf, &uSize) || uSize)
    {
        iRet = 1;
        goto bailout;
    }

    InitQHeader(&sQH);
    if(WriteHeader(hf, (LPVOID)&sQH, sizeof(PRIQHEADER))
            != sizeof(PRIQHEADER))
    {
        Assert(FALSE);
        goto bailout;
    }
    *lpfReinited = TRUE;
    iRet = 1;
#endif // READONLY_OPS

bailout:
    if (hf)
    {
        CloseFileLocal(hf);
    }

    FreeNameString(lpszName);
    return (iRet);
}

/******************* Local data size operations *****************************/

int ReadInodeHeader(
    LPTSTR    lpdbID,
    ULONG   ulidDir,
    LPGENERICHEADER lpGH,
    ULONG   ulSize
    )
/*++

Routine Description:

    Read the header of an inode file, which could be servers, PQ or any of the directories

Parameters:

Return Value:

Notes:


--*/
{
    CSCHFILE hf;
    int iRet = -1;
    LPSTR   lpszName = NULL;

    lpszName =  FormNameString(lpdbID, ulidDir);

    if (!lpszName)
    {
        return -1;
    }

    hf = OpenFileLocal(lpszName);

    FreeNameString(lpszName);

    if (!hf)
    {
        // error gets set by openfilelocal
        return -1;
    }

    iRet = ReadHeader(hf, (LPVOID)lpGH, (USHORT)ulSize);

    CloseFileLocal(hf);

    return iRet;

}

int PUBLIC GetStoreData(
    LPTSTR    lpdbID,
    LPSTOREDATA lpSD
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    CSCHFILE hf;
    SHAREHEADER sSH;
    int iRet = -1;
    BOOL    fCached;

    hf = OpenInodeFileAndCacheHandle(lpdbID, ULID_SHARE, ACCESS_READWRITE, &fCached);

    if (!hf)
    {
        return -1;
    }

    if ((iRet = ReadHeader(hf, (LPVOID)&sSH, sizeof(SHAREHEADER)))> 0)
    {
        *lpSD = sSH.sCur;
    }

    if (hf && !fCached)
    {
        Assert(vfStopHandleCaching);
        CloseFileLocal(hf);
    }
    else
    {
        Assert(!hf || !vfStopHandleCaching);
    }

    return iRet;
}

int PUBLIC GetInodeFileSize(
    LPTSTR    lpdbID,
    ULONG ulidShadow,
    ULONG far *lpuSize
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    LPSTR   lpszName = NULL;
    CSCHFILE hf;
    int iRet = -1;

    *lpuSize = 0;
    lpszName = FormNameString(lpdbID, ulidShadow);

    if (!lpszName)
    {
        return -1;
    }


    if (hf = OpenFileLocal(lpszName))
    {
        if(GetFileSizeLocal(hf, lpuSize))
        {
            iRet = -1;
        }
        else
        {
            iRet = 0;
        }
        CloseFileLocal(hf);
    }
    else
    {
        iRet = 0;    // BUGBUG-win9xonly for now while IFS fixes the problem

    }

    FreeNameString(lpszName);

    return iRet;
}

int DeleteInodeFile(
    LPTSTR    lpdbID,
    ULONG ulidShadow
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    LPSTR   lpszName = NULL;
    int iRet = -1;

    lpszName = FormNameString(lpdbID, ulidShadow);

    if (!lpszName)
    {
        return -1;
    }

    iRet = DeleteFileLocal(lpszName, ATTRIB_DEL_ANY);

    FreeNameString(lpszName);

    return iRet;
}

int TruncateInodeFile(
    LPTSTR    lpdbID,
    ULONG ulidShadow
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    LPSTR   lpszName = NULL;
    CSCHFILE hf;
    int iRet = -1;

    lpszName = FormNameString(lpdbID, ulidShadow);

    if (!lpszName)
    {
        return -1;
    }

    hf = R0OpenFile(ACCESS_READWRITE, ACTION_CREATEALWAYS, lpszName);

    if (hf)
    {
        CloseFileLocal(hf);
        iRet = 0;
    }


    FreeNameString(lpszName);

    return iRet;
}

int SetInodeAttributes(
    LPTSTR    lpdbID,
    ULONG ulid,
    ULONG ulAttr
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    LPSTR lpszName;
    int iRet=-1;

    lpszName = FormNameString(lpdbID, ulid);

    if (lpszName)
    {
        iRet = SetAttributesLocal(lpszName, ulAttr);
    }

    FreeNameString(lpszName);

    return (iRet);
}

int GetInodeAttributes(
    LPTSTR    lpdbID,
    ULONG ulid,
    ULONG *lpulAttr
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    LPSTR lpszName;
    int iRet=-1;

    lpszName = FormNameString(lpdbID, ulid);

    if (lpszName)
    {
        iRet = GetAttributesLocal(lpszName, lpulAttr);
    }

    FreeNameString(lpszName);
    return (iRet);
}

int PUBLIC CreateDirInode(
    LPTSTR    lpdbID,
    ULONG     ulidShare,
    ULONG     ulidDir,
    ULONG     ulidNew
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    LPSTR lpszName=NULL;
    FILEHEADER sFH;
    CSCHFILE hf= CSCHFILE_NULL;
    int iRet = -1;

    if (ulidDir)
    {
        lpszName = FormNameString(lpdbID, ulidDir);

        if (!lpszName)
        {
            goto bailout;
        }
        if (!(hf = OpenFileLocal(lpszName)))
        {
            RecordKdPrint(BADERRORS,("Couldn't access directory %s", lpszName));
            goto bailout;
        }

        if (ReadHeader(hf, (LPVOID)&sFH, sizeof(FILEHEADER)) != sizeof(FILEHEADER))
        {
            RecordKdPrint(BADERRORS,("Couldn't access directory %s", lpszName));
            goto bailout;
        }

        CloseFileLocal(hf);

        hf = CSCHFILE_NULL;

        ulidShare = sFH.ulidShare;
    }

    iRet = CreateRecordFile(lpdbID, ulidShare, ulidDir, ulidNew);

bailout:
    if (hf)
    {
        CloseFileLocal(hf);

    }

    FreeNameString(lpszName);

    return iRet;
}

/******************* Share database operations *****************************/


BOOL PUBLIC InitShareRec(
    LPSHAREREC lpSR,
    USHORT *lpName,
    ULONG ulidShare
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    unsigned i;

    memset((LPVOID)lpSR, 0, sizeof(SHAREREC));
    lpSR->uchType = REC_DATA;
    if (lpName)
    {
        i = wstrlen(lpName) * sizeof(USHORT);
        if(i >= sizeof(lpSR->rgPath))
        {
            SetLastErrorLocal(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        memcpy(lpSR->rgPath, lpName, i);
    }

    lpSR->ulShare = ulidShare;

    return TRUE;
}

int PUBLIC  ReadShareHeader(
    LPTSTR    lpdbID,
    LPSHAREHEADER lpSH
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    CSCHFILE hf;
    int iRet = -1;
    LPSTR   lpszName = NULL;

    lpszName = FormNameString(lpdbID, ULID_SHARE);

    if (!lpszName)
    {
        return -1;
    }

    hf = OpenFileLocal(lpszName);

    FreeNameString(lpszName);

    if (hf)
    {
        iRet = ReadHeader(hf, (LPVOID)lpSH, sizeof(SHAREHEADER));
        CloseFileLocal(hf);
    }

    return iRet;
}

int PUBLIC  WriteShareHeader(
    LPTSTR    lpdbID,
    LPSHAREHEADER lpSH
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    CSCHFILE hf;
    int iRet = -1;
    LPSTR   lpszName = NULL;

    lpszName = FormNameString(lpdbID, ULID_SHARE);


    if (!lpszName)
    {
        return -1;
    }

    hf = OpenFileLocal(lpszName);

    FreeNameString(lpszName);

    if (hf)
    {
        iRet = WriteHeader(hf, (LPVOID)lpSH, sizeof(SHAREHEADER));
        CloseFileLocal(hf);
    }

    return iRet;
}

ULONG PUBLIC FindShareRecord(
    LPTSTR    lpdbID,
    USHORT *lpName,
    LPSHAREREC lpSR
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    ULONG ulShare;

    if (!InitShareRec(lpSR, lpName, 0))
    {
        return 0;
    }

    ulShare = EditRecordEx(ULID_SHARE, (LPGENERICREC)lpSR, ICompareShareRec, INVALID_REC, FIND_REC);


    return (ulShare);
}

ULONG PUBLIC FindSharerecFromInode(
    LPTSTR    lpdbID,
    ULONG ulidRoot,
    LPSHAREREC lpSR
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    ULONG   ulShare;
    memset(lpSR, 0, sizeof(SHAREREC));

    lpSR->ulidShadow = ulidRoot;

    ulShare = EditRecordEx(ULID_SHARE, (LPGENERICREC)lpSR, ICompareShareRoot, INVALID_REC, FIND_REC);

    return (ulShare);
}

ULONG PUBLIC FindSharerecFromShare(
    LPTSTR    lpdbID,
    ULONG ulidShare,
    LPSHAREREC lpSR
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    ULONG   ulShare;

    if (!InitShareRec(lpSR, NULL, ulidShare))
    {
        return 0;
    }

    ulShare = EditRecordEx(ULID_SHARE, (LPGENERICREC)lpSR, ICompareShareRoot, INVALID_REC, FIND_REC);

    return ulShare;

}

ULONG PUBLIC AddShareRecord(
    LPTSTR    lpdbID,
    LPSHAREREC lpSR
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    ULONG   ulShare;

    ulShare = EditRecordEx(ULID_SHARE, (LPGENERICREC)lpSR, ICompareShareRec, INVALID_REC, CREATE_REC);


    return (ulShare);

}


int PUBLIC DeleteShareRecord(
    LPTSTR    lpdbID,
    ULONG ulidShare
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    SHAREREC sSR;
    int iRet = -1;


    if (!InitShareRec(&sSR, NULL, ulidShare))
    {
        return -1;
    }

    if(EditRecordEx(ULID_SHARE, (LPGENERICREC)&sSR, ICompareShareRecId, INVALID_REC, DELETE_REC))
    {
        iRet = 1;
    }

    return(iRet);
}

int PUBLIC GetShareRecord(
    LPTSTR    lpdbID,
    ULONG ulidShare,
    LPSHAREREC lpSR
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    CSCHFILE hf = CSCHFILE_NULL;
    SHAREHEADER sSH;
    int iRet = -1;
    LPSTR   lpszName = NULL;

    lpszName = FormNameString(lpdbID, ULID_SHARE);

    if (!lpszName)
    {
        return (-1);
    }

    hf = OpenFileLocal(lpszName);

    FreeNameString(lpszName);
    lpszName = NULL;

    if (!hf)
    goto bailout;

    if(ReadHeader(hf, (LPVOID)&sSH, sizeof(SHAREHEADER)) != sizeof(SHAREHEADER))
    goto bailout;
    if (ReadRecord(hf, (LPGENERICHEADER)&sSH, ulidShare, (LPGENERICREC)lpSR) < 0)
    goto bailout;
    iRet = 1;
bailout:
    if (hf)
    CloseFileLocal(hf);
    return (iRet);
}

int PUBLIC SetShareRecord(
    LPTSTR    lpdbID,
    ULONG ulidShare,
    LPSHAREREC lpSR
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    CSCHFILE hf = CSCHFILE_NULL;
    SHAREHEADER sSH;
    int iRet = -1;
    LPSTR lpszName;

    lpszName = FormNameString(lpdbID, ULID_SHARE);

    if (!lpszName)
    {
        goto bailout;
    }

    hf = OpenFileLocal(lpszName);

    FreeNameString(lpszName);

    if (!hf)
    goto bailout;

    if(ReadHeader(hf, (LPVOID)&sSH, sizeof(SHAREHEADER)) != sizeof(SHAREHEADER))
    goto bailout;
    if (WriteRecord(hf, (LPGENERICHEADER)&sSH, ulidShare, (LPGENERICREC)lpSR) < 0)
    goto bailout;
    iRet = 1;
bailout:
    if (hf)
    CloseFileLocal(hf);
    return (iRet);
}

int PUBLIC ICompareShareRec(
    LPSHAREREC lpDst,
    LPSHAREREC lpSrc
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    return ( wstrnicmp(lpDst->rgPath, lpSrc->rgPath, sizeof(lpDst->rgPath)));
}

int PUBLIC ICompareShareRoot(
    LPSHAREREC lpDst,
    LPSHAREREC lpSrc
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    return (!(lpDst->ulidShadow==lpSrc->ulidShadow));
}

int PUBLIC ICompareShareRecId(
    LPSHAREREC lpDst,
    LPSHAREREC lpSrc
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    return (!(lpDst->ulShare==lpSrc->ulShare));
}
/********************** File database operations ****************************/

void PRIVATE InitFileHeader(
    ULONG ulidShare,
    ULONG ulidDir,
    LPFILEHEADER lpFH
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    memset((LPVOID)lpFH, 0, sizeof(FILEHEADER));
    lpFH->uRecSize = sizeof(FILEREC);
    lpFH->lFirstRec = (LONG)sizeof(FILEHEADER);
    lpFH->ulidShare = ulidShare;
    lpFH->ulidDir = ulidDir;
    lpFH->ulidNextShadow = 1L;    // Leaf Inode at this level
    lpFH->ulVersion = CSC_DATABASE_VERSION;
}

void PRIVATE InitFileRec(
    LPFILERECEXT lpFR
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int cCount;
    memset((LPVOID)lpFR, 0, sizeof(FILERECEXT));
    lpFR->sFR.uchType = REC_DATA;
    // Note!! we are initializing the count of overflow records to 0
    // the routine that actually fills the structure
    // will init it to approrpiate sizes
    for (cCount = sizeof(lpFR->rgsSR)/sizeof(FILEREC) - 1; cCount >= 0; --cCount)
    lpFR->rgsSR[cCount].uchType = REC_OVERFLOW;
}

int PRIVATE CreateRecordFile(
    LPTSTR    lpdbID,
    ULONG     ulidShare,
    ULONG ulidDir,
    ULONG ulidNew
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    LPSTR lpszName;
    CSCHFILE hfDst=CSCHFILE_NULL;
    int iRet = -1;
    FILEHEADER sFH;
    ULONG uSize;

    lpszName = FormNameString(lpdbID, ulidNew);

    if (!lpszName)
    {
        return -1;

    }

    hfDst = R0OpenFileEx(ACCESS_READWRITE, ACTION_CREATEALWAYS, FILE_ATTRIBUTE_SYSTEM, lpszName, FALSE);


    if (!hfDst)
    {
        RecordKdPrint(BADERRORS,("Couldn't Create %s\n", lpszName));
        goto bailout;
    }


    if (GetFileSizeLocal(hfDst, &uSize))
        goto bailout;
    // If it is already filled up do nothing
    // BUGBUG-win9xonly this a kludge to get around Ring0 API bug in IFS
    if (uSize)
    {
        iRet = 1;
        goto bailout;
    }

    InitFileHeader(ulidShare, ulidDir, &sFH);

    if (WriteHeader(hfDst, (LPVOID)&sFH, sizeof(FILEHEADER))!=sizeof(FILEHEADER))
    {
        RecordKdPrint(BADERRORS,("Header write error in %s", lpszName));
        goto bailout;
    }
    iRet = 1;

bailout:
    if (hfDst)
        CloseFileLocal(hfDst);
    FreeNameString(lpszName);
    return iRet;
}


ULONG PUBLIC AddFileRecordFR(
    LPTSTR          lpdbID,
    ULONG           ulidDir,
    LPFILERECEXT    lpFR
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    ULONG       ulrec=INVALID_REC;


    BEGIN_TIMING(AddFileRecordFR);


    ulrec = EditRecordEx(ulidDir, (LPGENERICREC)lpFR, ICompareFileRec, INVALID_REC, CREATE_REC);

    DEBUG_LOG(RECORD,("AddFileRecordFR:Error=%d ulidDir=%xh hShadow=%xh FileName=%w\r\n",
                        (ulrec==0), ulidDir, lpFR->sFR.ulidShadow, lpFR->sFR.rgw83Name));

    END_TIMING(AddFileRecordFR);

    return (ulrec);
}


int PUBLIC DeleteFileRecord(
    LPTSTR    lpdbID,
    ULONG ulidDir,
    USHORT *lpName,
    LPFILERECEXT lpFR
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{

    ULONG       ulrec=INVALID_REC;
    BOOL        fFound = FALSE;

    InitFileRec(lpFR);

    LFNToFilerec(lpName, lpFR);

    ulrec = EditRecordEx(ulidDir, (LPGENERICREC)lpFR, ICompareFileRec, INVALID_REC, DELETE_REC);

    DEBUG_LOG(RECORD,("DeleteFileRecordFR:Error=%d ulidDir=%xh hShadow=%xh FileName=%w\r\n",
                        (ulrec==0), ulidDir, lpFR->sFR.ulidShadow, lpFR->sFR.rgw83Name));
    return (ulrec);
}

ULONG PUBLIC FindFileRecord(
    LPTSTR    lpdbID,
    ULONG ulidDir,      // which directory to look up
    USHORT *lpName,                  // string to lookup
    LPFILERECEXT lpFR                 // return the record
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    ULONG       ulrec=INVALID_REC;
    BOOL        fFound = FALSE;

    BEGIN_TIMING(FindFileRecord);

    InitFileRec(lpFR);

    LFNToFilerec(lpName, lpFR);

    ulrec = EditRecordEx(ulidDir, (LPGENERICREC)lpFR, ICompareFileRec, INVALID_REC, FIND_REC);

    RecordKdPrint(FINDFILERECORD,("FindFileRecord returns %08lx for %ws\n",ulrec,lpName));


    END_TIMING(FindFileRecord);

    return(ulrec);
}


int FindAncestorsFromInode(
    LPTSTR    lpdbID,
    ULONG ulidShadow,
    ULONG *lpulidDir,
    ULONG *lpulidShare
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    PRIQREC sPQ;
    int iRet;

    if ((iRet = FindPriQRecordInternal(lpdbID, ulidShadow, &sPQ)) >=0)
    {
        if (lpulidDir)
        {
            *lpulidDir = sPQ.ulidDir;
        }
        if (lpulidShare)
        {
            *lpulidShare = sPQ.ulidShare;
        }
    }
    return (iRet);
}

BOOL PUBLIC FInodeIsFile(
    LPTSTR    lpdbID,
    ULONG ulidDir,
    ULONG ulidShadow
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    ulidDir;
    return IsLeaf(ulidShadow);
}

int PUBLIC ICompareFileRec(
    LPFILERECEXT lpDst,
    LPFILERECEXT lpSrc
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet=1, i, cntOvf;

    // Compare the 8.3 name
    if (lpSrc->sFR.rgw83Name[0])
    {
        if (!(iRet = wstrnicmp( (CONST USHORT *)(lpDst->sFR.rgw83Name),
                                (CONST USHORT *)(lpSrc->sFR.rgw83Name),
                                sizeof(lpDst->sFR.rgw83Name)))){
            return iRet;
        }
    }

    if (lpSrc->sFR.rgwName[0] && ((cntOvf = OvfCount(lpSrc))==OvfCount(lpDst)))
    {
        // or compare the LFN name
        iRet = wstrnicmp(   (CONST USHORT *)(lpDst->sFR.rgwName),
                            (CONST USHORT *)(lpSrc->sFR.rgwName),
                            sizeof(lpDst->sFR.rgwName));

        for (i=0; (i<cntOvf) && !iRet; ++i)
        {
            iRet = wstrnicmp(   (CONST USHORT *)(lpDst->rgsSR[i].rgwOvf),
                                (CONST USHORT *)(lpSrc->rgsSR[i].rgwOvf),
                                (SIZEOF_OVERFLOW_FILEREC));
        }
    }
    return (iRet);
}

void PUBLIC CopyFindInfoToFilerec(
    LPFIND32         lpFind,
    LPFILERECEXT    lpFR,
    ULONG         uFlags
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{

    if (mCheckBit(uFlags, CPFR_INITREC))
    {
        InitFileRec(lpFR);
    }

    lpFR->sFR.dwFileAttrib = (DWORD)lpFind->dwFileAttributes;
    lpFR->sFR.ftLastWriteTime = lpFind->ftLastWriteTime;

    Win32ToDosFileSize(lpFind->nFileSizeHigh, lpFind->nFileSizeLow, &(lpFR->sFR.ulFileSize));

    if (mCheckBit(uFlags, CPFR_COPYNAME))
    {
        CopyNamesToFilerec(lpFind, lpFR);
    }
}

void PUBLIC CopyNamesToFilerec(
    LPFIND32      lpFind,
    LPFILERECEXT lpFR
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    unsigned i;

    LFNToFilerec(lpFind->cFileName, lpFR);

    // if there is an altername name, convert that too
    if (lpFind->cAlternateFileName[0])
    {
        memset(lpFR->sFR.rgw83Name, 0, sizeof(lpFR->sFR.rgw83Name));
        memcpy(lpFR->sFR.rgw83Name, lpFind->cAlternateFileName, sizeof(lpFR->sFR.rgw83Name)-sizeof(USHORT));
    }
    else
    {
        // If filename is smaller than 8.3 name stuff it in too.
        //if ((i = wstrlen(lpFind->cFileName))<
        //    (sizeof(lpFind->cAlternateFileName)/sizeof(lpFind->cAlternateFileName[0])))
		i = wstrlen(lpFind->cFileName);
		if (!IsLongFileName(lpFind->cFileName)) 
		
        {
            memset(lpFR->sFR.rgw83Name, 0, sizeof(lpFR->sFR.rgw83Name));
            memcpy(lpFR->sFR.rgw83Name, lpFind->cFileName, i*sizeof(USHORT));
        }

    }

}

void PUBLIC CopyFilerecToFindInfo(
    LPFILERECEXT    lpFR,
    LPFIND32     lpFind
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    memset(lpFind, 0, sizeof(_WIN32_FIND_DATA));
    // copy the attributes and the last write time
    lpFind->dwFileAttributes = lpFR->sFR.dwFileAttrib & ~FILE_ATTRIBUTE_ENCRYPTED;
    lpFind->ftLastWriteTime = lpFR->sFR.ftLastWriteTime;

    // Use the LastAccessTime field for ORG time
    lpFind->ftLastAccessTime = lpFR->sFR.ftOrgTime;

    DosToWin32FileSize(lpFR->sFR.ulFileSize, &(lpFind->nFileSizeHigh), &(lpFind->nFileSizeLow));

    // Convert the main name
    FilerecToLFN(lpFR, lpFind->cFileName);

    // if there is an altername name, convert that too
    if (lpFR->sFR.rgw83Name[0])
    {
        memcpy(lpFind->cAlternateFileName, lpFR->sFR.rgw83Name, sizeof(lpFR->sFR.rgw83Name)-sizeof(USHORT));
    }
}

int PRIVATE    LFNToFilerec(
    USHORT          *lpLFN,
    LPFILERECEXT    lpFR
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    size_t csCount, csSize, i=0, j, k;

    // make sure we didn't goof in structure definition
    Assert((sizeof(lpFR->sFR.rgwName)+SIZEOF_OVERFLOW_FILEREC*MAX_OVERFLOW_FILEREC_RECORDS)>=(MAX_PATH*sizeof(USHORT)));

    memset(lpFR->sFR.rgwName, 0, sizeof(lpFR->sFR.rgwName));

    for (j=0; j<MAX_OVERFLOW_FILEREC_RECORDS; ++j)
    {
        memset((lpFR->rgsSR[j].rgwOvf), 0, SIZEOF_OVERFLOW_FILEREC);
    }

    {
        // count of elements in the Unicode LFN string (without NULL)
        csCount = wstrlen(lpLFN);
        csSize = csCount*sizeof(USHORT);

        memcpy(lpFR->sFR.rgwName, lpLFN, (i = min(sizeof(lpFR->sFR.rgwName), csSize)));

        RecordKdPrint(LFN2FILEREC,("LFNToFilerec1 %ws,%x/%x>\n", lpFR->sFR.rgwName,i,csCount));

        // Keep converting till the total count of bytes exceeds the
        // # of Unicode elements
        for (j=0;(j<MAX_OVERFLOW_FILEREC_RECORDS) && (csSize > i);++j)
        {
            k = min(csSize-i, SIZEOF_OVERFLOW_FILEREC);

            memcpy(lpFR->rgsSR[j].rgwOvf, ((LPBYTE)lpLFN+i),  k);

            i += k;

            RecordKdPrint(LFN2FILEREC,("LFNToFilerec1 %ws,%x/%x>\n", lpFR->sFR.rgwName,i,csCount));
        }

        // Store the overfow record info. in the proper place
        SetOvfCount(lpFR, j);

        RecordKdPrint(LFN2FILEREC,("LFNToFilerec: %d overflow records \r\n", j));
    }
    // If it is small enough to fit as 8.3 name, copy it too
    if (i < sizeof(lpFR->sFR.rgw83Name))
    {
        memset(lpFR->sFR.rgw83Name, 0, sizeof(lpFR->sFR.rgw83Name));
        memcpy(lpFR->sFR.rgw83Name, lpFR->sFR.rgwName, i);
    }

    // return the total count of bytes in lpFR (without the NULLS)
    RecordKdPrint(LFN2FILEREC,("LFNToFilerec2 %ws %ws\n", lpFR->sFR.rgwName, lpFR->sFR.rgw83Name));
    return (i);
}

int PRIVATE    FilerecToLFN(
    LPFILERECEXT    lpFR,
    USHORT          *lpLFN
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    size_t csInSize, i=0, j;
    int count = OvfCount(lpFR);


    Assert(count <= MAX_OVERFLOW_FILEREC_RECORDS);

    {


        // Get the count of elements in the main record

        // check if the last element is NULL
        if (!lpFR->sFR.rgwName[(sizeof(lpFR->sFR.rgwName)/sizeof(USHORT))-1])
        {
            // it is NULL, so we need to find the real size
            csInSize = wstrlen(lpFR->sFR.rgwName) * sizeof(USHORT);
        }
        else
        {
            // it is not NULL, so this section is completely filled
            csInSize = sizeof(lpFR->sFR.rgwName);
        }


        // copy the bytes from filerec to LFN
        memcpy((LPBYTE)lpLFN, lpFR->sFR.rgwName, csInSize);

        i = csInSize;

        for (j=0; j<(ULONG)count;++j)
        {

            // Check if the Overflow records last wide character is NULL
            if (!lpFR->rgsSR[j].rgwOvf[(sizeof(lpFR->rgsSR[j])- sizeof(RECORDMANAGER_COMMON_RECORD))/sizeof(USHORT)-1])
            {
                // it is
                // Get the size in bytes of elements in the overflow record
                csInSize = wstrlen(lpFR->rgsSR[j].rgwOvf) * sizeof(USHORT);
            }
            else
            {
                // the record is completely full
                csInSize = sizeof(lpFR->rgsSR[0]) - sizeof(RECORDMANAGER_COMMON_RECORD);
            }

            if (!csInSize)
            {
                break;
            }

            memcpy(((LPBYTE)lpLFN+i), lpFR->rgsSR[j].rgwOvf, csInSize);

            i += csInSize;

        }

        // NULL terminate the unicode string
        *(USHORT *)((LPBYTE)lpLFN+i) = 0;
    }

    // The total count of bytes in the unicode string
    return (i);
}


int PUBLIC UpdateFileRecFromInode(
    LPTSTR    lpdbID,
    ULONG ulidDir,
    ULONG hShadow,
    ULONG ulrecDirEntry,
    LPFILERECEXT    lpFR
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    return (UpdateFileRecFromInodeEx(lpdbID, ulidDir, hShadow, ulrecDirEntry, lpFR, TRUE));
}

int PUBLIC UpdateFileRecFromInodeEx(
    LPTSTR    lpdbID,
    ULONG ulidDir,
    ULONG hShadow,
    ULONG ulrecDirEntry,
    LPFILERECEXT    lpFR,
    BOOL    fCompareInodes
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet;

    Assert(ulrecDirEntry > INVALID_REC);

    iRet = EditRecordEx(ulidDir, (LPGENERICREC)lpFR, (fCompareInodes)?ICompareFileRecInode:NULL, ulrecDirEntry, UPDATE_REC);

    return (iRet);
}

int PUBLIC FindFileRecFromInode(
    LPTSTR    lpdbID,
    ULONG ulidDir,
    ULONG ulidInode,
    ULONG ulrecDirEntry,
    LPFILERECEXT    lpFR
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet;

    InitFileRec(lpFR);
    lpFR->sFR.ulidShadow = ulidInode;

    iRet = (int)EditRecordEx(ulidDir, (LPGENERICREC)lpFR, ICompareFileRecInode, ulrecDirEntry, FIND_REC);

    return (iRet);
}

int PUBLIC DeleteFileRecFromInode(
    LPTSTR  lpdbID,
    ULONG   ulidDir,
    ULONG   ulidInode,
    ULONG   ulrecDirEntry,
    LPFILERECEXT lpFR
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet;

    InitFileRec(lpFR);
    lpFR->sFR.ulidShadow = ulidInode;

    iRet = (int)EditRecordEx(ulidDir, (LPGENERICREC)lpFR, ICompareFileRecInode, ulrecDirEntry, DELETE_REC);

    DEBUG_LOG(RECORD,("DeleteFileRecord:iRet=%d ulidDir=%xh hShadow=%xh FileName=%w\r\n",
                        (iRet), ulidDir, lpFR->sFR.ulidShadow, lpFR->sFR.rgw83Name));

    return (iRet);
}



int PUBLIC ICompareFileRecInode(
    LPFILERECEXT lpDst,
    LPFILERECEXT lpSrc
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    return ((lpDst->sFR.ulidShadow == lpSrc->sFR.ulidShadow)?0:-1);
}


int ReadDirHeader( LPTSTR    lpdbID,
    ULONG ulidDir,
    LPFILEHEADER lpFH
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet = -1;
    CSCHFILE hf;
    LPSTR   lpszName = NULL;

    lpszName = FormNameString(lpdbID, ulidDir);

    if (lpszName)
    {
        if (hf = OpenFileLocal(lpszName))
        {
            if (ReadHeader(hf, (LPGENERICHEADER)lpFH, sizeof(GENERICHEADER)) > 0)
            {
                iRet = 1;
            }
            CloseFileLocal(hf);
        }
    }

    FreeNameString(lpszName);

    return (iRet);
}

int WriteDirHeader( LPTSTR    lpdbID,
    ULONG ulidDir,
    LPFILEHEADER lpFH
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet = -1;
    CSCHFILE hf;
    LPSTR lpszName;

    lpszName = FormNameString(lpdbID, ulidDir);

    if (!lpszName)
    {
        return -1;
    }

    if (hf = OpenFileLocal(lpszName))
    {
    if (WriteHeader(hf, (LPGENERICHEADER)lpFH, sizeof(GENERICHEADER)) > 0)
        {
            iRet = 1;
        }

    CloseFileLocal(hf);
    }

    FreeNameString(lpszName);

    return (iRet);
}


#define JOE_DECL_CURRENT_PROGRESS CscProgressHasDesc
JOE_DECL_PROGRESS();

int
HasDescendents( LPTSTR    lpdbShadow,
    ULONG   ulidDir,
    ULONG   ulidShadow
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet = -1;
    ULONG count = 1;
    GENERICHEADER  sGH;
    FILERECEXT *lpFRExt;
    CSCHFILE hf = CSCHFILE_NULL;
    LPSTR   lpszName=NULL;

    JOE_INIT_PROGRESS(DelShadowInternalEntries,&lpdbShadow);

    if (FInodeIsFile(lpdbShadow, ulidDir, ulidShadow))
    {
        return 0;
    }
    else
    {
        JOE_PROGRESS(2);
        UseCommonBuff();

        lpFRExt = (FILERECEXT *)lpReadBuff;

        lpszName = FormNameString(lpdbShadow, ulidShadow);

        JOE_PROGRESS(3);
        if (!lpszName)
        {
            JOE_PROGRESS(4);
            goto bailout;
        }

        JOE_PROGRESS(5);
        if (!(hf = OpenFileLocal(lpszName)))
        {
            JOE_PROGRESS(6);
            goto bailout;
        }

        JOE_PROGRESS(7);
        if(ReadHeader(hf, &sGH, sizeof(GENERICHEADER)) < 0)
        {
            JOE_PROGRESS(8);
            goto bailout;
        }

        for (;count <=sGH.ulRecords;)
        {
            JOE_PROGRESS(9);
            iRet = ReadRecord(hf, &sGH, count, (LPGENERICREC)lpFRExt);

            JOE_PROGRESS(10);
            if (iRet < 0)
            {
                JOE_PROGRESS(11);
                goto bailout;
            }

            JOE_PROGRESS(12);
            // bump the record pointer
            count += iRet;

            if (lpFRExt->sFR.uchType == REC_DATA)
            {
                iRet = 1;
                JOE_PROGRESS(13);
                goto bailout;
            }
        }

        iRet = 0;
        JOE_PROGRESS(14);

    }
bailout:

    JOE_PROGRESS(20);

    FreeNameString(lpszName);
    JOE_PROGRESS(21);

    if (hf)
    {
        JOE_PROGRESS(22);
        CloseFileLocal(hf);
    }

    JOE_PROGRESS(23);

    UnUseCommonBuff();

    return (iRet);

}

/************************ Low level Header/Record Operations ****************/

int PUBLIC ReadHeader(
    CSCHFILE hf,
    LPGENERICHEADER lpGH,
    USHORT sizeBuff
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    return (ReadHeaderEx(hf, lpGH, sizeBuff, FALSE));

}
int PUBLIC ReadHeaderEx(
    CSCHFILE hf,
    LPGENERICHEADER lpGH,
    USHORT sizeBuff,
    BOOL    fInstrument
    )
{
    long cLength = sizeBuff;

    Assert(cLength >= sizeof(GENERICHEADER));

    if(ReadFileLocalEx(hf, 0, lpGH, cLength, fInstrument)==cLength)
    {
        if (ValidateGenericHeader(lpGH))
        {
            return cLength;
        }
        else
        {
            SetCSCDatabaseErrorFlags(CSC_DATABASE_ERROR_INVALID_HEADER);
            SetLastErrorLocal(ERROR_BAD_FORMAT);
            return -1;
        }
    }
    else
    {
        SetCSCDatabaseErrorFlags(CSC_DATABASE_ERROR_INVALID_HEADER);
        SetLastErrorLocal(ERROR_BAD_FORMAT);
        return -1;
    }
}

int PUBLIC WriteHeader(
    CSCHFILE hf,
    LPGENERICHEADER    lpGH,
    USHORT sizeBuff
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    return (WriteHeaderEx(hf, lpGH, sizeBuff, FALSE));
}

int PUBLIC WriteHeaderEx(
    CSCHFILE hf,
    LPGENERICHEADER    lpGH,
    USHORT sizeBuff,
    BOOL    fInstrument
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    long cLength = sizeBuff;

#ifdef WRITE_ERROR
    SetHeaderModFlag(lpGH, STATUS_WRITING);

    if (WriteFileLocalEx(hf, STRUCT_OFFSET(LPGENERICHEADER, uchFlags), &(lpGH->uchFlags, fInstrument),
        sizeof(lpGH->uchFlags))!=sizeof(lpGH->uchFlags))
        return -1;

#endif //WRITE_ERROR


    if(WriteFileLocalEx(hf, 0, lpGH, cLength, fInstrument)==cLength)
    {


#ifdef WRITE_ERROR
        ClearHeaderModFlag(lpGH);
        if (WriteFileLocal(hf, STRUCT_OFFSET(LPGENERICHEADER, uchFlags)
            , &(lpGH->uchFlags), sizeof(lpGH->uchFlags))!=sizeof(lpGH->uchFlags))
            return -1;
#endif //WRITE_ERROR


        return cLength;
    }
    else
        return -1;
}

int PUBLIC CopyRecord(
    LPGENERICREC    lpgrDst,
    LPGENERICREC    lpgrSrc,
    USHORT size,
    BOOL  fMarkEmpty
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int cCount, iTmp;

    cCount = OvfCount(lpgrSrc);

    for (iTmp=0;cCount>=0; --cCount)
    {
    memcpy(((LPBYTE)lpgrDst)+iTmp, ((LPBYTE)lpgrSrc)+iTmp, size);
    if (fMarkEmpty)
    {
        ((LPGENERICREC)((LPBYTE)lpgrDst+iTmp))->uchType = REC_EMPTY;
    }
    iTmp += size;
    }
    return(0);
}


int PUBLIC ReadRecord(
    CSCHFILE hf,
    LPGENERICHEADER lpGH,
    ULONG  ulRec,
    LPGENERICREC    lpSrc
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    return (ReadRecordEx(hf, lpGH, ulRec, lpSrc, FALSE));
}

int PUBLIC ReadRecordEx(
    CSCHFILE hf,
    LPGENERICHEADER lpGH,
    ULONG  ulRec,
    LPGENERICREC    lpSrc,
    BOOL    fInstrument
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    long lSeek, cRead;
    int iRet=0, cCount;

    if (ulRec > lpGH->ulRecords)
    return -1;

    lSeek = lpGH->lFirstRec + (long)(ulRec-1) * lpGH->uRecSize;

    cRead = lpGH->uRecSize;

    if ((cRead = ReadFileLocalEx(hf, lSeek, lpSrc, cRead, fInstrument)) < 0)
    return -1;

    // If some error happened in an earlier write, return
    if (ModFlag(lpSrc))
    return -1;

    lSeek += cRead;
    cCount = 1;

    if (OvfCount(lpSrc) > MAX_OVERFLOW_RECORDS)
    {
        RecordKdPrint(BADERRORS,("ReadRecordEx: Bad record; Overflow count is %d, max allowed is %d\r\n",OvfCount(lpSrc),MAX_OVERFLOW_RECORDS));
        SetCSCDatabaseErrorFlags(CSC_DATABASE_ERROR_INVALID_OVF_COUNT);
        SetLastErrorLocal(ERROR_BAD_FORMAT);
        return -1;
    }

    // Read overflow records if any
    if(OvfCount(lpSrc))
    {
        cCount += OvfCount(lpSrc);
        cRead = lpGH->uRecSize * (cCount-1);
        Assert(cRead);
        cRead = ReadFileLocalEx(hf, lSeek, (LPTSTR)lpSrc+lpGH->uRecSize, cRead, fInstrument);
        iRet = (cRead < 0);
    }
    return ((!iRet)?cCount:-1);
}


int PUBLIC WriteRecord(
    CSCHFILE hf,
    LPGENERICHEADER lpGH,
    ULONG  ulRec,
    LPGENERICREC    lpSrc
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    return (WriteRecordEx(hf, lpGH, ulRec, lpSrc, FALSE));

}
int PUBLIC WriteRecordEx(
    CSCHFILE hf,
    LPGENERICHEADER lpGH,
    ULONG  ulRec,
    LPGENERICREC    lpSrc,
    BOOL    fInstrument
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    long lSeek, cWrite;
    int cCount;

    if (ulRec > lpGH->ulRecords)
    {
        ulRec = lpGH->ulRecords+1;
    }
    lSeek = lpGH->lFirstRec + (long)(ulRec-1) * lpGH->uRecSize;
    cCount = 1 + OvfCount(lpSrc);
    cWrite = lpGH->uRecSize*cCount;


#ifdef WRITE_ERROR
    SetModFlag(lpSrc, STATUS_WRITING);
    if (WriteFileLocal(hf, lSeek+STRUCT_OFFSET(LPGENERICREC, uchFlags)
                , &(lpSrc->uchFlags)
                , sizeof(lpSrc->uchFlags))!=sizeof(lpSrc->uchFlags))
        return -1;

#endif //WRITE_ERROR

    // make sure that we are writing no-zero records
    Assert((lpSrc->uchType == REC_EMPTY)||(lpSrc->uchType == REC_DATA)||(lpSrc->uchType == REC_OVERFLOW));

    if(WriteFileLocalEx(hf, lSeek, lpSrc, cWrite, fInstrument)==cWrite)
    {


#ifdef WRITE_ERROR
    ClearModFlag(lpSrc);
    if (WriteFileLocal(hf, lSeek+STRUCT_OFFSET(LPGENERICREC, uchFlags)
                , &(lpSrc->uchFlags)
                , sizeof(lpSrc->uchFlags))!=sizeof(lpSrc->uchFlags))
        return -1;
#endif //WRITE_ERROR


        return cCount;
    }
    else
    return -1;
}

#if 0
ULONG PUBLIC EditRecord(
    ULONG   ulidInode,
    LPGENERICREC lpSrc,
    EDITCMPPROC lpCompareFunc,
    ULONG uOp
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    return(EditRecordEx(ulidInode, lpSrc, lpCompareFunc, INVALID_REC, uOp));
}
#endif

/*************************** Utility Functions ******************************/

LPVOID
PUBLIC
FormNameString(
    LPTSTR      lpdbID,
    ULONG       ulidFile
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    LPTSTR lp, lpT;
    int lendbID;
    char chSubdir;

    if (!lpdbID)
    {
        SetLastErrorLocal(ERROR_INVALID_PARAMETER);
        return (NULL);
    }

    if (lpdbID == vlpszShadowDir)
    {
        lendbID = vlenShadowDir;
    }
    else
    {
        lendbID = strlen(lpdbID);
    }

    lp = AllocMem(lendbID+1+INODE_STRING_LENGTH+1+SUBDIR_STRING_LENGTH+1);

    if (!lp)
    {
        return NULL;
    }

//      RecordKdPrint(ALWAYS,("FormNameString: Checking before memcpy\r\n"));
//      CheckHeap(lp);

    memcpy(lp, lpdbID, lendbID);


    // Bump the pointer appropriately
    lpT = lp+lendbID;

    if (*(lpT-1)!= '\\')
    {
        *lpT++ = '\\';
    }

    chSubdir = CSCDbSubdirSecondChar(ulidFile);

    // sprinkle the user files in one of the subdirectories
    if (chSubdir)
    {
        // now append the subdirectory

        *lpT++ = CSCDbSubdirFirstChar();
        *lpT++ = chSubdir;
        *lpT++ = '\\';
    }

    HexToA(ulidFile, lpT, 8);

    lpT += 8;

    *lpT = 0;

//      RecordKdPrint(ALWAYS,("FormNameString:Checking at the end\r\n"));
//      CheckHeap(lp);

    return(lp);
}


VOID
PUBLIC
FreeNameString(
    LPTSTR  lpszName
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    if (lpszName)
    {
#ifdef DEBUG
                CheckHeap(lpszName);
#endif
        FreeMem(lpszName);
    }
}

void PRIVATE DecomposeNameString(
    LPTSTR lpName,
    ULONG far *lpulidDir,
    ULONG far *lpulidFile
    )
{
    LPTSTR lp = lpName;
    *lpulidFile = AtoHex(lp, 4);
    *lpulidDir = AtoHex(lp+4, 4);
}

/******************************* Higher level queue operations **************/

BOOL
ResetInodeTransactionIfNeeded(
    void
    )
{
    BOOL    fDoneReset = FALSE;
    // if an inode transaction has gone on for too long let us nuke it
    if (cntInodeTransactions)
    {
        if ((GetTimeInSecondsSince1970() - ulLastInodeTransaction) >= MAX_INODE_TRANSACTION_DURATION_IN_SECS)
        {
            cntInodeTransactions = 0;
            RecordKdPrint(ALWAYS, ("UlAllocInode: resetting Inode transaction \r\n"));
            fDoneReset = TRUE;
        }

    }
    return fDoneReset;
}

void
BeginInodeTransaction(
    VOID
    )
{

    ResetInodeTransactionIfNeeded();

    ++cntInodeTransactions;
    ulLastInodeTransaction = GetTimeInSecondsSince1970();

    RecordKdPrint(PQ, ("BeginInodetransaction \r\n"));

}

void
EndInodeTransaction(
    VOID
    )
{
    if (cntInodeTransactions)
    {
        --cntInodeTransactions;
    }

    RecordKdPrint(PQ, ("EndInodetransaction \r\n"));
}

int PUBLIC AddPriQRecord(
    LPTSTR    lpdbID,
    ULONG     ulidShare,
    ULONG     ulidDir,
    ULONG     ulidShadow,
    ULONG     uStatus,
    ULONG     ulRefPri,
    ULONG     ulIHPri,
    ULONG     ulHintPri,
    ULONG     ulHintFlags,
    ULONG     ulrecDirEntry
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    PRIQREC sPQ;
    LPSTR   lpszName;
    int iRet=-1;
    ULONG ulRec;

    BEGIN_TIMING(AddPriQRecord);

    lpszName = FormNameString(lpdbID, ULID_PQ);

    if (!lpszName)
    {
        return -1;
    }

    InitPriQRec(ulidShare, ulidDir, ulidShadow, uStatus, ulRefPri, ulIHPri, ulHintPri, ulHintFlags, ulrecDirEntry, &sPQ);

    ulRec = RecFromInode(ulidShadow);

    ulRec = EditRecordEx(ULID_PQ, (LPGENERICREC)&sPQ, NULL, ulRec, CREATE_REC);

    if (ulRec)
    {
        Assert(ulRec == RecFromInode(ulidShadow));

        // don't worry too much about the error on PQ
        // we will try to heal it on the fly
        if (AddQRecord(lpszName, ULID_PQ, &sPQ, ulRec, IComparePri) < 0)
        {
            RecordKdPrint(BADERRORS,("Bad PQ trying to reorder!!!\r\n"));
            ReorderQ(lpdbID);
        }

        iRet = 1;
    }
    else
    {
        Assert(FALSE);
    }

    FreeNameString(lpszName);

    END_TIMING(AddPriQRecord);
    return (iRet);
}

int PUBLIC DeletePriQRecord(
    LPTSTR      lpdbID,
    ULONG       ulidDir,
    ULONG       ulidShadow,
    LPPRIQREC   lpSrc
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{

    LPSTR   lpszName;
    CSCHFILE hf;
    QREC sQR;
    ULONG ulRec;
    int iRet = -1;

    BEGIN_TIMING(DeletePriQRecord);

    CONDITIONALLY_NOP();
    lpszName = FormNameString(lpdbID, ULID_PQ);

    if (!lpszName)
    {
        return -1;
    }


    hf = OpenFileLocal(lpszName);

    if (!hf)
    {
    Assert(FALSE);
    goto bailout;
    }

    ulRec = RecFromInode(ulidShadow);

    Assert(ValidRec(ulRec));

    if (UnlinkQRecord(hf, ulRec, (LPQREC)lpSrc)>0)
    {
        Assert(lpSrc->ulidDir == ulidDir);
        Assert(lpSrc->ulidShadow == ulidShadow);

        // we set the ulidShadow of the record to 0s so that as far as priq is concerned
        // it is non-existent but it is still not de-allocated.

        //FreeInode will deallocate the record
        InitPriQRec(lpSrc->ulidShare, ulidDir, 0, 0, 0, 0, 0, 0, INVALID_REC, &sQR);

        if (EditRecordEx(ULID_PQ, (LPGENERICREC)&sQR, NULL, ulRec, UPDATE_REC))
        {
            iRet = 1;
        }
    }

bailout:
    if (hf)
    {
        CloseFileLocal(hf);
    }

    FreeNameString(lpszName);

    END_TIMING(DeletePriQRecord);
    DEBUG_LOG(RECORD,("DeletePriQRecord:iRet=%d, ulidDir=%xh, ulidSHadow=%xh\r\n", iRet, ulidDir, ulidShadow));
    return (iRet);
}

int PUBLIC FindPriQRecord(
    LPTSTR      lpdbID,
    ULONG       ulidDir,
    ULONG       ulidShadow,
    LPPRIQREC   lpSrc
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    CONDITIONALLY_NOP();

    if(FindPriQRecordInternal(lpdbID, ulidShadow, lpSrc) >= 0)
    {
        if (lpSrc->ulidDir == ulidDir)
        {
            return 1;
        }
    }

    return -1;
}

int FindPriQRecordInternal(
    LPTSTR      lpdbID,
    ULONG       ulidShadow,
    LPPRIQREC   lpSrc
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet=-1;
    ULONG ulRec;

    BEGIN_TIMING(FindPriQRecordInternal);


    ulRec = RecFromInode(ulidShadow);

    if(EditRecordEx(ULID_PQ, (LPGENERICREC)lpSrc, NULL, ulRec, FIND_REC))
    {
        // don't check whether the returned inode is of the same type or not
        if (lpSrc->ulidShadow)
        {
            iRet = 1;
        }
    }

    END_TIMING(FindPriQRecordInternal);
    return (iRet);
}



int PUBLIC UpdatePriQRecord(
    LPTSTR      lpdbID,
    ULONG       ulidDir,
    ULONG       ulidShadow,
    LPPRIQREC   lpPQ
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet = -1;
    ULONG ulrecSrc;

    CONDITIONALLY_NOP();

//    Assert(ValidInode(lpPQ->ulidShadow));

    Assert(lpPQ->ulidShadow == ulidShadow);

    Assert(lpPQ->uchType == REC_DATA);

    ulrecSrc = RecFromInode(lpPQ->ulidShadow);

    Assert(ValidRec(ulrecSrc));

    if(EditRecordEx(ULID_PQ, (LPGENERICREC)lpPQ, NULL, ulrecSrc, UPDATE_REC))
    {
        iRet = 1;
    }

    return (iRet);
}

int PUBLIC UpdatePriQRecordAndRelink(
    LPTSTR      lpdbID,
    ULONG       ulidDir,
    ULONG       ulidShadow,
    LPPRIQREC   lpPQ
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet;
    ULONG ulrecSrc;

    Assert(lpPQ->ulidShadow == ulidShadow);

    Assert(lpPQ->uchType == REC_DATA);

    ulrecSrc = RecFromInode(lpPQ->ulidShadow);

    Assert(ValidRec(ulrecSrc));

    iRet = RelinkQRecord(lpdbID, ULID_PQ, ulrecSrc, lpPQ, IComparePri);

    if (iRet < 0)
    {
        RecordKdPrint(BADERRORS,("Bad PQ, trying to reorder!!!\r\n"));
        ReorderQ(lpdbID);
        iRet = 1;
    }
    else
    {
        // iRet == 0 => record is OK where it is now
        // iRet == 1 => it has been relinked, this also means other values have been
        // updated

        if (iRet == 0)
        {
            // the record is OK where it is, we need to write the rest of the info

            if(EditRecordEx(ULID_PQ, (LPGENERICREC)lpPQ, NULL, ulrecSrc, UPDATE_REC))
            {
                iRet = 1;
            }

        }
    }

    return (iRet);
}

void PRIVATE InitPriQRec(
    ULONG ulidShare,
    ULONG ulidDir,
    ULONG ulidShadow,
    ULONG uStatus,
    ULONG ulRefPriority,
    ULONG ulIHPriority,
    ULONG ulHintPri,
    ULONG ulHintFlags,
    ULONG ulrecDirEntry,
    LPPRIQREC    lpDst
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    memset((LPVOID)lpDst, 0, sizeof(PRIQREC));
    lpDst->uchType = REC_DATA;
    lpDst->ulidShare = ulidShare;
    lpDst->ulidDir = ulidDir;
    lpDst->ulidShadow = ulidShadow;
    lpDst->usStatus = (USHORT)uStatus;
    lpDst->uchRefPri = (UCHAR)ulRefPriority;
    lpDst->uchIHPri = (UCHAR)ulIHPriority;
    lpDst->uchHintFlags = (UCHAR)ulHintFlags;
    lpDst->uchHintPri = (UCHAR)ulHintPri;
    lpDst->ulrecDirEntry = ulrecDirEntry;
}

int PUBLIC IComparePri(
    LPPRIQREC    lpDst,
    LPPRIQREC    lpSrc
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    USHORT usSrc, usDst;

    usSrc = lpSrc->uchRefPri;
    usDst = lpDst->uchRefPri;

    return ((usDst > usSrc)?1:((usDst == usSrc)?0:-1));
}

int PUBLIC ICompareQInode(
    LPPRIQREC    lpDst,
    LPPRIQREC    lpSrc
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    return ((lpDst->ulidShadow == lpSrc->ulidShadow)?0:-1);
}

ULONG PUBLIC UlAllocInode(
    LPTSTR    lpdbID,
    ULONG ulidDir,
    BOOL fFile
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    PRIQREC sPQ;
    ULONG ulRec;
    HSHADOW hShadow = INVALID_SHADOW;

    ResetInodeTransactionIfNeeded();

    InitPriQRec(0, ulidDir, 0, 0, 1, 0, 0, 0, INVALID_REC, &sPQ);

    if(ulRec = EditRecordEx(ULID_PQ, (LPGENERICREC)&sPQ, ICompareFail, INVALID_REC, ALLOC_REC))
    {
        hShadow = InodeFromRec(ulRec, fFile);
    }

    RecordKdPrint(PQ,("UlAllocInode: rec=%x, inode=%x", ulRec, hShadow));
    return (hShadow);
}

int PUBLIC FreeInode(
    LPTSTR    lpdbID,
    ULONG ulidFree
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    PRIQREC sPQ;
    ULONG ulRec;
    HSHADOW hShadow = INVALID_SHADOW;

    ulRec = RecFromInode(ulidFree);
    RecordKdPrint(PQ,("FreeInode: rec=%x, inode=%x", ulRec, ulidFree));

    Assert(ValidRec(ulRec));

    memset(&sPQ, 0, sizeof(sPQ));

    ulRec = EditRecordEx(ULID_PQ, (LPGENERICREC)&sPQ, NULL, ulRec, DELETE_REC);

    return ((ulRec != 0)?1:-1);
}

/******************************* Queue operations ***************************/
void
InitQHeader(
    LPQHEADER lpQH
    )
{
    memset((LPVOID)lpQH, 0, sizeof(PRIQHEADER));
    lpQH->uRecSize = sizeof(PRIQREC);
    lpQH->lFirstRec = (LONG) sizeof(PRIQHEADER);
    lpQH->ulVersion = CSC_DATABASE_VERSION;
}

CSCHFILE
PUBLIC
BeginSeqReadPQ(
    LPTSTR    lpdbID
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    LPSTR   lpszName;
    CSCHFILE hf;

    lpszName = FormNameString(lpdbID, ULID_PQ);
    if (!lpszName)
    {
        return (CSCHFILE_NULL);
    }
    hf = OpenFileLocal(lpszName);
    FreeNameString(lpszName);
    return (hf);
}

int PUBLIC SeqReadQ(
    CSCHFILE hf,
    LPQREC    lpSrc,
    LPQREC    lpDst,
    USHORT    uOp
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    QHEADER sQH;
    ULONG ulrecSeek = 0L, cLength;
    int iRet = -1;

    cLength = sizeof(QHEADER);
    if (ReadFileLocal(hf, 0L, (LPVOID)&sQH, cLength) < 0)
        goto bailout;

    switch (uOp)
    {
    case Q_GETFIRST:
        ulrecSeek = sQH.ulrecHead;
        break;
    case Q_GETNEXT:
        ulrecSeek = lpSrc->ulrecNext;
        break;
    case Q_GETLAST:
        ulrecSeek = sQH.ulrecTail;
        break;
    case Q_GETPREV:
        ulrecSeek = lpSrc->ulrecPrev;
        break;
    }
    if (ulrecSeek)
    {
        iRet = ReadRecord(hf, (LPGENERICHEADER)&sQH, ulrecSeek, (LPGENERICREC)lpDst);
    }
    else
    {
        lpDst->ulrecNext = lpDst->ulrecPrev = 0L;
        iRet = 0;
    }
bailout:
    return (iRet);
}

int PUBLIC
EndSeqReadQ(
    CSCHFILE hf
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    return(CloseFileLocal(hf));
}


int PUBLIC AddQRecord(
    LPTSTR  lpQFile,
    ULONG   ulidPQ,
    LPQREC  lpSrc,
    ULONG   ulrecNew,
    EDITCMPPROC fnCmp
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    CSCHFILE hf=CSCHFILE_NULL;
    ULONG ulrecPrev, ulrecNext;
    int iRet = -1, cntRetry;
    BOOL   fCached;

    // We are writing somewhere else
    lpSrc->ulrecNext = lpSrc->ulrecPrev = 0L;

    for(cntRetry=0; cntRetry<=1; cntRetry++)
    {
        hf = OpenInodeFileAndCacheHandle(vlpszShadowDir, ulidPQ, ACCESS_READWRITE, &fCached);

        if (!hf)
        {
            Assert(FALSE);
            return -1;
        }

        if (IsLeaf(lpSrc->ulidShadow))
        {
            BEGIN_TIMING(FindQRecordInsertionPoint_Addq);
        }
        else
        {
            BEGIN_TIMING(FindQRecordInsertionPoint_Addq_dir);
        }

        // Let us find a position to add it,
        iRet = FindQRecordInsertionPoint(   hf,
                    lpSrc,      // record to insert
                    INVALID_REC,// start from the head of the queue
                    fnCmp,      // comparison function
                    &ulrecPrev,
                    &ulrecNext);

        DEBUG_LOG(RECORD,("AddQRecord:Insertion points: Inode=%xh, ulrecPrev=%d, ulrecNext=%d \r\n", lpSrc->ulidShadow, ulrecPrev, ulrecNext));

        if (IsLeaf(lpSrc->ulidShadow))
        {
            END_TIMING(FindQRecordInsertionPoint_Addq);
        }
        else
        {
            END_TIMING(FindQRecordInsertionPoint_Addq_dir);
        }

        if (iRet<0)
        {
            if (cntRetry < 1)
            {

                RecordKdPrint(BADERRORS,("FindQRecordInsertionPoint: failed\r\n"));
                RecordKdPrint(BADERRORS,("FindQRecordInsertionPoint: purging handle cache and retrying \r\n"));

                DeleteFromHandleCache(INVALID_SHADOW);

                continue;
            }
            else
            {
                RecordKdPrint(BADERRORS,("FindQRecordInsertionPoint: failed, bailing out\r\n"));
                goto bailout;
            }
        }
        else
        {
            break;
        }
    }

    BEGIN_TIMING(LinkQRecord_Addq);

    Assert((ulrecNew != ulrecPrev) && (ulrecNew != ulrecNext));

    iRet = LinkQRecord(hf, lpSrc, ulrecNew, ulrecPrev, ulrecNext);

    END_TIMING(LinkQRecord_Addq);

    RecordKdPrint(PQ, ("AddQRecord: linking %x between prev=%x and Next=%x \r\n", ulrecNew, ulrecPrev, ulrecNext));

bailout:
    if (hf && !fCached)
    {
        Assert(vfStopHandleCaching);
        CloseFileLocal(hf);
    }
    else
    {
        Assert(!hf || !vfStopHandleCaching);
    }
    return (iRet);
}

int PUBLIC FindQRecordInsertionPoint(
    CSCHFILE   hf,
    LPQREC  lpSrc,
    ULONG   ulrecStart,
    EDITCMPPROC fnCmp,
    ULONG   *lpulrecPrev,
    ULONG   *lpulrecNext
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    QHEADER sQH;
    QREC sQR;
    ULONG ulrecFound, ulCnt;
    int iCmp;
    ULONG   fDownward;

    // Let us grab the header first
    if (ReadHeader(hf, (LPGENERICHEADER)&sQH, sizeof(QHEADER))<= 0)
        return -1;

//    Assert(!((ulrecStart == INVALID_REC) && !fDownward));

    // we do trivial checks for MAX and MIN
    if (lpSrc->uchRefPri >= MAX_PRI)
    {
        // if the passed in record is already at the head
        // then the current insertion point is just fine
        if ((ulrecStart != INVALID_REC) && (ulrecStart == sQH.ulrecHead))
        {
            return 0;
        }
        // make it the head

        *lpulrecPrev = 0;   // no prev

        *lpulrecNext = sQH.ulrecHead; // current head is the next

        RecordKdPrint(PQ,("FindQInsertionPoint: Insertion point for %x with ref=%d between prev=%x and Next=%x \r\n",
            lpSrc->ulidShadow, lpSrc->uchRefPri, *lpulrecPrev, *lpulrecNext));
        return 1;
    }
    // min priority?
    if (lpSrc->uchRefPri <= MIN_PRI)
    {
        // if the passed in record is already at the tail
        // then the current insertion point is just fine
        if ((ulrecStart != INVALID_REC) && (ulrecStart == sQH.ulrecTail))
        {
            return 0;
        }
        // make it the tail
        *lpulrecNext = 0;   // no next

        *lpulrecPrev = sQH.ulrecTail; // current  tail is the prev

        RecordKdPrint(PQ,("FindQInsertionPoint: Insertion point for %x with ref=%d between prev=%x and Next=%x \r\n",
            lpSrc->ulidShadow, lpSrc->uchRefPri, *lpulrecPrev, *lpulrecNext));
        return 1;
    }

    if (ulrecStart == INVALID_REC)
    {

        fDownward = (IsLeaf(lpSrc->ulidShadow)?TRUE:FALSE);

    }
    else
    {
        if(ReadRecord(hf, (LPGENERICHEADER)&sQH, ulrecStart, (LPGENERICREC)&sQR) <=0)
        {
            Assert(FALSE);
            return -1;
        }
        // is exiting record greater than the passed in record?
        // 1 => yes, 0 => equal, -1 => less
        iCmp = (*fnCmp)(&sQR, lpSrc);

        if (iCmp == 0)
        {
            *lpulrecPrev = sQR.ulrecPrev;
            *lpulrecNext = sQR.ulrecNext;

            return 0;
        }
        else {
            if (iCmp > 0)
            {
                // the existing record is greater than the new record
                // go down
                fDownward = TRUE;
                ulrecStart = sQR.ulrecNext;
            }
            else
            {
                // the existing record is less than the new record
                // go up
                fDownward = FALSE;
                ulrecStart = sQR.ulrecPrev;

            }
        }
    }

    // Start reading from the head and downward if starting rec is not provided
    // ensure that we don't traverse more than the total number of records in the PQ.
    // Thus if because of some problem there are loops in the PQ, we won't be stuck here.

    for (   ulrecFound = ((ulrecStart == INVALID_REC)?
                            ((fDownward)?sQH.ulrecHead:sQH.ulrecTail):ulrecStart),
                            ulCnt = sQH.ulRecords;
                        ulrecFound && ulCnt;
                        (ulrecFound = ((fDownward)?sQR.ulrecNext:sQR.ulrecPrev), --ulCnt)
        )
    {
        if(ReadRecord(hf, (LPGENERICHEADER)&sQH, ulrecFound, (LPGENERICREC)&sQR) <=0)
            return -1;


        if (fDownward)
        {
            // if we are going towards the tail (fDownward==TRUE ie: lower priority nodes) and
             // if the comparison function said that our priority is better than that of the one
            // pointed to by ulrecFound, then we must get inserted such that
            // ulrecFound is our next and it's prev is our prev

            *lpulrecNext = ulrecFound;
            *lpulrecPrev = sQR.ulrecPrev;
        }
        else
        {
            // if we are going towards the head (fDownward==FALSE ie: higher priority nodes)
            // and if the comparison function said that our priority is <= that of the one
            // pointed to by ulrecFound, then we must get inserted such that
            // ulrecFound is our prev and it's next is our Next

            *lpulrecPrev = ulrecFound;
            *lpulrecNext = sQR.ulrecNext;
        }


        // compare current record against passed in record
        // -1 => sQR<lpSrc
        // 0 => sQR==lpSrc
        // 1 => sQR>lpSrc

        iCmp = (*fnCmp)(&sQR, lpSrc);

        if (fDownward)
        {
            if (iCmp <= 0)
            {
                // found an entry which is equal to or less than the input priority
                break;
            }
        }
        else
        {
            if (iCmp >= 0)
            {
                // found an entry which is equal to or greater than the input priority
                break;
            }
        }
    }

    if (!ulrecFound)
    {
        // we are supposed to get inserted at the head or the tail

        // if going down, the current tail becomes our prev and we become the new tail
        // if going up, the current head becomes our next and we become the new head

        *lpulrecPrev = (fDownward)?sQH.ulrecTail:0;
        *lpulrecNext = (fDownward)?0:sQH.ulrecHead;
    }

    RecordKdPrint(PQ,("FindQInsertionPoint: Insertion point for %x with ref=%d between prev=%x and Next=%x \r\n", lpSrc->ulidShadow, lpSrc->uchRefPri, *lpulrecPrev, *lpulrecNext));
    return (1);
}

int PUBLIC DeleteQRecord(
    LPTSTR          lpQFile,
    LPQREC          lpSrc,
    ULONG           ulRec,
    EDITCMPPROC     fnCmp
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    CSCHFILE hf;
    int iRet = -1;

    hf = OpenFileLocal(lpQFile);

    if (!hf)
    {
    Assert(FALSE);
    return -1;
    }

    Assert(ValidRec(ulRec));

    iRet = UnlinkQRecord(hf, ulRec, lpSrc);

    CloseFileLocal(hf);

    return (iRet);
}

int PUBLIC RelinkQRecord(
    LPTSTR  lpdbID,
    ULONG   ulidPQ,
    ULONG   ulRec,
    LPQREC  lpSrc,
    EDITCMPPROC fnCmp
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    CSCHFILE hf;
    QREC    sQR1;
#ifdef DEBUG
    QREC sQRNext, sQRPrev;
#endif
    ULONG ulrecPrev, ulrecNext;
    int iRet = -1;
    LPSTR   lpszName;
    BOOL    fCached;

    hf = OpenInodeFileAndCacheHandle(lpdbID, ULID_PQ, ACCESS_READWRITE, &fCached);

    if (!hf)
    {
        return -1;
    }

    Assert(ValidRec(ulRec));

    // Let us find a position to add it,
    // iRet == 1 means it needs relinking
    // iRet ==0 means it is OK where it is
    // iRet < 0 means there has been some error

    iRet = FindQRecordInsertionPoint(  hf,
                lpSrc,
                ulRec,      // start looking from the current copy of the record
                fnCmp,
                &ulrecPrev, //returns rec # of the prev guy
                &ulrecNext); //returns rec # of the next guy

    if (iRet < 0)
        goto bailout;

#ifdef DEBUG

    // verify the reinsertion logic
    if (iRet == 1)
    {
        if (ulrecNext)
        {

            if (!EditRecordEx(ULID_PQ, (LPGENERICREC)&sQRNext, NULL, ulrecNext, FIND_REC))
            {
                Assert(FALSE);

            }
            else
            {

                if(sQRNext.uchRefPri > lpSrc->uchRefPri)
                {
                    LPQREC lpQT = &sQRNext;

                    RecordKdPrint(BADERRORS,("RelinkQRecord: Out of order insertion in PQ\r\n"));
                    RecordKdPrint(BADERRORS,("sQRNext.uchRefPri=%d lpSrc->uchRefPri=%d\r\n",(unsigned)(sQRNext.uchRefPri), (unsigned)(lpSrc->uchRefPri)));
                    RecordKdPrint(BADERRORS,("lpSrc=%x sQRNext=%x ulrecPrev=%d ulrecNext=%d\r\n", lpSrc, lpQT, ulrecPrev, ulrecNext));
//                    Assert(FALSE);
                }
            }
        }
        if (ulrecPrev)
        {

            if (!EditRecordEx(ULID_PQ, (LPGENERICREC)&sQRPrev, NULL, ulrecPrev, FIND_REC))
            {
                Assert(FALSE);

            }
            else
            {
                if(sQRPrev.uchRefPri < lpSrc->uchRefPri)
                {
                    LPQREC lpQT = &sQRPrev;
                    RecordKdPrint(BADERRORS,("RelinkQRecord: Out of order insertion in PQ\r\n"));
                    RecordKdPrint(BADERRORS,("sQRPrev.uchRefPri=%d lpSrc->uchRefPri=%d\r\n",(unsigned)(sQRPrev.uchRefPri), (unsigned)(lpSrc->uchRefPri)));
                    RecordKdPrint(BADERRORS,("lpSrc=%x sQRPrev=%x ulrecPrev=%d ulrecNext=%d\r\n", lpSrc, lpQT, ulrecPrev, ulrecNext));
//                    Assert(FALSE);
                }
            }
        }
    }
#endif //DEBUG

    Assert((iRet == 0) || ulrecPrev || ulrecNext);

    RecordKdPrint(PQ, ("RelinkQRecord: old location for %x with ref=%d at prev=%x and Next=%x \r\n", ulRec, lpSrc->uchRefPri, lpSrc->ulrecPrev, lpSrc->ulrecNext));
    RecordKdPrint(PQ, ("RelinkQRecord: new location at prev=%x and Next=%x \r\n", ulrecPrev, ulrecNext));

    if ((iRet == 0)||(ulrecPrev == ulRec)||(ulrecNext == ulRec))
    {
        RecordKdPrint(PQ, ("RelinkQRecord: %x is OK at its place for pri=%d\r\n", ulRec, lpSrc->uchRefPri));
        iRet = 0;
        goto bailout;
    }

    if ((iRet = UnlinkQRecord(hf, ulRec, &sQR1))>=0)
    {
        iRet = LinkQRecord(hf, lpSrc, ulRec, ulrecPrev, ulrecNext);
        if (iRet >= 0)
        {
            // return the fact that we relinked
            iRet = 1;
        }
    }

bailout:
    if (hf && !fCached)
    {
        Assert(vfStopHandleCaching);
        CloseFileLocal(hf);
    }
    else
    {
        Assert(!hf || !vfStopHandleCaching);
    }
    return (iRet);
}


int PRIVATE UnlinkQRecord(
    CSCHFILE hf,
    ULONG ulRec,
    LPQREC lpQR
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    QHEADER sQH;
    QREC sQRPrev, sQRNext;
    BOOL fPrev=FALSE, fNext=FALSE;

    // Let us grab the header first
    if (ReadHeader(hf, (LPGENERICHEADER)&sQH, sizeof(QHEADER))<= 0)
        return -1;

    if (ReadRecord(hf, (LPGENERICHEADER)&sQH, ulRec, (LPGENERICREC)lpQR) < 0)
    {
        return -1;
    }

    // Did we have a prev?
    if (lpQR->ulrecPrev)
    {
        // yes, let us read it
        fPrev = (ReadRecord(hf, (LPGENERICHEADER)&sQH, lpQR->ulrecPrev, (LPGENERICREC)&sQRPrev)>0);
        if (!fPrev)
            return -1;
    }
    // Did we have a Next
    if (lpQR->ulrecNext)
    {
        // yes, let us read it
        fNext = (ReadRecord(hf, (LPGENERICHEADER)&sQH, lpQR->ulrecNext, (LPGENERICREC)&sQRNext)>0);
        if (!fNext)
            return -1;
    }

    // Plug these values assuming no special cases
    sQRNext.ulrecPrev =  lpQR->ulrecPrev;
    sQRPrev.ulrecNext =  lpQR->ulrecNext;

    // Were we at the head
    if (!fPrev)
    {
        // modify the head in the header to point to our next
        sQH.ulrecHead = lpQR->ulrecNext;
    }
    // Were we at the tail
    if (!fNext)
    {
        // modify the tail in the header to point to our prev
        sQH.ulrecTail = lpQR->ulrecPrev;
    }

    // Write our next if it exists
    if (fNext)
    {
        Assert(lpQR->ulrecNext != sQRNext.ulrecNext);
        Assert(lpQR->ulrecNext != sQRNext.ulrecPrev);
        if (WriteRecord(hf, (LPGENERICHEADER)&sQH, lpQR->ulrecNext, (LPGENERICREC)&sQRNext)<=0)
            return -1;
    }

    // Write our prev if it exists
    if (fPrev)
    {
        Assert(lpQR->ulrecPrev != sQRPrev.ulrecNext);
        Assert(lpQR->ulrecPrev != sQRPrev.ulrecPrev);
        if (WriteRecord(hf, (LPGENERICHEADER)&sQH, lpQR->ulrecPrev, (LPGENERICREC)&sQRPrev) <=0)
            return -1;
    }
    // Did we get removed from head or tail?
    if (!fPrev || !fNext)
    {
        if(WriteHeader(hf, (LPVOID)&sQH, sizeof(QHEADER))<=0)
            return -1;
    }
    return 1;
}



int PRIVATE LinkQRecord(
    CSCHFILE     hf,           // This file
    LPQREC    lpNew,        // Insert This record
    ULONG     ulrecNew,     // This is it's location in the file
    ULONG     ulrecPrev,     // This is our Prev's location
    ULONG     ulrecNext      // This is our Next's location
    )
{
    QHEADER sQH;
    QREC  sQRNext, sQRPrev;
    BOOL fPrev, fNext;
#ifdef DEBUG
    QHEADER sQHOrg;
    QREC    sQRNextOrg, sQRPrevOrg, sQRNewOrg;
#endif

    // Let us grab the header first
    if (ReadHeader(hf, (LPGENERICHEADER)&sQH, sizeof(QHEADER))<= 0)
        return -1;
#ifdef DEBUG
    sQHOrg = sQH;
    sQRNewOrg=*lpNew;
#endif


    fPrev = fNext = FALSE;

    // Let us now modify the Next related pointers
    if (ulrecNext)
    {
        // normal case
        // Read the record at ulrecNext

        if (ReadRecord(hf, (LPGENERICHEADER)&sQH, ulrecNext, (LPGENERICREC)&sQRNext) <=0)
            return -1;

#ifdef DEBUG
        sQRNextOrg = sQRNext;
#endif
        // Change it's Prev to point to new
        sQRNext.ulrecPrev = ulrecNew;

        // And new's Next to point to ulrecNext
        lpNew->ulrecNext = ulrecNext;

        // note that ulrecNext has been modified and hence must be written
        fNext=TRUE;
    }
    else
    {
        // no next, that means the new record is being added at the tail of the list
        // this must mean that if there is a ulrecPrev, then it is the current tail

        Assert(!ulrecPrev || (ulrecPrev == sQH.ulrecTail));

        // Mark nobody as our Next
        lpNew->ulrecNext = 0L;
        lpNew->ulrecPrev = sQH.ulrecTail;
        sQH.ulrecTail = ulrecNew;
    }

    // Now let us modify  Prev related pointers

    // Are supposed to have a Prev?
    if (ulrecPrev)
    {
        // normal case
        // Read the (tobe) Prev record

        if (ReadRecord(hf, (LPGENERICHEADER)&sQH, ulrecPrev, (LPGENERICREC)&sQRPrev) <=0)
            return -1;

#ifdef DEBUG
        sQRPrevOrg = sQRPrev;
#endif
        // make the new one his next
        sQRPrev.ulrecNext = ulrecNew;

        // make the prev the prev of new one
        lpNew->ulrecPrev = ulrecPrev;

        // Note the fact that the record at ulrecPrev was modified and must be written out
        fPrev = TRUE;
    }
    else
    {
        // no previous, that means the new record is being added at the head of the list
        // this must mean that if there is a ulrecNext, then it is the current head

        Assert(!ulrecNext || (ulrecNext == sQH.ulrecHead));

        // Make the head guy our Next, nobody as our Prev
        lpNew->ulrecNext = sQH.ulrecHead;
        lpNew->ulrecPrev = 0L;

        // Change the head pointer in the header to point to us
        sQH.ulrecHead = ulrecNew;
    }


    // let us first link the new record in. The order is important.
    // If subsequent operations fail, the linked list is not broken
    // It may be that traverseing from top to bottom might include
    // this new element but may not include it from bottom to top

#ifdef DEBUG
    if ((ulrecNew == lpNew->ulrecPrev)||(ulrecNew == lpNew->ulrecNext))
    {
        LPQHEADER lpQHOrg = &sQHOrg, lpQHT=&sQH;

        RecordKdPrint(BADERRORS,("LinkQRecord: Circular linking sQHOrg.ulrecHead=%d sQHOrg.ulrecTail=%d\r\n",
                        sQHOrg.ulrecHead, sQHOrg.ulrecTail));

        RecordKdPrint(BADERRORS,("sQRNewOrg.ulrecPrev=%d, sQRNewOrg.ulrecNext=%d", sQRNewOrg.ulrecPrev, sQRNewOrg.ulrecNext));

        RecordKdPrint(BADERRORS,("sQRPrevOrg.ulrecPrev=%d, sQRPrevOrg.ulrecNext=%d", sQRPrevOrg.ulrecPrev, sQRPrevOrg.ulrecNext));

        RecordKdPrint(BADERRORS,("sQHOrg=%x sQH=%x\r\n", lpQHOrg,lpQHT));

        Assert(FALSE);
    }
#endif

    if(WriteRecord(hf, (LPGENERICHEADER)&sQH, ulrecNew, (LPGENERICREC)lpNew) < 0)
        return -1;

    if (fPrev)
    {
        Assert(ulrecPrev != sQRPrev.ulrecPrev);
        Assert(ulrecPrev != sQRPrev.ulrecNext);

        Assert(lpNew->uchRefPri <= sQRPrev.uchRefPri);

        if(WriteRecord(hf, (LPGENERICHEADER)&sQH, ulrecPrev, (LPGENERICREC)&sQRPrev) < 0)
            return -1;
    }
    if (fNext)
    {
        Assert(ulrecNext != sQRNext.ulrecPrev);
        Assert(ulrecNext != sQRNext.ulrecNext);

        Assert(lpNew->uchRefPri >= sQRNext.uchRefPri);

    if (WriteRecord(hf, (LPGENERICHEADER)&sQH, ulrecNext, (LPGENERICREC)&sQRNext) < 0)
        return -1;
    }

    if (!fNext || !fPrev)
        if (WriteHeader(hf, (LPGENERICHEADER)&sQH, sizeof(QHEADER))<0)
            return -1;

    return (1);
}


#ifdef LATER
LPPATH PRIVATE LpAppendStartDotStar
    (
    LPPATH lpSrc
    )
{
    count = strlen(lpSrc)+strlen(szStar)+1;
    if (!(lpNewSrc = (LPTSTR)AllocMem(count)))
    {
        RecordKdPrint(BADERRORS,("CopyDir: Memalloc failed\r\n"));
        return -1;
    }
    strcpy(lpNewSrc, lpSrc);
    strcat(lpNewSrc, szStar);
}

#endif //LATER

ULONG PRIVATE GetNormalizedPri(
    ULONG ulPri
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    ulPri = min(ulPri, MAX_PRI);
    ulPri = max(ulPri, MIN_PRI);
    return (ulPri);
}

ULONG PUBLIC AllocFileRecord(
    LPTSTR    lpdbID,
    ULONG ulidDir,
    USHORT    *lpcFileName,
    LPFILERECEXT    lpFR
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    ULONG ulRec;


    InitFileRec(lpFR);
    LFNToFilerec(lpcFileName, lpFR);
    ulRec = EditRecordEx(ulidDir, (LPGENERICREC)lpFR, ICompareFail, INVALID_REC, ALLOC_REC);

    return (ulRec);
}

ULONG PUBLIC AllocPQRecord(
    LPTSTR    lpdbID)
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    PRIQREC sPQ;
    ULONG ulRec;

    InitPriQRec(0, 0, 0, 0, 0, 0, 0, 0, 0, &sPQ);
    ulRec = EditRecordEx(ULID_PQ, (LPGENERICREC)&sPQ, ICompareFail, INVALID_REC, ALLOC_REC);

    return (ulRec);
}


ULONG AllocShareRecord( LPTSTR    lpdbID,
    USHORT *lpShare
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    SHAREREC sSR;
    ULONG ulRec=0;

    // we deal with \\server\share names of limited size.
    if (wstrlen(lpShare) < sizeof(sSR.rgPath))
    {

        if(!InitShareRec(&sSR, lpShare, 0))
        {
            return 0;
        }

        // Let us get the location of the soon to be server record
        ulRec = EditRecordEx(ULID_SHARE, (LPGENERICREC)&sSR, ICompareFail, INVALID_REC, ALLOC_REC);
    }

    return (ulRec);
}

int PRIVATE ICompareFail(
    LPGENERICREC    lpSrc,
    LPGENERICREC    lpDst
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    lpSrc;
    lpDst;
    return(1);
}

#ifdef MAYBE
BOOL
InsertInNameCache(
    HSHADOW hDir,
    HSHADOW hShadow,
    USHORT  *lpName,
    ULONG   ulrec,
    FILERECEXT  *lpFR
    )
{
    int     indx, len;
    DWORD   dwHash;
    BOOL fRet = FALSE;


    if(FindNameCacheEntryEx(hDir, hShadow, lpName, &dwHash, &indx))
    {
    Assert(indx >= 0 && indx < NAME_CACHE_TAB_SIZE);

    return TRUE;
    }
    else
    {

        Assert(indx >= 0 && indx < NAME_CACHE_TAB_SIZE);

        if(rgNameCache[indx] != NULL)
        {
            FreeMem(rgNameCache[indx]);
            rgNameCache[indx] = NULL;
        }

        len = wstrlen(lpName);

        if(rgNameCache[indx] = AllocMem(sizeof(NAME_CACHE_ENTRY)+sizeof(FILERECEXT)+(len+1)*sizeof(USHORT)))
        {
            rgNameCache[indx]->dwHash = dwHash;
            rgNameCache[indx]->hDir = hDir;
            rgNameCache[indx]->hShadow = hDir;
            rgNameCache[indx]->ulrec = ulrec;

            memcpy(&(rgNameCache[indx]->sFR), lpFR, sizeof(FILERECEXT));

            memcpy(rgNameCache[indx]->rgName, lpName, (len+1)*sizeof(USHORT));
            fRet = TRUE;
        }
    }

    return (fRet);
}

BOOL
DeleteFromNameCache(
    HSHADOW hDir,
    HSHADOW hShadow,
    USHORT  *lpName,
    ULONG   *lpulrec,
    FILERECEXT  *lpFR

)
{

    int     indx = -1;
    DWORD   dwHash;
    BOOL fFound;

    if(fFound = FindNameCacheEntryEx(hDir, hShadow, lpName, &dwHash, &indx))
    {
    Assert(indx >= 0 && indx < NAME_CACHE_TAB_SIZE);

    if(rgNameCache[indx] != NULL)
    {
        *lpulrec = rgNameCache[indx]->ulrec;
        memcpy(lpFR, &(rgNameCache[indx]->sFR), sizeof(FILERECEXT));
        FreeMem(rgNameCache[indx]);
        rgNameCache[indx] = NULL;
    }
    }

    return (fFound);
}

BOOL
FindNameCacheEntry(
    HSHADOW hDir,
    HSHADOW hShadow,
    USHORT  *lpName,
    ULONG   *lpulrec
    FILERECEXT  *lpFR
    )
{

    int     indx;
    DWORD   dwHash;
    BOOL fFound;

    dwNCETotalLookups++;

    if (fFound = FindNameCacheEntryEx(hDir, hShadow, lpName, &dwHash, &indx))
    {
    Assert(indx >=0 && indx < NAME_CACHE_TAB_SIZE);
    *lpulrec = rgNameCache[indx]->ulrec;
    memcpy(lpFR, &(rgNameCache[indx]->sFR), sizeof(FILERECEXT));
    dwNCEHits++;
    }

    return (fFound);
}

BOOL
FindNameCacheEntryEx(
    HSHADOW hDir,
    HSHADOW hShadow,
    USHORT  *lpName,
    DWORD   *lpdwHash,
    int     *lpindx
    )
{
    DWORD dwHash;
    int indx, indxT;
    BOOL fRet = FALSE, fHoleFound = FALSE;

    if (lpName)
    {
    dwHash = HashStr(hDir, lpName);
    }
    else
    {
    dwHash = 0; // 
    }
    if (lpdwHash)
    {
    *lpdwHash = dwHash;
    }

    indxT = indx = dwHash % NAME_CACHE_TAB_SIZE;

    for (;indx < NAME_CACHE_TAB_SIZE; ++indx)
    {
    if (rgNameCache[indx])
    {
        if ((rgNameCache[indx]->dwHash == dwHash)
        &&(rgNameCache[indx]->hDir == hDir)
        && (!hShadow || (hShadow == rgNameCache[indx]->hShadow))
        &&(!lpName || !wstrnicmp(rgNameCache[indx]->rgName, lpName, 256)))
        {
        indxT = indx;
        fRet = TRUE;
        break;
        }
    }
    else
    {
        if (!fHoleFound)
        {
        indxT = indx;   // a hole somewhere after the place where this name hashes
        fHoleFound = TRUE;
        }
    }
    }

    if (lpindx)
    {
    *lpindx = indxT;
    }

    return fRet;
}

DWORD
HashStr(
    HSHADOW hDir,
    USHORT  *lpName
    )
{
    DWORD dwHash = 0;

    while (*lpName)
    {
    dwHash += *lpName;
    dwHash <<= 1;
    lpName++;
    }
    return (dwHash);
}

ULONG PUBLIC UpdateFileRecordFR(
    LPTSTR          lpdbID,
    ULONG           ulidDir,
    LPFILERECEXT    lpFR
    )
{
    LPSTR lpszName;
    ULONG       ulrec=INVALID_REC;
    BOOL        fFound = FALSE;

    BEGIN_TIMING(AddFileRecordFR);

    if (fFound = DeleteFromNameCache(ulidDir, lpFR->sFR.ulidShadow, NULL, &ulrec, &sFR))
    {
    Assert(ulrec != INVALID_REC);
    }

    InitFileRec(&sFR);

    lpszName = FormNameString(lpdbID, ulidDir);

    if (!lpszName)
    {
        return 0;
    }


    ulrec = EditRecordEx(lpszName, (LPGENERICREC)lpFR, ICompareFileRec, ulrec, UPDATE_REC);

    if (ulrec)
    {
        InsertInNameCache(ulidDir, , lpFR->sFR.ulidShadow, lpName, NULL, ulrec);
    }

    FreeNameString(lpszName);

bailout:
    END_TIMING(AddFileRecordFR);

    return (ulrec);
}

#endif


ULONG PUBLIC EditRecordEx(
    ULONG           ulidInode,
    LPGENERICREC    lpSrc,
    EDITCMPPROC     lpCompareFunc,
    ULONG           ulInputRec,
    ULONG           uOp
    )
/*++

Routine Description:

    Workhorse routine called for all operations on the record manager.

Arguments:

    ulidInode       Inode # on which the operation needs to be performed

    lpSrc           record tobe created, lookedup, deleted etc.

    lpCompareFunc   Function to compare the input with the entries in the indoe file

    ulInputRec      If INVALID_REC, then we directly access the sadi record.
                    Otherwise we go linearly and apply the comparison routine.

    uOp             create,delete,find,alloc,update

Returns:

    If successful, returns a non-zero value which is the record number of the record operated on
    else returns 0.

Notes:

    Assumes we are in the shadow critical section.
    Tries to do a lot of paranoid checking + perf.

    Perf is improved by doing two things a) file handles are cached and b) reads are done in
    chunks of ~4K.

    Tries to fix problems on the fly, or bypass them if it may not be safe to fix them.

    Has become kind of messy but I am loathe to change stuff around in this particular routine
    because it is so central to CSC.


--*/
{
    CSCHFILE hf;
    ULONG ulRec;
    GENERICHEADER sGH;
    ULONG ulrecFound = 0L, ulrecHole=0L, ulrecTmp=0L, cntRecs=0;
    int cMaxHoles=0, iRet = -1;
    int iTmp, cOvf,  cntRead=-1, cntRetry;
    LPBYTE  lpGenT;
    LPSTR   lpFile=NULL;
    BOOL    fCached;

    BEGIN_TIMING(EditRecordEx);

    UseCommonBuff();

    for (cntRetry=0; cntRetry<= 1; cntRetry++)
    {
        BEGIN_TIMING(EditRecordEx_OpenFileLocal);

        ulRec = (((ulidInode == ULID_PQ)||(ulidInode == ULID_SHARE))&& (uOp == CREATE_REC))?
                (ACCESS_READWRITE|OPEN_FLAGS_COMMIT):ACCESS_READWRITE;


        hf = OpenInodeFileAndCacheHandle(vlpszShadowDir, ulidInode, ulRec, &fCached);

        if (!hf)
        {
            // spew only when database is enabled
            if(vlpszShadowDir)
            {
                RecordKdPrint(BADERRORS,("EditRecord: FileOpen Error: %xh op=%d \r\n", ulidInode, uOp));
            }
            END_TIMING(EditRecordEx_OpenFileLocal);
            UnUseCommonBuff();
            return 0L;
        }

        END_TIMING(EditRecordEx_OpenFileLocal);

        BEGIN_TIMING(EditRecordEx_Lookup);

        cntRead = ReadFileLocalEx(hf, 0, lpReadBuff, COMMON_BUFF_SIZE, TRUE);

        if (cntRead < (long)sizeof(GENERICHEADER))
        {
            if (cntRead == -1)
            {
                // the handle is invalid

                if (cntRetry < 1)
                {
                    RecordKdPrint(BADERRORS,("EditRecord: Invalid file handle %x\r\n", ulidInode));
                    RecordKdPrint(BADERRORS,("EditRecord: purging handle cache and retrying \r\n"));

                    DeleteFromHandleCache(INVALID_SHADOW);
                    continue;
                }
                else
                {
                    RecordKdPrint(BADERRORS,("EditRecord: Invalid file handle bailing out %x\r\n", ulidInode));
                    goto bailout;
                }
            }
            else
            {
                // an invalid record file !!!
                SetCSCDatabaseErrorFlags(CSC_DATABASE_ERROR_INVALID_HEADER);
                RecordKdPrint(BADERRORS,("EditRecord: Invalid record header for %x\r\n", ulidInode));
                END_TIMING(EditRecordEx_Lookup);
                goto bailout;
            }
        }

        // succeeded in reading the header
        break;

    }

    Assert (cntRead >= (long)sizeof(GENERICHEADER));

    sGH = *(LPGENERICHEADER)lpReadBuff;


    // validate header

    if (!ValidateGenericHeader(&sGH))
    {
        // an invalid record file !!!
        SetCSCDatabaseErrorFlags(CSC_DATABASE_ERROR_INVALID_HEADER);
        RecordKdPrint(BADERRORS,("EditRecord: Invalid record header %x\r\n", ulidInode));
        goto bailout;
    }


    lpGenT = lpReadBuff + sGH.lFirstRec;

    // truncated division gives the count of complete records read
    cntRecs = (cntRead - sGH.lFirstRec)/sGH.uRecSize;

    // if we read all the file
    if (cntRead < COMMON_BUFF_SIZE)
    {
        if (sGH.ulRecords > cntRecs)
        {
            // an invalid record file !!!
            RecordKdPrint(BADERRORS,("EditRecord: Invalid record header, fixable %x\r\n", ulidInode));
            sGH.ulRecords = cntRecs;
            WriteHeaderEx(hf, (LPVOID)&sGH, sizeof(sGH), TRUE);
        }

    }

    cntRecs = (cntRecs <= sGH.ulRecords)?cntRecs:sGH.ulRecords;


    if (ulInputRec == INVALID_REC)
    {
        // there are some records to iterate on and iteration is allowed.

        // in case of PQ, if someone has started an inode transation ans hence is
        // holding inodes, then we shouldn't be reusing them, even if they
        // are deleted by someone else

        if (cntRecs && !((ulidInode==ULID_PQ) && (uOp == ALLOC_REC) && cntInodeTransactions))
        {
            for (ulRec=1;ulRec <=sGH.ulRecords;)
            {

                // The count of complete record sequences, ie main + ovf
                iRet = 1 + ((cntRecs)?OvfCount(lpGenT):0);

                if (ulidInode >= ULID_FIRST_USER_DIR)
                {   // directory inode, we know what the max overflow can be
                    if (iRet > (MAX_OVERFLOW_RECORDS+1))
                    {
                        // file looks bad, bailout;
                        SetCSCDatabaseErrorFlags(CSC_DATABASE_ERROR_INVALID_OVF_COUNT);
                        RecordKdPrint(BADERRORS, ("Invalid overflow count = %d for Inode %x\r\n", iRet, ulidInode));
                        goto bailout;
                    }
                }
                else
                {   // PQ or server, these don't have any overflow records
                    if (iRet != 1)
                    {
                        // file looks bad, bailout;
                        SetCSCDatabaseErrorFlags(CSC_DATABASE_ERROR_INVALID_OVF_COUNT);
                        RecordKdPrint(BADERRORS, ("Invalid overflow count = %d for Inode %x\r\n", iRet, ulidInode));
                        goto bailout;
                    }
                }

                //RecordKdPrint(BADERRORS, ("iRet = %d, cntRecs = %d, ulRec = %d \r\n", iRet, cntRecs, ulRec));

                // time to read if we don't have a full complement of records
                //
                if (iRet > (LONG)cntRecs)
                {
                    cntRead = ReadFileLocalEx(  hf,
                                    sGH.lFirstRec + (long)(ulRec-1) * sGH.uRecSize,
                                    lpReadBuff,
                                    COMMON_BUFF_SIZE, TRUE);
                    if (cntRead <= 0)
                    {
                        // a truncated record file !!!!
//                        Assert(FALSE);
                        SetCSCDatabaseErrorFlags(CSC_DATABASE_ERROR_TRUNCATED_INODE);
                        goto bailout;
                    }

                    cntRecs = cntRead/sGH.uRecSize;

                    if ((LONG)cntRecs < iRet)
                    {
                        // a truncated record file !!!!
//                        Assert(FALSE);
                        SetCSCDatabaseErrorFlags(CSC_DATABASE_ERROR_TRUNCATED_INODE);
                        goto bailout;
                    }

                    // if we are at the end of the file, make sure that the # of records
                    // we read so far (ulRec-1) and the # we read in the latest read
                    // add up to sGH.ulRecords

                    if (cntRead < COMMON_BUFF_SIZE)
                    {
                        if(sGH.ulRecords > (ulRec + cntRecs - 1))
                        {
                            // an invalid record file !!!
                            RecordKdPrint(BADERRORS,("EditRecord: Invalid record header, fixable %x\r\n", ulidInode));
                            sGH.ulRecords = ulRec + cntRecs - 1;
                            WriteHeaderEx(hf, (LPVOID)&sGH, sizeof(sGH), TRUE);
                        }

                    }

                    // all is well
                    lpGenT = lpReadBuff;

                    // recalculate the count of complete records
                    iRet = 1 + ((cntRecs)?OvfCount(lpGenT):0);
                }

                // Make sure we are in ssync
                if ((((LPGENERICREC)lpGenT)->uchType == REC_EMPTY)||
                    (((LPGENERICREC)lpGenT)->uchType == REC_DATA))
                {
                    // make sure the overflow count is really correct

                    if (OvfCount(lpGenT))
                    {
                        Assert((ULONG)OvfCount(lpGenT) < cntRecs);
                        cOvf = RealOverflowCount((LPGENERICREC)lpGenT, &sGH, cntRecs);

                        if (cOvf != OvfCount(lpGenT))
                        {
                            RecordKdPrint(BADERRORS,("EditRecord: ovf count mismatch %xh ulRec=%d cntRecs=%d lpGenT=%x\r\n", ulidInode, ulRec, cntRecs, lpGenT));
//                            Assert(FALSE);
                            SetCSCDatabaseErrorFlags(CSC_DATABASE_ERROR_INVALID_OVF_COUNT);
                            SetOvfCount((LPBYTE)lpGenT, cOvf);
                            if (uOp != FIND_REC)
                            {
                                // do fixups only if we are doing some write operation
                                // this is done so for remoteboot, when we are doing lookups
                                // we won't try to fixup things, in an environment where writes
                                // are not allowed.
                                // at anyrate, we should do writes only when the operation demands writes

                                if (WriteRecord(hf, &sGH, ulRec, (LPGENERICREC)lpGenT) < 0)
                                {
                                    RecordKdPrint(BADERRORS,("EditRecord:Fixup failed \r\n"));
                                    goto bailout;
                                }
                            }
                        }
                    }
                }

                if (((LPGENERICREC)lpGenT)->uchType == REC_EMPTY)
                {
                    // If this is a hole let use keep track if this is the biggest
                    if ((OvfCount(lpGenT)+1) > cMaxHoles)
                    {
                        cMaxHoles = (OvfCount(lpGenT)+1);
                        ulrecHole = ulRec;
                    }
                }
                else if (((LPGENERICREC)lpGenT)->uchType == REC_DATA)
                {
                    // This is a data record, let us do comparing
                    if (lpCompareFunc && !(*lpCompareFunc)((LPGENERICREC)lpGenT, lpSrc))
                    {
                        ulrecFound = ulRec;
                        break;
                    }
                }

                ulRec += iRet;
                lpGenT += iRet * sGH.uRecSize;
                cntRecs -= iRet;

            }   // for loop

        }
    }
    else    // if (ulInputRec == INVALID_REC)
    {
        // random access
        ulrecFound = ulInputRec;
        lpGenT += (long)(ulInputRec-1) * sGH.uRecSize;

        // if the input record exists in the COMMON_BUFF_SIZE read in earlier
        // then just use it

        if ((ulInputRec <= cntRecs)&&
            ((cntRecs - ulInputRec)>=(ULONG)OvfCount(lpGenT)))
        {
        }
        else
        {
            if (ulrecFound <= sGH.ulRecords)
            {

                // NB the assumption here is that the lpReadBuff is big enough
                // to hold the biggest header and the biggest record

                iRet = ReadRecordEx(hf, &sGH, ulrecFound, (LPGENERICREC)lpReadBuff, TRUE);

                if (iRet < 0)
                {
                    goto bailout;
                }

                lpGenT = lpReadBuff;

            }
            else
            {
                iRet = -1;
                RecordKdPrint(ALWAYS,("EditRecordEx: invalid input rec# %d, max record=%d \r\n", ulInputRec, sGH.ulRecords));
                goto bailout;
            }
        }
        // paranoid check
        // even with random access, make sure that if there is a comparison function
        // then the entry matches with what we got, as per the function
        if (lpCompareFunc)
        {
            if((*lpCompareFunc)((LPGENERICREC)lpGenT, lpSrc))
            {
                iRet = -1;
                RecordKdPrint(ALWAYS,("EditRecordEx: invalid input rec# %d as per the comparison routine, \r\n", ulInputRec ));
                goto bailout;
            }
        }
    }

    END_TIMING(EditRecordEx_Lookup);


    BEGIN_TIMING(EditRecordEx_Data);

    switch (uOp)
    {
    case FIND_REC:
    {
        if (ulrecFound && (((LPGENERICREC)lpGenT)->uchType == REC_DATA))
        {
            Assert((LPGENERICREC)lpGenT);
            CopyRecord(lpSrc, (LPGENERICREC)lpGenT, sGH.uRecSize, FALSE);  // From Dst to Src
            iRet = 1;
        }
        else
        {
            iRet = 0;
        }
    }
    break;
    case DELETE_REC:
    {
        if (ulrecFound)
        {
            Assert(lpGenT);
            // Maybe we should truncate files and decrement ulRecords
            // in the header
            for (iTmp=0, cOvf = OvfCount((LPGENERICREC)lpGenT); cOvf >= 0 ; --cOvf)
            {
                // Copy it before we mark it empty so that it can be reused
                // as is
                memcpy(((LPBYTE)lpSrc)+iTmp, ((LPBYTE)lpGenT)+iTmp, sGH.uRecSize);
                ((LPGENERICREC)((LPBYTE)lpGenT+iTmp))->uchType = REC_EMPTY;

                //mark decreasing ovf counts so if next time a record with leass than cOvf
                // count uses this space, the remaining tail still indicates the max size of the hole

                SetOvfCount(((LPBYTE)lpGenT+iTmp), cOvf);

                iTmp += sGH.uRecSize;
            }
            // NB we are deliberately not resetting the overflow count
            // becaues WriteRecord uses it to write those many records
            if((iRet = WriteRecordEx(hf, &sGH, ulrecFound, (LPGENERICREC)lpGenT, TRUE))<=0)
            {
                RecordKdPrint(BADERRORS,("EditRecord:Delete failed \r\n"));
                goto bailout;
            }

            // make sure it went away from the handle cache
            if (IsDirInode(ulidInode))
            {
                DeleteFromHandleCacheEx(((LPFILEREC)lpSrc)->ulidShadow, ACCESS_READWRITE);
                DeleteFromHandleCacheEx(((LPFILEREC)lpSrc)->ulidShadow, ACCESS_READWRITE|OPEN_FLAGS_COMMIT);
            }
        }
    }
    break;
    case CREATE_REC:
    case UPDATE_REC:
    {
        RecordKdPrint(EDITRECORDUPDDATEINFO,("ulrecFound=%d ulrecHole=%d cMaxHoles=%d ovf record=%d \r\n",
            ulrecFound, ulrecHole, cMaxHoles, (ULONG)OvfCount(lpSrc)));
        // Let us try writing in the same place
        if (!ulrecFound)
        {
            // there is a hole and it is big enough and is sector aligned
            if (ulrecHole && (cMaxHoles > OvfCount(lpSrc)) && WithinSector(ulrecHole, &sGH))
            {
                ulrecFound = ulrecHole;
            }
            else
            {
                BEGIN_TIMING(EditRecordEx_ValidateHeader);
                // if necessary extend the file so the next record is sector aligned
                if(!ExtendFileSectorAligned(hf, (LPGENERICREC)lpReadBuff, &sGH))
                {
                    RecordKdPrint(BADERRORS,("EditRecord:filextend failed \r\n"));
                    goto bailout;
                }

                END_TIMING(EditRecordEx_ValidateHeader);
                ulrecFound = sGH.ulRecords+1; //Increase count on append

            }
        }

        Assert(WithinSector(ulrecFound, &sGH));

        if (ulidInode >= ULID_FIRST_USER_DIR)
        {
            Assert(((LPFILERECEXT)lpSrc)->sFR.ulidShadow);
//            Assert(((LPFILERECEXT)lpSrc)->sFR.rgw83Name[0]);
            Assert(((LPFILERECEXT)lpSrc)->sFR.rgwName[0]);
        }

        // ISSUE-1/31/2000 what about existing records that expand or contract
        if((iRet = WriteRecordEx(hf, &sGH, ulrecFound, lpSrc, TRUE))<=0)
        {
            RecordKdPrint(BADERRORS,("EditRecord:Update failed \r\n"));
            goto bailout;
        }

        // Increase record count only if appending
        if (ulrecFound == sGH.ulRecords+1)
        {
            sGH.ulRecords += iRet;
            iRet = WriteHeaderEx(hf, (LPVOID)&sGH, sizeof(sGH), TRUE);
        }

#ifdef DEBUG
        if ((ulidInode == ULID_PQ)&&(uOp == CREATE_REC))
        {
            // while createing an inode
            Assert(!((LPQREC)lpSrc)->ulrecPrev);
            Assert(!((LPQREC)lpSrc)->ulrecNext);
            Assert((((LPQHEADER)&sGH))->ulrecTail != ulrecFound);
        }
#endif
    }
    break;
    case ALLOC_REC:
    {
        Assert(!ulrecFound);

        Assert(!((ulidInode == ULID_PQ) && ulrecHole && cntInodeTransactions));

        // there is a hole and it is big enough and sector aligned
        if (ulrecHole && (cMaxHoles > OvfCount(lpSrc)) && WithinSector(ulrecHole, &sGH))
        {
            ulrecFound = ulrecHole;
            iRet = 1;
        }
        else
        {
            if(!ExtendFileSectorAligned(hf, (LPGENERICREC)lpReadBuff, &sGH))
            {
                RecordKdPrint(BADERRORS,("EditRecord:filextend failed \r\n"));
                goto bailout;
            }

            ulrecFound = sGH.ulRecords+1; //Increase count on append


            if((iRet = WriteRecordEx(hf, &sGH, ulrecFound, lpSrc, TRUE))<=0)
                goto bailout;
            sGH.ulRecords += iRet;
            iRet = WriteHeaderEx(hf, (LPVOID)&sGH, sizeof(sGH), TRUE);
            // Now we have a hole for this record
        }

#ifdef DEBUG
        if (ulidInode == ULID_PQ)
        {
            Assert(((LPQHEADER)&sGH)->ulrecTail != ulrecFound);
        }
#endif
        Assert(ulrecFound && WithinSector(ulrecFound, &sGH));
    }
    break;
    default:
        RecordKdPrint(ALWAYS,("EditRecord: Invalid Opcode \r\n"));
    }

    END_TIMING(EditRecordEx_Data);

bailout:
    if (hf && !fCached)
    {
        CloseFileLocal(hf);
    }
    else
    {
        Assert(!hf || !vfStopHandleCaching);
    }
    END_TIMING(EditRecordEx);

    UnUseCommonBuff();

    return ((iRet > 0)? ulrecFound : 0L);
}


BOOL
InsertInHandleCache(
    ULONG   ulidShadow,
    CSCHFILE   hf
)
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    return (InsertInHandleCacheEx(ulidShadow,  hf, ACCESS_READWRITE));
}

BOOL
InsertInHandleCacheEx(
    ULONG   ulidShadow,
    CSCHFILE   hf,
    ULONG   ulOpenMode
)
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int i, indx = -1;
    _FILETIME ft;

    Assert(ulidShadow && hf);

    IncrementFileTime(&ftHandleCacheCurTime);

    ft.dwHighDateTime = ft.dwLowDateTime = 0xffffffff;

    for (i=0; i<HANDLE_CACHE_SIZE; ++i)
    {
        if (rgHandleCache[i].ulidShadow == ULID_SHARE)
        {
            // ACHTUNG very sensitive fix. avoids us from getting into a deadlock
            // on FAT by keeping the handle for list of shares cached at all times
            // So we don't have to open the file ever, so we don't have to take the VCB

            continue;
        }
        if (!rgHandleCache[i].ulidShadow)
        {
            indx = i;
            break;
        }
        else if (CompareTimes(rgHandleCache[i].ft, ft) <= 0)
        {
            indx = i;   // LRU so far
            ft = rgHandleCache[i].ft;   // the time corresponding to LRU
        }
    }


    Assert( (indx>=0)&&(indx <HANDLE_CACHE_SIZE)  );

    if (rgHandleCache[indx].ulidShadow)
    {
        RecordKdPrint(PQ,("InsertInHandleCache: Evicting %x for %x\r\n", rgHandleCache[indx].ulidShadow, ulidShadow));
        Assert(rgHandleCache[indx].hf);
        CloseFileLocalFromHandleCache(rgHandleCache[indx].hf);
    }
    else
    {
        RecordKdPrint(PQ,("InsertInHandleCache: Inserted new entry for %x\r\n", ulidShadow));

    }

    rgHandleCache[indx].ulidShadow = ulidShadow;
    rgHandleCache[indx].hf = hf;
    rgHandleCache[indx].ulOpenMode = ulOpenMode;

    rgHandleCache[indx].ft = ftHandleCacheCurTime;

    return TRUE;

}

BOOL
DeleteFromHandleCache(
    ULONG   ulidShadow
)
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    return (DeleteFromHandleCacheEx(ulidShadow, ACCESS_READWRITE));
}

BOOL
DeleteFromHandleCacheEx(
    ULONG   ulidShadow,
    ULONG   ulOpenMode
)
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int i;
    CSCHFILE hf;

    if (ulidShadow != INVALID_SHADOW)
    {
        if (FindHandleFromHandleCacheInternal(ulidShadow, ulOpenMode, &hf, &i))
        {
            CloseFileLocalFromHandleCache(rgHandleCache[i].hf);
            memset(&rgHandleCache[i], 0, sizeof(HANDLE_CACHE_ENTRY));
            return TRUE;
        }
    }
    else
    {
        for (i=0; i<HANDLE_CACHE_SIZE; ++i)
        {
            if (rgHandleCache[i].ulidShadow)
            {
                Assert(rgHandleCache[i].hf);
                CloseFileLocalFromHandleCache(rgHandleCache[i].hf);
                memset(&rgHandleCache[i], 0, sizeof(HANDLE_CACHE_ENTRY));
            }
        }
    }
    return FALSE;

}

BOOLEAN
IsHandleCachedForRecordmanager(
   CSCHFILE hFile
   )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int i;

    for (i=0; i<HANDLE_CACHE_SIZE; ++i)
    {
        if (rgHandleCache[i].ulidShadow &&
            rgHandleCache[i].hf &&
            (rgHandleCache[i].hf == hFile))
        {
            return TRUE;
        }
    }

    return FALSE;

}

BOOL FindHandleFromHandleCache(
    ULONG   ulidShadow,
    CSCHFILE   *lphf)
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int i;

    if (FindHandleFromHandleCacheInternal(ulidShadow, ACCESS_READWRITE, lphf, &i))
    {
        IncrementFileTime(&ftHandleCacheCurTime);
        rgHandleCache[i].ft = ftHandleCacheCurTime;
        return TRUE;
    }
    return FALSE;
}

BOOL FindHandleFromHandleCacheEx(
    ULONG   ulidShadow,
    ULONG   ulOpenMode,
    CSCHFILE   *lphf
    )
{
    int i;

    if (FindHandleFromHandleCacheInternal(ulidShadow, ulOpenMode, lphf, &i))
    {
        IncrementFileTime(&ftHandleCacheCurTime);

        rgHandleCache[i].ft = ftHandleCacheCurTime;

        Assert(rgHandleCache[i].ulOpenMode == ulOpenMode);
        return TRUE;
    }

    return FALSE;
}

BOOL
FindHandleFromHandleCacheInternal(
    ULONG   ulidShadow,
    ULONG   ulOpenMode,
    CSCHFILE   *lphf,
    int     *lpIndx)
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int i;

    for (i=0; i<HANDLE_CACHE_SIZE; ++i)
    {
        if (    rgHandleCache[i].ulidShadow &&
                (rgHandleCache[i].ulidShadow == ulidShadow) &&
                (rgHandleCache[i].ulOpenMode == ulOpenMode)
                )
        {
            Assert(rgHandleCache[i].hf);
            *lphf = rgHandleCache[i].hf;
            *lpIndx = i;
            return TRUE;
        }
    }
    return FALSE;
}

BOOL
WithinSector(
    ULONG   ulRec,
    LPGENERICHEADER lpGH
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    ULONG ulStart, ulEnd;

    ulStart = lpGH->lFirstRec + (long)(ulRec-1) * lpGH->uRecSize;

    ulEnd = ulStart + lpGH->uRecSize -1;

    return ((ulStart/BYTES_PER_SECTOR) == (ulEnd/BYTES_PER_SECTOR));
    return TRUE;
}

BOOL
ExtendFileSectorAligned(
    CSCHFILE           hf,
    LPGENERICREC    lpDst,
    LPGENERICHEADER lpGH
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet;
    // if the record to be appended is not aligned on a sector
    // we need to write a hole there and make corresponding adjustments
    // in the header

    if (!WithinSector(lpGH->ulRecords+1, lpGH))
    {
        ((LPGENERICREC)((LPBYTE)lpDst))->uchType = REC_EMPTY;

        ClearOvfCount(lpDst);

        if((iRet = WriteRecordEx(hf, lpGH, lpGH->ulRecords+1, lpDst, TRUE))<=0)
        {
            return (FALSE);
        }

        Assert(iRet == 1);

        lpGH->ulRecords++;
    }
    return (TRUE);
}


BOOL
ValidateGenericHeader(
    LPGENERICHEADER    lpGH
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    BOOL fRet = FALSE;

    if (lpGH->ulVersion != CSC_DATABASE_VERSION)
    {
        RecordKdPrint(BADERRORS,("EditRecord: %x, incorrect version #%x\r\n", lpGH->ulVersion));
        goto bailout;

    }
    if (!lpGH->uRecSize)
    {
        goto bailout;
    }

    fRet = TRUE;

bailout:
    return fRet;
}

BOOL
ReorderQ(
    LPVOID  lpdbID
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    BOOL fRet = FALSE;
    LPTSTR  lpszName;
    QHEADER     sQH;
    QREC        sQR;
    unsigned    ulrecCur;
    CSCHFILE   hf = CSCHFILE_NULL;

    // keep count of how many times we tried reordering
    ++cntReorderQ;

    lpszName = FormNameString(lpdbID, ULID_PQ);

    if (!lpszName)
    {
        return FALSE;
    }

    hf = OpenFileLocal(lpszName);

    if (!hf)
    {
        RecordKdPrint(BADERRORS,("ReorderQ: %s FileOpen Error\r\n", lpszName));
        goto bailout;
    }

    if (ReadHeader(hf, (LPGENERICHEADER)&sQH, sizeof(QHEADER)) < 0)
    {
        RecordKdPrint(BADERRORS,("ReorderQ: %s  couldn't read the header\r\n", lpszName));
        goto bailout;
    }

    sQH.ulrecHead = sQH.ulrecTail = 0;


    // just read till you get an error
    // NB we know that there are no overflow records
    // hence we can do ulrecCur++ in the for loop below

    for (ulrecCur=1; TRUE; ulrecCur++)
    {
        if(ReadRecord(hf, (LPGENERICHEADER)&sQH, ulrecCur, (LPGENERICREC)&sQR) < 0)
        {
            break;
        }

        if (sQR.uchType == REC_DATA)
        {

            // in aid of performance, let us just put them together quickly,
            // files at the top of the queue while directories at the bottom

            if (IsLeaf(sQR.ulidShadow))
            {
                sQR.ulrecPrev = 0;              // no predecessor
                sQR.ulrecNext = sQH.ulrecHead;  // the current head as the successor
                sQH.ulrecHead = ulrecCur;       // we at the head
                sQR.uchRefPri = MAX_PRI;
            }
            else
            {
                sQR.ulrecNext = 0;              // no successor
                sQR.ulrecPrev = sQH.ulrecTail;  // current tail as the predecessor
                sQH.ulrecTail = ulrecCur;        // we at the tail
                sQR.uchRefPri = MIN_PRI;
            }

            if(WriteRecord(hf, (LPGENERICHEADER)&sQH, ulrecCur, (LPGENERICREC)&sQR) < 0)
            {
                RecordKdPrint(BADERRORS,("ReorderQ: WriteQRecord Failed\r\n"));
                goto bailout;
            }

            // NB!!! we will write the header out only at the end
        }

    }

    sQH.ulRecords = ulrecCur - 1;

    if (WriteHeader(hf, (LPGENERICHEADER)&sQH, sizeof(QHEADER)) < 0)
    {
        RecordKdPrint(BADERRORS,("ReorderQ: %s  couldn't write the header\r\n", lpszName));
        goto bailout;
    }

    fRet = TRUE;

bailout:

    if (hf)
    {
        CloseFileLocal(hf);
    }

    FreeNameString(lpszName);

    return (fRet);

}

CSCHFILE
OpenInodeFileAndCacheHandle(
    LPVOID  lpdbID,
    ULONG   ulidInode,
    ULONG   ulOpenMode,
    BOOL    *lpfCached
)
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    LPSTR lpFile = NULL;
    CSCHFILE hf = CSCHFILE_NULL;
    
    *lpfCached = FALSE;

    if (!FindHandleFromHandleCacheEx(ulidInode, ulOpenMode, &hf))
    {

        lpFile = FormNameString(lpdbID,  ulidInode);

        if (!lpFile)
        {
            if (!lpdbID)
            {
                RecordKdPrint(INIT,("OpenInodeFileAndCacheHandle: database uninitialized \r\n"));
            }
            else
            {
                RecordKdPrint(BADERRORS,("OpenInodeFileAndCacheHandle: memory allocation failed\r\n"));
            }
            return 0L;
        }

        hf = R0OpenFileEx((USHORT)ulOpenMode, ACTION_OPENEXISTING, FILE_ATTRIBUTE_NORMAL, lpFile, TRUE);

        FreeNameString(lpFile);


        if (!hf)
        {
            RecordKdPrint(BADERRORS,("OpenInodeFileAndCacheHandle: Failed to open file for %x \r\n", ulidInode));
            return 0L;
        }

        if (!vfStopHandleCaching)
        {
            InsertInHandleCacheEx(ulidInode, hf, ulOpenMode);
            *lpfCached = TRUE;
        }

    }
    else
    {
        *lpfCached = TRUE;
    }

    return hf;

}

BOOL
EnableHandleCachingInodeFile(
    BOOL    fEnable
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    BOOL    fOldState = vfStopHandleCaching;

    if (!fEnable)
    {
        if (vfStopHandleCaching == FALSE)
        {
            DeleteFromHandleCache(INVALID_SHADOW);
            vfStopHandleCaching = TRUE;
        }
    }
    else
    {
        vfStopHandleCaching = FALSE;
    }

    return fOldState;
}

int RealOverflowCount(
    LPGENERICREC    lpGR,
    LPGENERICHEADER lpGH,
    int             cntMaxRec
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int i = OvfCount(lpGR)+1;
    LPGENERICREC lpGRT = lpGR;
    char chType;

    cntMaxRec = min(cntMaxRec, i);

    Assert((lpGR->uchType == REC_DATA) || (lpGR->uchType == REC_EMPTY));

    chType = (lpGR->uchType == REC_DATA)?REC_OVERFLOW:REC_EMPTY;

    for (i=1; i<cntMaxRec; ++i)
    {
        lpGRT = (LPGENERICREC)((LPBYTE)lpGRT + lpGH->uRecSize);

        if (lpGRT->uchType != chType)
        {
            break;
        }

    }

    return (i-1);
}

#if defined(BITCOPY)
int
PUBLIC CopyFileLocalDefaultStream(
#else
int
PUBLIC CopyFileLocal(
#endif // defined(BITCOPY)
    LPVOID  lpdbShadow,
    ULONG   ulidFrom,
    LPSTR   lpszNameTo,
    ULONG   ulAttrib
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    LPSTR   lpszNameFrom=NULL;
    int iRet=-1;
    LPBYTE  lpBuff = (LPBYTE)lpReadBuff;

    CSCHFILE hfSrc= CSCHFILE_NULL;
    CSCHFILE hfDst= CSCHFILE_NULL;
    ULONG pos;

    UseCommonBuff();

    lpszNameFrom = FormNameString(lpdbShadow, ulidFrom);

    if (!lpszNameFrom)
    {
        goto bailout;
    }

    if (!(hfSrc = OpenFileLocal(lpszNameFrom)))
    {
        RecordKdPrint(BADERRORS,("CopyFileLocal: Can't open %s\r\n", lpszNameFrom));
        goto bailout;
    }
#ifdef CSC_RECORDMANAGER_WINNT

    memcpy(lpReadBuff, NT_DB_PREFIX, sizeof(NT_DB_PREFIX)-1);
    strcpy(lpReadBuff+sizeof(NT_DB_PREFIX)-1, lpszNameTo);

    // if the file exists it will get truncated
    if ( !(hfDst = R0OpenFileEx(ACCESS_READWRITE,
                                ACTION_CREATEALWAYS,
                                ulAttrib,
                                lpReadBuff,
                                FLAG_CREATE_OSLAYER_ALL_ACCESS
                                )))
    {
        RecordKdPrint(BADERRORS,("CopyFile: Can't create %s\r\n", lpReadBuff));
        goto bailout;
    }
#else
    // If the original file existed it would be truncated
    strcpy(lpReadBuff, lpszNameTo);
    if ( !(hfDst = R0OpenFile(ACCESS_READWRITE, ACTION_CREATEALWAYS, lpReadBuff)))
    {
        RecordKdPrint(BADERRORS,("CopyFile: Can't create %s\r\n", lpszNameTo));
        goto bailout;
    }
#endif

    RecordKdPrint(COPYLOCAL,("Copying...\r\n"));

    pos = 0;
    // Both the files are correctly positioned
    while ((iRet = ReadFileLocal(hfSrc, pos, lpBuff, COMMON_BUFF_SIZE))>0)
    {
        if (WriteFileLocal(hfDst, pos, lpBuff, iRet) < 0)
        {
            RecordKdPrint(BADERRORS,("CopyFile: Write Error\r\n"));
            goto bailout;
        }
        pos += iRet;
    }

    RecordKdPrint(COPYLOCAL,("Copy Complete\r\n"));

    iRet = 1;
bailout:
    if (hfSrc)
    {
        CloseFileLocal(hfSrc);
    }
    if (hfDst)
    {
        CloseFileLocal(hfDst);
    }
    if ((iRet==-1) && hfDst)
    {
#ifdef CSC_RECORDMANAGER_WINNT
        memcpy(lpReadBuff, NT_DB_PREFIX, sizeof(NT_DB_PREFIX)-1);
        strcpy(lpReadBuff+sizeof(NT_DB_PREFIX)-1, lpszNameTo);
        DeleteFileLocal(lpReadBuff, ATTRIB_DEL_ANY);
#else
        DeleteFileLocal(lpszNameTo, ATTRIB_DEL_ANY);
#endif
    }
    FreeNameString(lpszNameFrom);
    UnUseCommonBuff();

    return iRet;
}


#if defined(BITCOPY)
int
PUBLIC CopyFileLocalCscBmp(
    LPVOID  lpdbShadow,
    ULONG   ulidFrom,
    LPSTR   lpszNameTo,
    ULONG   ulAttrib
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    LPSTR   lpszNameCscBmpFrom = NULL;
    int iRet=-1;
    LPBYTE  lpBuff = (LPBYTE)lpReadBuff;

    CSCHFILE hfSrc= CSCHFILE_NULL;
    CSCHFILE hfDst= CSCHFILE_NULL;
    ULONG pos;

    UseCommonBuff();

    lpszNameCscBmpFrom = FormAppendNameString(lpdbShadow,
                          ulidFrom,
                          CscBmpAltStrmName);
    RecordKdPrint(COPYLOCAL, ("Trying to copy bitmap %s\n"));

    if (!lpszNameCscBmpFrom)
    {
        goto bailout;
    }

    if (!(hfSrc = OpenFileLocal(lpszNameCscBmpFrom)))
    {
        RecordKdPrint(COPYLOCAL,
  ("CopyFileLocalCscBmp: bitmap file %s does not exist or error opening.\r\n",
       lpszNameCscBmpFrom));
        goto bailout;
    }
#ifdef CSC_RECORDMANAGER_WINNT

    memcpy(lpReadBuff, NT_DB_PREFIX, sizeof(NT_DB_PREFIX)-1);
    strcpy(lpReadBuff+sizeof(NT_DB_PREFIX)-1, lpszNameTo);
    strcat(lpReadBuff, CscBmpAltStrmName);

    // if the file exists it will get truncated
    if ( !(hfDst = R0OpenFileEx(ACCESS_READWRITE,
                                ACTION_CREATEALWAYS,
                                ulAttrib,
                                lpReadBuff,
                                FLAG_CREATE_OSLAYER_ALL_ACCESS
                                )))
    {
        RecordKdPrint(BADERRORS,
         ("CopyFileLocalCscBmp: Can't create %s\r\n", lpReadBuff));
        goto bailout;
    }
#else
    // If the original file existed it would be truncated
    strcpy(lpReadBuff, lpszNameTo);
    strcat(lpReadBuff, CscBmpAltStrmName);
    if ( !(hfDst = R0OpenFile(ACCESS_READWRITE, ACTION_CREATEALWAYS, lpReadBuff)))
    {
        RecordKdPrint(BADERRORS,
      ("CopyFileLocalCscBmp: Can't create %s\r\n", lpszNameTo));
        goto bailout;
    }
#endif

    RecordKdPrint(COPYLOCAL,("Copying bitmap...\r\n"));

    pos = 0;
    // Both the files are correctly positioned
    while ((iRet = ReadFileLocal(hfSrc, pos, lpBuff, COMMON_BUFF_SIZE))>0)
    {
        if (WriteFileLocal(hfDst, pos, lpBuff, iRet) < 0)
        {
            RecordKdPrint(BADERRORS,
          ("CopyFileLocalCscBmp: Write Error\r\n"));
            goto bailout;
        }
        pos += iRet;
    }

    RecordKdPrint(COPYLOCAL,("CopyFileLocalCscBmp Complete\r\n"));

    iRet = 1;
bailout:
    if (hfSrc)
    {
        CloseFileLocal(hfSrc);
    }
    if (hfDst)
    {
        CloseFileLocal(hfDst);
    }
    if ((iRet==-1) && hfDst)
    {
#ifdef CSC_RECORDMANAGER_WINNT
        memcpy(lpReadBuff, NT_DB_PREFIX, sizeof(NT_DB_PREFIX)-1);
        strcpy(lpReadBuff+sizeof(NT_DB_PREFIX)-1, lpszNameTo);
        strcat(lpReadBuff, CscBmpAltStrmName);
        DeleteFileLocal(lpReadBuff, ATTRIB_DEL_ANY);
#else
    strcpy(lpReadBuff, lpszNameTo);
    strcat(lpReadBuff, CscBmpAltStrmName);
        DeleteFileLocal(lpReadBuff, ATTRIB_DEL_ANY);
#endif
    }
    FreeNameString(lpszNameCscBmpFrom);
    UnUseCommonBuff();

    return iRet;
}

int
PUBLIC CopyFileLocal(
    LPVOID  lpdbShadow,
    ULONG   ulidFrom,
    LPSTR   lpszNameTo,
    ULONG   ulAttrib
    )
/*++

Routine Description:

  The original CopyFileLocal is renamed CopyFileLocalDefaultStream.
  The new CopyFileLocal calls CopyFileLocalDefaultStream and
      dir
CopyFileLocalCscBmp.

Parameters:

Return Value:

Notes:


--*/
{
  int ret;

  ret = CopyFileLocalDefaultStream(lpdbShadow, ulidFrom, lpszNameTo, ulAttrib);

  // Don't care if be able to copy bitmap or not. Reint will copy whole file
  // back to share if bitmap does not exist.
  CopyFileLocalCscBmp(lpdbShadow, ulidFrom, lpszNameTo, ulAttrib);
  
  return ret;
}
#endif // defined(BITCOPY)


int
RecreateInode(
    LPTSTR  lpdbID,
    HSHADOW hShadow,
    ULONG   ulAttribIn
    )
/*++

Routine Description:

    This routine recreates an inode data file. This is so that when the CSC directory is
    marked for encryption, the newly created inode file will get encrypted.

Arguments:

    hDir        Inode directory

    hShadow     Inode whosw file needs to be recreated

    ulAttribIn  Recreate with the given attributes

Return Value:


--*/
{
    LPSTR   lpszTempFileName=NULL;
    int     iRet = -1;
    ULONG   ulAttributes;

    // do this only for files
    if (IsLeaf(hShadow))
    {
        if(lpszTempFileName = FormNameString(lpdbID, hShadow))
        {
            if(GetAttributesLocal(lpszTempFileName, &ulAttributes)>=0)
            {
                // For now special case it for encryption SPP
                
                if (!((!ulAttribIn && (ulAttributes & FILE_ATTRIBUTE_ENCRYPTED))||
                    (ulAttribIn && !(ulAttributes & FILE_ATTRIBUTE_ENCRYPTED))))
                {
                    iRet = 0;
                    goto FINALLY;
                }
            }

            FreeNameString(lpszTempFileName);
            lpszTempFileName = NULL;
        }
        

        // makeup a temporary name
        if(lpszTempFileName = FormNameString(lpdbID, ULID_TEMP1))
        {
            // we delete the original so that if we are doing
            // encrypting/decrypting, a new file will get created which will
            // get encrypted or decrypted
            if(DeleteFileLocal(lpszTempFileName, ATTRIB_DEL_ANY) < 0)
            {
                if (GetLastErrorLocal() != ERROR_FILE_NOT_FOUND)
                {
                    iRet = -1;
                    goto FINALLY;
                }
            }
        
            // make a new copy the file represented by the hShadow with the temp name
            if (CopyFileLocal(lpdbID, hShadow, lpszTempFileName+sizeof(NT_DB_PREFIX)-1, ulAttribIn) >= 0)
            {
                // rename the original to another temp name
                if (RenameInode(lpdbID, hShadow, ULID_TEMP2)>=0)
                {
                    // rename the copy to the origianl name
                    if (RenameInode(lpdbID, ULID_TEMP1, hShadow)>=0)
                    {
                        iRet = 0;
                    }
                    else
                    {
                        // if failed, try to restore it back.
                        RenameInode(lpdbID, ULID_TEMP2, hShadow);
                    }
                }

                if (iRet == -1)
                {
                    DeleteFileLocal(lpszTempFileName, ATTRIB_DEL_ANY);
                }
            }

        }
    }
FINALLY:
    if (lpszTempFileName)
    {
        FreeNameString(lpszTempFileName);
    }
    return iRet;
}

int RenameInode(
    LPTSTR  lpdbID,
    ULONG   ulidFrom,
    ULONG   ulidTo
    )
/*++

Routine Description:

    This routine renames an inode file to another inode file

Arguments:

    lpdbID  which database

    ulidFrom

    ulidTo

Return Value:


--*/
{
    LPSTR   lpszNameFrom=NULL, lpszNameTo=NULL;
    int iRet=-1;

    lpszNameFrom = FormNameString(lpdbID, ulidFrom);
    lpszNameTo = FormNameString(lpdbID, ulidTo);

    if (lpszNameFrom && lpszNameTo)
    {
        iRet = RenameFileLocal(lpszNameFrom, lpszNameTo);
    }

    FreeNameString(lpszNameFrom);
    FreeNameString(lpszNameTo);

    return (iRet);
}


ULONG
GetCSCDatabaseErrorFlags(
    VOID
    )
/*++

Routine Description:

    returns in memory error flags if any detected so far
    
Arguments:

    None

Return Value:

    error flags

--*/
{
    return ulErrorFlags;
}

#ifdef CSC_RECORDMANAGER_WINNT

BOOL
FindCreateDBDirEx(
    LPSTR   lpszShadowDir,
    BOOL    fCleanup,
    BOOL    *lpfCreated,
    BOOL    *lpfIncorrectSubdirs
    )
/*++

Routine Description:


Parameters:

Return Value:

Notes:

--*/
{
    DWORD   dwAttr;
    BOOL    fRet = FALSE;
    int i;
    UINT lenDir;


    UseCommonBuff();

    *lpfIncorrectSubdirs = *lpfCreated = FALSE;

    RecordKdPrint(INIT, ("InbCreateDir: looking for %s \r\n", lpszShadowDir));

    if ((GetAttributesLocalEx(lpszShadowDir, FALSE, &dwAttr)) == 0xffffffff)
    {
        RecordKdPrint(BADERRORS, ("InbCreateDir: didnt' find the CSC directory trying to create one \r\n"));
        if(CreateDirectoryLocal(lpszShadowDir)>=0)
        {
            *lpfCreated = TRUE;
        }
        else
        {
            goto bailout;
        }
    }
    else
    {
        if (dwAttr & FILE_ATTRIBUTE_DIRECTORY)
        {
            if (fCleanup && !DeleteDirectoryFiles(lpszShadowDir))
            {
                goto bailout;
            }
        }
        else
        {
            goto bailout;
        }
    }

    strcpy(lpReadBuff, lpszShadowDir);

    lenDir = strlen(lpReadBuff);
    lpReadBuff[lenDir++] = '\\';
    lpReadBuff[lenDir++] = CSCDbSubdirFirstChar();
    lpReadBuff[lenDir++] = '1';
    lpReadBuff[lenDir] = 0;

    for (i=0; i<CSCDB_SUBDIR_COUNT; ++i)
    {
        if ((GetAttributesLocalEx(lpReadBuff, FALSE, &dwAttr)) == 0xffffffff)
        {
            *lpfIncorrectSubdirs = TRUE;
            RecordKdPrint(BADERRORS, ("InbCreateDir: didnt' find the CSC directory trying to create one \r\n"));
            if(CreateDirectoryLocal(lpReadBuff) < 0)
            {
                goto bailout;
            }
        }
        else
        {
            if (!(dwAttr & FILE_ATTRIBUTE_DIRECTORY))
            {
                break;
            }
            if (fCleanup && !DeleteDirectoryFiles(lpReadBuff))
            {
                goto bailout;
            }
        }

        lpReadBuff[lenDir-1]++;
    }

    fRet = TRUE;

bailout:

    UnUseCommonBuff();

    return (fRet);
}

BOOL
FindCreateDBDir(
    LPSTR   lpszShadowDir,
    BOOL    fCleanup,    // empty the directory if found
    BOOL    *lpfCreated
    )
/*++

Routine Description:


Parameters:

Return Value:

Notes:

--*/
{
    BOOL    fIncorrectSubdirs = FALSE, fRet;

    if (fRet = FindCreateDBDirEx(lpszShadowDir, fCleanup, lpfCreated, &fIncorrectSubdirs))
    {
        // if the root directory wasn't created and there are incorrect subdirs
        // then we need to recreate the database.

        if (!*lpfCreated && fIncorrectSubdirs)
        {
            fRet = FindCreateDBDirEx(lpszShadowDir, TRUE, lpfCreated, &fIncorrectSubdirs);
        }
    }
    return fRet;
}
#endif

#if defined(REMOTE_BOOT)
int
GetCSCFileNameFromUNCPathCallback(
    USHORT  *lpuPath,
    USHORT  *lpuLastElement,
    LPVOID  lpCookie
    )
/*++

Routine Description:

    This is the callback function for GetCSCFileNameFromUNCPath (see below)

Parameters:

Return Value:

Notes:

--*/
{
    SHADOWINFO *lpSI = (SHADOWINFO *)lpCookie;

    if (!lpSI->hDir)
    {
        RecordKdPrint(ALWAYS, ("getting inode for %ls path is %ls\r\n", lpuLastElement, lpuPath));
        if (!FindShareRecord(vlpszShadowDir, lpuLastElement, (LPSHAREREC)(lpSI->lpFind32)))
        {
            return FALSE;
        }

        lpSI->hDir =((LPSHAREREC)(lpSI->lpFind32))->ulidShadow;
    }
    else
    {
        RecordKdPrint(ALWAYS, ("getting inode for %ls path is %ls\r\n", lpuLastElement, lpuPath));

        if (!FindFileRecord(vlpszShadowDir, lpSI->hDir, lpuLastElement, (LPFILERECEXT)(lpSI->lpFind32)))
        {
            return FALSE;
        }

        // return only complete files so RB knows that it has a good local copy
        if (!(((LPFILERECEXT)(lpSI->lpFind32))->sFR.dwFileAttrib & FILE_ATTRIBUTE_DIRECTORY)) {
            if ((((LPFILERECEXT)(lpSI->lpFind32))->sFR.usStatus & SHADOW_SPARSE)) {
                // RecordKdPrint(ALWAYS, ("inode for %ls path is %ls and is marked sparse\r\n", lpuLastElement, lpuPath));
                return FALSE;
            }
        }
        lpSI->hDir = ((LPFILERECEXT)(lpSI->lpFind32))->sFR.ulidShadow;
    }

    return TRUE;
}

BOOL
GetCSCFileNameFromUNCPath(
    LPSTR   lpszDatabaseLocation,
    USHORT  *lpuPath,
    LPBYTE  lpBuff  // must be MAX_PATH
    )
/*++

Routine Description:

    This function is used by remote boot, to get the filenames for csc database files, when
    the database is not initialized, and even the drive link is also not set. The location will
    come down in the form of \\harddisk\disk0\....

Parameters:

    lpszDatabaseLocation    CSC database location in ANSI (NB!!!)

    lpuPath                 UNC path for the file whose local copy name needs to be found.
                            This is in unicode ((NB!!!)

    lpBuff                  return buffer. Must be MAX_PATH or more bytes. The returned
                            string is ANSI. (NB!!!)

Return Value:

    if TRUE, the buffer contains a null terminated string for the internal name of the given
    file/directory on the server.

Notes:

    Assumes that this is called before the database is initialized. Opens the record database,
    does the job and closes it.

--*/
{
    BOOL fRet, fNew;
    SHADOWINFO sSI;
    LPFILERECEXT lpFRExt = NULL;
    LPVOID  lpdbID = NULL;
    LPSTR   lpszName = NULL;

    if (!vlpszShadowDir)
    {
        lpdbID = OpenRecDBInternal(lpszDatabaseLocation, NULL, 0, 0, 0, FALSE, FALSE, &fNew);
    }
    else
    {
        lpdbID = vlpszShadowDir;
    }

    if (!lpdbID)
    {
        return FALSE;
    }

    lpFRExt = AllocMem(sizeof(*lpFRExt));

    if (!lpFRExt)
    {
        goto bailout;
    }

    memset(&sSI, 0, sizeof(sSI));

    sSI.lpFind32 = (LPFIND32)lpFRExt;

    RecordKdPrint(ALWAYS, ("getting inode file for %ls\r\n", lpuPath));

    fRet = IterateOnUNCPathElements(lpuPath, GetCSCFileNameFromUNCPathCallback, (LPVOID)&sSI);

    if (fRet)
    {
        RecordKdPrint(ALWAYS, ("getting file name for %xh\r\n", sSI.hDir));

        lpszName = FormNameString(lpdbID, sSI.hDir);

        if (lpszName)
        {
            strcpy(lpBuff, lpszName);

            FreeNameString(lpszName);
        }

        RecordKdPrint(ALWAYS, ("file name is %s\r\n", lpBuff));

    }
bailout:
    if (lpFRExt)
    {
        FreeMem(lpFRExt);
    }

    // CloseRecDB(lpdbID);
    return fRet;
}
#endif // defined(REMOTE_BOOT)

#if 0

BOOL
ValidateQ(
    VOID
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    QREC      sQR, sPrev, sNext;
    unsigned ulRec;
    BOOL    fRet = FALSE, fValidHead=FALSE, fValidTail=FALSE;
    LPTSTR  lpszName;
    QHEADER     sQH;
    unsigned    ulRec;
    CSCHFILE   hf = CSCHFILE_NULL;

    lpszName = FormNameString(lpdbID, ULID_PQ);

    if (!lpszName)
    {
        return FALSE;
    }

    hf = R0OpenFileEx((USHORT)ulRec, ACTION_OPENEXISTING, lpszName, TRUE);

    if (!hf)
    {
        RecordKdPrint(BADERRORS,("ReorderQ: %s FileOpen Error\r\n", lpszName));
        goto bailout;
    }

    if (ReadHeader(hf, &sQH, sizeof(QHEADER)) < 0)
    {
        RecordKdPrint(BADERRORS, ("ReorderQ: %s  couldn't read the header\r\n", lpszName));
        goto bailout;
    }


    if ((sQH.ulrecTail > sQH.ulRecods) || (sQH.ulrecHead > sQH.ulRecords))
    {
        RecordKdPrint(BADERRORS, ("Invalid head-tail pointers\r\n"));
        goto bailout;
    }

    if (!sQH.ulRecords)
    {
        fRet = TRUE;
        goto bailout;
    }

    for (ulRec = 1; ulRec <= sQH.ulRecords; ulRec++)
    {
        if (!ReadRecord(hf, (LPGENERICHEADER)&sQH, ulRec, (LPGENERICREC)&sQR))
        {
            Assert(FALSE);
            goto bailout;
        }

        if (sQR.uchType == REC_DATA)
        {

            if (sQR.ulrecNext)
            {
                if (sQR.ulrecNext > sQH.ulRecords)
                {
                    RecordKdPrint(BADERRORS, ("Invalid next pointer to %d\r\n", ulRec));
                    goto bailout;
                }

                if (!ReadRecord(hf, (LPGENERICHEADER)&sQH, sQR.ulrecNext, (LPGENERICREC)&sNext))
                {
                    goto bailout;
                }


                if (sNext.ulrecPrev != ulRec)
                {
                    RecordKdPrint(BADERRORS, ("Prev pointer of %d doesn't equal %d\r\n", sNext.ulrecPrev, ulRec));
                    goto bailout;
                }
            }
            else
            {
                if (((LPQHEADER)&(sQH))->ulrecTail != ulRec)
                {

                    RecordKdPrint(BADERRORS, ("Invalid tail pointer to %d\r\n", ulRec));
                    goto bailout;
                }

                fValidTail = TRUE;
            }

            if (sQR.ulrecPrev)
            {
                if (sQR.ulrecPrev > sQH.ulRecords)
                {
                    RecordKdPrint(BADERRORS, ("Invalid prev pointer to %d\r\n", ulRec));
                    goto bailout;
                }

                if (!ReadRecord(hf, (LPGENERICHEADER)&sQH, sQR.ulrecPrev, (LPGENERICREC)&sPrev))
                {
                    Assert(FALSE);
                    goto bailout;
                }

                if (sPrev.ulrecNext != ulRec)
                {

                    RecordKdPrint(BADERRORS, ("Next pointer of %d doesn't equal %d\r\n", sPrev.ulrecNext, ulRec));
                    goto bailout;
                }
            }
            else
            {
                if (((LPQHEADER)&(sQH))->ulrecHead != ulRec)
                {

                    RecordKdPrint(BADERRORS, ("Invalid Head pointer to %d\r\n", ulRec));
                    goto bailout;
                }

                fValidHead = TRUE;
            }
        }
    }

    if (!fValidHead || !fValidTail)
    {
        RecordKdPrint(BADERRORS, ("Head or Tail invalid \r\n"));
        goto bailout;
    }

    fRet = TRUE;

bailout:
    if (hf)
    {
        CloseFileLocal(hf);
    }

    return (fRet);
}

#endif


BOOL
CheckCSCDatabaseVersion(
    LPTSTR  lpszLocation,       // database directory
    BOOL    *lpfWasDirty
)
{

    char *lpszName = NULL;
    SHAREHEADER sSH;
    PRIQHEADER    sPQ;

    CSCHFILE hfShare = 0, hfPQ=0;
    BOOL    fOK = FALSE;
    DWORD   dwErrorShare=NO_ERROR, dwErrorPQ=NO_ERROR;

//    OutputDebugStringA("Checking version...\r\n");
    lpszName = FormNameString(lpszLocation, ULID_SHARE);

    if (!lpszName)
    {
        return FALSE;
    }

    if(!(hfShare = OpenFileLocal(lpszName)))
    {
        dwErrorShare = GetLastErrorLocal();
    }


    FreeNameString(lpszName);

    lpszName = FormNameString(lpszLocation, ULID_PQ);

    if (!lpszName)
    {
        goto bailout;
    }


    if(!(hfPQ = OpenFileLocal(lpszName)))
    {
        dwErrorPQ = GetLastErrorLocal();
    }

    FreeNameString(lpszName);
    lpszName = NULL;

    if ((dwErrorShare == NO_ERROR)&&(dwErrorPQ==NO_ERROR))
    {
        if(ReadFileLocal(hfShare, 0, &sSH, sizeof(SHAREHEADER))!=sizeof(SHAREHEADER))
        {
            //error message
            goto bailout;
        }

        if (sSH.ulVersion != CSC_DATABASE_VERSION)
        {
            goto bailout;
        }

        if(ReadFileLocal(hfPQ, 0, &sPQ, sizeof(PRIQHEADER))!=sizeof(PRIQHEADER))
        {
            //error message
            goto bailout;
        }

        if (sPQ.ulVersion != CSC_DATABASE_VERSION)
        {
            goto bailout;
        }

        fOK = TRUE;
    }
    else
    {
        if (((dwErrorShare == ERROR_FILE_NOT_FOUND)&&(dwErrorPQ==ERROR_FILE_NOT_FOUND))||
            ((dwErrorShare == ERROR_PATH_NOT_FOUND)&&(dwErrorPQ==ERROR_PATH_NOT_FOUND)))
        {
            fOK = TRUE;
        }
    }

bailout:

    if (lpszName)
    {
        FreeNameString(lpszName);
    }

    if (hfShare)
    {
        CloseFileLocal(hfShare);
    }

    if (hfPQ)
    {
        CloseFileLocal(hfPQ);
    }

    return (fOK);
}

VOID
SetCSCDatabaseErrorFlags(
    ULONG ulFlags
)
{
    ulErrorFlags |= ulFlags;
}


BOOL
EncryptDecryptDB(
    LPVOID      lpdbID,
    BOOL        fEncrypt
)
/*++

Routine Description:

    This routine traverses the priority Q and encrypts/decrypts the database

Parameters:

    lpdbID      CSC database directory
    
    fEncrypt    TRUE if we are encrypting, else decrypting

Return Value:

    TRUE if Suceeded

Notes:

    This is called if the cache was paritally encrypted/decrypted. When the database is being initialized
    we try to encrypt/decrypt the files that couldn't be processed because either they were open or some other
    error occurred.

--*/
{
    QREC      sQR, sPrev, sNext;
    BOOL    fRet = FALSE;
    LPTSTR  lpszName;
    QHEADER     sQH;
    unsigned    ulRec;
    CSCHFILE   hf = CSCHFILE_NULL;
    ULONG   cntFailed = 0;
    
    lpszName = FormNameString(lpdbID, ULID_PQ);

    if (!lpszName)
    {
        return FALSE;
    }

    hf = R0OpenFile(ACCESS_READWRITE, ACTION_OPENEXISTING, lpszName);

    if (!hf)
    {
        RecordKdPrint(BADERRORS,("ReorderQ: %s FileOpen Error\r\n", lpszName));
        goto bailout;
    }

    if (ReadHeader(hf, (LPGENERICHEADER)&sQH, sizeof(QHEADER)) < 0)
    {
        RecordKdPrint(BADERRORS, ("ReorderQ: %s  couldn't read the header\r\n", lpszName));
        goto bailout;
    }


    if (!sQH.ulRecords)
    {
        fRet = TRUE;
        goto bailout;
    }

    for (ulRec = 1; ulRec <= sQH.ulRecords; ulRec++)
    {
        if (!ReadRecord(hf, (LPGENERICHEADER)&sQH, ulRec, (LPGENERICREC)&sQR))
        {
            Assert(FALSE);
            goto bailout;
        }

        if (sQR.uchType == REC_DATA)
        {
            if (IsLeaf(sQR.ulidShadow))
            {
                if (RecreateInode(lpdbID, sQR.ulidShadow, (fEncrypt)?FILE_ATTRIBUTE_ENCRYPTED:0) < 0)
                {
                    ++cntFailed;
                }
            }
        }
    }


    if (!cntFailed)
    {
        fRet = TRUE;
    }

bailout:
    if (hf)
    {
        CloseFileLocal(hf);
    }

    return (fRet);
}

#if defined(BITCOPY)
LPVOID
PUBLIC
FormAppendNameString(
    LPTSTR      lpdbID,
    ULONG       ulidFile,
    LPTSTR      str2Append
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    LPTSTR lp, lpT;
    int lendbID;
    char chSubdir;
    int lenStr2Append = 0;

    if (!lpdbID)
    {
        SetLastErrorLocal(ERROR_INVALID_PARAMETER);
        return (NULL);
    }

    if (lpdbID == vlpszShadowDir)
    {
        lendbID = vlenShadowDir;
    }
    else
    {
        lendbID = strlen(lpdbID);
    }

    if (str2Append) {
      lenStr2Append = strlen(str2Append);
      lp = AllocMem(lendbID+1+INODE_STRING_LENGTH+1
            +SUBDIR_STRING_LENGTH
            +lenStr2Append+1);
    }
    else {
      lp = AllocMem(lendbID+1+INODE_STRING_LENGTH+1 +SUBDIR_STRING_LENGTH+1);
    }

    if (!lp)
    {
        return NULL;
    }

    memcpy(lp, lpdbID, lendbID);


    // Bump the pointer appropriately
    lpT = lp+lendbID;

    if (*(lpT-1)!= '\\')
    {
        *lpT++ = '\\';
    }

    chSubdir = CSCDbSubdirSecondChar(ulidFile);

    // sprinkle the user files in one of the subdirectories
    if (chSubdir)
    {
        // now append the subdirectory

        *lpT++ = CSCDbSubdirFirstChar();
        *lpT++ = chSubdir;
        *lpT++ = '\\';
    }

    HexToA(ulidFile, lpT, 8);

    lpT += 8;

    if (str2Append) {
      memcpy(lpT, str2Append, lenStr2Append);
      lpT += lenStr2Append;
    }
    *lpT = 0;

    return(lp);
}


int
DeleteStream(
    LPTSTR      lpdbID,
    ULONG       ulidFile,
    LPTSTR      str2Append
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    LPVOID  lpStrmName;
    int iRet = SRET_OK;
    CSCHFILE    hf;
        
    if (!fSupportsStreams)
    {
        return SRET_OK;
    }
    
    lpStrmName = FormAppendNameString(lpdbID, ulidFile, str2Append);
    
    if (lpStrmName)
    {
        if(DeleteFileLocal(lpStrmName, 0) < 0)
        {
            if (GetLastErrorLocal() != ERROR_FILE_NOT_FOUND)
            {
                iRet = SRET_ERROR;
            }
        }
        FreeNameString(lpStrmName);
    }
    else
    {
        SetLastErrorLocal(ERROR_NO_SYSTEM_RESOURCES);
        iRet = SRET_ERROR;
    }
    
    return (iRet);    
}

#endif // defined(BITCOPY)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\record.mgr\shddbg.c ===
/********************************************************************/
/**               Copyright(c) Microsoft Corp., 1990-1993          **/
/********************************************************************/
/* :ts=4 	This file uses 4 space hard tabs */

// ***	vrddbg.c - VRedir debug routines
//

#ifdef DEBUG

#include "precomp.h"
#pragma hdrstop

#pragma code_seg("PAGE")

#include <ifsdebug.h>

#pragma intrinsic (memcmp, memcpy, memset, strcat, strcmp, strcpy, strlen)

#define  MAXPRO            (2+2)
extern NETPRO rgNetPro[MAXPRO];
extern int cMacPro;
extern LPSTR    lpLogBuff;
extern int indxCur;
VOID
DispThisIOReq(
	pioreq pir
	);

VOID
DispThisResource(
	PRESOURCE pResource	
	);

VOID
DispThisFdb(
	PFDB pFdb
	);

VOID
DispThisFileInfo(
	PFILEINFO pFileInfo
	);

VOID
DispThisFindInfo(
	PFINDINFO pFindInfo
	);

extern pimh
DebugMenu(
	IFSMenu *pIFSMenu
	);

IFSMenuHand DispNetPro, DispResource, DispFdb, DispFileInfo, DispFindInfo, DispIOReq, DispLog;

IFSMenu	SHDMainMenu[] = {
	{"NetPro info"	, DispNetPro},
	{"Resource info", DispResource},
	{"Fdb info"		, DispFdb},
	{"OpenFile Info", DispFileInfo},
	{"Find Info"	, DispFindInfo},
	{"DisplayIOReq"	, DispIOReq},
    {"DisplayLog"   , DispLog},
	{0				, 0}
};

typedef struct {
    char  *pName;      // Command name (unique part uppercase, optional lowercase)
    int   (*pHandler)(char *pArgs);
} QD, *pQD;


int NetProCmd(char *pCmd);
int ResCmd(char *pCmd);
int FdbCmd(char *pCmd);
int FileInfoCmd(char *pCmd);
int FindInfoCmd(char *pCmd);
int IoReqCmd(char *pCmd);
int FindInfoCmd(char *pCmd);
int LogCmd(char *pCmd);

QD QueryDispatch[] = {
    { "NETPRO"    	, NetProCmd     },
    { "RES"         , ResCmd     	},
    { "FDB"     	, FdbCmd        },
    { "FILEINFO"    , FileInfoCmd   },
    { "FINDINFO"   	, FindInfoCmd   },
    { "IOREQ"   	, IoReqCmd      },
    { "LOG"         , LogCmd        },
	{ ""        	, 0             },
};


#define MAX_ARG_LEN 30
#define MAX_DEBUG_QUERY_COMMAND_LENGTH 100

unsigned char DebugQueryCmdStr[MAX_DEBUG_QUERY_COMMAND_LENGTH+1] = "";
ULONG DebugQueryCmdStrLen = MAX_DEBUG_QUERY_COMMAND_LENGTH;
unsigned char CmdArg[MAX_ARG_LEN+1] = {0};
unsigned char vrgchBuffDebug[MAX_PATH+1];

/*
    GetArg - Gets a command line argument from a string.

    IN          ppArg = pointer to pointer to argument string
    OUT        *ppArg = pointer to next argument, or NULL if this was the last.
    Returns     Pointer to uppercase ASCIZ argument with delimeters stripped, or NULL if
                no more arguments.

    Note        Not reentrant

*/

unsigned char *GetArg(unsigned char **ppArg)
{
    // Note - Always returns at least one blank argument if string is valid, even
    //        if the string is empty.

    unsigned char *pDest = CmdArg;
    unsigned char c;
    ULONG i;

    #define pArg (*ppArg)

    // If end of command already reached, fail

    if (!pArg)
        return NULL;

    // Skip leading whitespace

    while (*pArg == ' ' || *pArg == '\t')
        pArg++;

    // Copy the argument

    for (i = 0; i < MAX_ARG_LEN; i++) {
        if ((c = *pArg) == 0 || c == '\t' || c == ' ' || c == ';' ||
                          c == '\n' || c == ',')
            break;
        if (c >= 'a' && c <= 'z')
            c -= ('a' - 'A');
        *(pDest++) = c;
        pArg++;
    }

    // Null terminate the result

    *pDest = '\0';

    // Skip trailing whitespace

    while (*pArg == ' ' || *pArg == '\t')
        pArg++;

    // strip up to one comma

    if (*pArg == ',')
        pArg++;

    // If end of command reached, make next request fail

    else if (*pArg == 0 || *pArg == ';' || *pArg == '\n')
        pArg = NULL;

    // return copy

    return CmdArg;

    #undef pArg
}

/*
    AtoI - Convert a string to a signed or unsigned integer

    IN          pStr = ASCIZ representation of number with optional leading/trailing
                       whitespace and optional leading '-'.
                Radix = Radix to use for conversion (2, 8, 10, or 16)
    OUT        *pResult = Numeric result, or unchanged on failure
    Returns     1 on success, 0 if malformed string.

    Note        Not reentrant

*/
ULONG AtoI(unsigned char *pStr, ULONG Radix, ULONG *pResult)
{
    ULONG r = 0;
    ULONG Sign = 0;
    unsigned char c;
    ULONG d;

    while (*pStr == ' ' || *pStr == '\t')
        pStr++;

    if (*pStr == '-') {
        Sign = 1;
        pStr++;
    }

    if (*pStr == 0)
        return 0;                   // Empty string!

    while ((c = *pStr) != 0 && c != ' ' && c != '\t') {
        if (c >= '0' && c <= '9')
            d = c - '0';
        else if (c >= 'A' && c <= 'F')
            d = c - ('A' - 10);
        else if (c >= 'a' && c <= 'f')
            d = c - ('a' - 10);
        else
            return 0;               // Not a digit
        if (d >= Radix)
            return 0;               // Not in radix
        r = r*Radix+d;
        pStr++;
    }

    while (*pStr == ' ' || *pStr == '\t')
        pStr++;

    if (*pStr != 0)
        return 0;                   // Garbage at end of string

    if (Sign)
        r = (ULONG)(-(int)r);
    *pResult = r;

    return 1;                       // Success!

}

VOID
*GetPtr(char *pCmd)
{
	char *pch;
	int p;
	
	pch = GetArg(&pCmd);
	
	//dprintf("cmd = '%s'\n");
	if (*pch == 0 || !AtoI(pch, 16, &p))
 		return 0;

	return (VOID *) p;
}

int
CmdDispatch(char *pCmdName, char *pCmd)
{
	int ret = 0;
	int i=0;
	pQD	pq;

	pq = QueryDispatch;

	while (pq->pName[0]) {
		if (strcmp(pCmdName, pq->pName) == 0) {
		    ret = (*pq->pHandler)(pCmd);
			DbgPrint("\n");
			break;
		}
		pq++;
	}

	return ret;
}

//** Debug Command Handlers

int
NetProCmd(char *pCmd)
{
	
	DispNetPro("");

	return 1;
}

int
IoReqCmd(char *pCmd)
{
	pioreq pir;

	if (pir = GetPtr(pCmd))
		DispThisIOReq(pir);
	else
		return 0;

	return 1;
}


int
ResCmd(char *pCmd)
{
	DispResource(pCmd);
	return 1;
}

int
FdbCmd(char *pCmd)
{
	PFDB pFdb;


	if (pFdb = GetPtr(pCmd)){
		DispThisFdb(pFdb);
	}

	return 1;
}

int
FileInfoCmd(char *pCmd)
{
	PFILEINFO pF;

	if (pF = GetPtr(pCmd))
		DispThisFileInfo(pF);

	return 1;
}

int
FindInfoCmd(char *pCmd)
{

	return 1;
}

int
LogCmd(char *pCmd)
{
    DispLog(pCmd);
}

// **	SHDDebug - handle Debug_Query request from windows
//

VOID
SHDDebug(unsigned char *pCmd)
{
	pimh phand;
	char *pCmdName;

//	dprintf("pCmd = '%s'\n", pCmd);
	//see if we got an explicit command
	pCmdName = GetArg(&pCmd);	

//	dprintf("pCmdName = (%x) '%s'\n", pCmdName, pCmdName);	
	if (*pCmdName != 0) { //got a command, try to process it
		if (!CmdDispatch(pCmdName, pCmd))  {
			DbgPrint("%* Shadow Command Options:\n");
			DbgPrint("%* NETPRO             ----- dump network provider info\n");
			DbgPrint("%* RES [addr]         ---- dump resource info\n");
			DbgPrint("%* FDB [addr]         ---- dump File Descriptor Block\n");
			DbgPrint("%* FILEINFO [addr]    --- dump per open file structure\n");
			DbgPrint("%* FINDINFO [addr]    --- dump findinfo structure\n");
			DbgPrint("%* IOREQ [addr]       --- dump IOReq structure\n");
    		DbgPrint("%* LOG                --- show trace log\n");
    	}
	} else {
		//no args passed, do the menu thing
		while ((phand=DebugMenu(SHDMainMenu)) != 0) {
			if (phand(0) != 0)
				return;
		}
	}
	return;
}


/*+++

Actual display functions

+++*/


VOID
DispThisIOReq(
	pioreq pir
	)
{
    // Display the ioreq structure
	DbgPrint("%*IoReq = \t\t%8.8x \n", pir );
	DbgPrint("%*ir_length=\t\t%x\n", pir->ir_length);
    DbgPrint("%*ir_flags=\t\t%x\n", pir->ir_flags);
    DbgPrint("%*ir_user=\t\t%x\n", pir->ir_user);
	DbgPrint("%*ir_sfn=\t\t%x\n", pir->ir_sfn);
    DbgPrint("%*ir_pid=\t\t%x\n", pir->ir_pid);
    DbgPrint("%*ir_ppath=\t\t%x\n", pir->ir_ppath);
	DbgPrint("%*ir_aux1=\t\t%x\n", pir->ir_aux1);
    DbgPrint("%*ir_data=\t\t%x\n", pir->ir_data);
    DbgPrint("%*ir_options=\t\t%x\n", pir->ir_options);
	DbgPrint("%*ir_error=\t\t%x\n", pir->ir_error);
	DbgPrint("%*ir_rh=\t\t%x\n", pir->ir_rh);
	DbgPrint("%*ir_fh=\t\t%x\n", pir->ir_fh);
	DbgPrint("%*ir_pos=\t\t%x\n", pir->ir_pos);
    DbgPrint("%*ir_aux2=\t\t%x\n", pir->ir_aux2);
    DbgPrint("%*ir_pev=\t\t%x\n", pir->ir_pev);
}

int DispIOReq(
	char *pCmd
	)
{
	pioreq pir;

	if (pir = GetPtr(pCmd))
	{
		DispThisIOReq(pir);
		return (1);
	}
	return (0);
}
int
DispNetPro(
	char *pcl
	)
{
	int i;

	if (cMacPro > 1){
		DbgPrint("%d redirs hooked \n", cMacPro-1);

		for (i=1; i< cMacPro; ++i){
			DbgPrint("Info for Redir # %d \n", i);

			DbgPrint("Head of Resource Chain = \t%x\n", rgNetPro[i].pheadResource);
			DbgPrint("Shadow Connect Function = \t%x\n", rgNetPro[i].pOurConnectNet);
			DbgPrint("Redir Connect Function = \t%x\n", rgNetPro[i].pConnectNet);
		}
		return (1);
	}
	else {
		DbgPrint("No Redirs have been hooked \n");
		return (0);
	}
}


int
DispResource(
	char *pCmd
	)
{
	PRESOURCE pResource = GetPtr(pCmd);

	if (pResource)
	{
		DispThisResource(pResource);

	}
	else
	{
		if (cMacPro > 1)
		{
			pResource = rgNetPro[1].pheadResource;
			while (pResource)
			{
				DispThisResource(pResource);
				pResource = pResource->pnextResource;
			}
		}
	}
}

int
DispFdb(
	char *pCmd
	)
{
	PFDB pFdb = GetPtr(pCmd);

	if (pFdb)
	{
		DispThisFdb(pFdb);
		return (1);
	}
	return (0);
}

int
DispFileInfo(
	char *pCmd
	)
{
	PFILEINFO pFileInfo = GetPtr(pCmd);

	if (pFileInfo)
	{
		DispThisFileInfo(pFileInfo);
		return (1);
	}
	return (0);
}

int
DispFindInfo(
	char *pCmd
	)
{
	PFINDINFO pFindInfo = GetPtr(pCmd);

	if (pFindInfo)
	{
		DispThisFindInfo(pFindInfo);
		return (1);
	}
	return (0);
}

int
DispLog(
	char *pCmd
    )
{
    int indxT=0, len;
    LPSTR   lpszT;

    pCmd;

    lpszT = lpLogBuff;

    while (indxCur > indxT)
    {
        DbgPrint(("%s"), lpszT);

        for (len=1; (*(lpszT+len) != 0xa) && ((indxT+len) < indxCur); ++len);

        // step over the string
        lpszT += len;
        indxT += len;
    }

}

/*+++

Helper Functions

+++*/


VOID
DispThisResource(
	PRESOURCE pResource
	)
{
	DbgPrint("Resource \t%x \n", pResource);
	PpeToSvr(pResource->pp_elements, vrgchBuffDebug, MAX_PATH, BCS_OEM);
	DbgPrint("Share name: \t%s \n", vrgchBuffDebug);
	DbgPrint("Next Resource \t%x \n", pResource->pnextResource);
	DbgPrint("FileInfo structures list \t%x \n", pResource->pheadFileInfo);
	DbgPrint("FindInfo structures list \t%x \n", pResource->pheadFindInfo);
	DbgPrint("FDB structures list \t%x \n", pResource->pheadFdb);
	DbgPrint("hServer: \t%x\n", pResource->hServer);
	DbgPrint("Root shadow: \t%x\n", pResource->hRoot);
	DbgPrint("usFlags \t%x\n", (ULONG)(pResource->usFlags));
	DbgPrint("usLocalFlags \t%x\n", (ULONG)(pResource->usLocalFlags));
	DbgPrint("Our Network Provider \t%x\n", pResource->pOurNetPro);
	DbgPrint("Providers resource handle \t%x\n", pResource->rhPro);
	DbgPrint("fh_t \t%x\n", pResource->fhSys);
	DbgPrint("Providers Volume Function table \t%x\n", pResource->pVolTab);
	DbgPrint(" Count of locks on this resource \t%x\n", pResource->cntLocks);
	DbgPrint(" Bitmap of mapped drives \t%x\n", pResource->uDriveMap);

}

VOID
DispThisFdb(
	PFDB pFdb
	)
{

	DbgPrint("\n");
	memset(vrgchBuffDebug, 0, sizeof(vrgchBuffDebug));
	UniToBCSPath(vrgchBuffDebug, &(pFdb->sppathRemoteFile.pp_elements[0]), MAX_PATH, BCS_OEM);
	DbgPrint("****** Fdb for \t%s ", vrgchBuffDebug);
	memset(vrgchBuffDebug, 0, sizeof(vrgchBuffDebug));
	PpeToSvr(pFdb->pResource->pp_elements, vrgchBuffDebug, MAX_PATH, BCS_OEM);
	DbgPrint("on \t%s \n", vrgchBuffDebug);

	DbgPrint("Next Fdb: \t%x \n", pFdb->pnextFdb);
	DbgPrint("Resource: \t%x\n", pFdb->pResource);
	DbgPrint("usFlags: \t%x\n", (ULONG)(pFdb->usFlags));
	DbgPrint("Total # of opens: \t%x\n", (ULONG)(pFdb->usCount));
	DbgPrint("File Inode: \t%x\n", pFdb->hShadow);
	DbgPrint("Dir Inode: \t%x\n", pFdb->hDir);

}


VOID
DispThisFileInfo(
	PFILEINFO pFileInfo
	)
{

	DbgPrint("\n");
	memset(vrgchBuffDebug, 0, sizeof(vrgchBuffDebug));
	UniToBCSPath(vrgchBuffDebug, &(pFileInfo->pFdb->sppathRemoteFile.pp_elements[0]), MAX_PATH, BCS_OEM);
	DbgPrint("****** FileInfo for \t%s ", vrgchBuffDebug);
	memset(vrgchBuffDebug, 0, sizeof(vrgchBuffDebug));
	PpeToSvr(pFileInfo->pResource->pp_elements, vrgchBuffDebug, MAX_PATH, BCS_OEM);
	DbgPrint("on \t%s \n", vrgchBuffDebug);

	DbgPrint(" Next FileInfo \t%x\n", pFileInfo->pnextFileInfo);
	DbgPrint(" Resource off which it is hangin%x\n", pFileInfo->pResource);
	DbgPrint(" Shadow file handle \t%x\n", pFileInfo->hfShadow);
	DbgPrint(" pFdb: %x\n", pFileInfo->pFdb);
	DbgPrint(" providers file handle: \t%x\n", pFileInfo->fhProFile);
	DbgPrint(" providers file function table \t%x\n", pFileInfo->hfFileHandle);
	DbgPrint(" Acess-share flags for this open \t%x\n", (ULONG)(pFileInfo->uchAccess));
	DbgPrint(" usFlags: \t%x\n", (ULONG)(pFileInfo->usFlags));
	DbgPrint(" usLocalFlags: \t%x\n", (ULONG)(pFileInfo->usLocalFlags));
	DbgPrint(" sfnFile: \t%x\n", pFileInfo->sfnFile);
	DbgPrint(" pidFile: \t%x\n", pFileInfo->pidFile);
	DbgPrint(" userFile: \t%x\n", pFileInfo->userFile);

}

VOID
DispThisFindInfo(
	PFINDINFO pFindInfo
	)
{
}


#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\record.mgr\win97csc.h ===
#include "basedef.h"
#include "shdcom.h"
#include "oslayer.h"
#include "log.h"
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include "assert.h"
#include "ifs.h"
#include "utils.h"
#include "winerror.h"
#include "vxdwraps.h"
#include "cscsec.h"


//got this from wdm.h....modified to use DEBUG
#ifdef DEBUG

#define KdPrint(_x_) DbgPrint _x_
#define KdBreakPoint() DbgBreakPoint()
#ifndef ASSERT
#define ASSERT(__X) Assert(__X)
#define ASSERTMSG(__X,__MSG) AssertMsg(__X,__MSG)
#endif


#else

#define KdPrint(_x_)
#define KdBreakPoint()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\record.mgr\bmreclib\assert.h ===
/* Routines for debugging and error messages. */

#define AssertFn  AssertFn
#define PrintFn   DbgPrint

#ifdef DBG


#define AssertData static char szFileAssert[] = __FILE__;
#define AssertError static char szError[] = "Error";
#define Assert(f)  do {if (!(f)) AssertFn(szError, szFileAssert, __LINE__);} while(0)
#define AssertSz(f, sz)  do {if (!(f)) AssertFn(sz, szFileAssert, __LINE__);} while(0)

VOID AssertFn(PCHAR pMsg, PCHAR pFile, ULONG uLine);

VOID _cdecl DbgPrint(PCHAR pFmt, ...);

VOID
NTAPI
DbgBreakPoint(
    VOID
    );

#else

#define Assert(f)
#define AssertData
#define AssertError
#define AssertSz(f, sz)
#define DbgPrint
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\record.mgr\bmreclib\localdefs.h ===
#define  PUBLIC
typedef int                 BOOL;
typedef  unsigned             HFILE;
typedef void             *LPVOID;
typedef unsigned long       DWORD;
typedef struct  _FILETIME
    {
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
    }   FILETIME;


typedef  ULONG  HSERVER;
typedef  ULONG  HSHADOW;
typedef  ULONG  HSHARE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\record.mgr\utils.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

     Utils.c

Abstract:

     none.

Author:

     Shishir Pardikar      [Shishirp]        01-jan-1995

Revision History:

     Joe Linn                 [JoeLinn]         23-jan-97     Ported for use on NT

--*/

#include "precomp.h"
#pragma hdrstop

#pragma code_seg("PAGE")

#ifndef CSC_RECORDMANAGER_WINNT
#define WIN32_APIS
#include "cshadow.h"
#endif //ifndef CSC_RECORDMANAGER_WINNT

#include <stdlib.h>
#include <ctype.h>
#include <string.h>
// #include "error.h"
#include <vmmreg.h>  // Must be after error.h
#include "vxdwraps.h"

#define  SIGN_BIT 0x80000000
#define  UCHAR_OFFLINE  ((USHORT)'_')
#define  HIGH_ONE_SEC    0x98
#define  LOW_ONE_SEC     0x9680

#pragma intrinsic (memcmp, memcpy, memset, strcat, strcmp, strcpy, strlen)
#define cBackSlash    '\\'
#define cNull          0

#ifdef MAYBE
ULONG UlGetDefaultShadowStore(LPSTR lpDrive);
#endif //MAYBE

AssertData
AssertError
extern char pathbuff[MAX_PATH+1];
extern char vszShadowDir[MAX_SHADOW_DIR_NAME+1];
char vszEnableShadow[]="EnableShadow";
char vszEnableRemoteLog[]="EnableRemoteLog";
char vszEnableDisconnect[]="EnableDisconnect";
char vszMaxShadowStoreHex[]="MaxShadowStoreHex";
char vszMaxLogfileSize[]="MaxLogfileSize";
char vszExcludeList[] = "ExcludeExtensions";
char vszIncludeList[] = "IncludeExtensions";
char vszExclDelim[]=" ;,";
char vszRemoteAccess[]="System\\CurrentControlSet\\Services\\RemoteAccess";
char vszRemoteConnection[]="Remote Connection";
char vszEnableSpeadOpt[]="EnableSpeadOpt";
char vszDefShadowDir[] = "c:\\shadow";
char vszCSCDirName[] = "CSC\\";

USHORT *rgwzHeuristicExtensionTab[] =
{
	L".exe",
	L".dll"
};

#ifndef CSC_RECORDMANAGER_WINNT
#pragma VxD_LOCKED_CODE_SEG
#endif //ifndef CSC_RECORDMANAGER_WINNT

int PUBLIC GetServerPart(
    LPPE  lppeServer,
    USHORT *lpBuff,
    int cBuff
    )
 {
    return(PpeToSvr(lppeServer, (LPSTR)lpBuff, cBuff, UNICODE));
 }

ULONG PUBLIC GetNextPathElement(
    LPPP    lppp,
    ULONG   indx,
    USHORT  *lpBuff,
    ULONG   cBuff
    )
 {
    LPPE lppe;

#if VERBOSE > 3
    KdPrint(("GetNextPathElement: input index=%d \r\n", indx));
#endif //VERBOSE > 3
    lppe = (LPPE)&(((LPBYTE)(lppp->pp_elements))[indx]);
    if (lpBuff)
     {
        Assert(cBuff);
        memset(lpBuff, 0, cBuff);

        memcpy(lpBuff, lppe->pe_unichars, min(lppe->pe_length-2, (int)cBuff));
//        UniToBCS(lpBuff, lppe->pe_unichars, lppe->pe_length-2, cBuff-1, BCS_OEM);
     }
#if VERBOSE > 3
    KdPrint(("GetNextPathElement: output index=%d \r\n", indx));
#endif //VERBOSE > 3
    indx += lppe->pe_length;
    return ((indx < IFSPathLength(lppp))?indx:0xffff);
 }

VOID PUBLIC GetLeafPtr
    (
    PIOREQ   pir,
    USHORT  *lpBuff,
    ULONG   cBuff
    )
 {
    LPPE lpLast;
    Assert(cBuff);
    lpLast = IFSLastElement((LPPP)(pir->ir_ppath));
    memset(lpBuff, 0, cBuff);
    memcpy(lpBuff, lpLast->pe_unichars, min(lpLast->pe_length-2, (int)cBuff));
 }


VOID PUBLIC BreakPath(
    LPPP lppp,
    ULONG indx,
    USHORT *pusCookie
    )
 {
    USHORT u;
    LPPE lppe;

#if VERBOSE > 3
	UniToBCSPath(pathbuff, &lppp->pp_elements[0], MAX_PATH, BCS_OEM);
    KdPrint(("BreakPath In %s \r\n", pathbuff));
#endif //VERBOSE > 3
    *pusCookie = lppp->pp_totalLength;
    *(pusCookie+1) = lppp->pp_prefixLength;
    *(pusCookie+2) = 0;
    if (IFSPathLength(lppp) > indx)
     {
        if (!indx)
         {
            lppp->pp_totalLength = lppp->pp_prefixLength = 4;
         }
        else
         {
            for (lppe = lppp->pp_elements, u=0;;)
             {
                u += lppe->pe_length;
                // This condition must happen
                if (u >= indx)
                 {
                    lppp->pp_totalLength = u+4;
                    lppp->pp_prefixLength = u - lppe->pe_length+4;
                    break;
                 }
                lppe = IFSNextElement(lppe);
             }
         }
        *(pusCookie+2) = *(USHORT *)&(((LPBYTE)(lppp->pp_elements))[indx]);
        *(USHORT *)&(((LPBYTE)(lppp->pp_elements))[indx]) = 0;
     }
#if VERBOSE > 3
    KdPrint(("BreakPath saved=%x \r\n", uSav));
	UniToBCSPath(pathbuff, &lppp->pp_elements[0], MAX_PATH, BCS_OEM);
    KdPrint(("BreakPath out %s \r\n", pathbuff));
#endif //VERBOSE > 3
 }

VOID PUBLIC MendPath(
    LPPP  lppp,
    ULONG indx,
    USHORT *pusCookie
    )
 {
    lppp->pp_totalLength = *pusCookie ;
    lppp->pp_prefixLength = *(pusCookie+1);
    if (indx < IFSPathLength(lppp))
     {
        *(USHORT *)&(((LPBYTE)(lppp->pp_elements))[indx])
            = *(pusCookie+2);
     }
#if VERBOSE > 3
	UniToBCSPath(pathbuff, &lppp->pp_elements[0], MAX_PATH, BCS_OEM);
    KdPrint(("MendPath %s \r\n", pathbuff));
#endif //VERBOSE > 3
 }


int PUBLIC GetPathLevel(
    LPPP ppath
    )
 {
	PathElement	*ppe;
    int level = 1;

	ppe = ppath->pp_elements;

	while(ppe->pe_length)
     {
        ++level;
        ppe = IFSNextElement(ppe);
    	}
    return (level);
 }

int PUBLIC HexToA(
    ULONG ulHex,
    LPSTR lpName,
    int count)
 {
    int i;
    LPSTR lp = lpName+count-1;
    UCHAR uch;

    for (i=0; i<count; ++i)
     {
        uch = (UCHAR)(ulHex & 0xf) + '0';
        if (uch > '9')
            uch += 7;    // A becomes '0' + A + 7 which is 'A'
        *lp = uch;
        --lp;
        ulHex >>= 4;
     }
    *(lpName+count) = cNull;
    return 0;
 }


ULONG PUBLIC AtoHex(
    LPSTR lpStr,
    int count
    )
 {
    int i;
    LPSTR lp = lpStr;
    UCHAR uch;
    ULONG ulHex = 0L;

    for (i=0; i<count; ++i)
     {
        uch = *lp;
        if (uch>= '0' && uch <= '9')
            ulHex += (uch - '0');
        else if (uch >= 'A' && uch <= 'F')
            ulHex += (uch - '0' - 7);
        else
            break;
        ++lp;
        ulHex <<= 4;
     }
    return ulHex;
 }


int PpeToSvr( LPPE lppe,
    LPSTR lpBuff,
    int cBuff,
    ULONG type
    )
 {
    LPSTR lpTmp = lpBuff;
    memset(lpTmp, 0, cBuff);
    if (type != UNICODE)
     {
        if (cBuff <= (lppe->pe_length+IFSNextElement(lppe)->pe_length)/2)
            return 0;
        *lpTmp = '\\';
        UniToBCS(lpTmp+1, lppe->pe_unichars, lppe->pe_length-2, cBuff, BCS_OEM);
        lpTmp += (lppe->pe_length)/2;
        lppe = IFSNextElement(lppe);
        *lpTmp = '\\';
        UniToBCS(lpTmp+1, lppe->pe_unichars, lppe->pe_length-2, cBuff, BCS_OEM);
     }
    else
     {
        USHORT *lpUni;

        lpUni = (USHORT *)lpTmp;
        if (cBuff < (lppe->pe_length+IFSNextElement(lppe)->pe_length))
            return 0;
        *lpUni = '\\';
        memcpy(lpUni+1, lppe->pe_unichars, lppe->pe_length);
        lpUni = (USHORT *)((LPSTR)lpUni+lppe->pe_length);
        lppe = IFSNextElement(lppe);
        *lpUni = '\\';
        memcpy(lpUni+1, lppe->pe_unichars, lppe->pe_length);
     }
    return (1);
 }

int IPathCompare( LPPP lpppDst,
    LPPP lpppSrc
    )
 {
    LPPE lppeDst, lppeSrc;
    if (lpppDst->pp_totalLength != lpppSrc->pp_totalLength)
        return -1;
    if (lpppDst->pp_prefixLength != lpppSrc->pp_prefixLength)
        return -1;

    lppeDst = lpppDst->pp_elements;
    lppeSrc = lpppSrc->pp_elements;
    for (;;)
     {
        if (!lppeDst->pe_length || !lppeSrc->pe_length)
            break;
        if (lppeDst->pe_length != lppeSrc->pe_length)
            return -1;
        if (wstrnicmp(lppeDst->pe_unichars, lppeSrc->pe_unichars, lppeSrc->pe_length))
            return -1;
        lppeDst = IFSNextElement(lppeDst);
        lppeSrc = IFSNextElement(lppeSrc);
     }
    return 0;
 }


int wstrnicmp( const USHORT *pStr1,
    const USHORT *pStr2,
    ULONG count
    )
 {
    USHORT c1, c2;
    int iRet;
    ULONG i=0;

    for(;;)
     {
        c1 = *pStr1++;
        c2 = *pStr2++;
        c1 = _wtoupper(c1);
        c2 = _wtoupper(c2);
        if (c1!=c2)
            break;
        if (!c1)
            break;
        i+=2;
        if (i >= count)
            break;
     }
    iRet = ((c1 > c2)?1:((c1==c2)?0:-1));
    return iRet;
 }

#ifndef CSC_RECORDMANAGER_WINNT
int mystrnicmp(
    const char *pStr1,
    const char *pStr2,
    unsigned count
    )
#else
_CRTIMP int __cdecl mystrnicmp(
    const char *pStr1,
    const char *pStr2,
    size_t count
    )
#endif //ifndef CSC_RECORDMANAGER_WINNT
 {
    char c1, c2;
    int iRet;
    ULONG i=0;

    for(;;)
     {
        c1 = *pStr1++;
        c2 = *pStr2++;
        c1 = _mytoupper(c1);
        c2 = _mytoupper(c2);
        if (c1!=c2)
            break;
        if (!c1)
            break;
        if (++i >= count)
            break;
     }
    iRet = ((c1 > c2)?1:((c1==c2)?0:-1));
    return iRet;
 }

ULONG strmcpy( LPSTR lpDst,
	LPSTR lpSrc,
    ULONG cTchar
    )
 {
    ULONG i;

    if (!cTchar)
        return 0;
    for(i=cTchar;i;--i)
        if (!(*lpDst++ = *lpSrc++))
						    break;
    lpDst[cTchar-i] ='\0';

    return(cTchar-i);
 }

ULONG wstrlen(
    USHORT *lpuStr
    )
 {
    ULONG i;

    for (i=0; *lpuStr; ++lpuStr, ++i);
    return (i);
 }

int DosToWin32FileSize( ULONG uDosFileSize,
    int *lpnFileSizeHigh,
    int *lpnFileSizeLow
    )
 {
    int iRet;

    if (uDosFileSize & SIGN_BIT)
     {
        *lpnFileSizeHigh = 1;
        *lpnFileSizeLow = uDosFileSize & SIGN_BIT;
        iRet = 1;
     }
    else
     {
        *lpnFileSizeHigh = 0;
        *lpnFileSizeLow = uDosFileSize;
        iRet = 0;
     }
    return (iRet);
 }

int Win32ToDosFileSize( int nFileSizeHigh,
    int nFileSizeLow,
    ULONG *lpuDosFileSize
    )
 {
    int iRet;
    *lpuDosFileSize = nFileSizeLow;
    if (nFileSizeHigh == 1)
     {
        *lpuDosFileSize += SIGN_BIT;
        iRet = 1;
     }
    else
        iRet = 0;
    return (iRet);
 }

int CompareTimes( _FILETIME ftDst,
    _FILETIME ftSrc
    )
 {
    int iRet = 0;

    if (ftDst.dwHighDateTime
                    > ftSrc.dwHighDateTime)
        iRet = 1;
    else if (ftDst.dwHighDateTime == ftSrc.dwHighDateTime)
     {
        if (ftDst.dwLowDateTime > ftSrc.dwLowDateTime)
            iRet = 1;
        else if (ftDst.dwLowDateTime == ftSrc.dwLowDateTime)
            iRet = 0;
        else
            iRet = -1;
     }
    else
        iRet = -1;
    return (iRet);
 }

int CompareTimesAtDosTimePrecision( _FILETIME ftDst,
    _FILETIME ftSrc
    )
 {
    dos_time dostDst, dostSrc;
    int diff;

    dostDst = IFSMgr_Win32ToDosTime(ftDst);
    dostSrc = IFSMgr_Win32ToDosTime(ftSrc);

    diff = (int)(*(ULONG *)&dostDst - *(ULONG *)&dostSrc);

    if (diff > 1)
        return 1;
    else if (diff < -1)
        return -1;
    else
        return 0;
 }

int CompareSize(
    long nHighDst,
    long nLowDst,
    long nHighSrc,
    long nLowSrc
    )
 {
    int iRet = 0;

    if (nHighDst > nHighSrc)
        iRet = 1;
    else if (nHighDst == nHighSrc)
     {
        if (nLowDst > nLowSrc)
            iRet = 1;
        else if (nLowDst == nLowSrc)
            iRet = 0;
        else
            iRet = -1;
     }
    else
        iRet = -1;
    return (iRet);
 }

void InitFind32FromIoreq
    (
    PIOREQ    pir,
    LPFIND32 lpFind32,
    ULONG uFlags
    )
 {
    if (uFlags & IF32_LOCAL)
     {
		memset(lpFind32, 0, sizeof(WIN32_FIND_DATA));
		InitFind32Names(lpFind32,
					  ((pir->ir_attr & FILE_FLAG_KEEP_CASE)&&(uFlags&IF32_LAST_ELEMENT))?
						pir->ir_uFName:
						IFSLastElement(pir->ir_ppath)->pe_unichars,
						(pir->ir_attr & FILE_FLAG_IS_LFN)? NULL:IFSLastElement((LPPP)(pir->ir_ppath))->pe_unichars);
     }

    if (!(uFlags & IF32_DIRECTORY))
     {
        lpFind32->dwFileAttributes =
                ((((pir->ir_attr) & ~FILE_ATTRIBUTE_DIRECTORY) | FILE_ATTRIBUTE_ARCHIVE)
			& FILE_ATTRIBUTE_EVERYTHING);
     }
    else
     {
        lpFind32->dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY;
     }

    if (uFlags & IF32_LOCAL)
     {
//CODE.IMPROVEMENT very ugly.....define a platform specific macro....
#ifndef CSC_RECORDMANAGER_WINNT
        lpFind32->ftCreationTime = IFSMgr_NetToWin32Time(IFSMgr_Get_NetTime());
#else
        //lpFind32->ftCreationTime = IFSMgr_NetToWin32Time(IFSMgr_Get_NetTime());
        KeQuerySystemTime(((PLARGE_INTEGER)(&lpFind32->ftCreationTime)));
#endif //ifndef CSC_RECORDMANAGER_WINNT
        lpFind32->ftLastAccessTime = lpFind32->ftLastWriteTime = lpFind32->ftCreationTime;
     }

    lpFind32->nFileSizeHigh = lpFind32->nFileSizeLow = 0;
 }

void InitIoreqFromFind32
    (
    LPFIND32 lpFind32,
    PIOREQ    pir
    )
 {
    pir->ir_attr = lpFind32->dwFileAttributes;
    pir->ir_size = lpFind32->nFileSizeLow;
 }

void InitFind32Names( LPFIND32 lpFind32,
    USHORT *lpcFileName,
    USHORT *lpcAlternateFileName
    )
 {
    int len;

    memset(lpFind32->cFileName, 0, sizeof(lpFind32->cFileName));
    memset(lpFind32->cAlternateFileName, 0, sizeof(lpFind32->cAlternateFileName));

    len = wstrlen(lpcFileName)*2;
    len = min(len, (sizeof(lpFind32->cFileName)-2));
    memcpy(lpFind32->cFileName, lpcFileName, len);

    if (lpcAlternateFileName)
     {
        len = wstrlen(lpcAlternateFileName)*2;
        len = min(len, (sizeof(lpFind32->cAlternateFileName)-2));
		memset(lpFind32->cAlternateFileName, 0, sizeof(lpFind32->cAlternateFileName));
		UniToUpper(lpFind32->cAlternateFileName, lpcAlternateFileName, len);
     }
 }

void Find32ToSearchEntry(LPFIND32 lpFind32, srch_entry *pse)
 {
    dos_time sDosTime;
    pse->se_attrib = (UCHAR)(lpFind32->dwFileAttributes);
    sDosTime = IFSMgr_Win32ToDosTime(lpFind32->ftLastWriteTime);
    pse->se_time = sDosTime.dt_time;
    pse->se_date = sDosTime.dt_date;
    Win32ToDosFileSize(lpFind32->nFileSizeHigh
                                , lpFind32->nFileSizeLow
                                , &(pse->se_size));
    memset(pse->se_name, 0, sizeof(pse->se_name));
    UniToBCS(pse->se_name
                , lpFind32->cAlternateFileName
                , wstrlen(lpFind32->cAlternateFileName) * 2
                , sizeof(pse->se_name)-1, BCS_OEM);
 }

void PUBLIC Find32AFromFind32(
    LPFIND32A    lpFind32ADst,
    LPFIND32     lpFind32WSrc,
    int            type
    )
 {
    // Copy everything except the names, we know the size of that is the
    // same for both structures
    memcpy(lpFind32ADst, lpFind32WSrc, sizeof(_WIN32_FIND_DATAA)
                                            -sizeof(lpFind32ADst->cFileName)
                                            -sizeof(lpFind32ADst->cAlternateFileName));

    // Cleanup the destineation names so we don't get into NULL termination problems
    memset(lpFind32ADst->cFileName, 0, sizeof(lpFind32ADst->cFileName));
    memset(lpFind32ADst->cAlternateFileName, 0, sizeof(lpFind32ADst->cAlternateFileName));


    UniToBCS(lpFind32ADst->cFileName     // Destination ANSI string
                , lpFind32WSrc->cFileName  // Source unicode string
                , sizeof(lpFind32WSrc->cFileName)    // bytes in the source
                    - sizeof(lpFind32WSrc->cFileName[0])
                , sizeof(lpFind32ADst->cFileName)    // max size of dst string wo NULL
                    -sizeof(lpFind32ADst->cFileName[0])
                , type    // ANSI or OEM
                );

    UniToBCS(lpFind32ADst->cAlternateFileName
                , lpFind32WSrc->cAlternateFileName
                , sizeof(lpFind32WSrc->cAlternateFileName)
                    - sizeof(lpFind32WSrc->cAlternateFileName[0])
                , sizeof(lpFind32ADst->cAlternateFileName)
                    -sizeof(lpFind32ADst->cAlternateFileName[0])
                , BCS_OEM);
 }

void PUBLIC Find32FromFind32A(
    LPFIND32     lpFind32WDst,
    LPFIND32A    lpFind32ASrc,
    int            type
    )
 {
    memcpy(lpFind32WDst, lpFind32ASrc, sizeof(_WIN32_FIND_DATAA)
                                            -sizeof(lpFind32ASrc->cFileName)
                                            -sizeof(lpFind32ASrc->cAlternateFileName));

    memset(lpFind32WDst->cFileName, 0, sizeof(lpFind32WDst->cFileName));
    memset(lpFind32WDst->cAlternateFileName, 0, sizeof(lpFind32WDst->cAlternateFileName));
    BCSToUni(lpFind32WDst->cFileName
                , lpFind32ASrc->cFileName
                , sizeof(lpFind32ASrc->cFileName)
                    - sizeof(lpFind32ASrc->cFileName[0])
                        , type);

    BCSToUni(lpFind32WDst->cAlternateFileName
                , lpFind32ASrc->cAlternateFileName
                , sizeof(lpFind32ASrc->cAlternateFileName)
                    - sizeof(lpFind32ASrc->cAlternateFileName[0])
                , BCS_OEM);
 }

//**	AddPathElement
//
//	This routine adds a path element to an existing parsed path structure
//	
//	flag =  0 - no mapping
//			1 - map from OEM to unicode
//

void  AddPathElement( path_t		ppath,
    string_t	pstr,	
    int			flag) 	
 {
	PathElement *ppe;
	int 		len, unilen;
	
	ppe = IFSLastElement(ppath);
	ppath->pp_prefixLength+=ppe->pe_length;	//update the prefix marker
	ppe = IFSNextElement(ppe);

	//add the new element
	if (flag)
     {
		//map to unicode
		len = strlen((char *)pstr);
		unilen = BCSToUni(ppe->pe_unichars, (char *) pstr, len, BCS_OEM);
	 }
    else
    {
		//already in unicode
		unilen = wstrlen(pstr)*sizeof(USHORT);
		memcpy(ppe->pe_unichars, pstr, unilen);
    }
	ppe->pe_length = (USHORT)(unilen+sizeof(USHORT)); //include the length word		
	//update the header
	ppath->pp_totalLength+=ppe->pe_length;  //update total length

	//mark the end
	ppe = IFSNextElement(ppe);
	ppe->pe_length = 0;	
 }

//**  	MakePath
//		
//		Builds a parsed path from a ASCII string in the format "\\FOO\BAR.."
//
//		ppath - points to a path buffer at least PATH_BUFF_SIZE
//		ppath - OEM path string
//

void MakePPath( path_t	ppath,
    LPBYTE 	ps
    )
{
    LPBYTE pc = ps;

    MakeNullPPath(ppath);	//initialize the path

    while(*pc == '\\') //skip past leading '\'
    {
       	pc++;
    }

    if (ps[0] =='\\')	//ps points to first name
    {
   	    ps++;
    }

    for (;;)
    {
   	    if (*pc == '\\')
        {
   		    *pc = 0;
   		    AddPathElement(ppath, (string_t)ps, 1);
   		    *pc = '\\';
   		    ps = ++pc;
   	    }
        else if (*pc == 0)
        {
   		    AddPathElement(ppath, (string_t)ps, 1);
   		    break;
   		}
   	    pc++;
    }
}


//**  	MakePathW
//		
//		Builds a parsed path from a unicode string in the format "\\FOO\BAR.."
//
//		ppath - points to a path buffer at least PATH_BUFF_SIZE
//		ppath - OEM path string
//

void MakePPathW( path_t	ppath,
    USHORT  *puName
    )
{
    USHORT *pu = puName;

    MakeNullPPath(ppath);   //initialize the path

    while(*pu == L'\\') //skip past leading '\'
    {
   	    pu++;
    }

    if (pu[0] == L'\\') //ps points to first name
    {
   	    pu++;
    }

    for (;;)
    {
   	    if (*pu == L'\\')
        {
   		    *pu = 0;

   		    AddPathElement(ppath, (string_t)puName, 0);

   		    *pu = L'\\';

   		    puName = ++pu;
   	    }
        else if (*pu == 0)
        {
   		    AddPathElement(ppath, (string_t)puName, 0);

   		    break;
   		}

   	    pu++;
    }
}

//** DeleteLastElement
//
// removes the last element from a parsed path
//
void DeleteLastElement( path_t ppath
    )
 {
	PathElement	*ppe, *ppelast;
	
	ppe = IFSLastElement(ppath);
	ppath->pp_totalLength -= ppe->pe_length;
	ppe->pe_length = 0;

	//set the new prefix length
	ppe = ppath->pp_elements;
	ppath->pp_prefixLength = 4;

	while(ppe->pe_length)
     {
		ppelast = ppe;
		ppe = IFSNextElement(ppe);
		if (ppe)
			ppath->pp_prefixLength += ppelast->pe_length;
    	}
 }


int ResNameCmp(
    LPPE  lppeSrc,
    LPPE  lppeDst
    )
 {
    int i;

    for (i=0; i<2; ++i)
     {
        if (lppeSrc->pe_length != lppeDst->pe_length)
            break;
        if (wstrnicmp(lppeSrc->pe_unichars
            , lppeDst->pe_unichars
            , lppeSrc->pe_length-sizeof(lppeDst->pe_length)))
            break;
        lppeSrc = IFSNextElement(lppeSrc);
        lppeDst = IFSNextElement(lppeDst);
     }
    return (!(i==2));//return 0 if equal
 }

int  Conv83ToFcb(
    LPSTR lp83Name,
    LPSTR lpFcbName
    )
 {
    int i, j;
    char ch;
    memset(lpFcbName, ' ', 11);
    for(i=0; ((ch=lp83Name[i]) && (i<8)); ++i)
     {
        if (ch=='.')
            break;
        lpFcbName[i] = ch;
     }
    if (lp83Name[i]=='.')
     {
        // Step over the dot
        ++i;
        // point to the extension area in the FCB format
        j = 8;
        for(;((ch=lp83Name[i]) && (j<11)); ++i, ++j)
         {
            lpFcbName[j] = ch;
         }
        return (i);
     }
    else
     {
        return (i);
     }
 }

int  Conv83UniToFcbUni(
    USHORT *lp83Name,
    USHORT *lpFcbName
    )
 {
    int i, j;
    USHORT uch;

    for (i=0; i<11; ++i)
     {
        lpFcbName[i] = (USHORT)' ';
     }

    for(i=0; ((uch=lp83Name[i]) && (i<8)); ++i)
     {
        if (uch==(USHORT)'.')
            break;
        lpFcbName[i] = uch;
     }
    if (lp83Name[i]=='.')
     {
        // Step over the dot
        ++i;
        // point to the extension area in the FCB format
        j = 8;
        for(;((uch=lp83Name[i]) && (j<11)); ++i, ++j)
         {
            lpFcbName[j] = uch;
         }
        return (i);
     }
    else
     {
        return (i);
     }
 }

void FillRootInfo(
    LPFIND32 lpFind32
    )
 {
    memset(lpFind32, 0, sizeof(WIN32_FIND_DATA));
    lpFind32->dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY;
    lpFind32->cFileName[0] = lpFind32->cAlternateFileName[0] = '\\';
 }

int ReadInitValues()
 {
    VMMHKEY hKeyShadow;
	LPSTR	lpWindir = NULL;
    int iSize = sizeof(int), lenWindir=0;
    DWORD dwType;
    extern int fLog, fShadow, fDiscon, fSpeadOpt, vlenShadowDir;
    extern ULONG ulMaxStoreSize, ulMaxLogfileSize;
	extern LPSTR vlpszShadowDir;
	
    if (_RegOpenKey(HKEY_LOCAL_MACHINE, REG_KEY_SHADOW, &hKeyShadow) ==  ERROR_SUCCESS)
    {
#ifdef CSC_RECORDMANAGER_WINNT
        memset(vszShadowDir, 0, sizeof(vszShadowDir));
        iSize = MAX_SHADOW_DIR_NAME+1;
        if(_RegQueryValueEx(hKeyShadow, REG_STRING_DATABASE_LOCATION, NULL, &dwType, vszShadowDir, &iSize)!=ERROR_SUCCESS)
         {
            Assert(strlen(vszDefShadowDir) <= MAX_SHADOW_DIR_NAME);
            KdPrint(("ReadInitValues: No vszShadowDb value in registry\r\n"));
            memcpy(vszShadowDir, vszDefShadowDir, strlen(vszDefShadowDir));
         }
#else

#ifdef OLDCODE

		lpWindir = (LPSTR)GetConfigDir();

		if (!lpWindir)
		{
			// VMM promises this to be valid!!!
			Assert(FALSE);
			return (0);
		}

		lenWindir = strlen(lpWindir);
		vlpszShadowDir = AllocMem(lenWindir+strlen(vszCSCDirName)+3);

		if (!vlpszShadowDir)
		{
			KdPrint(("ReadInitValues: Failed memroy allocation while\r\n"));
			return (0);
		}

		memcpy(vlpszShadowDir, lpWindir, lenWindir);

		if ((*(lpWindir+lenWindir-1))!='\\')
		{
			*(vlpszShadowDir+lenWindir)='\\';
		}

		// NB vszCSCDirName has a trailing backslash
		strcat(vlpszShadowDir, vszCSCDirName);
		vlenShadowDir = strlen(vlpszShadowDir);

        KdPrint(("ReadInitValues: ShadowDbDir is %s\r\n", vlpszShadowDir));
#endif // OLDCODE

#endif // CSC_RECORDMANAGER_WINNT

#ifdef MAYBE
		// we should let the agent decide whether shadowing should be on or off
        _RegQueryValueEx(hKeyShadow, vszEnableShadow, NULL, &dwType, &fShadow, &iSize);
#endif // MAYBE

        iSize = sizeof(int);
        _RegQueryValueEx(hKeyShadow, vszEnableRemoteLog, NULL, &dwType, &fLog, &iSize);
        iSize = sizeof(int);
        _RegQueryValueEx(hKeyShadow, vszEnableDisconnect, NULL, &dwType, &fDiscon, &iSize);
        iSize = sizeof(int);
        _RegQueryValueEx(hKeyShadow, vszEnableSpeadOpt, NULL, &dwType, &fSpeadOpt, &iSize);
        iSize = sizeof(ULONG);
        _RegQueryValueEx(hKeyShadow, vszMaxShadowStoreHex, NULL, &dwType, &ulMaxStoreSize, &iSize);
        iSize = sizeof(ULONG);
        if(_RegQueryValueEx(hKeyShadow, vszMaxLogfileSize, NULL, &dwType, &ulMaxLogfileSize, &iSize)!=ERROR_SUCCESS)
         {
            ulMaxLogfileSize = MAX_LOGFILE_SIZE;
         }
        else if (ulMaxLogfileSize < MIN_LOGFILE_SIZE)
         {
            ulMaxLogfileSize = MIN_LOGFILE_SIZE;
         }
        _RegCloseKey(hKeyShadow);
        ulMaxStoreSize = 0xffffffff;
#ifdef MAYBE
        ulMaxStoreSize = UlGetDefaultShadowStore(vszShadowDir);
#endif //MAYBE
        return(1);
     }
    return (0);
 }

BOOL IsSlowLink()
 {
    VMMHKEY hKeyRemote;
    int iSize = sizeof(int), fRemote=0;
    DWORD dwType;
    if (_RegOpenKey(HKEY_LOCAL_MACHINE, vszRemoteAccess, &hKeyRemote) ==  ERROR_SUCCESS)
     {
        _RegQueryValueEx(hKeyRemote, vszRemoteConnection, NULL, &dwType, &fRemote, &iSize);
        _RegCloseKey(hKeyRemote);
     }
    return (fRemote);
 }

BOOL FHasWildcard(
    USHORT *lpuName,
    int cMax
    )
 {
    int i;
    BOOL fRet = FALSE;
    USHORT uT;

    for (i=0; i<cMax; ++i)
     {
        uT = *(lpuName+i);
        if (!uT)
            break;
        if (fRet = ((uT==(USHORT)'*')||(uT == (USHORT)'?')))
            break;
     }
    return (fRet);
 }

int IncrementTime(
    LPFILETIME  lpFt,
    int    secs
    )
 {
    lpFt->dwHighDateTime += secs*(HIGH_ONE_SEC+1);
    return(0);  //stop complaining about no return value
 }

int FParentMatch(
    LPPP  lpp1,
    LPPP  lpp2
    )
 {
	PathElement	*ppe1, *ppe2, *ppe1Last, *ppe2Last;
    int fMatch = FALSE;

    //If either of them is root then say they have invalid parents
    if (IFSIsRoot(lpp1) || IFSIsRoot(lpp2))
        return 0;

    ppe1Last = IFSLastElement(lpp1);
    ppe2Last = IFSLastElement(lpp2);

    ppe1 = lpp1->pp_elements;
    ppe2 = lpp2->pp_elements;

	while((ppe1!=ppe1Last) && (ppe2!= ppe2Last))
     {
        if (ppe1->pe_length!=ppe1->pe_length)
            return 0;
        if (wstrnicmp(ppe1->pe_unichars, ppe2->pe_unichars, ppe1->pe_length-2))
            return 0;
        ppe1 = IFSNextElement(ppe1);
        ppe2 = IFSNextElement(ppe2);
    	}

    return ((ppe1==ppe1Last) && (ppe2==ppe2Last));
 }


LPSTR mystrpbrk(
    LPSTR lpSrc,
    LPSTR lpDelim
    )
 {
    char c, c1;
    LPSTR lpSav;
    BOOL fBegin = FALSE;

  for(;c = *lpSrc; ++lpSrc)
     {
        // skip leading blanks
        if (!fBegin)
         {
            if (c==' ')
                continue;
            else
                fBegin = TRUE;
         }

        lpSav = lpDelim;
        while (c1 = *lpDelim++)
         {
            if (c==c1)
                return (lpSrc);
         }
        lpDelim = lpSav;
     }
    return (NULL);
 }

LPWSTR
wstrpbrk(
    LPWSTR lpSrc,
    LPWSTR lpDelim
    )
{
    USHORT c, c1;
    LPWSTR lpSav;
    BOOL fBegin = FALSE;

    for(;c = *lpSrc; ++lpSrc)
    {
        // skip leading blanks
        if (!fBegin)
        {
            if (c==L' ')
            {
                continue;
            }
            else
            {
                fBegin = TRUE;
            }
        }

        lpSav = lpDelim;

        while (c1 = *lpDelim++)
        {
            if (c==c1)
            {
                return (lpSrc);
            }
        }

        lpDelim = lpSav;
    }
    return (NULL);
}

int OfflineToOnlinePath
    (
    path_t ppath
    )
 {
    if (!IFSIsRoot(ppath) && IsOfflinePE(ppath->pp_elements))
     {
        OfflineToOnlinePE(ppath->pp_elements);
        ppath->pp_totalLength -= sizeof(USHORT);
        ppath->pp_prefixLength-= sizeof(USHORT);
     }
    return(0);  //stop complaining about no return value
 }

int OnlineToOfflinePath
    (
    path_t ppath
    )
 {
    // Must have space for one extra character

    OnlineToOfflinePE(ppath->pp_elements);
    ppath->pp_totalLength  += sizeof(USHORT);
    ppath->pp_prefixLength += sizeof(USHORT);
    return(0);  //stop complaining about no return value
 }

BOOL IsOfflinePE
    (
    LPPE lppe
    )
 {
    return(lppe->pe_unichars[1] == UCHAR_OFFLINE);
 }

int OfflineToOnlinePE
    (
    LPPE lppe
    )
 {
    ULONG size;

    size = wstrlen(lppe->pe_unichars)*2+2;
    mymemmove(&(lppe->pe_unichars[1])
                ,&(lppe->pe_unichars[2])
                ,size-2*sizeof(USHORT));
    lppe->pe_length-= sizeof(USHORT);
    return(0);  //stop complaining about no return value
 }

int OnlineToOfflinePE
    (
    LPPE lppe
    )
 {
    ULONG size;

    size = wstrlen(lppe->pe_unichars)*2+2;
    // Must have space for one extra character
    mymemmove(&(lppe->pe_unichars[2])
                ,&(lppe->pe_unichars[1])
                ,size-sizeof(USHORT));

    lppe->pe_unichars[1] = UCHAR_OFFLINE;
    lppe->pe_length += sizeof(USHORT);
    return(0);  //stop complaining about no return value
 }

BOOL IsOfflineUni(
    USHORT *lpuName
    )
 {
    return(lpuName[2] == UCHAR_OFFLINE);
 }

int OfflineToOnlineUni(
    USHORT *lpuName,
    ULONG size)
 {
    if (!size)
     {
        size = wstrlen(lpuName)*2+2;
     }
    mymemmove(&(lpuName[2])
                ,&(lpuName[3])
                ,size-3*sizeof(short));
    return(0);  //stop complaining about no return value
 }

int OnlineToOfflineUni(
    USHORT *lpuName,
    ULONG size)
 {
    if (!size)
     {
        size = wstrlen(lpuName)*2+2;
     }

    // Must have space for one extra character
    mymemmove(&(lpuName[3])
                ,&(lpuName[2])
                ,size-2*sizeof(USHORT));

    lpuName[2] = UCHAR_OFFLINE;
    return(0);  //stop complaining about no return value
 }

LPVOID mymemmove(
    LPVOID    lpDst,
    LPVOID    lpSrc,
    ULONG size
    )
 {
    int i;

    if (!size)
        return (lpDst);

    // if lpDst does not fall within the source array, just do memcpy
    if (!(
             ( lpDst > lpSrc )
                && ( ((LPBYTE)lpDst) < ((LPBYTE)lpSrc)+size )    ))
     {
        memcpy(lpDst, lpSrc, size);
     }
    else
     {
        // do reverse copy
        for (i=size-1;i>=0;--i)
         {
            *((LPBYTE)lpDst+i) = *((LPBYTE)lpSrc+i);
         }
     }
    return (lpDst);
 }


#ifdef MAYBE
ULONG UlGetDefaultShadowStore(LPSTR lpDrive)
 {
    int indx;
    ULONG ulSize=0;
    ULONG uSectorsPerCluster, uBytesPerSector, uFreeClusters, uTotalClusters;
    if (indx = GetDriveIndex(lpDrive))
     {
        if (GetDiskFreeSpace(indx  , &uSectorsPerCluster
                                            , &uBytesPerSector
                                            , &uFreeClusters
                                            , &uTotalClusters) >= 0)
         {
            ulSize =  (uTotalClusters * uSectorsPerCluster * uBytesPerSector * 10)/100;
         }
     }
    return ulSize;
 }
#endif //MAYBE

#ifndef CSC_RECORDMANAGER_WINNT
int GetDriveIndex(LPSTR lpDrive)
 {
    int c;
    if (*(lpDrive+1)==':')
     {
        c = *lpDrive;
        c = _mytoupper(c);
        return (c - 'A'+1);
     }
    return (0);
}
#endif

BOOL
HasHeuristicTypeExtensions(
	USHORT	*lpwzFileName
	)
{
	ULONG lenName = wstrlen(lpwzFileName);
	int i;

	if (lenName > 4)
	{
		for (i=0; i<(sizeof(rgwzHeuristicExtensionTab)/sizeof(USHORT *)); ++i)
		{
			if (!wstrnicmp(&lpwzFileName[lenName-4], rgwzHeuristicExtensionTab[i], 4*sizeof(USHORT)))
			{
				return (TRUE);
			}
		}
	}
	return (FALSE);
}

VOID
IncrementFileTime(
    _FILETIME *lpft
    )
{
    DWORD dwTemp = lpft->dwLowDateTime;

    ++lpft->dwLowDateTime;

    // if it rolled over, there was a carry
    if (lpft->dwLowDateTime < dwTemp)
        lpft->dwHighDateTime++;

}

BOOL
CreateStringArrayFromDelimitedList(
    IN  LPWSTR  lpwzDelimitedList,
    IN  LPWSTR  lpwzDelimiters,
    IN  LPWSTR  *lprgwzStringArray,
    OUT LPDWORD lpdwCount
    )
{

    LPWSTR   lpStart, lpEnd, lpTmp;
    USHORT  c;
    BOOL    fRet = FALSE;

    *lpdwCount = 0;

    lpStart = lpwzDelimitedList;
    lpEnd = lpStart + wstrlen(lpwzDelimitedList);    // points to null

    // strip out the trailing spaces
    for(;(lpStart<lpEnd);--lpEnd) {
        c = *(lpEnd-1);

        if (c != L' ') {
            *lpEnd = 0;
            break;
        }
    }

    // bailout if this is an empty string
    if (lpStart == lpEnd) {
        fRet = TRUE;
        goto done;
    }


    for (lpTmp = lpStart;(lpTmp && (lpEnd > lpStart)); lpStart = lpTmp+1) {

        lpTmp = lpStart;

        c = *lpStart;

        if (c == L' ') {
             continue;
        }

        Assert(*lpStart != L' ');

        lpTmp = wstrpbrk(lpStart, lpwzDelimiters);

        if (lprgwzStringArray) {

            if (lpTmp) {
                *lpTmp = 0; // create a string out of it
            }

            // plug the start pointer into the array
            lprgwzStringArray[*lpdwCount] = lpStart;
        }

        ++*lpdwCount;

    }
    fRet = TRUE;
done:
    return (fRet);
}

BOOL IsValidName(LPSTR lpName)
{
    int len = strlen(lpName), ch, i=0;

    if (len != INODE_STRING_LENGTH)
    {
        return FALSE;
    }

    while (len--)
    {
        ++i;

        ch = *lpName++;
        if (!(((ch>='0') && (ch <='9'))||
            ((ch>='A') && (ch <='F'))||
            ((ch>='a') && (ch <='f'))))
        {
            return FALSE;
        }
    }

    if (i != INODE_STRING_LENGTH)
    {
        return FALSE;
    }

    return (TRUE);
}


BOOL
DeleteDirectoryFiles(
    LPCSTR  lpszDir
)
{
    _WIN32_FIND_DATAA sFind32;
    char buff[MAX_PATH+32];
    CSCHFILE hFind;
    int lenDir;
    BOOL fOK = TRUE;


    strcpy(buff, lpszDir);
    lenDir = strlen(buff);

    if (!lenDir)
    {
        return (FALSE);
    }

    if ((hFind = FindFirstFileLocal(buff, &sFind32)))
    {
        if (buff[lenDir-1] != '\\')
        {
            buff[lenDir++] ='\\';
            buff[lenDir]=0;
        }
        do
        {
            buff[lenDir] = 0;

            if (!(sFind32.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                && IsValidName(sFind32.cFileName))
            {
                strcat(buff, sFind32.cFileName);

                if(DeleteFileLocal(buff, ATTRIB_DEL_ANY) < 0)
                {
                    fOK = FALSE;
                    break;
                }
            }
        }
        while(FindNextFileLocal(hFind, &sFind32) >= 0);

        FindCloseLocal(hFind);
    }
    return (fOK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\record.mgr\sprintf.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sprintf.c

Abstract:

    Implements Windows friendly versions of sprintf and vsprintf

Author:



Revision History:

 	2/15/89     craigc	    Initial
 	4/6/93      ROBWI       For VxD

--*/

#include "precomp.h"
#pragma hdrstop

#pragma code_seg("PAGE")

#include <stdlib.h>
#include <ctype.h>
#include <string.h>

#ifndef CSC_RECORDMANAGER_WINNT
#include    "basedef.h"
#include    "vmm.h"
#pragma VxD_LOCKED_CODE_SEG
#endif //ifndef CSC_RECORDMANAGER_WINNT

#include "vxdwraps.h"

#define WSPRINTF_LIMIT 1024
#define DEBUG_BUFFER_SIZE 16376

extern int SP_PutNumber(char *, long, int, int, int);
extern void SP_Reverse(char * lp1, char * lp2);

DWORD DebugBufferLength = 0;
char * DebugBuffer;


#define out(c) if (--cchLimit) *lpOut++=(c); else goto errorout
#pragma intrinsic (memcmp, memcpy, memset, strcat, strcmp, strcpy, strlen)

/*
 *  GetFmtValue
 *
 *  reads a width or precision value from the format string
 */

char * SP_GetFmtValue(char * lpch, int * lpw)
{
    register int i=0;

    while (*lpch>='0' && *lpch<='9')
	{
	i *= 10;
	i += (int)(*lpch-'0');
	lpch++;
	}

    *lpw=i;

    /* return the address of the first non-digit character */
    return lpch;
}

/*
 *  vsprintf()
 *
 *  VxD version of vsprintf().  Does not support floating point or
 *  pointer types, and all strings are assumed to be NEAR.  Supports only
 *  the left alignment flag.
 *
 *  Takes pointers to an output buffer, where the string is built, a
 *  pointer to an input buffer, and a pointer to a list of parameters.
 *
 */

int vxd_vsprintf(char * lpOut, char * lpFmt, CONST VOID * lpParms)
{
    int left;
    char prefix;
    register int width;
    register int prec;
    char fillch;
    int size;
    int sign;
    int radix;
    int upper;
    int cchLimit=WSPRINTF_LIMIT;
    int cch;
    char * lpT;
    union {
	long l;
	ULONG ul;
	char sz[sizeof(long)];
	} val;
    int fWideChar;

    while (*lpFmt)
	{
	if (*lpFmt=='%')
	    {

	    /* read the flags.	These can be in any order */
	    left=0;
	    prefix=0;
        fWideChar = 0;
	    while (*++lpFmt)
		{
		if (*lpFmt=='-')
		    left++;
		else if (*lpFmt=='#')
		    prefix++;
		else
		    break;
		}

	    /* find fill character */
	    if (*lpFmt=='0')
		{
		fillch='0';
		lpFmt++;
		}
	    else
		fillch=' ';

	    /* read the width specification */
	    lpFmt=SP_GetFmtValue(lpFmt,&cch);
	    width=cch;

	    /* read the precision */
	    if (*lpFmt=='.')
		{
		lpFmt=SP_GetFmtValue(++lpFmt,&cch);
		prec=cch;
		}
	    else
		prec=-1;

	    /* get the operand size */
	    if (*lpFmt=='l')
		{
		size=1;
		lpFmt++;
		}
	    else
		{
		size=0;
		if (*lpFmt=='h')
		    lpFmt++;
		}

	    upper=0;
	    sign=0;
	    radix=10;
	    switch (*lpFmt)
		{
	    case 0:
		goto errorout;

	    case 'i':
	    case 'd':
		sign++;

	    case 'u':
		/* turn off prefix if decimal */
		prefix=0;
donumeric:
		/* special cases to act like MSC v5.10 */
		if (left || prec>=0)
		    fillch=' ';

		if (size)
		    val.l=*((long *)lpParms)++;
		else
		    if (sign)
		        val.l=*((long *)lpParms)++;
		    else
			val.ul=(ULONG)*((ULONG *)lpParms)++;

		if (sign && val.l<0L)
		    val.l=-val.l;
		else
		    sign=0;

		lpT=lpOut;

		/* blast the number backwards into the user buffer */
		cch=SP_PutNumber(lpOut,val.l,cchLimit,radix,upper);
		if (!(cchLimit-=cch))
		    goto errorout;

		lpOut+=cch;
		width-=cch;
		prec-=cch;
		if (prec>0)
		    width-=prec;

		/* fill to the field precision */
		while (prec-->0)
		    out('0');

		if (width>0 && !left)
		    {
		    /* if we're filling with spaces, put sign first */
		    if (fillch!='0')
			{
			if (sign)
			    {
			    sign=0;
			    out('-');
			    width--;
			    }

			if (prefix)
			    {
			    out(prefix);
			    out('0');
			    prefix=0;
			    }
			}

		    if (sign)
			width--;

		    /* fill to the field width */
		    while (width-->0)
			out(fillch);

		    /* still have a sign? */
		    if (sign)
			out('-');

		    if (prefix)
			{
			out(prefix);
			out('0');
			}

		    /* now reverse the string in place */
		    SP_Reverse(lpT,lpOut-1);
		    }
		else
		    {
		    /* add the sign character */
		    if (sign)
			{
			out('-');
			width--;
			}

		    if (prefix)
			{
			out(prefix);
			out('0');
			}

		    /* reverse the string in place */
		    SP_Reverse(lpT,lpOut-1);

		    /* pad to the right of the string in case left aligned */
		    while (width-->0)
			out(fillch);
		    }
		break;

	    case 'X':
		upper++;
	    case 'x':
		radix=16;
		if (prefix)
		    if (upper)
			prefix='X';
		    else
			prefix='x';
		goto donumeric;

	    case 'c':
		val.sz[0] = *((char *)lpParms);
		val.sz[1]=0;
		lpT=val.sz;
		cch = 1;  // Length is one character.
			  // Fix for Bug #1862 --01/10/91-- SANKAR --
		/* stack aligned to larger size */
		(BYTE *)lpParms += sizeof(DWORD);

		goto putstring;
        case 'w':
            fWideChar = 1;
	    case 's':
		lpT=*((char **)lpParms)++;
		cch=((!fWideChar)?strlen(lpT):wstrlen((USHORT *)lpT));
putstring:
		if (prec>=0 && cch>prec)
		    cch=prec;
		width -= cch;
		if (left)
		    {
		    while (cch--) {
			if (*lpT == 0x0A || *lpT == 0x0D) {
                                out(0x0D);
                                out(0x0A);
                        }
                        else
			    out(*lpT++);
                if (fWideChar)
                {
                    ++lpT;
                }
            }
		    while (width-->0)
			out(fillch);
		    }
		else
		    {
		    while (width-->0)
			out(fillch);
		    while (cch--) {
			if (*lpT == 0x0A || *lpT == 0x0D) {
                                out(0x0D);
                                out(0x0A);
                        }
                        else
		    	    out(*lpT++);
                    if (fWideChar)
                    {
                        ++lpT;
                    }
                }
		    }
		break;

	    default:
	    	/* This is an unsupported character that followed %; So,
		 * we must output that character as it is; This is the
		 * Documented behaviour; This is the Fix for Bug #15410.
		 * Please note that this could be due to a typo in the app as in the
		 * case of the sample app for Bug #13946 and in such cases,
		 * we might mis-interpret the parameters that follow and that
		 * could result in a GP Fault. But, this is clearly a bug in the app
		 * and we can't do anything about it. We will just RIP and let
		 * them know in such cases.
		 */
		if (*lpFmt == 0x0A || *lpFmt == 0x0D) {
                    out(0x0D);
                    out(0x0A);
                }
                else
	            out(*lpFmt);	/* Output the invalid char and continue */
		break;

		}			/* END OF SWITCH(*lpFmt) */
	    }		    /* END OF IF(%) */
	else
	  {
	    /* character not a '%', just do it */
	    if (*lpFmt == 0x0A || *lpFmt == 0x0D) {
                out(0x0D);
                out(0x0A);
            }
            else
	        out(*lpFmt);
	  }
		
	/* advance to next format string character */
	lpFmt++;
	}	    /* END OF OUTER WHILE LOOP */

errorout:
    *lpOut=0;

    return WSPRINTF_LIMIT-cchLimit;
}


int vxd_vprintf(char * Format, CONST VOID * lpParms)
{
    int length;

    if (DebugBufferLength+WSPRINTF_LIMIT < DEBUG_BUFFER_SIZE) {
        length =  vxd_vsprintf(DebugBuffer+DebugBufferLength, Format, lpParms);
        DebugBufferLength += length;
    }
    else
        length = 0;

    return length;

}

#ifdef CSC_RECORDMANAGER_WINNT
int
SP_PutNumber(
    LPSTR   lpb,
    long    n,
    int     limit,
    int     radix,
    int     strCase
    )
{
    unsigned long nT = (unsigned long)n, nRem=0;
    int i;

    for (i=0; i < limit; ++i)
    {

        nRem = nT%radix;

        nT = nT/radix;

        lpb[i] = (char)((nRem > 9)?((nRem-10) + ((strCase)?'A':'a')):(nRem+'0'));

        if (!nT)
        {
            ++i;    // bump up the count appropriately
            break;
        }
    }

    return (i);
}

void
SP_Reverse(
    LPSTR   lpFirst,
    LPSTR   lpLast
    )
{
    LPSTR   lpT = lpFirst;
    char ch;

    while (lpFirst < lpLast)
    {
        ch = *lpFirst;
        *lpFirst = *lpLast;
        *lpLast = ch;
        ++lpFirst; --lpLast;
    }
}
#endif //ifdef CSC_RECORDMANAGER_WINNT


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\record.mgr\utils.h ===
#define  IF32_LOCAL        	0x0001
#define  IF32_DIRECTORY    	0x0002
#define  IF32_LAST_ELEMENT	0x0004

#ifndef CSC_RECORDMANAGER_WINNT
#define _wtoupper(x)     ( ( ((x)>='a')&&((x)<='z') ) ? ((x)-'a'+'A'):(x))
#define _mytoupper(x)     ( ( ((x)>='a')&&((x)<='z') ) ? ((x)-'a'+'A'):(x))
#else
#define _wtoupper(x)    RtlUpcaseUnicodeChar(x)
#define _mytoupper(x)   RtlUpperChar(x)
#endif
// not to be used obsolete

#define MakeNullPPath(p_ppath)	p_ppath->pp_totalLength = 4; 	\
					p_ppath->pp_prefixLength = 4;				\
					p_ppath->pp_elements[0].pe_length = 0	

int PUBLIC GetServerPart(LPPE lppeServer, USHORT *lpBuff, int cBuff);
ULONG PUBLIC GetNextPathElement(LPPP lppp, ULONG indx,USHORT *lpBuff, ULONG cBuff);
VOID PUBLIC GetLeafPtr(LPPATH lpPath, USHORT *lpBuff, ULONG cBuff);
VOID PUBLIC BreakPath(LPPP lppp, ULONG indx, USHORT *pusSav);
VOID PUBLIC MendPath(LPPP lppp, ULONG indx, USHORT *pusSav);
int PUBLIC HexToA(ULONG ulHex, LPSTR lpBuff, int count);
ULONG PUBLIC AtoHex(LPSTR lpBuff, int count);
int wstrnicmp(const USHORT *, const USHORT *, ULONG);
//int strnicmp(const char *, const char *, ULONG);
ULONG strmcpy(LPSTR, LPSTR, ULONG);
int PpeToSvr(LPPE, LPSTR, int, ULONG);
ULONG wstrlen(USHORT *lpuStr);
int DosToWin32FileSize(ULONG, int *, int *);
int Win32ToDosFileSize(int, int, ULONG *);
int CompareTimes(_FILETIME, _FILETIME);
int CompareSize(long nHighDst, long nLowDst, long nHighSrc, long nLowSrc);
void InitFind32FromIoreq (PIOREQ, LPFIND32, ULONG uFlags);
void InitFind32Names(LPFIND32, USHORT * , USHORT *);
void InitIoreqFromFind32 (LPFIND32, PIOREQ);
void Find32ToSearchEntry(LPFIND32 lpFind32, srch_entry *pse);
void PUBLIC Find32AFromFind32(LPFIND32A, LPFIND32, int);
void PUBLIC Find32FromFind32A(LPFIND32, LPFIND32A, int);
void  AddPathElement(path_t, string_t, int);
void MakePPath(path_t, LPBYTE);
void MakePPathW(path_t, USHORT *);
void DeleteLastElement(path_t);
int ResNameCmp(LPPE, LPPE);
int  Conv83ToFcb(LPSTR lp83Name, LPSTR lpFcbName);
int  Conv83UniToFcbUni(USHORT *, USHORT *);
void  FileRootInfo(LPFIND32);
BOOL FHasWildcard(USHORT *lpuName, int cMax);
LPSTR mystrpbrk(LPSTR, LPSTR);
LPWSTR
wstrpbrk(
    LPWSTR lpSrc,
    LPWSTR lpDelim
    );

int OfflineToOnlinePath(path_t ppath);
int OnlineToOfflinePath(path_t ppath);

BOOL IsOfflinePE(LPPE lppp);
int OnlineToOfflinePE(LPPE lppp);
int OfflineToOnlinePE(LPPE lppp);

BOOL IsOfflineUni(USHORT *lpuName);
int OnlineToOfflineUni(USHORT *lpuName, ULONG size);
int OfflineToOnlineUni(USHORT *lpuName, ULONG size);

LPVOID mymemmove(LPVOID lpDst, LPVOID lpSrc, ULONG size);
int GetDriveIndex(LPSTR lpDrive);

//prototypes added to remove NT compile warn/errors

void FillRootInfo(
   LPFIND32 lpFind32
   );

int CompareTimesAtDosTimePrecision( _FILETIME ftDst,
   _FILETIME ftSrc
   );


int ReadInitValues();

BOOL
HasHeuristicTypeExtensions(
	USHORT	*lpwzFileName
	);

VOID
IncrementFileTime(
    _FILETIME *lpft
    );

int
IncrementTime(
    LPFILETIME  lpFt,
    int    secs
    );


#ifndef CSC_RECORDMANAGER_WINNT
int mystrnicmp(
    const char *pStr1,
    const char *pStr2,
    unsigned count
    );
#else
_CRTIMP int __cdecl mystrnicmp(
    const char *pStr1,
    const char *pStr2,
    size_t count
    );
#endif //ifndef CSC_RECORDMANAGER_WINNT

BOOL
CreateStringArrayFromDelimitedList(
    IN  LPWSTR  lpwzDelimitedList,
    IN  LPWSTR  lpwzDelimiters,
    IN  LPWSTR  *lprgwzStringArray,
    OUT LPDWORD lpdwCount
    );
    
BOOL
DeleteDirectoryFiles(
    LPCSTR  lpszDir
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\record.mgr\bmreclib\oslayeru.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

     OsLayerU.c

Abstract:

     Implementation of the OsLayer that interfaces to ARC so that setup loader and
     ntldr can retrieve files from the local CSC if available.

Author:

     Colin Watson      [ColinW]        11-05-1997

Revision History:


--*/

#pragma hdrstop
#include <ntos.h>
#include <arccodes.h>
#include <bldr.h>

#define  PUBLIC
typedef int             BOOL;
typedef void            *LPVOID;
typedef unsigned long   DWORD;
typedef struct  _FILETIME{
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
}   FILETIME;


typedef  ULONG  HSERVER;
typedef  ULONG  HSHADOW;
typedef  ULONG  HSHARE;

#include <oslayeru.h>

/********************** global data *****************************************/


//
//  In an attempt to avoid opening the disk device all the time we share the handle
//  with netboot.c if there is one.
//

extern ULONG NetBootDiskId;

DWORD    dwDebugLogVector;
AssertData;
AssertError;
/********************** function prototypes *********************************/

/****************************************************************************/

/************************ File I/O ******************************************/


CSCHFILE
R0OpenFileEx(
    USHORT  usOpenFlags,
    UCHAR   bAction,
    ULONG   ulAttr,
    LPSTR   lpPath,
    BOOL    fInstrument
    )
{
    ULONG hf;
    DWORD status;

    ASSERT( (usOpenFlags & 0xf) == ACCESS_READWRITE);

    if (!NetBootDiskId) {
        return (CSCHFILE)NULL;
    }

    //
    // Don't ever create the database or allow it to be modified since this would mean
    // the OS would not know to repin all the files.
    //

    status = BlOpen(NetBootDiskId, lpPath, ArcOpenReadOnly, &hf);

    if (status != ESUCCESS) {
        return (CSCHFILE)NULL;
    }
    return (CSCHFILE)hf;
}

CSCHFILE
CreateFileLocal(
    LPSTR lpFile
    )
{
    return R0OpenFileEx( ACCESS_READWRITE, ACTION_CREATEALWAYS, FILE_ATTRIBUTE_NORMAL, lpFile, FALSE);
}

CSCHFILE
OpenFileLocal(
    LPSTR lpFile
    )
{
    return R0OpenFileEx( ACCESS_READWRITE, ACTION_OPENEXISTING, FILE_ATTRIBUTE_NORMAL, lpFile, FALSE);
}

ULONG
CloseFileLocal(
    CSCHFILE hf
    )
{
    BlClose((ULONG)((ULONG_PTR)hf));
    return (1);
}


long
ReadFileLocal(
    CSCHFILE hf,
    unsigned long lSeek,
    LPVOID    lpBuff,
    long    cLength
    )
{
    ULONG dwBytesRead;
    ARC_STATUS status;

    LARGE_INTEGER seekValue;

    seekValue.QuadPart = lSeek;

    status = ArcSeek((ULONG)((ULONG_PTR)hf), &seekValue, SeekAbsolute);
    if (status==ESUCCESS) {
        status = ArcRead((ULONG)((ULONG_PTR)hf),
                         (VOID * POINTER_32)lpBuff,
                         cLength,
                         (ULONG * POINTER_32)&dwBytesRead);
        if (status==ESUCCESS) {
            return dwBytesRead;
        }
    }
    return (-1);
}

long
ReadFileLocalEx(
    CSCHFILE      hf,
    unsigned    long lSeek,
    LPVOID      lpBuff,
    long         cLength,
    BOOL        fInstrument
    )
{
    return ReadFileLocal(hf,lSeek,lpBuff,cLength);
}

long
ReadFileLocalEx2(
    CSCHFILE      hf,
    unsigned    long lSeek,
    LPVOID      lpBuff,
    long         cLength,
    ULONG       flags
    )
{
    return ReadFileLocalEx(hf, lSeek, lpBuff, cLength, FALSE);
}

long
WriteFileLocal(
    CSCHFILE hf,
    unsigned long lSeek,
    LPVOID    lpBuff,
    long    cLength
    )
{
    return (-1);
}

long WriteFileLocalEx(
    CSCHFILE hf,
    unsigned long lSeek,
    LPVOID    lpBuff,
    long    cLength,
    BOOL    fInstrument
    )
{
    fInstrument;
    return(WriteFileLocal(hf, lSeek, lpBuff, cLength));
}

long
WriteFileLocalEx2(
    CSCHFILE      hf,
    unsigned    long lSeek,
    LPVOID      lpBuff,
    long         cLength,
    ULONG       flags
    )
{
    return WriteFileLocalEx(hf, lSeek, lpBuff, cLength, FALSE);
}

CSCHFILE
OpenFileLocalEx(
    LPSTR lpPath,
    BOOL fInstrument
    )
{
    return(R0OpenFileEx(ACCESS_READWRITE, ACTION_OPENEXISTING, FILE_ATTRIBUTE_NORMAL, lpPath, fInstrument));
}


int
FileExists(
    LPSTR lpPath
    )
{
    CSCHFILE hf;
    hf = R0OpenFileEx(ACCESS_READWRITE, ACTION_OPENEXISTING, FILE_ATTRIBUTE_NORMAL, lpPath, FALSE);
    if ((ULONG)((ULONG_PTR)hf) != -1) {
        BlClose((ULONG)((ULONG_PTR)hf));
        return TRUE;
    }
    return FALSE;
}


int
GetFileSizeLocal
    (
    CSCHFILE handle,
    PULONG lpuSize
    )
{
    return (-1);
}

int
RenameFileLocal(
    LPSTR lpFrom,
    LPSTR lpTo
    )
{
    return -1;
}

int
DeleteFileLocal
    (
    LPSTR lpName,
    USHORT usAttrib
    )
{
    return(-1);
}

int
GetDiskFreeSpaceLocal(
    int indx,
    ULONG *lpuSectorsPerCluster,
    ULONG *lpuBytesPerSector,
    ULONG *lpuFreeClusters,
    ULONG *lpuTotalClusters
    )
{
    return (-1);
}

int
FileLockLocal(
    CSCHFILE hf,
    ULONG offsetLock,
    ULONG lengthLock,
    ULONG idProcess,
    BOOL  fLock
    )
{
    return (-1);
}

/*************************** Utility Functions ******************************/

LPVOID
AllocMem(
    ULONG uSize
    )
{
    return BlAllocateHeap(uSize);

}

VOID
FreeMem(
    LPVOID lp
    )
{
}

LPVOID
AllocMemPaged(
    ULONG uSize
    )
{
    return BlAllocateHeap(uSize);
}

VOID FreeMemPaged(
    LPVOID lp
    )
{
}

int GetAttributesLocal(
    LPSTR lpName,
    ULONG *lpuAttr
    )
{
    return -1;
}

int GetAttributesLocalEx
    (
    LPSTR   lpPath,
    BOOL    fFile,
    ULONG   *lpuAttributes
    )
{
    return (GetAttributesLocal(lpPath, lpuAttributes));
}

int
SetAttributesLocal (
    LPSTR lpName,
    ULONG uAttr
    )
{
    return -1;
}

CSCHFILE R0OpenFile (
    USHORT usOpenFlags,
    UCHAR bAction,
    LPSTR lpPath)
{
    return (R0OpenFileEx(usOpenFlags, bAction, FILE_ATTRIBUTE_NORMAL, lpPath, FALSE));
}

int CreateDirectoryLocal(
    LPSTR   lpszPath
    )
{
    return -1;
}
int wstrnicmp(
    const USHORT *pStr1,
    const USHORT *pStr2,
    ULONG count
)
{
    USHORT c1, c2;
    int iRet;
    ULONG i=0;

    for(;;)
     {
        c1 = *pStr1++;
        c2 = *pStr2++;
        c1 = towupper(c1);
        c2 = towupper(c2);
        if (c1!=c2)
            break;
        if (!c1)
            break;
        i+=2;
        if (i >= count)
            break;
     }
    iRet = ((c1 > c2)?1:((c1==c2)?0:-1));
    return iRet;
}

ULONG
GetTimeInSecondsSince1970(
    VOID
    )
{
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\record.mgr\bmreclib\precomp.h ===
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include "shdsys.h"
#include "assert.h"
#include "shdcom.h"
#include "oslayeru.h"
#include "cscsec.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\record.mgr\daytona\precomp.h ===
#include "ntcsc.h"

//this cannot be placed in ntcsc.h because it redefines dbgprint
#include "assert.h"

//sigh..........
#if DBG
#undef DbgPrint
#undef Assert
#undef AssertSz
#define Assert(f)  ASSERT(f)
#define AssertSz(f, sz) ASSERTMSG(sz,f)
#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\record.mgr\bmreclib\osutils.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

     Utils.c

Abstract:

     none.

Author:

     Shishir Pardikar      [Shishirp]        01-jan-1995

--*/

#include "precomp.h"
#pragma hdrstop

#define  SIGN_BIT 0x80000000
#define  UCHAR_OFFLINE  ((USHORT)'_')
#define  HIGH_ONE_SEC    0x98
#define  LOW_ONE_SEC     0x9680

#pragma intrinsic (memcmp, memcpy, memset, strcat, strcmp, strcpy, strlen)
#define cBackSlash    '\\'
#define cNull          0

AssertData
AssertError

int HexToA(
     ULONG ulHex,
     LPSTR lpName,
     int count
     )
{
    int i;
    LPSTR lp = lpName+count-1;
    UCHAR uch;

    for (i=0; i<count; ++i)
     {
         uch = (UCHAR)(ulHex & 0xf) + '0';
         if (uch > '9')
               uch += 7;     // A becomes '0' + A + 7 which is 'A'
         *lp = uch;
         --lp;
         ulHex >>= 4;
     }
    *(lpName+count) = cNull;
    return 0;
}


ULONG AtoHex(
     LPSTR lpStr,
     int count
)
{
     int i;
     LPSTR lp = lpStr;
     UCHAR uch;
     ULONG ulHex = 0L;

     for (i=0; i<count; ++i)
      {
          uch = *lp;
          if (uch>= '0' && uch <= '9')
                ulHex += (uch - '0');
          else if (uch >= 'A' && uch <= 'F')
                ulHex += (uch - '0' - 7);
          else
                break;
          ++lp;
          ulHex <<= 4;
      }
     return ulHex;
 }


ULONG strmcpy( LPSTR lpDst,
        LPSTR lpSrc,
     ULONG cTchar
     )
 {
     ULONG i;

     if (!cTchar)
          return 0;
     for(i=cTchar;i;--i)
          if (!(*lpDst++ = *lpSrc++))
                                                     break;
     lpDst[cTchar-i] ='\0';

     return(cTchar-i);
 }

ULONG wstrlen(
     USHORT *lpuStr
     )
 {
     ULONG i;

     for (i=0; *lpuStr; ++lpuStr, ++i);
     return (i);
 }

int CompareSize(
     long nHighDst,
     long nLowDst,
     long nHighSrc,
     long nLowSrc
     )
 {
     int iRet = 0;

     if (nHighDst > nHighSrc)
          iRet = 1;
     else if (nHighDst == nHighSrc)
      {
          if (nLowDst > nLowSrc)
                iRet = 1;
          else if (nLowDst == nLowSrc)
                iRet = 0;
          else
                iRet = -1;
      }
     else
          iRet = -1;
     return (iRet);
 }


LPSTR mystrpbrk(
     LPSTR lpSrc,
     LPSTR lpDelim
     )
{
    char c, c1;
    LPSTR lpSav;
    BOOL fBegin = FALSE;

 for(;c = *lpSrc; ++lpSrc)
     {
         // skip leading blanks
         if (!fBegin)
           {
               if (c==' ')
                    continue;
               else
                    fBegin = TRUE;
           }

         lpSav = lpDelim;
         while (c1 = *lpDelim++)
           {
               if (c==c1)
                    return (lpSrc);
           }
         lpDelim = lpSav;
     }
    return (NULL);
}

LPVOID mymemmove(
     LPVOID     lpDst,
     LPVOID     lpSrc,
     ULONG size
     )
{
    int i;

    if (!size)
         return (lpDst);

    // if lpDst does not fall within the source array, just do memcpy
    if (!(
                ( lpDst > lpSrc )
                    && ( ((LPBYTE)lpDst) < ((LPBYTE)lpSrc)+size )     ))
     {
         memcpy(lpDst, lpSrc, size);
     }
    else
     {
         // do reverse copy
         for (i=size-1;i>=0;--i)
           {
               *((LPBYTE)lpDst+i) = *((LPBYTE)lpSrc+i);
           }
     }
    return (lpDst);
}


VOID
IncrementFileTime(
     FILETIME *lpft
    )
{
    DWORD dwTemp = lpft->dwLowDateTime;

    ++lpft->dwLowDateTime;

    // if it rolled over, there was a carry
    if (lpft->dwLowDateTime < dwTemp)
         lpft->dwHighDateTime++;

}
#ifdef DBG
VOID AssertFn(PCHAR lpMsg, PCHAR lpFile, ULONG uLine)
{

    DbgPrint("Line %u file %s", uLine, lpFile);
    DbgBreakPoint();
}
#endif
int CompareTimes(
    FILETIME ftDst,
    FILETIME ftSrc
   )
{
    int iRet = 0;

    if (ftDst.dwHighDateTime > ftSrc.dwHighDateTime)
        iRet = 1;
    else if (ftDst.dwHighDateTime == ftSrc.dwHighDateTime)
    {
        if (ftDst.dwLowDateTime > ftSrc.dwLowDateTime)
            iRet = 1;
        else if (ftDst.dwLowDateTime == ftSrc.dwLowDateTime)
            iRet = 0;
        else
            iRet = -1;
    }
    else
        iRet = -1;
    return (iRet);
}


int DosToWin32FileSize( unsigned long uDosFileSize,
   int *lpnFileSizeHigh,
   int *lpnFileSizeLow
   )
   {
   int iRet;

   if (uDosFileSize & SIGN_BIT)
      {
      *lpnFileSizeHigh = 1;
      *lpnFileSizeLow = uDosFileSize & SIGN_BIT;
      iRet = 1;
      }
   else
      {
      *lpnFileSizeHigh = 0;
      *lpnFileSizeLow = uDosFileSize;
      iRet = 0;
      }
   return (iRet);
   }

int Win32ToDosFileSize( int nFileSizeHigh,
   int nFileSizeLow,
   unsigned long *lpuDosFileSize
   )
   {
   int iRet;
   Assert(nFileSizeHigh <= 1);
   *lpuDosFileSize = nFileSizeLow;
   if (nFileSizeHigh == 1)
      {
      *lpuDosFileSize += SIGN_BIT;
      iRet = 1;
      }
   else
      iRet = 0;
   return (iRet);
   }

int
PUBLIC
mystrnicmp(
    const char *pStr1,
    const char *pStr2,
    unsigned count
    )
{
    char c1, c2;
    int iRet;
    unsigned i=0;

    for(;;)
    {
        c1 = *pStr1++;
        c2 = *pStr2++;
        c1 = _toupper(c1);
        c2 = _toupper(c2);
        if (c1!=c2)
            break;
        if (!c1)
            break;
        if (++i >= count)
            break;
    }
    iRet = ((c1 > c2)?1:((c1==c2)?0:-1));
    return iRet;
}

int ShadowLog(
    LPSTR lpFmt,
    ...
    )
{
    return (0);
}

int TerminateShadowLog(VOID)
{
    return 0;
}

BOOL
IterateOnUNCPathElements(
    USHORT  *lpuPath,
    PATHPROC lpfn,
    LPVOID  lpCookie
    )
/*++

Routine Description:

    This routine takes a unicode UNC path and iterates over each path element, calling the
    callback function. Thus for a path \\server\share\dir1\dir2\file1.txt, the function makes
    the following calls to the lpfn callback function

    (lpfn)(\\server\share, \\server\share, lpCookie)
    (lpfn)(\\server\share\dir1, dir1, lpCookie)
    (lpfn)(\\server\share\dir1\dir2, dir2, lpCookie)
    (lpfn)(\\server\share\dir1\dir2\file1, file1, lpCookie)

Arguments:

    lpuPath     NULL terminated unicode string (NOT NT style, just a plain unicode string)

    lpfn        callback function. If the function returns TRUE on a callback, the iteration
                proceeds, else it terminates

    lpCookie    context passed back on each callback

Returns:

    return TRUE if the entire iteration went through, FALSE if some error occurred or the callback
    function terminated the iteration

Notes:


--*/
{
    int cnt, cntSlashes=0, cbSize;
    USHORT  *lpuT, *lpuLastElement = NULL, *lpuCopy = NULL;
    BOOL    fRet = FALSE;

//    DEBUG_PRINT(("InterateOnUNCPathElements:Path on entry =%ws\r\n", lpuPath));

    if (!lpuPath || ((cnt = wstrlen(lpuPath)) <= 3))
    {
        return FALSE;
    }

    // check for the first two backslashes
    if (!(*lpuPath == (USHORT)'\\') && (*(lpuPath+1) == (USHORT)'\\'))
    {
        return FALSE;
    }

    // ensure that the server field is not NULL
    if (*(lpuPath+2) == (USHORT)'\\')
    {
        return FALSE;
    }

    cbSize = (wstrlen(lpuPath)+1) * sizeof(USHORT);

    lpuCopy = (USHORT *)AllocMem(cbSize);

    if (!lpuCopy)
    {
        return FALSE;
    }

    memcpy(lpuCopy, lpuPath, cbSize);

    cntSlashes = 2;

    lpuLastElement = lpuCopy;

    for (lpuT= lpuCopy+2;; ++lpuT)
    {
        if (*lpuT == (USHORT)'\\')
        {
            BOOL fContinue;

            ++cntSlashes;

            if (cntSlashes == 3)
            {
                if (lpuT == (lpuCopy+2))
                {
                    goto bailout;
                }

                continue;
            }

            *lpuT = 0;

            fContinue = (lpfn)(lpuCopy, lpuLastElement, lpCookie);

            *lpuT = (USHORT)'\\';

            if (!fContinue)
            {
                goto bailout;
            }

            lpuLastElement = (lpuT+1);
        }
        else if (!*lpuT)
        {
            fRet = (lpfn)(lpuCopy, lpuLastElement, lpCookie);
            break;
        }
    }

bailout:

    if (lpuCopy)
    {
        FreeMem(lpuCopy);
    }
    return (fRet);
}

BOOL
IsPathUNC(
    USHORT      *lpuPath,
    int         cntMaxChars
    )
{
    USHORT *lpuT;
    int i, cntSlash=0;
    BOOL    fRet = FALSE;

    for(lpuT = lpuPath, i=0; (i < cntMaxChars) && *lpuT; lpuT++, ++i)
    {
        if (cntSlash <= 1)
        {
            // look for the first two backslashes
            if (*lpuT != (USHORT)'\\')
            {
                break;
            }

            ++cntSlash;
        }
        else if (cntSlash == 2)
        {
            // look for the 3rd one
            if (*lpuT == (USHORT)'\\')
            {
                if ((DWORD)(lpuT - lpuPath) < 3)
                {
                    // NULL server field
                    break;
                }
                else
                {
                    ++cntSlash;
                }
            }
        }
        else    // all three slashes accounted for
        {
            Assert(cntSlash == 3);

            // if a non-slash character, then this path is OK
            fRet = (*lpuT != (USHORT)'\\');
            break;
        }
    }
    return (fRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\record.mgr\daytona\ifsmgr.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ifsmgr.c

Abstract:

    this file contains routine to simulate the ifsmgr environment for the purposes
    of using the same record manager interface on nt and win95.

Author:

    Joe Linn             [JoeLinn]       31-jan-97

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#pragma code_seg("PAGE")

unsigned int  _cdecl UniToBCS(
                    unsigned char   *pStr,
                    string_t        pUni,
                    unsigned int    length,
                    unsigned int    maxLength,
                    unsigned int    charSet)
/*++

Routine Description:

    this routine converts from unicode to either ansi or oem depending on the
    charSet flag. the full description may be found in the ifsmanager sources
    or the ifsmanager docs.

    here's what it says in summary

        PROTO
            unsigned int UniToBCS (unsigned char  *pStr,
                                   unsigned short *pUni,
                                   unsigned int length,
                                   unsigned int maxLength,
                                   int charSet);

        ENTRY   pStr    Flat ptr to an Windows ANSI or OEM output string.

                pUni    Flat ptr to a UNICODE input string.

                length  Number of bytes in the UNICODE input string.

                maxLength - longest string that can be put into pStr
                             (not counting the nul terminator)

                charSet Ordinal specifying character set of input string.
                        0 == Windows ANSI
                        1 == OEM

    BUT!!!!!!!!!!!!!!!

    the trick is that the ifsmgr routine will do an early out if it encounters
    a null!!!! the bottom line is that i have to hunt up the null treating the
    length passed as the maxlength in the UNICODE_STRING sense. additionally,
    this is temporary....soon, we should stop translating back and forth.

--*/
{
    NTSTATUS Status;
    ULONG ReturnedLength;
    ULONG UnicodeLength;
    PWCHAR p;

    // look for a null for early out....sigh...
    for (p=pUni,UnicodeLength=0;;) {
        if (UnicodeLength==length) {
            break;
        }
        if (*p ==0) {
            break;
        }
        UnicodeLength+=sizeof(WCHAR);
        p++;
    }

    if (charSet == 0) {
        Status = RtlUnicodeToMultiByteN(
                        pStr,            //OUT PCH OemString,
                        maxLength,       //IN ULONG MaxBytesInOemString,
                        &ReturnedLength, //OUT PULONG BytesInOemString OPTIONAL,
                        pUni,            //IN PWCH UnicodeString,
                        UnicodeLength    //IN ULONG BytesInUnicodeString
                        );

    } else {
        Status = RtlUnicodeToOemN(
                        pStr,            //OUT PCH OemString,
                        maxLength,       //IN ULONG MaxBytesInOemString,
                        &ReturnedLength, //OUT PULONG BytesInOemString OPTIONAL,
                        pUni,            //IN PWCH UnicodeString,
                        UnicodeLength    //IN ULONG BytesInUnicodeString
                        );

    }

    return(ReturnedLength);

}

unsigned int UniToBCSPath(
                    unsigned char   *pStr,
                    PathElement     *pPth,
                    unsigned int    maxLength,
                    int             charSet);


_QWORD qwUniToBCS(
                    unsigned char   *pStr,
                    string_t        pUni,
                    unsigned int    length,
                    unsigned int    maxLength,
                    unsigned int    charSet);


_QWORD qwUniToBCSPath(
                    unsigned char   *pStr,
                    PathElement     *pPth,
                    unsigned int    maxLength,
                    int             charSet);






unsigned int  _cdecl BCSToUni(
                    string_t        pUni,
                    unsigned char   *pStr,
                    unsigned int    length,
                    int             charSet)
/*++

Routine Description:

    this routine converts to unicode from either ansi or oem depending on the
    charSet flag. the full description may be found in the ifsmanager sources
    or the ifsmanager docs

--*/
{
    ULONG ReturnedLength;

    if (charSet == 0) {
        RtlMultiByteToUnicodeN(
            pUni,            //OUT PWCH UnicodeString,
            0xffff,          //IN ULONG MaxBytesInUnicodeString,
            &ReturnedLength, //OUT PULONG BytesInUnicodeString OPTIONAL,
            pStr,            //IN PCH OemString,
            length           //IN ULONG BytesInOemString
            );
    } else {
        RtlOemToUnicodeN(
            pUni,            //OUT PWCH UnicodeString,
            0xffff,          //IN ULONG MaxBytesInUnicodeString,
            &ReturnedLength, //OUT PULONG BytesInUnicodeString OPTIONAL,
            pStr,            //IN PCH OemString,
            length           //IN ULONG BytesInOemString
            );
    }
    return(ReturnedLength);
}



unsigned int UniToUpper(
                    string_t        pUniUp,
                    string_t        pUni,
                    unsigned int    length)
/*++

Routine Description:

    this routine upcases from unicode to unicode. the full description
    may be found in the ifsmanager sources or the ifsmanager docs

--*/
{
    UNICODE_STRING u,uUp;
    u.Length = uUp.Length = (USHORT)length;
    u.MaximumLength = uUp.MaximumLength = (USHORT)length;
    u.Buffer = pUni;
    uUp.Buffer = pUniUp;

    RtlUpcaseUnicodeString(
        &uUp, //PUNICODE_STRING DestinationString,
        &u,   //PUNICODE_STRING SourceString,
        FALSE //BOOLEAN AllocateDestinationString
        );

    return(uUp.Length);
}




unsigned int BCSToBCS (unsigned char *pDst,
                       unsigned char *pSrc,
                       unsigned int  dstCharSet,
                       unsigned int  srcCharSet,
                       unsigned int  maxLen);


unsigned int BCSToBCSUpper (unsigned char *pDst,
                       unsigned char *pSrc,
                       unsigned int  dstCharSet,
                       unsigned int  srcCharSet,
                       unsigned int  maxLen);

//------------------------------------------------------------------------------
// T I M E
//
#include "smbtypes.h"
#include "smbgtpt.h"

/** Time format conversion routines
 *
 *  These routines will convert from time/date information between
 * the various formats used and required by IFSMgr and FSDs.
 */

_FILETIME  _cdecl IFSMgr_DosToWin32Time(dos_time dt)
/*++

Routine Description:

    This routine converts from the old dos packed time format to the
    normal win32 time. it was just lifted from the smbminirdr.

Arguments:



Return Value:



--*/


{
    TIME_FIELDS TimeFields;
    LARGE_INTEGER OutputTime;
    _FILETIME ret;
    SMB_TIME Time;
    SMB_DATE Date;

    Time.Ushort = dt.dt_time;
    Date.Ushort = dt.dt_date;

    OutputTime.LowPart = OutputTime.HighPart = 0;
    if (SmbIsTimeZero(&Date) && SmbIsTimeZero(&Time)) {
        NOTHING;
    } else {
        TimeFields.Year = Date.Struct.Year + (USHORT )1980;
        TimeFields.Month = Date.Struct.Month;
        TimeFields.Day = Date.Struct.Day;

        TimeFields.Hour = Time.Struct.Hours;
        TimeFields.Minute = Time.Struct.Minutes;
        TimeFields.Second = Time.Struct.TwoSeconds*(USHORT )2;
        TimeFields.Milliseconds = 0;

        //
        //  Make sure that the times specified in the SMB are reasonable
        //  before converting them.
        //

        if (TimeFields.Year < 1601) {
            TimeFields.Year = 1601;
        }

        if (TimeFields.Month > 12) {
            TimeFields.Month = 12;
        }

        if (TimeFields.Hour >= 24) {
            TimeFields.Hour = 23;
        }
        if (TimeFields.Minute >= 60) {
            TimeFields.Minute = 59;
        }
        if (TimeFields.Second >= 60) {
            TimeFields.Second = 59;

        }

        if (!RtlTimeFieldsToTime(&TimeFields, &OutputTime)) {
            OutputTime.HighPart = 0;
            OutputTime.LowPart = 0;
        } else {
            ExLocalTimeToSystemTime(&OutputTime, &OutputTime);
        }

    }

    ret.dwHighDateTime = OutputTime.HighPart;
    ret.dwLowDateTime  = OutputTime.LowPart;
    return(ret); //CODE.IMPROVEMENT put in some asserts and don't do this copy

}



dos_time IFSMgr_Win32ToDosTime(_FILETIME ft)
/*++

Routine Description:

    This routine converts from the normal win32 time to the old dos packed
    time format. it was just lifted from the smbminirdr.

Arguments:



Return Value:



--*/

{
    TIME_FIELDS TimeFields;
    LARGE_INTEGER InputTime;
    SMB_TIME Time;
    SMB_DATE Date;
    dos_time ret;

    PAGED_CODE();

    InputTime.HighPart = ft.dwHighDateTime;
    InputTime.LowPart  = ft.dwLowDateTime;

    if (InputTime.LowPart == 0 && InputTime.HighPart == 0) {
        Time.Ushort = Date.Ushort = 0;
    } else {
        LARGE_INTEGER LocalTime;

        ExSystemTimeToLocalTime(&InputTime, &LocalTime);

        RtlTimeToTimeFields(&LocalTime, &TimeFields);

        //if (TimeFields.Year < 1980) {
        //    return FALSE;
        //}

        Date.Struct.Year = (USHORT )(TimeFields.Year - 1980);
        Date.Struct.Month = TimeFields.Month;
        Date.Struct.Day = TimeFields.Day;

        Time.Struct.Hours = TimeFields.Hour;
        Time.Struct.Minutes = TimeFields.Minute;

        //
        //  When converting from a higher granularity time to a lesser
        //  granularity time (seconds to 2 seconds), always round up
        //  the time, don't round down.
        //

        Time.Struct.TwoSeconds = (TimeFields.Second + (USHORT)1) / (USHORT )2;

    }

    ret.dt_time = Time.Ushort;
    ret.dt_date = Date.Ushort;
    return ret;
}


dos_time IFSMgr_NetToDosTime(unsigned long time);

unsigned long IFSMgr_DosToNetTime(dos_time dt);

unsigned long IFSMgr_Win32ToNetTime(_FILETIME ft);

ULONG
IFSMgr_Get_NetTime()
{
    LARGE_INTEGER CurrentTime;
    ULONG SecondsSince1970;
    KeQuerySystemTime(&CurrentTime);
    RtlTimeToSecondsSince1970(&CurrentTime,&SecondsSince1970);
    return(SecondsSince1970);
}

_FILETIME
IFSMgr_NetToWin32Time(
    ULONG   time
    )
{
    LARGE_INTEGER sTime;

    RtlSecondsSince1970ToTime(time, &sTime);

    return (*(_FILETIME *)&sTime);
}

//----------------------------------------------------------
//----------------------------------------------------------
//----------------------------------------------------------
//----------------------------------------------------------
DEBUG_ONLY_DECL(ULONG IFSMgr_MetaMatch_DbgPFlag = 0);
unsigned int IFSMgr_MetaMatch(
                    string_t        pUniPat,
                    string_t        pUni,
                    int MatchSem)
/*++

Routine Description:

    this routine checks to see if the unicode pattern matches the
    passed unicode string. the MatchSem parameter is currently unused;
    it is supposed to represent doing a dos-fcb style match. please refer
    to the ifsmgr sources if necessary.

    the full description may be found in the ifsmanager sources
    or the ifsmanager docs

--*/
{
    UNICODE_STRING Pattern,Name;
    unsigned int Result;

    RtlInitUnicodeString(&Pattern,pUniPat);
    RtlInitUnicodeString(&Name,pUni);

    try
    {
        Result =  FsRtlIsNameInExpression (
                        &Pattern, //IN PUNICODE_STRING Expression,
                        &Name,    //IN PUNICODE_STRING Name,
                        TRUE,     //IN BOOLEAN IgnoreCase,
                        NULL      //IN PWCH UpcaseTable
                        );
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        Result = 0;
    }
    
#ifdef RX_PRIVATE_BUILD
    if (IFSMgr_MetaMatch_DbgPFlag) {
        DbgPrint("MMnt <%wZ> in <%wZ> returning %08lx\n", &Name, &Pattern, Result);
    }
#endif //ifdef RX_PRIVATE_BUILD

    return(Result);

}

// i moved these here from win95's hook.c
/*************************** Agent Related ********************************/
// Two globals vpFileInfoAgent and vpFileInfoDuped are used to deal with the agent
// The access to these globals is serialized by the hookcrit section
// Hookcrit section is entered, in VfnOpen, HfnClose, IoctlCopyChunk

// Info on file opened by agent
PFILEINFO vpFileInfoAgent = NULL;   // handle of file opened by agent
PFILEINFO vpFileInfoDuped = NULL;   // If duped, this is set

int SetInUseByAgent( PFILEINFO   pFileInfo, BOOL fDuped
   )
   {
   PFDB pFdb = pFileInfo->pFdb;

   Assert(vpFileInfoAgent==NULL);
   vpFileInfoAgent = pFileInfo;
   if (fDuped)
      {
      vpFileInfoDuped = pFileInfo;
      }
   else
      {
      vpFileInfoDuped = NULL;
      }
   return(0);  //stop complaining about no return value
   }

int ResetInUseByAgent( PFILEINFO   pFileInfo
   )
   {
   Assert(pFileInfo==vpFileInfoAgent);
   vpFileInfoAgent = NULL;
   vpFileInfoDuped = NULL;
   return(0);  //stop complaining about no return value
   }


PFILEINFO   PFileInfoAgent( VOID)
   {
   return (vpFileInfoAgent);
   }

BOOL IsAgentHandle(PFILEINFO pFileInfo)
   {
   return (pFileInfo == vpFileInfoAgent);
   }


BOOL IsDupHandle(PFILEINFO pFileInfo)
   {
   if (pFileInfo)
      return (pFileInfo == vpFileInfoDuped);
   return FALSE;
   }


LPVOID AllocMem (ULONG uSize)
{
    PVOID t;
    t = RxAllocatePoolWithTag(NonPagedPool,
                              uSize,
                              RX_MISC_POOLTAG);
    if (t) {
        RtlZeroMemory(t,uSize);
    }
    else
    {
        SetLastErrorLocal(ERROR_NOT_ENOUGH_MEMORY);
    }

    return(t);
}


LPVOID AllocMemPaged (ULONG uSize)
{
    PVOID t;
    t = RxAllocatePoolWithTag(PagedPool | POOL_COLD_ALLOCATION,
                              uSize,
                              RX_MISC_POOLTAG);
    if (t) {
        RtlZeroMemory(t,uSize);
    }
    else
    {
        SetLastErrorLocal(ERROR_NOT_ENOUGH_MEMORY);
    }

    return(t);
}

VOID
FreeMemPaged(
    LPVOID  lpBuff
    )
{
    FreeMem(lpBuff);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\record.mgr\daytona\nullincs.tmp\error.h ===
//null .h file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\record.mgr\daytona\ntcsclow.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

     NtCscLow.c

Abstract:

     Since this stuff is called from a low level, we must make use of the irp
     filesystems interface. An earlier experiment with ZwXXXFile failed due
     to the fact that the handles must be longlived and KeAttachProcess is
     unreliable. The strategy adopted has been to do the open in the rdbss
     process (i.e. in the system process) and then to use that handle as the
     basis for further Io. what we do is to get a pointer to the fileobject
     while we are in the system context. We do not take a reference on this
     because we already have the handle!

Author:


Revision History:

     Joe Linn              [joelinn]         01-jan-1997  ported to NT (as oslayer.c)
     Joe Linn              [joelinn]         22-aug-1997  moved into ntspecific file


--*/

#include "precomp.h"
#pragma hdrstop

#ifdef MRXSMBCSC_LOUDDOWNCALLS
#pragma alloc_text(PAGE, LoudCallsDbgPrint)
#endif //ifdef MRXSMBCSC_LOUDDOWNCALLS


#ifdef CSC_RECORDMANAGER_WINNT
#define Dbg (DEBUG_TRACE_MRXSMBCSC_OSLAYER)
RXDT_DeclareCategory(MRXSMBCSC_OSLAYER);
#endif //ifdef CSC_RECORDMANAGER_WINNT

//#define RXJOECSC_WHACKTRACE_FOR_OSLAYER
#ifdef RXJOECSC_WHACKTRACE_FOR_OSLAYER
#undef RxDbgTrace
#define RxDbgTrace(a,b,__d__) {DbgPrint __d__;}
#endif

#include "netevent.h"

typedef struct _NT5CSC_CLOSEFILE_POSTCONTEXT {
    KEVENT PostEvent;
    RX_WORK_QUEUE_ITEM  WorkQueueItem;
    PNT5CSC_MINIFILEOBJECT MiniFileObject;
    NTSTATUS PostedReturnStatus;
} NT5CSC_CLOSEFILE_POSTCONTEXT, *PNT5CSC_CLOSEFILE_POSTCONTEXT;


typedef struct _NT5CSC_ATTRIBS_CONTINUATION_CONTEXT {
    NTSTATUS Status;
    union {
        ULONG Attributes;
        struct {
            PFILE_RENAME_INFORMATION RenameInformation;
            ULONG RenameInfoBufferLength;
        };
    };
} NT5CSC_ATTRIBS_CONTINUATION_CONTEXT, *PNT5CSC_ATTRIBS_CONTINUATION_CONTEXT;


NTSTATUS
__Nt5CscCloseFile (
    IN OUT PNT5CSC_MINIFILEOBJECT MiniFileObject OPTIONAL,
    IN     BOOL  PostedCall
    );

NTSTATUS
Nt5CscCloseFilePostWrapper(
    IN OUT PNT5CSC_CLOSEFILE_POSTCONTEXT CloseFilePostContext
    );

NTSTATUS
Nt5CscCreateFilePostWrapper(
    IN OUT PNT5CSC_MINIFILEOBJECT MiniFileObject
    );

//CODE.IMPROVEMENT these could be combined as one...........
NTSTATUS
Nt5CscGetAttributesContinuation (
    IN OUT PNT5CSC_MINIFILEOBJECT MiniFileObject,
    IN OUT PVOID ContinuationContext,
    IN     NTSTATUS CreateStatus
    );

NTSTATUS
Nt5CscSetAttributesContinuation (
    IN OUT PNT5CSC_MINIFILEOBJECT MiniFileObject,
    IN OUT PVOID ContinuationContext,
    IN     NTSTATUS CreateStatus
    );

NTSTATUS
Nt5CscRenameContinuation (
    IN OUT PNT5CSC_MINIFILEOBJECT MiniFileObject,
    IN OUT PVOID ContinuationContext,
    IN     NTSTATUS CreateStatus
    );

NTSTATUS
Nt5CscDeleteContinuation (
    IN OUT PNT5CSC_MINIFILEOBJECT MiniFileObject,
    IN OUT PVOID ContinuationContext,
    IN     NTSTATUS CreateStatus
    );

VOID
SetLastNtStatusLocal(
    NTSTATUS    Status
    );

ULONG
CloseFileLocalFromHandleCache(
    CSCHFILE handle
    );

extern BOOLEAN
IsHandleCachedForRecordmanager(
   CSCHFILE hFile
   );

#pragma alloc_text(PAGE, CscInitializeSecurityDescriptor)
#pragma alloc_text(PAGE, CscUninitializeSecurityDescriptor)
#pragma alloc_text(PAGE, GetSystemTime)
#pragma alloc_text(PAGE, Nt5CscCloseFilePostWrapper)
#pragma alloc_text(PAGE, __Nt5CscCloseFile)
#pragma alloc_text(PAGE, CloseFileLocal)
#pragma alloc_text(PAGE, CloseFileLocalFromHandleCache)
#pragma alloc_text(PAGE, __Nt5CscCreateFile)
#pragma alloc_text(PAGE, Nt5CscCreateFilePostWrapper)
#pragma alloc_text(PAGE, R0OpenFileEx)
#pragma alloc_text(PAGE, Nt5CscReadWriteFileEx)
#pragma alloc_text(PAGE, Nt5CscXxxInformation)
#pragma alloc_text(PAGE, GetFileSizeLocal)
#pragma alloc_text(PAGE, GetAttributesLocal)
#pragma alloc_text(PAGE, GetAttributesLocalEx)
#pragma alloc_text(PAGE, Nt5CscGetAttributesContinuation)
#pragma alloc_text(PAGE, SetAttributesLocal)
#pragma alloc_text(PAGE, Nt5CscSetAttributesContinuation)
#pragma alloc_text(PAGE, RenameFileLocal)
#pragma alloc_text(PAGE, Nt5CscRenameContinuation)
#pragma alloc_text(PAGE, DeleteFileLocal)
#pragma alloc_text(PAGE, Nt5CscDeleteContinuation)
#pragma alloc_text(PAGE, CreateDirectoryLocal)
#pragma alloc_text(PAGE, CreateDirectoryLocal)
#pragma alloc_text(PAGE, SetLastErrorLocal)
#pragma alloc_text(PAGE, GetLastErrorLocal)
#pragma alloc_text(PAGE, SetLastNtStatusLocal)

//CODE.IMPROVEMENT.NTIFS this should be in ntifs.h
NTSYSAPI
NTSTATUS
NTAPI
ZwFsControlFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG FsControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    );

#ifdef RX_PRIVATE_BUILD
#undef IoGetTopLevelIrp
#undef IoSetTopLevelIrp
#endif //ifdef RX_PRIVATE_BUILD

PSECURITY_DESCRIPTOR CscSecurityDescriptor = NULL;

// This is a fake way by which we simulate the GetLastError and SetLastError calls
// vGloablWin32Error is set to the last error encountered if any.
// The reason why this works is because all csc database activities happen in
// the shadowcritsect, so effectively we are single threaded

DWORD   vGlobalWin32Error = 0;



extern NTSTATUS
RtlAbsoluteToSelfRelativeSD(
    PSECURITY_DESCRIPTOR AbsoluteSD,
    PSECURITY_DESCRIPTOR RelativeSD,
    PULONG               Length);


DWORD
CscInitializeSecurityDescriptor()
/*++

Routine Description:

    This routine initializes the security descriptor used for the creation of
    all the files in the database.

Notes:

    The current implementation provides for a ACL which grants the administrator
    group all access and read/execute access to everybody else.

    It is important to grant the local administrator group all access since the
    CSC utilities need to access these files

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PSID AdminsAliasSid;
    PACL TmpAcl = NULL;

    SECURITY_DESCRIPTOR AbsoluteSecurityDescriptor;

    SID_IDENTIFIER_AUTHORITY BuiltinAuthority = SECURITY_NT_AUTHORITY;

    ULONG Length = 0;

    AdminsAliasSid = (PSID)RxAllocatePoolWithTag(
                               NonPagedPool,
                               RtlLengthRequiredSid(2),
                               RX_MISC_POOLTAG);

    if (AdminsAliasSid != NULL) {

        RtlInitializeSid( AdminsAliasSid,   &BuiltinAuthority, 2 );

        *(RtlSubAuthoritySid( AdminsAliasSid,  0 )) = SECURITY_BUILTIN_DOMAIN_RID;
        *(RtlSubAuthoritySid( AdminsAliasSid,  1 )) = DOMAIN_ALIAS_RID_ADMINS;

        // The approach is to set up an absolute security descriptor that
        // looks like what we want and then copy it to make a self-relative
        // security descriptor.

        Status = RtlCreateSecurityDescriptor(
                     &AbsoluteSecurityDescriptor,
                     SECURITY_DESCRIPTOR_REVISION1);

        ASSERT( NT_SUCCESS(Status) );

        // Owner

        Status = RtlSetOwnerSecurityDescriptor (
                     &AbsoluteSecurityDescriptor,
                     AdminsAliasSid,
                     FALSE );

        ASSERT(NT_SUCCESS(Status));

        // Discretionary ACL
        //
        //      Calculate its length,
        //      Allocate it,
        //      Initialize it,
        //      Add each ACE
        //      Add it to the security descriptor

        Length = (ULONG)sizeof(ACL);

        Length += RtlLengthSid( AdminsAliasSid ) +
                  (ULONG)sizeof(ACCESS_ALLOWED_ACE) -
                  (ULONG)sizeof(ULONG);  //Subtract out SidStart field length

        TmpAcl = RxAllocatePoolWithTag(
                     NonPagedPool,
                     Length,
                     RX_MISC_POOLTAG);

        if (TmpAcl != NULL) {
            Status = RtlCreateAcl(
                         TmpAcl,
                         Length,
                         ACL_REVISION2);

            ASSERT( NT_SUCCESS(Status) );

            Status = RtlAddAccessAllowedAce (
                         TmpAcl,
                         ACL_REVISION2,
                         FILE_ALL_ACCESS,
                         AdminsAliasSid);

            ASSERT( NT_SUCCESS(Status) );

            Status = RtlSetDaclSecurityDescriptor (
                         &AbsoluteSecurityDescriptor,
                         TRUE,
                         TmpAcl,
                         FALSE );

            ASSERT(NT_SUCCESS(Status));


            // Convert the Security Descriptor to Self-Relative
            //
            //      Get the length needed
            //      Allocate that much memory
            //      Copy it
            //      Free the generated absolute ACLs

            Length = 0;
            Status = RtlAbsoluteToSelfRelativeSD(
                         &AbsoluteSecurityDescriptor,
                         NULL,
                         &Length );
            ASSERT(Status == STATUS_BUFFER_TOO_SMALL);

            CscSecurityDescriptor = (PSECURITY_DESCRIPTOR)
                                    RxAllocatePoolWithTag(
                                        NonPagedPool,
                                        Length,
                                        RX_MISC_POOLTAG);

            if (CscSecurityDescriptor != NULL) {
                Status = RtlAbsoluteToSelfRelativeSD(
                             &AbsoluteSecurityDescriptor,
                             CscSecurityDescriptor,
                             &Length );

                ASSERT(NT_SUCCESS(Status));
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (TmpAcl != NULL) {
        RxFreePool(TmpAcl);
    }

    if (AdminsAliasSid != NULL) {
        RxFreePool(AdminsAliasSid);
    }

    if (!NT_SUCCESS(Status)) {
        if (CscSecurityDescriptor != NULL) {
            RxFreePool(CscSecurityDescriptor);
        }
    }

    return RtlNtStatusToDosError(Status);
}

DWORD
CscUninitializeSecurityDescriptor()
/*++

Routine Description:

    This routine uninitializes the security descriptor used for the creation of
    all the files in the database.

--*/
{
    if (CscSecurityDescriptor != NULL) {
        RxFreePool(CscSecurityDescriptor);
        CscSecurityDescriptor = NULL;
    }
    return STATUS_SUCCESS;
}

VOID
GetSystemTime(
    _FILETIME *lpft
)
{
    LARGE_INTEGER l;

    KeQuerySystemTime(&l);
    lpft->dwLowDateTime = (DWORD)l.LowPart;
    lpft->dwHighDateTime = (DWORD)l.HighPart;
}


extern PRDBSS_DEVICE_OBJECT MRxSmbDeviceObject;

NTSTATUS
Nt5CscCloseFilePostWrapper(
    IN OUT PNT5CSC_CLOSEFILE_POSTCONTEXT CloseFilePostContext
    )
{
    NTSTATUS Status;

    ASSERT_MINIRDRFILEOBJECT(CloseFilePostContext->MiniFileObject);

    RxDbgTrace( 0, Dbg, ("Nt5CscCloseFilePostWrapper %08lx\n",
                 CloseFilePostContext->MiniFileObject));

    //KdPrint(("Nt5CscCloseFilePostWrapper %08lx\n",
    //             CloseFilePostContext->MiniFileObject));

    Status = __Nt5CscCloseFile (
                 CloseFilePostContext->MiniFileObject,
                 TRUE);

    CloseFilePostContext->PostedReturnStatus = Status;

    RxDbgTrace( 0, Dbg, ("Nt5CscCreateFilePostWrapper %08lx %08lx\n",
                 CloseFilePostContext->MiniFileObject,Status));
    //KdPrint(("Nt5CscCreateFilePostWrapper %08lx %08lx\n",
    //             CloseFilePostContext->MiniFileObject,Status));

    KeSetEvent( &CloseFilePostContext->PostEvent, 0, FALSE );
    return(Status);
}

NTSTATUS
__Nt5CscCloseFile (
    IN OUT PNT5CSC_MINIFILEOBJECT MiniFileObject OPTIONAL,
    IN     BOOL  PostedCall
    )
{
    NTSTATUS Status;

    ASSERT_MINIRDRFILEOBJECT(MiniFileObject);

    if (PsGetCurrentProcess()!= RxGetRDBSSProcess()) {
        //CODE.IMPROVEMENT we should capture the rdbss process
        //  and avoid this call (RxGetRDBSSProcess)
        NTSTATUS PostStatus;
        NT5CSC_CLOSEFILE_POSTCONTEXT PostContext;

        ASSERT(!PostedCall);
        //gather up exverything and post the call

        KeInitializeEvent(&PostContext.PostEvent,
                          NotificationEvent,
                          FALSE );
        PostContext.MiniFileObject = MiniFileObject;

        IF_DEBUG {
            //fill the workqueue structure with deadbeef....all the better to diagnose
            //a failed post
            ULONG i;
            for (i=0;i+sizeof(ULONG)-1<sizeof(PostContext.WorkQueueItem);i+=sizeof(ULONG)) {
                PBYTE BytePtr = ((PBYTE)&PostContext.WorkQueueItem)+i;
                PULONG UlongPtr = (PULONG)BytePtr;
                *UlongPtr = 0xdeadbeef;
            }
        }

        PostStatus = RxPostToWorkerThread(
                         MRxSmbDeviceObject,
                         HyperCriticalWorkQueue,
                         &PostContext.WorkQueueItem,
                         Nt5CscCloseFilePostWrapper,
                         &PostContext);

        ASSERT(PostStatus == STATUS_SUCCESS);


        KeWaitForSingleObject( &PostContext.PostEvent,
                               Executive, KernelMode, FALSE, NULL );

        Status = PostContext.PostedReturnStatus;

    } else {

        LoudCallsDbgPrint("Ready to close",
                                MiniFileObject,0xcc,0,0,0,0,0);

        Status = ZwClose(MiniFileObject->NtHandle); //no one to return a status to!

        RxDbgTrace( 0, Dbg, ("Ring0 close: miniFO/status is %08lx/%08lx\n",MiniFileObject,Status));

    }

    if (PostedCall) {
        return(Status);
    }

    if (FlagOn(MiniFileObject->Flags,
              NT5CSC_MINIFOBJ_FLAG_ALLOCATED_FROM_POOL)) {
        RxFreePool(MiniFileObject);
    }

    return(Status);
}


ULONG
CloseFileLocal(
    CSCHFILE handle
    )
{
    NTSTATUS Status;

    if (IsHandleCachedForRecordmanager(handle))
    {
        DbgPrint("Doing a close on CSC handle %x while it is cached \n", handle);
        ASSERT(FALSE);
    }

    Status = __Nt5CscCloseFile(
                (PNT5CSC_MINIFILEOBJECT)handle,
                FALSE);
    return(RtlNtStatusToDosErrorNoTeb(Status));
}

ULONG
CloseFileLocalFromHandleCache(
    CSCHFILE handle
    )
{
    NTSTATUS Status;

    Status = __Nt5CscCloseFile(
                (PNT5CSC_MINIFILEOBJECT)handle,
                FALSE);
    return(RtlNtStatusToDosErrorNoTeb(Status));
}

#define Nt5CscCreateFile(a1,a2,a3,a4,a5,a6,a7,a8,a9, a10) \
          __Nt5CscCreateFile(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,FALSE)

#ifdef MRXSMBCSC_LOUDDOWNCALLS
PCHAR LoudDownCallsTrigger = "\0";// "0000001D\0xxxxxxxxxxxxxxxxxxx";
#else
#define LoudDownCallsTrigger ((PCHAR)NULL)
#endif //ifdef MRXSMBCSC_LOUDDOWNCALLS


NTSTATUS
Nt5CscCreateFilePostWrapper(
    IN OUT PNT5CSC_MINIFILEOBJECT MiniFileObject
    );

ULONG EventLogForOpenFailure = 0;
ULONG MaximumEventLogsOfThisType = 10;
PNT5CSC_MINIFILEOBJECT
__Nt5CscCreateFile (
    IN OUT PNT5CSC_MINIFILEOBJECT MiniFileObject OPTIONAL,
    IN     LPSTR    lpPath,
    IN     ULONG    CSCFlags,
    IN     ULONG    FileAttributes,
    IN     ULONG    CreateOptions,
    IN     ULONG    Disposition,
    IN     ULONG    ShareAccess,
    IN     ACCESS_MASK DesiredAccess,
    IN     PNT5CSC_CREATEFILE_CONTINUATION Continuation,
    IN OUT PVOID    ContinuationContext,
    IN     BOOL     PostedCall
    )
/*++

Routine Description:

   This routine performs a IoCreateFile after gathering up
   all the params and getting into the right process. It also
   allocates (if needed) a MINIFILEOBJECT. All of the recordmanager
   opens are gathered up here....whether a regular open or a path-based
   operation.

   In addition, i discover that it is not enough to be in the system process;
   rather, i must be on a thread with APCs enabled. so, we will post all create
   calls even tho we do not post close calls if we are already in a system
   thread.

Arguments:

    these params are the same as for IoCreateFile.

Return Value:

    NULL is the operation failed......a MINIFILEOBJECT otherwise.

Notes:

--*/
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING FileName;
    ANSI_STRING FileNameAsAnsiString;
#if defined(BITCOPY)
    BOOLEAN Allocated = TRUE;
    ULONG fInstrument =   CSCFlags & FLAG_CREATE_OSLAYER_INSTRUMENT;
    ULONG fAllAccess  =   CSCFlags & FLAG_CREATE_OSLAYER_ALL_ACCESS;
    ULONG fOpenAltStream = CSCFlags & FLAG_CREATE_OSLAYER_OPEN_STRM;
#else
    BOOLEAN Allocated = TRUE;
    BOOLEAN fInstrument =   (BOOLEAN)(CSCFlags & FLAG_CREATE_OSLAYER_INSTRUMENT);
    BOOLEAN fAllAccess  =   (BOOLEAN)(CSCFlags & FLAG_CREATE_OSLAYER_ALL_ACCESS);
#endif // defined(BITCOPY)

    FileName.Buffer = NULL;

    if (MiniFileObject==NULL) {
        MiniFileObject = (PNT5CSC_MINIFILEOBJECT)RxAllocatePoolWithTag(
                            NonPagedPool, //this has events and mutexs in it
                            sizeof(*MiniFileObject),
                            RX_MISC_POOLTAG);
    } else {
        Allocated = FALSE;
    }
    if (MiniFileObject==NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto FINALLY;
    }

    ZeroAndInitializeNodeType(
          MiniFileObject,
          NT5CSC_NTC_MINIFILEOBJECT,
          ((USHORT)FIELD_OFFSET(NT5CSC_MINIFILEOBJECT,PostXX.PostEvent))
          );
    MiniFileObject->Flags |= NT5CSC_MINIFOBJ_FLAG_ALLOCATED_FROM_POOL;

    // There used to be an optimization here, which would check whether this was RDBSS
    // process and if so the code would not post the call.
    // But that causes IoCreateFile to be issued at APC irql becuase
    // shadowcrit is implemented as fastmutex which causes the irql level to be
    // raised to APC level

    // The above optimization was done for remoteboot. If and when we resurrect
    // remoteboot, we will revisit the issue

    if (!PostedCall) {
        NTSTATUS PostStatus;
        //gather up exverything and post the call

        KeInitializeEvent(&MiniFileObject->PostXX.PostEvent,
                          NotificationEvent,
                          FALSE );
        MiniFileObject->PostXX.lpPath = lpPath;
#if defined(BITCOPY)
        MiniFileObject->PostXX.fInstrument = fInstrument|fOpenAltStream|fAllAccess;
#else
        MiniFileObject->PostXX.fInstrument = fInstrument;
#endif // defined(BITCOPY)
        MiniFileObject->PostXX.FileAttributes = FileAttributes;
        MiniFileObject->PostXX.CreateOptions = CreateOptions;
        MiniFileObject->PostXX.Disposition = Disposition;
        MiniFileObject->PostXX.ShareAccess = ShareAccess;
        MiniFileObject->PostXX.DesiredAccess = DesiredAccess;
        MiniFileObject->PostXX.Continuation = Continuation;
        MiniFileObject->PostXX.ContinuationContext = ContinuationContext;


        IF_DEBUG {
            //fill the workqueue structure with deadbeef....all the better to diagnose
            //a failed post
            ULONG i;
            for (i=0;i+sizeof(ULONG)-1<sizeof(MiniFileObject->PostXX.WorkQueueItem);i+=sizeof(ULONG)) {
                PBYTE BytePtr = ((PBYTE)&MiniFileObject->PostXX.WorkQueueItem)+i;
                PULONG UlongPtr = (PULONG)BytePtr;
                *UlongPtr = 0xdeadbeef;
            }
        }

        PostStatus = RxPostToWorkerThread(
                         MRxSmbDeviceObject,
                         HyperCriticalWorkQueue,
                         &MiniFileObject->PostXX.WorkQueueItem,
                         Nt5CscCreateFilePostWrapper,
                         MiniFileObject);

        ASSERT(PostStatus == STATUS_SUCCESS);


        KeWaitForSingleObject( &MiniFileObject->PostXX.PostEvent,
                                Executive, KernelMode, FALSE, NULL );

        Status = MiniFileObject->PostXX.PostReturnStatus;
    } else {
        BOOLEAN ThisIsALoudFile = FALSE;

        RtlInitAnsiString(&FileNameAsAnsiString, lpPath);

        IF_BUILT_FOR_LOUD_DOWNCALLS() {
            ANSI_STRING LoudDownCallsTriggerAsAnsiString = {0,0,NULL};
            USHORT CompareLength;

            RtlInitAnsiString(&LoudDownCallsTriggerAsAnsiString, LoudDownCallsTrigger);
            if ((CompareLength=LoudDownCallsTriggerAsAnsiString.Length) != 0) {
                ANSI_STRING TailStringOfName;
                TailStringOfName.Length = CompareLength;
                TailStringOfName.MaximumLength = CompareLength;
                TailStringOfName.Buffer
                    = &FileNameAsAnsiString.Buffer[FileNameAsAnsiString.Length - CompareLength];
                if (RtlEqualString(&TailStringOfName,
                                   &LoudDownCallsTriggerAsAnsiString,TRUE)) {
                    KdPrint(("found loudfilename: file %s\n",lpPath));
                    ThisIsALoudFile = TRUE;
                }
            }
        }

        Status = RtlAnsiStringToUnicodeString(
                        &FileName,
                        &FileNameAsAnsiString,
                        TRUE //this says to allocate the string
                        );
        if (Status!=STATUS_SUCCESS) {
            goto FINALLY;
        }

#if defined(REMOTE_BOOT)
        //
        // At this point in the old remote boot code, we impersonated
        // the user for the call to IoCreateFile. There was an
        // OsSpecificContext saved in the MiniFileObject->PostXX
        // structure that was saved before we posted to a thread,
        // having been passed down by adding a context parameter
        // to CreateFileLocal, OpenFileLocal[Ex], and R0OpenFile[Ex].
        // This context pointed to a structure containing a
        // PNT_CREATE_PARAMETERS cp from the IRP and a place to return
        // a status. We called
        //  PsImpersonateContext(
        //      PsGetCurrentThread(),
        //      SeQuerySubjectContextToken(
        //          &cp->SecurityContext->AccessState->SubjectSecurityContext),
        //      TRUE,
        //      TRUE,
        //      SecurityImpersonation)
        // then in InitializeObjectAttributes we set the security descriptor
        // to cp->SecurityContext->AccessState->SecurityDescriptor (in case
        // we were creating the file). We then called IoCreateFile with the
        // IO_FORCE_ACCESS_CHECK option, saving the status in the context
        // (since we have no way to directly return an NTSTATUS from here).
        // Finally we called PsRevertToSelf() before returning.
        //
#endif

        RxDbgTrace( 0, Dbg, ("Ring0 open: file %wZ\n",&FileName));

        InitializeObjectAttributes(
             &ObjectAttributes,
             &FileName,
             OBJ_CASE_INSENSITIVE,
             0,
             (fAllAccess)?NULL:CscSecurityDescriptor
             );

        if (fInstrument)
        {
            BEGIN_TIMING(IoCreateFile_R0Open);
        }
#if DBG
        if(KeGetCurrentIrql() != PASSIVE_LEVEL)
        {
            DbgPrint("Irql level = %d \n", KeGetCurrentIrql());
            ASSERT(FALSE);
        }
#endif

        Status = IoCreateFile(
                          &MiniFileObject->NtHandle,
                          DesiredAccess,
                          &ObjectAttributes,
                          &IoStatusBlock,
                          NULL, //&CreateParameters->AllocationSize,
                          FileAttributes, //CreateParameters->FileAttributes,
                          ShareAccess, //CreateParameters->ShareAccess,
                          Disposition, //CreateParameters->Disposition,
                          CreateOptions,
                          NULL, //RxContext->Create.EaBuffer,
                          0, //RxContext->Create.EaLength,
                          CreateFileTypeNone,
                          NULL,                    // extra parameters
                          IO_NO_PARAMETER_CHECKING
                          );

        if (fInstrument)
        {
            END_TIMING(IoCreateFile_R0Open);
        }


        if (Status==STATUS_SUCCESS) {

            RxDbgTrace( 0, Dbg, ("Ring0 open: file %wZ, handle is %08lx\n",&FileName,MiniFileObject->NtHandle));
            //now get a pointer to the file object by referencing....since we
            //dont need the reference...drop it if successful

             Status = ObReferenceObjectByHandle(
                             MiniFileObject->NtHandle,
                             0L,
                             NULL,
                             KernelMode,
                             (PVOID *) &MiniFileObject->UnderlyingFileObject,
                             NULL );

            if (Status==STATUS_SUCCESS) {
                ObDereferenceObject( MiniFileObject->UnderlyingFileObject );
            }

#if defined(BITCOPY)
            if (TRUE && (Status==STATUS_SUCCESS) && !fOpenAltStream) {
#else
            if (TRUE && (Status==STATUS_SUCCESS)) {
#endif // defined(BITCOPY)
                IO_STATUS_BLOCK IoStatusBlock;
                USHORT CompressionFormat = COMPRESSION_FORMAT_NONE;
                Status = ZwFsControlFile(
                                MiniFileObject->NtHandle,  //IN HANDLE FileHandle,
                                NULL,                      //IN HANDLE Event OPTIONAL,
                                NULL,                      //IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
                                NULL,                      //IN PVOID ApcContext OPTIONAL,
                                &IoStatusBlock,            //OUT PIO_STATUS_BLOCK IoStatusBlock,
                                FSCTL_SET_COMPRESSION,     //IN ULONG FsControlCode,
                                &CompressionFormat,        //IN PVOID InputBuffer OPTIONAL,
                                sizeof(CompressionFormat), //IN ULONG InputBufferLength,
                                NULL,                      //OUT PVOID OutputBuffer OPTIONAL,
                                0                          //IN ULONG OutputBufferLength
                                );
                //DbgPrint("Ring0 setcompress : file %wZ, status is %08lx\n",&FileName,Status);
                if (Status!=STATUS_SUCCESS) {
                    if (Status==STATUS_INVALID_DEVICE_REQUEST) {
                        Status = STATUS_SUCCESS;
                    } else {
                        DbgPrint("Ring0 setcompress failed: file %wZ, status is %08lx\n",&FileName,Status);
                        RxDbgTrace( 0, Dbg,
                           ("Ring0 setcompress failed: file %wZ, status is %08lx\n",&FileName,Status));
                    }
                }
            }


            if (Status!=STATUS_SUCCESS) {
                NtClose(MiniFileObject->NtHandle);
                MiniFileObject->NtHandle = 0;
            }

        } else {
            RxDbgTrace( 0, Dbg, ("Ring0 open: file %wZ, status is %08lx\n",&FileName,Status));

            IF_BUILT_FOR_LOUD_DOWNCALLS() {
                if (ThisIsALoudFile) {
                    DbgPrint("Nt5Csc: openfailed %08lx %wZ\n",Status,&FileName);
                }
            }

            if (EventLogForOpenFailure && (MaximumEventLogsOfThisType > 0)) {
                PCHAR  LogBuffer = FileNameAsAnsiString.Buffer;
                USHORT LogBufferLength = FileNameAsAnsiString.Length;

                DbgPrint("Nt5Csc: openfailed %08lx %wZ\n",Status,&FileName);

                EventLogForOpenFailure = 0; //do this to be sure....
                MaximumEventLogsOfThisType--;

                if (LogBufferLength>12) {
                    LogBuffer += 12;
                    LogBufferLength -= 12;
                }
                RxLogFailureWithBuffer(
                     MRxSmbDeviceObject,
                     NULL,
                     EVENT_RDR_CANT_READ_REGISTRY,
                     Status,
                     LogBuffer,
                     LogBufferLength
                     );
            }
        }

        IF_BUILT_FOR_LOUD_DOWNCALLS() {
            if (ThisIsALoudFile) {
                DbgPrint("OpenedFile %08lx %08lx %02lx  %08lx@%08lx:%08lx\n",
                                MiniFileObject->NtHandle,
                                MiniFileObject->UnderlyingFileObject,
                                0xcc,
                                0,
                                0,
                                0
                                );
                SetFlag(MiniFileObject->Flags,NT5CSC_MINIFOBJ_FLAG_LOUDDOWNCALLS);
            }
        }

        if (Continuation!=NULL) {
            Status = Continuation(MiniFileObject,ContinuationContext,Status);
        }

    }

FINALLY:
    if (FileName.Buffer != NULL) {
        ExFreePool(FileName.Buffer);
    }

    if (PostedCall) {
        ASSERT(!Allocated);
        MiniFileObject->PostXX.PostReturnStatus = Status;
        return(NULL);
    }

    if (Status!=STATUS_SUCCESS) {
        //give back anything that we have
        if (Allocated && (MiniFileObject!=NULL)) {
            if (FlagOn(MiniFileObject->Flags,
                       NT5CSC_MINIFOBJ_FLAG_ALLOCATED_FROM_POOL)) {
                RxFreePool(MiniFileObject);
            }
        }
        SetLastNtStatusLocal(Status);
        return(NULL);
    }

    //initialize the deviceobjectpointer and the mutex........

    //cant do this MiniFileObject->UnderlyingDeviceObject
    //cant do this    = IoGetRelatedDeviceObject( MiniFileObject->UnderlyingFileObject );
    ExInitializeFastMutex(&MiniFileObject->MutexForSynchronousIo);
    return(MiniFileObject);
}


NTSTATUS
Nt5CscCreateFilePostWrapper(
    IN OUT PNT5CSC_MINIFILEOBJECT MiniFileObject
    )
/*++

Routine Description:

Arguments:

Return Value:

Notes:

--*/
{
    NTSTATUS Status;
    LPSTR Path = MiniFileObject->PostXX.lpPath;

    RxDbgTrace( 0, Dbg, ("Nt5CscCreateFilePostWrapper %08lx %s\n",
                 MiniFileObject,Path));

    __Nt5CscCreateFile (
                 MiniFileObject,
                 MiniFileObject->PostXX.lpPath,
                 MiniFileObject->PostXX.fInstrument,
                 MiniFileObject->PostXX.FileAttributes,
                 MiniFileObject->PostXX.CreateOptions,
                 MiniFileObject->PostXX.Disposition,
                 MiniFileObject->PostXX.ShareAccess,
                 MiniFileObject->PostXX.DesiredAccess,
                 MiniFileObject->PostXX.Continuation,
                 MiniFileObject->PostXX.ContinuationContext,
                 TRUE);

    Status = MiniFileObject->PostXX.PostReturnStatus;
    RxDbgTrace( 0, Dbg, ("Nt5CscCreateFilePostWrapper %08lx %s %08lx\n",
                 MiniFileObject,Path,Status));

    KeSetEvent( &MiniFileObject->PostXX.PostEvent, 0, FALSE );
    return(Status);
}



CSCHFILE
R0OpenFileEx(
    USHORT  usOpenFlags,
    UCHAR   bAction,
    ULONG   ulAttr,
    LPSTR   lpPath,
    BOOL    fInstrument
    )
/*++

Routine Description:

Arguments:

Return Value:

Notes:

--*/
{
     PNT5CSC_MINIFILEOBJECT MiniFileObject;
     ULONG Disposition,ShareAccess,CreateOptions;

     ASSERT( (usOpenFlags & 0xf) == ACCESS_READWRITE);
     ShareAccess = FILE_SHARE_READ | FILE_SHARE_WRITE;
     CreateOptions = FILE_SYNCHRONOUS_IO_NONALERT
                                    | FILE_NON_DIRECTORY_FILE;
     if (usOpenFlags & OPEN_FLAGS_COMMIT)
     {
        CreateOptions |= FILE_WRITE_THROUGH;
     }
     switch (bAction) {
     case ACTION_CREATEALWAYS:
          Disposition = FILE_OVERWRITE_IF;
          break;

     case ACTION_OPENALWAYS:
          Disposition = FILE_OPEN_IF;
          break;

     case ACTION_OPENEXISTING:
          Disposition = FILE_OPEN;
          break;

     default:
         return (CSCHFILE)(NULL);
     }

     MiniFileObject =  Nt5CscCreateFile (
                          NULL, //make him allocate
                          lpPath,
                          fInstrument,
                          ulAttr,
                          CreateOptions,
                          Disposition,
                          ShareAccess,
                          GENERIC_READ | GENERIC_WRITE,
                          NULL,NULL  //Continuation
                          );

    return (CSCHFILE)MiniFileObject;
}



typedef struct _NT5CSC_IRPCOMPLETION_CONTEXT {
    //IO_STATUS_BLOCK IoStatus;
    KEVENT Event;
} NT5CSC_IRPCOMPLETION_CONTEXT, *PNT5CSC_IRPCOMPLETION_CONTEXT;

NTSTATUS
Nt5CscIrpCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP CalldownIrp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called when the calldownirp is completed.

Arguments:

    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP CalldownIrp,
    IN PVOID Context

Return Value:

    RXSTATUS - STATUS_MORE_PROCESSING_REQUIRED

--*/
{
    PNT5CSC_IRPCOMPLETION_CONTEXT IrpCompletionContext
           = (PNT5CSC_IRPCOMPLETION_CONTEXT)Context;

    if (CalldownIrp->PendingReturned){
        //IrpCompletionContext->IoStatus = CalldownIrp->IoStatus;
        KeSetEvent( &IrpCompletionContext->Event, 0, FALSE );
    }
    return(STATUS_MORE_PROCESSING_REQUIRED);
}

//long R0ReadWriteFileEx
//    (
//    ULONG     uOper,
//    CSCHFILE  handle,
//    ULONG     pos,
//    PVOID     pBuff,
//    long      lCount,
//    BOOL      fInstrument
//    )


IO_STATUS_BLOCK Nt5CscGlobalIoStatusBlock;

LONG
Nt5CscReadWriteFileEx (
    ULONG       uOper,
    CSCHFILE    handle,
    ULONGLONG   pos,
    PVOID       pBuff,
    long        lCount,
    ULONG       Flags,
    PIO_STATUS_BLOCK OutIoStatusBlock OPTIONAL
    )

/*++

Routine Description:

Arguments:

Return Value:

Notes:

--*/
{
    NTSTATUS Status;
    LARGE_INTEGER ByteOffset;
    ULONG MajorFunction;
    PNT5CSC_MINIFILEOBJECT MiniFileObject = (PNT5CSC_MINIFILEOBJECT)handle;

    PIRP irp,TopIrp;
    PIO_STACK_LOCATION irpSp;

    PDEVICE_OBJECT DeviceObject;
    PFILE_OBJECT FileObject;

    NT5CSC_IRPCOMPLETION_CONTEXT IrpCompletionContext;
    ULONG ReturnedLength, MdlLength;
    BOOLEAN    fInstrument = BooleanFlagOn(Flags,NT5CSC_RW_FLAG_INSTRUMENTED);
    BOOLEAN    fPagedBuffer = BooleanFlagOn(Flags,NT5CSC_RW_FLAG_PAGED_BUFFER);


    if (OutIoStatusBlock==NULL) {
        OutIoStatusBlock = &Nt5CscGlobalIoStatusBlock;
    }
    OutIoStatusBlock->Information = 0;

    ASSERT (MiniFileObject);
    ASSERT_MINIRDRFILEOBJECT(MiniFileObject);

    //DeviceObject =  MiniFileObject->UnderlyingDeviceObject;
    FileObject = MiniFileObject->UnderlyingFileObject;
    ASSERT (FileObject);
    DeviceObject = IoGetRelatedDeviceObject( FileObject );
    ASSERT (DeviceObject);

    if (DeviceObject->Flags & DO_BUFFERED_IO) {
        //i cannot handled buffered_io devices....sigh
        OutIoStatusBlock->Status = STATUS_INVALID_DEVICE_REQUEST;
        SetLastNtStatusLocal(STATUS_INVALID_DEVICE_REQUEST);
        return -1;
    }

    ByteOffset.QuadPart = pos;

    if ((uOper == R0_READFILE) || (uOper == R0_READFILE_IN_CONTEXT)) {
        MajorFunction = IRP_MJ_READ;
    } else {
        MajorFunction = IRP_MJ_WRITE;
        //if (lCount ==0x44) {
        //     DbgBreakPoint();
        //}
    }

//    irp = IoBuildAsynchronousFsdRequest(
//              MajorFunction,
//              DeviceObject,
//              NULL, //Buffer...needs special treatment
//              lCount,
//              &ByteOffset,
//              NULL
//              );

    irp = IoAllocateIrp( DeviceObject->StackSize, FALSE ); //why not charge???
    if (!irp) {
        OutIoStatusBlock->Status = STATUS_INSUFFICIENT_RESOURCES;
        SetLastNtStatusLocal(STATUS_INSUFFICIENT_RESOURCES);
        return -1;
    }

    //
    // Set current thread for IoSetHardErrorOrVerifyDevice.
    //

    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    // Get a pointer to the stack location of the first driver which will be
    // invoked.  This is where the function codes and the parameters are set.
    //

    irpSp = IoGetNextIrpStackLocation( irp );  //ok4ioget
    irpSp->MajorFunction = (UCHAR) MajorFunction;
    irpSp->FileObject = FileObject;            //ok4->FileObj
    IoSetCompletionRoutine(irp,
                           Nt5CscIrpCompletionRoutine,
                           &IrpCompletionContext,
                           TRUE,TRUE,TRUE); //call no matter what....

    ASSERT (&irpSp->Parameters.Write.Key == &irpSp->Parameters.Read.Key);
    ASSERT (&irpSp->Parameters.Write.Length == &irpSp->Parameters.Read.Length);
    ASSERT (&irpSp->Parameters.Write.ByteOffset == &irpSp->Parameters.Read.ByteOffset);
    irpSp->Parameters.Read.Length = MdlLength = lCount;
    irpSp->Parameters.Read.ByteOffset = ByteOffset;
    irpSp->Parameters.Read.Key = 0;          //not used
    irp->RequestorMode = KernelMode;
    irp->UserBuffer = pBuff;

    if (FlagOn(Flags,NT5CSC_RW_FLAG_IRP_NOCACHE)) {
        irp->Flags |= IRP_NOCACHE;
        MdlLength = (ULONG)ROUND_TO_PAGES(MdlLength);
    }


    irp->MdlAddress = IoAllocateMdl(
                         irp->UserBuffer,
                         MdlLength,
                         FALSE,FALSE,NULL);

    if (!irp->MdlAddress) {
        //whoops.......sorry..........
        IoFreeIrp(irp);
        OutIoStatusBlock->Status = STATUS_INSUFFICIENT_RESOURCES;
        SetLastNtStatusLocal(STATUS_INSUFFICIENT_RESOURCES);
        return(-1);
    }

    Status = STATUS_SUCCESS;

    if (fPagedBuffer)
    {
        try {
            MmProbeAndLockPages(
                irp->MdlAddress,
                KernelMode,
                IoWriteAccess
            );
        } except(EXCEPTION_EXECUTE_HANDLER) {

            Status = GetExceptionCode();

            IoFreeMdl( irp->MdlAddress );
        }
    }
    else
    {
        MmBuildMdlForNonPagedPool(irp->MdlAddress);
    }

    if (Status != STATUS_SUCCESS)
    {
        IoFreeIrp(irp);
        OutIoStatusBlock->Status = Status;
        SetLastNtStatusLocal(Status);
        return(-1);
    }


    LoudCallsDbgPrint("Ready to ",
                            MiniFileObject,
                            MajorFunction,
                            lCount,
                            ByteOffset.LowPart,
                            ByteOffset.HighPart,0,0
                            );

    KeInitializeEvent(&IrpCompletionContext.Event,
                      NotificationEvent,
                      FALSE );

    try {
        TopIrp = IoGetTopLevelIrp();
        IoSetTopLevelIrp(NULL); //tell the underlying guy he's all clear
        Status = IoCallDriver(DeviceObject,irp);
    } finally {
        IoSetTopLevelIrp(TopIrp); //restore my context for unwind
    }

    //RxDbgTrace (0, Dbg, ("  -->Status after iocalldriver %08lx(%08lx)\n",RxContext,Status));

    if (Status == (STATUS_PENDING)) {
        KeWaitForSingleObject( &IrpCompletionContext.Event,
                               Executive, KernelMode, FALSE, NULL );
        Status = irp->IoStatus.Status;
    }

    ReturnedLength = (ULONG)irp->IoStatus.Information;
    RxDbgTrace( 0, Dbg, ("Ring0%sFile<%x> %x bytes@%x returns %08lx/%08lx\n",
                (MajorFunction == IRP_MJ_READ)?"Read":"Write",MiniFileObject,
                lCount,pos,Status,ReturnedLength));


    if (fPagedBuffer)
    {
        MmUnlockPages( irp->MdlAddress );
    }

    IoFreeMdl(irp->MdlAddress);
    IoFreeIrp(irp);

    LoudCallsDbgPrint("Back from",
                            MiniFileObject,
                            MajorFunction,
                            lCount,
                            ByteOffset.LowPart,
                            ByteOffset.HighPart,
                            Status,
                            ReturnedLength
                            );

    OutIoStatusBlock->Status = Status;
    if (Status==STATUS_SUCCESS) {

        OutIoStatusBlock->Information = ReturnedLength;

        return(ReturnedLength);

    } else if (Status == STATUS_END_OF_FILE){
        SetLastNtStatusLocal(STATUS_END_OF_FILE);
        return (0);
    }
    else {
        SetLastNtStatusLocal(Status);
        return(-1);
    }
}


NTSTATUS
Nt5CscXxxInformation(
    IN PCHAR xMajorFunction,
    IN PNT5CSC_MINIFILEOBJECT MiniFileObject,
    IN ULONG InformationClass,
    IN ULONG Length,
    OUT PVOID Information,
    OUT PULONG ReturnedLength
    )

/*++

Routine Description:

    This routine returns the requested information about a specified file
    or volume.  The information returned is determined by the class that
    is specified, and it is placed into the caller's output buffer.

Arguments:

    MiniFileObject - Supplies a pointer to the file object about which the requested
        information is returned.

    FsInformationClass - Specifies the type of information which should be
        returned about the file/volume.

    Length - Supplies the length of the buffer in bytes.

    FsInformation - Supplies a buffer to receive the requested information
        returned about the file.  This buffer must not be pageable and must
        reside in system space.

    ReturnedLength - Supplies a variable that is to receive the length of the
        information written to the buffer.

    FileInformation - Boolean that indicates whether the information requested
        is for a file or a volume.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    NTSTATUS Status;
    PIRP irp,TopIrp;
    PIO_STACK_LOCATION irpSp;

    PDEVICE_OBJECT DeviceObject;
    PFILE_OBJECT FileObject;

    NT5CSC_IRPCOMPLETION_CONTEXT IrpCompletionContext;
    ULONG DummyReturnedLength;

    ULONG SetFileInfoInfo;

    PAGED_CODE();

    if (ReturnedLength==NULL) {
        ReturnedLength = &DummyReturnedLength;
    }


    //DeviceObject =  MiniFileObject->UnderlyingDeviceObject;
    FileObject = MiniFileObject->UnderlyingFileObject;
    ASSERT (FileObject);
    DeviceObject = IoGetRelatedDeviceObject( FileObject );
    ASSERT (DeviceObject);

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.
    //

    irp = IoAllocateIrp( DeviceObject->StackSize, TRUE );
    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    irp->Tail.Overlay.OriginalFileObject = FileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    irp->RequestorMode = KernelMode;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = (UCHAR)xMajorFunction;
    irpSp->FileObject = FileObject;
    IoSetCompletionRoutine(irp,
                           Nt5CscIrpCompletionRoutine,
                           &IrpCompletionContext,
                           TRUE,TRUE,TRUE); //call no matter what....


    irp->AssociatedIrp.SystemBuffer = Information;

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    IF_DEBUG {
        ASSERT( (irpSp->MajorFunction == IRP_MJ_QUERY_INFORMATION)
                    || (irpSp->MajorFunction == IRP_MJ_SET_INFORMATION)
                    || (irpSp->MajorFunction == IRP_MJ_QUERY_VOLUME_INFORMATION) );

        if (irpSp->MajorFunction == IRP_MJ_SET_INFORMATION) {
            ASSERT( (InformationClass == FileAllocationInformation)
                        || (InformationClass == FileEndOfFileInformation) );

            IF_LOUD_DOWNCALLS(MiniFileObject) {
                SetFileInfoInfo =  ((PFILE_END_OF_FILE_INFORMATION)Information)->EndOfFile.LowPart;
            }
        }

        ASSERT(&irpSp->Parameters.QueryFile.Length == &irpSp->Parameters.SetFile.Length);
        ASSERT(&irpSp->Parameters.QueryFile.Length == &irpSp->Parameters.QueryVolume.Length);


        ASSERT(&irpSp->Parameters.QueryFile.FileInformationClass
                                          == &irpSp->Parameters.SetFile.FileInformationClass);
        ASSERT((PVOID)&irpSp->Parameters.QueryFile.FileInformationClass
                                          == (PVOID)&irpSp->Parameters.QueryVolume.FsInformationClass);

    }

    irpSp->Parameters.QueryFile.Length = Length;
    irpSp->Parameters.QueryFile.FileInformationClass = InformationClass;

    //
    // Now simply invoke the driver at its dispatch entry with the IRP.
    //

    KeInitializeEvent(&IrpCompletionContext.Event,
                      NotificationEvent,
                      FALSE );

    LoudCallsDbgPrint("Ready to",
                            MiniFileObject,
                            irpSp->MajorFunction,
                            irpSp->Parameters.QueryFile.FileInformationClass,
                            irpSp->Parameters.QueryFile.Length,
                            SetFileInfoInfo,0,0
                            );

    try {
        TopIrp = IoGetTopLevelIrp();
        IoSetTopLevelIrp(NULL); //tell the underlying guy he's all clear
        Status = IoCallDriver(DeviceObject,irp);
    } finally {
        IoSetTopLevelIrp(TopIrp); //restore my context for unwind
    }


    //RxDbgTrace (0, Dbg, ("  -->Status after iocalldriver %08lx(%08lx)\n",RxContext,Status));

    if (Status == (STATUS_PENDING)) {
        KeWaitForSingleObject( &IrpCompletionContext.Event,
                               Executive, KernelMode, FALSE, NULL );
        Status = irp->IoStatus.Status;
    }

    LoudCallsDbgPrint("Back from",
                            MiniFileObject,
                            irpSp->MajorFunction,
                            irpSp->Parameters.QueryFile.FileInformationClass,
                            irpSp->Parameters.QueryFile.Length,
                            SetFileInfoInfo,
                            Status,irp->IoStatus.Information
                            );

    if (Status==STATUS_SUCCESS) {
        *ReturnedLength = (ULONG)irp->IoStatus.Information;
        RxDbgTrace( 0, Dbg, ("Ring0QueryXXX(%x)Info<%x> %x bytes@%x returns %08lx/%08lx\n",
                    xMajorFunction,MiniFileObject,
                    Status,*ReturnedLength));
    }

    IoFreeIrp(irp);
    return(Status);

}

int
GetFileSizeLocal(
    CSCHFILE handle,
    PULONG lpuSize
    )
{
     NTSTATUS Status;
     IO_STATUS_BLOCK IoStatusBlock;
     FILE_STANDARD_INFORMATION Information;
     ULONG t,ReturnedLength;
     PNT5CSC_MINIFILEOBJECT MiniFileObject = (PNT5CSC_MINIFILEOBJECT)handle;


     RxDbgTrace( 0, Dbg, ("GetFileSizeLocal: handle %08lx\n",handle));
     ASSERT_MINIRDRFILEOBJECT(MiniFileObject);

     MiniFileObject->StandardInfo.EndOfFile.LowPart = 0xfffffeee;
     Status = Nt5CscXxxInformation((PCHAR)IRP_MJ_QUERY_INFORMATION,
                    MiniFileObject,
                    FileStandardInformation,//IN FILE_INFORMATION_CLASS FileInformationClass,
                    sizeof(MiniFileObject->StandardInfo),//IN ULONG Length,
                    &MiniFileObject->StandardInfo,   //OUT PVOID FileInformation,
                    &MiniFileObject->ReturnedLength //OUT PULONG ReturnedLength
                    );

     Information = MiniFileObject->StandardInfo;

     if (Status != STATUS_SUCCESS) {
          KdPrint(("GetFileSizeLocal: handle %08lx: bailing w %08lx\n",handle,Status));
          SetLastNtStatusLocal(Status);
          return(-1);
     }

     t = Information.EndOfFile.LowPart;
     RxDbgTrace( 0, Dbg, ("GetFileSizeLocal: handle %08lx: return w size%08lx\n",handle,t));
     //DbgPrint("GetFileSizeLocal: handle %08lx: return w size%08lx\n",handle,t);
     *lpuSize = t;
     return(STATUS_SUCCESS);
}

ULONG  Nt5CscGetAttributesLocalCalls = 0;
int
GetAttributesLocal(
    LPSTR   lpPath,
    ULONG   *lpuAttributes
    )
{
    return (GetAttributesLocalEx(lpPath, TRUE, lpuAttributes));
}

int GetAttributesLocalEx(
    LPSTR   lpPath,
    BOOL    fFile,
    ULONG   *lpuAttributes
    )
{
    PNT5CSC_MINIFILEOBJECT MiniFileObject;
    ULONG Disposition,ShareAccess,CreateOptions;
    NT5CSC_ATTRIBS_CONTINUATION_CONTEXT Context;

    Nt5CscGetAttributesLocalCalls++;
    ShareAccess = FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;
    CreateOptions = FILE_SYNCHRONOUS_IO_NONALERT
                                    | (fFile?FILE_NON_DIRECTORY_FILE:FILE_DIRECTORY_FILE);

    MiniFileObject =  Nt5CscCreateFile (
                          NULL, //make him allocate
                          lpPath,
                          FALSE,
                          FILE_ATTRIBUTE_NORMAL,
                          CreateOptions,
                          FILE_OPEN,  //disposition
                          ShareAccess,
                          FILE_READ_ATTRIBUTES,
                          Nt5CscGetAttributesContinuation,
                          &Context  //Continuation
                          );

     if (Context.Status != STATUS_SUCCESS) {
          SetLastNtStatusLocal(Context.Status);
          return(-1);
     }

     *lpuAttributes = Context.Attributes;
     return(STATUS_SUCCESS);
}

NTSTATUS
Nt5CscGetAttributesContinuation (
    IN OUT PNT5CSC_MINIFILEOBJECT MiniFileObject,
    IN OUT PVOID ContinuationContext,
    IN     NTSTATUS CreateStatus
    )
{
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_BASIC_INFORMATION BasicInformation;
    PNT5CSC_ATTRIBS_CONTINUATION_CONTEXT Context
          = (PNT5CSC_ATTRIBS_CONTINUATION_CONTEXT)ContinuationContext;

    if (CreateStatus == STATUS_SUCCESS) {

        LoudCallsDbgPrint("GetAttrContinue",
                                MiniFileObject,
                                0xa1,0,0,0,0,0);


        Context->Status = ZwQueryInformationFile(
                         MiniFileObject->NtHandle,  //IN HANDLE FileHandle,
                         &IoStatusBlock,            //OUT PIO_STATUS_BLOCK IoStatusBlock,
                         &BasicInformation,         //OUT PVOID FileInformation,
                         sizeof(BasicInformation),//IN ULONG Length,
                         FileBasicInformation      //IN FILE_INFORMATION_CLASS FileInformationClass
                         );

        LoudCallsDbgPrint("GetAttrContinueRR",
                                MiniFileObject,
                                0xa1,0,0,0,
                                Context->Status,IoStatusBlock.Information);

        Context->Attributes = BasicInformation.FileAttributes;
        NtClose(MiniFileObject->NtHandle);
    } else {
        Context->Status = CreateStatus;
    }
    return(STATUS_MORE_PROCESSING_REQUIRED);
}

ULONG  Nt5CscSetAttributesLocalCalls = 0;
int
SetAttributesLocal(
    LPSTR lpPath,
    ULONG uAttributes
    )
{
    PNT5CSC_MINIFILEOBJECT MiniFileObject;
    ULONG ShareAccess,CreateOptions;
    NT5CSC_ATTRIBS_CONTINUATION_CONTEXT Context;

    Nt5CscSetAttributesLocalCalls++;
    ShareAccess = FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;
    CreateOptions = FILE_SYNCHRONOUS_IO_NONALERT
                                    | FILE_NON_DIRECTORY_FILE;

    Context.Attributes = uAttributes;
    MiniFileObject =  Nt5CscCreateFile (
                          NULL, //make him allocate
                          lpPath,
                          FALSE,
                          FILE_ATTRIBUTE_NORMAL,
                          CreateOptions,
                          FILE_OPEN,  //disposition
                          ShareAccess,
                          FILE_WRITE_ATTRIBUTES|SYNCHRONIZE,
                          Nt5CscSetAttributesContinuation,
                          &Context  //Continuation
                          );

     if (Context.Status != STATUS_SUCCESS) {
          SetLastNtStatusLocal(Context.Status);
          return(-1);
     }

     return(STATUS_SUCCESS);
}

NTSTATUS
Nt5CscSetAttributesContinuation (
    IN OUT PNT5CSC_MINIFILEOBJECT MiniFileObject,
    IN OUT PVOID ContinuationContext,
    IN     NTSTATUS CreateStatus
    )
{
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_BASIC_INFORMATION BasicInformation;
    PNT5CSC_ATTRIBS_CONTINUATION_CONTEXT Context
          = (PNT5CSC_ATTRIBS_CONTINUATION_CONTEXT)ContinuationContext;

    if (CreateStatus == STATUS_SUCCESS) {
        RtlZeroMemory(&BasicInformation,sizeof(BasicInformation));
        BasicInformation.FileAttributes = Context->Attributes;

        LoudCallsDbgPrint("SetAttrContinue",
                                MiniFileObject,
                                0xa1,0,0,0,0,0);

        Context->Status = ZwSetInformationFile(
                         MiniFileObject->NtHandle,  //IN HANDLE FileHandle,
                         &IoStatusBlock,            //OUT PIO_STATUS_BLOCK IoStatusBlock,
                         &BasicInformation,         //OUT PVOID FileInformation,
                         sizeof(BasicInformation),//IN ULONG Length,
                         FileBasicInformation      //IN FILE_INFORMATION_CLASS FileInformationClass
                         );

        LoudCallsDbgPrint("SetAttrContinueRR",
                                MiniFileObject,
                                0xa1,0,0,0,
                                Context->Status,IoStatusBlock.Information);

        NtClose(MiniFileObject->NtHandle);
    } else {
        Context->Status = CreateStatus;
    }
    return(STATUS_MORE_PROCESSING_REQUIRED);
}

ULONG  Nt5CscRenameLocalCalls = 0;
int
RenameFileLocal(
    LPSTR lpFrom,
    LPSTR lpTo
    )
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    UNICODE_STRING RenameName;
    ANSI_STRING FileNameAsAnsiString;
    ULONG UnicodeLength;
    PFILE_RENAME_INFORMATION RenameInformation=NULL;
    ULONG RenameInfoBufferLength;

    PNT5CSC_MINIFILEOBJECT MiniFileObject;
    ULONG ShareAccess,CreateOptions;
    NT5CSC_ATTRIBS_CONTINUATION_CONTEXT Context;

    Nt5CscRenameLocalCalls++;
    //DbgPrint("here in rename %s %s\n",lpFrom,lpTo);
    //ASSERT(!"here in rename");

    RtlInitAnsiString(&FileNameAsAnsiString, lpTo);
    UnicodeLength = RtlAnsiStringToUnicodeSize(&FileNameAsAnsiString);
    if ( UnicodeLength > MAXUSHORT ) {
        Status = STATUS_NAME_TOO_LONG;
        goto FINALLY;
    }
    RenameName.MaximumLength = (USHORT)(UnicodeLength);
    RenameName.Length = RenameName.MaximumLength - sizeof(UNICODE_NULL);

    RenameInfoBufferLength = FIELD_OFFSET(FILE_RENAME_INFORMATION,FileName[0])
                                       + UnicodeLength; //already contains the null
    RenameInformation = (PFILE_RENAME_INFORMATION)RxAllocatePoolWithTag(
                                PagedPool | POOL_COLD_ALLOCATION,
                                RenameInfoBufferLength,
                                RX_MISC_POOLTAG);
    if (RenameInformation==NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto FINALLY;
    }
    RenameInformation->ReplaceIfExists = TRUE;
    RenameInformation->RootDirectory = 0;
    RenameInformation->FileNameLength = RenameName.Length;
    RenameName.Buffer = &RenameInformation->FileName[0];
    Status = RtlAnsiStringToUnicodeString(
                &RenameName,
                &FileNameAsAnsiString,
                FALSE //this says don't allocate the string
                );
    if (Status!=STATUS_SUCCESS) {
        goto FINALLY;
    }

    RxDbgTrace( 0, Dbg, ("rename: file %s %wZ\n",lpFrom,&RenameName));
    //DbgPrint("rename: file %s %wZ\n",lpFrom,&RenameName);

    ShareAccess = FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;
    CreateOptions = FILE_SYNCHRONOUS_IO_NONALERT
                                    | FILE_NON_DIRECTORY_FILE;

    Context.RenameInformation = RenameInformation;
    Context.RenameInfoBufferLength = RenameInfoBufferLength;
    MiniFileObject =  Nt5CscCreateFile (
                          NULL, //make him allocate
                          lpFrom,
                          FALSE,
                          FILE_ATTRIBUTE_NORMAL,
                          CreateOptions,
                          FILE_OPEN,  //disposition
                          ShareAccess,
                          DELETE | SYNCHRONIZE,  //DesiredAccess,
                          Nt5CscRenameContinuation,
                          &Context  //Continuation
                          );
    Status = Context.Status;
    if (Status!=STATUS_SUCCESS) {
        DbgPrint("rename didn't work....%08lx,%08lx,%08lx\n",
                      Status,RenameInformation,RenameInfoBufferLength);
    }

FINALLY:
     if (RenameInformation != NULL) {
          RxFreePool(RenameInformation);
     }

     if (Status != STATUS_SUCCESS) {
          return(-1);
     }

     return(STATUS_SUCCESS);
}

NTSTATUS
Nt5CscRenameContinuation (
    IN OUT PNT5CSC_MINIFILEOBJECT MiniFileObject,
    IN OUT PVOID ContinuationContext,
    IN     NTSTATUS CreateStatus
    )
{
    IO_STATUS_BLOCK IoStatusBlock;
    PNT5CSC_ATTRIBS_CONTINUATION_CONTEXT Context
          = (PNT5CSC_ATTRIBS_CONTINUATION_CONTEXT)ContinuationContext;

    if (CreateStatus == STATUS_SUCCESS) {

        LoudCallsDbgPrint("Rename",
                                MiniFileObject,
                                0xa1,0,0,0,0,0);

        Context->Status = ZwSetInformationFile(
                         MiniFileObject->NtHandle,  //IN HANDLE FileHandle,
                         &IoStatusBlock,            //OUT PIO_STATUS_BLOCK IoStatusBlock,
                         Context->RenameInformation,         //OUT PVOID FileInformation,
                         Context->RenameInfoBufferLength,//IN ULONG Length,
                         FileRenameInformation      //IN FILE_INFORMATION_CLASS FileInformationClass
                         );

        LoudCallsDbgPrint("RenameRR",
                                MiniFileObject,
                                0xa1,0,0,0,
                                Context->Status,IoStatusBlock.Information);

        NtClose(MiniFileObject->NtHandle);
    } else {
        Context->Status = CreateStatus;
    }
    return(STATUS_MORE_PROCESSING_REQUIRED);
}

//=======================================================================================================
ULONG Nt5CscDeleteLocalCalls = 0;
int
DeleteFileLocal(
    LPSTR lpName,
    USHORT usAttrib
    )
{
    PNT5CSC_MINIFILEOBJECT MiniFileObject;
    ULONG ShareAccess,CreateOptions;
    NT5CSC_ATTRIBS_CONTINUATION_CONTEXT Context;

    Nt5CscDeleteLocalCalls++;
    ShareAccess = FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;
    CreateOptions = FILE_SYNCHRONOUS_IO_NONALERT;

    MiniFileObject =  Nt5CscCreateFile (
                          NULL, //make him allocate
                          lpName,
                          FALSE,
                          FILE_ATTRIBUTE_NORMAL,
                          CreateOptions,
                          FILE_OPEN,  //disposition
                          ShareAccess,
                          DELETE,  //DesiredAccess,
                          Nt5CscDeleteContinuation,
                          &Context  //Continuation
                          );

     if (Context.Status != STATUS_SUCCESS) {
          SetLastNtStatusLocal(Context.Status);
          return((Context.Status | 0x80000000)); // just so this becomes -ve
     }

     return(STATUS_SUCCESS);
}

NTSTATUS
Nt5CscDeleteContinuation (
    IN OUT PNT5CSC_MINIFILEOBJECT MiniFileObject,
    IN OUT PVOID ContinuationContext,
    IN     NTSTATUS CreateStatus
    )
{
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_DISPOSITION_INFORMATION DispositionInformation;
    PNT5CSC_ATTRIBS_CONTINUATION_CONTEXT Context
          = (PNT5CSC_ATTRIBS_CONTINUATION_CONTEXT)ContinuationContext;

    if (CreateStatus == STATUS_SUCCESS) {
        DispositionInformation.DeleteFile = TRUE;

        LoudCallsDbgPrint("Delete",
                                MiniFileObject,
                                0xa1,0,0,0,0,0);

        Context->Status = ZwSetInformationFile(
                         MiniFileObject->NtHandle,  //IN HANDLE FileHandle,
                         &IoStatusBlock,            //OUT PIO_STATUS_BLOCK IoStatusBlock,
                         &DispositionInformation,         //OUT PVOID FileInformation,
                         sizeof(DispositionInformation),//IN ULONG Length,
                         FileDispositionInformation      //IN FILE_INFORMATION_CLASS FileInformationClass
                         );

        if (Context->Status!=STATUS_SUCCESS) {
          DbgPrint("DeleteBad %08lx %08lx %08lx\n",
                                MiniFileObject,
                                Context->Status,IoStatusBlock.Information);
        }

        LoudCallsDbgPrint("DeleteRR",
                                MiniFileObject,
                                0xa1,0,0,0,
                                Context->Status,IoStatusBlock.Information);

        NtClose(MiniFileObject->NtHandle);
    } else {
        Context->Status = CreateStatus;
    }
    return(STATUS_MORE_PROCESSING_REQUIRED);
}

int
CreateDirectoryLocal(
    LPSTR   lpPath
    )
{

    PNT5CSC_MINIFILEOBJECT MiniFileObject;

    MiniFileObject =  Nt5CscCreateFile (
                         NULL, //make him allocate
                         lpPath,
                         FALSE,
                         FILE_ATTRIBUTE_NORMAL,
                         FILE_SYNCHRONOUS_IO_NONALERT | FILE_DIRECTORY_FILE,
                         FILE_OPEN_IF,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         GENERIC_READ | GENERIC_WRITE,
                         NULL,NULL  //Continuation
                         );


    if (MiniFileObject)
    {
        CloseFileLocal((CSCHFILE)MiniFileObject);
        return 0;
    }

    return -1;
}


CSCHFILE
FindFirstFileLocal(
    LPSTR   lpPath,
    _WIN32_FIND_DATAA   *lpFind32A
    )
{

    PNT5CSC_MINIFILEOBJECT MiniFileObject;

    MiniFileObject =  Nt5CscCreateFile (
                         NULL, //make him allocate
                         lpPath,
                         FALSE,
                         FILE_ATTRIBUTE_NORMAL,
                         FILE_SYNCHRONOUS_IO_NONALERT | FILE_DIRECTORY_FILE,
                         FILE_OPEN,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         GENERIC_READ | GENERIC_WRITE,
                         NULL,NULL  //Continuation
                         );


    if (MiniFileObject)
    {
        if (FindNextFileLocal(MiniFileObject, lpFind32A) < 0)
        {
            CloseFileLocal(MiniFileObject);
            MiniFileObject = NULL;
        }
    }
    return MiniFileObject;
}



int
FindNextFileLocal(
    CSCHFILE handle,
    _WIN32_FIND_DATAA   *lpFind32A
    )
{
    NTSTATUS Status;
    PNT5CSC_MINIFILEOBJECT MiniFileObject = (PNT5CSC_MINIFILEOBJECT)handle;
    PIRP irp,TopIrp;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_OBJECT DeviceObject;
    PFILE_OBJECT FileObject;
    NT5CSC_IRPCOMPLETION_CONTEXT IrpCompletionContext;
    ULONG ReturnedLength, MdlLength,Length;
    PFILE_BOTH_DIR_INFORMATION DirectoryInfo;
    IO_STATUS_BLOCK IoStatusBlock;

    IoStatusBlock.Information = 0;

    ASSERT (MiniFileObject);
    ASSERT_MINIRDRFILEOBJECT(MiniFileObject);

    FileObject = MiniFileObject->UnderlyingFileObject;
    ASSERT (FileObject);

    DeviceObject = IoGetRelatedDeviceObject( FileObject );
    ASSERT (DeviceObject);

    if (DeviceObject->Flags & DO_BUFFERED_IO) {
        //i cannot handle buffered_io devices....sigh
        SetLastNtStatusLocal(STATUS_INVALID_DEVICE_REQUEST);
        return -1;
    }

    irp = IoAllocateIrp( DeviceObject->StackSize, FALSE ); //why not charge???

    if (!irp) {
        SetLastNtStatusLocal(STATUS_INSUFFICIENT_RESOURCES);
        return -1;
    }

    // get info for win32 find data

    MdlLength = Length = sizeof(FILE_BOTH_DIR_INFORMATION)+ sizeof(WCHAR) * (MAX_PATH+1);
    DirectoryInfo = (PFILE_BOTH_DIR_INFORMATION)RxAllocatePoolWithTag(NonPagedPool, Length, RX_MISC_POOLTAG);

    if (!DirectoryInfo)
    {
        IoFreeIrp(irp);
        SetLastNtStatusLocal(STATUS_INSUFFICIENT_RESOURCES);
        return -1;

    }

    // Set current thread for IoSetHardErrorOrVerifyDevice.
    //

    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    // Get a pointer to the stack location of the first driver which will be
    // invoked.  This is where the function codes and the parameters are set.
    //

    irpSp = IoGetNextIrpStackLocation( irp );  //ok4ioget
    irpSp->MajorFunction = IRP_MJ_DIRECTORY_CONTROL;
    irpSp->MinorFunction = IRP_MN_QUERY_DIRECTORY;
    irpSp->FileObject = FileObject;            //ok4->FileObj
    IoSetCompletionRoutine(irp,
                           Nt5CscIrpCompletionRoutine,
                           &IrpCompletionContext,
                           TRUE,TRUE,TRUE); //call no matter what....

    irp->RequestorMode = KernelMode;
    irp->UserBuffer = DirectoryInfo;
    irpSp->Parameters.QueryDirectory.Length = Length;
    irpSp->Parameters.QueryDirectory.FileInformationClass = FileBothDirectoryInformation;
    irpSp->Parameters.QueryDirectory.FileIndex = 0;
    irpSp->Parameters.QueryDirectory.FileName = NULL;
    irpSp->Flags = SL_RETURN_SINGLE_ENTRY;

    irp->MdlAddress = IoAllocateMdl(
                         irp->UserBuffer,
                         MdlLength,
                         FALSE,FALSE,NULL);

    if (!irp->MdlAddress) {
        //whoops.......sorry..........
        IoFreeIrp(irp);
        RxFreePool(DirectoryInfo);
        SetLastNtStatusLocal(STATUS_INSUFFICIENT_RESOURCES);
        return(-1);
    }

    Status = STATUS_SUCCESS;

    MmBuildMdlForNonPagedPool(irp->MdlAddress);

    if (Status != STATUS_SUCCESS)
    {
        IoFreeIrp(irp);
        RxFreePool(DirectoryInfo);
        SetLastNtStatusLocal(Status);
        return(-1);
    }


    KeInitializeEvent(&IrpCompletionContext.Event,
                      NotificationEvent,
                      FALSE );

    //
    try {
        TopIrp = IoGetTopLevelIrp();
        IoSetTopLevelIrp(NULL); //tell the underlying guy he's all clear
        Status = IoCallDriver(DeviceObject,irp);
    } finally {
        IoSetTopLevelIrp(TopIrp); //restore my context for unwind
    }

    //RxDbgTrace (0, Dbg, ("  -->Status after iocalldriver %08lx(%08lx)\n",RxContext,Status));

    if (Status == (STATUS_PENDING)) {
        KeWaitForSingleObject( &IrpCompletionContext.Event,
                               Executive, KernelMode, FALSE, NULL );
        Status = irp->IoStatus.Status;
    }

    ReturnedLength = (ULONG)irp->IoStatus.Information;

    IoFreeMdl(irp->MdlAddress);
    IoFreeIrp(irp);
    if (Status==STATUS_SUCCESS) {

        // Attributes are composed of the attributes returned by NT.
        //

        lpFind32A->dwFileAttributes = DirectoryInfo->FileAttributes;
        lpFind32A->ftCreationTime = *(LPFILETIME)&DirectoryInfo->CreationTime;
        lpFind32A->ftLastAccessTime = *(LPFILETIME)&DirectoryInfo->LastAccessTime;
        lpFind32A->ftLastWriteTime = *(LPFILETIME)&DirectoryInfo->LastWriteTime;
        lpFind32A->nFileSizeHigh = DirectoryInfo->EndOfFile.HighPart;
        lpFind32A->nFileSizeLow = DirectoryInfo->EndOfFile.LowPart;
        lpFind32A->cAlternateFileName[0] = 0;
        lpFind32A->cFileName[0] = 0;



        Status = RtlUnicodeToOemN(
                        lpFind32A->cAlternateFileName,            //OUT PCH OemString,
                        sizeof(lpFind32A->cAlternateFileName),    //IN ULONG MaxBytesInOemString,
                        &ReturnedLength, //OUT PULONG BytesInOemString OPTIONAL,
                        DirectoryInfo->ShortName,            //IN PWCH UnicodeString,
                        DirectoryInfo->ShortNameLength    //IN ULONG BytesInUnicodeString
                        );
        if (Status == STATUS_SUCCESS)
        {
            lpFind32A->cAlternateFileName[ReturnedLength] = 0;
        }



        Status = RtlUnicodeToOemN(
                        lpFind32A->cFileName,            //OUT PCH OemString,
                        sizeof(lpFind32A->cFileName)-1,    //IN ULONG MaxBytesInOemString,
                        &ReturnedLength, //OUT PULONG BytesInOemString OPTIONAL,
                        DirectoryInfo->FileName,            //IN PWCH UnicodeString,
                        DirectoryInfo->FileNameLength    //IN ULONG BytesInUnicodeString
                        );

        if (Status == STATUS_SUCCESS)
        {
            lpFind32A->cFileName[ReturnedLength] = 0;
        }

        RxFreePool(DirectoryInfo);
        return(1);

    }
    else {
        RxFreePool(DirectoryInfo);
        SetLastNtStatusLocal(Status);
        return(-1);
    }
}


int
FindCloseLocal(
    CSCHFILE handle
    )
{
    CloseFileLocal(handle);
    return 1;
}

DWORD
GetLastErrorLocal(
    VOID
    )
{
    return(vGlobalWin32Error);
}

VOID
SetLastErrorLocal(
    DWORD   dwError
    )
{
    vGlobalWin32Error = dwError;
}

VOID
SetLastNtStatusLocal(
    NTSTATUS    Status
    )
{
    vGlobalWin32Error = RtlNtStatusToDosErrorNoTeb(Status);
}


#ifdef MRXSMBCSC_LOUDDOWNCALLS

VOID
LoudCallsDbgPrint(
    PSZ Tag,
    PNT5CSC_MINIFILEOBJECT MiniFileObject,
    ULONG MajorFunction,
    ULONG lCount,
    ULONG LowPart,
    ULONG HighPart,
    ULONG Status,
    ULONG Information
    )
{
    PCHAR op = "***";
    BOOLEAN Chase = TRUE;
    PFILE_OBJECT FileObject = MiniFileObject->UnderlyingFileObject;
    PSECTION_OBJECT_POINTERS SecObjPtrs;
    PULONG SharedCacheMap;

    if(!FlagOn(MiniFileObject->Flags,NT5CSC_MINIFOBJ_FLAG_LOUDDOWNCALLS)) {
        return;
    }

    switch (MajorFunction) {
    case IRP_MJ_READ:  op = "READ"; break;
    case IRP_MJ_WRITE:  op = "WRITE"; break;
    case IRP_MJ_QUERY_INFORMATION:  op = "QryInfo"; break;
    case IRP_MJ_SET_INFORMATION:  op = "SetInfo"; break;
    case 0xff:  op = "SPECIALWRITE"; break;
    default: Chase = FALSE;
    }

    DbgPrint("%s %s(%x) h=%lx[%lx]  %lx@%lx:%lx  st %x:%x\n",
                        Tag,op,MajorFunction,
                        MiniFileObject->NtHandle,
                        MiniFileObject->UnderlyingFileObject,
                        lCount,
                        LowPart,
                        HighPart,
                        Status,
                        Information
                        );
    if (!Chase) {
        return;
    }

    SecObjPtrs = FileObject->SectionObjectPointer;
    if (SecObjPtrs==NULL) {
        DbgPrint("       No SecObjPtrs\n");
        return;
    }

    SharedCacheMap = (PULONG)(SecObjPtrs->SharedCacheMap);
    if (SharedCacheMap==NULL) {
        DbgPrint("       No SharedCacheMap\n");
        return;
    }
    DbgPrint("       size per sharedcachemap %08lx %08lx\n",*(SharedCacheMap+2),*(SharedCacheMap+3));
}

#endif //ifdef MRXSMBCSC_LOUDDOWNCALLS

BOOL
CscAmIAdmin(
    VOID
    )
/*++

Routine Description:

    This routine checks to see whether the caller is in the admin group
    all the files in the database.

Notes:

    We check the access_rights of the caller against CscSecurityDescriptor, which gives WRITE access
    only to principals in the admin group.
    The caller must impersonate in order to make sure he is in the right context

--*/
{
    NTSTATUS                 status;
    SECURITY_SUBJECT_CONTEXT SubjectContext;
    ACCESS_MASK              GrantedAccess;
    GENERIC_MAPPING          Mapping = {   FILE_GENERIC_READ,
                                           FILE_GENERIC_WRITE,
                                           FILE_GENERIC_EXECUTE,
                                           FILE_ALL_ACCESS
                                       };
    BOOLEAN                  retval  = FALSE;
    
    SeCaptureSubjectContext( &SubjectContext );

    retval = SeAccessCheck( CscSecurityDescriptor,
                            &SubjectContext,
                            FALSE,
                            FILE_GENERIC_WRITE,
                            0,
                            NULL,
                            &Mapping,
                            UserMode,
                            &GrantedAccess,
                            &status );

    SeReleaseSubjectContext( &SubjectContext );
    return retval;
    
}

BOOL
GetFileSystemAttributes(
    CSCHFILE handle,
    ULONG *lpFileSystemAttributes
    )
/*++

Routine Description:

    This API returns the attributes of the filesystem for the file handle. This is the way various
    features such as stream bitmaps, encryption etc. be checked

Notes:


--*/
{
    FILE_FS_ATTRIBUTE_INFORMATION fsAttribInfo;
    DWORD returnLen;
    NTSTATUS Status;
    BOOL    fRet = TRUE;
    
    // Check if volume is NTFS and hence support
    // multiple streams
    Status = Nt5CscXxxInformation(
                        (PCHAR)IRP_MJ_QUERY_VOLUME_INFORMATION,
                        (PNT5CSC_MINIFILEOBJECT)handle,
                        FileFsAttributeInformation,
                        sizeof(FILE_FS_ATTRIBUTE_INFORMATION),
                        &fsAttribInfo,
                        &returnLen);

    if (!NT_ERROR(Status)) {
        *lpFileSystemAttributes = fsAttribInfo.FileSystemAttributes;
    }
    else
    {
        SetLastNtStatusLocal(Status);
        fRet = FALSE;
    }
    
    return fRet;    
}

BOOL
HasStreamSupport(
    CSCHFILE handle,
    BOOL    *lpfResult
    )
/*++

Routine Description:


Notes:


--*/
{
    ULONG ulFsAttributes;

    if (GetFileSystemAttributes(handle, &ulFsAttributes))
    {
        *lpfResult =  ((ulFsAttributes & FILE_NAMED_STREAMS) != 0);
        return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\record.mgr\daytona\nullincs.tmp\shell.h ===
//null .h file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\record.mgr\daytona\nullincs.tmp\vmmreg.h ===
//null .h file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\record.mgr\daytona\nullincs.tmp\vxdwraps.h ===
//null .h file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\record.mgr\daytona\nullincs.tmp\io.h ===
//null .h file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\record.mgr\daytona\nullincs.tmp\net32def.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

/********************************************************************/
/*                                                                  */
/* This file contains definition that are required to make a .h     */
/* file compatable with 32-bit compiler.                            */
/*                                                                  */
/* History:                                                         */
/*	Madana	 08/03/90	- Initial coding		    */
/*	DavidHov 12/14/90	- added #undef for C++		    */
/*								    */
/********************************************************************/

/*NOINC*/

#if !defined(WIN32)
#if !defined(NET32DEF_INCLUDED)
	#define NET32DEF_INCLUDED
	#if !defined(OS2DEF_INCLUDED)
		#if !defined(FLAT_DEF)
			#if !(defined(INCL_32) || defined(INCL_16))
				#if defined(M_I386) || _M_IX86 >= 300	/* compiler const. */
					#define	INCL_32
				#else
					#define	INCL_16
				#endif
			#endif /* INCL_32 || INCL_16 */
			#undef PASCAL
			#undef FAR
			#undef NEAR
			#undef APIENTRY
			#undef NEAR_APIENTRY
			#if defined(INCL_32)
				#define	PASCAL		/* null string */
				#define FAR		/* null string */
				#define NEAR		/* null string */
				#define	APIENTRY	_cdecl
				#define NEAR_APIENTRY	_cdecl
			#else
				#define PASCAL		_pascal
				#define FAR		_far
				#define NEAR		_near
				#define APIENTRY	FAR PASCAL
				#define NEAR_APIENTRY	_near PASCAL
			#endif /* INCL_32 */

			#define FLAT_DEF
		#endif /* ! FLAT_DEF */
	#else
		#if !defined(FLAT_DEF)
			#if defined(INCL_32)
				#define NEAR_APIENTRY	_cdecl
			#else
				#define NEAR_APIENTRY	_near PASCAL
			#endif

			#define FLAT_DEF
		#endif /* FLAT_DEF */
	#endif /* OS2DEF_INCLUDED */
#endif /* NET32DEF_INCLUDED */

#endif

/*INC*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\record.mgr\daytona\nullincs.tmp\ifs.h ===
/*****************************************************************/
/**			Microsoft DOS IFS Manager		 					**/
/**		 Copyright(c) Microsoft Corp., 1990-1993				**/
/*****************************************************************/
/* :ts=4 */

/*NOINC*/
#ifndef IFS_INC
#define IFS_INC 1
/*INC*/

/***	ifs.h - Installable File System definitions
 *
 *	This file contains the C function prototypes, structure declarations,
 *	type names, and constants which define the DOS installable file system
 *	interface.
 *
 *	All of these routines take a pointer to an IO request structure that
 *	is filled in with the parameters relevant for the request. The routines
 *	return some result info in the IO request struct. The particulars
 *	for each routine are given below the function prototype. All of the
 *	requests use ir_pid as the ID of the requesting process and return
 *	success/failure info in ir_error.
 */

/*NOINC*/
#ifndef FAR
	#if defined(M_I386) || _M_IX86 >= 300
		#define FAR
	#else
		#define FAR _far
	#endif
#endif
/*INC*/

#ifndef IFSMgr_Device_ID

#define IFSMgr_Device_ID    0x00040	/* Installable File System Manager */

#define IFSMgr_Init_Order   0x10000 + V86MMGR_Init_Order
#define FSD_Init_Order      0x00100 + IFSMgr_Init_Order

#else
/* ASM

ifdef MASM
	.errnz IFSMgr_Device_ID - 0040h
endif
*/
#endif

/* ASM
ifdef MASM
;*	Equ's for types that h2inc script cannot convert.
;	BUGBUG: These are kept here only because there are other ifsmgr include
;	files that still use the SED script and they depend on these definitions.
;	Ifs.h itself doesn't use them any more. Once the other include files have
;	been converted to use h2inc, these definitions will be removed.

ubuffer_t	equ	<dd>
pos_t		equ	<dd>
uid_t		equ	<db>
sfn_t		equ	<dw>
$F			equ	<dd>

	path_t		equ	<dd>
	string_t	equ	<dd>
	pid_t		equ	<dd>
	rh_t		equ	<dd>
	fh_t		equ	<dd>
	vfunc_t		equ	<dd>
	$P			equ	<dd>
	$I			equ	<dd>
	fsdwork struc
		dd	16 dup (?)
	fsdwork ends

endif
*/

#define IFS_VERSION	0x030A
#define IFS_REVISION	0x10

/**	Maximum path length - excluding nul	*/

#define MAX_PATH	260	/* Maximum path length - including nul */

/* Maximum length for a LFN name element - excluding nul */
#define LFNMAXNAMELEN	255


#define MAXIMUM_USERID	2		/* max. # of users that can be logged */
								/* on at the same time.  Ir_user must */
								/* always be less than MAXIMUM_USERID. */
#define NULL_USER_ID	0		/* special user id for operations when */
								/* not logged on. */

/* Status indications returned as errors: */

#define STATUS_PENDING	-1		/* request is pending */
#define STATUS_RAWLOCK	-2		/* rawlock active on session			*/
								/* (only returned for async requests,	*/
								/*  sync requests will wait for the raw */
								/*  lock to be released)				*/
#define STATUS_BUSY	-3			/* request can't be started because of */
								/* serialization.	*/

/**	ANYPROID - Any Provider ID
 */
#define ANYPROID	-1


/**	Common function defintions for NetFunction */
#define	NF_PROCEXIT			0x111D	/* Process Exit sent (ID = ANYPROID)	*/
#define NF_DRIVEUSE			0x0001	/* Drive Use Created (ID = ID of owner FSD) */
#define NF_DRIVEUNUSE		0x0002	/* Drive Use Broken (ID = ID of owner FSD) */
#define	NF_GETPRINTJOBID	0x0003	/* Get Print Job ID					*/
									/* ir_fh - ptr to master file info	*/
									/* ir_data - ptr to data buffer		*/
									/* ir_length - IN: buffer size		*/
									/*			  OUT: amount transfered*/
									/* ir_SFN - SFN of file handle		*/
#define NF_PRINTERUSE		0x0004	/* Printer Use Created (ID = ID of owner FSD) */
#define NF_PRINTERUNUSE		0x0005	/* Printer Use Broken (ID = ID of owner FSD) */
#define NF_NetSetUserName	0x1181

/** Flags passed to NetFunction */
#define WIN32_CALLFLAG		0x04	/* call is Win32 api */

/** Values for the different types of FSDs that can be registered: */
#define FSTYPE_LOCAL_FSD		0		// a local FSD
#define FSTYPE_NET_FSD			1		// a network FSD
#define FSTYPE_MAILSLOT_FSD		2		// a mailslot provider
#define FSTYPE_CHARACTER_FSD	3		// a character FSD

/** Force levels that can be specified on IFSMgr_DeregisterFSD apis. A
 *	description of the actions performed at the various levels as well as
 *	which FSD types can use which levels is given below. Note that if the
 *	api is called with a force level that is not valid for its FSD type,
 *	the call will be failed.
 *	
 *	Level	FSD Type  	Action
 *	-----	--------	------
 *	  0		Only net 	Clean only UNC with no open handles.
 *
 *	  1		Only net	Clean up UNC & net drives with no open handles.
 *
 *	  2		Net, local	Close open files. For net FSD, get rid of UNC, and
 *						net drives that are not current drives in a VM. For
 *						local FSD, get rid of drive if no errors closing files.
 *						It is irrelevant if it is the current drive in a VM.
 *
 *	  3		Net, local	Does everything at level 2. In addition, for CFSD and
 *			and CFSD	local FSD, blast resources ignoring all	errors. For net
 *						FSD, ignore if drive is current drive in VM.
 *
 *	  4		Net only	Do everything at level 3. In addition, get rid of
 *						static connections also.
 */
#define FORCE_LEV_UNC			0	// clean up UNC connections only
#define FORCE_LEV_USE			1	// clean up any net uses to drives
									// provided there are no open files
#define FORCE_LEV_CLOSE_FILES	2	// close any open files and clean up
#define FORCE_LEV_CLEANUP		3	// ignore errors closing open files, or
									// for net drives, if it is current drive
#define FORCE_LEV_BLAST			4	// only for net, clean up static
									// connections also

/** Priority levels that can be specifed for FSDs while registering.
 *	Priority levels can only be passed in on the new service
 *	IFSMgr_RegisterFSDWithPriority. A priority level of zero cannot be
 *	passed in, the IFSMgr automatically converts this to a default
 *	priority level.
 *
 *	For reference, the filesystem components have the following
 *	priorities:
 *
 *	VDEF:	FS_PRIORITY_LOWEST
 *	VFAT:	FS_PRIORITY_DEFAULT
 *	CDFS:	FS_PRIORITY_LOW
 */
 #define FS_PRIORITY_LOWEST		0x00	// lowest value, only for default FSD
 #define FS_PRIORITY_LOW		0x20	// low priority FSD
 #define FS_PRIORITY_DEFAULT	0x40	// default value for priority
 #define FS_PRIORITY_MEDIUM		0x80	// medium value of priority
 #define FS_PRIORITY_HIGH		0xC0	// high priority FSD
 #define FS_PRIORITY_HIGHEST	0x100	// max value of priority

 /** Attributes that describe the level of support provided by the FSD.
  *	 The ifsmgr uses these attributes to determine what kinds of functions
  *	 are supported by the FSD. Currently, it is used to indicate that the
  *	 FSD supports large-disk access i.e. disks > 2Gb in size.
  */

 #define FS_ATTRIB_WIN95COMPAT	0x00000000	// Win95 level of support
 #define FS_ATTRIB_LARGE_MEDIA	0x00000001	// Supports media > 2Gb


/*NOINC*/

/** Macros for handling status indications when returned as errors
 *
 *	REAL_ERROR - returns TRUE if there is a real error
 *				 returns FALSE for NO_ERROR or STATUS_????
 *	STATUS_ERROR - returns TRUE if error is actually a status indication
 */

#define REAL_ERROR(err) ((err) > 0)
#define STATUS_ERROR(err) ((err) < 0)

/*INC*/

/**
 *	The types for resource handles (rh_t), file handles (fh_t),
 *	and the file system driver work space (fsdwork_t) can be defined
 *	by the FSD.  The FSD's version of the type must be exactly the
 *	same size as the types defined below.  To declare your own
 *	version of these types: define a macros of the same name as
 *	any of the three types before including ifs.h.
 */

#ifndef rh_t
	typedef void *rh_t;		/* resource handle */
#endif
#ifndef fh_t
	typedef void *fh_t;		/* file handle */
#endif
#ifndef fsdwork_t
	typedef int fsdwork_t[16];	/* provider work space */
#endif

typedef unsigned short *string_t;	/* character string */
typedef unsigned short sfn_t;		/* system file number */
typedef unsigned long pos_t;		/* file position */
typedef unsigned int pid_t;			/* process ID of requesting task */
typedef void FAR *ubuffer_t;		/* ptr to user data buffer */
typedef unsigned char uid_t;		/* user ID for this request */

/* Parsed path structures are defined later in this file. */
typedef struct PathElement PathElement;
typedef struct ParsedPath ParsedPath;
typedef ParsedPath *path_t;

typedef struct ioreq ioreq;
typedef struct ioreq *pioreq;

/** dos_time - DOS time & date format */

typedef struct dos_time dos_time;
struct dos_time {
	unsigned short	dt_time;
	unsigned short	dt_date;
};	/* dos_time */


/** dos_time_rounded - DOS date/time returned by ifsgmr_GetDosTimeRounded */

typedef struct dos_time_rounded dos_time_rounded;
struct dos_time_rounded {
	unsigned short	dtr_time_rounded;
	unsigned short	dtr_date_rounded;
	unsigned short	dtr_time;
	unsigned short	dtr_date;
	unsigned char	dtr_time_msec;
};	/* dos_time_rounded */

typedef struct volfunc volfunc;
typedef struct volfunc *vfunc_t;
typedef struct hndlfunc hndlfunc;
typedef struct hndlfunc *hfunc_t;


typedef union aux_t {
	ubuffer_t		aux_buf;
	unsigned long	aux_ul;
	dos_time		aux_dt;
	vfunc_t			aux_vf;
	hfunc_t			aux_hf;
	void			*aux_ptr;
	string_t		aux_str;
	path_t			aux_pp;
	unsigned int	aux_ui;
} aux_t;


/* ASM
ifdef MASM

aux_data struc
  aux_dword	dd	?
aux_data ends

if @Version ge 600
	aux_ul 	textequ	<aux_data.aux_dword>
	aux_ui 	textequ	<aux_data.aux_dword>
	aux_vf 	textequ	<aux_data.aux_dword>
	aux_hf 	textequ	<aux_data.aux_dword>
	aux_ptr textequ	<aux_data.aux_dword>
	aux_str textequ	<aux_data.aux_dword>
	aux_pp 	textequ	<aux_data.aux_dword>
	aux_buf textequ	<aux_data.aux_dword>
	aux_dt	textequ	<aux_data.aux_dword>
else
	aux_ul 	equ	aux_dword
	aux_ui 	equ	aux_dword
	aux_vf 	equ	aux_dword
	aux_hf 	equ	aux_dword
	aux_ptr equ	aux_dword
	aux_str equ	aux_dword
	aux_pp 	equ	aux_dword
	aux_buf equ	aux_dword
	aux_dt	equ	aux_dword
endif

endif
*/

typedef struct event event;
typedef struct event *pevent;

struct ioreq {
	unsigned int	ir_length;	/* length of user buffer (eCX) */
	unsigned char	ir_flags;	/* misc. status flags (AL) */
	uid_t			ir_user;	/* user ID for this request */
	sfn_t			ir_sfn;		/* System File Number of file handle */
	pid_t			ir_pid;		/* process ID of requesting task */
	path_t			ir_ppath;	/* unicode pathname */
	aux_t			ir_aux1;	/* secondary user data buffer (CurDTA) */
	ubuffer_t		ir_data;	/* ptr to user data buffer (DS:eDX) */
	unsigned short	ir_options;	/* request handling options */
	short			ir_error;	/* error code (0 if OK) */
	rh_t			ir_rh;		/* resource handle */
	fh_t			ir_fh;		/* file (or find) handle */
	pos_t			ir_pos;		/* file position for request */
	aux_t			ir_aux2;	/* misc. extra API parameters */
	aux_t			ir_aux3;	/* misc. extra API parameters */
	pevent			ir_pev;		/* ptr to IFSMgr event for async requests */
	fsdwork_t		ir_fsd;		/* Provider work space */
};	/* ioreq */


/* misc. fields overlayed with other ioreq members: */

#define ir_size		ir_pos
#define ir_conflags	ir_pos		/* flags for connect */
#define ir_attr2	ir_pos		/* destination attributes for Rename */
#define ir_attr		ir_length	/* DOS file attribute info */
#define ir_pathSkip	ir_length	/* # of path elements consumed by Connect */
#define ir_lananum	ir_sfn		/* LanA to Connect on (0xFF for any net) */
#define ir_tuna		ir_sfn		/* Mount: FSD authorises IFSMGR tunneling */
#define ir_ptuninfo ir_data		/* Rename/Create: advisory tunneling info ptr */


/* Fields overlayed with ir_options: */

#define ir_namelen	ir_options
#define ir_sectors	ir_options	/* sectors per cluster */
#define ir_status	ir_options	/* named pipe status */


/* Fields overlayed with ir_aux1: */

#define ir_data2	ir_aux1.aux_buf	/* secondary data buffer */
#define ir_vfunc	ir_aux1.aux_vf	/* volume function vector */
#define ir_hfunc	ir_aux1.aux_hf	/* file handle function vector */
#define ir_ppath2	ir_aux1.aux_pp	/* second pathname for Rename */
#define ir_volh		ir_aux1.aux_ul	/* VRP address for Mount */


/* Fields overlayed with ir_aux2: */

#define ir_numfree	ir_aux2.aux_ul	/* number of free clusters */
#define ir_locklen	ir_aux2.aux_ul	/* length of lock region */
#define ir_msglen	ir_aux2.aux_ui	/* length of current message (peek pipe) */
									/* next msg length for mailslots */
#define ir_dostime	ir_aux2.aux_dt	/* DOS file date & time stamp */
#define ir_timeout	ir_aux2.aux_ul	/* timeout value in milliseconds */
#define ir_password	ir_aux2.aux_ptr	/* password for Connect */
#define ir_drvh		ir_aux2.aux_ptr	/* drive handle for Mount */
#define ir_prtlen	ir_aux2.aux_dt.dt_time	/* length of printer setup string */
#define ir_prtflag	ir_aux2.aux_dt.dt_date	/* printer flags */
#define ir_firstclus ir_aux2.aux_ul	/* First cluster of file */
#define ir_mntdrv	ir_aux2.aux_ul	/* driveletter for Mount */
#define ir_cregptr	ir_aux2.aux_ptr	/* pointer to client registers */
#define ir_uFName	ir_aux2.aux_str	/* case preserved filename */

/* Fields overlayed with ir_aux3: */

#define ir_upath	ir_aux3.aux_str	/* pointer to unparsed pathname */
#define ir_scratch	ir_aux3.aux_ptr	/* scratch buffer for NetFunction calls */

/* Fields overlayed with ir_user: */

#define	ir_drivenum	ir_user		/* Logical drive # (when mounting) */


/**	IFSFunc - general IFS functions
 */
typedef	int	_cdecl IFSFunc(pioreq pir);
typedef IFSFunc *pIFSFunc;

/** hndlfunc - I/O functions for file handles
 */

#define NUM_HNDLMISC	8

/*NOINC*/
/** IFSFileHookFunc - IFS file hook function
 */
typedef	int	_cdecl IFSFileHookFunc( pIFSFunc pfn, int fn, int Drive, int ResType, int CodePage, pioreq pir );
typedef	IFSFileHookFunc	*pIFSFileHookFunc;
typedef	pIFSFileHookFunc	*ppIFSFileHookFunc;
/*INC*/

typedef struct hndlmisc hndlmisc;

struct hndlfunc {
	pIFSFunc	hf_read;	/* file read handler function */
	pIFSFunc	hf_write;	/* file write handler function */
	hndlmisc	*hf_misc;	/* ptr to misc. function vector */
};	/* hndlfunc */


struct hndlmisc {
	short		hm_version;			/* IFS version # */
	char		hm_revision;		/* IFS interface revision # */
	char		hm_size;			/* # of entries in table */
	pIFSFunc	hm_func[NUM_HNDLMISC];
};	/* hndlmisc */

#define HM_SEEK			0			/* Seek file handle */
#define HM_CLOSE		1			/* close handle */
#define HM_COMMIT		2			/* commit buffered data for handle*/
#define HM_FILELOCKS	3			/* lock/unlock byte range */
#define HM_FILETIMES	4			/* get/set file modification time */
#define HM_PIPEREQUEST	5			/* named pipe operations */
#define HM_HANDLEINFO	6			/* get/set file information */
#define HM_ENUMHANDLE	7			/* enum filename from handle, lock info */

/**	volfunc - volume based api fucntions
 */

#define NUM_VOLFUNC	15

struct volfunc {
	short		vfn_version;		/* IFS version # */
	char		vfn_revision;		/* IFS interface revision # */
	char		vfn_size;			/* # of entries in table */
	pIFSFunc	vfn_func[NUM_VOLFUNC];/* volume base function handlers */
};	/* volfunc */

#define VFN_DELETE			0		/* file delete */
#define VFN_DIR				1		/* directory manipulation */
#define VFN_FILEATTRIB		2		/* DOS file attribute manipulation */
#define VFN_FLUSH			3		/* flush volume */
#define VFN_GETDISKINFO		4		/* query volume free space */
#define VFN_OPEN			5		/* open file */
#define VFN_RENAME			6		/* rename path */
#define VFN_SEARCH			7		/* search for names */
#define VFN_QUERY			8		/* query resource info (network only) */
#define VFN_DISCONNECT		9		/* disconnect from resource (net only) */
#define VFN_UNCPIPEREQ		10		/* UNC path based named pipe operations */
#define VFN_IOCTL16DRIVE	11		/* drive based 16 bit IOCTL requests */
#define VFN_GETDISKPARMS	12		/* get DPB */
#define VFN_FINDOPEN		13		/* open	an LFN file search */
#define VFN_DASDIO			14		/* direct volume access */


/** IFS Function IDs passed to IFSMgr_CallProvider */

#define IFSFN_READ			0		/* read a file */
#define IFSFN_WRITE			1		/* write a file */
#define IFSFN_FINDNEXT		2		/* LFN handle based Find Next */
#define IFSFN_FCNNEXT		3		/* Find Next Change Notify */

#define IFSFN_SEEK			10		/* Seek file handle */
#define IFSFN_CLOSE			11		/* close handle */
#define IFSFN_COMMIT		12		/* commit buffered data for handle*/
#define IFSFN_FILELOCKS		13		/* lock/unlock byte range */
#define IFSFN_FILETIMES		14		/* get/set file modification time */
#define IFSFN_PIPEREQUEST	15		/* named pipe operations */
#define IFSFN_HANDLEINFO	16		/* get/set file information */
#define IFSFN_ENUMHANDLE	17		/* enum file handle information */
#define IFSFN_FINDCLOSE		18		/* LFN find close */
#define IFSFN_FCNCLOSE		19		/* Find Change Notify Close */

#define IFSFN_CONNECT		30		/* connect or mount a resource */
#define IFSFN_DELETE		31		/* file delete */
#define IFSFN_DIR			32		/* directory manipulation */
#define IFSFN_FILEATTRIB	33		/* DOS file attribute manipulation */
#define IFSFN_FLUSH			34		/* flush volume */
#define IFSFN_GETDISKINFO	35		/* query volume free space */
#define IFSFN_OPEN			36		/* open file */
#define IFSFN_RENAME		37		/* rename path */
#define IFSFN_SEARCH		38		/* search for names */
#define IFSFN_QUERY			39		/* query resource info (network only) */
#define IFSFN_DISCONNECT	40		/* disconnect from resource (net only) */
#define IFSFN_UNCPIPEREQ	41		/* UNC path based named pipe operations */
#define IFSFN_IOCTL16DRIVE	42		/* drive based 16 bit IOCTL requests */
#define IFSFN_GETDISKPARMS	43		/* get DPB */
#define IFSFN_FINDOPEN		44		/* open	an LFN file search */
#define IFSFN_DASDIO		45		/* direct volume access */

/**	Resource types passed in on the File Hook: */
#define IFSFH_RES_UNC		0x01	/* UNC resource */
#define IFSFH_RES_NETWORK	0x08	/* Network drive connection */
#define IFSFH_RES_LOCAL		0x10	/* Local drive */
#define IFSFH_RES_CFSD		0x80	/* Character FSD */

/** values for ir_options to Connect:
 * Note that only one of RESOPT_UNC_REQUEST, RESOPT_DEV_ATTACH, and
 * RESOPT_UNC_CONNECT may be set at once.
 */

#define RESOPT_UNC_REQUEST	0x01	/* UNC-style path based request */
#define RESOPT_DEV_ATTACH	0x02	/* explicit redirection of a device */
#define RESOPT_UNC_CONNECT	0x04	/* explicit UNC-style use */
#define RESOPT_DISCONNECTED	0x08	/* Set up connection disconnected */
									/* (Don't touch net) */
#define RESOPT_NO_CREATE	0x10	/* don't create a new resource */
#define RESOPT_STATIC		0x20	/* don't allow ui to remove */

/** values for ir_flags to Connect:	*/
#define RESTYPE_WILD	0			/* wild card service type */
#define RESTYPE_DISK	1			/* disk resource */
#define RESTYPE_SPOOL	2			/* spooled printer */
#define RESTYPE_CHARDEV 3			/* character device */
#define RESTYPE_IPC		4			/* interprocess communication */

#define FIRST_RESTYPE	RESTYPE_DISK
#define LAST_RESTYPE	RESTYPE_IPC

/** values for ir_options to Close **/

#define RESOPT_NO_IO 0x01     /* no I/O allowed during the operation */

/** values for ir_flags for FSD operations */

#define IR_FSD_MOUNT		0		/* mount volume */
//OBSOLETE: #define IR_FSD_DISMOUNT 1			/* dismount volume */
#define IR_FSD_VERIFY		2		/* verify volume */
#define IR_FSD_UNLOAD		3		/* unload volume */
#define	IR_FSD_MOUNT_CHILD	4		/* mount child volume */
#define	IR_FSD_MAP_DRIVE	5		/* change drive mapping */
#define	IR_FSD_UNMAP_DRIVE	6		/* reset drive mapping */


/** Value for ir_error from IR_FSD_MOUNT if volume exists **/
#define ERROR_IFSVOL_EXISTS		284 /* mounted volume already exists */

/** Values returned in ir_tuna from IR_FSD_MOUNT (default IR_TUNA_NOTUNNEL) */
#define IR_TUNA_NOTUNNEL	0		/* Disable IFSMGR tunneling on volume */
#define IR_TUNA_FSDTUNNEL	0		/* FSD implements tunneling itself */
#define IR_TUNA_IFSTUNNEL	1		/* FSD requests IFSMGR tunneling support */

/** Values for IFSMgr_PNPVolumeEvent */
#define	PNPE_SUCCESS		0x00
#define PNPE_QUERY_ACCEPTED	0x00
#define PNPE_QUERY_REFUSED	0x01
#define PNPE_BAD_ARGS		0x02
#define PNPE_UNDEFINED		0xFF

/** Type values for IFSMgr_PNPEvent */
#define PNPT_VOLUME			0x10000000
#define PNPT_NET			0x20000000
#define PNPT_MASK	        0xF0000000

/** Values for ir_options returned from QueryResource:	*/
#define RESSTAT_OK		0			/* connection to resource is valid */
#define RESSTAT_PAUSED	1			/* paused by workstation */
#define RESSTAT_DISCONN 2			/* disconnected */
#define RESSTAT_ERROR	3			/* cannot be reconnected */
#define RESSTAT_CONN	4			/* first connection in progress */
#define RESSTAT_RECONN	5			/* reconnection in progress */



/** Values for ir_flags to HM_CLOSE:	*/

#define CLOSE_HANDLE		0		/* only closing a handle */
#define CLOSE_FOR_PROCESS	1		/* last close of SFN for this process */
#define CLOSE_FINAL			2		/* final close of SFN for system */

/** Values for ir_options to HM_CLOSE, HM_COMMIT, hf_read, hf_write:	*/
#define FILE_NO_LAST_ACCESS_DATE	0x01	/* do not update last access date */
#define FILE_CLOSE_FOR_LEVEL4_LOCK	0x02	/* special close on a level 4 lock */
#define FILE_COMMIT_ASYNC			0x04	/* commit async instead of sync */

#define FILE_FIND_RESTART	0x40	/* set for findnext w/key */
#define IOOPT_PRT_SPEC		0x80	/* ir_options flag for int17 writes */

/**	Values for ir_flags to VFN_DIR: */

#define CREATE_DIR	0
#define DELETE_DIR	1
#define CHECK_DIR	2
#define QUERY83_DIR	3
#define QUERYLONG_DIR	4


/**	ir_flags values for HM_FILELOCKS:	*/

#define LOCK_REGION		0			/* lock specified file region */
#define UNLOCK_REGION	1			/* unlock region */

/* Note: these values are also used by the sharing services */
/** ir_options values for HM_FILELOCKS:	*/

#define LOCKF_MASK_RDWR	0x01	/* Read / write lock flag */
#define LOCKF_WR		0x00	/* bit 0 clear - write lock */
#define LOCKF_RD		0x01	/* bit 0 set - read lock(NW only) */

#define LOCKF_MASK_DOS_NW	0x02	/* DOS/Netware style lock flag */
#define LOCKF_DOS			0x00	/* bit 1 clear - DOS-style lock */
#define LOCKF_NW			0x02	/* bit 1 set - Netware-style lock */

/** These values are used internally by the IFS manager only: */
#define LOCKF_MASK_INACTIVE	0x80	/* lock active/inactive flag */
#define LOCKF_ACTIVE		0x00	/* bit 7 clear - lock active */
#define LOCKF_INACTIVE		0x80	/* bit 7 set - lock inactive */

/** Values for ir_flags to VFN_PIPEREQUEST and HM_PIPEREQUEST:
 *	(NOTE: these values have been chosen to agree with the opcodes used
 *	by the TRANSACTION SMB for the matching operation.)
 */

#define PIPE_QHandState		0x21
#define PIPE_SetHandState	0x01
#define PIPE_QInfo			0x22
#define PIPE_Peek			0x23
#define PIPE_RawRead		0x11
#define PIPE_RawWrite		0x31
#define PIPE_Wait			0x53
#define PIPE_Call			0x54
#define PIPE_Transact		0x26


/** Values for ir_flags for HM_HANDLEINFO call: */

#define HINFO_GET			0		/* retrieve current buffering info */
#define HINFO_SETALL		1		/* set info (all parms) */
#define HINFO_SETCHARTIME	2		/* set handle buffer timeout */
#define HINFO_SETCHARCOUNT	3		/* set handle max buffer count */

/** Values for ir_flags for HM_ENUMHANDLE call: */
#define ENUMH_GETFILEINFO	0		/* get fileinfo by handle */
#define ENUMH_GETFILENAME	1		/* get filename associated with handle */
#define ENUMH_GETFINDINFO	2		/* get info for resuming */
#define ENUMH_RESUMEFIND	3		/* resume find operation */
#define ENUMH_RESYNCFILEDIR	4		/* resync dir entry info for file */

/** Values for ir_options for the ENUMH_RESYNCFILEDIR call: */
#define RESYNC_INVALIDATEMETACACHE	0x01	/* invalidate meta cache on resync */

/** Values for ir_flags for VFN_FILEATTRIB:				   	*/
/**														   	*/
/**	Note: All functions that modify the volume MUST be odd.	*/
/**       Callers rely on this & test the low order bit.   	*/

#define GET_ATTRIBUTES					0	/* get attributes of file/dir         */
#define SET_ATTRIBUTES					1	/* set attributes of file/dir         */

#define GET_ATTRIB_COMP_FILESIZE		2	/* get compressed size of file        */

#define SET_ATTRIB_MODIFY_DATETIME		3	/* set date last written of file/dir  */
#define GET_ATTRIB_MODIFY_DATETIME		4 	/* get date last written of file/dir  */
#define SET_ATTRIB_LAST_ACCESS_DATETIME	5 	/* set date last accessed of file/dir */
#define GET_ATTRIB_LAST_ACCESS_DATETIME	6	/* get date last accessed of file/dir */
#define SET_ATTRIB_CREATION_DATETIME	7	/* set create date of file/dir        */
#define GET_ATTRIB_CREATION_DATETIME	8	/* get create date of file/dir        */

#define GET_ATTRIB_FIRST_CLUST			9	/* get first cluster of a file        */

/** Values for ir_flags for VFN_FLUSH: */
#define GDF_NORMAL			0x00	/* walk disk, if needed, to get free space */
#define GDF_NO_DISK_HIT		0x01	/* return current "hint", don't walk disk */
#define GDF_R0_EXT_FREESPACE	0x80	/* extended free space call for Fat32 */

/** Values for ir_flags for HM_FILETIMES: */

#define GET_MODIFY_DATETIME		0	/* get last modification date/time */
#define SET_MODIFY_DATETIME		1	/* set last modification date/time */
#define GET_LAST_ACCESS_DATETIME 4	/* get last access date/time */
#define SET_LAST_ACCESS_DATETIME 5	/* set last access date/time */
#define GET_CREATION_DATETIME	6	/* get creation date/time */
#define SET_CREATION_DATETIME	7	/* set creation date/time */

/** Values for ir_flags for HM_SEEK: */

#define FILE_BEGIN	0				/* absolute posn from file beginning */
#define FILE_END	2				/* signed posn from file end */

/** Values for ir_flags for VFN_OPEN: */

#define ACCESS_MODE_MASK	0x0007	/* Mask for access mode bits */
#define ACCESS_READONLY		0x0000	/* open for read-only access */
#define ACCESS_WRITEONLY	0x0001	/* open for write-only access */
#define ACCESS_READWRITE	0x0002	/* open for read and write access */
#define ACCESS_EXECUTE		0x0003	/* open for execute access */

#define SHARE_MODE_MASK		0x0070	/* Mask for share mode bits */
#define SHARE_COMPATIBILITY 0x0000	/* open in compatability mode */
#define SHARE_DENYREADWRITE 0x0010	/* open for exclusive access */
#define SHARE_DENYWRITE		0x0020	/* open allowing read-only access */
#define SHARE_DENYREAD		0x0030	/* open allowing write-only access */
#define SHARE_DENYNONE		0x0040	/* open allowing other processes access */
#define SHARE_FCB			0x0070	/* FCB mode open */

/** Values for ir_options for VFN_OPEN: */

#define ACTION_MASK				0xff	/* Open Actions Mask */
#define ACTION_OPENEXISTING		0x01	/* open an existing file */
#define ACTION_REPLACEEXISTING	0x02	/* open existing file and set length */
#define ACTION_CREATENEW		0x10	/* create a new file, fail if exists */
#define ACTION_OPENALWAYS		0x11	/* open file, create if does not exist */
#define ACTION_CREATEALWAYS		0x12	/* create a new file, even if it exists */

/** Alternate method: bit assignments for the above values: */

#define ACTION_EXISTS_OPEN	0x01	// BIT: If file exists, open file
#define ACTION_TRUNCATE		0x02	// BIT: Truncate file
#define ACTION_NEXISTS_CREATE	0x10	// BIT: If file does not exist, create

/* these mode flags are passed in via ifs_options to VFN_OPEN */
/* NOTE: These flags also directly correspond to DOS flags passed in BX, the */
/* only exception being OPEN_FLAGS_REOPEN */

#define OPEN_FLAGS_NOINHERIT	0x0080
#define OPEN_FLAGS_NO_CACHE	R0_NO_CACHE /* 0x0100 */
#define OPEN_FLAGS_NO_COMPRESS	0x0200
#define OPEN_FLAGS_ALIAS_HINT	0x0400
#define OPEN_FLAGS_NOCRITERR	0x2000
#define OPEN_FLAGS_COMMIT		0x4000
#define OPEN_FLAGS_REOPEN		0x0800	/* file is being reopened on vol lock */

/* These open flags are passed in via ir_attr to VFN_OPEN: */
/* NOTE: The third byte in the dword of ir_attr is unused on VFN_OPEN */
#define OPEN_FLAGS_EXTENDED_SIZE	0x10000	/* open in "extended size" mode */
#define OPEN_EXT_FLAGS_MASK			0x00FF0000 /* mask for extended flags */

/** Values returned by VFN_OPEN for action taken: */
#define ACTION_OPENED		1		/* existing file has been opened */
#define ACTION_CREATED		2		/* new file has been created */
#define ACTION_REPLACED		3		/* existing file has been replaced */

/** Values for ir_flags for VFN_SEARCH: */
#define SEARCH_FIRST		0		/* findfirst operation */
#define SEARCH_NEXT			1		/* findnext operation */

/** Values for ir_flags for VFN_DISCONNECT: */
#define	DISCONNECT_NORMAL	0	/* normal disconnect */
#define	DISCONNECT_NO_IO	1	/* no i/o can happen at this time */
#define	DISCONNECT_SINGLE	2	/* disconnect this drive only */

/** Values for ir_options for VFN_FLUSH: */
#define	VOL_DISCARD_CACHE	1
#define	VOL_REMOUNT			2

/** Values for ir_options for VFN_GETDISKINFO: */
#define GDF_EXTENDED_FREESPACE	0x01	/* Extended get free space for Fat32 */

/** Values for ir_options for VFN_IOCTL16DRIVE: */
#define IOCTL_PKT_V86_ADDRESS		0	/* V86 pkt address in user DS:DX */
#define IOCTL_PKT_LINEAR_ADDRESS	1	/* Linear address to packet in ir_data */

/** Values for ir_options for VFN_GETDISKPARMS: */
#define GDP_EXTENDED_PARMS		0x01	/* Extended disk parms for Fat32 */

/** Values for ir_flags for VFN_DASDIO:	*/
#define DIO_ABS_READ_SECTORS 		0	/* Absolute disk read */
#define DIO_ABS_WRITE_SECTORS		1	/* Absolute disk write */
#define DIO_SET_LOCK_CACHE_STATE	2	/* Set cache state during volume lock */
#define DIO_SET_DPB_FOR_FORMAT		3	/* Set DPB for format for Fat32 */

/** Values for ir_options for DIO_ABS_READ_SECTORS and DIO_ABS_WRITE_SECTORS: */
#define ABS_EXTENDED_DASDIO			0x01	/* Extended disk read/write */

/**	Values for ir_options for DIO_SET_LOCK_CACHE_STATE: */
#define DLC_LEVEL4LOCK_TAKEN	0x01	/* cache writethru, discard name cache */
#define DLC_LEVEL4LOCK_RELEASED	0x02	/* revert to normal cache state */
#define DLC_LEVEL1LOCK_TAKEN	0x04	/* cache writethru, discard name cache */
#define DLC_LEVEL1LOCK_RELEASED	0x08	/* revert to normal cache state */

/* These values for ir_options are used only on ring 0 apis */
#define R0_NO_CACHE				0x0100	/* must not cache reads/writes */
#define R0_SWAPPER_CALL			0x1000	/* called by the swapper */
#define R0_LOADER_CALL			0x2000	/* called by program loader */
#define R0_MM_READ_WRITE		0x8000	/* indicates this is a MMF R0 i/o */
#define R0_SPLOPT_MASK			0xFF00	/* mask for ring 0 special options */


/** Values for ir_attr for different file attributes: */

#define FILE_ATTRIBUTE_READONLY		0x01	/* read-only file */
#define FILE_ATTRIBUTE_HIDDEN		0x02	/* hidden file */
#define FILE_ATTRIBUTE_SYSTEM		0x04	/* system file */
#define FILE_ATTRIBUTE_LABEL		0x08	/* volume label */
#define FILE_ATTRIBUTE_DIRECTORY	0x10	/* subdirectory */
#define FILE_ATTRIBUTE_ARCHIVE		0x20	/* archived file/directory */

/* The second byte of ir_attr is a mask of attributes which "must match"
 * on a SEARCH or FINDOPEN call.  If an attribute bit is set in the
 * "must match" mask, then the file must also have that attribute set
 * to match the search/find.
 */
#define FILE_ATTRIBUTE_MUSTMATCH	0x00003F00	/* 00ADVSHR Must Match */
#define FILE_ATTRIBUTE_EVERYTHING	0x0000003F	/* 00ADVSHR Find Everything */
#define FILE_ATTRIBUTE_INTERESTING	0x0000001E	/* 000DVSH0 Search bits */

/*   Auto-generation flags returned from CreateBasis()
 */
#define	BASIS_TRUNC			0x01	/* original name was truncated     */
#define	BASIS_LOSS			0x02	/* char translation loss occurred  */
#define	BASIS_UPCASE		0x04	/* char in basis was upcased       */
#define	BASIS_EXT			0x20	/* char in basis is extended ASCII */

/*   Flags that SHOULD associated with detecting 'collisions' in the basis name
 *   and the numeric tail of a basis name.  They are defined here so that routines
 *   who need to flag these conditions use these values in a way that does not
 *   conflict with the previous three 'basis' flags.
 */
#define	BASIS_NAME_COLL		0x08	/* collision in the basis name component   */
#define	BASIS_NUM_TAIL_COLL	0x10	/* collision in the numeric-tail component */

/*	Flags returned by long-name FindOpen/Findnext calls.  The flags
 *	indicate whether a mapping from UNICODE to BCS of the primary and
 *	altername names in the find buffer have lost information.  This
 *	occurs whenever a UNICODE char cannot be mapped into an OEM/ANSI
 *	char in the codepage specified.
 */

#define	FIND_FLAG_PRI_NAME_LOSS			0x0001
#define	FIND_FLAG_ALT_NAME_LOSS			0x0002

/*	Flags returned by UNIToBCS, BCSToUni, UniToBCSPath, MapUniToBCS
 *  MapBCSToUni.  The flags indicate whether a mapping from UNICODE
 *  to BCS, or BCS to UNICODE have lost information.  This occurs
 *	whenever a char cannot be mapped.
 */

#define MAP_FLAG_LOSS					0x0001
#define MAP_FLAG_TRUNCATE				0x0002


/*NOINC*/
#define TestMustMatch(pir, attr)	(((((pir)->ir_attr & (attr)<<8)	\
											^ (pir)->ir_attr)		\
										& FILE_ATTRIBUTE_MUSTMATCH) == 0)
/*INC*/

/* These bits are also set in ir_attr for specific properties of the
 * pathname/filename.
 *
 * A filename is 8.3 compatible if it contains at most 8 characters before
 * a DOT or the end of the name, at most 3 chars after a DOT, at most one
 * DOT, and no new LFN only characters.  The new LFN characters are:
 * , + = [ ] ;
 *
 * If a name does not meet all of the 8.3 rules above then it is considered
 * to be a "long file name", LFN.
 */
#define FILE_FLAG_WILDCARDS	0x80000000	/* set if wildcards in name */
#define FILE_FLAG_HAS_STAR	0x40000000	/* set if *'s in name (PARSE_WILD also set) */
#define FILE_FLAG_LONG_PATH	0x20000000	/* set if any path element is not 8.3 */
#define FILE_FLAG_KEEP_CASE	0x10000000	/* set if FSD should use ir_uFName */
#define FILE_FLAG_HAS_DOT	0x08000000	/* set if last path element contains .'s */
#define FILE_FLAG_IS_LFN	0x04000000	/* set if last element is LFN */

/* Function definitions on the ring 0 apis function list:
 * NOTE: Most functions are context independent unless explicitly stated
 * i.e. they do not use the current thread context. R0_LOCKFILE is the only
 * exception - it always uses the current thread context.
 */
#define R0_OPENCREATFILE		0xD500	/* Open/Create a file */
#define R0_OPENCREAT_IN_CONTEXT	0xD501	/* Open/Create file in current context */
#define R0_READFILE				0xD600	/* Read a file, no context */
#define R0_WRITEFILE			0xD601	/* Write to a file, no context */
#define R0_READFILE_IN_CONTEXT	0xD602	/* Read a file, in thread context */
#define R0_WRITEFILE_IN_CONTEXT	0xD603	/* Write to a file, in thread context */
#define R0_CLOSEFILE			0xD700	/* Close a file */
#define R0_GETFILESIZE			0xD800	/* Get size of a file */
#define R0_FINDFIRSTFILE		0x4E00	/* Do a LFN FindFirst operation */
#define R0_FINDNEXTFILE			0x4F00	/* Do a LFN FindNext operation */
#define R0_FINDCLOSEFILE		0xDC00	/* Do a LFN FindClose operation */
#define R0_FILEATTRIBUTES		0x4300	/* Get/Set Attributes of a file */
#define R0_RENAMEFILE			0x5600	/* Rename a file */
#define R0_DELETEFILE			0x4100	/* Delete a file */
#define R0_LOCKFILE				0x5C00	/* Lock/Unlock a region in a file */
#define R0_GETDISKFREESPACE		0x3600	/* Get disk free space */
#define R0_READABSOLUTEDISK		0xDD00	/* Absolute disk read */
#define R0_WRITEABSOLUTEDISK	0xDE00	/* Absolute disk write */

/* Special definitions for ring 0 apis for drive information flags */

#define IFS_DRV_RMM		0x0001	/* drive is managed by RMM */
#define IFS_DRV_DOS_DISK_INFO		0x0002	/* drive needs DOS */


/*NOINC*/

/**	SetHandleFunc - set up routing info for a file handle.
 *
 *NOTE: the do {} while(0) construction below is necessary to obtain proper
 *		behavior when this macro is used in if statement body. Do not
 *		add a ; to the while (0) line!
 *
 *	Entry	(pir) = ptr to IOReq structure for request
 *			(read) = ptr to IO Function for reading from file
 *			(write) = ptr to IO Function for writting to file
 *			(table) = ptr to table of misc. IO Functions
 */

#define SetHandleFunc(pir, read, write, table)	\
	do {								\
		hfunc_t phf = (pir)->ir_hfunc;	\
		phf->hf_read = (read);			\
		phf->hf_write = (write);		\
		phf->hf_misc = (table);			\
	} while (0)


/**	SetVolumeFunc - set up routing info for a volume
 *
 *	Entry	(pir) = ptr to ioreq struct
 *			(table) = ptr to table of provider Functions
 */

#define SetVolumeFunc(pir, table) ((pir)->ir_vfunc = (table))

/*INC*/


/** search - Search record structure
 *
 * This strucure defines the result buffer format for search returns
 * for int21h based file searches: 11H/12H FCB Find First/Next
 *	and 4eH/4fH path based Find First/Next
 *
 * There are two areas in the search_record reserved for use by file system
 * drivers. One is to be used by local file systems such as FAT or CDROM
 * and the other is to be used by network file systems such as an SMB or
 * NCP client. The reason for the split is because many network file
 * systems send and receive the search key directly on the net.
 */

typedef struct srch_key srch_key;
struct srch_key {
	unsigned char	sk_drive;		/* Drive specifier (set by IFS MGR) */
	unsigned char	sk_pattern[11];	/* Reserved (pattern sought) */
	unsigned char	sk_attr;		/* Reserved (attribute sought) */
	unsigned char	sk_localFSD[4];	/* available for use local FSDs */
	unsigned char	sk_netFSD[2];	/* available for use by network FSDs */
	unsigned char	sk_ifsmgr[2];	/* reserved for use by IFS MGR */
}; /* srch_key */


typedef struct srch_entry srch_entry;
struct srch_entry {
	struct srch_key se_key;		/* resume key */
	unsigned char	se_attrib;	/* file attribute */
	unsigned short	se_time;	/* time of last modification to file */
	unsigned short	se_date;	/* date of last modification to file */
	unsigned long	se_size;	/* size of file */
	char		se_name[13];	/* ASCIIZ name with dot included */
}; /* srch_entry */


/** Win32 Date Time structure
 * This structure defines the new Win32 format structure for returning the
 * date and time
 */

typedef struct _FILETIME _FILETIME;
struct _FILETIME {
	unsigned long	dwLowDateTime;
	unsigned long	dwHighDateTime;
}; /* _FILETIME */

/** Win32 Find Structure
 *  This structure defines the contents of the result buffer on a
 * Win32 FindFirst / FindNext. These calls are accessed by the new
 * LFN find apis
 */

typedef struct _WIN32_FIND_DATA _WIN32_FIND_DATA;
struct _WIN32_FIND_DATA {
	unsigned long		dwFileAttributes;
	struct _FILETIME	ftCreationTime;
	struct _FILETIME	ftLastAccessTime;
	struct _FILETIME	ftLastWriteTime;
	unsigned long		nFileSizeHigh;
	unsigned long		nFileSizeLow;
	unsigned long		dwReserved0;
	unsigned long		dwReserved1;
	unsigned short		cFileName[MAX_PATH];	/* includes NUL */
	unsigned short		cAlternateFileName[14];	/* includes NUL */
};	/* _WIN32_FIND_DATA */


/** Win32 File Info By Handle Structure
 *  This structure defines the contents of the result buffer on a
 *  Win32 FileInfoByHandle. These calls are accessed by the new
 *  LFN find apis
 */

typedef struct _BY_HANDLE_FILE_INFORMATION _BY_HANDLE_FILE_INFORMATION;
struct _BY_HANDLE_FILE_INFORMATION { /* bhfi */
	unsigned long		bhfi_dwFileAttributes;
	struct _FILETIME	bhfi_ftCreationTime;
    struct _FILETIME	bhfi_ftLastAccessTime;
	struct _FILETIME	bhfi_ftLastWriteTime;
	unsigned long		bhfi_dwVolumeSerialNumber;
	unsigned long		bhfi_nFileSizeHigh;
	unsigned long		bhfi_nFileSizeLow;
	unsigned long		bhfi_nNumberOfLinks;
	unsigned long		bhfi_nFileIndexHigh;
	unsigned long		bhfi_nFileIndexLow;
};	/* _BY_HANDLE_FILE_INFORMATION */


/* these are win32 defined flags for GetVolInfo */

#define	FS_CASE_IS_PRESERVED		0x00000002
#define	FS_UNICODE_STORED_ON_DISK	0x00000004

/* these flags for GetVolInfo are NOT defined */

#define	FS_VOL_IS_COMPRESSED		0x00008000
#define FS_VOL_SUPPORTS_LONG_NAMES	0x00004000


/* these flags are returned by IFSMgr_Get_Drive_Info	*/

#define	FDRV_INT13		0x01
#define	FDRV_FASTDISK	0x02
#define	FDRV_COMP		0x04
#define	FDRV_RMM		0x08
#define	FDRV_DOS		0x10
#define	FDRV_USE_RMM	0x20
#define	FDRV_COMPHOST	0x40
#define	FDRV_NO_LAZY	0x80


/** TUNINFO - Tunneling Information
 *	This structure defines the information passed into the FSD on
 *	a Create or Rename operation if tunneling was detected.  This
 *	gives a set of advisory information to create the new file with.
 *	if ir_ptuninfo is NULL on Create or Rename, none of this information
 *	is available.  All of this information is advisory.  tuni_bfContents
 *	defines what pieces of tunneling information are available.
 */

typedef struct	TUNINFO		TUNINFO;
struct TUNINFO {
	unsigned long		tuni_bfContents;
	short			   *tuni_pAltName;
	struct _FILETIME	tuni_ftCreationTime;
	struct _FILETIME	tuni_ftLastAccessTime;
	struct _FILETIME	tuni_ftLastWriteTime;
}; /* TUNINFO */

#define TUNI_CONTAINS_ALTNAME		0x00000001	/* pAltName available */
#define TUNI_CONTAINS_CREATIONT		0x00000002	/* ftCreationTime available */
#define TUNI_CONTAINS_LASTACCESST	0x00000004	/* ftLastAccessTime available */
#define TUNI_CONTAINS_LASTWRITET	0x00000008	/* ftLastWriteTime available */


/** _QWORD - 64-bit data type
 *  A struct used to return 64-bit data types to C callers
 *  from the qwUniToBCS & qwUniToBCS rotuines.  These
 *  'routines' are just alias' for UntoToBCS & UniToBCSPath
 *  routines and do not exist as separate entities.  Both
 *  routines always return a 64-bit result.  The lower
 *  32-bits are a length.  The upper 32-bits are flags.
 *  Typically, the flag returned indicates whether a mapping
 *  resulted in a loss on information in the UNICODE to BCS
 *  translation (i.e. a unicode char was converted to an '_').
 */

typedef struct _QWORD _QWORD;
struct _QWORD {
	unsigned long	ddLower;
	unsigned long	ddUpper;
}; /* _QWORD */


/** ParsedPath - structure of an IFSMgr parsed pathname */

struct PathElement {
	unsigned short	pe_length;
	unsigned short	pe_unichars[1];
}; /* PathElement */

struct ParsedPath {
	unsigned short	pp_totalLength;
	unsigned short	pp_prefixLength;
	struct PathElement pp_elements[1];
}; /* ParsedPath */


/** Macros to mainipulate parsed pathnames receieved from IFSMgr */

/*NOINC*/
#define IFSPathSize(ppath)	((ppath)->pp_totalLength + sizeof(short))
#define IFSPathLength(ppath) ((ppath)->pp_totalLength - sizeof(short)*2)
#define IFSLastElement(ppath)	((PathElement *)((char *)(ppath) + (ppath)->pp_prefixLength))
#define IFSNextElement(pel)	((PathElement *)((char *)(pel) + (pel)->pe_length))
#define IFSIsRoot(ppath)	((ppath)->pp_totalLength == 4)
/*INC*/

/** Function prototypes for IFSMgr services */

/* Values for charSet passed to character conversion routines */
#define BCS_WANSI	0	/* use Windows ANSI set */
#define BCS_OEM		1	/* use current OEM character set */
#define BCS_UNI		2	/* use UNICODE character set */


/*   Matching semantics flags passed to MetaMatchUni() */
#define UFLG_META	0x01
#define UFLG_NT		0x02
#define UFLG_NT_DOS	0x04
#define UFLG_DOS	0x00

/* define the utb and btu ptr table structures */

typedef struct CPPtrs CPPtrs;
struct CPPtrs {
	unsigned long	AnsiPtr;
	unsigned long	OEMPtr;
}; /* CPPtrs */


typedef struct	UnitoUpperTab UnitoUpperTab;
struct UnitoUpperTab {
	unsigned long	delta;
	unsigned	long	TabPtr;
}; /* UnitoUpperTab */
	
typedef struct	CPTablePtrs CPTablePtrs;
struct CPTablePtrs {
	unsigned long	CPT_Length;
	struct CPPtrs utbPtrTab;
	struct CPPtrs btuPtrTab;
	struct UnitoUpperTab UnitoUpperPtr;
}; /* CPTablePtrs */


/*NOINC*/
unsigned int  _cdecl UniToBCS(
					unsigned char	*pStr,
					string_t 		pUni,
					unsigned int	length,
					unsigned int	maxLength,
					unsigned int	charSet);


unsigned int UniToBCSPath(
					unsigned char	*pStr,
					PathElement		*pPth,
					unsigned int	maxLength,
					int				charSet);


_QWORD qwUniToBCS(
					unsigned char	*pStr,
					string_t 		pUni,
					unsigned int	length,
					unsigned int	maxLength,
					unsigned int	charSet);


_QWORD qwUniToBCSPath(
					unsigned char	*pStr,
					PathElement		*pPth,
					unsigned int	maxLength,
					int				charSet);


unsigned int  _cdecl BCSToUni(
					string_t		pUni,
					unsigned char	*pStr,
					unsigned int	length,
					int				charSet);


unsigned int UniToUpper(
					string_t		pUniUp,
					string_t		pUni,
					unsigned int	length);


unsigned int BCSToBCS (unsigned char *pDst,
                       unsigned char *pSrc,
                       unsigned int  dstCharSet,
                       unsigned int  srcCharSet,
                       unsigned int  maxLen);


unsigned int BCSToBCSUpper (unsigned char *pDst,
                       unsigned char *pSrc,
                       unsigned int  dstCharSet,
                       unsigned int  srcCharSet,
                       unsigned int  maxLen);


/* Map a single Unicode character to OEM
 *	Entry	(uniChar) - character to map
 *
 *	Returns	(oemChar) - character in OEM set
 *			  (if oemChar > 255, then DBCS character with
 *				lead byte in LSB and trail byte in next byte)
 */
unsigned int  _cdecl UniCharToOEM(unsigned short uniChar);


unsigned int IFSMgr_MetaMatch(
					string_t		pUniPat,
					string_t		pUni,
					int MatchSem);

/** IFSMgr_TransMatch - translate and match
 *
 *	The routine converts a DOS format 43 bytes search buffer into
 * _WIN32_FIND_DATA format and will optionally perform attribute and
 * pattern matching on the entry.
 *
 *	Entry	(pir) - ptr to ioreq structure
 *			  ir_attr - attribute value from FINDOPEN call.
 *			(pse) - ptr to DOS format search buffer
 *			(pattern) - ptr to Unicode pattern string (0 terminated)
 *			(pwf) - ptr to _WIN32_FIND_DATA structure to fill in
 *	Exit	!= 0 if match
 *			  ir_pos - value from sk_localFSD.
 *						(used for restarting finds)
 *			0 if no match
 */
int IFSMgr_TransMatch(
					pioreq		pir,
					srch_entry	*pse,
					string_t	pattern,
					_WIN32_FIND_DATA *pwf);


/** Time format conversion routines
 *
 *	These routines will convert from time/date information between
 * the various formats used and required by IFSMgr and FSDs.
 */

extern _FILETIME  _cdecl IFSMgr_DosToWin32Time(dos_time dt);

extern _FILETIME IFSMgr_NetToWin32Time(unsigned long time);

extern dos_time IFSMgr_Win32ToDosTime(_FILETIME ft);

extern dos_time IFSMgr_NetToDosTime(unsigned long time);

extern unsigned long IFSMgr_DosToNetTime(dos_time dt);

extern unsigned long IFSMgr_Win32ToNetTime(_FILETIME ft);


/** IFSMgr_CallProvider - call file system provider
 *
 *	The IFSMgr makes all calls to file system providers via this
 * service.  It is possible for a VxD to hook this service to monitor
 * file system operations.
 *
 *	Entry	(pir) - ptr to ioreq structure
 *			(fnID) - function ID (see IFSFN_* above)
 *			(ifn) - provider function being called
 *	Exit	return code from provider
 */
int IFSMgr_CallProvider(pioreq pir, int fnID, pIFSFunc ifn);

/* These definitions are used by MSNET32 for */
/* making DeviceIOControl calls to ifsmgr */

#define IFS_IOCTL_21				100
#define IFS_IOCTL_2F				101
#define	IFS_IOCTL_GET_RES			102
#define IFS_IOCTL_GET_NETPRO_NAME_A	103	

struct win32apireq {
	unsigned long 	ar_proid;
	unsigned long  	ar_eax;		
	unsigned long  	ar_ebx;	
	unsigned long  	ar_ecx;	
	unsigned long  	ar_edx;	
	unsigned long  	ar_esi;	
	unsigned long  	ar_edi;
	unsigned long  	ar_ebp;		
	unsigned short 	ar_error;
	unsigned short  ar_pad;
}; /* win32apireq */

/* This structure is passed to IFSMgr_UseAdd and */
/* IFSMgr_UseDel */

typedef struct netuse_info netuse_info;
struct netuse_info {
	void			*nu_data;
	int				nu_info;	/* del use only */
	unsigned long	nu_flags;
	unsigned long	nu_rsvd;	
};	/* netuse_info */

/* values for nu_flags */

#define FSD_NETAPI_USEOEM	0x00000001		/* strings are OEM */
#define FSD_NETAPI_STATIC	0x00000002		/* drive redirection can */
											/* only be removed at shutdown */
#define FSD_NETAPI_USELFN	0x00000004      /* treat remote name as lfn */
/*INC*/


struct fmode_t {			/* File mode information */
    unsigned long fm_uid;		/* User ID */
    void *fm_cookie0;			/* Caller-supplied cookie */
    void *fm_cookie1;			/* Caller-supplied cookie */
    unsigned short fm_mode;		/* File sharing mode and access */
    unsigned short fm_attr;		/* File attributes */
}; /* fmode_t */

typedef struct fmode_t fmode_t;		/* Type definition */

/*
 *	These flags are used on the Win32 service to duplicate an extended handle
 *
 */

#define DUP_NORMAL_HANDLE		0x00	// dup handle for normal file io
#define DUP_MEMORY_MAPPED		0x01	// dup handle for memory-mapping
#define DUP_MEM_MAPPED_WRITE	0x02 	// mem mapping is for write if set,
										// is for read if clear.
/*
 * These constants for the different subfunctions on NameTrans (7160h)
 *
 */

#define NAMTRN_NORMALQUERY		0x00	// normal LFN NameTrans operation
#define NAMTRN_DO83QUERY		0x01	// NameTrans to return full 8.3 name
#define NAMTRN_DOLFNQUERY		0x02	// NameTrans to return full LFN name

/*
 * These constants are used for the different subfunctions on Get List Of
 * Open Files (440dh, 086Dh)
 *
 */

#define ENUM_ALL_FILES			0x00	// enumerate all open files
#define ENUM_UNMOVEABLE_FILES	0x01	// enumerate only unmoveable files

/** Structure for the open file information from DOS to take over open files.
 */

typedef struct SFTOpenInfo SFTOpenInfo;
typedef struct SFTOpenInfo *pSFTOpenInfo;
struct SFTOpenInfo {
	unsigned long  soi_dirclus;		// cluster # for directory
	unsigned short soi_dirind;		// directory index of dir entry
	unsigned char  soi_dirname[11];	// directory entry name
	unsigned char  soi_pad[3];		// pad out for dword boundary
};	/* SFTOpenInfo */

/*NOINC*/

/** Win32DupHandle service and associated constants.
 */

extern int _cdecl Win32DupHandle( pid_t srcpid,
  								  pid_t duppid,
  								  unsigned long *phandle,
  								  unsigned char flag,
  								  unsigned long globNWHandle,
  								  unsigned long *fReturnFlags );

/** Values for fReturnFlags: */
#define WDUP_RMM_DRIVE		0x01			// file mapped on a RMM drive
#define WDUP_NETWARE_HANDLE	0x02			// handle belongs to Netware


#endif	/* IFS_INC */
/*INC*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\record.mgr\daytona\nullincs.tmp\netcons.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

/********************************************************************
 *                                                                  *
 *  About this file ...  NETCONS.H                                  *
 *                                                                  *
 *  This file contains constants used throughout the LAN Manager    *
 *  API header files.  It should be included in any source file     *
 *  that is going to include other LAN Manager API header files or  *
 *  call a LAN Manager API.                                         *
 *                                                                  *
 ********************************************************************/

/*
 *      NOTE:  Lengths of ASCIIZ strings are given as the maximum
 *      strlen() value.  This does not include space for the
 *      terminating 0-byte.  When allocating space for such an item,
 *      use the form:
 *
 *              char username[UNLEN+1];
 *
 *      An exception to this is the PATHLEN manifest, which does
 *      include space for the terminating 0-byte.
 */

/*NOINC*/
#ifndef NETCONS_INCLUDED

#include <net32def.h>

#define NETCONS_INCLUDED

//#ifndef RC_INVOKED
//#pragma pack(1)         /* Assume byte packing throughout */
//#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/*INC*/

#define CNLEN           15                  /* Computer name length     */
#define UNCLEN          (CNLEN+2)           /* UNC computer name length */
#define NNLEN           12                  /* 8.3 Net name length      */
#define RMLEN           (UNCLEN+1+NNLEN)    /* Maximum remote name length */

#define SNLEN           15                  /* Service name length      */
#define STXTLEN         63                  /* Service text length      */

/**INTERNAL_ONLY**/
#ifdef DOS3
#define PATHLEN         128
#else  /* DOS3 */

#define PATHLEN1_1      128
#define COMPLEN1_1      (8 + 1 + 3)     /* 8.3 */

/* Determine if the CCHMAXPATH manifest is defined (and use it).
 * If it isn't, then the source file in question isn't using OS2.H,
 * and we display a warning message.
 */
#ifdef CCHMAXPATH
#define PATHLEN         CCHMAXPATH
#else  /* CCHMAXPATH */
/**END_INTERNAL**/
#define PATHLEN         260
/**INTERNAL_ONLY**/
#endif /* CCHMAXPATH */
#endif /* DOS3 */

/* BUG20.7067 - We define MAXPATHLEN to be equivalent to PATHLEN.  This
 *          should be removed.
 */
#ifndef MAXPATHLEN
#define MAXPATHLEN      PATHLEN
#endif /* not MAXPATHLEN */
/**END_INTERNAL**/

#define DEVLEN           8                  /* Device name length       */

/**INTERNAL_ONLY**/
/* WARNING:  DNLEN must be the same as CNLEN.  We have a sanity check
 *           below which verifies this.
 */
/**END_INTERNAL**/
#define DNLEN           CNLEN               /* Maximum domain name length */
#define EVLEN           16                  /* event name length        */
#define JOBSTLEN        80                  /* status length in print job */
#define AFLEN           64                  /* Maximum length of alert  */
                                            /* names field              */
#define UNLEN           20                  /* Maximum user name length */
#define GNLEN           UNLEN               /* Group name               */
#define PWLEN           14                  /* Maximum password length  */
#define SHPWLEN          8                  /* Share password length    */
#define CLTYPE_LEN      12                  /* Length of client type string */


#define MAXCOMMENTSZ    48                  /* server & share comment length */

#define QNLEN           12                  /* Queue name maximum length     */
/**INTERNAL_ONLY**/
/*NOINC*/
#if (QNLEN != NNLEN)
# error QNLEN and NNLEN are not equal
#endif
/*INC*/
/**END_INTERNAL**/
#define PDLEN            8                  /* Print destination length      */
#define DTLEN            9                  /* Spool file data type          */
                                            /* e.g. IBMQSTD,IBMQESC,IBMQRAW  */
#define ALERTSZ         128                 /* size of alert string in server */
//#define MAXDEVENTRIES   (sizeof (int)*8)    /* Max number of device entries   */
#define MAXDEVENTRIES   32    				/* Max number of device entries   */
                                            /* We use int bitmap to represent */
#define MAXRDRSRVNAM    2               /* max names rdr/svr can use (not */
                                        /* including services) */

#define HOURS_IN_WEEK           24*7        /* for struct user_info_2 in UAS */
#define MAXWORKSTATIONS         8           /* for struct user_info_2 in UAS */

#define NETBIOS_NAME_LEN        16          /* NetBIOS net name */


/**INTERNAL_ONLY**/
#ifdef  USHRT_MAX
#define MAX_API_BUFFER_SIZE     USHRT_MAX
#else
#define MAX_API_BUFFER_SIZE     0xffff
#endif

#define WRKHEUR_COUNT           54

#define WORKBUFSIZE             4096

#define SMBANDXPAD              212         /* Added to each rdr & srv wrkbuf */
#define SMB_HDR_SZ              48          /* Added to each rdr & srv wrkbuf */

                                            /* WARNING: The following two    */
                                            /*  defines are dependent upon   */
                                            /*  rdr data structures!!!       */
#define RDR_SMB_LINK_SZ         8           /* Additional amount rdr adds to */
                                            /*  to each work buf             */
#define RDR_SMB_SEG_HD_SZ       20          /* Amount of rdr overhd per each */
                                            /*  workbuf segment              */

#define MAXSRVWRKSEGS           80          /* 64K segs for srv work bufs */
#define MAXRDRWRKSEGS           1           /* 64K segs for rdr work bufs */
#define MAXRDRBIGBUFSEGS        10          /* rdr 64K big buf segs */
/**END_INTERNAL**/

/*
 *      Constants used with encryption
 */

#define CRYPT_KEY_LEN   7
#define CRYPT_TXT_LEN   8
#define ENCRYPTED_PWLEN 16
#define SESSION_PWLEN   24
#define SESSION_CRYPT_KLEN 21

/*
 *  Value to be used with SetInfo calls to allow setting of all
 *  settable parameters (parmnum zero option)
*/
#ifndef  PARMNUM_ALL
#define         PARMNUM_ALL             0
#endif

/*
 *      Message File Names
 */

#define MESSAGE_FILE            "NETPROG\\NET.MSG"
#define MESSAGE_FILENAME        "NET.MSG"
#define OS2MSG_FILE             "NETPROG\\OSO001.MSG"
#define OS2MSG_FILENAME         "OSO001.MSG"
#define HELP_MSG_FILE           "NETPROG\\NETH.MSG"
#define HELP_MSG_FILENAME       "NETH.MSG"
#define OS2HELP_MSG_FILE        "NETPROG\\OSO001H.MSG"
#define OS2HELP_MSG_FILENAME    "OSO001H.MSG"
#define NMP_MSG_FILE            "NETPROG\\NMP.MSG"
#define NMP_MSG_FILENAME        "NMP.MSG"

#define MESSAGE_FILE_BASE       "NETPROG\\NET00000"
#define MESSAGE_FILE_EXT        ".MSG"

/**INTERNAL_ONLY**/

/* The backup message file named here is a duplicate of net.msg. It
 * is not shipped with the product, but is used at buildtime to
 * msgbind certain messages to netapi.dll and some of the services.
 * This allows for OEMs to modify the message text in net.msg and
 * have those changes show up.  Only in case there is an error in
 * retrieving the messages from net.msg do we then get the bound
 * messages out of bak.msg (really out of the message segment).
 */

#define BACKUP_MSG_FILENAME     "BAK.MSG"

/**END_INTERNAL**/


#define NMP_LOW_END             230
#define NMP_HIGH_END            240

#ifndef NULL
#define  NULL    0
#endif


/*NOINC*/
#define PUNAVAIL NULL
#define API_RET_TYPE unsigned

#ifndef DLLAPI

#ifdef IS_32

/* for 32-bit code, no extra stuff is needed for APIs (like __loadds). */
#define DLLAPI

#else // IS_32 not defined

#if defined(_WINDLL)

#define DLLAPI _loadds
#elif defined(BUILDDLL)
  #define DLLAPI _loadds
#else
#define DLLAPI

#endif // IS_32

#endif // _WINDLL

#endif // DLLAPI

#define API_FUNCTION API_RET_TYPE APIENTRY DLLAPI
/*INC*/


/**INTERNAL_ONLY**/
/*NOINC*/
/* Sanity check to verify that CNLEN == DNLEN */
#if (CNLEN != DNLEN)
#error CNLEN and DNLEN are not equal
#endif
/*INC*/
/**END_INTERNAL**/

typedef const unsigned char FAR * CPSZ ;

/* The following are stolen from OS2DEF.H and should be removed when
 * all references to the obsolete DOSCALLS.H are removed.
 */
#if ! defined(WIN32)
#define INT     int
typedef unsigned char BYTE;
typedef unsigned short USHORT;
typedef unsigned long ULONG;
typedef unsigned char FAR  *PSZ;
typedef USHORT FAR *PUSHORT;
typedef ULONG  FAR *PULONG;
typedef unsigned short SEL;
#endif

/**INTERNAL_ONLY**/

/********************************************************************
 *
 *      There are (at present) six (6) files which are processed
 *      by the mapmsg utility to create an input file for the os
 *      utility mkmsgf.  Each of these files has a non-overlapping
 *      range of MESSAGE numbers assigned to it.  In addtion, the
 *      file neterr.h has a range of ERROR numbers.  The error
 *      numbers do not overlap with the error numbers assigned to
 *      other os components.
 *
 *      The ERROR number range in neterr.h is 2100 to 2999.  The
 *      range 2750 - 2799 has been reserved for IBM.  The range
 *      2900 - 2999 has been reserved for other Microsoft OEMs.
 *
 *      The MESSAGE number range is as follow:
 *
 *      neterr.h:       the same as the error range, 2100-2999, with some
 *                      reserved for IBM, and some reserved for other
 *                      Microsoft OEMs.
 *      alertmsg.h:     3000 - 3049
 *      service.h:      3050 - 3099
 *      errlog.h:       3100 - 3299
 *      msgtext.h:      3300 - 3499
 *      apperr.h:       3500 - (where ever it chooses to stop)
 *
 *     WARNING *** WARNING *** WARNING
 *
 *   The redirector has hardcoded in its
 *   makefile some message numbers used
 *   at startup.  If you change MTXT_BASE
 *   or any of the redirs message numbers
 *   you must also fix the redir makefile
 *   where it generates netwksta.pro
 *
 ********************************************************************/

/**END_INTERNAL**/

/*NOINC*/
#ifdef __cplusplus
}
#endif	/* __cplusplus */

//#ifndef RC_INVOKED
//#pragma pack()          /* Revert to default packing */
//#endif

#endif /* NETCONS_INCLUDED */
/*INC*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\record.mgr\daytona\nullincs.tmp\neterr.h ===
//redirect this to the new name in sdkinc
//#include "lmerr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\record.mgr\daytona\nullincs.tmp\vmm.h ===
//null .h file so as not to confuse build
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\record.mgr\daytona\nullincs.tmp\use.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

/********************************************************************
 *								    *
 *  About this file ...  USE.H					    *
 *								    *
 *  This file contains information about the NetUse APIs.	    *
 *								    *
 *	Function prototypes.					    *
 *								    *
 *	Data structure templates.				    *
 *								    *
 *	Definition of special values.				    *
 *								    *
 *								    *
 *  NOTE:  You must include NETCONS.H before this file, since this  *
 *	   file	depends on values defined in NETCONS.H.		    *
 *								    *
 ********************************************************************/

/*NOINC*/
#ifndef NETUSE_INCLUDED

#define NETUSE_INCLUDED

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/*INC*/



/****************************************************************
 *                                                              *
 *              Function prototypes                             *
 *                                                              *
 ****************************************************************/

extern API_FUNCTION
  NetUseAdd ( const char FAR * pszServer,
              short            sLevel,
	      const char FAR * pbBuffer,
              unsigned short   cbBuffer );

extern API_FUNCTION
  NetUseDel ( const char FAR * pszServer,
	      const char FAR * pszDeviceName,
              unsigned short   usForce );

extern API_FUNCTION
  NetUseEnum ( const char FAR *     pszServer,
               short                sLevel,
	       char FAR *	    pbBuffer,
               unsigned short       cbBuffer,
	       unsigned short FAR * pcEntriesRead,
	       unsigned short FAR * pcTotalAvail );

extern API_FUNCTION
  NetUseGetInfo ( const char FAR *     pszServer,
		  const char FAR *     pszUseName,
                  short                sLevel,
		  char FAR *	       pbBuffer,
                  unsigned short       cbBuffer,
		  unsigned short FAR * pcbTotalAvail );

/**INTERNAL_ONLY**/
/*NOINC*/

/*
 * Private GetConnectionPerformance API
 */
extern API_FUNCTION
  NetUseGetPerformance(
	const char FAR *        usename,
	char FAR *              buffer);

//
typedef struct tagCONNPERFINFO  
{
   	char FAR *	remotename;
   	unsigned long		ticks;
   	unsigned long		nsec_per_byte;  
   	unsigned long		nsec_delay;     
} CONNPERFINFO;
typedef CONNPERFINFO*	 LPCONNPERFINFO;

/*INC*/
/**END_INTERNAL**/

/****************************************************************
 *								*
 *	  	Data structure templates			*
 *								*
 ****************************************************************/

/**INTERNAL_ONLY**/
/*NOINC*/
/* NOTE: the field pad_1 in the use_info_x structures is now being
 * used to convey some status information about the use. This info
 * currently contains current drive status and if the use was made
 * as guest at the remote machine.
 * The pad byte should not be removed without defining an alternate
 * location in which to return the information.
 */
/*INC*/
/**END_INTERNAL**/

struct use_info_0 {
    char	   ui0_local[DEVLEN+1];
    char	   ui0_pad_1;
    char FAR *	   ui0_remote;
};	/* use_info_0 */

struct use_info_1 {
    char	   ui1_local[DEVLEN+1];
    char	   ui1_pad_1;
/**INTERNAL_ONLY**/
/*NOINC*/
#if (((DEVLEN+1)%2) == 0)
# error  "PAD BYTE NOT NEEDED"
#endif
/*INC*/
/**END_INTERNAL**/
    char FAR *	   ui1_remote;
    char FAR *	   ui1_password;
    unsigned short ui1_status;
    short 	   ui1_asg_type;
    unsigned short ui1_refcount;
    unsigned short ui1_usecount;
};	/* use_info_1 */

#ifdef LM_3
/*NOINC*/

/* BUGBUG -- GUID is multiply defined and there should only be
 *	     one definition somewhere. When definition is formalized
 *	     this struct definition must be deleted and all references
 *	     to LM_GUID replaced with GUID.
 */
typedef struct _LM_GUID
{
	unsigned short	guid_uid;	  /* LM10 style user id */
	unsigned long	guid_serial;	  /* user record serial number */
	unsigned char	guid_rsvd[10];	  /* pad out to 16 bytes for now */
} LM_GUID;

struct use_info_2 {
    char	   ui2_local[DEVLEN+1];
    char	   ui2_pad_1;
/**INTERNAL_ONLY**/
/* NOINC*/
#if (((DEVLEN+1)%2) == 0)
# error  "PAD BYTE NOT NEEDED"
#endif
/* INC*/
/**END_INTERNAL**/
    char FAR *	   ui2_remote;
    char FAR *	   ui2_password;
    unsigned short ui2_status;
    short	   ui2_asg_type;
    unsigned short ui2_refcount;
    unsigned short ui2_usecount;
    unsigned short ui2_res_type;
    unsigned short ui2_flags;
    unsigned short ui2_usrclass;
    void FAR *	   ui2_dirname;
    struct _LM_GUID ui2_dfs_id;
};	/* use_info_2 */
/*INC*/
#endif /* LM_3 */

/****************************************************************
 *								*
 *	  	Special values and constants			*
 *								*
 ****************************************************************/


/*
 *  	Definitions for NetUseDel's last parameter
 */

#define USE_NOFORCE         	0
#define USE_FORCE           	1
#define USE_LOTS_OF_FORCE   	2
#ifdef LM_3
/**INTERNAL_ONLY**/
#define USE_LOGOFF_FORCE	3
/**END_INTERNAL**/
#endif /* LM_3 */


/*
 *	Values appearing in the ui1_status field of use_info_1 structure.
 *	Note that USE_SESSLOST and USE_DISCONN are synonyms.
 */

#define USE_OK			0
#define USE_PAUSED		1
#define USE_SESSLOST		2
#define USE_DISCONN		2
#define USE_NETERR		3
#define	USE_CONN		4
#define USE_RECONN		5


/*
 *	Values of the ui1_asg_type field of use_info_1 structure
 */

#define USE_WILDCARD  		-1
#define USE_DISKDEV   		0
#define USE_SPOOLDEV  		1
#define USE_CHARDEV   		2
#define USE_IPC 			3

#define USE_ADD_DISCONN 	128  /* flag used to add connection in */
								 /* disconnected state */
#ifdef LM_3
#define USE_DFS 		4

/*
 *	Values of the ui2_res_type field of use_info_2 structure
 */
#define USE_RES_UNC		1
#define USE_RES_DFS		2
#define USE_RES_DS		3

/*
 *	Values of the ui2_flags field of use_info_2 structure
 */
#define USE_AS_GUEST		0x01
#define USE_CURR_DRIVE		0x02
#define USE_PERM_CONN		0x04
/**INTERNAL_ONLY**/
#define USE_ADD_PERM_CONN	0x0100
/**END_INTERNAL**/
#endif /* LM_3 */

/**INTERNAL_ONLY**/
/*
 *  Values for the pad_byte hidden return info in the use_info_x structures.
 *  NOTE: the redir returns a word of flags, we have only a byte to return
 *	  info in, thus these defines may not be the same bits as those in
 *	  the word returned by the redir.
 */

#define     REDIR_USE_AS_GUEST	0x1000

#define     USE_AS_GUEST	0x01
#define     USE_CURR_DRIVE	0x02



/**END_INTERNAL**/

/*NOINC*/
#ifdef __cplusplus
}
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif

#endif /* NETUSE_INCLUDED */
/*INC*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\record.mgr\inc.tmp\shdcom.h ===
#error shdcom.h is no longer in recm\inc.tmp.....it's in csc\inc

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\record.mgr\umreclib\precomp.h ===
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include "shdsys.h"
#include "assert.h"
#include <winbase.h>
#include "shdcom.h"
#include "oslayeru.h"
#include "cscsec.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\record.mgr\umreclib\osutils.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

     Utils.c

Abstract:

     none.

Author:

     Shishir Pardikar      [Shishirp]        01-jan-1995

--*/

#include "precomp.h"
#pragma hdrstop


#define  SIGN_BIT 0x80000000
#define  UCHAR_OFFLINE  ((USHORT)'_')
#define  HIGH_ONE_SEC    0x98
#define  LOW_ONE_SEC     0x9680

#pragma intrinsic (memcmp, memcpy, memset, strcat, strcmp, strcpy, strlen)
#define cBackSlash    '\\'
#define cNull          0

char vrgchLibBuff[1024];
char vrgchLibBuff2[1024+25];
DWORD    dwDebugLogVector;
extern DWORD vdwAgentSessionId;

AssertData
AssertError

int HexToA(
     ULONG ulHex,
     LPSTR lpName,
     int count
     )
{
    int i;
    LPSTR lp = lpName+count-1;
    UCHAR uch;

    for (i=0; i<count; ++i)
     {
         uch = (UCHAR)(ulHex & 0xf) + '0';
         if (uch > '9')
               uch += 7;     // A becomes '0' + A + 7 which is 'A'
         *lp = uch;
         --lp;
         ulHex >>= 4;
     }
    *(lpName+count) = cNull;
    return 0;
}


ULONG AtoHex(
     LPSTR lpStr,
     int count
)
{
     int i;
     LPSTR lp = lpStr;
     UCHAR uch;
     ULONG ulHex = 0L;

     for (i=0; i<count; ++i)
      {
          // a fake shift the very first time
          ulHex <<= 4;
          uch = *lp;
          if (uch>= '0' && uch <= '9')
                ulHex += (uch - '0');
          else if (uch >= 'A' && uch <= 'F')
                ulHex += (uch - '0' - 7);
          else
                break;
          ++lp;
      }
     return ulHex;
 }


ULONG strmcpy( LPSTR lpDst,
	LPSTR lpSrc,
     ULONG cTchar
     )
 {
     ULONG i;

     if (!cTchar)
          return 0;
     for(i=cTchar;i;--i)
          if (!(*lpDst++ = *lpSrc++))
						     break;
     lpDst[cTchar-i] ='\0';

     return(cTchar-i);
 }

ULONG wstrlen(
     USHORT *lpuStr
     )
 {
     ULONG i;

     for (i=0; *lpuStr; ++lpuStr, ++i);
     return (i);
 }

int CompareSize(
     long nHighDst,
     long nLowDst,
     long nHighSrc,
     long nLowSrc
     )
 {
     int iRet = 0;

     if (nHighDst > nHighSrc)
          iRet = 1;
     else if (nHighDst == nHighSrc)
      {
          if (nLowDst > nLowSrc)
                iRet = 1;
          else if (nLowDst == nLowSrc)
                iRet = 0;
          else
                iRet = -1;
      }
     else
          iRet = -1;
     return (iRet);
 }


LPSTR mystrpbrk(
     LPSTR lpSrc,
     LPSTR lpDelim
     )
{
    char c, c1;
    LPSTR lpSav;
    BOOL fBegin = FALSE;

 for(;c = *lpSrc; ++lpSrc)
     {
         // skip leading blanks
         if (!fBegin)
           {
               if (c==' ')
                    continue;
               else
                    fBegin = TRUE;
           }

         lpSav = lpDelim;
         while (c1 = *lpDelim++)
           {
               if (c==c1)
                    return (lpSrc);
           }
         lpDelim = lpSav;
     }
    return (NULL);
}

LPVOID mymemmove(
     LPVOID     lpDst,
     LPVOID     lpSrc,
     ULONG size
     )
{
    int i;

    if (!size)
         return (lpDst);

    // if lpDst does not fall within the source array, just do memcpy
    if (!(
                ( lpDst > lpSrc )
                    && ( ((LPBYTE)lpDst) < ((LPBYTE)lpSrc)+size )     ))
     {
         memcpy(lpDst, lpSrc, size);
     }
    else
     {
         // do reverse copy
         for (i=size-1;i>=0;--i)
           {
               *((LPBYTE)lpDst+i) = *((LPBYTE)lpSrc+i);
           }
     }
    return (lpDst);
}


VOID
IncrementFileTime(
     FILETIME *lpft
    )
{
    DWORD dwTemp = lpft->dwLowDateTime;

    ++lpft->dwLowDateTime;

    // if it rolled over, there was a carry
    if (lpft->dwLowDateTime < dwTemp)
         lpft->dwHighDateTime++;

}

unsigned int
UniToBCS (
     unsigned char  *pStr,
     unsigned short *pUni,
     unsigned int length,
     unsigned int maxLength,
     int charSet
)
{
     BOOL fDefSet;

     UINT uCodePage = (charSet == BCS_OEM)?CP_OEMCP:CP_ACP;
     return(WideCharToMultiByte(uCodePage, WC_DEFAULTCHAR, pUni, length/2, pStr, maxLength, NULL, &fDefSet));
}

unsigned int
BCSToUni (
     unsigned short *pUni,
     unsigned char  *pStr,
     unsigned int length,
     int charSet
)
{
     UINT uCodePage = (charSet == BCS_OEM)?CP_OEMCP:CP_ACP;

     return (MultiByteToWideChar(uCodePage, MB_PRECOMPOSED, pStr, length, pUni, length));
}

VOID __cdecl AssertFn(LPSTR lpMsg, LPSTR lpFile, ULONG uLine)
{
   wsprintf(vrgchLibBuff, "Line %u file %s", uLine, lpFile);
   MessageBox(NULL, vrgchLibBuff, NULL, MB_OK);
}

VOID
__cdecl PrintFn(
    LPSTR lpFmt,
    ...
    )
{
    va_list base;

    va_start(base,lpFmt);

    wvsprintf(vrgchLibBuff, lpFmt, base);
    if (vdwAgentSessionId != 0xffff)
        sprintf(vrgchLibBuff2, "%05d:%s", vdwAgentSessionId, vrgchLibBuff);
    else
        sprintf(vrgchLibBuff2, "%s", vrgchLibBuff);
    OutputDebugString(vrgchLibBuff2);
}

int CompareTimes(
    FILETIME ftDst,
    FILETIME ftSrc
   )
{
    int iRet = 0;

    if (ftDst.dwHighDateTime > ftSrc.dwHighDateTime)
        iRet = 1;
    else if (ftDst.dwHighDateTime == ftSrc.dwHighDateTime)
    {
        if (ftDst.dwLowDateTime > ftSrc.dwLowDateTime)
            iRet = 1;
        else if (ftDst.dwLowDateTime == ftSrc.dwLowDateTime)
            iRet = 0;
        else
            iRet = -1;
    }
    else
        iRet = -1;
    return (iRet);
}


int DosToWin32FileSize( unsigned long uDosFileSize,
   int *lpnFileSizeHigh,
   int *lpnFileSizeLow
   )
   {
   int iRet;

   if (uDosFileSize & SIGN_BIT)
      {
      *lpnFileSizeHigh = 1;
      *lpnFileSizeLow = uDosFileSize & SIGN_BIT;
      iRet = 1;
      }
   else
      {
      *lpnFileSizeHigh = 0;
      *lpnFileSizeLow = uDosFileSize;
      iRet = 0;
      }
   return (iRet);
   }

int Win32ToDosFileSize( int nFileSizeHigh,
   int nFileSizeLow,
   unsigned long *lpuDosFileSize
   )
   {
   int iRet;
   Assert(nFileSizeHigh <= 1);
   *lpuDosFileSize = nFileSizeLow;
   if (nFileSizeHigh == 1)
      {
      *lpuDosFileSize += SIGN_BIT;
      iRet = 1;
      }
   else
      iRet = 0;
   return (iRet);
   }

int CompareTimesAtDosTimePrecision(
	FILETIME ftDst,
	FILETIME ftSrc
    )
{
	WORD wdateDst, wtimeDst;
	WORD wdateSrc, wtimeSrc;

	if (FileTimeToDosDateTime((CONST FILETIME *)&ftSrc, &wdateSrc, &wtimeSrc) &&
		FileTimeToDosDateTime((CONST FILETIME *)&ftDst, &wdateDst, &wtimeDst)
		)
	{
		if (wdateDst > wdateSrc)
		{
			return 1;
		}
		else if (wdateDst < wdateSrc)
		{
			return -1;
		}
		else
		{	// same dates
			if (wtimeDst > wtimeSrc)
			{
				return 1;
			}
			else if(wtimeDst < wtimeSrc)
			{
					return -1;
			}
			else
			{
				return 0;
			}
		}
	}
	return -1;

}



int
PUBLIC
mystrnicmp(
    const char *pStr1,
    const char *pStr2,
    unsigned count
    )
{
    char c1, c2;
    int iRet;
    unsigned i=0;

    for(;;)
    {
        c1 = *pStr1++;
        c2 = *pStr2++;
        c1 = _toupper(c1);
        c2 = _toupper(c2);
        if (c1!=c2)
            break;
        if (!c1)
            break;
        if (++i >= count)
            break;
    }
    iRet = ((c1 > c2)?1:((c1==c2)?0:-1));
    return iRet;
}

int ShadowLog(
    LPSTR lpFmt,
    ...
    )
{
    return (0);
}

int TerminateShadowLog(VOID)
{
    return 0;
}

BOOL
IterateOnUNCPathElements(
    USHORT  *lpuPath,
    PATHPROC lpfn,
    LPVOID  lpCookie
    )
/*++

Routine Description:

    This routine takes a unicode UNC path and iterates over each path element, calling the
    callback function. Thus for a path \\server\share\dir1\dir2\file1.txt, the function makes
    the following calls to the lpfn callback function

    (lpfn)(\\server\share, \\server\share, lpCookie)
    (lpfn)(\\server\share\dir1, dir1, lpCookie)
    (lpfn)(\\server\share\dir1\dir2, dir2, lpCookie)
    (lpfn)(\\server\share\dir1\dir2\file1, file1, lpCookie)

Arguments:

    lpuPath     NULL terminated unicode string (NOT NT style, just a plain unicode string)

    lpfn        callback function. If the function returns TRUE on a callback, the iteration
                proceeds, else it terminates

    lpCookie    context passed back on each callback

Returns:

    return TRUE if the entire iteration went through, FALSE if some error occurred or the callback
    function terminated the iteration

Notes:


--*/
{
    int cnt, cntSlashes=0, cbSize;
    USHORT  *lpuT, *lpuLastElement = NULL, *lpuCopy = NULL;
    BOOL    fRet = FALSE;

//    DEBUG_PRINT(("InterateOnUNCPathElements:Path on entry =%ws\r\n", lpuPath));

    if (!lpuPath || ((cnt = wstrlen(lpuPath)) <= 3))
    {
        return FALSE;
    }

    // check for the first two backslashes
    if (!(*lpuPath == (USHORT)'\\') && (*(lpuPath+1) == (USHORT)'\\'))
    {
        return FALSE;
    }

    // ensure that the server field is not NULL
    if (*(lpuPath+2) == (USHORT)'\\')
    {
        return FALSE;
    }

    cbSize = (wstrlen(lpuPath)+1) * sizeof(USHORT);

    lpuCopy = (USHORT *)AllocMem(cbSize);

    if (!lpuCopy)
    {
        return FALSE;
    }

    memcpy(lpuCopy, lpuPath, cbSize);

    cntSlashes = 2;

    lpuLastElement = lpuCopy;

    for (lpuT= lpuCopy+2;; ++lpuT)
    {
        if (*lpuT == (USHORT)'\\')
        {
            BOOL fContinue;

            ++cntSlashes;

            if (cntSlashes == 3)
            {
                if (lpuT == (lpuCopy+2))
                {
                    goto bailout;
                }

                continue;
            }

            *lpuT = 0;

            fContinue = (lpfn)(lpuCopy, lpuLastElement, lpCookie);

            *lpuT = (USHORT)'\\';

            if (!fContinue)
            {
                goto bailout;
            }

            lpuLastElement = (lpuT+1);
        }
        else if (!*lpuT)
        {
            (lpfn)(lpuCopy, lpuLastElement, lpCookie);
            break;
        }
    }

    fRet = TRUE;
bailout:

    if (lpuCopy)
    {
        FreeMem(lpuCopy);
    }
    return (fRet);
}

BOOL
IsPathUNC(
    USHORT      *lpuPath,
    int         cntMaxChars
    )
{
    USHORT *lpuT;
    int i, cntSlash=0;
    BOOL    fRet = FALSE;

    for(lpuT = lpuPath, i=0; (i < cntMaxChars) && *lpuT; lpuT++, ++i)
    {
        if (cntSlash <= 1)
        {
            // look for the first two backslashes
            if (*lpuT != (USHORT)'\\')
            {
                break;
            }

            ++cntSlash;
        }
        else if (cntSlash == 2)
        {
            // look for the 3rd one
            if (*lpuT == (USHORT)'\\')
            {
                if (((DWORD_PTR)lpuT - (DWORD_PTR)lpuPath) < 3)
                {
                    // NULL server field
                    break;
                }
                else
                {
                    ++cntSlash;
                }
            }
        }
        else    // all three slashes accounted for
        {
            Assert(cntSlash == 3);

            // if a non-slash character, then this path is OK
            fRet = (*lpuT != (USHORT)'\\');
            break;
        }
    }
    return (fRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\usermode\db\csc_bmpd.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    csc_bmpd.c

Abstract:

    This module implements the utility functions of bitmaps associated
    with CSC files specifically for the db application.  CSC_BMP_U is
    an opaque structure. Must use the functions here to
    create/modify/destroy a CSC_BMP_U to ensure data integrity.  The
    'd' in the filename means "db."

Author:

    Nigel Choi [t-nigelc]  Sept 3, 1999

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <assert.h>
#include <winbase.h>
#include "csc_bmpd.h"

// append this to inode file name to get the stream name
LPSTR CscBmpAltStrmName = STRMNAME;

/*++

    DBCSC_BitmapCreate()

Routine Description:

    Allocates an appropriate in-memory bitmap CSC_BITMAP_DB with size
    corresponding to filesize.

Arguments:


Returns:

    NULL if memory allocation error.
    pointer to the newly allocated bitmap if successful.

Notes:


--*/
LPCSC_BITMAP_DB
DBCSC_BitmapCreate(
    DWORD filesize)
{
    LPCSC_BITMAP_DB bm;
    DWORD i;

    bm = (LPCSC_BITMAP_DB)malloc(sizeof(CSC_BITMAP_DB));

    if (bm == NULL)
        return NULL;

    bm->bitmapsize = filesize/BLOCKSIZE;
    if (filesize % BLOCKSIZE)
        bm->bitmapsize++;
    bm->numDWORD = bm->bitmapsize/(8*sizeof(DWORD));
    if (bm->bitmapsize % (8*sizeof(DWORD)))
        bm->numDWORD++;

    if (bm->bitmapsize) {
        bm->bitmap = (LPDWORD)malloc(bm->numDWORD*sizeof(DWORD));
        if (bm->bitmap == NULL) {
            free(bm);
            return NULL;
        }
        for (i = 0; i < bm->numDWORD; i++) {
            bm->bitmap[i] = 0;
        }
    } else {
        bm->bitmap = NULL;
    }

    return bm;
}

/*++

    DBCSC_BitmapDelete()

Routine Description:

Arguments:

Returns:

Notes:

--*/
void
DBCSC_BitmapDelete(
    LPCSC_BITMAP_DB *lplpbitmap)
{
    if (lplpbitmap == NULL)
        return;
    if (*lplpbitmap == NULL)
        return;
    if ((*lplpbitmap)->bitmap)
        free((*lplpbitmap)->bitmap);
    free((*lplpbitmap));
    *lplpbitmap = NULL;
}

/*++

    DBCSC_BitmapIsMarked()

Routine Description:


Arguments:


Returns:

    -1 if lpbitmap is NULL or bitoffset is larger than the bitmap
    TRUE if the bit is marked
    FALSE if the bit is unmarked

Notes:

--*/
int
DBCSC_BitmapIsMarked(
    LPCSC_BITMAP_DB lpbitmap,
    DWORD bitoffset)
{
    DWORD DWORDnum;
    DWORD bitpos;

    if (lpbitmap == NULL)
        return -1;
    if (bitoffset >= lpbitmap->bitmapsize)
        return -1;

    DWORDnum = bitoffset/(8*sizeof(DWORD));
    bitpos = 1 << bitoffset%(8*sizeof(DWORD));

    if (lpbitmap->bitmap[DWORDnum] & bitpos)
        return TRUE;

    return FALSE;
}

/*++

    DBCSC_BitmapAppendStreamName()

Routine Description:

    Appends the CSC stream name to the existing path/file name fname.

Arguments:

    fname is the sting buffer containing the path/file.
    bufsize is the buffer size.

Returns:

    TRUE if append successful.
    FALSE if buffer is too small or other errors.

Notes:

    Single-byte strings only.

--*/
int
DBCSC_BitmapAppendStreamName(
    LPSTR fname,
    DWORD bufsize)
{
    int ret = TRUE;

    if ((strlen(fname) + strlen(CscBmpAltStrmName) + 1) > bufsize) {
        return FALSE;
    }

    __try {
        ret = TRUE;
        strcat(fname, CscBmpAltStrmName);
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        ret = FALSE;
    }

    return ret;
}

/*++

    DBCSC_BitmapRead()

Routine Description:

    Reads the on-disk bitmap file, and if it exists, is not in use and valid,
    store it in *lplpbitmap. If *lplpbitmap is NULL allocate a new
    bitmap data structure. Otherwise, if *lplpbitmap is not NULL, the
    existing bitmap will be deleted and assigned the on-disk bitmap
    file.

Arguments:

    filename is the file that contains the bitmap. If read from a
    stream, append the stream name before passing the filename in. The
    filename is used as is and no checking of validity of the name is
    performed. For default stream name, append the global LPSTR
    CscBmpAltStrmName.

Returns:

    1 if read successful
    0 if lplpbitmap is NULL
    -1 if error in disk operation (open/read), memory allocating error,
          or invalid bitmap file format.
    -2 if bitmap not exist

Notes:

    CODE.IMPROVEMENT design a better error message propagation mechanism.
    Bitmap open for exclusive access.

--*/
int
DBCSC_BitmapRead(
    LPCSC_BITMAP_DB *lplpbitmap,
    LPCTSTR filename)
{
    CscBmpFileHdr hdr;
    HANDLE bitmapFile;
    DWORD bytesRead;
    DWORD bitmapByteSize;
    DWORD * bitmapBuf = NULL;
    DWORD errCode;
    int ret = 1;

    if (lplpbitmap == NULL)
        return 0;

    bitmapFile = CreateFile(
                    filename,
                    GENERIC_READ,
                    0, // No sharing; exclusive
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL);
    if (bitmapFile == INVALID_HANDLE_VALUE) {
        errCode = GetLastError();
        if (errCode == ERROR_FILE_NOT_FOUND) {
            // File does not exist
            return -2;
        }
        return -1;
    }

    if (!ReadFile(
            bitmapFile,
            &hdr, 
            sizeof(CscBmpFileHdr),
            &bytesRead,
            NULL)
    ) {
        ret = -1;
        goto CLOSEFILE;
    }

    if (
        bytesRead != sizeof(CscBmpFileHdr)
            ||
        hdr.magicnum != MAGICNUM
            ||
        !hdr.valid
            ||
        hdr.inuse
    ) {
        ret = -1;
        goto CLOSEFILE;
    }

    printf(
            "---Header---\n"
            "MagicNum: 0x%x\n"
            "inuse: 0x%x\n"
            "valid: 0x%x\n"
            "sizeinbits:0x%x\n"
            "numDWORDS:0x%x\n",
                hdr.magicnum,
                hdr.inuse,
                hdr.valid,
                hdr.sizeinbits,
                hdr.numDWORDs);

    if (hdr.sizeinbits > 0) {
        bitmapByteSize = hdr.numDWORDs*sizeof(DWORD);
        bitmapBuf = (DWORD *)malloc(bitmapByteSize);
        if (!bitmapBuf) {
            ret = -1;
            goto CLOSEFILE;
        }

        if (!ReadFile(
                bitmapFile,
                bitmapBuf,
                bitmapByteSize,
                &bytesRead,
                NULL)
        ) {
            ret = -1;
            goto CLOSEFILE;
        }

        if (bytesRead != bitmapByteSize) {
            ret = -1;
            goto CLOSEFILE;
        }
    }

    if (*lplpbitmap) {
        // bitmap exist, dump old and create new
        if ((*lplpbitmap)->bitmap)
            free((*lplpbitmap)->bitmap);
        (*lplpbitmap)->bitmap = bitmapBuf;
        (*lplpbitmap)->numDWORD = hdr.numDWORDs;
        (*lplpbitmap)->bitmapsize = hdr.sizeinbits;
    } else {
        // bitmap not exist, create brand new
        *lplpbitmap = (LPCSC_BITMAP_DB)malloc(sizeof(CSC_BITMAP_DB));
        if (!(*lplpbitmap)) {
            // Error in memory allocation
            ret = -1;
            goto CLOSEFILE;
        }
        (*lplpbitmap)->bitmap = bitmapBuf;
        (*lplpbitmap)->numDWORD = hdr.numDWORDs;
        (*lplpbitmap)->bitmapsize = hdr.sizeinbits;
    }

CLOSEFILE:
    CloseHandle(bitmapFile);

    return ret;
}

/*++

    DBCSC_BitmapOutput()

Routine Description:

    Outputs the passed in bitmap to the ouput file stream outStrm

Arguments:


Returns:


Notes:


--*/
void
DBCSC_BitmapOutput(
    FILE * outStrm,
    LPCSC_BITMAP_DB lpbitmap)
{
    DWORD i;

    if (lpbitmap == NULL) {
        fprintf(outStrm, "lpbitmap is NULL\n");
        return;
    }

    fprintf(outStrm, "lpbitmap 0x%08x, bitmapsize %u, numDWORD %u\n",
                (ULONG_PTR)lpbitmap, lpbitmap->bitmapsize, lpbitmap->numDWORD);
                fprintf(outStrm, "bitmap  |0/5        |1/6        |2/7        |3/8        |4/9\n");
    fprintf(outStrm, "number  |01234|56789|01234|56789|01234|56789|01234|56789|01234|56789");
    for (i = 0; i < lpbitmap->bitmapsize; i++) {
        if ((i % 50) == 0)
            fprintf(outStrm, "\n%08d", i);
        if ((i % 5) == 0)
            fprintf(outStrm, "|");
        fprintf(outStrm, "%1d", DBCSC_BitmapIsMarked(lpbitmap, i));
    }
    fprintf(outStrm, "\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\record.mgr\umreclib\oslayeru.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

     OsLayer.c

Abstract:

     none.

Author:

     Shishir Pardikar      [Shishirp]        01-jan-1995

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

/********************** global data *****************************************/

AssertData;
AssertError;
/********************** function prototypes *********************************/

/****************************************************************************/

/************************ File I/O ******************************************/


CSCHFILE
R0OpenFileEx(
    USHORT  usOpenFlags,
    UCHAR   bAction,
    ULONG   ulAttr,
    LPSTR   lpPath,
    BOOL    fInstrument
    )
{
    HANDLE hf;
    DWORD   DesiredAccess=0, CreateOptions=0, FlagsAndAttributes=ulAttr;

    Assert( (usOpenFlags & 0xf) == ACCESS_READWRITE);

    DesiredAccess = GENERIC_READ | GENERIC_WRITE;

    if (usOpenFlags & OPEN_FLAGS_COMMIT)
    {
       FlagsAndAttributes |= FILE_FLAG_WRITE_THROUGH;
    }

    switch (bAction) {
    case ACTION_CREATEALWAYS:
          CreateOptions = CREATE_ALWAYS;
          break;

    case ACTION_OPENALWAYS:
         CreateOptions = OPEN_ALWAYS;
         break;

    case ACTION_OPENEXISTING:
         CreateOptions = OPEN_EXISTING;
         break;

   default:
       CreateOptions = OPEN_EXISTING;
       break;

    }
#if 0
    if (fInstrument)
    {
        BEGIN_TIMING(KeAttachProcess_R0Open);
    }
    if (fInstrument)
    {
        END_TIMING(KeAttachProcess_R0Open);
    }

    if (fInstrument)
    {
        BEGIN_TIMING(IoCreateFile_R0Open);
    }
#endif


    hf = CreateFileA(    lpPath,
                        DesiredAccess,
                        FILE_SHARE_READ|FILE_SHARE_WRITE,
                        NULL,
                        CreateOptions,
                        FlagsAndAttributes,
                        NULL
                   );
    if (hf == INVALID_HANDLE_VALUE)
    {
        hf = 0;
    }

#if 0
    if (fInstrument)
    {
        END_TIMING(IoCreateFile_R0Open);
    }
#endif

    if (hf == INVALID_HANDLE_VALUE)
    {
        hf = 0;
    }
#if 0
    if (fInstrument)
    {
        BEGIN_TIMING(KeDetachProcess_R0Open);
    }
    if (fInstrument)
    {
        END_TIMING(KeDetachProcess_R0Open);
    }
#endif
    return (CSCHFILE)hf;
}

CSCHFILE
CreateFileLocal(
    LPSTR lpFile
    )
{
    HANDLE hf;

    hf = CreateFileA(lpFile,
                                            GENERIC_READ|GENERIC_WRITE,
                                            FILE_SHARE_READ|FILE_SHARE_WRITE,
                                            NULL,
                                            CREATE_ALWAYS,
                                            0,
                                            NULL);
    if (hf == INVALID_HANDLE_VALUE)
    {
        hf = 0;
    }

    return ((CSCHFILE)hf);
}

CSCHFILE
OpenFileLocal(
    LPSTR lpFile
    )
{
    HANDLE hf;

    hf = CreateFileA(lpFile,
                                            GENERIC_READ|GENERIC_WRITE,
                                            FILE_SHARE_READ|FILE_SHARE_WRITE,
                                            NULL,
                                            OPEN_EXISTING,
                                            0,
                                            NULL);
    if (hf == INVALID_HANDLE_VALUE)
    {
        hf = 0;
    }

    return ((CSCHFILE)hf);
}

ULONG CloseFileLocal(
    CSCHFILE hf
    )
{
    CloseHandle((HANDLE)hf);
    return (1);
}

ULONG CloseFileLocalFromHandleCache(
    CSCHFILE hf
    )
{
    CloseHandle((HANDLE)hf);
    return (1);
}


long ReadFileLocal(
    CSCHFILE hf,
    unsigned long lSeek,
    LPVOID    lpBuff,
    long    cLength
    )
{
    DWORD dwBytesRead;

    if (SetFilePointer((HANDLE)hf, lSeek, NULL, FILE_BEGIN) != lSeek)
        return (-1);

    if(ReadFile((HANDLE)hf, lpBuff, (DWORD)cLength, &dwBytesRead, NULL))
    {
        return ((int)dwBytesRead);
    }
    return (-1);
}

long ReadFileLocalEx(
    CSCHFILE      hf,
    unsigned    long lSeek,
    LPVOID      lpBuff,
    long         cLength,
    BOOL        fInstrument
    )
{
    DWORD dwBytesRead;

    if (SetFilePointer((HANDLE)hf, lSeek, NULL, FILE_BEGIN) != lSeek)
        return (-1);

    if(ReadFile((HANDLE)hf, lpBuff, (DWORD)cLength, &dwBytesRead, NULL))
    {
        return ((int)dwBytesRead);
    }

    return (-1);
}

long ReadFileLocalEx2(
    CSCHFILE      hf,
    unsigned    long lSeek,
    LPVOID      lpBuff,
    long         cLength,
    ULONG       flags
    )
{
    return ReadFileLocalEx(hf, lSeek, lpBuff, cLength, FALSE);
}

long WriteFileLocal(
    CSCHFILE hf,
    unsigned long lSeek,
    LPVOID    lpBuff,
    long    cLength
    )
{
    unsigned long dwBytesRead;

    if (SetFilePointer((HANDLE)hf, lSeek, NULL, FILE_BEGIN) != lSeek)
        return (-1);

    if(WriteFile((HANDLE)hf, lpBuff, (DWORD)cLength, &dwBytesRead, NULL))
    {
        if ((DWORD)cLength == dwBytesRead)
        {
            return ((int)dwBytesRead);
        }
    }
    return (-1);
}

long WriteFileLocalEx(
    CSCHFILE hf,
    unsigned long lSeek,
    LPVOID    lpBuff,
    long    cLength,
    BOOL    fInstrument
    )
{
    fInstrument;
    return(WriteFileLocal(hf, lSeek, lpBuff, cLength));
}

long WriteFileLocalEx2(
    CSCHFILE      hf,
    unsigned    long lSeek,
    LPVOID      lpBuff,
    long         cLength,
    ULONG       flags
    )
{
    return WriteFileLocalEx(hf, lSeek, lpBuff, cLength, FALSE);
}

CSCHFILE OpenFileLocalEx(LPSTR lpPath, BOOL fInstrument)
{
    return(R0OpenFileEx(ACCESS_READWRITE, ACTION_OPENEXISTING, FILE_ATTRIBUTE_NORMAL, lpPath, fInstrument));
}


int FileExists
    (
    LPSTR lpPath
    )
{

    return(GetFileAttributesA(lpPath)!= 0xffffffff);
}


int GetFileSizeLocal
    (
    CSCHFILE handle,
    PULONG lpuSize
    )
{
    *lpuSize = GetFileSize((HANDLE)handle, NULL);

    if(*lpuSize == 0xffffffff)
    {
        return (-1);
    }
    else
    {
        return (0);
    }
}

#if 0

int GetAttributesLocal
    (
    LPSTR lpPath,
    ULONG *lpuAttributes
    )
{
}

int SetAttributesLocal
    (
    LPSTR lpPath,
    ULONG uAttributes
    )
{
}

#endif // if 0

int RenameFileLocal
    (
    LPSTR lpFrom,
    LPSTR lpTo
    )
{
    if(MoveFileA(lpFrom, lpTo))
    {
        return 1;
    }
    return -1;
}

int DeleteFileLocal
    (
    LPSTR lpName,
    USHORT usAttrib
    )
{
    return(DeleteFileA(lpName));
}

int GetDiskFreeSpaceLocal(
    int indx,
    ULONG *lpuSectorsPerCluster,
    ULONG *lpuBytesPerSector,
    ULONG *lpuFreeClusters,
    ULONG *lpuTotalClusters
    )
{
    return (-1);
}

int FileLockLocal( CSCHFILE hf,
    ULONG offsetLock,
    ULONG lengthLock,
    ULONG idProcess,
    BOOL  fLock
    )
{
    return (-1);
}

/*************************** Utility Functions ******************************/

LPVOID AllocMem
    (
    ULONG uSize
    )
{

    return (LocalAlloc(LPTR, uSize));

}
VOID FreeMem
    (
    LPVOID lp
    )
{
    LocalFree(lp);
}

LPVOID AllocMemPaged(
    ULONG uSize
    )
{

    return (LocalAlloc(LPTR, uSize));

}
VOID FreeMemPaged(
    LPVOID lp
    )
{
    LocalFree(lp);
}

int GetAttributesLocal(
    LPSTR lpName,
    ULONG *lpuAttr
    )
{
    if ( (*lpuAttr = (ULONG)GetFileAttributesA(lpName)) == 0xffffffff)
    {
        return -1;
    }
    return 1;
}

int GetAttributesLocalEx
    (
    LPSTR   lpPath,
    BOOL    fFile,
    ULONG   *lpuAttributes
    )
{
    return (GetAttributesLocal(lpPath, lpuAttributes));
}

int
SetAttributesLocal (
    LPSTR lpName,
    ULONG uAttr
    )
{
    if (!SetFileAttributesA(lpName, uAttr))
    {
        return -1;
    }
    return 1;
}

CSCHFILE R0OpenFile (
    USHORT usOpenFlags,
    UCHAR bAction,
    LPSTR lpPath)
{
    return (R0OpenFileEx(usOpenFlags, bAction, FILE_ATTRIBUTE_NORMAL, lpPath, FALSE));
}

int CreateDirectoryLocal(
    LPSTR   lpszPath
    )
{
    if (CreateDirectoryA(lpszPath, NULL))
    {
        return 0;
    }

    return -1;
}
int wstrnicmp(
    const USHORT *pStr1,
    const USHORT *pStr2,
    ULONG count
)
{
    USHORT c1, c2;
    int iRet;
    ULONG i=0;

    for(;;)
     {
        c1 = *pStr1++;
        c2 = *pStr2++;
        c1 = towupper(c1);
        c2 = towupper(c2);
        if (c1!=c2)
            break;
        if (!c1)
            break;
        i+=2;
        if (i >= count)
            break;
     }
    iRet = ((c1 > c2)?1:((c1==c2)?0:-1));
    return iRet;
}

ULONG
GetTimeInSecondsSince1970(
    VOID
    )
{
    return 0;
}

BOOL
HasStreamSupport(
    CSCHFILE hf,
    BOOL    *lpfStreams
    )
{
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\usermode\db\csc_bmpd.h ===
/*++

    Copyright (c) 2000 Microsoft Corporation

Module Name:

    csc_bmpd.h

Abstract:

    Interface to the user mode utility functions of bitmaps associated
    with CSC files written specifically for the db program. The 'd' in
    the file name means "db."

Author:

    Nigel Choi [t-nigelc]  Sept 3, 1999

--*/

#ifndef _CSC_BITMAP_H_
#define _CSC_BITMAP_H_

#include <windows.h>
#include <stdio.h>
#include "csc_bmpc.h"

// The _DB is used to distinguish this from the kernel mode CSC_BITMAP
// or the usermode _U

typedef struct _CSC_BITMAP_DB {
    DWORD bitmapsize;  // size in bits. How many bits effective in the bitmap
    DWORD numDWORD;    // how many DWORDs to accomodate the bitmap */
    LPDWORD bitmap;    // The bitmap itself
} CSC_BITMAP_DB, *LPCSC_BITMAP_DB, *PCSC_BITMAP_DB;

extern LPSTR CscBmpAltStrmName;

LPCSC_BITMAP_DB
DBCSC_BitmapCreate(
    DWORD filesize);

VOID
DBCSC_BitmapDelete(
    LPCSC_BITMAP_DB *lplpbitmap);

int
DBCSC_BitmapIsMarked(
    LPCSC_BITMAP_DB lpbitmap,
    DWORD bitoffset);

int
DBCSC_BitmapAppendStreamName(
    LPSTR fname,
    DWORD bufsize);

int
DBCSC_BitmapRead(
    LPCSC_BITMAP_DB *lplpbitmap,
    LPCTSTR filename);

VOID
DBCSC_BitmapOutput(
    FILE *outStrm,
    LPCSC_BITMAP_DB lpbitmap);

#endif //#define _CSC_BITMAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\usermode\lib3\debug.c ===
#include "pch.h"
#pragma hdrstop

/*****************************************************************************
 *	Purpose: Cool debug function
 */
void DebugPrint(char *szFmt, ...)
{
	char szDebug[200];
	va_list base;

	va_start(base,szFmt);

	wvsprintfA(szDebug, szFmt, base);
	OutputDebugStringA(szDebug);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\usermode\lib3\debug.h ===
void DebugPrint(char *szFmt, ...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\usermode\db\db.c ===
#define PUBLIC
#define PRIVATE
#include <stdlib.h>
#include <stdio.h>
#include <memory.h>
#include <string.h>
#include <windows.h>
#include <conio.h>
#include <share.h>
#include <dos.h>
#include "cscapi.h"
#pragma pack (1)

#if defined(BITCOPY)
#include "csc_bmpd.h"
#endif // defined(BITCOPY)

#define  MAX_PQ_PER_PAGE   10
#define  MAX_SHARES_PER_PAGE  6
#define  MAX_FILE_PER_PAGE   4
#define  MAX_INODES_PER_PAGE   15


#define _wtoupper(x)     ( ( ((x)>='a')&&((x)<='z') ) ? ((x)-'a'+'A'):(x))
#define _mytoupper(x)     ( ( ((x)>='a')&&((x)<='z') ) ? ((x)-'a'+'A'):(x))

#ifndef CSC_ON_NT
typedef void *CSCHFILE;
typedef void *CSC_ENUMCOOKIE;

#define UCHAR   unsigned char
#define USHORT  unsigned short
#define ULONG   unsigned long
#define CHAR    char
#define wchar_t unsigned short
#define LPTSTR  LPSTR
#define CONST   const
#define LPWIN32_FIND_DATAW   LPVOID
typedef struct tagSTOREDATA
{
    ULONG   ulSize;           // Max shadow data size
    ULONG   ucntDirs;         // Current count of dirs
    ULONG   ucntFiles;        // Current count of files
}
STOREDATA, *LPSTOREDATA;
typedef LPVOID LPFIND32;
#else
typedef PVOID   CSCHFILE;
#include "shdcom.h"
#include "cscsec.h"
#endif //CSC_ON_NT

#define  ESC       0x1b

typedef unsigned long  ulong;
typedef unsigned short ushort;

typedef LPSTR LPPATH;

#include "record.h"

#define InodeFromRec(ulRec, fFile)  ((ulRec+ULID_FIRST_USER_DIR-1) | ((fFile)?0x80000000:0))
#define RecFromInode(hShadow)       ((hShadow & 0x7fffffff) - (ULID_FIRST_USER_DIR-1))

char rgch[256], rgPrint[1024], rgchPar[256];

char szShadow[] = "\\WINDOWS\\CSC";
char szBackslash[] = "\\";
char szDbDir[256];    // shadow database
char szName[MAX_PATH];     // working buffer

int DispFunc(char *);
void DisplayShares(char *);
void DisplayInodes(void);
void DisplayPriorityQ(void);
void DisplayFile(unsigned long ulid, char *);
int PUBLIC HexToA(ulong, LPSTR, int);
void PRIVATE FormNameStringDB(
   LPSTR lpdbID,
   ulong ulidFile,
   LPSTR lpName
    );

BOOL
FindAncestor(
    ulong ulid,
    ulong *lpulidDir
);
void
printwidestring(
    USHORT  *lpwString,
    unsigned long   cntChars
    );

int RoughCompareWideStringWithAnsiString(
    LPSTR   lpSrcString,
    USHORT  *lpwDstString,
    int     cntMax
    );

int _cdecl main(int argc, char *argv[], char *envp[])
{
   BOOL fRet;
   DWORD junk;
   unsigned uAttr;
   int iRet = -1;
   if (argc==1)
    {
       fRet = CSCGetSpaceUsage(
                    szDbDir,
                    sizeof(szDbDir),
                    &junk,
                    &junk,
                    &junk,
                    &junk,
                    &junk,
                    &junk);
       if (fRet == FALSE)
          strcpy(szDbDir, szShadow);
    }
   else
    {
       memset(szDbDir, 0, sizeof(szDbDir));
       strncpy(szDbDir, argv[1], sizeof(szDbDir)-1);
    }
#ifdef CSC_ON_NT
     if((uAttr = GetFileAttributes(szDbDir)) == 0xffffffff)
#else
   if(_dos_getfileattr(szDbDir, &uAttr))
#endif //CSC_ON_NT
    {
       printf("Error accessing directory %s \r\n", szDbDir);
    }
   else if (!(uAttr & _A_SUBDIR))
    {
       printf("%s is not a directory\r\n", szDbDir);
    }
   else
    {
       do
        {
           memset(rgch, 0, sizeof(rgch));
           printf("\r\n");
           printf("Shares [s [name]], ");
           printf("PriQ [q], ");
           printf("File [f inode# [name]], ");
           printf("Exit [x], ");
           printf("Enter:");
           if (!gets(rgch))
               break;
           printf("\r\n");
               if (!DispFunc(rgch))
               break;
        }
       while (1);
       iRet = 0;
    }
   return (iRet);
}

int DispFunc(
   char *lpBuff
    )
{
    char ch;
    unsigned long ulid;
    int cnt;

    cnt = sscanf(lpBuff, "%c", &ch);

    if (!cnt)
        return 0;

    switch (ch)
    {
    // Display shares database
        case 's':
        case 'S':
            cnt = sscanf(lpBuff, "%c%s", &ch, rgchPar);
            DisplayShares((cnt==2)?rgchPar:NULL);
        break;

        // display priority Q database
        case 'q':
        case 'Q':
            DisplayPriorityQ();
        break;

        case 'f':
        case 'F':
            cnt = sscanf(lpBuff, "%c%lx%s", &ch, &ulid, rgchPar);
            if (cnt==2)
            {
                // display Inode file
                DisplayFile(ulid, NULL);
            }
            else if (cnt==3)
            {
                printf("Looking for %s in %x \r\n", rgchPar, ulid);
                // display Inode file
                DisplayFile(ulid, rgchPar);
            }
        break;
        case 'x':
        case 'X':
            return 0;
    }
    return 1;
}

void
DisplaySecurityContext(
    char *pSecurityDescriptor,
    LPRECORDMANAGER_SECURITY_CONTEXT   pSecurityContext)
{
#ifdef CSC_ON_NT

    PCACHED_SECURITY_INFORMATION pCachedSecurityInformation;
    ULONG i;

    pCachedSecurityInformation = (PCACHED_SECURITY_INFORMATION)pSecurityContext;

    if (pSecurityDescriptor != NULL) {
        printf("\n%s ",pSecurityDescriptor);
    }

    printf("SECURITY CONTEXT:\n");

    for (i = 0; i < MAXIMUM_NUMBER_OF_USERS; i++) {
        CSC_SID_INDEX SidIndex;

        SidIndex = pCachedSecurityInformation->AccessRights[i].SidIndex;
        switch (SidIndex) {
        case CSC_INVALID_SID_INDEX:
            break;
        default:
            {
                if (SidIndex == CSC_GUEST_SID_INDEX) {
                    printf("\tGUEST: ");
                } else {
                    printf("\t%lx: ",SidIndex);
                }

                printf(
                    "Rights: %lx\t\n",
                    pCachedSecurityInformation->AccessRights[i].MaximalRights);
            }
        }
    }
#endif
}

void
DisplaySecurityContext2(
    char *pSecurityDescriptor,
    LPRECORDMANAGER_SECURITY_CONTEXT   pSecurityContext)
{
    PCACHED_SECURITY_INFORMATION pCachedSecurityInformation;
    BOOL fGotOne = FALSE;
    ULONG i;

    pCachedSecurityInformation = (PCACHED_SECURITY_INFORMATION)pSecurityContext;

    for (i = 0; i < MAXIMUM_NUMBER_OF_USERS; i++) {
        CSC_SID_INDEX SidIndex;

        SidIndex = pCachedSecurityInformation->AccessRights[i].SidIndex;
        if (SidIndex != CSC_INVALID_SID_INDEX) {
            fGotOne = TRUE;
            break;
        }
    }

    if (fGotOne == FALSE)
        return;

    printf("%s Security: ",pSecurityDescriptor);
    for (i = 0; i < MAXIMUM_NUMBER_OF_USERS; i++) {
        CSC_SID_INDEX SidIndex;

        SidIndex = pCachedSecurityInformation->AccessRights[i].SidIndex;
        if (SidIndex == CSC_INVALID_SID_INDEX) {
            continue;
        }else if (SidIndex == CSC_GUEST_SID_INDEX) {
            printf("(G:0x%x)",
                pCachedSecurityInformation->AccessRights[i].MaximalRights);
        } else {
            printf("(0x%x:0x%x)",
                SidIndex,
                pCachedSecurityInformation->AccessRights[i].MaximalRights);
        }
    }
    printf("\r\n");
}

void DisplayShares(
    char    *lpszShareName
    )
{
    FILE *fp= (FILE *)NULL;
    SHAREHEADER sSH;
    SHAREREC sSR;
    unsigned long ulrec=1L;
    int count=0;

    FormNameStringDB(szDbDir, ULID_SHARE, szName);
    if (fp = _fsopen(szName, "rb", _SH_DENYNO))
    {
        if (fread(&sSH, sizeof(SHAREHEADER), 1, fp) != 1)
        {
            printf("Error reading server header \r\n");
            goto bailout;
        }

        printf("Header: Flags=%x Version=%lx Records=%ld Size=%d \r\n",
                sSH.uFlags, sSH.ulVersion, sSH.ulRecords, sSH.uRecSize);

        printf("Store: Max=%ld Current=%ld \r\n", sSH.sMax.ulSize, sSH.sCur.ulSize);
        printf("store: files=%ld directories=%ld \r\n\r\n", sSH.sCur.ucntFiles, sSH.sCur.ucntDirs);

        while (fread(&sSR, sizeof(SHAREREC), 1, fp)==1)
        {
            if (count == MAX_SHARES_PER_PAGE) {
                printf("\r\n--- Press any key to continue; ESC to cancel ---\r\n");
                if(_getch()==ESC) {
                    break;
                }
                count = 0;
            }

            if (sSR.uchType == (unsigned char)REC_DATA) {
                if (lpszShareName) {
                    if (RoughCompareWideStringWithAnsiString(
                            lpszShareName,
                            sSR.rgPath,
                            sizeof(sSR.rgPath)/sizeof(USHORT)-1)
                    ) {
                        continue;
                    }
                }

                printwidestring(sSR.rgPath, sizeof(sSR.rgPath)/sizeof(USHORT));
                printf("\r\n");
                printf( "  Share=0x%x Root=0x%x Stat=0x%x RootStat=0x%x "
                        "HntFlgs=0x%x HntPri=0x%x Attr=0x%x\r\n",
                            ulrec++,
                            sSR.ulidShadow,
                            sSR.uStatus,
                            (unsigned)(sSR.usRootStatus),
                            (unsigned)(sSR.uchHintFlags),
                            (unsigned)(sSR.uchHintPri),
                            sSR.dwFileAttrib);

                DisplaySecurityContext2("  ShareLevel",&sSR.sShareSecurity);
                DisplaySecurityContext2("  Root ",&sSR.sRootSecurity);
                printf("\r\n");

                if (lpszShareName) {
                    printf("\r\n--- Press any key to continue search; ESC to cancel ---\r\n");
                    if(_getch()==ESC) {
                        break;
                    }
                } else {
                    ++count;
                }
            }
        }
    }
bailout:
    if (fp)
        fclose(fp);
}



void DisplayPriorityQ
    (
   void
    )
{
   FILE *fp= (FILE *)NULL;
   QHEADER sQH;
   QREC sQR;
   unsigned long ulRec=1;
   int count = 0;

   FormNameStringDB(szDbDir, ULID_PQ, szName);
   if (fp = _fsopen(szName, "rb", _SH_DENYNO)) {
       if (fread(&sQH, sizeof(QHEADER), 1, fp) != 1) {
           printf("Error reading PQ header \r\n");
           goto bailout;
        }
       printf("Header: Flags=%x Version=%lx Records=%ld Size=%d head=%ld tail=%ld\r\n",
                    sQH.uchFlags,
                    sQH.ulVersion,
                    sQH.ulRecords,
                    sQH.uRecSize,
                    sQH.ulrecHead,
                    sQH.ulrecTail);
       printf("\r\n");
       printf(
       "  REC SHARE      DIR   SHADOW   STATUS  PRI HINTFLGS HINTPRI  PREV  NEXT DIRENT\r\n");
       for (ulRec = sQH.ulrecHead; ulRec;) {
           if (count == MAX_PQ_PER_PAGE) {
               printf("\r\n--- Press any key to continue; ESC to cancel ---\r\n");
               if(_getch()==ESC) {
                   break;
                }
               count = 0;
               printf(
               "  REC SHARE      DIR   SHADOW   STATUS  PRI HINTFLGS HINTPRI  PREV  NEXT DIRENT\r\n");
           }
           fseek(fp, ((ulRec-1) * sizeof(QREC))+sizeof(QHEADER), SEEK_SET);
           if (fread(&sQR, sizeof(QREC), 1, fp)!=1)
               break;
           printf("%5d %5x %8x %8x %8x %4d %8x %7d %5d %5d %6d\r\n",
                        ulRec,
                        sQR.ulidShare,
                        sQR.ulidDir,
                        sQR.ulidShadow,
                        sQR.usStatus,
                        (unsigned)(sQR.uchRefPri),
                        (unsigned)(sQR.uchHintFlags),
                        (unsigned)(sQR.uchHintPri),
                        sQR.ulrecPrev,
                        sQR.ulrecNext,
                        sQR.ulrecDirEntry);
            ++count;
           ulRec = sQR.ulrecNext;
        }
    }
bailout:
   if (fp)
       fclose(fp);
}

void DisplayFile(
    unsigned long ulid,
    char *lpszName
    )
{
    FILE *fp= (FILE *)NULL;
    FILEHEADER sFH;
    FILEREC sFR;
    int fLfn=0;
    unsigned long ulidDir=ulid;
    int fPrintOvf = 0, count=0;
#if defined(BITCOPY)
    char strmPath[MAX_PATH];
    LPCSC_BITMAP_DB lpbitmap = NULL;
#endif // defined(BITCOPY)

    if (IsLeaf(ulid)) {
        if (!FindAncestor(ulid, &ulidDir))
            return;
    }

    FormNameStringDB(szDbDir, ulidDir, szName);

    if (fp = _fsopen(szName, "rb", _SH_DENYNO)) {
        if (fread(&sFH, sizeof(FILEHEADER), 1, fp) != 1) {
            printf("Error reading file header \r\n");
            goto bailout;
        }


        if (ulid == ulidDir) {
            printf("Header: Flags=%x Version=%lx Records=%ld Size=%d\r\n",
                        sFH.uchFlags, sFH.ulVersion, sFH.ulRecords, sFH.uRecSize);
            printf("Header: bytes=%ld entries=%d Share=%ld Dir=%lx\r\n",
                        sFH.ulsizeShadow, sFH.ucShadows, sFH.ulidShare, sFH.ulidDir);
            printf ("\r\n");
            fPrintOvf = 1;
        }

        while (fread(&sFR, sizeof(FILEREC), 1, fp)==1) {
            if (count == MAX_FILE_PER_PAGE) {
                printf("--- Press any key to continue; ESC to cancel ---\r\n");
                if(_getch()==ESC) {
                    break;
                }
                count = 0;
            }
            if (sFR.uchType != (unsigned char)REC_OVERFLOW) {
                if (fLfn) {
                    if (ulidDir != ulid)
                        break;
                }
                fLfn = 0;
            }

            if (sFR.uchType==(unsigned char)REC_DATA) {
                if (ulidDir != ulid) {
                    if (ulid != sFR.ulidShadow)
                        continue;
                }
                if (lpszName) {
                    if (RoughCompareWideStringWithAnsiString(
                            lpszName,
                            sFR.rgwName,
                            sizeof(sFR.rgw83Name)/sizeof(USHORT)-1)
                    ) {
                        continue;
                    }
                }

                fPrintOvf = 1;
                printwidestring(sFR.rgw83Name, sizeof(sFR.rgw83Name)/sizeof(USHORT));
                printf(" (0x%x)\r\n", sFR.ulidShadow);
                printf("  Type=%c Flags=0x%x status=0x%x size=%ld attrib=0x%lx\r\n",
                            sFR.uchType,
                            (unsigned)sFR.uchFlags,
                            sFR.uStatus,
                            sFR.ulFileSize,
                            sFR.dwFileAttrib);
                printf("  PinFlags=0x%x PinCount=%d RefPri=%d OriginalInode=0x%0x\r\n",
                             (unsigned)(sFR.uchHintFlags),
                             (int)(sFR.uchHintPri),
                             (int)(sFR.uchRefPri),
                             sFR.ulidShadowOrg);
                printf("  time: hi=%x lo=%x orgtime: hi=%x lo=%x\r\n",
                            sFR.ftLastWriteTime.dwHighDateTime,
                            sFR.ftLastWriteTime.dwLowDateTime,
                            sFR.ftOrgTime.dwHighDateTime,
                            sFR.ftOrgTime.dwLowDateTime);
                if (sFR.rgwName[0]) {
                    printf("  LFN:");
                    printwidestring(sFR.rgwName, sizeof(sFR.rgwName)/sizeof(USHORT));
                    fLfn = 1;
                }

                printf("\r\n");
                DisplaySecurityContext2(" ",&sFR.Security);

                if (ulidDir != ulid)
                {
                    printf("DirInode = %x\r\n", ulidDir);
#if defined(BITCOPY)
                    FormNameStringDB(szDbDir, sFR.ulidShadow, strmPath);
                    DBCSC_BitmapAppendStreamName(strmPath, MAX_PATH);
                    printf("Trying to read CSCBitmap file %s\n", strmPath);		
                    // read bitmap
                    switch(DBCSC_BitmapRead(&lpbitmap, strmPath)) {
                        case 1:
                            // Print the bitmap associated if any
                            printf("\n");
                            DBCSC_BitmapOutput(stdout, lpbitmap);
                            printf("\n");
                            // if bitmap opened delete bitmap
                            DBCSC_BitmapDelete(&lpbitmap);
                            break;
                        case -1:
                            printf("Error reading bitmap file %s or bitmap invalid\n",
                            strmPath);
                            break;
                        case -2:
                            printf("No CSCBitmap\n");
                            break;
                        case 0:
                        default:
                            printf("Something strange going on w/ bitmap printing...\n");
                            break;
                    }
#endif // defined(BITCOPY)
                    break;
                }

                if (lpszName) {
                    printf("--- Press any key to continue search; ESC to cancel ---\r\n");
                    if(_getch()==ESC) {
                        break;
                    }
                }
                printf("\r\n");
            } else if (fPrintOvf && (sFR.uchType == (unsigned char)REC_OVERFLOW)) {
                printf("(overflow) ");
                printwidestring(sFR.rgwOvf,
                    (sizeof(FILEREC)-sizeof(RECORDMANAGER_COMMON_RECORD))/sizeof(USHORT));
                printf("\r\n\r\n");
            }

            // do counting only when we are scanning the whole directory
            if (!lpszName &&  (ulid == ulidDir)) {
                ++count;
            }
        }
        printf("\r\n");
    }
bailout:
    if (fp)
        fclose(fp);
}

void PRIVATE FormNameStringDB(
   LPSTR lpdbID,
   ulong ulidFile,
   LPSTR lpName
    )
{
   LPSTR lp;
   char chSubdir;

#ifdef CSC_ON_NT
    // Prepend the local path
   strcpy(lpName, lpdbID);
   strcat(lpName, szBackslash);
#else
    // Prepend the local path
   _fstrcpy(lpName, lpdbID);
   _fstrcat(lpName, szBackslash);
#endif //CSC_ON_NT

    // Bump the pointer appropriately
#ifdef CSC_ON_NT
   lp = lpName + strlen(lpName);
#else
   lp = lpName + _fstrlen(lpName);
#endif //CSC_ON_NT

   chSubdir = CSCDbSubdirSecondChar(ulidFile);

   // sprinkle the user files in one of the subdirectories
   if (chSubdir)
   {
       // now append the subdirectory

       *lp++ = CSCDbSubdirFirstChar();
       *lp++ = chSubdir;
       *lp++ = '\\';
   }


   HexToA(ulidFile, lp, 8);

   lp += 8;
    *lp = 0;
}

int PUBLIC HexToA(
   ulong ulHex,
   LPSTR lpName,
   int count)
{
   int i;
   LPSTR lp = lpName+count-1;
   unsigned char uch;

   for (i=0; i<count; ++i)
    {
       uch = (unsigned char)(ulHex & 0xf) + '0';
       if (uch > '9')
           uch += 7;    // A becomes '0' + A + 7 which is 'A'
        *lp = uch;
        --lp;
       ulHex >>= 4;
    }
    *(lpName+count) = '\0';
   return 0;
}

BOOL
FindAncestor(
    ulong ulid,
    ulong *lpulidDir
)
{
    ulong ulRec = RecFromInode(ulid);
    FILE *fp= (FILE *)NULL;
    QHEADER sQH;
    QREC sQR;
    BOOL fRet = FALSE;

    *lpulidDir = 0;

    FormNameStringDB(szDbDir, ULID_PQ, szName);
    if (fp = _fsopen(szName, "rb", _SH_DENYNO))
     {
        if (fread(&sQH, sizeof(QHEADER), 1, fp) != 1)
         {
            printf("Error reading PQ header \r\n");
            goto bailout;
         }

         fseek(fp, ((ulRec-1) * sizeof(QREC))+sizeof(QHEADER), SEEK_SET);

         if (fread(&sQR, sizeof(QREC), 1, fp)!=1){
            goto bailout;
         }
         *lpulidDir = sQR.ulidDir;
         fRet = TRUE;
     }
 bailout:
    if (fp)
        fclose(fp);
    return fRet;
}

#ifndef CSC_ON_NT
void
printwidestring(
    USHORT  *lpwString,
    unsigned long   cntChars
    )
{
    unsigned long i;

    cntChars = min(cntChars, sizeof(rgPrint) -1);

    for(i=0; (i< cntChars) && lpwString[i]; ++i)
    {
        rgPrint[i] = (char)(lpwString[i]);
    }

    rgPrint[i] = 0;
    printf(rgPrint);
}
#else
void
printwidestring(
    USHORT  *lpwString,
    unsigned long   cntChars
    )
{
    printf("%ls", lpwString);
}
#endif

int RoughCompareWideStringWithAnsiString(
    LPSTR   lpSrcString,
    USHORT  *lpwDstString,
    int     cntMax
    )
{
    char ch;
    USHORT  uch;
    int i;

    for (i=0;i<cntMax;++i)
    {
        ch = *lpSrcString++;
        uch = *lpwDstString++;
        uch = _wtoupper(uch);
        ch = _mytoupper(ch);

        if (!ch)
        {
            return 0;
        }

        if (ch != (char)uch)
        {
            return ((char)uch - ch);
        }
    }
    if (i==cntMax)
    {
        return 0;
    }

    return 1;   // this should never occur
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\usermode\lib3\pch.h ===
#define STRICT

#ifdef CSC_ON_NT

#define UNICODE // use all widecharacter APIs

#endif

#include <windows.h>
#include <windowsx.h>

// Dont link - just do it.
#pragma intrinsic(memcpy,memcmp,memset,strcpy,strlen,strcmp,strcat)

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>			// implementation dependent values
#include <memory.h>
#include <winioctl.h>

#include "shdcom.h"

BOOL
Find32WToFind32A(
    WIN32_FIND_DATAW    *lpFind32W,
    WIN32_FIND_DATAA    *lpFind32A
);

BOOL
Find32AToFind32W(
    WIN32_FIND_DATAA    *lpFind32A,
    WIN32_FIND_DATAW    *lpFind32W
);

BOOL
ConvertCopyParamsFromUnicodeToAnsi(
    LPCOPYPARAMSW    lpCPUni,
    LPCOPYPARAMSA    lpCP
);

BOOL
ShareInfoWToShareInfoA(
    LPSHAREINFOW   lpShareInfoW,
    LPSHAREINFOA   lpShareInfoA
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\usermode\reint\csc_bmpu.h ===
/*++

    Copyright (c) 2000 Microsoft Corporation

Module Name:

    csc_bmpu.h

Abstract:

    Interface to the user mode utility functions of bitmaps
    associated with CSC files. The 'u' in the file name means "usermode"

Author:

    Nigel Choi [t-nigelc]  Sept 3, 1999

--*/

#ifndef _CSC_BITMAP_H_
#define _CSC_BITMAP_H_

#include "csc_bmpc.h"

// The _U is used to distinguish this from the kernel mode CSC_BITMAP

typedef struct _CSC_BITMAP_U {
    DWORD bitmapsize;    // size in bits. How many bits effective in the bitmap
    DWORD numDWORD;      // how many DWORDs to accomodate the bitmap
    DWORD reintProgress; // last fileoffset Reint copies + 1, initially 0 
    LPDWORD bitmap;      // The bitmap itself
} CSC_BITMAP_U, *LPCSC_BITMAP_U, *PCSC_BITMAP_U;

extern LPTSTR CscBmpAltStrmName;

LPCSC_BITMAP_U
CSC_BitmapCreate(
    DWORD filesize);

VOID
CSC_BitmapDelete(
    LPCSC_BITMAP_U *lplpbitmap);

int
CSC_BitmapIsMarked(
    LPCSC_BITMAP_U lpbitmap,
    DWORD bitoffset);

DWORD
CSC_BitmapGetBlockSize();

int
CSC_BitmapGetSize(
    LPCSC_BITMAP_U lpbitmap);

int
CSC_BitmapStreamNameLen();

int
CSC_BitmapAppendStreamName(
    LPTSTR fname,
    DWORD bufsize);

int
CSC_BitmapRead(
    LPCSC_BITMAP_U *lplpbitmap,
    LPCTSTR filename);

#define CSC_BITMAPReintInvalid  0
#define CSC_BITMAPReintError    1
#define CSC_BITMAPReintCont     2
#define CSC_BITMAPReintDone     3

int
CSC_BitmapReint(
    LPCSC_BITMAP_U lpbitmap,
    HANDLE srcH,
    HANDLE dstH,
    LPVOID buff,
    DWORD buffSize,
    DWORD * bytesRead);

#ifdef DEBUG
VOID
CSC_BitmapOutput(
    LPCSC_BITMAP_U lpbitmap);
#else
#define CSC_BitmapOutput(x) NOTHING;
#endif

#endif //#define _CSC_BITMAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\usermode\lib3\lib3.c ===
/*****************************************************************************
 *    This file is a ring 3 layer to call down to the VxD.
 */

#include "pch.h"
#pragma hdrstop

#include "assert.h"
#include "lib3.h"
#include "debug.h"

/*****************************************************************************
Globals declared within this file
*/
static char    vszShadowDevice[] = "\\\\.\\shadow";    // name of vxd

// must be declared in your OWN code...

/* assert/debug stuff */
AssertData;
AssertError;

//this variable is used as the receiver of the BytesReturned for DeviceIoControl Calls
//the value is never actually used
ULONG DummyBytesReturned, uShadowDeviceOpenCount=0;


//HACKHACKHACK the agent will wait up to 7 minutes for the rdr to show up
LONG NtWaitLoopMax = 7 * 60;
LONG NtWaitLoopSleep = 5;

/*****************************************************************************
Call once to get the file handle opened to talk to the VxD
*/

HANDLE
OpenShadowDatabaseIOex(ULONG WaitForDriver, DWORD dwFlags)
{
    HANDLE hShadowDB;
    LONG WaitLoopRemaining = NtWaitLoopMax;
    DWORD dwError;
    char buff[64];

#if 0
WAITLOOP_HACK:
#endif
    if ((hShadowDB = CreateFileA(vszShadowDevice,
                               FILE_EXECUTE, //GENERIC_READ | GENERIC_WRITE,
                               FILE_SHARE_READ | FILE_SHARE_WRITE,
                               NULL,
                               OPEN_EXISTING,
                               dwFlags,
                               NULL)) == INVALID_HANDLE_VALUE ) {

#if 0
        //HACKHACKHACK
        if (WaitForDriver && (WaitLoopRemaining > 0)) {
            Sleep(NtWaitLoopSleep * 1000);
            WaitLoopRemaining -= NtWaitLoopSleep;
            goto WAITLOOP_HACK;
        }
#endif
        dwError = GetLastError();

//        DEBUG_PRINT(("lib3:CreateFile on CSC device failed Error = %d\r\n", dwError));

        return INVALID_HANDLE_VALUE; /* failure */
    }

    InterlockedIncrement(&uShadowDeviceOpenCount);

    return hShadowDB; /* success */
}

HANDLE
__OpenShadowDatabaseIO(ULONG WaitForDriver)
{
    return OpenShadowDatabaseIOex(WaitForDriver, 0);
}


/*****************************************************************************
Call after we're all done to close down the IOCTL interface.
*/
void
CloseShadowDatabaseIO(HANDLE hShadowDB)
{
    CloseHandle(hShadowDB);
    InterlockedDecrement(&uShadowDeviceOpenCount);
}


int BeginInodeTransactionHSHADOW(
    VOID
    )
{
    int iRet;
    iRet = DoShadowMaintenance(INVALID_HANDLE_VALUE, SHADOW_BEGIN_INODE_TRANSACTION);
    if (!iRet)
    {
        SetLastError(ERROR_ACCESS_DENIED);
    }
    return (iRet);
}

int EndInodeTransactionHSHADOW(
    VOID
    )
{
    int iRet;

    iRet = DoShadowMaintenance(INVALID_HANDLE_VALUE, SHADOW_END_INODE_TRANSACTION);

    if (!iRet)
    {
        SetLastError(ERROR_ACCESS_DENIED);
    }
    return (iRet);
}

/*****************************************************************************
 *    Given an hDir and filename, find the hShadow, should it exist.
 */
int
GetShadowW(
    HANDLE                hShadowDB,
    HSHADOW                hDir,
    LPHSHADOW            lphShadow,
    LPWIN32_FIND_DATAW    lpFind32,
    unsigned long        *lpuStatus
    )
{
    int            iRet;
    SHADOWINFO    sSI;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }
    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.hDir = hDir;
    sSI.lpFind32 = lpFind32;
    iRet = DeviceIoControl(hShadowDB
                           , IOCTL_GETSHADOW
                           ,(LPVOID)(&sSI), 0
                           , NULL, 0
                           , &DummyBytesReturned, NULL);
    if (iRet) {
        *lpuStatus = sSI.uStatus;
        *lphShadow = sSI.hShadow;
    }

    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (!iRet)
    {
        SetLastError(sSI.dwError);
    }

    return (iRet);
}

/*****************************************************************************
 *    Given an hDir and filename, get SHADOWINFO if it exists
 */
int
GetShadowExW(
    HANDLE                hShadowDB,
    HSHADOW                hDir,
    LPWIN32_FIND_DATAW    lpFind32,
    LPSHADOWINFO          lpSI
    )
{
    int            iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(lpSI, 0, sizeof(SHADOWINFO));
    lpSI->hDir = hDir;
    lpSI->lpFind32 = lpFind32;
    iRet = DeviceIoControl(hShadowDB
                           , IOCTL_GETSHADOW
                           ,(LPVOID)(lpSI), 0
                           , NULL, 0
                           , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (!iRet)
    {
        SetLastError(lpSI->dwError);
    }
    return (iRet);
}

/*****************************************************************************
 *    Call down to the VxD to add a file to the shadow.
 *    lphShadow is filled in with the new HSHADOW.
 *    Set uStatus as necessary (ie: SPARSE or whatever...)
 */
int
CreateShadowW(
    HANDLE                hShadowDB,
    HSHADOW                hDir,
    LPWIN32_FIND_DATAW    lpFind32,
    unsigned long        uStatus,
    LPHSHADOW            lphShadow
    )
{
    int            iRet;
    SHADOWINFO    sSI;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.hDir = hDir;
    sSI.uStatus = uStatus;
    sSI.lpFind32 = lpFind32;
    iRet = DeviceIoControl(hShadowDB
                           , IOCTL_SHADOW_CREATE
                           ,(LPVOID)(&sSI), 0
                           , NULL, 0
                           , &DummyBytesReturned, NULL);
    if (iRet) {
        *lphShadow = sSI.hShadow;
    }

    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (!iRet)
    {
        SetLastError(sSI.dwError);
    }

    return (iRet);
}

/*****************************************************************************
 *    given an hDir and hShadow, nuke the shadow
 */
int
DeleteShadow(
    HANDLE     hShadowDB,
    HSHADOW  hDir,
    HSHADOW  hShadow
    )
{
    SHADOWINFO sSI;
    BOOL        fDBOpened = FALSE;
    int iRet;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.hDir = hDir;
    sSI.hShadow = hShadow;
    iRet = DeviceIoControl(hShadowDB  , IOCTL_SHADOW_DELETE
                           ,(LPVOID)(&sSI), 0
                           , NULL, 0
                           , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (!iRet)
    {
        SetLastError(sSI.dwError);
    }

    return (iRet);
}

/*****************************************************************************
 *    given an hDir and hShadow, get WIN32_FIND_DATAW about the file.
 */
int
GetShadowInfoW(
    HANDLE                hShadowDB,
    HSHADOW            hDir,
    HSHADOW            hShadow,
    LPWIN32_FIND_DATAW    lpFind32,
    unsigned long        *lpuStatus
    )
{
    int iRet;
    SHADOWINFO    sSI;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.hDir = hDir;
    sSI.hShadow = hShadow;
    sSI.lpFind32 = lpFind32;
    iRet = DeviceIoControl(hShadowDB    , IOCTL_SHADOW_GET_SHADOW_INFO
                                    ,(LPVOID)(&sSI), 0
                                    , NULL, 0
                                    , &DummyBytesReturned, NULL);
    *lpuStatus = sSI.uStatus;
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (!iRet)
    {
        SetLastError(sSI.dwError);
    }

    return (iRet);
}

/*****************************************************************************
 *    given an hDir and hShadow, get WIN32_FIND_DATAW about the file and the SHADOWINFO
 */
int
GetShadowInfoExW(
    HANDLE                hShadowDB,
    HSHADOW                hDir,
    HSHADOW                hShadow,
    LPWIN32_FIND_DATAW    lpFind32,
    LPSHADOWINFO          lpSI
    )
{
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(lpSI, 0, sizeof(SHADOWINFO));
    lpSI->hDir = hDir;
    lpSI->hShadow = hShadow;
    lpSI->lpFind32 = lpFind32;
    iRet = DeviceIoControl(hShadowDB    , IOCTL_SHADOW_GET_SHADOW_INFO
                                    ,(LPVOID)(lpSI), 0
                                    , NULL, 0
                                    , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (!iRet)
    {
        SetLastError(lpSI->dwError);
    }

    return (iRet);
}

/*****************************************************************************
 *    given an hDir and hShadow, set WIN32_FIND_DATAW or uStatus about the file.
 *    Operation depends on uOp given.
 */
int
SetShadowInfoW(
    HANDLE                hShadowDB,
    HSHADOW                hDir,
    HSHADOW                hShadow,
    LPWIN32_FIND_DATAW    lpFind32,
    unsigned long        uStatus,
    unsigned long        uOp
    )
{
    SHADOWINFO    sSI;
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.hDir = hDir;
    sSI.hShadow = hShadow;
    sSI.lpFind32 = lpFind32;
    sSI.uStatus = uStatus;
    sSI.uOp = uOp;
    iRet = DeviceIoControl(hShadowDB    , IOCTL_SHADOW_SET_SHADOW_INFO
                                    ,(LPVOID)(&sSI), 0
                                    , NULL, 0
                                    , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (!iRet)
    {
        SetLastError(sSI.dwError);
    }

    return (iRet);
}

/*****************************************************************************
 *    Fills out a GLOBALSTATUS passed in.
 */
int
GetGlobalStatus(
    HANDLE            hShadowDB,
    LPGLOBALSTATUS    lpGS
    )
{
    BOOL        fDBOpened = FALSE;
    int iRet;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }
    iRet = DeviceIoControl(hShadowDB    , IOCTL_GETGLOBALSTATUS
                                    ,(LPVOID)(lpGS), 0
                                    , NULL, 0
                                    , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    return (iRet);
}

/*****************************************************************************
 *    given an hDir, enumerate the directory.     A SHADOWINFO will be filled in.
 *    You must pass in a LPWIN32_FIND_DATAW that has cFileName and fileAttributes
 *    set properly.  The cookie returned must be used in findNext calls.
 */
int
FindOpenShadowW(
    HANDLE                hShadowDB,
    HSHADOW                hDir,
    unsigned              uOp,
    LPWIN32_FIND_DATAW    lpFind32,
    LPSHADOWINFO        lpSI
)
{
    BOOL retVal;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(lpSI, 0, sizeof(SHADOWINFO));
    lpSI->uOp = uOp;
    lpSI->hDir = hDir;
    lpSI->lpFind32 = lpFind32;

    retVal = DeviceIoControl(hShadowDB    , IOCTL_FINDOPEN_SHADOW
                                    ,(LPVOID)(lpSI), 0
                                    , NULL, 0
                                    , &DummyBytesReturned, NULL);
    lpSI->lpFind32 = NULL;

    if(!retVal) {

        memset(lpSI, 0, sizeof(SHADOWINFO));
    }

    if (!retVal)
    {
        SetLastError(lpSI->dwError);
    }

    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    return retVal;
}

/*****************************************************************************
 *    Continue enumeration based on handle returned above.
 */
int
FindNextShadowW(
    HANDLE                hShadowDB,
    CSC_ENUMCOOKIE        uEnumCookie,
    LPWIN32_FIND_DATAW    lpFind32,
    LPSHADOWINFO        lpSI
    )
{
    BOOL retVal;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(lpSI, 0, sizeof(SHADOWINFO));
    lpSI->uEnumCookie = uEnumCookie;
    lpSI->lpFind32 = lpFind32;
    retVal = DeviceIoControl(hShadowDB    , IOCTL_FINDNEXT_SHADOW
                                    ,(LPVOID)(lpSI), 0
                                    , NULL, 0
                                    , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    return retVal;
}

/*****************************************************************************
 *    Finished enumeration, return the handle.
 */
int
FindCloseShadow(
    HANDLE                hShadowDB,
    CSC_ENUMCOOKIE        uEnumCookie
    )
{
    SHADOWINFO    sSI;
    int iRet;

    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }
    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.uEnumCookie = uEnumCookie;
    iRet = DeviceIoControl(hShadowDB    , IOCTL_FINDCLOSE_SHADOW
                                    ,(LPVOID)(&sSI), 0
                                    , NULL, 0
                                    , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    return (iRet);
}

/*****************************************************************************
 *    Call down to the VxD to add a hint of some sort to the database.
 *    cFileName is the string to match against.
 *    lphShadow is filled in with the new HSHADOW.
 *    hDir = 0 means global hint.     Otherwise, this is the root to take it from.
 */
int
AddHintW(
    HANDLE            hShadowDB,
    HSHADOW            hDir,
    TCHAR            *cFileName,
    LPHSHADOW        lphShadow,
    unsigned long    ulHintFlags,
    unsigned long    ulHintPri
    )
{
    int                iRet;
    SHADOWINFO        sSI;
    WIN32_FIND_DATAW    sFind32;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    wcsncpy(sFind32.cFileName, cFileName, MAX_PATH-1);
    sSI.hDir = hDir;
    sSI.lpFind32 = (LPFIND32)&sFind32;
    sSI.ulHintFlags = ulHintFlags;
    sSI.ulHintPri = ulHintPri;

    iRet = DeviceIoControl(hShadowDB
                           , IOCTL_ADD_HINT
                           ,(LPVOID)(&sSI), 0
                           , NULL, 0
                           , &DummyBytesReturned, NULL);
    if (iRet) {
        *lphShadow = sSI.hShadow;
    }
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }
    return (iRet);
}

/*****************************************************************************
 *    Call down to the VxD to delete a hint of some sort from the database.
 *    cFileName is the string to match against.
 *    hDir = 0 means global hint.     Otherwise, this is the root to take it from.
 */
int
DeleteHintW(
    HANDLE    hShadowDB,
    HSHADOW    hDir,
    TCHAR   *cFileName,
    BOOL    fClearAll
    )
{
    int                iRet;
    SHADOWINFO        sSI;
    WIN32_FIND_DATAW    sFind32;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    wcsncpy(sFind32.cFileName, cFileName, MAX_PATH-1);

    sSI.hDir = hDir;
    sSI.lpFind32 = (LPFIND32)&sFind32;

    // nuke or just decrement?
    if (fClearAll)
    {
        sSI.ulHintPri = 0xffffffff;
    }
    iRet = DeviceIoControl(hShadowDB
                           , IOCTL_DELETE_HINT
                           ,(LPVOID)(&sSI), 0
                           , NULL, 0
                           , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }
    return iRet;
}

/*****************************************************************************
 *    given an hDir, enumerate the directory.     A SHADOWINFO will be filled in.
 *    You must pass in a LPWIN32_FIND_DATAW that has cFileName and fileAttributes
 *    set properly.  The cookie returned must be used in findNext calls.
 */
int
FindOpenHintW(
    HANDLE              hShadowDB,
    HSHADOW             hDir,
    LPWIN32_FIND_DATAW  lpFind32,
    CSC_ENUMCOOKIE      *lpuEnumCookie,
    HSHADOW             *hShadow,
    unsigned long       *lpulHintFlags,
    unsigned long       *lpulHintPri
    )
{
    SHADOWINFO    sSI;
    BOOL retVal;

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.uOp = FINDOPEN_SHADOWINFO_ALL;
    sSI.hDir = hDir;
//    sSI.ulHintFlags = 0xF;
    sSI.ulHintFlags = HINT_TYPE_FOLDER;
    sSI.lpFind32 = lpFind32;

    retVal = DeviceIoControl(hShadowDB    , IOCTL_FINDOPEN_HINT
                                    ,(LPVOID)(&sSI), 0
                                    , NULL, 0
                                    , &DummyBytesReturned, NULL);
    if(retVal) {
        *lpuEnumCookie = sSI.uEnumCookie;
        *hShadow = sSI.hShadow;
        *lpulHintFlags = sSI.ulHintFlags;
        *lpulHintPri = sSI.ulHintPri;
    } else {
        *lpuEnumCookie = 0;
        *hShadow = 0;
    }
    return retVal;
}

/*****************************************************************************
 *    Continue enumeration based on handle returned above.
 */
int
FindNextHintW(
    HANDLE                hShadowDB,
    CSC_ENUMCOOKIE      uEnumCookie,
    LPWIN32_FIND_DATAW    lpFind32,
    HSHADOW            *hShadow,
    unsigned long        *lpuHintFlags,
    unsigned long        *lpuHintPri
    )
{
    SHADOWINFO    sSI;
    BOOL retVal;
    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.uEnumCookie = uEnumCookie;
    sSI.lpFind32 = lpFind32;
    retVal = DeviceIoControl(hShadowDB    , IOCTL_FINDNEXT_HINT
                                    ,(LPVOID)(&sSI), 0
                                    , NULL, 0
                                    , &DummyBytesReturned, NULL);
    *hShadow = sSI.hShadow;
    *lpuHintFlags = sSI.ulHintFlags;
    *lpuHintPri = sSI.ulHintPri;

    return retVal;
}

/*****************************************************************************
 *    Finished enumeration, return the handle.
 */
int
FindCloseHint(
    HANDLE                hShadowDB,
    CSC_ENUMCOOKIE      uEnumCookie
    )
{
    SHADOWINFO    sSI;
    int iRet;
    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.uEnumCookie = uEnumCookie;
    return(DeviceIoControl(hShadowDB    , IOCTL_FINDCLOSE_HINT
                                    ,(LPVOID)(&sSI), 0
                                    , NULL, 0
                                    , &DummyBytesReturned, NULL));
}



/*****************************************************************************
 *    Call down to the VxD to add a hint on the inode.
 *  This ioctl does the right thing for user and system hints
 *  If successful, there is an additional pincount on the inode entry
 *  and the flags that are passed in are ORed with the original entry
 */
int
AddHintFromInode(
    HANDLE            hShadowDB,
    HSHADOW            hDir,
    HSHADOW         hShadow,
    unsigned        long    *lpulPinCount,
    unsigned        long    *lpulHintFlags
    )
{
    int                iRet;
    SHADOWINFO        sSI;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.hDir = hDir;
    sSI.hShadow = hShadow;
    sSI.ulHintFlags = *lpulHintFlags;
    sSI.uOp = SHADOW_ADDHINT_FROM_INODE;

    iRet = DeviceIoControl(hShadowDB
                           , IOCTL_DO_SHADOW_MAINTENANCE
                           ,(LPVOID)(&sSI), 0
                           , NULL, 0
                           , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }
    if (!iRet)
    {
        SetLastError(sSI.dwError);
    }
    else
    {
        *lpulHintFlags = sSI.ulHintFlags;
        *lpulPinCount = sSI.ulHintPri;
    }
    return (iRet);
}

/*****************************************************************************
 *    Call down to the VxD to add a hint on the inode.
 *  This ioctl does the right thing for user and system hints
 *  If successful, there is an one pincount less than the original
 *  and the ~ of flags that are passed in are ANDed with the original entry
 */
int
DeleteHintFromInode(
    HANDLE    hShadowDB,
    HSHADOW    hDir,
    HSHADOW hShadow,
    unsigned        long    *lpulPinCount,
    unsigned        long    *lpulHintFlags
    )
{
    int                iRet;
    SHADOWINFO        sSI;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.hDir = hDir;
    sSI.hShadow = hShadow;
    sSI.ulHintFlags = *lpulHintFlags;
    sSI.uOp = SHADOW_DELETEHINT_FROM_INODE;

    iRet = DeviceIoControl(hShadowDB
                           , IOCTL_DO_SHADOW_MAINTENANCE
                           ,(LPVOID)(&sSI), 0
                           , NULL, 0
                           , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }
    if (!iRet)
    {
        SetLastError(sSI.dwError);
    }
    else
    {
        *lpulHintFlags = sSI.ulHintFlags;
        *lpulPinCount = sSI.ulHintPri;
    }
    return (iRet);
}





/******************************************************/


/*****************************************************************************
 *    Given an hDir and filename, find the hShadow, should it exist.
 */
int
GetShadowA(
    HANDLE                hShadowDB,
    HSHADOW                hDir,
    LPHSHADOW            lphShadow,
    LPWIN32_FIND_DATAA    lpFind32,
    unsigned long        *lpuStatus
    )
{
    int iRet;
    WIN32_FIND_DATAW sFind32, *lpFind32W = NULL;

    if (lpFind32)
    {
        lpFind32W = &sFind32;
        Find32AToFind32W(lpFind32, lpFind32W);
    }
    iRet = GetShadowW(hShadowDB, hDir, lphShadow, lpFind32W, lpuStatus);
    if (lpFind32)
    {
        Assert(lpFind32W);
        Find32WToFind32A(lpFind32W, lpFind32);
    }

    return (iRet);
}

/*****************************************************************************
 *    Given an hDir and filename, get SHADOWINFO if it exists
 */
int
GetShadowExA(
    HANDLE                hShadowDB,
    HSHADOW                hDir,
    LPWIN32_FIND_DATAA    lpFind32,
    LPSHADOWINFO          lpSI
    )
{
    int iRet;

    WIN32_FIND_DATAW sFind32, *lpFind32W = NULL;

    if (lpFind32)
    {
        lpFind32W = &sFind32;
        Find32AToFind32W(lpFind32, lpFind32W);
    }
    iRet = GetShadowExW(hShadowDB, hDir, lpFind32W, lpSI);

    if (lpFind32)
    {
        Assert(lpFind32W);
        Find32WToFind32A(lpFind32W, lpFind32);
    }

    return (iRet);
}

/*****************************************************************************
 *    Call down to the VxD to add a file to the shadow.
 *    lphShadow is filled in with the new HSHADOW.
 *    Set uStatus as necessary (ie: SPARSE or whatever...)
 */
int
CreateShadowA(
    HANDLE                hShadowDB,
    HSHADOW                hDir,
    LPWIN32_FIND_DATAA    lpFind32,
    unsigned long        uStatus,
    LPHSHADOW            lphShadow
    )
{
    int iRet;
    WIN32_FIND_DATAW sFind32, *lpFind32W = NULL;

    if (lpFind32)
    {
        lpFind32W = &sFind32;
        Find32AToFind32W(lpFind32, lpFind32W);
    }
    iRet = CreateShadowW(hShadowDB, hDir, lpFind32W, uStatus, lphShadow);

    if (lpFind32)
    {
        Assert(lpFind32W);
        Find32WToFind32A(lpFind32W, lpFind32);
    }

    return (iRet);
}

/*****************************************************************************
 *    given an hDir and hShadow, get WIN32_FIND_DATAA about the file.
 */
int
GetShadowInfoA(
    HANDLE                hShadowDB,
    HSHADOW            hDir,
    HSHADOW            hShadow,
    LPWIN32_FIND_DATAA    lpFind32,
    unsigned long        *lpuStatus
    )
{
    int iRet;
    WIN32_FIND_DATAW sFind32, *lpFind32W = NULL;

    if (lpFind32)
    {
        lpFind32W = &sFind32;
    }

    iRet = GetShadowInfoW(hShadowDB, hDir, hShadow, lpFind32W, lpuStatus);

    if (lpFind32)
    {
        Assert(lpFind32W);
        Find32WToFind32A(lpFind32W, lpFind32);
    }

    return (iRet);
}

/*****************************************************************************
 *    given an hDir and hShadow, get WIN32_FIND_DATAA about the file and the SHADOWINFO
 */
int
GetShadowInfoExA(
    HANDLE                hShadowDB,
    HSHADOW                hDir,
    HSHADOW                hShadow,
    LPWIN32_FIND_DATAA    lpFind32,
    LPSHADOWINFO          lpSI
    )
{
    int iRet;
    WIN32_FIND_DATAW sFind32, *lpFind32W = NULL;

    if (lpFind32)
    {
        lpFind32W = &sFind32;
    }

    iRet = GetShadowInfoExW(hShadowDB, hDir, hShadow, lpFind32W, lpSI);

    if (lpFind32)
    {
        Assert(lpFind32W);
        Find32WToFind32A(lpFind32W, lpFind32);
    }

    return (iRet);
}

/*****************************************************************************
 *    given an hDir and hShadow, set WIN32_FIND_DATAA or uStatus about the file.
 *    Operation depends on uOp given.
 */
int
SetShadowInfoA(
    HANDLE                hShadowDB,
    HSHADOW                hDir,
    HSHADOW                hShadow,
    LPWIN32_FIND_DATAA    lpFind32,
    unsigned long        uStatus,
    unsigned long        uOp
    )
{
    int iRet;
    WIN32_FIND_DATAW sFind32, *lpFind32W = NULL;

    if (lpFind32)
    {
        lpFind32W = &sFind32;
        Find32AToFind32W(lpFind32, lpFind32W);
    }

    iRet = SetShadowInfoW(hShadowDB, hDir, hShadow, lpFind32W, uStatus, uOp);

    if (lpFind32)
    {
        Assert(lpFind32W);
        Find32WToFind32A(lpFind32W, lpFind32);
    }

    return (iRet);
}

/*****************************************************************************
 *    given an hDir, enumerate the directory.     A SHADOWINFO will be filled in.
 *    You must pass in a LPWIN32_FIND_DATAA that has cFileName and fileAttributes
 *    set properly.  The cookie returned must be used in findNext calls.
 */
int
FindOpenShadowA(
    HANDLE                hShadowDB,
    HSHADOW                hDir,
    unsigned              uOp,
    LPWIN32_FIND_DATAA    lpFind32,
    LPSHADOWINFO        lpSI
)
{
    int iRet;
    WIN32_FIND_DATAW sFind32, *lpFind32W = NULL;

    if (lpFind32)
    {
        lpFind32W = &sFind32;
        Find32AToFind32W(lpFind32, lpFind32W);
    }

    iRet = FindOpenShadowW(hShadowDB, hDir, uOp, lpFind32W, lpSI);

    if (lpFind32)
    {
        Assert(lpFind32W);
        Find32WToFind32A(lpFind32W, lpFind32);
    }

    return (iRet);
}

/*****************************************************************************
 *    Continue enumeration based on handle returned above.
 */
int
FindNextShadowA(
    HANDLE                hShadowDB,
    CSC_ENUMCOOKIE        uEnumCookie,
    LPWIN32_FIND_DATAA    lpFind32,
    LPSHADOWINFO        lpSI
    )
{
    int iRet;
    WIN32_FIND_DATAW sFind32, *lpFind32W = NULL;

    if (lpFind32)
    {
        lpFind32W = &sFind32;
    }

    iRet = FindNextShadowW(hShadowDB, uEnumCookie, lpFind32W, lpSI);

    if (lpFind32)
    {
        Assert(lpFind32W);
        Find32WToFind32A(lpFind32W, lpFind32);
    }

    return (iRet);
}

/*****************************************************************************
 *    Call down to the VxD to add a hint of some sort to the database.
 *    cFileName is the string to match against.
 *    lphShadow is filled in with the new HSHADOW.
 *    hDir = 0 means global hint.     Otherwise, this is the root to take it from.
 */
int
AddHintA(
    HANDLE            hShadowDB,
    HSHADOW            hDir,
    char            *cFileName,
    LPHSHADOW        lphShadow,
    unsigned long    ulHintFlags,
    unsigned long    ulHintPri
    )
{
    int                iRet = 0;
    unsigned short wBuff[MAX_PATH];

    if (MultiByteToWideChar(CP_ACP, 0, cFileName, strlen(cFileName), wBuff, sizeof(wBuff)/sizeof(WCHAR)))
    {
        iRet = AddHintW(hShadowDB, hDir, wBuff, lphShadow, ulHintFlags, ulHintPri);
    }
    else
    {
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    return (iRet);
}

/*****************************************************************************
 *    Call down to the VxD to delete a hint of some sort from the database.
 *    cFileName is the string to match against.
 *    hDir = 0 means global hint.     Otherwise, this is the root to take it from.
 */
int
DeleteHintA(
    HANDLE    hShadowDB,
    HSHADOW    hDir,
    char    *cFileName,
    BOOL    fClearAll
    )
{
    int                iRet = 0;
    unsigned short wBuff[MAX_PATH];

    if (MultiByteToWideChar(CP_ACP, 0, cFileName, strlen(cFileName), wBuff, sizeof(wBuff)/sizeof(WCHAR)))
    {
        iRet = DeleteHintW(hShadowDB, hDir, wBuff, fClearAll);
    }
    else
    {
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    return (iRet);
}

/*****************************************************************************
 *    given an hDir, enumerate the directory.     A SHADOWINFO will be filled in.
 *    You must pass in a LPWIN32_FIND_DATAA that has cFileName and fileAttributes
 *    set properly.  The cookie returned must be used in findNext calls.
 */
int
FindOpenHintA(
    HANDLE                hShadowDB,
    HSHADOW                hDir,
    LPWIN32_FIND_DATAA    lpFind32,
    CSC_ENUMCOOKIE        *lpuEnumCookie,
    HSHADOW                *lphShadow,
    unsigned long        *lpulHintFlags,
    unsigned long        *lpulHintPri
    )
{
    int iRet;
    WIN32_FIND_DATAW sFind32, *lpFind32W = NULL;

    if (lpFind32)
    {
        lpFind32W = &sFind32;
        Find32AToFind32W(lpFind32, lpFind32W);
    }

    iRet = FindOpenHintW(hShadowDB, hDir, lpFind32W, lpuEnumCookie, lphShadow, lpulHintFlags, lpulHintPri);

    if (lpFind32)
    {
        Assert(lpFind32W);
        Find32WToFind32A(lpFind32W, lpFind32);
    }

    return (iRet);
}

/*****************************************************************************
 *    Continue enumeration based on handle returned above.
 */
int
FindNextHintA(
    HANDLE                hShadowDB,
    CSC_ENUMCOOKIE        uEnumCookie,
    LPWIN32_FIND_DATAA    lpFind32,
    HSHADOW                *hShadow,
    unsigned long        *lpuHintFlags,
    unsigned long        *lpuHintPri
    )
{
    int iRet;
    WIN32_FIND_DATAW sFind32, *lpFind32W = NULL;

    if (lpFind32)
    {
        lpFind32W = &sFind32;
    }

    iRet = FindNextHintW(hShadowDB, uEnumCookie, lpFind32W, hShadow, lpuHintFlags, lpuHintPri);

    if (lpFind32)
    {
        Assert(lpFind32W);
        Find32WToFind32A(lpFind32W, lpFind32);
    }

    return (iRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\usermode\reint\api.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    api.c

Abstract:

    reintegration functions

    Contents:

Author:
    Shishir Pardikar


Environment:

    Win32 (user-mode) DLL

Revision History:

    4/24/97 Created  shishirp

--*/

#include "pch.h"


#ifdef CSC_ON_NT
#include <winioctl.h>
#define UNICODE
#endif //CSC_ON_NT

#include "shdcom.h"
#include "shdsys.h"
#include "reint.h"
#include "utils.h"
#include "resource.h"
#include "strings.h"
// this sets flags in a couple of headers to not include some defs.
#define REINT
#include "lib3.h"
#include "cscapi.h"

//
// Defines/structures
//

#define SHADOW_FIND_SIGNATURE           0x61626162  // abab
#define FLAG_SHADOW_FIND_TERMINATED     0x00000001


typedef struct tagSHADOW_FIND
{
    DWORD   dwSignature;    // for validation
    DWORD   dwFlags;
    HANDLE  hShadowDB;
    ULONG   ulPrincipalID;
    CSC_ENUMCOOKIE  uEnumCookie;
}
SHADOW_FIND, *LPSHADOW_FIND;

typedef struct tagMST_LIST
{
    struct tagMST_LIST *lpNext;
    HSHADOW             hDir;
} MST_LIST, *LPMST_LIST;

typedef struct tagMOVE_SUBTREE
{
    DWORD       dwFlags;
    DWORD       cntFail;
    HSHARE     hShareTo;
    LPCTSTR     lptzSource;
    LPCTSTR     lptzDestination;
    LPMST_LIST  lpTos;
    MST_LIST    sTos;
    SHADOWINFO  sSI;
    WIN32_FIND_DATA sFind32;
} MOVE_SUBTREE, *LPMOVE_SUBTREE;

#define MST_REPLACE_IF_EXISTS   0x00000001
#define MST_SHARE_MARKED_DIRTY  0x00000002
#define MST_MARK_AS_LOCAL       0x00000004

typedef struct tagSET_SUBTREE_STATUS
{
    DWORD       dwFlags;
    ULONG       uStatus;
    ULONG       uOp;

} SET_SUBTREE_STATUS, *LPSET_SUBTREE_STATUS;



#define EDS_FLAG_ERROR_ENCOUNTERED   0x00000001

typedef struct tagENCRYPT_DECRYPT_SUBTREE
{
    DWORD       dwFlags;
    BOOL        fEncrypt;
    LPCSCPROCW  lpfnEnumProgress;
    DWORD_PTR   dwContext;
    DWORD       dwEndingNameSpaceVersion;
}ENCRYPT_DECRYPT_SUBTREE, *LPENCRYPT_DECRYPT_SUBTREE;

BOOL
CheckCSCAccessForThread(
    HSHADOW hDir,
    HSHADOW hShadow,
    BOOL    fWrite
    );

int
MoveSubtree(
    HANDLE          hShadowDB,
    LPSECURITYINFO  pShareSecurityInfo,
    LPTSTR          lptzFullPath,
    DWORD           dwCallbackReason,
    WIN32_FIND_DATA *lpFind32,
    SHADOWINFO      *lpSI,
    LPMOVE_SUBTREE  lpMst
    );

int
SetSubtreeStatus(
    HANDLE          hShadowDB,
    LPSECURITYINFO  pShareSecurityInfo,
    LPTSTR          lptzFullPath,
    DWORD           dwCallbackReason,
    WIN32_FIND_DATA *lpFind32,
    SHADOWINFO      *lpSI,
    LPSET_SUBTREE_STATUS  lpSss
    );

int
EncryptDecryptSubtree(
    HANDLE          hShadowDB,
    LPSECURITYINFO  pShareSecurityInfo,
    LPTSTR          lptzFullPath,
    DWORD           dwCallbackReason,
    WIN32_FIND_DATA *lpFind32,
    SHADOWINFO      *lpSI,
    LPENCRYPT_DECRYPT_SUBTREE  lpEds
    );

BOOL
UncPathToDfsPath(
    PWCHAR UncPath,
    PWCHAR DfsPath,
    ULONG cbLen);

BOOL
IsPersonal(VOID);

//
// local data
//
static TCHAR vszStarDotStar[] = _TEXT("*.*");
static TCHAR vszStar[] = _TEXT("*");

static TCHAR vszPrefix[] = _TEXT("CSC");
AssertData;
AssertError;


//
// functions
//

BOOL
WINAPI
CSCIsCSCEnabled(
    VOID
)
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    unsigned ulSwitch = SHADOW_SWITCH_SHADOWING;

    if(ShadowSwitches(INVALID_HANDLE_VALUE, &ulSwitch, SHADOW_SWITCH_GET_STATE))
    {
        return((ulSwitch & SHADOW_SWITCH_SHADOWING)!=0);
    }

    return FALSE;
}

BOOL
WINAPI
CSCGetSpaceUsageA(
    LPSTR  lptzLocation,
    DWORD   dwSize,
    LPDWORD lpdwMaxSpaceHigh,
    LPDWORD lpdwMaxSpaceLow,
    LPDWORD lpdwCurrentSpaceHigh,
    LPDWORD lpdwCurrentSpaceLow,
    LPDWORD lpcntTotalFiles,
    LPDWORD lpcntTotalDirs
)
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
#ifdef UNICODE
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
#else
    SHADOWSTORE sST;
    WIN32_FIND_DATA sFind32;
    BOOL    fRet = FALSE;
    DWORD   dwLen;

    // NTRAID#455247-1/31/2000-shishirp parameter validation
    if (GetShadowDatabaseLocation(INVALID_HANDLE_VALUE, &sFind32))
    {
        memset(lptzLocation, 0, sizeof(dwSize));
        WideCharToMultiByte(CP_ACP, 0, sFind32.cFileName, wcslen(sFind32.cFileName), lptzLocation, dwSize, NULL, NULL);

        if (GetSpaceStats(INVALID_HANDLE_VALUE, &sST))
        {
            *lpdwMaxSpaceHigh = 0;
            *lpdwMaxSpaceLow = sST.sMax.ulSize;
            *lpdwCurrentSpaceHigh = 0;
            *lpdwCurrentSpaceLow = sST.sCur.ulSize;
            *lpcntTotalFiles = sST.sCur.ucntFiles;
            *lpcntTotalFiles = sST.sCur.ucntDirs;
            fRet = TRUE;
        }

    }
    return fRet;
#endif
}

BOOL
WINAPI
CSCGetSpaceUsageW(
    LPTSTR  lptzLocation,
    DWORD   dwSize,
    LPDWORD lpdwMaxSpaceHigh,
    LPDWORD lpdwMaxSpaceLow,
    LPDWORD lpdwCurrentSpaceHigh,
    LPDWORD lpdwCurrentSpaceLow,
    LPDWORD lpcntTotalFiles,
    LPDWORD lpcntTotalDirs
)
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
#ifndef UNICODE
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
#else
    SHADOWSTORE sST;
    WIN32_FIND_DATA sFind32;
    BOOL    fRet = FALSE;

    // NTRAID#455247-1/31/2000-shishirp parameter validation
    if (GetShadowDatabaseLocation(INVALID_HANDLE_VALUE, &sFind32))
    {
        memset(lptzLocation, 0, sizeof(dwSize));
        wcsncpy(lptzLocation, sFind32.cFileName, dwSize/sizeof(USHORT)-1);

        if (GetSpaceStats(INVALID_HANDLE_VALUE, &sST))
        {
            *lpdwMaxSpaceHigh = 0;
            *lpdwMaxSpaceLow = sST.sMax.ulSize;
            *lpdwCurrentSpaceHigh = 0;
            *lpdwCurrentSpaceLow = sST.sCur.ulSize;
            *lpcntTotalFiles = sST.sCur.ucntFiles;
            *lpcntTotalDirs = sST.sCur.ucntDirs;
            fRet = TRUE;
        }

    }
    return fRet;
#endif
}

BOOL
WINAPI
CSCSetMaxSpace(
    DWORD   nFileSizeHigh,
    DWORD   nFileSizeLow
)
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    int iRet;

    // 2GB is our limit
    if ((nFileSizeHigh)||(nFileSizeLow > 0x7fffffff))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    iRet = SetMaxShadowSpace(INVALID_HANDLE_VALUE, (long)nFileSizeHigh, (long)nFileSizeLow);

    if (iRet<0)
    {
        SetLastError(ERROR_INTERNAL_ERROR);
    }

    return (iRet >= 1);
}

BOOL
CSCPinFileInternal(
    LPCTSTR     lpszFileName,
    DWORD       dwHintFlags,
    LPDWORD     lpdwStatus,
    LPDWORD     lpdwPinCount,
    LPDWORD     lpdwHintFlags
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    WIN32_FIND_DATA sFind32;
    SHADOWINFO sSI;
    BOOL fCreated, fRet = FALSE;
    DWORD   dwError = ERROR_GEN_FAILURE;

    // NTRAID#455247-1/31/2000-shishirp parameter validation !!!!


    if (BeginInodeTransactionHSHADOW())
    {
        if(FindCreateShadowFromPath(lpszFileName, TRUE, &sFind32, &sSI, &fCreated))
        {
            sSI.ulHintFlags = dwHintFlags;

            fRet = (AddHintFromInode(    INVALID_HANDLE_VALUE,
                                        sSI.hDir,
                                        sSI.hShadow,
                                        &(sSI.ulHintPri),
                                        &(sSI.ulHintFlags)
                                        ) != 0);

            if (fRet)
            {
                if (lpdwStatus)
                {
                    *lpdwStatus = sSI.uStatus;
                }
                if (lpdwPinCount)
                {
                    *lpdwPinCount = sSI.ulHintPri;
                }
                if (lpdwHintFlags)
                {
                    *lpdwHintFlags = sSI.ulHintFlags;
                }

            }
            else
            {
                dwError = ERROR_INVALID_FUNCTION;
            }
        }
        else
        {
            dwError = GetLastError();
        }

        EndInodeTransactionHSHADOW();
    }
    if (!fRet)
    {
        Assert(dwError != ERROR_SUCCESS);
        SetLastError(dwError);
    }
    return fRet;
}


BOOL
CSCUnpinFileInternal(
    LPCTSTR lpszFileName,
    IN      DWORD   dwHintFlags,
    LPDWORD lpdwStatus,
    LPDWORD lpdwPinCount,
    LPDWORD lpdwHintFlags
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    WIN32_FIND_DATA sFind32;
    SHADOWINFO sSI;
    BOOL fRet = FALSE;
    DWORD   dwError = ERROR_GEN_FAILURE;

    // NTRAID#455247-1/31/2000-shishirp parameter validation !!!!


    if (BeginInodeTransactionHSHADOW())
    {
        if(FindCreateShadowFromPath(lpszFileName, FALSE, &sFind32, &sSI, NULL))
        {
            sSI.ulHintFlags = dwHintFlags;

            fRet = (DeleteHintFromInode(    INVALID_HANDLE_VALUE,
                                            sSI.hDir,
                                            sSI.hShadow,
                                            &(sSI.ulHintPri),
                                            &(sSI.ulHintFlags)
                                            ) != 0);

            if (fRet)
            {
                if (lpdwStatus)
                {
                    *lpdwStatus = sSI.uStatus;
                }
                if (lpdwPinCount)
                {
                    *lpdwPinCount = sSI.ulHintPri;
                }
                if (lpdwHintFlags)
                {
                    *lpdwHintFlags = sSI.ulHintFlags;
                }
            }
            else
            {
                dwError = ERROR_INVALID_FUNCTION;
            }
            
        }
        else
        {
            dwError = GetLastError();
        }

        EndInodeTransactionHSHADOW();

    }

    if (!fRet)
    {
        SetLastError(dwError);
    }

    return fRet;
}

BOOL
CSCQueryFileStatusInternal(
    LPCTSTR  lpszFileName,
    LPDWORD lpdwStatus,
    LPDWORD lpdwPinCount,
    LPDWORD lpdwHintFlags,
    LPDWORD lpdwUserPerms,
    LPDWORD lpdwOtherPerms
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{

    WIN32_FIND_DATA sFind32;
    SHADOWINFO sSI;

    // NTRAID#455247-1/31/2000-shishirp parameter validation !!!!


    if (FindCreateShadowFromPath(lpszFileName, FALSE, &sFind32, &sSI, NULL) != TRUE)
        return FALSE;

    if (lpdwStatus != NULL) {
        *lpdwStatus = sSI.uStatus;
        // return accessmask for files or the root
        if ((sSI.uStatus & SHADOW_IS_FILE)||(!sSI.hDir)) {
            if (sSI.hShadow) {
                ULONG ulPrincipalID;

                if (!GetCSCPrincipalID(&ulPrincipalID))
                    ulPrincipalID = CSC_GUEST_PRINCIPAL_ID;                            

                GetCSCAccessMaskForPrincipalEx(
                    ulPrincipalID,
                    sSI.hDir,
                    sSI.hShadow,
                    lpdwStatus,
                    lpdwUserPerms,
                    lpdwOtherPerms);

                Assert((*lpdwStatus & ~FLAG_CSC_ACCESS_MASK) == sSI.uStatus);

                if (lpdwUserPerms != NULL && lpdwOtherPerms != NULL) {

                    ULONG i;
                    ULONG GuestIdx = CSC_MAXIMUM_NUMBER_OF_CACHED_PRINCIPAL_IDS;
                    ULONG UserIdx = CSC_MAXIMUM_NUMBER_OF_CACHED_PRINCIPAL_IDS;
                    SECURITYINFO rgsSecurityInfo[CSC_MAXIMUM_NUMBER_OF_CACHED_PRINCIPAL_IDS];
                    _TCHAR  tchBuff[MAX_SERVER_SHARE_NAME_FOR_CSC];
                    ULONG nRet = 0;
                    DWORD dwDummy;
                    WIN32_FIND_DATA sFind32;
                    SHADOWINFO sSI2;
                    BOOL fDone = FALSE;

                    // DbgPrint("CSCQueryFileStatusInternal(%ws)\n", lpszFileName);

                    if (lstrlen(lpszFileName) >= MAX_SERVER_SHARE_NAME_FOR_CSC)
                        goto AllDone;

                    lstrcpy(tchBuff, lpszFileName);

                    if (!LpBreakPath(tchBuff, TRUE, &fDone))
                        goto AllDone;

                    // DbgPrint("   tchBuff=%ws\n", tchBuff);

                    if (!FindCreateShadowFromPath(tchBuff, FALSE, &sFind32, &sSI2, NULL))
                        goto AllDone;

                    // DbgPrint("CSCQueryFileStatusInternal: hShare=0x%x,hShadow=0x%x,hDir=0x%x\n",
                    //                         sSI2.hShare,
                    //                         sSI2.hShadow,
                    //                         sSI2.hDir);

                    dwDummy = sizeof(rgsSecurityInfo);
                    nRet = GetSecurityInfoForCSC(
                               INVALID_HANDLE_VALUE,
                               0,
                               sSI2.hShadow,
                               rgsSecurityInfo,
                               &dwDummy);

                    // DbgPrint("     GetSecurityInfoForCSC returned %d\n", nRet);

                    if (nRet == 0)
                        goto AllDone;

                    //
                    // Find the user's and guest's entries
                    //
                    for (i = 0; i < CSC_MAXIMUM_NUMBER_OF_CACHED_PRINCIPAL_IDS; i++) {
                        if (rgsSecurityInfo[i].ulPrincipalID == ulPrincipalID)
                            UserIdx = i;
                        if (rgsSecurityInfo[i].ulPrincipalID == CSC_GUEST_PRINCIPAL_ID)
                            GuestIdx = i;
                    }
                    if (GuestIdx < CSC_MAXIMUM_NUMBER_OF_CACHED_PRINCIPAL_IDS) {
                        if (UserIdx >= CSC_MAXIMUM_NUMBER_OF_CACHED_PRINCIPAL_IDS)
                            UserIdx = GuestIdx;

                        *lpdwUserPerms &= rgsSecurityInfo[UserIdx].ulPermissions;
                        *lpdwOtherPerms &= rgsSecurityInfo[GuestIdx].ulPermissions;

                        // DbgPrint("UserPerms=0x%x,OtherPerms=0x%x\n",
                        //                 *lpdwUserPerms,
                        //                 *lpdwOtherPerms);
                    }
                }
            }
        }
    }

AllDone:

    if (lpdwPinCount) {
        *lpdwPinCount = sSI.ulHintPri;
    }
    if (lpdwHintFlags) {
        *lpdwHintFlags = sSI.ulHintFlags;
    }
    return TRUE;
}


HANDLE
CSCFindFirstFileInternal(
    LPCTSTR             lpszFileName,
    ULONG               ulPrincipalID,
    WIN32_FIND_DATA     *lpFind32,
    LPDWORD             lpdwStatus,
    LPDWORD             lpdwPinCount,
    LPDWORD             lpdwHintFlags,
    FILETIME            *lpOrgFileTime
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    SHADOWINFO sSI;
    BOOL fRet = FALSE;
    LPSHADOW_FIND   lpShadowFind = NULL;

    // NTRAID#455247-1/31/2000-shishirp parameter validation !!!!


    if (lpszFileName && *lpszFileName)
    {
        fRet = FindCreateShadowFromPath(
                        lpszFileName,   // UNC path
                        FALSE,          // don't create
                        lpFind32,
                        &sSI,
                        NULL);

        if (fRet && !sSI.hShadow)
        {
            // a situation where, the share is connected but it's entry is
            // not in the database
            fRet = FALSE;
        }

    }
    else
    {
        memset(&sSI, 0, sizeof(sSI));   // sSI.hShadow is 0 => we are enumerating all shares
        lpFind32->dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY;
        fRet = TRUE;
    }

    if (fRet)
    {
        fRet = FALSE;

        // Found the shadow
        if (lpShadowFind = AllocMem(sizeof(SHADOW_FIND)))
        {
            lpShadowFind->dwSignature = SHADOW_FIND_SIGNATURE;
            lpShadowFind->hShadowDB = INVALID_HANDLE_VALUE;

            if (ulPrincipalID != CSC_INVALID_PRINCIPAL_ID)
            {
                lpShadowFind->ulPrincipalID = ulPrincipalID;
            }
            else
            {
                if (!GetCSCPrincipalID(&lpShadowFind->ulPrincipalID))
                {
                    lpShadowFind->ulPrincipalID = CSC_GUEST_PRINCIPAL_ID;                            
                }
            }

            if (!(lpFind32->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                lpShadowFind->dwFlags |= FLAG_SHADOW_FIND_TERMINATED;
                fRet = TRUE;
            }
            else
            {
//              lpShadowFind->hShadowDB = OpenShadowDatabaseIO();

//              if (lpShadowFind->hShadowDB != INVALID_HANDLE_VALUE)
                {
#ifndef CSC_ON_NT
                    lstrcpy(lpFind32->cFileName, vszStarDotStar);
#else
                    lstrcpy(lpFind32->cFileName, vszStar);
#endif

                    if(FindOpenShadow(
                                    lpShadowFind->hShadowDB,
                                    sSI.hShadow,
                                    FINDOPEN_SHADOWINFO_ALL,
                                    lpFind32,
                                    &sSI
                                    ))
                    {
                        lpShadowFind->uEnumCookie = sSI.uEnumCookie;

                        fRet = TRUE;
                    }
                }
            }
        }
    }

    if (!fRet)
    {
        if (lpShadowFind)
        {
            if (lpShadowFind->hShadowDB != INVALID_HANDLE_VALUE)
            {
                CloseShadowDatabaseIO(lpShadowFind->hShadowDB);
            }

            FreeMem(lpShadowFind);
    
        }

        EndInodeTransactionHSHADOW();

        return (INVALID_HANDLE_VALUE);
    }
    else
    {

        if (lpdwStatus)
        {
            *lpdwStatus = (DWORD)(sSI.uStatus);

            // return accessmask for files or the root
            if ((sSI.uStatus & SHADOW_IS_FILE)||(!sSI.hDir))
            {
                GetCSCAccessMaskForPrincipal(lpShadowFind->ulPrincipalID, sSI.hDir, sSI.hShadow, lpdwStatus);
                Assert((*lpdwStatus & ~FLAG_CSC_ACCESS_MASK) == sSI.uStatus);
            }

        }
        if (lpdwPinCount)
        {
            *lpdwPinCount = (DWORD)(sSI.ulHintPri);
        }
        if (lpdwHintFlags)
        {
            *lpdwHintFlags = sSI.ulHintFlags;
        }
        if (lpOrgFileTime)
        {
            *lpOrgFileTime = lpFind32->ftLastAccessTime;
        }

        return ((HANDLE)lpShadowFind);
    }
}


BOOL
CSCFindNextFileInternal(
    HANDLE  hFind,
    WIN32_FIND_DATA     *lpFind32,
    LPDWORD             lpdwStatus,
    LPDWORD             lpdwPinCount,
    LPDWORD             lpdwHintFlags,
    FILETIME            *lpOrgFileTime
)
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    LPSHADOW_FIND lpShadowFind = (LPSHADOW_FIND)hFind;
    BOOL fRet = FALSE;
    SHADOWINFO sSI;

    // validate parameters !!!!

    if (lpShadowFind->dwFlags & FLAG_SHADOW_FIND_TERMINATED)
    {
        SetLastError(ERROR_NO_MORE_FILES);
        return FALSE;
    }
    else
    {
        if (!FindNextShadow(    lpShadowFind->hShadowDB,
                            lpShadowFind->uEnumCookie,
                            lpFind32,
                            &sSI
                            ))
        {
            lpShadowFind->dwFlags |= FLAG_SHADOW_FIND_TERMINATED;
            SetLastError(ERROR_NO_MORE_FILES);          
        }
        else
        {
            if (lpdwStatus)
            {
                *lpdwStatus = (DWORD)(sSI.uStatus);

                // return accessmask for files or the root
                if ((sSI.uStatus & SHADOW_IS_FILE)||(!sSI.hDir))
                {
                    GetCSCAccessMaskForPrincipal(lpShadowFind->ulPrincipalID, sSI.hDir, sSI.hShadow, lpdwStatus);                            
                    Assert((*lpdwStatus & ~FLAG_CSC_ACCESS_MASK) == sSI.uStatus);
                }
            }
            if (lpdwPinCount)
            {
                *lpdwPinCount = (DWORD)(sSI.ulHintPri);
            }
            if (lpdwHintFlags)
            {
                *lpdwHintFlags = sSI.ulHintFlags;
            }

            if (lpOrgFileTime)
            {
                *lpOrgFileTime = lpFind32->ftLastAccessTime;
            }
            fRet = TRUE;
        }
    }
    return (fRet);
}

BOOL
WINAPI
CSCFindClose(
    HANDLE  hFind
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    LPSHADOW_FIND lpShadowFind = (LPSHADOW_FIND)hFind;

    if (lpShadowFind->uEnumCookie)
    {
        // don't check any errors
        FindCloseShadow(lpShadowFind->hShadowDB, lpShadowFind->uEnumCookie);
    }

    if (lpShadowFind->hShadowDB != INVALID_HANDLE_VALUE)
    {
        CloseShadowDatabaseIO(lpShadowFind->hShadowDB);
    }

    FreeMem(lpShadowFind);

    return (TRUE);
}


BOOL
CSCDeleteInternal(
    LPCTSTR lpszName
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    WIN32_FIND_DATA sFind32;
    SHADOWINFO sSI;
    BOOL fRet = FALSE;
    DWORD   dwError = ERROR_GEN_FAILURE;

    // NTRAID#455247 -1/31/2000-shishirp parameter validation !!!!

    ReintKdPrint(API, ("Delete %ls\r\n", lpszName));

    if (BeginInodeTransactionHSHADOW())
    {

        if(FindCreateShadowFromPath(lpszName, FALSE, &sFind32, &sSI, NULL))
        {

            ReintKdPrint(API, ("Delete Inode %x %x\r\n", sSI.hDir, sSI.hShadow));

            if (DeleteShadow(INVALID_HANDLE_VALUE, sSI.hDir, sSI.hShadow))
            {
                fRet = TRUE;
            }
            else
            {
                dwError = ERROR_ACCESS_DENIED;
            }
        }
        else
        {
            dwError = GetLastError();
        }

        EndInodeTransactionHSHADOW();
    }

    if (!fRet)
    {
        SetLastError(dwError);
    }

    return fRet;
}


BOOL
CSCFillSparseFilesInternal(
    IN  LPCTSTR     lpszShareOrFileName,
    IN  BOOL        fFullSync,
    IN  LPCSCPROC   lpfnFillProgress,
    IN  DWORD_PTR   dwContext
)
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    WIN32_FIND_DATA sFind32;
    SHADOWINFO sSI;
    DWORD   dwError = ERROR_INVALID_PARAMETER, dwRet;
    LPCOPYPARAMS lpCP = NULL;
    ULONG   ulPrincipalID;

    if (!GetCSCPrincipalID(&ulPrincipalID))
    {
        ulPrincipalID = CSC_GUEST_PRINCIPAL_ID;                            
    }
    if(FindCreateShadowFromPath(lpszShareOrFileName, FALSE, &sFind32, &sSI, NULL))
    {
        if (!sSI.hDir)
        {
            dwError = NO_ERROR;

            // if this is a share
            dwRet = (*lpfnFillProgress)(
                                    lpszShareOrFileName,
                                    sSI.uStatus,
                                    sSI.ulHintFlags,
                                    sSI.ulHintPri,
                                    &sFind32,
                                    CSCPROC_REASON_BEGIN,
                                    0,
                                    0,
                                    dwContext
                                    );
            if (dwRet == CSCPROC_RETURN_CONTINUE)
            {
                AttemptCacheFill(sSI.hShare, DO_ALL, fFullSync, ulPrincipalID, lpfnFillProgress, dwContext);
            }
            else
            {
                if (dwRet == CSCPROC_RETURN_ABORT)
                {
                    dwError = ERROR_OPERATION_ABORTED;
                }
            }

            (*lpfnFillProgress)(
                                lpszShareOrFileName,
                                sSI.uStatus,
                                sSI.ulHintFlags,
                                sSI.ulHintPri,
                                &sFind32,
                                CSCPROC_REASON_END,
                                0,
                                0,
                                dwContext
                                );
        }
        else if (!(sFind32.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            BOOL    fStalenessCheck;
            dwError = NO_ERROR;

            fStalenessCheck = (fFullSync || (sSI.uStatus & SHADOW_STALE));

            if (fStalenessCheck)
            {
                if (!(lpCP = LpAllocCopyParams()))
                {
                    dwError = GetLastError();
                    Assert(dwError != NO_ERROR);

                }
                else if(!GetUNCPath(INVALID_HANDLE_VALUE, sSI.hShare, sSI.hDir, sSI.hShadow, lpCP))
                {
                    Assert(lpCP);
                    FreeCopyParams(lpCP);
                    dwError = GetLastError();
                    Assert(dwError != NO_ERROR);
                }
            }

            if ((dwError == NO_ERROR) &&
                (fStalenessCheck || (sSI.uStatus & SHADOW_SPARSE))) {

                dwError = DoSparseFill( INVALID_HANDLE_VALUE,
                                        (LPTSTR)lpszShareOrFileName,
                                        NULL,
                                        &sSI,
                                        &sFind32,
                                        lpCP,
                                        fStalenessCheck,
                                        ulPrincipalID,
                                        lpfnFillProgress,
                                        dwContext);
            }

            if (lpCP)
            {
                FreeCopyParams(lpCP);
                lpCP = NULL;
            }
        }
    }
    else
    {
        dwError = GetLastError();
    }

    if (dwError != NO_ERROR)
    {
        SetLastError(dwError);
        return FALSE;
    }

    return TRUE;

}



BOOL
CSCMergeShareInternal(
    IN  LPCTSTR     lpszShareName,
    IN  LPCSCPROC   lpfnMergeProgress,
    IN  DWORD_PTR   dwContext
)
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{

    WIN32_FIND_DATA sFind32;
    SHADOWINFO sSI;
    int cntDriveMapped = 0;
    BOOL    fTransitionedToOnline = FALSE, fDone=FALSE;
    _TCHAR  tchBuff[MAX_SERVER_SHARE_NAME_FOR_CSC];
    DWORD   dwError = ERROR_SUCCESS;
    ULONG   ulPrincipalID;

    if (!GetCSCPrincipalID(&ulPrincipalID))
    {
        ulPrincipalID = CSC_GUEST_PRINCIPAL_ID;                            
    }

    if (lstrlen(lpszShareName) >= MAX_SERVER_SHARE_NAME_FOR_CSC)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    lstrcpy(tchBuff, lpszShareName);

    if (!LpBreakPath(tchBuff, TRUE, &fDone) && !fDone)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if(FindCreateShadowFromPath(tchBuff, FALSE, &sFind32, &sSI, NULL))
    {

        fDone = ReintOneShare(sSI.hShare, sSI.hShadow, NULL, NULL, NULL, ulPrincipalID, lpfnMergeProgress, dwContext);

        if (!fDone)
        {
            dwError = GetLastError();
        }

//        TransitionShareToOnline(INVALID_HANDLE_VALUE, sSI.hShare);

        if (!fDone)
        {
            SetLastError(dwError);
        }

        return fDone;
    }

    return FALSE;

}


BOOL
CSCCopyReplicaInternal(
    IN  LPCTSTR lpszFullPath,
    OUT LPTSTR  *lplpszLocalName
)
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{

    WIN32_FIND_DATA sFind32;
    SHADOWINFO sSI;
    BOOL fRet = FALSE;
    DWORD   dwError = ERROR_GEN_FAILURE;

    if (BeginInodeTransactionHSHADOW())
    {
        if(FindCreateShadowFromPath(lpszFullPath, FALSE, &sFind32, &sSI, NULL))
        {
            if (sFind32.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                dwError = ERROR_INVALID_PARAMETER;
                goto bailout;
            }

            if (!CheckCSCAccessForThread(sSI.hDir, sSI.hShadow, FALSE))
            {
                dwError = GetLastError();
                goto bailout;
            }

            if (!(*lplpszLocalName = GetTempFileForCSC(NULL)))
            {
                goto bailout;
            }

            if(!CopyShadow(INVALID_HANDLE_VALUE, sSI.hDir, sSI.hShadow, *lplpszLocalName))
            {
                LocalFree(*lplpszLocalName);
                *lplpszLocalName = NULL;
                goto bailout;
            }

            fRet = TRUE;
        }
        else
        {
            dwError = GetLastError();
        }

        EndInodeTransactionHSHADOW();
    }
bailout:
    if (!fRet)
    {
        SetLastError(dwError);
    }
    return fRet;
}

BOOL
CSCEnumForStatsInternal(
    IN  LPCTSTR     lpszShareName,
    IN  LPCSCPROC   lpfnEnumProgress,
    IN  BOOL        fPeruserInfo,
    IN  BOOL        fUpdateShareReintBit,
    IN  DWORD_PTR   dwContext
)
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    WIN32_FIND_DATA sFind32;
    SHADOWINFO sSI;
    BOOL    fRet = TRUE;
    PQPARAMS sPQP;
    HANDLE hShadowDB = INVALID_HANDLE_VALUE;
    DWORD   dwRet;
    ULONG ulPrincipalID = CSC_INVALID_PRINCIPAL_ID;

    if (lpszShareName)
    {

        if(!FindCreateShadowFromPath(lpszShareName, FALSE, &sFind32, &sSI, NULL))
        {
            fRet = FALSE;
        }
    }
    else
    {
        sSI.hShare = 0;
    }
    if (fRet)
    {
        fRet = FALSE;

        if ((hShadowDB = OpenShadowDatabaseIO())==INVALID_HANDLE_VALUE)
        {
            goto bailout;
        }

        if (lpfnEnumProgress)
        {
            dwRet = (*lpfnEnumProgress)(NULL, 0, 0, 0, NULL, CSCPROC_REASON_BEGIN, 0, 0, dwContext);

            if (dwRet != CSCPROC_RETURN_CONTINUE )
            {
                goto bailout;
            }
        }

        if (fPeruserInfo)
        {

            if (!GetCSCPrincipalID(&ulPrincipalID))
            {
                ulPrincipalID = CSC_GUEST_PRINCIPAL_ID;                            
            }
        }

        memset(&sPQP, 0, sizeof(sPQP));

        if(BeginPQEnum(hShadowDB, &sPQP) == 0) {
            goto bailout;
        }

        do {

            if(NextPriShadow(hShadowDB, &sPQP) == 0) {
                break;
            }

            if (!sPQP.hShadow) {
                break;
            }

            if (!sSI.hShare || (sSI.hShare == sPQP.hShare))
            {
                if (fPeruserInfo)
                {

                    // return accessmask for files or the root
                    if ((sPQP.ulStatus & SHADOW_IS_FILE)||(!sPQP.hDir))
                    {
                        GetCSCAccessMaskForPrincipal(ulPrincipalID, sPQP.hDir, sPQP.hShadow, &sPQP.ulStatus);
                    }
                }
                
                if (lpfnEnumProgress)
                {
                    // if we are enumerating for a particular share
                    // besides status, report whether file or directory and whether a root or a non-root
                    dwRet = (*lpfnEnumProgress)(NULL, sPQP.ulStatus & ~SHADOW_IS_FILE, sPQP.ulHintFlags, sPQP.ulHintPri, NULL, CSCPROC_REASON_MORE_DATA, (mShadowIsFile(sPQP.ulStatus) != 0), (sPQP.hDir==0), dwContext);
                
                    if (dwRet != CSCPROC_RETURN_CONTINUE )
                    {
                        break;
                    }
                }

                // if we are enumerating for a particular share
                // then make sure that the share dirty bit matches with what we got on the
                // actual files
                if (fUpdateShareReintBit && sSI.hShare && (sSI.hShare == sPQP.hShare))
                {
                    if (mShadowNeedReint(sPQP.ulStatus) && !(sSI.uStatus & SHARE_REINT))
                    {
                        if(SetShareStatus(hShadowDB, sSI.hShare, SHARE_REINT, SHADOW_FLAGS_OR))
                        {
                            sSI.uStatus |= SHARE_REINT;
                        }
                    }
                }
            }


        } while (sPQP.uPos);

        // Close the enumeration
        EndPQEnum(hShadowDB, &sPQP);

        if (lpfnEnumProgress)
        {
            dwRet = (*lpfnEnumProgress)(NULL, 0, 0, 0, NULL, CSCPROC_REASON_END, 0, 0, dwContext);
        }

        fRet = TRUE;
    }

bailout:

    if (hShadowDB != INVALID_HANDLE_VALUE)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    return fRet;
}


BOOL
WINAPI
CSCPinFileA(
    IN  LPCSTR  lpszFileName,
    IN  DWORD   dwHintFlags,
    IN  LPDWORD lpdwStatus,
    IN  LPDWORD lpdwPinCount,
    IN  LPDWORD lpdwHintFlags
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
#ifdef UNICODE
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
#else
    return (CSCPinFileInternal(lpszFileName, dwHintFlags, lpdwStatus, lpdwPinCount, lpdwHintFlags));
#endif
}

BOOL
WINAPI
CSCUnpinFileA(
    IN  LPCSTR  lpszFileName,
    IN  DWORD   dwHintFlags,
    IN  LPDWORD lpdwStatus,
    IN  LPDWORD lpdwPinCount,
    IN  LPDWORD lpdwHintFlags
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
#ifdef UNICODE
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
#else
    return (CSCUnpinFileInternal(lpszFileName, dwHintFlags, lpdwStatus, lpdwPinCount, lpdwHintFlags));
#endif
}

BOOL
WINAPI
CSCQueryFileStatusA(
    LPCSTR              lpszFileName,
    LPDWORD             lpdwStatus,
    LPDWORD             lpdwPinCount,
    LPDWORD             lpdwHintFlags
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
#ifdef UNICODE
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
#else
    return (CSCQueryFileStatusInternal(
                        lpszFileName,
                        lpdwStatus,
                        lpdwPinCount,
                        lpdwHintFlags,
                        NULL,
                        NULL));
#endif
}

BOOL
WINAPI
CSCQueryFileStatusExA(
    LPCSTR              lpszFileName,
    LPDWORD             lpdwStatus,
    LPDWORD             lpdwPinCount,
    LPDWORD             lpdwHintFlags,
    LPDWORD             lpdwUserPerms,
    LPDWORD             lpdwOtherPerms
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
#ifdef UNICODE
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
#else
    return (CSCQueryFileStatusInternal(
                        lpszFileName,
                        lpdwStatus,
                        lpdwPinCount,
                        lpdwHintFlags,
                        lpdwUserPerms,
                        llpdwOtherPerms));
#endif
}

BOOL
WINAPI
CSCQueryShareStatusA(
    LPCSTR              lpszFileName,
    LPDWORD             lpdwStatus,
    LPDWORD             lpdwPinCount,
    LPDWORD             lpdwHintFlags,
    LPDWORD             lpdwUserPerms,
    LPDWORD             lpdwOtherPerms)
{
#ifdef UNICODE
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
#else
    return (CSCQueryFileStatusInternal(
                        lpszFileName,
                        lpdwStatus,
                        lpdwPinCount,
                        lpdwHintFlags,
                        lpdwUserPerms,
                        llpdwOtherPerms));
#endif
}

HANDLE
WINAPI
CSCFindFirstFileA(
    LPCSTR              lpszFileName,
    WIN32_FIND_DATA     *lpFind32,
    LPDWORD             lpdwStatus,
    LPDWORD             lpdwPinCount,
    LPDWORD             lpdwHintFlags,
    FILETIME            *lpOrgFileTime
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
#ifdef UNICODE
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
#else
    return (CSCFindFirstFileInternal(
                        lpszFileName,
                        CSC_INVALID_PRINCIPAL_ID,
                        lpFind32,
                        lpdwStatus,
                        lpdwPinCount,
                        lpdwHintFlags,
                        lpOrgFileTime
                        ));
#endif

}

HANDLE
WINAPI
CSCFindFirstFileForSidA(
    LPCSTR              lpszFileName,
    PSID                pSid,
    WIN32_FIND_DATA     *lpFind32,
    LPDWORD             lpdwStatus,
    LPDWORD             lpdwPinCount,
    LPDWORD             lpdwHintFlags,
    FILETIME            *lpOrgFileTime
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
}

BOOL
WINAPI
CSCFindNextFileA(
    HANDLE  hFind,
    WIN32_FIND_DATA     *lpFind32,
    LPDWORD             lpdwStatus,
    LPDWORD             lpdwPinCount,
    LPDWORD             lpdwHintFlags,
    FILETIME            *lpOrgFileTime
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
#ifdef UNICODE
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
#else
    return(CSCFindNextFileInternal(
            hFind,
            lpFind32,
            lpdwStatus,
            lpdwPinCount,
            lpdwHintFlags,
            lpOrgFileTime
            ));
#endif
}


BOOL
WINAPI
CSCDeleteA(
    LPCSTR  lpszFileName
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
#ifdef UNICODE
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
#else

    return (CSCDeleteInternal(lpszFileName));

#endif

}

BOOL
WINAPI
CSCFillSparseFilesA(
    IN  LPCSTR      lpszShareName,
    IN  BOOL        fFullSync,
    IN  LPCSCPROCA  lpfnFillProgress,
    IN  DWORD_PTR   dwContext
)
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
#ifdef UNICODE
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
#else
    return (CSCFillSparseFilesInternal(
                    lpszShareName,
                    fFullSync,
                    lpfnFillProgress,
                    dwContext));

#endif
}



BOOL
WINAPI
CSCMergeShareA(
    IN  LPCSTR      lpszShareName,
    IN  LPCSCPROCA  lpfnMergeProgress,
    IN  DWORD_PTR   dwContext
)
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
#ifdef UNICODE
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
#else
    return(CSCMergeShareInternal(
                lpszShareName,
                lpfnMergeProgress,
                dwContext));
#endif
}


BOOL
WINAPI
CSCCopyReplicaA(
    IN  LPCSTR  lpszFullPath,
    OUT LPSTR   *lplpszLocalName
)
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
#ifdef UNICODE
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
#else
    return(CSCCopyReplicaInternal(
                lpszFullPath,
                lplpszLocalName));
#endif
}


BOOL
WINAPI
CSCEnumForStatsA(
    IN  LPCSTR      lpszShareName,
    IN  LPCSCPROCA  lpfnEnumProgress,
    IN  DWORD_PTR   dwContext
)
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{

#ifdef UNICODE
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
#else
    return(CSCEnumForStatsInternal(
                lpszShareName,
                lpfnEnumProgress,
                FALSE,
                FALSE,
                dwContext));
#endif
}
BOOL
WINAPI
CSCPinFileW(
    IN  LPCWSTR lpszFileName,
    IN  DWORD   dwHintFlags,
    IN  LPDWORD lpdwStatus,
    IN  LPDWORD lpdwPinCount,
    IN  LPDWORD lpdwHintFlags
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
#ifndef UNICODE
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
#else
    return (CSCPinFileInternal(lpszFileName, dwHintFlags, lpdwStatus, lpdwPinCount, lpdwHintFlags));
#endif
}

BOOL
WINAPI
CSCUnpinFileW(
    IN  LPCWSTR lpszFileName,
    IN  DWORD   dwHintFlags,
    IN  LPDWORD lpdwStatus,
    IN  LPDWORD lpdwPinCount,
    IN  LPDWORD lpdwHintFlags
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
#ifndef UNICODE
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
#else
    return (CSCUnpinFileInternal(lpszFileName, dwHintFlags, lpdwStatus, lpdwPinCount, lpdwHintFlags));
#endif
}

BOOL
WINAPI
CSCQueryFileStatusW(
    LPCWSTR             lpszFileName,
    LPDWORD             lpdwStatus,
    LPDWORD             lpdwPinCount,
    LPDWORD             lpdwHintFlags
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
#ifndef UNICODE
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
#else
    return (CSCQueryFileStatusInternal(
                        lpszFileName,
                        lpdwStatus,
                        lpdwPinCount,
                        lpdwHintFlags,
                        NULL,
                        NULL));
#endif
}

BOOL
WINAPI
CSCQueryFileStatusExW(
    LPCWSTR             lpszFileName,
    LPDWORD             lpdwStatus,
    LPDWORD             lpdwPinCount,
    LPDWORD             lpdwHintFlags,
    LPDWORD             lpdwUserPerms,
    LPDWORD             lpdwOtherPerms
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
#ifndef UNICODE
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
#else
    return (CSCQueryFileStatusInternal(
                        lpszFileName,
                        lpdwStatus,
                        lpdwPinCount,
                        lpdwHintFlags,
                        lpdwUserPerms,
                        lpdwOtherPerms));
#endif
}

BOOL
WINAPI
CSCQueryShareStatusW(
    LPCWSTR             lpszFileName,
    LPDWORD             lpdwStatus,
    LPDWORD             lpdwPinCount,
    LPDWORD             lpdwHintFlags,
    LPDWORD             lpdwUserPerms,
    LPDWORD             lpdwOtherPerms)
{
    BOOL fStatus = FALSE;
    BOOL fDfsStatus = FALSE;
    DWORD dwDfsStatus;
    WCHAR lpszOrgPath[MAX_PATH];
    WCHAR lpszDfsPath[MAX_PATH];
    PWCHAR wCp;
    ULONG sCount;

#ifndef UNICODE
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
#else

    // DbgPrint("CSCQueryShareStatusW(%ws)\n", lpszFileName);

    //
    // Save a copy of the original path passed in
    // 
    wcscpy(lpszOrgPath, lpszFileName);

    // Now truncate to just \\server\share
    for (sCount = 0, wCp = lpszOrgPath; *wCp !=L'\0'; wCp++) {
        if (*wCp == L'\\') {
            if (++sCount == 4) {
                *wCp = L'\0';
                break;
            }
        }
    }

    // DbgPrint("   OrgPath=%ws\n", lpszOrgPath);
    fStatus = CSCQueryFileStatusInternal(
                    lpszOrgPath,
                    lpdwStatus,
                    lpdwPinCount,
                    lpdwHintFlags,
                    lpdwUserPerms,
                    lpdwOtherPerms);

    //
    // If we found info, check if DFS, and (if so)
    // adjust Status
    //
    if (fStatus == TRUE) {
        DWORD Junk;

        lpszDfsPath[0] = L'\0';
        fDfsStatus = UncPathToDfsPath(
                        (PWCHAR)lpszFileName,
                        lpszDfsPath,
                        sizeof(lpszDfsPath));

        if (fDfsStatus != TRUE)
            goto AllDone;

        // DbgPrint("DfsPath(1)=%ws\n", lpszDfsPath);

        // turn into just \\server\share
        for (sCount = 0, wCp = lpszDfsPath; *wCp !=L'\0'; wCp++) {
            if (*wCp == L'\\') {
                if (++sCount == 4) {
                    *wCp = L'\0';
                    break;
                }
            }
        }
        // DbgPrint("DfsPath(2)=%ws\n", lpszDfsPath);
        fDfsStatus = CSCQueryFileStatusInternal(
                        lpszDfsPath,
                        &dwDfsStatus,
                        &Junk,
                        &Junk,
                        &Junk,
                        &Junk);
        if (
            fDfsStatus == TRUE
                &&
            (dwDfsStatus & FLAG_CSC_SHARE_STATUS_CACHING_MASK) == FLAG_CSC_SHARE_STATUS_NO_CACHING
        ) {
            *lpdwStatus &= ~FLAG_CSC_SHARE_STATUS_CACHING_MASK;
            *lpdwStatus |= FLAG_CSC_SHARE_STATUS_NO_CACHING;
            // DbgPrint("New Status=0x%x\n", dwDfsStatus);
        }
    }
AllDone:
    return fStatus;
#endif
}

HANDLE
WINAPI
CSCFindFirstFileW(
    LPCWSTR             lpszFileName,
    WIN32_FIND_DATAW    *lpFind32,
    LPDWORD             lpdwStatus,
    LPDWORD             lpdwPinCount,
    LPDWORD             lpdwHintFlags,
    FILETIME            *lpOrgFileTime
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
#ifndef UNICODE
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (INVALID_HANDLE_VALUE);
#else
    return (CSCFindFirstFileInternal(
                        lpszFileName,
                        CSC_INVALID_PRINCIPAL_ID,
                        lpFind32,
                        lpdwStatus,
                        lpdwPinCount,
                        lpdwHintFlags,
                        lpOrgFileTime
                        ));
#endif

}

HANDLE
WINAPI
CSCFindFirstFileForSidW(
    LPCWSTR             lpszFileName,
    PSID                pSid,
    WIN32_FIND_DATAW    *lpFind32,
    LPDWORD             lpdwStatus,
    LPDWORD             lpdwPinCount,
    LPDWORD             lpdwHintFlags,
    FILETIME            *lpOrgFileTime
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    ULONG   ulPrincipalID;

#ifndef UNICODE
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (INVALID_HANDLE_VALUE);
#else
    if (pSid)
    {
        if(!FindCreatePrincipalIDFromSID(INVALID_HANDLE_VALUE, pSid, GetLengthSid(pSid), &ulPrincipalID, FALSE))
        {
            return INVALID_HANDLE_VALUE;
        }
    }
    else
    {
        ulPrincipalID = CSC_INVALID_PRINCIPAL_ID;
    }

    return (CSCFindFirstFileInternal(
                        lpszFileName,
                        ulPrincipalID,
                        lpFind32,
                        lpdwStatus,
                        lpdwPinCount,
                        lpdwHintFlags,
                        lpOrgFileTime
                        ));
#endif

}

BOOL
WINAPI
CSCFindNextFileW(
    HANDLE  hFind,
    WIN32_FIND_DATAW    *lpFind32,
    LPDWORD             lpdwStatus,
    LPDWORD             lpdwPinCount,
    LPDWORD             lpdwHintFlags,
    FILETIME            *lpOrgFileTime
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
#ifndef UNICODE
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
#else
    return(CSCFindNextFileInternal(
            hFind,
            lpFind32,
            lpdwStatus,
            lpdwPinCount,
            lpdwHintFlags,
            lpOrgFileTime
            ));
#endif
}


BOOL
WINAPI
CSCDeleteW(
    LPCWSTR lpszFileName
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
#ifndef UNICODE
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
#else

    return (CSCDeleteInternal(lpszFileName));

#endif

}

BOOL
WINAPI
CSCFillSparseFilesW(
    IN  LPCWSTR     lpszShareName,
    IN  BOOL        fFullSync,
    IN  LPCSCPROCW  lpfnFillProgress,
    IN  DWORD_PTR   dwContext
)
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
#ifndef UNICODE
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
#else
    return (CSCFillSparseFilesInternal(
                    lpszShareName,
                    fFullSync,
                    lpfnFillProgress,
                    dwContext));

#endif
}



BOOL
WINAPI
CSCMergeShareW(
    IN  LPCWSTR     lpszShareName,
    IN  LPCSCPROCW  lpfnMergeProgress,
    IN  DWORD_PTR   dwContext
)
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
#ifndef UNICODE
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
#else
    return(CSCMergeShareInternal(
                lpszShareName,
                lpfnMergeProgress,
                dwContext));
#endif
}


BOOL
WINAPI
CSCCopyReplicaW(
    IN  LPCWSTR lpszFullPath,
    OUT LPWSTR  *lplpszLocalName
)
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
#ifndef UNICODE
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
#else
    return(CSCCopyReplicaInternal(
                lpszFullPath,
                lplpszLocalName));
#endif
}

BOOL
WINAPI
CSCEnumForStatsW(
    IN  LPCWSTR     lpszShareName,
    IN  LPCSCPROCW  lpfnEnumProgress,
    IN  DWORD_PTR   dwContext
)
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
#ifndef UNICODE
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
#else
    return(CSCEnumForStatsInternal(
                lpszShareName,
                lpfnEnumProgress,
                FALSE,
                FALSE,
                dwContext));
#endif
}

BOOL
WINAPI
CSCEnumForStatsExA(
    IN  LPCSTR     lpszShareName,
    IN  LPCSCPROCA  lpfnEnumProgress,
    IN  DWORD_PTR   dwContext
)
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
}

BOOL
WINAPI
CSCEnumForStatsExW(
    IN  LPCWSTR     lpszShareName,
    IN  LPCSCPROCW  lpfnEnumProgress,
    IN  DWORD_PTR   dwContext
)
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
#ifndef UNICODE
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
#else
    return(CSCEnumForStatsInternal(
                lpszShareName,
                lpfnEnumProgress,
                TRUE,
                FALSE,
                dwContext));
#endif
}

BOOL
WINAPI
CSCFreeSpace(
    DWORD   nFileSizeHigh,
    DWORD   nFileSizeLow
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    SHADOWSTORE sSTLast, sST;
    BOOL fRet = FALSE;

    if(!GetSpaceStats(INVALID_HANDLE_VALUE, &sSTLast))
    {
        return FALSE;
    }

    do
    {
        if (!FreeShadowSpace(INVALID_HANDLE_VALUE, nFileSizeHigh, nFileSizeLow, FALSE))
        {
            break;
        }

        if(!GetSpaceStats(INVALID_HANDLE_VALUE, &sST))
        {
            break;
        }

        // check if we are making any progress over successive
        // free space calls. If the current space used is greater than
        // after we last called, just quit.

        if (sST.sCur.ulSize >= sSTLast.sCur.ulSize)
        {
            fRet = TRUE;
            break;
        }

        sSTLast = sST;

    }
    while (TRUE);

    return fRet;
}


BOOL
WINAPI
CSCIsServerOfflineW(
    LPCWSTR  lptzServerName,
    BOOL    *lpfOffline
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    return(IsServerOfflineW(INVALID_HANDLE_VALUE, lptzServerName, lpfOffline));
}

BOOL
WINAPI
CSCIsServerOfflineA(
    LPCSTR  lptzServerName,
    BOOL    *lpfOffline
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    return(IsServerOfflineA(INVALID_HANDLE_VALUE, lptzServerName, lpfOffline));
}

BOOL
WINAPI
CSCTransitionServerOnlineW(
    IN  LPCWSTR     lpszShareName
    )
/*++

Routine Description:

    This routine transitions the server for the given share to online.

Arguments:

    lpszShareName

Returns:


Notes:

--*/
{

    WIN32_FIND_DATA sFind32;
    SHADOWINFO sSI;
    BOOL    fTransitionedToOnline = FALSE, fDone=FALSE;
    _TCHAR  tchBuff[MAX_SERVER_SHARE_NAME_FOR_CSC], tzDrive[4];
    DWORD   i;

    if (lstrlen(lpszShareName) >= MAX_SERVER_SHARE_NAME_FOR_CSC)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    lstrcpy(tchBuff, lpszShareName);

    if (!LpBreakPath(tchBuff, TRUE, &fDone) && !fDone)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    tzDrive[0] = 0;

    if(FindCreateShadowFromPath(tchBuff, FALSE, &sFind32, &sSI, NULL))
    {
        LPCONNECTINFO   lpHead = NULL;
        BOOL    fServerIsOffline = FALSE;

        fServerIsOffline = ((sSI.uStatus & SHARE_DISCONNECTED_OP) != 0);


        if(FGetConnectionListEx(&lpHead, tchBuff, TRUE, fServerIsOffline, NULL))
        {
            // take an extra reference, just in case there are some credentials on the server entry
            // with the redir
            // if it fails, don't stop going online
            // the worst that could happen is that the user might get an extra popup 
            // for the explicit credential case
            DWORD dwError;

            dwError = DWConnectNet(tchBuff, tzDrive, NULL, NULL, NULL, 0, NULL);
            if ((dwError != WN_SUCCESS) && (dwError != WN_CONNECTED_OTHER_PASSWORD_DEFAULT))
            {
                tzDrive[0] = 0;
            }

            DisconnectList(&lpHead, NULL, 0);
        }

        fTransitionedToOnline = TransitionShareToOnline(INVALID_HANDLE_VALUE, sSI.hShare);

        for (i=2;i<MAX_SERVER_SHARE_NAME_FOR_CSC;++i)
        {
            if (tchBuff[i] == '\\')
            {
                break;                
            }
        }

        Assert(i< MAX_SERVER_SHARE_NAME_FOR_CSC);

        // going online
        ReportTransitionToDfs(tchBuff, FALSE, i*sizeof(_TCHAR));

        if (lpHead)
        {
            ReconnectList(&lpHead, NULL);
            ClearConnectionList(&lpHead);

        }

        // if there was an extra reference,
        // remove it
        if (tzDrive[0])
        {
            DWDisconnectDriveMappedNet(tzDrive, TRUE);
        }
    }

    return(fTransitionedToOnline);
}

BOOL
WINAPI
CSCTransitionServerOnlineA(
    IN  LPCSTR     lpszShareName
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
}

BOOL
WINAPI
CSCCheckShareOnlineExW(
    IN  LPCWSTR     lpszShareName,
    LPDWORD         lpdwSpeed
    )
/*++

Routine Description:

    This routine checks whether a given share is available online.

Arguments:

    lpszShareName

Returns:


Notes:

--*/
{

    _TCHAR  tchBuff[MAX_SERVER_SHARE_NAME_FOR_CSC], tzDrive[4];
    BOOL    fIsOnline = FALSE, fDone;
    DWORD   dwError;

    if (lstrlen(lpszShareName) >= MAX_SERVER_SHARE_NAME_FOR_CSC)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    lstrcpy(tchBuff, lpszShareName);

    if (!LpBreakPath(tchBuff, TRUE, &fDone) && !fDone)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    dwError = DWConnectNet(tchBuff, tzDrive, NULL, NULL, NULL, 0, NULL);
    if ((dwError == WN_SUCCESS) || (dwError == WN_CONNECTED_OTHER_PASSWORD_DEFAULT))
    {
        fIsOnline = TRUE;

        if (lpdwSpeed)
        {
            GetConnectionInfoForDriveBasedName(tzDrive, lpdwSpeed);
        }                                       
        DWDisconnectDriveMappedNet(tzDrive, TRUE);
    }
    else
    {
        SetLastError(dwError);
    }

    return(fIsOnline);
}

BOOL
WINAPI
CSCCheckShareOnlineW(
    IN  LPCWSTR     lpszShareName
    )
/*++

Routine Description:

    This routine checks whether a given share is available online.

Arguments:

    lpszShareName

Returns:


Notes:

--*/
{
    return (CSCCheckShareOnlineExW(lpszShareName, NULL));
}

BOOL
WINAPI
CSCCheckShareOnlineA(
    IN  LPCSTR     lpszShareName
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
}

BOOL
WINAPI
CSCDoLocalRenameW(
    IN  LPCWSTR     lpszSource,
    IN  LPCWSTR     lpszDestination,
    IN  BOOL        fReplaceFileIfExists
    )
{
    return CSCDoLocalRenameExW(lpszSource, lpszDestination, NULL, FALSE, fReplaceFileIfExists);
}

BOOL
WINAPI
CSCDoLocalRenameExW(
    IN  LPCWSTR     lpszSource,
    IN  LPCWSTR     lpszDestination,
    IN  WIN32_FIND_DATAW    *lpFind32,
    IN  BOOL        fMarkAsLocal,
    IN  BOOL        fReplaceFileIfExists
    )
/*++

Routine Description:

    This routine does a rename in the datbase. The rename operation can be across shares

Arguments:

    lpszSource              Fully qualified source name (must be UNC)

    lpszDestination         Fully qualified destination directory name (must be UNC)
    
    lpFind32                New name in the destination directory, given the long name
                            the shortnmae is locally generated. For this reason, when
                            a new name is given, fMarkAsLocal is forced TRUE.
    
    fMarkAsLocal            Mark the newly created entry as locally created (except see lpFind32)
    
    fReplaceFileIfExists    replace destination file with the source if it exists

Returns:

    TRUE if successfull, FALSE otherwise. If the API fails, GetLastError returns the specific
    errorcode.

Notes:

--*/
{

    DWORD   dwError = NO_ERROR;
    WIN32_FIND_DATA sFind32;
    BOOL    fDone=FALSE, fRet = FALSE, fBeginInodeTransaction = FALSE, fSourceIsFile=FALSE;
    SHADOWINFO  sSI;
    HSHADOW hDirFrom, hShadowFrom, hDirTo, hShadowTo=0;
    HSHARE hShareFrom, hShareTo;
    HANDLE      hShadowDB;
    DWORD   lenSrc=0, lenDst=0;

    ReintKdPrint(API, ("DoLocalRenameEx %ls %ls %x %x %x\r\n", lpszSource, lpszDestination, lpFind32, fMarkAsLocal, fReplaceFileIfExists));

    try
    {
        if ((lenSrc = lstrlen(lpszSource)) >= MAX_PATH)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        lstrcpy(sFind32.cFileName, lpszSource);

        if (!LpBreakPath(sFind32.cFileName, TRUE, &fDone) && fDone)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
    }

    try
    {
        if ((lenDst = lstrlen(lpszDestination)) >= MAX_PATH)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
    }

    // if source is not greater than the destination
    // verify that we are not renaming the parent under it's own child

    if (lenSrc <= lenDst)
    {
        lstrcpy(sFind32.cFileName, lpszDestination);
        sFind32.cFileName[lenSrc] = 0;

        // make a case insensitive comparison
        if(!lstrcmpi(lpszSource, sFind32.cFileName))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }
    }

    if ((hShadowDB = OpenShadowDatabaseIO()) ==INVALID_HANDLE_VALUE)
    {
        ReintKdPrint(BADERRORS, ("failed to open database\r\n"));
        return FALSE;
    }

    if(BeginInodeTransactionHSHADOW())
    {
        fBeginInodeTransaction = TRUE;

        if(!FindCreateShadowFromPath(lpszSource, FALSE, &sFind32, &sSI, NULL))
        {
            goto bailout;
        }

        ReintKdPrint(API, ("Source Share = %x Inode %x %x\r\n", sSI.hShare, sSI.hDir, sSI.hShadow));

        hDirFrom = sSI.hDir;
        hShadowFrom = sSI.hShadow;
        hShareFrom = sSI.hShare;
        fSourceIsFile = ((sFind32.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)==0);

        if(!FindCreateShadowFromPath(lpszDestination, TRUE, &sFind32, &sSI, NULL))
        {
            goto bailout;
        }

        ReintKdPrint(API, ("Destination Share = %x Inode %x %x\r\n", sSI.hShare, sSI.hDir, sSI.hShadow));
        hShareTo = sSI.hShare;
        hDirTo = sSI.hShadow;

        // if we are creating a new entry in the database, we say it was created
        // offline
        if (lpFind32)
        {
            fMarkAsLocal = TRUE;                        
            fReplaceFileIfExists = FALSE;
        }

        if (((hShareFrom == hShareTo) && !fReplaceFileIfExists) ||fSourceIsFile)
        {
            // do the rename only if the source directory is not the same as the destination directory.
            // or the destination name is different, otherwise there is nothing to do
            if ((hDirFrom != sSI.hShadow)||(lpFind32))
            {

                if (RenameShadow(hShadowDB, hDirFrom, hShadowFrom, hDirTo, lpFind32, fReplaceFileIfExists, &hShadowTo))
                {
                    //
                    fRet = SetShareStatus(hShadowDB, hShareTo, SHARE_REINT, SHADOW_FLAGS_OR);

                    if (fMarkAsLocal)
                    {
                        Assert(hShadowTo);
                        if (fSourceIsFile)
                        {
                            fRet = SetShadowInfo(hShadowDB, hDirTo, hShadowTo, NULL, SHADOW_LOCALLY_CREATED, SHADOW_FLAGS_ASSIGN);
                        }
                        else
                        {
                            SET_SUBTREE_STATUS sSSS;
                            memset(&sSSS, 0, sizeof(sSSS));
                            sSSS.uStatus = SHADOW_LOCALLY_CREATED;
                            sSSS.uOp = SHADOW_FLAGS_ASSIGN;
                            fRet = (TraverseOneDirectory(hShadowDB, NULL, hDirTo, hShadowTo, (LPTSTR)lpszSource, SetSubtreeStatus, &sSSS)!=TOD_ABORT);
                        }
                    }
                    if (!fRet)
                    {
                       dwError = GetLastError();                        
                    }
                }
                else
                {
                    dwError = GetLastError();
                }
            }
            else
            {
                fRet = TRUE;
            }
        }
        else
        {
            MOVE_SUBTREE    sMST;
            
            memset(&sMST, 0, sizeof(sMST));

            sMST.lptzSource = lpszSource;
            sMST.lptzDestination = lpszDestination;
            sMST.lpTos = &sMST.sTos;
            sMST.sTos.hDir = hDirTo;
            sMST.hShareTo = hShareTo;

            if (fReplaceFileIfExists)
            {
                sMST.dwFlags |= MST_REPLACE_IF_EXISTS;                
            }

            TraverseOneDirectory(hShadowDB,  NULL, hDirFrom, hShadowFrom, (LPTSTR)lpszSource, MoveSubtree, &sMST);

            fRet = (sMST.cntFail == 0);

            Assert(sMST.lpTos == &sMST.sTos);
            Assert(sMST.sTos.lpNext == NULL);
        }
    }

bailout:
    if (fBeginInodeTransaction)
    {
        EndInodeTransactionHSHADOW();
    }
    if (!fRet)
    {
        SetLastError(dwError);
    }

    CloseShadowDatabaseIO(hShadowDB);

    return fRet;
}

BOOL
CreateDirectoryAndSetHints(
    HANDLE          hShadowDB,
    LPTSTR          lptzFullPath,
    DWORD           dwCallbackReason,
    WIN32_FIND_DATA *lpFind32,
    SHADOWINFO      *lpSI,
    LPMOVE_SUBTREE  lpMst
    )
/*++

Routine Description:

    This routine creates a copy of a source directory under a destination directory

Arguments:

    hShadowDB           Handle to issue ioctls to the redir

    lptzFullPath        fully qualified path to the item

    dwCallbackReason    TOD_CALLBACK_REASON_XXX (BEGIN, NEXT_ITEM or END)

    lpFind32            local win32info

    lpSI                other info such as priority, pincount etc.

    lpMst               MOVE_SUBTREE structure which contains the rlevant info about this move


Returns:

    TRUE if successfull, FALSE otherwise. If the API fails, GetLastError returns the specific
    errorcode.

Notes:

--*/
{
    BOOL fRet = FALSE;

    lpMst->sFind32 =  *lpFind32;
    if(GetShadowEx(hShadowDB, lpMst->lpTos->hDir, &lpMst->sFind32, &lpMst->sSI))
    {
        // if it doesn't exist, create it and set it's hints to those found on the source
        if (!lpMst->sSI.hShadow)
        {
            if (CreateShadow(hShadowDB, lpMst->lpTos->hDir, &lpMst->sFind32, lpSI->uStatus, &lpMst->sSI.hShadow))
            {
                lpMst->sSI.ulHintPri = lpSI->ulHintPri;
                lpMst->sSI.ulHintFlags =  lpSI->ulHintFlags;

                if(AddHintFromInode(hShadowDB, lpMst->lpTos->hDir, lpMst->sSI.hShadow, &(lpMst->sSI.ulHintPri), &(lpMst->sSI.ulHintFlags)) != 0)
                {
                    fRet = TRUE;
                }

            }

        }
        else
        {
            fRet = TRUE;
        }

    }
    return fRet;
}

BOOL
WINAPI
CSCDoLocalRenameA(
    IN  LPCSTR      lpszSource,
    IN  LPCSTR      lpszDestination,
    IN  BOOL        fReplcaeFileIfExists
    )
/*++

Routine Description:

    This routine does a rename in the datbase. The rename operation can be across shares

Arguments:

    lpszSource          Fully qualified source name (must be UNC)

    lpszDestination     Fully qualified destination name (must be UNC)

Returns:

    TRUE if successfull, FALSE otherwise. If the API fails, GetLastError returns the specific
    errorcode.

Notes:

--*/
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
}

BOOL
WINAPI
CSCDoEnableDisable(
    BOOL    fEnable
    )
/*++

Routine Description:

    This routine enables/disables CSC

Arguments:

    fEnable enable CSC if TRUE, else disable CSC
    
Returns:

    TRUE if successfull, FALSE otherwise. If the API fails, GetLastError returns the specific
    errorcode.

Notes:

--*/
{
    BOOL fRet = FALSE, fReformat = FALSE;
    char    szDBDir[MAX_PATH+1];
    DWORD   dwDBCapacity, dwClusterSize;

    if (IsPersonal() == TRUE) {
        SetLastError(ERROR_INVALID_OPERATION);
        return FALSE;
    }

    if (fEnable)
    {
        if (InitValues(szDBDir, sizeof(szDBDir), &dwDBCapacity, &dwClusterSize))
        {
            fReformat = QueryFormatDatabase();

            fRet = EnableShadowingForUser(INVALID_HANDLE_VALUE, szDBDir, NULL, 0, dwDBCapacity, dwClusterSize, fReformat);
        }
    }
    else
    {
        fRet = DisableShadowingForUser(INVALID_HANDLE_VALUE);

    }
    return fRet;
}


int
MoveSubtree(
    HANDLE          hShadowDB,
    LPSECURITYINFO  pShareSecurityInfo,
    LPTSTR          lptzFullPath,
    DWORD           dwCallbackReason,
    WIN32_FIND_DATA *lpFind32,
    SHADOWINFO      *lpSI,
    LPMOVE_SUBTREE  lpMst
    )
/*++

Routine Description:

    This is a callback routine to TraverseOneDirectory. It moves the subtree from one place
    in the hierarchy to another. It would be necessary to call this routine only when
    the subtree is being moved from one share to another.

Arguments:

    hShadowDB           Handle to issue ioctls to the redir

    lptzFullPath        fully qualified path to the item

    dwCallbackReason    TOD_CALLBACK_REASON_XXX (BEGIN, NEXT_ITEM or END)

    lpFind32            local win32info

    lpSI                other info such as priority, pincount etc.

    lpMst               MOVE_SUBTREE structure which contains the rlevant info about this move


Returns:

    return code, whether continue, cancel etc.

Notes:

    As TravesreOneDirectory descends the source subtree, this routine creates directories in the
    corresponding location in the destination subtree. It then moves the files from one subtree
    to another. At the end of the enumeration of any directory, it tries to delete the source
    directory. The delete succeeds only if there are no more descedents left to the source
    directory

--*/
{
    BOOL    fRet = FALSE;
    LPMST_LIST lpT;

    ReintKdPrint(API, ("MoveSubTree %ls\r\n", lptzFullPath));

    switch (dwCallbackReason)
    {
    case TOD_CALLBACK_REASON_BEGIN:
        {
            ReintKdPrint(API, ("MST Begin source Inode %x %x\r\n", lpSI->hDir, lpSI->hShadow));

            // Get the source directory info
            if (GetShadowInfoEx(hShadowDB, lpSI->hDir, lpSI->hShadow, lpFind32, lpSI))
            {
                fRet = CreateDirectoryAndSetHints(hShadowDB, lptzFullPath, dwCallbackReason, lpFind32, lpSI, lpMst);
            }
            // if all is well, then make this directory the parent directory for
            // all subsequent creates and renames

            if (fRet)
            {

                lpT = (LPMST_LIST)LocalAlloc(LPTR, sizeof(MST_LIST));

                if (!lpT)
                {
                    return TOD_ABORT;
                }

                lpT->hDir = lpMst->sSI.hShadow;
                lpT->lpNext = lpMst->lpTos;
                lpMst->lpTos = lpT;

                // mark the destination share dirty, if necessary
                if (lpSI->uStatus & SHADOW_MODFLAGS)
                {
                    if (!(lpMst->dwFlags & MST_SHARE_MARKED_DIRTY))
                    {
                        ReintKdPrint(API, ("Setting Share %x dirty \n", lpMst->hShareTo));

                        if(SetShareStatus(hShadowDB, lpMst->hShareTo, SHARE_REINT, SHADOW_FLAGS_OR))
                        {
                            lpMst->dwFlags |= MST_SHARE_MARKED_DIRTY;
                        }
                    }
                }
            }
            else
            {
                lpMst->cntFail++;
            }
        }
    break;
    case TOD_CALLBACK_REASON_NEXT_ITEM:
        // if the source is a file, then move it
        ReintKdPrint(API, ("MST next source Inode %x %x\r\n", lpSI->hDir, lpSI->hShadow));
        if(!(lpFind32->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            ReintKdPrint(API, ("MST rename file SrcInode %x %x to destdir %x\r\n", lpSI->hDir, lpSI->hShadow, lpMst->lpTos->hDir));
            if (RenameShadow(hShadowDB, lpSI->hDir, lpSI->hShadow, lpMst->lpTos->hDir, NULL, 
                ((lpMst->dwFlags & MST_REPLACE_IF_EXISTS)!=0), NULL))
            {
                fRet = TRUE;

            }
        }
        else
        {
            if(CreateDirectoryAndSetHints(hShadowDB, lptzFullPath, dwCallbackReason, lpFind32, lpSI, lpMst))
            {
                fRet = TRUE;
            }
        }

        if (!fRet)
        {
            lpMst->cntFail++;
        }
        // mark the destination share dirty, if necessary
        if (lpSI->uStatus & SHADOW_MODFLAGS)
        {
            if (!(lpMst->dwFlags & MST_SHARE_MARKED_DIRTY))
            {
                if(SetShareStatus(hShadowDB, lpMst->hShareTo, SHARE_REINT, SHADOW_FLAGS_OR))
                {
                    lpMst->dwFlags |= MST_SHARE_MARKED_DIRTY;
                }
            }
        }
    break;
    case TOD_CALLBACK_REASON_END:
        Assert(lpMst->lpTos);
        lpT = lpMst->lpTos;
        lpMst->lpTos = lpMst->lpTos->lpNext;
        LocalFree(lpT);
        fRet = TRUE;

        ReintKdPrint(API, ("MST End Delete Inode %x %x \r\n", lpSI->hDir, lpSI->hShadow));
        DeleteShadow(hShadowDB, lpSI->hDir, lpSI->hShadow);

    break;

    }

    return (fRet?TOD_CONTINUE:TOD_ABORT);
}

int
SetSubtreeStatus(
    HANDLE          hShadowDB,
    LPSECURITYINFO  pShareSecurityInfo,
    LPTSTR          lptzFullPath,
    DWORD           dwCallbackReason,
    WIN32_FIND_DATA *lpFind32,
    SHADOWINFO      *lpSI,
    LPSET_SUBTREE_STATUS  lpSss
    )
/*++

Routine Description:

    This is a callback routine to TraverseOneDirectory. It moves the subtree from one place
    in the hierarchy to another. It would be necessary to call this routine only when
    the subtree is being moved from one share to another.

Arguments:

    hShadowDB           Handle to issue ioctls to the redir

    lptzFullPath        fully qualified path to the item

    dwCallbackReason    TOD_CALLBACK_REASON_XXX (BEGIN, NEXT_ITEM or END)

    lpFind32            local win32info

    lpSI                other info such as priority, pincount etc.

    lpSss               SET_SUBTREE_STATE structure which contains the relevant info about this state setting


Returns:

    return code, whether continue, cancel etc.

Notes:

    As TravesreOneDirectory descends the source subtree, this routine sets the required bits

--*/
{

    ReintKdPrint(API, ("SetSubTreeState %ls\r\n", lptzFullPath));

    if(SetShadowInfo(hShadowDB, lpSI->hDir, lpSI->hShadow, NULL, lpSss->uStatus, lpSss->uOp) == TRUE)
    {
        return TOD_CONTINUE;
    }
    else
    {
        return TOD_ABORT;
    }

}

BOOL
WINAPI
CSCBeginSynchronizationW(
    IN  LPCTSTR     lpszShareName,
    LPDWORD         lpdwSpeed,
    LPDWORD         lpdwContext
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/
{
    _TCHAR  tchBuff[MAX_SERVER_SHARE_NAME_FOR_CSC], tzDrive[4];
    BOOL    fIsOnline = FALSE, fDone, fExplicitCredentials=FALSE, fIsDfs;
    DWORD   dwError;
    
    if (lstrlen(lpszShareName) >= MAX_SERVER_SHARE_NAME_FOR_CSC)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    lstrcpy(tchBuff, lpszShareName);

    if (!LpBreakPath(tchBuff, TRUE, &fDone) && !fDone)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    ReintKdPrint(API, (" CSCBeginSynchronization %ls\r\n", tchBuff));

    dwError = DWConnectNet(tchBuff, tzDrive, NULL, NULL, NULL, CONNECT_INTERACTIVE, NULL);
    if ((dwError == WN_SUCCESS)||(dwError==WN_CONNECTED_OTHER_PASSWORD)||(dwError==WN_CONNECTED_OTHER_PASSWORD_DEFAULT))
    {
        fIsOnline = TRUE;

        if (lpdwSpeed)
        {
            GetConnectionInfoForDriveBasedName(tzDrive, lpdwSpeed);
        }

        if (dwError==WN_CONNECTED_OTHER_PASSWORD || dwError==WN_CONNECTED_OTHER_PASSWORD_DEFAULT)
        {
            ReintKdPrint(API, (" CSCBeginSynchronization: Explicit Credentials\r\n"));
            fExplicitCredentials = TRUE;

            dwError = DoNetUseAddForAgent(tchBuff, NULL, NULL, NULL, NULL, 0, &fIsDfs);
            if (dwError != WN_SUCCESS && dwError!=WN_CONNECTED_OTHER_PASSWORD_DEFAULT)
            {
                fIsOnline = FALSE;
                ReintKdPrint(API, (" CSCBeginSynchronization: Failed extra reference %d\r\n", dwError));
            }
        }

        DWDisconnectDriveMappedNet(tzDrive, TRUE);
    }

    if (!fIsOnline)
    {
        ReintKdPrint(ALWAYS, (" CSCBeginSynchronization: Failed %d\r\n", dwError));
        SetLastError(dwError);
    }
    else
    {
        *lpdwContext = fExplicitCredentials;
    }

    return(fIsOnline);
}

BOOL
WINAPI
CSCEndSynchronizationW(
    IN  LPCTSTR     lpszShareName,
    DWORD           dwContext
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/
{
    _TCHAR  tchBuff[MAX_SERVER_SHARE_NAME_FOR_CSC], tzDrive[4];
    BOOL    fIsOnline = FALSE, fDone, fExplicitCredentials=FALSE;
    DWORD   dwError;
    
    if (lstrlen(lpszShareName) >= MAX_SERVER_SHARE_NAME_FOR_CSC)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    lstrcpy(tchBuff, lpszShareName);

    if (!LpBreakPath(tchBuff, TRUE, &fDone) && !fDone)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (dwContext != 0)
    {
        WNetCancelConnection2(tchBuff, 0, TRUE);
    }

    return TRUE;
}

#if 0
BOOL
WINAPI
CSCEncryptDecryptFileW(
    IN  LPCTSTR     lpszFileName,
    IN  BOOL        fEncrypt
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:


--*/
{
    WIN32_FIND_DATA sFind32;
    SHADOWINFO sSI;
    BOOL fRet = FALSE;
    DWORD   dwError = ERROR_GEN_FAILURE;

    //    
    if(FindCreateShadowFromPath(lpszFileName, FALSE, &sFind32, &sSI, NULL))
    {
        fRet = RecreateShadow(INVALID_HANDLE_VALUE, sSI.hDir, sSI.hShadow, (fEncrypt)?FILE_ATTRIBUTE_ENCRYPTED:0);
    }
    
    return fRet;    
}
#endif

BOOL
WINAPI
CSCQueryDatabaseStatus(
    ULONG   *pulStatus,
    ULONG   *pulErrors
    )
/*++

Routine Description:

    Allows caller to query the database status.

Arguments:

    pulStatus   Current status. Encryption status is the most interesting

    pulErrors   If the database has any errors, one or more bits will be set

Returns:

    TRUE if the API succeeded

Notes:


--*/
{
    GLOBALSTATUS sGS;
    
    if(!GetGlobalStatus(INVALID_HANDLE_VALUE, &sGS))
    {
        return FALSE;
    }
    *pulStatus = sGS.sST.uFlags;
    *pulErrors = sGS.uDatabaseErrorFlags;
    return TRUE;
    
}


BOOL
WINAPI
CSCEncryptDecryptDatabase(
    IN  BOOL        fEncrypt,
    IN  LPCSCPROCW  lpfnEnumProgress,
    IN  DWORD_PTR   dwContext
    )
    
/*++

Routine Description:

    This routine is used to encrypt/decrypt the entire database in system context. The routine checks that
    the CSC database is hosted on a filesystem that allows encryption. Only admins can do the conversion
    

Arguments:

    fEncrypt    if TRUE, we encrypt the database else we decrypt.
    
    LPCSCPROCW  callback proc. The usual set of CSCPROC_REASON_BEGIN, CSCPROC_REASON_MORE_DATA, CSC_PROC_END
                are sent when the conversion actually begins. Conversion can fail if a file is open or for
                some other reason, in which case the second to last parameter in the callback with 
                CSCPROC_REASON_MORE_DATA has the error code. The third to last parameter indicates whether
                the conversion was complete or not. Incomplete conversion is not an error condition.
    
    dwContext   callback context

Returns:

    TRUE if no errors encountered.

Notes:


    Theory of operations:
    
        The CSC database encryption code encrypts all the inodes represented by remote files.
        Who: Only user in admingroup can do encryption/decryption. This is checked in kernel
        Which context: Files are encrypted in system context. This allows files to be shared
                       while still being encrypted. This solution protects from a stolen laptop case.
                       
        The database can have the following status set on it based on the four encryption states:
        
        a) FLAG_DATABASESTATUS_UNENCRYPTED b) FLAG_DATABASESTATUS_PARTIALLY_UNENCRYPTED
        c) FLAG_DATABASESTATUS_ENCRYPTED d) FLAG_DATABASESTATUS_PARTIALLY_ENCRYPTED
        
        In states a) and b) new files are created unencrypted. In states c) and d) new files are created encrypted.
        
        At the beginning of the conversion, the database stats is marked to the appropriate XX_PARTIAL_XX
        state. At the end, if all goes well, it is transitioned to the final state.
        At the time of enabling CSC, if the database state is XX_PARTIAL_XX, the kernel code tries to
        complete the conversion to the appropriate final state.
                               
                               
            

--*/
{
    BOOL fRet = FALSE, fComplete = FALSE;
    HANDLE hShadowDB = INVALID_HANDLE_VALUE;
    SHADOWSTORE sST;
    DWORD   dwRet, dwError=0, dwStartigNameSpaceVersion;
    ULONG   uT;
    WIN32_FIND_DATA sFind32;
    ENCRYPT_DECRYPT_SUBTREE sEDS;
    SHADOWINFO  sSI;
    HANDLE  ulEnumCookie;
            
    // we have begun    
    if (lpfnEnumProgress)
    {
        dwRet = (*lpfnEnumProgress)(NULL, 0, 0, 0, NULL, CSCPROC_REASON_BEGIN, fEncrypt, 0, dwContext);

        if (dwRet != CSCPROC_RETURN_CONTINUE )
        {
            goto bailout;
        }
    }
    
    if (GetShadowDatabaseLocation(INVALID_HANDLE_VALUE, &sFind32))
    {

        // Set NULL after the root backslash so that this API works correctly
        sFind32.cFileName[3] = 0;
                            
        if(!GetVolumeInformation(sFind32.cFileName, NULL, 0, NULL, &dwRet, &dwError, NULL, 0))
        {
            ReintKdPrint(BADERRORS, ("failed to get volume info for %ls Error=%d\r\n", sFind32.cFileName, GetLastError()));
            goto bailout;

        }
        if (!(dwError & FILE_SUPPORTS_ENCRYPTION))
        {
            ReintKdPrint(BADERRORS, ("volume doesn't support replication \r\n"));
            SetLastError(ERROR_NOT_SUPPORTED);
            goto bailout;
        }
        
    }
    else
    {
        ReintKdPrint(BADERRORS, ("failed to get database location Error=%d\r\n", GetLastError()));
        goto bailout;
    }
    
    if ((hShadowDB = OpenShadowDatabaseIO())==INVALID_HANDLE_VALUE)
    {
        goto bailout;
    }

    // let us see whether we need to do anything
    if(!GetSpaceStats(hShadowDB, &sST))
    {
        goto bailout;    
    }

    sST.uFlags &= FLAG_DATABASESTATUS_ENCRYPTION_MASK;

    // the database is already in the state desired, succeed and quit
    if ((fEncrypt && (sST.uFlags == FLAG_DATABASESTATUS_ENCRYPTED))||
        (!fEncrypt && (sST.uFlags == FLAG_DATABASESTATUS_UNENCRYPTED)))
    {
        fRet = TRUE;
        goto bailout;
    }


    sST.uFlags = (fEncrypt)? FLAG_DATABASESTATUS_PARTIALLY_ENCRYPTED : FLAG_DATABASESTATUS_PARTIALLY_UNENCRYPTED;

    // mark the database in appropriate transient state
    // once this is marked, any new file that is created is in correct encryption state    
    if (!SetDatabaseStatus(hShadowDB, sST.uFlags, FLAG_DATABASESTATUS_ENCRYPTION_MASK))
    {
        goto bailout;
    }

    
    memset(&sEDS, 0, sizeof(sEDS));
    memset(&sFind32, 0, sizeof(sFind32));
    lstrcpy(sFind32.cFileName, _TEXT("*"));

    if(!FindOpenShadow(  hShadowDB, 0, FINDOPEN_SHADOWINFO_ALL,
                        &sFind32, &sSI))
    {
        // The database is empty, so set the state to fully encrypted (or decrypted)
        sST.uFlags = (fEncrypt)? FLAG_DATABASESTATUS_ENCRYPTED : FLAG_DATABASESTATUS_UNENCRYPTED;
        SetDatabaseStatus(hShadowDB, sST.uFlags, FLAG_DATABASESTATUS_ENCRYPTION_MASK);
        goto bailout;
    }
    
    dwStartigNameSpaceVersion = sSI.dwNameSpaceVersion;
    ulEnumCookie = sSI.uEnumCookie;
    
    sEDS.dwContext = dwContext;
    sEDS.lpfnEnumProgress = lpfnEnumProgress;
    sEDS.fEncrypt = fEncrypt;
        
    ReintKdPrint(ALWAYS, ("Starting NameSpaceVersion %x \n", dwStartigNameSpaceVersion));
    do {

        if(TraverseOneDirectory(hShadowDB, NULL, sSI.hDir, sSI.hShadow, sFind32.cFileName, EncryptDecryptSubtree, &sEDS)==TOD_ABORT)
        {
            break;
        }

    }while(FindNextShadow(hShadowDB, ulEnumCookie, &sFind32, &sSI));

    FindCloseShadow(hShadowDB, ulEnumCookie);
    
    ReintKdPrint(ALWAYS, ("Ending NameSpaceVersion %x \n", sEDS.dwEndingNameSpaceVersion));

    if (!(sEDS.dwFlags & EDS_FLAG_ERROR_ENCOUNTERED) &&
        (dwStartigNameSpaceVersion == sEDS.dwEndingNameSpaceVersion))
    {
        sST.uFlags = (fEncrypt)? FLAG_DATABASESTATUS_ENCRYPTED : FLAG_DATABASESTATUS_UNENCRYPTED;
    
        if (!SetDatabaseStatus(hShadowDB, sST.uFlags, FLAG_DATABASESTATUS_ENCRYPTION_MASK))
        {
            goto bailout;
        }
        
        fComplete = TRUE;
        
    }

    dwError = NO_ERROR;
    fRet = TRUE;
    

bailout:

    if (!fRet)
    {
        dwError = GetLastError();
    }
    
    if (hShadowDB != INVALID_HANDLE_VALUE)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (lpfnEnumProgress)
    {
        dwRet = (*lpfnEnumProgress)(NULL, 0, 0, 0, NULL, CSCPROC_REASON_END, fComplete, dwError, dwContext);
    }

    return fRet;
}

int
EncryptDecryptSubtree(
    HANDLE          hShadowDB,
    LPSECURITYINFO  pShareSecurityInfo,
    LPTSTR          lptzFullPath,
    DWORD           dwCallbackReason,
    WIN32_FIND_DATA *lpFind32,
    SHADOWINFO      *lpSI,
    LPENCRYPT_DECRYPT_SUBTREE  lpEds
    )
/*++

Routine Description:

    This is a callback routine to TraverseOneDirectory. It encrypts or decrypts files in the subtree

Arguments:

    hShadowDB           Handle to issue ioctls to the redir

    lptzFullPath        fully qualified path to the item

    dwCallbackReason    TOD_CALLBACK_REASON_XXX (BEGIN, NEXT_ITEM or END)

    lpFind32            local win32info

    lpSI                other info such as priority, pincount etc.

    lpEds               ENCRYPT_DECRYPT_SUBTREE structure which contains the relevant info such
                        as encrypt-or-decrypt, callback function, context, error flag


Returns:

    return code, whether continue, cancel etc.

Notes:


--*/
{
    BOOL    fRet;
    DWORD   dwError, dwRet;
    int iRet = TOD_CONTINUE;

    // save the last known version number, the calling routine will
    // compare it against the first one    
    if(dwCallbackReason == TOD_CALLBACK_REASON_NEXT_ITEM)
    {
        lpEds->dwEndingNameSpaceVersion = lpSI->dwNameSpaceVersion;
    }

    // operate only on files        
    if (lpSI->uStatus & SHADOW_IS_FILE)
    {

        ReintKdPrint(ALWAYS, ("Processing file %ls \n", lptzFullPath));

        do
        {
            dwError = 0;

            // try conversion. If we fail, not in the EDS structure so 
            // the caller knows        
            if(!RecreateShadow(hShadowDB, lpSI->hDir, lpSI->hShadow, (lpEds->fEncrypt)?FILE_ATTRIBUTE_ENCRYPTED:0))
            {
                dwError = GetLastError();
            }
        
            if (lpEds->lpfnEnumProgress)
            {
                dwRet = (*(lpEds->lpfnEnumProgress))(lptzFullPath, 0, 0, 0, lpFind32, CSCPROC_REASON_MORE_DATA, 0, dwError, lpEds->dwContext);

                if (dwRet == CSCPROC_RETURN_RETRY)
                {
                    continue;                    
                }
                // abort if the callback wants to
                if (dwRet != CSCPROC_RETURN_CONTINUE )
                {
                    iRet = TOD_ABORT;
                }
            }                
            
            break;
        }
        while (TRUE);
        if (dwError != ERROR_SUCCESS)
        {
            lpEds->dwFlags |= EDS_FLAG_ERROR_ENCOUNTERED;
        }
    }
        
    return iRet;
}

BOOL
CSCPurgeUnpinnedFiles(
    ULONG Timeout,
    PULONG pnFiles,
    PULONG pnYoungFiles)
{
    BOOL iRet;

    iRet = PurgeUnpinnedFiles(
            INVALID_HANDLE_VALUE,
            Timeout,
            pnFiles,
            pnYoungFiles);

    // DbgPrint("CSCPurgeUnpinnedFiles(Timeout=%d nFiles=%d nYoungFiles=%d)\n",
    //                     Timeout,
    //                     *pnFiles,
    //                     *pnYoungFiles);

    return iRet;
}

BOOL
WINAPI
CSCShareIdToShareName(
    ULONG ShareId,
    PBYTE Buffer,
    PDWORD pBufSize)
{

    BOOL iRet;

    iRet = ShareIdToShareName(
                INVALID_HANDLE_VALUE,
                ShareId,
                Buffer,
                pBufSize);

    return iRet;
}

BOOL
IsPersonal(VOID)
{
    OSVERSIONINFOEX Osvi;
    DWORD TypeMask;
    DWORDLONG ConditionMask;

    memset(&Osvi, 0, sizeof(OSVERSIONINFOEX));
    Osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    Osvi.wSuiteMask = VER_SUITE_PERSONAL;
    TypeMask = VER_SUITENAME;
    ConditionMask = 0;
    VER_SET_CONDITION(ConditionMask, VER_SUITENAME, VER_OR);
    return(VerifyVersionInfo(&Osvi, TypeMask, ConditionMask)); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\usermode\lib3\misc.c ===
#include "pch.h"
#pragma hdrstop

#include "lib3.h"
#include "assert.h"

//this variable is used as the receiver of the BytesReturned for DeviceIoControl Calls
//the value is never actually used...it is declared in lib3.c
extern ULONG DummyBytesReturned;

/* assert/debug stuff */
AssertData;
AssertError;

#define MAX_USERNAME    8   // this is not used any more


// error codes on which we decide that we are in disconnected state
static const DWORD rgdwErrorTab[] = {
     ERROR_BAD_NETPATH
    ,ERROR_NETWORK_BUSY
    ,ERROR_REM_NOT_LIST
    ,ERROR_DEV_NOT_EXIST
    ,ERROR_ADAP_HDW_ERR
    ,ERROR_BAD_NET_RESP
    ,ERROR_UNEXP_NET_ERR
    ,ERROR_BAD_REM_ADAP
    ,ERROR_BAD_NET_NAME
    ,ERROR_TOO_MANY_NAMES
    ,ERROR_TOO_MANY_SESS
    ,ERROR_NO_NET_OR_BAD_PATH
    ,ERROR_NETNAME_DELETED
    ,ERROR_NETWORK_UNREACHABLE
};

typedef struct tagREINT_IO
{
    HANDLE  hShadowDBAsync;
    OVERLAPPED  sOverlapped;
}
REINT_IO, *LPREINT_IO;

/*--------------------------- Widecharacter APIs ----------------------------------------*/

/*****************************************************************************
 *    GetUNCPath().  Pass in hShare, hDir, hShadow and get a LPCOPYPARAMS
 *    filled out fully.
 */
int
GetUNCPathW(
    HANDLE          hShadowDB,
    HSHARE         hShare,
    HSHADOW         hDir,
    HSHADOW         hShadow,
    LPCOPYPARAMSW   lpCP
    )
{
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    lpCP->uOp = 0;  // this means we are looking for a local path of the driveletter kind
                    // ie. c:\winnt\csc\80000002. That is the only kind that any
                    // usermode code should want
                    // on nt it can be \dosdevice\harddisk0\winnt\csc\80000002

    lpCP->hShare = hShare;

    lpCP->hDir = hDir;

    lpCP->hShadow = hShadow;

    iRet = DeviceIoControl( hShadowDB,
                            IOCTL_SHADOW_GET_UNC_PATH,
                            (LPVOID)(lpCP),
                            0,
                            NULL,
                            0,
                            &DummyBytesReturned,
                            NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (!iRet)
    {
        SetLastError(lpCP->dwError);
    }

    return (iRet);

}

/*****************************************************************************
 */
int
ChkUpdtStatusW(
    HANDLE                hShadowDB,
    unsigned long        hDir,
    unsigned long        hShadow,
    LPWIN32_FIND_DATAW   lpFind32,
    unsigned long        *lpulShadowStatus
    )
{
    SHADOWINFO sSI;
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.hShadow = hShadow;
    sSI.lpFind32 = lpFind32;
    if(DeviceIoControl(hShadowDB  , IOCTL_SHADOW_CHK_UPDT_STATUS
                             ,(LPVOID)(&sSI), 0
                             , NULL, 0
                             , &DummyBytesReturned, NULL))
    {
        *lpulShadowStatus = sSI.uStatus;
        iRet = 1;
    } else {
        *lpulShadowStatus = 0;
        iRet = 0;
    }
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (!iRet)
    {
        SetLastError(sSI.dwError);
    }


    return (iRet);
}

int
GetShareInfoW(
    HANDLE              hShadowDB,
    HSHARE             hShare,
    LPSHAREINFOW       lpSVRI,
    unsigned long       *lpulStatus
    )
{
    SHADOWINFO sSI;
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.hShare = hShare;
    sSI.lpFind32 = (WIN32_FIND_DATAW *)lpSVRI;
    iRet = DeviceIoControl(hShadowDB  , IOCTL_GET_SHARE_STATUS
                                  ,(LPVOID)(&sSI), 0
                                  , NULL, 0
                                  , &DummyBytesReturned, NULL);
    if(iRet)
        *lpulStatus = sSI.uStatus;
    else
        *lpulStatus = 0;

    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (!iRet)
    {
        SetLastError(sSI.dwError);
    }

    return iRet;
}



BOOL
CopyShadowA(
    HANDLE  hShadowDB,
    HSHADOW hDir,
    HSHADOW hShadow,
    LPSTR   lpszFileName
    )
{

    SHADOWINFO sSI;
    int iRet, len;
    BOOL        fDBOpened = FALSE;
    WIN32_FIND_DATAA    sFind32;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }
    memset(sFind32.cFileName, 0, sizeof(sFind32.cFileName));
    lstrcpyA(sFind32.cFileName, lpszFileName);

    sFind32.dwFileAttributes = FILE_ATTRIBUTE_SYSTEM;   // to make it explicit

    sSI.hDir = hDir;
    sSI.hShadow = hShadow;
    sSI.uOp = SHADOW_COPY_INODE_FILE;
    sSI.lpFind32 = (WIN32_FIND_DATAW *)&sFind32;
    iRet = DeviceIoControl(hShadowDB, IOCTL_DO_SHADOW_MAINTENANCE, (LPVOID)&(sSI), 0, NULL, 0, &DummyBytesReturned, NULL);

    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (iRet)
    {
        iRet = SetFileAttributesA(lpszFileName, 0);
    }
    
    if (!iRet)
    {
        DeleteFileA(lpszFileName);
        SetLastError(sSI.dwError);
        
    }


    return (iRet);

}

/*****************************************************************************
 *    GetUNCPath().  Pass in hShare, hDir, hShadow and get a LPCOPYPARAMS
 *    filled out fully.
 */
int
GetUNCPathA(
    HANDLE          hShadowDB,
    HSHARE         hShare,
    HSHADOW         hDir,
    HSHADOW         hShadow,
    LPCOPYPARAMSA   lpCP
    )
{
    int iRet = 0;
    LPCOPYPARAMSW lpCPW;

    if (lpCPW = LpAllocCopyParamsW())
    {
        iRet = GetUNCPathW(hShadowDB, hShare, hDir, hShadow, lpCPW);

        if (iRet == 1)
        {
            ConvertCopyParamsFromUnicodeToAnsi(lpCPW, lpCP);
        }

        FreeCopyParamsW(lpCPW);
    }

    return (iRet);

}

/*****************************************************************************
 */
int
ChkUpdtStatusA(
    HANDLE                hShadowDB,
    unsigned long        hDir,
    unsigned long        hShadow,
    LPWIN32_FIND_DATAA   lpFind32,
    unsigned long        *lpulShadowStatus
    )
{
    WIN32_FIND_DATAW    sFind32W;
    int iRet;

    iRet = ChkUpdtStatusW(hShadowDB, hDir, hShadow, (lpFind32)?&sFind32W:NULL, lpulShadowStatus);

    if ((iRet == 1) && lpFind32)
    {
        Find32WToFind32A(&sFind32W, lpFind32);
    }
    return (iRet);
}


int
GetShareInfoA(
    HANDLE              hShadowDB,
    HSHARE             hShare,
    LPSHAREINFOA       lpSVRI,
    unsigned long       *lpulStatus
    )
{
    int iRet;
    SHAREINFOW sShareInfoW;

    iRet = GetShareInfoW(hShadowDB, hShare, (lpSVRI)?&sShareInfoW:NULL, lpulStatus);

    if ((iRet==1) && lpSVRI)
    {
        ShareInfoWToShareInfoA(&sShareInfoW, lpSVRI);
    }
    return iRet;
}

BOOL
CopyShadowW(
    HANDLE  hShadowDB,
    HSHADOW hDir,
    HSHADOW hShadow,
    LPWSTR   lpwFileName
    )
{

    char chBuff[MAX_PATH];

    memset(chBuff, 0, sizeof(chBuff));
    WideCharToMultiByte(CP_ACP, 0, lpwFileName, wcslen(lpwFileName), chBuff, MAX_PATH, NULL, NULL);
    return (CopyShadowA(INVALID_HANDLE_VALUE, hDir, hShadow, chBuff));
}
/*****************************************************************************
 *    Cache maintenance ioctl
 */
int
DoShadowMaintenance(
    HANDLE            hShadowDB,
    unsigned long     uOp
    )
{
    SHADOWINFO sSI;
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    sSI.uOp = uOp;
    iRet = DeviceIoControl(hShadowDB, IOCTL_DO_SHADOW_MAINTENANCE, (LPVOID)&(sSI), 0, NULL, 0, &DummyBytesReturned, NULL);

    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (!iRet)
    {
        SetLastError(sSI.dwError);
    }


    return (iRet);

}


int
SetMaxShadowSpace(
    HANDLE    hShadowDB,
    long     nFileSizeHigh,
    long     nFileSizeLow
    )
{
    SHADOWINFO sSI;
    WIN32_FIND_DATAW   sFind32;
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sFind32, 0, sizeof(WIN32_FIND_DATAW));
    memset(&sSI, 0, sizeof(SHADOWINFO));
    sFind32.nFileSizeHigh = nFileSizeHigh;
    sFind32.nFileSizeLow = nFileSizeLow;
    sSI.lpFind32 = &sFind32;
    sSI.uOp = SHADOW_SET_MAX_SPACE;
    iRet = DeviceIoControl(hShadowDB  , IOCTL_DO_SHADOW_MAINTENANCE
                                  ,(LPVOID)(&sSI), 0
                                  , NULL, 0
                                  , &DummyBytesReturned, NULL);


    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (!iRet)
    {
        SetLastError(sSI.dwError);
    }

    return (iRet);
}

BOOL
PurgeUnpinnedFiles(
    HANDLE hShadowDB,
    LONG   Timeout,
    PULONG  pnFiles,
    PULONG  pnYoungFiles)
{
    SHADOWINFO sSI;
    WIN32_FIND_DATAW sFind32;
    BOOL fDBOpened = FALSE;
    BOOL bRet;

    if (hShadowDB == INVALID_HANDLE_VALUE) {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE) {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sFind32, 0, sizeof(WIN32_FIND_DATAW));
    memset(&sSI, 0, sizeof(SHADOWINFO));
    sFind32.nFileSizeHigh = Timeout;
    sSI.lpFind32 = &sFind32;
    sSI.uOp = SHADOW_PURGE_UNPINNED_FILES;
    bRet = DeviceIoControl(
                hShadowDB,
                IOCTL_DO_SHADOW_MAINTENANCE,
                (LPVOID)(&sSI),
                0,
                NULL,
                0,
                &DummyBytesReturned,
                NULL);

    if (fDBOpened)
        CloseShadowDatabaseIO(hShadowDB);

    if (bRet == TRUE) {
        *pnFiles = sFind32.nFileSizeHigh;
        *pnYoungFiles = sFind32.nFileSizeLow;
    }

    return (bRet);
}

BOOL
ShareIdToShareName(
    HANDLE hShadowDB,
    ULONG ShareId,
    PBYTE Buffer,
    LPDWORD  pBufSize)
{
    SHADOWINFO sSI;
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE) {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
            return 0;
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.hShare = ShareId;
    sSI.lpBuffer = (LPVOID)(Buffer);
    sSI.cbBufferSize = *pBufSize;

    iRet = DeviceIoControl(
                    hShadowDB,
                    IOCTL_SHAREID_TO_SHARENAME,
                    (LPVOID)(&sSI), 0,
                    NULL, 0,
                    &DummyBytesReturned, NULL);
    if (fDBOpened)
        CloseShadowDatabaseIO(hShadowDB);
    if (!iRet) {
        *pBufSize = sSI.cbBufferSize;
        SetLastError(sSI.dwError);
    }
    return (iRet);


}


/*****************************************************************************
 *    Priority queue enumerators
 */
int
BeginPQEnum(
    HANDLE        hShadowDB,
    LPPQPARAMS     lpPQP
    )
{
    return DeviceIoControl(hShadowDB, IOCTL_SHADOW_BEGIN_PQ_ENUM
                                  ,(LPVOID)(lpPQP), 0, NULL, 0, &DummyBytesReturned, NULL);
}

int
NextPriShadow(
    HANDLE        hShadowDB,
    LPPQPARAMS     lpPQP
    )
{
    return DeviceIoControl(hShadowDB, IOCTL_SHADOW_NEXT_PRI_SHADOW
                                  ,(LPVOID)(lpPQP), 0, NULL, 0, &DummyBytesReturned, NULL);
}

int
PrevPriShadow(
    HANDLE        hShadowDB,
    LPPQPARAMS     lpPQP
    )
{
    return DeviceIoControl(hShadowDB, IOCTL_SHADOW_PREV_PRI_SHADOW
                                  ,(LPVOID)(lpPQP), 0, NULL, 0, &DummyBytesReturned, NULL);
}

int
EndPQEnum(
    HANDLE        hShadowDB,
    LPPQPARAMS    lpPQP
    )
{
    return DeviceIoControl(hShadowDB, IOCTL_SHADOW_END_PQ_ENUM
                                  ,(LPVOID)(lpPQP), 0, NULL, 0, &DummyBytesReturned, NULL);
}


/*****************************************************************************
 *    FreeShadowSpace().  Pass in lpFind32 with filesize stuff filled out?.
 *    tHACK: not a very elegant interface.
 */
int
FreeShadowSpace(
    HANDLE  hShadowDB,
    long    nFileSizeHigh,
    long    nFileSizeLow,
    BOOL    fClearAll
    )
{
    SHADOWINFO sSI;
    int iRet;
    BOOL        fDBOpened = FALSE;
    WIN32_FIND_DATAW sFind32;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    memset(&sFind32, 0, sizeof(sFind32));
    sFind32.nFileSizeHigh = nFileSizeHigh;
    sFind32.nFileSizeLow = nFileSizeLow;
    sSI.lpFind32 = (LPWIN32_FIND_DATAW)&sFind32;
    sSI.uOp = SHADOW_MAKE_SPACE;

    if (fClearAll)
    {
        sSI.ulHintPri = 0xffffffff;
    }

    iRet = DeviceIoControl(hShadowDB  , IOCTL_DO_SHADOW_MAINTENANCE
                                  ,(LPVOID)(&sSI), 0
                                  , NULL, 0
                                  , &DummyBytesReturned, NULL);


    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (!iRet)
    {
        SetLastError(sSI.dwError);
    }


    return (iRet);
}

int
GetSpaceStats(
    HANDLE  hShadowDB,
    SHADOWSTORE *lpsST
)
{
    SHADOWINFO  sSI;
    int         iRet;
    BOOL        fDBOpened = FALSE;
    SHADOWSTORE sST;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    memset(&sST, 0, sizeof(sST));

    sSI.lpBuffer = (LPVOID)&sST;
    sSI.cbBufferSize = sizeof(sST);

    sSI.uOp = SHADOW_GET_SPACE_STATS;

    iRet = DeviceIoControl(hShadowDB  , IOCTL_DO_SHADOW_MAINTENANCE
                                  ,(LPVOID)(&sSI), 0
                                  , NULL, 0
                                  , &DummyBytesReturned, NULL);


    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    *lpsST = sST;

    return (iRet);

}


/*****************************************************************************
 */
#ifndef NT
int CopyChunk(
                HANDLE    hShadowDB,
                LPSHADOWINFO    lpSI,
                struct tagCOPYCHUNKCONTEXT FAR *CopyChunkContext
             )
{
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    iRet = DeviceIoControl(hShadowDB  , IOCTL_SHADOW_COPYCHUNK
                                  ,(LPVOID)(lpSI), 0
                                  , (LPVOID)CopyChunkContext, 0
                                  , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    return (iRet);
}
#else
int CopyChunk(
                HANDLE                          hShadowDB,
                LPSHADOWINFO                    lpSI,
                struct tagCOPYCHUNKCONTEXT FAR  *CopyChunkContext
             )
{
    BOOL Success;
    BOOL fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    CopyChunkContext->LastAmountRead = 0;

    Success = DeviceIoControl(hShadowDB  , IOCTL_SHADOW_COPYCHUNK
                                  , (LPVOID)(lpSI), 0
                                  , (LPVOID)CopyChunkContext, sizeof(*CopyChunkContext)
                                  , &DummyBytesReturned, NULL);

    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    return(Success);
}

int CloseFileWithCopyChunkIntent(
    HANDLE    hShadowDB,
    struct tagCOPYCHUNKCONTEXT FAR *CopyChunkContext
    )
{
    BOOL Success;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }


    Success = DeviceIoControl(hShadowDB  , IOCTL_CLOSEFORCOPYCHUNK
                                  , NULL, 0
                                  , (LPVOID)CopyChunkContext, sizeof(*CopyChunkContext)
                                  , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    return(Success);
}
int OpenFileWithCopyChunkIntent(
    HANDLE      hShadowDB,
    LPCWSTR     lpFileName,
    struct      tagCOPYCHUNKCONTEXT FAR *CopyChunkContext,
    int         ChunkSize
    )
{
    BOOL Success;
    int FileNameLength;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }



    FileNameLength = wcslen(lpFileName) * sizeof(USHORT);

    CopyChunkContext->ChunkSize = ChunkSize;

    Success = DeviceIoControl(hShadowDB  , IOCTL_OPENFORCOPYCHUNK
                                  , (LPVOID)lpFileName, FileNameLength
                                  , (LPVOID)CopyChunkContext, sizeof(*CopyChunkContext)
                                  , &DummyBytesReturned, NULL);

    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    return(Success);
}
#endif

int
BeginReint(
    HSHARE      hShare,
    BOOL        fBlockingReint,
    LPREINT_IO  *lplpReintIO
    )
{
    SHADOWINFO sSI;
    LPREINT_IO lpReintIO = NULL;
    BOOL fSuccess = FALSE;
    
    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.hShare = hShare;

    lpReintIO = LocalAlloc(LPTR, sizeof(REINT_IO));
    if (!lpReintIO)
    {
        return 0;        
    }
    
    // don't create hevent in the overlapped structure because we are not going to do any read write
    // on this

    if (!fBlockingReint)
    {
        sSI.uOp = 1;
    }
    
    // create an async handle
    lpReintIO->hShadowDBAsync = OpenShadowDatabaseIOex(1, FILE_FLAG_OVERLAPPED);

    if (lpReintIO->hShadowDBAsync == INVALID_HANDLE_VALUE)
    {
        goto bailout;
    }

    *lplpReintIO = lpReintIO;

    // issue an overlapped I/O request
    // This creates an IRP which is cancelled when the thread that is merging
    // dies in the middle of a merge
    fSuccess = DeviceIoControl(lpReintIO->hShadowDBAsync  , IOCTL_SHADOW_BEGIN_REINT
                                  ,(LPVOID)(&sSI), 0
                                  , NULL, 0
                                  , &DummyBytesReturned, &(lpReintIO->sOverlapped));
bailout:
    if (!fSuccess)
    {
        DWORD   dwError;

        dwError = GetLastError();
        if (dwError != ERROR_IO_PENDING)
        {
            if (lpReintIO->hShadowDBAsync != INVALID_HANDLE_VALUE)
            {
                CloseHandle(lpReintIO->hShadowDBAsync);
            }
            LocalFree(lpReintIO);
            SetLastError(dwError);
            *lplpReintIO = NULL;
        }
        else
        {
            fSuccess = TRUE;
        }
    }

    return fSuccess;
}

int
EndReint(
    HSHARE      hShare,
    LPREINT_IO  lpReintIO
    )
{
    SHADOWINFO sSI;
    BOOL fSuccess;
    DWORD   dwError = NO_ERROR;   

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.hShare = hShare;
    fSuccess = DeviceIoControl(lpReintIO->hShadowDBAsync  , IOCTL_SHADOW_END_REINT
                                  ,(LPVOID)(&sSI), 0
                                  , NULL, 0
                                  , &DummyBytesReturned, NULL);
    
    if (!fSuccess)
    {
        dwError = GetLastError();        
    }

    CloseHandle(lpReintIO->hShadowDBAsync);
    LocalFree(lpReintIO);

    if (!fSuccess)
    {
        SetLastError(dwError);        
    }
    return fSuccess;
}

int
SetShareStatus(
    HANDLE          hShadowDB,
    HSHARE         hShare,
    unsigned long   uStatus,
    unsigned long   uOp
    )
{
    SHADOWINFO sSI;
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.hShare = hShare;
    sSI.uStatus = uStatus;
    sSI.uOp = uOp;
    iRet = DeviceIoControl(hShadowDB  , IOCTL_SET_SHARE_STATUS
                                  ,(LPVOID)(&sSI), 0
                                  , NULL, 0
                                  , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (!iRet)
    {
        SetLastError(sSI.dwError);
    }

    return (iRet);
}

int
GetShareStatus(
    HANDLE          hShadowDB,
    HSHARE         hShare,
    unsigned long   *lpulStatus
    )
{
    SHADOWINFO sSI;
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.hShare = hShare;
    iRet = DeviceIoControl(hShadowDB  , IOCTL_GET_SHARE_STATUS
                                  ,(LPVOID)(&sSI), 0
                                  , NULL, 0
                                  , &DummyBytesReturned, NULL);
    if(iRet)
    {
        *lpulStatus = sSI.uStatus;
    }
    else
    {
        *lpulStatus = 0;
    }

    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (!iRet)
    {
        SetLastError(sSI.dwError);
    }


    return iRet;
}


int ShadowSwitches(
    HANDLE          hShadowDB,
    unsigned long   *lpuSwitches,
    unsigned long   uOp
    )
{
    SHADOWINFO sSI;
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.uStatus = *lpuSwitches;
    sSI.uOp = uOp;
    iRet = DeviceIoControl(hShadowDB  , IOCTL_SWITCHES
                                  ,(LPVOID)(&sSI), 0
                                  , NULL, 0
                                  , &DummyBytesReturned, NULL);
    *lpuSwitches = sSI.uStatus;
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (!iRet)
    {
        SetLastError(sSI.dwError);
    }


    return (iRet);
}


int GetShadowDatabaseLocationW(
    HANDLE              hShadowDB,
    WIN32_FIND_DATAW    *lpFind32W
    )
{
    SHADOWINFO sSI;
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.uStatus = SHADOW_SWITCH_SHADOWING;
    sSI.uOp = SHADOW_SWITCH_GET_STATE;
    sSI.lpFind32 = lpFind32W;

    iRet = DeviceIoControl(hShadowDB  , IOCTL_SWITCHES
                                  ,(LPVOID)(&sSI), 0
                                  , NULL, 0
                                  , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }
    if (!iRet)
    {
        SetLastError(sSI.dwError);
    }
    return (iRet);
}

int EnableShadowing(
    HANDLE    hShadowDB,
    LPCSTR    lpszDatabaseLocation,    // location of the shadowing directory
    LPCSTR    lpszUserName,            // name of the user
    DWORD    dwDefDataSizeHigh,        // cache size if being created for the first time
    DWORD    dwDefDataSizeLow,
    DWORD   dwClusterSize,
    BOOL    fReformat
)
{
    SHADOWINFO sSI;
    WIN32_FIND_DATAA   sFind32;
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    memset(&sFind32, 0, sizeof(WIN32_FIND_DATAA));
    sFind32.nFileSizeHigh = dwDefDataSizeHigh;
    sFind32.nFileSizeLow = dwDefDataSizeLow;
    sFind32.dwReserved1 = dwClusterSize;
    if (lpszDatabaseLocation)
    {
        if (strlen(lpszDatabaseLocation) > sizeof(sFind32.cFileName))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return 0;
        }

        strcpy(sFind32.cFileName, lpszDatabaseLocation);
    }
    if (lpszUserName)
    {
        strncpy(sFind32.cAlternateFileName, lpszUserName, MAX_USERNAME);
    }
    sSI.uStatus = SHADOW_SWITCH_SHADOWING;
    sSI.uOp = SHADOW_SWITCH_ON;
    sSI.ulRefPri = fReformat;
    sSI.lpFind32 = (WIN32_FIND_DATAW *)&sFind32;
    iRet = DeviceIoControl(hShadowDB  , IOCTL_SWITCHES
                                  ,(LPVOID)(&sSI), 0
                                  , NULL, 0
                                  , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (!iRet)
    {
        SetLastError(sSI.dwError);
    }


    return (iRet);
}

int
RegisterAgent(
    HANDLE  hShadowDB,
    HWND    hwndAgent,
    HANDLE  hEvent
    )
{

    SHADOWINFO sSI;
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = __OpenShadowDatabaseIO(1);
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(sSI));
    sSI.hShare = HandleToUlong(hwndAgent);
    sSI.hDir = HandleToUlong(hEvent);

    //
    // Ensure that we're dealing with truncatable handles here
    //

    Assert( (HANDLE)sSI.hShare == hwndAgent );
    Assert( (HANDLE)sSI.hDir == hEvent );

    iRet = DeviceIoControl(hShadowDB, IOCTL_SHADOW_REGISTER_AGENT,
                                  (LPVOID)&sSI, 0,
                                  NULL, 0,
                                  &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (!iRet)
    {
        SetLastError(sSI.dwError);
    }

    return (iRet);
}

int
UnregisterAgent(
    HANDLE  hShadowDB,
    HWND    hwndAgent
    )
{
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    iRet = DeviceIoControl(hShadowDB, IOCTL_SHADOW_UNREGISTER_AGENT,
                                  (LPVOID)hwndAgent, 0,
                                  NULL, 0,
                                  &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    return (iRet);
}


int
DisableShadowingForThisThread(
    HANDLE  hShadowDB
    )
{
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }
    iRet = DoShadowMaintenance(hShadowDB, SHADOW_PER_THREAD_DISABLE);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }
    return (iRet);
}

int
EnableShadowingForThisThread(
    HANDLE  hShadowDB
    )
{
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }
    iRet = DoShadowMaintenance(hShadowDB, SHADOW_PER_THREAD_ENABLE);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }
    return (iRet);

}

int
ReinitShadowDatabase(
    HANDLE  hShadowDB,
    LPCSTR  lpszDatabaseLocation,    // location of the shadowing directory
    LPCSTR  lpszUserName,            // name of the user
    DWORD   dwDefDataSizeHigh,        // cache size if being created for the first time
    DWORD   dwDefDataSizeLow,
    DWORD   dwClusterSize
    )
{
    SHADOWINFO sSI;
    WIN32_FIND_DATAA   sFind32;
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    memset(&sFind32, 0, sizeof(WIN32_FIND_DATAA));
    sFind32.nFileSizeHigh = dwDefDataSizeHigh;
    sFind32.nFileSizeLow = dwDefDataSizeLow;
    sFind32.dwReserved1 = dwClusterSize;
    if (lpszDatabaseLocation)
    {
        if (strlen(lpszDatabaseLocation) > sizeof(sFind32.cFileName))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return 0;
        }
        strcpy(sFind32.cFileName, lpszDatabaseLocation);
    }
    if (lpszUserName)
    {
        strncpy(sFind32.cAlternateFileName, lpszUserName, MAX_USERNAME);
    }
    sSI.uOp = SHADOW_REINIT_DATABASE;
    sSI.lpFind32 = (WIN32_FIND_DATAW *)&sFind32;
    iRet = DeviceIoControl(hShadowDB  , IOCTL_DO_SHADOW_MAINTENANCE
                                  ,(LPVOID)(&sSI), 0
                                  , NULL, 0
                                  , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (!iRet)
    {
        SetLastError(sSI.dwError);
    }

    return (iRet);
}



BOOL
IsNetDisconnected(
    DWORD dwErrorCode
)
{
    int i;

    if (dwErrorCode != NO_ERROR)
    {

        for (i=0; i< (sizeof(rgdwErrorTab)/sizeof(DWORD)); ++i)
        {
            if (rgdwErrorTab[i] == dwErrorCode)
            {
//                DEBUG_PRINT(("lib3: IsNetDisconnected on %d\r\n",  dwErrorCode));
                return TRUE;
            }
        }
    }

    return FALSE;
}

int
FindCreatePrincipalIDFromSID(
    HANDLE  hShadowDB,
    LPVOID  lpSidBuffer,
    ULONG   cbSidLength,
    ULONG   *lpuPrincipalID,
    BOOL    fCreate
    )
{
    SHADOWINFO sSI;
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.uSubOperation = SHADOW_FIND_CREATE_PRINCIPAL_ID;
    sSI.lpBuffer = lpSidBuffer;
    sSI.cbBufferSize = cbSidLength;
    sSI.uStatus = fCreate;
    iRet = DeviceIoControl(hShadowDB  , IOCTL_DO_SHADOW_MAINTENANCE
                                  ,(LPVOID)(&sSI), 0
                                  , NULL, 0
                                  , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (iRet)
    {
        *lpuPrincipalID = sSI.ulPrincipalID;
    }
    else
    {
        SetLastError(sSI.dwError);
    }


    return (iRet);
}

int
GetSecurityInfoForCSC(
    HANDLE          hShadowDB,
    HSHADOW         hDir,
    HSHADOW         hShadow,
    LPSECURITYINFO  lpSecurityInfo,
    DWORD           *lpdwBufferSize
    )
{
    SHADOWINFO sSI;
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.uSubOperation = SHADOW_GET_SECURITY_INFO;
    sSI.lpBuffer = lpSecurityInfo;
    sSI.cbBufferSize = *lpdwBufferSize;
    sSI.hDir = hDir;
    sSI.hShadow = hShadow;
    iRet = DeviceIoControl(hShadowDB  , IOCTL_DO_SHADOW_MAINTENANCE
                                  ,(LPVOID)(&sSI), 0
                                  , NULL, 0
                                  , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (iRet)
    {
        *lpdwBufferSize = sSI.cbBufferSize;
    }
    else
    {
        SetLastError(sSI.dwError);
    }


    return (iRet);

}

BOOL
SetExclusionList(
    HANDLE  hShadowDB,
    LPWSTR  lpwList,
    DWORD   cbSize
    )
{

    SHADOWINFO sSI;
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.uSubOperation = SHADOW_SET_EXCLUSION_LIST;
    sSI.lpBuffer = lpwList;
    sSI.cbBufferSize = cbSize;

    iRet = DeviceIoControl(hShadowDB  , IOCTL_DO_SHADOW_MAINTENANCE
                                  ,(LPVOID)(&sSI), 0
                                  , NULL, 0
                                  , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (!iRet)
    {
        SetLastError(sSI.dwError);
    }


    return (iRet);

}

BOOL
SetBandwidthConservationList(
    HANDLE  hShadowDB,
    LPWSTR  lpwList,
    DWORD   cbSize
    )
{

    SHADOWINFO sSI;
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.uSubOperation = SHADOW_SET_BW_CONSERVE_LIST;
    sSI.lpBuffer = lpwList;
    sSI.cbBufferSize = cbSize;

    iRet = DeviceIoControl(hShadowDB  , IOCTL_DO_SHADOW_MAINTENANCE
                                  ,(LPVOID)(&sSI), 0
                                  , NULL, 0
                                  , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (!iRet)
    {
        SetLastError(sSI.dwError);
    }


    return (iRet);

}


BOOL
TransitionShareInternal(
    HANDLE  hShadowDB,
    HSHARE hShare,
    BOOL    fTrue,
    BOOL    fOnlineToOffline
    )
{

    SHADOWINFO sSI;
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.hShare = hShare;
    sSI.uStatus = fTrue;

    iRet = DeviceIoControl(
                    hShadowDB,
                    (fOnlineToOffline)?IOCTL_TRANSITION_SERVER_TO_OFFLINE:IOCTL_TRANSITION_SERVER_TO_ONLINE
                                  ,(LPVOID)(&sSI), 0
                                  , NULL, 0
                                  , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    return (iRet);

}

BOOL
TransitionShareToOffline(
    HANDLE  hShadowDB,
    HSHARE hShare,
    BOOL    fTrue
    )
{
    return TransitionShareInternal(
                hShadowDB,
                hShare,    // which share
                fTrue,      // transtion or not
                TRUE);      // online to offline
}

BOOL
TransitionShareToOnline(
    HANDLE  hShadowDB,
    HSHARE hShare
    )
{
    return TransitionShareInternal(
            hShadowDB,
            hShare,    // which share
            TRUE,       // really a don't care
            FALSE);     // offlinetoonline
}


BOOL
IsServerOfflineW(
    HANDLE  hShadowDB,
    LPCWSTR  lptzShare,
    BOOL    *lpfIsOffline
    )
{
    SHADOWINFO sSI;
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    if (lptzShare)
    {
        sSI.lpBuffer = (LPVOID)(lptzShare);
        sSI.cbBufferSize = sizeof(WORD) * (lstrlenW(lptzShare)+1);
    }


    iRet = DeviceIoControl(
                    hShadowDB,
                    IOCTL_IS_SERVER_OFFLINE
                    ,(LPVOID)(&sSI), 0
                    , NULL, 0
                    , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (iRet)
    {
        *lpfIsOffline = sSI.uStatus;
    }
    return (iRet);

}

BOOL
IsServerOfflineA(
    HANDLE  hShadowDB,
    LPCSTR  lptzShare,
    BOOL    *lpfIsOffline
    )
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

int GetShadowDatabaseLocationA(
    HANDLE              hShadowDB,
    WIN32_FIND_DATAA    *lpFind32A
    )
{
    int iRet = 0;
    WIN32_FIND_DATAW    sFind32W;

    if (GetShadowDatabaseLocationW(hShadowDB, &sFind32W))
    {
        memset(lpFind32A, 0, sizeof(*lpFind32A));
        iRet = WideCharToMultiByte(CP_ACP, 0, sFind32W.cFileName, wcslen(sFind32W.cFileName), lpFind32A->cFileName, sizeof(lpFind32A->cFileName), NULL, NULL);
    }

    return (iRet);
}

BOOL
GetNameOfServerGoingOfflineW(
    HANDLE      hShadowDB,
    LPBYTE      lpBuffer,
    LPDWORD     lpdwSize
    )
{
    SHADOWINFO sSI;
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.lpBuffer = (LPVOID)(lpBuffer);
    sSI.cbBufferSize = *lpdwSize;


    iRet = DeviceIoControl(
                    hShadowDB,
                    IOCTL_NAME_OF_SERVER_GOING_OFFLINE
                    ,(LPVOID)(&sSI), 0
                    , NULL, 0
                    , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (!iRet)
    {
        *lpdwSize = sSI.cbBufferSize;
    }

    return (iRet);

}

BOOL
RenameShadow(
    HANDLE  hShadowDB,
    HSHADOW hDirFrom,
    HSHADOW hShadowFrom,
    HSHADOW hDirTo,
    LPWIN32_FIND_DATAW   lpFind32,
    BOOL    fReplaceFile,
    HSHADOW *lphShadowTo
    )
{

    SHADOWINFO sSI;
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));

    sSI.hDir = hDirFrom;
    sSI.hShadow = hShadowFrom;
    sSI.hDirTo = hDirTo;
    sSI.uSubOperation = SHADOW_RENAME;
    sSI.uStatus = fReplaceFile;
    sSI.lpFind32 = lpFind32;
    iRet = DeviceIoControl(
                    hShadowDB
                    ,IOCTL_DO_SHADOW_MAINTENANCE
                    ,(LPVOID)(&sSI), 0
                    , NULL, 0
                    , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (!iRet)
    {
        SetLastError(sSI.dwError);
    }
    else
    {
        if (lphShadowTo)
        {
            *lphShadowTo = sSI.hShadow;
        }
    }
    return (iRet);

}

BOOL
GetSparseStaleDetectionCounter(
    HANDLE  hShadowDB,
    LPDWORD lpdwCounter
    )
{
    SHADOWINFO sSI;
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.uSubOperation = SHADOW_SPARSE_STALE_DETECTION_COUNTER;

    iRet = DeviceIoControl(
                    hShadowDB
                    ,IOCTL_DO_SHADOW_MAINTENANCE
                    ,(LPVOID)(&sSI), 0
                    , NULL, 0
                    , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (!iRet)
    {
        SetLastError(sSI.dwError);
    }
    else
    {
        *lpdwCounter = sSI.dwError;
    }

    return (iRet);


}

BOOL
GetManualFileDetectionCounter(
    HANDLE  hShadowDB,
    LPDWORD lpdwCounter
    )
{
    SHADOWINFO sSI;
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.uSubOperation = SHADOW_MANUAL_FILE_DETECTION_COUNTER;

    iRet = DeviceIoControl(
                    hShadowDB
                    ,IOCTL_DO_SHADOW_MAINTENANCE
                    ,(LPVOID)(&sSI), 0
                    , NULL, 0
                    , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (!iRet)
    {
        SetLastError(sSI.dwError);
    }
    else
    {
        *lpdwCounter = sSI.dwError;
    }

    return (iRet);


}


int EnableShadowingForUser(
    HANDLE    hShadowDB,
    LPCSTR    lpszDatabaseLocation,    // location of the shadowing directory
    LPCSTR    lpszUserName,            // name of the user
    DWORD    dwDefDataSizeHigh,        // cache size if being created for the first time
    DWORD    dwDefDataSizeLow,
    DWORD   dwClusterSize,
    BOOL    fFormat
)
{
    SHADOWINFO sSI;
    WIN32_FIND_DATAA   sFind32;
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    memset(&sFind32, 0, sizeof(WIN32_FIND_DATAA));
    sFind32.nFileSizeHigh = dwDefDataSizeHigh;
    sFind32.nFileSizeLow = dwDefDataSizeLow;
    sFind32.dwReserved1 = dwClusterSize;
    if (lpszDatabaseLocation)
    {
        if (strlen(lpszDatabaseLocation) > sizeof(sFind32.cFileName))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return 0;
        }

        strcpy(sFind32.cFileName, lpszDatabaseLocation);
    }
    if (lpszUserName)
    {
        strncpy(sFind32.cAlternateFileName, lpszUserName, MAX_USERNAME);
    }

    sSI.lpFind32 = (WIN32_FIND_DATAW *)&sFind32;
    sSI.uSubOperation = SHADOW_ENABLE_CSC_FOR_USER;
    sSI.ulRefPri = fFormat;

    iRet = DeviceIoControl(hShadowDB
                           ,IOCTL_DO_SHADOW_MAINTENANCE,(LPVOID)(&sSI), 0
                                  , NULL, 0
                                  , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (!iRet)
    {
        SetLastError(sSI.dwError);
    }


    return (iRet);
}

int DisableShadowingForUser(
    HANDLE    hShadowDB
)
{
    SHADOWINFO sSI;
    WIN32_FIND_DATAA   sFind32;
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.uSubOperation = SHADOW_DISABLE_CSC_FOR_USER;

    iRet = DeviceIoControl(hShadowDB
                           ,IOCTL_DO_SHADOW_MAINTENANCE,(LPVOID)(&sSI), 0
                                  , NULL, 0
                                  , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (!iRet)
    {
        SetLastError(sSI.dwError);
    }


    return (iRet);
}


LPCOPYPARAMSW LpAllocCopyParamsW(
    VOID
    )
{
    LPCOPYPARAMSW   lpCPW = NULL;

    DWORD   dwMinSize = (sizeof(COPYPARAMSW) + MAX_PATH+MAX_PATH+MAX_SERVER_SHARE_NAME_FOR_CSC)*sizeof(unsigned short);

    lpCPW = (LPCOPYPARAMSW)LocalAlloc(LPTR, dwMinSize);

    if (lpCPW)
    {
        lpCPW->lpLocalPath  = (LPWSTR)((LPBYTE)lpCPW+sizeof(COPYPARAMSW));
        lpCPW->lpRemotePath = (lpCPW->lpLocalPath + MAX_PATH);
        lpCPW->lpSharePath = (lpCPW->lpRemotePath + MAX_PATH);

    }

    return (lpCPW);
}

VOID
FreeCopyParamsW(
    IN LPCOPYPARAMSW lpCPW
    )
{
    LocalFree(lpCPW);
}

LPCOPYPARAMSA LpAllocCopyParamsA(
    VOID
    )
{
    LPCOPYPARAMSA   lpCPA = NULL;
    DWORD   dwMinSize = (sizeof(COPYPARAMSA) + MAX_PATH+MAX_PATH+MAX_SERVER_SHARE_NAME_FOR_CSC);

    lpCPA = (LPCOPYPARAMSA)LocalAlloc(LPTR, dwMinSize);

    if (lpCPA)
    {
        lpCPA->lpLocalPath  = (LPSTR)((LPBYTE)lpCPA+sizeof(COPYPARAMSA));
        lpCPA->lpRemotePath = (lpCPA->lpLocalPath + MAX_PATH);
        lpCPA->lpSharePath = (lpCPA->lpRemotePath + MAX_PATH);

    }
    return (lpCPA);
}

VOID
FreeCopyParamsA(
    IN LPCOPYPARAMSA lpCPA
    )
{
    LocalFree(lpCPA);
}

BOOL
ConvertCopyParamsFromUnicodeToAnsi(
    LPCOPYPARAMSW   lpCPUni,
    LPCOPYPARAMSA   lpCP
)
{
    memset(lpCP->lpLocalPath, 0, MAX_PATH);
    memset(lpCP->lpRemotePath, 0, MAX_PATH);
    memset(lpCP->lpSharePath, 0, MAX_SERVER_SHARE_NAME_FOR_CSC);

    WideCharToMultiByte(CP_ACP, 0, lpCPUni->lpLocalPath, wcslen(lpCPUni->lpLocalPath), lpCP->lpLocalPath, MAX_PATH, NULL, NULL);
    WideCharToMultiByte(CP_ACP, 0, lpCPUni->lpRemotePath, wcslen(lpCPUni->lpRemotePath), lpCP->lpRemotePath, MAX_PATH, NULL, NULL);
    WideCharToMultiByte(CP_ACP, 0, lpCPUni->lpSharePath, wcslen(lpCPUni->lpSharePath), lpCP->lpSharePath, MAX_SERVER_SHARE_NAME_FOR_CSC, NULL, NULL);
    return TRUE;
}

BOOL
Find32WToFind32A(
    WIN32_FIND_DATAW    *lpFind32W,
    WIN32_FIND_DATAA    *lpFind32A
    )
{
    memset(lpFind32A, 0, sizeof(WIN32_FIND_DATAA));
    memcpy(lpFind32A, lpFind32W, sizeof(WIN32_FIND_DATAA)-sizeof(lpFind32A->cFileName)-sizeof(lpFind32A->cAlternateFileName));

    if (    WideCharToMultiByte(CP_ACP, 0, lpFind32W->cFileName, wcslen(lpFind32W->cFileName), lpFind32A->cFileName, sizeof(lpFind32A->cFileName), NULL, NULL)
        &&  WideCharToMultiByte(CP_OEMCP, 0, lpFind32W->cAlternateFileName, wcslen(lpFind32W->cAlternateFileName), lpFind32A->cAlternateFileName, sizeof(lpFind32A->cAlternateFileName), NULL, NULL))
    {
        return TRUE;
    }
    return FALSE;
}

BOOL
Find32AToFind32W(
    WIN32_FIND_DATAA    *lpFind32A,
    WIN32_FIND_DATAW    *lpFind32W
    )
{
    memset(lpFind32W, 0, sizeof(WIN32_FIND_DATAW));
    memcpy(lpFind32W, lpFind32A, sizeof(WIN32_FIND_DATAW)-sizeof(lpFind32W->cFileName)-sizeof(lpFind32W->cAlternateFileName));

    if (    MultiByteToWideChar(CP_ACP, 0, lpFind32A->cFileName, strlen(lpFind32A->cFileName), lpFind32W->cFileName, sizeof(lpFind32W->cFileName)/sizeof(WCHAR))
        &&  MultiByteToWideChar(CP_OEMCP, 0, lpFind32A->cAlternateFileName, strlen(lpFind32A->cAlternateFileName), lpFind32W->cAlternateFileName, sizeof(lpFind32W->cAlternateFileName)/sizeof(WCHAR)))
    {
        return TRUE;
    }
    return FALSE;
}

BOOL
ShareInfoWToShareInfoA(
    LPSHAREINFOW   lpShareInfoW,
    LPSHAREINFOA   lpShareInfoA
    )
{
    memset(lpShareInfoA, 0, sizeof(*lpShareInfoA));

    lpShareInfoA->hShare = lpShareInfoW->hShare;
    lpShareInfoA->usCaps = lpShareInfoW->usCaps;
    lpShareInfoA->usState = lpShareInfoW->usState;

    WideCharToMultiByte( CP_ACP, 0,
                         lpShareInfoW->rgSharePath,
                         wcslen(lpShareInfoW->rgSharePath),
                         lpShareInfoA->rgSharePath,
                         sizeof(lpShareInfoA->rgSharePath), NULL, NULL);

    WideCharToMultiByte(    CP_ACP, 0,
                            lpShareInfoW->rgFileSystem,
                            wcslen(lpShareInfoW->rgFileSystem),
                            lpShareInfoA->rgFileSystem,
                            sizeof(lpShareInfoA->rgFileSystem), NULL, NULL);
    return TRUE;
}

BOOL
RecreateShadow(
    HANDLE  hShadowDB,
    HSHADOW hDir,
    HSHADOW hShadow,
    ULONG   ulAttrib
    )
{
    SHADOWINFO sSI;
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.hDir = hDir;
    sSI.hShadow = hShadow;
    sSI.uStatus = ulAttrib;
    sSI.uSubOperation = SHADOW_RECREATE;

    iRet = DeviceIoControl(
                    hShadowDB
                    ,IOCTL_DO_SHADOW_MAINTENANCE
                    ,(LPVOID)(&sSI), 0
                    , NULL, 0
                    , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (!iRet)
    {
        SetLastError(sSI.dwError);
    }

    return (iRet);



}

BOOL
SetDatabaseStatus(
    HANDLE  hShadowDB,
    ULONG   ulStatus,
    ULONG   uMask
    )
{
    SHADOWINFO sSI;
    int iRet;
    BOOL        fDBOpened = FALSE;

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        hShadowDB = OpenShadowDatabaseIO();
        if (hShadowDB == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
        fDBOpened = TRUE;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.uStatus = ulStatus;
    sSI.uSubOperation = SHADOW_SET_DATABASE_STATUS;
    sSI.ulHintFlags = uMask;

    iRet = DeviceIoControl(
                    hShadowDB
                    ,IOCTL_DO_SHADOW_MAINTENANCE
                    ,(LPVOID)(&sSI), 0
                    , NULL, 0
                    , &DummyBytesReturned, NULL);
    if (fDBOpened)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (!iRet)
    {
        SetLastError(sSI.dwError);
    }
    return (iRet);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\usermode\reint\csc_bmpu.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    csc_bmpu.c

Abstract:

    This module implements the user mode utility functions of bitmaps
    associated with CSC files. CSC_BMP_U is an opaque structure. Must
    use the functions here to create/modify/destroy a CSC_BMP_U to
    ensure data integrity.  The 'u' in the filename means "usermode."

Author:

    Nigel Choi [t-nigelc]  Sept 3, 1999

--*/

#include "pch.h"

#ifdef CSC_ON_NT
#pragma hdrstop

#define UNICODE

#endif //CSC_ON_NT

#include "csc_bmpu.h"

 // append this to inode file name to get the stream name
LPTSTR CscBmpAltStrmName = TEXT(STRMNAME);

#ifdef DEBUG

#define CSC_BitmapKdPrint(__bit,__x) {\
    if (((CSC_BITMAP_KDP_##__bit)==0) || (CSC_BitmapKdPrintVector & (CSC_BITMAP_KDP_##__bit))) {\
    DEBUG_PRINT(__x);\
    }\
}
#define CSC_BITMAP_KDP_ALWAYS                0x00000000
#define CSC_BITMAP_KDP_REINT                 0x00000001
#define CSC_BITMAP_KDP_PRINTBITMAP           0x00000002

// static ULONG CSC_BitmapKdPrintVector = 0XFFFFFFFF;
static ULONG CSC_BitmapKdPrintVector = 0;

#else

#define CSC_BitmapKdPrint(__bit,__x) ;

#endif

/*++

    CSC_BitmapCreate()

Routine Description:

    Allocates an appropriate in-memory bitmap CSC_BITMAP_U with size
    corresponding to filesize.

Arguments:


Returns:

    NULL if memory allocation error.
    pointer to the newly allocated bitmap if successful.

Notes:


--*/
LPCSC_BITMAP_U
CSC_BitmapCreate(
    DWORD filesize)
{
    LPCSC_BITMAP_U bm;
    DWORD i;

    bm = (LPCSC_BITMAP_U)malloc(sizeof(CSC_BITMAP_U));

    if (bm == NULL)
        return NULL;

    bm->bitmapsize = filesize/BLOCKSIZE;
    if (filesize % BLOCKSIZE)
        bm->bitmapsize++;
    bm->numDWORD = bm->bitmapsize/(8*sizeof(DWORD));
    if (bm->bitmapsize % (8*sizeof(DWORD)))
        bm->numDWORD++;

    bm->reintProgress = 0; /* not reint yet */

    if (bm->bitmapsize) {
        bm->bitmap = (LPDWORD)malloc(bm->numDWORD*sizeof(DWORD));
        if (bm->bitmap == NULL) {
            free(bm);
            return NULL;
        }
        for (i = 0; i < bm->numDWORD; i++) {
          bm->bitmap[i] = 0;
        }
    } else {
        bm->bitmap = NULL;
    }

    return bm;
}

/*++

    CSC_BitmapDelete()

Routine Description:


Arguments:


Returns:


Notes:

--*/
void
CSC_BitmapDelete(
    LPCSC_BITMAP_U *lplpbitmap)
{
    if (lplpbitmap == NULL)
        return;
    if (*lplpbitmap == NULL)
        return;
    if ((*lplpbitmap)->bitmap)
        free((*lplpbitmap)->bitmap);
    free((*lplpbitmap));
    *lplpbitmap = NULL;
}

/*++

    CSC_BitmapIsMarked()

Routine Description:


Arguments:


Returns:

    -1 if lpbitmap is NULL or bitoffset is larger than the bitmap
    TRUE if the bit is marked
    FALSE if the bit is unmarked

Notes:

--*/
int
CSC_BitmapIsMarked(
    LPCSC_BITMAP_U lpbitmap,
    DWORD bitoffset)
{
    DWORD DWORDnum;
    DWORD bitpos;

    if (lpbitmap == NULL)
        return -1;
    if (bitoffset >= lpbitmap->bitmapsize)
        return -1;

    DWORDnum = bitoffset/(8*sizeof(DWORD));
    bitpos = 1 << bitoffset%(8*sizeof(DWORD));

    if (lpbitmap->bitmap[DWORDnum] & bitpos) {
        return TRUE;
    }

    return FALSE;
}

/*++

    CSC_BitmapGetBlockSize()

Routine Description:


Arguments:


Returns:

    The pre-defined block size represented by one bit of the bitmap.

Notes:

--*/
DWORD
CSC_BitmapGetBlockSize()
{
  return BLOCKSIZE;
}

/*++

    CSC_BitmapGetSize()

Routine Description:

Arguments:

Returns:

    -1 if lpbitmap is NULL.
    The size of the bitmap passed in.

Notes:

--*/
int
CSC_BitmapGetSize(
    LPCSC_BITMAP_U lpbitmap)
{
    if (lpbitmap == NULL)
        return -1;
    return lpbitmap->bitmapsize;
}

/*++

    CSC_BitmapStreamNameLen()

Routine Description:

    returns the length of the CSC stream name including the colon, in bytes.

Arguments:


Returns:


Notes:

    size is in bytes. 

--*/
int
CSC_BitmapStreamNameLen()
{
  return lstrlen(CscBmpAltStrmName);
}

/*++

    CSC_BitmapAppendStreamName()

Routine Description:

    Appends the CSC stream name to the existing path/file name fname.

Arguments:

    fname is the sting buffer containing the path/file.
    bufsize is the buffer size.

Returns:

    TRUE if append successful.
    FALSE if buffer is too small or other errors.

Notes:

    Single-byte strings only.

--*/
int
CSC_BitmapAppendStreamName(
    LPTSTR fname,
    DWORD bufsize)
{
    int ret = TRUE;

    if ((lstrlen(fname) + lstrlen(CscBmpAltStrmName) + 1) > (int)bufsize) {
        return FALSE;
    }

    __try {
        ret = TRUE;
        lstrcat(fname, CscBmpAltStrmName);
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        ret = FALSE;
    }

    return ret;
}

/*++

    CSC_BitmapRead()

Routine Description:

    Reads the on-disk bitmap file, and if it exists, is not in use and valid,
    store it in *lplpbitmap. If *lplpbitmap is NULL allocate a new
    bitmap data structure. Otherwise, if *lplpbitmap is not NULL, the
    existing bitmap will be deleted and assigned the on-disk bitmap
    file.

Arguments:

    filename is the file that contains the bitmap. If read from a
    stream, append the stream name before passing the filename in. The
    filename is used as is and no checking of validity of the name is
    performed. For default stream name, append the global LPSTR
    CscBmpAltStrmName.

Returns:

    1 if read successful
    0 if lplpbitmap is NULL
    -1 if error in disk operation (open/read), memory allocating error,
          or invalid bitmap file format.
    -2 if bitmap not exist

Notes:

    CODE.IMPROVEMENT design a better error message propagation mechanism.
    Bitmap open for exclusive access.

--*/
int
CSC_BitmapRead(
    LPCSC_BITMAP_U *lplpbitmap,
    LPCTSTR filename)
{
    CscBmpFileHdr hdr;
    HANDLE bitmapFile;
    DWORD bytesRead;
    DWORD bitmapByteSize;
    DWORD * bitmapBuf = NULL;
    DWORD errCode;
    int ret = 1;

    if (lplpbitmap == NULL)
        return 0;

    bitmapFile = CreateFile(
                    filename,
                    GENERIC_READ,
                    0, // No sharing; exclusive
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL);
    if (bitmapFile == INVALID_HANDLE_VALUE) {
        errCode = GetLastError();
        if (errCode == ERROR_FILE_NOT_FOUND) {
            // File does not exist
            return -2;
        }
        return -1;
    }

    if (!ReadFile(
            bitmapFile,
            &hdr, 
            sizeof(CscBmpFileHdr),
            &bytesRead, NULL)
    ) {
        ret = -1;
        goto CLOSEFILE;
    }

    if (
        bytesRead != sizeof(CscBmpFileHdr)
            ||
        hdr.magicnum != MAGICNUM
            ||
        !hdr.valid
            ||
        hdr.inuse
    ) {
        ret = -1;
        goto CLOSEFILE;
    }

    if (hdr.sizeinbits > 0) {
        bitmapByteSize = hdr.numDWORDs*sizeof(DWORD);
        bitmapBuf = (DWORD *)malloc(bitmapByteSize);
        if (!bitmapBuf) {
            ret = -1;
            goto CLOSEFILE;
        }

        if (!ReadFile(
                bitmapFile,
                bitmapBuf,
                bitmapByteSize,
                &bytesRead,
                NULL)
        ) {
            ret = -1;
            goto CLOSEFILE;
        }

        if (bytesRead != bitmapByteSize) {
            ret = -1;
            goto CLOSEFILE;
        }
    }

    if (*lplpbitmap) {
        // bitmap exist, dump old and create new
        if ((*lplpbitmap)->bitmap)
            free((*lplpbitmap)->bitmap);
            (*lplpbitmap)->bitmap = bitmapBuf;
            (*lplpbitmap)->numDWORD = hdr.numDWORDs;
            (*lplpbitmap)->bitmapsize = hdr.sizeinbits;
    } else {
        // bitmap not exist, create brand new
        *lplpbitmap = (LPCSC_BITMAP_U)malloc(sizeof(CSC_BITMAP_U));
        if (!(*lplpbitmap)) {
            // Error in memory allocation
            ret = -1;
            goto CLOSEFILE;
        }
        (*lplpbitmap)->bitmap = bitmapBuf;
        (*lplpbitmap)->numDWORD = hdr.numDWORDs;
        (*lplpbitmap)->bitmapsize = hdr.sizeinbits;
    }
    (*lplpbitmap)->reintProgress = 0; /* not reint yet */

CLOSEFILE:
    CloseHandle(bitmapFile);

    return ret;
}

/*++

    CSC_BitmapReint()

Routine Description:

    Copy a chunk of srcH to dstH. Offset depends on lpbitmap. Size of
    chunk depends on buffSize. May have to call several times to get
    srcH and dstH fully synchronized. lpbitmap remembers where the last
    CSC_BitmapReint call got to. See description of Return value below
    about how to know when to call again or stop calling.

Arguments:

    lpbitmap  the bitmap must not be zero, otherwise can't keep track of reint 
                progress
    srcH      the handle of the source file. See notes below
    dstH      the handle of the destination file. See notes below
    buff      user-supplied buffer
    buffSize  size of the user-supplied buffer. See notes below
    lpbytesXfered Returns how many bytes are transferred, optional.

Returns:

    CSC_BITMAPReintInvalid lpbitmap or buff is NULL, or srcH or dstH is invalid
    CSC_BITMAPReintError Error in transferring data
    CSC_BITMAPReintCont  made some progress, call CSC_BITMAPReint again
                       to continue Reint
    CSC_BITMAPReintDone  Done Reint, don't need to call again

Notes:

    srcH and dstH MUST NOT be opened with FILE_FLAG_OVERLAPPED 
                                   or FILE_FLAG_NO_BUFFERING
    buffSize must be at least 2 times greater than BLOCKSIZE

--*/
int
CSC_BitmapReint(
    LPCSC_BITMAP_U lpbitmap,
    HANDLE srcH,
    HANDLE dstH,
    LPVOID buff,
    DWORD buffSize,
    DWORD * lpbytesXfered)
{
    DWORD bitoffset;
    DWORD DWORDoffset;
    DWORD bitmask;
    DWORD bytes2cpy = 0;
    DWORD bytesActuallyRead, bytesActuallyCopied;
    DWORD startFileOffset = 0;
    DWORD fileSize;
    BOOL seen1b4 = FALSE;
    int ret = CSC_BITMAPReintCont;

    if (lpbitmap == NULL || buff == NULL) {
        return CSC_BITMAPReintInvalid;
    }
    if (srcH == INVALID_HANDLE_VALUE || dstH == INVALID_HANDLE_VALUE) {
        return CSC_BITMAPReintInvalid;
    }

    CSC_BitmapKdPrint(
            REINT,
            ("***CSC_BitmapReint reintProgress: %u\n",
            lpbitmap->reintProgress));

    startFileOffset = lpbitmap->reintProgress;
    bitoffset = startFileOffset/BLOCKSIZE;
    startFileOffset = bitoffset * BLOCKSIZE; // make sure startFileOffset is 
    // aligned with BLOCKSIZE
    DWORDoffset = bitoffset/(sizeof(DWORD)*8);
    bitmask = 1 << bitoffset%(sizeof(DWORD)*8);

    while (bytes2cpy < buffSize && bitoffset < lpbitmap->bitmapsize) {
        // the loop
        if ((bitmask & lpbitmap->bitmap[DWORDoffset]) != 0) {
            // the bit is marked
            if (!seen1b4) {
                // seeing first bit of a consecutive chunk of 1's
                startFileOffset = bitoffset * BLOCKSIZE;
                bytes2cpy += BLOCKSIZE;
                seen1b4 = TRUE;
            } else {
                // seeing the rest of the bits of a consecutive chunk of 1's
                // other than the first one
                bytes2cpy += BLOCKSIZE;
            }
        } else {
            // this bit is not marked
            if (seen1b4) {
                // first 0 after a chunk of consecutive 1's
                break;
            }
        }
        // Advance bitmap index
        bitoffset++;
        bitmask = bitmask << 1;
        if (bitmask == 0) {
            bitmask = 1;
            DWORDoffset++;
        }
    } // while

    if (bytes2cpy > buffSize) {
        bytes2cpy = buffSize;
    }

    // if never seen 1's then must have reached end of bitmap
    // Can't get Assert to compile!?
    // Assert(seen1b4 || (!seen1b4 && (bitoffset >= lpbitmap->bitmapsize)));
    /*
    CSC_BitmapKdPrint(
        REINT,
        ("Must be true, csc_bmpu.c, CSC_BitmapReint: %s\n",
        (seen1b4 || (!seen1b4 && (bitoffset >= lpbitmap->bitmapsize)))?
        "TRUE":"FALSE"));
    */

    CSC_BitmapKdPrint(
        REINT,
        ("startFileOffset: %u bytes2cpy: %u\n",
        startFileOffset,
        bytes2cpy));

    fileSize = GetFileSize(srcH, NULL);
    if (fileSize == 0xFFFFFFFF) {
        // if cannot get filesize, just be conservative on
        // what needs to be copied, ie, copy as much as possible
        if (seen1b4) {
            // Seen 1's before
            if (bitoffset >= lpbitmap->bitmapsize) {
                // copying until end of bitmap, copy as much as possible
                bytes2cpy = buffSize;
            }
        } else {
            // not seen 1's before, copy from the last block represented
            // by bitmap for as many bytes as possible
            startFileOffset = (lpbitmap->bitmapsize)?  ((lpbitmap->bitmapsize-1)*BLOCKSIZE):0;
            bytes2cpy = buffSize;
        }
    } else { // filesize == 0xFFFFFFFF
        if (startFileOffset >= fileSize) {
            // Obviously done
            return CSC_BITMAPReintDone;
        }
        if (!seen1b4) {
            // never seen 1's
            if ((bitoffset * BLOCKSIZE) >= fileSize) {
                // bitmap is accurate representation of the file, or bitmap is larger
                // bitoffset should be pointing to last bit of the bitmap + 1
                // see ASSERT above
                return CSC_BITMAPReintDone;
            } else {
                // bitmap is shorter than the file, copy the rest of the file
                if (startFileOffset < lpbitmap->bitmapsize*BLOCKSIZE) {
                    startFileOffset = (lpbitmap->bitmapsize)?
                    ((lpbitmap->bitmapsize-1)*BLOCKSIZE):0;
                }
                bytes2cpy = fileSize - startFileOffset;
                if (bytes2cpy > buffSize) {
                    bytes2cpy = buffSize;
                }
            }
        } else { // if !seen1b4
            // seen 1's
            if (bitoffset >= lpbitmap->bitmapsize) {
                // end of bitmap
                if (bitoffset * BLOCKSIZE < fileSize) {
                    // bitmap is too small compared to real file
                    bytes2cpy = fileSize - startFileOffset;
                    if (bytes2cpy > buffSize) {
                        bytes2cpy = buffSize;
                    }
                } else {
                    ret = CSC_BITMAPReintDone;
                }
            }
        }
    } // fileSize != 0xffffffff

    CSC_BitmapKdPrint(REINT, ("new startFileOffset: %u new bytes2cpy: %u\n",
    startFileOffset, bytes2cpy));

    //Assert(bytes2cpy <= buffSize);

    // Copy Contents

    //****** SET FILE POINTERS!!
    if (SetFilePointer(
            srcH, 
            startFileOffset,
            NULL,
            FILE_BEGIN) == INVALID_SET_FILE_POINTER
    ) {
        return CSC_BITMAPReintError;
    }
    if (!ReadFile(srcH, buff, bytes2cpy, &bytesActuallyRead, NULL)) {
        return CSC_BITMAPReintError;
    }
    if (bytesActuallyRead > 0) {
        if (SetFilePointer(
                dstH, 
                startFileOffset,
                NULL,
                FILE_BEGIN) == INVALID_SET_FILE_POINTER
        ) {
            return CSC_BITMAPReintError;
        }
        if (!WriteFile(
                dstH,
                buff,
                bytesActuallyRead,
            &bytesActuallyCopied, NULL)
        ) {
            return CSC_BITMAPReintError;
        }
    }

    // If copied all data or none read, done.
    if (
        (fileSize != 0xFFFFFFFF && (startFileOffset + bytesActuallyCopied) == fileSize)
            ||
        bytesActuallyRead == 0
    ) {
        ret = CSC_BITMAPReintDone;
    }

    CSC_BitmapKdPrint(
        REINT,
        ("bytesActuallyRead: %u bytesActuallyCopied: %u\n",
        bytesActuallyRead,
        bytesActuallyCopied));

    lpbitmap->reintProgress = startFileOffset + bytesActuallyCopied;

    CSC_BitmapKdPrint(
        REINT,
        ("***CSC_BitmapReint New reintProgress: %u\n",
        lpbitmap->reintProgress));

    if (lpbytesXfered) {
        *lpbytesXfered = bytesActuallyCopied;
    }

    return ret;
}

#ifdef DEBUG
/*++

    CSC_BitmapOutput()

Routine Description:

    Outputs the passed in bitmap to kd

Arguments:


Returns:


Notes:


--*/
VOID
CSC_BitmapOutput(
    LPCSC_BITMAP_U lpbitmap)
{
    DWORD i;

    if (lpbitmap == NULL) {
        CSC_BitmapKdPrint( PRINTBITMAP, ("lpbitmap is NULL\n"));
        return;
    }

    CSC_BitmapKdPrint(
        PRINTBITMAP,
        ( "lpbitmap 0x%08x, bitmapsize 0x%x (%u) bits, numDWORD 0x%x (%u)\n",
            lpbitmap, 
            lpbitmap->bitmapsize, 
            lpbitmap->bitmapsize, 
            lpbitmap->numDWORD,
            lpbitmap->numDWORD));
    CSC_BitmapKdPrint(
        PRINTBITMAP,
            ( "bitmap  |0/5        |1/6        |2/7        |3/8        |4/9\n"));
    CSC_BitmapKdPrint(
        PRINTBITMAP,
            ("number  |01234|56789|01234|56789|01234|56789|01234|56789|01234|56789"));
    for (i = 0; i < lpbitmap->bitmapsize; i++) {
        if ((i % 50) == 0)
            CSC_BitmapKdPrint(PRINTBITMAP, ( "\n%08d", i));
        if ((i % 5) == 0)
            CSC_BitmapKdPrint(PRINTBITMAP, ( "|"));
        CSC_BitmapKdPrint(
            PRINTBITMAP,
            ( "%1d", CSC_BitmapIsMarked(lpbitmap, i)));
    }
    CSC_BitmapKdPrint(PRINTBITMAP, ( "\n"));
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\usermode\reint\dobj.h ===
//
// dobj.h: Declares data, defines and struct types for RecAct
//          module.
//
//

#ifndef __DOBJ_H__
#define __DOBJ_H__

// DOBJ is the draw object structure for drawing listbox entries
//
// DOBJ kinds
//
#define DOK_ICON        1   // lpvObject is the HICON
#define DOK_STRING      2   // lpvObject is the LPCSTR
#define DOK_BITMAP      3   // lpvObject is the HBITMAP
#define DOK_SIDEITEM    4   // lpvObject points to LPSIDEITEM
#define DOK_IMAGE       5   // 
#define DOK_IDS         6   // lpvObject is the resource ID

// DOBJ item styles
//
#define DOF_LEFT        0x0000
#define DOF_CENTER      0x0001
#define DOF_RIGHT       0x0002
#define DOF_DIFFER      0x0004  // This item's appearance is affected by uState
#define DOF_MENU        0x0008  // Use menu colors
#define DOF_DISABLED    0x0010
#define DOF_IGNORESEL   0x0020  // Ignore selection state
#define DOF_USEIDS      0x0040  // lpvObject is a resource string ID
#define DOF_NODRAW      0x1000  // Don't draw 

typedef struct tagDOBJ
    {
    UINT    uKind;          // One of DOK_* ordinals
    UINT    uFlags;         // One of DOF_* styles
    LPVOID  lpvObject;      // ptr or handle
    HIMAGELIST himl;        // 
    int     iImage;         // 
    int     x;
    int     y;
    RECT    rcBounding;     // Bounding rect of entire object
    union 
        {
        RECT rcSrc;         // DOK_BITMAP: source rect to blt from
        RECT rcClip;        // Clipping rect
        RECT rcLabel;       // Clipping rect for label
        };

    } DOBJ, FAR * LPDOBJ;


void PUBLIC Dobj_Draw(HDC hdc, LPDOBJ pdobj, int cItems, UINT uState, int cxEllipses, int cyText, COLORREF clrBkgnd);

void PUBLIC ComputeImageRects(LPCSTR psz, HDC hdc, LPPOINT ppt, LPRECT prcIcon, LPRECT prcLabel, int cxIcon, int cyIcon, int cxIconSpacing, int cyText);

#endif // __DOBJ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\usermode\reint\dobj.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: dobj.c
//
//  This file contains support routines for the reconciliation-action 
//   control class code
//
//
// History:
//  09-13-93 ScottH     Extracted from recact.c
//
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////  INCLUDES

#include "pch.h"

#include "extra.h"
#include "resource.h"
#include "recact.h"
#include "dobj.h"

/////////////////////////////////////////////////////  CONTROLLING DEFINES


/////////////////////////////////////////////////////  DEFINES

#define DT_CALCWRAP     (DT_CALCRECT | DT_CENTER | DT_WORDBREAK | DT_NOPREFIX)
#define DT_CALC         (DT_CALCRECT | DT_CENTER | DT_SINGLELINE | DT_NOPREFIX)

/*----------------------------------------------------------
Purpose: Formats the given path to the correct location format
Returns: --
Cond:    --
*/
void PRIVATE FormatLocationPath(
    LPCSTR pszPath,
    LPSTR pszBuffer)        // Must be MAX_PATH
    {
    UINT ids;
// tHACK    char szBrfDir[MAX_PATH];
    LPCSTR psz;
    LPSTR pszMsg;

    //  The format for the directory location is:
    //
    //      Inside briefcase:       "In Briefcase"
    //      Below briefcase:        "In Briefcase\FolderName"
    //      Outside briefcase:      "In FullPath"
    //
    // We assume that paths outside the current briefcase
    //  never consist of a briefcase name of another.
    //
#if 0
	 // tHACK
	 if (PathGetLocality(pszPath, szBrfDir) != PL_FALSE)
        {
        // Inside the briefcase
        psz = &pszPath[lstrlen(szBrfDir)];
        ids = IDS_InBriefcase;
        }
    else
#endif
        {
        // Outside the briefcase
        psz = pszPath;
        ids = IDS_InLocation;
        }

    if (ConstructMessage(&pszMsg, vhinstCur, MAKEINTRESOURCE(ids), psz))
        {
        lstrcpy(pszBuffer, pszMsg);
        GFree(pszMsg);
        }
    else
        *pszBuffer = 0;
    }


/*----------------------------------------------------------
Purpose: Return the string describing the status of this sideitem
Returns: ptr to status string
Cond:    --
*/
LPSTR PRIVATE SideItem_GetStatus(
    LPSIDEITEM this,
    LPSTR pszBuf,
    UINT cchBuf)
    {
    switch (this->uState)
        {
    case SI_CHANGED:
        return SzFromIDS(IDS_STATE_Changed, pszBuf, cchBuf);
    case SI_UNCHANGED:
        return SzFromIDS(IDS_STATE_Unchanged, pszBuf, cchBuf);
    case SI_NEW:
        return SzFromIDS(IDS_STATE_NewFile, pszBuf, cchBuf);
    case SI_UNAVAILABLE:
        return SzFromIDS(IDS_STATE_Unavailable, pszBuf, cchBuf);
    default:
        return NULL;
        }
    }


/*----------------------------------------------------------
Purpose: Displays the 3-liner: location, status, and timestamp
Returns: --
Cond:    --
*/
void PRIVATE SideItem_Display(
    LPSIDEITEM this,
    HDC hdc,
    LPRECT prc,
    int cxEllipses,
    int cyText)
    {
    char sz[MAX_PATH];
    char szBuf[MAXBUFLEN];
    LPSTR psz;
    RECT rc = *prc;

    // Directory location.  

	 FormatLocationPath(this->pszDir, sz);
//    strcpy(sz, "a long path tHACKed");
    MyDrawText(hdc, sz, &rc, MDT_LEFT | MDT_TRANSPARENT | MDT_ELLIPSES, 
        cyText, cxEllipses, CLR_DEFAULT, CLR_DEFAULT);

    // Status string
    psz = SideItem_GetStatus(this, szBuf, sizeof(szBuf));
    if (psz)
        {
        // Only bother with these two lines if the file actually
        // exists.

        rc.top += cyText;
        MyDrawText(hdc, psz, &rc, MDT_LEFT | MDT_TRANSPARENT, 
            cyText, cxEllipses, CLR_DEFAULT, CLR_DEFAULT);

        // Date stamp.  Skip this if this is a folder or unavailable.
        //
        if (this->fs.fscond != FS_COND_UNAVAILABLE)
            {
            FileTimeToDateTimeString(&this->fs.ftMod, sz, sizeof(sz));

            rc.top += cyText;
            MyDrawText(hdc, sz, &rc, MDT_LEFT | MDT_TRANSPARENT, 
                cyText, cxEllipses, CLR_DEFAULT, CLR_DEFAULT);
            }
        }
    }


/*----------------------------------------------------------
Purpose: Return the bounding rect for a labelled image.

Returns: --
Cond:    --
*/
void PUBLIC ComputeImageRects(
    LPCSTR psz,
    HDC hdc,
    LPPOINT pptInOut,       
    LPRECT prcWhole,        // May be NULL
    LPRECT prcLabel,        // May be NULL
    int cxIcon,
    int cyIcon,
    int cxIconSpacing,
    int cyText)
    {
    RECT rc;
    int yLabel;
    int cxLabel;
    int cyLabel;
    int cchLabel;
    POINT pt;

    ASSERT(psz);

    // Set our minimum rect size for icon spacing
    if (cxIconSpacing < cxIcon)
        cxIconSpacing = cxIcon + g_cxIconMargin * 2;

    // Upon entry, *pptInOut is expected to be the upper left corner of the 
    // icon-spacing rect.  This function will set it to the upper left
    // corner of the icon itself.

    pt.x = pptInOut->x + (cxIconSpacing - cxIcon) / 2;
    pt.y = pptInOut->y + g_cyIconMargin;

    // Determine rectangle of label with wrap

    rc.left = rc.top = rc.bottom = 0;
    rc.right = cxIconSpacing - g_cxLabelMargin * 2;

    cchLabel = lstrlen(psz);
    if (0 < cchLabel)
        {
        DrawText(hdc, psz, cchLabel, &rc, DT_CALCWRAP);
        }
    else
        {
        rc.bottom = rc.top + cyText;
        }

    yLabel = pptInOut->y + g_cyIconMargin + cyIcon + g_cyLabelSpace;
    cxLabel = (rc.right - rc.left) + 2 * g_cxLabelMargin;
    cyLabel = rc.bottom - rc.top;

    if (prcWhole)
        {
        prcWhole->left   = pptInOut->x;
        prcWhole->right  = prcWhole->left + cxIconSpacing;
        prcWhole->top    = pptInOut->y;
        prcWhole->bottom = max(prcWhole->top + g_cyIconSpacing,
                            yLabel + cyLabel + g_cyLabelSpace);
        }

    if (prcLabel)
        {
        prcLabel->left = pptInOut->x + ((cxIconSpacing - cxLabel) / 2);
        prcLabel->right = prcLabel->left + cxLabel;
        prcLabel->top = yLabel;
        prcLabel->bottom = prcLabel->top + cyLabel;
        }

    *pptInOut = pt;
    }


/*----------------------------------------------------------
Purpose: Set the colors for the given HDC.  The previous colors
          are stored in pcrText and pcrBk.

Returns: uStyle to pass to ImageList_Draw (specific to images only)
Cond:    --
*/
UINT PRIVATE Dobj_SetColors(
    LPDOBJ this,
    HDC hdc,
    UINT uState,
    COLORREF clrBkgnd)
    {
    COLORREF clrText;
    COLORREF clrBk;
    UINT uStyleILD = ILD_NORMAL;
    BOOL bSetColors = FALSE;
    BOOL bDiffer;
    BOOL bMenu;
    BOOL bDisabled;

    // Determine selection colors
    //
    bDiffer = IsFlagSet(this->uFlags, DOF_DIFFER);
    bMenu = IsFlagSet(this->uFlags, DOF_MENU);
    bDisabled = IsFlagSet(this->uFlags, DOF_DISABLED);

    switch (this->uKind)
        {
    case DOK_STRING:
    case DOK_IDS:
    case DOK_SIDEITEM:
        bSetColors = TRUE;
        break;
        }
    
    // Set the text and background colors
    //
    if (bSetColors)
        {
        if (bDiffer)
            {
            // Make the colors differ based on selection state
            //
            if (bMenu)
                {
                if (bDisabled)
                    clrText = GetSysColor(COLOR_GRAYTEXT);
                else
                    clrText = GetSysColor(ColorMenuText(uState));

                clrBk = GetSysColor(ColorMenuBk(uState));
                }
            else
                {
                if (bDisabled)
                    clrText = GetSysColor(COLOR_GRAYTEXT);
                else
                    clrText = GetSysColor(ColorText(uState));

                clrBk = GetSysColor(ColorBk(uState));
                }
            }
        else
            {
            // Transparent colors
            //
            if (bMenu)
                {
                if (bDisabled)
                    clrText = GetSysColor(COLOR_GRAYTEXT);
                else
                    clrText = GetSysColor(COLOR_MENUTEXT);

                clrBk = GetSysColor(COLOR_MENU);
                }
            else
                {
                if (bDisabled)
                    clrText = GetSysColor(COLOR_GRAYTEXT);
                else
                    clrText = GetSysColor(COLOR_WINDOWTEXT);

                clrBk = clrBkgnd;
                }
            }
        SetTextColor(hdc, clrText);
        SetBkColor(hdc, clrBk);
        }

    return uStyleILD;
    }


/*----------------------------------------------------------
Purpose: Draw the menu image and text
Returns: --
Cond:    --
*/
void PRIVATE Dobj_DrawMenuImage(
    LPDOBJ this,
    HDC hdc,
    UINT uState,
    int cyText,
    COLORREF clrBkgnd)
    {
    UINT uStyleILD;
    UINT uFlagsETO;
    LPCSTR psz;
    char szIDS[MAXBUFLEN];
    int cch;
    HIMAGELIST himl = this->himl;
    COLORREF clrText;
    COLORREF clrBk;
    int x;
    int y;
    int cxIcon;
    RECT rc;

    if (IsFlagSet(this->uFlags, DOF_USEIDS))
        psz = SzFromIDS((UINT)this->lpvObject, szIDS, sizeof(szIDS));
    else
        psz = (LPCSTR)this->lpvObject;

    ASSERT(psz);

    cch = lstrlen(psz);
    ImageList_GetImageRect(himl, this->iImage, &rc);
    cxIcon = rc.right-rc.left;

    // Draw the text first

    uFlagsETO = ETO_OPAQUE | ETO_CLIPPED;
    x = this->rcLabel.left + g_cxMargin + cxIcon + g_cxMargin;
    y = this->rcLabel.top + ((this->rcLabel.bottom - this->rcLabel.top - cyText) / 2);

    if (IsFlagSet(this->uFlags, DOF_DISABLED) && 
        IsFlagClear(uState, ODS_SELECTED))
        {
        int imodeOld;
        COLORREF crOld;

        // For disabled menu strings (not selected), we draw the string 
        // twice.  The first is offset down and to the right and drawn 
        // in the 3D hilight color.  The second time is the disabled text
        // color in the normal offset.
        //
        crOld = SetTextColor(hdc, GetSysColor(COLOR_3DHILIGHT));
        imodeOld = SetBkMode(hdc, TRANSPARENT);
        ExtTextOut(hdc, x+1, y+1, uFlagsETO, &this->rcLabel, psz, cch, NULL);

        // Reset back to original color.  Also, turn off the opaqueness.
        //
        SetTextColor(hdc, crOld);
        uFlagsETO ^= ETO_OPAQUE;
        }

    if (IsFlagSet(this->uFlags, DOF_DISABLED))
        clrText = GetSysColor(COLOR_GRAYTEXT);
    else
        clrText = GetSysColor(ColorMenuText(uState));

    clrBk = GetSysColor(ColorMenuBk(uState));
    SetTextColor(hdc, clrText);
    SetBkColor(hdc, clrBk);

    ExtTextOut(hdc, x, y, uFlagsETO, &this->rcLabel, psz, cch, NULL);

    // Draw the image

    if (GetBkColor(hdc) == ImageList_GetBkColor(himl))
        uStyleILD = ILD_NORMAL;     // Paint quicker
    else
        uStyleILD = ILD_TRANSPARENT;

    ImageList_Draw(himl, this->iImage, hdc, this->x, this->y, uStyleILD);
    }


/*----------------------------------------------------------
Purpose: Draw the icon image and label
Returns: --
Cond:    --
*/
void PRIVATE Dobj_DrawIconImage(
    LPDOBJ this,
    HDC hdc,
    UINT uState,
    int cxEllipses,
    int cyText,
    COLORREF clrBkgnd)
    {
    UINT uStyleILD;
    UINT uFlagsMDT;
    LPCSTR psz;
    char szIDS[MAXBUFLEN];

    if (IsFlagSet(this->uFlags, DOF_USEIDS))
        psz = SzFromIDS((UINT)this->lpvObject, szIDS, sizeof(szIDS));
    else
        psz = (LPCSTR)this->lpvObject;

    ASSERT(psz);

    // Draw the image
    //
    if (IsFlagClear(this->uFlags, DOF_IGNORESEL))
        {
        uStyleILD = GetImageDrawStyle(uState);
        uFlagsMDT = IsFlagSet(uState, ODS_SELECTED) ? MDT_SELECTED : MDT_DESELECTED;
        }
    else
        {
        uStyleILD = ILD_NORMAL;
        uFlagsMDT = MDT_DESELECTED;
        ClearFlag(uState, ODS_FOCUS);
        }

    ImageList_Draw(this->himl, this->iImage, hdc, this->x, this->y, uStyleILD);

    // Draw the file label.  Wrap if it is long.

    if (this->rcLabel.bottom - this->rcLabel.top > cyText)
        uFlagsMDT |= MDT_DRAWTEXT;
    
    MyDrawText(hdc, psz, &this->rcLabel, MDT_CENTER | uFlagsMDT, cyText, 
        cxEllipses, CLR_DEFAULT, clrBkgnd);

    // (uState may have been changed above)
    if (IsFlagSet(uState, ODS_FOCUS))
        DrawFocusRect(hdc, &this->rcLabel);
    }


#ifdef UNUSED
/*----------------------------------------------------------
Purpose: Draw a picture
Returns: --
Cond:    --
*/
void PRIVATE Dobj_DrawPicture(
    LPDOBJ this,
    HDC hdc,
    UINT uState,
    UINT uDrawStyle)
    {
    HIMAGELIST himl;
    HDC hdcMem;
    HBITMAP hbmp;
    BITMAP bm;
    RECT rc;
    int iImage;
    int cx;
    int x;
    int y;

    switch (this->uKind)
        {
    case DOK_BITMAP:
        hbmp = (HBITMAP)(DWORD)this->lpvObject;
        GetObject(hbmp, sizeof(BITMAP), &bm);
        cx = this->rcSrc.right - this->rcSrc.left;
        break;

    case DOK_ICON:
        cx = 32;
        break;
        }

    // We only align horizontally
    //
    y = this->y;
    if (IsFlagSet(this->uFlags, DOF_CENTER))
        x = this->x - (cx / 2);
    else if (IsFlagSet(this->uFlags, DOF_RIGHT))
        x = this->x - cx;
    else
        x = this->x;

    // Draw the object
    //
    switch (this->uKind)
        {
    case DOK_ICON:
        // BUGBUG: we don't handle DOF_DIFFER for icons
        DrawIcon(hdc, x, y, (HICON)(DWORD)this->lpvObject);
        break;

    case DOK_BITMAP:
        hdcMem = CreateCompatibleDC(hdc);
        if (hdcMem)
            {
            SIZE size;

            SelectBitmap(hdcMem, hbmp);
    
            size.cx = this->rcSrc.right - this->rcSrc.left;
            size.cy = this->rcSrc.bottom - this->rcSrc.top;

            if (IsFlagSet(this->uFlags, DOF_MENU) && 
                IsFlagSet(this->uFlags, DOF_DISABLED) && 
                IsFlagClear(uState, ODS_SELECTED))
                {
                COLORREF crOld;
    
                // For disabled menu strings (not selected), we draw the bitmap 
                //  twice.  The first is offset down and to the right and drawn 
                //  in the 3D hilight color.  The second time is the disabled 
                //  color in the normal offset.
                //
                crOld = SetTextColor(hdc, GetSysColor(COLOR_3DHILIGHT));
                BitBlt(hdc, x+1, y+1, size.cx, size.cy, hdcMem, this->rcSrc.left, 
                    this->rcSrc.top,  SRCCOPY);
    
                // Reset back to original color.  Also, turn off the opaqueness.
                //
                SetTextColor(hdc, crOld);
                }

            BitBlt(hdc, x, y, size.cx, size.cy, hdcMem, this->rcSrc.left, this->rcSrc.top,  SRCCOPY);
            DeleteDC(hdcMem);
            }
        break;
        }
    }
#endif

/*----------------------------------------------------------
Purpose: Draw a string
Returns: --
Cond:    --
*/
void PRIVATE Dobj_DrawString(
    LPDOBJ this,
    HDC hdc,
    UINT uState,
    int cxEllipses,
    int cyText)
    {
    UINT ufAlignSav;
                                               
    ASSERT(this);

    // Prep the alignment
    //
    if (this->uFlags & (DOF_LEFT | DOF_CENTER | DOF_RIGHT))
        {
        UINT ufMode;

        ufMode = IsFlagSet(this->uFlags, DOF_CENTER) ? TA_CENTER :
                 (IsFlagSet(this->uFlags, DOF_RIGHT) ? TA_RIGHT : TA_LEFT);
        ufAlignSav = SetTextAlign(hdc, ufMode);
        }

    // Draw the string
    //
    switch (this->uKind)
        {
    case DOK_IDS:
    case DOK_STRING:
        {
        char szBuf[MAXBUFLEN];
        LPSTR lpsz;
        UINT uflag = ETO_OPAQUE;

        if (this->uKind == DOK_IDS)
            lpsz = SzFromIDS((UINT)(DWORD)this->lpvObject, szBuf, sizeof(szBuf));
        else
            lpsz = (LPSTR)this->lpvObject;

        if (!IsRectEmpty(&this->rcClip))
            uflag |= ETO_CLIPPED;
        
        if (IsFlagSet(this->uFlags, DOF_MENU) && 
            IsFlagSet(this->uFlags, DOF_DISABLED) && 
            IsFlagClear(uState, ODS_SELECTED))
            {
            int imodeOld;
            COLORREF crOld;

            // For disabled menu strings (not selected), we draw the string 
            //  twice.  The first is offset down and to the right and drawn 
            //  in the 3D hilight color.  The second time is the disabled text
            //  color in the normal offset.
            //
            crOld = SetTextColor(hdc, GetSysColor(COLOR_3DHILIGHT));
            imodeOld = SetBkMode(hdc, TRANSPARENT);
            ExtTextOut(hdc, this->x+1, this->y+1, uflag, &this->rcClip, lpsz,
                lstrlen(lpsz), NULL);

            // Reset back to original color.  Also, turn off the opaqueness.
            //
            SetTextColor(hdc, crOld);
            uflag ^= ETO_OPAQUE;
            }

        ExtTextOut(hdc, this->x, this->y, uflag, &this->rcClip, lpsz,
            lstrlen(lpsz), NULL);
        }
        break;

    case DOK_SIDEITEM:
        SideItem_Display((LPSIDEITEM)this->lpvObject, hdc, &this->rcClip, 
            cxEllipses, cyText);
        break;
        }

    // Clean up
    //
    if (this->uFlags & (DOF_LEFT | DOF_CENTER | DOF_RIGHT))
        {
        SetTextAlign(hdc, ufAlignSav);
        }
    }


/*----------------------------------------------------------
Purpose: Draw an object
Returns: --
Cond:    --
*/
void PUBLIC Dobj_Draw(
    HDC hdc,
    LPDOBJ rgdobj,
    int cItems,
    UINT uState,            // ODS_*
    int cxEllipses,
    int cyText,
    COLORREF clrBkgnd)
    {
    UINT uDrawStyle;
    LPDOBJ pdobj;
    int i;

    ASSERT(rgdobj);

    for (i = 0, pdobj = rgdobj; i < cItems; i++, pdobj++)
        {
        if (IsFlagSet(pdobj->uFlags, DOF_NODRAW))
            continue ;
    
        uDrawStyle = Dobj_SetColors(pdobj, hdc, uState, clrBkgnd);

        // Draw the object
        //
        switch (pdobj->uKind)
            {
        case DOK_IMAGE:
            if (IsFlagSet(pdobj->uFlags, DOF_MENU))
                Dobj_DrawMenuImage(pdobj, hdc, uState, cyText, clrBkgnd);
            else
                Dobj_DrawIconImage(pdobj, hdc, uState, cxEllipses, cyText, clrBkgnd);
            break;

#ifdef UNUSED
        case DOK_BITMAP:
        case DOK_ICON:
            Dobj_DrawPicture(pdobj, hdc, uState, uDrawStyle);
            break;
#endif
    
        case DOK_IDS:
        case DOK_STRING:
        case DOK_SIDEITEM:
            Dobj_DrawString(pdobj, hdc, uState, cxEllipses, cyText);
            break;
            }
        }
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\usermode\reint\extra.h ===
#ifndef __EXTRA_H__
#define __EXTRA_H__
/* hacked headers from filesync... */

#define PUBLIC          FAR PASCAL
#define CPUBLIC         FAR _cdecl
#define PRIVATE         NEAR PASCAL

#define MAXBUFLEN       260
#define MAXMSGLEN       520
#define MAXMEDLEN       64
#define MAXSHORTLEN     32

#define NULL_CHAR       '\0'

#define DPA_ERR         (-1)
#define DPA_APPEND      0x7fff

#define CRL_FLAGS       CRL_FL_DELETE_DELETED_TWINS

/* err.h */
#include "err.h"

/* port32.h */

#ifndef CSC_ON_NT
/* void Cls_OnContextMenu(HWND hwnd, HWND hwndClick, int x, int y) */
#define HANDLE_WM_CONTEXTMENU(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam)), 0L)
#endif

void InitializeAll(WPARAM wParam);

/* globals...*/
extern UINT g_uDumpFlags;          // Controls what structs get dumped

extern int g_cxIconSpacing;
extern int g_cyIconSpacing;
extern int g_cxBorder;
extern int g_cyBorder;

extern int g_cxMargin;
extern int g_cxIcon;
extern int g_cyIcon;
extern int g_cxIconMargin;
extern int g_cyIconMargin;

extern int g_cxLabelMargin;
extern int g_cyLabelSpace;

extern char const FAR c_szWinHelpFile[];

// Debugging variables
extern UINT g_uBreakFlags;         // Controls when to int 3
extern UINT g_uTraceFlags;         // Controls what trace messages are spewed
extern UINT g_uDumpFlags;          // Controls what structs get dumped


/* brfprv.h */
void    PUBLIC PathMakePresentable(LPSTR pszPath);
UINT    PUBLIC PathGetLocality(LPCSTR pszPath, LPSTR pszBuf);
LPSTR   PUBLIC PathFindNextComponentI(LPCSTR lpszPath);

// Path locality values, relative to a briefcase
//
#define PL_FALSE   0       // path is not related at all to a briefcase
#define PL_ROOT    1       // path directly references the root of a briefcase
#define PL_INSIDE  2       // path is somewhere inside a briefcase


/* comm.h */

LPSTR PUBLIC _ConstructMessageString(HINSTANCE hinst, LPCSTR pszMsg, va_list *ArgList);

BOOL PUBLIC ConstructMessage(LPSTR * ppsz, HINSTANCE hinst, LPCSTR pszMsg, ...);


// Flags for MyDrawText()
#define MDT_DRAWTEXT        0x00000001                                  
#define MDT_ELLIPSES        0x00000002                                  
#define MDT_LINK            0x00000004                                  
#define MDT_SELECTED        0x00000008                                  
#define MDT_DESELECTED      0x00000010                                  
#define MDT_DEPRESSED       0x00000020                                  
#define MDT_EXTRAMARGIN     0x00000040                                  
#define MDT_TRANSPARENT     0x00000080
#define MDT_LEFT            0x00000100
#define MDT_RIGHT           0x00000200
#define MDT_CENTER          0x00000400
#define MDT_VCENTER         0x00000800
#define MDT_CLIPPED         0x00001000

void PUBLIC MyDrawText(HDC hdc, LPCSTR pszText, RECT FAR* prc, UINT flags, int cyChar, int cxEllipses, COLORREF clrText, COLORREF clrTextBk);

void PUBLIC FileTimeToDateTimeString(LPFILETIME pft, LPSTR pszBuf, int cchBuf);

// Copies psz into *ppszBuf and (re)allocates *ppszBuf accordingly
BOOL PUBLIC GSetString(LPSTR * ppszBuf, LPCSTR psz);

// FileInfo struct that contains file time/size info
//
typedef struct _FileInfo
{
	HICON   hicon;
	FILETIME ftMod;
	DWORD   dwSize;         // size of the file
	DWORD   dwAttributes;   // attributes
	LPARAM  lParam;
	LPSTR   pszDisplayName; // points to the display name
	char    szPath[1];      
} FileInfo;

#define FIGetSize(pfi)          ((pfi)->dwSize)
#define FIGetPath(pfi)          ((pfi)->szPath)
#define FIGetDisplayName(pfi)   ((pfi)->pszDisplayName)
#define FIGetAttributes(pfi)    ((pfi)->dwAttributes)
#define FIIsFolder(pfi)         (IsFlagSet((pfi)->dwAttributes, SFGAO_FOLDER))

#ifndef REINT
// tHACK to not cause warnings in reint.c because of this def later in shdsys.h
#define SetFlag(obj, f)             do {obj |= (f);} while (0)
#define ToggleFlag(obj, f)          do {obj ^= (f);} while (0)
#define ClearFlag(obj, f)           do {obj &= ~(f);} while (0)
#define IsFlagSet(obj, f)           (BOOL)(((obj) & (f)) == (f))  
#define IsFlagClear(obj, f)         (BOOL)(((obj) & (f)) != (f))  
#endif

// Flags for FICreate
#define FIF_DEFAULT     0x0000
#define FIF_ICON        0x0001
#define FIF_DONTTOUCH   0x0002

HRESULT PUBLIC FICreate(LPCSTR pszPath, FileInfo ** ppfi, UINT uFlags);
BOOL    PUBLIC FISetPath(FileInfo ** ppfi, LPCSTR pszPathNew, UINT uFlags);
BOOL    PUBLIC FIGetInfoString(FileInfo * pfi, LPSTR pszBuf, int cchBuf);
void    PUBLIC FIFree(FileInfo * pfi);


//
// Non-shared memory allocation
//

//      void * GAlloc(DWORD cbBytes)
//          Alloc a chunk of memory, quickly, with no 64k limit on size of
//          individual objects or total object size.  Initialize to zero.
//
#define GAlloc(cbBytes)         GlobalAlloc(GPTR, cbBytes)

//      void * GReAlloc(void * pv, DWORD cbNewSize)
//          Realloc one of above.  If pv is NULL, then this function will do
//          an alloc for you.  Initializes new portion to zero.
//
#define GReAlloc(pv, cbNewSize) GlobalReAlloc(pv, cbNewSize, GMEM_MOVEABLE | GMEM_ZEROINIT)

//      void GFree(void *pv)
//          Free pv if it is nonzero.  Set pv to zero.  
//
#define GFree(pv)        do { (pv) ? GlobalFree(pv) : (void)0;  pv = NULL; } while (0)

//      DWORD GGetSize(void *pv)
//          Get the size of a block allocated by Alloc()
//
#define GGetSize(pv)            GlobalSize(pv)

//      type * GAllocType(type);                    (macro)
//          Alloc some memory the size of <type> and return pointer to <type>.
//
#define GAllocType(type)                (type *)GAlloc(sizeof(type))

//      type * GAllocArray(type, int cNum);         (macro)
//          Alloc an array of data the size of <type>.
//
#define GAllocArray(type, cNum)          (type *)GAlloc(sizeof(type) * (cNum))

//      type * GReAllocArray(type, void * pb, int cNum);
//
#define GReAllocArray(type, pb, cNum)    (type *)GReAlloc(pb, sizeof(type) * (cNum))

// Color macros
//
#define ColorText(nState)   (((nState) & ODS_SELECTED) ? COLOR_HIGHLIGHTTEXT : COLOR_WINDOWTEXT)
#define ColorBk(nState)     (((nState) & ODS_SELECTED) ? COLOR_HIGHLIGHT : COLOR_WINDOW)
#define ColorMenuText(nState)   (((nState) & ODS_SELECTED) ? COLOR_HIGHLIGHTTEXT : COLOR_MENUTEXT)
#define ColorMenuBk(nState)     (((nState) & ODS_SELECTED) ? COLOR_HIGHLIGHT : COLOR_MENU)
#define GetImageDrawStyle(nState)   (((nState) & ODS_SELECTED) ? ILD_SELECTED : ILD_NORMAL)

#define CCH_NUL                     (sizeof(TCHAR))
#define CbFromCch(cch)              ((cch)*sizeof(TCHAR))

/* strings.h */
LPSTR PUBLIC SzFromIDS (UINT ids, LPSTR pszBuf, UINT cchBuf);
#define IsSzEqual(sz1, sz2)         (BOOL)(lstrcmpi(sz1, sz2) == 0)

/* comm.h */
VOID PUBLIC SetRectFromExtent(HDC hdc, LPRECT lprc, LPCSTR lpcsz);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\usermode\reint\err.h ===
// Debugging macros
//

#define DEBUG_CASE_STRING(x)    case x: return #x

// Dump flags used in g_uDumpFlags
//
#define DF_RECLIST      0x0001
#define DF_RECITEM      0x0002
#define DF_RECNODE      0x0004
#define DF_CREATETWIN   0x0008
#define DF_ATOMS        0x0010
#define DF_CRL          0x0020
#define DF_CBS          0x0040
#define DF_CPATH        0x0080
#define DF_PATHS        0x0100
#define DF_UPDATECOUNT  0x0200
#define DF_TWINPAIR     0x0400
#define DF_FOLDERTWIN   0x0800
#define DF_CHOOSESIDE   0x1000

// Break flags used in g_uBreakFlags
//
#define BF_ONOPEN       0x0001
#define BF_ONCLOSE      0x0002
#define BF_ONRUNONCE    0x0004
#define BF_ONVALIDATE   0x0010
#define BF_ONTHREADATT  0x0100
#define BF_ONTHREADDET  0x0200
#define BF_ONPROCESSATT 0x0400
#define BF_ONPROCESSDET 0x0800

// Trace flags used in g_uTraceFlags (defined in retail on purpose)
//
#define TF_ALWAYS       0x0000
#define TF_WARNING      0x0001
#define TF_ERROR        0x0002
#define TF_GENERAL      0x0004      // Standard briefcase trace messages
#define TF_FUNC         0x0008      // Trace function calls
#define TF_CACHE        0x0010      // Cache-specific trace messages
#define TF_ATOM         0x0020      // Atom-specific trace messages

LPCSTR PUBLIC Dbg_SafeStr(LPCSTR psz);

#ifdef DEBUG

#define DEBUG_CASE_STRING(x)    case x: return #x

#define ASSERTSEG

// Use this macro to declare message text that will be placed
// in the CODE segment (useful if DS is getting full)
//
// Ex: DEBUGTEXT(szMsg, "Invalid whatever: %d");
//
#define DEBUGTEXT(sz, msg)	/* ;Internal */ \
    static const char ASSERTSEG sz[] = msg;

void PUBLIC BrfAssertFailed(LPCSTR szFile, int line);
void CPUBLIC BrfAssertMsg(BOOL f, LPCSTR pszMsg, ...);
void CPUBLIC BrfDebugMsg(UINT mask, LPCSTR pszMsg, ...);

// ASSERT(f)  -- Generate "assertion failed in line x of file.c"
//               message if f is NOT true.
//
#define ASSERT(f)                                                       \
    {                                                                   \
        DEBUGTEXT(szFile, __FILE__);                                    \
        if (!(f))                                                       \
            BrfAssertFailed(szFile, __LINE__);                          \
    }
#define ASSERT_E(f)  ASSERT(f)

// ASSERT_MSG(f, msg, args...)  -- Generate wsprintf-formatted msg w/params
//                          if f is NOT true.
//
#define ASSERT_MSG   BrfAssertMsg

// DEBUG_MSG(mask, msg, args...) - Generate wsprintf-formatted msg using
//                          specified debug mask.  System debug mask
//                          governs whether message is output.
//
#define DEBUG_MSG    BrfDebugMsg
#define TRACE_MSG    DEBUG_MSG

// VERIFYSZ(f, msg, arg)  -- Generate wsprintf-formatted msg w/ 1 param
//                          if f is NOT true 
//
#define VERIFYSZ(f, szFmt, x)   ASSERT_MSG(f, szFmt, x)


// VERIFYSZ2(f, msg, arg1, arg2)  -- Generate wsprintf-formatted msg w/ 2
//                          param if f is NOT true 
//
#define VERIFYSZ2(f, szFmt, x1, x2)   ASSERT_MSG(f, szFmt, x1, x2)



// DBG_ENTER(szFn)  -- Generates a function entry debug spew for
//                          a function 
//
#define DBG_ENTER(szFn)                  \
    TRACE_MSG(TF_FUNC, " > " szFn "()")


// DBG_ENTER_SZ(szFn, sz)  -- Generates a function entry debug spew for
//                          a function that accepts a string as one of its
//                          parameters.
//
#define DBG_ENTER_SZ(szFn, sz)                  \
    TRACE_MSG(TF_FUNC, " > " szFn "(..., \"%s\",...)", Dbg_SafeStr(sz))


// DBG_ENTER_DTOBJ(szFn, pdtobj, szBuf)  -- Generates a function entry 
//                          debug spew for a function that accepts a 
//                          string as one of its parameters.
//
#define DBG_ENTER_DTOBJ(szFn, pdtobj, szBuf) \
    TRACE_MSG(TF_FUNC, " > " szFn "(..., %s,...)", Dbg_DataObjStr(pdtobj, szBuf))


// DBG_ENTER_RIID(szFn, riid)  -- Generates a function entry debug spew for
//                          a function that accepts an riid as one of its
//                          parameters.
//
#define DBG_ENTER_RIID(szFn, riid)                  \
    TRACE_MSG(TF_FUNC, " > " szFn "(..., %s,...)", Dbg_GetRiidName(riid))


// DBG_EXIT(szFn)  -- Generates a function exit debug spew 
//
#define DBG_EXIT(szFn)                              \
        TRACE_MSG(TF_FUNC, " < " szFn "()")

// DBG_EXIT_US(szFn, us)  -- Generates a function exit debug spew for
//                          functions that return a USHORT.
//
#define DBG_EXIT_US(szFn, us)                       \
        TRACE_MSG(TF_FUNC, " < " szFn "() with %#x", (USHORT)us)

// DBG_EXIT_UL(szFn, ul)  -- Generates a function exit debug spew for
//                          functions that return a ULONG.
//
#define DBG_EXIT_UL(szFn, ul)                   \
        TRACE_MSG(TF_FUNC, " < " szFn "() with %#lx", (ULONG)ul)

// DBG_EXIT_PTR(szFn, pv)  -- Generates a function exit debug spew for
//                          functions that return a pointer.
//
#define DBG_EXIT_PTR(szFn, pv)                   \
        TRACE_MSG(TF_FUNC, " < " szFn "() with %#lx", (LPVOID)pv)

// DBG_EXIT_HRES(szFn, hres)  -- Generates a function exit debug spew for
//                          functions that return an HRESULT.
//
#define DBG_EXIT_HRES(szFn, hres)                   \
        TRACE_MSG(TF_FUNC, " < " szFn "() with %s", Dbg_GetScode(hres))


#else

#define ASSERT(f)
#define ASSERT_E(f)      (f)
#define ASSERT_MSG   1 ? (void)0 : (void)
#define DEBUG_MSG    1 ? (void)0 : (void)
#define TRACE_MSG    1 ? (void)0 : (void)

#define VERIFYSZ(f, szFmt, x)     (f)

#define DBG_ENTER(szFn)
#define DBG_ENTER_SZ(szFn, sz)
#define DBG_ENTER_DTOBJ(szFn, pdtobj, sz)
#define DBG_ENTER_RIID(szFn, riid)   

#define DBG_EXIT(szFn)                            
#define DBG_EXIT_US(szFn, us)
#define DBG_EXIT_UL(szFn, ul)
#define DBG_EXIT_PTR(szFn, ptr)                            
#define DBG_EXIT_HRES(szFn, hres)   

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\usermode\reint\list.h ===
#ifndef __LIST_H__
#define __LIST_H__

#include "shdcom.h"

typedef struct node {
	struct node *next;
	LPCOPYPARAMS lpCP;
	int iShadowStatus;
	int iFileStatus;
	unsigned int uAction;
	SHADOWINFO sSI;						// tHACK:  too BIG!!!
	WIN32_FIND_DATA sFind32Local;
	WIN32_FIND_DATA sFind32Remote;
} node;

void killList(node *);
node *
insertList(
	node 				**thisList,
	LPCOPYPARAMS 		aNode,
	LPSHADOWINFO 		lpSI,
	LPWIN32_FIND_DATA	lpFind32Local,
	LPWIN32_FIND_DATA	lpFind32Remote,
	int 				iShadowStatus,
	int 				iFileStatus,
	unsigned int 		uAction);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\usermode\reint\extra.c ===
#include "pch.h"

#ifndef CSC_ON_NT
#define MyStrChr            StrChr
#define MyPathIsUNC(lpT)    PathIsUNC(lpT)
#endif

#include "extra.h"

// System colors
COLORREF g_clrHighlightText = 0;
COLORREF g_clrHighlight = 0;
COLORREF g_clrWindowText = 0;
COLORREF g_clrWindow = 0;

HBRUSH g_hbrHighlight = 0;
HBRUSH g_hbrWindow = 0;

char const FAR c_szEllipses[] = "...";
BOOL PUBLIC PathExists(
    LPCSTR pszPath);

/*----------------------------------------------------------
Purpose: Get the system metrics we need
Returns: --
Cond:    --
*/
void PRIVATE GetMetrics(
    WPARAM wParam)      // wParam from WM_WININICHANGE
    {
    if ((wParam == 0) || (wParam == SPI_SETNONCLIENTMETRICS))
        {
        g_cxIconSpacing = GetSystemMetrics( SM_CXICONSPACING );
        g_cyIconSpacing = GetSystemMetrics( SM_CYICONSPACING );

        g_cxBorder = GetSystemMetrics(SM_CXBORDER);
        g_cyBorder = GetSystemMetrics(SM_CYBORDER);

        g_cxIcon = GetSystemMetrics(SM_CXICON);
        g_cyIcon = GetSystemMetrics(SM_CYICON);

        g_cxIconMargin = g_cxBorder * 8;
        g_cyIconMargin = g_cyBorder * 2;
        g_cyLabelSpace = g_cyIconMargin + (g_cyBorder * 2);
        g_cxLabelMargin = (g_cxBorder * 2);
        g_cxMargin = g_cxBorder * 5;
        }
    }


/*----------------------------------------------------------
Purpose: Initializes colors
Returns: --
Cond:    --
*/
void PRIVATE InitGlobalColors()
    {
    g_clrWindowText = GetSysColor(COLOR_WINDOWTEXT);
    g_clrWindow = GetSysColor(COLOR_WINDOW);
    g_clrHighlightText = GetSysColor(COLOR_HIGHLIGHTTEXT);
    g_clrHighlight = GetSysColor(COLOR_HIGHLIGHT);

    g_hbrWindow = GetSysColorBrush(COLOR_WINDOW);
    g_hbrHighlight = GetSysColorBrush(COLOR_HIGHLIGHT);
    }



/*----------------------------------------------------------
Purpose: Sets up a bunch of necessary globals

Returns: nothing.

Cond:    --
*/
void InitializeAll(WPARAM wParam)
{
	GetMetrics(wParam);      // wParam from WM_WININICHANGE
	InitGlobalColors();
}

/*----------------------------------------------------------
Purpose: Load the string (if necessary) and format the string
         properly.

Returns: A pointer to the allocated string containing the formatted
         message or
         NULL if out of memory

Cond:    --
*/
LPSTR PUBLIC _ConstructMessageString(
    HINSTANCE hinst,
    LPCSTR pszMsg,
    va_list *ArgList)
    {
    char szTemp[MAXBUFLEN];
    LPSTR pszRet;
    LPSTR pszRes;

    if (HIWORD(pszMsg))
        pszRes = (LPSTR)pszMsg;
    else if (LOWORD(pszMsg) && LoadString(hinst, LOWORD(pszMsg), szTemp, sizeof(szTemp)))
        pszRes = szTemp;
    else
        pszRes = NULL;

    if (pszRes)
        {
        if (!FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                           pszRes, 0, 0, (LPTSTR)&pszRet, 0, ArgList))
            {
            pszRet = NULL;
            }
        }
    else
        {
        // Bad parameter
        pszRet = NULL;
        }

    return pszRet;      // free with LocalFree()
    }


/*----------------------------------------------------------
Purpose: Constructs a formatted string.  The returned string
         must be freed using GFree().

Returns: TRUE on success
Cond:    --
*/
BOOL PUBLIC ConstructMessage(
    LPSTR * ppsz,
    HINSTANCE hinst,
    LPCSTR pszMsg, ...)
    {
    BOOL bRet;
    LPSTR pszRet;
    va_list ArgList;

    va_start(ArgList, pszMsg);

    pszRet = _ConstructMessageString(hinst, pszMsg, &ArgList);

    va_end(ArgList);

    *ppsz = NULL;

    if (pszRet)
        {
        bRet = GSetString(ppsz, pszRet);
        LocalFree(pszRet);
        }
    else
        bRet = FALSE;

    return bRet;
    }

#if 0
/*----------------------------------------------------------
Purpose: Gets the locality of the path, relative to any
         briefcase.  If PL_ROOT or PL_INSIDE is returned,
         pszBuf will contain the path to the root of the
         briefcase.

         This function may hit the file-system to achieve
         its goal.

         Worst case: performs 2*n GetFileAttributes, where
         n is the number of components in pszPath.

Returns: Path locality (PL_FALSE, PL_ROOT, PL_INSIDE)

Cond:    --
*/
UINT PUBLIC PathGetLocality(
    LPCSTR pszPath,
    LPSTR pszBuf)       // Buffer for root path
    {
    UINT uRet;

    ASSERT(pszPath);
    ASSERT(pszBuf);

    *pszBuf = NULL_CHAR;

    // pszPath may be:
    //  1) a path to the briefcase folder itself
    //  2) a path to a file or folder beneath the briefcase
    //  3) a path to something unrelated to a briefcase

    // We perform our search by first looking in our cache
    // of known briefcase paths (CPATH).  If we don't find
    // anything, then we proceed to iterate thru each
    // component of the path, checking for these two things:
    //
    //   1) A directory with the system attribute
    //   2) The existence of a brfcase.dat file in the directory.
    //
    uRet = CPATH_GetLocality(pszPath, pszBuf);
    if (PL_FALSE == uRet)
        {
        int cnt = 0;

        lstrcpy(pszBuf, pszPath);
        do
            {
            if (PathCheckForBriefcase(pszBuf, (DWORD)-1))
                {
                int atom;

                uRet = cnt > 0 ? PL_INSIDE : PL_ROOT;

                // Add this briefcase path to our cache
                //
                atom = Atom_Add(pszBuf);
                if (ATOM_ERR != atom)
                    CPATH_Replace(atom);

                break;      // Done
                }

            cnt++;

            } while (PathRemoveFileSpec(pszBuf));

        if (PL_FALSE == uRet)
            *pszBuf = NULL_CHAR;
        }

    return uRet;
    }
#endif

/*----------------------------------------------------------
Purpose: Convert FILETIME struct to a readable string

Returns: String
Cond:    --
*/
void PUBLIC FileTimeToDateTimeString(
    LPFILETIME pft,
    LPSTR pszBuf,
    int cchBuf)
    {
    SYSTEMTIME st;
    FILETIME ftLocal;

    FileTimeToLocalFileTime(pft, &ftLocal);
    FileTimeToSystemTime(&ftLocal, &st);
    GetDateFormatA(LOCALE_USER_DEFAULT, DATE_SHORTDATE, &st, NULL, pszBuf, cchBuf/2);
    pszBuf += lstrlen(pszBuf);
    *pszBuf++ = ' ';
    GetTimeFormatA(LOCALE_USER_DEFAULT, TIME_NOSECONDS, &st, NULL, pszBuf, cchBuf/2);
    }


/*----------------------------------------------------------
Purpose: Sees whether the entire string will fit in *prc.
         If not, compute the numbder of chars that will fit
         (including ellipses).  Returns length of string in
         *pcchDraw.

         Taken from COMMCTRL.

Returns: TRUE if the string needed ellipses
Cond:    --
*/
BOOL PRIVATE NeedsEllipses(
    HDC hdc,
    LPCSTR pszText,
    RECT * prc,
    int * pcchDraw,
    int cxEllipses)
    {
    int cchText;
    int cxRect;
    int ichMin, ichMax, ichMid;
    SIZE siz;

    cxRect = prc->right - prc->left;

    cchText = lstrlen(pszText);

    if (cchText == 0)
        {
        *pcchDraw = cchText;
        return FALSE;
        }

    GetTextExtentPoint(hdc, pszText, cchText, &siz);

    if (siz.cx <= cxRect)
        {
        *pcchDraw = cchText;
        return FALSE;
        }

    cxRect -= cxEllipses;

    // If no room for ellipses, always show first character.
    //
    ichMax = 1;
    if (cxRect > 0)
        {
        // Binary search to find character that will fit
        ichMin = 0;
        ichMax = cchText;
        while (ichMin < ichMax)
            {
            // Be sure to round up, to make sure we make progress in
            // the loop if ichMax == ichMin + 1.
            //
            ichMid = (ichMin + ichMax + 1) / 2;

            GetTextExtentPoint(hdc, &pszText[ichMin], ichMid - ichMin, &siz);

            if (siz.cx < cxRect)
                {
                ichMin = ichMid;
                cxRect -= siz.cx;
                }
            else if (siz.cx > cxRect)
                {
                ichMax = ichMid - 1;
                }
            else
                {
                // Exact match up up to ichMid: just exit.
                //
                ichMax = ichMid;
                break;
                }
            }

        // Make sure we always show at least the first character...
        //
        if (ichMax < 1)
            ichMax = 1;
        }

    *pcchDraw = ichMax;
    return TRUE;
    }


#define CCHELLIPSES     3
#define DT_LVWRAP       (DT_CENTER | DT_WORDBREAK | DT_NOPREFIX | DT_EDITCONTROL)

/*----------------------------------------------------------
Purpose: Draws text the shell's way.

         Taken from COMMCTRL.

Returns: --

Cond:    This function requires TRANSPARENT background mode
         and a properly selected font.
*/
void PUBLIC MyDrawText(
    HDC hdc,
    LPCSTR pszText,
    RECT FAR* prc,
    UINT flags,
    int cyChar,
    int cxEllipses,
    COLORREF clrText,
    COLORREF clrTextBk)
    {
    int cchText;
    COLORREF clrSave;
    COLORREF clrSaveBk;
    UINT uETOFlags = 0;
    RECT rc;
    char ach[MAX_PATH + CCHELLIPSES];

    // REVIEW: Performance idea:
    // We could cache the currently selected text color
    // so we don't have to set and restore it each time
    // when the color is the same.
    //
    if (!pszText)
        return;

    rc = *prc;

    // If needed, add in a little extra margin...
    //
    if (IsFlagSet(flags, MDT_EXTRAMARGIN))
        {
        rc.left  += g_cxLabelMargin * 3;
        rc.right -= g_cxLabelMargin * 3;
        }
    else
        {
        rc.left  += g_cxLabelMargin;
        rc.right -= g_cxLabelMargin;
        }

    if (IsFlagSet(flags, MDT_ELLIPSES) &&
        NeedsEllipses(hdc, pszText, &rc, &cchText, cxEllipses))
        {
        hmemcpy(ach, pszText, cchText);
        lstrcpy(ach + cchText, c_szEllipses);

        pszText = ach;

        // Left-justify, in case there's no room for all of ellipses
        //
        ClearFlag(flags, (MDT_RIGHT | MDT_CENTER));
        SetFlag(flags, MDT_LEFT);

        cchText += CCHELLIPSES;
        }
    else
        {
        cchText = lstrlen(pszText);
        }

    if (IsFlagSet(flags, MDT_TRANSPARENT))
        {
        clrSave = SetTextColor(hdc, 0x000000);
        }
    else
        {
        uETOFlags |= ETO_OPAQUE;

        if (IsFlagSet(flags, MDT_SELECTED))
            {
            clrSave = SetTextColor(hdc, g_clrHighlightText);
            clrSaveBk = SetBkColor(hdc, g_clrHighlight);

            if (IsFlagSet(flags, MDT_DRAWTEXT))
                {
                FillRect(hdc, prc, g_hbrHighlight);
                }
            }
        else
            {
            if (clrText == CLR_DEFAULT && clrTextBk == CLR_DEFAULT)
                {
                clrSave = SetTextColor(hdc, g_clrWindowText);
                clrSaveBk = SetBkColor(hdc, g_clrWindow);

                if (IsFlagSet(flags, MDT_DRAWTEXT | MDT_DESELECTED))
                    {
                    FillRect(hdc, prc, g_hbrWindow);
                    }
                }
            else
                {
                HBRUSH hbr;

                if (clrText == CLR_DEFAULT)
                    clrText = g_clrWindowText;

                if (clrTextBk == CLR_DEFAULT)
                    clrTextBk = g_clrWindow;

                clrSave = SetTextColor(hdc, clrText);
                clrSaveBk = SetBkColor(hdc, clrTextBk);

                if (IsFlagSet(flags, MDT_DRAWTEXT | MDT_DESELECTED))
                    {
                    hbr = CreateSolidBrush(GetNearestColor(hdc, clrTextBk));
                    if (hbr)
                        {
                        FillRect(hdc, prc, hbr);
                        DeleteObject(hbr);
                        }
                    else
                        FillRect(hdc, prc, GetStockObject(WHITE_BRUSH));
                    }
                }
            }
        }

    // If we want the item to display as if it was depressed, we will
    // offset the text rectangle down and to the left
    if (IsFlagSet(flags, MDT_DEPRESSED))
        OffsetRect(&rc, g_cxBorder, g_cyBorder);

    if (IsFlagSet(flags, MDT_DRAWTEXT))
        {
        UINT uDTFlags = DT_LVWRAP;

        if (IsFlagClear(flags, MDT_CLIPPED))
            uDTFlags |= DT_NOCLIP;

        DrawText(hdc, pszText, cchText, &rc, uDTFlags);
        }
    else
        {
        if (IsFlagClear(flags, MDT_LEFT))
            {
            SIZE siz;

            GetTextExtentPoint(hdc, pszText, cchText, &siz);

            if (IsFlagSet(flags, MDT_CENTER))
                rc.left = (rc.left + rc.right - siz.cx) / 2;
            else
                {
                ASSERT(IsFlagSet(flags, MDT_RIGHT));
                rc.left = rc.right - siz.cx;
                }
            }

        if (IsFlagSet(flags, MDT_VCENTER))
            {
            // Center vertically
            rc.top += (rc.bottom - rc.top - cyChar) / 2;
            }

        if (IsFlagSet(flags, MDT_CLIPPED))
            uETOFlags |= ETO_CLIPPED;

        ExtTextOut(hdc, rc.left, rc.top, uETOFlags, prc, pszText, cchText, NULL);
        }

    if (flags & (MDT_SELECTED | MDT_DESELECTED | MDT_TRANSPARENT))
        {
        SetTextColor(hdc, clrSave);
        if (IsFlagClear(flags, MDT_TRANSPARENT))
            SetBkColor(hdc, clrSaveBk);
        }
    }


//---------------------------------------------------------------------------
// Given a pointer to a point in a path - return a ptr the start of the
// next path component. Path components are delimted by slashes or the
// null at the end.
// There's special handling for UNC names.
// This returns NULL if you pass in a pointer to a NULL ie if you're about
// to go off the end of the  path.
LPSTR PUBLIC PathFindNextComponentI(LPCSTR lpszPath)
{
    LPSTR lpszLastSlash;

    // Are we at the end of a path.
    if (!*lpszPath)
    {
        // Yep, quit.
        return NULL;
    }
    // Find the next slash.
    // REVIEW UNDONE - can slashes be quoted?
    lpszLastSlash = MyStrChr(lpszPath, '\\');
    // Is there a slash?
    if (!lpszLastSlash)
    {
        // No - Return a ptr to the NULL.
        return (LPSTR) (lpszPath+lstrlen(lpszPath));
    }
    else
    {
        // Is it a UNC style name?
        if ('\\' == *(lpszLastSlash+1))
        {
            // Yep, skip over the second slash.
            return lpszLastSlash+2;
        }
        else
        {
            // Nope. just skip over one slash.
            return lpszLastSlash+1;
        }
    }
}

/*----------------------------------------------------------
Purpose: Convert a file spec to make it look a bit better
         if it is all upper case chars.

Returns: --
Cond:    --
*/
BOOL PRIVATE PathMakeComponentPretty(LPSTR lpPath)
{
    LPSTR lp;

    // REVIEW: INTL need to deal with lower case chars in (>127) range?

    // check for all uppercase
    for (lp = lpPath; *lp; lp = AnsiNext(lp)) {
        if ((*lp >= 'a') && (*lp <= 'z'))
            return FALSE;       // this is a LFN, dont mess with it
    }

    AnsiLower(lpPath);
    AnsiUpperBuff(lpPath, 1);
    return TRUE;        // did the conversion
}

/*----------------------------------------------------------
Purpose: Takes the path and makes it presentable.

The rules are:
If the LFN name is simply the short name (all caps),
then convert to lowercase with first letter capitalized

Returns: --
Cond:    --
*/
void PUBLIC PathMakePresentable(
										  LPSTR pszPath)
{
	LPSTR pszComp;          // pointers to begining and
	LPSTR pszEnd;           //  end of path component
	LPSTR pch;
	int cComponent = 0;
	BOOL bUNCPath;
	char ch;

	bUNCPath = MyPathIsUNC(pszPath);

	pszComp = pszPath;
	while (pszEnd = PathFindNextComponentI(pszComp))
	{
		// pszEnd may be pointing to the right of the backslash
		//  beyond the path component, so back up one
		//
		ch = *pszEnd;
		*pszEnd = 0;        // temporary null

		// pszComp points to the path component
		//
		pch = AnsiNext(pszComp);
		if (':' == *pch)
		{
			// Simply capitalize the drive-portion of the path
			//
			AnsiUpper(pszComp);
		}
		else if (bUNCPath && cComponent++ < 3)
		{
			// Network server or share name
			//      BUGBUG: handle LFN network names
			//
			AnsiUpper(pszComp);
			PathMakeComponentPretty(pszComp);
		}
		else
		{
			// Normal path component
			//
			PathMakeComponentPretty(pszComp);
		}

		*pszEnd = ch;
		pszComp = pszEnd;
	}
}

/*----------------------------------------------------------
Purpose: Get a string from the resource string table.  Returned
ptr is a ptr to static memory.  The next call to this
function will wipe out the prior contents.
Returns: Ptr to string
Cond:    --
*/
LPSTR PUBLIC SzFromIDS(
							  UINT ids,               // resource ID
							  LPSTR pszBuf,
							  UINT cchBuf)
{
	ASSERT(pszBuf);

	*pszBuf = NULL_CHAR;
	LoadString(vhinstCur, ids, pszBuf, cchBuf);
	return pszBuf;
}


/*----------------------------------------------------------
Purpose: Sets the rectangle with the bounding extent of the given string.
Returns: Rectangle
Cond:    --
*/
void PUBLIC SetRectFromExtent(
										HDC hdc,
										LPRECT lprect,
										LPCSTR lpcsz)
{
	SIZE size;

	GetTextExtentPoint(hdc, lpcsz, lstrlen(lpcsz), &size);
	SetRect(lprect, 0, 0, size.cx, size.cy);
}

/*----------------------------------------------------------
Purpose: Copies psz into *ppszBuf.  Will alloc or realloc *ppszBuf
         accordingly.

Returns: TRUE on success
Cond:    --
*/
BOOL PUBLIC GSetString(
    LPSTR * ppszBuf,
    LPCSTR psz)
    {
    BOOL bRet = FALSE;
    DWORD cb;

    ASSERT(ppszBuf);
    ASSERT(psz);

    cb = CbFromCch(lstrlen(psz)+CCH_NUL);

    if (*ppszBuf)
        {
        // Need to reallocate?
        if (cb > GGetSize(*ppszBuf))
            {
            // Yes
            LPSTR pszT = GReAlloc(*ppszBuf, cb);
            if (pszT)
                {
                *ppszBuf = pszT;
                bRet = TRUE;
                }
            }
        else
            {
            // No
            bRet = TRUE;
            }
        }
    else
        {
        *ppszBuf = (LPSTR)GAlloc(cb);
        if (*ppszBuf)
            {
            bRet = TRUE;
            }
        }

    if (bRet)
        {
        ASSERT(*ppszBuf);
        lstrcpy(*ppszBuf, psz);
        }
    return bRet;
    }

/*----------------------------------------------------------
Purpose: Gets the file info given a path.  If the path refers
         to a directory, then simply the path field is filled.

         If himl != NULL, then the function will add the file's
         image to the provided image list and set the image index
         field in the *ppfi.

Returns: standard hresult
Cond:    --
*/
HRESULT PUBLIC FICreate(
    LPCSTR pszPath,
    FileInfo ** ppfi,
    UINT uFlags)
    {
    HRESULT hres = ResultFromScode(E_OUTOFMEMORY);
    int cchPath;
    SHFILEINFO sfi;
    UINT uInfoFlags = SHGFI_DISPLAYNAME | SHGFI_ATTRIBUTES;
    DWORD dwAttr;

    ASSERT(pszPath);
    ASSERT(ppfi);

    // Get shell file info
    if (IsFlagSet(uFlags, FIF_ICON))
        uInfoFlags |= SHGFI_ICON;
    if (IsFlagSet(uFlags, FIF_DONTTOUCH))
        {
        uInfoFlags |= SHGFI_USEFILEATTRIBUTES;

        // Today, FICreate is not called for folders, so this is ifdef'd out
#ifdef SUPPORT_FOLDERS
        dwAttr = IsFlagSet(uFlags, FIF_FOLDER) ? FILE_ATTRIBUTE_DIRECTORY : 0;
#else
        dwAttr = 0;
#endif
        }
    else
        dwAttr = 0;

    if (SHGetFileInfo(pszPath, dwAttr, &sfi, sizeof(sfi), uInfoFlags))
        {
        // Allocate enough for the structure, plus buffer for the fully qualified
        // path and buffer for the display name (and extra null terminator).
        cchPath = lstrlen(pszPath);

        *ppfi = GAlloc(sizeof(FileInfo)+cchPath+1-sizeof((*ppfi)->szPath)+lstrlen(sfi.szDisplayName)+1);
        if (*ppfi)
            {
            FileInfo * pfi = *ppfi;

            pfi->pszDisplayName = pfi->szPath+cchPath+1;
            lstrcpy(pfi->pszDisplayName, sfi.szDisplayName);

            if (IsFlagSet(uFlags, FIF_ICON))
                pfi->hicon = sfi.hIcon;

            pfi->dwAttributes = sfi.dwAttributes;

            // Does the path refer to a directory?
            if (FIIsFolder(pfi))
                {
                // Yes; just fill in the path field
                lstrcpy(pfi->szPath, pszPath);
                hres = NOERROR;
                }
            else
                {
                // No; assume the file exists?
                if (IsFlagClear(uFlags, FIF_DONTTOUCH))
                    {
                    // Yes; get the time, date and size of the file
                    HANDLE hfile = CreateFile(pszPath, GENERIC_READ,
                                FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                                NULL);

                    if (hfile == INVALID_HANDLE_VALUE)
                        {
                        GFree(*ppfi);
                        hres = ResultFromScode(E_HANDLE);
                        }
                    else
                        {
                        hres = NOERROR;

                        lstrcpy(pfi->szPath, pszPath);
                        pfi->dwSize = GetFileSize(hfile, NULL);
                        GetFileTime(hfile, NULL, NULL, &pfi->ftMod);
                        CloseHandle(hfile);
                        }
                    }
                else
                    {
                    // No; use what we have
                    hres = NOERROR;
                    lstrcpy(pfi->szPath, pszPath);
                    }
                }
            }
        }
    else if (!PathExists(pszPath))
        {
        // Differentiate between out of memory and file not found
        hres = E_FAIL;
        }

    return hres;
    }

/*----------------------------------------------------------
Purpose: Set the path entry.  This can move the pfi.

Returns: FALSE on out of memory
Cond:    --
*/
BOOL PUBLIC FISetPath(
    FileInfo ** ppfi,
    LPCSTR pszPathNew,
    UINT uFlags)
    {
    ASSERT(ppfi);
    ASSERT(pszPathNew);

    FIFree(*ppfi);

    return SUCCEEDED(FICreate(pszPathNew, ppfi, uFlags));
    }

/*----------------------------------------------------------
Purpose: Free our file info struct
Returns: --
Cond:    --
*/
void PUBLIC FIFree(
    FileInfo * pfi)
    {
    if (pfi)
        {
        if (pfi->hicon)
            DestroyIcon(pfi->hicon);

        GFree(pfi);     // This macro already checks for NULL pfi condition
        }
    }

/*----------------------------------------------------------
Purpose: Returns TRUE if the file/directory exists.

Returns: see above
Cond:    --
*/
BOOL PUBLIC PathExists(
    LPCSTR pszPath)
    {
    return GetFileAttributes(pszPath) != 0xFFFFFFFF;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\usermode\reint\err.c ===
#include "pch.h"

#include "extra.h"

// Debugging variables
UINT g_uBreakFlags = 0;         // Controls when to int 3
UINT g_uTraceFlags = 0;         // Controls what trace messages are spewed
UINT g_uDumpFlags = 0;          // Controls what structs get dumped

char const FAR c_szAssertFailed[] = "BRIEFCASE  Assertion failed in %s on line %d\r\n";

/*----------------------------------------------------------
Purpose: Returns a string safe enough to print...and I don't
mean swear words.

Returns: String ptr
Cond:    --
*/
LPCSTR PUBLIC Dbg_SafeStr(LPCSTR psz)
{
	if (psz)
		return psz;
	else
		return "NULL";
}

void PUBLIC BrfAssertFailed(
    LPCSTR pszFile, 
    int line)
    {
    LPCSTR psz;
    char ach[256];
    UINT uBreakFlags;

// tHACK    ENTEREXCLUSIVE()
        {
        uBreakFlags = g_uBreakFlags;
        }
//    LEAVEEXCLUSIVE()

    // Strip off path info from filename string, if present.
    //
    for (psz = pszFile + lstrlen(pszFile); psz != pszFile; psz=AnsiPrev(pszFile, psz))
        {
#ifdef  DBCS
        if ((AnsiPrev(pszFile, psz) != (psz-2)) && *(psz - 1) == '\\')
#else
        if (*(psz - 1) == '\\')
#endif
            break;
        }
    wsprintf(ach, c_szAssertFailed, psz, line);
    OutputDebugString(ach);
    
    if (IsFlagSet(uBreakFlags, BF_ONVALIDATE))
        DebugBreak();
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\usermode\reint\exports.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    exports.c

Abstract:

    entry point and functions exported by cscdll.dll

    Contents:

Author:

    Shishir Pardikar


Environment:

    Win32 (user-mode) DLL

Revision History:

    4-4-97  created by putting all the exported functions here.

--*/

#include "pch.h"


#ifdef CSC_ON_NT
#include <winioctl.h>
#endif //CSC_ON_NT

#include "shdcom.h"
#include "shdsys.h"
#include "reint.h"
#include "utils.h"
#include "resource.h"
#include "strings.h"
// this sets flags in a couple of headers to not include some defs.
#define REINT
#include "lib3.h"


//
// Globals/Locals
//

HANDLE  vhinstCur=NULL;             // current instance
AssertData;
AssertError;

#ifndef CSC_ON_NT
extern HWND vhwndShared;
#endif

//
// Local prototypes
//



int
PASCAL
ReInt_WinMain(
    HANDLE,
    HANDLE,
    LPSTR,
    int
    );

//
// functions
//



BOOL
APIENTRY
LibMain(
    IN HANDLE hDll,
    IN DWORD dwReason,
    IN LPVOID lpReserved
    )
/*++

Routine Description:

    Entry point for the agent library.

Arguments:

    hDll - Library handle

    dwReason - PROCESS_ATTACH etc.

    lpReserved - reserved

Returns:

    TRUE if successful.

Notes:

--*/
{
    switch(dwReason){
        case DLL_PROCESS_ATTACH:
        case DLL_THREAD_ATTACH:
            if (!vhinstCur){
               vhinstCur = hDll;
            }
            if (!vhMutex){
               vhMutex = CreateMutex(NULL, FALSE, NULL);
               if (!vhMutex){
                   OutputDebugString(_TEXT("CreateMutex Failed \r\n"));
               }
           }
        break;

        case DLL_THREAD_DETACH:
            break;
        case DLL_PROCESS_DETACH:
            CleanupReintState();
           if (vhMutex)
           {
               CloseHandle(vhMutex);
           }
        break;

        default:
        break;

    } // end switch()

    return TRUE;

}


DWORD
WINAPI
MprServiceProc(
    IN LPVOID lpvParam
    )
/*++

Routine Description:


Parameters:

    lpvParam - NULL indicates start, non-NULL indicates terminate

Return Value:


Notes:



--*/
{
    if (!lpvParam){
        Assert (vhinstCur != NULL);
//        DEBUG_PRINT(("MprServiceProc: Calling ReInt_WinMain!\n"));
        ReInt_WinMain(vhinstCur, NULL, NULL, SW_SHOW);
    }
    else
    {
        if (vhwndMain)
        {
            DestroyWindow(vhwndMain);
        }
    }
   return (0L);
}


#ifndef CSC_ON_NT

VOID
WINAPI
LogonHappened(
    IN BOOL fDone
    )
/*++

Routine Description:
    Win95 specific routine. No significance for NT

Parameters:

Return Value:

Notes:

When the network comes back on, this is called by shdnp.dll
we nuke our shadowed connections, and replace them with 'true' connections
NB!!!!: this function could be called in the context of a thread other than the
reint thread.

--*/
{

    if (vhwndShared)
    {
        SendMessage(vhwndShared, WM_COMMAND, IDM_LOGON, fDone);
    
    }
}


VOID
WINAPI
LogoffHappened(
    BOOL fDone
    )
/*++

Routine Description:

    this is called by shdnp.dll during logoff sequence by shdnp
    NB!!!!: this function could be called in the context of a thread other than the
    reint thread.

Arguments:


Returns:


Notes:

--*/
{
    if (vhwndShared)
    {
        SendMessage(vhwndShared, WM_COMMAND, IDM_LOGOFF, fDone);
    
    }
}

//
// Called from Shhndl.dll to update the servers
// Pass the server ID and a parent window to own the UI.
//
int
WINAPI
Update(
    HSERVER hServer,
    HWND hwndParent
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    int iRes;
    if(hServer==(HSERVER)NULL){
        iRes=(int)SendMessage(vhwndShared, RWM_UPDATEALL, (WPARAM)hServer, (LPARAM)hwndParent);
    }
    else{
        iRes=(int)SendMessage(vhwndShared, RWM_UPDATE, (WPARAM)hServer, (LPARAM)hwndParent);
    }
    return iRes;
}


int
WINAPI
RefreshConnections(
    int  force,
    BOOL verbose
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    return (SendMessage(vhwndShared, WM_COMMAND, IDM_REFRESH_CONNECTIONS, MAKELPARAM(force, verbose)));
}


int
WINAPI
BreakConnections(
    int  force,
    BOOL verbose
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    return (SendMessage(vhwndShared, WM_COMMAND, IDM_BREAK_CONNECTIONS, MAKELPARAM(force, verbose)));
}
#else

VOID
WINAPI
LogonHappened(
    IN BOOL fDone
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
}


VOID
WINAPI
LogoffHappened(
    BOOL fDone
    )
/*++

Routine Description:

Arguments:


Returns:


Notes:

--*/
{
}

int
WINAPI
Update(
    HSERVER hServer,
    HWND hwndParent
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    return -1;
}


int
WINAPI
RefreshConnections(
    int  force,
    BOOL verbose
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    return (-1);
}


int
WINAPI
BreakConnections(
    int  force,
    BOOL verbose
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    return (-1);
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\usermode\reint\list.c ===
/*****************************************************************************
 *	This is a poor list.  Insert only of a (node *).data with no ordering.
 *	To create the list (and insert 1 item), call insertList(NULL, blah, blah...)
 */

#include "pch.h"
#include "lib3.h"
#include "list.h"

AssertData;
AssertError;

void killList(node *thisList)
{
	node *currRoot=thisList,*last;

	while(currRoot) {
		last = currRoot;
		currRoot = currRoot->next;
		FreeCopyParams(last->lpCP);
		GlobalFree(last);
	}
}

/*
	insert a node.  Small bug: if mem alloc fails for CopyParams, the list will
	have 1 extra fluff node at the end.
*/
node *
insertList(
	node 				**thisList,
	LPCOPYPARAMS 		aNode,
	LPSHADOWINFO 		lpSI,
	LPWIN32_FIND_DATA	lpFind32Local,
	LPWIN32_FIND_DATA	lpFind32Remote,
	int 				iShadowStatus,
	int 				iFileStatus,
	unsigned int 		uAction)
{
	node *startItem = *thisList;
	node *currItem = startItem;

	if(startItem) {
		while(currItem->next)
			currItem = currItem->next;
		if(!(currItem->next = (node *) GlobalAlloc(GPTR,sizeof(node))))
			return NULL;
		currItem = currItem->next;
	} else {
		if(!(startItem = (node *) GlobalAlloc(GPTR,sizeof(node))))
			return NULL;
		currItem = startItem;
		*thisList = currItem;
	}

	if(!(currItem->lpCP = LpAllocCopyParams())) {
		GlobalFree(currItem);
		return 0;
	}
	currItem->lpCP->hShare = aNode->hShare;
	currItem->lpCP->hDir = aNode->hDir;
	currItem->lpCP->hShadow = aNode->hShadow;
	lstrcpy(currItem->lpCP->lpLocalPath, aNode->lpLocalPath);
	lstrcpy(currItem->lpCP->lpSharePath, aNode->lpSharePath);
	lstrcpy(currItem->lpCP->lpRemotePath, aNode->lpRemotePath);
	currItem->iShadowStatus = iShadowStatus;
	currItem->iFileStatus = iFileStatus;
	currItem->uAction = uAction;
	memcpy(&(currItem->sSI), lpSI, sizeof(SHADOWINFO));
	currItem->sSI.lpFind32 = NULL;

	memcpy(&(currItem->sFind32Local), lpFind32Local, sizeof(WIN32_FIND_DATA));

	if (lpFind32Remote)
	{
        Assert(sizeof(currItem->sFind32Remote) == sizeof(*lpFind32Remote));

        currItem->sFind32Remote = *lpFind32Remote;

	}
	else
	{
		memset(&(currItem->sFind32Remote), 0, sizeof(currItem->sFind32Remote));
	}

	currItem->next = (node *) NULL;
	return startItem;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\usermode\reint\merge.c ===
#include "pch.h"

#include "extra.h"
#include "resource.h"
#include "recact.h"
#include "list.h"
#include "merge.h"
#include "lib3.h"
#include "utils.h"

//
AssertData;
AssertError;
//

//
extern HANDLE vhinstCur;				// current instance (from reint.c)

typedef struct tagINFO
{
	HWND	hwnd;						// dialog handle.
	node	*mergeList;				// list of files to query
} INFO, FAR * PINFO;

BOOL APIENTRY NewDlg_DlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

/* externs needed */
BOOL GetWin32Info(LPSTR lpFile, LPWIN32_FIND_DATA lpFW32);


char vszLocalCopy[] = "Local Database";
/****************************************************************************
 *	Caller entrypoint for merge conflicts dialog.
 */
int doMergeDialog(HWND hWnd, node *aList)
{
	int nRet=-1;
	INFO sInfo;
	static inited=FALSE;
	node *currItem=aList;

    // There is a chance that the view window may be closed before we put up UI
    // in this case, we abort any merging that we thought may have gone on.
    if( !IsWindow(hWnd) )
    {
        DEBUG_PRINT(("Merge: hwnd is no longer active\n"));
        return -1;
    }

	sInfo.mergeList = aList;

	DEBUG_PRINT(("attempt to open dialog\n"));
	if(!inited)
	{
		RecAct_Init(vhinstCur);
		InitCommonControls();
		InitializeAll(0);		// bogus param, but same as in FileSync...
		inited = TRUE;
	}
	nRet = DialogBoxParam(vhinstCur, MAKEINTRESOURCE(IDD_MERGE_LIST), hWnd, NewDlg_DlgProc, (LPARAM) &sInfo);
	DEBUG_PRINT(("return = %d (0x%08x)\n", nRet, nRet));

	while(currItem)
	{
		char szBigBuf[2*MAX_PATH];

		if(currItem->iFileStatus == SI_NOEXIST)
		{
			strcpy(szBigBuf, currItem->lpCP->lpServerPath);
			strcat(szBigBuf, currItem->lpCP->lpRemotePath);
			DeleteFile(szBigBuf);
			DEBUG_PRINT(("temp file <%s> deleted\n", szBigBuf));
		}
		currItem= currItem->next;
	}

	//	RecAct_Term(vhinstCur);
    return(nRet);
}

/****************************************************************************
 *	dialog stuff
 */

BOOL NEAR PASCAL NewDlg_OnInitDialog(
    PINFO this,
    HWND hwndFocus,
    LPARAM lParam)
{
	int currCount=0;
	RA_ITEM item;
	node *currItem=this->mergeList;
	char szBigBuf[2*MAX_PATH];
	char *szTemp;

	DEBUG_PRINT(("Merge:OnInitDialog\n"));

	while(currItem)
	{
		// insert each item into the list...
		item.mask = RAIF_ALL;					// One of RAIF_
		item.iItem = currCount++;
		item.uStyle=RAIS_CANMERGE;				// One of RAIS_
		item.uAction=currItem->uAction;		// One of RAIA_

		item.pszName = currItem->sFind32Local.cFileName;

        if (currItem->sFind32Local.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            item.uStyle = RAIS_FOLDER;
		memcpy(&item.siInside.fs.ftMod,&currItem->sFind32Local.ftLastWriteTime, sizeof(FILETIME));
		item.siInside.fs.dwcbHighLength = currItem->sFind32Local.nFileSizeHigh;
		item.siInside.fs.dwcbLowLength = currItem->sFind32Local.nFileSizeLow;
		item.siInside.pszDir=vszLocalCopy;
		item.siInside.fs.fscond = FS_COND_EXISTS;
		item.siInside.uState=currItem->iShadowStatus;

		lstrcpy(szBigBuf, currItem->lpCP->lpServerPath);
		lstrcat(szBigBuf, currItem->lpCP->lpRemotePath);
		if(currItem->iFileStatus != SI_NOEXIST)
		{
			Assert(currItem->sFind32Remote.cFileName[0]);
			memcpy(&item.siOutside.fs.ftMod, &currItem->sFind32Remote.ftLastWriteTime, sizeof(FILETIME));
			item.siOutside.fs.dwcbHighLength = currItem->sFind32Remote.nFileSizeHigh;
			item.siOutside.fs.dwcbLowLength = currItem->sFind32Remote.nFileSizeLow;
		}
		else
		{
			HANDLE fh;
			// fake up a file for a little while.
			fh = CreateFile(szBigBuf, GENERIC_READ|GENERIC_WRITE,
								 FILE_SHARE_READ|FILE_SHARE_WRITE,
								 NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
			if(fh==INVALID_HANDLE_VALUE) {
				DEBUG_PRINT(("file not created\n"));
			} else {
				DEBUG_PRINT(("temp file <%s> created\n", szBigBuf));
				CloseHandle( fh );
			}
		}
		szTemp = StrRChr(szBigBuf, szBigBuf+lstrlen(szBigBuf)-1, '\\');
		Assert(szTemp);
		*szTemp = (char) 0;
		item.siOutside.pszDir=szBigBuf;
		item.siOutside.fs.fscond = FS_COND_EXISTS;
		item.siOutside.uState=currItem->iFileStatus;

		item.lParam=(LPARAM) currItem;

		DEBUG_PRINT(("inserting <%s> <%s %s> at %d\n", item.siInside.pszDir, item.siOutside.pszDir, item.pszName, item.iItem));

		if(-1 == RecAct_InsertItem(GetDlgItem(this->hwnd, IDC_RECACTION), &item))
         {
#ifdef DEBUG
			DEBUG_PRINT(("RecAct_InsertItem failed\n"));
#endif //DEBUG
         }
		else
         {
#ifdef DEBUG
			DEBUG_PRINT(("RecAct_InsertItem done right!\n"));
#endif //DEBUG
         }
		
		currItem = currItem->next;
	}
	DEBUG_PRINT(("done list\n"));
	return TRUE;
}

/*****************************************************************************
 *	Purpose: NewDlg handle WM_COMMAND
 *	Returns: --
 *	Cond:    --
 */
VOID NEAR PASCAL NewDlg_OnCommand(
    PINFO this,
    int id,
    HWND hwndCtl,
    UINT uNotifyCode)
{
	HWND hwnd = this->hwnd;

	switch (id)
	{
		case IDOK:
			EndDialog(hwnd,TRUE);
			break;

		case IDCANCEL:
			EndDialog(hwnd,FALSE);
            break;

		default:
		    DEBUG_PRINT(("Merge:OnCommand - Unknown id %d\n",id));
			return;
	}
}

/*****************************************************************************
 *	Purpose: NewDlg handle WM_NOTIFY
 *	Returns: --
 *	Cond:    --
 */
BOOL NEAR PASCAL NewDlg_OnNotify(
    PINFO this,
    int idFrom,
    NMHDR FAR * lpnmhdr)
{
	node *currItem;
	HWND hwnd = this->hwnd;
	NM_RECACT *pnmrecact = (NM_RECACT *) lpnmhdr;

	Assert(lpnmhdr);  Assert(this);

	switch (lpnmhdr->code)
	{
		case RN_SELCHANGED:
			DEBUG_PRINT(("RN_SELCHANGED received\n"));
			return FALSE;

		case RN_ITEMCHANGED:
			if(pnmrecact->mask & RAIF_ACTION)
			{
				currItem = (node *) pnmrecact->lParam;
				Assert(currItem);
				currItem->uAction = pnmrecact->uAction;
				DEBUG_PRINT(("RN_ITEMCHANGED on %08x received and delt with\n", currItem->lpCP->hShadow));
			}
			else
				DEBUG_PRINT(("RN_ITEMCHANGED: no RAIF_ACTION\n"));
			break;

		default:
			break;
	}
	return FALSE;
}

/*****************************************************************************
 *	Purpose: Handle WM_DESTROY
 *	Returns: --
 *	Cond:    --
 */
void NEAR PASCAL NewDlg_OnDestroy(PINFO this)
{
}

/*****************************************************************************
 *	Purpose: random
 *	Returns: mush
 *	Cond:    --
 */
BOOL APIENTRY NewDlg_DlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
	PINFO this;

	this = (PINFO)GetWindowLong(hDlg, DWL_USER);
	if(!this)
		if(message == WM_INITDIALOG)
		{
			// lparam = the pinfo we need.  Allocated from above.
			this = (PINFO) lParam;
			this->hwnd = hDlg;
			SetWindowLong(hDlg, DWL_USER, (LONG) lParam);
		}
		else
			return FALSE;  // ignore everthing until we get an initdialog

	switch (message)
	{
		HANDLE_MSG(this, WM_INITDIALOG, NewDlg_OnInitDialog);
		HANDLE_MSG(this, WM_COMMAND, NewDlg_OnCommand);
		HANDLE_MSG(this, WM_NOTIFY, NewDlg_OnNotify);
		HANDLE_MSG(this, WM_DESTROY, NewDlg_OnDestroy);
		default:
			return FALSE;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\usermode\reint\pch.c ===
#include "pch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\usermode\reint\merge.h ===
int doMergeDialog(HWND hWnd, node *aList);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\usermode\reint\pch.h ===
//--------------------------------------------------------------
// common user interface routines
//
//
//--------------------------------------------------------------


#ifdef CSC_ON_NT

#ifndef DEFINED_UNICODE
#define _UNICODE
#define UNICODE
#define DEFINED_UNICODE
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#undef ASSERT
#else
#define STRICT
#endif

#define NOWINDOWSX
#define NOSHELLDEBUG
#define DONT_WANT_SHELLDEBUG
#define USE_MONIKER

#define _INC_OLE				// WIN32

#include <tchar.h>
#include <windows.h>
#include <windowsx.h>

#include <shellapi.h>		// for registration functions
#include "port32.h"

#define NO_COMMCTRL_DA
#define NO_COMMCTRL_ALLOCFCNS
#define NO_COMMCTRL_STRFCNS
// the DebugMsg is here because we want OUR Assert, not their stub.
#define DebugMsg    1 ? (void)0 : (void)                                        /* ;Internal */
#include <commctrl.h>

#ifdef CSC_ON_NT
#include <comctrlp.h>
#endif

#include <ole2.h>				// object binding
#include <shlobj.h>			// IContextMenu
#include <shlwapi.h>

#include <stdlib.h>
#include <string.h>			// for string macros
#include <limits.h>			// implementation dependent values
#include <memory.h>

#include <synceng.h>			// Twin Engine include file
#include <cscapi.h>

#ifdef CSC_ON_NT
#ifndef DBG
#define DBG 0
#endif
#if DBG
#define DEBUG
#else
//if we don't do this DEBUG is defined in shdsys.h....sigh
#define NONDEBUG
#endif
#endif //ifdef CSC_ON_NT

/* globals */
extern HANDLE vhinstCur;				// current instance

#include "assert.h"
// Dont link - just do it.
#pragma intrinsic(memcpy,memcmp,memset,strcpy,strlen,strcmp,strcat)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\usermode\reint\reintinc.h ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\usermode\reint\ntstuff.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ntstuff.c

Abstract:

    entry point and functions exported by cscdll.dll which are specific for nt

    Contents:

Author:

    Shishir Pardikar


Environment:

    Win32 (user-mode) DLL

Revision History:

    11-5-97  created

--*/

#include "pch.h"


#ifdef CSC_ON_NT

#include <winioctl.h>
#include <winwlx.h>
#endif

#include "shdcom.h"
#include "shdsys.h"
#include "reint.h"
#include "utils.h"
#include "resource.h"
#include "strings.h"
// this sets flags in a couple of headers to not include some defs.
#define REINT
#include "lib3.h"

#ifdef CSC_ON_NT

#include "ntioapi.h"
#include "npapi.h"
#include "ntddnfs.h"
#include "dfsfsctl.h"
#define MAX_LOGONS  64

#define FLAG_AGENT_SEC_LOCAL_SYSTEM 0x00000001

typedef struct tagAGENT_SEC AGENT_SEC, *LPAGENT_SEC;

typedef struct tagAGENT_SEC {
    LPAGENT_SEC             lpASNext;    // next in the list !ACHTUNG, this must be the first element
    DWORD                   dwFlags;
    HANDLE                  hDupToken;         // thread token
    ULONG                   ulPrincipalID;      // ID of this principal in the CSC database
    LUID                    luidAuthId;     // auth ID to disambiguate between tokens with the same SID
    TOKEN_USER              sTokenUser;
}
AGENT_SEC, *LPAGENT_SEC;

//
// Globals/Locals
//
#define REG_VALUE_DISABLE_AGENT L"DisableAgent"
#define REG_VALUE_INACTIVE_AGENT L"InactiveAgent"
#define NT_PREFIX_FOR_UNC   L"\\??\\UNC"

#define SHUTDOWN_SLEEP_INTERVAL_MS  (1000)
#define SHUTDOWN_WAIT_INTERVAL_MS   (60*1000)

BOOL    fAgentThreadRunning = FALSE;    // agent is running

LPAGENT_SEC vlpASHead = NULL;     // head of the security info list for all logged on users

DWORD   rgdwCSCSecIndx[MAX_LOGONS];
DWORD   dwLogonCount = 0;

HDESK   hdesktopUser = NULL;    // set at every logon logon, reset at every logon
HDESK   hdesktopCur = NULL;     // set while reporting events, reset at logoff

_TCHAR  vszNTLANMAN[] = _TEXT("ntlanman.dll");

static UNICODE_STRING DfsDriverObjectName =
{
    sizeof(DFS_DRIVER_NAME) - sizeof(UNICODE_NULL),
    sizeof(DFS_DRIVER_NAME) - sizeof(UNICODE_NULL),
    DFS_DRIVER_NAME
};


AssertData;
AssertError;


//
// prototypes
//

BOOL
OkToLaunchAgent(
    VOID
);


BOOL
AttachAuthInfoForThread(
    HANDLE  hTokenInput
    );

BOOL
ReleaseAuthInfoForThread(
    HANDLE  hTokenInput
    );


BOOL
ImpersonateALoggedOnUser(
    VOID
    );


#ifdef __cplusplus
extern "C" {
#endif

DWORD APIENTRY
NPAddConnection3ForCSCAgent(
    HWND            hwndOwner,
    LPNETRESOURCE   lpNetResource,
    LPTSTR          pszPassword,
    LPTSTR          pszUserName,
    DWORD           dwFlags,
    BOOL            *lpfIsDfsConnect
    );

DWORD APIENTRY
NPCancelConnectionForCSCAgent (
    LPCTSTR         szName,
    BOOL            fForce );

DWORD APIENTRY
NPGetConnectionPerformance(
    LPCWSTR         lpRemoteName,
    LPNETCONNECTINFOSTRUCT lpNetConnectInfo
    );
#ifdef __cplusplus
}
#endif


DWORD
WINAPI
MprServiceProc(
    IN LPVOID lpvParam
    );
//
// functions
//

DWORD WINAPI
WinlogonStartupEvent(
    LPVOID lpParam
    )
/*++

Routine Description:

    The routine is called by winlogon when a user logs on to the system.

Arguments:

    none

Returns:

    ERROR_SUCCESS if all went well, otherwise the appropriate error code.

Notes:

    Because of the way registry is setup for cscdll.dll, winlogon will call this routine
    (and all the winlogonXXXEvent routines) on a seperate thread. We get the auth info for
    for the localsystem if necessary and attach it in our list of currently logged on users.

    NB. This solution works only for interactive logons. This is good enough for V1 of the
    product. All the "known" services that log on non-interactively do so as local-system. We
    are already keeping the auth-info for local-system. Hence this should cover all the
    pricipals running on a system.


    Once the agent runs, it runs forever till the system shuts down.

--*/
{
    BOOL bResult;

    bResult = ProcessIdToSessionId(
                GetCurrentProcessId(),
                &vdwAgentSessionId);

    ReintKdPrint(SECURITY, ("WinlogonStartupEvent\n"));

    if (!fAgentThreadRunning)
    {
        // agent is not yet running
        if (OkToLaunchAgent())
        {
            // registry doesn't disallow from launching the agent

            // let us be the localsystem.

            // let us also get the winlogon (localsystem) token
            if(AttachAuthInfoForThread(NULL))
            {
                // launch the agent
                fAgentThreadRunning = TRUE;

                // we will essentially get stuck here for ever
                MprServiceProc(NULL);

                fAgentThreadRunning = FALSE;
            }
            else
            {
                ReintKdPrint(BADERRORS, ("Couldn't get authinfo for self, error=%d\r\n", GetLastError()));
            }

        }
        else
        {
            ReintKdPrint(BADERRORS, ("Disbaling agent launch\r\n"));
        }
    }

    return ERROR_SUCCESS;
}

DWORD WINAPI
WinlogonLogonEvent(
    LPVOID lpParam
    )
/*++

Routine Description:

    The routine is called by winlogon when a user logs on to the system.

Arguments:

    none

Returns:

    ERROR_SUCCESS if all went well, otherwise the appropriate error code.

Notes:

    Because of the way registry is setup for cscdll.dll, winlogon will call this routine
    (and all the winlogonXXXEvent routines) on a seperate thread, impersonated as the
    currently logged on user. We get the auth info this guy and also for the localsystem, if
    necessary and attach it in our list of currently logged on users.

    NB. This solution works only for interactive logons. This is good enough for V1 of the
    product. All the "known" services that log on non-interactively do so as local-system. We
    are already keeping the auth-info for local-system. Hence this should cover all the
    pricipals running on a system.


    Once the agent runs, it runs forever till the system shuts down.

--*/
{
    DWORD dwError = ERROR_SUCCESS;
    PWLX_NOTIFICATION_INFO pWlx = (PWLX_NOTIFICATION_INFO)lpParam;

    ReintKdPrint(SECURITY, ("WinlogonLogonEvent\n"));
    Assert(pWlx->hToken);

    // NTRAID-455262-1/31/2000-shishirp this desktop scheme breaks for HYDRA
    EnterAgentCrit();

    if (!hdesktopUser)
    {
        if(!DuplicateHandle( GetCurrentProcess(),
                                    pWlx->hDesktop,
                                    GetCurrentProcess(),
                                    &hdesktopUser,
                                    0,
                                    FALSE,
                                    DUPLICATE_SAME_ACCESS
                                    ))
        {
            ReintKdPrint(ALWAYS, ("Failed to dup dekstop handle Error = %d \n", GetLastError()));
        }
        else
        {
            ReintKdPrint(INIT, ("dekstop handle = %x \n", hdesktopUser));
        }
    }
    
    LeaveAgentCrit();

    UpdateExclusionList();
    UpdateBandwidthConservationList();
    InitCSCUI(pWlx->hToken);

// attached to the list of logged on users
    if(AttachAuthInfoForThread(pWlx->hToken))
    {
        if (fAgentThreadRunning)
        {
        }
    }
    else
    {
        dwError = GetLastError();
        ReintKdPrint(BADERRORS, ("Failed to get Authentication Info for the thread Error %d, disbaling agent launch\r\n", dwError));
    }

    return ERROR_SUCCESS;
}



DWORD WINAPI
WinlogonLogoffEvent(
    LPVOID lpParam
    )
/*++

Routine Description:

    The routine is called by winlogon when a user logs off the system.

Arguments:


Returns:

    ERROR_SUCCESS if all went well, otherwise the appropriate error code.

Notes:

--*/
{
    PWLX_NOTIFICATION_INFO pWlx = (PWLX_NOTIFICATION_INFO)lpParam;
    BOOL    fLastLogoff = FALSE;

    ReintKdPrint(SECURITY, ("WinlogonLogoffEvent\n"));

    Assert(pWlx->hToken);
    ReleaseAuthInfoForThread(pWlx->hToken);

    // only when there is no-one in the queue or the only guy remaining is the system,
    // we declare that we are getting logged off.

    EnterAgentCrit();
    fLastLogoff = ((vlpASHead == NULL)||(vlpASHead->lpASNext == NULL));
    LeaveAgentCrit();

    if (fLastLogoff)
    {
        TerminateCSCUI();
        if (hdesktopUser)
        {
            CloseDesktop(hdesktopUser);
            hdesktopUser = NULL;
        }
    }

#if 0
    if (fAgentThreadRunning)
    {
        Assert(vhwndMain);

        PostMessage(vhwndMain, WM_QUIT, 0, 0);
    }
#endif
    ReintKdPrint(SECURITY, ("User logging off \r\n"));
    return ERROR_SUCCESS;
}



DWORD WINAPI
WinlogonScreenSaverEvent(
    LPVOID lpParam
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    ReintKdPrint(SECURITY, ("WinlogonScreenSaverEvent\n"));
    return ERROR_CALL_NOT_IMPLEMENTED;
}



DWORD WINAPI
WinlogonShutdownEvent(
    LPVOID lpParam
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    DWORD   dwStart, dwCur;

    ReintKdPrint(SECURITY, ("WinlogonShutdownEvent\n"));

    if (fAgentThreadRunning)
    {
        ReintKdPrint(MAINLOOP, ("Setting Agent Shtudown \r\n"));
        SetAgentShutDownRequest();

        dwCur = dwStart = GetTickCount();

        // hang out here for sometime to see if he shuts down
        for (;;)
        {
            if (HasAgentShutDown() || ((dwCur < dwStart)||(dwCur > (dwStart+SHUTDOWN_WAIT_INTERVAL_MS))))
            {
                break;
            }


            ReintKdPrint(ALWAYS, ("Waiting 1 second for agent to shutdown \r\n"));
            // achtung!!! we use sleep becuase at this time the system is shutting down
            Sleep(SHUTDOWN_SLEEP_INTERVAL_MS);

            dwCur = GetTickCount();

        }
    }

    ReintKdPrint(SECURITY, ("WinlogonShutdownEvent exit\n"));
    return ERROR_SUCCESS;
}



DWORD WINAPI
WinlogonLockEvent(
    LPVOID lpParam
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    ReintKdPrint(SECURITY, ("Lock \r\n"));
    return ERROR_CALL_NOT_IMPLEMENTED;
}



DWORD WINAPI
WinlogonUnlockEvent(
    LPVOID lpParam
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    ReintKdPrint(SECURITY, ("Unlock \r\n"));
    return ERROR_CALL_NOT_IMPLEMENTED;
}


DWORD WINAPI
WinlogonStartShellEvent(
    LPVOID lpParam
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    ReintKdPrint(SECURITY, ("WinlogonStartShellEvent\n"));
    UpdateExclusionList();
    UpdateBandwidthConservationList();
    return ERROR_SUCCESS;
}




BOOL
OkToLaunchAgent(
    VOID
)
/*++

Routine Description:

    A secret registry way of disabling the agent for testing purposes.

Arguments:


Returns:


Notes:

--*/
{
    DWORD dwDisposition;
    HKEY hKey = NULL;
    BOOL fLaunchAgent = TRUE;
    extern BOOL vfAgentQuiet;
#if 0
    NT_PRODUCT_TYPE productType;

    if( !RtlGetNtProductType( &productType ) ) {
        productType = NtProductWinNt;
    }

    switch ( productType ) {
    case NtProductWinNt:
        /* WORKSTATION */
        ReintKdPrint(INIT, ("Agent:CSC running workstation\r\n"));
        break;
    case NtProductLanManNt:
    case NtProductServer:
        /* SERVER */
        ReintKdPrint(INIT, ("Agent:CSC running server, disabling CSC\r\n"));
        return FALSE;
    }
#endif
    if (RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                    REG_KEY_CSC_SETTINGS,
                    0,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_READ | KEY_WRITE,
                    NULL,
                    &hKey,
                    &dwDisposition) == ERROR_SUCCESS)
    {
        // autocheck is always be done on an unclean shutdown
        if (RegQueryValueEx(hKey, REG_VALUE_DISABLE_AGENT, NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
        {
            fLaunchAgent = FALSE;
            ReintKdPrint(BADERRORS, ("Agent:CSC disabled agent launching\r\n"));
        }

        if (RegQueryValueEx(hKey, REG_VALUE_INACTIVE_AGENT, NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
        {
            vfAgentQuiet = TRUE;
            ReintKdPrint(BADERRORS, ("Agent:CSC agent made inactive\r\n"));
        }

    }
    if(hKey)
    {
        RegCloseKey(hKey);
    }
    return fLaunchAgent;
}


//
// Security stuff
//

BOOL
AttachAuthInfoForThread(
    HANDLE  hTokenInput
    )
/*++

Routine Description:

    This routine is called when we get a logon notification from winlogon. We get this
    notification on a thread that is impersonating the user that has logged on.
    The routine creates an AGENT_SEC structure for this logged on user. We keep enough
    information so that the CSC agent thread can impersonate any of the logged on users.

    The agent thread does this in order to make sure that while filling incomplete files
    it is impersonating a logged on user, who has read access on the file to be filled.
    That way, sparse fills will not generate audits on the server side.

Arguments:

    None

Returns:

    TRUE if successful

Notes:
    We keep AuthenticationID as SIDs are not enough to identify the logged on user because in
    case of HYDRA, the same user could get logged in multiple times
    The AuthenticationID is guaranteed to be unique for each logon even though the SID is
    the same

--*/
{
    LPAGENT_SEC lpAS = NULL;
    BOOL    fRet = FALSE;
    HANDLE  hDupToken=NULL, hToken=NULL;
    DWORD   dwSidAndAttributeSize = 0, dwDummy;
    TOKEN_STATISTICS sStats;
    DWORD   dwError;


    if (hTokenInput)
    {
        ReintKdPrint(SECURITY, ("Opening thread token \r\n"));

        hToken = hTokenInput;
        fRet = TRUE;
#if 0
        fRet = OpenThreadToken(
                GetCurrentThread(),
                TOKEN_DUPLICATE|TOKEN_IMPERSONATE|TOKEN_READ,
                FALSE,
                &hToken);
#endif
    }
    else
    {
        ReintKdPrint(SECURITY, ("Opening process token \r\n"));

        fRet = OpenProcessToken(
                GetCurrentProcess(),
                TOKEN_DUPLICATE|TOKEN_IMPERSONATE|TOKEN_READ,
                &hToken);

    }
    if (fRet)
    {
        ReintKdPrint(SECURITY, ("Duplicating token \r\n"));

        if (DuplicateToken(hToken, SecurityImpersonation, &hDupToken))
        {
            ReintKdPrint(SECURITY, ("Getting AuthID for the duplicated thread token \r\n"));

            if(GetTokenInformation(
                hDupToken,
                TokenStatistics,
                (LPVOID)&sStats,
                sizeof(sStats),
                &dwSidAndAttributeSize
                ))
            {
                // make a dummy call to find out actually how big a buffer we need

                ReintKdPrint(SECURITY, ("Calling to find how much buffer SidAndAttribute needs\r\n"));

                GetTokenInformation(
                    hDupToken,
                    TokenUser,
                    (LPVOID)&dwDummy,
                    0,          // 0 byte buffer
                    &dwSidAndAttributeSize
                    );

                dwError = GetLastError();

                ReintKdPrint(SECURITY, ("Finding buffer size, error=%d\r\n", dwError));


                if (dwError == ERROR_INSUFFICIENT_BUFFER)
                {
                    ReintKdPrint(SECURITY, ("SidAndAttribute needs %d bytes\r\n", dwSidAndAttributeSize));

                    // allocate enough for everything and a little extra
                    lpAS = (LPAGENT_SEC)LocalAlloc(LPTR, sizeof(AGENT_SEC) + dwSidAndAttributeSize + sizeof(SID_AND_ATTRIBUTES));

                    if (lpAS)
                    {
                        ReintKdPrint(SECURITY, ("Getting SidAndAttribute for the duplicated thread token \r\n"));

                        if(GetTokenInformation(
                            hDupToken,
                            TokenUser,
                            (LPVOID)&(lpAS->sTokenUser),
                            dwSidAndAttributeSize,
                            &dwSidAndAttributeSize
                        ))
                        {

                            ReintKdPrint(SECURITY, ("Success !!!!\r\n"));

                            // all is well, fill up the info
                            lpAS->luidAuthId = sStats.AuthenticationId;
                            lpAS->hDupToken = hDupToken;
                            lpAS->ulPrincipalID = CSC_INVALID_PRINCIPAL_ID;

                            if (!hTokenInput)
                            {
                                lpAS->dwFlags |= FLAG_AGENT_SEC_LOCAL_SYSTEM;
                            }

                            fRet = TRUE;

                            EnterAgentCrit();

                            lpAS->lpASNext = vlpASHead;
                            vlpASHead = lpAS;

                            LeaveAgentCrit();
                        }
                        else
                        {
                            ReintKdPrint(BADERRORS, ("Failed to get SidIndex from the database \r\n"));
                        }

                        if (!fRet)
                        {
                            LocalFree(lpAS);
                            lpAS = NULL;
                        }
                    }
                }
            }
        }
        if (!hTokenInput)
        {
            CloseHandle(hToken);
        }
        hToken = NULL;
    }

    if (!fRet)
    {
        ReintKdPrint(BADERRORS, ("AttachAuthInfoForThread Error %d\r\n", GetLastError()));

    }
    return fRet;
}

BOOL
ReleaseAuthInfoForThread(
    HANDLE  hThreadToken
    )
/*++

Routine Description:

    This routine is called when we get a logoff notification for winlogon. We look at
    the current threads to token to get the AuthenticationId for the currently logged on user.
    We check our structures to find the one that matches with the AuthId. We remove that
    from the list.


Arguments:

    None

Returns:

    TRUE if successfull

Notes:

    We do this based on AuthenticationID rather than the SID because in case of HYDRA, the same
    user could get logged in multiple times, so he has the same SID, but the AuthenticationID is
    guaranteed to be unique

--*/
{
    BOOL    fRet = FALSE;
    DWORD   dwSidAndAttributeSize = 0;
    TOKEN_STATISTICS sStats;
    LPAGENT_SEC *lplpAS, lpAST;

    ReintKdPrint(SECURITY, ("ReleaseAuthInfoForThread: Getting AuthID for the thread token \r\n"));

    if(GetTokenInformation(
            hThreadToken,
            TokenStatistics,
            (LPVOID)&sStats,
            sizeof(sStats),
            &dwSidAndAttributeSize
            ))
    {
        ReintKdPrint(SECURITY, ("ReleaseAuthInfoForThread: looking for the right thread\r\n"));

        EnterAgentCrit();

        for (lplpAS = &vlpASHead; *lplpAS; lplpAS = &((*lplpAS)->lpASNext))
        {
            if (!memcmp(&((*lplpAS)->luidAuthId), &(sStats.AuthenticationId), sizeof(LUID)))
            {
                CloseHandle((*lplpAS)->hDupToken);

                lpAST = *lplpAS;

                *lplpAS = lpAST->lpASNext;

                LocalFree(lpAST);

                fRet = TRUE;

                ReintKdPrint(SECURITY, ("ReleaseAuthInfoForThread: found him and released\r\n"));

                break;
            }
        }

        LeaveAgentCrit();
    }


    return fRet;
}

BOOL
SetAgentThreadImpersonation(
    HSHADOW hDir,
    HSHADOW hShadow,
    BOOL    fWrite
    )
/*++

Routine Description:

    This routine checks with the database, for the given inode, any of the logged on
    users have the desired access. If such a user is found, it impersonates that user.

Arguments:

    hDir        Parent Inode of the file being accessed

    hShadow     Inode of the file being accessed

    fWrite      whether to check for write access, or read access is sufficient

Returns:

    TRUE if successfull

Notes:



--*/
{
    SECURITYINFO    rgsSecurityInfo[CSC_MAXIMUM_NUMBER_OF_CACHED_PRINCIPAL_IDS];
    DWORD   dwSize;
    LPAGENT_SEC lpAS;
    int i;

    // for now juts impersonate the logged on user
    if (vlpASHead)
    {
        dwSize = sizeof(rgsSecurityInfo);

        if (GetSecurityInfoForCSC(INVALID_HANDLE_VALUE, hDir, hShadow, rgsSecurityInfo, &dwSize))
        {
            EnterAgentCrit();

            for (lpAS = vlpASHead; lpAS; lpAS = lpAS->lpASNext)
            {
                if (lpAS->ulPrincipalID == CSC_INVALID_PRINCIPAL_ID)
                {
                    if(!FindCreatePrincipalIDFromSID(INVALID_HANDLE_VALUE, lpAS->sTokenUser.User.Sid, GetLengthSid(lpAS->sTokenUser.User.Sid), &(lpAS->ulPrincipalID), TRUE))
                    {
                        ReintKdPrint(BADERRORS, ("Failed to get SidIndex from the database \r\n"));
                        continue;
                    }
                }

                Assert(lpAS->ulPrincipalID != CSC_INVALID_PRINCIPAL_ID);

                for (i=0;i<CSC_MAXIMUM_NUMBER_OF_CACHED_PRINCIPAL_IDS;++i)
                {
                    // either the indices match or this is a guest index
                    if ((rgsSecurityInfo[i].ulPrincipalID == lpAS->ulPrincipalID)||
                        (rgsSecurityInfo[i].ulPrincipalID == CSC_GUEST_PRINCIPAL_ID))
                    {
                        if (rgsSecurityInfo[i].ulPermissions & ((fWrite)?FILE_GENERIC_WRITE:FILE_GENERIC_EXECUTE))
                        {
                            goto doneChecking;
                        }
                    }
                }
            }

            lpAS = NULL;
doneChecking:
            LeaveAgentCrit();
            if (!lpAS)
            {
                ReintKdPrint(SECURITY, ("Couldn't find any user with security info\r\n", GetLastError()));
            }
            else
            {
                if (SetThreadToken(NULL, lpAS->hDupToken))
                {
                    return TRUE;
                }
                else
                {
                    ReintKdPrint(BADERRORS, ("Error %d impersonating the agent\r\n", GetLastError()));
                }
            }
        }
        else
        {
            ReintKdPrint(BADERRORS, ("Couldn't get security info for hShadow=%xh\r\n", hShadow));
        }
    }
    return (FALSE);
}

BOOL
ResetAgentThreadImpersonation(
    VOID
    )
/*++

Routine Description:

    Reverts the agent to

Arguments:

    None

Returns:

    TRUE if successfull

Notes:



--*/
{
    if(!RevertToSelf())
    {
        ReintKdPrint(BADERRORS, ("Error %d reverting to self\r\n", GetLastError()));
        return FALSE;
    }

    return TRUE;
}


BOOL
ImpersonateALoggedOnUser(
    VOID
    )
{
    LPAGENT_SEC lpAS;
    BOOL fRet = FALSE;

    EnterAgentCrit();
    for (lpAS = vlpASHead; lpAS; lpAS = lpAS->lpASNext)
    {
        if (lpAS->dwFlags & FLAG_AGENT_SEC_LOCAL_SYSTEM)
        {
            continue;
        }

        fRet = SetThreadToken(NULL, lpAS->hDupToken);
    }

    LeaveAgentCrit();

    return (fRet);
}

BOOL
GetCSCPrincipalID(
    ULONG *lpPrincipalID
    )
/*++

Routine Description:

Arguments:

    None

Returns:

    TRUE if successful

Notes:

--*/
{

    TOKEN_USER *lpTokenUser = NULL;
    BOOL    fRet = FALSE;
    HANDLE  hToken=NULL;
    DWORD   dwSidAndAttributeSize = 0, dwDummy;
    TOKEN_STATISTICS sStats;
    DWORD   dwError=ERROR_SUCCESS;
    int i;
    SECURITYINFO    rgsSecurityInfo[CSC_MAXIMUM_NUMBER_OF_CACHED_PRINCIPAL_IDS];

    *lpPrincipalID = CSC_INVALID_PRINCIPAL_ID;

    if(OpenThreadToken(GetCurrentThread(),TOKEN_QUERY,FALSE,&hToken)||
        OpenProcessToken(GetCurrentProcess(),TOKEN_QUERY,&hToken))
    {

        if(GetTokenInformation(
            hToken,
            TokenStatistics,
            (LPVOID)&sStats,
            sizeof(sStats),
            &dwSidAndAttributeSize
            ))
        {
            // make a dummy call to find out actually how big a buffer we need

            GetTokenInformation(
                hToken,
                TokenUser,
                (LPVOID)&dwDummy,
                0,          // 0 byte buffer
                &dwSidAndAttributeSize
                );

            dwError = GetLastError();


            if (dwError == ERROR_INSUFFICIENT_BUFFER)
            {
                // allocate enough for everything and a little extra
                lpTokenUser = (TOKEN_USER *)LocalAlloc(LPTR, dwSidAndAttributeSize + sizeof(SID_AND_ATTRIBUTES));

                if (lpTokenUser)
                {
                    if(GetTokenInformation(
                        hToken,
                        TokenUser,
                        (LPVOID)(lpTokenUser),
                        dwSidAndAttributeSize,
                        &dwSidAndAttributeSize
                    ))
                    {
                        if(FindCreatePrincipalIDFromSID(INVALID_HANDLE_VALUE, lpTokenUser->User.Sid, GetLengthSid(lpTokenUser->User.Sid), lpPrincipalID, FALSE))
                        {
                            fRet = TRUE;                            
                        }
                        else
                        {
                            dwError = GetLastError();
                        }
                    }
                    else
                    {
                        dwError = GetLastError();
                    }

                    LocalFree(lpTokenUser);
                }
                else
                {
                    dwError = GetLastError();
                }
            }
        }
        else
        {
            dwError = GetLastError();
        }

        CloseHandle(hToken);

        hToken = NULL;
        if (!fRet)
        {
            SetLastError(dwError);
        }
    }

    return fRet;
}

BOOL
GetCSCAccessMaskForPrincipal(
    unsigned long ulPrincipalID,
    HSHADOW hDir,
    HSHADOW hShadow,
    unsigned long *pulAccessMask
    )
{
    return GetCSCAccessMaskForPrincipalEx(ulPrincipalID, hDir, hShadow, pulAccessMask, NULL, NULL);
}

BOOL
GetCSCAccessMaskForPrincipalEx(
    unsigned long ulPrincipalID,
    HSHADOW hDir,
    HSHADOW hShadow,
    unsigned long *pulAccessMask,
    unsigned long *pulActualMaskForUser,
    unsigned long *pulActualMaskForGuest
    )
/*++

Routine Description:

Arguments:

    None

Returns:

    TRUE if successful

Notes:

--*/
{
    BOOL    fRet = FALSE;
    DWORD   dwDummy,i;
    SECURITYINFO    rgsSecurityInfo[CSC_MAXIMUM_NUMBER_OF_CACHED_PRINCIPAL_IDS];
    
    *pulAccessMask &= ~FLAG_CSC_ACCESS_MASK;

    if (pulActualMaskForUser)
    {
        *pulActualMaskForUser = 0;
    }

    if (pulActualMaskForGuest)
    {
        *pulActualMaskForGuest = 0;
    }

    if (ulPrincipalID == CSC_INVALID_PRINCIPAL_ID)
    {
        DbgPrint("Invalid Principal ID !! \n");
        return TRUE;
    }

    dwDummy = sizeof(rgsSecurityInfo);
    if (GetSecurityInfoForCSC(INVALID_HANDLE_VALUE, hDir, hShadow, rgsSecurityInfo, &dwDummy))
    {
        
        // ulPrincipalID can be a guest 

        for (i=0;i<CSC_MAXIMUM_NUMBER_OF_CACHED_PRINCIPAL_IDS;++i)
        {
            unsigned long ulCur, ulPermissions;
            
            ulCur = rgsSecurityInfo[i].ulPrincipalID;
            ulPermissions = 0;          

            if (ulCur != CSC_INVALID_PRINCIPAL_ID)
            {
                
                // first get the bitmask
                if (rgsSecurityInfo[i].ulPermissions & FILE_GENERIC_WRITE)
                {
                    ulPermissions |= FLAG_CSC_WRITE_ACCESS;
                }
                if (rgsSecurityInfo[i].ulPermissions & FILE_GENERIC_EXECUTE)
                {
                    ulPermissions |= FLAG_CSC_READ_ACCESS;
                }

                // now shift and OR it in appropriate place
                if ((ulCur == ulPrincipalID)&&(ulCur != CSC_GUEST_PRINCIPAL_ID))
                {
                    *pulAccessMask |= (ulPermissions << FLAG_CSC_USER_ACCESS_SHIFT_COUNT);

                    if (pulActualMaskForUser)
                    {
                        *pulActualMaskForUser = rgsSecurityInfo[i].ulPermissions;
                    }
                }
                else if (ulCur == CSC_GUEST_PRINCIPAL_ID)
                {
                    *pulAccessMask |= (ulPermissions << FLAG_CSC_GUEST_ACCESS_SHIFT_COUNT);
                    if (pulActualMaskForGuest)
                    {
                        *pulActualMaskForGuest = rgsSecurityInfo[i].ulPermissions;
                    }
                }
                else
                {
                    *pulAccessMask |= (ulPermissions << FLAG_CSC_OTHER_ACCESS_SHIFT_COUNT);                                
                }
            }
        }

        fRet = TRUE;
    }
    return fRet;
}

BOOL
CheckCSCAccessForThread(
    HSHADOW hDir,
    HSHADOW hShadow,
    BOOL    fWrite
    )
/*++

Routine Description:

Arguments:

    None

Returns:

    TRUE if successful

Notes:

--*/
{
    TOKEN_USER *lpTokenUser = NULL;
    BOOL    fRet = FALSE;
    HANDLE  hToken=NULL;
    DWORD   dwSidAndAttributeSize = 0, dwDummy;
    TOKEN_STATISTICS sStats;
    DWORD   dwError=ERROR_SUCCESS;
    int i;
    SECURITYINFO    rgsSecurityInfo[CSC_MAXIMUM_NUMBER_OF_CACHED_PRINCIPAL_IDS];

    if(OpenThreadToken(GetCurrentThread(),TOKEN_QUERY,FALSE,&hToken)||
        OpenProcessToken(GetCurrentProcess(),TOKEN_QUERY,&hToken))
    {

        if(GetTokenInformation(
            hToken,
            TokenStatistics,
            (LPVOID)&sStats,
            sizeof(sStats),
            &dwSidAndAttributeSize
            ))
        {
            // make a dummy call to find out actually how big a buffer we need

            GetTokenInformation(
                hToken,
                TokenUser,
                (LPVOID)&dwDummy,
                0,          // 0 byte buffer
                &dwSidAndAttributeSize
                );

            dwError = GetLastError();


            if (dwError == ERROR_INSUFFICIENT_BUFFER)
            {
                // allocate enough for everything and a little extra
                lpTokenUser = (TOKEN_USER *)LocalAlloc(LPTR, dwSidAndAttributeSize + sizeof(SID_AND_ATTRIBUTES));

                if (lpTokenUser)
                {
                    if(GetTokenInformation(
                        hToken,
                        TokenUser,
                        (LPVOID)(lpTokenUser),
                        dwSidAndAttributeSize,
                        &dwSidAndAttributeSize
                    ))
                    {
                        ULONG ulPrincipalID;

                        if(FindCreatePrincipalIDFromSID(INVALID_HANDLE_VALUE, lpTokenUser->User.Sid, GetLengthSid(lpTokenUser->User.Sid), &ulPrincipalID, FALSE))
                        {
                            dwDummy = sizeof(rgsSecurityInfo);

                            if (GetSecurityInfoForCSC(INVALID_HANDLE_VALUE, hDir, hShadow, rgsSecurityInfo, &dwDummy))
                            {
                                Assert(ulPrincipalID != CSC_INVALID_PRINCIPAL_ID);

                                for (i=0;i<CSC_MAXIMUM_NUMBER_OF_CACHED_PRINCIPAL_IDS;++i)
                                {
                                    // either the indices match or this is a guest index
                                    if ((rgsSecurityInfo[i].ulPrincipalID == ulPrincipalID)||
                                        (rgsSecurityInfo[i].ulPrincipalID == CSC_GUEST_PRINCIPAL_ID))
                                    {
                                        if (rgsSecurityInfo[i].ulPermissions & ((fWrite)?FILE_GENERIC_WRITE:FILE_GENERIC_EXECUTE))
                                        {
                                            fRet = TRUE;
                                            break;
                                        }

                                    }
                                }

                                if (!fRet)
                                {
                                    dwError = ERROR_ACCESS_DENIED;
                                }

                            }
                            else
                            {
                                dwError = GetLastError();
                            }

                        }
                        else
                        {
                            dwError = GetLastError();
                        }
                    }
                    else
                    {
                        dwError = GetLastError();
                    }

                    LocalFree(lpTokenUser);
                }
                else
                {
                    dwError = GetLastError();
                }
            }
        }
        else
        {
            dwError = GetLastError();
        }

        CloseHandle(hToken);
        hToken = NULL;

        if (!fRet)
        {
            SetLastError(dwError);
        }
    }

    return fRet;
}
#else   //CSC_ON_NT

BOOL
SetAgentThreadImpersonation(
    HSHADOW hDir,
    HSHADOW hShadow,
    BOOL    fWrite
    )
/*++

Routine Description:

    NOP for win9x

Arguments:

    hDir        Parent Inode of the file being accessed

    hShadow     Inode of the file being accessed

    fWrite      whether to check for write access, or read access is sufficient

Returns:

    TRUE if successfull

Notes:



--*/
{
    return (TRUE);
}

BOOL
ResetAgentThreadImpersonation(
    VOID
    )
/*++

Routine Description:

    NOP for win9x

Arguments:

    None

Returns:

    TRUE if successfull

Notes:



--*/
{
    return TRUE;
}

DWORD WINAPI
WinlogonStartupEvent(
    LPVOID lpParam
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    return ERROR_CALL_NOT_IMPLEMENTED;
}

DWORD WINAPI
WinlogonLogonEvent(
    LPVOID lpParam
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    return ERROR_CALL_NOT_IMPLEMENTED;
}



DWORD WINAPI
WinlogonLogoffEvent(
    LPVOID lpParam
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    return ERROR_CALL_NOT_IMPLEMENTED;
}



DWORD WINAPI
WinlogonScreenSaverEvent(
    LPVOID lpParam
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    return ERROR_CALL_NOT_IMPLEMENTED;
}



DWORD WINAPI
WinlogonShutdownEvent(
    LPVOID lpParam
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    return ERROR_CALL_NOT_IMPLEMENTED;
}



DWORD WINAPI
WinlogonLockEvent(
    LPVOID lpParam
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    return ERROR_CALL_NOT_IMPLEMENTED;
}



DWORD WINAPI
WinlogonUnlockEvent(
    LPVOID lpParam
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    return ERROR_CALL_NOT_IMPLEMENTED;
}

DWORD WINAPI
WinlogonStartShellEvent(
    LPVOID lpParam
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    return ERROR_CALL_NOT_IMPLEMENTED;
}
#endif //CSC_ON_NT


#ifdef CSC_ON_NT


DWORD
DoNetUseAddForAgent(
    IN  LPTSTR  lptzShareName,
    IN  LPTSTR  lptzUseName,
    IN  LPTSTR  lptzDomainName,
    IN  LPTSTR  lptzUserName,
    IN  LPTSTR  lptzPassword,
    IN  DWORD   dwFlags,
    OUT BOOL    *lpfIsDfsConnect
    )

{
    NETRESOURCE sNR;
    memset(&sNR, 0, sizeof(NETRESOURCE));
    sNR.dwType = RESOURCETYPE_DISK;
    sNR.lpRemoteName = lptzShareName;
    sNR.lpLocalName = lptzUseName;
//    return (NPAddConnection3(NULL, &sNR, lptzPassword, lptzUserName, 0));
    try
    {
        return (NPAddConnection3ForCSCAgent(NULL, &sNR, lptzPassword, lptzUserName, dwFlags, lpfIsDfsConnect));
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        ReintKdPrint(BADERRORS, ("Took exception in  DoNetUseAddForAgent list \n"));
        return GetLastError();
    }
}

DWORD
PRIVATE
DWConnectNet(
    _TCHAR  *lpServerPath,
    _TCHAR  *lpOutDrive,
    _TCHAR  *lpDomainName,
    _TCHAR  *lpUserName,
    _TCHAR  *lpPassword,
    DWORD   dwFlags,
    OUT BOOL    *lpfIsDfsConnect

    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    DWORD dwError;
    BOOL    fIsDfsConnect = FALSE;

    lpOutDrive[0]='E';
    lpOutDrive[1]=':';
    lpOutDrive[2]=0;
    do{
        if(lpOutDrive[0]=='Z') {
            break;
        }
        if ((dwError =
                DoNetUseAddForAgent(lpServerPath, lpOutDrive, lpDomainName, lpUserName, lpPassword, dwFlags, &fIsDfsConnect))
                ==WN_SUCCESS){
            if (lpfIsDfsConnect)
            {
                *lpfIsDfsConnect = fIsDfsConnect;
            }
            break;
        }
        else if ((dwError == WN_BAD_LOCALNAME)||
                (dwError == WN_ALREADY_CONNECTED)){
            ++lpOutDrive[0];
            continue;
        }
        else{
            break;
        }
    }
    while (TRUE);

    return (dwError);
}

DWORD DWDisconnectDriveMappedNet(
    LPTSTR  lptzDrive,
    BOOL    fForce
)
{
    Assert(lptzDrive);
    try
    {
        return NPCancelConnectionForCSCAgent(lptzDrive, fForce);
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        ReintKdPrint(BADERRORS, ("Took exception in  DWDisconnectDriveMappedNet list \n"));
        return GetLastError();
    }
}

ULONG
BaseSetLastNTError(
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This API sets the "last error value" and the "last error string"
    based on the value of Status. For status codes that don't have
    a corresponding error string, the string is set to null.

Arguments:

    Status - Supplies the status value to store as the last error value.

Return Value:

    The corresponding Win32 error code that was stored in the
    "last error value" thread variable.

--*/

{
    ULONG dwErrorCode;

    dwErrorCode = RtlNtStatusToDosError( Status );
    SetLastError( dwErrorCode );
    return( dwErrorCode );
}


BOOL
GetWin32InfoForNT(
    _TCHAR * lpFile,
    LPWIN32_FIND_DATA lpFW32
    )

/*++


Arguments:

    lpFileName - Supplies the file name of the file to find.  The file name
        may contain the DOS wild card characters '*' and '?'.


    lpFindFileData - Supplies a pointer whose type is dependent on the value
        of fInfoLevelId. This buffer returns the appropriate file data.

Return Value:

--*/

{
    HANDLE hFindFile = 0;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING FileName, *pFileName;
    UNICODE_STRING PathName;
    IO_STATUS_BLOCK IoStatusBlock;
    PFILE_BOTH_DIR_INFORMATION DirectoryInfo;
    struct SEARCH_BUFFER {
        union
        {
            FILE_BOTH_DIR_INFORMATION DirInfo;
            FILE_BASIC_INFORMATION    BasicInfo;
        };
        WCHAR Names[MAX_PATH];
    } Buffer;
    BOOLEAN TranslationStatus, fRet = FALSE;
    RTL_RELATIVE_NAME RelativeName;
    PVOID FreeBuffer = NULL;
    BOOLEAN EndsInDot;
    LPWIN32_FIND_DATAW FindFileData;
    PFILE_FULL_EA_INFORMATION EaBuffer = NULL;
    ULONG                     EaBufferSize = 0;

    FindFileData = lpFW32;

#if 0
    if (!AllocateEaBuffer(&EaBuffer, &EaBufferSize))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
#endif
    TranslationStatus = RtlDosPathNameToNtPathName_U(
                            lpFile,
                            &PathName,
                            &FileName.Buffer,
                            &RelativeName
                            );

    if ( !TranslationStatus) {
        SetLastError(ERROR_PATH_NOT_FOUND);
        goto bailout;
    }


    FreeBuffer = PathName.Buffer;

    //
    //  If there is a a file portion of this name, determine the length
    //  of the name for a subsequent call to NtQueryDirectoryFile.
    //

    if (FileName.Buffer) {
        FileName.Length =
            PathName.Length - (USHORT)((ULONG_PTR)FileName.Buffer - (ULONG_PTR)PathName.Buffer);
        PathName.Length -= (FileName.Length);
        PathName.MaximumLength -= (FileName.Length);
        pFileName = &FileName;
        FileName.MaximumLength = FileName.Length;
    } else {
        pFileName = NULL;
    }


    InitializeObjectAttributes(
        &Obja,
        &PathName,
        0,
        NULL,
        NULL
        );

    if (pFileName)
    {
        Status = NtCreateFile(
                    &hFindFile,
                    SYNCHRONIZE | FILE_LIST_DIRECTORY,
                    &Obja,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_OPEN,
                    FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                    EaBuffer,
                    EaBufferSize
                    );



        if ( !NT_SUCCESS(Status) ) {
            ReintKdPrint(ALWAYS, ("GetWin32InfoForNT Failed Status=%x\n", Status));
            BaseSetLastNTError(Status);
            goto bailout;
        }
        //
        // If there is no file part, but we are not looking at a device,
        // then bail.
        //

        DirectoryInfo = &Buffer.DirInfo;

        Status = NtQueryDirectoryFile(
                    hFindFile,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    DirectoryInfo,
                    sizeof(Buffer),
                    FileBothDirectoryInformation,
                    TRUE,
                    pFileName,
                    FALSE
                    );

        if ( !NT_SUCCESS(Status) ) {
            ReintKdPrint(ALWAYS, ("Failed Status=%x\n", Status));
            BaseSetLastNTError(Status);
            goto bailout;
        }

        //
        // Attributes are composed of the attributes returned by NT.
        //

        FindFileData->dwFileAttributes = DirectoryInfo->FileAttributes;
        FindFileData->ftCreationTime = *(LPFILETIME)&DirectoryInfo->CreationTime;
        FindFileData->ftLastAccessTime = *(LPFILETIME)&DirectoryInfo->LastAccessTime;
        FindFileData->ftLastWriteTime = *(LPFILETIME)&DirectoryInfo->LastWriteTime;
        FindFileData->nFileSizeHigh = DirectoryInfo->EndOfFile.HighPart;
        FindFileData->nFileSizeLow = DirectoryInfo->EndOfFile.LowPart;

        RtlMoveMemory( FindFileData->cFileName,
                       DirectoryInfo->FileName,
                       DirectoryInfo->FileNameLength );

        FindFileData->cFileName[DirectoryInfo->FileNameLength >> 1] = UNICODE_NULL;

        RtlMoveMemory( FindFileData->cAlternateFileName,
                       DirectoryInfo->ShortName,
                       DirectoryInfo->ShortNameLength );

        FindFileData->cAlternateFileName[DirectoryInfo->ShortNameLength >> 1] = UNICODE_NULL;

        //
        // For NTFS reparse points we return the reparse point data tag in dwReserved0.
        //

        if ( DirectoryInfo->FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT ) {
            FindFileData->dwReserved0 = DirectoryInfo->EaSize;
        }

        fRet = TRUE;
    }
    else
    {
        Status = NtOpenFile(
                    &hFindFile,
                    FILE_LIST_DIRECTORY| FILE_READ_EA | FILE_READ_ATTRIBUTES,
                    &Obja,
                    &IoStatusBlock,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_DIRECTORY_FILE
                    );

        if ( !NT_SUCCESS(Status) ) {
            ReintKdPrint(ALWAYS, ("GetWin32InfoForNT Failed Status=%x\n", Status));
            BaseSetLastNTError(Status);
            goto bailout;
        }

        Buffer.BasicInfo.FileAttributes = FILE_ATTRIBUTE_NORMAL;
        Status = NtQueryInformationFile(
                     hFindFile,
                     &IoStatusBlock,
                     (PVOID)&Buffer.BasicInfo,
                     sizeof(Buffer),
                     FileBasicInformation
                     );

        if ( !NT_SUCCESS(Status) ) {
            ReintKdPrint(ALWAYS, ("GetWin32InfoForNT Failed Status=%x\n", Status));
            BaseSetLastNTError(Status);
            goto bailout;
        }

        FindFileData->dwFileAttributes = Buffer.BasicInfo.FileAttributes;
        FindFileData->ftCreationTime = *(LPFILETIME)&Buffer.BasicInfo.CreationTime;
        FindFileData->ftLastAccessTime = *(LPFILETIME)&Buffer.BasicInfo.LastAccessTime;
        FindFileData->ftLastWriteTime = *(LPFILETIME)&Buffer.BasicInfo.LastWriteTime;
        FindFileData->nFileSizeHigh = 0;
        FindFileData->nFileSizeLow = 0;
        lstrcpy(FindFileData->cFileName, lpFile);
        FindFileData->cAlternateFileName[0] = UNICODE_NULL;
        fRet = TRUE;
    }

bailout:

    if (FreeBuffer)
    {
        RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);
    }
#if 0
    if (EaBuffer)
    {
        FreeEaBuffer(EaBuffer);
    }
#endif
    if (hFindFile)
    {
        NtClose(hFindFile);
    }

    return fRet;
}

BOOL
GetConnectionInfoForDriveBasedName(
    _TCHAR * lpName,
    LPDWORD lpdwSpeed
    )

/*++


Arguments:

    lpFileName - Supplies the file name of the file to find.  The file name
        may contain the DOS wild card characters '*' and '?'.


    lpFindFileData - Supplies a pointer whose type is dependent on the value
        of fInfoLevelId. This buffer returns the appropriate file data.

Return Value:

--*/

{
    HANDLE hFindFile = 0;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING PathName;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN TranslationStatus, fRet = FALSE;
    LMR_REQUEST_PACKET request;
    PVOID FreeBuffer = NULL;
    USHORT uBuff[4];
    LMR_CONNECTION_INFO_3 ConnectInfo;

    *lpdwSpeed = 0xffffffff;

    if (lstrlen(lpName) <2)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;        
    }

    uBuff[0] = lpName[0];
    uBuff[1] = ':';
    uBuff[2] = '\\';
    uBuff[3] = 0;

    TranslationStatus = RtlDosPathNameToNtPathName_U(
                            uBuff,
                            &PathName,
                            NULL,
                            NULL
                            );

    if ( !TranslationStatus) {
        SetLastError(ERROR_PATH_NOT_FOUND);
        goto bailout;
    }

    FreeBuffer = PathName.Buffer;

    InitializeObjectAttributes(
        &Obja,
        &PathName,
        0,
        NULL,
        NULL
        );

    Status = NtCreateFile(
                &hFindFile,
                SYNCHRONIZE | FILE_LIST_DIRECTORY,
                &Obja,
                &IoStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_OPEN,
                FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                NULL,
                0
                );

    if ( !NT_SUCCESS(Status) ) {
        ReintKdPrint(ALWAYS, ("Failed Status=%x\n", Status));
        BaseSetLastNTError(Status);
        goto bailout;
    }

    memcpy(&ConnectInfo, EA_NAME_CSCAGENT, sizeof(EA_NAME_CSCAGENT));

    Status = NtFsControlFile(
                        hFindFile,               // handle
                        NULL,                            // no event
                        NULL,                            // no APC routine
                        NULL,                            // no APC context
                        &IoStatusBlock,                  // I/O stat blk (set)
                        FSCTL_LMR_GET_CONNECTION_INFO,   // func code
                        NULL,
                        0,
                        &ConnectInfo,
                        sizeof(ConnectInfo));



    if ( !NT_SUCCESS(Status) ) {
        ReintKdPrint(ALWAYS, ("Failed Status=%x\n", Status));
        BaseSetLastNTError(Status);
        goto bailout;
    }

    *lpdwSpeed = ConnectInfo.Throughput * 8 / 100;
    


    fRet = TRUE;

bailout:

    if (FreeBuffer)
    {
        RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);
    }

    if (hFindFile)
    {
        NtClose(hFindFile);
    }

    return fRet;
}

BOOL
ReportTransitionToDfs(
    _TCHAR *lptServerName,
    BOOL    fOffline,
    DWORD   cbLen
    )
/*++

Routine Description:


Parameters:

Return Value:

Notes:

--*/
{
    ULONG   DummyBytesReturned;
    BOOL    fRet=FALSE;
    HANDLE  hDFS;
    PFILE_FULL_EA_INFORMATION eaBuffer = NULL;
    ULONG eaLength = 0;
    NTSTATUS status;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatus;
    PUNICODE_STRING name;
    
    ACCESS_MASK DesiredAccess;

    if (lptServerName)
    {
        if (cbLen == 0xffffffff)
        {
            cbLen = lstrlen(lptServerName) * sizeof(_TCHAR);
        }
    }
    else
    {
        cbLen = 0;
    }

    name = &DfsDriverObjectName;

    InitializeObjectAttributes(
        &objectAttributes,
        name,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
    );

    //
    // The CSC agent goes offline, and we require that the agent be in admin
    // or system mode, to avoid a non-privileged user from causing us to go
    // offline.
    // To go back online, the check is less stringent, since the online
    // transition is more of a hint and causing an incorrect online
    // indication does not cause wrong results.
    //
    DesiredAccess = (fOffline) ? FILE_WRITE_DATA : 0;

    status = NtCreateFile(
        &hDFS,
        SYNCHRONIZE | DesiredAccess,
        &objectAttributes,
        &ioStatus,
        NULL,
        FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
        FILE_OPEN_IF,
        FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
        eaBuffer,
        eaLength
    );

    if (NT_SUCCESS(status))
    {

        status = NtFsControlFile(
            hDFS,
            NULL,           // Event,
            NULL,           // ApcRoutine,
            NULL,           // ApcContext,
            &ioStatus,
            (fOffline)?FSCTL_DFS_CSC_SERVER_OFFLINE:FSCTL_DFS_CSC_SERVER_ONLINE,
            (LPVOID)(lptServerName),
            cbLen,
            NULL,
            0);

            CloseHandle(hDFS);
        if (NT_SUCCESS(status))
        {
            fRet = TRUE;
        }
    }

    if (!fRet)
    {
        ReintKdPrint(BADERRORS, ("ReportTransitionToDfs failed, Status %x\n", status));
    }

    return fRet;    
}

BOOL
UncPathToDfsPath(
    PWCHAR UncPath,
    PWCHAR DfsPath,
    ULONG cbLen)
{
    BOOL    fRet = FALSE;
    HANDLE  hDfs;
    NTSTATUS NtStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatus;

    if (UncPath == NULL)
        goto AllDone;
    
    InitializeObjectAttributes(
        &ObjectAttributes,
        &DfsDriverObjectName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    NtStatus = NtCreateFile(
        &hDfs,
        SYNCHRONIZE,
        &ObjectAttributes,
        &IoStatus,
        NULL,
        FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
        FILE_OPEN_IF,
        FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
        NULL,
        0);

    if (NT_SUCCESS(NtStatus)) {
        NtStatus = NtFsControlFile(
            hDfs,
            NULL,           // Event,
            NULL,           // ApcRoutine,
            NULL,           // ApcContext,
            &IoStatus,
            FSCTL_DFS_GET_SERVER_NAME,
            (PVOID)UncPath,
            wcslen(UncPath) * sizeof(WCHAR),
            (PVOID)DfsPath,
            cbLen);

        CloseHandle(hDfs);

        if (NT_SUCCESS(NtStatus))
            fRet = TRUE;
    }

AllDone:
    return fRet;    
}


#else   // CSC_ON_NT is not TRUE
BOOL
GetWin32InfoForNT(
    _TCHAR * lpFile,
    LPWIN32_FIND_DATA lpFW32
    )
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}
#endif



#if 0
#ifdef CSC_ON_NT

#define ROUND_UP_COUNT(Count,Pow2) \
        ( ((Count)+(Pow2)-1) & (~((Pow2)-1)) )

#define ALIGN_WCHAR             sizeof(WCHAR)

// need to include ntxxx.h where the ea is defined
#define EA_NAME_CSCAGENT    "CscAgent"

ULONG
BaseSetLastNTError(
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This API sets the "last error value" and the "last error string"
    based on the value of Status. For status codes that don't have
    a corresponding error string, the string is set to null.

Arguments:

    Status - Supplies the status value to store as the last error value.

Return Value:

    The corresponding Win32 error code that was stored in the
    "last error value" thread variable.

--*/

{
    ULONG dwErrorCode;

    dwErrorCode = RtlNtStatusToDosError( Status );
    SetLastError( dwErrorCode );
    return( dwErrorCode );
}


BOOL
AllocateEaBuffer(
    PFILE_FULL_EA_INFORMATION   *ppEa,
    ULONG                       *pEaLength

)
{
    FILE_ALLOCATION_INFORMATION AllocationInfo;

    PFILE_FULL_EA_INFORMATION EaBuffer = NULL;
    ULONG                     EaBufferSize = 0;

    UCHAR   CscAgentEaNameSize;
    DWORD   CscAgentEaValue = 0;

    CscAgentEaNameSize = (UCHAR)ROUND_UP_COUNT(
                                   strlen(EA_NAME_CSCAGENT) +
                                   sizeof(CHAR),
                                   ALIGN_WCHAR
                                   ) - sizeof(CHAR);

    EaBufferSize += FIELD_OFFSET( FILE_FULL_EA_INFORMATION, EaName[0]) +
                    CscAgentEaNameSize + sizeof(CHAR) +
                    sizeof(CscAgentEaValue);

    EaBuffer = RtlAllocateHeap(
                   RtlProcessHeap(),
                   0,
                   EaBufferSize);

    memset(EaBuffer, 0, EaBufferSize);

    if (EaBuffer == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    strcpy((LPSTR) EaBuffer->EaName, EA_NAME_CSCAGENT);

    EaBuffer->EaNameLength = CscAgentEaNameSize;
    EaBuffer->EaValueLength = sizeof(CscAgentEaValue);

    RtlCopyMemory(
        &EaBuffer->EaName[CscAgentEaNameSize],
        &CscAgentEaValue,
        sizeof(CscAgentEaValue));

    *ppEa = EaBuffer;
    *pEaLength = EaBufferSize;
    return TRUE;
}

VOID
FreeEaBuffer(
    PFILE_FULL_EA_INFORMATION pEa
    )
{
    RtlFreeHeap(RtlProcessHeap(), 0, pEa);
}


BOOL
CreateFileForAgent(
    PHANDLE         h,
    PCWSTR          lpFileName,
    ULONG           dwDesiredAccess,
    ULONG           dwFlagsAndAttributes,
    ULONG           dwShareMode,
    ULONG           CreateDisposition,
    ULONG           CreateFlags
    )
/*++

Routine Description:

    This routine opens/creates a file/directory for "only" on the server. The redir
    triggers off of the extended attribute that is sent down to it by this call.

Arguments:

    None.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/
{
    NTSTATUS            Status;
    OBJECT_ATTRIBUTES   Obja;
    UNICODE_STRING      FileName;
    IO_STATUS_BLOCK     IoStatusBlock;
    BOOLEAN             TranslationStatus, fRet=FALSE;
    PVOID               FreeBuffer=NULL;
    RTL_RELATIVE_NAME   RelativeName;



    FILE_ALLOCATION_INFORMATION AllocationInfo;

    PFILE_FULL_EA_INFORMATION EaBuffer = NULL;
    ULONG                     EaBufferSize = 0;

    if (!AllocateEaBuffer(&EaBuffer, &EaBufferSize))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    TranslationStatus = RtlDosPathNameToNtPathName_U(
                            lpFileName,
                            &FileName,
                            NULL,
                            &RelativeName
                            );

    if ( !TranslationStatus ) {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto bailout;
    }

    FreeBuffer = FileName.Buffer;

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtCreateFile(
                h,
                (ACCESS_MASK)dwDesiredAccess | SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                &Obja,
                &IoStatusBlock,
                NULL,
                dwFlagsAndAttributes & (FILE_ATTRIBUTE_VALID_FLAGS),
                dwShareMode,
                CreateDisposition,
                CreateFlags,
                EaBuffer,
                EaBufferSize
                );

    if (Status != STATUS_SUCCESS)
    {
        Assert(fRet == FALSE);
        BaseSetLastNTError(Status);
    }
    else
    {
        fRet = TRUE;
    }
bailout:
    if (FreeBuffer)
    {
        RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);
    }
    if (EaBuffer)
    {
        FreeEaBuffer(EaBuffer);
    }

    return (fRet);
}


BOOL
AgentDeleteFile(
    PCWSTR          lpFileName,
    BOOL            fFile
    )
{
    HANDLE hFile;
    FILE_DISPOSITION_INFORMATION Disposition;
    IO_STATUS_BLOCK IoStatus;
    NTSTATUS    Status;
    BOOL    fRet = FALSE;

    if (CreateFileForAgent(
            &hFile,
            lpFileName,
           (ACCESS_MASK)DELETE | FILE_READ_ATTRIBUTES,
           FILE_ATTRIBUTE_NORMAL,
           FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
           FILE_OPEN,
           (fFile)?FILE_NON_DIRECTORY_FILE:FILE_DIRECTORY_FILE
       ))
    {
#undef  DeleteFile

        Disposition.DeleteFile = TRUE;

#define DeleteFile  DeleteFileW

        Status = NtSetInformationFile(
                     hFile,
                     &IoStatus,
                     &Disposition,
                     sizeof(Disposition),
                     FileDispositionInformation
                     );

        NtClose(hFile);

        if (Status == STATUS_SUCCESS)
        {
            fRet = TRUE;
        }
        else
        {
            Assert(fRet == FALSE);
            BaseSetLastNTError(Status);
        }
    }

    return fRet;
}


BOOL
AgentSetFileInformation(
    PCWSTR      lpFileName,
    DWORD       *lpdwFileAttributes,
    FILETIME    *lpftLastWriteTime,
    BOOL        fFile
    )
{
    NTSTATUS    Status;
    BOOL        fRet = FALSE;
    IO_STATUS_BLOCK IoStatus;
    FILE_BASIC_INFORMATION  sFileBasicInformation;
    HANDLE hFile;

    if (!CreateFileForAgent(
           &hFile,
           lpFileName,
           (ACCESS_MASK)FILE_READ_ATTRIBUTES|FILE_WRITE_ATTRIBUTES,
           FILE_ATTRIBUTE_NORMAL,
           FILE_SHARE_READ | FILE_SHARE_WRITE,
           FILE_OPEN,
           (fFile)?FILE_NON_DIRECTORY_FILE:FILE_DIRECTORY_FILE))
    {
        return FALSE;
    }

    Status = NtQueryInformationFile(
                hFile,
                &IoStatus,
                (PVOID) &sFileBasicInformation,
                sizeof(sFileBasicInformation),
                FileBasicInformation
                );
    if (Status == STATUS_SUCCESS)
    {
        if (lpdwFileAttributes)
        {
            sFileBasicInformation.FileAttributes = *lpdwFileAttributes;
        }
        if (lpftLastWriteTime)
        {
            sFileBasicInformation.LastWriteTime = *(LARGE_INTEGER *)lpftLastWriteTime;

        }

        Status = NtSetInformationFile(
                hFile,
                &IoStatus,
                (PVOID) &sFileBasicInformation,
                sizeof(sFileBasicInformation),
                FileBasicInformation
                );
    }

    NtClose(hFile);

    if (Status == STATUS_SUCCESS)
    {
        fRet = TRUE;
    }
    else
    {
        Assert(fRet == FALSE);

        BaseSetLastNTError(Status);
    }

    return fRet;
}


BOOL
AgentRenameFile(
    _TCHAR *lpFileSrc,
    _TCHAR *lpFileDst
    )
{

    HANDLE hFile;
    char    chBuff[sizeof(FILE_RENAME_INFORMATION) + (MAX_PATH+1) * sizeof(_TCHAR)];
    PFILE_RENAME_INFORMATION pFileRenameInformation;
    IO_STATUS_BLOCK IoStatus;
    NTSTATUS    Status;
    BOOL    fRet = FALSE;

    memset(chBuff, 0, sizeof(chBuff));
    pFileRenameInformation = (PFILE_RENAME_INFORMATION)chBuff;
    pFileRenameInformation->FileNameLength = lstrlen(lpFileDst) * sizeof(_TCHAR);
    if (pFileRenameInformation->FileNameLength > MAX_PATH * sizeof(_TCHAR))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    pFileRenameInformation->ReplaceIfExists = TRUE;
    memcpy(pFileRenameInformation->FileName, lpFileDst, pFileRenameInformation->FileNameLength);

    if (CreateFileForAgent(
            &hFile,
            lpFileSrc,
           (ACCESS_MASK)DELETE | FILE_READ_ATTRIBUTES,
           FILE_ATTRIBUTE_NORMAL,
           FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
           FILE_OPEN,
           FILE_NON_DIRECTORY_FILE
       ))
    {
        Status = NtSetInformationFile(
                     hFile,
                     &IoStatus,
                     pFileRenameInformation,
                     sizeof(chBuff),
                     FileRenameInformation
                     );

        NtClose(hFile);

        if (Status == STATUS_SUCCESS)
        {
            fRet = TRUE;
        }
        else
        {
            Assert(fRet == FALSE);
            BaseSetLastNTError(Status);
        }
    }

    return fRet;
}

BOOL
GetWin32Info(
    _TCHAR * lpFile,
    LPWIN32_FIND_DATA lpFW32
    )

/*++


Arguments:

    lpFileName - Supplies the file name of the file to find.  The file name
        may contain the DOS wild card characters '*' and '?'.


    lpFindFileData - Supplies a pointer whose type is dependent on the value
        of fInfoLevelId. This buffer returns the appropriate file data.

Return Value:

--*/

{
    HANDLE hFindFile = 0;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING FileName, *pFileName;
    UNICODE_STRING PathName;
    IO_STATUS_BLOCK IoStatusBlock;
    PFILE_BOTH_DIR_INFORMATION DirectoryInfo;
    struct SEARCH_BUFFER {
        FILE_BOTH_DIR_INFORMATION DirInfo;
        WCHAR Names[MAX_PATH];
    } Buffer;
    BOOLEAN TranslationStatus, fRet = FALSE;
    RTL_RELATIVE_NAME RelativeName;
    PVOID FreeBuffer = NULL;
    BOOLEAN EndsInDot;
    LPWIN32_FIND_DATAW FindFileData;
    PFILE_FULL_EA_INFORMATION EaBuffer = NULL;
    ULONG                     EaBufferSize = 0;

    FindFileData = lpFW32;

    if (!AllocateEaBuffer(&EaBuffer, &EaBufferSize))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    TranslationStatus = RtlDosPathNameToNtPathName_U(
                            lpFile,
                            &PathName,
                            &FileName.Buffer,
                            &RelativeName
                            );

    if ( !TranslationStatus) {
        SetLastError(ERROR_PATH_NOT_FOUND);
        goto bailout;
    }

    FreeBuffer = PathName.Buffer;

    //
    //  If there is a a file portion of this name, determine the length
    //  of the name for a subsequent call to NtQueryDirectoryFile.
    //

    if (FileName.Buffer) {
        FileName.Length =
            PathName.Length - (USHORT)((ULONG_PTR)FileName.Buffer - (ULONG_PTR)PathName.Buffer);
        PathName.Length -= (FileName.Length+sizeof(WCHAR));
        PathName.MaximumLength -= (FileName.Length+sizeof(WCHAR));
        pFileName = &FileName;
        FileName.MaximumLength = FileName.Length;
    } else {
        pFileName = NULL;
    }


    InitializeObjectAttributes(
        &Obja,
        &PathName,
        0,
        NULL,
        NULL
        );

    Status = NtCreateFile(
                &hFindFile,
                SYNCHRONIZE | FILE_LIST_DIRECTORY,
                &Obja,
                &IoStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_OPEN,
                FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                EaBuffer,
                EaBufferSize
                );


    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        goto bailout;
    }
    //
    // If there is no file part, but we are not looking at a device,
    // then bail.
    //

    DirectoryInfo = &Buffer.DirInfo;

    if (pFileName)
    {
        Status = NtQueryDirectoryFile(
                    hFindFile,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    DirectoryInfo,
                    sizeof(Buffer),
                    FileBothDirectoryInformation,
                    TRUE,
                    pFileName,
                    FALSE
                    );
    }
    else
    {
        Status = NtQueryInformationFile(
                    hFindFile,
                    &IoStatusBlock,
                    DirectoryInfo,
                    sizeof(Buffer),
                    FileBothDirectoryInformation,
                    );

    }

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        goto bailout;
    }

    //
    // Attributes are composed of the attributes returned by NT.
    //

    FindFileData->dwFileAttributes = DirectoryInfo->FileAttributes;
    FindFileData->ftCreationTime = *(LPFILETIME)&DirectoryInfo->CreationTime;
    FindFileData->ftLastAccessTime = *(LPFILETIME)&DirectoryInfo->LastAccessTime;
    FindFileData->ftLastWriteTime = *(LPFILETIME)&DirectoryInfo->LastWriteTime;
    FindFileData->nFileSizeHigh = DirectoryInfo->EndOfFile.HighPart;
    FindFileData->nFileSizeLow = DirectoryInfo->EndOfFile.LowPart;

    RtlMoveMemory( FindFileData->cFileName,
                   DirectoryInfo->FileName,
                   DirectoryInfo->FileNameLength );

    FindFileData->cFileName[DirectoryInfo->FileNameLength >> 1] = UNICODE_NULL;

    RtlMoveMemory( FindFileData->cAlternateFileName,
                   DirectoryInfo->ShortName,
                   DirectoryInfo->ShortNameLength );

    FindFileData->cAlternateFileName[DirectoryInfo->ShortNameLength >> 1] = UNICODE_NULL;

    //
    // For NTFS reparse points we return the reparse point data tag in dwReserved0.
    //

    if ( DirectoryInfo->FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT ) {
        FindFileData->dwReserved0 = DirectoryInfo->EaSize;
    }

    fRet = TRUE;

bailout:

    if (FreeBuffer)
    {
        RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);
    }
    if (EaBuffer)
    {
        FreeEaBuffer(EaBuffer);
    }
    if (hFindFile)
    {
        NtClose(hFindFile);
    }

    return fRet;
}


BOOL
AgentGetFileInformation(
    PCWSTR      lpFileName,
    DWORD       *lpdwFileAttributes,
    FILETIME    *lpftLastWriteTime,
    BOOL        fFile
    )
{
    NTSTATUS    Status;
    BOOL        fRet = FALSE;
    IO_STATUS_BLOCK IoStatus;
    FILE_BASIC_INFORMATION  sFileBasicInformation;
    HANDLE hFile;

    if (!CreateFileForAgent(
           &hFile,
           lpFileName,
           (ACCESS_MASK)FILE_READ_ATTRIBUTES|FILE_WRITE_ATTRIBUTES,
           FILE_ATTRIBUTE_NORMAL,
           FILE_SHARE_READ | FILE_SHARE_WRITE,
           FILE_OPEN,
           (fFile)?FILE_NON_DIRECTORY_FILE:FILE_DIRECTORY_FILE))
    {
        return FALSE;
    }

    Status = NtQueryInformationFile(
                hFile,
                &IoStatus,
                (PVOID) &sFileBasicInformation,
                sizeof(sFileBasicInformation),
                FileBasicInformation
                );
    if (Status == STATUS_SUCCESS)
    {
        if (lpdwFileAttributes)
        {
            *lpdwFileAttributes = sFileBasicInformation.FileAttributes;
        }
        if (lpftLastWriteTime)
        {
            *(LARGE_INTEGER *)lpftLastWriteTime = sFileBasicInformation.LastWriteTime;
        }
    }

    NtClose(hFile);

    if (Status == STATUS_SUCCESS)
    {
        fRet = TRUE;
    }
    else
    {
        Assert(fRet == FALSE);

        BaseSetLastNTError(Status);
    }

    return fRet;
}


DWORD
PRIVATE
DoObjectEdit(
    HANDLE              hShadowDB,
    _TCHAR *            lpDrive,
    LPCOPYPARAMS        lpCP,
    LPSHADOWINFO        lpSI,
    LPWIN32_FIND_DATA   lpFind32Local,
    LPWIN32_FIND_DATA   lpFind32Remote,
    int                 iShadowStatus,
    int                 iFileStatus,
    int                 uAction,
    LPCSCPROC           lpfnMergeProgress,
    DWORD               dwContext
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/

{
    HANDLE hfSrc = 0, hfDst = 0;
    HANDLE hDst=0;
    _TCHAR * lpT;
    LONG lOffset=0;
    DWORD dwError=ERROR_REINT_FAILED;
    WIN32_FIND_DATA    sFind32Remote;
    DWORD   dwTotal = 0, dwRet;
    _TCHAR szSrcName[MAX_PATH+MAX_SERVER_SHARE_NAME_FOR_CSC+10];
    _TCHAR szDstName[MAX_PATH+MAX_SERVER_SHARE_NAME_FOR_CSC+10];
    _TCHAR *lprwBuff = NULL;

    lprwBuff = LocalAlloc(LPTR, FILL_BUF_SIZE_LAN);

    if (!lprwBuff)
    {
        return (ERROR_NOT_ENOUGH_MEMORY);
    }
    lOffset=0;

    // Create \\server\share\foo\00010002 kind of temporary filename

    lstrcpy(szDstName, lpCP->lpServerPath);
    lstrcat(szDstName, lpCP->lpRemotePath);

    lpT = GetLeafPtr(szDstName);
    *lpT = 0;   // remove the remote leaf

    lpT = GetLeafPtr(lpCP->lpLocalPath);

    // attach the local leaf
    lstrcat(szDstName, lpT);

    // Let us also create the real name \\server\share\foo\bar
    // we will use this to issue the rename ioctl

    lstrcpy(szSrcName, lpCP->lpServerPath);
    lstrcat(szSrcName, lpCP->lpRemotePath);

    ReintKdPrint(MERGE, ("Reintegrating file %s \r\n", szSrcName));

    if (mShadowDeleted(lpSI->uStatus)){

        ReintKdPrint(MERGE, ("Deleting %s from the share\r\n", szSrcName));

        if (lpFind32Remote)
        {
            if((lpFind32Remote->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                ReintKdPrint(MERGE, ("DoObjectEdit:attribute conflict on %s \r\n", szSrcName));
                goto bailout;
            }

            if (lpFind32Remote->dwFileAttributes & FILE_ATTRIBUTE_READONLY)
            {
                DWORD   dwT = FILE_ATTRIBUTE_NORMAL;

                if(!AgentSetFileInformation(szSrcName, &dwT, NULL, TRUE))
                {
                    ReintKdPrint(BADERRORS, ("DoObjectEdit: failed setattribute before delete on %s error=%d\r\n", szSrcName, GetLastError()));
                    goto bailout;
                }
            }

            // delete a file
            if(!AgentDeleteFile(szSrcName, TRUE))
            {
                dwError = GetLastError();

                if ((dwError==ERROR_FILE_NOT_FOUND)||
                    (dwError==ERROR_PATH_NOT_FOUND)){

                    ReintKdPrint(MERGE, ("DoObjectEdit:delete failed %s benign error=%d\r\n", szSrcName, dwError));
                }
                else
                {
                    ReintKdPrint(BADERRORS, ("DoObjectEdit:delete failed %s error=%d\r\n", szSrcName, dwError));
                }

                goto bailout;
            }

        }

        ReintKdPrint(MERGE, ("Deleted %s \r\n", szSrcName));

        DeleteShadow(hShadowDB, lpSI->hDir, lpSI->hShadow);

        dwError = NO_ERROR;

        goto bailout;
    }

    if (mShadowDirty(lpSI->uStatus)
        || mShadowLocallyCreated(lpSI->uStatus)){

        ReintKdPrint(MERGE, ("Writing data for %s \r\n", szSrcName));

        hfSrc = CreateFile( lpCP->lpLocalPath,
                             GENERIC_READ,
                             FILE_SHARE_READ,
                             NULL,
                             OPEN_EXISTING,
                             0,
                             NULL);

        if (hfSrc ==  INVALID_HANDLE_VALUE)
        {
            ReintKdPrint(BADERRORS, ("DoObjectEdit:failed to open database file %s error=%d\r\n", szDstName, GetLastError()));
            goto bailout;
        }

        if (!CreateFileForAgent(
                &hfDst,
                szDstName,
                GENERIC_READ|GENERIC_WRITE,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ,
                FILE_CREATE,
                FILE_NON_DIRECTORY_FILE))
        {
            ReintKdPrint(BADERRORS, ("DoObjectEdit:failed to create new temp file %s error=%d\r\n", szDstName, GetLastError()));
            goto bailout;
        }

        // let us append
        if((lOffset = SetFilePointer(hfDst, 0, NULL, FILE_END))==0xffffffff) {
            ReintKdPrint(BADERRORS, ("DoObjectEdit:failed to set filepointer on  %s error=%d\r\n", szDstName, GetLastError()));
            goto error;
        }

        ReintKdPrint(MERGE, ("Copying back %s to %s%s \r\n"
            , lpCP->lpLocalPath
            , lpCP->lpServerPath
            , lpCP->lpRemotePath
            ));

        lpSI->uStatus &= ~SHADOW_DIRTY;
        SetShadowInfo(  hShadowDB, lpSI->hDir, lpSI->hShadow, NULL,
                        lpSI->uStatus, SHADOW_FLAGS_ASSIGN);

        do{
            unsigned cbRead;
            if (!ReadFile(hfSrc, lprwBuff, FILL_BUF_SIZE_LAN, &cbRead, NULL)){
                ReintKdPrint(BADERRORS, ("DoObjectEdit:failed to read database file %s error=%d\r\n", szDstName, GetLastError()));
                goto error;
            }

            if (!cbRead) {
                break;
            }

            if(!WriteFile(hfDst, (LPBYTE)lprwBuff, cbRead, &cbRead, NULL)){
                ReintKdPrint(BADERRORS, ("DoObjectEdit:failed to write temp file %s error=%d\r\n", szDstName, GetLastError()));
                goto error;
            }

            dwTotal += cbRead;

            if (lpfnMergeProgress)
            {
                dwRet = (*lpfnMergeProgress)(
                                szSrcName,
                                lpSI->uStatus,
                                lpSI->ulHintFlags,
                                lpSI->ulHintPri,
                                lpFind32Local,
                                CSCPROC_REASON_MORE_DATA,
                                cbRead,
                                0,
                                dwContext
                            );
                if (dwRet != CSCPROC_RETURN_CONTINUE)
                {
                    ReintKdPrint(BADERRORS, ("DoObjectEdit: Callback function cancelled the operation\r\n"));
                    SetLastError(ERROR_OPERATION_ABORTED);
                    goto bailout;
                }

            }

            if (FAbortOperation())
            {
                ReintKdPrint(BADERRORS, ("DoObjectEdit: got an abort command from the redir\r\n"));
                SetLastError(ERROR_OPERATION_ABORTED);
                goto error;
            }
        } while(TRUE);

        CloseHandle(hfSrc);
        hfSrc = 0;

        NtClose(hfDst);
        hfDst = 0;

        // nuke the remote one if it exists
        if (lpFind32Remote){
            DWORD dwT = FILE_ATTRIBUTE_NORMAL;
            if(!AgentSetFileInformation(szSrcName, &dwT, NULL, TRUE)||
                !AgentDeleteFile(szSrcName, TRUE))
            {
                ReintKdPrint(BADERRORS, ("DoObjectEdit: failed to delete file %s error=%d\r\n", szSrcName, GetLastError()));
                goto error;
            }
        }


        if(!AgentRenameFile(szDstName, szSrcName))
        {
            ReintKdPrint(BADERRORS, ("DoObjectEdit: failed to rename file %s to %s error=%d\r\n", szDstName, szSrcName, GetLastError()));
            goto bailout;
        }

    }

    if (mShadowAttribChange(lpSI->uStatus)||mShadowTimeChange(lpSI->uStatus)){

        if(!AgentSetFileInformation(szSrcName, &(lpFind32Local->dwFileAttributes), &(lpFind32Local->ftLastWriteTime), TRUE))
        {
            ReintKdPrint(BADERRORS, ("DoObjectEdit: failed to change attributes on file %s error=%d\r\n", szSrcName, GetLastError()));
            goto bailout;
        }

    }

    // Get the latest timestamps/attributes/LFN/SFN on the file we just copied back
    if (!GetWin32Info(szSrcName, &sFind32Remote)) {
        goto error;
    }

    lpSI->uStatus &= (unsigned long)(~(SHADOW_MODFLAGS));

    SetShadowInfo(hShadowDB, lpSI->hDir, lpSI->hShadow, &sFind32Remote, lpSI->uStatus, SHADOW_FLAGS_ASSIGN|SHADOW_FLAGS_CHANGE_83NAME);

    dwError = NO_ERROR;
    goto bailout;

error:

bailout:
    if (hfSrc) {
        CloseHandle(hfSrc);
    }

    if (hfDst) {

        NtClose(hfDst);

        // if we failed,
        if (dwError != ERROR_SUCCESS)
        {
            DeleteFile(szDstName);
        }
    }

    if (lprwBuff)
    {
        LocalFree(lprwBuff);
    }
    if (dwError == NO_ERROR)
    {
        ReintKdPrint(MERGE, ("Done Reintegration for file %s \r\n", szSrcName));
    }
    else
    {
        dwError = GetLastError();
        ReintKdPrint(MERGE, ("Failed Reintegration for file %s Error = %d\r\n", szSrcName, dwError));
    }

    return (dwError);
}

DWORD
PRIVATE
DoCreateDir(
    HANDLE              hShadowDB,
    _TCHAR *            lpDrive,
    LPCOPYPARAMS        lpCP,
    LPSHADOWINFO        lpSI,
    LPWIN32_FIND_DATA   lpFind32Local,
    LPWIN32_FIND_DATA   lpFind32Remote,
    int                 iShadowStatus,
    int                 iFileStatus,
    int                 uAction,
    LPCSCPROC           lpfnMergeProgress,
    DWORD               dwContext
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    DWORD dwError=ERROR_FILE_NOT_FOUND;
    WIN32_FIND_DATA sFind32Remote;
    BOOL fCreateDir = FALSE;
    _TCHAR szSrcName[MAX_PATH+MAX_SERVER_SHARE_NAME_FOR_CSC+10];
    HANDLE hFile;

    // Let us create the real name x:\foo\bar
    lstrcpy(szSrcName, lpCP->lpServerPath);
    lstrcat(szSrcName, lpCP->lpRemotePath);

    ReintKdPrint(MERGE, ("CSC.DoCreateDirectory: Reintegrating directory %s \r\n", szSrcName));

    if(lpFind32Remote &&
        !(lpFind32Remote->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)){

        if (lpSI->uStatus & SHADOW_REUSED){

            ReintKdPrint(MERGE, ("CSC.DoCreateDirectory: %s is a file on the server, attempting to delete\r\n", szSrcName));

            // we now know that a file by this name has been deleted
            // and a directory has been created in it's place
            // we try to delete the file before creating the directory
            // NB, the other way is not possible because we don't allow directory deletes
            // in disconnected mode

            if (lpFind32Remote->dwFileAttributes & FILE_ATTRIBUTE_READONLY)
            {
                DWORD   dwT = FILE_ATTRIBUTE_NORMAL;

                if(!AgentSetFileInformation(szSrcName, &dwT, NULL, TRUE))
                {
                    ReintKdPrint(BADERRORS, ("CSC.DoCreateDirectory: failed setattribute before delete on %s error=%d\r\n", szSrcName, GetLastError()));
                    goto bailout;
                }
            }

            // delete the remote file before trying to create a directory
            if(!AgentDeleteFile(szSrcName, TRUE))
            {
                dwError = GetLastError();

                if ((dwError==ERROR_FILE_NOT_FOUND)||
                    (dwError==ERROR_PATH_NOT_FOUND)){
                    ReintKdPrint(MERGE, ("DoCreateDirectory: file delete failed %s benign error=%d\r\n", szSrcName, dwError));
                }
                else
                {
                    ReintKdPrint(BADERRORS, ("DoCreateDirectory: file delete failed %s error=%d\r\n", szSrcName, dwError));
                    goto bailout;
                }
            }
        }

        if (!CreateFileForAgent(
               &hFile,
               szSrcName,
               (ACCESS_MASK)FILE_READ_ATTRIBUTES|FILE_WRITE_ATTRIBUTES,
               FILE_ATTRIBUTE_NORMAL,
               FILE_SHARE_READ | FILE_SHARE_WRITE,
               FILE_OPEN_IF,
               FILE_DIRECTORY_FILE))
        {
            ReintKdPrint(BADERRORS, ("DoCreateDirectory: failed to create %s error=%d\r\n", szSrcName, GetLastError()));
            goto bailout;
        }

        NtClose(hFile);

        if(!AgentSetFileInformation(szSrcName, &(lpFind32Local->dwFileAttributes), NULL, FALSE))
        {
            ReintKdPrint(BADERRORS, ("DoCreateDirectory: failed to set attributes on %s error=%d\r\n", szSrcName, GetLastError()));
            goto bailout;
        }

        if(!GetWin32Info(szSrcName, &sFind32Remote)){
            ReintKdPrint(BADERRORS, ("DoCreateDirectory: failed to get win32 info for %s error=%d\r\n", szSrcName, GetLastError()));
            goto bailout;
        }

        dwError = NO_ERROR;

        SetShadowInfo(hShadowDB, lpSI->hDir, lpSI->hShadow, &sFind32Remote, (unsigned)(~SHADOW_MODFLAGS), SHADOW_FLAGS_AND);
        ReintKdPrint(MERGE, ("Created directory %s%s", lpCP->lpServerPath, lpCP->lpRemotePath));
    }

bailout:

    if (dwError != NO_ERROR)
    {
        dwError = GetLastError();
        ReintKdPrint(MERGE, ("CSC.DoCreateDirectory: Failed Reintegrating directory %s Error = %d \r\n", szSrcName, dwError));
    }
    else
    {
        ReintKdPrint(MERGE, ("CSC.DoCreateDirectory: Done Reintegrating directory %s \r\n", szSrcName));
    }
    return (dwError);
}

#endif  // ifdef CSC_ON_NT
#endif  // if 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\usermode\reint\recact.h ===
//
// recact.h: Declares data, defines and struct types for RecAct
//				  module.
//
//

#ifndef __RECACT_H__
#define __RECACT_H__


/////////////////////////////////////////////////////  INCLUDES

/////////////////////////////////////////////////////  DEFINES

// RecAct message ranges
//
#define RAM_FIRST       (WM_USER+1)
#define RAM_LAST        (WM_USER+20)
#define RN_FIRST        (0U-700U)
#define RN_LAST         (0U-799U)

// Window class name
//
#define WC_RECACT       "RecAction"



// BOOL RecAct_Enable(HWND hwnd, BOOL fEnable);
//
#define RecAct_Enable(hwnd, fEnable) \
	EnableWindow((hwnd), (fEnable))

// int RecAct_GetItemCount(HWND hwnd);
//
#define RAM_GETITEMCOUNT		(RAM_FIRST + 0)
#define RecAct_GetItemCount(hwnd) \
		(int)SendMessage(hwnd, RAM_GETITEMCOUNT, 0, 0L)

// Side item structure
//
#define SI_UNCHANGED    0
#define SI_CHANGED      1
#define SI_NEW          2
#define SI_NOEXIST      3
#define SI_UNAVAILABLE  4
#define SI_DELETED      5

typedef struct tagSIDE_ITEM
    {
    LPSTR pszDir;
    UINT uState;        // One of SI_* flags
    FILESTAMP fs;
    } SIDEITEM, FAR * LPSIDEITEM;

// RecAction Item structure
//
#define RAIF_ACTION      0x0001     // Mask codes
#define RAIF_NAME        0x0002
#define RAIF_STYLE       0x0004
#define RAIF_INSIDE      0x0008
#define RAIF_OUTSIDE     0x0010
#define RAIF_LPARAM      0x0020

#define RAIF_ALL         0x001f


typedef struct tagRA_ITEM
    {
    UINT mask;          // One of RAIF_
    int iItem;
    UINT uStyle;        // One of RAIS_
    UINT uAction;       // One of RAIA_

    LPCSTR pszName;

    SIDEITEM siInside;
    SIDEITEM siOutside;

    LPARAM lParam;

    } RA_ITEM, FAR * LPRA_ITEM;


// RecAct item styles
//
#define RAIS_CANMERGE   0x0001
#define RAIS_FOLDER     0x0002
#define RAIS_CANSKIP		0x0004

// RecAct actions
//
#define RAIA_TOOUT      0       // Don't change these values without changing
#define RAIA_TOIN       1       //  the order of the bitmaps in s_rgidAction
#define RAIA_SKIP       2
#define RAIA_CONFLICT   3
#define RAIA_MERGE      4
#define RAIA_SOMETHING  5       // These two require RAIS_FOLDER
#define RAIA_NOTHING    6
#define RAIA_ORPHAN     7

// Insert item at specified index.  Item is inserted at end if
// i is greater than or equal to the number of items in the twinview.
// Returns the index of the inserted item, or -1 on error.
//
// int RecAct_InsertItem(HWND hwnd, const LPRA_ITEM pitem);
//
#define RAM_INSERTITEM		    (RAM_FIRST + 1)
#define RecAct_InsertItem(hwnd, pitem) \
		(int)SendMessage((hwnd), RAM_INSERTITEM, 0, (LPARAM)(const LPRA_ITEM)(pitem))

// Delete an item at the specified index.
//
// int RecAct_DeleteItem(HWND hwnd, int i);
//
#define RAM_DELETEITEM			(RAM_FIRST + 2)
#define RecAct_DeleteItem(hwnd, i) \
		(int)SendMessage((hwnd), RAM_DELETEITEM, (WPARAM)(int)(i), 0L)

// Deletes all items in the control
//
// BOOL RecAct_DeleteAllItems(HWND hwnd);
//
#define RAM_DELETEALLITEMS		(RAM_FIRST + 3)
#define RecAct_DeleteAllItems(hwnd) \
		(BOOL)SendMessage((hwnd), RAM_DELETEALLITEMS, 0, 0L)

// BOOL RecAct_GetItem(HWND hwnd, LPRA_ITEM pitem);
//
#define RAM_GETITEM				(RAM_FIRST + 4)
#define RecAct_GetItem(hwnd, pitem) \
		(BOOL)SendMessage((hwnd), RAM_GETITEM, 0, (LPARAM)(LPRA_ITEM)(pitem))

// BOOL RecAct_SetItem(HWND hwnd, const LPRA_ITEM pitem);
//
#define RAM_SETITEM				(RAM_FIRST + 5)
#define RecAct_SetItem(hwnd, pitem) \
		(BOOL)SendMessage((hwnd), RAM_SETITEM, 0, (LPARAM)(const LPRA_ITEM)(pitem))

// Get the current selection by index.  -1 if nothing is selected.
//
// int RecAct_GetCurSel(HWND hwnd);
//
#define RAM_GETCURSEL			(RAM_FIRST + 6)
#define RecAct_GetCurSel(hwnd) \
		(int)SendMessage((hwnd), RAM_GETCURSEL, (WPARAM)0, 0L)

// Set the current selection by index.  -1 to deselect.
//
// int RecAct_SetCurSel(HWND hwnd, int i);
//
#define RAM_SETCURSEL			(RAM_FIRST + 7)
#define RecAct_SetCurSel(hwnd, i) \
		(int)SendMessage((hwnd), RAM_SETCURSEL, (WPARAM)(i), 0L)

// RecAct_FindItem flags
//
#define RAFI_NAME       0x0001
#define RAFI_LPARAM     0x0002
#define RAFI_ACTION     0x0004

typedef struct tagRA_FINDITEM
    {
    UINT    flags;      // One of RAFI_* flags
    UINT    uAction;    // One of RAIA_* flags
    LPCSTR  psz;
    LPARAM  lParam;
    
    } RA_FINDITEM;

// Find an item according to RA_FINDITEM struct.  iStart = -1 to
//  start at beginning.
//
// int RecAct_FindItem(HWND hwnd, int iStart, const RA_FINDITEM FAR* prafi);
#define RAM_FINDITEM				(RAM_FIRST + 8)
#define RecAct_FindItem(hwnd, iStart, prafi) \
		(int)SendMessage((hwnd), RAM_FINDITEM, (WPARAM)(int)(iStart), (LPARAM)(const RA_FINDINFO FAR*)(prafi))

// Refresh the control.
//
// void RecAct_Refresh(HWND hwnd);
#define RAM_REFRESH				(RAM_FIRST + 9)
#define RecAct_Refresh(hwnd) \
		SendMessage((hwnd), RAM_REFRESH, 0, 0L)


// Notification codes
//
#define RN_SELCHANGED	(RN_FIRST-0)
#define RN_ITEMCHANGED  (RN_FIRST-1)

typedef struct tagNM_RECACT
    {
    NMHDR   hdr;
    int     iItem;
    UINT    mask;           // One of RAIF_* 
    UINT    uAction;        // One of RAIA_*
    UINT    uActionOld;     // One of RAIA_*
    LPARAM  lParam;
    
    } NM_RECACT;

// Window styles
#define RAS_SINGLEITEM  0x0001L


/////////////////////////////////////////////////////  EXPORTED DATA


/////////////////////////////////////////////////////  PUBLIC PROTOTYPES

BOOL PUBLIC RecAct_Init (HINSTANCE hinst);
void PUBLIC RecAct_Term(HINSTANCE hinst);

void PUBLIC RAI_FillFromObject(LPRA_ITEM pitem, int atomBrf, LPCSTR pszInsideDir, PRECITEM lpri, HTWIN FAR * lphtwin);
BOOL PUBLIC RAI_FillFromFolder(LPRA_ITEM pitem, PFOLDERTWINLIST lpftl, PRECLIST lprl, LPCSTR lpcszPath, HTWIN FAR * lphtwin);

#endif // __RECACT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\usermode\reint\recon.c ===
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

#include "pch.h"

#include "recon.h"
#include "resource.h"

BOOL CALLBACK Recon_DlgProc(
    HWND  hwndDlg,
    UINT  uMsg,
    WPARAM  wParam,
    LPARAM  lParam)
{
    switch (uMsg )
    {
		case WM_INITDIALOG:
			SetWindowLong(hwndDlg, DWL_USER, lParam);
            DEBUG_PRINT(("Reconnect: Init dialog\n"));
			break;

		case WM_DESTROY:
            DEBUG_PRINT(("Reconnect: DestroyDialog\n"));
			break;

		case WM_COMMAND:
        	switch (LOWORD(wParam))
        	{
            }
            return FALSE;
			break;

		default:
			return FALSE;
	}
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\usermode\reint\recact.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: recact.c
//
//  This file contains the reconciliation-action control class code
//
//
// History:
//  08-12-93 ScottH     Created.
//
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////  INCLUDES

#include "pch.h"

#include "reintinc.h"
#include "extra.h"
#include "resource.h"

#include "recact.h"
#include "dobj.h"


/////////////////////////////////////////////////////	 Globals

int g_cxIconSpacing = 0;
int g_cyIconSpacing = 0;
int g_cxBorder = 0;
int g_cyBorder = 0;

int g_cxMargin = 0;
int g_cxIcon = 0;
int g_cyIcon = 0;
int g_cxIconMargin = 0;
int g_cyIconMargin = 0;

int g_cxLabelMargin = 0;
int g_cyLabelSpace = 0;

//char const FAR c_szWinHelpFile[] = "windows.hlp";

/////////////////////////////////////////////////////  CONTROLLING DEFINES


/////////////////////////////////////////////////////  DEFINES

// Manifest constants 
#define SIDE_INSIDE     0
#define SIDE_OUTSIDE    1

// These should be changed if the bitmap sizes change!!
#define CX_ACTIONBMP    26
#define CY_ACTIONBMP    26

#define RECOMPUTE       (-1)

#define X_INCOLUMN      (g_cxIcon*2)

// Image indexes 
#define II_RIGHT        0
#define II_LEFT         1
#define II_CONFLICT     2
#define II_SKIP         3
#define II_MERGE        4
#define II_SOMETHING    5
#define II_UPTODATE     6

// Menu items
//
#define IDM_ACTIONFIRST     100
#define IDM_TOOUT           100
#define IDM_TOIN            101
#define IDM_SKIP            102
#define IDM_MERGE           103
#define IDM_ACTIONLAST      103

#define IDM_WHATSTHIS       104


/////////////////////////////////////////////////////  TYPEDEFS

typedef struct tagRECACT
    {
    HWND        hwnd;
    
    HWND        hwndLB;
    HDC         hdcOwn;             // Own DC
    HMENU       hmenu;              // Action and help context menu
    HFONT       hfont;
    WNDPROC     lpfnLBProc;         // Default LB proc
    HIMAGELIST  himlAction;         // imagelist for actions
    HIMAGELIST  himlCache;          // control imagelist cache
    HBITMAP     hbmpBullet;

    HBRUSH      hbrBkgnd;
    COLORREF    clrBkgnd;

    LONG        lStyle;             // Window style flags

    // Metrics
    int         xAction;
    int         cxAction;
    int         cxItem;             // Generic width of an item
    int         cxMenuCheck;
    int         cyMenuCheck;
    int         cyText;
    int         cxSideItem;
    int         cxEllipses;

    } RECACT, FAR * LPRECACT;

#define RecAct_IsNoIcon(this)   IsFlagSet((this)->lStyle, RAS_SINGLEITEM)

// Internal item data struct
//
typedef struct tagRA_PRIV
    {
    UINT uStyle;        // One of RAIS_
    UINT uAction;       // One of RAIA_

    FileInfo * pfi;

    SIDEITEM siInside;
    SIDEITEM siOutside;

    LPARAM  lParam;

    DOBJ    rgdobj[4];      // Array of Draw object info
    int     cx;             // Bounding width and height
    int     cy;

    } RA_PRIV, FAR * LPRA_PRIV;

#define IDOBJ_ACTION    3

// RecAction menu item definition structure.  Used to define the
//  context menu brought up in this control.
//
typedef struct tagRAMID
    {
    UINT    idm;               // Menu ID (for MENUITEMINFO struct)
    UINT    uAction;           // One of RAIA_* flags
    UINT    ids;               // Resource string ID
    int     iImage;            // Index into himlAction 
    RECT    rcExtent;          // Extent rect of string
    } RAMID, FAR * LPRAMID;   // RecAction Menu Item Definition

// Help menu item definition structure.  Used to define the help
//  items in the context menu.
//
typedef struct tagHMID
    {
    UINT idm;
    UINT ids;
    } HMID;

/////////////////////////////////////////////////////  MACROS

#define RecAct_DefProc      DefWindowProc
#define RecActLB_DefProc    CallWindowProc


// Instance data pointer macros
//
#define RecAct_GetPtr(hwnd)     (LPRECACT)GetWindowLong(hwnd, 0)
#define RecAct_SetPtr(hwnd, lp) (LPRECACT)SetWindowLong(hwnd, 0, (LONG)(lp))

#define RecAct_GetCount(this)   ListBox_GetCount((this)->hwndLB)

/////////////////////////////////////////////////////  MODULE DATA

static char const c_szEllipses[] = "...";
static char const c_szDateDummy[] = "99/99/99 99:99PM";

// Map RAIA_* values to image indexes 
//
static UINT const c_mpraiaiImage[] = 
    { II_RIGHT, II_LEFT, II_SKIP, II_CONFLICT, II_MERGE, II_SOMETHING, II_UPTODATE };

// Map RAIA_* values to menu command positions
//
static UINT const c_mpraiaidmMenu[] = 
    {IDM_TOOUT, IDM_TOIN, IDM_SKIP, IDM_SKIP, IDM_MERGE, 0, 0 };

// Define the context menu layout
//
static RAMID const c_rgramid[] = {
    { IDM_TOOUT,    RAIA_TOOUT, IDS_MENU_REPLACE,   II_RIGHT,   0 },
    { IDM_TOIN,     RAIA_TOIN,  IDS_MENU_REPLACE,   II_LEFT,    0 },
    { IDM_SKIP,     RAIA_SKIP,  IDS_MENU_SKIP,      II_SKIP,    0 },
    // Merge must be the last item!
    { IDM_MERGE,    RAIA_MERGE, IDS_MENU_MERGE,     II_MERGE,   0 },
    };

static RAMID const c_rgramidCreates[] = {
    { IDM_TOOUT,    RAIA_TOOUT, IDS_MENU_CREATE,    II_RIGHT,   0 },
    { IDM_TOIN,     RAIA_TOIN,  IDS_MENU_CREATE,    II_LEFT,    0 },
    };

// Indexes into c_rgramidCreates
//
#define IRAMID_CREATEOUT    0
#define IRAMID_CREATEIN     1

static HMID const c_rghmid[] = {
    { IDM_WHATSTHIS, IDS_MENU_WHATSTHIS },
    };

/////////////////////////////////////////////////////  LOCAL PROCEDURES

LRESULT _export CALLBACK RecActLB_LBProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam);

/////////////////////////////////////////////////////  PRIVATE FUNCTIONS



#ifdef DEBUG
LPCSTR PRIVATE DumpRecAction(
    UINT uAction)        // RAIA_
    {
    switch (uAction)
        {
    DEBUG_CASE_STRING( RAIA_TOOUT );
    DEBUG_CASE_STRING( RAIA_TOIN );     
    DEBUG_CASE_STRING( RAIA_SKIP );     
    DEBUG_CASE_STRING( RAIA_CONFLICT ); 
    DEBUG_CASE_STRING( RAIA_MERGE );    
    DEBUG_CASE_STRING( RAIA_SOMETHING );
    DEBUG_CASE_STRING( RAIA_NOTHING );  
    DEBUG_CASE_STRING( RAIA_ORPHAN );   

    default:        return "Unknown";
        }
    }


LPCSTR PRIVATE DumpSideItemState(
    UINT uState)        // SI_
    {
    switch (uState)
        {
    DEBUG_CASE_STRING( SI_UNCHANGED );
    DEBUG_CASE_STRING( SI_CHANGED );     
    DEBUG_CASE_STRING( SI_NEW );     
    DEBUG_CASE_STRING( SI_NOEXIST ); 
    DEBUG_CASE_STRING( SI_UNAVAILABLE );    
    DEBUG_CASE_STRING( SI_DELETED );

    default:        return "Unknown";
        }
    }


/*----------------------------------------------------------
Purpose: 
Returns: 
Cond:    --
*/
void PUBLIC DumpTwinPair(
    LPRA_ITEM pitem)
    {
    if (pitem)
        {
        char szBuf[MAXMSGLEN];

        #define szDump   "Dump TWINPAIR: "
        #define szBlank  "               "

        if (IsFlagClear(g_uDumpFlags, DF_TWINPAIR))
            {
            return;
            }

        wsprintf(szBuf, "%s.pszName = %s\r\n", (LPSTR)szDump, Dbg_SafeStr(pitem->pszName));
        OutputDebugString(szBuf);
        wsprintf(szBuf, "%s.uStyle = %lx\r\n", (LPSTR)szBlank, pitem->uStyle);
        OutputDebugString(szBuf);
        wsprintf(szBuf, "%s.uAction = %s\r\n", (LPSTR)szBlank, DumpRecAction(pitem->uAction));
        OutputDebugString(szBuf);

        #undef szDump
        #define szDump   "       Inside: "
        wsprintf(szBuf, "%s.pszDir = %s\r\n", (LPSTR)szDump, Dbg_SafeStr(pitem->siInside.pszDir));
        OutputDebugString(szBuf);
        wsprintf(szBuf, "%s.uState = %s\r\n", (LPSTR)szBlank, DumpSideItemState(pitem->siInside.uState));
        OutputDebugString(szBuf);

        #undef szDump
        #define szDump   "      Outside: "
        wsprintf(szBuf, "%s.pszDir = %s\r\n", (LPSTR)szDump, Dbg_SafeStr(pitem->siOutside.pszDir));
        OutputDebugString(szBuf);
        wsprintf(szBuf, "%s.uState = %s\r\n", (LPSTR)szBlank, DumpSideItemState(pitem->siOutside.uState));
        OutputDebugString(szBuf);

        #undef szDump
        #undef szBlank
        }
    }


#endif


/*----------------------------------------------------------
Purpose: Create a monochrome bitmap of the bullet, so we can
         play with the colors later.
Returns: handle to bitmap
Cond:    Caller must delete bitmap
*/
HBITMAP PRIVATE CreateBulletBitmap(
    LPSIZE psize)
    {
    HDC hdcMem;
    HBITMAP hbmp = NULL;

    hdcMem = CreateCompatibleDC(NULL);
    if (hdcMem)
        {
        hbmp = CreateCompatibleBitmap(hdcMem, psize->cx, psize->cy);
        if (hbmp)
            {
            HBITMAP hbmpOld;
            RECT rc;

            // hbmp is monochrome

            hbmpOld = SelectBitmap(hdcMem, hbmp);
            rc.left = 0;
            rc.top = 0;
            rc.right = psize->cx;
            rc.bottom = psize->cy;
            DrawFrameControl(hdcMem, &rc, DFC_MENU, DFCS_MENUBULLET);

            SelectBitmap(hdcMem, hbmpOld);
            }
        DeleteDC(hdcMem);
        }
    return hbmp;
    }


/*----------------------------------------------------------
Purpose: Returns the resource ID string given the action
         flag.
Returns: IDS_ value
Cond:    --
*/
UINT PRIVATE GetActionText(
    LPRA_PRIV ppriv)
    {
    UINT ids;

    ASSERT(ppriv);

    switch (ppriv->uAction)
        {
    case RAIA_TOOUT:
        if (SI_NEW == ppriv->siInside.uState)
            {
            ids = IDS_STATE_Creates;
            }
        else
            {
            ids = IDS_STATE_Replaces;
            }
        break;

    case RAIA_TOIN:
        if (SI_NEW == ppriv->siOutside.uState)
            {
            ids = IDS_STATE_Creates;
            }
        else
            {
            ids = IDS_STATE_Replaces;
            }
        break;

    case RAIA_SKIP:         
        // Can occur if the user explicitly wants to skip, or if
        // one side is unavailable.
        ids = IDS_STATE_Skip;           
        break;

    case RAIA_CONFLICT:     ids = IDS_STATE_Conflict;       break;
    case RAIA_MERGE:        ids = IDS_STATE_Merge;          break;
    case RAIA_NOTHING:      ids = IDS_STATE_Uptodate;       break;
    case RAIA_SOMETHING:    ids = IDS_STATE_NeedToUpdate;   break;
    default:                ids = 0;                        break;
        }

    return ids;
    }


/*----------------------------------------------------------
Purpose: Repaint an item in the listbox
Returns: --
Cond:    --
*/
void PRIVATE ListBox_RepaintItemNow(
    HWND hwnd,
    int iItem,
    LPRECT prc,         // Relative to individual entry rect.  May be NULL
    BOOL bEraseBk)
    {
    RECT rc;
    RECT rcItem;

    ListBox_GetItemRect(hwnd, iItem, &rcItem);
    if (prc)
        {
        OffsetRect(prc, rcItem.left, rcItem.top);
        IntersectRect(&rc, &rcItem, prc);
        }
    else
        rc = rcItem;

    InvalidateRect(hwnd, &rc, bEraseBk);
    UpdateWindow(hwnd);
    }


/*----------------------------------------------------------
Purpose: Send selection change notification
Returns: 
Cond:    --
*/
BOOL PRIVATE RecAct_SendSelChange(
    LPRECACT this,
    int isel)
    {
    NM_RECACT nm;
    
    nm.iItem = isel;
    nm.mask = 0;
    
    if (isel != -1)
        {
        LPRA_ITEM pitem;
        
        ListBox_GetText(this->hwndLB, isel, &pitem);
        if (!pitem)
            return FALSE;
        
        nm.lParam = pitem->lParam;
        nm.mask |= RAIF_LPARAM;
        }
    
    return !(BOOL)SendNotify(GetParent(this->hwnd), this->hwnd, RN_SELCHANGED, &nm.hdr);
    }


/*----------------------------------------------------------
Purpose: Send an action change notification
Returns: 
Cond:    --
*/
BOOL PRIVATE RecAct_SendItemChange(
    LPRECACT this,
    int iEntry,
    UINT uActionOld)
    {
    NM_RECACT nm;
    
    nm.iItem = iEntry;
    nm.mask = 0;
    
    if (iEntry != -1)
        {
        LPRA_PRIV ppriv;
        
        ListBox_GetText(this->hwndLB, iEntry, &ppriv);
        if (!ppriv)
            return FALSE;
        
        nm.mask |= RAIF_LPARAM | RAIF_ACTION;
        nm.lParam = ppriv->lParam;
        nm.uAction = ppriv->uAction;
        nm.uActionOld = uActionOld;
        }
    
    return !(BOOL)SendNotify(GetParent(this->hwnd), this->hwnd, RN_ITEMCHANGED, &nm.hdr);
    }


/*----------------------------------------------------------
Purpose: Calculate the important coordinates that we want to save.
Returns: --
Cond:    --
*/
void PRIVATE RecAct_CalcCoords(
    LPRECACT this)
    {
    int xOutColumn;
      
    ASSERT(this->cxSideItem != 0);
      
    xOutColumn = this->cxItem - this->cxSideItem - g_cxMargin;

    this->xAction = (RecAct_IsNoIcon(this) ? 0 : X_INCOLUMN) + this->cxSideItem;
    this->cxAction = xOutColumn - this->xAction;
    }


/*----------------------------------------------------------
Purpose: Create the action context menu
Returns: TRUE on success
Cond:    --
*/
BOOL PRIVATE RecAct_CreateMenu(
    LPRECACT this)
    {
    HMENU hmenu;

    hmenu = CreatePopupMenu();
    if (hmenu)
        {
        char sz[MAXSHORTLEN];
        MENUITEMINFO mii;
        int i;

        // Add the help menu items now, since these will be standard
        //
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_TYPE | MIIM_STATE | MIIM_ID;
        mii.fType = MFT_STRING;
        mii.fState = MFS_ENABLED;

        for (i = 0; i < ARRAYSIZE(c_rghmid); i++)
            {
            mii.wID = c_rghmid[i].idm;
            mii.dwTypeData = SzFromIDS(c_rghmid[i].ids, sz, sizeof(sz));
            InsertMenuItem(hmenu, i, TRUE, &mii);
            }

        this->hmenu = hmenu;
        }

    return hmenu != NULL;
    }


/*----------------------------------------------------------
Purpose: Add the action menu items to the context menu
Returns: --
Cond:    --
*/
void PRIVATE AddActionsToContextMenu(
    HMENU hmenu,
    UINT idmCheck,      // menu item to checkmark
    LPRA_PRIV ppriv)
    {
    MENUITEMINFO mii;
    int i;
    int cItems = ARRAYSIZE(c_rgramid);

    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_TYPE | MIIM_STATE | MIIM_ID | MIIM_DATA;
    mii.fType = MFT_OWNERDRAW;
    mii.fState = MFS_ENABLED;

    // Is merge supported?
    if (IsFlagClear(ppriv->uStyle, RAIS_CANMERGE))
        {
        // No
        --cItems;
        }

    for (i = 0; i < cItems; i++)
        {
        mii.wID = c_rgramid[i].idm;
        mii.dwItemData = (DWORD)&c_rgramid[i];

        InsertMenuItem(hmenu, i, TRUE, &mii);
        }

    // Add the separator
    mii.fMask = MIIM_TYPE;
    mii.fType = MFT_SEPARATOR;
    InsertMenuItem(hmenu, i, TRUE, &mii);

    // Set the initial checkmark.  
    CheckMenuRadioItem(hmenu, IDM_ACTIONFIRST, IDM_ACTIONLAST, idmCheck, 
        MF_BYCOMMAND | MF_CHECKED);

#if 0
    // Is merge supported?
    if (IsFlagClear(ppriv->uStyle, RAIS_CANMERGE))
        {
        // No
        mii.fMask = MIIM_STATE;
        mii.fState = MFS_GRAYED | MFS_DISABLED;
        SetMenuItemInfo(hmenu, IDM_MERGE, FALSE, &mii);
        }
#endif
	 //tHACK
	 mii.fMask = MIIM_STATE;
	 mii.fState = MFS_GRAYED | MFS_DISABLED;
	 SetMenuItemInfo(hmenu, IDM_SKIP, FALSE, &mii);

    // Is the file or its sync copy unavailable?
    if (SI_UNAVAILABLE == ppriv->siInside.uState ||
        SI_UNAVAILABLE == ppriv->siOutside.uState)
        {
        // Yes
        mii.fMask = MIIM_STATE;
        mii.fState = MFS_GRAYED | MFS_DISABLED;
        SetMenuItemInfo(hmenu, IDM_TOIN, FALSE, &mii);
        SetMenuItemInfo(hmenu, IDM_TOOUT, FALSE, &mii);
        SetMenuItemInfo(hmenu, IDM_MERGE, FALSE, &mii);
        }

    // Is the file being created?
    else if (ppriv->siInside.uState == SI_NEW ||
        ppriv->siOutside.uState == SI_NEW)
        {
        // Yes; disable the replace-in-opposite direction 
        UINT idmDisable;
        UINT idmChangeVerb;

        if (ppriv->siInside.uState == SI_NEW)
            {
            idmDisable = IDM_TOIN;
            idmChangeVerb = IDM_TOOUT;
            i = IRAMID_CREATEOUT;
            }
        else
            {
            idmDisable = IDM_TOOUT;
            idmChangeVerb = IDM_TOIN;
            i = IRAMID_CREATEIN;
            }
            
        // Disable one of the directions
        mii.fMask = MIIM_STATE;
        mii.fState = MFS_GRAYED | MFS_DISABLED;
        SetMenuItemInfo(hmenu, idmDisable, FALSE, &mii);

        // Change the verb of the other direction
        mii.fMask = MIIM_DATA;
        mii.dwItemData = (DWORD)&c_rgramidCreates[i];

        SetMenuItemInfo(hmenu, idmChangeVerb, FALSE, &mii);
        }
    }


/*----------------------------------------------------------
Purpose: Clear out the context menu
Returns: --
Cond:    --
*/
void PRIVATE ResetContextMenu(
    HMENU hmenu)
    {
    int cnt;

    // If there is more than just the help items, remove them
    //  (but leave the help items)
    //
    cnt = GetMenuItemCount(hmenu);
    if (cnt > ARRAYSIZE(c_rghmid))
        {
        int i;

        cnt -= ARRAYSIZE(c_rghmid);
        for (i = 0; i < cnt; i++)
            {
            DeleteMenu(hmenu, 0, MF_BYPOSITION);
            }
        }
    }


/*----------------------------------------------------------
Purpose: Do the context menu
Returns: --
Cond:    --
*/
void PRIVATE RecAct_DoContextMenu(
    LPRECACT this,
    int x,              // in screen coords
    int y,
    int iEntry,
    BOOL bHelpOnly)     // TRUE: only show the help items
    {
    UINT idCmd;

    if (this->hmenu)
        {
        LPRA_PRIV ppriv;
        RECT rc;
        int idmCheck;
        UINT uActionOld;

        // Only show help-portion of context menu?
        if (bHelpOnly)
            {
            // Yes
            ppriv = NULL;
            }
        else
            {
            // No
            ListBox_GetText(this->hwndLB, iEntry, &ppriv);

            // Determine if this is a help-context menu only.
            //  It is if this is a folder-item or if there is no action
            //  to take.
            //
            ASSERT(ppriv->uAction < ARRAYSIZE(c_mpraiaidmMenu));
            idmCheck = c_mpraiaidmMenu[ppriv->uAction];

            // Build the context menu
            //
            if (IsFlagClear(ppriv->uStyle, RAIS_FOLDER) && idmCheck != 0)
                {
                AddActionsToContextMenu(this->hmenu, idmCheck, ppriv);
                }
            }

        // Show context menu
        //
        idCmd = TrackPopupMenu(this->hmenu, 
                    TPM_RETURNCMD | TPM_RIGHTBUTTON | TPM_LEFTALIGN,
                    x, y, 0, this->hwnd, NULL);

        // Clear menu
        //
        ResetContextMenu(this->hmenu);

        if (ppriv)
            {
            // Save the old action
            uActionOld = ppriv->uAction;
            }

        // Act on whatever the user chose
        switch (idCmd)
            {
        case IDM_TOOUT:
            ppriv->uAction = RAIA_TOOUT;
            break;

        case IDM_TOIN:
            ppriv->uAction = RAIA_TOIN;
            break;

        case IDM_SKIP:
            ppriv->uAction = RAIA_SKIP;
            break;

        case IDM_MERGE:
            ppriv->uAction = RAIA_MERGE;
            break;

// tHACK        case IDM_WHATSTHIS:
//            WinHelp(this->hwnd, c_szWinHelpFile, HELP_CONTEXTPOPUP, IDH_BFC_UPDATE_SCREEN);
//            return;         // Return now

        default:
            return;         // Return now
            }

        // Repaint action portion of entry
        ppriv->cx = RECOMPUTE;
        rc = ppriv->rgdobj[IDOBJ_ACTION].rcBounding;
        ListBox_RepaintItemNow(this->hwndLB, iEntry, &rc, TRUE);

        // Send a notify message
        ASSERT(NULL != ppriv);      // uActionOld should be valid
        RecAct_SendItemChange(this, iEntry, uActionOld);
        }
    }


/*----------------------------------------------------------
Purpose: Create the windows for this control
Returns: TRUE on success
Cond:    --
*/
BOOL PRIVATE RecAct_CreateWindows(
    LPRECACT this,
    CREATESTRUCT FAR * lpcs)
    {
    HWND hwnd = this->hwnd;
    HWND hwndLB = NULL;
    RECT rc;
    int cxEdge = GetSystemMetrics(SM_CXEDGE);
    int cyEdge = GetSystemMetrics(SM_CYEDGE);

    // Create listbox
    hwndLB = CreateWindowEx(
                0, 
                "listbox",
                "",
                WS_CHILD | WS_CLIPSIBLINGS | LBS_SORT | LBS_OWNERDRAWVARIABLE |
                WS_VSCROLL | WS_TABSTOP | WS_VISIBLE | LBS_NOINTEGRALHEIGHT |
                LBS_NOTIFY,
                0, 0, lpcs->cx, lpcs->cy,
                hwnd,
                NULL,
                lpcs->hInstance,
                0L);
    if (!hwndLB)
        return FALSE;

    SetWindowFont(hwndLB, this->hfont, FALSE);

    this->hwndLB = hwndLB;

    // Determine layout of window
    GetClientRect(hwnd, &rc);
    InflateRect(&rc, -cxEdge, -cyEdge);
    SetWindowPos(hwndLB, NULL, rc.left, rc.top, rc.right-rc.left, rc.bottom-rc.top,
        SWP_NOACTIVATE | SWP_SHOWWINDOW | SWP_NOZORDER);

    GetClientRect(hwndLB, &rc);
    this->cxItem = rc.right - rc.left;

    return TRUE;
    }


/*----------------------------------------------------------
Purpose: Set the colors of the control
Returns: --
Cond:    --
*/
void PRIVATE RecAct_SetColors(
    LPRECACT this)
    {
    int cr;

    if (IsFlagClear(this->lStyle, RAS_SINGLEITEM))
        {
        cr = COLOR_WINDOW;
        }
    else
        {
        cr = COLOR_3DFACE;
        }

    this->clrBkgnd = GetSysColor(cr);

    if (this->hbrBkgnd)
        DeleteBrush(this->hbrBkgnd);

    this->hbrBkgnd = CreateSolidBrush(this->clrBkgnd);
    }


/*----------------------------------------------------------
Purpose: Creates an imagelist of the action images

Returns: TRUE on success

Cond:    --
*/
BOOL PRIVATE CreateImageList(
    HIMAGELIST * phiml,
    HDC hdc,
    UINT idb,
    int cxBmp,
    int cyBmp,
    int cImage)
    {
    BOOL bRet;
    HIMAGELIST himl;

    himl = ImageList_Create(cxBmp, cyBmp, TRUE, cImage, 1);

    if (himl)
        {
        COLORREF clrMask;
        HBITMAP hbm;

        hbm = LoadBitmap(vhinstCur, MAKEINTRESOURCE(idb));
        ASSERT(hbm);

        if (hbm)
            {
            HDC hdcMem = CreateCompatibleDC(hdc);
            if (hdcMem)
                {
                HBITMAP hbmSav = SelectBitmap(hdcMem, hbm);

                clrMask = GetPixel(hdcMem, 0, 0);
                SelectBitmap(hdcMem, hbmSav);

                bRet = (0 == ImageList_AddMasked(himl, hbm, clrMask));

                DeleteDC(hdcMem);
                }
            else
                bRet = FALSE;

            DeleteBitmap(hbm);
            }
        else
            bRet = FALSE;
        }
    else
        bRet = FALSE;

    *phiml = himl;
    return bRet;
    }


/*----------------------------------------------------------
Purpose: WM_CREATE handler
Returns: TRUE on success
Cond:    --
*/
BOOL PRIVATE RecAct_OnCreate(
    LPRECACT this,
    CREATESTRUCT FAR * lpcs)
    {
    BOOL bRet = FALSE;
    HWND hwnd = this->hwnd;
    HDC hdc;
    TEXTMETRIC tm;
    RECT rcT;
    LOGFONT lf;

    this->lStyle = GetWindowLong(hwnd, GWL_STYLE);
    RecAct_SetColors(this);

    // Determine some font things

    SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(lf), &lf, FALSE);
    this->hfont = CreateFontIndirect(&lf);

    // This window is registered with the CS_OWNDC flag
    this->hdcOwn = GetDC(hwnd);
    ASSERT(this->hdcOwn);

    hdc = this->hdcOwn;

    SelectFont(hdc, this->hfont);
    GetTextMetrics(hdc, &tm);
    this->cyText = tm.tmHeight;

    // Calculate text extent for sideitems (use the listbox font)
    //
    SetRectFromExtent(hdc, &rcT, c_szEllipses);
    this->cxEllipses = rcT.right - rcT.left;

    SetRectFromExtent(hdc, &rcT, c_szDateDummy);
    this->cxSideItem = (rcT.right - rcT.left) + 2*g_cxMargin;

    // Create windows used by control
    if (RecAct_CreateWindows(this, lpcs))
        {
        RecAct_CalcCoords(this);

        this->lpfnLBProc = SubclassWindow(this->hwndLB, RecActLB_LBProc);

        // Get the system imagelist cache
        //
        this->himlCache = ImageList_Create(g_cxIcon, g_cyIcon, TRUE, 8, 8);
        if (this->himlCache)
            {
            if (CreateImageList(&this->himlAction, hdc, IDB_ACTIONS,
                CX_ACTIONBMP, CY_ACTIONBMP, 8))
                {
                SIZE size;

                // Get some metrics
                this->cxMenuCheck = GetSystemMetrics(SM_CXMENUCHECK);
                this->cyMenuCheck = GetSystemMetrics(SM_CYMENUCHECK);

                size.cx = this->cxMenuCheck;
                size.cy = this->cyMenuCheck;
                this->hbmpBullet = CreateBulletBitmap(&size);
                if (this->hbmpBullet)
                    {
                    bRet = RecAct_CreateMenu(this);
                    }
                }
            }
        }

    return bRet;
    }


/*----------------------------------------------------------
Purpose: WM_DESTROY Handler
Returns: --
Cond:    --
*/
void PRIVATE RecAct_OnDestroy(
    LPRECACT this)
    {
    if (this->himlCache)
        {
        ImageList_Destroy(this->himlCache);
        this->himlCache = NULL;
        }

    if (this->himlAction)
        {
        ImageList_Destroy(this->himlAction);
        this->himlAction = NULL;
        }
    
    if (this->hbmpBullet)
        {
        DeleteBitmap(this->hbmpBullet);
        this->hbmpBullet = NULL;
        }

    if (this->hmenu)
        {
        DestroyMenu(this->hmenu);
        this->hmenu = NULL;
        }

    if (this->hbrBkgnd)
        DeleteBrush(this->hbrBkgnd);

    if (this->hfont)
        DeleteFont(this->hfont);
    }


/*----------------------------------------------------------
Purpose: WM_COMMAND Handler
Returns: --
Cond:    --
*/
VOID PRIVATE RecAct_OnCommand(
    LPRECACT this,
    int id,
    HWND hwndCtl,
    UINT uNotifyCode)
    {
    if (hwndCtl == this->hwndLB)
        {
        switch (uNotifyCode)
            {
        case LBN_SELCHANGE:
            break;
            }
        }
    }


/*----------------------------------------------------------
Purpose: WM_NOTIFY handler
Returns: varies
Cond:    --
*/
LRESULT PRIVATE RecAct_OnNotify(
    LPRECACT this,
    int idFrom,
    NMHDR FAR * lpnmhdr)
    {
    LRESULT lRet = 0;

    switch (lpnmhdr->code)
        {
    case HDN_BEGINTRACK:
        lRet = TRUE;       // prevent tracking
        break;

    default:
        break;
        }

    return lRet;
    }


/*----------------------------------------------------------
Purpose: WM_CONTEXTMENU handler
Returns: --
Cond:    --
*/
void PRIVATE RecAct_OnContextMenu(
    LPRECACT this,
    HWND hwnd,
    int x,
    int y)
    {
    if (hwnd == this->hwndLB)
        {
        POINT pt;
        int iHitEntry;
        BOOL bHelpOnly = TRUE;
    
        pt.x = x;
        pt.y = y;
        ScreenToClient(hwnd, &pt);
        iHitEntry = (pt.y / ListBox_GetItemHeight(hwnd, 0)) + ListBox_GetTopIndex(hwnd);

        ASSERT(iHitEntry >= 0);
    
        if (iHitEntry < ListBox_GetCount(hwnd))
            {
            ListBox_SetCurSel(hwnd, iHitEntry);
            ListBox_RepaintItemNow(hwnd, iHitEntry, NULL, FALSE);

            bHelpOnly = FALSE;
            }

        // Bring up the context menu for the listbox
        RecAct_DoContextMenu(this, x, y, iHitEntry, bHelpOnly);
        }
    }


/*----------------------------------------------------------
Purpose: Calculate the rectangle boundary of a sideitem

Returns: calculated rect
Cond:    --
*/
void PRIVATE RecAct_CalcSideItemRect(
    LPRECACT this,
    int nSide,          // SIDE_INSIDE or SIDE_OUTSIDE
    LPRECT prcOut)
    {
    int x;
    int y = g_cyIconMargin*2;

    if (SIDE_INSIDE == nSide)
        {
        x = g_cxMargin;
        if ( !RecAct_IsNoIcon(this) )
            x += X_INCOLUMN;
        }
    else
        {
        ASSERT(SIDE_OUTSIDE == nSide);
        x = this->cxItem - this->cxSideItem - g_cxMargin;
        }

    prcOut->left   = x;
    prcOut->top    = y;
    prcOut->right  = x + this->cxSideItem;
    prcOut->bottom = y + (this->cyText * 3);
    }


/*----------------------------------------------------------
Purpose: Draw a reconciliation listbox entry
Returns: --
Cond:    --
*/
void PRIVATE RecAct_RecomputeItemMetrics(
    LPRECACT this,
    LPRA_PRIV ppriv)
    {
    HDC hdc = this->hdcOwn;
    LPDOBJ pdobj = ppriv->rgdobj;
    RECT rcT;
    RECT rcUnion;
    char szIDS[MAXBUFLEN];
    UINT ids;
    int cyText = this->cyText;
    POINT pt;

    // Compute the metrics and dimensions of each of the draw objects
    // and store back into the item.

    // File icon and label

    pt.x = 0;
    pt.y = 0;
    ComputeImageRects(FIGetDisplayName(ppriv->pfi), hdc, &pt, 
        &pdobj->rcBounding, &pdobj->rcLabel, g_cxIcon, g_cyIcon, 
        g_cxIconSpacing, cyText);

    pdobj->uKind = DOK_IMAGE;
    pdobj->lpvObject = FIGetDisplayName(ppriv->pfi);
    pdobj->uFlags = DOF_DIFFER | DOF_CENTER;
    if (RecAct_IsNoIcon(this))
        SetFlag(pdobj->uFlags, DOF_NODRAW);
    pdobj->x = pt.x;
    pdobj->y = pt.y;
    pdobj->himl = this->himlCache;
    pdobj->iImage = (UINT)ppriv->pfi->lParam;

    rcUnion = pdobj->rcBounding;

    // Sideitem Info (Inside Briefcase)

    RecAct_CalcSideItemRect(this, SIDE_INSIDE, &rcT);

    pdobj++;
    pdobj->uKind = DOK_SIDEITEM;
    pdobj->lpvObject = &ppriv->siInside;
    pdobj->uFlags = DOF_LEFT;
    pdobj->x = rcT.left;
    pdobj->y = rcT.top;
    pdobj->rcClip = rcT;
    pdobj->rcBounding = rcT;

    // Sideitem Info (Outside Briefcase)

    RecAct_CalcSideItemRect(this, SIDE_OUTSIDE, &rcT);

    pdobj++;
    pdobj->uKind = DOK_SIDEITEM;
    pdobj->lpvObject = &ppriv->siOutside;
    pdobj->uFlags = DOF_LEFT;
    pdobj->x = rcT.left;
    pdobj->y = rcT.top;
    pdobj->rcClip = rcT;
    pdobj->rcBounding = rcT;

    UnionRect(&rcUnion, &rcUnion, &rcT);

    // Action image

    ASSERT(ppriv->uAction <= ARRAYSIZE(c_mpraiaiImage));

    pdobj++;

    ids = GetActionText(ppriv);
    pt.x = this->xAction;
    pt.y = 0;
    ComputeImageRects(SzFromIDS(ids, szIDS, sizeof(szIDS)), hdc, &pt,
        &pdobj->rcBounding, &pdobj->rcLabel, CX_ACTIONBMP, CY_ACTIONBMP, 
        this->cxAction, cyText);

    pdobj->uKind = DOK_IMAGE;
    pdobj->lpvObject = (LPVOID)ids;
    pdobj->uFlags = DOF_CENTER | DOF_USEIDS;
    if (!RecAct_IsNoIcon(this))
        SetFlag(pdobj->uFlags, DOF_IGNORESEL);
    pdobj->x = pt.x;
    pdobj->y = pt.y;
    pdobj->himl = this->himlAction;
    pdobj->iImage = c_mpraiaiImage[ppriv->uAction];

    UnionRect(&rcUnion, &rcUnion, &pdobj->rcBounding);

    // Set the bounding rect of this item.
    ppriv->cx = rcUnion.right - rcUnion.left;
    ppriv->cy = max((rcUnion.bottom - rcUnion.top), g_cyIconSpacing);
    }


/*----------------------------------------------------------
Purpose: WM_MEASUREITEM handler
Returns: --
Cond:    --
*/
void PRIVATE RecAct_OnMeasureItem(
    LPRECACT this,
    LPMEASUREITEMSTRUCT lpmis)
    {
    HDC hdc = this->hdcOwn;

    switch (lpmis->CtlType)
        {
    case ODT_LISTBOX: {
        LPRA_PRIV ppriv = (LPRA_PRIV)lpmis->itemData;
        
        // Recompute item metrics?
        if (RECOMPUTE == ppriv->cx)
            {
            RecAct_RecomputeItemMetrics(this, ppriv);   // Yes
            }

        lpmis->itemHeight = ppriv->cy;
        }
        break;

    case ODT_MENU:
        {
        int i;
        int cxMac = 0;
        RECT rc;
        char sz[MAXBUFLEN];

        // Calculate based on font and image dimensions.
        //
        SelectFont(hdc, this->hfont);

        cxMac = 0;
        for (i = 0; i < ARRAYSIZE(c_rgramid); i++)
            {
            SzFromIDS(c_rgramid[i].ids, sz, sizeof(sz));
            SetRectFromExtent(hdc, &rc, sz);
            cxMac = max(cxMac, 
                        g_cxMargin + CX_ACTIONBMP + g_cxMargin + 
                        (rc.right-rc.left) + g_cxMargin);
            }

        lpmis->itemHeight = max(this->cyText, CY_ACTIONBMP);
        lpmis->itemWidth = cxMac;
        }
        break;
        }
    }


/*----------------------------------------------------------
Purpose: Draw a reconciliation listbox entry
Returns: --
Cond:    --
*/
void PRIVATE RecAct_DrawLBItem(
    LPRECACT this,
    const DRAWITEMSTRUCT FAR * lpcdis)
    {
    LPRA_PRIV ppriv = (LPRA_PRIV)lpcdis->itemData;
    HDC hdc = lpcdis->hDC;
    RECT rc = lpcdis->rcItem;
    POINT ptSav;
    LPDOBJ pdobj;
    UINT cdobjs;

    if (!ppriv)
        {
        // Empty listbox and we're getting the focus
        return;
        }

    SetBkMode(hdc, TRANSPARENT);        // required for Shell_DrawText
    SetViewportOrgEx(hdc, rc.left, rc.top, &ptSav);

    // The Chicago-look mandates that icon and filename are selected, 
    //  the rest of the entry is normal.  Yuk.

    // Recompute item metrics?
    if (RECOMPUTE == ppriv->cx)
        {
        RecAct_RecomputeItemMetrics(this, ppriv);   // Yes
        }

    // Do we need to redraw everything?
    if (IsFlagSet(lpcdis->itemAction, ODA_DRAWENTIRE))
        {
        // Yes
        cdobjs = ARRAYSIZE(ppriv->rgdobj);
        pdobj = ppriv->rgdobj;
        }
    else
        {
        // No; should we even draw the file icon or action icon?
        if (lpcdis->itemAction & (ODA_FOCUS | ODA_SELECT))
            {
            cdobjs = 1;     // Yes

            // Focus rect on file icon?
            if (!RecAct_IsNoIcon(this))
                pdobj = ppriv->rgdobj;
            else
                pdobj = &ppriv->rgdobj[IDOBJ_ACTION];
            }
        else
            {
            cdobjs = 0;     // No
            pdobj = ppriv->rgdobj;
            }
        }

    Dobj_Draw(hdc, pdobj, cdobjs, lpcdis->itemState, this->cxEllipses, this->cyText,
        this->clrBkgnd);
    
    // Clean up
    //
    SetViewportOrgEx(hdc, ptSav.x, ptSav.y, NULL);
    }


/*----------------------------------------------------------
Purpose: Draw an action menu item
Returns: --
Cond:    --
*/
void PRIVATE RecAct_DrawMenuItem(
    LPRECACT this,
    const DRAWITEMSTRUCT FAR * lpcdis)
    {
    LPRAMID pramid = (LPRAMID)lpcdis->itemData;
    HDC hdc = lpcdis->hDC;
    RECT rc = lpcdis->rcItem;
    DOBJ dobj;
    LPDOBJ pdobj;
    POINT ptSav;
    MENUITEMINFO mii;
    int cx;
    int cy;
    UINT uFlags;
    UINT uFlagsChecked;

    ASSERT(pramid);
    
    if (lpcdis->itemID == -1)
        return;

    SetViewportOrgEx(hdc, rc.left, rc.top, &ptSav);
    OffsetRect(&rc, -rc.left, -rc.top);

    cx = rc.right - rc.left;
    cy = rc.bottom - rc.top;

    // Get the menu state 
    mii.cbSize = sizeof(mii);
    mii.fMask = MIIM_STATE | MIIM_CHECKMARKS;
    GetMenuItemInfo(this->hmenu, lpcdis->itemID, FALSE, &mii);
    uFlagsChecked = IsFlagClear(mii.fState, MFS_CHECKED) ? DOF_NODRAW : 0;

    uFlags = DOF_DIFFER | DOF_MENU | DOF_USEIDS;
    if (IsFlagSet(mii.fState, MFS_GRAYED))
        SetFlag(uFlags, DOF_DISABLED);

    // Build the array of DObjs that we want to draw.

    // Action image

    pdobj = &dobj;

    pdobj->uKind = DOK_IMAGE;
    pdobj->lpvObject = (LPVOID)pramid->ids;
    pdobj->himl = this->himlAction;
    pdobj->iImage = pramid->iImage;
    pdobj->uFlags = uFlags;
    pdobj->x = g_cxMargin;
    pdobj->y = (cy - CY_ACTIONBMP) / 2;
    pdobj->rcLabel.left = 0;
    pdobj->rcLabel.right = cx;
    pdobj->rcLabel.top = 0;
    pdobj->rcLabel.bottom = cy;

    // Draw the entry...
    //
    Dobj_Draw(hdc, &dobj, 1, lpcdis->itemState, 0, this->cyText, this->clrBkgnd);
    
    // Clean up
    //
    SetViewportOrgEx(hdc, ptSav.x, ptSav.y, NULL);
    }


/*----------------------------------------------------------
Purpose: WM_DRAWITEM handler
Returns: --
Cond:    --
*/
void PRIVATE RecAct_OnDrawItem(
    LPRECACT this,
    const DRAWITEMSTRUCT FAR * lpcdis)
    {
    switch (lpcdis->CtlType)
        {
    case ODT_LISTBOX:
        RecAct_DrawLBItem(this, lpcdis);
        break;

    case ODT_MENU:
        RecAct_DrawMenuItem(this, lpcdis);
        break;
        }
    }


/*----------------------------------------------------------
Purpose: WM_COMPAREITEM handler
Returns: -1 (item 1 precedes item 2), 0 (equal), 1 (item 2 precedes item 1)
Cond:    --
*/
int PRIVATE RecAct_OnCompareItem(
    LPRECACT this,
    const COMPAREITEMSTRUCT FAR * lpcis)
    {
    LPRA_PRIV ppriv1 = (LPRA_PRIV)lpcis->itemData1;
    LPRA_PRIV ppriv2 = (LPRA_PRIV)lpcis->itemData2;

    // We sort based on name of file
    //
    return lstrcmpi(FIGetPath(ppriv1->pfi), FIGetPath(ppriv2->pfi));
    }


/*----------------------------------------------------------
Purpose: WM_DELETEITEM handler
Returns: --
Cond:    --
*/
void RecAct_OnDeleteLBItem(
    LPRECACT this,
    const DELETEITEMSTRUCT FAR * lpcdis)
    {
    switch (lpcdis->CtlType)
        {
    case ODT_LISTBOX:
        {
        LPRA_PRIV ppriv = (LPRA_PRIV)lpcdis->itemData;
        
        ASSERT(ppriv);
    
        if (ppriv)
            {
            FIFree(ppriv->pfi);

            GFree(ppriv->siInside.pszDir);
            GFree(ppriv->siOutside.pszDir);
            GFree(ppriv);
            }
        }
        break;
        }
    }


/*----------------------------------------------------------
Purpose: WM_CTLCOLORLISTBOX handler
Returns: --
Cond:    --
*/
HBRUSH PRIVATE RecAct_OnCtlColorListBox(
    LPRECACT this,
    HDC hdc,
    HWND hwndLB,
    int nType)
    {
    return this->hbrBkgnd;
    }


/*----------------------------------------------------------
Purpose: WM_PAINT handler
Returns: --
Cond:    --
*/
void RecAct_OnPaint(
    LPRECACT this)
    {
    HWND hwnd = this->hwnd;
    PAINTSTRUCT ps;
    RECT rc;
    HDC hdc;

    hdc = BeginPaint(hwnd, &ps);
    GetClientRect(hwnd, &rc);
    if (IsFlagSet(this->lStyle, RAS_SINGLEITEM))
        {
        DrawEdge(hdc, &rc, BDR_SUNKENINNER, BF_TOPLEFT);
        DrawEdge(hdc, &rc, BDR_SUNKENOUTER, BF_BOTTOMRIGHT);
        }
    else
        {
        DrawEdge(hdc, &rc, EDGE_SUNKEN, BF_RECT);
        }

    EndPaint(hwnd, &ps);
    }


/*----------------------------------------------------------
Purpose: WM_SETFONT handler
Returns: --
Cond:    --
*/
void RecAct_OnSetFont(
    LPRECACT this,
    HFONT hfont,
    BOOL bRedraw)
    {
    this->hfont = hfont;
    FORWARD_WM_SETFONT(this->hwnd, hfont, bRedraw, RecAct_DefProc);
    }


/*----------------------------------------------------------
Purpose: WM_SETFOCUS handler
Returns: --
Cond:    --
*/
void RecAct_OnSetFocus(
    LPRECACT this,
    HWND hwndOldFocus)
    {
    SetFocus(this->hwndLB);
    }


/*----------------------------------------------------------
Purpose: WM_SYSCOLORCHANGE handler
Returns: --
Cond:    --
*/
void RecAct_OnSysColorChange(
    LPRECACT this)
    {
    RecAct_SetColors(this);
    InvalidateRect(this->hwnd, NULL, TRUE);
    }


/*----------------------------------------------------------
Purpose: Insert item
Returns: index
Cond:    --
*/
int PRIVATE RecAct_OnInsertItem(
    LPRECACT this,
    const LPRA_ITEM pitem)
    {
    HWND hwndLB = this->hwndLB;
    LPRA_PRIV pprivNew;
    char szPath[MAXPATHLEN];
    int iRet = -1;
    int iItem = LB_ERR;

    ASSERT(pitem);
    ASSERT(pitem->siInside.pszDir);
    ASSERT(pitem->siOutside.pszDir);
    ASSERT(pitem->pszName);

    pprivNew = GAlloc(sizeof(*pprivNew));
    if (pprivNew)
        {
        SetWindowRedraw(hwndLB, FALSE);

        // Fill the prerequisite fields first
        //
        pprivNew->uStyle = pitem->uStyle;
        pprivNew->uAction = pitem->uAction;

        // Set the fileinfo stuff and large icon system-cache index.
        //  If we can't get the fileinfo of the inside file, get the outside
        //  file.  If neither can be found, then we fail
        //
        lstrcpy(szPath, pitem->siInside.pszDir);
        if (IsFlagClear(pitem->uStyle, RAIS_FOLDER))
            PathAppend(szPath, pitem->pszName);
        PathMakePresentable(szPath);

        if (FAILED(FICreate(szPath, &pprivNew->pfi, FIF_ICON)))
            {
            // Try the outside file
            //
            lstrcpy(szPath, pitem->siOutside.pszDir);
            if (IsFlagClear(pitem->uStyle, RAIS_FOLDER))
                PathAppend(szPath, pitem->pszName);
            PathMakePresentable(szPath);

            if (FAILED(FICreate(szPath, &pprivNew->pfi, FIF_ICON)))
                {
                // Don't try to touch the file
                if (FAILED(FICreate(szPath, &pprivNew->pfi, FIF_ICON | FIF_DONTTOUCH)))
                    goto Insert_Cleanup;
                }
            }
        ASSERT(pprivNew->pfi);

        pprivNew->pfi->lParam = (LPARAM)ImageList_AddIcon(this->himlCache, pprivNew->pfi->hicon);

        // Fill in the rest of the fields
        //
        lstrcpy(szPath, pitem->siInside.pszDir);
        if (IsFlagSet(pitem->uStyle, RAIS_FOLDER))
            PathRemoveFileSpec(szPath);
        PathMakePresentable(szPath);
        if (!GSetString(&pprivNew->siInside.pszDir, szPath))
            goto Insert_Cleanup;

        pprivNew->siInside.uState = pitem->siInside.uState;
        pprivNew->siInside.fs = pitem->siInside.fs;

        lstrcpy(szPath, pitem->siOutside.pszDir);
        if (IsFlagSet(pitem->uStyle, RAIS_FOLDER))
            PathRemoveFileSpec(szPath);
        PathMakePresentable(szPath);
        if (!GSetString(&pprivNew->siOutside.pszDir, szPath))
            goto Insert_Cleanup;

        pprivNew->siOutside.uState = pitem->siOutside.uState;
        pprivNew->siOutside.fs = pitem->siOutside.fs;

        pprivNew->lParam = pitem->lParam;

        pprivNew->cx = RECOMPUTE;

        // We know we're doing a redundant sorted add if the element
        //  needs to be inserted at the end of the list, but who cares.
        //
        if (pitem->iItem >= RecAct_GetCount(this))
            iItem = ListBox_AddString(hwndLB, pprivNew);
        else
            iItem = ListBox_InsertString(hwndLB, pitem->iItem, pprivNew);
        
        if (iItem == LB_ERR)
            goto Insert_Cleanup;

        SetWindowRedraw(hwndLB, TRUE);

        iRet = iItem;
        }
    goto Insert_End;

Insert_Cleanup:
    // Have DeleteString handler clean up field allocations
    //  of pitem.
    //
    if (iItem != LB_ERR)
        ListBox_DeleteString(hwndLB, iItem);
    else
        {
        FIFree(pprivNew->pfi);
        GFree(pprivNew);
        }
    SetWindowRedraw(hwndLB, TRUE);
    
Insert_End:

    return iRet;
    }


/*----------------------------------------------------------
Purpose: Delete item
Returns: count of items left
Cond:    --
*/
int PRIVATE RecAct_OnDeleteItem(
    LPRECACT this,
    int i)
    {
    HWND hwndLB = this->hwndLB;
    
    return ListBox_DeleteString(hwndLB, i);
    }


/*----------------------------------------------------------
Purpose: Delete all items
Returns: TRUE 
Cond:    --
*/
BOOL PRIVATE RecAct_OnDeleteAllItems(
    LPRECACT this)
    {
    ListBox_ResetContent(this->hwndLB);
    
    return TRUE;
    }


/*----------------------------------------------------------
Purpose: Get item
Returns: TRUE on success
Cond:    --
*/
BOOL PRIVATE RecAct_OnGetItem(
    LPRECACT this,
    LPRA_ITEM pitem)
    {
    LPRA_PRIV ppriv;
    HWND hwndLB = this->hwndLB;
    UINT uMask;
    int iItem;
    
    if (!pitem)
        return FALSE;
    
    iItem = pitem->iItem;
    uMask = pitem->mask;
    
    ListBox_GetText(hwndLB, iItem, &ppriv);
    
    if (uMask & RAIF_ACTION)
        pitem->uAction = ppriv->uAction;
    
    if (uMask & RAIF_NAME)
        pitem->pszName = FIGetPath(ppriv->pfi);
    
    if (uMask & RAIF_STYLE)
        pitem->uStyle = ppriv->uStyle;
    
    if (uMask & RAIF_INSIDE)
        pitem->siInside = ppriv->siInside;
    
    if (uMask & RAIF_OUTSIDE)
        pitem->siOutside = ppriv->siOutside;
    
    if (uMask & RAIF_LPARAM)
        pitem->lParam = ppriv->lParam;
    
    return TRUE;
    }


/*----------------------------------------------------------
Purpose: Set item
Returns: TRUE on success
Cond:    --
*/
BOOL PRIVATE RecAct_OnSetItem(
    LPRECACT this,
    LPRA_ITEM pitem)
    {
    LPRA_PRIV ppriv;
    HWND hwndLB = this->hwndLB;
    UINT uMask;
    int iItem;

    if (!pitem)
        return FALSE;
    
    uMask = pitem->mask;
    iItem = pitem->iItem;
    
    ListBox_GetText(hwndLB, iItem, &ppriv);
    
    if (uMask & RAIF_ACTION)
        ppriv->uAction = pitem->uAction;
    
    if (uMask & RAIF_STYLE)
        ppriv->uStyle = pitem->uStyle;
    
    if (uMask & RAIF_NAME)
        {
        if (!FISetPath(&ppriv->pfi, pitem->pszName, FIF_ICON))
            return FALSE;

        ppriv->pfi->lParam = (LPARAM)ImageList_AddIcon(this->himlCache, ppriv->pfi->hicon);
        }
    
    if (uMask & RAIF_INSIDE)
        {
        if (!GSetString(&ppriv->siInside.pszDir, pitem->siInside.pszDir))
            return FALSE;
        ppriv->siInside.uState = pitem->siInside.uState;
        ppriv->siInside.fs = pitem->siInside.fs;
        }
    
    if (uMask & RAIF_OUTSIDE)
        {
        if (!GSetString(&ppriv->siOutside.pszDir, pitem->siOutside.pszDir))
            return FALSE;
        ppriv->siOutside.uState = pitem->siOutside.uState;
        ppriv->siOutside.fs = pitem->siOutside.fs;
        }
    
    if (uMask & RAIF_LPARAM)
        ppriv->lParam = pitem->lParam;
    
    return TRUE;
    }


/*----------------------------------------------------------
Purpose: Get the current selection
Returns: index
Cond:    --
*/
int PRIVATE RecAct_OnGetCurSel(
    LPRECACT this)
    {
    return ListBox_GetCurSel(this->hwndLB);
    }


/*----------------------------------------------------------
Purpose: Set the current selection
Returns: --
Cond:    --
*/
int PRIVATE RecAct_OnSetCurSel(
    LPRECACT this,
    int i)
    {
    int iRet = ListBox_SetCurSel(this->hwndLB, i);

    if (iRet != LB_ERR)
        RecAct_SendSelChange(this, i);

    return iRet;
    }


/*----------------------------------------------------------
Purpose: Find an item
Returns: TRUE on success
Cond:    --
*/
int PRIVATE RecAct_OnFindItem(
    LPRECACT this,
    int iStart,
    const RA_FINDITEM FAR * prafi)
    {
    HWND hwndLB = this->hwndLB;
    UINT uMask = prafi->flags;
    LPRA_PRIV ppriv;
    BOOL bPass;
    int i;
    int cItems = ListBox_GetCount(hwndLB);

    for (i = iStart+1; i < cItems; i++)
        {
        bPass = TRUE;       // assume we pass

        ListBox_GetText(hwndLB, i, &ppriv);

        if (uMask & RAFI_NAME &&
            !IsSzEqual(FIGetPath(ppriv->pfi), prafi->psz))
            bPass = FALSE;

        if (uMask & RAFI_ACTION && ppriv->uAction != prafi->uAction)
            bPass = FALSE;

        if (uMask & RAFI_LPARAM && ppriv->lParam != prafi->lParam)
            bPass = FALSE;

        if (bPass)
            break;          // found it
        }

    return i == cItems ? -1 : i;
    }


/////////////////////////////////////////////////////  EXPORTED FUNCTIONS


/*----------------------------------------------------------
Purpose: RecAct window proc
Returns: varies
Cond:    --
*/
LRESULT CALLBACK RecAct_WndProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
    {
    LPRECACT this = RecAct_GetPtr(hwnd);
    
    if (this == NULL)
        {
        if (msg == WM_NCCREATE)
            {
            this = GAlloc(sizeof(*this));
            ASSERT(this);
            if (!this)
                return 0L;      // OOM failure
            
            this->hwnd = hwnd;
            RecAct_SetPtr(hwnd, this);
            }
        else
            {
            return RecAct_DefProc(hwnd, msg, wParam, lParam);
            }
        }

    if (msg == WM_NCDESTROY)
        {
        GFree(this);
        RecAct_SetPtr(hwnd, NULL);
        }

    switch (msg)
        {
        HANDLE_MSG(this, WM_CREATE, RecAct_OnCreate);
        HANDLE_MSG(this, WM_DESTROY, RecAct_OnDestroy);
        
        HANDLE_MSG(this, WM_SETFONT, RecAct_OnSetFont);
        HANDLE_MSG(this, WM_COMMAND, RecAct_OnCommand);
        HANDLE_MSG(this, WM_NOTIFY, RecAct_OnNotify);
        HANDLE_MSG(this, WM_MEASUREITEM, RecAct_OnMeasureItem);
        HANDLE_MSG(this, WM_DRAWITEM, RecAct_OnDrawItem);
        HANDLE_MSG(this, WM_COMPAREITEM, RecAct_OnCompareItem);
        HANDLE_MSG(this, WM_DELETEITEM, RecAct_OnDeleteLBItem);
        HANDLE_MSG(this, WM_CONTEXTMENU, RecAct_OnContextMenu);
        HANDLE_MSG(this, WM_SETFOCUS, RecAct_OnSetFocus);
        HANDLE_MSG(this, WM_CTLCOLORLISTBOX, RecAct_OnCtlColorListBox);
        HANDLE_MSG(this, WM_PAINT, RecAct_OnPaint);
        HANDLE_MSG(this, WM_SYSCOLORCHANGE, RecAct_OnSysColorChange);

	case RAM_GETITEMCOUNT:
		return (LRESULT)RecAct_GetCount(this);

	case RAM_GETITEM:
		return (LRESULT)RecAct_OnGetItem(this, (LPRA_ITEM)lParam);

	case RAM_SETITEM:
		return (LRESULT)RecAct_OnSetItem(this, (const LPRA_ITEM)lParam);

	case RAM_INSERTITEM:
		return (LRESULT)RecAct_OnInsertItem(this, (const LPRA_ITEM)lParam);

	case RAM_DELETEITEM:
		return (LRESULT)RecAct_OnDeleteItem(this, (int)wParam);

	case RAM_DELETEALLITEMS:
		return (LRESULT)RecAct_OnDeleteAllItems(this);

	case RAM_GETCURSEL:
		return (LRESULT)RecAct_OnGetCurSel(this);

	case RAM_SETCURSEL:
		return (LRESULT)RecAct_OnSetCurSel(this, (int)wParam);

	case RAM_FINDITEM:
		return (LRESULT)RecAct_OnFindItem(this, (int)wParam, (const RA_FINDITEM FAR *)lParam);

	case RAM_REFRESH:
		RedrawWindow(this->hwndLB, NULL, NULL, RDW_ERASE | RDW_INVALIDATE);

	default:
		return RecAct_DefProc(hwnd, msg, wParam, lParam);
		}
	}


/////////////////////////////////////////////////////  PUBLIC FUNCTIONS


/*----------------------------------------------------------
Purpose: Initialize the reconciliation-action window class
Returns: TRUE on success
Cond:    --
*/
BOOL PUBLIC RecAct_Init(HINSTANCE hinst)
{
	WNDCLASSEX wc;

	wc.cbSize       = sizeof(WNDCLASSEX);
	wc.style        = CS_DBLCLKS | CS_OWNDC;
	wc.lpfnWndProc  = RecAct_WndProc;
	wc.cbClsExtra   = 0;
	wc.cbWndExtra   = sizeof(LPRECACT);
	wc.hInstance    = hinst;
	wc.hIcon        = NULL;
	wc.hCursor      = LoadCursor(NULL, IDC_ARROW);
	wc.hbrBackground= NULL;
	wc.lpszMenuName = NULL;
	wc.lpszClassName= WC_RECACT;
	wc.hIconSm      = NULL;

	return (RegisterClassEx(&wc) != 0);
}


/*----------------------------------------------------------
Purpose: Clean up RecAct window class
Returns: --
Cond:    --
*/
void PUBLIC RecAct_Term(
								HINSTANCE hinst)
{
	UnregisterClass(WC_RECACT, hinst);
}


/*----------------------------------------------------------
Purpose: Special sub-class listbox proc 
Returns: varies
Cond:    --
*/
LRESULT _export CALLBACK RecActLB_LBProc(
													  HWND hwnd,          // window handle
													  UINT msg,           // window message
													  WPARAM wparam,      // varies
													  LPARAM lparam)      // varies
{
	LRESULT lRet;
	LPRECACT lpra = NULL;

	// Get the instance data for the control
	lpra = RecAct_GetPtr(GetParent(hwnd));
	ASSERT(lpra);

	switch (msg)
	{
		default:
			lRet = RecActLB_DefProc(lpra->lpfnLBProc, hwnd, msg, wparam, lparam);
			break;
	}

	return lRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\usermode\reint\recon.h ===
// Reconnect Dialog and friends

#ifndef __RECONH
#define __RECONH

extern HANDLE vhinstCur;			// current instance from reint.c
BOOL CALLBACK Recon_DlgProc(
    HWND  hwndDlg,
    UINT  uMsg,
    WPARAM  wParam,
    LPARAM  lParam);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\usermode\reint\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by reint.rc
//
#define menuAllApis                     0
#define menuMain                        1
#define IDS_SHADOW_SW_ERR               1
#define IDS_SHADOW_AGENT                2
#define IDM_CONTEXT_MENU                2
#define IDM_TRAY_MERGE                  103
#define IDM_TRAY_FILL_SHADOW            104
#define IDM_SHADOW_LOG                  105
#define IDM_SHADOWING                   106
#define IDM_TRAY_FREE_SPACE             107
#define IDM_MERGE_DIALOG                108
#define IDM_TRAY_FORCE_LOG              108
#define IDM_LOGON						109
#define IDM_LOGOFF						110


#define IDD_MERGE_LIST                  109
#define IDC_RECACTION                   110
#define IDB_ACTIONS                     111
#define IDI_LEATHER_BRIEF               120
#define IDI_METAL_BRIEF                 121
#define IDI_SPLIT_FILE                  122
#define IDI_SPLIT_FOLDER                123
#define IDI_SPLIT_MULT                  124
#define IDI_UPDATE_FILE                 125
#define IDI_UPDATE_FOLDER               126
#define IDI_UPDATE_MULT                 127
#define IDI_UPDATE_DOCK                 128
#define IDI_ADD_FOLDER                  129
#define IDI_REPLACE_FILE                130
#define IDI_REPLACE_FOLDER              131
#define IDI_UPDATE                      132
#define IDI_OPEN_FOLDER                 133
#define IDI_OLD_IDLE                    134
#define IDI_OLD_FILL                    135
#define IDI_OLD_MERGE                   136
#define miLogCopying                    140

#define IDD_DIALOG1                     140
#define IDM_LOG_COPYING_ON              140
#define IDM_LOG_COPYING                 140
#define miSpeadOpt                      141
#define IDM_SPEED_OPT                   141
#define IDD_DIALOG2                     142
#define IDI_FILL                        142
#define IDM_FILL_SHADOW                 143
#define IDI_MERGE                       143
#define IDD_SHARES_RECONNECT            143
#define miUpdate                        144
#define IDM_FREE_SPACE                  144
#define IDI_NETTRACKER                  144
#define IDM_FORCE_LOG_COPY              145
#define IDI_IDLE                        145
#define IDM_LOG_ON                      146
#define IDM_SHADOW_ON                   147
#define IDM_LOG_COPY_ON                 148
#define IDM_OPTIMIZE                    149
#define IDM_PROPERTIES                  150
#define IDM_REFRESH_CONNECTIONS         151
#define IDM_BREAK_CONNECTIONS           152
#define IDC_MERGE_TEXT					153

#define iconReint                       300
#define IDC_SHARE_NAME                  1000
#define ID_BASE                         0x2000
#define IDS_MENU_REPLACE                14336
#define IDS_MENU_CREATE                 14337
#define IDS_MENU_WHATSTHIS              14338
#define IDS_MENU_UPDATE                 14340
#define IDS_MENU_UPDATEALL              14341
#define IDS_MENU_SKIP                   14342
#define IDS_MENU_MERGE                  14343
#define IDS_InLocation                  14609
#define IDS_InBriefcase                 14610
#define IDS_BYTES                       14611
#define IDS_BOGUSDBTEMPLATE             14612
#define IDS_BC_DATABASE                 14613
#define IDS_BC_NAME                     14614
#define IDS_DATESIZELINE                14615
#define IDS_ORDERKB                     14616
#define IDS_ORDERMB                     14617
#define IDS_ORDERGB                     14618
#define IDS_ORDERTB                     14619
#define IDS_BC_DATABASE_SHORT           14620
#define IDS_BC_NAME_SHORT               14621
#define IDS_ALTNAME                     14622
#define IDS_STATE_Creates               15360
#define IDS_STATE_Replaces              15361
#define IDS_STATE_Skip                  15362
#define IDS_STATE_Conflict              15363
#define IDS_STATE_Merge                 15364
#define IDS_STATE_Uptodate              15365
#define IDS_STATE_NeedToUpdate          15366
#define IDS_STATE_Orphan                15367
#define IDS_STATE_Subfolder             15368
#define IDS_STATE_Changed               15369
#define IDS_STATE_Unchanged             15370
#define IDS_STATE_NewFile               15371
#define IDS_STATE_Unavailable           15372
#define IDS_STATE_UptodateInBrf         15373
#define IDS_STATE_SystemFile            15374
#define IDS_NEEDS_REINT                 15375
#define IDS_ATTEMPTING_RECONNECT        15376
#define IDS_DONE_RECONNECT              15377
#define IDS_NEW_LOGON                   15378
#define IDS_CREATE_CONFLICT             15379
#define IDS_DELETE_CONFLICT             15380
#define IDS_UPDATE_CONFLICT             15381
#define IDS_ATTRIBUTE_CONFLICT          15382
#define IDS_OPS_IN_PROGRESS             15383
#define IDS_TIP_MERGE_REQUIRED          15384
#define	IDS_MERGING_SHARE				15385
#define IDS_NETS_ARRIVING				15386
#define IDS_INITING_OFFLINE_NET 		15387
#define	IDS_FILLING_BEFORE_OFFLINE		15388
#define IDS_DB_CREATION_FAILED          15389
#define IDS_DB_UPGRADE_FAILED           15390
#define IDS_CSC_ENABLE_FAILED           15391

#define IDC_STATIC                      -1

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        146
#define _APS_NEXT_COMMAND_VALUE         151
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           140
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\usermode\reint\reint.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    reint.c

Abstract:

    This file contains the fill and merge functions necessary for bot inward and outward
    synchronization of files and directories. It also contains generic database tree-traversal
    code. This is used by merge as well as DoLocalRename API.


    Tree Traversal:
    
        TraverseOneDirectory    // traverses a subtree in the database
        
    Fill Functions:
    
        AttemptCacheFill    Fills the entire cache or a particular share
        DoSparseFill        Fills a particular file
    
    Merge Functions:
    
        ReintOneShare       // reintegrate one share
        ReintAllShares      // reintegrate all shares



Author:
    Trent-Gray-Donald/Shishir Pardikar


Environment:

    Win32 (user-mode) DLL

Revision History:

    1-1-94    original
    4-4-97  removed all the entry points to exports.c
    reint.c

--*/

#include "pch.h"

#pragma hdrstop
#define UNICODE

#ifndef DEBUG
#undef VERBOSE
#else
#undef VERBOSE
#define VERBOSE 1
#endif

#include <winioctl.h>

#include "lib3.h"
#include "shdsys.h"
#include "reint.h"
#include "utils.h"
#include "resource.h"
#include "traynoti.h"
#include <dbt.h>
#include "strings.h"

#include "csc_bmpu.h"

// this sets flags in a couple of headers to not include some defs.
#define REINT
#include "list.h"
#include "merge.h"
#include "recact.h"
#include "recon.h"  // reconnect shares dialog
#include "reint.h"
#include "aclapi.h"

//
// Defines
//

#define chNull '\0'    // terminator

#define BUFF_SIZE 64


#define MAX_WAIT_PERIODS       1
#define MAX_ATTEMPTS           1

#define MAX_ATTEMPTS_SHARE    1
#define MAX_ATTEMPTS_SHADOW    5
#define MAX_SPARSE_FILL_RETRIES 4



#define  STATE_REINT_BEGIN    0

#define  STATE_REINT_CREATE_DIRS    STATE_REINT_BEGIN
#define  STATE_REINT_FILES          (STATE_REINT_CREATE_DIRS+1)
#define  STATE_REINT_END            (STATE_REINT_FILES+1)

#define  MAX_EXCLUSION_STRING 1024


// for some Registry queries, this is the max len buffer that I want back
#define MAX_NAME_LEN    100

#define MY_SZ_TRUE _TEXT("true")
#define MY_SZ_FALSE _TEXT("false")
#define  SLOWLINK_SPEED 400   // in 100 bitspersec units
// NB!!! these defines cannot be changed they are in the order in which
// reintegration must proceed

#define REINT_DELETE_FILES  0
#define REINT_DELETE_DIRS   1
#define REINT_CREATE_UPDATE_DIRS   2
#define REINT_CREATE_UPDATE_FILES  3


typedef struct tagREINT_INFO {

    int nCurrentState;  // 0->deleting files, 1->deleting directories, 2->creating directoires
                        // 3 ->creating files
    node *lpnodeInsertList; // reint errors

    LPCSCPROC   lpfnMergeProgress;

    DWORD_PTR   dwContext;
    DWORD       dwFileSystemFlags;  // From GetVolumeInformation, used to set ACCLs etc. if the
                                    // share is hosted on NTFS
    HSHARE      hShare;            // handle to the share being reintegrated
    ULONG       ulPrincipalID;
    _TCHAR      tzDrive[4];         // mapped drive to the remote path

} REINT_INFO, *LPREINT_INFO;


#define SPARSEFILL_SLEEP_TIME_FOR_WIN95         2000    // two seconds
#define MAX_SPARSEFILL_SLEEP_TIME_FOR_WIN95     2 * 60 * 100    // two minutes


#define DFS_ROOT_FILE_SYSTEM_FLAGS 0xffffffff

//
// Variables Global/Local
//

_TCHAR  *vlpExclusionList = NULL;
REINT_INFO  vsRei;  // global reint structure. NTRAID-455269-shishirp-1/31/2000 we should make this into a list
                    // in order to allow multiple reintegrations on various shares


unsigned long   ulMinSparseFillPri = MIN_SPARSEFILL_PRI;
int     cntDelay=0;
HANDLE  vhShadow=NULL;
BOOL    vfTimerON = FALSE, vfAutoDeleteOrphans=TRUE;
char    vrgchBuff[1024], vrwBuff[4096], vrgchSrcName[350], vrgchDstName[300];
unsigned    vcntDirty=0, vcntStale=0, vcntSparse=0, vcntWaitDirty=0;
LPFAILINFO  lpheadFI = NULL;
HCURSOR     vhcursor=NULL;

BOOL    vfLogCopying=TRUE;

LPCONNECTINFO   vlpLogonConnectList = NULL;

BOOL    vfNeedPQTraversal = TRUE;
DWORD   vdwSparseStaleDetectionCounter = 0;


_TCHAR vrgchCRLF[] = _TEXT("\r\n");
_TCHAR tzStarDotStar[] = _TEXT("*");
#pragma data_seg(DATASEG_READONLY)

ERRMSG rgErrorTab[] =
{
    ERROR_CREATE_CONFLICT, IDS_CREATE_CONFLICT

   ,ERROR_DELETE_CONFLICT, IDS_DELETE_CONFLICT

   ,ERROR_UPDATE_CONFLICT, IDS_UPDATE_CONFLICT

   ,ERROR_ATTRIBUTE_CONFLICT, IDS_ATTRIBUTE_CONFLICT

};


static const _TCHAR vszMachineName[]= _TEXT("System\\CurrentControlSet\\Control\\ComputerName\\ComputerName");
static const _TCHAR vszComputerName[]=_TEXT("ComputerName");
static const _TCHAR vszLogUNCPath[]=_TEXT("\\\\scratch\\scratch\\t-trentg\\logs\\");
static const _TCHAR vszLogShare[]=_TEXT("\\\\scratch\\scratch");
static const _TCHAR vszLocalLogPath[]=_TEXT("c:\\shadow.log");
static const _TCHAR vszConflictDir[]=_TEXT("C:\\ConflictsWhileMerging");

#pragma data_seg()

AssertData;
AssertError;




//
// Local prototypes
//



BOOL
CheckForStalenessAndRefresh(
    HANDLE          hShadowDB,
    _TCHAR          *lptzDrive,
    LPCOPYPARAMS    lpCP,
    _TCHAR *        lpszFullPath,
    LPSHADOWINFO    lpSI
    );

BOOL
StalenessCheck(
    BOOL hasBeenInited
    );

VOID
GetLogCopyStatus(
    VOID
    );

VOID
CopyLogToShare(
    VOID
    );

VOID
AppendToShareLog(
    HANDLE hLog
    );


int
PRIVATE
AttemptReint(
    int forceLevel
    );

VOID
PRIVATE
AddToReintList(
    LPCOPYPARAMS lpCP,
    LPSHADOWINFO lpSI,
    _TCHAR *szFileName
    );

DWORD
PRIVATE
DoObjectEdit(
    HANDLE                hShadowDB,
    _TCHAR *               lpDrive,
    _TCHAR *            lptzFullPath,
    LPCOPYPARAMS        lpCP,
    LPSHADOWINFO        lpSI,
    LPWIN32_FIND_DATA    lpFind32Local,
    LPWIN32_FIND_DATA    lpFind32Remote,
    int         iShadowStatus,
    int         iFileStatus,
    int         uAction,
    DWORD       dwFileSystemFlags,
    LPCSCPROC   lpfnMergeProc,
    DWORD_PTR   dwContext
    );

DWORD
PRIVATE
DoCreateDir(
    HANDLE                hShadowDB,
    _TCHAR *               lpDrive,
    _TCHAR *            lptzFullPath,
    LPCOPYPARAMS        lpCP,
    LPSHADOWINFO        lpSI,
    LPWIN32_FIND_DATA    lpFind32Local,
    LPWIN32_FIND_DATA    lpFind32Remote,
    int         iShadowStatus,
    int         iFileStatus,
    int         uAction,
    DWORD       dwFileSystemFlags,
    LPCSCPROC   lpfnMergeProc,
    DWORD_PTR   dwContext
    );

DWORD
PRIVATE
CheckFileConflict(
    LPSHADOWINFO,
    LPWIN32_FIND_DATA
    );

BOOL
FCheckAncestor(
    node *lpnodeList,
    LPCOPYPARAMS lpCP
    );

int
PRIVATE
StampReintLog(
    VOID
    );

int
PRIVATE
LogReintError(
    DWORD,
    _TCHAR *,
    _TCHAR *);

int
PRIVATE
WriteLog(
    _TCHAR *
    );

DWORD
PRIVATE
MoveConflictingFile(
    LPCOPYPARAMS
    );

DWORD
PRIVATE
GetUniqueName(
    _TCHAR *,
    _TCHAR *
    );

VOID
PRIVATE
FormLocalNameFromRemoteName(
    _TCHAR *,
    _TCHAR *
    );

DWORD
PRIVATE
InbCreateDir(
    _TCHAR *     lpDir,
    DWORD    dwAttr
    );

int
PRIVATE
GetShadowByName(
    HSHADOW,
    _TCHAR *,
    LPWIN32_FIND_DATA,
    unsigned long *
    );

_TCHAR *
PRIVATE
LpGetExclusionList(
    VOID
    );

VOID
PRIVATE
ReleaseExclusionList(
    LPVOID
    );


int
PRIVATE
DisplayMessageBox(
    HWND,
    int,
    int,
    UINT
    );

BOOL
PRIVATE
FSkipObject(
    HSHARE,
    HSHADOW,
    HSHADOW
    );

int
PRIVATE
PurgeSkipQueue(
    BOOL,
    HSHARE,
    HSHADOW,
    HSHADOW
    );

LPFAILINFO FAR *
LplpFindFailInfo(
    HSHARE,
    HSHADOW,
    HSHADOW
    );

VOID
PRIVATE
ReportStats(
    VOID
    );

VOID
PRIVATE
CopyPQInfoToShadowInfo(
    LPPQPARAMS,
    LPSHADOWINFO
    );

BOOL
PRIVATE
IsSlowLink(
    _TCHAR *
    );

VOID
PRIVATE
InferReplicaReintStatus(
    LPSHADOWINFO         lpSI,
    LPWIN32_FIND_DATA    lpFind32Local,    // shadow info
    LPWIN32_FIND_DATA     lpFind32Remote,    // if NULL, the remote doesn't exist
    int                 *lpiShadowStatus,
    int                 *lpiFileStatus,
    unsigned             *lpuAction
    );

BOOL
GetRemoteWin32Info(
    _TCHAR  *lptzDrive,
    LPCOPYPARAMS lpCP,
    LPWIN32_FIND_DATA    lpFind32,
    BOOL *lpfExists
    );

BOOL
PRIVATE
PerformOneReint(
    HANDLE              hShadowDB,
    LPSECURITYINFO      pShareSecurityInfo,
    _TCHAR *            lpszDrive,          // drive mapped to the UNC name of lpSI->hShare
    _TCHAR *            lptzFullPath,       // full UNC path
    LPCOPYPARAMS        lpCP,               // copy parameters
    LPSHADOWINFO        lpSI,               // shadowinfo structure
    LPWIN32_FIND_DATA   lpFind32Local,      // local win32 data
    LPWIN32_FIND_DATA   lpFind32Remote,     // remote win32 data, could be NULL
    DWORD               dwErrorRemoteFind32,// error code while getting remote win32 data
    int                 iShadowStatus,      // local copy status
    int                 iFileStatus,        // remote file status
    unsigned            uAction,            // action to be taken
    DWORD               dwFileSystemFlags,  // CODE.IMPROVEMENT, why not just pass down REINT_INFO
    ULONG               ulPrincipalID,
    LPCSCPROC           lpfnMergeProgress,  // instead of the three parameters?
    DWORD_PTR           dwContext
    );

ImpersonateALoggedOnUser(
    VOID
    );

HANDLE
CreateTmpFileWithSourceAcls(
    _TCHAR  *lptzSrc,
    _TCHAR  *lptzDst
    );

BOOL
HasMultipleStreams(
    _TCHAR  *lpExistingFileName,
    BOOL    *lpfTrueFalse
    );

int
PRIVATE
CALLBACK
RefreshProc(
    LPCONNECTINFO  lpCI,
    DWORD          dwCookie // LOWORD 0==Silently, 1== Give messages
                           // HIWORD 0==Nuke UNC, 1==Nuke all if no ongoing open/finds
                           // 2==Maximum force for shadow 3==Nuke ALL
    );

int
CALLBACK
CheckDirtyMessage(
    int cntDrvMapped,
    DWORD dwCookie
    );



int
CALLBACK
CheckDirtyMessage(
    int cntDrvMapped,
    DWORD dwCookie
    )
/*++

Routine Description:

    Legacy code, used to be used in win9x implementation

Arguments:


Returns:


Notes:

--*/
{
    dwCookie;
    if (vhwndMain){

    if (CheckDirtyShares()) {
        DisplayMessageBox(vhwndMain, IDS_NEEDS_REINT, IDS_SHADOW_AGENT, MB_OK);
        return 1;
        }
    }
   return 0;
}

BOOL
CALLBACK
ShdLogonProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
/*++

Routine Description:

    Legacy code, used to be used in win9x implementation

Arguments:


Returns:


Notes:

--*/
{
    switch(msg)
    {
        case WM_INITDIALOG:
            return TRUE;
    }
    return 0;
}

/**************************** Fill routines *********************************/

int
AttemptCacheFill (
    HSHARE      hShareToSync,
    int         type,
    BOOL        fFullSync,
    ULONG       ulPrincipalID,
    LPCSCPROC   lpfnFillProgress,
    DWORD_PTR   dwContext
    )
/*++

Routine Description:

    Routine called by the agent and the fill API to do filling on a share.

Arguments:

    hShareToSync        Represnts the share to fill. If 0, fill all shares

    type                DO_ONE or DO_ALL. No one sets it to DO_ONE anymore

    fFullSync           if TRUE, we do a staleness check as well
    
    ulPrincipalID       ID of the principal as maintained in the shadow database
                        used to avoid ssyncing files for which the currently logged
                        on user doesn't have access

    lpfnFillProgress    Callback function to report progress, can be NULL

    dwContext           Callback context


Returns:

    count of items done

Notes:

    

--*/
{
    PQPARAMS sPQP;
    BOOL fFound = FALSE, fFoundBusy = FALSE, fAmAgent=FALSE, fNeedImpersonation=FALSE, fInodeTransaction=FALSE;
    BOOL    fSparseStaleDetected = FALSE;
    SHADOWINFO  sSI;
    SHAREINFO  sSR;
    LPCOPYPARAMS lpCP = NULL;
    DWORD dwError = NO_ERROR, dwFillStartTick=0, dwCount=0, dwSleepCount=0, dwSparseStaleDetectionCounter=0xffff;
    HANDLE hShadowDB;
    int cntDone = 0;
    WIN32_FIND_DATA sFind32Local;
    _TCHAR szNameBuff[MAX_PATH+MAX_SERVER_SHARE_NAME_FOR_CSC+10], tzDrive[4];

    tzDrive[0] = 0;

    fAmAgent = (GetCurrentThreadId() == vdwCopyChunkThreadId);
    Assert(GetCurrentThreadId() != vdwAgentThreadId);

    // when the agent comes here to fill, if the vfNeedPQTraversal flag is set
    // we go ahead and traverse the priority Q.

    // Otherwise, we check with the record manager whether since the last time we looked
    // there has been any sparse or stale files encountered.

    // If what the agent gets from the record manager
    // is not the same as what the agent stored last time around
    // then we let him traverse the Q.

    // the whole idea here is to converse CPU cycles when
    // there is nothing to fill

    if (fAmAgent && !vfNeedPQTraversal)
    {
        GetSparseStaleDetectionCounter(INVALID_HANDLE_VALUE, &dwSparseStaleDetectionCounter);

        if (dwSparseStaleDetectionCounter == vdwSparseStaleDetectionCounter)
        {
            ReintKdPrint(FILL, ("Agent.fill: SparseStaleDetectionCounter =%d is unchanged, not filling\n", vdwSparseStaleDetectionCounter));
            return 0;
        }
        else
        {
            vfNeedPQTraversal = TRUE;
            vdwSparseStaleDetectionCounter = dwSparseStaleDetectionCounter;
            ReintKdPrint(FILL, ("**Agent.fill: SparseStaleDetectionCounter =%d is changed**\n", vdwSparseStaleDetectionCounter));
        }
    }

    if ((hShadowDB = OpenShadowDatabaseIO())==INVALID_HANDLE_VALUE)
    {
        goto bailout;
    }

    Assert(!(fFullSync && fAmAgent));


    lpCP = LpAllocCopyParams();

    if (!lpCP){
        ReintKdPrint(BADERRORS, ("Agent:Allocation of copyparam buffer failed\n"));
        goto bailout;
    }

    if (fFullSync && hShareToSync)
    {
        ULONG   ulStatus;
        BOOL    fIsDfsConnect;
        
        if(GetShareInfo(hShadowDB, hShareToSync, &sSR, &ulStatus)<= 0)
        {
            ReintKdPrint(BADERRORS, ("AttemptCacheFill: couldn't get status for server 0x%x\r\n", hShareToSync));
            goto bailout;
        }

        dwError = DWConnectNet(sSR.rgSharePath, tzDrive, NULL, NULL, NULL, CONNECT_INTERACTIVE, &fIsDfsConnect);

        if ((dwError != WN_SUCCESS) && (dwError != WN_CONNECTED_OTHER_PASSWORD) && (dwError != WN_CONNECTED_OTHER_PASSWORD_DEFAULT))
        {
            ReintKdPrint(BADERRORS, ("AttemptCacheFill: connect to %ls failed error=%d\r\n", sSR.rgSharePath, dwError));
            goto bailout;
        }
                
    }

    memset(&sPQP, 0, sizeof(PQPARAMS));
    memset(&sSI, 0, sizeof(SHADOWINFO));

    if (type == DO_ALL)
    {
        PurgeSkipQueue(TRUE, hShareToSync, 0, 0);
    }

    if(BeginPQEnum(hShadowDB, &sPQP) == 0) {
        goto bailout;
    }

    ReintKdPrint(FILL, ("Agent.fill:Started enumeration\n"));

    do {

        if (FAbortOperation())
        {
            cntDone = 0;
            goto bailout;
        }
        if (fInodeTransaction)
        {
            DoShadowMaintenance(hShadowDB, SHADOW_END_INODE_TRANSACTION);
            fInodeTransaction = FALSE;
        }
        if (fAmAgent)
        {
            Sleep(1);   // Yield on NT because we are winlogon
        }
        if(!DoShadowMaintenance(hShadowDB, SHADOW_BEGIN_INODE_TRANSACTION))
        {
            ReintKdPrint(BADERRORS, ("AttemptCacheFill: failed to begin inode transaction, aborting\n"));
            break;
        }

        fInodeTransaction = TRUE;
        if(NextPriShadow(hShadowDB, &sPQP) == 0) {
            break;
        }

        if (++dwCount > 100000)
        {
            ReintKdPrint(BADERRORS, ("AttemptCacheFill: Aborting, more than 100000 entries!!!\n"));
            break;
        }

        if (!sPQP.hShadow) {
            break;
        }

        if (fAmAgent && !fSparseStaleDetected &&
            ((mShadowIsFile(sPQP.ulStatus) && (sPQP.ulStatus & SHADOW_SPARSE)) || // sparse file
             (sPQP.ulStatus & SHADOW_STALE)))   // or stale file or dir
        {
            fSparseStaleDetected = TRUE;
        }

        if (!fFullSync && !(mShadowIsFile(sPQP.ulStatus) || (sPQP.ulStatus & SHADOW_STALE)))
        {
            continue;
        }

        if (hShareToSync && (hShareToSync != sPQP.hShare))
        {
            continue;
        }

        if (fAmAgent && FSkipObject(sPQP.hShare, 0, 0)){
            continue;
        }

        else if  (mShadowNeedReint(sPQP.ulStatus)||
                    mShadowOrphan(sPQP.ulStatus)||
                    mShadowSuspect(sPQP.ulStatus)){
            continue;
        }

        if (fAmAgent && FSkipObject(sPQP.hShare, sPQP.hDir, sPQP.hShadow)) {
            continue;
        }

        // If we are not doing full sync then do only sparse filling
        // or filling stale directories
        // otherwise we also want to update the attributes and timestamps on
        // the directories

        if (fFullSync || (sPQP.ulStatus & (SHADOW_STALE|SHADOW_SPARSE))){

            if (fAmAgent)
            {
                if (!hdesktopUser)
                {
                    if (!(sPQP.ulHintFlags & FLAG_CSC_HINT_PIN_SYSTEM))
                    {
                        ReintKdPrint(FILL, ("AttemptCacheFill: skipping fill till logon happens\n"));
                        continue;
                    }
                }
            }
            if (FAbortOperation())
            {
                cntDone = 0;
                goto bailout;
            }

            if (!GetShadowInfoEx(hShadowDB, sPQP.hDir, sPQP.hShadow,
                &sFind32Local, &sSI)){

                ReintKdPrint(BADERRORS, ("AttemptCacheFill: GetShadowInfoEx failed\n"));
                continue;
            }

            if (FAbortOperation())
            {
                cntDone = 0;
                goto bailout;
            }

            if(GetUNCPath(hShadowDB, sPQP.hShare, sPQP.hDir, sPQP.hShadow, lpCP)){

                // impersonate only if we are the agent and the file we are trying to 
                // bring down is not pinned for system. This was for remoteboot feature
                // which doesn't exist any more.

                fNeedImpersonation = (fAmAgent && !(sPQP.ulHintFlags & FLAG_CSC_HINT_PIN_SYSTEM));

                if (!fNeedImpersonation || 
                    (mShadowIsFile(sPQP.ulStatus) && SetAgentThreadImpersonation(sPQP.hDir, sPQP.hShadow, FALSE))||
                    (!mShadowIsFile(sPQP.ulStatus) && ImpersonateALoggedOnUser()))
                {
                    BOOL    fStalenessCheck;

                    // !!NB Stale must be dealt with first
                    // because a sparse shadow can become stale

                    // NB!!! we assume the limits because we know that
                    // the database handles only that much size

                    lstrcpy(szNameBuff, lpCP->lpSharePath);
                    lstrcat(szNameBuff, lpCP->lpRemotePath);

                    fStalenessCheck = (fFullSync || (sSI.uStatus & SHADOW_STALE));

                    if (fStalenessCheck || (sSI.uStatus & SHADOW_SPARSE)) {

                        dwError = DoSparseFill(hShadowDB, szNameBuff, tzDrive, &sSI, &sFind32Local, lpCP, fStalenessCheck, ulPrincipalID, lpfnFillProgress, dwContext);

                    }

                    if (fNeedImpersonation)
                    {
                        ResetAgentThreadImpersonation();
                    }

                    if (fAmAgent)
                    {
                        if (dwFillStartTick == 0)
                        {
                            dwFillStartTick = GetTickCount();
                            ReintKdPrint(FILL, ("AttemptCacheFill: start tick count is %d ms\r\n", dwFillStartTick));
                        }
                        else
                        {
                            Assert(type != DO_ALL);

                            // if we have been filling too long
                            // comeback later
                            if (((int)(GetTickCount() - (dwFillStartTick+dwSleepCount)) > WAIT_INTERVAL_ATTEMPT_MS/3))
                            {
                                ReintKdPrint(FILL, ("AttemptCacheFill: aborting, been filling for more than %d ms\r\n", WAIT_INTERVAL_ATTEMPT_MS/3));
                                break;
                            }

                        }
                        Sleep(200);
                        dwSleepCount+=200;
                    }
                }
                else
                {
                    Assert(fAmAgent);
                    Sleep(200);
                    dwSleepCount+=200;

                    // no one is allowed to read the entry
                    // go on to fill other things
                    continue;

                }

            }
            else
            {
                ReintKdPrint(BADERRORS, ("Agent: Shadow %08lx doesn't have an entry in the hierarchy \r\n", sPQP.hShadow));
                continue;
            }

            if (dwError == NO_ERROR) {

                cntDone += 1;
            }
#if 0
            if (type == DO_ONE_OBJECT) {
                break;
            }
#endif
            if (dwError == ERROR_OPERATION_ABORTED)
            {
                cntDone = 0;
                break;
            }

        }

    } while (sPQP.uPos);

    // if the agent traversed the entire PQ and didn't come across any item
    // that needed to be filled or refreshed, then we turnoff the global flag indicating
    // that we need priority Q traversal.
    // From here on, the agent will be driven by the SparseStaleDetectionCount
    if (fAmAgent)
    {
        // if even one sparse or stale was detected, traverse the queue again
        if (fSparseStaleDetected)
        {
            vfNeedPQTraversal = TRUE;
        }
        else if (!sPQP.uPos)
        {
            vfNeedPQTraversal = FALSE;
            ReintKdPrint(FILL, ("Agent.fill: No sparse stale entries found, going in querycount mode\r\n"));
        }
    }

    // Close the enumeration
    EndPQEnum(hShadowDB, &sPQP);

bailout:
    if (fInodeTransaction)
    {
        DoShadowMaintenance(hShadowDB, SHADOW_END_INODE_TRANSACTION);
        fInodeTransaction = FALSE;
    }
    if (hShadowDB != INVALID_HANDLE_VALUE)
    {
        CloseShadowDatabaseIO(hShadowDB);
    }

    if (lpCP) {
        FreeCopyParams(lpCP);
    }

    if (tzDrive[0])
    {
        if(DWDisconnectDriveMappedNet(tzDrive, TRUE))
        {
            ReintKdPrint(BADERRORS, ("Failed disconnection of merge drive \r\n"));
        }
        else
        {
            ReintKdPrint(MERGE, ("Disconnected merge drive \r\n"));
        }
                
    }

    ReintKdPrint(FILL, ("Agent.fill:done cachefill\n"));
    return (cntDone);
}


DWORD
DoRefresh(
    HANDLE          hShadowDB,
    LPCOPYPARAMS    lpCP,
    _TCHAR *        lpszFullPath,
    LPSHADOWINFO    lpSI,
    _TCHAR *        lptzDrive
    )
/*++

Routine Description:

    Checks whether an item in the database has gone stale and if so, it refreshes it. If it is
    a file, it is truncated and marked SPARSE

Arguments:


Returns:


Notes:

--*/
{
    DWORD dwError = 0xffffffff;

    if (!CheckForStalenessAndRefresh(hShadowDB, lptzDrive, lpCP, lpszFullPath, lpSI)) {
            dwError = GetLastError();
    }
    else
    {
        dwError = NO_ERROR;
    }

    if ((dwError != NOERROR) && IsNetDisconnected(dwError))
    {

#ifdef DEBUG
        EnterSkipQueue(lpSI->hShare, lpSI->hDir, lpSI->hShadow, lpszFullPath);
#else
        EnterSkipQueue(lpSI->hShare, lpSI->hDir, lpSI->hShadow);
#endif //DEBUG
    }

    return (dwError);
}

/*********************** Merging related routines **************************/

int
TraverseOneDirectory(
    HANDLE          hShadowDB,
    LPSECURITYINFO  pShareSecurityInfo,
    HSHADOW         hParentDir,
    HSHADOW         hDir,
    LPTSTR          lptzInputPath,
    TRAVERSEFUNC    lpfnTraverseDir,
    LPVOID          lpContext
    )
/*++

Routine Description:

    Generic routine that traverses a directory in the database recursively and issues a
    callback function to let callers do interesting things, such as merge or rename.

Arguments:

    hShadowDB       Handle to the redir for issuing ioctls

    hParentDir      handle to the parent directory

    hDir            handle to the directory to be traversed

    lptzInputPath   full qualified path of the directory

    lpfnTraverseDir callback function to call at each step in the traversal

    lpContext       callback context

Returns:

    return code, whether continue, cancel etc.

Notes:

--*/
{
    WIN32_FIND_DATA sFind32;
    SHADOWINFO sSI;
    int retCode = TOD_CONTINUE, lenInputPath = 0, retCodeSav;
    CSC_ENUMCOOKIE  ulEnumCookie = NULL;

    Assert(lptzInputPath);

    lenInputPath = lstrlen(lptzInputPath);

    Assert(lenInputPath && (lenInputPath < MAX_PATH));

    ReintKdPrint(MERGE, ("Begin_Traverse directory %ls\r\n", lptzInputPath));

    sSI.hDir = hParentDir;
    sSI.hShadow = hDir;
    retCode = (lpfnTraverseDir)(hShadowDB, pShareSecurityInfo, lptzInputPath, TOD_CALLBACK_REASON_BEGIN, &sFind32, &sSI, lpContext);

    memset(&sFind32, 0, sizeof(sFind32));
    lstrcpy(sFind32.cFileName, tzStarDotStar);

    if(FindOpenShadow(  hShadowDB, hDir, FINDOPEN_SHADOWINFO_ALL,
                        &sFind32, &sSI))
    {
        if (FAbortOperation())
        {
            ReintKdPrint(MERGE, ("TraverseOneDirectory:Abort received\r\n"));
            SetLastError(ERROR_CANCELLED);
            goto bailout;
        }


        ulEnumCookie = sSI.uEnumCookie;

        do
        {
            int lenChildName;

            lenChildName = lstrlen(sFind32.cFileName);

            if (!lenChildName || ((lenInputPath+lenChildName+1) >= MAX_PATH))
            {
                ReintKdPrint(MERGE, ("TraverseOneDirectory: path exceeds max path or is invalid\r\n"));
                SetLastError(ERROR_INVALID_PARAMETER);
                retCode = TOD_ABORT;
                goto bailout;
            }

            lptzInputPath[lenInputPath] = _T('\\');
            lstrcpy(&lptzInputPath[lenInputPath+1], sFind32.cFileName);

            if (sFind32.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                retCode = (lpfnTraverseDir)(hShadowDB, pShareSecurityInfo, lptzInputPath, TOD_CALLBACK_REASON_NEXT_ITEM, &sFind32, &sSI, lpContext);

                if (retCode == TOD_ABORT)
                {
                    ReintKdPrint(MERGE, ("TraverseOneDirectory:Abort\r\n"));
                    goto bailout;
                }
                retCode = TraverseOneDirectory(hShadowDB, pShareSecurityInfo, sSI.hDir, sSI.hShadow, lptzInputPath, lpfnTraverseDir, lpContext);
            }
            else
            {
                retCode = (lpfnTraverseDir)(hShadowDB, pShareSecurityInfo, lptzInputPath, TOD_CALLBACK_REASON_NEXT_ITEM, &sFind32, &sSI, lpContext);

            }

            lptzInputPath[lenInputPath] = 0;

            if (retCode == TOD_ABORT)
            {
                ReintKdPrint(MERGE, ("TraverseOneDirectory:Abort\r\n"));
                goto bailout;
            }

        } while(FindNextShadow(hShadowDB, ulEnumCookie, &sFind32, &sSI));
    }

bailout:

    sSI.hDir = hParentDir;
    sSI.hShadow = hDir;
    retCodeSav = (lpfnTraverseDir)(hShadowDB, pShareSecurityInfo, lptzInputPath, TOD_CALLBACK_REASON_END, &sFind32, &sSI, lpContext);
    if (retCode != TOD_ABORT)
    {
        retCode = retCodeSav;
    }
    ReintKdPrint(MERGE, ("End_Traverse directory %ls\r\n", lptzInputPath));

    if (ulEnumCookie)
    {
        FindCloseShadow(hShadowDB, ulEnumCookie);
    }

    return retCode;
}

int
ReintDirCallback(
    HANDLE          hShadowDB,
    LPSECURITYINFO  pShareSecurityInfo,
    LPTSTR          lptzFullPath,
    DWORD           dwCallbackReason,
    WIN32_FIND_DATA *lpFind32,
    SHADOWINFO      *lpSI,
    LPREINT_INFO     lpRei
    )
/*++

Routine Description:

    callback function used by ReintOneShare while calling TraverseOneDirectory. It is called
    on each step in the traversal. This routine issues call to do the merging

Arguments:

    hShadowDB           Handle to issue ioctls to the redir

    lptzFullPath        fully qualified path to the item

    dwCallbackReason    TOD_CALLBACK_REASON_XXX (BEGIN, NEXT_ITEM or END)

    lpFind32            local win32info

    lpSI                other info such as priority, pincount etc.

    lpRei               reintegration information context

Returns:

    return code, whether continue, cancel etc.

Notes:

--*/
{
    int retCode = TOD_CONTINUE;
    int iFileStatus, iShadowStatus;
    LPCOPYPARAMS lpCP = NULL;
    BOOL    fInsertInList = FALSE, fIsFile;
    WIN32_FIND_DATA sFind32Remote, *lpFind32Remote = NULL;
    unsigned    uAction;
    DWORD   dwErrorRemote = ERROR_SUCCESS;

    if (dwCallbackReason != TOD_CALLBACK_REASON_NEXT_ITEM)
    {
        return TOD_CONTINUE;
    }

    if ( mShadowOrphan(lpSI->uStatus)||
                 mShadowSuspect(lpSI->uStatus))
    {
        return TOD_CONTINUE;
    }

    if (!mShadowNeedReint(lpSI->uStatus))
    {
        return TOD_CONTINUE;
    }

    fIsFile = ((lpFind32->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0);

    switch (lpRei->nCurrentState)
    {
        case REINT_DELETE_FILES:
            if (!fIsFile || !mShadowDeleted(lpSI->uStatus))
            {
                return TOD_CONTINUE;
            }
        break;
        case REINT_DELETE_DIRS:
            if (fIsFile || !mShadowDeleted(lpSI->uStatus))
            {
                return TOD_CONTINUE;
            }
        break;
        case REINT_CREATE_UPDATE_FILES:
            if (!fIsFile)
            {
                return TOD_CONTINUE;
            }
        break;
        case REINT_CREATE_UPDATE_DIRS:
            if (fIsFile)
            {
                return TOD_CONTINUE;
            }
        break;
        default:
        Assert(FALSE);
        break;
    }

#if 0
    if (!fStamped){
        StampReintLog();
        fStamped = TRUE;
    }
#endif
    lpCP = LpAllocCopyParams();

    if (!lpCP){
        ReintKdPrint(BADERRORS, ("ReintDirCallback: Allocation of copyparam buffer failed\n"));
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        retCode = TOD_ABORT;
        goto bailout;
    }
    if(!GetUNCPath(hShadowDB, lpSI->hShare, lpSI->hDir, lpSI->hShadow, lpCP)){

        ReintKdPrint(BADERRORS, ("ReintDirCallback: GetUNCPath failed\n"));
        Assert(FALSE);
        retCode =  TOD_CONTINUE;
        goto bailout;
    }

    ReintKdPrint(MERGE, ("Merging local changes to <%ls%ls>\n", lpCP->lpSharePath, lpCP->lpRemotePath));

    fInsertInList = FALSE;

    lpFind32Remote = NULL;

    // if there is an insertion list, then check whether his ancestor
    // didn't fail in reintegration
    if (lpRei->lpnodeInsertList)
    {
        // if there is an acestor then we should put this guy in the list
        fInsertInList = FCheckAncestor(lpRei->lpnodeInsertList, lpCP);
    }

    // if we are not supposed to put him in the list then try getting
    // his win32 strucuture
    if (!fInsertInList)
    {

        BOOL fExists;

        ReintKdPrint(MERGE, ("getting Remote win32 Info \n"));

        if (!GetRemoteWin32Info(lpRei->tzDrive, lpCP, &sFind32Remote, &fExists) && (fExists == -1))
        {
            // NB: dwErrorRemote is set only when fExists is -1, ie there some error
            // besides the file not being there

            // some error happened while getting remote find32
            if (IsNetDisconnected(dwErrorRemote = GetLastError()))
            {
#ifdef DEBUG
                EnterSkipQueue(lpSI->hShare, 0, 0, lpCP->lpSharePath);
#else
                EnterSkipQueue(lpSI->hShare, 0, 0);
#endif //DEBUG
                retCode = TOD_ABORT;
                ReintKdPrint(BADERRORS, ("ReintDirCallback: Error = %d NetDisconnected aborting\r\n", GetLastError()));
                goto bailout;
            }

        }

        // passing remote find32 only if it succeeded
        if (fExists == TRUE)
        {
            lpFind32Remote = &sFind32Remote;
        }
        Assert(!((fExists != -1) && (dwErrorRemote != NO_ERROR)));
    }
    else
    {
        ReintKdPrint(BADERRORS, ("ReintDirCallback: Inserting in failed list\r\n"));
    }


    // find out what needs to be done
    // this is one central place to infer all the stuff
    InferReplicaReintStatus(
                            lpSI,    // shadowinfo
                            lpFind32,    // win32 info for the shadow
                            lpFind32Remote,    // remote win32 info
                            &iShadowStatus,
                            &iFileStatus,
                            &uAction
                            );


    if (!fInsertInList)
    {
        ReintKdPrint(MERGE, ("Silently doing <%ls%ls>\n", lpCP->lpSharePath, lpCP->lpRemotePath));


        fInsertInList = (PerformOneReint(
                                    hShadowDB,
                                    pShareSecurityInfo,
                                    lpRei->tzDrive,
                                    lptzFullPath,
                                    lpCP,
                                    lpSI,
                                    lpFind32,
                                    lpFind32Remote,
                                    dwErrorRemote,
                                    iShadowStatus,
                                    iFileStatus,
                                    uAction,
                                    lpRei->dwFileSystemFlags,
                                    lpRei->ulPrincipalID,
                                    lpRei->lpfnMergeProgress,
                                    lpRei->dwContext
                                    ) == FALSE);
        if (fInsertInList)
        {
            if (IsNetDisconnected(GetLastError()))
            {
#ifdef DEBUG
                EnterSkipQueue(lpSI->hShare, 0, 0, lpCP->lpSharePath);
#else
                EnterSkipQueue(lpSI->hShare, 0, 0);
#endif //DEBUG
                retCode = TOD_ABORT;
                ReintKdPrint(BADERRORS, ("ReintDirCallback: Error = %d NetDisconnected aborting\r\n", GetLastError()));
                goto bailout;
            }
            else if (GetLastError() == ERROR_OPERATION_ABORTED)
            {
                retCode = TOD_ABORT;
                ReintKdPrint(BADERRORS, ("ReintDirCallback: operation aborted becuase of ERROR_OPERATION_ABORT\r\n"));
                goto bailout;
            }

        }
        else
        {
            retCode = TOD_CONTINUE;
        }
    }
    else
    {
        ReintKdPrint(BADERRORS, ("ReintDirCallback: Was Inserted in failed list\r\n"));
    }


bailout:
    if (lpCP) {
        FreeCopyParams(lpCP);
    }

    return retCode;
}

BOOL
PUBLIC
ReintOneShare(
    HSHARE         hShare,
    HSHADOW         hRoot,    // root inode
    _TCHAR          *lpDomainName,
    _TCHAR          *lpUserName,
    _TCHAR          *lpPassword,
    ULONG           ulPrincipalID,
    LPCSCPROC       lpfnMergeProgress,
    DWORD_PTR       dwContext
    )
/*++

Routine Description:

    This is the workhorse routine that does the merging of a share which may have modifications
    made while offline.

    The routine, first checks whether any modifications have been done at all on this share.
    Is so, then it gets a list of all the drive-mapped and explicit UNC connections made to
    this share.

    The routine then creates a special drive mapping to the share, done by passing in an
    extended attribute flag CSC_BYPASS (defined in lmuse.h). This tells the redir
    to bypass all CSC functionality.

    It then deletes all the connections in the list gathered before making the EA based
    connections.

    The merge then proceeds by enumerating the share from the database. It uses, TraverseOneDirectory
    routine and gives it ReintDirCallback routine as a callback with REINT_INFO as the context.
    The directory travesal proceeds from the root of the share

    At the end of the merge, the EA connection is deleted and the connections in the list are
    reconnected.


Arguments:

    hShare         // Represents the share to merged

    hRoot           // the root inode for the share

    lpDomainName    // domain name for EA drivemapping (can be NULL)

    lpUserName      // username for EA drivemapping (can be NULL)

    lpPassword      // password for EA drivemapping (can be NULL)
    
    ulPrinciaplID   // the ID of the guy calling reint

    lpfnMergeProgress   // callback function for reporting progress

    dwContext           // callback context

Returns:

    TRUE if successful. If FALSE, GetLastError returns the actual errorcode.

Notes:

    The EA drivemap is passed back to the callback routine during the CSCPROC_REASON_BEGIN callback
    so that the callback routine can use the same driveletter to bypass CSC for doing whatever
    it needs to do on the server without having CSC get in it's way.
    
--*/

{
    BOOL fConnected=FALSE, fDone = FALSE;
    BOOL fStamped = FALSE, fInsertInList = FALSE, fBeginReint = FALSE, fDisabledShadowing = FALSE;
    unsigned long ulStatus;
    HANDLE                hShadowDB;
    SHAREINFO  sSR;
    SHADOWINFO  sSI;
    int iRet, i;
    ULONG nRet = 0;
    DWORD   dwError, dwRet, dwMaxComponentLength=0;
    TCHAR   tzFullPath[MAX_PATH+1], tzDrive[4];
    LPCONNECTINFO lpHead = NULL;
    BOOL    fIsDfsConnect = FALSE;
    LPVOID  lpContext = NULL;
    DWORD   dwDummy;
    SECURITYINFO rgsSecurityInfo[CSC_MAXIMUM_NUMBER_OF_CACHED_PRINCIPAL_IDS];
    LPSECURITYINFO pShareSecurityInfo = NULL;

    // if reintegration is going on on a share, then ask him to stop
    // NTRAID-455269-shishirp-1/31/2000 we should allow reintegration on multiple shares
    if (vsRei.hShare)
    {
        ReintKdPrint(BADERRORS, ("ReintOneShare: reintegration is in progress\r\n"));
        SetLastError(ERROR_SHARING_VIOLATION);
        return FALSE;
    }

    // we enter a critical section because eventually we should allocate a reint_info strucuture
    // and thread it in a list

    EnterAgentCrit();
    memset(&vsRei, 0, sizeof(vsRei));
   
    vsRei.lpfnMergeProgress = lpfnMergeProgress;

    vsRei.dwContext = dwContext;
    vsRei.hShare = hShare;
    vsRei.ulPrincipalID = ulPrincipalID;

    LeaveAgentCrit();

    memset(tzDrive, 0, sizeof(tzDrive));

    if ((hShadowDB = OpenShadowDatabaseIO()) ==INVALID_HANDLE_VALUE)
    {
        ReintKdPrint(BADERRORS, ("ReintOneShare: failed to open database\r\n"));
        return FALSE;
    }
    if(GetShareInfo(hShadowDB, hShare, &sSR, &ulStatus)<= 0)
    {
        ReintKdPrint(BADERRORS, ("ReintOneShare: couldn't get status for server 0x%x\r\n", hShare));
        goto bailout;
    }

    dwDummy = sizeof(rgsSecurityInfo);
    nRet = GetSecurityInfoForCSC(
                hShadowDB,
                0,
                hRoot,
                rgsSecurityInfo,
                &dwDummy);

    if (nRet > 0)
        pShareSecurityInfo = rgsSecurityInfo;

    lstrcpy(tzFullPath, sSR.rgSharePath);

    // this will modify the reint bit on the share if necessary
    if(!CSCEnumForStatsInternal(sSR.rgSharePath, NULL, FALSE, TRUE, 0))
    {
        ReintKdPrint(MERGE, ("ReintOneShare: Couldn't get stats for %ls \r\n", sSR.rgSharePath));
        goto bailout;

    }

    if (!(ulStatus & SHARE_REINT))
    {
        ReintKdPrint(MERGE, ("ReintOneShare: server %ls doesn't need reintegration\r\n", sSR.rgSharePath));
        fDone = TRUE;
        goto bailout;
    }

    if (!GetShadowInfoEx(INVALID_HANDLE_VALUE, 0, hRoot, NULL, &sSI)){

        ReintKdPrint(BADERRORS, ("ReintOneShare: GetShadowInfoEx failed\n"));
        goto bailout;
    }



    // put the share in reintegration mode
    // if this is not marked system pinned, then it would be a blocking reint
    // Putting the share in reintegration mode makes all open calls fail, except those
    // done on the special EA drive mapping

    // NB, beginreint is an async ioctl. This is the basis for cleanup
    // when the thread does the merge dies


    // All reint's are blocking reints.
    if (!BeginReint(hShare, TRUE /*!(sSI.ulHintFlags & FLAG_CSC_HINT_PIN_SYSTEM)*/, &lpContext))
    {
        if (GetLastError() != ERROR_IO_PENDING)
        {
            ReintKdPrint(BADERRORS, ("ReintOneShare: Couldn't put server 0x%x in reintegration state\r\n", hShare));
            goto bailout;
        }
    }

    fBeginReint = TRUE;

    // After putting the share in reintegration mode, we get the list of all
    // connection to the share and delete them with maximum force.
    // this ensures that no files are open after the share is put in reintegration mode
    // Moreover any files that are open are only thorugh the EA drive mapping

    // obtain the list of connections to this share.
    // do this before making a the special CSC_BYPASS connection
    // so that the list won't have it
    FGetConnectionListEx(&lpHead, sSR.rgSharePath, FALSE, FALSE, NULL);

    // now make the connection
    ReintKdPrint(MERGE, ("CSC.ReintOneShare: Attempting to map drive letter to %ls \r\n", sSR.rgSharePath));
    dwError = DWConnectNet(sSR.rgSharePath, tzDrive, lpDomainName, lpUserName, lpPassword, CONNECT_INTERACTIVE, &fIsDfsConnect);
    if ((dwError != WN_SUCCESS) &&
         (dwError != WN_CONNECTED_OTHER_PASSWORD_DEFAULT) &&
             (dwError != WN_CONNECTED_OTHER_PASSWORD))
    {
#ifdef DEBUG
        EnterSkipQueue(hShare, 0, 0, sSR.rgSharePath);
#else
        EnterSkipQueue(hShare, 0, 0);
#endif
        SetLastError(dwError);

        ReintKdPrint(BADERRORS, ("ReintOneShare: Error %d, couldn't connect to %ls\r\n", dwError, sSR.rgSharePath));

        // clear the connection list and bailout
        if (lpHead)
        {
            ClearConnectionList(&lpHead);
            lpHead = NULL;
        }

        goto bailout;

    }

    fConnected = TRUE;

    // if we have a connectionlist, disconnect all connections before attempting merge
    // NB, this is done after the drivemapped connection is made, so that
    // if there are special credentials on the server, they are maintained
    // as there is always atelast one outstanding connection

    if (lpHead)
    {
        DisconnectList(&lpHead, NULL, 0);
    }

    lstrcpy(vsRei.tzDrive, tzDrive);

    tzDrive[2]='\\';tzDrive[3]=0;
    ReintKdPrint(MERGE, ("CSC.ReintOneShare: mapped drive letter %ls IsDfs=%d\r\n", tzDrive, fIsDfsConnect));

    vsRei.dwFileSystemFlags = 0;

    // NTRAID#455273-shishirp-1/31/2000  we do getvolumeinfo only for non-dfs shares. This is because of a problem in
    // the DFS code that doesn't bypass volume operations for CSC agent. GetVolumeInfo is not implemented
    // by DFS

    if (!fIsDfsConnect)
    {
        if(!GetVolumeInformation(tzDrive, NULL, 0, NULL, &dwMaxComponentLength, &vsRei.dwFileSystemFlags, NULL, 0))
        {
            ReintKdPrint(BADERRORS, ("CSC.ReintOneShare: failed to get volume info for %ls Error=%d\r\n", tzDrive, GetLastError()));
            goto bailout;

        }
    }
    else
    {
        vsRei.dwFileSystemFlags = DFS_ROOT_FILE_SYSTEM_FLAGS;
    }

    tzDrive[2]=0;

    ReintKdPrint(MERGE, ("CSC.ReintOneShare: FileSystemFlags=%x \r\n", vsRei.dwFileSystemFlags));

    if (lpfnMergeProgress)
    {
        WIN32_FIND_DATA *lpFT;

        lpFT = (WIN32_FIND_DATA *)LocalAlloc(LPTR, sizeof(WIN32_FIND_DATA));

        if (!lpFT)
        {
            ReintKdPrint(BADERRORS, ("ReintOneShare: Couldn't allocate find32 strucutre for callback \r\n"));
            goto bailout;
        }

        lstrcpy(lpFT->cFileName, vsRei.tzDrive);

        try
        {
            dwRet = (*lpfnMergeProgress)(sSR.rgSharePath, ulStatus, 0, 0, lpFT, CSCPROC_REASON_BEGIN, 0, 0, dwContext);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            dwRet = CSCPROC_RETURN_ABORT;
        }


        LocalFree(lpFT);

        if (dwRet != CSCPROC_RETURN_CONTINUE)
        {
            if (dwRet == CSCPROC_RETURN_ABORT)
            {
                SetLastError(ERROR_OPERATION_ABORTED);
            }
            else
            {
                SetLastError(ERROR_SUCCESS);
            }
        }
    }

    for (i=0; i<4; ++i)
    {
        // for now we don't do directory deletions
        // we will fix this later

        if (i==REINT_DELETE_DIRS)
        {
            continue;
        }

        vsRei.nCurrentState = i;

        try
        {
            iRet = TraverseOneDirectory(
                        hShadowDB,
                        pShareSecurityInfo,
                        0,
                        hRoot,
                        tzFullPath,
                        ReintDirCallback,
                        (LPVOID)&vsRei);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            iRet = TOD_ABORT;
        }

        if (iRet == TOD_ABORT)
        {
            break;
        }
    }


    if (iRet != TOD_ABORT)
    {
        if(!vsRei.lpnodeInsertList)
        {
            fDone = TRUE;
        }
    }

    if (fDone) {

        SetShareStatus(hShadowDB, hShare, (unsigned long)(~SHARE_REINT), SHADOW_FLAGS_AND);
    }

bailout:


    if (!fDone)
    {
        dwError = GetLastError();
    }

#if 0
    if (fIsDfsConnect)
    {
        DbgPrint("Nuking DFS connects On Close %ls \n", sSR.rgSharePath);
        do
        {
            if(WNetCancelConnection2(sSR.rgSharePath, 0, TRUE) != NO_ERROR)
            {
                DbgPrint("Nuked On Close %ls Error=%d\n", sSR.rgSharePath, GetLastError());
                break;
            }
            else
            {
                DbgPrint("Nuked On Close %ls \n", sSR.rgSharePath);
            }

        } while (TRUE);
    }
#endif

    EnterAgentCrit();

    if (fBeginReint){

        Assert(hShare == vsRei.hShare);

        EndReint(hShare, lpContext);

        vsRei.hShare = 0;


        fBeginReint = FALSE;
        if (lpfnMergeProgress)
        {
            try
            {
                dwRet = (*lpfnMergeProgress)(sSR.rgSharePath, ulStatus, 0, 0, NULL, CSCPROC_REASON_END, 0, 0, dwContext);
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                dwRet = CSCPROC_RETURN_ABORT;
            }
        }
    }

    if (fDisabledShadowing)
    {
        EnableShadowingForThisThread(hShadowDB);
    }

    CloseShadowDatabaseIO(hShadowDB);

    if(vsRei.lpnodeInsertList) {
        killList(vsRei.lpnodeInsertList);
    }

    // reestablish the connection list
    // NB we do this before we disconnect the drive mapping
    // so that if any special credentials stay because
    // there is always one connection outstanding to the server
    
    if (lpHead)
    {
        ReconnectList(&lpHead, NULL);
        ClearConnectionList(&lpHead);
    }

    if (fConnected) {

        if(DWDisconnectDriveMappedNet(vsRei.tzDrive, TRUE))
        {
            ReintKdPrint(BADERRORS, ("Failed disconnection of merge drive \r\n"));
        }
        else
        {
            ReintKdPrint(MERGE, ("Disconnected merge drive \r\n"));
        }
    }

    memset(&vsRei, 0, sizeof(vsRei));

    LeaveAgentCrit();

    if (!fDone)
    {

        ReintKdPrint(BADERRORS, ("Failed merge dwError=%d\r\n", dwError));
        SetLastError(dwError);
    }


    return (fDone);
}


/***************************************************************************
 * enumerate all the shares, checking to see if the share needs to be
 *    merged before starting.
 * Returns: # of shares that needed to be merged and were successfully done.
 */
// HWND for parent for UI.
int
PUBLIC
ReintAllShares(
    HWND hwndParent
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/

{
    unsigned long ulStatus;
    WIN32_FIND_DATA sFind32;
    int iDone=0, iDoneOne;
    SHADOWINFO sSI;
    HANDLE                hShadowDB;
    CSC_ENUMCOOKIE  ulEnumCookie=NULL;

    if ((hShadowDB = OpenShadowDatabaseIO()) ==INVALID_HANDLE_VALUE)
    {
        return FALSE;
    }

#if 0
    if (!EnterAgentCrit()) {
        ReintKdPrint(BADERRORS, ("ReintAllShares:Failed to enter critsect \r\n"));
        return 0;
    }
#endif


    vhcursor = LoadCursor(NULL, IDC_WAIT);

    memset(&sFind32, 0, sizeof(sFind32));
    lstrcpy(sFind32.cFileName, tzStarDotStar);


    if(FindOpenShadow( hShadowDB, 0, FINDOPEN_SHADOWINFO_ALL, &sFind32, &sSI)){

        ulEnumCookie = sSI.uEnumCookie;

        do {
            if (FAbortOperation())
            {
                break;
            }

            if(GetShareStatus(hShadowDB, sSI.hShare, &ulStatus)) {
                if(TRUE/*ulStatus & SHARE_REINT*/){ // OLDCODE
                    iDoneOne = ReintOneShare(sSI.hShare, sSI.hShadow, NULL, NULL, NULL, CSC_INVALID_PRINCIPAL_ID, NULL, 0);
                    if (iDoneOne > 0){
                        if (iDone >= 0)
                            ++iDone;
                        }
                    else if (iDoneOne < 0){
                        iDone = -1;
                    }
                }
                else {
                    ReintKdPrint(MERGE, ("server %d doesn't need reint.\n", sSI.hShare));
                }
            }
        } while(FindNextShadow( hShadowDB, ulEnumCookie, &sFind32, &sSI));

        FindCloseShadow(hShadowDB, ulEnumCookie);
    }

#if 0
    LeaveAgentCrit();
#endif
    vhcursor = NULL;

    CloseShadowDatabaseIO(hShadowDB);
    return (iDone);
}

int
CheckDirtyShares(
    VOID
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/

{
    unsigned long ulStatus;
    WIN32_FIND_DATA sFind32;
    int cntDirty=0;
    SHADOWINFO sSI;
    HANDLE                hShadowDB;
    CSC_ENUMCOOKIE  ulEnumCookie=NULL;

    if ((hShadowDB = OpenShadowDatabaseIO()) ==INVALID_HANDLE_VALUE)
    {
        return 0;
    }

    memset(&sFind32, 0, sizeof(sFind32));
    lstrcpy(sFind32.cFileName, tzStarDotStar);

    if(FindOpenShadow(  hShadowDB, 0, FINDOPEN_SHADOWINFO_ALL,
                        &sFind32, &sSI))
    {
        ulEnumCookie = sSI.uEnumCookie;

        do {
            if(GetShareStatus(hShadowDB, sSI.hShare, &ulStatus)) {

                if(ulStatus & SHARE_REINT){
                    ++cntDirty;
                }

            }
        } while(FindNextShadow(hShadowDB, ulEnumCookie, &sFind32, &sSI));

        FindCloseShadow(hShadowDB, ulEnumCookie);
    }

    CloseShadowDatabaseIO(hShadowDB);

    return cntDirty;
}

BOOL
GetRemoteWin32Info(
    _TCHAR              *lptzDrive,
    LPCOPYPARAMS        lpCP,
    LPWIN32_FIND_DATA   lpFind32,
    BOOL                *lpfExists
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/

{
    _TCHAR *    lpT = NULL;
    BOOL fRet = FALSE;
    _TCHAR  tzDrive[4];
    DWORD   dwError = ERROR_SUCCESS;

    *lpfExists = -1;
    tzDrive[0] = 0;

    lpT = AllocMem((lstrlen(lpCP->lpSharePath) + lstrlen(lpCP->lpRemotePath) + 2) * sizeof(_TCHAR));

    if (lpT)
    {

        if (lptzDrive && lptzDrive[0])
        {
            lstrcpy(lpT, lptzDrive);
        }
        else
        {
            dwError = DWConnectNet(lpCP->lpSharePath, tzDrive, NULL, NULL, NULL, 0, NULL);
            if ((dwError != WN_SUCCESS) && (dwError != WN_CONNECTED_OTHER_PASSWORD_DEFAULT))
            {
                tzDrive[0] = 0;
                goto bailout;
            }

            lstrcpy(lpT, tzDrive);
        }

        lstrcat(lpT, lpCP->lpRemotePath);

        fRet = GetWin32Info(lpT, lpFind32);    // if this fails, GetLastError is properly set

        if (fRet)
        {
            *lpfExists = TRUE;
        }
        else
        {
            dwError = GetLastError();
            if ((dwError == ERROR_FILE_NOT_FOUND)||
                 (dwError == ERROR_PATH_NOT_FOUND)||
                 (dwError == ERROR_INVALID_PARAMETER)
                )
            {
                *lpfExists = FALSE;
            }
        }
    }
    else
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
    }
bailout:
    if (tzDrive[0])
    {
        if(DWDisconnectDriveMappedNet(tzDrive, TRUE))
        {
            ReintKdPrint(BADERRORS, ("Failed disconnection of remote drive \r\n"));
        }
    }
    if (lpT)
    {
        FreeMem(lpT);
    }
    if (!fRet)
    {
        SetLastError(dwError);
    }
    return (fRet);
}


VOID
PRIVATE
InferReplicaReintStatus(
    LPSHADOWINFO         lpSI,              // shadow info
    LPWIN32_FIND_DATA    lpFind32Local,     // win32 info in the database
    LPWIN32_FIND_DATA     lpFind32Remote,   // if NULL, the remote doesn't exist
    int                 *lpiShadowStatus,
    int                 *lpiFileStatus,
    unsigned             *lpuAction
    )
/*++

Routine Description:

    As the name sugggests, the routine find out what changes have occurred on the local replica
    and whether there is a conflict with the original on the remote.

Arguments:

    lpSI                shadow info

    lpFind32Local       win32 info in the database

    lpFind32Remote      win32 info for the original if NULL, the original doesn't exist

    lpiShadowStatus     status of local replica returned

    lpiFileStatus       status of remote replica returned

    lpuAction           Action to be performed to do the merge returned


Returns:

    -

Notes:

--*/

{
    int iShadowStatus=SI_UNCHANGED, iFileStatus=SI_UNCHANGED;
    unsigned int uAction=RAIA_TOOUT;


    if(mShadowDeleted(lpSI->uStatus)){
        iShadowStatus=SI_DELETED;
    }

    if(lpSI->uStatus & (SHADOW_DIRTY|SHADOW_TIME_CHANGE|SHADOW_ATTRIB_CHANGE)){
        iShadowStatus=SI_CHANGED;
    }

    if(mShadowLocallyCreated(lpSI->uStatus)){
        iShadowStatus=SI_NEW;
    }

    // no one should be calling this if there have been no offline changes
    Assert(iShadowStatus != SI_UNCHANGED);

    if(!lpFind32Remote){    // does the remote exist?
        // No
        // if the shadow was not locally created then it must have vanished from the share
        if(iShadowStatus != SI_NEW) {
            iFileStatus=SI_DELETED;
            uAction = RAIA_MERGE;
            ReintKdPrint(MERGE, ("<%ls> deleted at some stage\n", lpFind32Local->cFileName));
        }
        else {
            // we mark the outside as not existing.  We also have to
            // create a file locally to get the insert to work right...
            // don't forget to kill it later. 
            iFileStatus=SI_NOEXIST;
            ReintKdPrint(MERGE, ("<%ls> will be created\n", lpFind32Local->cFileName));
        }
    }
    else {
        // check to see if server version has been touched
        // NB the last accesstime field of the lpFind32Local contains the replica time

        if ((lpFind32Local->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            != (lpFind32Remote->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            // dir became file or vice versa
            iFileStatus=SI_CHANGED;
            uAction = RAIA_MERGE;
        }
        else
        {
            if(CompareTimesAtDosTimePrecision(lpFind32Remote->ftLastWriteTime, //dst
                lpFind32Local->ftLastAccessTime))    //src , does (dst-src)
            {
                // the timestamps don't match

                // mark the remote as changed only if it is a file
                // will do the directories quitely
                if (!(lpFind32Remote->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
                {
                    iFileStatus=SI_CHANGED;
                    uAction = RAIA_MERGE;
                    ReintKdPrint(MERGE, ("<%ls> will be merged\n", lpFind32Local->cFileName));
                }
            }
        }
    }

    *lpiShadowStatus = iShadowStatus;
    *lpiFileStatus = iFileStatus;
    *lpuAction = uAction;

}


BOOL
PRIVATE
PerformOneReint(
    HANDLE              hShadowDB,
    LPSECURITYINFO      pShareSecurityInfo,
    _TCHAR *            lpszDrive,          // drive mapped to the UNC name of lpSI->hShare
    _TCHAR *            lptzFullPath,       // full UNC path
    LPCOPYPARAMS        lpCP,               // copy parameters
    LPSHADOWINFO        lpSI,               // shadowinfo structure
    LPWIN32_FIND_DATA   lpFind32Local,      // local win32 data
    LPWIN32_FIND_DATA   lpFind32Remote,     // remote win32 data, could be NULL
    DWORD               dwErrorRemoteFind32,// error code while getting remote win32 data
    int                 iShadowStatus,      // local copy status
    int                 iFileStatus,        // remote file status
    unsigned            uAction,            // action to be taken
    DWORD               dwFileSystemFlags,  // CODE.IMPROVEMENT, why not just pass down REINT_INFO
    ULONG               ulPrincipalID,
    LPCSCPROC           lpfnMergeProgress,  // instead of the three parameters?
    DWORD_PTR           dwContext
    )
/*++

Routine Description:

    Merges a filesystem object by calling the routine for the appropriate type of FS object.
    We implement only files and directories for NT5. Also does callbacks for the UI.

Arguments:

    hShadowDB           Shadow Database handle
    
    lpszDrive           drive mapped to the UNC name of lpSI->hShare
    
    lptzFullPath        full UNC path
    
    lpCP                copy parameters containing various paths for the object being merged
    
    lpSI                shadowinfo structure for the object being merged
    
    lpFind32Local       local win32 data for the object being merged
    
    lpFind32Remote      remote win32 data for the object being merged, could be NULL
    
    iShadowStatus       local copy status
    
    iFileStatus         remote file status
    
    uAction             action to be taken
    
    dwFileSystemFlags   remote filesystem 
    
    ulPrincipalID       principal ID in order to skip selectively
    
    lpfnMergeProgress   callback function
    
    dwContext           callback context

Returns:


Notes:

--*/
{
    DWORD dwError, dwRet;

    dwError = NO_ERROR;

    ReintKdPrint(
        MERGE,
        ("++++++++PerformOneReint: %s (%08x) %d %d perform:\n",
        lptzFullPath,
        lpSI->hShadow,
        iShadowStatus,
        iFileStatus));

    if (lpfnMergeProgress)
    {
        ULONG   uStatus = lpSI->uStatus;
        DWORD   dwsav0, dwsav1;

        // if there is an error in getting remote find32, then 
        // don't tell any conflicts to the callback, because we don't want to show any UI
        if (dwErrorRemoteFind32 != NO_ERROR)
        {
            iFileStatus = SI_CHANGED;
            uAction = RAIA_TOOUT;
        }

        // if this is a file, check whether access is allowed for this user
        if (!(lpFind32Local->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            BOOL fRet;

            Assert(dwError == NO_ERROR);
            Assert(ulPrincipalID != CSC_INVALID_PRINCIPAL_ID);

            dwsav0 = lpFind32Local->dwReserved0;
            dwsav1 = lpFind32Local->dwReserved1;

            fRet = GetCSCAccessMaskForPrincipalEx(
                        ulPrincipalID,
                        lpSI->hDir,
                        lpSI->hShadow,
                        &uStatus,
                        &lpFind32Local->dwReserved0,
                        &lpFind32Local->dwReserved1);

            //
            // Adjust user and guest permissions based on share security, if
            // we have such info.
            //
            if (pShareSecurityInfo != NULL) {
                ULONG i;
                ULONG GuestIdx = CSC_MAXIMUM_NUMBER_OF_CACHED_PRINCIPAL_IDS;
                ULONG UserIdx = CSC_MAXIMUM_NUMBER_OF_CACHED_PRINCIPAL_IDS;

                //
                // Find the user's and guest's entries
                //
                for (i = 0; i < CSC_MAXIMUM_NUMBER_OF_CACHED_PRINCIPAL_IDS; i++) {
                    if (pShareSecurityInfo[i].ulPrincipalID == ulPrincipalID)
                        UserIdx = i;
                    if (pShareSecurityInfo[i].ulPrincipalID == CSC_GUEST_PRINCIPAL_ID)
                        GuestIdx = i;
                }
                //
                // Only work with share perms if we found a guest perm in the list
                //
                if (GuestIdx < CSC_MAXIMUM_NUMBER_OF_CACHED_PRINCIPAL_IDS) {
                    if (UserIdx >= CSC_MAXIMUM_NUMBER_OF_CACHED_PRINCIPAL_IDS)
                        UserIdx = GuestIdx;
                    //
                    // Logical AND the share perms with the file perms - to prevent
                    // ACCESS_DENIED errors on files which a user has access to via
                    // file perms, but share perms deny such access.
                    //
                    lpFind32Local->dwReserved0 &= pShareSecurityInfo[UserIdx].ulPermissions;
                    lpFind32Local->dwReserved1 &= pShareSecurityInfo[GuestIdx].ulPermissions;
                }
            }

            if (!fRet)
            {
                dwError = GetLastError();
                ReintKdPrint(MERGE, ("Failed to get accessmask Error=%d \n", dwError));
                lpFind32Local->dwReserved0 = dwsav0;
                lpFind32Local->dwReserved1 = dwsav1;
                goto bailout;            
            }
            else
            {
                Assert((uStatus & ~FLAG_CSC_ACCESS_MASK) == lpSI->uStatus);
                ReintKdPrint(MERGE, ("PerformOneReint: Status with mask 0x%x\n",uStatus));
            }
        }

        try{
            dwRet = (*lpfnMergeProgress)(
                        lptzFullPath,
                        uStatus,
                        lpSI->ulHintFlags,
                        lpSI->ulHintPri,
                        lpFind32Local,
                        CSCPROC_REASON_BEGIN,
                        (uAction == RAIA_MERGE),
                        (iFileStatus == SI_DELETED),
                        dwContext
                        );
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            dwRet = CSCPROC_RETURN_ABORT;
        }

        lpFind32Local->dwReserved0 = dwsav0;
        lpFind32Local->dwReserved1 = dwsav1;

        if (dwRet != CSCPROC_RETURN_CONTINUE)
        {
            // if the guy said abort, we want to quit with the correct error code
            if (dwRet == CSCPROC_RETURN_ABORT)
            {
                dwError = ERROR_OPERATION_ABORTED;
                goto bailout;
            }


            if (dwRet == CSCPROC_RETURN_FORCE_INWARD)
            {
                // the remote copy wins
                uAction = RAIA_TOIN;
            }
            else if (dwRet == CSCPROC_RETURN_FORCE_OUTWARD)
            {
                // local copy wins
#if defined(BITCOPY)
                ReintKdPrint(MERGE, ("CSCPROC_RETURN_FORCE_OUTWARD\n"));
                uAction = RAIA_MERGE;
#else
                uAction = RAIA_TOOUT;
#endif // defined(BITCOPY)
            }
            else
            {
                goto bailout;
            }
        }
        else
        {
            // if we are asked to continue, we press on irrespective of whether there is
            // a conflict or not

#if defined(BITCOPY)
            ReintKdPrint(MERGE, ("CSCPROC_RETURN_CONTINUE\n"));
#endif // defined(BITCOPY)
            uAction = RAIA_TOOUT;
        }

        // if there is an error in getting remote find32, then 
        // tell the real error code to the callback
        if (dwErrorRemoteFind32 != NO_ERROR)
        {
            dwError = dwErrorRemoteFind32;
            goto bailout;
        }
    }

    switch(uAction){

        case RAIA_MERGE:
        case RAIA_TOOUT:
            ReintKdPrint(MERGE, ((uAction==RAIA_TOOUT)?"RAIA_TOOUT\n":"RAIA_MERGE\n"));

            if (lpFind32Local->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY){
                dwError = DoCreateDir(
                            hShadowDB,
                            lpszDrive,
                            lptzFullPath,
                            lpCP,
                            lpSI,
                            lpFind32Local,
                            lpFind32Remote,
                            iShadowStatus,
                            iFileStatus,
                            uAction,
                            dwFileSystemFlags,
                            lpfnMergeProgress,
                            dwContext
                            );
            }
            else {
                dwError = DoObjectEdit(
                            hShadowDB,
                            lpszDrive,
                            lptzFullPath,
                            lpCP,
                            lpSI,
                            lpFind32Local,
                            lpFind32Remote,
                            iShadowStatus,
                            iFileStatus,
                            uAction,
                            dwFileSystemFlags,
                            lpfnMergeProgress,
                            dwContext
                            );
                ReintKdPrint(MERGE, ("DoObjectEdit returned 0x%x\n", dwError));
            }
        break;

        case RAIA_TOIN:
            ReintKdPrint(MERGE, ("RAIA_TOIN\n"));

            if((!SetShadowInfo(hShadowDB, lpSI->hDir, lpSI->hShadow, NULL, (unsigned long)~(SHADOW_MODFLAGS), SHADOW_FLAGS_AND))
               ||!CheckForStalenessAndRefresh(hShadowDB, lpszDrive, lpCP, lptzFullPath, lpSI))
            {
                dwError = GetLastError();
            }
        break;

        case RAIA_SKIP:
            ReintKdPrint(MERGE, ("RAIA_SKIP\n"));
        break;

        case RAIA_CONFLICT:
            ReintKdPrint(MERGE, ("RAIA_CONFLICT\n"));
        break;

        case RAIA_SOMETHING:
            ReintKdPrint(MERGE, ("RAIA_SOMETHING\n"));
        break;

        case RAIA_NOTHING:
            ReintKdPrint(MERGE, ("RAIA_NOTHING\n"));
        break;

        case RAIA_ORPHAN:
            ReintKdPrint(MERGE, ("RAIA_ORPHAN\n"));
        break;

        default:
            ReintKdPrint(MERGE, ("BOGUS!!!!!!!!!!!! %d\n",uAction));
    }
bailout:

    if (lpfnMergeProgress)
    {
        try
        {
            dwRet = (*lpfnMergeProgress)(
                                lptzFullPath,
                                lpSI->uStatus,
                                lpSI->ulHintFlags,
                                lpSI->ulHintPri,
                                lpFind32Local,
                                CSCPROC_REASON_END,
                                (uAction == RAIA_MERGE),
                                dwError,
                                dwContext
                                );
            ReintKdPrint(MERGE, ("Got %d from callback at CSCPROC_REASON_END\n", dwRet));
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            dwRet = CSCPROC_RETURN_ABORT;
        }
        if (dwRet == CSCPROC_RETURN_ABORT)
        {
            dwError = ERROR_OPERATION_ABORTED;
        }
    }

    if (dwError == NO_ERROR) {
        ReintKdPrint(MERGE, ("--------PerformOneReint exit TRUE\n"));
        return TRUE;
    }

    ReintKdPrint(MERGE, ("--------PerformOneReint exit FALSE (0x%x)\n", dwError));
    SetLastError(dwError);
    return (FALSE);
}


/******************************* Conflict related operations ****************/

DWORD
PRIVATE
CheckFileConflict(
   LPSHADOWINFO   lpSI,
   LPWIN32_FIND_DATA lpFind32Remote
   )
{
    unsigned long ulStatus = lpSI->uStatus;

    if (!lpFind32Remote){
        if (!(mShadowLocallyCreated(ulStatus)||mShadowDeleted(ulStatus))){
            return (ERROR_DELETE_CONFLICT);
        }
        else{
            return (NO_ERROR);
        }
    }
    else {
        // Create/Create conflict
        if (mShadowLocallyCreated(ulStatus)){
            return (ERROR_CREATE_CONFLICT);
        }

        if (lpFind32Remote->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY){
            if (mShadowDeleted(ulStatus)){
                return (NO_ERROR);
            }
            else{
                return(ERROR_ATTRIBUTE_CONFLICT);
            }
        }

        if(ChkUpdtStatus(INVALID_HANDLE_VALUE, lpSI->hDir, lpSI->hShadow, lpFind32Remote, &ulStatus) == 0){
            return (GetLastError());
        }

        if (mShadowConflict(ulStatus)){
            return (ERROR_UPDATE_CONFLICT);
        }
    }

   return (NO_ERROR);
}


DWORD
PRIVATE
InbCreateDir(
    _TCHAR *     lpDir,
    DWORD    dwAttr
    )
{
    SECURITY_ATTRIBUTES sSA;
    DWORD dwError = NO_ERROR, dwT;

    sSA.nLength = sizeof(SECURITY_ATTRIBUTES);
    sSA.lpSecurityDescriptor = NULL;
    sSA.bInheritHandle = TRUE;

    if ((dwT = GetFileAttributes(lpDir))==0xffffffff){
        if (!CreateDirectory(lpDir, &sSA)){
            dwError = GetLastError();
        }
    }
    else
    {
        if (!(dwT & FILE_ATTRIBUTE_DIRECTORY))
        {
            dwError = ERROR_FILE_EXISTS;    // there is a file by the same name
        }
    }
    if (dwError == NO_ERROR)
    {
        if (dwAttr != 0xffffffff)
        {
            if(!SetFileAttributes(lpDir, dwAttr))
            {
                ReintKdPrint(MERGE, ("Benign error %x \n", GetLastError()));
            }
        }
    }
    return (dwError);
}


/*********************************** Misc routines **************************/

#if defined(BITCOPY)
int
PRIVATE
GetShadowByName(
    HSHADOW              hDir,
    _TCHAR *                lpName,
    LPWIN32_FIND_DATA    lpFind32,
    unsigned long        *lpuStatus
    )
/*++

Routine Description:


Arguments:


Returns:

Notes:

--*/
{
    HSHADOW hShadow;
    memset(lpFind32, 0, sizeof(WIN32_FIND_DATA));
    lstrcpyn(lpFind32->cFileName, lpName, sizeof(lpFind32->cFileName)-1);
    return(GetShadow(INVALID_HANDLE_VALUE, hDir, &hShadow, lpFind32, lpuStatus));
}
#endif // defined(BITCOPY)

DWORD
DoSparseFill(
    HANDLE          hShadowDB,
    _TCHAR *          lpszFullPath,
    _TCHAR *          lptzDrive,
    LPSHADOWINFO    lpSI,
    WIN32_FIND_DATA *lpFind32,
    LPCOPYPARAMS    lpCP,
    BOOL            fStalenessCheck,
    ULONG           ulPrincipalID,
    LPCSCPROC       lpfnProgress,
    DWORD_PTR       dwContext
   )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    DWORD dwError = 0xffffffff, dwRet, dwTotal=0, dwTotalSleepTime = 0, cntRetries=0, cntMaxRetries=1;
    BOOL fConnected = FALSE, fIsSlowLink, fDisabledShadowing = FALSE, fAmAgent;
    int cbRead;
    COPYCHUNKCONTEXT CopyChunkContext;
    HANDLE hAnchor = INVALID_HANDLE_VALUE;
    ULONG   uStatus;

    fAmAgent = (GetCurrentThreadId() == vdwCopyChunkThreadId);
    Assert(GetCurrentThreadId() != vdwAgentThreadId);

    memset(&CopyChunkContext, 0, sizeof(CopyChunkContext));
    CopyChunkContext.handle = INVALID_HANDLE_VALUE;

    if (!fAmAgent)
    {
        cntMaxRetries = MAX_SPARSE_FILL_RETRIES;
    }

    ReintKdPrint(FILL, ("cntMaxRetries = %d \r\n", cntMaxRetries));

    if(!DoShadowMaintenance(hShadowDB, SHADOW_BEGIN_INODE_TRANSACTION))
    {
        return GetLastError();
    }

    // report the progress
    if (lpfnProgress)
    {
        DWORD   dwsav0, dwsav1;
        BOOL    fRet;

        uStatus = lpSI->uStatus;


        Assert(ulPrincipalID != CSC_INVALID_PRINCIPAL_ID);

        dwError = ERROR_SUCCESS;

        dwsav0 = lpFind32->dwReserved0;
        dwsav1 = lpFind32->dwReserved1;

        fRet = GetCSCAccessMaskForPrincipalEx(ulPrincipalID, lpSI->hDir, lpSI->hShadow, &uStatus, &lpFind32->dwReserved0, &lpFind32->dwReserved1);


        if (!fRet)
        {
            dwError = GetLastError();
            ReintKdPrint(BADERRORS, ("DoSparseFill Failed to get accessmask Error=%d\r\n", dwError));
            lpFind32->dwReserved0 = dwsav0;
            lpFind32->dwReserved1 = dwsav1;
            goto done;            
        }
        else
        {
            Assert((uStatus & ~FLAG_CSC_ACCESS_MASK) == lpSI->uStatus);
        }

        try{
            dwRet = (*lpfnProgress)(
                                    lpszFullPath,
                                    uStatus,
                                    lpSI->ulHintFlags,
                                    lpSI->ulHintPri,
                                    lpFind32,
                                    CSCPROC_REASON_BEGIN,
                                    0,
                                    0,
                                    dwContext
                                    );
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            dwRet = CSCPROC_RETURN_ABORT;
        }

        lpFind32->dwReserved0 = dwsav0;
        lpFind32->dwReserved1 = dwsav1;

        if (dwRet != CSCPROC_RETURN_CONTINUE)
        {
            if (dwRet == CSCPROC_RETURN_ABORT)
            {
                dwError = ERROR_OPERATION_ABORTED;
            }
            else
            {
                dwError = ERROR_SUCCESS;
            }

            goto done;
        }
    }

    if (fStalenessCheck)
    {
        ReintKdPrint(FILL, ("Doing staleness check %ls \r\n", lpszFullPath));
        dwError = DoRefresh(hShadowDB, lpCP, lpszFullPath, lpSI, lptzDrive);

        if (dwError != NO_ERROR)
        {
            ReintKdPrint(ALWAYS, ("Error = %x on refresh for %ls \r\n", dwError, lpszFullPath));
            goto bailout;
        }

        if (!(lpSI->uStatus & SHADOW_SPARSE) && !(lpFind32->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            HANDLE hFile;


            if (    !lpfnProgress ||    // if this is not UI
                    (uStatus & FLAG_CSC_USER_ACCESS_MASK) || // or the user already has a mask
                    ((uStatus & FLAG_CSC_GUEST_ACCESS_MASK)== // or the guest has full permission
                        ((FLAG_CSC_READ_ACCESS|FLAG_CSC_WRITE_ACCESS)
                            <<FLAG_CSC_GUEST_ACCESS_SHIFT_COUNT)))
            {
                goto done;
            }

            // open the file to get the access rights for the user

            hFile = CreateFile(lpszFullPath,
                                     GENERIC_READ,
                                     FILE_SHARE_READ,
                                     NULL,
                                     OPEN_EXISTING,
                                     0,
                                     NULL);

            if (hFile != INVALID_HANDLE_VALUE)
            {
                CloseHandle(hFile);
            }
            else
            {
                dwError = GetLastError();
                goto bailout;
            }

            goto done;
        }

        if (!lpSI->hDir || !mShadowIsFile(lpSI->uStatus))
        {
            ReintKdPrint(FILL, ("Done staleness check for directory %ls, quitting \r\n", lpszFullPath));
            goto done;
        }
    }

    Assert(mShadowIsFile(lpSI->uStatus));
    Assert((lpSI->uStatus & SHADOW_SPARSE));

    fIsSlowLink = FALSE;    // on NT we are always going aggressively
    cbRead = (fIsSlowLink)?FILL_BUF_SIZE_SLOWLINK:FILL_BUF_SIZE_LAN;

    for (cntRetries=0; cntRetries<cntMaxRetries; ++cntRetries)
    {

        memset(&CopyChunkContext, 0, sizeof(CopyChunkContext));
        CopyChunkContext.handle = INVALID_HANDLE_VALUE;
        if (fAmAgent)
        {
            CopyChunkContext.dwFlags |= COPYCHUNKCONTEXT_FLAG_IS_AGENT_OPEN;
        }

        if (!OpenFileWithCopyChunkIntent(hShadowDB, lpszFullPath,
                                         &CopyChunkContext,
                                         (fIsSlowLink)?FILL_BUF_SIZE_SLOWLINK
                                                      :FILL_BUF_SIZE_LAN
                                         )) {
            dwError = GetLastError();
            if(dwError == ERROR_LOCK_VIOLATION)
            {
                if (cntMaxRetries > 1)
                {
                    ReintKdPrint(FILL, ("LockViolation, Retrying Sparse filling %ls \r\n", lpszFullPath));
                    Sleep(1000);
                    continue;
                }
            }
            ReintKdPrint(FILL, ("error %x, OpenCopyChunk failed %ls \r\n", dwError, lpszFullPath));
            goto bailout;
        }

        do {
            CopyChunkContext.ChunkSize = cbRead;

            if (FAbortOperation())
            {
                dwError = ERROR_OPERATION_ABORTED;
                goto done;
            }


            if((CopyChunk(hShadowDB, lpSI, &CopyChunkContext)) == 0){

                // NB we break here deliberately in order to get into the outer loop
                // where we will retry the operation
                dwError = GetLastError();
                ReintKdPrint(FILL, ("error %x, CopyChunk failed %ls \r\n", dwError, lpszFullPath));
                break;
            }

            if (lpfnProgress)
            {
                dwRet = (*lpfnProgress)(  lpszFullPath,
                                    lpSI->uStatus,
                                    lpSI->ulHintFlags,
                                    lpSI->ulHintPri,
                                    lpFind32,
                                    CSCPROC_REASON_MORE_DATA,
                                    (DWORD)(CopyChunkContext.LastAmountRead+
                                            CopyChunkContext.TotalSizeBeforeThisRead),    // low dword of bytes transferred
                                    0,
                                    dwContext
                                    );

                if (dwRet != CSCPROC_RETURN_CONTINUE)
                {
                    // once we start copying, any return code
                    // other than continue is abort
                    dwError = ERROR_OPERATION_ABORTED;
                    goto done;
                }
            }

// NB there seems to be a timing window here. The file could get out of ssync
// by the time we came here and it could have been marked sparse by then
            if (!CopyChunkContext.LastAmountRead) {
                SetShadowInfo(hShadowDB, lpSI->hDir, lpSI->hShadow, NULL, (unsigned long)~SHADOW_SPARSE, SHADOW_FLAGS_AND);
                ReintKdPrint(FILL, ("Done Sparse filling %ls \r\n", lpszFullPath));
                goto success;
            }


        }while (TRUE);

        if (dwError == ERROR_GEN_FAILURE)
        {
            // this might be due to the fact that
            // the guy we were piggybacking on went away
            // Just try a few times

            ReintKdPrint(FILL, ("Retrying Sparse filling %ls \r\n", lpszFullPath));
            CloseFileWithCopyChunkIntent(hShadowDB, &CopyChunkContext);
            CopyChunkContext.handle = INVALID_HANDLE_VALUE;
            dwError = 0xffffffff;
            continue;
        }
        else if (dwError != NO_ERROR)
        {
            ReintKdPrint(BADERRORS, ("Error %x while Sparse filling %ls \r\n", dwError, lpszFullPath));
            goto bailout;
        }

    }

success:

   dwError = NO_ERROR;
   goto done;

bailout:


    // if the net is disconnected then put the whole share in the skip queue
    // else put the file in the queue
    if (IsNetDisconnected(dwError))
    {
#ifdef DEBUG
         EnterSkipQueue(lpSI->hShare, 0, 0, lpszFullPath);
#else
         EnterSkipQueue(lpSI->hShare, 0, 0);
#endif //DEBUG
    }
    else
    {
#ifdef DEBUG
         EnterSkipQueue(lpSI->hShare, lpSI->hDir, lpSI->hShadow, lpszFullPath);
#else
         EnterSkipQueue(lpSI->hShare, lpSI->hDir, lpSI->hShadow);
#endif //DEBUG

    }

    ReportLastError();

done:

    if (lpfnProgress)
    {
        dwRet = (*lpfnProgress)( lpszFullPath,
                         lpSI->uStatus,
                         lpSI->ulHintFlags,
                         lpSI->ulHintPri,
                         lpFind32,
                         CSCPROC_REASON_END,
                         (DWORD)(CopyChunkContext.LastAmountRead+
                                 CopyChunkContext.TotalSizeBeforeThisRead),    // low dword of bytes transferred
                         dwError,    // errorcode
                         dwContext
                         );

        if (dwRet == CSCPROC_RETURN_ABORT)
        {
            dwError = ERROR_OPERATION_ABORTED;
        }

    }

    if (CopyChunkContext.handle != INVALID_HANDLE_VALUE){
        CloseFileWithCopyChunkIntent(hShadowDB, &CopyChunkContext);
    }

    if (hAnchor != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hAnchor);
    }

    DoShadowMaintenance(hShadowDB, SHADOW_END_INODE_TRANSACTION);

    return (dwError);
}

BOOL
CheckForStalenessAndRefresh(
    HANDLE          hShadowDB,
    _TCHAR          *lptzDrive,
    LPCOPYPARAMS    lpCP,
    _TCHAR          *lpRemoteName,
    LPSHADOWINFO    lpSI
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    BOOL fDone = FALSE, fDisabledShadowing=FALSE;
    WIN32_FIND_DATA sFind32;
    BOOL fExists = FALSE;

    // Let us get the latest info
    if (GetRemoteWin32Info(lptzDrive, lpCP, &sFind32, &fExists))
    {
        // If this is a file, update the file status
        if (lpSI->hDir && mShadowIsFile(lpSI->uStatus))
        {
            if (!(lpSI->uStatus & SHADOW_STALE))
            {
                ReintKdPrint(FILL, ("Checking update status for a file %ls\r\n", lpRemoteName));
                // compare the timestamp as obtained from the
                // server with that on the database. If the two are the same
                // the file in our database is still consistent with the one on the server
                // Otherwise the call below will mark it as stale
                if(ChkUpdtStatus(   hShadowDB,
                                    lpSI->hDir,
                                    lpSI->hShadow,
                                    &sFind32, &(lpSI->uStatus)) == 0){
                    ReintKdPrint(BADERRORS, ("ChkUpdt failed %X \r\n", lpSI->hShadow));
                    goto bailout;
                }

            }

            if (lpSI->uStatus & SHADOW_STALE)
            {
                // if it changed from being a file, then mark it a orphan
                // else truncate it's data and mark it sparse
                if (IsFile(sFind32.dwFileAttributes))
                {
                    ReintKdPrint(FILL, ("File %ls is stale, truncating\r\n", lpRemoteName));

                    if(SetShadowInfo(hShadowDB, lpSI->hDir, lpSI->hShadow, &sFind32, 0, SHADOW_FLAGS_OR|SHADOW_FLAGS_TRUNCATE_DATA))
                    {
                        lpSI->uStatus &= ~SHADOW_STALE;
                        lpSI->uStatus |= SHADOW_SPARSE;

                        fDone = TRUE;
                    }
                }
                else
                {
                    ReintKdPrint(FILL, ("File %ls become directory, marking orphan\r\n", lpRemoteName));
                    if(SetShadowInfo(hShadowDB, lpSI->hDir, lpSI->hShadow, NULL, SHADOW_ORPHAN, SHADOW_FLAGS_OR))
                    {
                        lpSI->uStatus |= SHADOW_ORPHAN;

                        fDone = TRUE;
                    }
                }
            }
            else
            {
                fDone = TRUE;
            }
        }
        else
        {
            // NB, we do nothing if a directory changed to file
            // we are letting the scavenging code remove the entries in due course.
            // If one of the descendents of this directory are pinned, then they stay on
            // in the database till the user actually cleans then up.
            // Need a good startegy to warn the user about it.

            if (!IsFile(sFind32.dwFileAttributes))
            {
                // this is a directory
                // update it's win32 data so that things like attributes get updated
                // We get here only during fullsync operations
                if(SetShadowInfo(hShadowDB, lpSI->hDir, lpSI->hShadow, &sFind32, ~(SHADOW_STALE), SHADOW_FLAGS_AND|SHADOW_FLAGS_CHANGE_83NAME))
                {
                    fDone = TRUE;
                }
            }

        }
    }

bailout:

    if (fDisabledShadowing)
    {
        int iEnable;

        iEnable = EnableShadowingForThisThread(hShadowDB);

        Assert(iEnable);

    }

    if (!fDone)
    {
        ReportLastError();

    }

    return (fDone);
}

DWORD
DWConnectNetEx(
    _TCHAR * lpSharePath,
    _TCHAR * lpOutDrive,
    BOOL fInteractive
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    NETRESOURCE sNR;
    DWORD dwError;
    _TCHAR szErr[16], szNP[16];

    if (lpOutDrive){
        lpOutDrive[0]='E';   // Let use start searching from e:
        lpOutDrive[1]=':';
        lpOutDrive[2]=0;
    }
    do{
        memset(&sNR, 0, sizeof(NETRESOURCE));
        sNR.lpRemoteName = lpSharePath;
        if (lpOutDrive){
            if(lpOutDrive[0]=='Z') {
                break;
            }
            sNR.lpLocalName = lpOutDrive;
        }
        sNR.dwType = RESOURCETYPE_DISK;
        dwError = WNetAddConnection3(vhwndMain, &sNR, NULL, NULL, 0);
        if (dwError==WN_SUCCESS){
            break;
        }
        else if (lpOutDrive &&
                    ((dwError == WN_BAD_LOCALNAME)||
                    (dwError == WN_ALREADY_CONNECTED))){
            ++lpOutDrive[0];
            continue;
        }
        else{
            if (dwError==WN_EXTENDED_ERROR){
                WNetGetLastError(&dwError, szErr, sizeof(szErr), szNP, sizeof(szNP));
            }
            break;
        }
    }
    while (TRUE);

    if ((dwError == ERROR_SUCCESS) && !IsShareReallyConnected((LPCTSTR)lpSharePath))
    {
        WNetCancelConnection2((lpOutDrive)?lpOutDrive:lpSharePath, 0, FALSE);
        SetLastError(dwError = ERROR_REM_NOT_LIST);
    }

    return (dwError);
}

/************************** Skip queue related operations *******************/

#ifdef DEBUG
VOID
EnterSkipQueue(
    HSHARE hShare,
    HSHADOW hDir,
    HSHADOW hShadow,
    _TCHAR * lpPath
    )
#else
VOID
EnterSkipQueue(
    HSHARE hShare,
    HSHADOW hDir,
    HSHADOW hShadow
    )
#endif //DEBUG
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    LPFAILINFO lpFI = NULL;
    LPFAILINFO FAR * lplpFI;

    if (!EnterAgentCrit()){
        return;
    }

    if(lplpFI = LplpFindFailInfo(hShare, hDir, hShadow)){
        lpFI = *lplpFI;
    }

    if (!lpFI){
        if (lpFI = (LPFAILINFO)AllocMem(sizeof(FAILINFO))){
            lpFI->hShare = hShare;
            lpFI->hDir = hDir;
            lpFI->hShadow = hShadow;
#ifdef DEBUG
            lstrcpyn(lpFI->rgchPath, lpPath, MAX_SERVER_SHARE_NAME_FOR_CSC);
#endif //DEBUG
            lpFI->cntFail = 1;
            lpFI->cntMaxFail = (hShadow)?MAX_ATTEMPTS_SHADOW:MAX_ATTEMPTS_SHARE;
            lpFI->lpnextFI = lpheadFI;
            lpheadFI = lpFI;
        }
    }

    if (lpFI){
        if (lpFI->cntFail >= lpFI->cntMaxFail){
            lpFI->dwFailTime = GetTickCount();
            ReintKdPrint(SKIPQUEUE, ("EnterSkipQueue: Marking %ls for Skipping \r\n", lpPath));
        } else{
            // Increment the fail count
            lpFI->cntFail++;
            ReintKdPrint(SKIPQUEUE, ("EnterSkipQueue: Incementing failcount for %ls \r\n", lpPath));
        }
    }
   LeaveAgentCrit();
}


BOOL
PRIVATE
FSkipObject(
    HSHARE hShare,
    HSHADOW hDir,
    HSHADOW hShadow
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    LPFAILINFO FAR *lplpFI;

    if (!EnterAgentCrit()){
        return 0;
    }

    if (lplpFI = LplpFindFailInfo(hShare, hDir, hShadow)){
        if ((*lplpFI)->cntFail >= (*lplpFI)->cntMaxFail) {
            LeaveAgentCrit();
            return TRUE;
        }
    }

    LeaveAgentCrit();
    return FALSE;
}

int
PRIVATE
PurgeSkipQueue(
    BOOL fAll,
    HSHARE  hShare,
    HSHADOW  hDir,
    HSHADOW  hShadow
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    LPFAILINFO FAR *lplpFI = NULL, lpfiTemp;
    DWORD dwCurTime = GetTickCount();
    int cntUnmark=0;

    if (!EnterAgentCrit()){
        return 0;
    }

    for (lplpFI = &lpheadFI; *lplpFI; lplpFI = &((*lplpFI)->lpnextFI)){

        if (fAll ||
            ((dwCurTime - (*lplpFI)->dwFailTime) > WAIT_INTERVAL_SKIP_MS)){
            if ((!hShare || (hShare==(*lplpFI)->hShare))
                && (!hDir || (hDir==(*lplpFI)->hDir))
                && (!hShadow || (hShadow==(*lplpFI)->hShadow)))
                {
                    ReintKdPrint(SKIPQUEUE, ("PurgeSkipQueue: Purging Skip Queue Entry for %s \r\n"
                                    ,(*lplpFI)->rgchPath));
                    lpfiTemp = *lplpFI;
                    *lplpFI = lpfiTemp->lpnextFI;
                    FreeMem(lpfiTemp);
                    ++cntUnmark;
                    if (!*lplpFI){
                        break;
                    }
                }
            }
        }
    LeaveAgentCrit();
    return (cntUnmark);
}

LPFAILINFO FAR *
LplpFindFailInfo(
    HSHARE hShare,
    HSHADOW hDir,
    HSHADOW hShadow
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    LPFAILINFO FAR *lplpFI = NULL;

    // look for the inode or the server entry

    for (lplpFI = &lpheadFI; *lplpFI; lplpFI = &((*lplpFI)->lpnextFI)) {
            if ((hShadow && (hShadow ==  (*lplpFI)->hShadow)) ||
                (hShare && ((*lplpFI)->hShare == hShare))){
            return (lplpFI);
        }
    }
    return (NULL);
}



VOID
ReportLastError(
    VOID
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    DWORD dwError;

    dwError = GetLastError();

    ReintKdPrint(FILL, ("Error # %ld \r\n", dwError));
}

VOID
PRIVATE
ReportStats(
    VOID
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    ReintKdPrint(BADERRORS, ("dirty=%d stale=%d sparse=%d \r\n"
            , vcntDirty
            , vcntStale
            , vcntSparse));
}


VOID
PRIVATE
CopyPQInfoToShadowInfo(
    LPPQPARAMS     lpPQ,
    LPSHADOWINFO   lpShadowInfo
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    lpShadowInfo->hShare = lpPQ->hShare;
    lpShadowInfo->hDir = lpPQ->hDir;
    lpShadowInfo->hShadow = lpPQ->hShadow;
    lpShadowInfo->uStatus = lpPQ->ulStatus;   //Sic
}

int
PRIVATE
DisplayMessageBox(
    HWND  hwndParent,
    int   rsText,
    int   rsTitle,
    UINT uStyle
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    _TCHAR szText[128], szTitle[128];
    int iRet=-1;

    if (!rsTitle ||
        !LoadString(vhinstCur, rsTitle, (_TCHAR *)szTitle, sizeof(szTitle))){
      szTitle[0] = '\0';
    }

    if (LoadString(vhinstCur, rsText, (_TCHAR *)szText, sizeof(szText))){
        iRet = MessageBox(hwndParent, (_TCHAR *)szText, (_TCHAR *)szTitle, uStyle);
    }
    return (iRet);
}

int
PUBLIC
EnterAgentCrit(
    VOID
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    if (!vhMutex){
        return 0;
    }
    WaitForSingleObject(vhMutex, INFINITE);
    return 1;
}

VOID
PUBLIC
LeaveAgentCrit(
    VOID
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    ReleaseMutex(vhMutex);
}



BOOL
FGetConnectionList(
    LPCONNECTINFO *lplpHead,
    int *lpcntDiscon
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    return (FGetConnectionListEx(lplpHead, NULL, FALSE, FALSE, lpcntDiscon));
}

BOOL
FGetConnectionListEx(
    LPCONNECTINFO   *lplpHead,
    LPCTSTR         lptzShareName,
    BOOL            fAllSharesOnServer,
    BOOL            fServerIsOffline,
    int             *lpcntDiscon
    )
/*++

Routine Description:

    This routine makes a list of shares that are connected and are in disconnected state.
    If lptzShareName is not NULL it returns all the mapping of that share that are
    in disconnected state.

    This is the first of a trilogy of routines used while doing a merge. The other two are
    DisconnectList and ReconnectList.

Arguments:

    lplpHead        head of the list is created here.

    lptzShareName   list of connections for this share, if NULL, list of all connected shares

    lpcntDiscon     # of shares in the list. Can be NULL.

Returns:

    TRUE if there are some entries in the connection list

Notes:

    List is allocated using LocalAlloc. It is upto the caller to free it.

--*/
{
    HANDLE hEnum;
    DWORD cbNum, cbSize, dwError, dwDummy, len=0;
    LPCONNECTINFO lpCI;
    WIN32_FIND_DATA sFind32;


    ReintKdPrint(MERGE, ("Getting conection list\r\n"));

    try
    {
        if (lpcntDiscon){
            *lpcntDiscon = 0;
        }

        *lplpHead = NULL;

        if (lptzShareName)
        {
            len = lstrlen(lptzShareName);
            if (fAllSharesOnServer)
            {
                _TCHAR *lpT, chT;
            
                len = 2;
                for (lpT = (LPTSTR)lptzShareName+2;;)
                {
                    chT = *lpT++;
                
                    Assert(chT);
                    if (chT == (_TCHAR)'\\')
                    {
                        break;
                    }

                    ++len;
                }
                ReintKdPrint(MERGE, ("Nuking shares %ls len %d \n", (LPTSTR)lptzShareName, len));
            }
        }

        // enumerate all connected shares
        if (WNetOpenEnum(   RESOURCE_CONNECTED,
                            RESOURCETYPE_DISK, RESOURCEUSAGE_CONNECTABLE,
                            NULL, &hEnum) == NO_ERROR ){
            do{
                cbNum = 1;
                cbSize = sizeof(dwDummy);
                dwError = WNetEnumResource(hEnum, &cbNum, &dwDummy, &cbSize);

                if (dwError==ERROR_MORE_DATA){

                    if (lpCI =
                        (LPCONNECTINFO)AllocMem(sizeof(CONNECTINFO)+cbSize)){
                        cbNum = 1;
                        dwError = WNetEnumResource(hEnum, &cbNum
                                    , &(lpCI->rgFill[0])
                                    , &cbSize);

                        if (!cbNum || (dwError!=NO_ERROR)){
                            FreeMem(lpCI);
                            break;
                        }
                        if(lptzShareName)
                        {

                            // do case insensitive prefix matching and ensure that
                            // the next character after the match is a path delimiter

                            if (!((CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, 
                                            lptzShareName, len,
                                            ((NETRESOURCE *)&(lpCI->rgFill[0]))->lpRemoteName,len)
                                            == CSTR_EQUAL)&&
                                ((((NETRESOURCE *)&(lpCI->rgFill[0]))->lpRemoteName[len] == (_TCHAR)'\\')||
                                 (((NETRESOURCE *)&(lpCI->rgFill[0]))->lpRemoteName[len] == (_TCHAR)0))))
                            {
                                FreeMem(lpCI);
                                continue;
                            }

                            ReintKdPrint(MERGE, ("Got %ls on %ls\r\n"
                                , (((NETRESOURCE *)&(lpCI->rgFill[0]))->lpLocalName)?((NETRESOURCE *)&(lpCI->rgFill[0]))->lpLocalName:L"Empty"
                                , ((NETRESOURCE *)&(lpCI->rgFill[0]))->lpRemoteName));

                        }
                        lpCI->lpnextCI = *lplpHead;
                        *lplpHead = lpCI;

                        if (!fServerIsOffline)
                        {
                            BOOL fRet;
                            SHADOWINFO sSI;
                            fRet = FindCreateShadowFromPath(((NETRESOURCE *)&(lpCI->rgFill[0]))->lpRemoteName,
                                                            FALSE, // Don't create, just look
                                                            &sFind32,
                                                            &sSI,
                                                            NULL
                                                            );
                            lpCI->uStatus = 0;                                                            
                            if (fRet && sSI.hShadow)
                            {
                                lpCI->uStatus = sSI.uStatus;
                            }
                        }
                        else
                        {
                            lpCI->uStatus |= SHARE_DISCONNECTED_OP;
                        }
                        if (lpcntDiscon && (lpCI->uStatus & SHARE_DISCONNECTED_OP)){
                            ++*lpcntDiscon;
                        }
                    }
                    else{
                        //PANIC
                        break;
                    }
                }
                else{
                    break;
                }
            }while (TRUE);
            WNetCloseEnum(hEnum);
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        ReintKdPrint(BADERRORS, ("Took exception in FGetConnectionListEx list \n"));
    }

    return (*lplpHead != NULL);
}

int
DisconnectList(
    LPCONNECTINFO       *lplpHead,
    LPFNREFRESHPROC     lpfn,
    DWORD               dwCookie
)
/*++

Routine Description:

    disconnects all drive mapped shares in a list accumulated using FGetConnectionList

Arguments:


Returns:


Notes:

--*/
{
    BOOL fOk = TRUE;
    DWORD dwError;
    int icntDriveMapped=0;
    LPCONNECTINFO lpTmp = *lplpHead;

    ReintKdPrint(MERGE, ("In DisconnectList \n"));
    
    try
    {
        for (;lpTmp;lpTmp = lpTmp->lpnextCI){
        
            if (!(lpTmp->uStatus & SHARE_DISCONNECTED_OP))
            {
                continue;
            }
            if (((NETRESOURCE *)&(lpTmp->rgFill[0]))->lpLocalName){
        
                ++icntDriveMapped;

                ReintKdPrint(MERGE, ("Nuking %ls on %ls\r\n"
                    , ((NETRESOURCE *)&(lpTmp->rgFill[0]))->lpLocalName
                    , ((NETRESOURCE *)&(lpTmp->rgFill[0]))->lpRemoteName));
                dwError = WNetCancelConnection2( ((NETRESOURCE *)&(lpTmp->rgFill[0]))->lpLocalName, 0, TRUE);

            }
            else{
                ReintKdPrint(MERGE, ("Nuking %ls \r\n" , ((NETRESOURCE *)&(lpTmp->rgFill[0]))->lpRemoteName));
                dwError = WNetCancelConnection2(
                    ((NETRESOURCE *)&(lpTmp->rgFill[0]))->lpRemoteName
                    , 0
                    , TRUE);
            }

            if (dwError != NO_ERROR){
                ReintKdPrint(BADERRORS, ("Error=%ld \r\n", dwError));
                fOk = FALSE;
            }
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        ReintKdPrint(BADERRORS, ("Took exception in Disconnecte list \n"));
        fOk = FALSE;
    }

    ReintKdPrint(MERGE, ("Out DisconnectList %x\n", (fOk?icntDriveMapped:-1)));
    return (fOk?icntDriveMapped:-1);
}

int
CALLBACK
RefreshProc(
    LPCONNECTINFO  lpCI,
    DWORD          dwCookie // LOWORD 0==Silently, 1== Give messages
                           // HIWORD 0==Nuke UNC, 1==Nuke all if no ongoing open/finds
                           // 2==Maximum force for shadow 3==Nuke ALL
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    WORD  wVerbose = LOWORD(dwCookie), wForce = HIWORD(dwCookie);
    int iRet = 0;
    BOOL fDisconnectedOp=FALSE, fOpensFinds = FALSE;


    fDisconnectedOp = (lpCI->uStatus & SHARE_DISCONNECTED_OP);
    fOpensFinds = (lpCI->uStatus & (SHARE_FILES_OPEN|SHARE_FINDS_IN_PROGRESS));

    switch (wForce){
        case 0://shadow UNC connections with no opens/finds in progress
            iRet = (fDisconnectedOp && !fOpensFinds && !((NETRESOURCE *)&(lpCI->rgFill[0]))->lpLocalName)?1:0;
            break;
        case 1://shadow connections (UNC+drivemapped) with no opens/finds in progress
            iRet = (fDisconnectedOp && !fOpensFinds)?1:0;
            break;
        case 2://shadow connections with or without opens/finds
            iRet = (fDisconnectedOp)?1:0;
            break;
        case 3://all connections
            iRet = 1;
            break;
    }
    if ((iRet==1) && wVerbose && fOpensFinds){
        LoadString(vhinstCur, IDS_OPS_IN_PROGRESS, (LPTSTR)(vrgchBuff), 128 * sizeof(TCHAR));
        LoadString(vhinstCur, IDS_SHADOW_AGENT, (LPTSTR)(vrgchBuff+128* sizeof(TCHAR)), 128* sizeof(TCHAR));
        wsprintf((LPTSTR)(vrgchBuff+256), (LPTSTR)(vrgchBuff), ((NETRESOURCE *)&(lpCI->rgFill[0]))->lpRemoteName);
        MessageBox(vhwndMain, (LPTSTR)(vrgchBuff+256* sizeof(TCHAR)), (LPTSTR)(vrgchBuff+128* sizeof(TCHAR)), MB_OK);
    }

    return (iRet);
}


//
// Reconnects a list of shares
// if you pass in a parent HWND then you will get UI
//
int
ReconnectList(
    LPCONNECTINFO   *lplpHead,
    HWND            hwndParent
    )
/*++

Routine Description:

    reconnects all the connections in disconnected state.


Arguments:


Returns:


Notes:

--*/
{
    int iDone = 0;
    DWORD dwError;
    LPCONNECTINFO lpTmp = *lplpHead;
    _TCHAR * lpSave;
    HWND hwndUI=NULL;

    try
    {
        for (;lpTmp;lpTmp = lpTmp->lpnextCI){
        
            if (!(lpTmp->uStatus & SHARE_DISCONNECTED_OP))
            {
                continue;
            }

            if (((NETRESOURCE *)&(lpTmp->rgFill[0]))->lpLocalName){
                ReintKdPrint(MERGE, ("Adding back %ls on %ls\r\n"
                , ((NETRESOURCE *)&(lpTmp->rgFill[0]))->lpLocalName
                , ((NETRESOURCE *)&(lpTmp->rgFill[0]))->lpRemoteName));

            }
            else{
                ReintKdPrint(MERGE, ((LPSTR)vrgchBuff, "Adding back %ls\r\n" , ((NETRESOURCE *)&(lpTmp->rgFill[0]))->lpRemoteName));
            }

            lpSave = ((NETRESOURCE *)&(lpTmp->rgFill[0]))->lpProvider;
            ((NETRESOURCE *)&(lpTmp->rgFill[0]))->lpProvider = NULL;
            dwError = WNetAddConnection3(vhwndMain, (NETRESOURCE *)&(lpTmp->rgFill[0]), NULL, NULL, CONNECT_INTERACTIVE);
            ((NETRESOURCE *)&(lpTmp->rgFill[0]))->lpProvider = lpSave;
            if (dwError!=NO_ERROR){

                ReintKdPrint(BADERRORS, ("Error=%ld \r\n", dwError));
                iDone = -1;
            }
            else if (iDone >= 0){
                ++iDone;
            }
        }

        if( hwndUI ){

            DestroyWindow(hwndUI);
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        ReintKdPrint(BADERRORS, ("Took exception in Reconnect list \n"));
        iDone = 0;
    }
    return (iDone);
}

VOID
ClearConnectionList(
    LPCONNECTINFO *lplpHead
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    LPCONNECTINFO lpTmp = *lplpHead, lpSave;
    for (;lpTmp;){
        lpSave = lpTmp->lpnextCI;
        FreeMem(lpTmp);
        lpTmp = lpSave;
    }
    *lplpHead = NULL;
}

BOOL
PRIVATE
IsSlowLink(
    _TCHAR * lpPath
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    NETRESOURCE sNR;
    NETCONNECTINFOSTRUCT sNCINFO;
    int done = 0;
    BOOL fRet = FALSE;

    memset(&sNCINFO, 0, sizeof(NETCONNECTINFOSTRUCT));
    sNCINFO.cbStructure = sizeof(NETCONNECTINFOSTRUCT);
    memset(&sNR, 0, sizeof(NETRESOURCE));
    sNR.lpRemoteName=lpPath;
    if ((MultinetGetConnectionPerformance(&sNR, &sNCINFO)==WN_SUCCESS)
       && (sNCINFO.dwSpeed < SLOWLINK_SPEED)){
        fRet = TRUE;
    }

    return (fRet);
}


int RefreshConnectionsInternal(
   int  force,
   BOOL verbose
   )
{
    return (RefreshConnectionsEx(force, verbose, NULL, 0));
}


int
BreakConnectionsInternal(
    int  force,
    BOOL verbose
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    LPCONNECTINFO lpHead = NULL;
    if (FGetConnectionList(&lpHead, NULL)){
        DisconnectList(&lpHead, RefreshProc, MAKELONG(verbose,force));
        ClearConnectionList(&lpHead);
        return (1);
    }
    return (0);
}


//
// This refreshes all the connections.
// Force -
// Verbose - causes annoying UI to be displayed
// lpfn -
// dwCookie - parameter for lpfn
//
int RefreshConnectionsEx(
    int  force,
    BOOL verbose,
    LPFNREFRESHEXPROC lpfn,
    DWORD dwCookie)
{
    int cntDriveMapped, iRet = -1;
    LPCONNECTINFO lpHead = NULL;

    if (FGetConnectionList(&lpHead, NULL)){
        cntDriveMapped = DisconnectList(&lpHead, RefreshProc, MAKELONG(verbose,force));
        if (cntDriveMapped < 0){
            goto bailout;
        }
        if (lpfn){
            (*lpfn)(cntDriveMapped, dwCookie);
        }
        if (cntDriveMapped > 0){
            ReconnectList(&lpHead,verbose?vhwndMain:NULL);
        }
        ClearConnectionList(&lpHead);
        iRet = 1;
    }
    else
    {
        iRet = 0;
    }

bailout:

    return iRet;
}


BOOL
FCheckAncestor(
    node *lpnodeList,
    LPCOPYPARAMS lpCP
    )
{
    node *lpItem;
    BOOL fHaveAncestor = FALSE;
    unsigned lenDest;
#ifdef DEBUG
    unsigned lenSrc;
#endif

#ifdef DEBUG
    lenSrc = lstrlen(lpCP->lpRemotePath);
#endif
    for(lpItem = lpnodeList; lpItem; lpItem = lpItem->next)
    {
        // is it on the same share?
        if (!lstrcmpi(lpItem->lpCP->lpSharePath, lpCP->lpSharePath))
        {
            // check upto the length of the ancestor. By definition he is supposed to be smaller
            // than the src
            lenDest = lstrlen(lpItem->lpCP->lpRemotePath);
            Assert(lenDest <= lenSrc);

            // NB, we do memcmp because, the strings will have the same case
            // as they are obtained from the same source, ie, the CSC database.

            // is it a child of any item in the list?
            if (!memcmp(lpItem->lpCP->lpRemotePath, lpCP->lpRemotePath, lenDest * sizeof(_TCHAR)))
            {
                fHaveAncestor = TRUE;
                break;
            }
        }
    }

    return (fHaveAncestor);
}

DWORD
PRIVATE
GetUniqueName(
   _TCHAR * lpName,
   _TCHAR * lpUniqueName
   )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/

{
    int i=0, orglen;
    DWORD dwError;
    _TCHAR buff[10 * sizeof(_TCHAR)];

    lstrcpy(lpUniqueName, lpName);

    orglen = lstrlen(lpName);

    if (orglen >= MAX_PATH-1){
        lpUniqueName[MAX_PATH-5] = 0;
        orglen = MAX_PATH-5;
    }
    for (i=0; i<100; ++i){
        if (GetFileAttributes(lpUniqueName)==0xffffffff){
            dwError = GetLastError();
            if ((dwError==ERROR_FILE_NOT_FOUND)||
                (dwError == ERROR_PATH_NOT_FOUND)){
                break;
            }
        }
        lpUniqueName[orglen] = 0;
        wsprintf(buff, _TEXT("(%2d)"), i);
        lstrcat(lpUniqueName, (LPTSTR)buff);
    }
    if (i < 100){
        dwError = NO_ERROR;
    }
    else{
        dwError = 0xffffffff;
    }
    return(dwError);
}




#ifdef MAYBE_USEFUL

/***************************************************************************
 * reintegrate one server.
 */
//
// Pass in the Share to merge on
// and the parent window.
//
BOOL
PUBLIC
ReintOneShare(
    HSHARE hShare,
    HWND hwndParent
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/

{
    node  *lpnodeInsertList=NULL;                // merge file list.
    PQPARAMS sPQP;
    int state, iFileStatus, iShadowStatus;
    BOOL fConnected=FALSE, fBeginReint=FALSE, fDone = FALSE;
    BOOL fStamped = FALSE, fInsertInList = FALSE;
    SHADOWINFO  sSI;
    LPCOPYPARAMS lpCP = NULL;
    _TCHAR szDrive[3];
    unsigned long ulStatus, uAction;
    DWORD dwError;
    WIN32_FIND_DATA    sFind32Local, sFind32Remote;
    WIN32_FIND_DATA *lpFind32Remote = NULL;    // temporary variable
    HANDLE                hShadowDB;
    BOOL fAmAgent=FALSE;

    if ((hShadowDB = OpenShadowDatabaseIO()) ==INVALID_HANDLE_VALUE)
    {
        return FALSE;
    }

    fAmAgent = (GetCurrentThreadId() == vdwCopyChunkThreadId);

    lpCP = LpAllocCopyParams();

    if (!lpCP){

        ReintKdPrint(BADERRORS, ("ReintOneShare():Allocation of copyparam buffer failed \r\n"));

        goto bailout;
    }

    // Reint in multiple passes. Do directories first, files next
    for (state=STATE_REINT_BEGIN;state<STATE_REINT_END;++state) {
        if (FAbortOperation())
        {
            goto bailout;
        }
        dwError = NO_ERROR;
        memset(&sPQP, 0, sizeof(PQPARAMS));
        memset(&sSI, 0, sizeof(SHADOWINFO));

        // Start looking through the queue
        if(BeginPQEnum(hShadowDB, &sPQP) == 0) {
            goto bailout;
        }
        // Start looking through the queue
        do {

            if (FAbortOperation())
            {
                goto bailout;
            }

            if(PrevPriShadow(hShadowDB, &sPQP) == 0){
                break;
            }
            // end of this enumeration
            if (!sPQP.hShadow){
                break;
            }

            if ( mShadowOrphan(sPQP.ulStatus)||
                 mShadowSuspect(sPQP.ulStatus))
            {
                continue;
            }

            // keep going if this is a file and we are trying to reintegrate directories
            // or if this entry isn't from the server we are dealing with.
            if ((sPQP.hShare != hShare) ||
                 ((state != STATE_REINT_FILES) && mShadowIsFile(sPQP.ulStatus)) ||
                 ((state == STATE_REINT_FILES) && !mShadowIsFile(sPQP.ulStatus))){
                continue;
            }


            if (mShadowNeedReint(sPQP.ulStatus)){


                if (!fStamped){

                    StampReintLog();
                    fStamped = TRUE;
                }

                if (fAmAgent && FSkipObject(sPQP.hShare, 0, 0)){
                    continue;
                }

                if (!GetShadowInfo(hShadowDB, sPQP.hDir, sPQP.hShadow,
                    &sFind32Local, &ulStatus)){

                    ReintKdPrint(BADERRORS, ("ReintOneShare: GetShadowInfo failed\n"));
                    continue;
                }

                CopyPQInfoToShadowInfo(&sPQP, &sSI);

                sSI.lpFind32 = &sFind32Local;

                if(!GetUNCPath(hShadowDB, sPQP.hShare, sPQP.hDir, sPQP.hShadow, lpCP)){

                    ReintKdPrint(BADERRORS, ("ReintOneShare: GetUNCPath failed\n"));
                    continue;
                }
                if (!fConnected){
                    DWORD dwError2;
                    dwError2 = DWConnectNetEx(lpCP->lpSharePath, szDrive, TRUE);
                    if(dwError2 == WN_SUCCESS || dwError2 == WN_CONNECTED_OTHER_PASSWORD_DEFAULT)
                    {
                        fConnected = TRUE;

                        if (!BeginReint(hShadowDB, hShare)) {
                            goto bailout;
                        }

                        fBeginReint = TRUE;
                    }
                    else{
#ifdef DEBUG
                        EnterSkipQueue(sPQP.hShare, 0, 0, lpCP->lpSharePath);
#else
                        EnterSkipQueue(sPQP.hShare, 0, 0);
#endif //DEBUG
                        // try some other server for reintegration
                        goto bailout;
                    }
                }

                ReintKdPrint(BADERRORS, ("Merging local changes to <%s%s>\n", lpCP->lpSharePath, lpCP->lpRemotePath));

                Assert((sPQP.hShare == hShare) &&    // this is the given server
                        (
                         ((state != STATE_REINT_FILES) && !mShadowIsFile(sPQP.ulStatus)) ||
                         ((state == STATE_REINT_FILES) && mShadowIsFile(sPQP.ulStatus))
                        )
                      );

                fInsertInList = FALSE;

                lpFind32Remote = NULL;

                // if there is an insertion list, then check whether his ancestor
                // didn't fail in reintegration
                if (lpnodeInsertList)
                {
                    // if there is an acestor then we should put this guy in the list
                    fInsertInList = FCheckAncestor(lpnodeInsertList, lpCP);
                }

                // if we are not supposed to put him in the list then try getting
                // his win32 strucuture
                if (!fInsertInList)
                {
                    BOOL fExists;

                    GetRemoteWin32Info(NULL, lpCP, &sFind32Remote, &fExists);

                    // insert in list only if some error happened
                    if (fExists == -1)
                    {
                        fInsertInList = TRUE;
                    }

                    // passing remote find32 only if it succeeded
                    if (fExists == TRUE)
                    {
                        lpFind32Remote = &sFind32Remote;
                    }
                }

                // find out what needs to be done
                // this one central place to infer all the stuff
                InferReplicaReintStatus(
                                        &sSI,    // shadowinfo
                                        &sFind32Local,    // win32 info for the shadow
                                        lpFind32Remote,    // remote win32 info
                                        &iShadowStatus,
                                        &iFileStatus,
                                        &uAction
                                        );

                // insert if it had an ancestor in the list or some merge needed to be done
                fInsertInList = (fInsertInList || (uAction == RAIA_MERGE) || (uAction==RAIA_CONFLICT));

                if (!fInsertInList)
                {
                    ReintKdPrint(BADERRORS, ("Silently doing <%s%s>\n", lpCP->lpSharePath, lpCP->lpRemotePath));
                    fInsertInList = (PerformOneReint(
                                                    hShadowDB,
                                                    szDrive,
                                                    lpCP,
                                                    &sSI,
                                                    &sFind32Local,
                                                    lpFind32Remote,
                                                    iShadowStatus,
                                                    iFileStatus,
                                                    uAction
                                                    ) == FALSE);
                }

                if (fInsertInList)
                {
                    if(!insertList(    &lpnodeInsertList,
                                    lpCP,
                                    &sSI,
                                    &sFind32Local,
                                    lpFind32Remote,
                                    iShadowStatus,
                                    iFileStatus,
                                    uAction
                                    ))
                        {
                            ReintKdPrint(BADERRORS, ("ReintOneShare: insertlist failed in memory allocation \r\n"));
                            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                            fDone = FALSE;
                            goto bailout;
                        }
                        ReintKdPrint(BADERRORS, ("Inserted <%s%s> in list\n", lpCP->lpSharePath, lpCP->lpRemotePath));
                }
            }
        } while (sPQP.uPos); // Priority queue enumeration

        // Close the enumeration
        EndPQEnum(hShadowDB, &sPQP);

    }  // reint pass 1 & 2

    if (fBeginReint){
        // we found something to merge
        if (lpnodeInsertList)
        {
            ReintKdPrint(BADERRORS, ("Found reint list, doing UI \n"));
            fDone = DoFilesListReint(hShadowDB, szDrive, hwndParent, lpnodeInsertList);  // 1 if successful, -1 if error, 0 if cancelled
        }
        else
        {
            // all went well
            fDone = TRUE;
        }
    }

    if (fConnected){

        DWDisconnectDriveMappedNet(szDrive, TRUE); // force a disconnect
        fConnected = FALSE;
    }

    if (fDone==TRUE) {

        SetShareStatus(hShadowDB, hShare, (unsigned long)(~SHARE_REINT), SHADOW_FLAGS_AND);
    }

bailout:

    if (fBeginReint){
        EndReint(hShadowDB, hShare);
        fBeginReint = FALSE;
    }

    CloseShadowDatabaseIO(hShadowDB);

    if(lpnodeInsertList) {
        killList(lpnodeInsertList);
        lpnodeInsertList = NULL; //general paranoia
    }

    FreeCopyParams(lpCP);

    if (fConnected) {
        WNetCancelConnection2(szDrive, 0, FALSE);
    }

    // Remove the tray notification about merging
    if( CheckDirtyShares()==0 ) {

        Tray_Modify(vhwndMain,0,NULL);
    }

    return fDone;
}

/****************************************************************************
 *    Query the registry to see if we should make log copies
 */
VOID GetLogCopyStatus(VOID)
{
   HKEY hKey;
    DWORD dwSize = MAX_NAME_LEN;
    _TCHAR szDoCopy[MAX_NAME_LEN];

    // get the user name.
    if(RegOpenKey(HKEY_LOCAL_MACHINE, vszShadowReg, &hKey) !=  ERROR_SUCCESS) {
        ReintKdPrint(BADERRORS, ("GetLogCopyStatus: RegOpenKey failed\n"));
        return;
    }

    if(RegQueryValueEx(hKey, vszDoLogCopy, NULL, NULL, szDoCopy, &dwSize) != ERROR_SUCCESS) {
        RegCloseKey(hKey);
        ReintKdPrint(BADERRORS, ("GetLogCopyStatus: RegQueryValueEx failed\n"));
        return;
    }

    if(mystrnicmp(szDoCopy, MY_SZ_TRUE, strlen(szDoCopy)))
        vfLogCopying = FALSE;
    else
        vfLogCopying = TRUE;

    RegCloseKey(hKey);
}

/****************************************************************************
 *    Make a connection to the logging server and copy the log over.
 */
VOID CopyLogToShare(VOID)
{
   HKEY hKeyShadow;
    DWORD dwSize = MAX_NAME_LEN, dwRes;
    _TCHAR szComputerName[MAX_NAME_LEN];
    _TCHAR szLogDirPath[MAX_PATH], szLogPath[MAX_PATH];
    WIN32_FIND_DATAA sFind32;
    int iCurrFile=0;
    NETRESOURCE sNR;
    HANDLE hLog;

    // check to see if we should copy the log over.
    if(!vfLogCopying) {
        return;
    }

    // get the user name.
    if(RegOpenKey(HKEY_LOCAL_MACHINE, vszMachineName, &hKeyShadow) !=  ERROR_SUCCESS) {
        ReintKdPrint(BADERRORS, ("RegOpenKey failed\n"));
    }

    if(RegQueryValueEx(hKeyShadow, vszComputerName, NULL, NULL, szComputerName, &dwSize) != ERROR_SUCCESS) {
        RegCloseKey(hKeyShadow);
        ReintKdPrint(BADERRORS, ("RegQueryValueEx failed\n"));
        return;
    }
    RegCloseKey(hKeyShadow);

    lstrcpy(szLogDirPath, vszLogUNCPath);
    lstrcat(szLogDirPath, szComputerName);

    sNR.lpRemoteName = vszLogShare;
    sNR.lpLocalName = NULL;
    sNR.lpProvider = NULL;
    sNR.dwType = RESOURCETYPE_DISK;
    dwRes = WNetAddConnection3(vhwndMain, &sNR, NULL, NULL, CONNECT_TEMPORARY);
    if(dwRes != WN_SUCCESS) {
        ReintKdPrint(BADERRORS, ("CopyLogToShare() AddConn3 failed (%d)\n", dwRes));
        return;
    }

    // check to see if that dir lives on the server.
    if(!GetWin32Info(szLogDirPath, &sFind32)) {
        // if not, create it.
        ReintKdPrint(BADERRORS, ("dir not found\n"));
        if(!CreateDirectory(szLogDirPath, NULL)) {
            ReintKdPrint(BADERRORS, ("Create dir failed, reason = %d\n", GetLastError()));
        }
    }
    wsprintf(szLogPath, "%s\\status.log",szLogDirPath);
    // copy file over.
    ReintKdPrint(BADERRORS, ("we'll use <%s> next\n", szLogPath));
   if((hLog = CreateFile(szLogPath
                                  , GENERIC_READ|GENERIC_WRITE
                                  , FILE_SHARE_READ|FILE_SHARE_WRITE
                                  , NULL
                                  , OPEN_ALWAYS
                                  , 0
                                  , NULL)) != INVALID_HANDLE_VALUE) {
        ReintKdPrint(BADERRORS, ("file created\n"));
        AppendToShareLog(hLog);
        CloseHandle(hLog);
        } else {
        ReintKdPrint(BADERRORS, ("create failed, reason = %d\n", GetLastError()));
    }
    WNetCancelConnection2(vszLogShare, CONNECT_REFCOUNT, FALSE);
}

#define MAX_BUF_SIZE    1024

/****************************************************************************
 *    Copy the final stats from local log to the server version (hLog)
 */
VOID AppendToShareLog(HANDLE hLog)
{
    HANDLE hLocal=0;
    DWORD dwBytesRead, dwBytesWritten, dwPos, x;
    BOOL fDone=FALSE;
    _TCHAR cBuffer[MAX_BUF_SIZE];

   if((hLocal = CreateFile(vszLocalLogPath
                                  , GENERIC_READ
                                  , FILE_SHARE_READ
                                  , NULL
                                  , OPEN_EXISTING
                                  , 0
                                  , NULL)) != INVALID_HANDLE_VALUE) {
        ReintKdPrint(BADERRORS, ("local log file opened (0x%x)\n", hLocal));
        dwPos = SetFilePointer(hLog, 0, NULL, FILE_END);
        if(dwPos == 0xFFFFFFFF) {
            ReintKdPrint(BADERRORS, ("Failed seek on remote file, reason = %d\n", GetLastError()));
            goto cleanup;
        }
        dwPos = SetFilePointer(hLocal, 0, NULL, FILE_END);
        if(dwPos == 0xFFFFFFFF) {
            ReintKdPrint(BADERRORS, ("Failed seek on local file, reason = %d\n", GetLastError()));
            goto cleanup;
        }
        if((dwPos = SetFilePointer(hLocal, -MAX_BUF_SIZE, NULL, FILE_CURRENT)) == 0xFFFFFFFF)
            goto cleanup;

        // move backwards until we find the "!*" that I use as my start token.
        while(!fDone) {
            if(!ReadFile(hLocal, cBuffer, MAX_BUF_SIZE, &dwBytesRead, NULL) || !dwBytesRead) {
                if(!dwBytesRead) {
                    ReintKdPrint(BADERRORS, ("local eof\n"));
                } else {
                    ReintKdPrint(BADERRORS, ("R error: %d\n", GetLastError()));
                }
                goto cleanup;
            }

            for(x=0;x<dwBytesRead;x++) {
                if(cBuffer[x] == '!' && cBuffer[x+1] == '*') {
                    fDone = TRUE;
                    dwPos += x;
                    break;
                }
            }
            if(!fDone)
                if((dwPos = SetFilePointer(hLocal, -2*MAX_BUF_SIZE, NULL, FILE_CURRENT)) == 0xFFFFFFFF) {
                    ReintKdPrint(BADERRORS, ("seeked all the way and failed, error=%d\n",GetLastError()));
                    goto cleanup;
                }
        }
        // we have found the !*.  Seek there and copy until end of file.
        // tHACK.  We should have a final delimiter (ie: *!)
        if((dwPos = SetFilePointer(hLocal, dwPos, NULL, FILE_BEGIN)) == 0xFFFFFFFF)
            goto cleanup;
        for(;;) {
            if(!ReadFile(hLocal, cBuffer, MAX_BUF_SIZE, &dwBytesRead, NULL)) {
                ReintKdPrint(BADERRORS, ("R error: %d\n", GetLastError()));
                break;
            }
            if(dwBytesRead == 0)
                break;
            if(!WriteFile(hLog, cBuffer, dwBytesRead, &dwBytesWritten, NULL)) {
                ReintKdPrint(BADERRORS, ("W error: %d\n", GetLastError()));
                break;
            }
        }
    }
cleanup:
    if(hLocal)
        CloseHandle(hLocal);
    if(!FlushFileBuffers(hLog)) {
        ReintKdPrint(BADERRORS, ("FlushFileBuffers failed, reason = %d\n",GetLastError()));
    }
}

DWORD
PRIVATE
MoveConflictingFile(
   LPCOPYPARAMS     lpCP
   )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    DWORD dwError;
    _TCHAR * lpLeaf;


    lstrcpy(vrgchBuff, vszConflictDir);
    lstrcat(vrgchBuff, vszSlash);
    FormLocalNameFromRemoteName(vrgchBuff+strlen(vrgchBuff), lpCP->lpSharePath);

    dwError = InbCreateDir(vrgchBuff, 0xffffffff);

    if (dwError != NO_ERROR) {
        dwError = ERROR_NO_CONFLICT_DIR;
        goto bailout;
    }

    lpLeaf = GetLeafPtr(lpCP->lpRemotePath);

    lstrcat(vrgchBuff, vszSlash);
    lstrcat(vrgchBuff, lpLeaf);
    GetUniqueName(vrgchBuff, vrgchBuff+512);
    ReintKdPrint(BADERRORS, ("Shadow of %s!%s is saved as %s \r\n"
                  , lpCP->lpSharePath
                  , lpCP->lpRemotePath
                  , vrgchBuff+512));

    if(!MoveFile(lpCP->lpLocalPath, vrgchBuff+512)){
        dwError = GetLastError();
    }
    else{
        wsprintf(vrwBuff, "Shadow of %s!%s is saved as %s \r\n"
                     , lpCP->lpSharePath
                     , lpCP->lpRemotePath
                     , vrgchBuff+512);
        WriteLog(vrwBuff);
        dwError = 0;
    }
bailout:
    return (dwError);
}


VOID
PRIVATE
FormLocalNameFromRemoteName(
    _TCHAR * lpBuff,
    _TCHAR * lpRemoteName
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    int i;
    lstrcpy(lpBuff, lpRemoteName);
    for (i= strlen(lpRemoteName)-1; i>=0 ; --i){
        if (lpBuff[i]=='\\') {
            lpBuff[i] = '_';
        }
    }
}

int
PRIVATE
StampReintLog(
   VOID
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/

{
    SYSTEMTIME sST;

    GetLocalTime(&sST);
    wsprintf(vrgchBuff, vszTimeDateFormat, sST.wHour, sST.wMinute, sST.wSecond, sST.wMonth, sST.wDay, sST.wYear);
    return (WriteLog(vrgchBuff));
}

int PRIVATE LogReintError(
    DWORD          dwError,
    _TCHAR *          lpSharePath,
    _TCHAR *          lpRemotePath
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/

{
    int i;

    for (i=0; i< sizeof(rgErrorTab)/sizeof(ERRMSG); ++i){
        if (dwError == rgErrorTab[i].dwError){
            LoadString(vhinstCur, rgErrorTab[i].uMessageID, vrgchBuff, 128);
            wsprintf(vrgchBuff+128, "%s%s: %s \r\n"
                  , lpSharePath
                  , lpRemotePath
                  , vrgchBuff);
            WriteLog(vrgchBuff+128);
            return (1);
         }
    }
    wsprintf(vrgchBuff, "%s%s: ", lpSharePath, lpRemotePath);
    WriteLog(vrgchBuff);
    if (FormatMessage(  FORMAT_MESSAGE_FROM_SYSTEM,
                        NULL, dwError,
                        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                        vrgchBuff, sizeof(vrgchBuff), NULL)){
        WriteLog(vrgchBuff);
    }

    WriteLog(vrgchCRLF);
}

int
PRIVATE
WriteLog(
    _TCHAR * lpStrLog
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    HANDLE hfLog;
    DWORD dwRetLen;

    if((hfLog = CreateFile(vszLogFile
                           , GENERIC_READ|GENERIC_WRITE
                           , FILE_SHARE_READ|FILE_SHARE_WRITE
                           , NULL
                           , OPEN_ALWAYS
                           , 0
                           , NULL)) != INVALID_HANDLE_VALUE){
        SetFilePointer(hfLog, 0, NULL, FILE_END);
        WriteFile(hfLog, lpStrLog, strlen(lpStrLog), &dwRetLen, NULL);
        CloseHandle(hfLog);
        return (1);
    }

    return (0);
}


#endif //MAYBE_USEFUL

BOOL
GetWin32Info(
    _TCHAR * lpFile,
    LPWIN32_FIND_DATA lpFW32
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/
{
    return GetWin32InfoForNT(lpFile, lpFW32);
}


DWORD
PRIVATE
DoObjectEdit(
    HANDLE              hShadowDB,
    _TCHAR *            lpDrive,
    _TCHAR *            lptzFullPath,
    LPCOPYPARAMS        lpCP,
    LPSHADOWINFO        lpSI,
    LPWIN32_FIND_DATA   lpFind32Local,
    LPWIN32_FIND_DATA   lpFind32Remote,
    int                 iShadowStatus,
    int                 iFileStatus,
    int                 uAction,
    DWORD               dwFileSystemFlags,
    LPCSCPROC           lpfnMergeProgress,
    DWORD_PTR           dwContext
    )
/*++

Routine Description:

    This routine does the actual merge for files

Arguments:

    hShadowDB           Handle to the redir to call issue ioctl calls

    lpDrive             drivemapping to bypass CSC while making changes on the remote

    lptzFullPath        Fully qualified path

    lpCP                Copy parameters, contain share name, path relative to the share and the
                        the name in the local database

    lpSI                info such as pincount and pinflags

    lpFind32Local       win32 info for the local replica

    lpFind32Remote      win32 infor for the origianl, NULL if the original doesn't exist

    iShadowStatus       status of the local copy

    iFileStatus         status of the remote copy

    uAction             action to be performed

    dwFileSystemFlags   filesystem flags to do special things for NTFS

    lpfnMergeProgress   progress callback

    dwContext           callback context


Returns:

    error code as defined in winerror.h

Notes:

--*/

{
    HANDLE hfSrc = INVALID_HANDLE_VALUE, hfDst = INVALID_HANDLE_VALUE;
    HANDLE hDst=0;
    _TCHAR * lpT;
    LONG lOffset=0;
    DWORD dwError=ERROR_REINT_FAILED;
    BOOL fRet, fFileExists, fOverWrite=FALSE, fForceAttribute = FALSE;
    WIN32_FIND_DATA    sFind32Remote;
    DWORD   dwTotal = 0, dwRet;
    _TCHAR szSrcName[MAX_PATH+MAX_SERVER_SHARE_NAME_FOR_CSC+10];
    _TCHAR szDstName[MAX_PATH+MAX_SERVER_SHARE_NAME_FOR_CSC+10];
    _TCHAR *lprwBuff = NULL;
    _TCHAR *lptzLocalPath = NULL;
    _TCHAR *lptzLocalPathCscBmp = NULL;
    LPCSC_BITMAP_U lpbitmap = NULL;
    DWORD fileSize, fileSizeHigh;
    int cscReintRet;

    lprwBuff = LocalAlloc(LPTR, FILL_BUF_SIZE_LAN);

    if (!lprwBuff)
    {
        return (ERROR_NOT_ENOUGH_MEMORY);
    }

    if (!(lptzLocalPath = GetTempFileForCSC(NULL)))
    {
        ReintKdPrint(BADERRORS, ("DoObjectEdit: failed to get temp file\r\n"));
        goto bailout;
    }

    if (!CopyShadow(hShadowDB, lpSI->hDir, lpSI->hShadow, lptzLocalPath))
    {
        ReintKdPrint(BADERRORS, ("DoObjectEdit: failed to make local copy\r\n"));
        goto bailout;
    }

    // for EFS files, we overwrite the original file, that way the encryption information
    // will not be lost due to us doing a new create followed by a rename and delete

    fOverWrite = ((lpFind32Local->dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED) != 0);

    if (!fOverWrite && lpFind32Remote)
    {
        fOverWrite = (((lpFind32Remote->dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED) != 0)||
                      ((lpFind32Remote->dwFileAttributes & FILE_ATTRIBUTE_COMPRESSED) != 0));
    }

    // if this is the DFS root, always overwrite. This is to avoind sharing violation problems
    // while merging
    if (!fOverWrite && (dwFileSystemFlags == DFS_ROOT_FILE_SYSTEM_FLAGS))
    {
        fOverWrite = TRUE;                
    }

    ReintKdPrint(MERGE, ("Overwrite=%d\r\n", fOverWrite));

    lOffset=0;

    // Create x:\foo\00010002 kind of temporary filename

    lstrcpy(szDstName, lpDrive);
    lstrcat(szDstName, lpCP->lpRemotePath);

    lpT = GetLeafPtr(szDstName);
    *lpT = 0;   // remove the remote leaf

    lpT = GetLeafPtr(lpCP->lpLocalPath);

    // attach the local leaf
    lstrcat(szDstName, lpT);

    // Let us also create the real name x:\foo\bar
    lstrcpy(szSrcName, lpDrive);
    lstrcat(szSrcName, lpCP->lpRemotePath);

    fFileExists = (lpFind32Remote != NULL);

    if (!fFileExists)
    {
        fOverWrite = FALSE;
        ReintKdPrint(MERGE, ("File doesn't exist, Overwrite=%d\r\n", fOverWrite));
    }

    if (mShadowDeleted(lpSI->uStatus)){

        ReintKdPrint(MERGE, ("Deleting %ls \r\n", szSrcName));

        if (lpFind32Remote)
        {
            if((lpFind32Remote->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                ReintKdPrint(MERGE, ("DoObjectEdit:attribute conflict on %ls \r\n", szSrcName));
                goto bailout;
            }
            if(!DeleteFile(szSrcName))
            {
                ReintKdPrint(BADERRORS, ("DoObjectEdit:delete failed %ls error=%d\r\n", szSrcName, GetLastError()));
                goto bailout;
            }
        }

        // if this operation fails we want to abort
        // directory
        if(!DeleteShadow(hShadowDB, lpSI->hDir, lpSI->hShadow))
        {
            dwError = GetLastError();
            goto error;
        }
        else
        {
            dwError = 0;
            goto bailout;
        }

    }

    if (mShadowDirty(lpSI->uStatus)
        || mShadowLocallyCreated(lpSI->uStatus)){


        hfSrc = CreateFile(  lptzLocalPath,
                             GENERIC_READ,
                             FILE_SHARE_READ,
                             NULL,
                             OPEN_EXISTING,
                             0,
                             NULL);

        if (hfSrc ==  INVALID_HANDLE_VALUE)
        {
            goto bailout;
        }

        if (lpFind32Remote && uAction != RAIA_MERGE) {
            // Load the bitmap only when the remote file exists and
            // that no conflict occurs. (if there's a conflict,
            // uAction == RAIA_MERGE. See PerformOneReint()
            lptzLocalPathCscBmp = (_TCHAR *)LocalAlloc(
                                                LPTR,
                                                (lstrlen(lptzLocalPath) +
                                                CSC_BitmapStreamNameLen() + 1) * sizeof(_TCHAR));
            lstrcpy(lptzLocalPathCscBmp, lptzLocalPath);
            CSC_BitmapAppendStreamName(
                lptzLocalPathCscBmp,
                (lstrlen(lptzLocalPath) + CSC_BitmapStreamNameLen() + 1) * sizeof(_TCHAR));
            ReintKdPrint(MERGE, ("TempFileBmp (WCHAR) %ws\r\n", lptzLocalPathCscBmp));
            switch(CSC_BitmapRead(&lpbitmap, lptzLocalPathCscBmp)) {
                // for return values of CSC_BitmapRead see csc_bmpu.c
                case 0:
                    ReintKdPrint(BADERRORS, ("&lpbitmap is null, cannot happen\n"));
                    lpbitmap = NULL;
                    break;
                case 1:
                    ReintKdPrint(MERGE, ("Read bitmap successful\n"));
                    // Overwrite the updated parts of the original file in the
                    // share
                    fOverWrite = TRUE;
                    CSC_BitmapOutput(lpbitmap); // this is NOTHING in free build
                    break;
                case -2:
                    ReintKdPrint(
                        MERGE,
                        ("No Bitmap file %ws exists\n",
                        lptzLocalPathCscBmp));
                    lpbitmap = NULL;
                    break;
                case -1:
                    ReintKdPrint(
                        MERGE,
                        ("Error in reading Bitmap file %ws\n",
                        lptzLocalPathCscBmp));
                    lpbitmap = NULL;
                    break;
                default:
                    ReintKdPrint(MERGE, ("CSC_BitmapRead return code unknown\n"));
                    lpbitmap = NULL;
                    break;
            }
        }
                           
        // if the destination file has multiple streams
        // we should overwrite it
        if (mShadowDirty(lpSI->uStatus) &&
            (dwFileSystemFlags & FS_PERSISTENT_ACLS)&&  // indication of NTFS
            (fFileExists)&&
            !fOverWrite)
        {
            BOOL    fStreams = FALSE;

            // check if this has multiple streams
            if(!HasMultipleStreams(szSrcName, &fStreams) || fStreams )
            {
                // if the call failed, we go conservative and assume there are multiple streams
                ReintKdPrint(MERGE, ("Have multiple streams, overwriting\n"));
                fOverWrite = TRUE;
            }

        }
        if (!fOverWrite)
        {

            ReintKdPrint(MERGE, ("Creating temp \r\n"));

            if ((dwFileSystemFlags & FS_PERSISTENT_ACLS)&&(fFileExists))
            {
                hfDst = CreateTmpFileWithSourceAcls(
                            szSrcName,
                            szDstName);
            }
            else
            {
                hfDst = CreateFile(szDstName,
                                     GENERIC_WRITE,
                                     0,
                                     NULL,
                                     CREATE_ALWAYS,
                                     0,
                                     NULL);
            }
        }
        else
        {
            ReintKdPrint(MERGE, ("Overwriting existing file\r\n"));
            Assert(lpFind32Remote);
            if (lpFind32Remote->dwFileAttributes & FILE_ATTRIBUTE_READONLY)
            {
                ReintKdPrint(MERGE, ("Clearing Readonly attribute \r\n"));
                if(!SetFileAttributes(szSrcName, (lpFind32Remote->dwFileAttributes & ~FILE_ATTRIBUTE_READONLY))){
                    ReintKdPrint(MERGE, ("Failed to clear Readonly attribute, bailing\r\n"));
                    goto error;
                }
                
                fForceAttribute = TRUE;
            }

            // Want to open existing so can copy only those parts of
        