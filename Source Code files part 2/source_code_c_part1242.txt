ght (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;


#ifndef __BDADEBUG_H
#define __BDADEBUG_H
#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

//======================================================;
//  Interfaces provided by this file:
//
//      All interfaces provided by this file only exist and generate
//      code when DEBUG is defined.  No code or data are generated when
//      DEBUG is not defined.
//
//      CDEBUG_BREAK()
//          Causes a trap #3, which hopefully will put you
//          in your debugger.
//
//      MDASSERT(exp)
//          If <exp> evaluates to false, prints a failure message
//          and calls CDEBUG_BREAK()
//
//      CdebugPrint(level, (printf_args));
//          If <level> is >= _CDebugLevel, then calls
//          DbgPrint(printf_args)
//
//======================================================;

#define DEBUG_BREAK     DbgBreakPoint()


#ifdef DEBUG

#define DEBUG_LEVEL     DEBUGLVL_VERBOSE     //DEBUGLVL_TERSE

#  if _X86_
#    define CDEBUG_BREAK()  { __asm { int 3 }; }
#  else
#    define CDEBUG_BREAK()  DbgBreakPoint()
#  endif

   extern char _CDebugAssertFail[];
#  define MDASSERT(exp) {\
    if ( !(exp) ) {\
        DbgPrint(_CDebugAssertFail, #exp, __FILE__, __LINE__); \
        CDEBUG_BREAK(); \
    }\
    }

extern enum STREAM_DEBUG_LEVEL _CDebugLevel;

#  define CDebugPrint(level, args) { if (level <= _CDebugLevel) DbgPrint args; }

#else /*DEBUG*/

#  define CDEBUG_BREAK()
#  define MDASSERT(exp)
#  define CDebugPrint(level, args)

#endif /*DEBUG*/


#ifdef __cplusplus
}
#endif // __cplusplus
#endif // #ifndef __BDADEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\casamp\driver\inc\wdmdebug.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
// WDMDEBUG.H
//==========================================================================;


#ifndef __WDMDEBUG_H
#define __WDMDEBUG_H

#define DebugAssert(exp)

#ifdef DEBUG
#define DebugInfo(x) KdPrint(x)
#define DBG1(String) DebugPrint((DebugLevelVerbose, String))
#define TRAP DbgBreakPoint() //DEBUG_BREAKPOINT();
#else
#define DebugInfo(x)
#define DBG1(String)
#define TRAP
#endif


#if DBG

#define _DebugPrint(x)  ::StreamClassDebugPrint x

#else

#define _DebugPrint(x)

#endif // #if DBG

#endif // #ifndef __WDMDEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\casamp\driver\inc\bdamedia.h ===
/*++

Copyright (c) 1996 Microsoft Corporation.

Module Name:

    BdaMedia.h

Abstract:

    Broadcast Driver Architecture Multimedia Definitions.

--*/

#if !defined(_KSMEDIA_)
#error KSMEDIA.H must be included before BDAMEDIA.H
#endif // !defined(_KSMEDIA_)

#if !defined(_BDATYPES_)
#error BDATYPES.H must be included before BDAMEDIA.H
#endif // !defined(_BDATYPES_)

#if !defined(_BDAMEDIA_)
#define _BDAMEDIA_

#if defined(__cplusplus)
extern "C" {
#endif // defined(__cplusplus)



//===========================================================================
//
//  KSProperty Set Structure Definitions for BDA
//
//===========================================================================

typedef struct _KSP_BDA_NODE_PIN {
    KSPROPERTY      Property;
    ULONG           ulNodeType;
    ULONG           ulInputPinId;
    ULONG           ulOutputPinId;
} KSP_BDA_NODE_PIN, *PKSP_BDA_NODE_PIN;



//===========================================================================
//
//  BDA Data Range definitions.  Includes specifier definitions.
//
//===========================================================================

//  Antenna Signal Formats
//

typedef struct tagKS_DATARANGE_BDA_ANTENNA {
   KSDATARANGE                  DataRange;

   //   Antenna specifier can go here if required
   //
} KS_DATARANGE_BDA_ANTENNA, *PKS_DATARANGE_BDA_ANTENNA;



//  Transport Formats
//

typedef struct tagBDA_TRANSPORT_INFO {
    ULONG           ulcbPhyiscalPacket; // Size, in bytes, of a physical packet
                                        // (e.g. Satellite link payload size.
    ULONG           ulcbPhyiscalFrame;  // Size, in bytes, of each physical frame
                                        // 0 indicates no HW requirement
    ULONG           ulcbPhyiscalFrameAlignment; // Capture buffer alignment in bytes
                                                // 0 and 1 indicate no alignment requirements
    REFERENCE_TIME  AvgTimePerFrame; // Normal ActiveMovie units (100 nS)

} BDA_TRANSPORT_INFO, *PBDA_TRANSPORT_INFO;

typedef struct tagKS_DATARANGE_BDA_TRANSPORT {
   KSDATARANGE                  DataRange;
   BDA_TRANSPORT_INFO           BdaTransportInfo;

   //   Transport specifier can go here if required
   //
} KS_DATARANGE_BDA_TRANSPORT, *PKS_DATARANGE_BDA_TRANSPORT;



//===========================================================================
//
//  BDA Stream Format GUIDs
//
//===========================================================================

#define STATIC_KSDATAFORMAT_TYPE_BDA_ANTENNA\
    0x71985f41, 0x1ca1, 0x11d3, 0x9c, 0xc8, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("71985F41-1CA1-11d3-9CC8-00C04F7971E0", KSDATAFORMAT_TYPE_BDA_ANTENNA);
#define KSDATAFORMAT_TYPE_BDA_ANTENNA DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_BDA_ANTENNA)


#define STATIC_KSDATAFORMAT_SPECIFIER_BDA_TRANSPORT\
    0x8deda6fd, 0xac5f, 0x4334, 0x8e, 0xcf, 0xa4, 0xba, 0x8f, 0xa7, 0xd0, 0xf0
DEFINE_GUIDSTRUCT("8DEDA6FD-AC5F-4334-8ECF-A4BA8FA7D0F0", KSDATAFORMAT_SPECIFIER_BDA_TRANSPORT);
#define KSDATAFORMAT_SPECIFIER_BDA_TRANSPORT DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_BDA_TRANSPORT)


#define STATIC_KSDATAFORMAT_TYPE_BDA_IF_SIGNAL\
    0x61be0b47, 0xa5eb, 0x499b, 0x9a, 0x85, 0x5b, 0x16, 0xc0, 0x7f, 0x12, 0x58
DEFINE_GUIDSTRUCT("61BE0B47-A5EB-499b-9A85-5B16C07F1258", KSDATAFORMAT_TYPE_BDA_IF_SIGNAL);
#define KSDATAFORMAT_TYPE_BDA_IF_SIGNAL DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_BDA_IF_SIGNAL)


#define STATIC_KSDATAFORMAT_TYPE_MPEG2_SECTIONS\
    0x455f176c, 0x4b06, 0x47ce, 0x9a, 0xef, 0x8c, 0xae, 0xf7, 0x3d, 0xf7, 0xb5
DEFINE_GUIDSTRUCT("455F176C-4B06-47CE-9AEF-8CAEF73DF7B5", KSDATAFORMAT_TYPE_MPEG2_SECTIONS);
#define KSDATAFORMAT_SUBTYPE_TYPE_MPEG2_SECTIONS DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_MPEG2_SECTIONS)


#define STATIC_KSDATAFORMAT_SUBTYPE_ATSC_SI\
    0xb3c7397c, 0xd303, 0x414d, 0xb3, 0x3c, 0x4e, 0xd2, 0xc9, 0xd2, 0x97, 0x33
DEFINE_GUIDSTRUCT("B3C7397C-D303-414D-B33C-4ED2C9D29733", KSDATAFORMAT_SUBTYPE_ATSC_SI);
#define KSDATAFORMAT_SUBTYPE_SUBTYPE_ATSC_SI DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_ATSC_SI)


#define STATIC_KSDATAFORMAT_SUBTYPE_DVB_SI\
    0xe9dd31a3, 0x221d, 0x4adb, 0x85, 0x32, 0x9a, 0xf3, 0x9, 0xc1, 0xa4, 0x8
DEFINE_GUIDSTRUCT("e9dd31a3-221d-4adb-8532-9af309c1a408", KSDATAFORMAT_SUBTYPE_DVB_SI);
#define KSDATAFORMAT_SUBTYPE_SUBTYPE_DVB_SI DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_DVB_SI)


#define STATIC_KSDATAFORMAT_SUBTYPE_BDA_OPENCABLE_PSIP\
    0x762e3f66, 0x336f, 0x48d1, 0xbf, 0x83, 0x2b, 0x0, 0x35, 0x2c, 0x11, 0xf0
DEFINE_GUIDSTRUCT("762E3F66-336F-48d1-BF83-2B00352C11F0", KSDATAFORMAT_SUBTYPE_BDA_OPENCABLE_PSIP);
#define KSDATAFORMAT_SUBTYPE_BDA_OPENCABLE_PSIP DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_BDA_OPENCABLE_PSIP)


//===========================================================================
//
//  KSPinName Definitions for BDA
//
//===========================================================================

//  Pin name for a BDA transport pin
//
// {78216A81-CFA8-493e-9711-36A61C08BD9D}
//
#define STATIC_PINNAME_BDA_TRANSPORT \
    0x78216a81, 0xcfa8, 0x493e, 0x97, 0x11, 0x36, 0xa6, 0x1c, 0x8, 0xbd, 0x9d
DEFINE_GUIDSTRUCT("78216A81-CFA8-493e-9711-36A61C08BD9D", PINNAME_BDA_TRANSPORT);
#define PINNAME_BDA_TRANSPORT DEFINE_GUIDNAMED(PINNAME_BDA_TRANSPORT)


//  Pin name for a BDA analog video pin
//
// {5C0C8281-5667-486c-8482-63E31F01A6E9}
//
#define STATIC_PINNAME_BDA_ANALOG_VIDEO \
    0x5c0c8281, 0x5667, 0x486c, 0x84, 0x82, 0x63, 0xe3, 0x1f, 0x1, 0xa6, 0xe9
DEFINE_GUIDSTRUCT("5C0C8281-5667-486c-8482-63E31F01A6E9", PINNAME_BDA_ANALOG_VIDEO);
#define PINNAME_BDA_ANALOG_VIDEO DEFINE_GUIDNAMED(PINNAME_BDA_ANALOG_VIDEO)


//  Pin name for a BDA analog audio pin
//
// {D28A580A-9B1F-4b0c-9C33-9BF0A8EA636B}
//
#define STATIC_PINNAME_BDA_ANALOG_AUDIO \
    0xd28a580a, 0x9b1f, 0x4b0c, 0x9c, 0x33, 0x9b, 0xf0, 0xa8, 0xea, 0x63, 0x6b
DEFINE_GUIDSTRUCT("D28A580A-9B1F-4b0c-9C33-9BF0A8EA636B", PINNAME_BDA_ANALOG_AUDIO);
#define PINNAME_BDA_ANALOG_AUDIO DEFINE_GUIDNAMED(PINNAME_BDA_ANALOG_AUDIO)


//  Pin name for a BDA FM Radio pin
//
// {D2855FED-B2D3-4eeb-9BD0-193436A2F890}
//
#define STATIC_PINNAME_BDA_FM_RADIO \
    0xd2855fed, 0xb2d3, 0x4eeb, 0x9b, 0xd0, 0x19, 0x34, 0x36, 0xa2, 0xf8, 0x90
DEFINE_GUIDSTRUCT("D2855FED-B2D3-4eeb-9BD0-193436A2F890", PINNAME_BDA_FM_RADIO);
#define PINNAME_BDA_FM_RADIO DEFINE_GUIDNAMED(PINNAME_BDA_FM_RADIO)


//  Pin name for a BDA Intermediate Frequency pin
//
// {1A9D4A42-F3CD-48a1-9AEA-71DE133CBE14}
//
#define STATIC_PINNAME_BDA_IF_PIN \
    0x1a9d4a42, 0xf3cd, 0x48a1, 0x9a, 0xea, 0x71, 0xde, 0x13, 0x3c, 0xbe, 0x14
DEFINE_GUIDSTRUCT("1A9D4A42-F3CD-48a1-9AEA-71DE133CBE14", PINNAME_BDA_IF_PIN);
#define PINNAME_BDA_IF_PIN DEFINE_GUIDNAMED(PINNAME_BDA_IF_PIN)


//  Pin name for a BDA Open Cable PSIP pin
//
// {297BB104-E5C9-4ACE-B123-95C3CBB24D4F}
//
#define STATIC_PINNAME_BDA_OPENCABLE_PSIP_PIN \
    0x297bb104, 0xe5c9, 0x4ace, 0xb1, 0x23, 0x95, 0xc3, 0xcb, 0xb2, 0x4d, 0x4f
DEFINE_GUIDSTRUCT("297BB104-E5C9-4ACE-B123-95C3CBB24D4F", PINNAME_BDA_OPENCABLE_PSIP_PIN);
#define PINNAME_BDA_OPENCABLE_PSIP_PIN DEFINE_GUIDNAMED(PINNAME_BDA_OPENCABLE_PSIP_PIN)


//===========================================================================
//
//  KSProperty Set Definitions for BDA
//
//===========================================================================


//------------------------------------------------------------
//
//  BDA Network Ethernet Filter Property Set
//
// {71985F43-1CA1-11d3-9CC8-00C04F7971E0}
//
#define STATIC_KSPROPSETID_BdaEthernetFilter \
    0x71985f43, 0x1ca1, 0x11d3, 0x9c, 0xc8, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("71985F43-1CA1-11d3-9CC8-00C04F7971E0", KSPROPSETID_BdaEthernetFilter);
#define KSPROPSETID_BdaEthernetFilter DEFINE_GUIDNAMED(KSPROPSETID_BdaEthernetFilter)

typedef enum {
    KSPROPERTY_BDA_ETHERNET_FILTER_MULTICAST_LIST_SIZE = 0,
    KSPROPERTY_BDA_ETHERNET_FILTER_MULTICAST_LIST,
    KSPROPERTY_BDA_ETHERNET_FILTER_MULTICAST_MODE
} KSPROPERTY_BDA_ETHERNET_FILTER;

#define DEFINE_KSPROPERTY_ITEM_BDA_ETHERNET_FILTER_MULTICAST_LIST_SIZE(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_ETHERNET_FILTER_MULTICAST_LIST_SIZE,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(ULONG),\
        FALSE,\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_ETHERNET_FILTER_MULTICAST_LIST(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_ETHERNET_FILTER_MULTICAST_LIST,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(BDA_ETHERNET_ADDRESS_LIST),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_ETHERNET_FILTER_MULTICAST_MODE(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_ETHERNET_FILTER_MULTICAST_MODE,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(BDA_MULTICAST_MODE),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)



//------------------------------------------------------------
//
//  BDA Network IPv4 Filter Property Set
//
// {71985F44-1CA1-11d3-9CC8-00C04F7971E0}
//
#define STATIC_KSPROPSETID_BdaIPv4Filter \
    0x71985f44, 0x1ca1, 0x11d3, 0x9c, 0xc8, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("71985F44-1CA1-11d3-9CC8-00C04F7971E0", KSPROPSETID_BdaIPv4Filter);
#define KSPROPSETID_BdaIPv4Filter DEFINE_GUIDNAMED(KSPROPSETID_BdaIPv4Filter)

typedef enum {
    KSPROPERTY_BDA_IPv4_FILTER_MULTICAST_LIST_SIZE = 0,
    KSPROPERTY_BDA_IPv4_FILTER_MULTICAST_LIST,
    KSPROPERTY_BDA_IPv4_FILTER_MULTICAST_MODE
} KSPROPERTY_BDA_IPv4_FILTER;

#define DEFINE_KSPROPERTY_ITEM_BDA_IPv4_FILTER_MULTICAST_LIST_SIZE(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_IPv4_FILTER_MULTICAST_LIST_SIZE,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(ULONG),\
        FALSE,\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_IPv4_FILTER_MULTICAST_LIST(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_IPv4_FILTER_MULTICAST_LIST,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(BDA_IPv4_ADDRESS_LIST),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_IPv4_FILTER_MULTICAST_MODE(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_IPv4_FILTER_MULTICAST_MODE,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(BDA_MULTICAST_MODE),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)



//------------------------------------------------------------
//
//  BDA Network IPv6 Filter Property Set
//
// {E1785A74-2A23-4fb3-9245-A8F88017EF33}
//
#define STATIC_KSPROPSETID_BdaIPv6Filter \
    0xe1785a74, 0x2a23, 0x4fb3, 0x92, 0x45, 0xa8, 0xf8, 0x80, 0x17, 0xef, 0x33
DEFINE_GUIDSTRUCT("E1785A74-2A23-4fb3-9245-A8F88017EF33", KSPROPSETID_BdaIPv6Filter);
#define KSPROPSETID_BdaIPv6Filter DEFINE_GUIDNAMED(KSPROPSETID_BdaIPv6Filter)

typedef enum {
    KSPROPERTY_BDA_IPv6_FILTER_MULTICAST_LIST_SIZE = 0,
    KSPROPERTY_BDA_IPv6_FILTER_MULTICAST_LIST,
    KSPROPERTY_BDA_IPv6_FILTER_MULTICAST_MODE
} KSPROPERTY_BDA_IPv6_FILTER;

#define DEFINE_KSPROPERTY_ITEM_BDA_IPv6_FILTER_MULTICAST_LIST_SIZE(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_IPv6_FILTER_MULTICAST_LIST_SIZE,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(ULONG),\
        FALSE,\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_IPv6_FILTER_MULTICAST_LIST(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_IPv6_FILTER_MULTICAST_LIST,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(BDA_IPv6_ADDRESS_LIST),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_IPv6_FILTER_MULTICAST_MODE(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_IPv6_FILTER_MULTICAST_MODE,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(BDA_MULTICAST_MODE),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)



//------------------------------------------------------------
//
//
//  BDA Signal Property Set
//
//  {D2F1644B-B409-11d2-BC69-00A0C9EE9E16}
//
#define STATIC_KSPROPSETID_BdaSignal \
    0xd2f1644b, 0xb409, 0x11d2, 0xbc, 0x69, 0x0, 0xa0, 0xc9, 0xee, 0x9e, 0x16
DEFINE_GUIDSTRUCT("D2F1644B-B409-11d2-BC69-00A0C9EE9E16", KSPROPSETID_BdaSignal);
#define KSPROPSETID_BdaSignal DEFINE_GUIDNAMED(KSPROPSETID_BdaSignal)

typedef enum {
    KSPROPERTY_BDA_SIGNAL_SOURCE = 0,
    KSPROPERTY_BDA_SIGNAL_TUNING_SPACE,
    KSPROPERTY_BDA_SIGNAL_NETWORK_TYPE,
    KSPROPERTY_BDA_SIGNAL_STATE
} KSPROPERTY_BDA_SIGNAL;

#define DEFINE_KSPROPERTY_ITEM_BDA_SIGNAL_SOURCE(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_SIGNAL_SOURCE,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(ULONG),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_SIGNAL_TUNING_SPACE(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_SIGNAL_TUNING_SPACE,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(GUID),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_SIGNAL_NETWORK_TYPE(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_SIGNAL_NETWORK_TYPE,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(GUID),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_SIGNAL_STATE(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_SIGNAL_STATE,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(BDA_SIGNAL_STATE),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)



//------------------------------------------------------------
//
//
//  BDA Change Sync Method Set
//
// {FD0A5AF3-B41D-11d2-9C95-00C04F7971E0}
//
#define STATIC_KSMETHODSETID_BdaChangeSync \
    0xfd0a5af3, 0xb41d, 0x11d2, 0x9c, 0x95, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("FD0A5AF3-B41D-11d2-9C95-00C04F7971E0", KSMETHODSETID_BdaChangeSync);
#define KSMETHODSETID_BdaChangeSync DEFINE_GUIDNAMED(KSMETHODSETID_BdaChangeSync)

typedef enum {
    KSMETHOD_BDA_START_CHANGES = 0,
    KSMETHOD_BDA_CHECK_CHANGES,
    KSMETHOD_BDA_COMMIT_CHANGES,
    KSMETHOD_BDA_GET_CHANGE_STATE
} KSMETHOD_BDA_CHANGE_SYNC;

#define DEFINE_KSMETHOD_ITEM_BDA_START_CHANGES(MethodHandler, SupportHandler)\
    DEFINE_KSMETHOD_ITEM(\
        KSMETHOD_BDA_START_CHANGES,\
        KSMETHOD_TYPE_NONE,\
        (MethodHandler),\
        sizeof(KSMETHOD),\
        0,\
        SupportHandler)

#define DEFINE_KSMETHOD_ITEM_BDA_CHECK_CHANGES(MethodHandler, SupportHandler)\
    DEFINE_KSMETHOD_ITEM(\
        KSMETHOD_BDA_CHECK_CHANGES,\
        KSMETHOD_TYPE_NONE,\
        (MethodHandler),\
        sizeof(KSMETHOD),\
        0,\
        SupportHandler)

#define DEFINE_KSMETHOD_ITEM_BDA_COMMIT_CHANGES(MethodHandler, SupportHandler)\
    DEFINE_KSMETHOD_ITEM(\
        KSMETHOD_BDA_COMMIT_CHANGES,\
        KSMETHOD_TYPE_NONE,\
        (MethodHandler),\
        sizeof(KSMETHOD),\
        0,\
        SupportHandler)

#define DEFINE_KSMETHOD_ITEM_BDA_GET_CHANGE_STATE(MethodHandler, SupportHandler)\
    DEFINE_KSMETHOD_ITEM(\
        KSMETHOD_BDA_GET_CHANGE_STATE,\
        KSMETHOD_TYPE_READ,\
        (MethodHandler),\
        sizeof(KSMETHOD),\
        0,\
        SupportHandler)



//------------------------------------------------------------
//
//
//  BDA Device Configuration Method Set
//
// {71985F45-1CA1-11d3-9CC8-00C04F7971E0}
//
#define STATIC_KSMETHODSETID_BdaDeviceConfiguration \
    0x71985f45, 0x1ca1, 0x11d3, 0x9c, 0xc8, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("71985F45-1CA1-11d3-9CC8-00C04F7971E0", KSMETHODSETID_BdaDeviceConfiguration);
#define KSMETHODSETID_BdaDeviceConfiguration DEFINE_GUIDNAMED(KSMETHODSETID_BdaDeviceConfiguration)

typedef enum {
    KSMETHOD_BDA_CREATE_PIN_FACTORY = 0,
    KSMETHOD_BDA_DELETE_PIN_FACTORY,
    KSMETHOD_BDA_CREATE_TOPOLOGY
} KSMETHOD_BDA_DEVICE_CONFIGURATION;

#define DEFINE_KSMETHOD_ITEM_BDA_CREATE_PIN_FACTORY(MethodHandler, SupportHandler)\
    DEFINE_KSMETHOD_ITEM(\
        KSMETHOD_BDA_CREATE_PIN_FACTORY,\
        KSMETHOD_TYPE_READ,\
        (MethodHandler),\
        sizeof(KSM_PIN),\
        sizeof(ULONG),\
        SupportHandler)

#define DEFINE_KSMETHOD_ITEM_BDA_DELETE_PIN_FACTORY(MethodHandler, SupportHandler)\
    DEFINE_KSMETHOD_ITEM(\
        KSMETHOD_BDA_DELETE_PIN_FACTORY,\
        KSMETHOD_TYPE_NONE,\
        (MethodHandler),\
        sizeof(KSM_PIN),\
        0,\
        SupportHandler)

#define DEFINE_KSMETHOD_ITEM_BDA_CREATE_TOPOLOGY(MethodHandler, SupportHandler)\
    DEFINE_KSMETHOD_ITEM(\
        KSMETHOD_BDA_CREATE_TOPOLOGY,\
        KSMETHOD_TYPE_WRITE,\
        (MethodHandler),\
        sizeof(KSMETHOD),\
        sizeof(KSMULTIPLE_ITEM),\
        SupportHandler)



//------------------------------------------------------------
//
//
//  BDA Topology Property Set
//
// {A14EE835-0A23-11d3-9CC7-00C04F7971E0}
//
#define STATIC_KSPROPSETID_BdaTopology \
    0xa14ee835, 0x0a23, 0x11d3, 0x9c, 0xc7, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("A14EE835-0A23-11d3-9CC7-00C04F7971E0", KSPROPSETID_BdaTopology);
#define KSPROPSETID_BdaTopology DEFINE_GUIDNAMED(KSPROPSETID_BdaTopology)

typedef enum {
    KSPROPERTY_BDA_NODE_TYPES,
    KSPROPERTY_BDA_PIN_TYPES,
    KSPROPERTY_BDA_TEMPLATE_CONNECTIONS,
    KSPROPERTY_BDA_NODE_METHODS,
    KSPROPERTY_BDA_NODE_PROPERTIES,
    KSPROPERTY_BDA_NODE_EVENTS,
    KSPROPERTY_BDA_CONTROLLING_PIN_ID
 }KSPROPERTY_BDA_TOPOLOGY;

#define DEFINE_KSPROPERTY_ITEM_BDA_NODE_TYPES(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_NODE_TYPES,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        0,\
        FALSE,\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_PIN_TYPES(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_PIN_TYPES,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        0,\
        FALSE,\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_TEMPLATE_CONNECTIONS(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_TEMPLATE_CONNECTIONS,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof( BDA_TEMPLATE_CONNECTION),\
        FALSE,\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_NODE_METHODS(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_NODE_METHODS,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        0,\
        FALSE,\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_NODE_PROPERTIES(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_NODE_PROPERTIES,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        0,\
        FALSE,\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_NODE_EVENTS(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_NODE_EVENTS,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        0,\
        FALSE,\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_CONTROLLING_PIN_ID(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_CONTROLLING_PIN_ID,\
        (GetHandler),\
        sizeof(KSP_BDA_NODE_PIN),\
        sizeof( ULONG),\
        FALSE,\
        NULL, 0, NULL, NULL, 0)



//------------------------------------------------------------
//
//
//  BDA Pin Control Property Set
//
// {0DED49D5-A8B7-4d5d-97A1-12B0C195874D}
//
#define STATIC_KSPROPSETID_BdaPinControl \
    0xded49d5, 0xa8b7, 0x4d5d, 0x97, 0xa1, 0x12, 0xb0, 0xc1, 0x95, 0x87, 0x4d
DEFINE_GUIDSTRUCT("0DED49D5-A8B7-4d5d-97A1-12B0C195874D", KSPROPSETID_BdaPinControl);
#define KSPROPSETID_BdaPinControl DEFINE_GUIDNAMED(KSPROPSETID_BdaPinControl)

typedef enum {
    KSPROPERTY_BDA_PIN_ID = 0,
    KSPROPERTY_BDA_PIN_TYPE
} KSPROPERTY_BDA_PIN_CONTROL;

#define DEFINE_KSPROPERTY_ITEM_BDA_PIN_ID(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_PIN_ID,\
        (GetHandler),\
        sizeof( KSPROPERTY),\
        sizeof( ULONG),\
        FALSE,\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_PIN_TYPE(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_PIN_TYPE,\
        (GetHandler),\
        sizeof( KSPROPERTY),\
        sizeof( ULONG),\
        FALSE,\
        NULL, 0, NULL, NULL, 0)



//------------------------------------------------------------
//
//
//  BDA Pin Event Set
//
// {104781CD-50BD-40d5-95FB-087E0E86A591}
//
#define STATIC_KSEVENTSETID_BdaPinEvent \
    0x104781cd, 0x50bd, 0x40d5, 0x95, 0xfb, 0x08, 0x7e, 0xe, 0x86, 0xa5, 0x91
DEFINE_GUIDSTRUCT("104781CD-50BD-40d5-95FB-087E0E86A591", KSEVENTSETID_BdaPinEvent);
#define KSEVENTSETID_BdaPinEvent DEFINE_GUIDNAMED(KSEVENTSETID_BdaPinEvent)

typedef enum {
    KSEVENT_BDA_PIN_CONNECTED = 0,
    KSEVENT_BDA_PIN_DISCONNECTED
} KSPROPERTY_BDA_PIN_EVENT;

#define DEFINE_KSEVENT_ITEM_BDA_PIN_CONNECTED(AddHandler, RemoveHandler, SupportHandler)\
    DEFINE_KSEVENT_ITEM(\
        KSEVENT_BDA_PIN_CONNECTED,\
        sizeof( KSEVENTDATA), \
        0, \
        (AddHandler),\
        (RemoveHandler),\
        (SupportHandler)\
        )

#define DEFINE_KSEVENT_ITEM_BDA_PIN_DISCONNECTED(AddHandler, RemoveHandler, SupportHandler)\
    DEFINE_KSEVENT_ITEM(\
        KSEVENT_BDA_PIN_DISCONNECTED,\
        sizeof( KSEVENTDATA), \
        0, \
        (AddHandler),\
        (RemoveHandler),\
        (SupportHandler)\
        )



//------------------------------------------------------------
//
//
//  BDA Void Transform Property Set
//
// {71985F46-1CA1-11d3-9CC8-00C04F7971E0}
//
#define STATIC_KSPROPSETID_BdaVoidTransform \
    0x71985f46, 0x1ca1, 0x11d3, 0x9c, 0xc8, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("71985F46-1CA1-11d3-9CC8-00C04F7971E0", KSPROPSETID_BdaVoidTransform);
#define KSPROPSETID_BdaVoidTransform DEFINE_GUIDNAMED(KSPROPSETID_BdaVoidTransform)

typedef enum {
    KSPROPERTY_BDA_VOID_TRANSFORM_START = 0,
    KSPROPERTY_BDA_VOID_TRANSFORM_STOP
} KSPROPERTY_BDA_VOID_TRANSFORM;

#define DEFINE_KSPROPERTY_ITEM_BDA_VOID_TRANSFORM_START(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_VOID_TRANSFORM_START,\
        FALSE,\
        sizeof(KSPROPERTY),\
        0,\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_VOID_TRANSFORM_STOP(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_VOID_TRANSFORM_STOP,\
        FALSE,\
        sizeof(KSPROPERTY),\
        0,\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)



//------------------------------------------------------------
//
//
//  BDA Null Transform Property Set
//
// {DDF15B0D-BD25-11d2-9CA0-00C04F7971E0}
//
#define STATIC_KSPROPSETID_BdaNullTransform \
    0xddf15b0d, 0xbd25, 0x11d2, 0x9c, 0xa0, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("DDF15B08-BD25-11d2-9CA0-00C04F7971E0", KSPROPSETID_BdaNullTransform);
#define KSPROPSETID_BdaNullTransform DEFINE_GUIDNAMED(KSPROPSETID_BdaNullTransform)

typedef enum {
    KSPROPERTY_BDA_NULL_TRANSFORM_START = 0,
    KSPROPERTY_BDA_NULL_TRANSFORM_STOP
} KSPROPERTY_BDA_NULL_TRANSFORM;

#define DEFINE_KSPROPERTY_ITEM_BDA_NULL_TRANSFORM_START(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_NULL_TRANSFORM_START,\
        FALSE,\
        sizeof(KSPROPERTY),\
        0,\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_NULL_TRANSFORM_STOP(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_NULL_TRANSFORM_STOP,\
        FALSE,\
        sizeof(KSPROPERTY),\
        0,\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)



//------------------------------------------------------------
//
//
//  BDA Frequency Filter Property Set
//
// {71985F47-1CA1-11d3-9CC8-00C04F7971E0}
//
#define STATIC_KSPROPSETID_BdaFrequencyFilter \
    0x71985f47, 0x1ca1, 0x11d3, 0x9c, 0xc8, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("71985F47-1CA1-11d3-9CC8-00C04F7971E0", KSPROPSETID_BdaFrequencyFilter);
#define KSPROPSETID_BdaFrequencyFilter DEFINE_GUIDNAMED(KSPROPSETID_BdaFrequencyFilter)

typedef enum {
    KSPROPERTY_BDA_RF_TUNER_FREQUENCY = 0,
    KSPROPERTY_BDA_RF_TUNER_POLARITY,
    KSPROPERTY_BDA_RF_TUNER_RANGE,
    KSPROPERTY_BDA_RF_TUNER_TRANSPONDER
} KSPROPERTY_BDA_FREQUENCY_FILTER;

#define DEFINE_KSPROPERTY_ITEM_BDA_RF_TUNER_FREQUENCY(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_RF_TUNER_FREQUENCY,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(ULONG),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_RF_TUNER_POLARITY(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_RF_TUNER_POLARITY,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(ULONG),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_RF_TUNER_RANGE(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_RF_TUNER_RANGE,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(ULONG),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_RF_TUNER_TRANSPONDER(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_RF_TUNER_TRANSPONDER,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(ULONG),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)



//------------------------------------------------------------
//
//
//  BDA Digital Demodulator Property Set
//
// {EF30F379-985B-4d10-B640-A79D5E04E1E0}
//
#define STATIC_KSPROPSETID_BdaDigitalDemodulator \
    0xef30f379, 0x985b, 0x4d10, 0xb6, 0x40, 0xa7, 0x9d, 0x5e, 0x4, 0xe1, 0xe0
DEFINE_GUIDSTRUCT("EF30F379-985B-4d10-B640-A79D5E04E1E0", KSPROPSETID_BdaDigitalDemodulator);
#define KSPROPSETID_BdaDigitalDemodulator DEFINE_GUIDNAMED(KSPROPSETID_BdaDigitalDemodulator)

typedef enum {
    KSPROPERTY_BDA_MODULATION_TYPE = 0,
    KSPROPERTY_BDA_INNER_FEC_TYPE,
    KSPROPERTY_BDA_INNER_FEC_RATE,
    KSPROPERTY_BDA_OUTER_FEC_TYPE,
    KSPROPERTY_BDA_OUTER_FEC_RATE,
    KSPROPERTY_BDA_SYMBOL_RATE,
    KSPROPERTY_BDA_SPECTRAL_INVERSION,

} KSPROPERTY_BDA_DIGITAL_DEMODULATOR;

#define DEFINE_KSPROPERTY_ITEM_BDA_MODULATION_TYPE(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_MODULATION_TYPE,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(ModulationType),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_INNER_FEC_TYPE(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_INNER_FEC_TYPE,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(FECMethod),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_INNER_FEC_RATE(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_INNER_FEC_RATE,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(BinaryConvolutionCodeRate),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_OUTER_FEC_TYPE(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_OUTER_FEC_TYPE,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(FECMethod),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_OUTER_FEC_RATE(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_OUTER_FEC_RATE,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(BinaryConvolutionCodeRate),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_SYMBOL_RATE(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_SYMBOL_RATE,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(ULONG),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_SPECTRAL_INVERSION(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_SPECTRAL_INVERSION,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(SpectralInversion),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)



//------------------------------------------------------------
//
//
//  BDA Autodemodulate Property Set
//
// {DDF15B12-BD25-11d2-9CA0-00C04F7971E0}
//
#define STATIC_KSPROPSETID_BdaAutodemodulate \
    0xddf15b12, 0xbd25, 0x11d2, 0x9c, 0xa0, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("DDF15B08-BD25-11d2-9CA0-00C04F7971E0", KSPROPSETID_BdaAutodemodulate);
#define KSPROPSETID_BdaAutodemodulate DEFINE_GUIDNAMED(KSPROPSETID_BdaAutodemodulate)

typedef enum {
    KSPROPERTY_BDA_AUTODEMODULATE_START = 0,
    KSPROPERTY_BDA_AUTODEMODULATE_STOP
} KSPROPERTY_BDA_AUTODEMODULATE;

#define DEFINE_KSPROPERTY_ITEM_BDA_AUTODEMODULATE_START(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_AUTODEMODULATE_START,\
        FALSE,\
        sizeof(KSP_NODE),\
        0,\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_AUTODEMODULATE_STOP(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_AUTODEMODULATE_STOP,\
        FALSE,\
        sizeof(KSP_NODE),\
        0,\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)



//------------------------------------------------------------
//
//
//  BDA EcmMap Property Set
//
// {FA14A8B3-6068-48ef-96DD-53010B985A7D}
//
#define STATIC_KSPROPSETID_BdaEcmMap \
    0xfa14a8b3, 0x6068, 0x48ef, 0x96, 0xdd, 0x53, 0x1, 0xb, 0x98, 0x5a, 0x7d
DEFINE_GUIDSTRUCT("FA14A8B3-6068-48ef-96DD-53010B985A7D", KSPROPSETID_BdaEcmMap);
#define KSPROPSETID_BdaEcmMap DEFINE_GUIDNAMED(KSPROPSETID_BdaEcmMap)

typedef enum {
    KSPROPERTY_BDA_ECMMAP_EMM_PID = 0,
    KSPROPERTY_BDA_ECMMAP_MAP_LIST,
    KSPROPERTY_BDA_ECMMAP_UPDATE_MAP,
    KSPROPERTY_BDA_ECMMAP_REMOVE_MAP,
    KSPROPERTY_BDA_ECMMAP_UPDATE_ES_DESCRIPTOR,
    KSPROPERTY_BDA_ECMMAP_UPDATE_PROGRAM_DESCRIPTOR
} KSPROPERTY_BDA_ECMMAP;

#define DEFINE_KSPROPERTY_ITEM_BDA_ECMMAP_EMM_PID(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_ECMMAP_EMM_PID,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(ULONG),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_ECMMAP_MAP_LIST(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_ECMMAP_MAP_LIST,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        0,\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_ECMMAP_UPDATE_MAP(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_ECMMAP_UPDATE_MAP,\
        FALSE,\
        sizeof(KSPROPERTY),\
        sizeof(BDA_ECM_MAP),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_ECMMAP_REMOVE_MAP(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_ECMMAP_REMOVE_MAP,\
        FALSE,\
        sizeof(KSPROPERTY),\
        sizeof(BDA_ECM_MAP),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_ECMMAP_UPDATE_ES_DESCRIPTOR(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_ECMMAP_UPDATE_ES_DESCRIPTOR,\
        FALSE,\
        sizeof(KSPROPERTY),\
        sizeof(BDA_ES_DESCRIPTOR),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_ECMMAP_UPDATE_PROGRAM_DESCRIPTOR(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_ECMMAP_UPDATE_PROGRAM_DESCRIPTOR,\
        FALSE,\
        sizeof(KSPROPERTY),\
        sizeof(BDA_PROGRAM_DESCRIPTOR),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)


//------------------------------------------------------------
//
//
//  BDA PID Filter Property Set
//
// {D0A67D65-08DF-4fec-8533-E5B550410B85}
//
#define STATIC_KSPROPSETID_BdaPIDFilter \
    0xd0a67d65, 0x8df, 0x4fec, 0x85, 0x33, 0xe5, 0xb5, 0x50, 0x41, 0xb, 0x85
DEFINE_GUIDSTRUCT("D0A67D65-08DF-4fec-8533-E5B550410B85", KSPROPSETID_BdaPIDFilter);
#define KSPROPSETID_BdaPIDFilter DEFINE_GUIDNAMED(KSPROPSETID_BdaPIDFilter)

typedef enum {
    KSPROPERTY_BDA_PIDFILTER_MAP_PIDS = 0,
    KSPROPERTY_BDA_PIDFILTER_UNMAP_PIDS,
    KSPROPERTY_BDA_PIDFILTER_LIST_PIDS
} KSPROPERTY_BDA_PIDFILTER;

#define DEFINE_KSPROPERTY_ITEM_BDA_PIDFILTER_MAP_PIDS(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_PIDFILTER_MAP_PIDS,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(BDA_PID_MAP),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_PIDFILTER_UNMAP_PIDS(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_PIDFILTER_UNMAP_PIDS,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(BDA_PID_UNMAP),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_PIDFILTER_LIST_PIDS(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_PIDFILTER_LIST_PIDS,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        0,\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)



//------------------------------------------------------------
//
//
//  BDA CA Property Set
//
// {B0693766-5278-4ec6-B9E1-3CE40560EF5A}
//
#define STATIC_KSPROPSETID_BdaCA \
    0xb0693766, 0x5278, 0x4ec6, 0xb9, 0xe1, 0x3c, 0xe4, 0x5, 0x60, 0xef, 0x5a
DEFINE_GUIDSTRUCT("B0693766-5278-4ec6-B9E1-3CE40560EF5A", KSPROPSETID_BdaCA);
#define KSPROPSETID_BdaCA DEFINE_GUIDNAMED(KSPROPSETID_BdaCA)

typedef enum {
    KSPROPERTY_BDA_ECM_MAP_STATUS = 0,
    KSPROPERTY_BDA_CA_MODULE_STATUS,
    KSPROPERTY_BDA_CA_SMART_CARD_STATUS,
    KSPROPERTY_BDA_CA_MODULE_UI
} KSPROPERTY_BDA_CA;

#define DEFINE_KSPROPERTY_ITEM_BDA_ECM_MAP_STATUS(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_ECM_MAP_STATUS,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(ULONG),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_CA_MODULE_STATUS(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_CA_MODULE_STATUS,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(ULONG),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_CA_SMART_CARD_STATUS(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_CA_SMART_CARD_STATUS,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(ULONG),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_BDA_CA_MODULE_UI(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_BDA_CA_MODULE_UI,\
        (GetHandler),\
        sizeof(KSP_NODE),\
        sizeof(BDA_CA_MODULE_UI),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)



//------------------------------------------------------------
//
//
//  BDA CA Event Set
//
// {488C4CCC-B768-4129-8EB1-B00A071F9068}
//
#define STATIC_KSEVENTSETID_BdaCAEvent \
    0x488c4ccc, 0xb768, 0x4129, 0x8e, 0xb1, 0xb0, 0xa, 0x7, 0x1f, 0x90, 0x68
DEFINE_GUIDSTRUCT("488C4CCC-B768-4129-8EB1-B00A071F9068", KSEVENTSETID_BdaCAEvent);
#define KSEVENTSETID_BdaCAEvent DEFINE_GUIDNAMED(KSEVENTSETID_BdaCAEvent)

typedef enum {
	KSEVENT_BDA_ECM_MAP_STATUS_CHANGED = 0,
	KSEVENT_BDA_CA_MODULE_STATUS_CHANGED,
	KSEVENT_BDA_CA_SMART_CARD_STATUS_CHANGED,
	KSEVENT_BDA_CA_MODULE_UI_REQUESTED
} KSPROPERTY_BDA_CA_EVENT;

#define DEFINE_KSEVENT_BDA_ECM_MAP_STATUS_CHANGED(AddHandler, RemoveHandler, SupportHandler)\
    DEFINE_KSEVENT_ITEM(\
        KSEVENT_BDA_ECM_MAP_STATUS_CHANGED,\
        sizeof( KSEVENTDATA), \
        0, \
        (AddHandler),\
        (RemoveHandler),\
        (SupportHandler)\
        )

#define DEFINE_KSEVENT_BDA_CA_MODULE_STATUS_CHANGED(AddHandler, RemoveHandler, SupportHandler)\
    DEFINE_KSEVENT_ITEM(\
        KSEVENT_BDA_CA_MODULE_STATUS_CHANGED,\
        sizeof( KSEVENTDATA), \
        0, \
        (AddHandler),\
        (RemoveHandler),\
        (SupportHandler)\
        )

#define DEFINE_KSEVENT_BDA_CA_SMART_CARD_STATUS_CHANGED(AddHandler, RemoveHandler, SupportHandler)\
    DEFINE_KSEVENT_ITEM(\
        KSEVENT_BDA_CA_SMART_CARD_STATUS_CHANGED,\
        sizeof( KSEVENTDATA), \
        0, \
        (AddHandler),\
        (RemoveHandler),\
        (SupportHandler)\
        )

#define DEFINE_KSEVENT_BDA_CA_MODULE_UI_REQUESTED(AddHandler, RemoveHandler, SupportHandler)\
    DEFINE_KSEVENT_ITEM(\
        KSEVENT_BDA_CA_MODULE_UI_REQUESTED,\
        sizeof( KSEVENTDATA), \
        0, \
        (AddHandler),\
        (RemoveHandler),\
        (SupportHandler)\
        )


//===========================================================================
//
// BDA Filter Categories
//
//===========================================================================

#define STATIC_KSCATEGORY_BDA_RECEIVER_COMPONENT \
    0xFD0A5AF4, 0xB41D, 0x11d2, 0x9c, 0x95, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("FD0A5AF4-B41D-11d2-9C95-00C04F7971E0", KSCATEGORY_BDA_RECEIVER_COMPONENT);
#define KSCATEGORY_BDA_RECEIVER_COMPONENT DEFINE_GUIDNAMED(KSCATEGORY_BDA_RECEIVER_COMPONENT)


#define STATIC_KSCATEGORY_BDA_NETWORK_TUNER \
    0x71985f48, 0x1ca1, 0x11d3, 0x9c, 0xc8, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("71985F48-1CA1-11d3-9CC8-00C04F7971E0", KSCATEGORY_BDA_NETWORK_TUNER);
#define KSCATEGORY_BDA_NETWORK_TUNER DEFINE_GUIDNAMED(KSCATEGORY_BDA_NETWORK_TUNER)


#define STATIC_KSCATEGORY_BDA_NETWORK_EPG \
    0x71985f49, 0x1ca1, 0x11d3, 0x9c, 0xc8, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("71985F49-1CA1-11d3-9CC8-00C04F7971E0", KSCATEGORY_BDA_NETWORK_EPG);
#define KSCATEGORY_BDA_NETWORK_EPG DEFINE_GUIDNAMED(KSCATEGORY_BDA_NETWORK_EPG)


#define STATIC_KSCATEGORY_BDA_IP_SINK \
    0x71985f4aL, 0x1ca1, 0x11d3, 0x9c, 0xc8, 0x00, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("71985F4A-1CA1-11d3-9CC8-00C04F7971E0", KSCATEGORY_BDA_IP_SINK);
#define KSCATEGORY_IP_SINK DEFINE_GUIDNAMED(KSCATEGORY_BDA_IP_SINK)


#define STATIC_KSCATEGORY_BDA_NETWORK_PROVIDER \
    0x71985f4b, 0x1ca1, 0x11d3, 0x9c, 0xc8, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("71985F4B-1CA1-11d3-9CC8-00C04F7971E0", KSCATEGORY_BDA_NETWORK_PROVIDER);
#define KSCATEGORY_BDA_NETWORK_PROVIDER DEFINE_GUIDNAMED(KSCATEGORY_BDA_NETWORK_PROVIDER)

// {A2E3074F-6C3D-11d3-B653-00C04F79498E}
#define STATIC_KSCATEGORY_BDA_TRANSPORT_INFORMATION \
        0xa2e3074f, 0x6c3d, 0x11d3, 0xb6, 0x53, 0x0, 0xc0, 0x4f, 0x79, 0x49, 0x8e
DEFINE_GUIDSTRUCT("A2E3074F-6C3D-11d3-B653-00C04F79498E", KSCATEGORY_BDA_TRANSPORT_INFORMATION);
#define KSCATEGORY_BDA_TRANSPORT_INFORMATION DEFINE_GUIDNAMED(KSCATEGORY_BDA_TRANSPORT_INFORMATION)


//===========================================================================
//
// BDA Node Categories
//
//===========================================================================


#define STATIC_KSNODE_BDA_RF_TUNER \
    0x71985f4c, 0x1ca1, 0x11d3, 0x9c, 0xc8, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("71985F4C-1CA1-11d3-9CC8-00C04F7971E0", KSNODE_BDA_RF_TUNER);
#define KSNODE_BDA_RF_TUNER DEFINE_GUIDNAMED(KSNODE_BDA_RF_TUNER)


#define STATIC_KSNODE_BDA_QAM_DEMODULATOR \
    0x71985f4d, 0x1ca1, 0x11d3, 0x9c, 0xc8, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("71985F4D-1CA1-11d3-9CC8-00C04F7971E0", KSNODE_BDA_QAM_DEMODULATOR);
#define KSNODE_BDA_QAM_DEMODULATOR DEFINE_GUIDNAMED(KSNODE_BDA_QAM_DEMODULATOR)


#define STATIC_KSNODE_BDA_QPSK_DEMODULATOR \
    0x6390c905, 0x27c1, 0x4d67, 0xbd, 0xb7, 0x77, 0xc5, 0xd, 0x7, 0x93, 0x0
DEFINE_GUIDSTRUCT("6390C905-27C1-4d67-BDB7-77C50D079300", KSNODE_BDA_QPSK_DEMODULATOR);
#define KSNODE_BDA_QPSK_DEMODULATOR DEFINE_GUIDNAMED(KSNODE_BDA_QPSK_DEMODULATOR)


#define STATIC_KSNODE_BDA_8VSB_DEMODULATOR \
    0x71985f4f, 0x1ca1, 0x11d3, 0x9c, 0xc8, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("71985F4F-1CA1-11d3-9CC8-00C04F7971E0", KSNODE_BDA_8VSB_DEMODULATOR);
#define KSNODE_BDA_8VSB_DEMODULATOR DEFINE_GUIDNAMED(KSNODE_BDA_8VSB_DEMODULATOR)


#define STATIC_KSNODE_BDA_OPENCABLE_POD \
    0xd83ef8fc, 0xf3b8, 0x45ab, 0x8b, 0x71, 0xec, 0xf7, 0xc3, 0x39, 0xde, 0xb4
DEFINE_GUIDSTRUCT("D83EF8FC-F3B8-45ab-8B71-ECF7C339DEB4", KSNODE_BDA_OPENCABLE_POD);
#define KSNODE_BDA_OPENCABLE_POD DEFINE_GUIDNAMED(KSNODE_BDA_OPENCABLE_POD)


#define STATIC_KSNODE_BDA_PID_FILTER \
    0xf5412789, 0xb0a0, 0x44e1, 0xae, 0x4f, 0xee, 0x99, 0x9b, 0x1b, 0x7f, 0xbe
DEFINE_GUIDSTRUCT("F5412789-B0A0-44e1-AE4F-EE999B1B7FBE", KSNODE_BDA_PID_FILTER);
#define KSNODE_BDA_PID_FILTER DEFINE_GUIDNAMED(KSNODE_BDA_PID_FILTER)


#define STATIC_KSNODE_BDA_IP_SINK \
    0x71985f4e, 0x1ca1, 0x11d3, 0x9c, 0xc8, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe0
DEFINE_GUIDSTRUCT("71985F4E-1CA1-11d3-9CC8-00C04F7971E0", KSNODE_BDA_IP_SINK);
#define KSNODE_IP_SINK DEFINE_GUIDNAMED(KSNODE_BDA_IP_SINK)


//===========================================================================
//
// IPSink PINNAME GUID
//
//===========================================================================

#define STATIC_PINNAME_IPSINK_INPUT \
    0x3fdffa70L, 0xac9a, 0x11d2, 0x8f, 0x17, 0x00, 0xc0, 0x4f, 0x79, 0x71, 0xe2
DEFINE_GUIDSTRUCT("3fdffa70-ac9a-11d2-8f17-00c04f7971e2", PINNAME_IPSINK_INPUT);
#define PINNAME_IPSINK_INPUT   DEFINE_GUIDNAMED(PINNAME_IPSINK_INPUT)


//===========================================================================
//
// BDA IPSink Categories/Types
//
//===========================================================================


#define STATIC_KSDATAFORMAT_TYPE_BDA_IP\
    0xe25f7b8e, 0xcccc, 0x11d2, 0x8f, 0x25, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe2
DEFINE_GUIDSTRUCT("e25f7b8e-cccc-11d2-8f25-00c04f7971e2", KSDATAFORMAT_TYPE_BDA_IP);
#define KSDATAFORMAT_TYPE_BDA_IP  DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_BDA_IP)

#define STATIC_KSDATAFORMAT_SUBTYPE_BDA_IP\
    0x5a9a213c, 0xdb08, 0x11d2, 0x8f, 0x32, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe2
DEFINE_GUIDSTRUCT("5a9a213c-db08-11d2-8f32-00c04f7971e2", KSDATAFORMAT_SUBTYPE_BDA_IP);
#define KSDATAFORMAT_SUBTYPE_BDA_IP  DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_BDA_IP)

#define STATIC_KSDATAFORMAT_SPECIFIER_BDA_IP\
    0x6b891420, 0xdb09, 0x11d2, 0x8f, 0x32, 0x0, 0xc0, 0x4f, 0x79, 0x71, 0xe2
DEFINE_GUIDSTRUCT("6B891420-DB09-11d2-8F32-00C04F7971E2", KSDATAFORMAT_SPECIFIER_BDA_IP);
#define KSDATAFORMAT_SPECIFIER_BDA_IP  DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_BDA_IP)



#define STATIC_KSDATAFORMAT_TYPE_BDA_IP_CONTROL\
    0xdadd5799, 0x7d5b, 0x4b63, 0x80, 0xfb, 0xd1, 0x44, 0x2f, 0x26, 0xb6, 0x21
DEFINE_GUIDSTRUCT("DADD5799-7D5B-4b63-80FB-D1442F26B621", KSDATAFORMAT_TYPE_BDA_IP_CONTROL);
#define KSDATAFORMAT_TYPE_BDA_IP_CONTROL  DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_BDA_IP_CONTROL)

#define STATIC_KSDATAFORMAT_SUBTYPE_BDA_IP_CONTROL\
    0x499856e8, 0xe85b, 0x48ed, 0x9b, 0xea, 0x41, 0xd, 0xd, 0xd4, 0xef, 0x81
DEFINE_GUIDSTRUCT("499856E8-E85B-48ed-9BEA-410D0DD4EF81", KSDATAFORMAT_SUBTYPE_BDA_IP_CONTROL);
#define KSDATAFORMAT_SUBTYPE_BDA_IP_CONTROL  DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_BDA_IP_CONTROL)


//===========================================================================
//
// MPE PINNAME GUID
//
//===========================================================================

#define STATIC_PINNAME_MPE \
    0xc1b06d73L, 0x1dbb, 0x11d3, 0x8f, 0x46, 0x00, 0xC0, 0x4f, 0x79, 0x71, 0xE2
DEFINE_GUIDSTRUCT("C1B06D73-1DBB-11d3-8F46-00C04F7971E2", PINNAME_MPE);
#define PINNAME_MPE   DEFINE_GUIDNAMED(PINNAME_MPE)


/////////////////////////////////////////////////////////////
//
// BDA MPE Categories/Types
//
#define STATIC_KSDATAFORMAT_TYPE_MPE \
    0x455f176c, 0x4b06, 0x47ce, 0x9a, 0xef, 0x8c, 0xae, 0xf7, 0x3d, 0xf7, 0xb5
DEFINE_GUIDSTRUCT("455F176C-4B06-47ce-9AEF-8CAEF73DF7B5", KSDATAFORMAT_TYPE_MPE);
#define KSDATAFORMAT_TYPE_MPE  DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_MPE)


#if defined(__cplusplus)
}
#endif // defined(__cplusplus)

#endif // !defined(_BDAMEDIA_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\casamp\plugin\catoll.cpp ===
#ifdef IMPLEMENT_TOLL
///////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996  Microsoft Corporation
//
//  Module Name: catoll.cpp
//
//  Abstract:
//
//    Implements ICAToll and IDispatch interface for CA Plugin Component
//
//
////////////////////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "catoll.h"

////////////////////////////////////////////////////////////////////////////////////////////
//
//  class constructor
//
CMyToll::CMyToll(
    LPUNKNOWN   UnkOuter,
    TCHAR*      Name,
    HRESULT*    hr
    )
////////////////////////////////////////////////////////////////////////////////////////////
{
	ITypeLib *ptlib;

	//initialize time and state
	m_PaidDate = 0;
	m_State = Unpaid;

	//initialize policy and request pointers
	m_pRequest = NULL;
	m_pPolicy = NULL;

	//initialize TypeInfo
	m_ptinfo = NULL;

    if (UnkOuter)
		m_UnkOuter = UnkOuter;
    else
	{
        *hr = VFW_E_NEED_OWNER;
		return;
	}

	*hr = LoadTypeLib(L"ca\\ca.dll", &ptlib);

	if(FAILED(*hr))
		return;

	if(ptlib == NULL)
		return;

	*hr = ptlib->GetTypeInfoOfGuid(IID_ICAToll, &m_ptinfo); 

    return;
}


////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
CMyToll::~CMyToll (
    void
    )
////////////////////////////////////////////////////////////////////////////////////////////
{
	if(m_pPolicy)
		m_pPolicy->Release();

	if(m_pRequest)
		m_pRequest->Release();
}

////////////////////////////////////////////////////////////////////////////////////////////
//
//	QueryInterface
//
// determine if we support various interfaces
//
STDMETHODIMP
CMyToll::QueryInterface(
    const IID& iid,
    void** ppv
    )
{
    if (iid ==  __uuidof(ICAToll))
        return GetInterface(static_cast<ICAToll*>(this), ppv);

    if (m_UnkOuter)
        return (m_UnkOuter->QueryInterface (iid, ppv));

    return E_NOINTERFACE;
}

////////////////////////////////////////////////////////////////////////////////////////////
//
//	AddRef
//
// pass through AddRef calls to aggregated parent
//
STDMETHODIMP_(ULONG)
CMyToll::AddRef ()
{
    if (m_UnkOuter)
        return m_UnkOuter->AddRef ();
    else
        return 0;
}

////////////////////////////////////////////////////////////////////////////////////////////
//
//	Release
//
// pass through Release calls to aggregated parent
//
STDMETHODIMP_(ULONG)
CMyToll::Release ()
{
    if (m_UnkOuter)
        return m_UnkOuter->Release ();
    else
        return 1;
}

////////////////////////////////////////////////////////////////////////////////////////////
//
//	GetIDsOfNames
//
// pass through IDispatch call
//
STDMETHODIMP 
CMyToll::GetIDsOfNames(
        REFIID riid,
        OLECHAR FAR* FAR* rgszNames,
        UINT cNames,
        LCID lcid,
        DISPID FAR* rgDispId)
{
        return DispGetIDsOfNames(m_ptinfo, rgszNames, cNames, rgDispId);
}

////////////////////////////////////////////////////////////////////////////////////////////
//
//	Invoke
//
// pass through IDispatch call
//
STDMETHODIMP
CMyToll::Invoke(
    DISPID dispidMember,
    REFIID riid,
    LCID lcid,
    WORD wFlags,
    DISPPARAMS FAR* pdispparams,
    VARIANT FAR* pvarResult,
    EXCEPINFO FAR* pexcepinfo,
    UINT FAR* puArgErr)
{
    return DispInvoke(this, m_ptinfo, dispidMember, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
}

////////////////////////////////////////////////////////////////////////////////////////////
//
//	GetTypeInfo
//
// pass through IDispatch call
//
STDMETHODIMP
CMyToll::GetTypeInfo(
      UINT iTInfo,
      LCID lcid,
      ITypeInfo FAR* FAR* ppTInfo)
{
   *ppTInfo = NULL;

   if(iTInfo != 0)
      return ResultFromScode(DISP_E_BADINDEX);

   m_ptinfo->AddRef();
   *ppTInfo = m_ptinfo;

   return NOERROR;
}

////////////////////////////////////////////////////////////////////////////////////////////
//
//	GetTypeInfoCount
//
// pass through IDispatch call
//
STDMETHODIMP
CMyToll::GetTypeInfoCount(UINT FAR* pctinfo)
{
   *pctinfo = 1;
   return NOERROR;
}

////////////////////////////////////////////////////////////////////////////////////////////
//
//	PayToll
//
// Handles payment of this particular toll
//
STDMETHODIMP
CMyToll::PayToll()
{
	SYSTEMTIME timeNow;

	//TO DO:actual code to handle paying should be put here
	
	//get current system time
	GetSystemTime(&timeNow);

	//set it as the time paid
	SystemTimeToVariantTime(&timeNow, &m_PaidDate);
	
	//change the state of the toll to paid.
	m_State = Paid;
	return NOERROR;
}

////////////////////////////////////////////////////////////////////////////////////////////
//
//	get_Request
//
// get a pointer to the request this is associated with
//
STDMETHODIMP
CMyToll::get_Request(ICARequest * * preq)
{
	if (preq == NULL)
		return E_POINTER;

	*preq = m_pRequest;
		
	return NOERROR;
}

////////////////////////////////////////////////////////////////////////////////////////////
//
//	get_Policy
//
// get a pointer to the policy this is associated with
//
STDMETHODIMP
CMyToll::get_Policy(ICAPolicy * * ppolicy)
{
	if (ppolicy == NULL)
		return E_POINTER;

	*ppolicy = m_pPolicy;
		
	return NOERROR;
}

////////////////////////////////////////////////////////////////////////////////////////////
//
//	get_Description
//		lFormat = format of description to retrieve
//		pbstr = where to return the description
//
// retrieve the description of this toll
//
STDMETHODIMP
CMyToll::get_Description(LONG lFormat, BSTR * pbstr)
{
	if (pbstr == NULL)
		return E_POINTER;
	
	*pbstr = SysAllocString(L"CA Toll Object");

	if ((*pbstr) == NULL)
		return E_OUTOFMEMORY;

	return NOERROR;
}

////////////////////////////////////////////////////////////////////////////////////////////
//
//	RefundToll
//
// refund a toll
//
STDMETHODIMP
CMyToll::RefundToll()
{
	//TO DO:  needs to have code to refund the acctual money
	
	m_State = Unpaid;
	return NOERROR;
}

////////////////////////////////////////////////////////////////////////////////////////////
//
//	get_State
//		plState = where to store the state
//
// returns the state of the current toll
//
STDMETHODIMP
CMyToll::get_State(LONG * plState)
{
	if (plState == NULL)
		return E_POINTER;

	*plState = m_State;
		
	return NOERROR;
}

////////////////////////////////////////////////////////////////////////////////////////////
//
//	get_TimePaid
//
// return when this toll was paid
//
STDMETHODIMP
CMyToll::get_TimePaid(DATE * pdtPaid)
{
	if (pdtPaid == NULL)
		return E_POINTER;
		
	*pdtPaid = m_PaidDate;
	
	return NOERROR;
}

////////////////////////////////////////////////////////////////////////////////////////////
//
//	get_Refundable
//		pVal = boolean variable to hold result
//
// return whether this toll is refundable
//
STDMETHODIMP
CMyToll::get_Refundable(BOOL * pVal)
{
	if (pVal == NULL)
		return E_POINTER;

	*pVal = false;
		
	return NOERROR;
}

////////////////////////////////////////////////////////////////////////////////////////////
//
//	set_Policy
//		pPolicy = policy to set to
//
// set which policy we are connected to
//
STDMETHODIMP
CMyToll::set_Policy(IUnknown *pPolicy)
{
	m_pPolicy = (ICAPolicy *)pPolicy;

	if(m_pPolicy)
		m_pPolicy->AddRef();
	else
		return E_FAIL;

	return S_OK;
}

////////////////////////////////////////////////////////////////////////////////////////////
//
//	set_Request
//		pRequest = request to set to
//
// set which request we are connected to
//
STDMETHODIMP
CMyToll::set_Request(IUnknown *pRequest)
{
	m_pRequest = (ICARequest *)pRequest;

	if(m_pRequest)
		m_pRequest->AddRef();
	else
		return E_FAIL;

	return S_OK;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\casamp\plugin\dllentryhack.cpp ===
#define DllGetClassObject AMovieDllGetClassObject
#define DllEntryPoint AMovieDllEntryPoint
#define UNICODE
#include "dllentry.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\casamp\plugin\pch.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    pch.h

Abstract:

    Precompiled header

--*/

// Windows
#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <memory.h>
#include <stdio.h>

// DShow
#include <streams.h>
#include <amstream.h>
#include <dvdmedia.h>

// DDraw
#include <ddraw.h>
#include <ddkernel.h>

// KS
#include <ks.h>
#include <ksmedia.h>
#include <ksproxy.h>

#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#include <strmif.h>
#include <BdaIface.h>
#include "bdamedia.h"
#include "bdatypes.h"
#ifdef IMPLEMENT_IBDA_ECMMap
#include "ecmmap.h"
#endif
#include "mstvca.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\mauitune\bdadebug.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;


#ifndef __BDADEBUG_H
#define __BDADEBUG_H
#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

//======================================================;
//  Interfaces provided by this file:
//
//      All interfaces provided by this file only exist and generate
//      code when DEBUG is defined.  No code or data are generated when
//      DEBUG is not defined.
//
//      CDEBUG_BREAK()
//          Causes a trap #3, which hopefully will put you
//          in your debugger.
//
//      MDASSERT(exp)
//          If <exp> evaluates to false, prints a failure message
//          and calls CDEBUG_BREAK()
//
//      CdebugPrint(level, (printf_args));
//          If <level> is >= _CDebugLevel, then calls
//          DbgPrint(printf_args)
//
//======================================================;

#define DEBUG_BREAK     DbgBreakPoint()


#ifdef DEBUG

#define DEBUG_LEVEL     DEBUGLVL_VERBOSE     //DEBUGLVL_TERSE

#  if _X86_
#    define CDEBUG_BREAK()  { __asm { int 3 }; }
#  else
#    define CDEBUG_BREAK()  DbgBreakPoint()
#  endif

   extern char _CDebugAssertFail[];
#  define MDASSERT(exp) {\
    if ( !(exp) ) {\
        DbgPrint(_CDebugAssertFail, #exp, __FILE__, __LINE__); \
        CDEBUG_BREAK(); \
    }\
    }

extern enum STREAM_DEBUG_LEVEL _CDebugLevel;

#  define CDebugPrint(level, args) { if (level <= _CDebugLevel) DbgPrint args; }

#else /*DEBUG*/

#  define CDEBUG_BREAK()
#  define MDASSERT(exp)
#  define CDebugPrint(level, args)

#endif /*DEBUG*/


#ifdef __cplusplus
}
#endif // __cplusplus
#endif // #ifndef __BDADEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\casamp\plugin\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by OpenCable.rc
//
#define IDS_PROJNAME                    100
#define IDR_CA                          101
#define IDR_PODPROTOCOL                 102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           105
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\casamp\plugin\catoll.h ===
///////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996  Microsoft Corporation
//
//  Module Name: catoll.h
//
//  Abstract:
//
//    Implements ICAToll and IDispatch interface for CA Plugin Component
//
//
////////////////////////////////////////////////////////////////////////////////////////////


class CMyToll :
    public ICAToll
{

public:

	//IUnknown functions:
    STDMETHODIMP QueryInterface(
        const IID& iid,
        void** ppv
        );

    STDMETHODIMP_(ULONG) AddRef ();

    STDMETHODIMP_(ULONG) Release ();

	//IDispatch functions:
	STDMETHODIMP Invoke( 
		DISPID  dispIdMember,      
		REFIID  riid,              
		LCID  lcid,                
		WORD  wFlags,              
		DISPPARAMS FAR*  pDispParams,  
		VARIANT FAR*  pVarResult,  
		EXCEPINFO FAR*  pExcepInfo,  
		unsigned int FAR*  puArgErr  
		);

	STDMETHODIMP GetTypeInfoCount( 
		unsigned int FAR*  pctinfo  
		);

	STDMETHODIMP GetTypeInfo( 
		unsigned int  iTInfo,         
		LCID  lcid,                   
		ITypeInfo FAR* FAR*  ppTInfo  
		);

	STDMETHODIMP GetIDsOfNames( 
		REFIID  riid,                  
		OLECHAR FAR* FAR*  rgszNames,  
		unsigned int  cNames,          
		LCID   lcid,                   
		DISPID FAR*  rgDispId          
		);
	
	//ICAToll functions:
	STDMETHODIMP PayToll(
		);
        
	STDMETHODIMP get_Request( 
        ICARequest **preq
		);
        
	STDMETHODIMP get_Policy( 
        ICAPolicy **ppolicy
		);
        
	STDMETHODIMP get_Description( 
        long lFormat,
        BSTR *pbstr
		);
        
	STDMETHODIMP RefundToll(
		);

	STDMETHODIMP get_TimePaid(
		DATE * pdtPaid
		);

	STDMETHODIMP get_Refundable(
		BOOL * pVal
		);

	STDMETHODIMP get_State(
		LONG * plState
		);


	STDMETHODIMP set_Request(
		IUnknown *pRequest
		);

	STDMETHODIMP set_Policy(
		IUnknown *pPolicy
		);

	//constructor
    CMyToll(
        LPUNKNOWN UnkOuter,
        TCHAR* Name,
        HRESULT* hr
        );

private:

    //destructor
	~CMyToll (
        void
        );

	//the policy we belong to
	ICAPolicy * m_pPolicy;

	//the request we are connected with
	ICARequest * m_pRequest;

	//date this toll was paid, 0 if unpaid
	DATE m_PaidDate;

	//state of the toll, defined as an enum in the CA header files
	LONG m_State;

    //the outer pUnknown
	LPUNKNOWN             m_UnkOuter;

	//the CA manger
	ICAManager *		  m_pCAMan;

	//our type info
	ITypeInfo *			  m_ptinfo;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\casamp\plugin\podprotocol.cpp ===
// PODProtocol.cpp : Implementation of CPODProtocol
#include "pch.h"
#include "pod.h"
#include "PODProtocol.h"

/////////////////////////////////////////////////////////////////////////////
// CPODProtocol

int HexValue(char ch)
{
	if ((ch >= '0') && (ch <= '9'))
		return (ch - '0');
	
	if ((ch >= 'A') && (ch <= 'F'))
		return (ch - 'A');
	
	if ((ch >= 'a') && (ch <= 'f'))
		return (ch - 'a');
	
	return -1;
}

void ReplaceEscapeSequences(char *sz)
{
    if (NULL == sz)
		return;

    char* pchSrc = sz;
    char* pchDst = sz;
    while (*pchSrc != NULL)
		{
		if (*pchSrc != '%')
			{
			*pchDst++ = *pchSrc++;
			}
		else
			{
			int i1 = HexValue(pchSrc[1]);
			int i2 = HexValue(pchSrc[2]);
			if ((i1 != -1) && (i2 != -1))
				{
				*pchDst++ = (char) ((i1 << 4) | i2);
				pchSrc += 3;
				}
			else
				{
				// Not hex, so just go ahead and copy the '%'.
				*pchDst++ = *pchSrc++;
				}
			}
		
		}
    *pchDst = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\mauitune\ari.cpp ===
//////////////////////////////////////////////////////////////////////////////
//                     (C) Philips Semiconductors-CSU 1999
//  All rights are reserved. Reproduction in whole or in part is prohibited
//  without the written consent of the copyright owner.
//
//  Philips reserves the right to make changes without notice at any time.
//  Philips makes no warranty, expressed, implied or statutory, including but
//  not limited to any implied warranty of merchantibility or fitness for any
//  particular purpose, or that the use will not infringe any third party
//  patent, copyright or trademark. Philips must not be liable for any loss
//  or damage arising from its use.
//
//  ARI.CPP
//      CDevice class : ARI function implementations.
//
//////////////////////////////////////////////////////////////////////////////


#include "philtune.h"

//void STREAMAPI FEQualityCheckThread(IN PVOID Context);
void FEQualityCheckThread(IN PVOID Context);


/*
* CreateQualityCheckThread()
* Input :
* Output:   TRUE - if thread creation and timer creation succeeds
*           FALSE - if thread creation or timer creation does not succeed
* Description:  Creates a new thread to check the VSB hang condition and quality of the signal
*   and take necessary actions. Also Initializes a timer, which will wake up this
*   thread at regular intervals to do the check.
*/
BOOL CDevice::CreateQualityCheckThread()
{
    BOOL        bStatus;
    HANDLE      hHandle;

    // Enable QCM
    m_uiQualityCheckMode = QCM_ENABLE;
    
    // Create new thread
    if(StartThread( &hHandle, FEQualityCheckThread, this) == TRUE)
    {
        _DbgPrintF( DEBUGLVL_VERBOSE,("CDevice::CreateQualityCheckThread: Thread Created Success\n"));
    }
    else
    {
        _DbgPrintF( DEBUGLVL_ERROR,("CDevice::CreateQualityCheckThread: Thread Created Fail\n"));
        return FALSE;
    }
    m_bQualityCheckActiveFlag = TRUE;
    m_QualityCheckTimer.Set(100000);
    return TRUE;
}


/*
* QualityCheckThread()
* Input : Context
* Output:
* Description: Thread which checks signal quality
*/
//void STREAMAPI FEQualityCheckThread(IN PVOID Context)
void FEQualityCheckThread(IN PVOID Context)
{
    CDevice *p_FE = (CDevice *)Context;
    p_FE->QualityCheckThread();
}

/*
* QualityCheckThread()
* Input : Context
* Output:
* Description: Thread which checks signal quality
*/
void CDevice::QualityCheckThread()
{

    _DbgPrintF( DEBUGLVL_VERBOSE,("CDevice::QualityCheckThread: In Quality Check Thread\n"));

    UINT i, k;

    Delay(10000);
    // Infinite loop
    while(1)
    {
        // Wait for timer to signal. Timeout = 200ms
        if(!m_QualityCheckTimer.Wait(200000))
        {
            _DbgPrintF( DEBUGLVL_VERBOSE,("QualityCheckThread: QCT Timed Out"));
        }
        else
        {
            // Wait for mutex
            m_QualityCheckMutex.Lock();
            UINT uiQcm;
            // if signalled , read Quality check mode (QCM). Release mutex
            uiQcm = m_uiQualityCheckMode;
            m_QualityCheckMutex.Unlock();

            // if QCM = ENABLE , check signal quality
            if (uiQcm == QCM_ENABLE)
            {
                m_uiQualityCheckModeAck = QCM_ENABLE;
                TimerRoutine();
            }
            // if QCM = DISABLE, do nothing
            else if (uiQcm == QCM_DISABLE)
            {
                // Reset all counters
                ((CVSB1Demod *)(m_pDemod))->ResetHangCounter();
                m_uiQualityCheckModeAck = QCM_DISABLE;
//              _DbgPrintF( DEBUGLVL_VERBOSE,("QualityCheckThread: Inside Disable\n"));
            }
            // if QCM = RESET. Reset all counters
            else if (uiQcm == QCM_RESET)
            {
                m_uiQualityCheckModeAck = QCM_RESET;
                _DbgPrintF( DEBUGLVL_VERBOSE,("QualityCheckThread: Inside Reset\n"));
            }
            // if QCM = TERMINATE, Cancel timer and end thread
            else if (uiQcm == QCM_TERMINATE)
            {
                m_uiQualityCheckModeAck = QCM_TERMINATE;
                break;
            }
            // if QCM = none of the above, do nothing
            else
            {
            }
        } // Wait for timer

    }// infinite while loop

    // Cancel timer
    m_QualityCheckTimer.Cancel();

    _DbgPrintF( DEBUGLVL_VERBOSE,("QualityCheckThread: Terminating Thread\n"));
    // End thread
    StopThread();
}



/*
* TimerRoutine()
* Input :
* Output:
* Description: Timer routine which periodically checks for a chip hang
* Called only when QCM is Enabled
*/
//void STREAMAPI CDevice::TimerRoutine()
void CDevice::TimerRoutine()
{
    if(m_bHangCheckFlag == TRUE)
        ((CVSB1Demod *)(m_pDemod))->CheckHang();
    else
        ((CVSB1Demod *)(m_pDemod))->ResetHangCounter();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\casamp\plugin\podprotocol.h ===
// PODProtocol.h : Declaration of the CPODProtocol

#ifndef __PODPROTOCOL_H_
#define __PODPROTOCOL_H_

#include <comdef.h>
#include "resource.h"

int HexValue(char ch);
void ReplaceEscapeSequences(char *sz);

/////////////////////////////////////////////////////////////////////////////
// CPODProtocol
class ATL_NO_VTABLE CPODProtocol : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CPODProtocol, &CLSID_PODProtocol>,
	public IInternetProtocol,
	public IPODProtocol
{
public:
	CPODProtocol()
	{
		m_pUnkMarshaler = NULL;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_PODPROTOCOL)
DECLARE_GET_CONTROLLING_UNKNOWN()
DECLARE_NOT_AGGREGATABLE(CPODProtocol)
DECLARE_CLASSFACTORY_SINGLETON(CPODProtocol)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CPODProtocol)
	COM_INTERFACE_ENTRY(IPODProtocol)
	COM_INTERFACE_ENTRY(IInternetProtocol)
	COM_INTERFACE_ENTRY(IInternetProtocolRoot)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

/////////////////////////////////////////////////////////////////////////////
// CTVProt -- IInternetProtocol

	STDMETHODIMP Read(LPVOID pv, ULONG cb, ULONG* pcbRead)
		{
		// TRACELM(TRACE_DEBUG, "CTVProt::Read()");
		if (m_sz == NULL)
			{
			*pcbRead = 0;
			return S_FALSE;
			}

		strncpy((char *)pv, m_sz, cb);
		*pcbRead = strlen(m_sz);

		delete m_sz;
		m_sz = NULL;
		return S_OK;
		}

	STDMETHODIMP Seek(LARGE_INTEGER /* dlibMove */, 
					DWORD /* dwOrigin */, 
					ULARGE_INTEGER* /* plibNewPosition*/)
		{
		// TRACELM(TRACE_DEBUG, "CTVProt::Seek()");
		return E_FAIL;
		}

	STDMETHODIMP LockRequest(DWORD /* dwOptions */)
		{
		// TRACELM(TRACE_DEBUG, "CTVProt::LockRequest()");
		return S_OK;
		}

	STDMETHODIMP UnlockRequest()
		{
		// TRACELM(TRACE_DEBUG, "CTVProt::UnlockRequest()");
		return S_OK;
		}

	/////////////////////////////////////////////////////////////////////////////
	// IInternetProtocolRoot
	STDMETHOD(Start)(LPCWSTR szwUrl,
					IInternetProtocolSink* pOIProtSink,
					IInternetBindInfo* pOIBindInfo,
					DWORD grfPI,
					DWORD /* dwReserved */)
		{
		if (!pOIProtSink)
			return E_POINTER;
		
		m_pSink.Release();
		m_pSink = pOIProtSink;

		char szURL[256];

		WideCharToMultiByte(CP_ACP, 0, szwUrl, -1, szURL, sizeof(szURL), NULL, NULL);

		ReplaceEscapeSequences(szURL);

		if (m_ppod == NULL)
			{
			TCHAR sz[4*1024];
			wsprintf(sz,_T("<HTML><BODY><B>POD Driver not found to handle:</B> %s</BODY></HTML>"), szURL);
			m_sz = new char [strlen(sz) + 1];
			strcpy(m_sz, sz);
			}
		else
			{
			long cb = 1024;
			HRESULT hr = ERROR_MORE_DATA;
			while (HRESULT_CODE(hr) == ERROR_MORE_DATA)
			    {
			    delete [] m_sz;
			    m_sz = new char[cb];
			    hr = m_ppod->get_HTML(szURL, &cb, m_sz);
			    }
			}

		m_pSink->ReportData(BSCF_DATAFULLYAVAILABLE, 0, 0);


		m_pSink->ReportResult(S_OK, 0, 0);
		return S_OK;
		}

	STDMETHODIMP Continue(PROTOCOLDATA* /* pProtocolData */)
		{
		// TRACELM(TRACE_DEBUG, "CTVProt::Continue()");
		return S_OK;
		}

	STDMETHODIMP Abort(HRESULT /* hrReason */, DWORD /* dwOptions */)
		{
		// TRACELM(TRACE_DEBUG, "CTVProt::Abort()");

		if (m_pSink)
		{
			m_pSink->ReportResult(E_ABORT, 0, 0);
		}

		return S_OK;
		}

	STDMETHODIMP Terminate(DWORD dwf/* dwOptions */)
		{
		// TRACELSM(TRACE_DEBUG, (dbgDump << "CTVProt::Terminate() " << hexdump(dwf)), "");
		return S_OK;
		}

	STDMETHODIMP Suspend()
		{
		// TRACELM(TRACE_DEBUG, "CTVProt::Suspend()");
		return E_NOTIMPL;
		}

	STDMETHODIMP Resume()
		{
		// TRACELM(TRACE_DEBUG, "CTVProt::Resume()");
		return E_NOTIMPL;
		}
	
    CComPtr<IInternetProtocolSink> m_pSink;
	CComPtr<ICAPod> m_ppod;
	char *m_sz;

// IPODProtocol
	STDMETHOD(put_CAPod)(IUnknown *punk)
		{
		return punk->QueryInterface(__uuidof(ICAPod), (void **)&m_ppod);
		}
public:
};

#endif //__PODPROTOCOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\mauitune\antenna.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    Antenna.cpp

Abstract:

    Antenna pin code.

--*/

#include "PhilTune.h"

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA

enum tuner_errors { NO_ERRORS_DEFINED};


NTSTATUS
CAntennaPin::PinCreate(
    IN OUT PKSPIN pKSPin,
    IN PIRP pIrp
    )
{
    NTSTATUS        Status = STATUS_SUCCESS;
    CAntennaPin*    pPin;
    CFilter*        pFilter;

    _DbgPrintF(DEBUGLVL_VERBOSE,("CAntennaPin::PinCreate"));

    ASSERT( pKSPin);
    ASSERT( pIrp);

    pFilter = FilterFromIRP( pIrp);
    ASSERT( pFilter);
    if (!pFilter)
    {
        Status = STATUS_DEVICE_NOT_CONNECTED;
        goto exit;
    }

    pPin = new(NonPagedPool,'IFsK') CAntennaPin;
    if (!pPin)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    //  Link our pin context to our filter context.
    //
    pPin->SetFilter( pFilter);

    //  Link our context to the KSPIN structure.
    //
    pKSPin->Context = pPin;

exit:
    return Status;
}


NTSTATUS
CAntennaPin::PinClose(
    IN OUT PKSPIN Pin,
    IN PIRP Irp
    )
{
    _DbgPrintF(DEBUGLVL_VERBOSE,("PinClose"));

    ASSERT(Pin);
    ASSERT(Irp);

    CAntennaPin* pin = reinterpret_cast<CAntennaPin*>(Pin->Context);

    ASSERT(pin);

    delete pin;

    return STATUS_SUCCESS;
}


NTSTATUS
CAntennaPin::PinSetDeviceState(
    IN PKSPIN Pin,
    IN KSSTATE ToState,
    IN KSSTATE FromState
    )
{
    NTSTATUS        Status = STATUS_SUCCESS;
    PKSDEVICE       pKSDevice;
    CAntennaPin *   pPin;
    CDevice *       pDevice;

    _DbgPrintF( DEBUGLVL_VERBOSE,
                ("CAntennaPin::PinSetDeviceState"));

    ASSERT(Pin);

    pKSDevice = KsPinGetDevice( Pin);

    pPin = reinterpret_cast<CAntennaPin*>(Pin->Context);
    ASSERT( pPin);

    pDevice = reinterpret_cast<CDevice *>(pKSDevice->Context);
    ASSERT(pDevice);

    if ((ToState == KSSTATE_STOP) && (FromState != KSSTATE_STOP))
    {
        //  Since this driver allocates resources on a filter wide basis,
        //  we tell the filter to release resources when the last pin,
        //  most upstream pin, transitions to stop.
        //
        //  The antenna pin is the last one to be transitioned to stop,
        //  so tell the filter to release its resources.
        //
        Status = pPin->m_pFilter->ReleaseResources();
        pPin->m_KsState = ToState;
    }
    else if ((ToState == KSSTATE_ACQUIRE) && (FromState == KSSTATE_STOP))
    {
        //  Since this driver allocates resources on a filter wide basis,
        //  we tell the filter to acquire resources when the last pin,
        //  most upstream pin, transitions out of stop.
        //
        //  The antenna pin is the last one to be transitioned to stop,
        //  so tell the filter to acquire its resources.
        //
        Status = pPin->m_pFilter->AcquireResources();
        if (NT_SUCCESS( Status))
        {
            pPin->m_KsState = ToState;
        }
    }
    else if (ToState > KSSTATE_RUN)
    {
        _DbgPrintF( DEBUGLVL_TERSE,
                    ("CAntennaPin::PinSetDeviceState - Invalid Device State. ToState 0x%08x.  FromState 0x%08x.",
                     ToState, FromState));
        Status = STATUS_INVALID_PARAMETER;
    }
    else
    {
        pPin->m_KsState = ToState;
    }

    pPin->m_pFilter->SetDeviceState( pPin->m_KsState);

    return Status;
}


NTSTATUS
CAntennaPin::GetCenterFrequency(
    IN PIRP         pIrp,
    IN PKSPROPERTY  pKSProperty,
    IN PULONG       pulProperty
    )
{
    CAntennaPin* pPin;

    _DbgPrintF(DEBUGLVL_VERBOSE,("PinClose"));

    ASSERT(pIrp);
    ASSERT(pKSProperty);
    ASSERT(pulProperty);

    pPin = AntennaPinFromIRP( pIrp);
    ASSERT(pPin);
    if (!pPin)
    {
        return STATUS_INVALID_PARAMETER;
    }

    *pulProperty = pPin->m_ulCurrentFrequency;

    return STATUS_SUCCESS;
}


NTSTATUS
CAntennaPin::PutCenterFrequency(
    IN PIRP         pIrp,
    IN PKSPROPERTY  pKSProperty,
    IN PULONG       pulProperty
    )
{
    NTSTATUS        Status = STATUS_SUCCESS;
    CAntennaPin*    pPin;
    CFilter*        pFilter;

    _DbgPrintF(DEBUGLVL_VERBOSE,("PinClose"));

    ASSERT(pIrp);
    ASSERT(pKSProperty);
    ASSERT(pulProperty);


    //  Validate that the node type is associated with this pin.
    //
    Status = BdaValidateNodeProperty( pIrp, pKSProperty);
    if (!NT_SUCCESS( Status))
    {
        goto errExit;
    }


    //  Get a pointer to our object.
    //
    pPin = AntennaPinFromIRP( pIrp);
    ASSERT( pPin);
    if (!pPin)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    pFilter = pPin->GetFilter();
    ASSERT( pFilter);
    if (!pFilter)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }


    Status = pFilter->ChangeFrequency( *pulProperty);

errExit:
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\mauitune\bdaguid.c ===
#include <wdm.h>
#include <windef.h>
#include <ks.h>
#include <ksmedia.h>
#include <bdatypes.h>

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_PRAGMA

//  KSGuid.h defines INITGUID and some other macros that are useful in the
//  the actual definition of GUIDs.
//  KSGuid.h should be included immediately before those include files that
//  contain the GUIDS that you need defined.  Do NOT put it before include
//  files like KSMedia.h.  If you need definitions of GUIDS that are declared
//  there, use KSGuid.lib.
//
#include <ksguid.h>

#include <i2cgpio.h>
#include <bdamedia.h>
#include <atsmedia.h>

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif // ALLOC_DATA_PRAGMA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\mauitune\devcaps.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    device.cpp

Abstract:

    Device driver core, initialization, etc.

--*/

#include "PhilTune.h"

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA

//  BASIC
//
//  55250000L, 0x8ea2
//  203000000L, 0x8e94
//  497000000L, 0x8e31
//  801250000L MAX

//  TD1536 - MODE_NTSC
//
//  55250000L, 0x8ea0
//  203000000L, 0x8e90
//  497000000L, 0x8e30

//  TD1536 - MODE_ATSC
//
//  55250000L, 0x8ea5
//  203000000L, 0x8e95
//  497000000L, 0x8e35

//  FI1236 - Standard: !KS_AnalogVideo_NTSC_M
//
//  BASIC

//  FI1236 - Standard: KS_AnalogVideo_NTSC_M
//
//  55250000L, 0x8ea2
//  203000000L, 0x8e94
//  497000000L, 0x8e31
//  ==811000000L, 0x8e34
//  ==817000000L, 0x8e34

//  FR1236
//
//  55250000L, 0x8ea0
//  203000000L, 0x8e90
//  497000000L, 0x8e30

//  FI1216
//  FI1246
//  FR1216
//
//  BASIC


//  FI1256
//
//  55250000L, 0x8ea2
//  206250000L, 0x8e94
//  493250000L, 0x8e31

//  FI1216MF - Standard: NOT KS_AnalogVideo_SECAM_L
//
//  55250000L, 0x8ea4
//  203000000L, 0x8e94
//  497000000L, 0x8e34

//  FI1216MF - Standard: KS_AnalogVideo_SECAM_L
//
//  55250000L, 0x8ea6
//  158125000L, 0x8e96
//  333125000L, 0x8e36


#if 0
const PHILIPS_TUNER_CAPAPILITIES rgTunerCaps[] =
{
    // PAL B/G
    //
    {
        L"FI1216",                  // pwcTunerId
        FI1216,                     // ulTunerId
        KS_AnalogVideo_PAL_B,       // ulStandardsSupported
        NULL,                       // pFrequencyRanges
        62500L,                     // ulhzTuningGranularity
        2,                          // ulNumberOfInputs
        150,                        // ulmsSettlingTime
        KSPROPERTY_TUNER_MODE_TV,   // ulModesSupported
        KS_TUNER_STRATEGY_PLL       // ulStrategy
    },

    // SECAM + PAL B/G
    //
    {
        L"FI1216MF",                // pwcTunerId
        FI1216MF,                   // ulTunerId
          KS_AnalogVideo_PAL_B      // ulStandardsSupported
        | KS_AnalogVideo_SECAM_L,
        NULL,                       // pFrequencyRanges
        62500L,                     // ulhzTuningGranularity
        1,                          // ulNumberOfInputs
        150,                        // ulmsSettlingTime
        KSPROPERTY_TUNER_MODE_TV,   // ulModesSupported
        KS_TUNER_STRATEGY_PLL       // ulStrategy
    },

    // NTSC North America + NTSC Japan
    //
    {
        L"FI1236",                  // pwcTunerId
        FI1236,                     // ulTunerId
        KS_AnalogVideo_NTSC_M,      // ulStandardsSupported
        NULL,                       // pFrequencyRanges
        62500L,                     // ulhzTuningGranularity
        1,                          // ulNumberOfInputs
        150,                        // ulmsSettlingTime
        KSPROPERTY_TUNER_MODE_TV,   // ulModesSupported
        KS_TUNER_STRATEGY_PLL       // ulStrategy
    },

    // PAL I
    //
    {
        L"FI1246",                  // pwcTunerId
        FI1246,                     // ulTunerId
        KS_AnalogVideo_PAL_I,       // ulStandardsSupported
        NULL,                       // pFrequencyRanges
        62500L,                     // ulhzTuningGranularity
        2,                          // ulNumberOfInputs
        150,                        // ulmsSettlingTime
        KSPROPERTY_TUNER_MODE_TV,   // ulModesSupported
        KS_TUNER_STRATEGY_PLL       // ulStrategy
    },

    // PAL D China
    //
    {
        L"FI1256",                  // pwcTunerId
        FI1256,                     // ulTunerId
        KS_AnalogVideo_PAL_D,       // ulStandardsSupported
        NULL,                       // pFrequencyRanges
        62500L,                     // ulhzTuningGranularity
        1,                          // ulNumberOfInputs
        150,                        // ulmsSettlingTime
        KSPROPERTY_TUNER_MODE_TV,   // ulModesSupported
        KS_TUNER_STRATEGY_PLL       // ulStrategy
    },

    // PAL B/G FM Tuner
    //
    {
        L"FR1216",                  // pwcTunerId
        FR1216,                     // ulTunerId
        KS_AnalogVideo_PAL_B,       // ulStandardsSupported
        NULL,                       // pFrequencyRanges
        62500L,                     // ulhzTuningGranularity
        2,                          // ulNumberOfInputs
        150,                        // ulmsSettlingTime
          KSPROPERTY_TUNER_MODE_TV  // ulModesSupported
        | KSPROPERTY_TUNER_MODE_FM_RADIO,
        KS_TUNER_STRATEGY_PLL       // ulStrategy
    },

    // NTSC North America FM Tuner
    //
    {
        L"FR1236",                  // pwcTunerId
        FR1236,                     // ulTunerId
        KS_AnalogVideo_NTSC_M,      // ulStandardsSupported
        NULL,                       // pFrequencyRanges
        62500L,                     // ulhzTuningGranularity
        2,                          // ulNumberOfInputs
        150,                        // ulmsSettlingTime
          KSPROPERTY_TUNER_MODE_TV  // ulModesSupported
        | KSPROPERTY_TUNER_MODE_FM_RADIO,
        KS_TUNER_STRATEGY_PLL       // ulStrategy
    },

    // ATSC Digital tuner (NTSC North America + NTSC Japan)?
    //
    {
        L"TD1536",                  // pwcTunerId
        TD1536,                     // ulTunerId
        KS_AnalogVideo_NTSC_M,      // ulStandardsSupported
        NULL,                       // pFrequencyRanges
        62500L,                     // ulhzTuningGranularity
        2,                          // ulNumberOfInputs
        150,                        // ulmsSettlingTime
          KSPROPERTY_TUNER_MODE_TV  // ulModesSupported
        | KSPROPERTY_TUNER_MODE_ATSC,
        KS_TUNER_STRATEGY_PLL       // ulStrategy
    },
};

const ULONG ulcTunerCapsEntries = SIZEOF_ARRAY( rgTunerCaps);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\mauitune\common.h ===
#ifndef _COMMON_H
#define _COMMON_H_

extern "C" {
#include <wdm.h>
#include "wdmdebug.h"
}

// #include <limits.h>
#include <unknown.h>
#include <ks.h>
#include <ksmedia.h>
#include <bdatypes.h>
#include <bdamedia.h>
#include <atsmedia.h>
#include <bdasup.h>

#include "medguid.h"
#include <kcom.h>
#include <ksdebug.h>

#undef INTERFACE



#endif //_COMMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\mauitune\filtprop.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    FiltProp.cpp

Abstract:

    Private Filter Property Sets

--*/

#include "PhilTune.h"



/*
** SetVsbResetProperty ()
**
.
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
NTSTATUS
CFilter::
SetVsbResetProperty(
    IN PIRP         pIrp,
    IN PKSPROPERTY  pKSProperty,
    IN PKSPROPERTY_VSB_CTRL_S  pProperty
    )
{
    NTSTATUS        Status = STATUS_SUCCESS;
    CFilter *       pFilter;

    ASSERT( pIrp);
    ASSERT( pKSProperty);
    ASSERT( pProperty);

    //  Obtain a "this" pointer for the method.
    //
    //  Because this function is called directly from the property dispatch
    //  table, we must get our own pointer to the underlying object.
    //
    pFilter = FilterFromIRP( pIrp);
    ASSERT( pFilter);
    if (!pFilter)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    //  Set the property.
    //
    Status = (pFilter->GetDevice())->VsbReset(pProperty->Value);

errExit:
    return Status;
}


/*
** GetVsbCapabilitiesProperty ()
**
**    Example of a get property handler for a filter global property set.
**    Use this as a template for adding support for filter global
**    properties.
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
NTSTATUS
CFilter::
GetVsbCapabilitiesProperty(
    IN PIRP         pIrp,
    IN PKSPROPERTY  pKSProperty,
    OUT PKSPROPERTY_VSB_CAP_S   pProperty
    )
{
    NTSTATUS        Status = STATUS_SUCCESS;
    CFilter *       pFilter;

    ASSERT( pIrp);
    ASSERT( pKSProperty);
    ASSERT( pProperty);

    //  Obtain a "this" pointer for the method.
    //
    //  Because this function is called directly from the property dispatch
    //  table, we must get our own pointer to the underlying object.
    //
    pFilter = FilterFromIRP( pIrp);
    ASSERT( pFilter);
    if (!pFilter)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    //  Return the property
    //
    Status = (pFilter->GetDevice())->GetVsbCapabilities(pProperty);

errExit:
    return Status;
}


/*
** SetVsbCapabilitiesProperty ()
**
**    Example of a set property handler for a filter global property set.
**    Use this as a template for adding support for filter global
**    properties.
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
NTSTATUS
CFilter::
SetVsbCapabilitiesProperty(
    IN PIRP         pIrp,
    IN PKSPROPERTY  pKSProperty,
    IN PKSPROPERTY_VSB_CAP_S  pProperty
    )
{
    NTSTATUS        Status = STATUS_SUCCESS;
    CFilter *       pFilter;

    ASSERT( pIrp);
    ASSERT( pKSProperty);
    ASSERT( pProperty);

    //  Obtain a "this" pointer for the method.
    //
    //  Because this function is called directly from the property dispatch
    //  table, we must get our own pointer to the underlying object.
    //
    pFilter = FilterFromIRP( pIrp);
    ASSERT( pFilter);
    if (!pFilter)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    //  Set the property.
    //
    Status = (pFilter->GetDevice())->SetVsbCapabilities(pProperty);

errExit:
    return Status;
}

/*
** GetVsbRegisterProperty ()
**
**    Example of a get property handler for a filter global property set.
**    Use this as a template for adding support for filter global
**    properties.
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
NTSTATUS
CFilter::
GetVsbRegisterProperty(
    IN PIRP         pIrp,
    IN PKSPROPERTY  pKSProperty,
    OUT PKSPROPERTY_VSB_REG_CTRL_S   pProperty
    )
{
    NTSTATUS        Status = STATUS_SUCCESS;
    CFilter *       pFilter;

    ASSERT( pIrp);
    ASSERT( pKSProperty);
    ASSERT( pProperty);

    //  Obtain a "this" pointer for the method.
    //
    //  Because this function is called directly from the property dispatch
    //  table, we must get our own pointer to the underlying object.
    //
    pFilter = FilterFromIRP( pIrp);
    ASSERT( pFilter);
    if (!pFilter)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    //  Return the property
    //
    Status = (pFilter->GetDevice())->AccessRegisterList(pProperty, READ_REGISTERS);

errExit:
    return Status;
}


/*
** SetVsbRegisterProperty ()
**
**    Example of a set property handler for a filter global property set.
**    Use this as a template for adding support for filter global
**    properties.
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
NTSTATUS
CFilter::
SetVsbRegisterProperty(
    IN PIRP         pIrp,
    IN PKSPROPERTY  pKSProperty,
    IN PKSPROPERTY_VSB_REG_CTRL_S  pProperty
    )
{
    NTSTATUS        Status = STATUS_SUCCESS;
    CFilter *       pFilter;

    ASSERT( pIrp);
    ASSERT( pKSProperty);
    ASSERT( pProperty);

    //  Obtain a "this" pointer for the method.
    //
    //  Because this function is called directly from the property dispatch
    //  table, we must get our own pointer to the underlying object.
    //
    pFilter = FilterFromIRP( pIrp);
    ASSERT( pFilter);
    if (!pFilter)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    //  Set the property.
    //
    Status = (pFilter->GetDevice())->AccessRegisterList(pProperty, WRITE_REGISTERS);

errExit:
    return Status;
}

/*
** GetVsbCoefficientProperty ()
**
**    Example of a get property handler for a filter global property set.
**    Use this as a template for adding support for filter global
**    properties.
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
NTSTATUS
CFilter::
GetVsbCoefficientProperty(
    IN PIRP         pIrp,
    IN PKSPROPERTY  pKSProperty,
    OUT PKSPROPERTY_VSB_COEFF_CTRL_S   pProperty
    )
{
    NTSTATUS        Status = STATUS_SUCCESS;
    CFilter *       pFilter;

    ASSERT( pIrp);
    ASSERT( pKSProperty);
    ASSERT( pProperty);

    //  Obtain a "this" pointer for the method.
    //
    //  Because this function is called directly from the property dispatch
    //  table, we must get our own pointer to the underlying object.
    //
    pFilter = FilterFromIRP( pIrp);
    ASSERT( pFilter);
    if (!pFilter)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    //  Return the property
    //
    Status = (pFilter->GetDevice())->AccessVsbCoeffList(pProperty, READ_REGISTERS);

errExit:
    return Status;
}


/*
** SetVsbCoefficientProperty ()
**
**    Example of a set property handler for a filter global property set.
**    Use this as a template for adding support for filter global
**    properties.
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
NTSTATUS
CFilter::
SetVsbCoefficientProperty(
    IN PIRP         pIrp,
    IN PKSPROPERTY  pKSProperty,
    IN PKSPROPERTY_VSB_COEFF_CTRL_S  pProperty
    )
{
    NTSTATUS        Status = STATUS_SUCCESS;
    CFilter *       pFilter;

    ASSERT( pIrp);
    ASSERT( pKSProperty);
    ASSERT( pProperty);

    //  Obtain a "this" pointer for the method.
    //
    //  Because this function is called directly from the property dispatch
    //  table, we must get our own pointer to the underlying object.
    //
    pFilter = FilterFromIRP( pIrp);
    ASSERT( pFilter);
    if (!pFilter)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    //  Set the property.
    //
    Status = (pFilter->GetDevice())->AccessVsbCoeffList(pProperty, WRITE_REGISTERS);

errExit:
    return Status;
}


/*
** GetVsbDiagControlProperty ()
**
**    Example of a get property handler for a filter global property set.
**    Use this as a template for adding support for filter global
**    properties.
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
NTSTATUS
CFilter::
GetVsbDiagControlProperty(
    IN PIRP         pIrp,
    IN PKSPROPERTY  pKSProperty,
    OUT PKSPROPERTY_VSB_DIAG_CTRL_S   pProperty
    )
{
    NTSTATUS        Status = STATUS_SUCCESS;
    CFilter *       pFilter;

    ASSERT( pIrp);
    ASSERT( pKSProperty);
    ASSERT( pProperty);

    //  Obtain a "this" pointer for the method.
    //
    //  Because this function is called directly from the property dispatch
    //  table, we must get our own pointer to the underlying object.
    //
    pFilter = FilterFromIRP( pIrp);
    ASSERT( pFilter);
    if (!pFilter)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    //  Return the property
    //
    Status = (pFilter->GetDevice())->GetVsbDiagMode(&pProperty->OperationMode,
                                                    &pProperty->Type);

errExit:
    return Status;
}


/*
** SetVsbDiagControlProperty ()
**
**    Example of a set property handler for a filter global property set.
**    Use this as a template for adding support for filter global
**    properties.
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
NTSTATUS
CFilter::
SetVsbDiagControlProperty(
    IN PIRP         pIrp,
    IN PKSPROPERTY  pKSProperty,
    IN PKSPROPERTY_VSB_DIAG_CTRL_S  pProperty
    )
{
    NTSTATUS        Status = STATUS_SUCCESS;
    CFilter *       pFilter;

    ASSERT( pIrp);
    ASSERT( pKSProperty);
    ASSERT( pProperty);

    //  Obtain a "this" pointer for the method.
    //
    //  Because this function is called directly from the property dispatch
    //  table, we must get our own pointer to the underlying object.
    //
    pFilter = FilterFromIRP( pIrp);
    ASSERT( pFilter);
    if (!pFilter)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    //  Set the property.
    //
    Status = (pFilter->GetDevice())->SetVsbDiagMode(pProperty->OperationMode,
                                                    (VSBDIAGTYPE) (pProperty->Type));

errExit:
    return Status;
}


/*
** SetVsbQualityControlProperty ()
**
**    Example of a set property handler for a filter global property set.
**    Use this as a template for adding support for filter global
**    properties.
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
NTSTATUS
CFilter::
SetVsbQualityControlProperty(
    IN PIRP         pIrp,
    IN PKSPROPERTY  pKSProperty,
    IN PKSPROPERTY_VSB_CTRL_S  pProperty
    )
{
    NTSTATUS        Status = STATUS_SUCCESS;
    CFilter *       pFilter;

    ASSERT( pIrp);
    ASSERT( pKSProperty);
    ASSERT( pProperty);

    //  Obtain a "this" pointer for the method.
    //
    //  Because this function is called directly from the property dispatch
    //  table, we must get our own pointer to the underlying object.
    //
    pFilter = FilterFromIRP( pIrp);
    ASSERT( pFilter);
    if (!pFilter)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    //  Set the property.
    //
    Status = (pFilter->GetDevice())->VsbQuality(pProperty->Value);

errExit:
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\mauitune\device.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    device.cpp

Abstract:

    Device driver core, initialization, etc.

--*/

#define KSDEBUG_INIT

#include "PhilTune.h"
#include "wdmdebug.h"

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA






extern "C"
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPathName
    )
/*++

Routine Description:

    Sets up the driver object.

Arguments:

    DriverObject -
        Driver object for this instance.

    RegistryPathName -
        Contains the registry path which was used to load this instance.

Return Values:

    Returns STATUS_SUCCESS if the driver was initialized.

--*/
{
    NTSTATUS    Status = STATUS_SUCCESS;

    _DbgPrintF(DEBUGLVL_VERBOSE,("DriverEntry"));

    // DEBUG_BREAK;

    Status = KsInitializeDriver( DriverObject,
                                 RegistryPathName,
                                 &DeviceDescriptor);

    // DEBUG_BREAK;

    return Status;
}

STDMETHODIMP_(NTSTATUS)
CDevice::
Create(
    IN PKSDEVICE Device
    )
{
    NTSTATUS    Status = STATUS_SUCCESS;
    CDevice *   pDevice = NULL;

    // DEBUG_BREAK;

    _DbgPrintF(DEBUGLVL_VERBOSE,("CDevice::Create"));

    ASSERT(Device);


    //  Allocate memory for the our device class.
    //
    pDevice = new(NonPagedPool,'IDsK') CDevice;
    if (pDevice)
    {
        Device->Context = pDevice;
    } else
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto errExit;
    }

    //  Point back to the KSDEVICE.
    //
    pDevice->m_pKSDevice = Device;
    pDevice->m_pDemod = NULL;
    pDevice->m_pTuner = NULL;


errExit:
    return Status;
}


STDMETHODIMP_(NTSTATUS)
CDevice::
Start(
    IN PKSDEVICE            pKSDevice,
    IN PIRP                 pIrp,
    IN PCM_RESOURCE_LIST    pTranslatedResourceList OPTIONAL,
    IN PCM_RESOURCE_LIST    pUntranslatedResourceList OPTIONAL
    )
{
    NTSTATUS        Status = STATUS_SUCCESS;
    CDevice *       pDevice;
    PDEVICE_OBJECT  pPhysicalDeviceObject;
    CI2CScript *    pI2CScript;
    CGpio *     pCGpio;


    // DEBUG_BREAK;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("CDevice::Start"));
    ASSERT( pKSDevice);

    // DEBUG_BREAK;

    pDevice = reinterpret_cast<CDevice *>(pKSDevice->Context);
    ASSERT(pDevice);

    pDevice->m_bHangCheckFlag = TRUE;
    pDevice->m_bQualityCheckActiveFlag = FALSE;
    pDevice->m_uiOutputMode = VSB_OUTPUT_MODE_NORMAL;

    // Delete any existing tuner and VSB objects
    if (pDevice->m_pTuner != NULL)
    {
        delete(pDevice->m_pTuner);
        pDevice->m_pTuner = NULL;
    }

    if (pDevice->m_pDemod != NULL)
    {
        // Create a demodulator object based on VSB chip type
        if((VSBCHIPTYPE)(pDevice->m_BoardInfo.uiVsbChipVersion >> 8) == VSB1)
        {
            CVSB1Demod *p_Demod = (CVSB1Demod *)(pDevice->m_pDemod);
            delete (p_Demod);
        }
        else
        {
            CVSB2Demod *p_Demod = (CVSB2Demod *)(pDevice->m_pDemod);
            delete (p_Demod);
        }
        pDevice->m_pDemod = NULL;
    }

    //  Get the Device capabilities, etc, from the registry.
    //
    Status = pDevice->InitFromRegistry();


    //  Get the GPIO interface on the parent device.
    //
    //  The GPIO interface is used by a child device to control specific
    //  pins on the parent PIO hardware.  The tuner minidriver uses
    //  PIO pins to control the mode of the tuner hardware and to reset
    //  the tuner hardware.
    //
    pCGpio = (CGpio *) new(NonPagedPool,'oipG')
                       CGpio( pKSDevice->PhysicalDeviceObject, &Status);
    if (Status != STATUS_SUCCESS)
    {
        _DbgPrintF( DEBUGLVL_ERROR, ("CGPIO creation failure."));
        goto errExit;
    }
    else
        _DbgPrintF( DEBUGLVL_VERBOSE, ("CGPIO created."));

    pDevice->m_pGpio = pCGpio;


    //  Get the I2C interface on the parent device.
    //
    //  The I2C interface is used by a child device to exchange data
    //  with a chip on the parents I2C bus.  The tuner minidriver uses
    //  the I2C bus to set a frequency and control code on the RF
    //  tuner device as well as to initialize the 8VSB decoder.
    //
    pI2CScript = (CI2CScript *) new(NonPagedPool,' C2I')
                                CI2CScript( pKSDevice->PhysicalDeviceObject,
                                            &Status
                                          );
    if (Status != STATUS_SUCCESS)
    {
        _DbgPrintF( DEBUGLVL_ERROR, ("I2CScript creation failure."));
        goto errExit;
    }
    else if (!pI2CScript)
    {
        Status = STATUS_NO_MEMORY;
        _DbgPrintF( DEBUGLVL_ERROR, ("I2CScript creation failure."));
        goto errExit;
    }
    else
        _DbgPrintF( DEBUGLVL_VERBOSE, ("I2CScript created."));

    pDevice->m_pI2CScript = pI2CScript;

    // Set the board and initialize all required data structures pertaining
    // to the board
    Status = pDevice->SetBoard(pDevice->m_BoardInfo.uiBoardID);
    if (Status != STATUS_SUCCESS)
    {
        goto errExit;
    }

    /*
    //  Initialize the tuner hardware.
    //
    Status = pDevice->Initialize();
    if (Status != STATUS_SUCCESS)
    {
        goto errExit;
    }
    */

    //  Create the the Tuner Filter Factory.  This factory is used to
    //  create instances of the tuner filter.
    //
    Status = BdaCreateFilterFactory( pKSDevice,
                                     &InitialTunerFilterDescriptor,
                                     &TunerBdaFilterTemplate
                                   );
    if (!NT_SUCCESS(Status))
    {
        goto errExit;
    }

errExit:
    return Status;
}



NTSTATUS
CDevice::
InitFromRegistry()
{
    NTSTATUS                        Status = STATUS_SUCCESS;
    HANDLE                          hRegistry;
    UNICODE_STRING                  KeyName;
    ULONG                           rgulValueInfo[10];
    ULONG                           ulcbValueInfo;
    PKEY_VALUE_PARTIAL_INFORMATION  pPartialValueInfo;
    PULONG                          pulData;


    ASSERT(KeGetCurrentIrql() <= PASSIVE_LEVEL);


    pPartialValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION) rgulValueInfo;
    pulData = (PULONG) pPartialValueInfo->Data;


    //  Open the registry key for this device.
    //
    Status = IoOpenDeviceRegistryKey( m_pKSDevice->PhysicalDeviceObject,
                                      PLUGPLAY_REGKEY_DRIVER,
                                      STANDARD_RIGHTS_ALL,
                                      &hRegistry
                                    );
    if (!NT_SUCCESS( Status))
    {
        _DbgPrintF( DEBUGLVL_ERROR, ("Can't open device registry key."));
        return Status;
    }


    //  Get the I2C address of the tuner chip.
    //
    RtlInitUnicodeString(&KeyName, L"TunerI2cAddress");
    Status = ZwQueryValueKey( hRegistry,
                              &KeyName,
                              KeyValuePartialInformation,
                              (PVOID) rgulValueInfo,
                              sizeof( rgulValueInfo),
                              &ulcbValueInfo
                            );
    if (!NT_SUCCESS( Status))
    {
        _DbgPrintF( DEBUGLVL_ERROR, ("Tuner I2C address is not in registry."));
        goto errExit;
    }

    ASSERT( ulcbValueInfo >= sizeof( KEY_VALUE_PARTIAL_INFORMATION));

    //  Make sure the date is of the correct type.
    //
    if (   (   (pPartialValueInfo->Type != REG_DWORD)
            && (pPartialValueInfo->Type != REG_BINARY))
        || (pPartialValueInfo->DataLength != sizeof( DWORD))
        || (*pulData >= 256)
       )
    {
        _DbgPrintF( DEBUGLVL_ERROR, ("Invalid tuner I2C address in registry."));
        goto errExit;
    }

    m_BoardInfo.ucTunerAddress = (UCHAR) (*pulData);


    //  Get the I2C address of the 8VSB demodulator chip.
    //


    //  Get the I2C address of the tuner chip.
    //
    RtlInitUnicodeString(&KeyName, L"8VsbI2cAddress");
    Status = ZwQueryValueKey( hRegistry,
                              &KeyName,
                              KeyValuePartialInformation,
                              (PVOID) rgulValueInfo,
                              sizeof( rgulValueInfo),
                              &ulcbValueInfo
                            );
    if (!NT_SUCCESS( Status))
    {
        _DbgPrintF( DEBUGLVL_ERROR, ("8VSB I2C address is not in registry."));
        goto errExit;
    }

    ASSERT( ulcbValueInfo >= sizeof( KEY_VALUE_PARTIAL_INFORMATION));

    //  Make sure the date is of the correct type.
    //
    if (   (   (pPartialValueInfo->Type != REG_DWORD)
            && (pPartialValueInfo->Type != REG_BINARY))
        || (pPartialValueInfo->DataLength != sizeof( DWORD))
        || (*pulData >= 256)
       )
    {
        _DbgPrintF( DEBUGLVL_ERROR, ("Invalid 8VSB I2C address in registry."));
        goto errExit;
    }

    m_BoardInfo.ucVsbAddress = (UCHAR) (*pulData);

#ifdef NEVER

    //  Get the I2C address of the parallel port.
    //
    RtlInitUnicodeString(&KeyName, L"ParallelPortI2cAddress");
    Status = ZwQueryValueKey( hRegistry,
                              &KeyName,
                              KeyValuePartialInformation,
                              (PVOID) rgulValueInfo,
                              sizeof( rgulValueInfo),
                              &ulcbValueInfo
                            );
    if (!NT_SUCCESS( Status))
    {
        _DbgPrintF( DEBUGLVL_ERROR, ("Parallel port I2C address is not in registry."));
        goto errExit;
    }

    ASSERT( ulcbValueInfo >= sizeof( KEY_VALUE_PARTIAL_INFORMATION));

    //  Make sure the date is of the correct type.
    //
    if (   (   (pPartialValueInfo->Type != REG_DWORD)
            && (pPartialValueInfo->Type != REG_BINARY))
        || (pPartialValueInfo->DataLength != sizeof( DWORD))
        || (*pulData >= 256)
       )
    {
        _DbgPrintF( DEBUGLVL_ERROR, ("Invalid parallel port I2C address in registry."));
        goto errExit;
    }

    m_BoardInfo.ucParallelPortI2cAddress = (UCHAR) (*pulData);

#endif // NEVER


    //  Get the tuner type identifier.
    //
    RtlInitUnicodeString(&KeyName, L"TunerType");
    Status = ZwQueryValueKey( hRegistry,
                              &KeyName,
                              KeyValuePartialInformation,
                              (PVOID) rgulValueInfo,
                              sizeof( rgulValueInfo),
                              &ulcbValueInfo
                            );
    if (!NT_SUCCESS( Status))
    {
        _DbgPrintF( DEBUGLVL_ERROR, ("Tuner type is not in registry."));
        goto errExit;
    }

    ASSERT( ulcbValueInfo >= sizeof( KEY_VALUE_PARTIAL_INFORMATION));

    //  Make sure the date is of the correct type.
    //
    if (pPartialValueInfo->Type != REG_SZ)
    {
        _DbgPrintF( DEBUGLVL_ERROR, ("Tuner type in registry is not REG_SZ."));
        goto errExit;
    }

    if((StringsEqual((PWCHAR)(pPartialValueInfo->Data), L"TD1536")))
    {
        m_BoardInfo.uiTunerID = TD1536;
        Status = STATUS_SUCCESS;
    }
    else
    {
        Status = STATUS_DEVICE_CONFIGURATION_ERROR ;
        _DbgPrintF( DEBUGLVL_ERROR, ("Unknown tuner type in registry."));
        goto errExit;
    }

    RtlInitUnicodeString(&KeyName, L"BoardType");
    Status = ZwQueryValueKey( hRegistry,
                              &KeyName,
                              KeyValuePartialInformation,
                              (PVOID) rgulValueInfo,
                              sizeof( rgulValueInfo),
                              &ulcbValueInfo
                            );
    if (!NT_SUCCESS( Status))
    {
        _DbgPrintF( DEBUGLVL_ERROR, ("Board type is not in registry."));
        goto errExit;
    }

    ASSERT( ulcbValueInfo >= sizeof( KEY_VALUE_PARTIAL_INFORMATION));

  //
    if (   (   (pPartialValueInfo->Type != REG_DWORD)
            && (pPartialValueInfo->Type != REG_BINARY))
        || (pPartialValueInfo->DataLength != sizeof( DWORD))
       )
    {
        _DbgPrintF( DEBUGLVL_ERROR, ("Invalid Board type in registry."));
        goto errExit;
    }

    m_BoardInfo.uiBoardID = (UINT)(*pulData);

    _DbgPrintF( DEBUGLVL_VERBOSE, ("CDevice: Board ID = %d", m_BoardInfo.uiBoardID));



errExit:
    ZwClose( hRegistry);

    return Status;
}


NTSTATUS
CDevice::
GetRegistryULONG( PWCHAR    pwcKeyName,
                  PULONG    pulValue
                )
{
    NTSTATUS                        Status = STATUS_SUCCESS;
    HANDLE                          hRegistry;
    UNICODE_STRING                  KeyName;
    ULONG                           rgulValueInfo[10];
    ULONG                           ulcbValueInfo;
    PKEY_VALUE_PARTIAL_INFORMATION  pPartialValueInfo;
    PULONG                          pulData;


    ASSERT(KeGetCurrentIrql() <= PASSIVE_LEVEL);

    pPartialValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION) rgulValueInfo;
    pulData = (PULONG) pPartialValueInfo->Data;

    //  Open the registry key for this device.
    //
    Status = IoOpenDeviceRegistryKey( m_pKSDevice->PhysicalDeviceObject,
                                      PLUGPLAY_REGKEY_DRIVER,
                                      STANDARD_RIGHTS_ALL,
                                      &hRegistry
                                    );
    if (!NT_SUCCESS( Status))
    {
        _DbgPrintF( DEBUGLVL_ERROR, ("Can't open device registry key."));
        goto errExit;
    }


    //  Get the registry entry.
    //
    RtlInitUnicodeString(&KeyName, pwcKeyName);
    Status = ZwQueryValueKey( hRegistry,
                              &KeyName,
                              KeyValuePartialInformation,
                              (PVOID) rgulValueInfo,
                              sizeof( rgulValueInfo),
                              &ulcbValueInfo
                            );
    if (!NT_SUCCESS( Status))
    {
        _DbgPrintF( DEBUGLVL_ERROR, ("Key is not in registry."));
        ZwClose( hRegistry);
        goto errExit;
    }

    ASSERT( ulcbValueInfo >= sizeof( KEY_VALUE_PARTIAL_INFORMATION));

    if (   (   (pPartialValueInfo->Type != REG_DWORD)
            && (pPartialValueInfo->Type != REG_BINARY))
        || (pPartialValueInfo->DataLength != sizeof( DWORD))
       )
    {
        _DbgPrintF( DEBUGLVL_ERROR, ("Invalid key value in registry."));
        ZwClose( hRegistry);
        goto errExit;
    }

    *pulValue = *pulData;

    ZwClose( hRegistry);

errExit:
    return Status;
}


NTSTATUS
CDevice::
AcquireResources(
    PPHILIPS_TUNER_RESOURCE pNewTunerResource,
    PULONG                  pulAquiredResourceID
    )
{
    NTSTATUS    Status = STATUS_SUCCESS;
    TunerStatusType tunerStatus;
    VsbStatusType  vsbStatus;

    //$Review - Add resource managment code here.
    //
    //Status = STATUS_RESOURCE_NOT_OWNED;

    //  Only ATSC mode is supported for now.  Just check that
    //  ATSC mode is requested.
    //
    if (!IsEqualGUID( &pNewTunerResource->guidDemodulatorNode,
                      &KSNODE_BDA_8VSB_DEMODULATOR)
       )
    {
        Status = STATUS_NOT_IMPLEMENTED;
        goto errExit;
    }

    //  If we haven't yet set ATSC mode, then go ahead and set it.
    //
    if (!IsEqualGUID( &m_CurTunerResource.guidDemodulatorNode,
                      &KSNODE_BDA_8VSB_DEMODULATOR)
       )
    {
        Status = SetTunerMode(KSPROPERTY_TUNER_MODE_ATSC);
        if (!NT_SUCCESS( Status))
        {
            goto errExit;
        }
        m_CurTunerResource.guidDemodulatorNode
            = KSNODE_BDA_8VSB_DEMODULATOR;
    }

    //  Set a new tuner frequency if it is different.
    //
    if (pNewTunerResource->ulhzCarrierFrequency != m_CurTunerResource.ulhzCarrierFrequency)
    {
        m_CurTunerResource.ulhzCarrierFrequency
            = pNewTunerResource->ulhzCarrierFrequency;
        SetTunerFrequency( &m_CurTunerResource.ulhzCarrierFrequency);
    }

    //  Get the Tuner and VSB status
    //
    GetTunerStatus(&tunerStatus);
    m_pDemod->GetStatus(&vsbStatus);


errExit:
    return Status;
}


NTSTATUS
CDevice::
ReleaseResources(
    ULONG                   ulAquiredResourceID
    )
{
    NTSTATUS    Status = STATUS_SUCCESS;

    //$REVIEW - Put Resource management code here.

    return Status;
}


/*
 * SetBoard()
 */
NTSTATUS CDevice::SetBoard(UINT uiBoardID)
{
    NTSTATUS     Status = STATUS_SUCCESS;

    if(uiBoardID == BOARD_CONEY)
    {
        // if IF type = 0, then the IF is not MPOC
        // else IF is MPOC
        m_BoardInfo.uiBoardID = uiBoardID;
        m_BoardInfo.uiIFStage = IF_OTHER;
        m_BoardInfo.uiVsbChipVersion = VSB1 << 8;
        m_BoardInfo.ulSupportedModes =
            KSPROPERTY_TUNER_MODE_TV | KSPROPERTY_TUNER_MODE_ATSC;
        m_BoardInfo.ulNumSupportedModes = 2;
//      m_ulNumberOfPins = 4;
        _DbgPrintF( DEBUGLVL_VERBOSE,("CDevice::Loading Coney Drivers\n"));

    }
    else if(uiBoardID == BOARD_CATALINA)
    {
        // if IF type = 0, then the IF is not MPOC
        // else IF is MPOC
        m_BoardInfo.uiBoardID = uiBoardID;
        m_BoardInfo.uiIFStage = IF_MPOC;
        m_BoardInfo.uiVsbChipVersion = VSB2 << 8;
        m_BoardInfo.ulSupportedModes =
            KSPROPERTY_TUNER_MODE_TV | KSPROPERTY_TUNER_MODE_ATSC;
        m_BoardInfo.ulNumSupportedModes = 2;
//      m_ulNumberOfPins = 4;
        _DbgPrintF( DEBUGLVL_VERBOSE,("CDevice::Loading Catalina Drivers\n"));

    }
    else if(uiBoardID == BOARD_CORONADO)
    {
        // if IF type = 0, then the IF is not MPOC
        // else IF is MPOC
        m_BoardInfo.uiBoardID = uiBoardID;
        m_BoardInfo.uiIFStage = IF_OTHER;
        m_BoardInfo.uiVsbChipVersion = VSB1 << 8;
        m_BoardInfo.ulSupportedModes =
            KSPROPERTY_TUNER_MODE_TV | KSPROPERTY_TUNER_MODE_ATSC;
        m_BoardInfo.ulNumSupportedModes = 2;
//      m_ulNumberOfPins = 4;
        _DbgPrintF( DEBUGLVL_VERBOSE,("CDevice::Loading Coronado Drivers\n"));
    }
    else if(uiBoardID == BOARD_CES)
    {
        // if IF type = 0, then the IF is not MPOC
        // else IF is MPOC
        m_BoardInfo.uiBoardID = uiBoardID;
        m_BoardInfo.uiIFStage = IF_OTHER;
        m_BoardInfo.uiVsbChipVersion = VSB1 << 8;
        m_BoardInfo.ulSupportedModes = KSPROPERTY_TUNER_MODE_ATSC;
        m_BoardInfo.ulNumSupportedModes = 1;
//      m_ulNumberOfPins = 4;
        _DbgPrintF( DEBUGLVL_VERBOSE,("CDevice::Loading CES Drivers\n"));
    }
    else if(uiBoardID == BOARD_CORFU)
    {
        // if IF type = 0, then the IF is not MPOC
        // else IF is MPOC
        m_BoardInfo.uiBoardID = uiBoardID;
        m_BoardInfo.uiIFStage = IF_OTHER;
        m_BoardInfo.uiVsbChipVersion = VSB2 << 8;
        m_BoardInfo.ulSupportedModes =
            KSPROPERTY_TUNER_MODE_ATSC;
        m_BoardInfo.ulNumSupportedModes = 1;
//      m_ulNumberOfPins = 4;
        _DbgPrintF( DEBUGLVL_VERBOSE,("CDevice::Loading Corfu Drivers\n"));

    }
    else
    {
        _DbgPrintF( DEBUGLVL_ERROR,("CDevice::Invalid Board ID\n"));
        Status = STATUS_DEVICE_CONFIGURATION_ERROR;
        goto errexit;
    }

    // Create a tuner object
//      m_pTuner = new CTuner(&m_I2CScript);
    m_pTuner = new(NonPagedPool,'Tune') CTuner(m_pI2CScript, &m_BoardInfo, &Status);
    if (!NT_SUCCESS( Status))
    {
        _DbgPrintF( DEBUGLVL_ERROR,("CDevice::Could not create Tuner Object\n"));
        goto errexit;
    }
    if (!m_pTuner)
    {
        Status = STATUS_NO_MEMORY;
        goto errexit;
    }

    // Create a demodulator object based on VSB chip type
    if((VSBCHIPTYPE)(m_BoardInfo.uiVsbChipVersion >> 8) == VSB1)
//          m_pDemod = (CVSBDemod *)(new CVSB1Demod(&m_I2CScript));
        m_pDemod = (CVSBDemod *)(new(NonPagedPool,'VSB1') CVSB1Demod(m_pI2CScript, &m_BoardInfo, &Status));
    else
//          m_pDemod = (CVSBDemod *)(new CVSB2Demod(&m_I2CScript));
        m_pDemod = (CVSBDemod *)(new(NonPagedPool,'VSB2')CVSB2Demod(m_pI2CScript, &m_BoardInfo, &Status));


    if (!NT_SUCCESS( Status))
    {
        _DbgPrintF( DEBUGLVL_ERROR,("CDevice::Could not create VSB Object\n"));
        goto errexit;
    }

#if 0
        // Set tuner capabilities (RO properties) based upon the TunerId
        if(!m_pTuner->SetCapabilities(&m_BoardInfo))
        {
            // there is unsupported hardware was found
            Status = STATUS_ADAPTER_HARDWARE_ERROR;
        goto errexit;
        }
#endif

    // If board initialize fails, don't return FALSE as this could affect
    // the non-PnP devices such as PP boards from loading. We would like these
    // Non PnP drivers to load and when the devices are attached to the PP,
    // we would like it to function as a pseudo PnP device.
    // Initialize the board
    BoardInitialize();

    m_bFirstEntry = TRUE;
    _DbgPrintF( DEBUGLVL_VERBOSE,("CDevice:SetBoard() ok\n"));

errexit:
    return Status;

}


/*
 * BoardInitialize()
 * Purpose: Initialize the board
 *
 * Inputs :
 * Outputs: BOOL - FALSE if board initialization fails, else TRUE
 * Author : MM
 */
NTSTATUS CDevice::BoardInitialize()
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG ulhzFrequency = 373250000;

    if(m_BoardInfo.uiIFStage == IF_MPOC)
    {
        // Get MPOC interface
        //GetIFInterface();
        Status = MpocInit();
        if (!NT_SUCCESS( Status))
        {
            _DbgPrintF( DEBUGLVL_ERROR,("CDevice::MPOC Initialization failure\n"));
            goto errexit;
        }
        Status = GetMpocVersion(&m_BoardInfo.uiMpocVersion);
        if (!NT_SUCCESS( Status))
        {
            _DbgPrintF( DEBUGLVL_ERROR,("CDevice::MPOC Version failure\n"));
            goto errexit;
        }
    }
    // Initialize mode register
    Status = ModeInit();
    if (!NT_SUCCESS( Status))
    {
        _DbgPrintF( DEBUGLVL_ERROR,("CDevice::Mode Initialization failure\n"));
        goto errexit;
    }

    // DO a VSB hardware reset
    Status = VsbReset(HARDWARE_RESET);
    if (!NT_SUCCESS( Status))
    {
        _DbgPrintF( DEBUGLVL_ERROR,("CDevice::Hardware reset failure\n"));
        goto errexit;
    }

    // DO a VSB software reset
    Status = VsbReset(VSB_INITIAL_RESET);
    if (!NT_SUCCESS( Status))
    {
        _DbgPrintF( DEBUGLVL_ERROR,("CDevice::Software reset failure\n"));
        goto errexit;
    }

    // Set TV System to NTSC
    Status = SetTunerMode(KSPROPERTY_TUNER_MODE_ATSC);
    if (!NT_SUCCESS( Status))
    {
        _DbgPrintF( DEBUGLVL_ERROR,("CDevice::TV System change failure\n"));
        goto errexit;
    }

    //  Get the initial tuner frequency from the registry.
    //  Set it to 37325000 if registry value is absent.
    //
    // ulhzFrequency = 615250000;
    // ulhzFrequency = 531250000;
    // ulhzFrequency = 307250000;
    //
    Status = GetRegistryULONG( L"InitialFrequency", &ulhzFrequency);

    //  Set the intial frequency on the tuner.
    //
    Status = SetTunerFrequency( &ulhzFrequency);
    if (!NT_SUCCESS( Status))
    {
        _DbgPrintF( DEBUGLVL_ERROR,("CDevice::Channel change failure\n"));
        goto errexit;
    }
    if((m_BoardInfo.uiBoardID == BOARD_CATALINA) || (m_BoardInfo.uiBoardID == BOARD_CONEY))
    {

#define BTSC_CONTROL_REGISTER   0xB6

        //Mini: Adding Initialization of BTSC decoder here so that it functions
        // 2/17/2000
        // BTSC decoder settings:
        // AVL Attack time = 420ohm
        // Normal load current
        // Automatic Volume control ON
        // No Mute
        // Stereo bit 0
        UCHAR ucDataWr = 0x4;
        m_pI2CScript->WriteSeq(BTSC_CONTROL_REGISTER, &ucDataWr, 1);
    }

errexit:
    return Status;
}




UCHAR ConeyModeInitArray[1]=
{
    0x3F,
};

UCHAR CatalinaModeInitArray[1]=
{
    0x02,
};




/*
* ModeInit()
* Input
* Output :  TRUE - mode initialization succeeds
*           FALSE - if there is an I2C error & mode initialization fails
* Description: Initialize mode register
*/
NTSTATUS CDevice::ModeInit()
{
    NTSTATUS Status = STATUS_SUCCESS;

    _DbgPrintF( DEBUGLVL_VERBOSE,("CDevice::ModeInit(): Inside\n"));

    if(m_BoardInfo.uiBoardID == BOARD_CONEY)
    {
        m_ucModeInit = ConeyModeInitArray[0];
        if(!m_pI2CScript->WriteSeq(CONEY_I2C_PARALLEL_PORT, ConeyModeInitArray,
            sizeof (ConeyModeInitArray)))
            Status = STATUS_ADAPTER_HARDWARE_ERROR;
    }
    else if (m_BoardInfo.uiBoardID == BOARD_CATALINA)
    {
        m_ucModeInit = CatalinaModeInitArray[0];
        // CATALINA specific initializations
        if(!m_pI2CScript->WriteSeq(CATALINA_MISC_CONTROL_REGISTER,
            CatalinaModeInitArray, sizeof (CatalinaModeInitArray)))
            Status = STATUS_ADAPTER_HARDWARE_ERROR;
    }
    else
    {
    }

    if (!NT_SUCCESS( Status))
    {
        _DbgPrintF( DEBUGLVL_ERROR,("CDevice: Demodulator Mode Init FAILED !!! ------------ \n"));
    }
    else
    {
        _DbgPrintF( DEBUGLVL_TERSE,("CDevice: Demodulator Mode Init PASSED !!! ------------ \n"));
    }
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\mauitune\filter.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    filter.cpp

Abstract:

    Filter core, initialization, etc.

--*/

#include "PhilTune.h"

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA

enum tuner_errors { NO_ERRORS_DEFINED};

typedef struct _BDA_TUNER_STATISTICS BDA_TUNER_STATISTICS;

struct _BDA_TUNER_STATISTICS
{
    ULONG       ulPlaceHolder;
};


STDMETHODIMP_(NTSTATUS)
CFilter::Create(
    IN OUT PKSFILTER pKSFilter,
    IN PIRP Irp
    )
{
    NTSTATUS    Status = STATUS_SUCCESS;
    ULONG       ulPinId;
    PKSDEVICE   pKSDevice = NULL;
    CDevice *   pDevice = NULL;

    _DbgPrintF(DEBUGLVL_VERBOSE,("FilterCreate"));

    ASSERT(pKSFilter);
    ASSERT(Irp);


    //  Create our filter object.
    //
    CFilter* pFilter = new(NonPagedPool,'IFsK') CFilter;
    if (!pFilter)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto errExit;
    }
    pKSFilter->Context = pFilter;

    //  Point to the KS device object for this filter.
    //
    pKSDevice = KsFilterGetDevice( pKSFilter);
    ASSERT( pKSDevice);
    if (!pKSDevice)
    {
        Status = STATUS_DEVICE_NOT_CONNECTED;
        goto errExit;
    }

    //  Get our device object.
    //
    pDevice = reinterpret_cast<CDevice *>(pKSDevice->Context);
    ASSERT( pDevice);
    if (!pDevice)
    {
        Status = STATUS_DEVICE_NOT_CONNECTED;
        goto errExit;
    }

    pFilter->m_pDevice = pDevice;

    //  Initialize member variables.
    //
    pFilter->m_ulcPins = 0;
    pFilter->m_ulExampleProperty = 0;
    pFilter->m_KsState = KSSTATE_STOP;
    pFilter->m_BdaChangeState = BDA_CHANGES_COMPLETE;
    pFilter->m_ulCurResourceID = 0;
    pFilter->m_ulNewResourceID = 0;

    //  Set the initial resource set that this filter will allocate on
    //  transition to acquire state.
    //
    pFilter->m_CurTunerResource.guidDemodulatorNode
        = KSNODE_BDA_8VSB_DEMODULATOR;
    pFilter->m_CurTunerResource.ulhzCarrierFrequency = 529250000;
    pDevice->GetRegistryULONG(
                 L"InitialFrequency",
                 &pFilter->m_CurTunerResource.ulhzCarrierFrequency
                 );
    pFilter->m_NewTunerResource= pFilter->m_CurTunerResource;


    //  Initialize this filter instance with the default template
    //  topology.
    //
    Status = BdaInitFilter( pKSFilter, &TunerBdaFilterTemplate);
    if (NT_ERROR( Status))
    {
        goto errExit;
    }

#ifdef NO_NETWORK_PROVIDER

    //  Create the transport output pin
    //
    Status = BdaCreatePin( pKSFilter, 1, &ulPinId);
    if (!NT_SUCCESS(Status))
    {
        goto errExit;
    }

    //  Create the topology between the antenna and transport pin.
    //
    //$REVIEW - Add topology for filters with no network provider.
    //

#endif // NO_NETWORK_PROVIDER

exit:
    return Status;

errExit:
    if (pFilter)
    {
        delete pFilter;
    }
    pKSFilter->Context = NULL;

    goto exit;
}


STDMETHODIMP_(NTSTATUS)
CFilter::FilterClose(
    IN OUT PKSFILTER pKSFilter,
    IN PIRP pIrp
    )
{
    _DbgPrintF(DEBUGLVL_VERBOSE,("FilterClose"));

    ASSERT( pKSFilter);
    ASSERT( pIrp);

    CFilter* filter = reinterpret_cast<CFilter*>(pKSFilter->Context);
    ASSERT(filter);

    delete filter;

    BdaUninitFilter( pKSFilter);

    return STATUS_SUCCESS;
}


BDA_CHANGE_STATE
CFilter::ChangeState()
{
    //  Add Resource Management code
    //

    return BDA_CHANGES_COMPLETE;
}



//
//  Device Specific Filter Properties
//



NTSTATUS
PinSetDeviceState(
    IN PKSPIN Pin,
    IN KSSTATE ToState,
    IN KSSTATE FromState
    )
{
    return STATUS_SUCCESS;
}



NTSTATUS
PinNullProcess(
    IN PKSPIN Pin
    )
{
    return STATUS_SUCCESS;
}


/*
** FilterStartChanges ()
**
**    Puts the filter into change state.  All changes to BDA topology
**    and properties changed after this will be in effect only after
**    CommitChanges.
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
NTSTATUS
CFilter::
StartChanges(
    IN PIRP         pIrp,
    IN PKSMETHOD    pKSMethod,
    OPTIONAL PVOID  pvIgnored
    )
{
    NTSTATUS        Status = STATUS_SUCCESS;
    CFilter *       pFilter;

    ASSERT( pIrp);
    ASSERT( pKSMethod);

    //  Obtain a "this" pointer for the method.
    //
    //  Because this function is called directly from the property dispatch
    //  table, we must get our own pointer to the underlying object.
    //
    pFilter = FilterFromIRP( pIrp);
    ASSERT( pFilter);
    if (!pFilter)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    //  Reset any pending BDA topolgoy changes.
    //
    Status = BdaStartChanges( pIrp);
    if (!NT_SUCCESS( Status))
    {
        goto errExit;
    }

    //  Reset any pending resource changes.
    //
    pFilter->m_NewTunerResource = pFilter->m_CurTunerResource;
    pFilter->m_BdaChangeState = BDA_CHANGES_COMPLETE;

errExit:
    return Status;
}


/*
** CheckChanges ()
**
**    Checks the changes to BDA interfaces that have occured since the
**    last StartChanges.  Returns the result that would have occurred if
**    CommitChanges had been called.
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
NTSTATUS
CFilter::
CheckChanges(
    IN PIRP         pIrp,
    IN PKSMETHOD    pKSMethod,
    OPTIONAL PVOID  pvIgnored
    )
{
    NTSTATUS            Status = STATUS_SUCCESS;
    CFilter *           pFilter;
    BDA_CHANGE_STATE    topologyChangeState;

    ASSERT( pIrp);
    ASSERT( pKSMethod);

    //  Obtain a "this" pointer for the method.
    //
    //  Because this function is called directly from the property dispatch
    //  table, we must get our own pointer to the underlying object.
    //
    pFilter = FilterFromIRP( pIrp);
    ASSERT( pFilter);
    if (!pFilter)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    //  Check if the BDA topology changes are good.
    //
    Status = BdaCheckChanges( pIrp);
    if (!NT_SUCCESS( Status))
    {
        goto errExit;
    }

    //  Validate the new resource list here.
    //  In this driver the new resource list is always valid.
    //

#ifdef RESOURCE_MANAGEMENT
    //  Reserve resources from the device.
    //
    Status = m_pDevice->ReserveReplacementResources(
                            &m_CurTunerResource
                            &m_NewTunerResource
                            );
    if (Status == STATUS_PENDING)
    {
        //  Status pending means that the resource is valid, but not
        //  currently available.
        //
        Status = STATUS_SUCCESS;
    }
#endif // RESOURCE_MANAGEMENT

errExit:
    return Status;
}


/*
** CommitChanges ()
**
**    Checks and commits the changes to BDA interfaces that have occured since the
**    last StartChanges.
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
NTSTATUS
CFilter::
CommitChanges(
    IN PIRP         pIrp,
    IN PKSMETHOD    pKSMethod,
    OPTIONAL PVOID  pvIgnored
    )
{
    NTSTATUS        Status = STATUS_SUCCESS;
    CFilter *       pFilter;

    ASSERT( pIrp);
    ASSERT( pKSMethod);
    ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL);

    //  Obtain a "this" pointer for the method.
    //
    //  Because this function is called directly from the property dispatch
    //  table, we must get our own pointer to the underlying object.
    //
    pFilter = FilterFromIRP( pIrp);
    ASSERT( pFilter);
    if (!pFilter)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }


    //  Commit any BDA topology changes.
    //
    Status = BdaCommitChanges( pIrp);

    if (!NT_SUCCESS( Status))
    {
        goto errExit;
    }

    //  Mark the changes as having been made.
    //
    pFilter->m_CurTunerResource = pFilter->m_NewTunerResource;
    pFilter->m_BdaChangeState = BDA_CHANGES_COMPLETE;

    if (pFilter->m_KsState != KSSTATE_STOP)
    {
        //  Commit the resources on the underlying device
        //
        Status = pFilter->AcquireResources( );
    }

errExit:
    return Status;
}


/*
** AcquireResources ()
**
**    Acquires Resources from the underlying device.
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
NTSTATUS
CFilter::
AcquireResources(
    )
{
    NTSTATUS        Status = STATUS_SUCCESS;

    if (m_ulCurResourceID)
    {
        m_pDevice->ReleaseResources(
                       m_ulCurResourceID
                       );
        m_ulCurResourceID = 0;
    }

    //  Commit the resources on the underlying device
    //
    Status = m_pDevice->AcquireResources(
                            &m_CurTunerResource,
                            &m_ulCurResourceID
                            );
    return Status;
}


/*
** ReleaseResources ()
**
**    Acquires Resources from the underlying device.
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
NTSTATUS
CFilter::
ReleaseResources(
    )
{
    NTSTATUS        Status = STATUS_SUCCESS;

    //  Release the resources on the underlying device
    //
    if (m_ulCurResourceID)
    {
        Status = m_pDevice->ReleaseResources(
                                m_ulCurResourceID
                                );
        m_ulCurResourceID = 0;
    }

    return Status;
}


/*
** GetChangeState ()
**
**    Returns the current BDA change state
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
NTSTATUS
CFilter::
GetChangeState(
    IN PIRP         pIrp,
    IN PKSMETHOD    pKSMethod,
    OUT PULONG      pulChangeState
    )
{
    NTSTATUS            Status = STATUS_SUCCESS;
    CFilter *           pFilter;
    BDA_CHANGE_STATE    topologyChangeState;

    ASSERT( pIrp);
    ASSERT( pKSMethod);

    //  Obtain a "this" pointer for the method.
    //
    //  Because this function is called directly from the property dispatch
    //  table, we must get our own pointer to the underlying object.
    //
    pFilter = FilterFromIRP( pIrp);
    ASSERT( pFilter);
    if (!pFilter)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }


    //  See if any BDA topology changes are pending
    //
    Status = BdaGetChangeState( pIrp, &topologyChangeState);
    if (!NT_SUCCESS( Status))
    {
        goto errExit;
    }


    //  Figure out if there are changes pending.
    //
    if (   (topologyChangeState == BDA_CHANGES_PENDING)
        || (pFilter->m_BdaChangeState == BDA_CHANGES_PENDING)
       )
    {
        *pulChangeState = BDA_CHANGES_PENDING;
    }
    else
    {
        *pulChangeState = BDA_CHANGES_COMPLETE;
    }


errExit:
    return Status;
}


/*
** CreateTopology ()
**
**    Keeps track of the topology association between input and output pins
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
NTSTATUS
CFilter::
CreateTopology(
    IN PIRP         pIrp,
    IN PKSMETHOD    pKSMethod,
    PVOID           pvIgnored
    )
{
    NTSTATUS            Status = STATUS_SUCCESS;
    CFilter *           pFilter;
    ULONG               ulPinType;
    PKSFILTER           pKSFilter;

    ASSERT( pIrp);
    ASSERT( pKSMethod);

    //  Obtain a "this" pointer for the method.
    //
    //  Because this function is called directly from the property dispatch
    //  table, we must get our own pointer to the underlying object.
    //
    pFilter = FilterFromIRP( pIrp);
    ASSERT( pFilter);
    if (!pFilter)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    //  Let the BDA topology DLL create the standard topology.
    //  It will also validate the method, instance count, etc.
    //
    Status = BdaMethodCreateTopology( pIrp, pKSMethod, pvIgnored);
    if (Status != STATUS_SUCCESS)
    {
        goto errExit;
    }

    //  This is where our filter can keep track of associated pins.
    //




errExit:
    return Status;
}


/*
** ChangeDemodulator ()
**
**    Sets up a change to a different demodulator.
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
STDMETHODIMP_(NTSTATUS)
CFilter::
ChangeDemodulator(
    IN const GUID *       pguidNetworkType
    )
{
    NTSTATUS        Status = STATUS_SUCCESS;

    //  Make sure the demodulator is supported.
    //
    if (IsEqualGUID( pguidNetworkType, &KSNODE_BDA_8VSB_DEMODULATOR))
    {
        m_NewTunerResource.guidDemodulatorNode
            = KSNODE_BDA_8VSB_DEMODULATOR;
        m_BdaChangeState = BDA_CHANGES_PENDING;
    }
    else
    {
        Status = STATUS_NOT_SUPPORTED;
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\mauitune\gpio.h ===
//==========================================================================;
//
//  Gpio.H
//  Gpio Class declaration
//  Based on code from ATI Technologies Inc.  Copyright (c) 1996 - 1998
//
//
//==========================================================================;

#ifndef _GPIO_H_

#define _GPIO_H_

#include "i2cgpio.h"

#define GPIO_TIMELIMIT_OPENPROVIDER     50000000    // 5 seconds in 100 nsec.
#define GPIO_TUNER_MODE_SELECT_PIN      0x8
#define GPIO_VSB_RESET_PIN              0x1
#define GPIO_TUNER_PINS                 (GPIO_TUNER_MODE_SELECT_PIN | GPIO_VSB_RESET_PIN)

#define GPIO_TUNER_MODE_ATSC            GPIO_TUNER_MODE_SELECT_PIN
#define GPIO_TUNER_MODE_NTSC            0
#define GPIO_VSB_ON                     GPIO_VSB_RESET_PIN
#define GPIO_VSB_OFF                    0


#define	GPIO_VSB_RESET						0x0
#define	GPIO_VSB_SET						0x1

// GPIO class object .	
// Provides functionality to obtain a GPIO interface, Lock GPIO for
// exclusive use, querying the GPIO provider, write/read GPIO and
// general access to GPIO
class CGpio
{
public:
    // constructor
    CGpio       ( PDEVICE_OBJECT pDeviceObject, NTSTATUS * pStatus);
//  PVOID operator new      ( UINT size_t, PVOID pAllocation);

// Attributes
private:

    // GPIO Provider related
    GPIOINTERFACE   m_gpioProviderInterface;
    PDEVICE_OBJECT  m_pdoDriver;
    DWORD           m_dwGPIOAccessKey;

// Implementation
public:

    BOOL            InitializeAttachGPIOProvider( GPIOINTERFACE * pGPIOInterface, PDEVICE_OBJECT pDeviceObject);
    BOOL            LocateAttachGPIOProvider    ( GPIOINTERFACE * pGPIOInterface, PDEVICE_OBJECT pDeviceObject, int nIrpMajorFunction);

    BOOL            QueryGPIOProvider           ( PGPIOControl pgpioAccessBlock);
    BOOL            LockGPIOProviderEx          ( PGPIOControl pgpioAccessBlock);
    BOOL            ReleaseGPIOProvider         ( PGPIOControl pgpioAccessBlock);
    BOOL            AccessGPIOProvider          ( PGPIOControl pgpioAccessBlock);
    BOOL            WriteGPIO                   ( PGPIOControl pgpioAccessBlock);
    BOOL            ReadGPIO                    ( PGPIOControl pgpioAccessBlock);
    //BOOL          AccessGPIOProvider          ( PDEVICE_OBJECT pdoClient, PGPIOControl pgpioAccessBlock);
    //BOOL          WriteGPIO                   ( PDEVICE_OBJECT pdoClient, PGPIOControl pgpioAccessBlock);
    //BOOL          ReadGPIO                    ( PDEVICE_OBJECT pdoClient, PGPIOControl pgpioAccessBlock);
	BOOL			WriteGPIO					( UCHAR *p_uchPin, UCHAR *p_uchValue);
	BOOL			ReadGPIO					( UCHAR *p_uchPin, UCHAR *p_uchValue);

};


#endif  // _GPIO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\mauitune\gpio.cpp ===
//==========================================================================;
//
//
//  Gpio.cpp
//  Gpio Class implementation
//  Based on code from ATI Technologies Inc.  Copyright (c) 1996 - 1997
//
//  ATIConfg.CPP
//  WDM MiniDrivers development.
//      ATIHwConfiguration class implementation.
//  Copyright (c) 1996 - 1997  ATI Technologies Inc.  All Rights Reserved.
//
//==========================================================================;

extern "C"
{
#include <wdm.h>
}

#include <unknown.h>
#include "ks.h"
#include "ksmedia.h"
#include <ksdebug.h>
#include "gpio.h"
#include "wdmdebug.h"

//$REVIEW - Let's find a way to get the proper module name into this
//
#define MODULENAME           "PhilTune"
#define MODULENAMEUNICODE   L"PhilTune"

#define STR_MODULENAME      MODULENAME

#define ENSURE    do
#define END_ENSURE  while( FALSE)
#define FAIL    break




/*^^*
 *      CGpio()
 * Purpose  : CGpio Class constructor
 *              Determines I2CExpander address and all possible hardware IDs and addresses
 *
 * Inputs   : PDEVICE_OBJECT pDeviceObject  : pointer to the creator DeviceObject
 *            CI2CScript * pCScript         : pointer to the I2CScript class object
 *            PUINT puiError                : pointer to return Error code
 *
 * Outputs  : none
 * Author   : IKLEBANOV
 *^^*/
CGpio::CGpio( PDEVICE_OBJECT pDeviceObject, NTSTATUS * pStatus)
{
    *pStatus = STATUS_SUCCESS;

    ENSURE
    {
        m_gpioProviderInterface.gpioOpen = NULL;
        m_gpioProviderInterface.gpioAccess = NULL;
        m_pdoDriver = NULL;


        if( InitializeAttachGPIOProvider( &m_gpioProviderInterface, pDeviceObject))
        {
            //  There was no error to get GPIOInterface from the MiniVDD
            //
            m_pdoDriver = pDeviceObject;
        }
        else
        {
            * pStatus = STATUS_NOINTERFACE;
            FAIL;
        }

    } END_ENSURE;

    _DbgPrintF( DEBUGLVL_VERBOSE, ( "CGPio:CGpio() Status=%x\n", * pStatus));
}




/*^^*
 *      GPIOIoSynchCompletionRoutine()
 * Purpose  : This routine is for use with synchronous IRP processing.
 *          All it does is signal an event, so the driver knows it and can continue.
 *
 * Inputs   :   PDEVICE_OBJECT DriverObject : Pointer to driver object created by system
 *              PIRP pIrp                   : Irp that just completed
 *              PVOID Event                 : Event we'll signal to say Irp is done
 *
 * Outputs  : none
 * Author   : IKLEBANOV
 *^^*/
extern "C"
NTSTATUS GPIOIoSynchCompletionRoutine( IN PDEVICE_OBJECT pDeviceObject,
                                       IN PIRP pIrp,
                                       IN PVOID Event)
{

    KeSetEvent(( PKEVENT)Event, 0, FALSE);
    return( STATUS_MORE_PROCESSING_REQUIRED);
}



/*^^*
 *      InitializeAttachGPIOProvider()
 * Purpose  : determines the pointer to the parent GPIO Provider interface
 *              This function will be called at Low priority
 *
 * Inputs   :   GPIOINTERFACE * pGPIOInterface  : pointer to the Interface to be filled in
 *              PDEVICE_OBJECT pDeviceObject    : MiniDriver device object, which is a child of GPIO Master
 *
 * Outputs  : BOOL  - returns TRUE, if the interface was found
 * Author   : IKLEBANOV
 *^^*/
BOOL CGpio::InitializeAttachGPIOProvider( GPIOINTERFACE * pGPIOInterface, PDEVICE_OBJECT pDeviceObject)
{
    BOOL bResult;

    // Find the GPIO provider
    bResult = LocateAttachGPIOProvider( pGPIOInterface, pDeviceObject, IRP_MJ_PNP);
    if(( pGPIOInterface->gpioOpen == NULL) || ( pGPIOInterface->gpioAccess == NULL))
    {
        // TRAP;
        _DbgPrintF( DEBUGLVL_ERROR,
                    ( "CGpio(): GPIO interface has NULL pointers\n")
                  );
        bResult = FALSE;
    }

    return( bResult);
}



/*^^*
 *      LocateAttachGPIOProvider()
 * Purpose  : gets the pointer to the parent GPIO Provider interface
 *              This function will be called at Low priority
 *
 * Inputs   :   GPIOINTERFACE * pGPIOInterface  : pointer to the Interface to be filled in
 *              PDEVICE_OBJECT pDeviceObject    : MiniDriver device object, which is a child of I2C Master
 *              int         nIrpMajorFunction   : IRP major function to query the GPIO Interface
 *
 * Outputs  : BOOL  - returns TRUE, if the interface was found
 * Author   : IKLEBANOV
 *^^*/
BOOL CGpio::LocateAttachGPIOProvider( GPIOINTERFACE * pGPIOInterface, PDEVICE_OBJECT pDeviceObject, int nIrpMajorFunction)
{
    PIRP    pIrp;
    BOOL    bResult = FALSE;

    ENSURE
    {
        PIO_STACK_LOCATION  pNextStack;
        NTSTATUS            ntStatus;
        KEVENT              Event;


        pIrp = IoAllocateIrp( pDeviceObject->StackSize, FALSE);
        if( pIrp == NULL)
        {
            // TRAP;
            _DbgPrintF( DEBUGLVL_ERROR, ("CGpio(): can not allocate IRP\n"));
            FAIL;
        }

        pNextStack = IoGetNextIrpStackLocation( pIrp);
        if( pNextStack == NULL)
        {
            // TRAP;
            _DbgPrintF( DEBUGLVL_ERROR,
                        ("CATIHwConfig(): can not allocate NextStack\n")
                      );
            FAIL;
        }

        //$REVIEW - Should change function decl to make nIrpMajorFunction be UCHAR - TCP
        pNextStack->MajorFunction = (UCHAR) nIrpMajorFunction;
        pNextStack->MinorFunction = IRP_MN_QUERY_INTERFACE;
        KeInitializeEvent( &Event, NotificationEvent, FALSE);

        IoSetCompletionRoutine( pIrp,
                                GPIOIoSynchCompletionRoutine,
                                &Event, TRUE, TRUE, TRUE);

        pNextStack->Parameters.QueryInterface.InterfaceType = ( struct _GUID *)&GUID_GPIO_INTERFACE;
        pNextStack->Parameters.QueryInterface.Size = sizeof( GPIOINTERFACE);
        pNextStack->Parameters.QueryInterface.Version = 1;
        pNextStack->Parameters.QueryInterface.Interface = ( PINTERFACE)pGPIOInterface;
        pNextStack->Parameters.QueryInterface.InterfaceSpecificData = NULL;

        ntStatus = IoCallDriver( pDeviceObject, pIrp);

        if( ntStatus == STATUS_PENDING)
            KeWaitForSingleObject(  &Event,
                                    Suspended, KernelMode, FALSE, NULL);
        if(( pGPIOInterface->gpioOpen == NULL) || ( pGPIOInterface->gpioAccess == NULL))
        {
            _DbgPrintF( DEBUGLVL_ERROR,
                        ( "CATIHwConfig(): GPIO interface has NULL pointers\n")
                      );
            FAIL;
        }
        bResult = TRUE;

    } END_ENSURE;

    if( pIrp != NULL)
        IoFreeIrp( pIrp);

    return( bResult);
}



/*^^*
 *      QueryGPIOProvider()
 * Purpose  : queries the GPIOProvider for the pins supported and private interfaces
 *
 * Inputs   : PGPIOControl pgpioAccessBlock : pointer to GPIO control structure
 *
 * Outputs  : BOOL : retunrs TRUE, if the query function was carried on successfully
 * Author   : IKLEBANOV
 *^^*/
BOOL CGpio::QueryGPIOProvider( PGPIOControl pgpioAccessBlock)
{

    ENSURE
    {
        if(( m_gpioProviderInterface.gpioOpen == NULL)      ||
            ( m_gpioProviderInterface.gpioAccess == NULL)   ||
            ( m_pdoDriver == NULL))
            FAIL;

        pgpioAccessBlock->Status = GPIO_STATUS_NOERROR;
        pgpioAccessBlock->Command = GPIO_COMMAND_QUERY;
        pgpioAccessBlock->AsynchCompleteCallback = NULL;

        if(( !NT_SUCCESS( m_gpioProviderInterface.gpioOpen( m_pdoDriver, TRUE, pgpioAccessBlock))) ||
            ( pgpioAccessBlock->Status != GPIO_STATUS_NOERROR))
            FAIL;

        return( TRUE);

    } END_ENSURE;

    return( FALSE);
}



/*^^*
 *      LockGPIOProviderEx()
 * Purpose  : locks the GPIOProvider for exclusive use
 *
 * Inputs   : PGPIOControl pgpioAccessBlock : pointer to GPIO control structure
 *
 * Outputs  : BOOL : retunrs TRUE, if the GPIOProvider is locked
 * Author   : IKLEBANOV
 *^^*/
BOOL CGpio::LockGPIOProviderEx( PGPIOControl pgpioAccessBlock)
{
    NTSTATUS        ntStatus;
    LARGE_INTEGER   liStartTime, liCurrentTime;

    KeQuerySystemTime( &liStartTime);

    ENSURE
    {
        if(( m_gpioProviderInterface.gpioOpen == NULL)      ||
            ( m_gpioProviderInterface.gpioAccess == NULL)   ||
            ( m_pdoDriver == NULL))
            FAIL;

        pgpioAccessBlock->Status = GPIO_STATUS_NOERROR;
        pgpioAccessBlock->Command = GPIO_COMMAND_OPEN_PINS;

        while( TRUE)
        {
            KeQuerySystemTime( &liCurrentTime);

            if(( liCurrentTime.QuadPart - liStartTime.QuadPart) >= GPIO_TIMELIMIT_OPENPROVIDER)
            {
                // time has expired for attempting to lock GPIO provider
                return (FALSE);
            }

            ntStatus = m_gpioProviderInterface.gpioOpen( m_pdoDriver, TRUE, pgpioAccessBlock);

            if(( NT_SUCCESS( ntStatus)) && ( pgpioAccessBlock->Status == GPIO_STATUS_NOERROR))
                break;
        }

        // the GPIO Provider has granted access - save dwCookie for further use
        m_dwGPIOAccessKey = pgpioAccessBlock->dwCookie;

        return( TRUE);

    } END_ENSURE;

    return( FALSE);
}



/*^^*
 *      ReleaseGPIOProvider()
 * Purpose  : releases the GPIOProvider for other clients' use
 *
 * Inputs   : PGPIOControl pgpioAccessBlock : pointer to a composed GPIO access block
 *
 * Outputs  : BOOL : retunrs TRUE, if the GPIOProvider is released
 * Author   : IKLEBANOV
 *^^*/
BOOL CGpio::ReleaseGPIOProvider( PGPIOControl pgpioAccessBlock)
{
    NTSTATUS    ntStatus;

    ENSURE
    {
        if(( m_gpioProviderInterface.gpioOpen == NULL)      ||
            ( m_gpioProviderInterface.gpioAccess == NULL)   ||
            ( m_pdoDriver == NULL))
            FAIL;

        pgpioAccessBlock->Status = GPIO_STATUS_NOERROR;
        pgpioAccessBlock->Command = GPIO_COMMAND_CLOSE_PINS;
        pgpioAccessBlock->dwCookie = m_dwGPIOAccessKey;

        ntStatus = m_gpioProviderInterface.gpioOpen( m_pdoDriver, FALSE, pgpioAccessBlock);

        if( !NT_SUCCESS( ntStatus))
        {
            _DbgPrintF( DEBUGLVL_ERROR,
                        ( "CGpio: ReleaseGPIOProvider() NTSTATUS = %x\n",
                          ntStatus)
                        );
            FAIL;
        }

        if( pgpioAccessBlock->Status != GPIO_STATUS_NOERROR)
        {
            _DbgPrintF( DEBUGLVL_ERROR,
                        ( "CGpio: ReleaseGPIOProvider() Status = %x\n",
                          pgpioAccessBlock->Status)
                      );
            FAIL;
        }

        m_dwGPIOAccessKey = 0;
        return ( TRUE);

    } END_ENSURE;

    return( FALSE);
}



/*^^*
 *      AccessGPIOProvider()
 * Purpose  : provide synchronous type of access to GPIOProvider
 *
 * Inputs   :   PDEVICE_OBJECT pdoDriver    : pointer to the client's device object
 *              PGPIOControl pgpioAccessBlock   : pointer to a composed GPIO access block
 *
 * Outputs  : BOOL, TRUE if acsepted by the GPIO Provider
 *
 * Author   : IKLEBANOV
 *^^*/
//BOOL CGpio::AccessGPIOProvider( PDEVICE_OBJECT pdoClient, PGPIOControl pgpioAccessBlock)
BOOL CGpio::AccessGPIOProvider( PGPIOControl pgpioAccessBlock)

{
    NTSTATUS    ntStatus;

    ENSURE
    {

        if(( m_gpioProviderInterface.gpioOpen == NULL)      ||
            ( m_gpioProviderInterface.gpioAccess == NULL)   ||
            ( m_pdoDriver == NULL))
            FAIL;


        //ntStatus = m_gpioProviderInterface.gpioAccess( pdoClient, pgpioAccessBlock);
        ntStatus = m_gpioProviderInterface.gpioAccess( m_pdoDriver, pgpioAccessBlock);

        if( !NT_SUCCESS( ntStatus))
        {
            _DbgPrintF( DEBUGLVL_ERROR,
                        ( "CGpio: AccessGPIOProvider() NTSTATUS = %x\n",
                          ntStatus)
                      );
            FAIL;
        }

        if( pgpioAccessBlock->Status != GPIO_STATUS_NOERROR)
        {
            _DbgPrintF( DEBUGLVL_ERROR,
                        ( "CGpio: AccessGPIOProvider() Status = %x\n",
                          pgpioAccessBlock->Status)
                      );
            FAIL;
        }

        return TRUE;

    } END_ENSURE;

    return( FALSE);
}

/*
 *      WriteGPIO()
 * Purpose  : write to GPIO
 *
 * Inputs   :   PDEVICE_OBJECT pdoDriver    : pointer to the client's device object
 *              PGPIOControl pgpioAccessBlock   : pointer to a composed GPIO access block
 *
 * Outputs  : BOOL, TRUE if write succeeds
 *
 * Author   : MM
 *
*/
BOOL CGpio::WriteGPIO(PGPIOControl pgpioAccessBlock)
{

    ENSURE
    {
        // Put cookie value in the structure
        pgpioAccessBlock->dwCookie = m_dwGPIOAccessKey;
        pgpioAccessBlock->Command = GPIO_COMMAND_WRITE_BUFFER;
        pgpioAccessBlock->Flags = GPIO_FLAGS_BYTE;
        pgpioAccessBlock->nBytes = 1;
        pgpioAccessBlock->nBufferSize = 1;

        // Put cookie value in the structure
        pgpioAccessBlock->dwCookie = m_dwGPIOAccessKey;

        if (AccessGPIOProvider(pgpioAccessBlock) == FALSE)
        {
            _DbgPrintF( DEBUGLVL_ERROR, ("CGpio: GPIO Write Error\n"));
            FAIL;
        }

        return TRUE;

    } END_ENSURE;

    return( FALSE);
}

/*
 *      ReadGPIO()
 * Purpose  : Read From GPIO
 *
 * Inputs   :   PDEVICE_OBJECT pdoDriver    : pointer to the client's device object
 *              PGPIOControl pgpioAccessBlock   : pointer to a composed GPIO access block
 *
 * Outputs  : BOOL, TRUE if write succeeds
 *
 * Author   : MM
 *
*/
BOOL CGpio::ReadGPIO(PGPIOControl pgpioAccessBlock)
{

    ENSURE
    {
        // Put cookie value in the structure
        pgpioAccessBlock->dwCookie = m_dwGPIOAccessKey;
        pgpioAccessBlock->Command = GPIO_COMMAND_READ_BUFFER;
        pgpioAccessBlock->Flags = GPIO_FLAGS_BYTE;
        pgpioAccessBlock->nBytes = 1;
        pgpioAccessBlock->nBufferSize = 1;

        // Put cookie value in the structure
        pgpioAccessBlock->dwCookie = m_dwGPIOAccessKey;

        if (AccessGPIOProvider(pgpioAccessBlock) == FALSE)
        {
            _DbgPrintF( DEBUGLVL_ERROR, ("CGpio: GPIO Read Error\n"));
            FAIL;
        }
        else
            _DbgPrintF( DEBUGLVL_BLAB, ("CGpio: GPIO Read OK\n"));

        return TRUE;

    } END_ENSURE;

    return( FALSE);
}


/*      WriteGPIO()
 * Purpose  : write to GPIO
 *
 * Inputs   :   UCHAR *p_uchPin : the pin number
 *              UCHAR *p_uchValue   : the pin value
 *
 * Outputs  : BOOL, TRUE if write succeeds
 *
 * Author   : MM
 *
*/
BOOL CGpio::WriteGPIO(UCHAR *p_uchPin,UCHAR *p_uchValue )
{
    GPIOControl gpioAccessBlock;
    BOOL    bResult = FALSE;

    ENSURE
    {
        // Put cookie value in the structure

        gpioAccessBlock.Flags = GPIO_FLAGS_BYTE;
        gpioAccessBlock.nBytes = 1;
        gpioAccessBlock.nBufferSize = 1;
        gpioAccessBlock.AsynchCompleteCallback = NULL;

        int counter = 0;
        LARGE_INTEGER   liTime;
        // Somewhat arbitrary max of 1 second.
        while (!LockGPIOProviderEx( &gpioAccessBlock))
        {
            if (counter++ >= 100)
            {
                _DbgPrintF( DEBUGLVL_ERROR,("PhilTune: unable to lock GPIOProvider\n"));
                FAIL;
            }

            liTime.QuadPart = 100000;
            KeDelayExecutionThread(KernelMode, FALSE, &liTime); // = 10 milliseconds
         }  // try to get GPIO Provider


        gpioAccessBlock.Command = GPIO_COMMAND_WRITE_BUFFER;
        gpioAccessBlock.Pins = p_uchPin;
        // Put cookie value in the structure
        gpioAccessBlock.dwCookie = m_dwGPIOAccessKey;
        gpioAccessBlock.Buffer = p_uchValue;

        if (AccessGPIOProvider(&gpioAccessBlock) == FALSE)
        {
            _DbgPrintF( DEBUGLVL_ERROR,("CGpio: GPIO Write Error\n"));
            FAIL;
        }

        bResult = TRUE;

    } END_ENSURE;

    ReleaseGPIOProvider(&gpioAccessBlock);
    return bResult;
}

/*
 *      ReadGPIO()
 * Purpose  : Read From GPIO
 *
 * Inputs   :   UCHAR *p_uchPin : the pin number
 *              UCHAR *p_uchValue   : the pin value
 *
 * Outputs  : BOOL, TRUE if write succeeds
 *
 * Author   : MM
 *
*/
BOOL CGpio::ReadGPIO(UCHAR *p_uchPin,UCHAR *p_uchValue )
{
    GPIOControl gpioAccessBlock;
    BOOL    bResult = FALSE;

    ENSURE
    {
        // Put cookie value in the structure
        gpioAccessBlock.Flags = GPIO_FLAGS_BYTE;
        gpioAccessBlock.nBytes = 1;
        gpioAccessBlock.nBufferSize = 1;
        gpioAccessBlock.AsynchCompleteCallback = NULL;

        int counter = 0;
        LARGE_INTEGER   liTime;
        // Somewhat arbitrary max of 1 second.
        while (!LockGPIOProviderEx( &gpioAccessBlock))
        {
            if (counter++ >= 100)
            {
                _DbgPrintF( DEBUGLVL_ERROR,("PhilTune: unable to lock GPIOProvider"));
                FAIL;
            }

            liTime.QuadPart = 100000;
            KeDelayExecutionThread(KernelMode, FALSE, &liTime); // = 10 milliseconds
         }  // try to get GPIO Provider

        gpioAccessBlock.Command = GPIO_COMMAND_READ_BUFFER;
        gpioAccessBlock.Pins = p_uchPin;
        // Put cookie value in the structure
        gpioAccessBlock.dwCookie = m_dwGPIOAccessKey;
        gpioAccessBlock.Buffer = p_uchValue;

        if (AccessGPIOProvider(&gpioAccessBlock) == FALSE)
        {
            _DbgPrintF( DEBUGLVL_ERROR,("CGpio: GPIO Read Error\n"));
            FAIL;
        }
        else
        {
            _DbgPrintF( DEBUGLVL_TERSE,("CGpio: GPIO Read OK\n"));
        }

        bResult = TRUE;

    } END_ENSURE;

    ReleaseGPIOProvider(&gpioAccessBlock);
    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\mauitune\i2script.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//  I2CSCRPT.C
//  I2CScript class implementation.
//      Main Include Module.
//
//==========================================================================;

extern "C"
{
#include <wdm.h>
}

#include <unknown.h>
#include "ks.h"
#include "ksmedia.h"
#include <ksdebug.h>
#include "i2script.h"
#include "wdmdebug.h"

//$REVIEW - Let's find a way to get the proper module name into this
//
#define MODULENAME           "PhilTune"
#define MODULENAMEUNICODE   L"PhilTune"

#define STR_MODULENAME      MODULENAME

#define ENSURE    do
#define END_ENSURE  while( FALSE)
#define FAIL    break


/*^^*
 *      CI2CScript()
 * Purpose  : CI2CScript class constructor.
 *              Performs checking of the I2C provider presence. Sets the script in the initial state.
 *
 * Inputs   :   PUINT puiError                      : pointer to return a completion error code
 *              PHW_STREAM_REQUEST_BLOCK    pSrb    : pointer to HW_INITIALIZE SRB
 *
 * Outputs  : none
 * Author   : IKLEBANOV
 *^^*/
CI2CScript::
CI2CScript(
    PDEVICE_OBJECT pDeviceObject,
    NTSTATUS *      pStatus
    )
{
    *pStatus = STATUS_SUCCESS;

    m_dwI2CAccessKey = 0;

    m_liOperationStartTime.QuadPart = 0;

    m_i2cProviderInterface.i2cOpen = NULL;
    m_i2cProviderInterface.i2cAccess = NULL;

    m_pdoDriver = NULL;

    if( !InitializeAttachI2CProvider( &m_i2cProviderInterface, pDeviceObject))
    {
        *pStatus = STATUS_NOINTERFACE;
    }
    else
    {
        // there was no error to get I2CInterface from the MiniVDD
        m_pdoDriver = pDeviceObject;
        m_ulI2CAccessClockRate = I2C_FIXED_CLOCK_RATE;
    }

    _DbgPrintF( DEBUGLVL_VERBOSE,
                ( "CI2CScript:CI2CScript() exit Error = %x\n", * pStatus)
              );
}



/*^^*
 *      LockI2CProvider()
 * Purpose  : locks the I2CProvider for exclusive use
 *
 * Inputs   : none
 *
 * Outputs  : BOOL : retunrs TRUE, if the I2CProvider is locked
 * Author   : IKLEBANOV
 *^^*/
BOOL CI2CScript::LockI2CProvider( void)
{
    BOOL        bResult;
    I2CControl  i2cAccessBlock;

    bResult = FALSE;

    ENSURE
    {
        if(( m_i2cProviderInterface.i2cOpen == NULL)    ||
            ( m_i2cProviderInterface.i2cAccess == NULL) ||
            ( m_pdoDriver == NULL))
            FAIL;

        i2cAccessBlock.Status = I2C_STATUS_NOERROR;
        if( m_i2cProviderInterface.i2cOpen( m_pdoDriver, TRUE, &i2cAccessBlock) != STATUS_SUCCESS)
        {
            _DbgPrintF( DEBUGLVL_ERROR,
                        ( "CI2CScript: LockI2CProvider() bResult = %x\n",
                          bResult)
                      );
            FAIL;
        }

        if( i2cAccessBlock.Status != I2C_STATUS_NOERROR)
        {
            _DbgPrintF( DEBUGLVL_ERROR,
                        ( "CI2CScript: LockI2CProvider() Status = %x\n",
                          i2cAccessBlock.Status)
                      );
            FAIL;
        }

        // the I2C Provider has granted access - save dwCookie for further use
        m_dwI2CAccessKey = i2cAccessBlock.dwCookie;

        bResult = TRUE;

    } END_ENSURE;

    return( bResult);
}



/*^^*
 *      LockI2CProvider()
 * Purpose  : locks the I2CProvider for exclusive use. Provides attempts to lock the
 *              provider unless either the time-out condition or the attempt succeeded.
 *
 * Inputs   : none
 *
 * Outputs  : BOOL : retunrs TRUE, if the I2CProvider is locked
 * Author   : IKLEBANOV
 *^^*/
BOOL CI2CScript::LockI2CProviderEx( void)
{
    LARGE_INTEGER liTime;

    m_liOperationStartTime.QuadPart = 0;

    while( !LockI2CProvider())
    {
        KeQuerySystemTime( &liTime);

        if( m_liOperationStartTime.QuadPart)
            m_liOperationStartTime.QuadPart = liTime.QuadPart;
        else
            if( liTime.QuadPart - m_liOperationStartTime.QuadPart >
                I2CSCRIPT_TIMELIMIT_OPENPROVIDER)
            {
                // the time is expired - abort the initialization
                return( FALSE);
            }

        liTime.QuadPart = I2CSCRIPT_DELAY_OPENPROVIDER;
        KeDelayExecutionThread( KernelMode, FALSE, &liTime);
    }

    return( TRUE);
}




/*^^*
 *      GetI2CProviderLockStatus()
 * Purpose  : retrieves I2CProvider lock status
 *
 * Inputs   : none
 *
 * Outputs  : BOOL : retunrs TRUE, if the I2CProvider has been locked
 * Author   : IKLEBANOV
 *^^*/
BOOL CI2CScript::GetI2CProviderLockStatus( void)
{

    return( m_dwI2CAccessKey);
}




/*^^*
 *      ReleaseI2CProvider()
 * Purpose  : releases the I2CProvider for other clients' use
 *
 * Inputs   : none
 *
 * Outputs  : BOOL : retunrs TRUE, if the I2CProvider is released
 * Author   : IKLEBANOV
 *^^*/
BOOL CI2CScript::ReleaseI2CProvider( void)
{
    BOOL        bResult;
    I2CControl  i2cAccessBlock;

    bResult = FALSE;

    ENSURE
    {
        if(( m_i2cProviderInterface.i2cOpen == NULL)    ||
            ( m_i2cProviderInterface.i2cAccess == NULL) ||
            ( m_pdoDriver == NULL))
            // the I2CProvider was not found
            FAIL;

        i2cAccessBlock.Status = I2C_STATUS_NOERROR;
        i2cAccessBlock.dwCookie = m_dwI2CAccessKey;
        i2cAccessBlock.ClockRate = m_ulI2CAccessClockRate;
        if( m_i2cProviderInterface.i2cOpen( m_pdoDriver, FALSE, &i2cAccessBlock) != STATUS_SUCCESS)
        {
            _DbgPrintF( DEBUGLVL_ERROR,
                        ( "CI2CScript: ReleaseI2CProvider() bResult = %x\n",
                          bResult)
                      );
            FAIL;
        }

        if( i2cAccessBlock.Status != I2C_STATUS_NOERROR)
        {
            _DbgPrintF( DEBUGLVL_ERROR,
                        ( "CI2CScript: ReleaseI2CProvider() bResult = %x\n",
                          bResult)
                      );
            FAIL;
        }

        m_dwI2CAccessKey = 0;
        bResult = TRUE;

    } END_ENSURE;

    return( bResult);
}



/*^^*
 *      PerformI2CPacketOperation()
 * Purpose  : synchronosly executes I2C access packet. It assumed to be executed at Low priority.
 *              The function does not return until the I2C session is done. The execution
 *              is not dependent on the I2C Provider lock status
 *
 * Inputs   :   PI2CPacket pI2CPacket : pointer to I2C access packet
 *
 * Outputs  : BOOL : returns TRUE, if I2C operation was carried out successfuly
 *              The error status is returned via uchI2CResult field of the PI2CPacket
 * Author   : IKLEBANOV
 *^^*/
BOOL CI2CScript::PerformI2CPacketOperation( IN OUT PI2CPacket pI2CPacket)
{
    BOOL bResult;

    if( GetI2CProviderLockStatus())
        // the Provider was locked before and we're not going to change it
        bResult = ExecuteI2CPacket( pI2CPacket);
    else
    {
        // the Provider was not locked and it's our responsibility to lock it first,
        // execute I2C operation and release it after the use
        if( LockI2CProviderEx())
        {
            bResult = ExecuteI2CPacket( pI2CPacket);
            ReleaseI2CProvider();
        }
        else
            bResult = FALSE;
    }

    return( bResult);
}



/*^^*
 *      ExecuteI2CPacket()
 * Purpose  : synchronosly executes I2C access packet. It assumed to be executed at Low priority.
 *              The function does not return until the I2C session is done. This kind of access
 *              is used during initialization ( boot up) time only. This function should be
 *              called only after the I2CProvider was locked for exclusive service
 *
 * Inputs   :   PI2CPacket pI2CPacket : pointer to I2C access packet
 *
 * Outputs  : BOOL : returns TRUE, if I2C operation was carried out successfuly
 *              The error status is returned via uchI2CResult field of the PI2CPacket
 * Author   : IKLEBANOV
 *^^*/
BOOL CI2CScript::ExecuteI2CPacket( IN OUT PI2CPacket pI2CPacket)
{
    UINT    nError, cbCount;
    UCHAR   uchValue;
    UCHAR   uchI2CResult = I2C_STATUS_ERROR;

    ENSURE
    {
        I2CControl  i2cAccessBlock;

        if(( nError = CheckI2CScriptPacket( pI2CPacket)) != I2CSCRIPT_NOERROR)
            FAIL;

        // we'll use I2CProvider interface, assuming there is a syncronous provider
        // for asynchronous provider some work has to be added. 16 bits emulation is
        // not supported at this time either. This implementation does not support
        // Read-Modify-Write request either
        ENSURE
        {
            UINT        nIndex;

            i2cAccessBlock.dwCookie = m_dwI2CAccessKey;
            i2cAccessBlock.ClockRate = m_ulI2CAccessClockRate;

            // We assume the last byte in the buffer belongs to the Write operation
            // after Read-Modify, is specified.
            cbCount = ( pI2CPacket->usFlags & I2COPERATION_READWRITE) ?
                            ( pI2CPacket->cbWriteCount - 1) : ( pI2CPacket->cbWriteCount);

            if( cbCount)
            {
                // implement a write request
                // apply START condition with the I2C chip address first
                i2cAccessBlock.Flags = I2C_FLAGS_START | I2C_FLAGS_ACK;
                i2cAccessBlock.Command = I2C_COMMAND_WRITE;
                i2cAccessBlock.Data = pI2CPacket->uchChipAddress & 0xFE;
                if( AccessI2CProvider( m_pdoDriver, &i2cAccessBlock) != I2C_STATUS_NOERROR)
                    FAIL;

                i2cAccessBlock.Flags = I2C_FLAGS_ACK;
                for( nIndex = 0; nIndex < cbCount; nIndex ++)
                {
                    // write the data from the buffer
                    i2cAccessBlock.Data = pI2CPacket->puchWriteBuffer[nIndex];
                    if(( nIndex == cbCount - 1) &&
                        !( pI2CPacket->usFlags & I2COPERATION_RANDOMACCESS))
                        // the last byte to write - apply STOP condition, if no
                        // I2COPERATION_RANDOMACCESS flag is specified
                        i2cAccessBlock.Flags |= I2C_FLAGS_STOP;

                    if( AccessI2CProvider( m_pdoDriver, &i2cAccessBlock) != I2C_STATUS_NOERROR)
                        break;
                }
                if( nIndex != cbCount)
                    FAIL;
/*  // STOP condition is applied withe the last byte to be written
                // apply stop condition as the end of write operation
                i2cAccessBlock.Flags = I2C_FLAGS_STOP;
                i2cAccessBlock.Command = I2C_COMMAND_NULL;
                m_i2cProviderInterface.i2cAccess( m_pdoDriver, &i2cAccessBlock);
*/
            }

            if( pI2CPacket->cbReadCount)
            {
                // implement a read request
                // apply START condition with the I2C chip address first
                i2cAccessBlock.Flags = I2C_FLAGS_START | I2C_FLAGS_ACK;
                i2cAccessBlock.Command = I2C_COMMAND_WRITE;
                i2cAccessBlock.Data = pI2CPacket->uchChipAddress | 0x01;
                if( AccessI2CProvider( m_pdoDriver, &i2cAccessBlock) != I2C_STATUS_NOERROR)
                    FAIL;

                i2cAccessBlock.Flags = I2C_FLAGS_ACK;
                i2cAccessBlock.Command = I2C_COMMAND_READ;
                for( nIndex = 0; nIndex < pI2CPacket->cbReadCount; nIndex ++)
                {
                    // read the data to the buffer
                    if( nIndex == ( UINT)( pI2CPacket->cbReadCount - 1))
                    {
                        // don't apply ACK at the last read - read operation termination
                        i2cAccessBlock.Flags &= ~I2C_FLAGS_ACK;
                        // also apply STOP condition for the last byte
                        i2cAccessBlock.Flags |= I2C_FLAGS_STOP;
                    }

                    if( AccessI2CProvider( m_pdoDriver, &i2cAccessBlock) != I2C_STATUS_NOERROR)
                        break;
                    pI2CPacket->puchReadBuffer[nIndex] = i2cAccessBlock.Data;
                }
                if( nIndex != pI2CPacket->cbReadCount)
                    FAIL;

/*  // STOP condition is applied with the last byte to be read
                // apply stop condition as the end of read operation
                i2cAccessBlock.Flags = I2C_FLAGS_STOP;
                i2cAccessBlock.Command = I2C_COMMAND_NULL;
                m_i2cProviderInterface.i2cAccess( m_pdoDriver, &i2cAccessBlock);
*/
                if( pI2CPacket->usFlags & I2COPERATION_READWRITE)
                {
                    // write operation should be taken care again, the last byte in the pbyWriteBuffer
                    // should be constructed from the value read back and the binary operations OR and AND
                    // with the values specified in the packet
                    uchValue = pI2CPacket->puchReadBuffer[pI2CPacket->cbReadCount - 1];
                    uchValue &= pI2CPacket->uchANDValue;
                    pI2CPacket->puchWriteBuffer[pI2CPacket->cbWriteCount - 1] = uchValue | pI2CPacket->uchORValue;

                    if( pI2CPacket->cbWriteCount)
                    {
                        // implement a write request
                        // apply START condition with the I2C chip address first
                        i2cAccessBlock.Flags = I2C_FLAGS_START | I2C_FLAGS_ACK;
                        i2cAccessBlock.Command = I2C_COMMAND_WRITE;
                        i2cAccessBlock.Data = pI2CPacket->uchChipAddress & 0xFE;
                        if( AccessI2CProvider( m_pdoDriver, &i2cAccessBlock) != I2C_STATUS_NOERROR)
                            FAIL;

                        i2cAccessBlock.Flags = I2C_FLAGS_ACK;
                        for( nIndex = 0; nIndex < pI2CPacket->cbWriteCount; nIndex ++)
                        {
                            // write the data from the buffer
                            i2cAccessBlock.Data = pI2CPacket->puchWriteBuffer[nIndex];
                            if( nIndex == ( UINT)( pI2CPacket->cbWriteCount - 1))
                                // the last byte to write - apply STOP condition
                                i2cAccessBlock.Flags |= I2C_FLAGS_STOP;

                            if( AccessI2CProvider( m_pdoDriver, &i2cAccessBlock) != I2C_STATUS_NOERROR)
                                break;
                        }

                        if( nIndex != pI2CPacket->cbWriteCount)
                            FAIL;
/*  // STOP condition is applied withe the last byte to be written
                        // apply stop condition as the end of write operation
                        i2cAccessBlock.Flags = I2C_FLAGS_STOP;
                        i2cAccessBlock.Command = I2C_COMMAND_NULL;
                        m_i2cProviderInterface.i2cAccess( m_pdoDriver, &i2cAccessBlock);
*/
                    }
                }
            }

            uchI2CResult = I2C_STATUS_NOERROR;

        } END_ENSURE;

        if( uchI2CResult == I2C_STATUS_ERROR)
        {
            // there was an error during accessing I2C - issue Reset command
            i2cAccessBlock.Command = I2C_COMMAND_RESET;
            AccessI2CProvider( m_pdoDriver, &i2cAccessBlock);
        }

        pI2CPacket->uchI2CResult = uchI2CResult;

        return( TRUE);

    } END_ENSURE;

    _DbgPrintF( DEBUGLVL_VERBOSE,
                ( "CI2CScript:ExecuteI2CPacket() nError = %x", nError)
              );
    return( FALSE);
}



/*^^*
 *      CheckI2CScriptPacket()
 * Purpose  : checks integrity of the I2C control package
 *
 * Inputs   :   PI2CPacket pI2CPacket   : pointer to I2C access packet
 *
 * Outputs  : BOOL : returns TRUE, if I2C control package is a valid one
 *
 * Author   : IKLEBANOV
 *^^*/
UINT CI2CScript::CheckI2CScriptPacket( IN PI2CPacket pI2CPacket)
{
    UINT nPacketError;

    ENSURE
    {
        if(( m_i2cProviderInterface.i2cOpen == NULL)    ||
            ( m_i2cProviderInterface.i2cAccess == NULL) ||
            ( m_pdoDriver == NULL))
        {
            // the I2CProvider was not found
            nPacketError = I2CSCRIPT_ERROR_NOPROVIDER;
            FAIL;
        }

        if(( !pI2CPacket->cbWriteCount) && ( !pI2CPacket->cbReadCount))
        {
            // nothing to do
            nPacketError = I2CSCRIPT_ERROR_NODATA;
            FAIL;
        }

        if((( pI2CPacket->cbWriteCount) && ( pI2CPacket->puchWriteBuffer == NULL))
            || (( pI2CPacket->cbReadCount) && ( pI2CPacket->puchReadBuffer == NULL)))
        {
            // NULL pointer, when the data is specified
            nPacketError = I2CSCRIPT_ERROR_NOBUFFER;
            FAIL;
        }

        if(( pI2CPacket->usFlags & I2COPERATION_READWRITE) && ( !pI2CPacket->cbWriteCount))
        {
            // if Read-Modify-Write is specified, the Write data should be present
            nPacketError = I2CSCRIPT_ERROR_READWRITE;
            FAIL;
        }

        nPacketError = I2CSCRIPT_NOERROR;

    } END_ENSURE;

    return( nPacketError);
}




/*^^*
 *      ClearScript()
 * Purpose  : clears I2CScript to the NULL state - no I2C operations are on hold.
 *
 * Inputs   :   none
 *
 * Outputs  : none
 * Author   : IKLEBANOV
 *^^*/
void CI2CScript::ClearScript( void)
{

    m_nExecutionIndex = 0;
    m_nScriptLength = 0;
    m_pfnReturnWhenDone = NULL;
    m_bExecutionInProcess = FALSE;
}



/*^^*
 *      AppendToScript()
 * Purpose  : appends a I2CPacket to the bottom of the I2CScript.
 *              The 16 bits emulation is not implemented at this time.
 *
 * Inputs   :   PI2CPacket pI2CPacket - pointer to the I2C packet to append
 *
 * Outputs  : BOOL : returns TRUE, if the packet was successfully appended.
 *              FALSE might happend if the I2CPacket is a bad one, or overflow occurs
 * Author   : IKLEBANOV
 *^^*/
BOOL CI2CScript::AppendToScript( PI2CPacket pI2CPacket)
{
    UINT    nError, nScriptIndex;
    UINT    nIndex, cbCount;

    ENSURE
    {
        PI2CScriptPrimitive pI2CPrimitive;

        if(( nError = CheckI2CScriptPacket( pI2CPacket)) != I2CSCRIPT_NOERROR)
            FAIL;
        nError = I2CSCRIPT_ERROR_OVERFLOW;

        // m_nExecutionIndex is used as a Script build index. We will work with a local copy of it
        // first to ensure we have no overflow
        nScriptIndex = m_nExecutionIndex;
        pI2CPrimitive = &m_i2cScript[nScriptIndex];

        // We assume the last byte in the buffer belongs to the Write operation
        // after Read-Modify, is specified.
        cbCount = ( pI2CPacket->usFlags & I2COPERATION_READWRITE) ? \
                        ( pI2CPacket->cbWriteCount - 1) : ( pI2CPacket->cbWriteCount);

        if( cbCount)
        {
            // I2C Chip address should be taken care of first
            pI2CPrimitive->ulCommand = I2C_COMMAND_WRITE;
            pI2CPrimitive->byData = pI2CPacket->uchChipAddress;
            pI2CPrimitive->byANDData = 0xFE;
            pI2CPrimitive->byORData = 0x00;
            pI2CPrimitive->ulProviderFlags = I2C_FLAGS_START | I2C_FLAGS_ACK;
            pI2CPrimitive->byFlags = 0x0;

            // check the Script length
            if( ++ nScriptIndex >= I2CSCRIPT_LENGTH_MAXIMUM)
                FAIL;
            pI2CPrimitive ++;

            // I2C write buffer should be taken care of.
            for( nIndex = 0; nIndex < cbCount; nIndex ++)
            {
                pI2CPrimitive->ulCommand = I2C_COMMAND_WRITE;
                pI2CPrimitive->byData = pI2CPacket->puchWriteBuffer[nIndex];
                pI2CPrimitive->byORData = 0x00;
                pI2CPrimitive->byANDData = 0xFF;
                pI2CPrimitive->ulProviderFlags = I2C_FLAGS_ACK;
                pI2CPrimitive->byFlags = 0x0;

                if( nIndex == cbCount - 1)
                    // this is the last byte to be written - apply STOP
                    pI2CPrimitive->ulProviderFlags |= I2C_FLAGS_STOP;

                // check the Script length
                if( ++ nScriptIndex >= I2CSCRIPT_LENGTH_MAXIMUM)
                    break;
                pI2CPrimitive ++;
            }

            // check the Script length
            if( nScriptIndex >= I2CSCRIPT_LENGTH_MAXIMUM)
                FAIL;

/*
    // Stop condition is applied with the last byte to be written
    // We finished Write portion here, whether it's a Write only, Read-Modify-Write operation
            pI2CPrimitive->ulCommand = I2C_COMMAND_NULL;
            pI2CPrimitive->ulProviderFlags = I2C_FLAGS_STOP;
            pI2CPrimitive->byFlags = 0x0;

            // check the Script length
            if( ++ nScriptIndex >= I2CSCRIPT_LENGTH_MAXIMUM)
                FAIL;
            pI2CPrimitive ++;
*/
        }

        // We have to see, if there is a Read operation involved
        if( pI2CPacket->cbReadCount)
        {
            // I2C Chip address should be taken care of first
            pI2CPrimitive->ulCommand = I2C_COMMAND_WRITE;
            pI2CPrimitive->byData = pI2CPacket->uchChipAddress;
            pI2CPrimitive->byANDData = 0xFE;
            pI2CPrimitive->byORData = 0x01;
            pI2CPrimitive->ulProviderFlags = I2C_FLAGS_START | I2C_FLAGS_ACK;
            pI2CPrimitive->byFlags = 0x0;

            // check the Script length
            if( ++ nScriptIndex >= I2CSCRIPT_LENGTH_MAXIMUM)
                FAIL;
            pI2CPrimitive ++;

            // I2C read buffer should be taken care of. We assume the last byte in the buffer belongs to
            // the Write operation after Read-Modify, is specified.
            for( nIndex = 0; nIndex < pI2CPacket->cbReadCount; nIndex ++)
            {
                pI2CPrimitive->ulCommand = I2C_COMMAND_READ;
                if( nIndex == ( UINT)( pI2CPacket->cbReadCount - 1))
                {
                    pI2CPrimitive->ulProviderFlags = I2C_FLAGS_STOP;
                    pI2CPrimitive->byFlags = pI2CPacket->usFlags & I2COPERATION_READWRITE;
                }
                else
                {
                    pI2CPrimitive->ulProviderFlags = I2C_FLAGS_ACK;
                    pI2CPrimitive->byFlags = 0x0;
                }

                // check the Script length
                if( ++ nScriptIndex >= I2CSCRIPT_LENGTH_MAXIMUM)
                    break;
                pI2CPrimitive ++;
            }

            // check the Script length
            if( nScriptIndex >= I2CSCRIPT_LENGTH_MAXIMUM)
                FAIL;

/*  // Stop condition is applied with the last byte to be read
            // We finished Read portion here, whether it's a Read only, Read-Modify-Write operation
            pI2CPrimitive->ulCommand = I2C_COMMAND_NULL;
            pI2CPrimitive->ulProviderFlags = I2C_FLAGS_STOP;
            pI2CPrimitive->byFlags = 0x0;

            // check the Script length
            if( ++ nScriptIndex >= I2CSCRIPT_LENGTH_MAXIMUM)
                FAIL;
            pI2CPrimitive ++;
*/
        }

        // the last thing left to do, is to implement Write after Read-Modify, if specified
        if( pI2CPacket->usFlags & I2COPERATION_READWRITE)
        {
            // I2C Chip address should be taken care of first
            pI2CPrimitive->ulCommand = I2C_COMMAND_WRITE;
            pI2CPrimitive->byData = pI2CPacket->uchChipAddress;
            pI2CPrimitive->byANDData = 0xFE;
            pI2CPrimitive->byORData = 0x00;
            pI2CPrimitive->ulProviderFlags = I2C_FLAGS_START | I2C_FLAGS_ACK;
            pI2CPrimitive->byFlags = 0x0;

            // check the Script length
            if( ++ nScriptIndex >= I2CSCRIPT_LENGTH_MAXIMUM)
                FAIL;
            pI2CPrimitive ++;

            // I2C write buffer should be taken care of.
            for( nIndex = 0; nIndex < pI2CPacket->cbWriteCount; nIndex ++)
            {
                pI2CPrimitive->ulCommand = I2C_COMMAND_WRITE;
                pI2CPrimitive->byData = pI2CPacket->puchWriteBuffer[nIndex];
                pI2CPrimitive->ulProviderFlags = I2C_FLAGS_ACK;
                if( nIndex == ( UINT)( pI2CPacket->cbWriteCount - 1))
                {
                    // it's time to write the byte modified after the Read operation
                    pI2CPrimitive->byORData = pI2CPacket->uchORValue;
                    pI2CPrimitive->byANDData = pI2CPacket->uchANDValue;
                    pI2CPrimitive->byFlags = I2COPERATION_READWRITE;
                    // apply STOP condition with the last byte to be read
                    pI2CPrimitive->ulProviderFlags |= I2C_FLAGS_STOP;
                }
                else
                {
                    pI2CPrimitive->byORData = 0x00;
                    pI2CPrimitive->byANDData = 0xFF;
                    pI2CPrimitive->byFlags = 0x0;
                }

                // check the Script length
                if( ++ nScriptIndex >= I2CSCRIPT_LENGTH_MAXIMUM)
                    break;
                pI2CPrimitive ++;
            }

            // check the Script length
            if( nScriptIndex >= I2CSCRIPT_LENGTH_MAXIMUM)
                FAIL;

/*  // Stop condition is applied with the last byte to be written
            // We finished Write portion here, whether it's a Write only, Read-Modify-Write operation
            pI2CPrimitive->ulCommand = I2C_COMMAND_NULL;
            pI2CPrimitive->ulProviderFlags = I2C_FLAGS_STOP;
            pI2CPrimitive->byFlags = 0x0;

            // check the Script length
            if( ++ nScriptIndex >= I2CSCRIPT_LENGTH_MAXIMUM)
                FAIL;
            pI2CPrimitive ++;
*/
        }

        // the Packet was added succesfully to the Script. Modify the Script propertirs
        m_nExecutionIndex = nScriptIndex;
        m_nScriptLength = nScriptIndex;
        return( TRUE);

    } END_ENSURE;

    _DbgPrintF( DEBUGLVL_VERBOSE,
                ( "CI2CScript:AppendToScript() nError = %x", nError)
              );
    return( FALSE);
}



/*^^*
 *      ExecuteScript()
 * Purpose  : triggers the execution of previously built I2CScript. This function is also
 *              responsible for allocating I2CProvider for its own exclusive use.
 *
 * Inputs   :   PIRP pIrp
 *              PHWCompletionRoutine pfnScriptCompletion: function pointer will be called,
 *                  when the script execution is completed. Indicates the Script execution
 *                  is to be carried out asynchronously.
 *
 * Outputs  : BOOL : returns TRUE, if the execution was successfully triggered.
 *              FALSE might happend if the Script has not been built by the time of the call
 *
 * Note     : if pfnScriptExecuted is NULL pointer, the Script will be executed synchronously
 *
 * Author   : IKLEBANOV
 *^^*/
BOOL CI2CScript::ExecuteScript( IN PIRP                     pIrp,
                                IN PHWCompletionRoutine     pfnScriptCompletion)
{

    ENSURE
    {
        if( pfnScriptCompletion != NULL)
            // not supported at this point. The idea is to create a new system thread,
            // where the Script to be executed. When the Script will be copleted,
            // call-back is called and the thred terminates itself.
            FAIL;

        if( !m_nExecutionIndex)
            FAIL;

        // there is not a NULL Script - proceed
        m_nScriptLength = m_nExecutionIndex;
        m_nExecutionIndex = m_nCompletionIndex = 0;

        if( !GetI2CProviderLockStatus())
            // The provider was not locked prior the Script execution
            if( !LockI2CProviderEx())
                FAIL;

        InterpreterScript();

        ReleaseI2CProvider();

        return( TRUE);

    } END_ENSURE;

    return( FALSE);
}



/*^^*
 *      InterpreterScript()
 * Purpose  : interpreters the I2CScript line by line. The Script is not cleaned up
 *              after the completion to allow to client retrive the results of
 *              the script execution. It's the client responsibility to clean it up
 *              upon the results retrieving
 *
 * Inputs   : none
 * Outputs  : none
 *
 * Author   : IKLEBANOV
 *^^*/
void CI2CScript::InterpreterScript( void)
{
    UINT        nScriptIndex, nIndex;
    I2CControl  i2cAccessBlock;

    m_bExecutionInProcess = TRUE;

    i2cAccessBlock.dwCookie = m_dwI2CAccessKey;
    i2cAccessBlock.ClockRate = m_ulI2CAccessClockRate;

    // We'll interpreter every line of the Script and call the I2C Provider to
    // execute it. It's assumed the I2CProvider is a syncronous one. If it's not the
    // case, the special care should be taken of based upon returned value I2C_STATUS_BUSY
    // in the Status.
    for( nScriptIndex = 0; nScriptIndex < m_nScriptLength; nScriptIndex ++)
    {
        i2cAccessBlock.Command = m_i2cScript[nScriptIndex].ulCommand;
        i2cAccessBlock.Flags = m_i2cScript[nScriptIndex].ulProviderFlags;
        if( i2cAccessBlock.Command == I2C_COMMAND_WRITE)
        {
            i2cAccessBlock.Data = m_i2cScript[nScriptIndex].byData;
            i2cAccessBlock.Data &= m_i2cScript[nScriptIndex].byANDData;
            i2cAccessBlock.Data |= m_i2cScript[nScriptIndex].byORData;
        }

        if( AccessI2CProvider( m_pdoDriver, &i2cAccessBlock) == I2C_STATUS_ERROR)
            break;

        // check, wether it's a Read operation - save result
        if( i2cAccessBlock.Command == I2C_COMMAND_READ)
        {
            m_i2cScript[nScriptIndex].byData = i2cAccessBlock.Data;
            // check, if this data belongs to Read-Modify-Write operation
            if( m_i2cScript[nScriptIndex].byFlags & I2COPERATION_READWRITE)
            {
                // let's look for the next I2COPERATION_READWRITE flag - it is the pair
                for( nIndex = nScriptIndex; nIndex < m_nScriptLength; nIndex ++)
                    if(( m_i2cScript[nIndex].ulCommand == I2C_COMMAND_WRITE) &&
                        ( m_i2cScript[nIndex].byFlags & I2COPERATION_READWRITE))
                        break;

                if( nIndex >= m_nScriptLength)
                    // the Script got corrupted
                    break;

                m_i2cScript[nIndex].byData = i2cAccessBlock.Data;
            }
        }
    }

    m_nCompletionIndex = nScriptIndex;

    m_bExecutionInProcess = FALSE;
}



/*^^*
 *      AccessI2CProvider()
 * Purpose  : provide synchronous type of access to I2CProvider
 *
 * Inputs   :   PDEVICE_OBJECT pdoDriver    : pointer to the client's device object
 *              PI2CControl pi2cAccessBlock : pointer to a composed I2C access block
 *
 * Outputs  : UINT : status of the I2C operation I2C_STATUS_NOERROR or I2C_STATUS_ERROR
 *
 * Author   : IKLEBANOV
 *^^*/
UINT CI2CScript::
AccessI2CProvider( PDEVICE_OBJECT pdoClient, PI2CControl pi2cAccessBlock)
{
    UINT            uiStatus;
    LARGE_INTEGER   liTime;

    do
    {
        // this loop is infinitive. It has to be taken care of
        ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL);
        if( m_i2cProviderInterface.i2cAccess( pdoClient, pi2cAccessBlock) != STATUS_SUCCESS)
        {
            uiStatus = I2C_STATUS_ERROR;
            break;
        }

        if( pi2cAccessBlock->Status != I2C_STATUS_BUSY)
        {
            uiStatus = pi2cAccessBlock->Status;
            break;
        }

        liTime.QuadPart = I2CSCRIPT_DELAY_GETPROVIDERSTATUS;
        ::KeDelayExecutionThread( KernelMode, FALSE, &liTime);

        pi2cAccessBlock->Command = I2C_COMMAND_STATUS;

    } while( TRUE);

    return( uiStatus);
}



/*^^*
 *      GetScriptResults()
 * Purpose  : returns result of the executed Script
 *              This function idealy is called twice:
 *                  first time with the puchReadBuffer = NULL to retrive the number of bytes read
 *                  second time - to fill in the pointer
 * Inputs   :   PUINT puiReadCount  : pointer to the counter of the bytes were read
 *              PUCH puchReadBuffer : pointer to the buffer to put the data
 *
 * Outputs  : UINT : status of the I2C operation
 *              If the status is I2C_STATUS_ERROR, puiReadCount will contain the step, where
 *              I2CScript failed
 * Author   : IKLEBANOV
 *^^*/
UINT CI2CScript::GetScriptResults( PUINT puiReadCount, PUCHAR puchReadBuffer)
{
    UINT nScriptIndex, nCount;

    ASSERT( puiReadCount != NULL);

    if( m_bExecutionInProcess)
        return( I2C_STATUS_BUSY);

    if( m_nScriptLength != m_nCompletionIndex)
    {
        // if the case of failure, step where I2CScript failed is return
        // instead of Read Counter. The returned status indicates the
        // failure
        * puiReadCount = m_nCompletionIndex;

        return( I2C_STATUS_ERROR);
    }
    else
    {
        nCount = 0;

        for( nScriptIndex = 0; nScriptIndex < m_nCompletionIndex; nScriptIndex ++)
        {
            if( m_i2cScript[nScriptIndex].ulCommand == I2C_COMMAND_READ)
            {
                if( puchReadBuffer != NULL)
                    // fill in the supplied buffer
                    puchReadBuffer[nCount] = m_i2cScript[nScriptIndex].byData;
                nCount ++;
            }
        }

        * puiReadCount = nCount;

        return( I2C_STATUS_NOERROR);
    }
}



/*^^*
 *      InitializeAttachI2CProvider()
 * Purpose  : gets the pointer to the parent I2C Provider interface using
 *              several IRP_MJ_??? functions.
 *              This function will be called at Low priority
 *
 * Inputs   :   I2CINTERFACE * pI2CInterface    : pointer to the Interface to be filled in
 *              PDEVICE_OBJECT pDeviceObject    : MiniDriver device object, which is a child of I2C Master
 *
 * Outputs  : BOOL  - returns TRUE, if the interface was found
 * Author   : IKLEBANOV
 *^^*/
BOOL CI2CScript::InitializeAttachI2CProvider( I2CINTERFACE * pI2CInterface, PDEVICE_OBJECT pDeviceObject)
{
    BOOL bResult;

    // try the new path
    bResult = LocateAttachI2CProvider( pI2CInterface, pDeviceObject, IRP_MJ_PNP);
    if(( pI2CInterface->i2cOpen == NULL) || ( pI2CInterface->i2cAccess == NULL))
    {
        // TRAP;
        _DbgPrintF( DEBUGLVL_ERROR,
                    ( "CI2CScript(): interface has NULL pointers\n")
                  );
        bResult = FALSE;
    }

    return( bResult);
}



/*^^*
 *      LocateAttachI2CProvider()
 * Purpose  : gets the pointer to the parent I2C Provider interface
 *              This function will be called at Low priority
 *
 * Inputs   :   I2CINTERFACE * pI2CInterface    : pointer to the Interface to be filled in
 *              PDEVICE_OBJECT pDeviceObject    : MiniDriver device object, which is a child of I2C Master
 *              int         nIrpMajorFunction   : IRP major function to query the I2C Interface
 *
 * Outputs  : BOOL  - returns TRUE, if the interface was found
 * Author   : IKLEBANOV
 *^^*/
BOOL CI2CScript::LocateAttachI2CProvider( I2CINTERFACE * pI2CInterface, PDEVICE_OBJECT pDeviceObject, int nIrpMajorFunction)
{
    PIRP    pIrp;
    BOOL    bResult = FALSE;

    ENSURE
    {
        PIO_STACK_LOCATION  pNextStack;
        NTSTATUS            ntStatus;
        KEVENT              Event;


        pIrp = IoAllocateIrp( pDeviceObject->StackSize, FALSE);
        if( pIrp == NULL)
        {
            // TRAP;
            _DbgPrintF( DEBUGLVL_ERROR,
                        ( "CI2CScript(): can not allocate IRP\n")
                      );
            FAIL;
        }

        pNextStack = IoGetNextIrpStackLocation( pIrp);
        if( pNextStack == NULL)
        {
            // TRAP;
            _DbgPrintF( DEBUGLVL_ERROR,
                        ( "CI2CScript(): can not allocate NextStack\n")
                      );
            FAIL;
        }

        //$REVIEW - Should change function decl to make nIrpMajorFunction be UCHAR - TCP
        pNextStack->MajorFunction = (UCHAR) nIrpMajorFunction;
        pNextStack->MinorFunction = IRP_MN_QUERY_INTERFACE;
        KeInitializeEvent( &Event, NotificationEvent, FALSE);

        IoSetCompletionRoutine( pIrp,
                                I2CScriptIoSynchCompletionRoutine,
                                &Event, TRUE, TRUE, TRUE);

        pNextStack->Parameters.QueryInterface.InterfaceType = ( struct _GUID *)&GUID_I2C_INTERFACE;
        pNextStack->Parameters.QueryInterface.Size = sizeof( I2CINTERFACE);
        pNextStack->Parameters.QueryInterface.Version = 1;
        pNextStack->Parameters.QueryInterface.Interface = ( PINTERFACE)pI2CInterface;
        pNextStack->Parameters.QueryInterface.InterfaceSpecificData = NULL;

        ntStatus = IoCallDriver( pDeviceObject, pIrp);

        if( ntStatus == STATUS_PENDING)
            KeWaitForSingleObject(  &Event,
                                    Suspended, KernelMode, FALSE, NULL);
        if(( pI2CInterface->i2cOpen == NULL) || ( pI2CInterface->i2cAccess == NULL))
        {
            _DbgPrintF( DEBUGLVL_ERROR,
                        ( "CI2CScript(): interface has NULL pointers\n")
                      );
            FAIL;
        }
        bResult = TRUE;

    } END_ENSURE;

    if( pIrp != NULL)
        IoFreeIrp( pIrp);

    return( bResult);
}


/*^^*
 *      I2CScriptIoSynchCompletionRoutine()
 * Purpose  : This routine is for use with synchronous IRP processing.
 *              All it does is signal an event, so the driver knows it and can continue.
 *
 * Inputs   :   PDEVICE_OBJECT DriverObject : Pointer to driver object created by system
 *              PIRP pIrp                   : Irp that just completed
 *              PVOID Event                 : Event we'll signal to say Irp is done
 *
 * Outputs  : none
 * Author   : IKLEBANOV
 *^^*/
extern "C"
NTSTATUS I2CScriptIoSynchCompletionRoutine( IN PDEVICE_OBJECT pDeviceObject,
                                            IN PIRP pIrp,
                                            IN PVOID Event)
{

    KeSetEvent(( PKEVENT)Event, 0, FALSE);
    return( STATUS_MORE_PROCESSING_REQUIRED);
}



/*
 * WriteSeq()
 * Purpose  : Write a specified sequence to address specified.
 *
 *
 * Inputs   :   UCHAR addr : I2CAddress
 *              UCHAR  *p_seq : sequence
 *              USHORT len    : length of the sequence
 *
 * Outputs  : BOOL - TRUE if operation succeeded else FALSE
 * Author   : MM
 *
*/
BOOL CI2CScript::WriteSeq(UCHAR addr, UCHAR  *p_seq, USHORT len)
{

  I2CPacket     i2cPacket;
  LARGE_INTEGER liTime;

   // Init rest of I2CPacket
  i2cPacket.usFlags = I2COPERATION_WRITE;
  i2cPacket.uchChipAddress = addr;
  i2cPacket.cbReadCount = 0;
  i2cPacket.cbWriteCount = len;
  i2cPacket.puchReadBuffer = NULL;
  i2cPacket.puchWriteBuffer = p_seq;

  int counter = 0;

  // Somewhat arbitrary max of 1 second.
  while (!LockI2CProviderEx())
  {
    if (counter++ >= 100)
    {
//    ReleaseI2CProvider();
      return(FALSE);
    }

    liTime.QuadPart = 100000;
    KeDelayExecutionThread(KernelMode, FALSE, &liTime); // = 10 milliseconds
  }

  /*
  if(!CheckInterface(addr))
  {
    ReleaseI2CProvider();
    return FALSE;
  }
*/
  ExecuteI2CPacket(&i2cPacket);
  ReleaseI2CProvider();

  //DebugInfo(("CI2CScript::WriteSeq(): Inside\n"));

  if (i2cPacket.uchI2CResult != I2C_STATUS_NOERROR)
  {
       _DbgPrintF( DEBUGLVL_ERROR,("CI2CScript::WriteSeq(): Error\n"));
    return(FALSE);
  }

  return(TRUE);
}

/*
 * ReadSeq()
 * Purpose  : Read a specified number of bytes from address specified.
 *
 *
 * Inputs   :   UCHAR addr : I2CAddress
 *              UCHAR  *p_seq : sequence
 *              USHORT len    : length of the sequence
 *
 * Outputs  : BOOL - TRUE if operation succeeded else FALSE
 * Author   : MM
 *
 *
*/
BOOL CI2CScript::ReadSeq(UCHAR addr, UCHAR  *p_seq, USHORT len)
{

  I2CPacket     i2cPacket;
  LARGE_INTEGER liTime;

   // Init rest of I2CPacket
  i2cPacket.usFlags = I2COPERATION_READ;
  i2cPacket.uchChipAddress = addr;
  i2cPacket.cbReadCount = len;
  i2cPacket.cbWriteCount = 0;
  i2cPacket.puchReadBuffer = p_seq;
  i2cPacket.puchWriteBuffer = NULL;

  int counter = 0;
  // Somewhat arbitrary max of 1 second.
  while (!LockI2CProviderEx())
  {
    if (counter++ >= 100)
    {
//    ReleaseI2CProvider();
      return(FALSE);
    }

    liTime.QuadPart = 100000;
    KeDelayExecutionThread(KernelMode, FALSE, &liTime); // = 10 milliseconds
  }

  /*
 if(!CheckInterface(addr))
  {
    ReleaseI2CProvider();
    return FALSE;
  }
*/
 ExecuteI2CPacket(&i2cPacket);
  ReleaseI2CProvider();

//  DebugInfo(("CI2CScript::ReadSeq(): Inside\n"));

  if (i2cPacket.uchI2CResult != I2C_STATUS_NOERROR)
  {
    _DbgPrintF( DEBUGLVL_ERROR,("CI2CScript::ReadSeq(): Error\n"));
    return(FALSE);
  }

  return(TRUE);
}

/*
 * CombinedSeq()
 * Purpose  : Write a specified sequence and then read a specified number of
 *             bytes from address specified.
 *
 *
 * Inputs   :   UCHAR addr : I2CAddress
 *              UCHAR seqWr[] : write sequence
 *              USHORT lenWr    : length of the write sequence
 *              UCHAR seqRd[]   : read sequence
 *              USHORT lenRd    : length of the read sequence
 *
 * Outputs  : BOOL - TRUE if operation succeeded else FALSE
 * Author   : MM
 *
 *
*/

BOOL
CI2CScript::CombinedSeq(UCHAR addr, UCHAR seqWr[], USHORT lenWr, UCHAR seqRd[], USHORT lenRd)
{

 I2CPacket     i2cPacket;
 LARGE_INTEGER liTime;

  // Init rest of I2CPacket
  i2cPacket.usFlags = I2COPERATION_READWRITE;
  i2cPacket.uchChipAddress = addr;
  i2cPacket.cbReadCount = lenRd;
  i2cPacket.cbWriteCount = lenWr;
  i2cPacket.puchReadBuffer = seqRd;
  i2cPacket.puchWriteBuffer = seqWr;

  int counter = 0;
 // Somewhat arbitrary max of 1 second.
  while (!LockI2CProviderEx())
  {
    if (counter++ >= 100)
    {
//    ReleaseI2CProvider();
      return(FALSE);
    }

    liTime.QuadPart = 100000;
    KeDelayExecutionThread(KernelMode, FALSE, &liTime); // = 10 milliseconds
  }

  if(!CheckInterface(addr))
  {
    ReleaseI2CProvider();
    return FALSE;
  }

  ExecuteI2CPacket(&i2cPacket);
  ReleaseI2CProvider();

  //DebugInfo(("CI2CScript::CombinedSeq(): Inside\n"));

  if (i2cPacket.uchI2CResult != I2C_STATUS_NOERROR)
  {
    return(FALSE);
  }

  return(TRUE);
}

/*
 * CheckInterface()
 * Purpose  : Check if I2C Interface is working by reading a byte
 *            from the specified address
 *
 * Inputs   :   UCHAR addr : I2CAddress
 *
 * Outputs  : BOOL - TRUE if operation succeeded else FALSE
 * Author   : MM
 *
 *
*/

BOOL CI2CScript::CheckInterface(UCHAR addr)
{

  I2CPacket     i2cPacket;
  LARGE_INTEGER liTime;
  UCHAR ucData;

   // Init rest of I2CPacket
  i2cPacket.usFlags = I2COPERATION_READ;
  i2cPacket.uchChipAddress = addr;
  i2cPacket.cbReadCount = 1;
  i2cPacket.cbWriteCount = 0;
  i2cPacket.puchReadBuffer = &ucData;
  i2cPacket.puchWriteBuffer = NULL;


  ExecuteI2CPacket(&i2cPacket);

  if (i2cPacket.uchI2CResult != I2C_STATUS_NOERROR)
  {
    _DbgPrintF( DEBUGLVL_ERROR,("CI2CScript::CheckInterface(): Error\n"));
    return(FALSE);
  }

  return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\mauitune\medguid.h ===
#ifndef _MEDGUID_H_
#define _MEDGUID_H_

//
// Definition of Medium GUIDs used in SAA7146 WDM mini-driver and related driver
                               
#define GUID_DMSD_IN    0x328c7240, 0x2b0d, 0x11d2, 0xa4, 0xd9, 0x0, 0x60, 0x8, 0xb, 0xa6, 0x34

#define GUID_DMSD_OUT   0x328c7241, 0x2b0d, 0x11d2, 0xa4, 0xd9, 0x0, 0x60, 0x8, 0xb, 0xa6, 0x34

#define GUID_TV_VIDEO   0x328c7242, 0x2b0d, 0x11d2, 0xa4, 0xd9, 0x0, 0x60, 0x8, 0xb, 0xa6, 0x34
#define GUID_TV_AUDIO   0x328c7243, 0x2b0d, 0x11d2, 0xa4, 0xd9, 0x0, 0x60, 0x8, 0xb, 0xa6, 0x34

#define GUID_7146IN     0x328c7241, 0x2b0d, 0x11d2, 0xa4, 0xd9, 0x0, 0x60, 0x8, 0xb, 0xa6, 0x34

#define GUID_6750_OUT   0x328c7245, 0x2b0d, 0x11d2, 0xa4, 0xd9, 0x0, 0x60, 0x8, 0xb, 0xa6, 0x34
#define GUID_7146_DEBI  0x328c7245, 0x2b0d, 0x11d2, 0xa4, 0xd9, 0x0, 0x60, 0x8, 0xb, 0xa6, 0x34

// output to BRS connection (video encoder)
#define GUID_BRS_OUT    0x328c7246, 0x2b0d, 0x11d2, 0xa4, 0xd9, 0x0, 0x60, 0x8, 0xb, 0xa6, 0x34

// output to DEBI Output connection (eg MPEG Decoder)
// {BAF13000-33A7-11d3-A4D9-0060080BA634}
#define GUID_DEBI_OUT   0xbaf13000, 0x33a7, 0x11d3, 0xa4, 0xd9, 0x0, 0x60, 0x8, 0xb, 0xa6, 0x34
                        

// from jaybo
// {F3954424-34F6-11D1-821D-0000F8300212}
#define GUID_VSB_OUT    0xf3954424, 0x34f6, 0x11d1, 0x82, 0x1d, 0x0, 0x0, 0xf8, 0x30, 0x2, 0x12
#define GUID_7146XPIN   0xf3954424, 0x34f6, 0x11d1, 0x82, 0x1d, 0x0, 0x0, 0xf8, 0x30, 0x2, 0x12

#define M_NOCONNECT     0x328c7247, 0x2b0d, 0x11d2, 0xa4, 0xd9, 0x0, 0x60, 0x8, 0xb, 0xa6, 0x34

// {A7DF70A1-6452-11d2-B371-006097170118}
DEFINE_GUIDSTRUCT("A7DF70A1-6452-11d2-B371-006097170118", GUID_SEND_VIDEO_STANDARD);
#define GUID_SEND_VIDEO_STANDARD DEFINE_GUIDNAMED(GUID_SEND_VIDEO_STANDARD)


typedef struct {
    INTERFACE _vddInterface;

    // CSpciIo* returned -- declared as PVOID to avoid excessive dependency on HAL classes
    PVOID pSpciIo;
} SPCIIOINTERFACE;

// interface to obtain master CSpciIo object -- uses SPCIIOINTERFACE structure
// {5DA0C940-0884-11d3-A4D9-0060080BA634}
DEFINE_GUIDSTRUCT("5DA0C940-0884-11d3-A4D9-0060080BA634", GUID_SPCIIO_INTERFACE);
#define GUID_SPCIIO_INTERFACE DEFINE_GUIDNAMED(GUID_SPCIIO_INTERFACE)



// {548F5540-F3DC-11d2-A4D9-0060080BA634}
DEFINE_GUIDSTRUCT("548F5540-F3DC-11d2-A4D9-0060080BA634", PINNAME_DEBI_IN);
#define PINNAME_DEBI_IN DEFINE_GUIDNAMED(PINNAME_DEBI_IN)


// {0896cda0-393f-11d3-8a11-00609405306e}
DEFINE_GUIDSTRUCT("0896cda0-393f-11d3-8a11-00609405306e", GUID_IF_DISPATCHER);
#define GUID_IF_DISPATCHER DEFINE_GUIDNAMED(GUID_IF_DISPATCHER)

// {4cadb500-4419-11d3-91b2-00c04f81b56b}
DEFINE_GUIDSTRUCT("4cadb500-4419-11d3-91b2-00c04f81b56b", GUID_IF_INTERFACE);
#define GUID_IF_INTERFACE DEFINE_GUIDNAMED(GUID_IF_INTERFACE)

// {a2487ce0-5b05-11d3-91b2-00c04f81b56b}
DEFINE_GUIDSTRUCT("a2487ce0-5b05-11d3-91b2-00c04f81b56b", GUID_SEND_DIAG_INFO);
#define GUID_SEND_DIAG_INFO DEFINE_GUIDNAMED(GUID_SEND_DIAG_INFO)


#endif //_MEDGUID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\mauitune\ksvsb.h ===
//////////////////////////////////////////////////////////////////////////////
//
//                     (C) Philips Semiconductors-CSU 1999
//  All rights are reserved. Reproduction in whole or in part is prohibited
//  without the written consent of the copyright owner.
//
//  Philips reserves the right to make changes without notice at any time.
//  Philips makes no warranty, expressed, implied or statutory, including but
//  not limited to any implied warranty of merchantibility or fitness for any
//  particular purpose, or that the use will not infringe any third party
//  patent, copyright or trademark. Philips must not be liable for any loss
//  or damage arising from its use.
//
//	KSVSB.H
//		Constants and structures for the VSB which wll also be used in the 
//		user mode
//////////////////////////////////////////////////////////////////////////////

#ifndef _KSVSB_H_
#define _KSVSB_H_


#ifndef REGISTER_SETS

#define REGISTER_SETS

// Register Types
#define	CONTROL_REGISTER	0x0
#define	STATUS_REGISTER		0x1

// Register Access structures
typedef struct
{
	UINT	Address;	// Register address
	UINT	Length;		// Length
} RegisterListType;


#endif



// Coefficient IDs
#define	EQUALIZER_ID					0x2
#define	EQUALIZER_CLUSTER_ID			0x1
#define	SYNC_ENHANCER_ID				0x8
#define	NTSC_COCHANNEL_REJECTION_ID		0x4
#define	CORRELATOR_ID					0x10


// Constants for resets .
// The various resets that can be applied to VSB
#define	VSB_GENERAL_RESET			0x02
#define	VSB_INITIAL_RESET			0x01
#define	HARDWARE_RESET				0x1000

// Constants for Hang Check
#define	VSB_HANG_CHECK_ENABLE		0x1

// VSB output modes
#define	VSB_OUTPUT_MODE_NORMAL			0
#define	VSB_OUTPUT_MODE_DIAGNOSTIC		1
#define	VSB_OUTPUT_MODE_ITU656			2	// applicable only for VSB2
#define	VSB_OUTPUT_MODE_SERIAL_INPUT	3	// applicable only for VSB2
#define	VSB_OUTPUT_MODE_BYPASS			4	// applicable only for VSB1

#define VSB1_TS_OUT_MODE_MASK			0x3F
#define VSB2_TS_OUT_MODE_MASK			0xF3
#define VSB1_DIAG_MODE_MASK				0xC7
#define VSB2_DIAG_MODE_MASK				0xF0

// Register addresses

// Common
#define	VSB_REG_RESET					0x00
#define	VSB_REG_STATE					0x00


// VSB1
#define	VSB1_CTRL_REG_EQUALIZER_COEFF				0x12
#define	VSB1_STATUS_REG_EQUALIZER_COEFF				0x05

//Control Registers
#define	VSB1_REG_OUTPUT					0x02


// VSB2
// Status Registers
#define	VSB2_REG_CARRIER_OFFSET			0x01
#define	VSB2_REG_MSE_1					0x04
#define	VSB2_REG_MSE_2					0x05
#define	VSB2_REG_CORRELATOR				0x08
#define	VSB2_REG_SER_1					0x0B
#define	VSB2_REG_SER_2					0x0C

// Control registers
#define	VSB2_REG_COEFFICIENT_ENABLE		0x02
#define VSB2_REG_SYN_ENHANCER_0			0x0B
#define VSB2_REG_SYN_ENHANCER_1			0x0C
#define VSB2_REG_SYN_ENHANCER_2			0x0D
#define VSB2_REG_SYN_ENHANCER_3			0x0E
#define	VSB2_CTRL_REG_CORRELATOR		0x1F
#define VSB2_REG_TS_OUT_1				0x31
#define	VSB2_REG_DIAG_SELECT			0x34

// Coefficient registers
#define	VSB2_CTRL_REG_EQUALIZER_COEFF				0x1A
#define	VSB2_CTRL_REG_EQUALIZER_CLUSTER_COEFF		0x1E
#define	VSB2_CTRL_REG_COCHANNEL_REJECTION_COEFF		0x2E		
#define	VSB2_CTRL_REG_SYNC_ENHANCER_COEFF			0x0F

#define	VSB2_STATUS_REG_EQUALIZER_COEFF				0x06
#define	VSB2_STATUS_REG_EQUALIZER_CLUSTER_COEFF		0x07
#define	VSB2_STATUS_REG_COCHANNEL_REJECTION_COEFF	0x09
#define	VSB2_STATUS_REG_SYNC_ENHANCER_COEFF			0x02
#define	VSB2_REG_CORRELATOR_COEFF					0x0A


	
#define	MAX_VSB_BUF_SIZE			3000
#define	MAX_VSB_REGISTERS			54
#define	MAX_VSB_REG_BUF_SIZE		100
#define	MAX_COEFFICIENTS			4




// Register Access structures
typedef struct
{
	UINT	ID;			// Coefficient ID
	UINT	Length;		// Length
} CoeffListType;

// VSB Modulation scheme
typedef enum
{
	VSB8,		// VSB- 8 
	VSB16		// VSB-16
}VSBMODULATIONTYPE;

// VSB Chip type
typedef enum
{
	VSB1,		// VSB 1 (version 1)
	VSB2		// VSB 2 (version 2)
}VSBCHIPTYPE;

// Diagnostic Enumeration
typedef enum
{
	EQUALIZER_OUT = 0,
	CR_ERROR,
	TR_ERROR,
	EQUALIZER_IN,
	TRELLIS_DEC_DIAG_OUT,
	TRELLIS_DEC_OUT = 6,
	REED_SOLOMON_DIAG_OUT,
	SYNC_ENHANCER_REAL_IN,
	SRC_OUT
} VSBDIAGTYPE;

// Operation Mode enumeration
typedef enum
{
	VSB_OPERATION_MODE_DIAG,	
	VSB_OPERATION_MODE_DATA,		
	VSB_OPERATION_MODE_INVALID
} VSBDIAGOPNMODETYPE;

#define STATIC_PROPSETID_VSB\
	0xb96e0100L, 0xce52, 0x11d2, 0x8a, 0x11, 0x00, 0x60, 0x94, 0x05, 0x30, 0x6e
DEFINE_GUIDSTRUCT("b96e0100-ce52-11d2-8a11-00609405306e", PROPSETID_VSB);
#define PROPSETID_VSB DEFINE_GUIDNAMED(PROPSETID_VSB)

// The properties defined for VSB
typedef enum 
{
    KSPROPERTY_VSB_CAP,				// RW - VSB Driver Capabilities
    KSPROPERTY_VSB_REG_CTRL,		// RW - Register access control
    KSPROPERTY_VSB_COEFF_CTRL,      // RW - Coefficient access control
    KSPROPERTY_VSB_RESET_CTRL,      // RW - Reset control
	KSPROPERTY_VSB_DIAG_CTRL,		// RW - Diagnostic control
	KSPROPERTY_VSB_QUALITY_CTRL,	// W -  Quality  control . For VSB1 its hangcheck control

} KSPROPERTY_VSB;

// The Property structure for Register settings.
typedef struct
{
	UINT	NumRegisters;		// Number of registers to be written or read
	UINT	RegisterSize;		// Size of the register data in bytes
	RegisterListType  RegisterList[MAX_VSB_REGISTERS]; // List of register 
											// addresses and length
	UCHAR	Buffer[MAX_VSB_REG_BUF_SIZE]; // The buffer to be filled or passed
	UINT	RegisterType;		// Type of register (CONTROL/STATUS)
	
} KSPROPERTY_VSB_REG_CTRL_S, *PKSPROPERTY_VSB_REG_CTRL_S;

// The Property structure for Coefficient settings.
typedef struct
{
	UINT	NumRegisters;		// Number of coefficients to be written or read
	UINT	RegisterSize;		// Size of the coefficient data in bytes
	CoeffListType  CoeffList[MAX_COEFFICIENTS]; // List of register 
											// addresses and length
	UCHAR	Buffer[MAX_VSB_BUF_SIZE]; // The buffer to be filled or passed

} KSPROPERTY_VSB_COEFF_CTRL_S, *PKSPROPERTY_VSB_COEFF_CTRL_S;


// The Property structure for VSB control such as reset, disable.
typedef  struct
{
	UINT		Value;
} KSPROPERTY_VSB_CTRL_S, *PKSPROPERTY_VSB_CTRL_S;



// The Property structure for VSB capabilities
typedef  struct
{
	VSBMODULATIONTYPE Modulation;	// The modulation scheme. Currently VSB-8 but 
									// support for VSB-16
	VSBCHIPTYPE ChipVersion;   		// Chip version - 1 = VSB1, 2= VSB2
	UINT		BoardID;			// Board ID.
} KSPROPERTY_VSB_CAP_S, *PKSPROPERTY_VSB_CAP_S;

// The Property structure for VSB diagnostic ontrol
typedef  struct
{
	ULONG OperationMode;	// The operation mode (enumeration VSBDIAGOPNMODETYPE)
	ULONG Type;   			// Diagnostic type (enumeration VSBDIAGTYPE)
} KSPROPERTY_VSB_DIAG_CTRL_S, *PKSPROPERTY_VSB_DIAG_CTRL_S;

#endif // _KSVSB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\mauitune\mpoc.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//                     (C) Philips Semiconductors 1998
//  All rights are reserved. Reproduction in whole or in part is prohibited
//  without the written consent of the copyright owner.
//
//  Philips reserves the right to make changes without notice at any time.
//  Philips makes no warranty, expressed, implied or statutory, including but
//  not limited to any implied warranty of merchantibility or fitness for any
//  particular purpose, or that the use will not infringe any third party
//  patent, copyright or trademark. Philips must not be liable for any loss
//  or damage arising from its use.
//
//  MPOC.CPP
//  Implementation for MPOC
//////////////////////////////////////////////////////////////////////////////

#include "philtune.h"
#include "mpoc.h"
#include "wdmdebug.h"




UCHAR MpocInitArray[] =
{
    0x20,   // 1D
    0x20,   // 1E
    0x1F,   // 1F
    0x00,   // 20
    0x00,   // 21
    0x00,   // 22
    0x00,   // 23
    0x00,   // 24
    0x00,   // 25
    0x00,   // 26
    0x10,   // 27
    0x12,   // 28
    0x00,   // 29
    0x13,   // 2A
    0x00,   // 2B
    0x00,   // 2C
    0x00,   // 2D
    0x00,   // 2E
};

/*
* MpocInit()
* Input
* Output :  TRUE - mode initialization succeeds
*           FALSE - if there is an I2C error
* Description: Initialize MPOC registers
*/
NTSTATUS CDevice::MpocInit()
{
    NTSTATUS Status = STATUS_SUCCESS;

    _DbgPrintF( DEBUGLVL_VERBOSE,("CDevice::MPOCInit(): Inside\n"));
    m_MpocRegisters.reg_set.offset = MPOC_CONTROL_REG_OFFSET;
    MemoryCopy(m_MpocRegisters.reg_set.buffer, &MpocInitArray, sizeof(MpocInitArray));
    if(!m_pI2CScript->WriteSeq(MPOC_I2C_ADDRESS, (UCHAR *)(m_MpocRegisters.array), sizeof(MpocInitArray)+1))
    {   
        _DbgPrintF( DEBUGLVL_ERROR,("CDevice: MPOC Initialize failed"));
        return STATUS_ADAPTER_HARDWARE_ERROR;
    }
    return STATUS_SUCCESS;
}

/*
* SetMpocIFMode()
* Input
* Output :  TRUE - mode initialization succeeds
*           FALSE - if there is an I2C error
* Description: Set IF Mpode on MPOC
*/
NTSTATUS CDevice::SetMpocIFMode(ULONG ulMode)
{
    NTSTATUS Status = STATUS_SUCCESS;
    UCHAR ucBuffer;

    _DbgPrintF( DEBUGLVL_VERBOSE,("CDevice::MPOCSetMode(): Inside\n"));
    ucBuffer = m_MpocRegisters.reg_set.buffer[MPOC_CONTROL_REG_VIDEO_ADC - MPOC_CONTROL_REG_OFFSET];
    ucBuffer &= 0xF8;
    
    if(ulMode == (ULONG)KSPROPERTY_TUNER_MODE_ATSC)
    {
        // Set the appropriate bits based on the Output ( this corresponds
        // directly to the bits to be set for Video ADC output)
        if(m_BoardInfo.uiMpocVersion < 4)
        {
            ucBuffer |= MPOC_VIDEOADC_VSBI;
        }
        else
        {
            // 1/25/2000 . Versions >= N1D have the VSB-1 value shifted
            // by 1 (register value changes)
            ucBuffer |= MPOC_VIDEOADC_VSBIQ;
        }
        m_MpocRegisters.reg_set.buffer[MPOC_CONTROL_REG_VIDEO_ADC- MPOC_CONTROL_REG_OFFSET] = ucBuffer;
        // Set AGC to external mode
        m_MpocRegisters.reg_set.buffer[MPOC_CONTROL_REG_VISION_IF_1 - MPOC_CONTROL_REG_OFFSET] |= EXTERNAL_AGC;
    }
    else if(ulMode == (ULONG)KSPROPERTY_TUNER_MODE_TV)
    {

        // Set the appropriate bits based on the Output ( this corresponds
        // directly to the bits to be set for Video ADC output)
        ucBuffer |= MPOC_VIDEOADC_TV27;
        m_MpocRegisters.reg_set.buffer[MPOC_CONTROL_REG_VIDEO_ADC- MPOC_CONTROL_REG_OFFSET] = ucBuffer;
        if(m_BoardInfo.uiMpocVersion >= 4)
        {
            m_MpocRegisters.reg_set.buffer[MPOC_CONTROL_REG_VISION_IF_0 - MPOC_CONTROL_REG_OFFSET] |=
                    MPOC_PLL_IF_FREQ_45_POINT_75;
        }
        // Set AGC to external mode
        m_MpocRegisters.reg_set.buffer[MPOC_CONTROL_REG_VISION_IF_1 - MPOC_CONTROL_REG_OFFSET] &= ~EXTERNAL_AGC;
    }   
    else {}

    if(!m_pI2CScript->WriteSeq(MPOC_I2C_ADDRESS, (UCHAR *)(m_MpocRegisters.array), sizeof(m_MpocRegisters.array)))
    {   
        _DbgPrintF( DEBUGLVL_ERROR,("CDevice: SetIFMode: MPOC Write failed"));
        return STATUS_ADAPTER_HARDWARE_ERROR;
    }
    return STATUS_SUCCESS;
}

/*
* GetMpocVersion()
* Input:
* Output:
* Description: Get MPOC version number
*/
NTSTATUS CDevice::GetMpocVersion(UINT *p_version)
{

    // Read EEPROM for version number
    // MPOC version number is in register 0xFC of EEPROM at address 0xA6
    // Version  N1A - 1
    //          N1B - 2
    //          N1C - 3
    //          N1D - 4
    //          N1F - 6

    UCHAR   ucStartAddr = 0xFC;
    UCHAR   ucVersion = 4;
    NTSTATUS Status = STATUS_SUCCESS;

    if(!m_pI2CScript->WriteSeq(BOARD_EEPROM_ADDRESS, &ucStartAddr, 1))
    {
        Status = STATUS_ADAPTER_HARDWARE_ERROR;
        // Set default version to N1D
        ucVersion = 4;
    }

    if(!m_pI2CScript->ReadSeq(BOARD_EEPROM_ADDRESS, &ucVersion, 1))
    {
        Status = STATUS_ADAPTER_HARDWARE_ERROR;
        // Set default version to N1D
        ucVersion = 4;
    }

    //Mini: Test
    //ucVersion = 6;
    *p_version = (UINT)(ucVersion);
    _DbgPrintF( DEBUGLVL_VERBOSE,("CDevice :MPOC Version = %x \n", ucVersion));
    return Status;
}




/*
* GetMpocIFStatus()
* Input:
* Output:
* Description:
*/
NTSTATUS CDevice::GetMpocStatus(UINT StatusType, UINT *puiStatus)
{
    UCHAR ucBuffer[MAX_MPOC_STATUS_REGISTERS];

    if(!m_pI2CScript->ReadSeq(MPOC_I2C_ADDRESS, ucBuffer, MAX_MPOC_STATUS_REGISTERS))
    {   
        _DbgPrintF( DEBUGLVL_ERROR,("CDevice: MPOC Read failed"));
        return STATUS_ADAPTER_HARDWARE_ERROR;
    }

    switch (StatusType)
    {
    case MPOC_STATUS_IF_PLL_LOCK:
        // Bit 5 of status register 0
        *puiStatus = (ucBuffer[MPOC_STATUS_REG_0] & 0x20) ? 1 : 0;
        break;

    case MPOC_STATUS_PHASE_LOCK:
        // Bit 4 of status register 0
        *puiStatus = (ucBuffer[MPOC_STATUS_REG_0] & 0x10) ? 1 : 0;
        break;

    case MPOC_STATUS_PLL_OFFSET:
        // Bits 3 and 2 of status register 2
        *puiStatus = (ucBuffer[MPOC_STATUS_REG_2] & 0x0c) >> 2;
        break;

    default:
        return STATUS_INVALID_PARAMETER;
        break;
    }
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\mauitune\i2script.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//  I2CSCRPT.H
//  I2CScript class definitions.
//      Main Include Module.
//==========================================================================;

#ifndef _I2CSCRPT_H_
#define _I2CSCRPT_H_


//#include "i2c.h"
#include "i2cgpio.h"


#define I2CSCRIPT_LENGTH_MAXIMUM    100
#define I2C_FIXED_CLOCK_RATE        10000


// The I2CScript is build from the following primitives
typedef struct tagI2CScriptPrimitive
{
    BYTE    byData;             // Data to be used in the I2C operation
    BYTE    byORData;           // Data to be used for a logical OR operation
    BYTE    byANDData;          // Data to be used for a logical AND operation
    BYTE    byFlags;            // implementation specific internal Script flags for I2C operation
    ULONG   ulProviderFlags;    // I2CProvider specific flags
    ULONG   ulCommand;          // I2CProvider specific command

} I2CScriptPrimitive, * PI2CScriptPrimitive;

typedef struct
{
    UCHAR uchModifyORValue;
    UCHAR uchModifyANDValue;

} I2C_MODIFY_VALUES, * PI2C_MODIFY_VALUES;

// New I2CScript control structure - extension to the old I2C access structure
typedef struct tagI2CPacket
{
    UCHAR   uchChipAddress;     // I2C Address
    UCHAR   uchI2CResult;       // valid in synchronous operation only
    USHORT  cbWriteCount;       // bytes to write ( included SubAddress, if exist)
    USHORT  cbReadCount;        // bytes to read ( usually one)
    USHORT  usFlags;            // describes the desired operation
    PUCHAR  puchWriteBuffer;    // buffer to write
    PUCHAR  puchReadBuffer;     // buffer to read
    UCHAR   uchORValue;         // applied only in Read-Modify-Write cycle
    UCHAR   uchANDValue;        // applied only in Read-Modify-Write cycle
    USHORT  usReserved;         //

} I2CPacket, * PI2CPacket;

// possible flags applied to usFlags
#define I2COPERATION_READ           0x0001  // might not be needed - use bcReadCount
#define I2COPERATION_WRITE          0x0002  // might be not needed - use bcReadCount
#define I2COPERATION_READWRITE      0x0004  
#define I2COPERATION_RANDOMACCESS   0x0100  // to indicate 16 bits emulation to provide
                                            // built-in support for ITT decoder and ST24 series
                                            // of I2C driven EEPROM

extern "C"
{
typedef VOID (__stdcall * PHWCompletionRoutine)( IN PIRP pIrp);
}

class CI2CScript
{
public:
    CI2CScript              ( PDEVICE_OBJECT pDeviceObject, NTSTATUS * pStatus);
//  PVOID operator new      ( UINT size_t, PVOID pAllocation);

// Attributes   
public:
    
private:
    // I2C Provider related
    I2CINTERFACE                m_i2cProviderInterface;
    PDEVICE_OBJECT              m_pdoDriver;
    ULONG                       m_ulI2CAccessClockRate;
    DWORD                       m_dwI2CAccessKey;
    LARGE_INTEGER               m_liOperationStartTime;

    // I2CScript management related
    BOOL                        m_bExecutionInProcess;
    UINT                        m_nExecutionIndex;
    UINT                        m_nCompletionIndex;
    UINT                        m_nScriptLength;
    PHWCompletionRoutine        m_pfnReturnWhenDone;
    I2CScriptPrimitive          m_i2cScript[I2CSCRIPT_LENGTH_MAXIMUM];

// Implementation
public:
    BOOL    LockI2CProviderEx               ( void);
    BOOL    ReleaseI2CProvider              ( void);

    BOOL    ExecuteI2CPacket                ( IN OUT PI2CPacket);
    BOOL    PerformI2CPacketOperation       ( IN OUT PI2CPacket pI2CPacket);

    BOOL    AppendToScript                  ( IN PI2CPacket);
    void    ClearScript                     ( void);
    BOOL    ExecuteScript                   ( IN PIRP                   pIrp,
                                              IN PHWCompletionRoutine   pfnScriptCompletion);
    void    InterpreterScript               ( void);
    UINT    GetScriptResults                ( PUINT puiReadCount, PUCHAR puchReadBuffer);
	BOOL	CombinedSeq(UCHAR addr, UCHAR seqWr[], USHORT lenWr, UCHAR seqRd[], USHORT lenRd);
	BOOL	ReadSeq(UCHAR addr, UCHAR  *p_seq, USHORT len) ;
	BOOL	WriteSeq(UCHAR addr, UCHAR  *p_seq, USHORT len) ;

private:
    BOOL    LockI2CProvider                 ( void);
    UINT    AccessI2CProvider               ( PDEVICE_OBJECT pdoClient, PI2CControl pi2cAccessBlock);
    BOOL    InitializeAttachI2CProvider     ( I2CINTERFACE * pI2CInterface, PDEVICE_OBJECT pDeviceObject);
    BOOL    LocateAttachI2CProvider         ( I2CINTERFACE * pI2CInterface, PDEVICE_OBJECT pDeviceObject, int nIrpMajorFunction);
    UINT    CheckI2CScriptPacket            ( IN PI2CPacket pI2CPacket);
    BOOL    GetI2CProviderLockStatus        ( void);
	BOOL	CheckInterface(UCHAR addr) ;
};


extern "C"
NTSTATUS I2CScriptIoSynchCompletionRoutine  ( IN PDEVICE_OBJECT pDeviceObject,
                                              IN PIRP pIrp,
                                              IN PVOID Event);

// errors definition for internal use
#define I2CSCRIPT_NOERROR               0x00
#define I2CSCRIPT_ERROR_NOPROVIDER      0x01
#define I2CSCRIPT_ERROR_NODATA          0x02
#define I2CSCRIPT_ERROR_NOBUFFER        0x03
#define I2CSCRIPT_ERROR_READWRITE       0x04
#define I2CSCRIPT_ERROR_OVERFLOW        0x05

// time definitions
#define I2CSCRIPT_DELAY_OPENPROVIDER        -2000
#define I2CSCRIPT_DELAY_GETPROVIDERSTATUS   -2000

// time limits
#define I2CSCRIPT_TIMELIMIT_OPENPROVIDER    50000000    // 5 seconds in 100 nsec.


#endif  // _I2CSCRPT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\mauitune\mpoc.h ===
//////////////////////////////////////////////////////////////////////////////
//
//                     (C) Philips Semiconductors 1998
//  All rights are reserved. Reproduction in whole or in part is prohibited
//  without the written consent of the copyright owner.
//
//  Philips reserves the right to make changes without notice at any time.
//  Philips makes no warranty, expressed, implied or statutory, including but
//  not limited to any implied warranty of merchantibility or fitness for any
//  particular purpose, or that the use will not infringe any third party
//  patent, copyright or trademark. Philips must not be liable for any loss
//  or damage arising from its use.
//
//  MPOC.H
//  Constants for MPOC
//////////////////////////////////////////////////////////////////////////////


#ifndef _MPOC_H_
#define _MPOC_H_


#define MAX_MPOC_CONTROL_REGISTERS  18
#define MAX_MPOC_STATUS_REGISTERS   4


// I2C Address
#define MPOC_I2C_ADDRESS                    0x8A


// Control registers
#define MPOC_CONTROL_REG_OFFSET             0x1D
#define MPOC_CONTROL_REG_AGCTAKEOVER        0x1E
#define MPOC_CONTROL_REG_HUE                0x1F
#define MPOC_CONTROL_REG_COLOR_DECODER_0    0x20
#define MPOC_CONTROL_REG_COLOR_DECODER_1    0x21
#define MPOC_CONTROL_REG_VIDEO_SWITCH       0x22
#define MPOC_CONTROL_REG_AUDIO_SWITCH       0x23
#define MPOC_CONTROL_REG_SYNC_0             0x24
#define MPOC_CONTROL_REG_SYNC_1             0x25
#define MPOC_CONTROL_REG_SOUND              0x26
#define MPOC_CONTROL_REG_VISION_IF_0        0x27
#define MPOC_CONTROL_REG_VISION_IF_1        0x28
#define MPOC_CONTROL_REG_VIDEO_CONTROL      0x29
#define MPOC_CONTROL_REG_VIDEO_ADC          0x2A
#define MPOC_CONTROL_REG_SPARE              0x2B
#define MPOC_CONTROL_REG_AUDIO_ADC          0x2C
#define MPOC_CONTROL_REG_FEATURES           0x2D
#define MPOC_CONTROL_REG_IO                 0x2E


// Status registers
#define MPOC_STATUS_REG_0                   0x00


#define MPOC_STATUS_REG_1                   0x01
#define MPOC_STATUS_REG_2                   0x02
#define MPOC_STATUS_REG_3                   0x03



#define VIDEO   0x1
#define AUDIO   0x2

#define MAX_AUDIO_SOURCES   0x6
#define MAX_SOURCES         0xB
#define MAX_VIDEO_SOURCES   0x5

#define EXTERNAL_AGC        0x10

// PLL demodulator setting frequency for N1D and above
// 1/25/2000
#define MPOC_PLL_IF_FREQ_58_POINT_75    0x00
#define MPOC_PLL_IF_FREQ_45_POINT_75    0x20
#define MPOC_PLL_IF_FREQ_38_POINT_90    0x40
#define MPOC_PLL_IF_FREQ_38_POINT_00    0x60
#define MPOC_PLL_IF_FREQ_33_POINT_40    0x80
#define MPOC_PLL_IF_FREQ_33_POINT_90    0xc0

typedef enum
{
    MPOC_SRC_COMPOSITE,
    MPOC_SRC_SVHS,
    MPOC_SRC_TUNER,
    MPOC_SRC_RGB,
    MPOC_SRC_DVD,
    MPOC_SRC_AUDIO_STEREO,
    MPOC_SRC_AUDIO_EXT

} MPOC_SRC_ENUM;


typedef enum
{
    MPOC_STATUS_VIDEO_IDENT,
    MPOC_STATUS_IF_PLL_LOCK,
    MPOC_STATUS_PHASE_LOCK,
    MPOC_STATUS_COLOR_IDENT,
    MPOC_STATUS_STANDARD_VIDEO,
    MPOC_STATUS_REF_OSC_LOCK,
    MPOC_STATUS_SUPPLIES_OK,
    MPOC_STATUS_AGC,
    MPOC_STATUS_RGB_INSERT,
    MPOC_STATUS_PLL_OFFSET,
    MPOC_STATUS_FM_PLL_WINDOW,
    MPOC_STATUS_FM_PLL_LOCK,
    // Additional status bits for N1D and above
    // 1/25/2000
    MPOC_STATUS_MACROVISION_SIG,
    MPOC_STATUS_IO

}MPOC_STATUSTYPE_ENUM;

// MPOC Video ADC mode enumeration
typedef enum
{
    MPOC_VIDEOADC_TV27,
    MPOC_VIDEOADC_TV32,
    MPOC_VIDEOADC_TV36,
    MPOC_VIDEOADC_VSBI,
    MPOC_VIDEOADC_VSBIQ,
    MPOC_VIDEOADC_EXT1,
    MPOC_VIDEOADC_EXT2,
    MPOC_VIDEOADC_SVGA

}MPOC_VIDEOADC_MODE_ENUM;


typedef union
{
    struct
    {
        char offset;
        char buffer[MAX_MPOC_CONTROL_REGISTERS];
    }reg_set;
    char array[MAX_MPOC_CONTROL_REGISTERS+1];
}Register;


#endif // _MPOC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\mauitune\objdesc.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    ObjDesc.cpp

Abstract:

    Static object description data structures.

    This file includes initial descriptors for all filter, pin, and node
    objects exposed by this driver.  It also include descriptors for the
    properties, methods, and events on those objects.

--*/

#include "PhilTune.h"

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA


//===========================================================================
//
//  Node  definitions
//
//  Nodes are special in that, though they are defined at the filter level,
//  they are actually associated with a pin type.  The filter's node
//  descriptor list is actually a list of node types.
//
//  You will notice that the dispatch routines actually point to
//  pin specific methods.  This is because the context data associated with
//  a node is stored in the pin context.
//
//  Node properties and methods should only be used on the appropriate
//  pin.
//
//===========================================================================


//===========================================================================
//
//  RF Tuner Node  definitions
//
//  This structure defines the Properties, Methods, and Events
//  available on the BDA RF Tuner Node.
//
//  The properties are used to set the center frequency and frequency range
//  as well as to report signal strength.
//
//  This node is associated with an antenna input pin and thus the node
//  properties should be set/put using the antenna input pin.
//
//===========================================================================


//
//  BDA RF Tune Frequency Filter
//
//  Defines the dispatch routines for the Frequency Filter Properties
//  on the RF Tuner Node
//
DEFINE_KSPROPERTY_TABLE(RFNodeFrequencyProperties)
{
    DEFINE_KSPROPERTY_ITEM_BDA_RF_TUNER_FREQUENCY(
        CAntennaPin::GetCenterFrequency,
        CAntennaPin::PutCenterFrequency
        ),
    DEFINE_KSPROPERTY_ITEM_BDA_RF_TUNER_POLARITY(
        NULL, NULL
        ),
    DEFINE_KSPROPERTY_ITEM_BDA_RF_TUNER_RANGE(
        NULL, NULL
        ),
    DEFINE_KSPROPERTY_ITEM_BDA_RF_TUNER_TRANSPONDER(
        NULL, NULL
        ),
};


//
//  RF Tuner Node Property Sets supported
//
//  This table defines all property sets supported by the
//  RF Tuner Node associated with the antenna input pin.
//
DEFINE_KSPROPERTY_SET_TABLE(RFNodePropertySets)
{
    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_BdaFrequencyFilter,            // Set
        SIZEOF_ARRAY(RFNodeFrequencyProperties),    // PropertiesCount
        RFNodeFrequencyProperties,                  // PropertyItems
        0,                                          // FastIoCount
        NULL                                        // FastIoTable
    )
};


//
//  Radio Frequency Tuner Node Automation Table
//
//
DEFINE_KSAUTOMATION_TABLE(RFTunerNodeAutomation) {
    DEFINE_KSAUTOMATION_PROPERTIES( RFNodePropertySets),
    DEFINE_KSAUTOMATION_METHODS_NULL,
    DEFINE_KSAUTOMATION_EVENTS_NULL
};


//===========================================================================
//
//  QAM Demodulator Node  definitions
//
//  This structure defines the Properties, Methods, and Events
//  available on the BDA QAM Demodulator Node.
//
//  This node is associated with a transport output pin and thus the node
//  properties should be set/put using the transport output pin.
//
//===========================================================================


//
//  QAM Demodulator Node Automation Table
//
//  This structure defines the Properties, Methods, and Events
//  available on the BDA QAM Demodulator Node.
//  These are used to set the symbol rate, and Viterbi rate,
//  as well as to report signal lock and signal quality.
//
DEFINE_KSAUTOMATION_TABLE(QAMDemodulatorNodeAutomation) {
    DEFINE_KSAUTOMATION_PROPERTIES_NULL,
    DEFINE_KSAUTOMATION_METHODS_NULL,
    DEFINE_KSAUTOMATION_EVENTS_NULL
};


//===========================================================================
//
//  8VSB Demodulator Node  definitions
//
//  This structure defines the Properties, Methods, and Events
//  available on the BDA 8VSB Demodulator Node.
//
//  This node is associated with a transport output pin and thus the node
//  properties should be set/put using the transport output pin.
//
//===========================================================================


//
//  8VSB BDA Autodemodulate Properties
//
//  Defines the dispatch routines for the Autodemodulate
//  on the 8VSB demodulator node.
//
DEFINE_KSPROPERTY_TABLE(VSB8NodeAutoDemodProperties)
{
    DEFINE_KSPROPERTY_ITEM_BDA_AUTODEMODULATE_START(
        NULL,
        CTransportPin::StartDemodulation
        ),
    DEFINE_KSPROPERTY_ITEM_BDA_AUTODEMODULATE_STOP(
        NULL,
        CTransportPin::StopDemodulation
        )
};



// Define VSB property Table
//
//  This is a private property set associated with the 8VSB node.
//  In this example it is used as a filter property set.
//
DEFINE_KSPROPERTY_TABLE (VSBProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
      KSPROPERTY_VSB_CAP,                   // 1
      CFilter::GetVsbCapabilitiesProperty,  // GetSupported or Handler
      sizeof(KSPROPERTY),                   // MinProperty
      sizeof(KSPROPERTY_VSB_CAP_S),         // MinData
      CFilter::SetVsbCapabilitiesProperty,  // SetSupported or Handler
      NULL,                                 // Values
      0,                                    // RelationsCount
      NULL,                                 // Relations
      NULL,                                 // SupportHandler
      0                                     // SerializedSize
    ),

    DEFINE_KSPROPERTY_ITEM
    (
      KSPROPERTY_VSB_REG_CTRL,              // 2
      CFilter::GetVsbRegisterProperty,      // GetSupported or Handler
      sizeof(KSPROPERTY),                   // MinProperty
      sizeof(KSPROPERTY_VSB_REG_CTRL_S),    // MinData
      CFilter::SetVsbRegisterProperty,      // SetSupported or Handler
      NULL,                                 // Values
      0,                                    // RelationsCount
      NULL,                                 // Relations
      NULL,                                 // SupportHandler
      0                                     // SerializedSize
    ),

    DEFINE_KSPROPERTY_ITEM
    (
      KSPROPERTY_VSB_COEFF_CTRL,            // 3
      CFilter::GetVsbCoefficientProperty,   // GetSupported or Handler
      sizeof(KSPROPERTY),                   // MinProperty
      sizeof(KSPROPERTY_VSB_COEFF_CTRL_S),  // MinData
      CFilter::SetVsbCoefficientProperty,   // SetSupported or Handler
      NULL,                                 // Values
      0,                                    // RelationsCount
      NULL,                                 // Relations
      NULL,                                 // SupportHandler
      0                                     // SerializedSize
    ),

    DEFINE_KSPROPERTY_ITEM
    (
      KSPROPERTY_VSB_RESET_CTRL,            // 4
      FALSE,                                // GetSupported or Handler
      sizeof(KSPROPERTY),                   // MinProperty
      sizeof(KSPROPERTY_VSB_CTRL_S),        // MinData
      CFilter::SetVsbResetProperty,         // SetSupported or Handler
      NULL,                                 // Values
      0,                                    // RelationsCount
      NULL,                                 // Relations
      NULL,                                 // SupportHandler
      0                                     // SerializedSize
    ),

    DEFINE_KSPROPERTY_ITEM
    (
      KSPROPERTY_VSB_DIAG_CTRL,             // 5
      CFilter::GetVsbDiagControlProperty,   // GetSupported or Handler
      sizeof(KSPROPERTY),                   // MinProperty
      sizeof(KSPROPERTY_VSB_DIAG_CTRL_S),   // MinData
      CFilter::SetVsbDiagControlProperty,   // SetSupported or Handler
      NULL,                                 // Values
      0,                                    // RelationsCount
      NULL,                                 // Relations
      NULL,                                 // SupportHandler
      0                                     // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
      KSPROPERTY_VSB_QUALITY_CTRL,          // 6
      FALSE,                                // GetSupported or Handler
      sizeof(KSPROPERTY),                   // MinProperty
      sizeof(KSPROPERTY_VSB_CTRL_S),        // MinData
      CFilter::SetVsbQualityControlProperty,// SetSupported or Handler
      NULL,                                 // Values
      0,                                    // RelationsCount
      NULL,                                 // Relations
      NULL,                                 // SupportHandler
      0                                     // SerializedSize
    ),
};


//
//  8VSB Demodulator Node Property Sets supported
//
//  This table defines all property sets supported by the
//  8VSB Demodulator Node associated with the transport output pin.
//
DEFINE_KSPROPERTY_SET_TABLE(VSB8NodePropertySets)
{
    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_BdaAutodemodulate,             // Set
        SIZEOF_ARRAY(VSB8NodeAutoDemodProperties),   // PropertiesCount
        VSB8NodeAutoDemodProperties,                 // PropertyItems
        0,                                          // FastIoCount
        NULL                                        // FastIoTable
    )};


//
//  VSB8 Demodulator Node Automation Table
//
//  This structure defines the Properties, Methods, and Events
//  available on the BDA 8VSB Demodulator Node.
//  These are used to set the symbol rate, and Viterbi rate,
//  as well as to report signal lock and signal quality.
//
DEFINE_KSAUTOMATION_TABLE(VSB8DemodulatorNodeAutomation) {
    DEFINE_KSAUTOMATION_PROPERTIES( VSB8NodePropertySets),
    DEFINE_KSAUTOMATION_METHODS_NULL,
    DEFINE_KSAUTOMATION_EVENTS_NULL
};


//===========================================================================
//
//  Antenna Pin Definitions
//
//===========================================================================


//
//  Antenna Pin Property Sets supported
//
//  This table defines all property sets supported by the
//  antenna input pin exposed by this filter.
//
DEFINE_KSPROPERTY_SET_TABLE(AntennaPropertySets)
{
    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_BdaFrequencyFilter,            // Set
        SIZEOF_ARRAY(RFNodeFrequencyProperties),    // PropertiesCount
        RFNodeFrequencyProperties,                  // PropertyItems
        0,                                          // FastIoCount
        NULL                                        // FastIoTable
    )
};


//
//  Antenna Pin Automation Table
//
//  Lists all Property, Method, and Event Set tables for the antenna pin
//
DEFINE_KSAUTOMATION_TABLE(AntennaAutomation) {
    DEFINE_KSAUTOMATION_PROPERTIES(AntennaPropertySets),
    DEFINE_KSAUTOMATION_METHODS_NULL,
    DEFINE_KSAUTOMATION_EVENTS_NULL
};


//
//  Dispatch Table for the Antenna Input Pin
//
//  This pin does not process any data.  A connection
//  on this pin enables the driver to determine which
//  Tuning Space is connected to the input.  This information
//  may then be used to select a physical antenna jack
//  on the card.
//
const
KSPIN_DISPATCH
AntennaPinDispatch =
{
    CAntennaPin::PinCreate,               // Create
    CAntennaPin::PinClose,                // Close
    NULL,               // Process
    NULL,               // Reset
    NULL,               // SetDataFormat
    CAntennaPin::PinSetDeviceState,   // SetDeviceState
    NULL,               // Connect
    NULL,               // Disconnect
    NULL,               // Clock
    NULL                // Allocator
};


//
//  Format of an Antenna Connection
//
//  Used when connecting the antenna input pin to the Network Provider.
//
const KS_DATARANGE_BDA_ANTENNA AntennaPinRange =
{
   // KSDATARANGE
    {
        sizeof( KS_DATARANGE_BDA_ANTENNA), // FormatSize
        0,                                 // Flags - (N/A)
        0,                                 // SampleSize - (N/A)
        0,                                 // Reserved
        { STATIC_KSDATAFORMAT_TYPE_BDA_ANTENNA },  // MajorFormat
        { STATIC_KSDATAFORMAT_SUBTYPE_NONE },  // SubFormat
        { STATIC_KSDATAFORMAT_SPECIFIER_NONE } // Specifier
    }
};

//  Format Ranges of Antenna Input Pin.
//
static PKSDATAFORMAT AntennaPinRanges[] =
{
    (PKSDATAFORMAT) &AntennaPinRange,

    // Add more formats here if additional antenna signal formats are supported.
    //
};


//===========================================================================
//
//  Tranport Pin Definitions
//
//===========================================================================


//
//  Transport Pin Automation Table
//
//  Lists all Property, Method, and Event Set tables for the transport pin
//
DEFINE_KSAUTOMATION_TABLE(TransportAutomation) {
    DEFINE_KSAUTOMATION_PROPERTIES_NULL,
    DEFINE_KSAUTOMATION_METHODS_NULL,
    DEFINE_KSAUTOMATION_EVENTS_NULL
};


//
//  Dispatch Table for the ATSC transport Output pin.
//
//  Since data on the transport is actually delivered to the
//  PCI bridge in hardware, this pin does not need to process
//  data.
//
//  Connection of, and state transitions on, this pin help the
//  driver to determine when to allocate hardware resources for
//  the tuner and demodulator.
//
const
KSPIN_DISPATCH
TransportPinDispatch =
{
    CTransportPin::PinCreate,           // Create
    NULL,                               // Close
    NULL,                               // Process
    NULL,                               // Reset
    NULL,                               // SetDataFormat
    PinSetDeviceState,  // SetDeviceState
    NULL,                               // Connect
    NULL,                               // Disconnect
    NULL,                               // Clock
    NULL                                // Allocator
};


//
//  Format of an ATSC Transport Stream Connection
//
//  Used to connect the Transport Stream output pin to the
//  Capture Filter.
//
#ifdef NEW_BDA_TRANSPORT_FORMAT
const KS_DATARANGE_BDA_TRANSPORT TransportPinRange =
{
   // KSDATARANGE
    {
        sizeof( KS_DATARANGE_BDA_TRANSPORT),               // FormatSize
        0,                                                 // Flags - (N/A)
        0,                                                 // SampleSize - (N/A)
        0,                                                 // Reserved
        { STATIC_KSDATAFORMAT_TYPE_STREAM },               // MajorFormat
        { STATIC_KSDATAFORMAT_TYPE_MPEG2_TRANSPORT },      // SubFormat
        { STATIC_KSDATAFORMAT_SPECIFIER_BDA_TRANSPORT }    // Specifier
    },
    //  BDA_TRANSPORT_INFO
    {
        188,        //  ulcbPhyiscalPacket
        312 * 188,  //  ulcbPhyiscalFrame
        0,          //  ulcbPhyiscalFrameAlignment (no requirement)
        0           //  AvgTimePerFrame (not known)
    }

};
#else
const KS_DATARANGE_ANALOGVIDEO TransportPinRange =
{
    // KS_DATARANGE_ANALOGVIDEO
    {
        sizeof (KS_DATARANGE_ANALOGVIDEO),      // FormatSize
        0,                                      // Flags
        sizeof (KS_TVTUNER_CHANGE_INFO),        // SampleSize
        0,                                      // Reserved

        STATIC_KSDATAFORMAT_TYPE_ANALOGVIDEO,   // aka MEDIATYPE_AnalogVideo
        STATIC_KSDATAFORMAT_SUBTYPE_NONE,
        STATIC_KSDATAFORMAT_SPECIFIER_ANALOGVIDEO, // aka FORMAT_AnalogVideo
    },
    // KS_ANALOGVIDEOINFO
    {
        0, 0, 720, 480,         // rcSource;
        0, 0, 720, 480,         // rcTarget;
        720,                    // dwActiveWidth;
        480,                    // dwActiveHeight;
        0,                      // REFERENCE_TIME  AvgTimePerFrame;
    }
};
#endif // NEW_BDA_TRANSPORT_FORMAT

//  Format Ranges of Transport Output Pin.
//
static PKSDATAFORMAT TransportPinRanges[] =
{
    (PKSDATAFORMAT) &TransportPinRange,

    // Add more formats here if additional transport formats are supported.
    //
};

//  Medium GUIDs for the Transport Output Pin.
//
//  This insures contection to the correct Capture Filter pin.
//
const KSPIN_MEDIUM TransportPinMedium =
{
    GUID_7146XPIN, 0, 0
};


//===========================================================================
//
//  Filter  definitions
//
//===========================================================================


//
//  Template Node Descriptors
//
//  This array describes all Node Types available in the template
//  topology of the filter.
//
const
KSNODE_DESCRIPTOR
NodeDescriptors[] =
{
    {
        &RFTunerNodeAutomation,         // PKSAUTOMATION_TABLE AutomationTable;
        &KSNODE_BDA_RF_TUNER,           // Type
        NULL    // Name
    },
    {
        &VSB8DemodulatorNodeAutomation,  // PKSAUTOMATION_TABLE AutomationTable;
        &KSNODE_BDA_8VSB_DEMODULATOR,    // Type
        NULL    // Name
    }
};


//
//  Initial Pin Descriptors
//
//  This data structure defines the pins that will appear on the filer
//  when it is first created.
//
const
KSPIN_DESCRIPTOR_EX
InitialPinDescriptors[] =
{
    //  Antenna Pin
    //
    {
        &AntennaPinDispatch,
        &AntennaAutomation,   // AntennaPinAutomation
        {
            0,  // Interfaces
            NULL,
            0,  // Mediums
            NULL,
            SIZEOF_ARRAY(AntennaPinRanges),
            AntennaPinRanges,
            KSPIN_DATAFLOW_IN,
            KSPIN_COMMUNICATION_BOTH,
            NULL,   // Name
            NULL,   // Category
            0
        },
        KSPIN_FLAG_DO_NOT_USE_STANDARD_TRANSPORT | KSPIN_FLAG_FRAMES_NOT_REQUIRED_FOR_PROCESSING | KSPIN_FLAG_FIXED_FORMAT,
        1,      // InstancesPossible
        0,      // InstancesNecessary
        NULL,   // Allocator Framing
        NULL    // PinIntersectHandler
    }
};


//
//  Template Pin Descriptors
//
//  This data structure defines the pin types available in the filters
//  template topology.  These structures will be used to create a
//  KDPinFactory for a pin type when BdaCreatePin is called.
//
const
KSPIN_DESCRIPTOR_EX
TemplatePinDescriptors[] =
{
    //  Antenna Pin
    //
    {
        &AntennaPinDispatch,
        &AntennaAutomation,   // AntennaPinAutomation
        {
            0,  // Interfaces
            NULL,
            0,  // Mediums
            NULL,
            SIZEOF_ARRAY(AntennaPinRanges),
            AntennaPinRanges,
            KSPIN_DATAFLOW_IN,
            KSPIN_COMMUNICATION_BOTH,
            NULL,   // Name
            NULL,   // Category
            0
        },
        KSPIN_FLAG_DO_NOT_USE_STANDARD_TRANSPORT | KSPIN_FLAG_FRAMES_NOT_REQUIRED_FOR_PROCESSING | KSPIN_FLAG_FIXED_FORMAT,
        1,      // InstancesPossible
        0,      // InstancesNecessary
        NULL,   // Allocator Framing
        NULL    // PinIntersectHandler
    },

    //  Tranport Pin
    //
    {
        &TransportPinDispatch,
        &TransportAutomation,   // TransportPinAutomation
        {
            0,  // Interfaces
            NULL,
            1,  // Mediums
            &TransportPinMedium,
            SIZEOF_ARRAY(TransportPinRanges),
            TransportPinRanges,
            KSPIN_DATAFLOW_OUT,
            KSPIN_COMMUNICATION_BOTH,
            (GUID *) &PINNAME_BDA_TRANSPORT,   // Name
            (GUID *) &PINNAME_BDA_TRANSPORT,   // Category
            0
        },
        KSPIN_FLAG_DO_NOT_USE_STANDARD_TRANSPORT | KSPIN_FLAG_FRAMES_NOT_REQUIRED_FOR_PROCESSING | KSPIN_FLAG_FIXED_FORMAT,
        1,
        1,      // InstancesNecessary
        NULL,   // Allocator Framing
        NULL    // PinIntersectHandler
    }
};


//
//  BDA Device Topology Property Set
//
//  Defines the dispatch routines for the filter level
//  topology properties
//
DEFINE_KSPROPERTY_TABLE(FilterTopologyProperties)
{
    DEFINE_KSPROPERTY_ITEM_BDA_NODE_TYPES(
        BdaPropertyNodeTypes,
        NULL
        ),
    DEFINE_KSPROPERTY_ITEM_BDA_PIN_TYPES(
        BdaPropertyPinTypes,
        NULL
        ),
    DEFINE_KSPROPERTY_ITEM_BDA_TEMPLATE_CONNECTIONS(
        BdaPropertyTemplateConnections,
        NULL
        ),
    DEFINE_KSPROPERTY_ITEM_BDA_CONTROLLING_PIN_ID(
        BdaPropertyGetControllingPinId,
        NULL
        )
};


//
//  Filter Level Property Sets supported
//
//  This table defines all property sets supported by the
//  tuner filter exposed by this driver.
//
DEFINE_KSPROPERTY_SET_TABLE(FilterPropertySets)
{

    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_BdaTopology,                   // Set
        SIZEOF_ARRAY(FilterTopologyProperties),     // PropertiesCount
        FilterTopologyProperties,                   // PropertyItems
        0,                                          // FastIoCount
        NULL                                        // FastIoTable
    ),

    //$REVIEW
    //
    //  This property set should be moved to the 8VSB node.  It works
    //  here for a filter that only has one 8VSB demodulator.  It works
    //  for now because you only have one 8VSB demodulator on the board.
    //
    // - TCP
    //
    DEFINE_KSPROPERTY_SET
    (
        &PROPSETID_VSB,                              // Set
        SIZEOF_ARRAY(VSBProperties),                 // PropertiesCount
        VSBProperties,                              // PropertyItems
        0,                                          // FastIoCount
        NULL                                        // FastIoTable
    ),
};


//
//  BDA Change Sync Method Set
//
//  Defines the dispatch routines for the filter level
//  Change Sync methods
//
DEFINE_KSMETHOD_TABLE(BdaChangeSyncMethods)
{
    DEFINE_KSMETHOD_ITEM_BDA_START_CHANGES(
        CFilter::StartChanges,
        NULL
        ),
    DEFINE_KSMETHOD_ITEM_BDA_CHECK_CHANGES(
        CFilter::CheckChanges,
        NULL
        ),
    DEFINE_KSMETHOD_ITEM_BDA_COMMIT_CHANGES(
        CFilter::CommitChanges,
        NULL
        ),
    DEFINE_KSMETHOD_ITEM_BDA_GET_CHANGE_STATE(
        CFilter::GetChangeState,
        NULL
        )
};


//
//  BDA Device Configuration Method Set
//
//  Defines the dispatch routines for the filter level
//  Topology Configuration methods
//
DEFINE_KSMETHOD_TABLE(BdaDeviceConfigurationMethods)
{
    DEFINE_KSMETHOD_ITEM_BDA_CREATE_PIN_FACTORY(
        BdaMethodCreatePin,
        NULL
        ),
    DEFINE_KSMETHOD_ITEM_BDA_DELETE_PIN_FACTORY(
        BdaMethodDeletePin,
        NULL
        ),
    DEFINE_KSMETHOD_ITEM_BDA_CREATE_TOPOLOGY(
        CFilter::CreateTopology,
        NULL
        )
};


//
//  Filter Level Method Sets supported
//
//  This table defines all method sets supported by the
//  tuner filter exposed by this driver.
//
DEFINE_KSMETHOD_SET_TABLE(FilterMethodSets)
{
    DEFINE_KSMETHOD_SET
    (
        &KSMETHODSETID_BdaChangeSync,               // Set
        SIZEOF_ARRAY(BdaChangeSyncMethods),         // PropertiesCount
        BdaChangeSyncMethods,                       // PropertyItems
        0,                                          // FastIoCount
        NULL                                        // FastIoTable
    ),

    DEFINE_KSMETHOD_SET
    (
        &KSMETHODSETID_BdaDeviceConfiguration,      // Set
        SIZEOF_ARRAY(BdaDeviceConfigurationMethods),// PropertiesCount
        BdaDeviceConfigurationMethods,              // PropertyItems
        0,                                          // FastIoCount
        NULL                                        // FastIoTable
    )
};


//
//  Filter Automation Table
//
//  Lists all Property, Method, and Event Set tables for the filter
//
DEFINE_KSAUTOMATION_TABLE(FilterAutomation) {
    DEFINE_KSAUTOMATION_PROPERTIES(FilterPropertySets),
    DEFINE_KSAUTOMATION_METHODS(FilterMethodSets),
    DEFINE_KSAUTOMATION_EVENTS_NULL
};


//
//  Filter Dispatch Table
//
//  Lists the dispatch routines for major events at the filter
//  level.
//
const
KSFILTER_DISPATCH
FilterDispatch =
{
    CFilter::Create,        // Create
    CFilter::FilterClose,   // Close
    NULL,                   // Process
    NULL                    // Reset
};

//
//  Filter Factory Descriptor for the tuner filter
//
//  This structure brings together all of the structures that define
//  the tuner filter as it appears when it is first instanciated.
//  Note that not all of the template pin and node types may be exposed as
//  pin and node factories when the filter is first instanciated.
//
DEFINE_KSFILTER_DESCRIPTOR(InitialTunerFilterDescriptor)
{
    &FilterDispatch,                                    // Dispatch
    &FilterAutomation,                                  // AutomationTable
    KSFILTER_DESCRIPTOR_VERSION,                        // Version
    0,                                                  // Flags
    &KSNAME_Filter,                                     // ReferenceGuid

    DEFINE_KSFILTER_PIN_DESCRIPTORS(InitialPinDescriptors), // PinDescriptorsCount
                                                            // PinDescriptorSize
                                                            // PinDescriptors


    DEFINE_KSFILTER_CATEGORY(KSCATEGORY_BDA_RECEIVER_COMPONENT),// CategoriesCount
                                                                // Categories

    DEFINE_KSFILTER_NODE_DESCRIPTORS_NULL,              // NodeDescriptorsCount
                                                        // NodeDescriptorSize
                                                        // NodeDescriptors

    DEFINE_KSFILTER_DEFAULT_CONNECTIONS,                // ConnectionsCount
                                                        // Connections

    NULL                                                // ComponentId
};


//===========================================================================
//
//  Filter Template Topology  definitions
//
//===========================================================================


//
//  BDA Template Topology Connections
//
//  Lists the Connections that are possible between pin types and
//  node types.  This, together with the Template Filter Descriptor, and
//  the Pin Pairings, describe how topologies can be created in the filter.
//
const
KSTOPOLOGY_CONNECTION TemplateTunerConnections[] =
{
    { -1,  0,  0,  0},
    {  0,  1,  1,  0},
    {  1,  1,  -1, 1},
};


//
//  Template Joints between the Antenna and Transport Pin Types.
//
//  Lists the template joints between the Antenna Input Pin Type and
//  the Transport Output Pin Type.
//
//  In this case the RF Node is considered to belong to the antennea input
//  pin and the 8VSB Demodulator Node is considered to belong to the
//  tranport stream output pin.
//
const
ULONG   AntennaTransportJoints[] =
{
    1
};


//
//  Template Pin Parings.
//
//  These are indexes into the template connections structure that
//  are used to determine which nodes get duplicated when more than
//  one output pin type is connected to a single input pin type or when
//  more that one input pin type is connected to a single output pin
//  type.
//
const
BDA_PIN_PAIRING TemplateTunerPinPairings[] =
{
    //  Antenna to Transport Topology Joints
    //
    {
        0,  // ulInputPin
        1,  // ulOutputPin
        1,  // ulcMaxInputsPerOutput
        1,  // ulcMinInputsPerOutput
        1,  // ulcMaxOutputsPerInput
        1,  // ulcMinOutputsPerInput
        SIZEOF_ARRAY(AntennaTransportJoints),   // ulcTopologyJoints
        AntennaTransportJoints                  // pTopologyJoints
    }
};


//
//  Filter Factory Descriptor for the tuner filter template topology
//
//  This structure brings together all of the structures that define
//  the topologies that the tuner filter can assume as a result of
//  pin factory and topology creation methods.
//  Note that not all of the template pin and node types may be exposed as
//  pin and node factories when the filter is first instanciated.
//
DEFINE_KSFILTER_DESCRIPTOR(TemplateTunerFilterDescriptor)
{
    &FilterDispatch,                                    // Dispatch
    &FilterAutomation,                                  // AutomationTable
    KSFILTER_DESCRIPTOR_VERSION,                        // Version
    0,                                                  // Flags
    &KSNAME_Filter,                                     // ReferenceGuid

    DEFINE_KSFILTER_PIN_DESCRIPTORS(TemplatePinDescriptors),// PinDescriptorsCount
                                                            // PinDescriptorSize
                                                            // PinDescriptors


    DEFINE_KSFILTER_CATEGORY(KSCATEGORY_BDA_RECEIVER_COMPONENT),// CategoriesCount
                                                                // Categories

    DEFINE_KSFILTER_NODE_DESCRIPTORS(NodeDescriptors),  // NodeDescriptorsCount
                                                        // NodeDescriptorSize
                                                        // NodeDescriptors

    DEFINE_KSFILTER_CONNECTIONS(TemplateTunerConnections),  // ConnectionsCount
                                                            // Connections

    NULL                                                // ComponentId
};


//
//  BDA Template Topology Descriptor for the filter.
//
//  This structure define the pin and node types that may be created
//  on the filter.
//
const
BDA_FILTER_TEMPLATE
TunerBdaFilterTemplate =
{
    &TemplateTunerFilterDescriptor,
    SIZEOF_ARRAY(TemplateTunerPinPairings),
    TemplateTunerPinPairings
};


//===========================================================================
//
//  Device definitions
//
//===========================================================================


//
//  Array containing descriptors for all of the filter factories
//  that are available on the device.
//
//  Note!  This only used when dynamic topology is not desired.
//         (i.e. filters and pins are fixed, usually there is also no
//          network provider in this case)
//
DEFINE_KSFILTER_DESCRIPTOR_TABLE(FilterDescriptors)
{
    &TemplateTunerFilterDescriptor
};


//
//  Device Dispatch Table
//
//  Lists the dispatch routines for the major events in the life
//  of the underlying device.
//
extern
const
KSDEVICE_DISPATCH
DeviceDispatch =
{
    CDevice::Create,    // Add
    CDevice::Start,     // Start
    NULL,               // PostStart
    NULL,               // QueryStop
    NULL,               // CancelStop
    NULL,               // Stop
    NULL,               // QueryRemove
    NULL,               // CancelRemove
    NULL,               // Remove
    NULL,               // QueryCapabilities
    NULL,               // SurpriseRemoval
    NULL,               // QueryPower
    NULL                // SetPower
};


//
//  Device Descriptor
//
//  Brings together all data structures that define the device and
//  the intial filter factories that can be created on it.
//  Note that this structure does not include the template topology
//  structures as they are specific to BDA.
//
extern
const
KSDEVICE_DESCRIPTOR
DeviceDescriptor =
{
    &DeviceDispatch,    // Dispatch
#ifdef DYNAMIC_TOPOLOGY
    0,      // SIZEOF_ARRAY( FilterDescriptors),   // FilterDescriptorsCount
    NULL,   // FilterDescriptors                   // FilterDescriptors
#else
    SIZEOF_ARRAY( FilterDescriptors),   // FilterDescriptorsCount
    FilterDescriptors                   // FilterDescriptors
#endif // DYNAMIC_TOPOLOGY
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\mauitune\philtune.h ===
#include "common.h"

#include "ksvsb.h"

#include "i2script.h"
#include "gpio.h"
#include "tunerdef.h"
#include "bdadebug.h"


#include "wdmdrv.h"
#include "mpoc.h"
#include "util.h"
#include "tuner.h"
#include "vsb1.h"
#include "vsb2.h"


#define DYNAMIC_TOPOLOGY    TRUE
#define ANTENNA     TRUE

#define IsEqualGUID(rguid1, rguid2) (!memcmp(rguid1, rguid2, sizeof(GUID)))

/**************************************************************/
/* Driver Name - Change this to reflect your executable name! */
/**************************************************************/

#define MODULENAME           "PhilTune"
#define MODULENAMEUNICODE   L"PhilTune"

#define STR_MODULENAME      MODULENAME

// This defines the name of the WMI device that manages service IOCTLS
#define DEVICENAME (L"\\\\.\\" MODULENAMEUNICODE)
#define SYMBOLICNAME (L"\\DosDevices\\" MODULENAMEUNICODE)


//  This structure represents what the underlying device can do.
//
//  Note -  It is possible to set conflicting settings.  In this case
//  it is the responsibilty of the CheckChanges code to return an
//  error.  Only a self-consistent tuner resource should be submitted to
//  the underlying device.
//
typedef struct _PHILIPS_TUNER_RESOURCE
{
    GUID                guidDemodulatorNode;
    ULONG               ulhzCarrierFrequency;//  The channel frequency without
                                            //  The IMFrequency added in.

} PHILIPS_TUNER_RESOURCE, * PPHILIPS_TUNER_RESOURCE;


#define MAX_FILTER_PINS     2

typedef struct _PHILIPS_PIN_INFO
{
    ULONG       ulPinType;
    ULONG       ulIdConnectedPin;
} PHILIPS_PIN_INFO, * PPHILIPS_PIN_INFO;

extern const KSDEVICE_DESCRIPTOR DeviceDescriptor;


class CFilter {
public:

    //
    //  AVStream Filter Dispatch Functions
    //
    static
    STDMETHODIMP_(NTSTATUS)
    Create(
        IN OUT PKSFILTER Filter,
        IN PIRP Irp
        );

    static
    STDMETHODIMP_(NTSTATUS)
    FilterClose(
        IN OUT PKSFILTER Filter,
        IN PIRP Irp
        );

    static
    STDMETHODIMP
    Process(
        IN PKSFILTER Filter,
        IN PKSPROCESSPIN_INDEXENTRY ProcessPinsIndex
        );

    //
    //  KSMETHODSETID_BdaChangeSync - Filter change sync methods
    //
    static
    STDMETHODIMP_(NTSTATUS)
    StartChanges(
        IN PIRP         pIrp,
        IN PKSMETHOD    pKSMethod,
        OPTIONAL PVOID  pvIgnored
        );

    static
    STDMETHODIMP_(NTSTATUS)
    CheckChanges(
        IN PIRP         pIrp,
        IN PKSMETHOD    pKSMethod,
        OPTIONAL PVOID  pvIgnored
        );

    static
    STDMETHODIMP_(NTSTATUS)
    CommitChanges(
        IN PIRP         pIrp,
        IN PKSMETHOD    pKSMethod,
        OPTIONAL PVOID  pvIgnored
        );

    static
    STDMETHODIMP_(NTSTATUS)
    GetChangeState(
        IN PIRP         pIrp,
        IN PKSMETHOD    pKSMethod,
        OUT PULONG      pulChangeState
        );

    //
    //  KSMETHODSETID_BdaDeviceConfiguration - Methods to modify filter topology.
    //
    static
    STDMETHODIMP_(NTSTATUS)
    CreateTopology(
        IN PIRP         pIrp,
        IN PKSMETHOD    pKSMethod,
        OPTIONAL PVOID  pvIgnored
        );

    //
    //  PROPSETID_VSB - Private Property Set
    //
    static
    STDMETHODIMP_(NTSTATUS)
    GetVsbCapabilitiesProperty(
        IN PIRP         pIrp,
        IN PKSPROPERTY  pKSProperty,
        OUT PKSPROPERTY_VSB_CAP_S pProperty
        );

    static
    STDMETHODIMP_(NTSTATUS)
    SetVsbCapabilitiesProperty(
        IN PIRP         pIrp,
        IN PKSPROPERTY  pKSProperty,
        IN PKSPROPERTY_VSB_CAP_S pProperty
        );
    static
    STDMETHODIMP_(NTSTATUS)
    GetVsbRegisterProperty(
        IN PIRP         pIrp,
        IN PKSPROPERTY  pKSProperty,
        OUT PKSPROPERTY_VSB_REG_CTRL_S pProperty
        );

    static
    STDMETHODIMP_(NTSTATUS)
    SetVsbRegisterProperty(
        IN PIRP         pIrp,
        IN PKSPROPERTY  pKSProperty,
        IN PKSPROPERTY_VSB_REG_CTRL_S pProperty
        );
    static
    STDMETHODIMP_(NTSTATUS)
    GetVsbCoefficientProperty(
        IN PIRP         pIrp,
        IN PKSPROPERTY  pKSProperty,
        OUT PKSPROPERTY_VSB_COEFF_CTRL_S pProperty
        );

    static
    STDMETHODIMP_(NTSTATUS)
    SetVsbCoefficientProperty(
        IN PIRP         pIrp,
        IN PKSPROPERTY  pKSProperty,
        IN PKSPROPERTY_VSB_COEFF_CTRL_S pProperty
        );
    static
    STDMETHODIMP_(NTSTATUS)
    GetVsbDiagControlProperty(
        IN PIRP         pIrp,
        IN PKSPROPERTY  pKSProperty,
        OUT PKSPROPERTY_VSB_DIAG_CTRL_S pProperty
        );

    static
    STDMETHODIMP_(NTSTATUS)
    SetVsbDiagControlProperty(
        IN PIRP         pIrp,
        IN PKSPROPERTY  pKSProperty,
        IN PKSPROPERTY_VSB_DIAG_CTRL_S pProperty
        );

    static
    STDMETHODIMP_(NTSTATUS)
    SetVsbQualityControlProperty(
        IN PIRP         pIrp,
        IN PKSPROPERTY  pKSProperty,
        IN PKSPROPERTY_VSB_CTRL_S pProperty
        );

    static
    STDMETHODIMP_(NTSTATUS)
    SetVsbResetProperty(
        IN PIRP         pIrp,
        IN PKSPROPERTY  pKSProperty,
        IN PKSPROPERTY_VSB_CTRL_S pProperty
        );

    STDMETHODIMP_(BDA_CHANGE_STATE)
    ChangeState();

    STDMETHODIMP_(class CDevice *)
    GetDevice() { return m_pDevice;};

    STDMETHODIMP_(NTSTATUS)
    ChangeFrequency(
        IN ULONG        ulhzCarrierFrequency
        )
        {
            //$Review - Should we validate the frequency here?
            //
            m_NewTunerResource.ulhzCarrierFrequency = ulhzCarrierFrequency;
            m_BdaChangeState = BDA_CHANGES_PENDING;

            return STATUS_SUCCESS;
        };

    STDMETHODIMP_(NTSTATUS)
    ChangeDemodulator(
        IN const GUID *       pguidNetworkType
    );

    STDMETHODIMP_(NTSTATUS)
    SetDeviceState(
        KSSTATE     newKsState
        )
    {
        m_KsState = newKsState;
        return STATUS_SUCCESS;
    };

    STDMETHODIMP_(NTSTATUS)
    AcquireResources();

    STDMETHODIMP_(NTSTATUS)
    ReleaseResources();

private:
    class CDevice * m_pDevice;

    //  Topology information
    //
    //  We know the maximum number of pins that this filter
    //  can create.  The Id of the pin we want information for is
    //  the index into the PinInfo array.
    //
    ULONG               m_ulcPins;
    PPHILIPS_PIN_INFO   m_rgPinInfo[MAX_FILTER_PINS];

    //  Filter Properties
    //
    ULONG               m_ulExampleProperty;
    ULONG               m_ulSignalSource;
    GUID                m_guidTuningSpace;
    GUID                m_guidNetworkType;
    ULONG               m_ulSignalState;

    //  Filter Resources
    //
    KSSTATE                 m_KsState;
    BDA_CHANGE_STATE        m_BdaChangeState;
    PHILIPS_TUNER_RESOURCE  m_CurTunerResource;
    ULONG                   m_ulCurResourceID;
    PHILIPS_TUNER_RESOURCE  m_NewTunerResource;
    ULONG                   m_ulNewResourceID;
};


class CDevice {
public:

    //
    //  AVStream Device Dispatch Functions
    //
    static
    STDMETHODIMP_(NTSTATUS)
    Create(
        IN PKSDEVICE    pKSDevice
        );

    static
    STDMETHODIMP_(NTSTATUS)
    Start(
        IN PKSDEVICE            pKSDevice,
        IN PIRP                 pIrp,
        IN PCM_RESOURCE_LIST    pTranslatedResourceList OPTIONAL,
        IN PCM_RESOURCE_LIST    pUntranslatedResourceList OPTIONAL
        );

    static
    STDMETHODIMP
    PnpStop(
        IN PKSDEVICE    pKSDevice,
        IN PIRP         pIrp
        );

    static
    STDMETHODIMP
    PnpRemove(
        IN PKSDEVICE    pKSDevice,
        IN PIRP         pIrp
        );

    //
    //  Utility functions
    //
    NTSTATUS
    GetRegistryULONG(
        PWCHAR  pwcKeyName,
        PULONG  pulValue
        );


    NTSTATUS
    AcquireResources(
        PPHILIPS_TUNER_RESOURCE pNewTunerResource,
        PULONG                  pulAquiredResourceID
        );

    NTSTATUS
    ReleaseResources(
        ULONG                   ulResourceID
        );

    //
    // VSB property related methods
    //
    //$TCP - Add these to the resource
    //
    NTSTATUS VsbReset(UINT  uiReset);
    NTSTATUS SetVsbCapabilities(PKSPROPERTY_VSB_CAP_S p_Caps);
    NTSTATUS GetVsbCapabilities(PKSPROPERTY_VSB_CAP_S p_Caps);

    NTSTATUS
    AccessRegisterList(
        PKSPROPERTY_VSB_REG_CTRL_S p_RegCtrl,
        UINT uiOperation);

    NTSTATUS
    AccessVsbCoeffList(
        PKSPROPERTY_VSB_COEFF_CTRL_S p_VsbCoeff,
        UINT uiOperation);

    NTSTATUS SetVsbDiagMode(ULONG ulOperationMode, VSBDIAGTYPE ulType);
    NTSTATUS GetVsbDiagMode(ULONG *p_ulOperationMode, ULONG *p_ulType);
    NTSTATUS VsbQuality(UINT    uiQu);




    // Tuner property related methods
//OOL GetTunerModeCapbilities(KSPROPERTY_TUNER_MODE_CAPS_S *p_TunerModeCaps);
    NTSTATUS GetTunerMode(ULONG *p_ulMode);
    NTSTATUS GetTunerVideoStandard(ULONG *p_ulStandard);
    NTSTATUS GetTunerStatus(PTunerStatusType p_Status);
    NTSTATUS GetTunerInput(ULONG *p_ulTunerInput);
    NTSTATUS SetTunerMode(ULONG ulModeToSet);
    NTSTATUS GetTunerFrequency(ULONG *p_ulFreq);
    NTSTATUS SetTunerFrequency(ULONG *p_ulFreq);
    NTSTATUS SetTunerVideoStandard(ULONG ulStandard);
    NTSTATUS SetTunerInput(ULONG ulInput);



    //$REVIEW - Should this be done in Ring 0? - TCP
    //
    BOOL        CreateQualityCheckThread();
    void        TimerRoutine();
    void        QualityCheckThread();
//  void STREAMAPI  TimerRoutine();
//  void STREAMAPI QualityCheckThread();


public:
    CVSBDemod           *m_pDemod;
    CTuner              *m_pTuner;

    BoardInfoType       m_BoardInfo;

private:

    PKSDEVICE           m_pKSDevice;
    CGpio *             m_pGpio;
    CI2CScript *        m_pI2CScript;

    CPhilTimer          m_QualityCheckTimer;

    BOOL                m_bFirstEntry;
    BOOL                m_bQualityCheckActiveFlag;

    // Signal Quality check parameters
    UINT                m_uiQualityCheckMode;
    UINT                m_uiQualityCheckModeAck;
    CMutex              m_QualityCheckMutex;
    UINT                m_State1Cnt;
    BOOL                m_bHangCheckFlag;

    // Data in Misc./Mode Register
    UCHAR               m_ucModeInit;
    UINT                m_uiOutputMode;


    Register            m_MpocRegisters;

    PHILIPS_TUNER_RESOURCE  m_CurTunerResource;

    NTSTATUS        InitFromRegistry();
    NTSTATUS SetBoard(UINT uiBoardID);
    NTSTATUS BoardInitialize();
    NTSTATUS ModeInit();

    UINT SetRegisterList(RegisterType *p_Registers,
                         UINT uiNumRegisters);

    UINT GetRegisterList(RegisterType *p_Registers,
                         UINT uiNumRegisters,
                         UINT uiRegisterType);

    NTSTATUS MapErrorToNTSTATUS(UINT err);


    // MPOC related functions
    NTSTATUS MpocInit();
    NTSTATUS SetMpocIFMode(ULONG ulMode);
    NTSTATUS GetMpocVersion(UINT *p_version);
    NTSTATUS GetMpocStatus(UINT StatusType, UINT *puiStatus);


};


class CAntennaPin {
public:
    static
    STDMETHODIMP_(NTSTATUS)
    PinCreate(
        IN OUT PKSPIN Pin,
        IN PIRP Irp
        );

    static
    STDMETHODIMP_(NTSTATUS)
    PinClose(
        IN OUT PKSPIN Pin,
        IN PIRP Irp
        );

    static
    STDMETHODIMP_(NTSTATUS)
    PinSetDeviceState(
        IN PKSPIN Pin,
        IN KSSTATE ToState,
        IN KSSTATE FromState
        );

    static
    STDMETHODIMP_(NTSTATUS)
    GetSignalSource(
        IN PIRP         Irp,
        IN PKSPROPERTY  pKSProperty,
        IN PULONG       pulProperty
        );

    static
    STDMETHODIMP_(NTSTATUS)
    PutSignalSource(
        IN PIRP         Irp,
        IN PKSPROPERTY  pKSProperty,
        IN PULONG       pulProperty
        );

    static
    STDMETHODIMP_(NTSTATUS)
    GetTuningSpace(
        IN PIRP         Irp,
        IN PKSPROPERTY  pKSProperty,
        IN PGUID        pguidProperty
        );

    static
    STDMETHODIMP_(NTSTATUS)
    PutTuningSpace(
        IN PIRP         Irp,
        IN PKSPROPERTY  pKSProperty,
        IN PGUID        pguidProperty
        );

    static
    STDMETHODIMP_(NTSTATUS)
    GetNetworkType(
        IN PIRP         Irp,
        IN PKSPROPERTY  pKSProperty,
        IN PGUID        pguidProperty
        );

    static
    STDMETHODIMP_(NTSTATUS)
    PutNetworkType(
        IN PIRP         Irp,
        IN PKSPROPERTY  pKSProperty,
        IN PGUID        pguidProperty
        );

    static
    STDMETHODIMP_(NTSTATUS)
    GetSignalState(
        IN PIRP         Irp,
        IN PKSPROPERTY  pKSProperty,
        IN PULONG       pulProperty
        );

    static
    STDMETHODIMP_(NTSTATUS)
    PutSignalState(
        IN PIRP         Irp,
        IN PKSPROPERTY  pKSProperty,
        IN PULONG       pulProperty
        );

    static
    STDMETHODIMP_(NTSTATUS)
    GetCenterFrequency(
        IN PIRP         Irp,
        IN PKSPROPERTY  pKSProperty,
        IN PULONG       pulProperty
        );

    static
    STDMETHODIMP_(NTSTATUS)
    PutCenterFrequency(
        IN PIRP         Irp,
        IN PKSPROPERTY  pKSProperty,
        IN PULONG       pulProperty
        );

    STDMETHODIMP_(class CFilter *)
    GetFilter() { return m_pFilter;};

    STDMETHODIMP_(void)
    SetFilter(class CFilter * pFilter) { m_pFilter = pFilter;};

private:
    class CFilter*  m_pFilter;
    ULONG           ulReserved;
    KSSTATE         m_KsState;

    //  BDA Signal Properties
    //
    ULONG           m_ulSignalSource;
    GUID            m_guidTuningSpace;
    GUID            m_guidNetworkType;
    ULONG           m_ulSignalState;

    //  RF Tuner Node Properties
    //
    BOOLEAN         m_fFrequencyChanged;
    ULONG           m_ulCurrentFrequency;
    ULONG           m_ulPendingFrequency;
};


class CTransportPin
{
public:
    static
    STDMETHODIMP_(NTSTATUS)
    PinCreate(
        IN OUT PKSPIN Pin,
        IN PIRP Irp
        );

    static
    STDMETHODIMP_(NTSTATUS)
    PinClose(
        IN OUT PKSPIN Pin,
        IN PIRP Irp
        );

    static
    STDMETHODIMP_(NTSTATUS)
    GetSignalSource(
        IN PIRP         Irp,
        IN PKSPROPERTY  pKSProperty,
        IN PULONG       pulProperty
        );

    static
    STDMETHODIMP_(NTSTATUS)
    PutSignalSource(
        IN PIRP         Irp,
        IN PKSPROPERTY  pKSProperty,
        IN PULONG       pulProperty
        );

    static
    STDMETHODIMP_(NTSTATUS)
    GetTuningSpace(
        IN PIRP         Irp,
        IN PKSPROPERTY  pKSProperty,
        IN PGUID        pguidProperty
        );

    static
    STDMETHODIMP_(NTSTATUS)
    PutTuningSpace(
        IN PIRP         Irp,
        IN PKSPROPERTY  pKSProperty,
        IN PGUID        pguidProperty
        );

    static
    STDMETHODIMP_(NTSTATUS)
    GetNetworkType(
        IN PIRP         Irp,
        IN PKSPROPERTY  pKSProperty,
        IN PGUID        pguidProperty
        );

    static
    STDMETHODIMP_(NTSTATUS)
    PutNetworkType(
        IN PIRP         Irp,
        IN PKSPROPERTY  pKSProperty,
        IN PGUID        pguidProperty
        );

    static
    STDMETHODIMP_(NTSTATUS)
    GetSignalState(
        IN PIRP         Irp,
        IN PKSPROPERTY  pKSProperty,
        IN PULONG       pulProperty
        );

    static
    STDMETHODIMP_(NTSTATUS)
    PutSignalState(
        IN PIRP         Irp,
        IN PKSPROPERTY  pKSProperty,
        IN PULONG       pulProperty
        );

    STDMETHODIMP_(class CFilter *)
    GetFilter() { return m_pFilter;};

    STDMETHODIMP_(void)
    SetFilter(class CFilter * pFilter) { m_pFilter = pFilter;};

    static
    STDMETHODIMP_(NTSTATUS)
    StartDemodulation(
        IN PIRP         Irp,
        IN PKSPROPERTY  pKSProperty,
        IN PULONG       pulProperty
        );

    static
    STDMETHODIMP_(NTSTATUS)
    StopDemodulation(
        IN PIRP         Irp,
        IN PKSPROPERTY  pKSProperty,
        IN PULONG       pulProperty
        );

private:
    KSSTATE         m_KsState;
    CFilter *       m_pFilter;

    //  BDA Signal Properties
    //
    ULONG           m_ulSignalSource;
    GUID            m_guidTuningSpace;
    GUID            m_guidNetworkType;
    ULONG           m_ulSignalState;
};


//
//  Helper routines
//

NTSTATUS
PinSetDeviceState(
    IN PKSPIN Pin,
    IN KSSTATE ToState,
    IN KSSTATE FromState
    );


__inline CFilter *
FilterFromIRP(
    PIRP    pIrp
    )
{
    PKSFILTER       pKSFilter;

    pKSFilter = KsGetFilterFromIrp( pIrp);
    if (!pKSFilter || !pKSFilter->Context)
    {
        return NULL;
    }

    return reinterpret_cast<CFilter*>(pKSFilter->Context);
}


__inline CAntennaPin *
AntennaPinFromIRP(
    PIRP    pIrp
    )
{
    PKSPIN       pKSPin;

    pKSPin = KsGetPinFromIrp( pIrp);
    if (!pKSPin || !pKSPin->Context)
    {
        return NULL;
    }

    return reinterpret_cast<CAntennaPin*>(pKSPin->Context);
}


__inline CTransportPin *
TransportPinFromIRP(
    PIRP    pIrp
    )
{
    PKSPIN       pKSPin;

    pKSPin = KsGetPinFromIrp( pIrp);
    if (!pKSPin || !pKSPin->Context)
    {
        return NULL;
    }

    return reinterpret_cast<CTransportPin*>(pKSPin->Context);
}

//
//  Data declarations
//

extern const BDA_FILTER_TEMPLATE    TunerBdaFilterTemplate;
extern const KSFILTER_DESCRIPTOR    InitialTunerFilterDescriptor;
extern const KSFILTER_DESCRIPTOR    TemplateTunerFilterDescriptor;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\mauitune\tuneprop.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//                     (C) Philips Semiconductors-CSU and Microsoft 1999
//  All rights are reserved. Reproduction in whole or in part is prohibited
//  without the written consent of the copyright owner.
//
//  Philips reserves the right to make changes without notice at any time.
//  Philips makes no warranty, expressed, implied or statutory, including but
//  not limited to any implied warranty of merchantibility or fitness for any
//  particular purpose, or that the use will not infringe any third party
//  patent, copyright or trademark. Philips must not be liable for any loss
//  or damage arising from its use.
//
// TUNERPROP.CPP
//////////////////////////////////////////////////////////////////////////////


#include "philtune.h"

#define     MPOC_TUNER_ATSC     0x0
#define     MPOC_TUNER_NTSC     0x3

#if 0
/*
* GetTunerModeCapbilities()
* Inputs: KSPROPERTY_TUNER_MODE_CAPS_S *p_tuner_mode_cap : pointer to
*   mode capability structure of the tuner
* Outputs: Filled KSPROPERTY_TUNER_MODE_CAPS_S
* Returns: BOOL: returns TRUE, if the operation succeeds else FALSE
* Description: Returns the mode capabilities of tuner for a particluar mode.
*/
NTSTATUS CDevice::GetTunerModeCapbilities(KSPROPERTY_TUNER_MODE_CAPS_S *p_TunerModeCaps)
{
    m_pTuner->GetModeCapabilities((TunerModeCapsType *)&p_TunerModeCaps->Mode);
    return STATUS_SUCCESS;
}
#endif

/*
* GetTunerMode ()
* Inputs: ULONG *p_ulMode : pointer to mode
* Outputs: Fills p_ulMode
* Returns: BOOL: returns TRUE, if the operation succeeds else FALSE
* Description: Returns the current tuner mode. Called in response to
* property ID KSPROPERTY_TUNER_MODE by GetProperty(). The modes could be
* either ATSC or TV (NTSC).
*/
NTSTATUS CDevice::GetTunerMode(ULONG *p_ulMode)
{
    m_pTuner->GetMode(p_ulMode);
    return STATUS_SUCCESS;

}

/*
* GetTunerVideoStandard ()
* Inputs: ULONG *p_ulStandard   : pointer to standard
* Outputs: Fills p_ulStandard
* Returns: BOOL: returns TRUE, if the operation succeeds else FALSE
* Description: Returns the current standard. Applicable only for TV mode.
*/
NTSTATUS CDevice::GetTunerVideoStandard(ULONG *p_ulStandard)
{
    m_pTuner->GetVideoStandard(p_ulStandard);
    return STATUS_SUCCESS;

}


/*
* GetTunerStatus ()
* Inputs: PTunerStatusType *p_status   : pointer to status
* Outputs: Fills p_status
* Returns: BOOL: returns TRUE, if the operation succeeds else FALSE
* Description: Returns the status of the tuner.
*/
NTSTATUS CDevice::GetTunerStatus(PTunerStatusType p_Status)
{
    NTSTATUS nStatus = STATUS_SUCCESS;
    long lPLLOffset = 0;
    BOOL bBusy = FALSE;

    if (m_pTuner->GetPLLOffsetBusyStatus(&lPLLOffset, &bBusy))
    {

        p_Status->Busy = bBusy;
        if(bBusy)
        {
            // If tuner is busy , return FALSE
            p_Status->Busy = TRUE;
            _DbgPrintF( DEBUGLVL_ERROR,("CDevice:GetStatus() fails\n"));
            return STATUS_DEVICE_BUSY;
        }

        if(m_BoardInfo.uiIFStage == IF_MPOC)
        {
            GetMpocStatus(MPOC_STATUS_PLL_OFFSET, (UINT *)(&p_Status->PLLOffset));
            if(p_Status->PLLOffset == 0)
                p_Status->PLLOffset = -2;
            else if(p_Status->PLLOffset == 1)
                p_Status->PLLOffset = 2;
            else
                p_Status->PLLOffset = 0;
        }
        else
            p_Status->PLLOffset = lPLLOffset;

        m_pTuner->GetFrequency(&p_Status->CurrentFrequency);
        p_Status->SignalStrength = m_pDemod->IsVSBLocked();

    }
    else
        nStatus = STATUS_UNSUCCESSFUL;

    _DbgPrintF( DEBUGLVL_VERBOSE,("CDevice::GetTunerStatus() Busy = %d, Offset = %d Frequency = %ld\n",bBusy, p_Status->PLLOffset, p_Status->CurrentFrequency));

    return nStatus;

}


/*
* GetTunerInput ()
* Inputs: ULONG *p_ulTuner_input   : pointer to tuner input index
* Outputs: Fills p_ulTuner_input
* Returns: BOOL: returns TRUE, if the operation succeeds else FALSE
* Description: Returns the current tuner input index. The input index is 0 based.
*/
NTSTATUS CDevice::GetTunerInput(ULONG *p_ulTunerInput)
{
    m_pTuner->GetInput(p_ulTunerInput);
    return STATUS_SUCCESS;

}



/*
* SetTunerMode()
* Inputs: ULONG ulModeToSet : an operation mode required to be set
* Outputs:
* Returns: NTSTATUS: returns STATUS_SUCCESS, if the operation succeeds
* Description: Set device into tuner mode requested.
* Do required I2C or GPIO writes to do a mode change for the chips.
* On 1st entry into this section, create a new thread to check hang and
* signal quality. In ATSC mode, enable signal quality check & in NTSC mode,
* disable signal quality check.
* Called in response to property ID KSPROPERTY_TUNER_MODE by SetProperty().
*/
NTSTATUS CDevice::SetTunerMode(ULONG ulModeToSet)
{
    UCHAR           ucPin;
    UCHAR           ucValue;
    BOOL            bResult = TRUE;
    ULONG           ulPrevMode;
    UINT            uiResult;
    UCHAR           ucDataWr[4];
    NTSTATUS        nStatus;

    m_pTuner->GetMode(&ulPrevMode);
    nStatus = m_pTuner->SetMode(ulModeToSet);
    if (!NT_SUCCESS( nStatus))
    {
        return STATUS_INVALID_PARAMETER;
    }

    _DbgPrintF( DEBUGLVL_VERBOSE,("CDevice::SetTunerMode: prev Mode = %d CurentMode = %d",
        ulPrevMode, ulModeToSet));

    // Take actions based on board ID
    if (m_BoardInfo.uiBoardID == BOARD_CONEY)
    {
        // Based on mode, set GPIO pins.
        // GPIO pin 2 = HIGH  for ATSC
        //              LOW   for NTSC
        // In ATSC mode - the first time create a thread to check
        // signal quality and hang check . At other times enable the thread.
        // in TV mode, disable the thread.
        ucPin = GPIO_TUNER_MODE_SELECT_PIN;         // use as a PinMask
        if (ulModeToSet == KSPROPERTY_TUNER_MODE_ATSC)
        {
            ucValue = GPIO_TUNER_MODE_ATSC;
            if(!m_pGpio->WriteGPIO(&ucPin, &ucValue))
            {   _DbgPrintF( DEBUGLVL_ERROR,("CDevice: GPIO write failed"));
                nStatus = STATUS_ADAPTER_HARDWARE_ERROR;
                goto errexit;
            }
            if(!(m_pDemod->SetOutputMode(m_uiOutputMode)))
            {
                nStatus = STATUS_ADAPTER_HARDWARE_ERROR;
                goto errexit;
            }
        }
        else if(ulModeToSet == KSPROPERTY_TUNER_MODE_TV)
        {
            ucValue = GPIO_TUNER_MODE_NTSC;
            if(!m_pGpio->WriteGPIO(&ucPin, &ucValue))
            {
                _DbgPrintF( DEBUGLVL_ERROR,("CDevice: GPIO write failed"));
                nStatus = STATUS_ADAPTER_HARDWARE_ERROR;
                goto errexit;
            }
        }
        else
        {
            _DbgPrintF( DEBUGLVL_ERROR,("CDevice:SetTunerMode: Invalid Mode"));
            nStatus = STATUS_INVALID_PARAMETER_1;
            goto errexit;
        }
    }
    else if(m_BoardInfo.uiBoardID == BOARD_CATALINA)
    {

        if (ulModeToSet == KSPROPERTY_TUNER_MODE_TV)
        {
            if(!(m_pDemod->SetOutputMode(VSB_OUTPUT_MODE_ITU656)))
            {
                nStatus = STATUS_ADAPTER_HARDWARE_ERROR;
                goto errexit;
            }

            // Set MiscRegister Tuner AGC to external (bit 4 = 1)
            // Set MiscRegister PLD mode to NTSC ( bit 5-7 = 010)
            // Set Misc Register DTV IF disable (bit 2 = 0)
            // Set Misc Register NTSC IF enable (bit 3 = 1)
            ucDataWr[0] = m_ucModeInit;
            ucDataWr[0] &= 0x03;
            ucDataWr[0] |= 0x58;
            m_pI2CScript->WriteSeq(CATALINA_MISC_CONTROL_REGISTER, ucDataWr, 1);
            m_ucModeInit = ucDataWr[0];

        }
        else if (ulModeToSet == KSPROPERTY_TUNER_MODE_ATSC)
        {
            if(!(m_pDemod->SetOutputMode(m_uiOutputMode)))
            {
                nStatus = STATUS_ADAPTER_HARDWARE_ERROR;
                goto errexit;
            }

            // Set MiscRegister Tuner AGC to internal (bit 4 = 0)
            // Set MiscRegister PLD mode to DTV ( bit 5-7 = 000)
            // Set Misc Register DTV IF enable (bit 2 = 1)
            // Set Misc Register NTSC IF disable (bit 3 = 0)
            ucDataWr[0] = m_ucModeInit;
            ucDataWr[0] &= 0x03;
            ucDataWr[0] |= 0x04;
            if(m_uiOutputMode == VSB_OUTPUT_MODE_DIAGNOSTIC)
                ucDataWr[0] |= 0x80;
            m_pI2CScript->WriteSeq(CATALINA_MISC_CONTROL_REGISTER, ucDataWr, 1);
            m_ucModeInit = ucDataWr[0];

        }
        else
        {
            _DbgPrintF( DEBUGLVL_ERROR,("CDevice:SetTunerMode: Invalid Mode"));
            nStatus = STATUS_INVALID_PARAMETER_1;
            goto errexit;
        }
        _DbgPrintF( DEBUGLVL_VERBOSE,("CDevice:SetTunerMode: Misc Reg = %x", m_ucModeInit));
//          SendTunerMode(ulModeToSet);
        //Set Mode in MPOC
        nStatus = SetMpocIFMode(ulModeToSet);
        if (!NT_SUCCESS( nStatus))
        {
            _DbgPrintF( DEBUGLVL_ERROR,("CDevice:SetTunerMode: Cannot set MPOC IF Mode"));
            goto errexit;
        }

    }
    else
    {
    //  TRAP;
    //  _DbgPrintF( DEBUGLVL_VERBOSE,("CDevice:SetTunerMode: Invalid Board ID"));
    //  FAIL;
    }

    if((m_BoardInfo.uiVsbChipVersion >> 8) == VSB1)
    {
        if (ulModeToSet == KSPROPERTY_TUNER_MODE_ATSC)
        {
            if (m_bFirstEntry == TRUE)
            {
                m_bFirstEntry = FALSE;
                // Create a new thread to constantly monitor the quality of
                // the input signal and check hang

                CreateQualityCheckThread();
            }
            // Get Mutex and enable QCM
            m_QualityCheckMutex.Lock();
            m_uiQualityCheckMode = QCM_ENABLE;
            m_QualityCheckMutex.Unlock();

        }
        else if(ulModeToSet == KSPROPERTY_TUNER_MODE_TV)
        {
            if (m_bFirstEntry == FALSE)
            {
                // Get Mutex and enable QCM
                m_QualityCheckMutex.Lock();
                m_uiQualityCheckMode = QCM_DISABLE;
                m_QualityCheckMutex.Unlock();
            }
        }
        else
        {}
    }
    m_pDemod->IsVSBLocked();
    // Mini: Test
    VsbStatusType Status;
    m_pDemod->GetStatus(&Status);
    return STATUS_SUCCESS;

errexit:
    // If the mode cannot be changed , restore the previous mode
    uiResult = m_pTuner->SetMode(ulPrevMode);
    return nStatus;
}


/*
* GetTunerFrequency ()
* Inputs: ULONG *p_ulFreq: pointer to frequency
* Outputs: Filled *p_ulfreq
* Return: NTSTATUS: returns STATUS_SUCCESS
* Description: Gets the tuner frequency parameters.
*/
NTSTATUS CDevice::GetTunerFrequency(ULONG *p_ulFreq)
{
    m_pTuner->GetFrequency(p_ulFreq);
    return STATUS_SUCCESS;
}


/*
* SetTunerFrequency()
* Inputs: ULONG *p_ulFreq: pointer to frequency
* Outputs:
* Return: NTSTATUS: returns STATUS_SUCCESS, if the operation succeeds
*         else STATUS_UNSUCCESSFUL
* Description: Set the frequency parameters and change to tuner frequency
* specified. In ATSC mode, introduce a small delay (~400ms) to let the VSB
* settle. If the quality check thread is created, disable it.
*/
NTSTATUS CDevice::SetTunerFrequency(ULONG *p_ulFreq)
{
    UINT    uiQcm;
    BOOL    bResult;

    if((m_BoardInfo.uiVsbChipVersion >> 8) == VSB1)
    {
        if (m_bFirstEntry == FALSE)
        {
            // Disable Quality Check mode
            m_QualityCheckMutex.Lock();
            uiQcm = m_uiQualityCheckMode;
            m_uiQualityCheckMode = QCM_DISABLE;
            m_QualityCheckMutex.Unlock();
            _DbgPrintF( DEBUGLVL_VERBOSE,("CDevice::GetTunerFrequency(): Disable QCM\n"));

            // Wait for ~400ms to let the Tuner and VSB settle down
            //Delay(400000);
        }

        bResult = m_pTuner->SetFrequency(*p_ulFreq);

        if (m_bFirstEntry == FALSE)
        {
            // Restore Quality Check mode
            m_QualityCheckMutex.Lock();
            m_uiQualityCheckMode = uiQcm;
            m_QualityCheckMutex.Unlock();
        }
    }
    else
        bResult = m_pTuner->SetFrequency(*p_ulFreq);

    m_pDemod->IsVSBLocked();

    if(bResult) return STATUS_SUCCESS;
    else return STATUS_UNSUCCESSFUL;
}


/*
* SetTunerVideoStandard ()
* Inputs: ULONG ulStandard  : a standard required to be set
* Outputs:
* Return: NTSTATUS: returns STATUS_SUCCESS, if the operation succeeds
*          else STATUS_UNSUCCESSFUL
* Description: Set Tuner Video standard.
*/
NTSTATUS CDevice::SetTunerVideoStandard(ULONG ulStandard)
{
    if(!m_pTuner->SetVideoStandard(ulStandard))
        return STATUS_UNSUCCESSFUL;
    else
        return STATUS_SUCCESS;
}

/*
* SetTunerInput
* Inputs: ULONG ulInput : input number required to be set as an active
* (begins from 0)
* Outputs:
* Return: NTSTATUS: returns STATUS_SUCCESS, if the operation succeeds
*          else STATUS_UNSUCCESSFUL
* Description: Set Tuner input to that requested.
*/
NTSTATUS CDevice::SetTunerInput(ULONG ulInput)
{
    if(!m_pTuner->SetInput(ulInput))
        return STATUS_UNSUCCESSFUL;
    else
        return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\mauitune\trnsport.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    Trnsport.cpp

Abstract:

    Transport pin code.

--*/

#include "PhilTune.h"

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA

enum tuner_errors { NO_ERRORS_DEFINED};


NTSTATUS
CTransportPin::PinCreate(
    IN OUT PKSPIN pKSPin,
    IN PIRP pIrp
    )
{
    NTSTATUS            Status = STATUS_SUCCESS;
    CTransportPin*      pPin;
    CFilter*            pFilter;

    _DbgPrintF(DEBUGLVL_VERBOSE,("CTransportPin::PinCreate"));

    ASSERT(pKSPin);
    ASSERT(pIrp);

    //  Get a pointer to our filter instance that this pin is being
    //  created for.  Remember it for later.
    //
    pFilter = FilterFromIRP( pIrp);
    ASSERT( pFilter);
    if (!pFilter)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    //  Create our transport pin object.
    //
    pPin = new(NonPagedPool,'IFsK') CTransportPin;
    if (!pPin)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto errExit;
    }

    //  Link our pin context to our filter context.
    //
    pPin->SetFilter( pFilter);

    //  Link our context to the KSPIN structure.
    //
    pKSPin->Context = pPin;

#ifdef NEVER
    //  Set our initial demodulation mode to ATSC.
    //
    pFilter->m_CurTunerResource.guidDemodulatorNode
        = KSNODE_BDA_8VSB_DEMODULATOR;
    pFilter->m_NewTunerResource.guidDemodulatorNode
        = KSNODE_BDA_8VSB_DEMODULATOR;
#endif // NEVER

errExit:
    return Status;
}


NTSTATUS
CTransportPin::PinClose(
    IN OUT PKSPIN pKSPin,
    IN PIRP pIrp
    )
{
    NTSTATUS            Status = STATUS_SUCCESS;
    CTransportPin*      pPin = NULL;

    _DbgPrintF(DEBUGLVL_VERBOSE,("PinClose"));

    ASSERT(pKSPin);
    ASSERT(pIrp);

    if (!pKSPin)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    pPin = reinterpret_cast<CTransportPin*>(pKSPin->Context);
    ASSERT(pPin);
    if (pPin)
    {
        delete pPin;
    }

errExit:
    return STATUS_SUCCESS;
}


NTSTATUS
CTransportPin::StartDemodulation(
    IN PIRP         pIrp,
    IN PKSPROPERTY  pKSProperty,
    IN PULONG       pulProperty
    )
{
    NTSTATUS        Status = STATUS_SUCCESS;
    CTransportPin*  pPin;
    CFilter*        pFilter;

    _DbgPrintF(DEBUGLVL_VERBOSE,("PinClose"));

    ASSERT(pIrp);
    ASSERT(pKSProperty);


    //  Validate that the node type is associated with this pin.
    //
    Status = BdaValidateNodeProperty( pIrp, pKSProperty);
    if (!NT_SUCCESS( Status))
    {
        goto errExit;
    }


    //  Get a pointer to our object.
    //
    pPin = TransportPinFromIRP( pIrp);
    ASSERT( pPin);
    if (!pPin)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    pFilter = pPin->GetFilter();
    ASSERT( pFilter);
    if (!pFilter)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    //  Set the filter resource to include 8VSB demodulation
    //
    Status = pFilter->ChangeDemodulator( &KSNODE_BDA_8VSB_DEMODULATOR);

errExit:
    return Status;
}


NTSTATUS
CTransportPin::StopDemodulation(
    IN PIRP         pIrp,
    IN PKSPROPERTY  pKSProperty,
    IN PULONG       pulProperty
    )
{
    NTSTATUS        Status = STATUS_SUCCESS;
    CTransportPin*  pPin;
    CFilter*        pFilter;

    _DbgPrintF(DEBUGLVL_VERBOSE,("PinClose"));

    ASSERT(pIrp);
    ASSERT(pKSProperty);


    //  Validate that the node type is associated with this pin.
    //
    Status = BdaValidateNodeProperty( pIrp, pKSProperty);
    if (!NT_SUCCESS( Status))
    {
        goto errExit;
    }


    //  Get a pointer to our object.
    //
    pPin = TransportPinFromIRP( pIrp);
    ASSERT( pPin);
    if (!pPin)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    pFilter = pPin->GetFilter();
    ASSERT( pFilter);
    if (!pFilter)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    //  Set the filter resource to include 8VSB demodulation
    //
    Status = pFilter->ChangeDemodulator( &KSNODE_BDA_8VSB_DEMODULATOR);

errExit:
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\mauitune\tuner.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//                     (C) Philips Semiconductors-CSU and Microsoft 1999
//  All rights are reserved. Reproduction in whole or in part is prohibited
//  without the written consent of the copyright owner.
//
//  Philips reserves the right to make changes without notice at any time.
//  Philips makes no warranty, expressed, implied or statutory, including but
//  not limited to any implied warranty of merchantibility or fitness for any
//  particular purpose, or that the use will not infringe any third party
//  patent, copyright or trademark. Philips must not be liable for any loss
//  or damage arising from its use.
//
// TUNER.CPP
//////////////////////////////////////////////////////////////////////////////

#include "philtune.h"

/*
* CTuner()
* Input :
* Output:   TRUE - if initialization data can be written to I2C
*           FALSE - if there is an I2C error
* Description:  CTuner Constructor.
*/
CTuner::CTuner(CI2CScript *p_I2CScript, BoardInfoType *p_BoardInfo, NTSTATUS *pStatus)
{
    m_pI2CScript = p_I2CScript;
    m_ucTunerAddress = TUNER_I2C_ADDRESS;
    m_ulInput = 0L;        // unknown input or the only one
    m_ulCurrentFrequency = 0L;   // unknown tuning frequency
    m_ulMode = 0;
    m_ulPrevMode = 0;

    m_TunerID = TD1536;

    m_ulPreviousFrequency = 0L;
    //m_FrequencyParam.ulCurrentCFrequency = 0L;

    LONG    lPLLOffset;
    BOOL    bBusyStatus;

    //GetPLLOffsetBusyStatus(&lPLLOffset, &bBusyStatus);
    m_uiBoardID = 0;

    if(p_BoardInfo != NULL)
    {
        NTSTATUS status;
        status = SetCapabilities(p_BoardInfo);
        if(pStatus != NULL)
            *pStatus = status;
    }
}

/*
* ~CTuner()
* Input :
* Output:
* Description:  CTuner Destructor.
*/
CTuner::~CTuner()
{
}



/*
 * SetCapabilities()
 * Purpose  :  Sets the capabilities based upon the Tuner Id
 *
 * Inputs : UINT tuner : Tuner Id
 *
 * Outputs  : returns TRUE, if there is a supported Tuner Id specified;
 *
 * Author : MM
 */
NTSTATUS
CTuner::SetCapabilities(BoardInfoType *p_BoardInfo)
{
    NTSTATUS nStatus = STATUS_SUCCESS;

    m_TunerID = (TunerTypes)(p_BoardInfo->uiTunerID);
    m_ucTunerAddress = p_BoardInfo->ucTunerAddress;
    m_uiBoardID = p_BoardInfo->uiBoardID;


    // Note:
    // If mode is KSPROPERTY_TUNER_MODE_ATSC, then the IF is
    // 43.75MHz, else it is 44MHz. But as the frequency
    // being passed (ulFrequency) is the Video Signal freq,
    // the calculation should take into consideration that the video signal
    // is 1.75 MHz from the centre of the band. This 1.75MHz should be
    // added to the actual IF hence for ATSC IF = 43.75 + 1.75 = 45.5MHz
    // and NTSC IF = 44 + 1.75 = 45.75MHz
    // Currently , supporting only TD1536, other tune support can be added later
    // as necessary
    switch(m_TunerID)
    {
        case TD1536:    // Digital Tuner
        {
            // Check to determine if it is a single input or a dual input
            // tuner
            ULONG inputs = 1;
            GetNumberOfInputs(&inputs);
            int i = 0;
            if(p_BoardInfo->ulSupportedModes & KSPROPERTY_TUNER_MODE_TV)
            {
                // Set mode capabilities for  TV mode
                m_ModeCaps[i].ModeCaps.ulMode = KSPROPERTY_TUNER_MODE_TV;
                m_ModeCaps[i].ModeCaps.ulNumberOfInputs = inputs; //2;
                m_ModeCaps[i].ModeCaps.ulMinFrequency =  55250000L;
                m_ModeCaps[i].ModeCaps.ulMaxFrequency = 801250000L;
                m_ModeCaps[i].ModeCaps.ulStrategy =  KS_TUNER_STRATEGY_PLL;
                m_ModeCaps[i].ulIntermediateFrequency = 45750000L;
                m_ModeCaps[i].ModeCaps.ulStandardsSupported = KS_AnalogVideo_NTSC_M;
                m_ModeCaps[i].ulNumberOfStandards = 1;
                m_ModeCaps[i].ModeCaps.ulTuningGranularity = 62500L;
                m_ModeCaps[i].ModeCaps.ulSettlingTime = 150;    // 150 ms
                i++;
            }
            if(p_BoardInfo->ulSupportedModes & KSPROPERTY_TUNER_MODE_ATSC)
            {
                // Set mode capabilities for  ATSC mode
                m_ModeCaps[i].ModeCaps.ulMode = KSPROPERTY_TUNER_MODE_ATSC;
                m_ModeCaps[i].ModeCaps.ulNumberOfInputs = inputs; //2;
                m_ModeCaps[i].ModeCaps.ulMinFrequency =  55250000L;
                m_ModeCaps[i].ModeCaps.ulMaxFrequency = 801250000L;
                m_ModeCaps[i].ModeCaps.ulStrategy =
                                            KS_TUNER_STRATEGY_DRIVER_TUNES;

                if((m_uiBoardID == BOARD_CATALINA) ||
                    (m_uiBoardID == BOARD_CORFU))
                    m_ModeCaps[i].ulIntermediateFrequency = 45750000L;
                else
                    m_ModeCaps[i].ulIntermediateFrequency = 45500000L;

                m_ModeCaps[i].ModeCaps.ulStandardsSupported = KS_AnalogVideo_NTSC_M;
                m_ModeCaps[i].ulNumberOfStandards = 0;
                m_ModeCaps[i].ModeCaps.ulTuningGranularity = 62500L;
                m_ModeCaps[i].ModeCaps.ulSettlingTime = 800;    // 800ms
                i++;
            }

            m_ulSupportedModes = p_BoardInfo->ulSupportedModes;
            m_ulNumSupportedModes = p_BoardInfo->ulNumSupportedModes;
            m_ucTunerAddress = TUNER_I2C_ADDRESS;
            _DbgPrintF( DEBUGLVL_VERBOSE,("CDevice::Supported Modes = %x \n", m_ulSupportedModes));
        }
        break;


        default:
            return STATUS_INVALID_PARAMETER;
    }

    SetMode(KSPROPERTY_TUNER_MODE_ATSC);
    m_ulVideoStandard = KS_AnalogVideo_NTSC_M;


  return nStatus;
}



/*
* GetModeCapabilities()
* Inputs: TunerModeCapsType *p_TunerModeCaps : pointer to
*   mode capability structure of the tuner
* Outputs: Filled TunerModeCapsType structure
* Returns: BOOL: returns TRUE, if the operation succeeds else FALSE
* Description: Returns the mode capabilities of tuner for a particluar mode.
*/
NTSTATUS
CTuner::GetModeCapabilities(TunerModeCapsType *p_TunerModeCaps)
 {

    ULONG ulOperationMode =     p_TunerModeCaps->ulMode;

    _DbgPrintF( DEBUGLVL_VERBOSE,("CTuner::GetTunerModeCapbilities Mode = %x  Mode in obj %x\n",
        ulOperationMode, m_ulMode ));

    // QF:This is a work-around, as the mode passed by the filter the 1st time
    // is not correct. Will have to be removed later.
    p_TunerModeCaps->ulMode  = m_ulMode;
    ulOperationMode = m_ulMode;

    if (!(ulOperationMode & m_ulSupportedModes))
    {
        // TRAP;
        return STATUS_INVALID_PARAMETER;
    }

    // There is support for TVTuner at this time only.
    // It will be enchanced later on to support FM Tuner as well.
    for(ULONG i = 0; i < m_ulNumSupportedModes; i++)
    {
        if(ulOperationMode == m_ModeCaps[m_ulModeCapIndex].ModeCaps.ulMode)
            break;
    }
    MemoryCopy(&p_TunerModeCaps->ulMode, &m_ModeCaps[m_ulModeCapIndex].ModeCaps,
        sizeof(TunerModeCapsType));

    return STATUS_SUCCESS;
 }


 /*
* SetMode()
* Inputs: ULONG ulMode : an operation mode required to be set
* Outputs:
* Returns: UINT: 0 - if mode is not supported
*                1 - if mode is same as previous mode
*                2 - if new mode has been set
* Description: Set TV mode
*/
NTSTATUS
CTuner::SetMode(ULONG ulMode)
{
    ULONG i;

    // Check if mod eis supported
    if(ulMode & m_ulSupportedModes)
    {
        m_ulPrevMode = m_ulMode;
        // Change mode only if it is different from the previous mode
        if(ulMode != m_ulMode)
        {
            // Check if the mode supported is part of the mode capability
            // structure array for the tuner. If it is , get the index into the
            // array for the given mode and change the mode.
            for(i = 0; i < m_ulNumSupportedModes; i++)
            {
                if(m_ModeCaps[i].ModeCaps.ulMode == ulMode)
                {
                    m_ulModeCapIndex = i;
                    break;
                }
            }
            if(i == m_ulNumSupportedModes)
            {
                _DbgPrintF( DEBUGLVL_ERROR,("CTuner::SetMode: Couldn't find mode in capability array\n"));
                return STATUS_INVALID_PARAMETER;
            }
            else
                m_ulMode = ulMode;
        }
        return STATUS_SUCCESS;
    }
    else
    {
        _DbgPrintF( DEBUGLVL_ERROR,("CTuner: Mode not supported : %x %x \n", ulMode, m_ulSupportedModes));
        return STATUS_INVALID_PARAMETER;
    }
}

/*
* GetMode()
* Inputs: ULONG *p_ulMode : pointer to operation mode that has to be read
* Outputs: operation mode
* Returns:
* Description: Get Mode (TV/ATSC)
*/
void CTuner::GetMode(ULONG *p_ulMode)
{
    *p_ulMode = m_ulMode ;
}

/*
* SetVideoStandard()
* Inputs: ULONG ulStandard : a standard required to be set
* Outputs:
* Returns: NTSTATUS: STATUS_INVALID_PARAMETER - if standard is not supported
*                    STATUS_SUCCESS - if operation succeeded
* Description: Set the TV video standard requested.
*/
NTSTATUS
CTuner::SetVideoStandard(ULONG ulStandard)
{
    if(ulStandard &
        m_ModeCaps[m_ulModeCapIndex].ModeCaps.ulStandardsSupported)
    {
        if(ulStandard != m_ulVideoStandard)
        {
            m_ulVideoStandard = ulStandard;
        }
        return STATUS_SUCCESS;
    }
    return STATUS_INVALID_PARAMETER;
}

/*
* GetVideoStandard()
* Inputs: ULONG *p_ulStandard : pointer to standard required to be filled
* Outputs: standard
* Returns:
* Description: Get the TV video standard requested.
*/
void CTuner::GetVideoStandard(ULONG *p_ulStandard)
{
    *p_ulStandard = m_ulVideoStandard;
}

/*
 * GetPLLOffsetBusyStatus()
 * Purpose: Returns tuner Busy status and PLLOffset, if the tuner is not busy
 *          The function reads the hardware in order to accomplish the task
 *          The operation might be carried on either synchronously or asynchronously
 * Inputs : PLONG plPLLOffset   : a pointer to write a PLLOffset value
 *          PBOOL pbBusyStatus  : a pointer to write a Busy status
 *
 * Outputs: BOOL : returns TRUE, if the operation succeded
 * Author : MM
 */

NTSTATUS
CTuner::GetPLLOffsetBusyStatus(PLONG plPLLOffset, PBOOL pbBusyStatus)
{
    UCHAR   ucI2CValue = 0;
    NTSTATUS  nResult = STATUS_SUCCESS;

    if( Read(&ucI2CValue, 1, 0) != WDMMINI_NOERROR)
        nResult = STATUS_ADAPTER_HARDWARE_ERROR;
    if (nResult == STATUS_SUCCESS)
    {
        // bit 6 - PLL locked indicator
        *pbBusyStatus = !((BOOL)(ucI2CValue & 0x40));
        if (!(* pbBusyStatus))
        {
            ucI2CValue &= 0x07;  // only 3 LSBits are PLLOffset

            // let's map the result into MS defined values
            // from -2 to 2
            *plPLLOffset = ucI2CValue - 2;
        }
    }

    // Read only busy bit for TD1536 as the tuner does not provide
    // PLL offset information.
    if (m_TunerID == TD1536)
    {
        *plPLLOffset = 0;
    //  *pbBusyStatus = 0;
    //  return TRUE;
    }


  return nResult;
}



/*
 * SetFrequency()
 * Purpose: Sets a new Tuner frequency
 * Inputs : ULONG ulFrequency   : a frequency required to be set
 *
 * Outputs: BOOL : returns TRUE, if the operation succeded
 * Author : MM
 */
BOOL CTuner::SetFrequency(ULONG ulFrequency)
{
    ASSERT(m_ModeCaps[m_ulModeCapIndex].ulIntermediateFrequency != 0L);

    // Change frequency
    if (!ChangeFrequency(ulFrequency))
        return FALSE;

    m_ulCurrentFrequency = ulFrequency;

    if (m_ulPreviousFrequency != ulFrequency)
    {
        // Mini: Delay for 400ms to let the tuner settle to a tuned state and to let
        // the VSB acquire equalizer lock
        if (m_ulMode == KSPROPERTY_TUNER_MODE_ATSC)
            Delay(400000);
    }

    _DbgPrintF( DEBUGLVL_VERBOSE,("CTuner::SetTunerFrequency(): PrevFreq = %d CurrentFreq = %d\n",
        m_ulPreviousFrequency,m_ulCurrentFrequency));
    m_ulPreviousFrequency = ulFrequency;
    return TRUE;
}

/*
 * GetFrequency()
 * Purpose: Gets  the Tuner frequency
 * Inputs : ULONG *p_ulFrequency   : a frequency required
 *
 * Outputs:
 * Author : MM
 */
void CTuner::GetFrequency(ULONG *p_ulFrequency)
{
    *p_ulFrequency = m_ulCurrentFrequency;
}


/*
* ChangeFrequency()
* Input : frequency
* Output: TRUE if able to to tune to the frequency
*        FALSE if unable to tune to the frequency
* Description: Change the frequency of tuner to that specified
*/

BOOL CTuner::ChangeFrequency(ULONG ulFrequency)
{
    ULONG      ulFrequenceDivider;
    USHORT     usControlCode;
    UCHAR      ucI2CBuffer[6];
    I2CPacket  i2cPacket;
    BOOL       bResult;
    ULONG IF = m_ModeCaps[m_ulModeCapIndex].ulIntermediateFrequency;
    // Set the video carrier frequency by controlling the programmable divider
    // N = (16 * (FreqRF + FreqIntermediate)) / 1000000

    _DbgPrintF( DEBUGLVL_VERBOSE,("CTuner: ulFrequency = %x \n", ulFrequency));
    ulFrequenceDivider = ulFrequency + IF;
    _DbgPrintF( DEBUGLVL_VERBOSE,("CTuner::ChangeFrequency: IF = %d\n", IF));

    ulFrequenceDivider /= (1000000 / 16);  // divide by 62,500

    usControlCode = GetControlCode(ulFrequenceDivider);
    if(!usControlCode)
        return(FALSE);

//  _DbgPrintF( DEBUGLVL_VERBOSE,("PhilTune: ulFrequencyDivider before %x \n", ulFrequenceDivider));
//  _DbgPrintF( DEBUGLVL_VERBOSE,("PhilTune: ulFrequencyDivider after  %x \n", ulFrequenceDivider));

    ucI2CBuffer[0] = 0xCE;
    ucI2CBuffer[1] = (UCHAR)usControlCode;
    ucI2CBuffer[2] = (UCHAR)(ulFrequenceDivider >> 8);
    ucI2CBuffer[3] = (UCHAR)ulFrequenceDivider;
    ucI2CBuffer[4] = (UCHAR)(usControlCode >> 8);
    ucI2CBuffer[5] = (UCHAR)usControlCode;

    _DbgPrintF( DEBUGLVL_TERSE,("\n CPhilipsWDMTuner:Tuner Control Code = %x %x %x %x \n",
        ucI2CBuffer[0], ucI2CBuffer[1], ucI2CBuffer[2], ucI2CBuffer[3]));


    /*i2cPacket.uchChipAddress = m_uchTunerI2CAddress;
    i2cPacket.cbReadCount = 0;
    i2cPacket.cbWriteCount = 4;
    i2cPacket.puchReadBuffer = NULL;
    i2cPacket.puchWriteBuffer = auchI2CBuffer;
    i2cPacket.usFlags = 0;

    bResult = m_pI2CScript->PerformI2CPacketOperation(&i2cPacket);
        return bResult;
        */
    if(Write(ucI2CBuffer, sizeof(ucI2CBuffer), 0) == WDMMINI_NOERROR)
        return TRUE;
    else
        return FALSE;
}

BOOL CTuner::TweakChannel(LONG lTweak, int iTweakReference)
{
    // Should change the routine later to support tweak reference
    // if tweak reference is TUNER_ABSOLUTE_TWEAK, then tweaking is about the centre
    // frequency else if tweak reference is TUNER_RELATIVE_TWEAK, then tweaking is about
    // the current frequency
    LONG lTweakFrq = (lTweak * 62500) + m_ulCurrentFrequency;
    if (lTweakFrq > 0)
        if (!ChangeFrequency((ULONG)lTweakFrq))
            return FALSE;
    else
        return FALSE;
    m_ulCurrentFrequency = (ULONG)lTweakFrq;
    return TRUE;
}

/*
* GetNumberOfInputs()
* Input : pointer to ULONG variable which will be filled with number of inputs
* Output: TRUE - if the number of inputs can be determined
*           FALSE - if there is an I2C error & number of inputs can't be determined
* Description: Determine the number of tuner inputs
*/
BOOL CTuner::GetNumberOfInputs(ULONG *p_ulInputs)
{
    UCHAR ucMode = 0;

    _DbgPrintF( DEBUGLVL_VERBOSE,("CTuner::GetNumberOfInputs: Inside\n"));
    if(m_uiBoardID == BOARD_CONEY)
    {
        if(!m_pI2CScript->ReadSeq(CONEY_I2C_PARALLEL_PORT, &ucMode, 1))
        {
            _DbgPrintF( DEBUGLVL_ERROR,("CTuner::GetNumberOfInputs: Error\n"));
            return(FALSE);
        }
        // If the mode bit 0 = 1,then its a dual input tuner , else its a single input tuner
        if ((ucMode & 0x1) == 0)
            *p_ulInputs = 1;
        else
            *p_ulInputs = 2;
    }
    else //if(m_uiBoardID == BOARD_CATALINA)
        *p_ulInputs = 1;
//  else
//  {
//      *p_ulInputs = 1;
//      _DbgPrintF( DEBUGLVL_ERROR,("CTuner::GetNumberOfInputs:Invalid Board ID\n"));
//  }
    m_uiNumInputs = *p_ulInputs;
    _DbgPrintF( DEBUGLVL_VERBOSE,("CTuner::GetNumberOfInputs: Number of input pins = %d Mode = %x\n",
        *p_ulInputs, ucMode));
    return(TRUE);
}


/*
 * GetInput()
 * Purpose: Gets the current tuner inputs as an active one
 * Inputs : ULONG nInput : input number required to be set as an active
 * (begins from 0)
 *
 * Outputs: BOOL : returns TRUE, if the operation succeded
 * Author : MM
 */
BOOL CTuner::GetInput(ULONG *p_ulInput)
{
    *p_ulInput = m_ulInput;
    return(TRUE);
}


/*
 * SetInput()
 * Purpose: Sets one of the possible Tuner inputs as an active one
 * Inputs : ULONG nInput : input number required to be set as an active
 * (begins from 0)
 *
* Returns: UINT: 0 - if tuner input is out of range
 *               1 - if tuner input is same as previous tuner input
 *               2 - if new tuner input has been set
  * Author : MM
 */
UINT CTuner::SetInput(ULONG ulInput)
{
    if(ulInput < m_ModeCaps[m_ulModeCapIndex].ModeCaps.ulNumberOfInputs)
    {
        if(ulInput != m_ulInput)
            m_ulInput = ulInput;
        else
            return 1;
        return 2;
    }
    else
        return 0;
}


/*
 * GetControlCode()
 * Purpose: Determines the Tuner control code to be send to tuner with a new frequency value
 *
 * Inputs : ULONG ulFrequencyDivider  : new frequency divider
 *
 * Outputs: USHORT : value, the tuner should be programmed, when the new frequency is set
 *                   id the is no valid uiTunerId is passed as paramter, 0 is returned
 * Author : MM
 */
USHORT CTuner::GetControlCode(ULONG ulFrequencyDivider)
{
    USHORT  usLowBandFrequencyHigh, usMiddleBandFrequencyHigh;
    USHORT  usLowBandControl, usMiddleBandControl, usHighBandControl;
    USHORT  usControlCode = 0;

    usLowBandFrequencyHigh    = kUpperLowBand;
    usMiddleBandFrequencyHigh = kUpperMidBand;
    usLowBandControl          = kLowBand;
    usMiddleBandControl       = kMidBand;
    usHighBandControl         = kHighBand;

    switch(m_TunerID)
    {
        case TD1536:
        {
            if (m_ulMode != KSPROPERTY_TUNER_MODE_ATSC)
            {
                usLowBandControl    = kLowBand_1536_NTSC_A;
                usMiddleBandControl = kMidBand_1536_NTSC_A;
                usHighBandControl   = kHighBand_1536_NTSC_A;

                if(m_uiBoardID == BOARD_CORONADO)
                {
                    usLowBandControl     &= 0xffbf;
                    usMiddleBandControl  &= 0xffbf;
                    usHighBandControl    &= 0xffbf;
                }
            }
            else
            {
                usLowBandControl    = kLowBand_1536_NTSC_D;
                usMiddleBandControl = kMidBand_1536_NTSC_D;
                usHighBandControl   = kHighBand_1536_NTSC_D;

                if(m_uiBoardID == BOARD_CORONADO)
                {
                    usLowBandControl    |= 0x40;
                    usMiddleBandControl |= 0x40;
                    usHighBandControl   |= 0x40;
                }

            }
            // Based on the tuner input modify control word
            // Test
            ULONG ulInp = m_ulInput;    //1
            if (ulInp == 1)
            {
                usLowBandControl |= 0x1;
                usMiddleBandControl |= 0x1;
                usHighBandControl |= 0x1;
            }
            else
            {
                usLowBandControl &= 0xfffe;
                usMiddleBandControl &= 0xfffe;
                usHighBandControl &= 0xfffe;
            }

            _DbgPrintF( DEBUGLVL_VERBOSE,("CPhilipsWDMTuner::GetControlCode(): LBand = %x, MBand = %x, HBand = %x\n", usLowBandControl,
                usMiddleBandControl, usHighBandControl));
        }
        break;


        default :
            return(usControlCode);
    }

    if(ulFrequencyDivider <= (ULONG)usLowBandFrequencyHigh)
        usControlCode = usLowBandControl;
    else
    {
        if(ulFrequencyDivider <= (ULONG)usMiddleBandFrequencyHigh)
            usControlCode = usMiddleBandControl;
        else
            usControlCode = usHighBandControl;
    }

    return(usControlCode);
}

/*
* Write()
* Input:UCHAR *p_ucBuffer - buffer to be written
*       int uiNumReg -  Number of registers to be written
*       UINT uiStartAddr - start address
* Output : UINT - Error code
* Description: Write data to chip
*/

UINT CTuner::Write(UCHAR *p_ucBuffer, UINT uiNumReg, UINT uiStartAddr)
{
    UINT uiResult = WDMMINI_NOERROR;

    // The present versions of the chip do not support sub-addressing, hence
    // uiStartAddr is not used.
    // write to chip
    //$REVIEW - Should change function decl to make uiNumReg be USHORT - TCP
    if(!m_pI2CScript->WriteSeq(m_ucTunerAddress, p_ucBuffer, (USHORT) uiNumReg))
        uiResult = WDMMINI_HARDWAREFAILURE;

    return uiResult;
}

/*
* Read()
* Input:UCHAR *p_ucBuffer - buffer to be filled
*       int uiNumReg -  Number of registers to be read
*       UINT uiStartAddr - start address
* Output : UINT - Error code
* Description: Read data from chip
*/

UINT CTuner::Read(UCHAR *p_ucBuffer, UINT uiNumReg, UINT uiStartAddr)
{
    UINT uiResult = WDMMINI_NOERROR;

    // The present versions of the chip do not support sub-addressing, hence
    // uiStartAddr is not used.
    // write to chip
    //$REVIEW - Should change function decl to make uiNumReg be USHORT - TCP
    if(!m_pI2CScript->ReadSeq(m_ucTunerAddress, p_ucBuffer, (USHORT) uiNumReg))
        uiResult = WDMMINI_HARDWAREFAILURE;

    return uiResult;
}





#if 0
/*
 * operator new
 * Purpose: CTuner class overrides operator new.
 *
 * Inputs : UINT uiSize       : size of the object to be placed
 *
 * Outputs: PVOID : pointer of the CTuner class object
 * Author : MM
 */
PVOID CTuner::operator new(UINT uiSize)
{
    if (uiSize != sizeof(CTuner))
    {
        _DbgPrintF( DEBUGLVL_ERROR,("CTuner: operator new() fails\n"));
        return(NULL);
    }

    return (AllocateFixedMemory(uiSize));
}

/*
 * operator delete
 * Purpose: CTuner class overrides operator delete
 *
 * Inputs : PVOID p_Buffer      : pointer to object being deleted
 *
 * Outputs:
 * Author : MM
 */
void CTuner::operator delete(PVOID p_Object)
{
    if(p_Object != NULL)
        FreeFixedMemory(p_Object);
    _DbgPrintF( DEBUGLVL_VERBOSE,("CTuner: operator delete() succeeds\n"));

}


/*
 * SetFrequencyParam()
 * Purpose: Sets the frequency parameters for the tuner
 * Inputs : TunerFrequencyType  *p_Frequency : a frequency required to be set
 *
 * Returns: UINT: 0 - if frequency is out of range or frequency setting fails
 *                1 - if frequency is same as previous frequency
 *                2 - if new frequency has been set
 * Author : MM
 */
UINT CTuner::SetFrequencyParam(TunerFrequencyType  *p_Frequency)
{
    ULONG ulFrequency = p_Frequency->ulCurrentCFrequency;
    if((ulFrequency < m_ModeCaps[m_ulModeCapIndex].ModeCaps.ulMinFrequency) ||
        (ulFrequency > m_ModeCaps[m_ulModeCapIndex].ModeCaps.ulMaxFrequency))
        return 0;

    // If the tuning frequency has changed or the tuner mode has changed ,
    // then change the tuner frequency
    if((ulFrequency != m_ulCurrentFrequency) ||
        (m_ulPrevMode != m_ulMode))
    {
        // Set the tuner frequency
        if(!SetFrequency(ulFrequency))
            return 0;

        // Update the CTuner's frequency parameters
        MemoryCopy(&m_FrequencyParam, p_Frequency, sizeof(TunerFrequencyType));
        return 2;
    }
    return 1;
}

/*
 * GetFrequencyParam()
 * Purpose: Gets the frequency parameters for the tuner
 * Inputs : TunerFrequencyType  *p_Frequency : a frequency required to be filled
 * Output:
 * Author : MM
 */
void CTuner::GetFrequencyParam(TunerFrequencyType  *p_Frequency)
{
    MemoryCopy(p_Frequency, &m_FrequencyParam, sizeof(TunerFrequencyType));
    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\mauitune\tuner.h ===
//////////////////////////////////////////////////////////////////////////////
//
//                     (C) Philips Semiconductors-CSU and Microsoft 1999
//  All rights are reserved. Reproduction in whole or in part is prohibited
//  without the written consent of the copyright owner.
//
//  Philips reserves the right to make changes without notice at any time.
//  Philips makes no warranty, expressed, implied or statutory, including but
//  not limited to any implied warranty of merchantibility or fitness for any
//  particular purpose, or that the use will not infringe any third party
//  patent, copyright or trademark. Philips must not be liable for any loss
//  or damage arising from its use.
//
//  Tuner.H
//    CTuner Class definition.
//
//////////////////////////////////////////////////////////////////////////////

#ifndef _TUNER_H_
#define _TUNER_H_

#include "i2script.h"
#include "tunerdef.h"


class CTuner
{
public:

    CTuner(CI2CScript *p_I2CScript, BoardInfoType *p_BoardInfo, NTSTATUS *p_Status);
    ~CTuner();
 // PVOID operator new (UINT size_t);
//  void operator delete(PVOID p_Object);

    NTSTATUS SetCapabilities(BoardInfoType *p_BoardInfo);
    NTSTATUS    GetModeCapabilities(TunerModeCapsType *p_TunerModeCaps);
    NTSTATUS    SetVideoStandard(ULONG ulStandard)  ;
    void    GetVideoStandard(ULONG *p_ulStandard);
    UINT    SetInput(ULONG ulInput);
    BOOL    GetInput(ULONG *p_ulInput);
    NTSTATUS    SetMode(ULONG ulMode);
    void    GetMode(ULONG *p_ulMode);
#if 0
    UINT    SetFrequencyParam(TunerFrequencyType  *p_Frequency);
    void    GetFrequencyParam(TunerFrequencyType  *p_Frequency);
#endif

    NTSTATUS    GetPLLOffsetBusyStatus(PLONG plPLLOffset, PBOOL pbBusyStatus);

    BOOL    SetFrequency(ULONG ulFrequency);
    void    GetFrequency(ULONG *p_ulFrequency);
    BOOL    ChangeFrequency(ULONG ulFrequency);
    BOOL    TweakChannel(LONG lTweak, int iTweakReference);
    BOOL    GetNumberOfInputs(ULONG *p_ulInputs);

protected:
    USHORT  GetControlCode(ULONG ulFrequencyDivider);
    UINT    Write(UCHAR *p_ucBuffer, UINT uiNumReg, UINT uiStartAddr);
    UINT    Read(UCHAR *p_ucBuffer, UINT uiNumReg, UINT uiStartAddr);


protected:
    ULONG               m_ulPreviousFrequency;
    ULONG               m_ulCurrentFrequency;
    ULONG               m_ulMode;
    ULONG               m_ulPrevMode;
//  TunerFrequencyType  m_FrequencyParam;
    ULONG               m_ulModeCapIndex;
    TunerCapsType       m_ModeCaps[MAX_TUNER_MODES];
    ULONG               m_ulSupportedModes;
    ULONG               m_ulNumSupportedModes;
    ULONG               m_ulVideoStandard;
    CI2CScript          *m_pI2CScript;
    UINT                m_uiNumInputs;
    UCHAR               m_ucTunerAddress;
    TunerTypes          m_TunerID;
    UINT                m_ulInput;
    UINT                m_uiBoardID;

};

#endif //_TUNER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\mauitune\tunerdef.h ===
//////////////////////////////////////////////////////////////////////////////
//
//                     (C) Philips Semiconductors-CSU and Microsoft 1999
//  All rights are reserved. Reproduction in whole or in part is prohibited
//  without the written consent of the copyright owner.
//
//  Philips reserves the right to make changes without notice at any time.
//  Philips makes no warranty, expressed, implied or statutory, including but
//  not limited to any implied warranty of merchantibility or fitness for any
//  particular purpose, or that the use will not infringe any third party
//  patent, copyright or trademark. Philips must not be liable for any loss
//  or damage arising from its use.
//
//  TUNERDEF.H
//	Tuner constants and structures
//////////////////////////////////////////////////////////////////////////////

#ifndef _TUNERDEF_H_
#define _TUNERDEF_H_


// Special case for Temic Tuner, Channels 63, 64
#define kTemicControl         0x8E34
#define kAirChannel63         0x32B0
#define kAirChannel64         0x3310

// Upper low and upper mid range band definitions
#define kUpperLowBand         0x0CB0
#define kUpperMidBand         0x1F10
#define kUpperLowBand_PALD    0x0CE4
#define kUpperMidBand_PALD    0x1ED4
#define kUpperLowBand_SECAM   0x09E2
#define kUpperMidBand_SECAM   0x14D2

// Low, Mid and High band control definitions
#define kLowBand              0x8EA2
#define kMidBand              0x8E94
#define kHighBand             0x8E31
#define kLowBand_SECAM        0x8EA6
#define kMidBand_SECAM        0x8E96
#define kHighBand_SECAM       0x8E36
#define kLowBand_PALBG        0x8EA4
#define kMidBand_PALBG        0x8E94
#define kHighBand_PALBG       0x8E34
#define kLowBand_NTSC_FM      0x8EA0
#define kMidBand_NTSC_FM      0x8E90
#define kHighBand_NTSC_FM     0x8E30

// jaybo for TD1536, digital mode
#define kLowBand_1536_NTSC_D  0x8EA5	//0x8EA4
#define kMidBand_1536_NTSC_D  0x8E95	//0x8E94
#define kHighBand_1536_NTSC_D 0x8E35	//0x8E34
// jaybo for TD1536, analog mode
#define kLowBand_1536_NTSC_A  0x8EA0
#define kMidBand_1536_NTSC_A  0x8E90
#define kHighBand_1536_NTSC_A 0x8E30


#define	MAX_TUNER_MODES			2


#define		MAX_TWEAKS		5
#define		FREQUENCY_STEP	62500


typedef enum _TunerTypes
{
  FI1216,
  FI1216MF,
  FI1236,
  FI1246,
  FI1256,
  FR1216,
  FR1236,
  TD1536,        
} TunerTypes;



typedef struct              // this structure is derived from MS KSPROPERTY_TUNER_CAPS_S
{
    ULONG  ulMode;                  // Mode : ATSC, TV
    ULONG  ulStandardsSupported;    // KS_AnalogVideo_*
    ULONG  ulMinFrequency;          // Hz
    ULONG  ulMaxFrequency;          // Hz
    ULONG  ulTuningGranularity;     // Hz
    ULONG  ulNumberOfInputs;        // count of inputs
    ULONG  ulSettlingTime;          // milliSeconds
    ULONG  ulStrategy;              // KS_TUNER_STRATEGY
}TunerModeCapsType, * PTunerModeCapsType;

typedef struct
{
	TunerModeCapsType ModeCaps;		// Mode capabilities
	ULONG	ulIntermediateFrequency;	// IF value
	ULONG	ulNumberOfStandards;		// Number of video standards
 
} TunerCapsType, *PTunerCapsType;

typedef struct {
    ULONG  CurrentFrequency;            // Hz
    ULONG  PLLOffset;                   // if Strategy.KS_TUNER_STRATEGY_PLL
    ULONG  SignalStrength;              // if Stretegy.KS_TUNER_STRATEGY_SIGNAL_STRENGTH
    ULONG  Busy;                        // TRUE if in the process of tuning
} TunerStatusType, *PTunerStatusType;


#if 0
typedef struct
{
	ULONG	ulCurrentCFrequency;			// The current centre frequency
	ULONG	ulLastFrequency;				// Hz (last known good)
    ULONG	ulTuningFlags;					// KS_TUNER_TUNING_FLAGS
    ULONG	ulVideoSubChannel;				// DSS
    ULONG	ulAudioSubChannel;				// DSS
    ULONG	ulChannel;						// VBI decoders
    ULONG	ulCountry;						// VBI decoders
} TunerFrequencyType, *PTunerFrequencyType;
#endif

#endif  // _TUNERDEF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\mauitune\util.h ===
//
// Kernel-mode utility classes for minidrivers
//

#ifndef _UTIL_H_
#define _UTIL_H_

//
// _purecall must be defined in the main compile unit, not in a library
//
// the driver must define DECLARE_PURECALL once exactly somewhere
#ifdef DECLARE_PURECALL
// to handle pure virtual functions
// -- this is needed to complete the link, and can be
// called eg when a base class destructor calls a method
// that is only defined in a derived class.
//
// Alas it does not seem to be loaded correctly from a library
// and thus must be in the main module
extern "C" int _cdecl _purecall()
{
    ASSERT(FALSE);
    return 0;
}

#endif                 

#ifndef NO_GLOBAL_FUNCTION

extern	BOOL StartThread(HANDLE hHandle, void(*p_Function)(void *), PVOID p_Context);
extern	BOOL StopThread();
extern	void Delay(int iTime);
extern	PVOID AllocateFixedMemory(UINT uiSize);
extern	void FreeFixedMemory(PVOID p_vBuffer);
extern	void MemoryCopy(VOID *p_Destination, CONST VOID *p_Source, ULONG ulLength);
extern	NTSTATUS GetRegistryValue(IN HANDLE Handle, IN PWCHAR KeyNameString,       
				IN ULONG  KeyNameStringLength, IN PWCHAR Data, IN ULONG  DataLength);           
extern	BOOL StringsEqual(PWCHAR pwc1, PWCHAR pwc2);                   
extern	BOOL ConvertToNumber(PWCHAR sLine, PULONG pulNumber);                
extern	BOOL ConvertNumberToString(PWCHAR sLine, ULONG ulNumber) ;



#endif // NO_GLOBAL_FUNCTION

// mutex wrapper and auto lock/unlock class
class CMutex 
{
public:
    CMutex(ULONG level = 1) 
    {
        KeInitializeMutex(&m_Mutex, level);
    }

    void Lock() {
        KeWaitForSingleObject(&m_Mutex, Executive, KernelMode, false, NULL);
    }

    void Unlock() {
        KeReleaseMutex(&m_Mutex, false);
    }

private:
    KMUTEX m_Mutex;
};

// use c++ ctor/dtor framework to ensure unlocking
class CAutoMutex
{
public:
    CAutoMutex(CMutex* pLock)
    : m_pLock(pLock)
    {
        m_pLock->Lock();
    }
    ~CAutoMutex()
    {
        m_pLock->Unlock();
    }
private:
    CMutex* m_pLock;
};

class CPhilTimer
{
public:
	CPhilTimer();
	~CPhilTimer();

	BOOL Set(int iTimePeriod);
	void Cancel();
	BOOL Wait(int iTimeOut);

private:
	KTIMER	m_Timer;
};

#endif // _UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\mauitune\util.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//                     (C) Philips Semiconductors-CSU 1999
//  All rights are reserved. Reproduction in whole or in part is prohibited
//  without the written consent of the copyright owner.
//
//  Philips reserves the right to make changes without notice at any time.
//  Philips makes no warranty, expressed, implied or statutory, including but
//  not limited to any implied warranty of merchantibility or fitness for any
//  particular purpose, or that the use will not infringe any third party
//  patent, copyright or trademark. Philips must not be liable for any loss
//  or damage arising from its use.
//
// UTIL.CPP
//////////////////////////////////////////////////////////////////////////////

#define DECLARE_PURECALL

#include "common.h"



#define NO_GLOBAL_FUNCTION
#include "wdmdrv.h"
#include "util.h"


// global space functions definition

// Thread related functions
BOOL StartThread(HANDLE hHandle, void(*p_Function)(void *), PVOID p_Context);
BOOL StopThread();

void Delay(int iTime);

// Memory related functions
PVOID AllocateFixedMemory(UINT uiSize);
void FreeFixedMemory(PVOID p_vBuffer);
void MemoryCopy(VOID *p_Destination, CONST VOID *p_Source, ULONG ulLength);

// Registry related functions
NTSTATUS GetRegistryValue(IN HANDLE Handle, IN PWCHAR KeyNameString,
    IN ULONG  KeyNameStringLength, IN PWCHAR Data, IN ULONG  DataLength);
BOOL StringsEqual(PWCHAR pwc1, PWCHAR pwc2);
BOOL ConvertToNumber(PWCHAR sLine, PULONG pulNumber);
BOOL ConvertNumberToString(PWCHAR sLine, ULONG ulNumber) ;




/*
* StringsEqual()
* Input:    PWCHAR pwc1 - First string to compare.
            PWCHAR pwc2 - Second string to compare.
* Output:  TRUE - if equal else FALSE
* Description: Compares to UNICODE srings and checks if they are equal
*/
BOOL StringsEqual(PWCHAR pwc1, PWCHAR pwc2)
{
    UNICODE_STRING us1, us2;

    RtlInitUnicodeString(&us1, pwc1);
    RtlInitUnicodeString(&us2, pwc2);

    // case INsensitive
    return (RtlEqualUnicodeString(&us1, &us2, TRUE));
}



/*
* ConvertToNumber()
* Input:    PWCHAR sLine - String to parse.
*           PULONG pulNumber - Reference to variable to store the value.
* Output: TRUE if operation succeeded else FALSE
* Description: Converts UNICODE string to integer
*/
BOOL ConvertToNumber(PWCHAR sLine, PULONG pulNumber)
{
    UNICODE_STRING usLine;

    RtlInitUnicodeString(&usLine, sLine);

    if (!(NT_SUCCESS(RtlUnicodeStringToInteger(&usLine, 0, pulNumber))))
        return FALSE;

    return TRUE;
}

/*
* ConvertNumberToString()
* Input:    PWCHAR sLine - String to store.
*           ULONG ulNumber - Number to convert.
*
* Output: TRUE if operation succeeded else FALSE
* Description: Converts integer to UNICODE string
*/
BOOL ConvertNumberToString(PWCHAR sLine, ULONG ulNumber)
{
    UNICODE_STRING UnicodeString;
    RtlInitUnicodeString(&UnicodeString, sLine);
    if (!(NT_SUCCESS(RtlIntegerToUnicodeString(ulNumber, 10, &UnicodeString))))
        return FALSE;

    return TRUE;

}


/*
* Delay()
* Input: int iTime : its the delay required in musec
* Output:
* Description: Introduces delay corresponding to parameter passed
*/
void Delay(int iTime)
{
    LARGE_INTEGER liTime;
    liTime.QuadPart = 0 - (iTime * 10);

    // uses time in units of 100ns
    KeDelayExecutionThread(KernelMode, FALSE, &liTime);
}


BOOL StartThread(HANDLE hHandle, void(*p_Function)(void *), PVOID p_Context)
{
    if(PsCreateSystemThread( &hHandle, 0L, NULL, NULL, NULL, p_Function,
            p_Context) == STATUS_SUCCESS)
        return TRUE;
    else
        return FALSE;
}

BOOL StopThread()
{
    PsTerminateSystemThread(STATUS_SUCCESS);
    return TRUE;
}



PVOID AllocateFixedMemory(UINT uiSize)
{
    return ExAllocatePool(NonPagedPool, uiSize);
}

void FreeFixedMemory(PVOID p_vBuffer)
{
    ExFreePool(p_vBuffer);
}

void MemoryCopy(VOID *p_Destination, CONST VOID *p_Source, ULONG ulLength)
{
   RtlCopyMemory(p_Destination, p_Source, ulLength);
}


 /********************* TIMER RELATED FUNCTIONS ********************/

CPhilTimer::CPhilTimer()
{
}

CPhilTimer::~CPhilTimer()
{
    KeCancelTimer(&m_Timer);
}

BOOL CPhilTimer::Set(int iTimePeriod)
{
    // Initialize and start timer
    KeInitializeTimerEx(&m_Timer, SynchronizationTimer);

    int iTime = iTimePeriod/1000;
    // Set timer to occur every "uiTimePeriod" microseconds
    LARGE_INTEGER liTime;
    liTime.QuadPart = (LONGLONG)(0-(iTimePeriod * 10));
    if(!KeSetTimerEx(&m_Timer, liTime, iTime, NULL))
        return FALSE;
    return TRUE;
}

void CPhilTimer::Cancel()
{
    KeCancelTimer(&m_Timer);
}

BOOL CPhilTimer::Wait(int iTimeOut)
{
    LARGE_INTEGER liTime;
    liTime.QuadPart = (LONGLONG)(0-(iTimeOut * 10));
    if (KeWaitForSingleObject(&m_Timer, Executive, KernelMode,
        FALSE, &liTime) == STATUS_TIMEOUT)
        return FALSE;
    else
        return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\mauitune\vsb1.h ===
//////////////////////////////////////////////////////////////////////////////
//
//                     (C) Philips Semiconductors-CSU 1999
//  All rights are reserved. Reproduction in whole or in part is prohibited
//  without the written consent of the copyright owner.
//
//  Philips reserves the right to make changes without notice at any time.
//  Philips makes no warranty, expressed, implied or statutory, including but
//  not limited to any implied warranty of merchantibility or fitness for any
//  particular purpose, or that the use will not infringe any third party
//  patent, copyright or trademark. Philips must not be liable for any loss
//  or damage arising from its use.
//
//  VSB1.H
//  Definition of CVSB1Demod class
//////////////////////////////////////////////////////////////////////////////


#ifndef _VSB1_H_
#define _VSB1_H_

#include "vsbbase.h"

class CVSB1Demod : public CVSBDemod
{
public:

    CVSB1Demod(CI2CScript *p_I2CScript, BoardInfoType *p_BoardInfo, NTSTATUS *p_Status);
    ~CVSB1Demod();

//  PVOID operator new (UINT size_t);
//  void operator delete(PVOID p_Object);

    virtual BOOL    GetStatus(PVsbStatusType p_Status);
    virtual BOOL    InitVSB();
    BOOL            CheckHang();
    virtual void    ResetHangCounter();
    virtual BOOL    CoeffIDToAddress(UINT uiID, UINT *p_uiAddress,
            UINT    uiRegisterType);
    
    virtual BOOL    SetOutputMode(UINT uiOutputMode);
    virtual BOOL    GetOutputMode(UINT *p_uiOutputMode);
    virtual BOOL    SetDiagMode(VSBDIAGTYPE ulMode);
    virtual BOOL    GetDiagMode(ULONG *p_ulMode);
    virtual ULONG   GetDiagSpeed(ULONG ulType);

protected:
    virtual BOOL    EnableCoefficients(UCHAR ucEnable);
    virtual BOOL    DisableCoefficients();
    virtual BOOL    Initialize();



protected:
    UINT    m_uiHangCounter;
    UINT    m_uiPrevMseValue;


};

#endif //_VSB1_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\mauitune\vsb1.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//                     (C) Philips Semiconductors-CSU 1999
//  All rights are reserved. Reproduction in whole or in part is prohibited
//  without the written consent of the copyright owner.
//
//  Philips reserves the right to make changes without notice at any time.
//  Philips makes no warranty, expressed, implied or statutory, including but
//  not limited to any implied warranty of merchantibility or fitness for any
//  particular purpose, or that the use will not infringe any third party
//  patent, copyright or trademark. Philips must not be liable for any loss
//  or damage arising from its use.
//
// VSB1.CPP
//  Class CVSB1Demod Implementation
//////////////////////////////////////////////////////////////////////////////


#include "philtune.h"
#include "vsb1.h"



//VSB Initialization sequence
UCHAR VsbInitArray[17]=
{
    0x00,   //0
    0x00,   //1
    0x04,   //2
    0x00,   //3
    0x02,   //4
    0x80,   //5
    0x00,   //6
    0xca,   //7
    0x74,   //8
    0x00,   //9
    0x00,   //a
    0x00,   //b
    0xfc,   //c
    0x96,   //d
    0x66,   //e
    0x55,   //f
    0x5f    //10
};


/*
* CVSB1Demod()
* Input :
* Output:   TRUE - if initialization data can be written to I2C
*           FALSE - if there is an I2C error
* Description:  CVSB2Demod Constructor.
*/
CVSB1Demod::CVSB1Demod(CI2CScript *p_I2CScript, BoardInfoType *p_BoardInfo, NTSTATUS *p_Status)
:CVSBDemod(p_I2CScript, p_BoardInfo, p_Status)
{
    Initialize();
}

/*
* ~CVSB1Demod()
* Input :
* Output:
* Description:  CVSB1Demod Destructor.
*/
CVSB1Demod::~CVSB1Demod()
{
}

#if 0
/*
 * operator new
 * Purpose: CVSB1Demod class overrides operator new.
 *
 * Inputs : UINT uiSize       : size of the object to be placed
 *
 * Outputs: PVOID : pointer of the CVSB1Demod class object
 * Author : MM
 */
PVOID CVSB1Demod::operator new(UINT uiSize)
{
    if (uiSize != sizeof(CVSB1Demod))
    {
        _DbgPrintF( DEBUGLVL_ERROR,("CVSB1Demod: operator new() fails\n"));
        return(NULL);
    }

    return (AllocateFixedMemory(uiSize));
}

/*
 * operator delete
 * Purpose: CVSB1Demod class overrides operator delete
 *
 * Inputs : PVOID p_Buffer      : pointer to object being deleted
 *
 * Outputs:
 * Author : MM
 */
void CVSB1Demod::operator delete(PVOID p_Object)
{
    if(p_Object != NULL)
        FreeFixedMemory(p_Object);
    _DbgPrintF( DEBUGLVL_VERBOSE,("CVSB1Demod: operator delete() succeeds\n"));

}
#endif
/*
* Initialize()
* Input :
* Output:   TRUE - if initialization data can be written to I2C
*           FALSE - if there is an I2C error
* Description:  Initialize.
*/
BOOL CVSB1Demod::Initialize()
{
    m_uiMaxControlRegisterAddress = VSB1_CONTROL_SIZE - 1;
    m_uiMaxStatusRegisterAddress = VSB1_STATUS_SIZE - 1;

    return (InitVSB());
}

/*
* InitVSB()
* Input :
* Output:   TRUE - if initialization data can be written to I2C
*           FALSE - if there is an I2C error
* Description:  Initialize the VSB chip with default values.
*/
BOOL CVSB1Demod::InitVSB()
{
    MemoryCopy(m_ucControlReg, VsbInitArray, sizeof(VsbInitArray));
    // Write I2C sequence to chip
    if(Write(VsbInitArray, sizeof VsbInitArray, 0) == WDMMINI_NOERROR)
    {
        _DbgPrintF( DEBUGLVL_TERSE,("CVSB1Demod: Demodulator Init PASSED !!! ------------ \n"));
        return TRUE;
    }
    else
    {
        _DbgPrintF( DEBUGLVL_TERSE,("CVSB1Demod: Demodulator Init FAILED !!! ------------ \n"));
        return FALSE;
    }
}


/*
* GetStatus()
* Input : PVsbStatusType p_Status : pointer to Status structure
* Output:   TRUE - if status can be read from I2C
*           FALSE - if there is an I2C error
* Description:  Get chip status. The status is stored in m_8VSBStatus
*/

BOOL CVSB1Demod::GetStatus(PVsbStatusType p_Status)
{
    UCHAR ucStatus[VSB1_STATUS_SIZE];

    if(Read(ucStatus, sizeof(ucStatus), 0) != WDMMINI_NOERROR)
        return FALSE;

    p_Status->bFrontEndLock = (ucStatus[0] & 0x4) >> 2;
    p_Status->ucState = ucStatus[0] & 0x3;
    p_Status->bEqualizerLock = ((ucStatus[0] & 0x7) == 0x7) ? 1 : 0;
    p_Status->uiMse = ((UINT(ucStatus[1]) << 8) & 0xff00) |
                    (UINT(ucStatus[2]) & 0xff);
    p_Status->ucCarrierOffset = UCHAR(ucStatus[3]) & 0xff;
    // Not implemented in VSB1
    p_Status->uiSegmentErrorRate = 0;
//  _DbgPrintF( DEBUGLVL_TERSE,("CVSB1Demod::GetStatus: %x %x %x %x\n", ucStatus[0], ucStatus[1], ucStatus[2], ucStatus[3]));
    return TRUE;
}




/*
* EnableCoefficients()
* Input: UCHAR ucEnable
* Output :
* Description: Set the enable coefficients register
*/
BOOL CVSB1Demod::EnableCoefficients(UCHAR ucEnable)
{
    // Nothing is done in VSB1 as no register has to be set for reading
    // coefficients
    _DbgPrintF( DEBUGLVL_VERBOSE,("CVSB1Demod::EnableCoefficients()\n"));
    return TRUE;
}

/*
* DisableCoefficients()
* Input:
* Output :
* Description: Disable coefficient Read/Write
*/
BOOL CVSB1Demod::DisableCoefficients()
{
    // Nothing is done in VSB1 as no register has to be set for reading
    // coefficients
    _DbgPrintF( DEBUGLVL_VERBOSE,("CVSB1Demod::DisableCoefficients()\n"));
    return TRUE;
}

/*
* ResetHangCounter()
* Input:
* Output :
* Description: Reset Hang Counters
*/
void CVSB1Demod::ResetHangCounter()
{
    // Initialize parameters
    m_uiHangCounter = 0;
    m_uiPrevMseValue = 0xffff;
}


/*
* CheckHang()
* Input:
* Output :
* Description: Check VSB chip Hang
*/
BOOL CVSB1Demod::CheckHang()
{
    VsbStatusType VSBStatus;
    BOOL bReset;

    // Read status register and MSE
    if(!GetStatus(&VSBStatus))
        return TRUE; // Chip is not in HANG, hence returning TRUE


//  _DbgPrintF( DEBUGLVL_VERBOSE,("CPhilipsWDMTuner::TimerRoutine(): Prev MSE = %x Curent MSE = %x\n",
//  *p_uiMseValue, VSBStatusItem.Mse));

    bReset = TRUE;
    if (VSBStatus.ucState == 0x1)
    {
        // Check Hang
        if(m_uiPrevMseValue == VSBStatus.uiMse)// Is VSB State = 1 and mse = previous mse
        {
            bReset = FALSE;
            _DbgPrintF( DEBUGLVL_VERBOSE,("CVSB1Demod::TimerRoutine(): Increment HC \n"));
            // Is the hang counter count > 800ms ( hang counter
            // = 8 as interrupt occurs every 100 ms)
            if(++(m_uiHangCounter) > 8)
            {
                m_uiHangCounter = 0;    // Reset Hang Counter
                _DbgPrintF( DEBUGLVL_VERBOSE,("CVSB1Demod::TimerRoutine(): Chip Hang. Resetting\n"));

                SoftwareReset(VSB_GENERAL_RESET);
                return TRUE ;
            }
        }
    }

    if (bReset == TRUE)
    {
        // Reset the Hang counter if the the chip is not in
        // State 1 as the chip hangs only in State 1
        m_uiHangCounter = 0;
        // Save current MSE
        m_uiPrevMseValue = VSBStatus.uiMse;
//      _DbgPrintF( DEBUGLVL_VERBOSE,("CPhilipsWDMTuner::TimerRoutine(): Prev MSE = %x \n",
//          m_PrevMseValue));

    }
    return FALSE;
}

/*
* CoeffIDToAddress()
* Input: UINT uiID - ID
*        UINT *p_uiAddress - The address pointer
* Output :  TRUE: If ID can be translated
*           FALSE: IF ID does not exist
* Description: Translate coefficient ID to address
*/
BOOL CVSB1Demod::CoeffIDToAddress(UINT uiID, UINT *p_uiAddress,
                                  UINT uiRegisterType)
{
    _DbgPrintF( DEBUGLVL_VERBOSE,("CVSB1Demod::CoeffIDToAddress()\n"));
    switch(uiID)
    {
    case EQUALIZER_ID:
        if(uiRegisterType == WRITE_REGISTERS)
            *p_uiAddress = VSB1_CTRL_REG_EQUALIZER_COEFF;
        else
            *p_uiAddress = VSB1_STATUS_REG_EQUALIZER_COEFF;

        break;

    default:
        *p_uiAddress = 0;
        return FALSE;
    }

    return TRUE;
}


/*
* SetOutputMode()
* Input:
* Output :
* Description: Set The output mode (Normal/Diagnostic/Bypass)
*/
BOOL CVSB1Demod::SetOutputMode(UINT uiOutputMode)
{
    RegisterType Control;
    UCHAR ucOutput;
    UCHAR ucMask;

    ucOutput = m_ucControlReg[VSB1_REG_OUTPUT] & VSB1_TS_OUT_MODE_MASK;

    if(uiOutputMode == VSB_OUTPUT_MODE_NORMAL)
    {}
    else if(uiOutputMode == VSB_OUTPUT_MODE_DIAGNOSTIC)
        ucOutput |= 0x80;
    else if(uiOutputMode == VSB_OUTPUT_MODE_BYPASS)
        ucOutput |= 0x40;
    else
        return FALSE;

    Control.uiAddress = VSB1_REG_OUTPUT;
    Control.uiLength = 1;
    Control.p_ucBuffer = &ucOutput;

    // Reset chip
    if(SetControlRegister(&Control, 1) != WDMMINI_NOERROR)
        return FALSE;
    return TRUE;
}

/*
* GetOutputMode()
* Input:
* Output :
* Description: Get The output mode (Normal/Diagnostic/Bypass)
*/
BOOL CVSB1Demod::GetOutputMode(UINT *p_uiOutputMode)
{
    RegisterType Control;
    UCHAR ucOutput;
    UCHAR ucMask;

    ucOutput = m_ucControlReg[VSB1_REG_OUTPUT] & (~VSB1_TS_OUT_MODE_MASK);
    if(ucOutput == 0)
        *p_uiOutputMode = VSB_OUTPUT_MODE_NORMAL;
    else if(ucOutput == 0x40)
        *p_uiOutputMode = VSB_OUTPUT_MODE_BYPASS;
    else
        *p_uiOutputMode = VSB_OUTPUT_MODE_DIAGNOSTIC;

    return TRUE;
}


/*
* SetDiagMode()
* Input: ULONG ulMode - Diagnostic mode(enumeration VSBDIAGTYPE)
* Output :
* Description: Set The diag mode
*/
BOOL CVSB1Demod::SetDiagMode(VSBDIAGTYPE ulMode)
{
    RegisterType Control;
    UCHAR ucOutput;
    UCHAR ucMask;

    ucOutput = m_ucControlReg[VSB1_REG_OUTPUT] & VSB1_DIAG_MODE_MASK;

    if((((LONG)ulMode >= EQUALIZER_OUT) && (ulMode <= TRELLIS_DEC_DIAG_OUT)) ||
        ((ulMode >= TRELLIS_DEC_OUT) && (ulMode <= REED_SOLOMON_DIAG_OUT)))
    {
        Control.uiAddress = VSB1_REG_OUTPUT;
        Control.uiLength = 1;
        Control.p_ucBuffer = &ucOutput;

        // Send Diag type to chip
        if(SetControlRegister(&Control, 1) != WDMMINI_NOERROR)
            return FALSE;
        return TRUE;
    }
    else
        return FALSE;
}

/*
* GetDiagMode()
* Input: ULONG *p_ulMode - pointer to diagnostic mode
* Output :  Diagnostic mode (enumeration VSBDIAGTYPE)
* Description: Get The Diag mode
*/
BOOL CVSB1Demod::GetDiagMode(ULONG *p_ulMode)
{
    RegisterType Control;
    UCHAR ucOutput;
    UCHAR ucMask;

    *p_ulMode = (UINT)(m_ucControlReg[VSB1_REG_OUTPUT]) & (~VSB1_DIAG_MODE_MASK);
    return TRUE;
}


/*
* GetDiagSpeed()
* Input: ULONG ulType - Diagnostic type
* Output :  Diagnostic speed
* Description: Get The Diagnostic data speed
*/
ULONG CVSB1Demod::GetDiagSpeed(ULONG ulType)
{
    RegisterType Control;
    UCHAR ucOutput;
    UCHAR ucMask;
    ULONG ulSpeed;

    ucOutput = m_ucControlReg[VSB1_REG_OUTPUT] & (~VSB1_TS_OUT_MODE_MASK);
        switch(ulType)
    {
    case EQUALIZER_OUT:
    case CR_ERROR:
    case TR_ERROR:
    case EQUALIZER_IN:
    case TRELLIS_DEC_DIAG_OUT:

        ulSpeed = TENPOINT76MHZ;
        break;

    case TRELLIS_DEC_OUT:
    case REED_SOLOMON_DIAG_OUT:

        ulSpeed = TWOPOINT69MHZ;
        break;

    default:
        ulSpeed = 0;
        break;
    }

    return ulSpeed;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\mauitune\vsb2.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//                     (C) Philips Semiconductors-CSU 1999
//  All rights are reserved. Reproduction in whole or in part is prohibited
//  without the written consent of the copyright owner.
//
//  Philips reserves the right to make changes without notice at any time.
//  Philips makes no warranty, expressed, implied or statutory, including but
//  not limited to any implied warranty of merchantibility or fitness for any
//  particular purpose, or that the use will not infringe any third party
//  patent, copyright or trademark. Philips must not be liable for any loss
//  or damage arising from its use.
//
// VSB2.CPP
//  Class CVSB2Demod Implementation
//////////////////////////////////////////////////////////////////////////////


#include "philtune.h"
#include "vsb2.h"


UCHAR Vsb2InitArray[] =
{   0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x20, 0x0E, 0x04, 0x80,
    0x00, 0x00, 0x00, 0x44 ,0x24,
    0x00, 0x80, 0x02, 0x80, 0x00,
    0xCA, 0xFC, 0x96, 0x66, 0x22,
    0x2F, 0x00, 0xFC, 0x96, 0x66,
    0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x20, 0x00, 0x40, 0x00,
    0x60, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x04, 0x38, 0x00,
    0x00, 0x00, 0x00, 0x00};

/*
* CVSB2Demod()
* Input :
* Output:
* Description:  CVSB2Demod Constructor.
*/
CVSB2Demod::CVSB2Demod(CI2CScript *p_I2CScript, BoardInfoType *p_BoardInfo, NTSTATUS *p_Status)
:CVSBDemod(p_I2CScript, p_BoardInfo, p_Status)
{
    Initialize();
}

/*
* ~CVSB2Demod()
* Input :
* Output:
* Description:  CVSB2Demod Destructor.
*/
CVSB2Demod::~CVSB2Demod()
{
}


#if 0
/*
 * operator new
 * Purpose: CVSB2Demod class overrides operator new.
 *
 * Inputs : UINT uiSize       : size of the object to be placed
 *
 * Outputs: PVOID : pointer of the CVSB2Demod class object
 * Author : MM
 */
PVOID CVSB2Demod::operator new(UINT uiSize)
{
    if (uiSize != sizeof(CVSB2Demod))
    {
        _DbgPrintF( DEBUGLVL_ERROR,("CVSB2Demod: operator new() fails\n"));
        return(NULL);
    }

    return (AllocateFixedMemory(uiSize));
}

/*
 * operator delete
 * Purpose: CVSB2Demod class overrides operator delete
 *
 * Inputs : PVOID p_Buffer      : pointer to object being deleted
 *
 * Outputs:
 * Author : MM
 */
void CVSB2Demod::operator delete(PVOID p_Object)
{
    if(p_Object != NULL)
        FreeFixedMemory(p_Object);
    _DbgPrintF( DEBUGLVL_VERBOSE,("CVSB2Demod: operator delete() succeeds\n"));

}
#endif

/*
* Initialize()
* Input :
* Output:   TRUE - if initialization data can be written to I2C
*           FALSE - if there is an I2C error
* Description:  Initialize.
*/
BOOL CVSB2Demod::Initialize()
{
    m_uiMaxControlRegisterAddress = VSB2_CONTROL_SIZE - 1;

    //Mini: 2/18/2000
    // Adding a check to see if the version status register exists, this indicates
    // that its verison N1E or higher
    UCHAR ucStatus[VSB2_STATUS_SIZE+1];
    ucStatus[VSB2_STATUS_SIZE] = 0;
    Read(ucStatus, VSB2_STATUS_SIZE+1, 0);
    if(ucStatus != 0)
        m_uiMaxStatusRegisterAddress = VSB2_STATUS_SIZE;
    else
        m_uiMaxStatusRegisterAddress = VSB2_STATUS_SIZE - 1;
    return TRUE;
    //  return (InitVSB());
}

/*
* InitVSB()
* Input :
* Output:   TRUE - if initialization data can be written to I2C
*           FALSE - if there is an I2C error
* Description:  Initialize the VSB chip with default values.
*/
BOOL CVSB2Demod::InitVSB()
{
    BOOL bResult;

    MemoryCopy(m_ucControlReg, Vsb2InitArray, sizeof(Vsb2InitArray));
    // Write I2C sequence to chip
    bResult = m_pI2CScript->WriteSeq(VSB_I2C_ADDRESS, Vsb2InitArray,
            sizeof Vsb2InitArray);
    if (bResult)
    {
        _DbgPrintF( DEBUGLVL_VERBOSE,("CVSB2Demod: Demodulator Init PASSED !!! ------------ \n"));
    }
    else
    {
        _DbgPrintF( DEBUGLVL_ERROR,("CVSB2Demod: Demodulator Init FAILED !!! ------------ \n"));
    }

//  return (bResult & bResult1);

    return bResult;
}


/*
* GetStatus()
* Input : PVsbStatusType p_Status : pointer to Status structure
* Output:   TRUE - if status can be read from I2C
*           FALSE - if there is an I2C error
* Description:  Get chip status.
*/

BOOL CVSB2Demod::GetStatus(PVsbStatusType p_Status)
{

    BOOL bResult;
    UINT uiNumCoeff;
    UINT uiLength;
    UCHAR ucStatus[VSB2_STATUS_SIZE+1];
    Vsb2StatusType  AllStatus;

    if(GetStatus(&AllStatus))
    {
        MemoryCopy(p_Status, &AllStatus.Status, sizeof(VsbStatusType));
        return TRUE;
    }
    else
        return FALSE;
}


/*
* GetStatus()
* Input : PVsb2StatusType p_Status : pointer to Status structure
* Output:   TRUE - if status can be read from I2C
*           FALSE - if there is an I2C error
* Description:  Get chip status.
*/

BOOL CVSB2Demod::GetStatus(PVsb2StatusType p_Status)
{

    BOOL bResult;
    UINT uiNumCoeff;
    UINT uiLength;
    UCHAR ucStatus[VSB2_STATUS_SIZE+1];

    m_RegisterLock.Lock();
    RegisterType Status;
    Status.uiAddress = 0;
    Status.uiLength = m_uiMaxStatusRegisterAddress+1; //VSB2_STATUS_SIZE
    Status.p_ucBuffer = ucStatus;

    if(ReadStatusReg(&Status, 1) == WDMMINI_NOERROR)
        bResult = TRUE;
    else
        bResult = FALSE;

    m_RegisterLock.Unlock();

    if(bResult == TRUE)
    {
        p_Status->Status.bFrontEndLock = (ucStatus[VSB_REG_STATE] & 0x4) >> 2;
        p_Status->Status.ucState = ucStatus[VSB_REG_STATE] & 0x3;
        p_Status->Status.bEqualizerLock =
            ((ucStatus[VSB_REG_STATE] & 0x7) == 0x7) ? 1 : 0;
        p_Status->Status.uiMse =
            ((UINT(ucStatus[VSB2_REG_MSE_1]) << 8) & 0xff00) |
            (UINT(ucStatus[VSB2_REG_MSE_2]) & 0xff);
        p_Status->Status.ucCarrierOffset =
            UCHAR(ucStatus[VSB2_REG_CARRIER_OFFSET]) & 0xff;
        p_Status->Status.uiSegmentErrorRate =
            ((UINT(ucStatus[VSB2_REG_SER_1]) << 8) & 0xff00) |
            (UINT(ucStatus[VSB2_REG_SER_2]) & 0xff);
        p_Status->bCorrelatorError =
            (ucStatus[VSB2_REG_CORRELATOR] & 0x2) >> 1;
        p_Status->bCorrelatorFull =
            ucStatus[VSB2_REG_CORRELATOR] & 0x1;
    }
//  _DbgPrintF( DEBUGLVL_TERSE,("CPhilipsWDMTuner:VSB status = %x %x %x %x\n",m_8VSBStatus[0], m_8VSBStatus[1],
//    m_8VSBStatus[2], m_8VSBStatus[3]));

    return(bResult);
}

/*
* EnableCoefficients()
* Input: UCHAR ucEnable
* Output :
* Description: Set the enable coefficients register
*/
BOOL CVSB2Demod::EnableCoefficients(UCHAR ucEnable)
{
    _DbgPrintF( DEBUGLVL_VERBOSE,("CVSB2Demod::EnableCoefficients()\n"));
/*  if(ucEnable & CORRELATOR_ID)
    {
        if(!EnableCorrelatorRead())
            return FALSE;
        if(!WaitForCorrelatorFull())
            return FALSE;
    }
*/
    m_ucControlReg[VSB2_REG_COEFFICIENT_ENABLE] |= ucEnable;
    if(Write(m_ucControlReg, (VSB2_REG_COEFFICIENT_ENABLE + 1), 0)== WDMMINI_NOERROR)
        return TRUE;
    else
        return FALSE;
}

/*
* DisableCoefficients()
* Input:
* Output :
* Description: Disable coefficient read/write
*/
BOOL CVSB2Demod::DisableCoefficients(UINT ucEnable)
{
    _DbgPrintF( DEBUGLVL_VERBOSE,("CVSB2Demod::DisableCoefficients()\n"));
//  m_ucControlReg[VSB2_REG_COEFFICIENT_ENABLE] = 0;
    m_ucControlReg[VSB2_REG_COEFFICIENT_ENABLE] &= (~ucEnable);
    if(Write(m_ucControlReg, (VSB2_REG_COEFFICIENT_ENABLE + 1), 0)!= WDMMINI_NOERROR)
        return FALSE;
    else
        return TRUE;
}

/*
* DisableCoefficients()
* Input:
* Output :
* Description: Disable coefficient read/write
*/
BOOL CVSB2Demod::DisableCoefficients()
{
    _DbgPrintF( DEBUGLVL_VERBOSE,("CVSB2Demod::DisableCoefficients()\n"));
    m_ucControlReg[VSB2_REG_COEFFICIENT_ENABLE] = 0;
    if(Write(m_ucControlReg, (VSB2_REG_COEFFICIENT_ENABLE + 1), 0)!= WDMMINI_NOERROR)
        return FALSE;
    else
        return TRUE;
}
BOOL CVSB2Demod::EnableCorrelatorRead()
{
    // Reset correlator ?????
//  m_ucControlReg[VSB2_CTRL_REG_CORRELATOR] |= 0x08;
//  if(Write(m_ucControlReg, (VSB2_CTRL_REG_CORRELATOR + 1), 0) != WDMMINI_NOERROR)
//      return FALSE;

    // should I set the correlator length too based on the length passed in
    // property set . I don't think so as there will be no information on the
    // start and end

    // Clear reset and Set correlator fill flag
//  m_ucControlReg[VSB2_CTRL_REG_CORRELATOR] &= 0xF7;
    m_ucControlReg[VSB2_CTRL_REG_CORRELATOR] |= 0x10;

    if(Write(m_ucControlReg, (VSB2_CTRL_REG_CORRELATOR + 1), 0)!= WDMMINI_NOERROR)
        return FALSE;

    return TRUE;
}

BOOL CVSB2Demod::WaitForCorrelatorFull()
{
    UCHAR ucStatus[10];
    UINT    uiTimeout = 100;
    while(uiTimeout)
    {
        if(Read(ucStatus, sizeof(ucStatus), 0)!= WDMMINI_NOERROR)
            return FALSE;
        if(ucStatus[VSB2_REG_CORRELATOR] & 0xFE)
            break;
        // Delay of 100ms
        Delay(100000);
        uiTimeout--;
    }

    // Disable Correlator FILL
    m_ucControlReg[VSB2_CTRL_REG_CORRELATOR] &= 0xEF;
    Write(m_ucControlReg, (VSB2_CTRL_REG_CORRELATOR + 1), 0);

    if(uiTimeout == 0)
        return FALSE;

    return TRUE;
}



/*
* CoeffIDToAddress()
* Input: UINT uiID - ID
*        UINT *p_uiAddress - The address pointer
* Output :  TRUE: If ID can be translated
*           FALSE: IF ID does not exist
* Description: Translate coefficient ID to address
*/
BOOL CVSB2Demod::CoeffIDToAddress(UINT uiID, UINT *p_uiAddress,
                                  UINT uiRegisterType)
{
    _DbgPrintF( DEBUGLVL_VERBOSE,("CVSB2Demod::CoeffIDToAddress()\n"));

    if(uiRegisterType == WRITE_REGISTERS)
    {
        switch(uiID)
        {
        case EQUALIZER_ID:
            *p_uiAddress = VSB2_CTRL_REG_EQUALIZER_COEFF;
            break;

        case EQUALIZER_CLUSTER_ID:
            *p_uiAddress = VSB2_CTRL_REG_EQUALIZER_CLUSTER_COEFF;
            break;

        case SYNC_ENHANCER_ID:
            *p_uiAddress = VSB2_CTRL_REG_SYNC_ENHANCER_COEFF;
            break;

        case NTSC_COCHANNEL_REJECTION_ID:
            *p_uiAddress = VSB2_CTRL_REG_COCHANNEL_REJECTION_COEFF;
            break;

        default:
            *p_uiAddress = 0;
            return FALSE;
        }
    }
    else
    {
        switch(uiID)
        {
        case EQUALIZER_ID:
            *p_uiAddress = VSB2_STATUS_REG_EQUALIZER_COEFF;
            break;

        case EQUALIZER_CLUSTER_ID:
            *p_uiAddress = VSB2_STATUS_REG_EQUALIZER_CLUSTER_COEFF;
            break;

        case SYNC_ENHANCER_ID:
            *p_uiAddress = VSB2_STATUS_REG_SYNC_ENHANCER_COEFF;
            break;

        case NTSC_COCHANNEL_REJECTION_ID:
            *p_uiAddress = VSB2_STATUS_REG_COCHANNEL_REJECTION_COEFF;
            break;

        case CORRELATOR_ID:
            *p_uiAddress = VSB2_REG_CORRELATOR_COEFF;
            break;

        default:
            *p_uiAddress = 0;
            return FALSE;
        }
    }
    return TRUE;
}


/*
* SetOutputMode()
* Input:
* Output :
* Description: Set The output mode (Normal/Diagnostic/ITU656/Serialized input)
*/
BOOL CVSB2Demod::SetOutputMode(UINT uiOutputMode)
{
    RegisterType Control;
    UCHAR ucOutput;
    UCHAR ucMask;

    ucOutput = m_ucControlReg[VSB2_REG_TS_OUT_1] & VSB2_TS_OUT_MODE_MASK;
    ucOutput |= (uiOutputMode << 2); // shifted by 2 bits

    Control.uiAddress = VSB2_REG_TS_OUT_1;
    Control.uiLength = 1;
    Control.p_ucBuffer = &ucOutput;

    // Reset chip
    if(SetControlRegister(&Control, 1) != WDMMINI_NOERROR)
        return FALSE;
    return TRUE;
}

/*
* GetOutputMode()
* Input:
* Output :
* Description: Get The output mode (Normal/Diagnostic/ITU656/Serialized input)
*/
BOOL CVSB2Demod::GetOutputMode(UINT *p_uiOutputMode)
{
    RegisterType Control;
    UCHAR ucOutput;
    UCHAR ucMask;

    ucOutput = m_ucControlReg[VSB2_REG_TS_OUT_1] & (~VSB2_TS_OUT_MODE_MASK);
    ucOutput >>= 2 ; // sifted by 2 bits
    *p_uiOutputMode = (UINT)(ucOutput & 0x3); // mask of all bits but the 2 LSBs
    return TRUE;
}


/*
* SetDiagMode()
* Input: ULONG ulMode - Diagnostic mode(enumeration VSBDIAGTYPE)
* Output :
* Description: Set The diag mode
*/
BOOL CVSB2Demod::SetDiagMode(VSBDIAGTYPE ulMode)
{
    RegisterType Control;
    UCHAR ucOutput;
    UCHAR ucMask;

    if((((LONG)ulMode >= EQUALIZER_OUT) && (ulMode <= TRELLIS_DEC_DIAG_OUT)) ||
        ((ulMode >= TRELLIS_DEC_OUT) && (ulMode <= SRC_OUT)))
    {
        ucOutput = UCHAR(ulMode);
        Control.uiAddress = VSB2_REG_DIAG_SELECT;
        Control.uiLength = 1;
        Control.p_ucBuffer = &ucOutput;

        // Reset chip
        if(SetControlRegister(&Control, 1) != WDMMINI_NOERROR)
            return FALSE;
        return TRUE;
    }
    else
        return FALSE;
}

/*
* GetDiagMode()
* Input: ULONG *p_ulMode - pointer to diagnostic mode
* Output :  Diagnostic mode (enumeration VSBDIAGTYPE)
* Description: Get The Diag mode
*/
BOOL CVSB2Demod::GetDiagMode(ULONG *p_ulMode)
{
    RegisterType Control;
    UCHAR ucOutput;
    UCHAR ucMask;

    *p_ulMode = (UINT)(m_ucControlReg[VSB2_REG_DIAG_SELECT]) &
                        (~VSB2_DIAG_MODE_MASK);
    return TRUE;
}


/*
* GetDiagSpeed()
* Input: ULONG ulType - Diagnostic type
* Output :  Diagnostic speed
* Description: Get The Diagnostic data speed
*/
ULONG CVSB2Demod::GetDiagSpeed(ULONG ulType)
{
    RegisterType Control;
    UCHAR ucOutput;
    UCHAR ucMask;
    ULONG ulSpeed;

    switch(ulType)
    {
    case EQUALIZER_OUT:
    case CR_ERROR:
    case TR_ERROR:
    case EQUALIZER_IN:
    case TRELLIS_DEC_DIAG_OUT:
    case SYNC_ENHANCER_REAL_IN:

        ulSpeed = TENPOINT76MHZ;
        break;

    case TRELLIS_DEC_OUT:
    case REED_SOLOMON_DIAG_OUT:

        ulSpeed = TWOPOINT69MHZ;
        break;

    case SRC_OUT:

        ulSpeed = TWENTYONEPOINT52MHZ;
        break;

    default:
        ulSpeed = 0;
        break;
    }

    return ulSpeed;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\mauitune\vsbbase.h ===
//////////////////////////////////////////////////////////////////////////////
//
//                     (C) Philips Semiconductors-CSU 1999
//  All rights are reserved. Reproduction in whole or in part is prohibited
//  without the written consent of the copyright owner.
//
//  Philips reserves the right to make changes without notice at any time.
//  Philips makes no warranty, expressed, implied or statutory, including but
//  not limited to any implied warranty of merchantibility or fitness for any
//  particular purpose, or that the use will not infringe any third party
//  patent, copyright or trademark. Philips must not be liable for any loss
//  or damage arising from its use.
//
//  VSBBASE.H
//  Definition of CVSBDemod class
//////////////////////////////////////////////////////////////////////////////


#ifndef _VSBBASE_H_
#define _VSBBASE_H_

#include "wdmdrv.h"
#include "i2script.h"
#include "util.h"
#include "ksvsb.h"
#include "vsbdef.h"


class CVSBDemod
{
public:

    CVSBDemod(CI2CScript *p_I2CScript, BoardInfoType *p_BoardInfo, NTSTATUS *p_Status);
    
    virtual UINT SetRegisterList(RegisterType *p_Registers, UINT uiNumRegisters);
    virtual UINT GetRegisterList(RegisterType *p_Registers, UINT uiNumRegisters,
                                UINT uiRegisterType);
    virtual UINT    SetCoeff(VsbCoeffType *p_Coeff, UINT uiNumCoeff);
    virtual UINT    GetCoeff(VsbCoeffType *p_Coeff, UINT uiNumCoeff);


    virtual UINT SetControlRegister(RegisterType *p_Registers,
                                UINT uiNumRegisters);
    virtual UINT GetControlRegister(RegisterType *p_registers,
                                UINT uinum_registers);
    virtual UINT GetStatusRegister(RegisterType *p_Registers,
                                UINT uiNumRegisters);

    virtual UINT WriteControlReg(RegisterType *p_Registers, UINT uiNumRegisters,
                                BOOL bWrite);
    virtual UINT ReadStatusReg(RegisterType *p_Registers, UINT uiNumRegisters);

    virtual BOOL IsVSBLocked();
    virtual BOOL SoftwareReset(ULONG ulResetCtrl);
    virtual BOOL InitVSB() = 0;
    virtual BOOL CoeffIDToAddress(UINT uiID, UINT *p_uiAddress,
                    UINT uiRegisterType) = 0;
    virtual BOOL GetStatus(PVsbStatusType p_Status) = 0;

    virtual BOOL    SetOutputMode(UINT uiOutputMode) = 0;
    virtual BOOL    GetOutputMode(UINT *p_uiOutputMode) = 0;
    virtual BOOL    SetDiagMode(VSBDIAGTYPE ulMode) = 0;
    virtual BOOL    GetDiagMode(ULONG *p_ulMode) = 0;
    virtual ULONG   GetDiagSpeed(ULONG ulType) = 0;

protected:
    virtual UINT WriteCoeff(VsbCoeffType **pp_Coeff, UINT uiNumCoeff);
    virtual UINT ReadCoeff(VsbCoeffType **pp_Coeff, UINT uiNumCoeff);
    virtual UINT Write(UCHAR *p_ucBuffer, UINT uiNumReg, UINT uiStartAddr);
    virtual UINT Read(UCHAR *p_ucBuffer, UINT uiNumReg, UINT uiStartAddr);

    virtual BOOL EnableCoefficients(UCHAR ucEnable) = 0;
    virtual BOOL DisableCoefficients() = 0;
    virtual BOOL Initialize() = 0;


protected:
    UCHAR       m_ucControlReg[MAX_VSB_REGISTERS];
    CMutex      m_RegisterLock;
    UCHAR       m_ucI2CBuffer[MAX_VSB_BUF_SIZE];
    CI2CScript  *m_pI2CScript;
    UCHAR       m_ucVsbDemodAddress;
    UINT        m_uiMaxControlRegisterAddress;
    UINT        m_uiMaxStatusRegisterAddress;

};



#endif //_VSBBASE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\mauitune\vsbbase.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//                     (C) Philips Semiconductors-CSU 1999
//  All rights are reserved. Reproduction in whole or in part is prohibited
//  without the written consent of the copyright owner.
//
//  Philips reserves the right to make changes without notice at any time.
//  Philips makes no warranty, expressed, implied or statutory, including but
//  not limited to any implied warranty of merchantibility or fitness for any
//  particular purpose, or that the use will not infringe any third party
//  patent, copyright or trademark. Philips must not be liable for any loss
//  or damage arising from its use.
//
// VSBBASE.CPP
//////////////////////////////////////////////////////////////////////////////


#include "philtune.h"
#include "vsbbase.h"


/*
* CVSBDemod()
* Input :
* Output:   TRUE - if initialization data can be written to I2C
*           FALSE - if there is an I2C error
* Description:  CVSBDemod Constructor.
*/
CVSBDemod::CVSBDemod(CI2CScript *p_I2CScript, BoardInfoType *p_BoardInfo, NTSTATUS *p_Status)
:m_RegisterLock(1)
{
    m_pI2CScript = p_I2CScript;
    m_ucVsbDemodAddress = VSB_I2C_ADDRESS;
}


/*
* SetRegisterList()
* Input:
* Output:
* Description:
*/
UINT CVSBDemod::SetRegisterList(RegisterType *p_Registers, UINT uiNumRegisters)
{
    return SetControlRegister(p_Registers, uiNumRegisters);
}

/*
* GetRegisterList()
* Input:
* Output:
* Description:
*/
UINT CVSBDemod::GetRegisterList(RegisterType *p_Registers, UINT uiNumRegisters,
                                UINT uiRegisterType)
{

    if(uiRegisterType == CONTROL_REGISTER)
    {
        return GetControlRegister(p_Registers, uiNumRegisters);
    }
    else if(uiRegisterType == STATUS_REGISTER)
    {
        return GetStatusRegister(p_Registers, uiNumRegisters);
    }
    else{}

        return WDMMINI_INVALIDPARAM;
}



/*
* SetCoeff()
* Input:VsbCoeffType *p_Coeff - pointer to the coefficients register
*                               structure
*       UINT uiNumCoeff -  Number of coefficients
* Output : UINT - Error code
* Description: Lock register access and Set the coefficients into the chip
*/
UINT CVSBDemod::SetCoeff(VsbCoeffType *p_Coeff, UINT uiNumRegisters)
{
    UINT uiResult;
    UINT i;

    // Lock the Register control handle
    m_RegisterLock.Lock();
    VsbCoeffType *pp_TempCoeff[MAX_VSB_COEFF];

    UCHAR ucEnable = 0;

    if (p_Coeff != NULL)
    {
        for (i = 0; i < uiNumRegisters; i++)
        {
            pp_TempCoeff[i] = &p_Coeff[i];
            ucEnable |= p_Coeff[i].uiID;
        }

        if(!EnableCoefficients(ucEnable))
        {
            uiResult = WDMMINI_HARDWAREFAILURE;
            goto errexit;
        }
        uiResult = WriteCoeff(pp_TempCoeff, uiNumRegisters);
        if(!DisableCoefficients())
        {
            uiResult = WDMMINI_HARDWAREFAILURE;
            goto errexit;
        }
    }
    else
    {
        _DbgPrintF( DEBUGLVL_ERROR,("CVSBDemod::WriteCoeff() No Coeff !!! \n"));
        uiResult = WDMMINI_INVALIDPARAM;
    }

errexit:
    m_RegisterLock.Unlock();

    return uiResult;
}


/*
* GetCoeff()
* Input:VsbCoeffType *p_Coeff - pointer to the coefficients register
*                               structure
*       UINT uiNumCoeff -  Number of coefficients
* Output : UINT - Error code
* Description: Lock register access and Get the coefficients from the chip
*/
UINT CVSBDemod::GetCoeff(VsbCoeffType *p_Coeff, UINT uiNumRegisters)
{
    UINT uiResult;
    UINT i;
    UCHAR ucEnable = 0;

    // Lock the Register control handle
    m_RegisterLock.Lock();

    VsbCoeffType *pp_TempCoeff[MAX_VSB_COEFF];

    if (p_Coeff != NULL)
    {
        for (i = 0; i < uiNumRegisters; i++)
        {
            pp_TempCoeff[i] = &p_Coeff[i];
            ucEnable |= p_Coeff[i].uiID;
        }

        if(!EnableCoefficients(ucEnable))
        {
            uiResult = WDMMINI_HARDWAREFAILURE;
            goto errexit;

        }
        uiResult = ReadCoeff(pp_TempCoeff, uiNumRegisters);
        if(!DisableCoefficients())
        {
            uiResult = WDMMINI_HARDWAREFAILURE;
            goto errexit;
        }
    }
    else
    {
        _DbgPrintF( DEBUGLVL_ERROR,("CVSBDemod::ReadAndCreateRegisters() No Coeff !!! \n"));
        uiResult = WDMMINI_INVALIDPARAM;
    }

errexit:
    m_RegisterLock.Unlock();
    return uiResult;

}

/*
* SetControlRegister()
* Input:
* Output:
* Description:
*/
UINT CVSBDemod::SetControlRegister(RegisterType *p_Registers,
                                UINT uiNumRegisters)
{
    int i;
    UINT uiResult;
    UINT uiPrevAddress = 0;

    m_RegisterLock.Lock();
    uiResult = WriteControlReg(p_Registers, uiNumRegisters, TRUE);
    m_RegisterLock.Unlock();
    return uiResult;
}


/*
* GetControlRegister()
* Input:
* Output:
* Description:
*/
UINT CVSBDemod::GetControlRegister(RegisterType *p_Registers,
                                UINT uiNumRegisters)
{
    UINT i, a, b;
    RegisterType Temp;
    UINT    uiResult = WDMMINI_NOERROR;

    // This read operation is a shadow operation. The values in the control
    // regsiter (in memory) is passed back

    // Lock the Register control handle
    m_RegisterLock.Lock();

    // Write data into control registers (memory)
    for (i = 0; i < uiNumRegisters; i++)
    {
        // Check to see that the address is within the specified
        // range for the chip
        UINT    uiAddr = p_Registers[i].uiAddress;
        if ( uiAddr <= m_uiMaxControlRegisterAddress)
        {
            // Copy the register values from the control register
            // in memory
            MemoryCopy(p_Registers[i].p_ucBuffer, &m_ucControlReg[uiAddr],
                    p_Registers[i].uiLength);
        }
        else
        {
            uiResult = WDMMINI_INVALIDPARAM;
            break;
        }
    }
    m_RegisterLock.Unlock();

    return uiResult;
}

/*
* GetStatusRegister()
* Input:
* Output:
* Description:
*/
UINT CVSBDemod::GetStatusRegister(RegisterType *p_Registers,
                                UINT uiNumRegisters)
{
    UINT    uiResult;

    // Lock the Register control handle
    m_RegisterLock.Lock();
    uiResult = ReadStatusReg(p_Registers, uiNumRegisters);
    m_RegisterLock.Unlock();
    return uiResult;
}



/*
* WriteControlReg()
* Input:RegisterType *p_reg_list-   Register list to be written to control registers
        int i_num_reg -  Number of registers in the list
* Output : UINT - Error code
* Description: Update the control registers and write to chip
*/

UINT CVSBDemod::WriteControlReg(RegisterType *p_Registers, UINT uiNumRegisters,
                                BOOL bWrite)
{
    UINT uiResult = WDMMINI_NOERROR;
    UINT i;
    UINT uiPrevAddress;
    UINT uiLastAddress;

    UINT uiAddress;
    uiPrevAddress = p_Registers[0].uiAddress;

    // Write data into control registers (memory)
    for (i = 0; i < uiNumRegisters; i++)
    {
        // Check to see that the address is within the specified
        // range for the chip
        uiAddress = p_Registers[i].uiAddress;
        uiLastAddress = uiAddress + p_Registers[i].uiLength - 1;
        if ( (uiLastAddress)<= m_uiMaxControlRegisterAddress)
        {
            // Copy the register values into the control register
            //memory
            MemoryCopy(&m_ucControlReg[uiAddress], p_Registers[i].p_ucBuffer,
                p_Registers[i].uiLength);
        }
        else
        {
            uiResult = WDMMINI_INVALIDPARAM;
            return uiResult ;
        }
        // Find the highest address
        if(uiPrevAddress < uiLastAddress)
            uiPrevAddress = uiLastAddress;

        if (bWrite)
        {
            if((uiResult = Write(m_ucControlReg, (uiPrevAddress + 1), 0)) !=
                WDMMINI_NOERROR)
            {
                _DbgPrintF( DEBUGLVL_ERROR,("CVSBDemod::WriteControlReg() Error in Write !!! \n"));
                return uiResult;
            }

        }
    }
    _DbgPrintF( DEBUGLVL_VERBOSE,("CVSBDemod::WriteControlReg() Write !!! ------------ \n"));

    return uiResult;

}


/*
* ReadStatusReg()
* Input:RegisterType *p_reg_list-   Register list to be written to control registers
        int i_num_reg -  Number of registers in the list
* Output : UINT - Error code
* Description: Update the control registers and write to chip
*/

UINT CVSBDemod::ReadStatusReg(RegisterType *p_Registers, UINT uiNumRegisters)
{
    UINT uiResult = WDMMINI_NOERROR;
    UINT i;
    UINT uiPrevAddress;
    UINT uiLastAddress;

    UINT uiAddress;
    uiPrevAddress = p_Registers[0].uiAddress;

    // Write data into control registers (memory)
    for (i = 0; i < uiNumRegisters; i++)
    {
        // Check to see that the address is within the specified
        // range for the chip
        uiAddress = p_Registers[i].uiAddress;
        uiLastAddress = uiAddress + p_Registers[i].uiLength - 1;
        if (uiLastAddress <= m_uiMaxStatusRegisterAddress)
        {
            // Find the highest address
            if(uiPrevAddress < uiLastAddress)
                uiPrevAddress = uiLastAddress;
        }
        else
        {
            _DbgPrintF( DEBUGLVL_ERROR,("CVSBDemod::ReadStatusReg() Error: Too many values !!! \n"));
            return(WDMMINI_INVALIDPARAM);
        }
    }
    // Read I2C data
    if((uiResult = Read(m_ucI2CBuffer, uiPrevAddress + 1, 0)) !=
                        WDMMINI_NOERROR)
    {
        _DbgPrintF( DEBUGLVL_ERROR,("CVSBDemod::ReadStatusReg() Error in Read !!! \n"));
        return uiResult;
    }

    // Read data from status registers (memory)
    for (i = 0; i < uiNumRegisters; i++)
    {
        // Copy the register values into the control register
        //memory
        MemoryCopy(p_Registers[i].p_ucBuffer, &m_ucI2CBuffer[p_Registers[i].uiAddress],
            p_Registers[i].uiLength);
    }

    _DbgPrintF( DEBUGLVL_VERBOSE,("CVSBDemod::ReadStatusReg() Read !!! ------------ \n"));

    return uiResult;

}



/*
* WriteCoeff()
* Input:VsbCoeffType **pp_Coeff -pointer to an array of pointers pointing to
*               coefficients register   structure
*       UINT uiNumCoeff -  Number of coefficient pointers
* Output : UINT - Error code
* Description: Write the coefficients into the chip
*/
UINT CVSBDemod::WriteCoeff(VsbCoeffType **pp_Coeff, UINT uiNumCoeff)
{
    UINT uiResult = WDMMINI_NOERROR;
    UINT uiStart = 0;
    UINT uiCurrentPos = 0;
    UINT uiNumValues = 0;
    UINT uiIndex = 0;
    UINT i, j;
    VsbCoeffType *p_TempCoeff;

    uiCurrentPos = 0;
    p_TempCoeff = pp_Coeff[0];

    // Find the least address coefficient.
    // Fill up the output buffer with control register values upto
    // this least coefficient.
    // Write the coefficient values.
    // Find the next least address coefficient.
    // Write the control register values between the previous coefficient end
    // and this coefficient beginning.
    for (i = 0; i < uiNumCoeff; i++)
    {
        p_TempCoeff = pp_Coeff[i];
        uiIndex = i;
        for(j = i; j < uiNumCoeff; j++)
        {
            if(pp_Coeff[j]->uiAddress < p_TempCoeff->uiAddress)
            {
                p_TempCoeff = pp_Coeff[j];
                uiIndex = j;
            }
        }
        pp_Coeff[uiIndex] = pp_Coeff[i];
        pp_Coeff[i] = p_TempCoeff;

        // Number of control registers to be copied into the I2C buffer before
        // the coefficient array
        uiNumValues = p_TempCoeff->uiAddress - uiStart;
        // Copy the partial control registers
        MemoryCopy(&m_ucI2CBuffer[uiCurrentPos], &m_ucControlReg[uiStart], uiNumValues) ;

        // position the pointer to the next position in the i2C buffer
        uiCurrentPos += uiNumValues;

        // Position the pointer to the next control register
        uiStart += uiNumValues + 1;

        // Write 0 to coefficient write trigger point. It is not necessary to write 0,
        // but as the document does not say what value should be written, its better to
        // write 0. In VSB1, writing to the coefficient trigger point freezes the Equalizer
        // thats the reason for keeping the write to trigger point a separate operation
        m_ucI2CBuffer[uiCurrentPos] = 0;

        // position the pointer to the next position in the i2C buffer
        uiCurrentPos += 1;

        // Copy the coefficient values into the I2C control buffer
        MemoryCopy(&m_ucI2CBuffer[uiCurrentPos],
            p_TempCoeff->p_ucBuffer, p_TempCoeff->uiLength);

        // Update i2C buffer position pointer
        uiCurrentPos += p_TempCoeff->uiLength;
    }


    // Copy control register values to I2C buffer and write
    //to chip
    if((uiResult = Write(m_ucI2CBuffer, uiCurrentPos, 0))
        != WDMMINI_NOERROR)
    {
        _DbgPrintF( DEBUGLVL_ERROR,("CVSBDemod::WriteCoeff() Error in Write !!! \n"));
    }
    else
    {
        _DbgPrintF( DEBUGLVL_VERBOSE,("CVSBDemod::WriteCoeff() Write !!! \n"));
    }

    return uiResult;
}

/*
* ReadCoeff()
* Input:VsbCoeffType **pp_Coeff -   pointer to an array of pointers pointing to
*               coefficients register   structure
*       UINT uiNumCoeff -  Number of coefficient pointers
* Output : UINT - Error code
* Description:Read the coefficients from the chip
*/
UINT CVSBDemod::ReadCoeff(VsbCoeffType **pp_Coeff, UINT uiNumCoeff)
{
    UINT uiResult = WDMMINI_NOERROR;
    UINT uiStart = 0;
    UINT uiCurrentPos = 0;
    UINT uiNumValues = 0;
    UINT i, j;
    UINT uiLength = 0;
    UINT uiIndex = 0;

    VsbCoeffType *p_TempCoeff;

    p_TempCoeff = pp_Coeff[0];
    UINT uiTempAdd = p_TempCoeff->uiAddress;
    for (i = 0; i < uiNumCoeff; i++)
    {
        if(uiTempAdd < pp_Coeff[i]->uiAddress)
        {
            uiTempAdd = pp_Coeff[i]->uiAddress;
        }
        uiLength += pp_Coeff[i]->uiLength;
    }
    uiLength += uiTempAdd + 1;

    // Read I2C data
    if((uiResult = Read(m_ucI2CBuffer, uiLength, 0)) != WDMMINI_NOERROR)
    {
        _DbgPrintF( DEBUGLVL_ERROR,("CVSBDemod::ReadAndCreateRegisters() Error in Read !!! \n"));
        return uiResult;
    }
    else
        _DbgPrintF( DEBUGLVL_VERBOSE,("CVSBDemod::ReadAndCreateRegisters() Read !!! \n"));


    // Sort Array
    for (i = 0; i < uiNumCoeff; i++)
    {
        p_TempCoeff = pp_Coeff[i];
        uiIndex = i;
        for(j = i; j < uiNumCoeff; j++)
        {
            if(pp_Coeff[j]->uiAddress < p_TempCoeff->uiAddress)
            {
                p_TempCoeff = pp_Coeff[j];
                uiIndex = j;
            }
        }
        pp_Coeff[uiIndex] = pp_Coeff[i];
        pp_Coeff[i] = p_TempCoeff;

        // Number of values to be ignored includes the coefficient-read trigger point
        uiNumValues = p_TempCoeff->uiAddress - uiStart + 1;

        // Update i2C buffer pointer position
        uiCurrentPos += uiNumValues;

        // Update status register pointer position
        uiStart += uiNumValues;

        // Copy the coefficient values
        MemoryCopy(p_TempCoeff->p_ucBuffer, &m_ucI2CBuffer[uiCurrentPos],
                p_TempCoeff->uiLength);
        uiCurrentPos += p_TempCoeff->uiLength;
    }

    return uiResult;
}


/*
* Write()
* Input:UCHAR *p_ucBuffer - buffer to be written
*       int uiNumReg -  Number of registers to be written
*       UINT uiStartAddr - start address
* Output : UINT - Error code
* Description: Write data to chip
*/

UINT CVSBDemod::Write(UCHAR *p_ucBuffer, UINT uiNumReg, UINT uiStartAddr)
{
    UINT uiResult = WDMMINI_NOERROR;

    // The present versions of the chip do not support sub-addressing, hence
    // uiStartAddr is not used.
    // write to chip
    //$REVIEW - Should change function decl to make uiNumReg be USHORT - TCP
    if(!m_pI2CScript->WriteSeq(m_ucVsbDemodAddress, p_ucBuffer,
        (USHORT) uiNumReg))
        uiResult = WDMMINI_HARDWAREFAILURE;

    return uiResult;
}

/*
* Read()
* Input:UCHAR *p_ucBuffer - buffer to be filled
*       int uiNumReg -  Number of registers to be read
*       UINT uiStartAddr - start address
* Output : UINT - Error code
* Description: Read data from chip
*/

UINT CVSBDemod::Read(UCHAR *p_ucBuffer, UINT uiNumReg, UINT uiStartAddr)
{
    UINT uiResult = WDMMINI_NOERROR;

    // The present versions of the chip do not support sub-addressing, hence
    // uiStartAddr is not used.
    // write to chip
    //$REVIEW - Should change function decl to make uiNumReg be USHORT - TCP
    if(!m_pI2CScript->ReadSeq(m_ucVsbDemodAddress, p_ucBuffer, (USHORT) uiNumReg))
        uiResult = WDMMINI_HARDWAREFAILURE;

    return uiResult;
}


/*
* IsVSBLocked()
* Input :
* Output:   TRUE - if chip is locked
*           FALSE - if chip is not locked
* Description:  Check if chip is locked ( equalizer lock )
*/

BOOL CVSBDemod::IsVSBLocked()
{
    BOOL bLocked = FALSE;
    UCHAR ucByte = 0;
    RegisterType Status;

    Status.uiLength = 1;
    Status.uiAddress = VSB_REG_STATE;
    Status.p_ucBuffer = &ucByte;

    if(GetStatusRegister(&Status, 1) !=WDMMINI_NOERROR)
        return FALSE;

    bLocked = ((ucByte & 0x7) == 0x7) ? 1 : 0;

    if (bLocked)
    {
        _DbgPrintF( DEBUGLVL_TERSE,("CVSBDemod: 8VSB LOCKED !!! ------------ \n"));
    }
    else
    {
        _DbgPrintF( DEBUGLVL_TERSE,("CVSBDemod: 8VSB not locked %x!!!\n", ucByte));
    }

    return(bLocked);
}


/*
* SoftwareReset()
* Input: Reset control
* Output :
* Description: Reset chip
*/
BOOL CVSBDemod::SoftwareReset(ULONG ulResetCtrl)
{
    RegisterType Control;
    UCHAR ucMask;

    UCHAR ucReset = m_ucControlReg[VSB_REG_RESET];

    if(ulResetCtrl & VSB_GENERAL_RESET)
        ucMask = VSB_GENERAL_RESET;
    else if(ulResetCtrl & VSB_INITIAL_RESET)
        ucMask = VSB_INITIAL_RESET;
    else
        return FALSE;
    ucReset |= ucMask;

    Control.uiAddress = VSB_REG_RESET;
    Control.uiLength = 1;
    Control.p_ucBuffer = &ucReset;


    // Reset chip
    SetControlRegister(&Control, 1);
    ucReset &= ~ucMask;
    //50ms delay
    Delay(500000);
    // Remove reset
    SetControlRegister(&Control, 1);
    //50ms delay
    Delay(500000);

        // Initialize VSB if INITIAL RESET is done
    if(ulResetCtrl & VSB_INITIAL_RESET)
        if(!InitVSB())
            return FALSE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\mauitune\vsbdef.h ===
//////////////////////////////////////////////////////////////////////////////
//
//                     (C) Philips Semiconductors-CSU 1999
//  All rights are reserved. Reproduction in whole or in part is prohibited
//  without the written consent of the copyright owner.
//
//  Philips reserves the right to make changes without notice at any time.
//  Philips makes no warranty, expressed, implied or statutory, including but
//  not limited to any implied warranty of merchantibility or fitness for any
//  particular purpose, or that the use will not infringe any third party
//  patent, copyright or trademark. Philips must not be liable for any loss
//  or damage arising from its use.
//
//	VSBDEF.H
//	Constants and structures for the VSB
//////////////////////////////////////////////////////////////////////////////

#ifndef _VSBDEF_H_
#define _VSBDEF_H_




// Register access operation
#define		WRITE_REGISTERS		0x1
#define		READ_REGISTERS		0x2


// Quality Check Modes
#define	QCM_ENABLE				0x1
#define	QCM_DISABLE				0x2
#define	QCM_RESET				0x4
#define	QCM_TERMINATE			0x8


// Tweaking constants
#define		TUNER_ABSOLUTE_TWEAK	0
#define		TUNER_RELATIVE_TWEAK	1

#define		MAX_MSE					0xffff	// Maximum MSE value
#define		MAX_CONTROL_REG			MAX_VSB_REG		// Maximum control registers
#define		MAX_VSB_COEFF			4

#define		VSB1_CONTROL_SIZE		0x11	//0x12
#define		VSB1_STATUS_SIZE		0x5

#define		VSB2_CONTROL_SIZE		0x36	//0x34
#define		VSB2_STATUS_SIZE		0xd

// Maximum size of I2C buffer This size > than max correlator coeff 
// + equalizer taps
// + equalizer cluster taps 
// + sync-enhancer taps 
// + cochannel rejection filter taps 
// + other control registers
#define		MAX_BUFFER_SIZE			MAX_VSB_BUF_SIZE	

// Register structures
// Status registers
typedef struct 
{
	BOOL	bFrontEndLock;
	UCHAR	ucState;
	BOOL	bEqualizerLock;
	UINT	uiMse;
	UCHAR	ucCarrierOffset;
	// Not implemented in VSB1
	UINT	uiSegmentErrorRate;
} VsbStatusType, *PVsbStatusType;

// Coefficient structure
typedef struct
{
	UINT	uiID;
	UINT	uiAddress;
	UINT	uiLength;
	UCHAR	*p_ucBuffer;

} VsbCoeffType, *PVsbCoeffType;



#endif // _VSBDEF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\mauitune\wdmdebug.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
// WDMDEBUG.H
//==========================================================================;


#ifndef __WDMDEBUG_H
#define __WDMDEBUG_H

#define DebugAssert(exp)

#ifdef DEBUG
#define DebugInfo(x) KdPrint(x)
#define DBG1(String) DebugPrint((DebugLevelVerbose, String))
#define TRAP DbgBreakPoint() //DEBUG_BREAKPOINT();
#else
#define DebugInfo(x)
#define DBG1(String)
#define TRAP
#endif


#if DBG

#define _DebugPrint(x)  ::StreamClassDebugPrint x

#else

#define _DebugPrint(x)

#endif // #if DBG

#endif // #ifndef __WDMDEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\mauitune\vsb.h ===
//==========================================================================;
//
//	VSB.H
//	
//	Constants and structures for the VSB
//
//==========================================================================;

#ifndef _VSB_H_
#define _VSB_H_

// Register structures

// Status registers
typedef struct 
{
	UCHAR FrontEndLock;
	UCHAR State;
	UCHAR EqualizerLock;
	UINT  Mse;
	UCHAR CarrierOffset;
	// Not implemented in VSB1
	UINT  SegmentErrorRate;
} VSB_STATUS_STRUCT, *PVSB_STATUS_STRUCT;


// Equalizer control registers
typedef struct
{
	UCHAR	Mu1;
	UCHAR	Mu2;
	UCHAR	Mu3;
	UCHAR	Mu4;
	UCHAR	Mu5;
	UCHAR	Mu6;
	UCHAR	Sw1;
	UCHAR	Sw2;
	UCHAR	Sw3;
	UCHAR	RValue;
	UINT	MseLowerThreshold;
	UINT	MseUpperThreshold;

}VSB_EQUALIZER_CONTROL, *PVSB_EQUALIZER_CONTROL;

// Carrier Recovery registers
typedef struct
{
	UCHAR	LoopControl;
	UCHAR	SecondOrderLoopFilterControl;
	UCHAR	InvertSpectrum;
	UCHAR	GainSelect;
	UCHAR	Gain;
	UCHAR	NonLinearityDisable;

}VSB_CARRIER_RECOVERY_CONTROL, *PVSB_CARRIER_RECOVERY_CONTROL;


// Timing Recovery registers
typedef struct
{
	UCHAR	Mode;
	UCHAR	GainInfo;
	UCHAR	AccumulatorLength;
	UCHAR	IIRBandwidth;
	UCHAR	DACInterfaceMode;
	UCHAR	PropIntegralParamIndexState1;
	UCHAR	PropIntegralParamIndexState2;
	UCHAR	PropIntegralParamIndexState3;
	UCHAR	TimeInState1NormalMode;
	UCHAR	TimeInState2NormalMode;
	UCHAR	TimeInState1and2LongMode;

}VSB_TIMING_RECOVERY_CONTROL, *PVSB_TIMING_RECOVERY_CONTROL;

// Diagnostic control registers
typedef  struct
{
	UCHAR	DiagnosticSelect;
	UCHAR	TrellisDecoderDiag;
	UCHAR	SyncRecoveryDiag;
	UCHAR	CarrierRecoveryDiag;
} VSB_DIAGNOSTIC_CONTROL, *PVSB_DIAGNOSTIC_CONTROL;

// Remote mode registers
typedef struct
{
	UCHAR	RemoteModeEnable;
	UCHAR	LockIn;
	UCHAR	Mse;
	UCHAR	TRSelect;
}VSB_REMOTE_MODE_CONTROL, *PVSB_REMOTE_MODE_CONTROL;

// AGC registers
typedef struct
{
  UCHAR		AGCThreshold;
  UCHAR		RescaleControl;

} VSB_AGC_CONTROL, *PVSB_AGC_CONTROL;

// Constants for resets .
// The various resets that can be applied to VSB
#define		EQUALIZER_RESET			0x08
#define		BACKEND_RESET			0x04
#define		GENERAL_RESET			0x02
#define		INITIAL_RESET			0x01
#define		SYNC_RECOVERY_RESET		0x100
#define		TIMING_RECOVERY_RESET	0x200
#define		CARRIER_RECOVERY_RESET	0x400
#define		AGC_RESET				0x800
#define		HARDWARE_RESET			0x1000

// Constants for Freeze
// The various freeze that can be applied to VSB
#define		EQUALIZER_ADAPTATION_FREEZE	0x10
#define		RESCALE_AGC_FREEZE			0x1


// Constants for Disables
// The various disables that can be applied to VSB
#define			TIMEOUT_DISABLE			0x80
#define			FRONTEND_RESET_DISABLE	0x40
#define			EQUALIZER_RESET_DISABLE	0x20


#define			BIT_ENABLE		0x1

//****** Diagnostic and O/P control

// Selection of which diagnostic data comes out on the Diagnostic and Data
// bus
#define		VSB_DIAG_EQOUT_SYMOUT		0x00
#define		VSB_DIAG_CRERR_SYMOUT		0x08
#define		VSB_DIAG_TRERR_CRERR		0x10
#define		VSB_DIAG_SYMOUT_TRERR		0x18
#define		VSB_DIAG_TDDIAG_EQOUT		0x20
#define		VSB_DIAG_TDDIAG_TDOUT		0x28
#define		VSB_DIAG_TDOUT_RSDIAG		0x30
#define		VSB_DIAG_RSDIAG_TDDIAG		0x38
#define		VSB_DIAG_SELECT_MASK		0x38

//Trellis Decoder Diagnostic Select
#define		VSB_DIAG_STATE_0_METRIC			0
#define		VSB_DIAG_STATE_1_METRIC			1
#define		VSB_DIAG_STATE_2_METRIC			2
#define		VSB_DIAG_STATE_3_METRIC			3
#define		VSB_DIAG_SURVIVOR_PATH_METRIC	4
#define		VSB_DIAG_TD_MASK				7

// Sync recovery & Pilot removal Diagnostic Select
#define		VSB_DIAG_SEGSYNC_CONFIDENCE_CNTR	0
#define		VSB_DIAG_FLDSYNC_CONFIDENCE_CNTR	0x20	
#define		VSB_DIAG_PILOT_VALUE				0x40
#define		VSB_DIAG_RESCALE_AGC				0x60
#define		VSB_DIAG_SP_MASK					0x60

// Carrier Recovery Diagnostic Select
#define		VSB_DIAG_LOOP_FILTER_IN			0
#define		VSB_DIAG_LOOP_FILTER_OUT		0x80
#define		VSB_DIAG_LOOP_FILTER_MASK		0x80

//FIFO Control
#define		VSB_FIFO_OUTPUT				0
#define		VSB_DESCARMBLER_OUTPUT		0x40
#define		VSB_DIAGNOSTIC_OUTPUT		0x80
#define		VSB_FIFO_MASK				0xc0


// ***** Carrier Recovery Control
// Carrier Spectrum
#define		VSB_CR_CTRL_HIGH_END_PILOT		0
#define		VSB_CR_CTRL_LOW_END_PILOT		0x4
#define		VSB_CR_CTRL_PILOT_MASK				0x4

// Carrier Gain Selection
#define		VSB_CR_CTRL_SR_GAIN				0
#define		VSB_CR_CTRL_CR_GAIN				0x10
#define		VSB_CR_CTRL_GAINSELECT_MASK		0x10

// Gain values
#define		VSB_CR_CTRL_GAIN_1				0
#define		VSB_CR_CTRL_GAIN_05				0x20
#define		VSB_CR_CTRL_GAIN_025			0x40
#define		VSB_CR_CTRL_GAIN_0125			0x60
#define		VSB_CR_CTRL_GAIN_MASK			0x60


// ***** Timing Recovery Control

// Moe selection ( Normal/Long )
#define		VSB_TR_CTRL_SELECT_NORMAL		0x0
#define		VSB_TR_CTRL_SELECT_LONG			0x1
#define		VSB_TR_CTRL_SELECT_MASK			0x1

// Gain Info
#define		VSB_TR_CTRL_GAININFO_STATE2		0x0
#define		VSB_TR_CTRL_GAININFO_STATE3		0x1
#define		VSB_TR_CTRL_GAININFO_FIXED		0x2
#define		VSB_TR_CTRL_GAININFO_MASK		0x3

// Accumulator length
#define		VSB_TR_CTRL_ACC_LEN_32			0
#define		VSB_TR_CTRL_ACC_LEN_16			0x04
#define		VSB_TR_CTRL_ACC_LEN_MASK		0x04

// IIR Bandwidth
#define		VSB_TR_CTRL_BW_6				0
#define		VSB_TR_CTRL_BW_7				0x4
#define		VSB_TR_CTRL_BW_MASK				0x4

//DAC interface mode
#define		VSB_TR_CTRL_MODE0				0
#define		VSB_TR_CTRL_MODE1				0x10
#define		VSB_TR_CTRL_MODE2				0x20
#define		VSB_TR_CTRL_MODE3				0x30
#define		VSB_TR_CTRL_MODE_MASK			0x30

//Duration of FSM in state 1 Normal mode
#define		VSB_TR_CTRL_N1_30MS				0
#define		VSB_TR_CTRL_N1_80MS				0x8
#define		VSB_TR_CTRL_N1_100MS			0x10
#define		VSB_TR_CTRL_N1_150MS			0x18
#define		VSB_TR_CTRL_N1_MASK				0x18

//Duration of FSM in state 2 Normal mode
#define		VSB_TR_CTRL_N2_50MS				0
#define		VSB_TR_CTRL_N2_100MS			0x20
#define		VSB_TR_CTRL_N2_MASK				0x20

//Duration of FSM in state 1 and 2 Long mode
#define		VSB_TR_CTRL_L1_200MS_L2_100MS	0x0
#define		VSB_TR_CTRL_L1_500MS_L2_100MS	0x40
#define		VSB_TR_CTRL_L1_MASK				0x40

// ***** Equalizer Control
// Mu values
#define		VSB_EQ_CTRL_MU_NO_UPDT			0
#define		VSB_EQ_CTRL_MU_MINUS_22			0x1
#define		VSB_EQ_CTRL_MU_MINUS_21			0x2
#define		VSB_EQ_CTRL_MU_MINUS_20			0x3
#define		VSB_EQ_CTRL_MU_MINUS_19			0x4
#define		VSB_EQ_CTRL_MU_MINUS_18			0x5
#define		VSB_EQ_CTRL_MU_MINUS_17			0x6
#define		VSB_EQ_CTRL_MU_MINUS_16			0x7
#define		VSB_EQ_CTRL_MU_MINUS_15			0x8
#define		VSB_EQ_CTRL_MU_MINUS_14			0x9
#define		VSB_EQ_CTRL_MU_MINUS_13			0xa
#define		VSB_EQ_CTRL_MU_MINUS_12			0xb
#define		VSB_EQ_CTRL_MU_MINUS_11			0xc
#define		VSB_EQ_CTRL_MU_MINUS_10			0xd
#define		VSB_EQ_CTRL_MU_MINUS_9			0xe
#define		VSB_EQ_CTRL_MU_MINUS_8			0xf

// R values
#define		VSB_EQ_CTRL_BLIND_R_5_POINT_20		0
#define		VSB_EQ_CTRL_BLIND_R_5_POINT_22		0x1
#define		VSB_EQ_CTRL_BLIND_R_5_POINT_25		0x2
#define		VSB_EQ_CTRL_BLIND_R_5_POINT_28		0x3
#define		VSB_EQ_CTRL_BLIND_R_5_POINT_30		0x4
#define		VSB_EQ_CTRL_BLIND_R_5_POINT_33		0x5
#define		VSB_EQ_CTRL_BLIND_R_5_POINT_36		0x6
#define		VSB_EQ_CTRL_BLIND_R_5_POINT_38		0x7
#define		VSB_EQ_CTRL_BLIND_R_5_POINT_41		0x8
#define		VSB_EQ_CTRL_BLIND_R_5_POINT_44		0x9
#define		VSB_EQ_CTRL_BLIND_R_5_POINT_46		0xa
#define		VSB_EQ_CTRL_BLIND_R_5_POINT_49		0xb
#define		VSB_EQ_CTRL_BLIND_R_5_POINT_52		0xc
#define		VSB_EQ_CTRL_BLIND_R_5_POINT_54		0xd
#define		VSB_EQ_CTRL_BLIND_R_5_POINT_57		0xe
#define		VSB_EQ_CTRL_BLIND_R_5_POINT_60		0xf


//******* Data Input Format
#define		VSB_DATA_INP_2S_COMPLEMENT			0
#define		VSB_DATA_INP_BINARY					0x8
#define		VSB_DATA_INP_MASK					0x8


//*****	AGC Control
// Rescale AGC control
#define		VSB_AGC_CTRL_NORMAL						0x0
#define		VSB_AGC_CTRL_FREEZE_AFTER_1_SYNC		0x40
#define		VSB_AGC_CTRL_CHANGE_IIRBW_AFTER_1_SYNC	0xc0
#define		VSB_AGC_CTRL_MASK						0xc0

#define		VSB_AGC_THRESH_MASK						0xf

// A set of all VSB register control structures.
typedef struct 
{
	VSB_EQUALIZER_CONTROL Equalizer;
	VSB_TIMING_RECOVERY_CONTROL TimingRecovery;
    VSB_CARRIER_RECOVERY_CONTROL  CarrierRecovery;
    VSB_DIAGNOSTIC_CONTROL  Diagnostics;         
    VSB_REMOTE_MODE_CONTROL  RemoteMode;
    VSB_AGC_CONTROL  AGC;    
    char  DataInput;           
    char  FIFO;
	ULONG Reset;
	ULONG Freeze;
	ULONG Disable;
} VSB_MODULE_SET, *PVSB_MODULE_SET;



#define STATIC_PROPSETID_VSB\
	0xb96e0100L, 0xce52, 0x11d2, 0x8a, 0x11, 0x00, 0x60, 0x94, 0x05, 0x30, 0x6e
DEFINE_GUIDSTRUCT("b96e0100-ce52-11d2-8a11-00609405306e", PROPSETID_VSB);
#define PROPSETID_VSB DEFINE_GUIDNAMED(PROPSETID_VSB)

// The properties defined for VSB
typedef enum {
    KSPROPERTY_VSB_STATUS = 0,			// R  - VSB status
    KSPROPERTY_VSB_EQ_CTRL,				// RW - Equalizer control
    KSPROPERTY_VSB_TR_CTRL,				// RW - Timing Recovery Control
    KSPROPERTY_VSB_CR_CTRL,				// RW - Carrier Recovery Control
    KSPROPERTY_VSB_DIAG_CTRL,			// RW - Diagnostic Control
    KSPROPERTY_VSB_REMOTE_MODE_CTRL,    // RW - Remote Mode control
    KSPROPERTY_VSB_AGC_CTRL,			// RW - Remote Mode control
    KSPROPERTY_VSB_DATA_INPUT_CTRL,     // RW - Input Control
    KSPROPERTY_VSB_FIFO_CTRL,            // RW - FIFO control
    KSPROPERTY_VSB_RESET_CTRL,           // RW - Reset control
    KSPROPERTY_VSB_FREEZE_CTRL,          // RW - Freeze control
    KSPROPERTY_VSB_DISABLE_CTRL         // RW - Disable control

} KSPROPERTY_VSB;

// A union of all VSB register control structures.
typedef union 
{
	VSB_EQUALIZER_CONTROL Equalizer;
	VSB_TIMING_RECOVERY_CONTROL TimingRecovery;
    VSB_CARRIER_RECOVERY_CONTROL  CarrierRecovery;
    VSB_DIAGNOSTIC_CONTROL  Diagnostics;         
    VSB_REMOTE_MODE_CONTROL  RemoteMode;
    VSB_AGC_CONTROL  AGC;    
    char  DataInput;           
    char  FIFO;
	ULONG Reset;
	ULONG Freeze;
	ULONG Disable;
} VSB_MODULE_CONTROL_UNION;

// Property structure for status
typedef struct {
    KSPROPERTY Property;
    VSB_STATUS_STRUCT  Status;          
 } KSPROPERTY_VSB_STATUS_S, *PKSPROPERTY_VSB_STATUS_S;

// property structure for any register access
typedef struct {
    KSPROPERTY Property;
    VSB_MODULE_CONTROL_UNION  ModuleControl;           
	BOOL		ShadowOpn;
 } KSPROPERTY_VSB_REGISTER_S, *PKSPROPERTY_VSB_REGISTER_S;

// property structure for any tap/coefficient access
typedef struct {
    KSPROPERTY Property;
    char	*CoeffArray;     
	ULONG	NumCoeff;
	BOOL	ShadowOpn;
 } KSPROPERTY_VSB_COEFF_S, *PKSPROPERTY_VSB_COEFF_S;




#endif // _VSB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\mauitune\vsb2.h ===
//////////////////////////////////////////////////////////////////////////////
//
//                     (C) Philips Semiconductors-CSU 1999
//  All rights are reserved. Reproduction in whole or in part is prohibited
//  without the written consent of the copyright owner.
//
//  Philips reserves the right to make changes without notice at any time.
//  Philips makes no warranty, expressed, implied or statutory, including but
//  not limited to any implied warranty of merchantibility or fitness for any
//  particular purpose, or that the use will not infringe any third party
//  patent, copyright or trademark. Philips must not be liable for any loss
//  or damage arising from its use.
//
//  VSB2.H
//  Definition of CVSB2Demod class
//////////////////////////////////////////////////////////////////////////////

#ifndef _VSB2_H_
#define _VSB2_H_

#include "vsbbase.h"

// Status registers
typedef struct
{
    VsbStatusType   Status;
    BOOL            bCorrelatorError;
    BOOL            bCorrelatorFull;
} Vsb2StatusType, *PVsb2StatusType;

class CVSB2Demod : public CVSBDemod
{
public:

    CVSB2Demod(CI2CScript *p_I2CScript, BoardInfoType *p_BoardInfo, NTSTATUS *p_Status);
    ~CVSB2Demod();

//  PVOID operator new (UINT size_t);
//  void operator delete(PVOID p_Object);

    virtual BOOL    GetStatus(PVsbStatusType p_Status);
    virtual BOOL    GetStatus(PVsb2StatusType p_Status);
    virtual BOOL    InitVSB();
    virtual BOOL    CoeffIDToAddress(UINT uiID, UINT *p_uiAddress,
                            UINT uiRegisterType);
    virtual BOOL    SetOutputMode(UINT uiOutputMode);
    virtual BOOL    GetOutputMode(UINT *p_uiOutputMode);
    virtual BOOL    SetDiagMode(VSBDIAGTYPE ulMode);
    virtual BOOL    GetDiagMode(ULONG *p_ulMode);
    virtual ULONG   GetDiagSpeed(ULONG ulType);

protected:
    virtual BOOL    EnableCoefficients(UCHAR ucEnable);
    virtual BOOL    DisableCoefficients();
    virtual BOOL    DisableCoefficients(UINT ucEnable);
    virtual BOOL    Initialize();
    virtual BOOL    EnableCorrelatorRead();
    virtual BOOL    WaitForCorrelatorFull();

};


#endif // _VSB2_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\slip\makefile.inc ===
# HACK ALERT: This target is solely to keep nmake from whining that it doesn't
# know how to make the dependency in rules that depend on the target executable.
$(TARGETPATHEX)\$(TARGETNAME).sys:

# Build SoftICE symbols
$(TARGETPATHEX)\$(TARGETNAME).nms: $(TARGETPATHEX)\$(TARGETNAME).sys
    echo $(TARGETPATHEX)\$(TARGETNAME) > target.txt
    nmsym /translate:source,package,always /source:. /output:$(TARGETPATHEX)\$(TARGETNAME).nms $(TARGETPATHEX)\$(TARGETNAME).sys
    splitsym -s $(_NT_SYMBOL_PATH)  $(TARGETPATHEX)\$(TARGETNAME).sys

# Delete built files
clean:
    -echo $(TARGETPATHEX)\$(TARGETNAME).*
    -del /s *.obj
    -del /s *.res
    -del build.log
    -del build.err
    -del /s _objects.mac
    -del $(TARGETPATHEX)\$(TARGETNAME).*
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\slip\filter.h ===
#ifndef _FILTER_H_
#define _FILTER_H_


//////////////////////////////////////////////////////////////////
//
//
//
NTSTATUS
CreateFilter (
    PDRIVER_OBJECT DriverObject,
    PDEVICE_OBJECT DeviceObject,
    PSLIP_FILTER   pFilter
    );

NTSTATUS
Filter_QueryInterface (
    PSLIP_FILTER pFilter
    );

ULONG
Filter_AddRef (
    PSLIP_FILTER pFilter
    );

ULONG
Filter_Release (
    PSLIP_FILTER pFilter
    );

#endif  // _FILTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\slip\main.c ===
/////////////////////////////////////////////////////////////////////////////
//
//
// Copyright (c) 1996, 1997  Microsoft Corporation
//
//
// Module Name:
//      test.c
//
// Abstract:
//
//
//
// Author:
//
//      P Porzuczek
//
// Environment:
//
// Revision History:
//
//
//////////////////////////////////////////////////////////////////////////////

//
//
#include <wdm.h>
#include <memory.h>
#include "Main.h"

#if DBG

/////////////////////////////////////////////////////////////////////////////
//
// Default debug mode
//

ULONG TestDebugFlag = TEST_DBG_NONE;

/////////////////////////////////////////////////////////////////////////////
// Debugging definitions
//


//
// Debug tracing defintions
//
#define TEST_LOG_SIZE 256
UCHAR TestLogBuffer[TEST_LOG_SIZE]={0};
ULONG TestLogLoc = 0;

/////////////////////////////////////////////////////////////////////////////
//
// Logging function in debug builds
//
extern VOID
TestLog (
    UCHAR c         // input character
    )
/////////////////////////////////////////////////////////////////////////////
{
    TestLogBuffer[TestLogLoc++] = c;

    TestLogBuffer[(TestLogLoc + 4) % TEST_LOG_SIZE] = '\0';

    if (TestLogLoc >= TEST_LOG_SIZE) {
        TestLogLoc = 0;
    }
}

#else // DBG == 0

ULONG TestDebugFlag = 0;

#endif // DBG

//////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT    pDriverObject,
    IN PUNICODE_STRING   pszuRegistryPath
    )
//////////////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS                        ntStatus = STATUS_SUCCESS;

    //
    // Register the Slip Class binding
    //
    ntStatus = SlipDriverInitialize (pDriverObject,  pszuRegistryPath);
    if (ntStatus != STATUS_SUCCESS)
    {
        goto ret;
    }

ret:

    TEST_DEBUG (TEST_DBG_TRACE, ("Driver Entry complete, ntStatus: %08X\n", ntStatus));

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\slip\main.h ===
//////////////////////////////////////////////////////////////////////////////\
//
//  Copyright (c) 1990  Microsoft Corporation
//
//  Module Name:
//
//     test.h
//
//  Abstract:
//
//     The main header for the NDIS/KS test driver
//
//  Author:
//
//     P Porzuczek
//
//  Environment:
//
//  Notes:
//
//  Revision History:
//
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _MAIN_H
#define _MAIN_H


#if DBG

extern  ULONG TestDebugFlag;

#define TEST_DBG_NONE       0x00000000
#define TEST_DBG_TRACE      0x00000001
#define TEST_DBG_WRITE_DATA 0x00000002
#define TEST_DBG_READ_DATA  0x00000004

#define TEST_DBG_RECV       0x00000008
#define TEST_DBG_SRB        0x00000010
#define TEST_DBG_CRC        0x00000020
#define TEST_DBG_NAB        0x00000040
#define TEST_DBG_BUF        0x00000080
#define TEST_DBG_ASSERT     0x00000100


#define TEST_DBG_DETAIL  0x00001000
#define TEST_DBG_INFO    0x00002000
#define TEST_DBG_WARNING 0x00004000
#define TEST_DBG_ERROR   0x00008000

#ifdef DEBUG_EXTRAS
#define TEST_DEBUG(_Trace, _Msg)                 \
{                                               \
        __int64                 llTime = 0;             \
        ULONG                   ulTime = 0;                     \
        NdisGetCurrentSystemTime ((PLARGE_INTEGER)&llTime);     \
        ulTime = (ULONG) (llTime >> 2);         \
    if (_Trace & TestDebugFlag)                  \
    {                                           \
        DbgPrint ("%04X %08X %-10.10s %4d  ", ulTime & 0xffff, _Trace, &__FILE__[2], __LINE__); \
        DbgPrint _Msg;                          \
    }                                           \
}

#else

#define TEST_DEBUG(_Trace, _Msg)                 \
{                                               \
    if (_Trace & TestDebugFlag)                  \
    {                                           \
        DbgPrint _Msg;                          \
    }                                           \
}

#endif  // DEBUG_EXTRAS

#define IF_TESTDEBUG(f) if (TestDebugFlag & (f))

#define TEST_DEBUG_LOUD               0x00010000  // debugging info
#define TEST_DEBUG_VERY_LOUD          0x00020000  // excessive debugging info
#define TEST_DEBUG_LOG                0x00040000  // enable Log
#define TEST_DEBUG_CHECK_DUP_SENDS    0x00080000  // check for duplicate sends
#define TEST_DEBUG_TRACK_PACKET_LENS  0x00100000  // track directed packet lens
#define TEST_DEBUG_WORKAROUND1        0x00200000  // drop DFR/DIS packets
#define TEST_DEBUG_CARD_BAD           0x00400000  // dump data if CARD_BAD
#define TEST_DEBUG_CARD_TESTS         0x00800000  // print reason for failing


//
// Macro for deciding whether to print a lot of debugging information.
//
#define IF_LOUD(A) IF_TESTDEBUG( TEST_DEBUG_LOUD ) { A }
#define IF_VERY_LOUD(A) IF_TESTDEBUG( TEST_DEBUG_VERY_LOUD ) { A }


//
// Whether to use the Log buffer to record a trace of the driver.
//
#define IF_LOG(A) IF_TESTDEBUG( TEST_DEBUG_LOG ) { A }
extern VOID TESTLog(UCHAR);

//
// Whether to do loud init failure
//
#define IF_INIT(A) A

//
// Whether to do loud card test failures
//
#define IF_TEST(A) IF_TESTDEBUG( TEST_DEBUG_CARD_TESTS ) { A }

#else

extern  ULONG TestDebugFlag;


#define TEST_NONE
#define TEST_FUNCTIONS
#define TEST_COMMANDS
#define TEST_CONNECTIONS
#define TEST_SCIDS
#define TEST_LIST_ALLOCS
#define TEST_POOL
#define TEST_INDICATES
#define TEST_ALLOCATION


#define TEST_DEBUG(_Trace, _Msg)

#define IF_TESTDEBUG(f)

#define TEST_DEBUG_LOUD
#define TEST_DEBUG_VERY_LOUD
#define TEST_DEBUG_LOG
#define TEST_DEBUG_CHECK_DUP_SENDS
#define TEST_DEBUG_TRACK_PACKET_LENS
#define TEST_DEBUG_WORKAROUND1
#define TEST_DEBUG_CARD_BAD
#define TEST_DEBUG_CARD_TESTS


//
// This is not a debug build, so make everything quiet.
//
#define IF_LOUD(A)
#define IF_VERY_LOUD(A)
#define IF_LOG(A)
#define IF_INIT(A)
#define IF_TEST(A)

#endif // DBG


NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT    pDriverObject,
    IN PUNICODE_STRING   pszuRegistryPath);


VOID
SlipFreeMemory (
    PVOID pvToFree,
    ULONG ulSize
    );

NTSTATUS
SlipAllocateMemory (
    PVOID  *ppvAllocated,
    ULONG   ulcbSize
    );


NTSTATUS
SlipDriverInitialize (
    IN PDRIVER_OBJECT    DriverObject,
    IN PUNICODE_STRING   RegistryPath
    );

#endif // _MAIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\mauitune\wdmdrv.h ===
//==========================================================================;
//
//  WDMDRV.H
//  WDM Capture Class Driver definitions.
//    Main Include Module.
//  Copyright (c) 1996 - 1997  ATI Technologies Inc.  All Rights Reserved.
//
//==========================================================================;

#ifndef _WDMDRV_H_
#define _WDMDRV_H_

#include "wdmcommon.h"


#define	BOARD_CONEY			0
#define	BOARD_CATALINA		1
#define	BOARD_KANGAROO		2
#define	BOARD_CORONADO		3
#define	BOARD_CES			4
#define	BOARD_CORFU			5
#define	BOARD_MAUI			6

#define		IF_OTHER		0
#define		IF_MPOC			1

#define	CATALINA_MISC_CONTROL_REGISTER	0x40
#define CONEY_I2C_PARALLEL_PORT       0x40  // PCF8574

#define	CATALINA_TS_OUT_DISABLE		0x1
#define	CATALINA_HARDWARE_RESET		0x2
#define	CATALINA_DTV_IF_DISABLE		0x4
#define	CATALINA_NTSC_IF_DISABLE	0x8
#define	CATALINA_TUNER_AGC_EXTERNAL	0x10

#define	MPOC_I2C_ADDRESS		0x8A
#define TUNER_I2C_ADDRESS		0xC0
// VSB I2C Address : 8 bit address with LSB as don't care
#define VSB_I2C_ADDRESS			0x18

/*
 * VSB chip version is as below:
 * VSB main series - VSB1, VSB2, VSB3... are bits 15-8 of uiVsbChipVersion
 * VSB sub series - A,B,C are bits 7-0 of uiVsbChipVersion
 * 
 */
// Board Information
typedef struct
{
    UINT  uiVsbChipVersion;      // Chip type : VSB1 , VSB2
	UCHAR ucVsbAddress;
    UINT  uiIFStage;             // IF Stage: MPOC or any other
    ULONG ulSupportedModes;     // All Modes supported: ATSC, TV
    ULONG ulNumSupportedModes;  // Number of modes supported
	UINT  uiBoardID;			// Board ID
    UCHAR ucBoardName[30];      // Name of the board (CONEY, CATALINA, ..)
	UCHAR ucTunerAddress;		// Tuner Address
	UINT  uiTunerID;			// Tuner type
	UINT  uiMpocVersion;			// Version of MPOC is IF stage is MPOC
} BoardInfoType, *PBoardInfoType;






#endif  // _WDMDRV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\mauitune\wdmcommon.h ===
#ifndef _WDM_COMMON_H_
#define _WDM_COMMON_H_

#define ENSURE    do
#define END_ENSURE  while( FALSE)
#define FAIL    break


// WDM MiniDriver Error codes
#define WDMMINI_NOERROR                 0x0000
#define WDMMINI_INVALIDPARAM            0x0010
#define WDMMINI_NOHARDWARE              0x0020
#define WDMMINI_UNKNOWNHARDWARE         0x0021
#define WDMMINI_HARDWAREFAILURE         0x0022
#define WDMMINI_ERROR_NOI2CPROVIDER     0x0040
#define WDMMINI_ERROR_NOGPIOPROVIDER    0x0041
#define WDMMINI_ERROR_MEMORYALLOCATION  0x0080
#define WDMMINI_ERROR_REGISTRY          0x0081
#define	WDMMINI_ERROR					0x8000

// EEPROM address on the board.
#define BOARD_EEPROM_ADDRESS				0xA6

// Register structure
typedef struct
{
	UINT	uiAddress;	// Register address
	UINT	uiLength;		// Length
	UCHAR	 *p_ucBuffer;	// Data
} RegisterType;

// Status Command enumeration
typedef enum
{
	PLL_OFFSET,
	PLL_LOCK

}IF_STATUS_ENUM;

typedef struct _IFStatus {
        ULONG StatusCommand;	// Status command
        ULONG  Data;            // Status Data to be returned
} IFStatus, *PIFStatus;

// this is the Interface definition for IF interface
//
typedef NTSTATUS (STDMETHODCALLTYPE *IFMODE)(PVOID, ULONG);
typedef NTSTATUS (STDMETHODCALLTYPE *IFSTATUS)(PVOID, PIFStatus);

typedef struct {
    INTERFACE _vddInterface;
    IFMODE   SetIFMode;
    IFSTATUS GetIFStatus;
} IFINTERFACE, *PIFINTERFACE;

// Diagnostic stream's property structures

// Enumeration for the Diagnostic modes
typedef enum 
{
	TENPOINT76MHZ,
	TWOPOINT69MHZ,
	TWENTYONEPOINT52MHZ,

}DIAGNOSTIC_MODE_ENUM;

// The size of the data sample field
typedef enum
{
	DIAG_FIELD,
	DATA_FIELD,
} DIAGNOSTIC_TYPE_ENUM;


#endif // _WDM_COMMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\mauitune\vsbprop.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//                     (C) Philips Semiconductors-CSU and Microsoft 1999
//  All rights are reserved. Reproduction in whole or in part is prohibited
//  without the written consent of the copyright owner.
//
//  Philips reserves the right to make changes without notice at any time.
//  Philips makes no warranty, expressed, implied or statutory, including but
//  not limited to any implied warranty of merchantibility or fitness for any
//  particular purpose, or that the use will not infringe any third party
//  patent, copyright or trademark. Philips must not be liable for any loss
//  or damage arising from its use.
//
// VSBPROP.CPP
//////////////////////////////////////////////////////////////////////////////


#include "philtune.h"


/*
* VsbReset()
* Inputs: UINT  reset
* Outputs:
* Return: BOOL: returns TRUE, if the operation succeeds else FALSE
* Description: Hardware/software reset of VSB. A software reset would imply
* writing to the reset registers of VSB and hardware reset would be a hardware
* VSB reset.
* Author : MM
*/
NTSTATUS CDevice::VsbReset(UINT uiReset)
{
    BOOL bResult = TRUE;
    UCHAR   ucPin, ucValue;

    if (uiReset & HARDWARE_RESET)
    {
        if (m_BoardInfo.uiBoardID == BOARD_CONEY)
        {
            // DO hardware reset
            // ********** VSB reset . GPIO pin 0 high - low- high
            // GPIO HIGH
            ucPin = GPIO_VSB_RESET_PIN ;            // use as a PinMask
            ucValue = GPIO_VSB_SET ;
            if(!m_pGpio->WriteGPIO(&ucPin, &ucValue))
            {   _DbgPrintF( DEBUGLVL_ERROR,("CReceiverFE::VsbReset: GPIO write failed"));
                return STATUS_ADAPTER_HARDWARE_ERROR;
            }

            // GPIO LOW
            ucValue = GPIO_VSB_RESET ;
            if(!m_pGpio->WriteGPIO(&ucPin, &ucValue))
            {   _DbgPrintF( DEBUGLVL_ERROR,("CReceiverFE::VsbReset: GPIO write failed"));
                return STATUS_ADAPTER_HARDWARE_ERROR;
            }

            // GPIO HIGH
            ucValue = GPIO_VSB_SET ;
            if(!m_pGpio->WriteGPIO(&ucPin, &ucValue))
            {   _DbgPrintF( DEBUGLVL_ERROR,("CReceiverFE::VsbReset: GPIO write failed"));
                return STATUS_ADAPTER_HARDWARE_ERROR;
            }

//          ((CVSB1Demod *)(m_pDemod))->InitVSB();
            m_pDemod->InitVSB();
        }
        else if(m_BoardInfo.uiBoardID == BOARD_CATALINA)
        {
            ucValue = m_ucModeInit;
            // To reset VSB, pull Miscellaneous register bit 1 low,
            // then high and then low again

            // Some boards have resets going from 0 to 1 to 0
            // and others have 1 to 0 to 1
            // Bit 1 = 0
            // For old board
#if 0
            ucValue &= ~CATALINA_HARDWARE_RESET;
            if(!m_pI2CScript->WriteSeq(CATALINA_MISC_CONTROL_REGISTER, &ucValue, 1))
                return STATUS_ADAPTER_HARDWARE_ERROR;

            // 10ms delay
            Delay(10000);
            // Bit 1 = 1
#endif
            ucValue |= CATALINA_HARDWARE_RESET;
            if(!m_pI2CScript->WriteSeq(CATALINA_MISC_CONTROL_REGISTER, &ucValue, 1))
                return STATUS_ADAPTER_HARDWARE_ERROR;

            // 50ms delay
            Delay(500000);

            // Bit 1 = 0
            ucValue &= ~CATALINA_HARDWARE_RESET;
            if(!m_pI2CScript->WriteSeq(CATALINA_MISC_CONTROL_REGISTER, &ucValue, 1))
                return STATUS_ADAPTER_HARDWARE_ERROR;

            // 50ms delay
            Delay(500000);

#if 1
            ucValue |= CATALINA_HARDWARE_RESET;
            if(!m_pI2CScript->WriteSeq(CATALINA_MISC_CONTROL_REGISTER, &ucValue, 1))
                return STATUS_ADAPTER_HARDWARE_ERROR;

            // 50ms delay
            Delay(500000);
#endif
            m_ucModeInit = ucValue;

            // Initialize VSB2 chip
//          ((CVSB2Demod *)(m_pDemod))->InitVSB();
            m_pDemod->InitVSB();

        }
        else
        {
            // For boards that don't support Hardware reset, just initialize the
            // chip
            m_pDemod->InitVSB();
        //  _DbgPrintF( DEBUGLVL_ERROR,("CReceiverFE::VsbReset: Invalid Board ID"));
        //  return FALSE;
        }

    }
    else
    {
        if ((m_BoardInfo.uiVsbChipVersion >> 8)== VSB1)
        {
            if(!m_pDemod->SoftwareReset(uiReset))
                return STATUS_ADAPTER_HARDWARE_ERROR;
        }
        else if((m_BoardInfo.uiVsbChipVersion >> 8) == VSB2)
        {
            if(!m_pDemod->SoftwareReset(uiReset))
                return STATUS_ADAPTER_HARDWARE_ERROR;
        }
        else
        {
            _DbgPrintF( DEBUGLVL_ERROR,("CReceiverFE::VsbReset: Invalid VSB Chip version"));
            return STATUS_INVALID_PARAMETER;
        }

        //  if(!m_pDemod->SoftwareReset(uiReset))

        //          return FALSE;

    }
    // delay for 50 ms
    Delay(50000);
    return STATUS_SUCCESS;
}



/*
* SetVsbCapabilities()
* Inputs:    PKSPROPERTY_VSB_CAP_S p_Caps - pointer to VSB capability structure
* Outputs:
* Return: BOOL: returns TRUE, if the operation succeeds else FALSE
* Description: Sets the VSB capabilities (VSB demodulator scheme - VSB-16 or
* VSB-8), VSB version, modes of operation .
* Author : MM
*/
 NTSTATUS CDevice::SetVsbCapabilities(PKSPROPERTY_VSB_CAP_S p_Caps)
 {
    return SetBoard(p_Caps->BoardID);
 }

/*
* GetVsbCapabilities()
* Inputs:    PKSPROPERTY_VSB_CAP_S p_Caps - pointer to VSB capability structure
* Outputs: Filled p_Caps
* Return: BOOL: returns TRUE, if the operation succeeds else FALSE
* Description: Gets the VSB capabilities (VSB demodulator scheme - VSB-16 or
* VSB-8), VSB version, modes of operation .
* Author : MM
*/
 NTSTATUS CDevice::GetVsbCapabilities(PKSPROPERTY_VSB_CAP_S p_Caps)
 {
    p_Caps->ChipVersion = (VSBCHIPTYPE)(m_BoardInfo.uiVsbChipVersion);
    p_Caps->Modulation = VSB8;
    p_Caps->BoardID = m_BoardInfo.uiBoardID;
    return STATUS_SUCCESS;
 }



/*
* AccessRegisterList()
* Inputs:    PKSPROPERTY_VSB_REG_CTRL_S p_VsbCoeff - pointer to register
*               control property set structure
*           UINT uiOperation - Operation (Read or Write)
* Outputs:
* Return: NTSTATUS:
* Description: Based on the operataion requested , Reads/Writes the registers
*
* Author : MM
*/

NTSTATUS CDevice::AccessRegisterList(PKSPROPERTY_VSB_REG_CTRL_S p_RegCtrl,
                                     UINT uiOperation)
{
    RegisterType *p_Registers;
    UINT    uiResult = WDMMINI_NOERROR;

    // Allocate memory for registers
    p_Registers = (RegisterType *)(AllocateFixedMemory(sizeof(RegisterType) *
                                            p_RegCtrl->NumRegisters));

    if (p_Registers == NULL)
        return STATUS_NO_MEMORY;

    // Create a RegisterType array
    UINT uiLength = 0;
    for (UINT i = 0; i < p_RegCtrl->NumRegisters; i++)
    {
        p_Registers[i].uiAddress = p_RegCtrl->RegisterList[i].Address;
        p_Registers[i].uiLength = p_RegCtrl->RegisterList[i].Length;
        p_Registers[i].p_ucBuffer = &p_RegCtrl->Buffer[uiLength];
        uiLength += p_RegCtrl->RegisterList[i].Length;
    }

    if(uiOperation == WRITE_REGISTERS)
    {
        // Set the registers in chip
        uiResult = SetRegisterList(p_Registers, i);
    }
    else
    {
        // Get the registers in chip
        uiResult = GetRegisterList(p_Registers, i, p_RegCtrl->RegisterType);

    }
    // Free memory
    FreeFixedMemory(p_Registers);


    return MapErrorToNTSTATUS(uiResult);

}

/*
* AccessVsbCoeffList()
* Inputs:    PKSPROPERTY_VSB_COEFF_CTRL_S p_VsbCoeff - pointer to register
*               coefficient property set structure
*           UINT uiOperation - Operation (Read or Write)
* Outputs:
* Return: BOOL: returns TRUE, if the operation succeeds else FALSE
* Description: Based on the operataion requested , Reads/Writes the coefficients
* and puts them into the buffer
* Author : MM
*/

NTSTATUS CDevice::AccessVsbCoeffList(PKSPROPERTY_VSB_COEFF_CTRL_S p_VsbCoeff,
                                  UINT uiOperation)
{
    VsbCoeffType VsbCoeff[4];
    UINT i = 0;
    UINT uiLength = 0;
    UINT uiResult ;

    for(i = 0; i < p_VsbCoeff->NumRegisters; i++)
    {
        VsbCoeff[i].uiID = p_VsbCoeff->CoeffList[i].ID;

        if(!m_pDemod->CoeffIDToAddress(p_VsbCoeff->CoeffList[i].ID,
                &VsbCoeff[i].uiAddress, uiOperation))
            return STATUS_INVALID_PARAMETER;

        VsbCoeff[i].uiLength = p_VsbCoeff->CoeffList[i].Length;
        VsbCoeff[i].p_ucBuffer = &p_VsbCoeff->Buffer[uiLength];
        uiLength += VsbCoeff[i].uiLength;

    }
    if(uiOperation == WRITE_REGISTERS)
    {
        uiResult = m_pDemod->SetCoeff(VsbCoeff, i);
    }
    else
    {
        uiResult = m_pDemod->GetCoeff(VsbCoeff, i);
    }
    return MapErrorToNTSTATUS(uiResult);
}



/*
* SetVsbDiagMode()
* Inputs:   ULONG ulOperationMode - Operation mode (Diagnostic/Normal)
*           ULONG ulType - Diagnostic type (valid only when Operation mode is Diagnostic
* Outputs:
* Return: BOOL: returns TRUE, if the operation succeeds else FALSE
* Description: Sets the output to diagnostic or data(normal) mode
* Called in response to property ID KSPROPERTY_VSB_DIAG_CTRL by SetProperty().
* Author : Mini
*/
NTSTATUS CDevice::SetVsbDiagMode(ULONG ulOperationMode, VSBDIAGTYPE ulType)
{
    BOOL bResult = TRUE;
    UCHAR   ucPin, ucValue;


    // VSB1 does not support Diagnostic streaming
    if((m_BoardInfo.uiVsbChipVersion >> 8)== VSB1)
        return STATUS_NOT_IMPLEMENTED;

    // If the mode is NTSC, then don't put changes into effect. These will come into
    // effect next time we swith to ATSC mode
    ULONG ulTunerMode;
    m_pTuner->GetMode(&ulTunerMode);
    if(ulTunerMode == KSPROPERTY_TUNER_MODE_TV)
    {
        if(ulOperationMode == VSB_OPERATION_MODE_DATA)
            m_uiOutputMode = VSB_OUTPUT_MODE_NORMAL;
        else
        {
            m_uiOutputMode = VSB_OUTPUT_MODE_DIAGNOSTIC;
            // Based on type passed, set the diagnostic type in the chip
            if(!m_pDemod->SetDiagMode(ulType))
                return STATUS_UNSUCCESSFUL;
        }
        return STATUS_SUCCESS;
    }

    if(ulOperationMode == VSB_OPERATION_MODE_DATA)
    {
        m_uiOutputMode = VSB_OUTPUT_MODE_NORMAL;
        // Set VSB output mode to normal mode
        if(!m_pDemod->SetOutputMode(VSB_OUTPUT_MODE_NORMAL))
            return STATUS_UNSUCCESSFUL;

        if(m_BoardInfo.uiBoardID == BOARD_CATALINA)
        {
            // Set mode bits (bits 7 - 5 corresponding to bits Mode1 Mode0 Mode2) to 000
            ucValue = m_ucModeInit;
            ucValue &= 0x1F;
            m_pI2CScript->WriteSeq(CATALINA_MISC_CONTROL_REGISTER, &ucValue, 1);
            m_ucModeInit = ucValue;
        }
        else{}
    }
    else if(ulOperationMode == VSB_OPERATION_MODE_DIAG)
    {
        m_uiOutputMode = VSB_OUTPUT_MODE_DIAGNOSTIC;

        // Set VSB output mode to diagnostic mode
        if(!m_pDemod->SetOutputMode(VSB_OUTPUT_MODE_DIAGNOSTIC))
            return STATUS_UNSUCCESSFUL;
        // Based on type passed, set the diagnostic type in the chip
        if(!m_pDemod->SetDiagMode(ulType))
            return STATUS_UNSUCCESSFUL;
        ULONG ulDiagRate = m_pDemod->GetDiagSpeed(ulType);

        if(m_BoardInfo.uiBoardID == BOARD_CATALINA)
        {
            // Set mode bits (bits 7 - 5 corresponding to bits Mode1 Mode0 Mode2)
            // to 100
            ucValue = m_ucModeInit;
            ucValue &= 0x1F;
            ucValue |= 0x80;
            m_pI2CScript->WriteSeq(CATALINA_MISC_CONTROL_REGISTER, &ucValue, 1);
            m_ucModeInit = ucValue;
            // MM; Commented out now. Once I find a way of sending IRPs to apture driver,
            //this can be restored
            //          SendCurrentDiagInfo(ulDiagRate, DIAG_FIELD);

        }
        else{}
    }
    else
    {
        // Invalid operation
            _DbgPrintF( DEBUGLVL_ERROR,("CReceiverFE::VsbReset: Invalid Option"));
            return STATUS_INVALID_PARAMETER;
    }

    return STATUS_SUCCESS;
}

/*
* GetVsbDiagMode()
* Inputs:   ULONG *p_ulOperationMode - pointer to Operation mode (Diagnostic/Normal)
*           ULONG *p_ulType - pointer to Diagnostic type (valid only when Operation mode is Diagnostic
* Outputs: Operation mode and diagnostic type
* Return: NTSTATUS: returns STATUS_SUCCESS, if the operation succeeds
*                   STATUS_NOT_IMPLEMENTED if its VSB2
*                   STATUS_UNSUCCESSFUL if the operation didn't succeed
* Description: Gets the diagnostic type and diagnostic or data(normal) mode
* Author : MM
*/
NTSTATUS CDevice::GetVsbDiagMode(ULONG *p_ulOperationMode, ULONG *p_ulType)
{
    UINT uiOutputMode;

    // VSB1 does not support Diagnostic streaming
    if((m_BoardInfo.uiVsbChipVersion >> 8) == VSB1)
        return STATUS_NOT_IMPLEMENTED;

    if(!m_pDemod->GetOutputMode(&uiOutputMode))
        return STATUS_UNSUCCESSFUL;
    if(!m_pDemod->GetDiagMode(p_ulType))
        return STATUS_UNSUCCESSFUL;

    if(uiOutputMode == VSB_OUTPUT_MODE_DIAGNOSTIC)
        *p_ulOperationMode = VSB_OPERATION_MODE_DIAG;
    else if(uiOutputMode == VSB_OUTPUT_MODE_NORMAL)
        *p_ulOperationMode = VSB_OPERATION_MODE_DATA;
    else
        *p_ulOperationMode = VSB_OPERATION_MODE_INVALID;

    return STATUS_SUCCESS;
}





/*
* VsbQuality()
* Inputs: UINT  quality
* Outputs:
* Return: NTSTATUS: returns STATUS_SUCCESS, if the operation succeeds
*          else STATUS_NOT_IMPLEMENTED if its VSB2
* Description: Enables/Disables quality check and improvement routines. Currently
* it only enables or disables chip hang in VSB1. But can be extended later if necessary
* Author : MM
*/
NTSTATUS CDevice::VsbQuality(UINT   uiQu)
{
    // This property set is only supported for VSB1
    if ((m_BoardInfo.uiVsbChipVersion >> 8) == VSB1)
    {
        if(uiQu & VSB_HANG_CHECK_ENABLE)
            m_bHangCheckFlag = TRUE;
        else
            m_bHangCheckFlag = FALSE;

        return STATUS_SUCCESS;
    }
    else
        return STATUS_NOT_IMPLEMENTED;
}


/*
* SetRegList()
* Inputs:    RegListType *p_Registers - pointer to register list structure
*    UINT    uiNumRegisters : number of registers
* Outputs:
* Return: BOOL: returns TRUE, if the operation succeeds else FALSE
* Description: Writes to registers with the values given in the list.
* Called in response to property ID KSPROPERTY_VSB_ REG_CTRL by SetProperty().
* Author : Mini
*/
UINT CDevice::SetRegisterList(RegisterType *p_Registers, UINT uiNumRegisters)
{
    return (m_pDemod->SetRegisterList(p_Registers, uiNumRegisters));
}

/*
* GetRegList()
* Inputs:    RegListType *p_reg - pointer to register list structure
*    UINT    uiNumRegisters : number of registers
*    UINT    uiRegisterType : Type of Regsiter (Control  or Status)
* Outputs: Filled p_reg
* Return: BOOL: returns TRUE, if the operation succeeds else FALSE
* Description: Reads from registers given in the list and fills their values back
* into the list. This is a shadow operation as the control registers cannot be
* read.
* Called in response to property ID KSPROPERTY_VSB_REG_CTRL by GetProperty().
* Author : Mini
*/

UINT CDevice::GetRegisterList(RegisterType *p_Registers, UINT uiNumRegisters,
                                  UINT uiRegisterType)
{
    return (m_pDemod->GetRegisterList(p_Registers, uiNumRegisters, uiRegisterType));

}



/*
 * MapErrorToNTSTATUS()
 * Maps the WDMMINI error code to NTSTATUS status code
 */
NTSTATUS CDevice::MapErrorToNTSTATUS(UINT uiErr)
{
    if(uiErr == WDMMINI_NOERROR)
        return STATUS_SUCCESS;
    else if((uiErr == WDMMINI_HARDWAREFAILURE) ||
            (uiErr == WDMMINI_NOHARDWARE) ||
            (uiErr == WDMMINI_ERROR_NOI2CPROVIDER) ||
            (uiErr == WDMMINI_ERROR_NOGPIOPROVIDER) ||
            (uiErr == WDMMINI_UNKNOWNHARDWARE))
        return STATUS_ADAPTER_HARDWARE_ERROR;
    else if(uiErr == WDMMINI_INVALIDPARAM)
        return STATUS_INVALID_PARAMETER;
    else if(uiErr == WDMMINI_ERROR_MEMORYALLOCATION)
        return STATUS_NO_MEMORY;
    else if(uiErr == WDMMINI_ERROR_REGISTRY)
        return STATUS_NO_MATCH;
    else
        return STATUS_UNSUCCESSFUL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\slip\mpegcrc.c ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (C) 1996-1997  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:   mpegcrc.c
//
//  PURPOSE:  calculate a standard MPEG 13818-1 style MSB CRC 32.
//
//  FUNCTIONS:
//
//  COMMENTS:   Routine replaced with known good algorithm 4/9/1999 =tkb
//
///////////////////////////////////////////////////////////////////////////////

#include <stdlib.h>
#include <stdio.h>
#include <winsock2.h>
#include <windows.h>

///////////////////////////////////////////////////////////////////////////////
//
//
// Build crc table the first time
//
//
#define MPEGCRC_POLY 0x04c11db7     // MPEG polynomial

ULONG crc32_table[256];


///////////////////////////////////////////////////////////////////////////////
void
init_mpegcrc (
    )
///////////////////////////////////////////////////////////////////////////////
{
        int i, j;
        ULONG c;

        for (i = 0; i < 256; ++i) {
                for (c = i << 24, j = 8; j > 0; --j)
                        c = c & 0x80000000 ? (c << 1) ^ MPEGCRC_POLY : (c << 1);
                crc32_table[i] = c;
        }
}

///////////////////////////////////////////////////////////////////////////////
void
MpegCrcUpdate (
    ULONG * crc,
    UINT len,
    UCHAR * buf
    )
///////////////////////////////////////////////////////////////////////////////
{
        UCHAR *p;

        if (!crc32_table[1])    /* if not already done, */
                init_mpegcrc();   /* build table */

        for (p = buf; len > 0; ++p, --len)
                *crc = (*crc << 8) ^ crc32_table[(*crc >> 24) ^ *p];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\slip\filter.c ===
/////////////////////////////////////////////////////////////////////////////
//
//
// Copyright (c) 1996, 1997  Microsoft Corporation
//
//
// Module Name:
//      filter.c
//
// Abstract:
//
//      This file is a test to find out if dual binding to NDIS and KS works
//
// Author:
//
//      P Porzuczek
//
// Environment:
//
// Revision History:
//
//
//////////////////////////////////////////////////////////////////////////////

#include <wdm.h>
#include <strmini.h>

#include "slip.h"
#include "Main.h"
#include "filter.h"


//////////////////////////////////////////////////////////////////////////////
//
//
//
const FILTER_VTABLE FilterVTable =
    {
    Filter_QueryInterface,
    Filter_AddRef,
    Filter_Release,
    };


///////////////////////////////////////////////////////////////////////////////////
NTSTATUS
CreateFilter (
    PDRIVER_OBJECT DriverObject,
    PDEVICE_OBJECT DeviceObject,
    PSLIP_FILTER pFilter
    )
///////////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS ntStatus = STATUS_SUCCESS;

    //
    // Save off our Device/Driver Objectsx in our context area
    //
    pFilter->DeviceObject          = DeviceObject;
    pFilter->DriverObject          = DriverObject;
    pFilter->lpVTable              = (PFILTER_VTABLE) &FilterVTable;
    pFilter->ulRefCount            = 1;

    pFilter->bDiscontinuity        = FALSE;

    return ntStatus;
}


///////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Filter_QueryInterface (
    PSLIP_FILTER pFilter
    )
///////////////////////////////////////////////////////////////////////////////////
{
    return STATUS_NOT_IMPLEMENTED;
}

///////////////////////////////////////////////////////////////////////////////////
ULONG
Filter_AddRef (
    PSLIP_FILTER pFilter
    )
///////////////////////////////////////////////////////////////////////////////////
{
    if (pFilter)
    {
        pFilter->ulRefCount += 1;
        return pFilter->ulRefCount;
    }

    return 0;
}

///////////////////////////////////////////////////////////////////////////////////
ULONG
Filter_Release (
    PSLIP_FILTER pFilter
    )
///////////////////////////////////////////////////////////////////////////////////
{
    ULONG ulRefCount = 0L;

    if (pFilter)
    {
        pFilter->ulRefCount -= 1;
        ulRefCount = pFilter->ulRefCount;

        if (pFilter->ulRefCount == 0)
        {
            // $$BUG  Free Filter here
            return ulRefCount;
        }
    }

    return ulRefCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\slip\slip.c ===
////////////////////////////////////////////////////////////////////////////
//
//
// Copyright (c) 1996, 1997  Microsoft Corporation
//
//
// Module Name:
//      slip.c
//
// Abstract:
//
//
// Author:
//
//      P Porzuczek
//
// Environment:
//
// Revision History:
//
//
//////////////////////////////////////////////////////////////////////////////

#include <wdm.h>
#include <strmini.h>
#include <ksmedia.h>
#include <BdaTypes.h>
#include <BdaMedia.h>

#include "Slip.h"
#include "SlipMedia.h"
#include "SlipStream.h"
#include "Recv.h"

#include "Main.h"
#include "filter.h"

//////////////////////////////////////////////////////////////////////////////
//
//
VOID
DumpDataFormat (
    PKSDATAFORMAT   pF
    );



typedef struct _IPHeader {
   UCHAR       ucIPVerLen;       // Version and length.
   UCHAR       ucIPTos;          // Type of service.
   USHORT      usLength;         // Total length of datagram.
   USHORT      usIPId;           // Identification.
   USHORT      usIPOffset;       // Flags and fragment offset.
   UCHAR       ucIPTtl;          // Time to live.
   UCHAR       ucProtocol  ;     // Protocol.
   USHORT      usChkSum;         // Header checksum.
   UCHAR       ulIPSrc [4];      // Source address.
   UCHAR       ulIPDst [4];      // Destination address.
} IPHEADER, * PIPHEADER;

//////////////////////////////////////////////////////////////////////////////
VOID
BuildTestIPFrame (
    PUCHAR pFrame
)
//////////////////////////////////////////////////////////////////////////////
{
    ULONG ul          = 0;
    PIPHEADER pHeader = (PIPHEADER) pFrame;

    if (pFrame == NULL)
    {
        return;
    }

    //
    // Do the header part 1st
    //
    pHeader->ucIPVerLen = 0x45;
    pHeader->ucIPTos    = 0x00;
    pHeader->usLength   = 0x1C01;
    pHeader->usIPId     = 0x980A;
    pHeader->usIPOffset = 0x0000;
    pHeader->ucIPTtl    = 0x08;
    pHeader->ucProtocol = 0x11;
    pHeader->usChkSum   = 0x72B6;


    pHeader->ulIPSrc [0] = 0xC0;
    pHeader->ulIPSrc [1] = 0xA8;
    pHeader->ulIPSrc [2] = 0x01;
    pHeader->ulIPSrc [3] = 0x64;

    pHeader->ulIPDst [0] = 0xE3;
    pHeader->ulIPDst [1] = 0x02;
    pHeader->ulIPDst [2] = 0x02;
    pHeader->ulIPDst [3] = 0x02;

    //
    // Do the Data Part
    //
    for (pFrame += sizeof (IPHEADER), ul = 0; ul < 0x11C; ul++)
    {
        *pFrame++ = 0x11;
    }

    return;
}


//////////////////////////////////////////////////////////////////////////////
VOID
SlipGetConnectionProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    PSTREAM pStream                     = (PSTREAM)pSrb->StreamObject->HwStreamExtension;
    PSTREAM_PROPERTY_DESCRIPTOR pSPD    = pSrb->CommandData.PropertyInfo;
    ULONG Id                            = pSPD->Property->Id;                // index of the property
    ULONG ulStreamNumber                = pSrb->StreamObject->StreamNumber;

    pSrb->ActualBytesTransferred = 0;

    switch (Id)
    {
        case KSPROPERTY_CONNECTION_ALLOCATORFRAMING:
        {
            PKSALLOCATOR_FRAMING Framing = (PKSALLOCATOR_FRAMING) pSPD->PropertyInfo;

            Framing->RequirementsFlags   = KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY    |
                                           KSALLOCATOR_REQUIREMENTF_INPLACE_MODIFIER |
                                           KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY;

            Framing->PoolType            = NonPagedPool;
            Framing->Frames              = 0;
            Framing->FrameSize           = 0;
            Framing->FileAlignment       = 0;         // None OR FILE_QUAD_ALIGNMENT-1 OR PAGE_SIZE-1;
            Framing->Reserved            = 0;

            switch (ulStreamNumber)
            {
                case SLIP_IPV4:
                    Framing->Frames    = 64;
                    Framing->FrameSize = pStream->OpenedFormat.SampleSize;
                    pSrb->Status = STATUS_SUCCESS;
                    break;

                case SLIP_STREAM:
                    Framing->Frames    = 64;
                    Framing->FrameSize = pStream->OpenedFormat.SampleSize;
                    pSrb->Status = STATUS_SUCCESS;
                    break;

                default:
                    pSrb->Status = STATUS_NOT_IMPLEMENTED;
                    break;
            }
            pSrb->ActualBytesTransferred = sizeof (KSALLOCATOR_FRAMING);
        }
        break;

        default:
            pSrb->Status = STATUS_NOT_IMPLEMENTED;
            break;
    }


    return;
}


//////////////////////////////////////////////////////////////////////////////
NTSTATUS
SlipDriverInitialize (
    IN PDRIVER_OBJECT    DriverObject,
    IN PUNICODE_STRING   RegistryPath
    )
//////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS ntStatus                        = STATUS_SUCCESS;
    HW_INITIALIZATION_DATA   HwInitData;
    UNICODE_STRING           DeviceNameString;
    UNICODE_STRING           SymbolicNameString;

    RtlZeroMemory(&HwInitData, sizeof(HwInitData));
    HwInitData.HwInitializationDataSize = sizeof(HwInitData);


    ////////////////////////////////////////////////////////////////
    //
    // Setup the stream class dispatch table
    //
    HwInitData.HwInterrupt                 = NULL; // HwInterrupt is only for HW devices

    HwInitData.HwReceivePacket             = CodecReceivePacket;
    HwInitData.HwCancelPacket              = CodecCancelPacket;
    HwInitData.HwRequestTimeoutHandler     = CodecTimeoutPacket;

    HwInitData.DeviceExtensionSize         = sizeof(SLIP_FILTER);
    HwInitData.PerRequestExtensionSize     = sizeof(SRB_EXTENSION);
    HwInitData.FilterInstanceExtensionSize = 0;
    HwInitData.PerStreamExtensionSize      = sizeof(STREAM);
    HwInitData.BusMasterDMA                = FALSE;
    HwInitData.Dma24BitAddresses           = FALSE;
    HwInitData.BufferAlignment             = 3;
    HwInitData.TurnOffSynchronization      = TRUE;
    HwInitData.DmaBufferSize               = 0;


    ntStatus = StreamClassRegisterAdapter (DriverObject, RegistryPath, &HwInitData);
    if (ntStatus != STATUS_SUCCESS)
    {
        goto ret;
    }

ret:

    return ntStatus;
}


//
//
//////////////////////////////////////////////////////////////////////////////
BOOLEAN
CodecInitialize (
    IN OUT PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS ntStatus                           = STATUS_SUCCESS;
    BOOLEAN bStatus                             = FALSE;
    PPORT_CONFIGURATION_INFORMATION pConfigInfo = pSrb->CommandData.ConfigInfo;
    PSLIP_FILTER pFilter                      = (PSLIP_FILTER) pConfigInfo->HwDeviceExtension;

    //
    // Define the default return codes
    //
    pSrb->Status = STATUS_SUCCESS;
    bStatus = TRUE;

    //
    // Initialize Statistics block
    //
    RtlZeroMemory(&pFilter->Stats, sizeof (STATS));

    //
    // Check out init flag so we don't try to init more then once.  The Streaming
    // Class driver appears to call the init handler several times for some reason.
    //
    if (pFilter->bInitializationComplete)
    {
        goto ret;
    }

    if (pConfigInfo->NumberOfAccessRanges == 0)
    {
        pConfigInfo->StreamDescriptorSize = sizeof (HW_STREAM_HEADER) +
            DRIVER_STREAM_COUNT * sizeof (HW_STREAM_INFORMATION);

    }
    else
    {
        pSrb->Status = STATUS_NO_SUCH_DEVICE;
        bStatus = FALSE;
        goto ret;
    }


    //
    // Create a filter object to represent our context
    //
    pSrb->Status = CreateFilter (pConfigInfo->ClassDeviceObject->DriverObject, pConfigInfo->ClassDeviceObject, pFilter);
    if (pSrb->Status != STATUS_SUCCESS)
    {
        bStatus = FALSE;
        goto ret;
    }

    pFilter->bInitializationComplete = TRUE;

ret:

    return (bStatus);
}


//////////////////////////////////////////////////////////////////////////////
BOOLEAN
CodecUnInitialize (
    IN OUT PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS ntStatus                           = STATUS_SUCCESS;
    BOOLEAN bStatus                             = FALSE;
    PPORT_CONFIGURATION_INFORMATION pConfigInfo = pSrb->CommandData.ConfigInfo;
    PSLIP_FILTER pFilter                      = ((PSLIP_FILTER)pSrb->HwDeviceExtension);
    PSTREAM pStream                             = NULL;


    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Codec Unitialize called\n"));

    if (pSrb->StreamObject != NULL)
    {
        pStream = (PSTREAM)pSrb->StreamObject->HwStreamExtension;
    }


    if (pStream)
    {

        //
        // Clean up the NAB_STREAM QUEUE used for deframing
        //
        DeleteNabStreamQueue (pFilter);

        //
        // Clean up any queues we have and complete any outstanding SRB's
        //
        while (QueueRemove (&pSrb, &pFilter->StreamUserSpinLock, &pFilter->StreamContxList))
        {
            pSrb->Status = STATUS_CANCELLED;
            StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
            TEST_DEBUG( TEST_DBG_SRB, ("SLIP 5Completed SRB %08X\n", pSrb));

        }

        while (QueueRemove (&pSrb, &pFilter->IpV4StreamDataSpinLock, &pFilter->IpV4StreamDataQueue))
        {
            pSrb->Status = STATUS_CANCELLED;
            StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb );
            TEST_DEBUG( TEST_DBG_SRB, ("SLIP 6Completed SRB %08X\n", pSrb));
        }


        while (QueueRemove (&pSrb, &pFilter->StreamDataSpinLock, &pFilter->StreamDataQueue))
        {
            pSrb->Status = STATUS_CANCELLED;
            StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb );
            TEST_DEBUG( TEST_DBG_SRB, ("SLIP 7Completed SRB %08X\n", pSrb));
        }


        while (QueueRemove (&pSrb, &pFilter->StreamControlSpinLock, &pFilter->StreamControlQueue))
        {
            pSrb->Status = STATUS_CANCELLED;
            StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
            TEST_DEBUG( TEST_DBG_SRB, ("SLIP 8Completed SRB %08X\n", pSrb));
        }

    }


    while (QueueRemove (&pSrb, &pFilter->AdapterSRBSpinLock, &pFilter->AdapterSRBQueue))
    {
        pSrb->Status = STATUS_CANCELLED;
        StreamClassDeviceNotification (DeviceRequestComplete, pSrb->StreamObject, pSrb);
        TEST_DEBUG( TEST_DBG_RECV, ("SLIP 9Completed SRB %08X\n", pSrb));
    }


    bStatus = TRUE;

    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Codec Unitialize completed\n"));

    return (bStatus);
}


//////////////////////////////////////////////////////////////////////////////
VOID
CodecStreamInfo (
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    int j;

    PSLIP_FILTER pFilter =
            ((PSLIP_FILTER)pSrb->HwDeviceExtension);

    //
    // pick up the pointer to header which preceeds the stream info structs
    //
    PHW_STREAM_HEADER pstrhdr =
            (PHW_STREAM_HEADER)&(pSrb->CommandData.StreamBuffer->StreamHeader);

    //
    // pick up the pointer to the array of stream information data structures
    //
    PHW_STREAM_INFORMATION pstrinfo =
            (PHW_STREAM_INFORMATION)&(pSrb->CommandData.StreamBuffer->StreamInfo);


    //
    // Set the header
    //
    StreamHeader.NumDevPropArrayEntries = 0;
    StreamHeader.DevicePropertiesArray = (PKSPROPERTY_SET)NULL;

    *pstrhdr = StreamHeader;

    //
    // stuff the contents of each HW_STREAM_INFORMATION struct
    //
    for (j = 0; j < DRIVER_STREAM_COUNT; j++)
    {
       *pstrinfo++ = Streams[j].hwStreamInfo;
    }

    pSrb->Status = STATUS_SUCCESS;

}


//////////////////////////////////////////////////////////////////////////////
VOID
STREAMAPI
CodecCancelPacket(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    PSTREAM  pStream = (PSTREAM)pSrb->StreamObject->HwStreamExtension;
    PSLIP_FILTER  pFilter = ((PSLIP_FILTER)pSrb->HwDeviceExtension);

    //
    // Check whether the SRB to cancel is in use by this stream
    //

    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: CancelPacket Called\n"));


    CancelNabStreamSrb (pFilter, pSrb);


    if (QueueRemoveSpecific (pSrb, &pFilter->IpV4StreamDataSpinLock, &pFilter->IpV4StreamDataQueue))
    {
        pSrb->Status = STATUS_CANCELLED;
        StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb );
        TEST_DEBUG( TEST_DBG_SRB, ("SLIP 10Completed SRB %08X\n", pSrb));
        return;
    }


    if (QueueRemoveSpecific (pSrb, &pFilter->StreamDataSpinLock, &pFilter->StreamDataQueue))
    {
        pSrb->Status = STATUS_CANCELLED;
        StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb );
        TEST_DEBUG( TEST_DBG_SRB, ("SLIP 11Completed SRB %08X\n", pSrb));
        return;
    }


    if (QueueRemoveSpecific (pSrb, &pFilter->StreamControlSpinLock, &pFilter->StreamControlQueue))
    {
        pSrb->Status = STATUS_CANCELLED;
        StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
        TEST_DEBUG( TEST_DBG_SRB, ("SLIP 12Completed SRB %08X\n", pSrb));
        return;
    }

    if (QueueRemoveSpecific (pSrb, &pFilter->AdapterSRBSpinLock, &pFilter->AdapterSRBQueue))
    {
        pSrb->Status = STATUS_CANCELLED;
        StreamClassDeviceNotification (DeviceRequestComplete, pSrb->StreamObject, pSrb);
        TEST_DEBUG( TEST_DBG_SRB, ("SLIP 13Completed SRB %08X\n", pSrb));
        return;
    }

    return;
}


//////////////////////////////////////////////////////////////////////////////
VOID
STREAMAPI
CodecTimeoutPacket(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    //
    // if we timeout while playing, then we need to consider this
    // condition an error, and reset the hardware, and reset everything
    // as well as cancelling this and all requests
    //

    //
    // if we are not playing, and this is a CTRL request, we still
    // need to reset everything as well as cancelling this and all requests
    //

    //
    // if this is a data request, and the device is paused, we probably have
    // run out of data buffer, and need more time, so just reset the timer,
    // and let the packet continue
    //

    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: TimeoutPacket Called\n"));

    pSrb->TimeoutCounter = 0;

    return;
}


//////////////////////////////////////////////////////////////////////////////
VOID
STREAMAPI
CodecReceivePacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    PSLIP_FILTER pFilter = ((PSLIP_FILTER)pSrb->HwDeviceExtension);


    //
    // Make sure queue & SL initted
    //
    if (!pFilter->bAdapterQueueInitialized)
    {
        InitializeListHead (&pFilter->AdapterSRBQueue);
        KeInitializeSpinLock (&pFilter->AdapterSRBSpinLock);
        pFilter->bAdapterQueueInitialized = TRUE;
    }

    //
    // Assume success
    //
    pSrb->Status = STATUS_SUCCESS;

    //
    // determine the type of packet.
    //
    QueueAdd (pSrb, &pFilter->AdapterSRBSpinLock, &pFilter->AdapterSRBQueue);
    TEST_DEBUG( TEST_DBG_SRB, ("SLIP Queuing SRB %08X\n", pSrb));


    while (QueueRemove( &pSrb, &pFilter->AdapterSRBSpinLock, &pFilter->AdapterSRBQueue ))
    {
        switch (pSrb->Command)
        {

            case SRB_INITIALIZE_DEVICE:
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: SRB_INITIALIZE Command\n"));
                CodecInitialize(pSrb);
                break;

            case SRB_UNINITIALIZE_DEVICE:
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: SRB_UNINITIALIZE Command\n"));
                CodecUnInitialize(pSrb);
                break;

            case SRB_INITIALIZATION_COMPLETE:
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: SRB_INITIALIZE_COMPLETE Command\n"));
                pSrb->Status = STATUS_SUCCESS;
                break;

            case SRB_OPEN_STREAM:
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: SRB_OPEN_STREAM Command\n"));
                OpenStream (pSrb);
                break;

            case SRB_CLOSE_STREAM:
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: SRB_CLOSE_STREAM Command\n"));
                CloseStream (pSrb);
                break;

            case SRB_GET_STREAM_INFO:
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: SRB_GET_STREAM_INFO Command\n"));
                CodecStreamInfo (pSrb);
                break;

            case SRB_GET_DATA_INTERSECTION:
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: SRB_GET_DATA_INTERSECTION Command\n"));

                //
                // Compare our stream formats.  NOTE, the compare functions sets the SRB
                // status fields
                //
                CompareStreamFormat (pSrb);
                break;

            case SRB_OPEN_DEVICE_INSTANCE:
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: SRB_OPEN_DEVICE_INSTANCE Command\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            case SRB_CLOSE_DEVICE_INSTANCE:
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: SRB_CLOSE_DEVICE_INSTANCE Command\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            case SRB_UNKNOWN_DEVICE_COMMAND:
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: SRB_UNKNOWN_DEVICE Command\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            case SRB_CHANGE_POWER_STATE:
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: SRB_CHANGE_POWER_STATE Command\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            case SRB_GET_DEVICE_PROPERTY:
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: SRB_GET_DEVICE_PROPERTY Command\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            case SRB_SET_DEVICE_PROPERTY:
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: SRB_SET_DEVICE_PROPERTY Command\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            case SRB_UNKNOWN_STREAM_COMMAND:
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: SRB_UNKNOWN Command\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            default:
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: SRB_DEFAULT Command\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

        };


        //
        // NOTE:
        //
        // All of the commands that we do, or do not understand can all be completed
        // syncronously at this point, so we can use a common callback routine here.
        // If any of the above commands require asyncronous processing, this will
        // have to change
        //

        TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: SRB Status returned: %08X\n", pSrb->Status));

        StreamClassDeviceNotification (DeviceRequestComplete, pFilter, pSrb);
        TEST_DEBUG( TEST_DBG_SRB, ("SLIP 14Completed SRB %08X\n", pSrb));

    }




}


//////////////////////////////////////////////////////////////////////////////
BOOL STREAMAPI
QueueAdd (
    IN PHW_STREAM_REQUEST_BLOCK pSrb,
    IN PKSPIN_LOCK pQueueSpinLock,
    IN PLIST_ENTRY pQueue
    )
//////////////////////////////////////////////////////////////////////////////
{
    KIRQL           Irql;
    PSRB_EXTENSION  pSrbExtension;

    pSrbExtension = ( PSRB_EXTENSION )pSrb->SRBExtension;

    KeAcquireSpinLock( pQueueSpinLock, &Irql );

    pSrbExtension->pSrb = pSrb;
    InsertTailList( pQueue, &pSrbExtension->ListEntry );

    KeReleaseSpinLock( pQueueSpinLock, Irql );

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
BOOL STREAMAPI
QueuePush (
    IN PHW_STREAM_REQUEST_BLOCK pSrb,
    IN PKSPIN_LOCK pQueueSpinLock,
    IN PLIST_ENTRY pQueue
    )
//////////////////////////////////////////////////////////////////////////////
{
    KIRQL           Irql;
    PSRB_EXTENSION  pSrbExtension;

    pSrbExtension = ( PSRB_EXTENSION )pSrb->SRBExtension;

    KeAcquireSpinLock( pQueueSpinLock, &Irql );

    pSrbExtension->pSrb = pSrb;
    InsertHeadList( pQueue, &pSrbExtension->ListEntry );

    KeReleaseSpinLock( pQueueSpinLock, Irql );

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
BOOL STREAMAPI
QueueAddIfNotEmpty (
    IN PHW_STREAM_REQUEST_BLOCK pSrb,
    IN PKSPIN_LOCK pQueueSpinLock,
    IN PLIST_ENTRY pQueue
    )
//////////////////////////////////////////////////////////////////////////////
{
   KIRQL           Irql;
   PSRB_EXTENSION  pSrbExtension;
   BOOL            bAddedSRB = FALSE;

   pSrbExtension = ( PSRB_EXTENSION )pSrb->SRBExtension;

   KeAcquireSpinLock( pQueueSpinLock, &Irql );

   if( !IsListEmpty( pQueue ))
   {
       pSrbExtension->pSrb = pSrb;
       InsertTailList (pQueue, &pSrbExtension->ListEntry );
       bAddedSRB = TRUE;
   }

   KeReleaseSpinLock( pQueueSpinLock, Irql );

   return bAddedSRB;
}

//////////////////////////////////////////////////////////////////////////////
BOOL STREAMAPI
QueueRemove (
    IN OUT PHW_STREAM_REQUEST_BLOCK * pSrb,
    IN PKSPIN_LOCK pQueueSpinLock,
    IN PLIST_ENTRY pQueue
    )
//////////////////////////////////////////////////////////////////////////////
{
   KIRQL    Irql;
   BOOL     bRemovedSRB = FALSE;

   KeAcquireSpinLock (pQueueSpinLock, &Irql);

   *pSrb =  (PHW_STREAM_REQUEST_BLOCK) NULL;

   if( !IsListEmpty( pQueue ))
   {
       PHW_STREAM_REQUEST_BLOCK *pCurrentSrb = NULL;
       PUCHAR Ptr                            = (PUCHAR) RemoveHeadList(pQueue);

       pCurrentSrb = (PHW_STREAM_REQUEST_BLOCK *) (((PUCHAR)Ptr) + sizeof (LIST_ENTRY));

       *pSrb = *pCurrentSrb;
       bRemovedSRB = TRUE;

   }

   KeReleaseSpinLock (pQueueSpinLock, Irql);

   return bRemovedSRB;
}

//////////////////////////////////////////////////////////////////////////////
BOOL STREAMAPI
QueueRemoveSpecific (
    IN PHW_STREAM_REQUEST_BLOCK pSrb,
    IN PKSPIN_LOCK pQueueSpinLock,
    IN PLIST_ENTRY pQueue
    )
//////////////////////////////////////////////////////////////////////////////
{
   KIRQL Irql;
   BOOL  bRemovedSRB = FALSE;
   PLIST_ENTRY pCurrentEntry;
   PHW_STREAM_REQUEST_BLOCK * pCurrentSrb;

   KeAcquireSpinLock( pQueueSpinLock, &Irql );

   if( !IsListEmpty( pQueue ))
   {
       pCurrentEntry = pQueue->Flink;
       while ((pCurrentEntry != pQueue ) && !bRemovedSRB)
       {
           pCurrentSrb = (PHW_STREAM_REQUEST_BLOCK * ) ((( PUCHAR )pCurrentEntry ) + sizeof( LIST_ENTRY ));

           if( *pCurrentSrb == pSrb )
           {
               RemoveEntryList( pCurrentEntry );
               bRemovedSRB = TRUE;
           }
           pCurrentEntry = pCurrentEntry->Flink;
       }
   }
   KeReleaseSpinLock( pQueueSpinLock, Irql );

   return bRemovedSRB;
}

//////////////////////////////////////////////////////////////////////////////
NTSTATUS
StreamIPIndicateEvent (
    PVOID pvEvent
)
//////////////////////////////////////////////////////////////////////////////
{
    return STATUS_NOT_IMPLEMENTED;
}



//////////////////////////////////////////////////////////////////////////////
BOOL
CompareGUIDsAndFormatSize(
    IN PKSDATARANGE pDataRange1,
    IN PKSDATARANGE pDataRange2,
    BOOLEAN bCheckSize
    )
//////////////////////////////////////////////////////////////////////////////
{
    BOOL bResult = FALSE;

    if ( IsEqualGUID(&pDataRange1->MajorFormat, &KSDATAFORMAT_TYPE_WILDCARD) ||
         IsEqualGUID(&pDataRange2->MajorFormat, &KSDATAFORMAT_TYPE_WILDCARD) ||
         IsEqualGUID(&pDataRange1->MajorFormat, &pDataRange2->MajorFormat) )
    {

        if ( IsEqualGUID(&pDataRange1->SubFormat, &KSDATAFORMAT_SUBTYPE_WILDCARD) ||
             IsEqualGUID(&pDataRange2->SubFormat, &KSDATAFORMAT_SUBTYPE_WILDCARD) ||
             IsEqualGUID(&pDataRange1->SubFormat, &pDataRange2->SubFormat) )
        {

            if ( IsEqualGUID(&pDataRange1->Specifier, &KSDATAFORMAT_SPECIFIER_WILDCARD) ||
                 IsEqualGUID(&pDataRange2->Specifier, &KSDATAFORMAT_SPECIFIER_WILDCARD) ||
                 IsEqualGUID(&pDataRange1->Specifier, &pDataRange2->Specifier) )
            {
                if ( !bCheckSize || pDataRange1->FormatSize == pDataRange2->FormatSize)
                {
                    bResult = TRUE;
                }
            }
        }
    }

    return bResult;

}

//////////////////////////////////////////////////////////////////////////////
VOID
DumpDataFormat (
    PKSDATAFORMAT   pF
    )
//////////////////////////////////////////////////////////////////////////////
{
    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: DATA Format\n"));
    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP:     Format Size:   %08X\n", pF->FormatSize));
    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP:     Flags:         %08X\n", pF->Flags));
    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP:     SampleSize:    %08X\n", pF->SampleSize));
    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP:     Reserved:      %08X\n", pF->Reserved));



    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP:     Major GUID:  %08X %04X %04X %02X %02X %02X %02X %02X %02X %02X %02X\n",
                                                pF->MajorFormat.Data1,
                                                pF->MajorFormat.Data2,
                                                pF->MajorFormat.Data3,
                                                pF->MajorFormat.Data4[0],
                                                pF->MajorFormat.Data4[1],
                                                pF->MajorFormat.Data4[2],
                                                pF->MajorFormat.Data4[3],
                                                pF->MajorFormat.Data4[4],
                                                pF->MajorFormat.Data4[5],
                                                pF->MajorFormat.Data4[6],
                                                pF->MajorFormat.Data4[7]
                                ));

    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP:     Sub GUID:    %08X %04X %04X %02X %02X %02X %02X %02X %02X %02X %02X\n",
                                                pF->SubFormat.Data1,
                                                pF->SubFormat.Data2,
                                                pF->SubFormat.Data3,
                                                pF->SubFormat.Data4[0],
                                                pF->SubFormat.Data4[1],
                                                pF->SubFormat.Data4[2],
                                                pF->SubFormat.Data4[3],
                                                pF->SubFormat.Data4[4],
                                                pF->SubFormat.Data4[5],
                                                pF->SubFormat.Data4[6],
                                                pF->SubFormat.Data4[7]
                                ));

    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP:     Specifier:   %08X %04X %04X %02X %02X %02X %02X %02X %02X %02X %02X\n",
                                                pF->Specifier.Data1,
                                                pF->Specifier.Data2,
                                                pF->Specifier.Data3,
                                                pF->Specifier.Data4[0],
                                                pF->Specifier.Data4[1],
                                                pF->Specifier.Data4[2],
                                                pF->Specifier.Data4[3],
                                                pF->Specifier.Data4[4],
                                                pF->Specifier.Data4[5],
                                                pF->Specifier.Data4[6],
                                                pF->Specifier.Data4[7]
                                ));

    TEST_DEBUG (TEST_DBG_TRACE, ("\n"));
}


//////////////////////////////////////////////////////////////////////////////
BOOL
CompareStreamFormat (
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    BOOL                        bStatus = FALSE;
    PSTREAM_DATA_INTERSECT_INFO pIntersectInfo;
    PKSDATARANGE                pDataRange1;
    PKSDATARANGE                pDataRange2;
    ULONG                       FormatSize = 0;
    ULONG                       ulStreamNumber;
    ULONG                       j;
    ULONG                       ulNumberOfFormatArrayEntries;
    PKSDATAFORMAT               *pAvailableFormats;


    pIntersectInfo = pSrb->CommandData.IntersectInfo;
    ulStreamNumber = pIntersectInfo->StreamNumber;


    pSrb->ActualBytesTransferred = 0;


    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Comparing Stream Formats\n"));


    //
    // Check that the stream number is valid
    //
    if (ulStreamNumber < DRIVER_STREAM_COUNT)
    {
        ulNumberOfFormatArrayEntries = Streams[ulStreamNumber].hwStreamInfo.NumberOfFormatArrayEntries;

        //
        // Get the pointer to the array of available formats
        //
        pAvailableFormats = Streams[ulStreamNumber].hwStreamInfo.StreamFormatsArray;

        //
        // Walk the formats supported by the stream searching for a match
        // of the three GUIDs which together define a DATARANGE
        //
        for (pDataRange1 = pIntersectInfo->DataRange, j = 0;
             j < ulNumberOfFormatArrayEntries;
             j++, pAvailableFormats++)

        {
            bStatus = FALSE;
            pSrb->Status = STATUS_UNSUCCESSFUL;

            pDataRange2 = *pAvailableFormats;

            if (CompareGUIDsAndFormatSize (pDataRange1, pDataRange2, TRUE))
            {

                ULONG   ulFormatSize = pDataRange2->FormatSize;

                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Stream Formats compare\n"));

                //
                // Is the caller trying to get the format, or the size of the format?
                //
                if (pIntersectInfo->SizeOfDataFormatBuffer == sizeof (ULONG))
                {
                    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Returning Stream Format size\n"));

                    *(PULONG) pIntersectInfo->DataFormatBuffer = ulFormatSize;
                    pSrb->ActualBytesTransferred = sizeof (ULONG);
                    pSrb->Status = STATUS_SUCCESS;
                    bStatus = TRUE;
                }
                else
                {
                    //
                    // Verify that there is enough room in the supplied buffer for the whole thing
                    //
                    pSrb->Status = STATUS_BUFFER_TOO_SMALL;
                    bStatus = FALSE;

                    if (pIntersectInfo->SizeOfDataFormatBuffer >= ulFormatSize)
                    {
                        TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Returning Stream Format\n"));
                        RtlCopyMemory (pIntersectInfo->DataFormatBuffer, pDataRange2, ulFormatSize);
                        pSrb->ActualBytesTransferred = ulFormatSize;
                        pSrb->Status = STATUS_SUCCESS;
                        bStatus = TRUE;
                    }
                    else
                    {
                        TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Stream Format return buffer too small\n"));
                    }
                }
                break;
            }
            else
            {
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Stream Formats DO NOT compare\n"));
            }
        }

        if ( j >= ulNumberOfFormatArrayEntries )
        {
            pSrb->ActualBytesTransferred = 0;
            pSrb->Status = STATUS_UNSUCCESSFUL;
            bStatus = FALSE;
        }

    }
    else
    {
        pSrb->ActualBytesTransferred = 0;
        pSrb->Status = STATUS_NOT_IMPLEMENTED;
        bStatus = FALSE;
    }

    return bStatus;
}


//////////////////////////////////////////////////////////////////////////////
VOID
CloseStream (
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    //
    // the stream extension structure is allocated by the stream class driver
    //
    PSTREAM         pStream                = (PSTREAM)pSrb->StreamObject->HwStreamExtension;
    PSLIP_FILTER  pFilter                = (PSLIP_FILTER)pSrb->HwDeviceExtension;
    ULONG           ulStreamNumber         = (ULONG) pSrb->StreamObject->StreamNumber;
    ULONG           ulStreamInstance       = pStream->ulStreamInstance;
    PHW_STREAM_REQUEST_BLOCK pCurrentSrb   = NULL;

    //
    // check that the stream index requested isn't too high
    // or that the maximum number of instances hasn't been exceeded
    //
    if (ulStreamNumber < DRIVER_STREAM_COUNT )
    {
        //
        // Flush the stream data queue
        //
        while (QueueRemove( &pCurrentSrb, &pFilter->IpV4StreamDataSpinLock, &pFilter->IpV4StreamDataQueue))
        {
           pCurrentSrb->Status = STATUS_CANCELLED;
           StreamClassStreamNotification( StreamRequestComplete, pCurrentSrb->StreamObject, pCurrentSrb);
           TEST_DEBUG( TEST_DBG_SRB, ("SLIP 15Completed SRB %08X\n", pCurrentSrb));
        }

        //
        // Flush the stream data queue
        //
        while (QueueRemove( &pCurrentSrb, &pFilter->StreamDataSpinLock, &pFilter->StreamDataQueue))
        {
           pCurrentSrb->Status = STATUS_CANCELLED;
           StreamClassStreamNotification( StreamRequestComplete, pCurrentSrb->StreamObject, pCurrentSrb);
           TEST_DEBUG( TEST_DBG_SRB, ("SLIP 16Completed SRB %08X\n", pCurrentSrb));
        }

        //
        // Flush the stream control queue
        //
        while (QueueRemove( &pCurrentSrb, &pFilter->StreamControlSpinLock, &pFilter->StreamControlQueue))
        {
           pCurrentSrb->Status = STATUS_CANCELLED;
           StreamClassStreamNotification (StreamRequestComplete, pCurrentSrb->StreamObject, pCurrentSrb);
           TEST_DEBUG( TEST_DBG_SRB, ("SLIP 17Completed SRB %08X\n", pCurrentSrb));
        }

        //
        // Clear this streams spot in the filters stream array
        //
        pFilter->pStream[ulStreamNumber][ulStreamInstance] = NULL;

        //
        // decrement the stream instance count for this filter
        //
        pFilter->ulActualInstances[ulStreamNumber]--;

        //
        // Indicate the clock support available on this stream
        //
        //pSrb->StreamObject->HwClockObject = 0;

        //
        // Reset the stream state to stopped
        //
        pStream->KSState = KSSTATE_STOP;

        //
        //
        //
        pStream->hMasterClock = NULL;

        //
        // Reset the stream extension blob
        //
        RtlZeroMemory(pStream, sizeof (STREAM));

        pSrb->Status = STATUS_SUCCESS;

    }
    else
    {
        pSrb->Status = STATUS_INVALID_PARAMETER;
    }
}


//////////////////////////////////////////////////////////////////////////////
VOID
OpenStream (
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    //
    // the stream extension structure is allocated by the stream class driver
    //
    PSTREAM         pStream        = (PSTREAM)pSrb->StreamObject->HwStreamExtension;
    PSLIP_FILTER    pFilter        = ((PSLIP_FILTER)pSrb->HwDeviceExtension);
    ULONG           ulStreamNumber = (ULONG) pSrb->StreamObject->StreamNumber;
    PKSDATAFORMAT   pKSDataFormat  = (PKSDATAFORMAT)pSrb->CommandData.OpenFormat;

    //
    // Initialize the stream extension blob
    //
    //RtlZeroMemory(pStream, sizeof (STREAM));

    //
    // Initialize stream state
    //
    //pStream->KSState = KSSTATE_STOP;

    //
    // Initialize the next stream life check time.
    //
    KeQuerySystemTime( &pFilter->liLastTimeChecked );

    //
    // Initialize stats dump time
    //
    KeQuerySystemTime( &pFilter->liLastTimeStatsDumped );

    //
    // check that the stream index requested isn't too high
    // or that the maximum number of instances hasn't been exceeded
    //
    if (ulStreamNumber < DRIVER_STREAM_COUNT )
    {
        ULONG ulStreamInstance;
        ULONG ulMaxInstances = Streams[ulStreamNumber].hwStreamInfo.NumberOfPossibleInstances;

        //
        // Search for next open slot
        //
        for (ulStreamInstance = 0; ulStreamInstance < ulMaxInstances; ++ulStreamInstance)
        {
            if (pFilter->pStream[ulStreamNumber][ulStreamInstance] == NULL)
            {
                break;
            }
        }

        if (ulStreamInstance < ulMaxInstances)
        {
            if (VerifyFormat(pKSDataFormat, ulStreamNumber, &pStream->MatchedFormat))
            {
                //
                // Initialize Data queues and SpinLocks
                //
                InitializeListHead(&pFilter->StreamControlQueue);
                KeInitializeSpinLock(&pFilter->StreamControlSpinLock);

                InitializeListHead(&pFilter->StreamDataQueue);
                KeInitializeSpinLock(&pFilter->StreamDataSpinLock);

                InitializeListHead(&pFilter->IpV4StreamDataQueue);
                KeInitializeSpinLock(&pFilter->IpV4StreamDataSpinLock);

                InitializeListHead(&pFilter->StreamContxList);
                KeInitializeSpinLock(&pFilter->StreamUserSpinLock);


                //
                // Maintain an array of all the StreamEx structures in the HwDevExt
                // so that we can reference IRPs from any stream
                //
                pFilter->pStream[ulStreamNumber][ulStreamInstance] = pStream;

                //
                // Save the Stream Format in the Stream Extension as well.
                //
                pStream->OpenedFormat = *pKSDataFormat;

                //
                // Set up pointers to the handlers for the stream data and control handlers
                //
                pSrb->StreamObject->ReceiveDataPacket =
                                                (PVOID) Streams[ulStreamNumber].hwStreamObject.ReceiveDataPacket;
                pSrb->StreamObject->ReceiveControlPacket =
                                                (PVOID) Streams[ulStreamNumber].hwStreamObject.ReceiveControlPacket;

                //
                // The DMA flag must be set when the device will be performing DMA directly
                // to the data buffer addresses passed in to the ReceiveDataPacket routines.
                //
                pSrb->StreamObject->Dma = Streams[ulStreamNumber].hwStreamObject.Dma;

                //
                // The PIO flag must be set when the mini driver will be accessing the data
                // buffers passed in using logical addressing
                //
                pSrb->StreamObject->Pio = Streams[ulStreamNumber].hwStreamObject.Pio;

                pSrb->StreamObject->Allocator = Streams[ulStreamNumber].hwStreamObject.Allocator;

                //
                // How many extra bytes will be passed up from the driver for each frame?
                //
                pSrb->StreamObject->StreamHeaderMediaSpecific =
                                        Streams[ulStreamNumber].hwStreamObject.StreamHeaderMediaSpecific;

                pSrb->StreamObject->StreamHeaderWorkspace =
                                        Streams[ulStreamNumber].hwStreamObject.StreamHeaderWorkspace;

                //
                // Indicate the clock support available on this stream
                //
                pSrb->StreamObject->HwClockObject =
                                        Streams[ulStreamNumber].hwStreamObject.HwClockObject;

                //
                // Increment the instance count on this stream
                //
                pStream->ulStreamInstance = ulStreamInstance;
                pFilter->ulActualInstances[ulStreamNumber]++;


                //
                // Retain a private copy of the HwDevExt and StreamObject in the stream extension
                // so we can use a timer
                //
                pStream->pFilter = pFilter;                     // For timer use
                pStream->pStreamObject = pSrb->StreamObject;        // For timer use


                pSrb->Status = STATUS_SUCCESS;

            }
            else
            {
                pSrb->Status = STATUS_INVALID_PARAMETER;
            }
        }
        else
        {
            pSrb->Status = STATUS_INVALID_PARAMETER;
        }

    }
    else
    {
        pSrb->Status = STATUS_INVALID_PARAMETER;
    }
}


//////////////////////////////////////////////////////////////////////////////
BOOLEAN
VerifyFormat(
    IN KSDATAFORMAT *pKSDataFormat,
    UINT StreamNumber,
    PKSDATARANGE pMatchedFormat
    )
//////////////////////////////////////////////////////////////////////////////
{
    BOOLEAN   bResult               = FALSE;
    ULONG     FormatCount           = 0;
    PKS_DATARANGE_VIDEO pThisFormat = NULL;

    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Verify Format\n"));

    for (FormatCount = 0; !bResult && FormatCount < Streams[StreamNumber].hwStreamInfo.NumberOfFormatArrayEntries;
         FormatCount++ )
    {


        pThisFormat = (PKS_DATARANGE_VIDEO) Streams [StreamNumber].hwStreamInfo.StreamFormatsArray [FormatCount];

        if (CompareGUIDsAndFormatSize( pKSDataFormat, &pThisFormat->DataRange, FALSE ) )
        {
            bResult = FALSE;

            if (pThisFormat->DataRange.SampleSize >= pKSDataFormat->SampleSize)
            {
                bResult = TRUE;
            }
            else
            {
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: VerifyFormat: Data range Sample Sizes don't match\n"));
            }
        }
    }

    if (bResult == TRUE && pMatchedFormat)
    {
        *pMatchedFormat = pThisFormat->DataRange;
    }

    return bResult;
}


//////////////////////////////////////////////////////////////////////////////
VOID
STREAMAPI
ReceiveDataPacket (
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    PSLIP_FILTER      pFilter         = (PSLIP_FILTER) pSrb->HwDeviceExtension;
    PSTREAM           pStream         = (PSTREAM)pSrb->StreamObject->HwStreamExtension;
    int               iStream         = (int) pSrb->StreamObject->StreamNumber;
    PKSSTREAM_HEADER  pStreamHdr      = pSrb->CommandData.DataBufferArray;
    PKSDATAFORMAT     pKSDataFormat   = (PKSDATAFORMAT) &pStream->MatchedFormat;
    ULONG             ul              = 0;
    PHW_STREAM_REQUEST_BLOCK pSrbIPv4 = NULL;

    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Receive Data packet handler called\n"));

    //
    // Default to success, disable timeouts
    //
    pSrb->TimeoutCounter = 0;
    pSrb->Status = STATUS_SUCCESS;

    //
    // Check for last buffer
    //
    if (pStreamHdr->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM)
    {
        TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Receive Data packet is LAST PACKET\n"));

        StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
        TEST_DEBUG( TEST_DBG_SRB, ("SLIP: Completed SRB %08X\n", pSrb));

        return;
    }


    if (pStreamHdr->OptionsFlags != 0)
    {
        TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: OptionsFlags: %08X\n", pStreamHdr->OptionsFlags));
    }


    //
    // determine the type of packet.
    //
    switch (pSrb->Command)
    {
        case SRB_WRITE_DATA:

            if (pStream->KSState == KSSTATE_STOP)
            {
                pSrb->Status = STATUS_SUCCESS;

                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: SRB_WRITE STOP SRB Status returned: %08X\n", pSrb->Status));

                StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb );
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: StreamRequestComplete on pSrb: %08X\n", pSrb));

                break;
            }

            //
            // Update the total number of packets written statistic
            //
            pFilter->Stats.ulTotalDataSRBWrites += 1;


            //
            // Handle data input, output requests differently.
            //
            switch (iStream)
            {
                //
                //  Frame input stream
                //
                case SLIP_STREAM:
                {
                    ULONG             ulBuffers        = pSrb->NumberOfBuffers;
                    PKSSTREAM_HEADER  pIPV4StreamHdr   = NULL;
                    PNABTSFEC_BUFFER  pNabData         = NULL;

                    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Receive Data packet handler - SRB_WRITE - SLIP_STREAM, Processing pSrb: %08X\n", pSrb));

                    //
                    // Initialize SRB Status to success
                    //
                    pSrb->Status = STATUS_SUCCESS;

                    //
                    // Process each chained buffer of data in the SRB
                    //
                    for (ul = 0; ul < ulBuffers; ul++, pStreamHdr++)
                    {
                        if (pStreamHdr)
                        {
                            //
                            // Update stats for IP Stream count
                            //
                            pFilter->Stats.ulTotalSlipBuffersReceived    += 1;
                            pFilter->Stats.ulTotalSlipBytesReceived      += pStreamHdr->DataUsed;

                            pNabData = (PNABTSFEC_BUFFER) pStreamHdr->Data;

                            if (pNabData && pStreamHdr->DataUsed > 0)
                            {
                                TEST_DEBUG (TEST_DBG_WRITE_DATA, ("SLIP: NAB_DATA[%d]....dataSize: %d  groupID: %d\n",
                                                                  ul,
                                                                  pNabData->dataSize,
                                                                  pNabData->groupID ));
                                ASSERT(pNabData->dataSize <= sizeof(pNabData->data));

                                if ((pSrb->Status = ntNabtsRecv (pFilter, pNabData)) != STATUS_SUCCESS)
                                {
                                    //
                                    // Something went wrong processing the data (such as running
                                    // out of output buffers).   We'll just complete the input SRB
                                    // and lose the data.  We'll return a successful status to make sure the
                                    // graph can continue to run.  Basically this error amounts to the SRB
                                    // being tossed out and never processed (ie. a Data Loss).
                                    //
                                    pSrb->Status = STATUS_SUCCESS;

                                    pFilter->bDiscontinuity = TRUE;

                                    break;
                                }
                            }
                            else
                            {
                                pFilter->Stats.ulTotalSlipZeroLengthBuffers += 1;
                            }
                        }
                    }


                    StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
                    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: StreamRequestComplete on pSrb: %08X\n", pSrb));
                }
                break;

                //
                // Other "unknown" streams are not valid and will be rejected.
                //
                case SLIP_NET_CONTROL:
                    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Receive Data packet handler called - SRB_WRITE - STREAM_NET_CONTROL\n"));
                    pSrb->Status = STATUS_NOT_IMPLEMENTED;

                    //
                    // Update stats for Net packet count
                    //
                    pFilter->Stats.ulTotalBadPinSRBWrites += 1;

                    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: SLIP_NET_CONTROL SRB Status returned: %08X\n", pSrb->Status));

                    StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
                    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: StreamRequestComplete on pSrb: %08X\n", pSrb));
                    break;

                default:
                    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Receive Data packet handler called - SRB_WRITE - Default\n"));
                    pSrb->Status = STATUS_NOT_IMPLEMENTED;

                    //
                    // Update stats for Unkown packet count
                    //
                    pFilter->Stats.ulTotalBadPinSRBWrites += 1;

                    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: DEFAULT SRB Status returned: %08X\n", pSrb->Status));

                    StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
                    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: StreamRequestComplete on pSrb: %08X\n", pSrb));

                    break;
            }
            break;


        case SRB_READ_DATA:

            if (pStream->KSState == KSSTATE_STOP)
            {
                pSrb->Status = STATUS_SUCCESS;
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: SRB_READ STOP SRB Status returned: %08X\n", pSrb->Status));

                StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb );
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: StreamRequestComplete on pSrb: %08X\n", pSrb));

                break;
            }

            //
            // Update stats
            //
            pFilter->Stats.ulTotalDataSRBReads += 1;

            switch (iStream)
            {
                case SLIP_NET_CONTROL:
                    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Receive Data packet handler called - SRB_READ - STREAM_NET_CONTROL, Processing pSrb: %08X\n", pSrb));
                    pSrb->Status = STATUS_SUCCESS;
                    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: SLIP_NET_CONTROL SRB Status returned: %08X\n", pSrb->Status));

                    //
                    // Update stats for Unkown packet count
                    //
                    pFilter->Stats.ulTotalBadPinSRBReads += 1;
                    
                    StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
                    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: StreamRequestComplete on pSrb: %08X\n", pSrb));
                    break;

                case SLIP_IPV4:
                {
                    ULONG             ulBuffers       = pSrb->NumberOfBuffers;

                    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Receive Data packet handler called - SRB_READ - SLIP_IPV4, Processing pSrb: %08X\n", pSrb));

                    if (pSrb->CommandData.DataBufferArray->FrameExtent < pKSDataFormat->SampleSize)
                    {
                        pSrb->Status = STATUS_BUFFER_TOO_SMALL;
                        TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: SLIP_IPV4 SRB Buffer too small.... Status returned: %08X\n", pSrb->Status));
                        StreamClassStreamNotification(StreamRequestComplete, pSrb->StreamObject, pSrb);
                        TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: StreamRequestComplete on pSrb: %08X\n", pSrb));
                    }
                    else
                    {

                        //
                        // Take the SRB we get and  queue it up.  These Queued SRB's will be filled with data on a WRITE_DATA
                        // request, at which point they will be completed.
                        //
                        QueueAdd (pSrb, &pFilter->IpV4StreamDataSpinLock, &pFilter->IpV4StreamDataQueue);
                        TEST_DEBUG( TEST_DBG_SRB, ("SLIP Queuing IPv4 SRB %08X\n", pSrb));


                        //
                        // Since the stream state may have changed while we were adding the SRB to the queue
                        // we'll check it again, and cancel it if necessary
                        //
                        if (pStream->KSState == KSSTATE_STOP)
                        {
                            TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: SRB_READ STOP SRB Status returned: %08X\n", pSrb->Status));

                            if (QueueRemoveSpecific (pSrb, &pFilter->IpV4StreamDataSpinLock, &pFilter->IpV4StreamDataQueue))
                            {
                                pSrb->Status = STATUS_CANCELLED;
                                StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb );
                                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: StreamRequestComplete on pSrb: %08X\n", pSrb));
                                return;
                            }
                            break;
                        }

                    }
                }
                break;


                default:
                    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Receive Data packet handler called - SRB_READ - Default\n"));
                    pSrb->Status = STATUS_NOT_IMPLEMENTED;
                    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: DEFAULT SRB Status returned: %08X\n", pSrb->Status));

                    //
                    // Update stats for Unkown packet count
                    //
                    pFilter->Stats.ulTotalBadPinSRBReads += 1;
                    
                    StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
                    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: StreamRequestComplete on pSrb: %08X\n", pSrb));
                    break;

            }
            break;

        default:

            //
            // invalid / unsupported command. Fail it as such
            //
            TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Receive Data packet handler called - Unsupported Command\n"));
            pSrb->Status = STATUS_NOT_IMPLEMENTED;
            TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: DEFAULT SRB Status returned: %08X\n", pSrb->Status));
            StreamClassStreamNotification( StreamRequestComplete, pSrb->StreamObject, pSrb );
            TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: StreamRequestComplete on pSrb: %08X\n", pSrb));
            ASSERT (FALSE);
            break;

    }


    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Receive Data packet handler called...status: %08X\n", pSrb->Status));

    return;
}



//////////////////////////////////////////////////////////////////////////////
VOID
SlipGetProperty (
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;

    pSrb->Status = STATUS_SUCCESS;

    if (IsEqualGUID (&KSPROPSETID_Connection, &pSPD->Property->Set))
    {
        SlipGetConnectionProperty (pSrb);
    }
    else
    {
        pSrb->Status = STATUS_NOT_IMPLEMENTED;
    }

    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: SlipGetProperty Status: %08X\n", pSrb->Status));

    return;
}


//////////////////////////////////////////////////////////////////////////////
VOID
IndicateMasterClock(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    PSTREAM pStream = (PSTREAM) pSrb->StreamObject->HwStreamExtension;

    pStream->hClock = pSrb->CommandData.MasterClockHandle;
}

//////////////////////////////////////////////////////////////////////////////
VOID
STREAMAPI
ReceiveCtrlPacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    PSLIP_FILTER pFilter = (PSLIP_FILTER) pSrb->HwDeviceExtension;
    PSTREAM pStream = (PSTREAM) pSrb->StreamObject->HwStreamExtension;

    TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Receive Control packet handler called\n"));

    pSrb->Status = STATUS_SUCCESS;

    QueueAdd (pSrb, &pFilter->StreamControlSpinLock, &pFilter->StreamControlQueue);
    TEST_DEBUG( TEST_DBG_SRB, ("SLIP Queuing Control Packet SRB %08X\n", pSrb));

    while (QueueRemove (&pSrb, &pFilter->StreamControlSpinLock, &pFilter->StreamControlQueue))
    {
        //
        // determine the type of packet.
        //
        switch (pSrb->Command)
        {
            case SRB_PROPOSE_DATA_FORMAT:
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Receive Control packet handler - Propose data format\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            case SRB_SET_STREAM_STATE:
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Receive Control packet handler - Set Stream State\n"));
                pSrb->Status = STATUS_SUCCESS;
                SlipSetState (pSrb);
                break;

            case SRB_GET_STREAM_STATE:
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Receive Control packet handler - Get Stream State\n"));
                pSrb->Status = STATUS_SUCCESS;
                pSrb->CommandData.StreamState = pStream->KSState;
                pSrb->ActualBytesTransferred = sizeof (KSSTATE);
                break;

            case SRB_GET_STREAM_PROPERTY:
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Receive Control packet handler - Get Stream Property\n"));
                SlipGetProperty(pSrb);
                break;

            case SRB_SET_STREAM_PROPERTY:
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Receive Control packet handler - Set Stream Property\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            case SRB_INDICATE_MASTER_CLOCK:
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Receive Control packet handler - Indicate Master Clock\n"));
                pSrb->Status = STATUS_SUCCESS;
                IndicateMasterClock (pSrb);
                break;

            case SRB_SET_STREAM_RATE:
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Receive Control packet handler - Set Stream Rate\n"));
                pSrb->Status = STATUS_SUCCESS;
                break;

            case SRB_PROPOSE_STREAM_RATE:
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Receive Control packet handler - Propose Stream Rate\n"));
                pSrb->Status = STATUS_SUCCESS;
                break;

            default:
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Receive Control packet handler - Default case\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

        }

        TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: SRB Status returned: %08X\n", pSrb->Status));

        StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
        TEST_DEBUG( TEST_DBG_SRB, ("SLIP 29Completed SRB %08X\n", pSrb));

    }

}



//////////////////////////////////////////////////////////////////////////////
VOID
SlipSetState(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    PSLIP_FILTER pFilter                 = ((PSLIP_FILTER) pSrb->HwDeviceExtension);
    PSTREAM pStream                      = (PSTREAM) pSrb->StreamObject->HwStreamExtension;
    PHW_STREAM_REQUEST_BLOCK pCurrentSrb = NULL;

    //
    // For each stream, the following states are used:
    //
    // Stop:    Absolute minimum resources are used.  No outstanding IRPs.
    // Acquire: KS only state that has no DirectShow correpondence
    //          Acquire needed resources.
    // Pause:   Getting ready to run.  Allocate needed resources so that
    //          the eventual transition to Run is as fast as possible.
    //          Read SRBs will be queued at either the Stream class
    //          or in your driver (depending on when you send "ReadyForNext")
    // Run:     Streaming.
    //
    // Moving to Stop to Run always transitions through Pause.
    //
    // But since a client app could crash unexpectedly, drivers should handle
    // the situation of having outstanding IRPs cancelled and open streams
    // being closed WHILE THEY ARE STREAMING!
    //
    // Note that it is quite possible to transition repeatedly between states:
    // Stop -> Pause -> Stop -> Pause -> Run -> Pause -> Run -> Pause -> Stop
    //
    switch (pSrb->CommandData.StreamState)
    {
        case KSSTATE_STOP:

            TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Set Stream State KSSTATE_STOP\n"));

            //
            // If transitioning to STOP state, then complete any outstanding IRPs
            //
            while (QueueRemove(&pCurrentSrb, &pFilter->IpV4StreamDataSpinLock, &pFilter->IpV4StreamDataQueue))
            {
                pCurrentSrb->Status = STATUS_CANCELLED;
                pCurrentSrb->CommandData.DataBufferArray->DataUsed = 0;

                StreamClassStreamNotification(StreamRequestComplete, pCurrentSrb->StreamObject, pCurrentSrb);
                TEST_DEBUG( TEST_DBG_SRB, ("SLIP 30Completed SRB %08X\n", pCurrentSrb));
            }

            pStream->KSState = pSrb->CommandData.StreamState;
            pSrb->Status = STATUS_SUCCESS;
            break;


        case KSSTATE_ACQUIRE:
            TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Set Stream State KSSTATE_ACQUIRE\n"));
            pStream->KSState = pSrb->CommandData.StreamState;
            pSrb->Status = STATUS_SUCCESS;
            break;

        case KSSTATE_PAUSE:
            TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Set Stream State KSSTATE_PAUSE\n"));
            pStream->KSState = pSrb->CommandData.StreamState;
            pSrb->Status = STATUS_SUCCESS;
            break;

        case KSSTATE_RUN:
            TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: Set Stream State KSSTATE_RUN\n"));
            pStream->KSState = pSrb->CommandData.StreamState;
            pSrb->Status = STATUS_SUCCESS;
            break;

    } // end switch (pSrb->CommandData.StreamState)

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\slip\mpegcrc.h ===
// Copyright (C) 1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:   mpegcrc.h
//
//  PURPOSE:  header file for a very fast CRC, all in MSB format.
//
//  FUNCTIONS:
//  
//  COMMENTS:
//	    This was written by Stephen Dennis, and it's very very quick.
//
//

#ifndef __bridge_mpegcrc_h
#define __bridge_mpegcrc_h

#ifndef	EXTERN_C
#ifdef	__cplusplus
#define	EXTERN_C extern "C"
#else
#define	EXTERN_C
#endif
#endif

#define	MPEG_CRC_START_VALUE	0xFFFFFFFFUL

EXTERN_C	void	MpegCrcUpdate	(ULONG * crc, UINT length, UCHAR * data);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\slip\slip.h ===
/////////////////////////////////////////////////////////////////////////////
//
//
// Copyright (c) 1996, 1997  Microsoft Corporation
//
//
// Module Name:
//      slip.h
//
// Abstract:
//
//
// Author:
//
//      P Porzuczek
//
// Environment:
//
// Revision History:
//
//
//////////////////////////////////////////////////////////////////////////////

#ifndef _SLIP_H_
#define _SLIP_H_

#define ENTRIES(a)  (sizeof(a)/sizeof(*(a)))

///////////////////////////////////////////////////////////////////////////////
//
//
#define SLIPNAME            "SLIP"
#define SLIPNAMEUNICODE    L"SLIP"

///////////////////////////////////////////////////////////////////////////////
//
// This defines the name of the WMI device that manages service IOCTLS
//
#define CodecDeviceName   (L"\\\\.\\" SLIPNAMEUNICODE)
#define CodecSymbolicName (L"\\DosDevices\\" SLIPNAMEUNICODE)


///////////////////////////////////////////////////////////////////////////////
//
//
typedef enum
{
    SLIP_STREAM = 0,
    SLIP_IPV4,
    SLIP_NET_CONTROL

} SLIP_STREAMS;

///////////////////////////////////////////////////////////////////////////////
//
// The MAX_STREAM_COUNT value must be equal to DRIVER_STREAM_COUNT
// This particular value must be defined here to avoid circular references
//
#define MAX_STREAM_COUNT    DRIVER_STREAM_COUNT

///////////////////////////////////////////////////////////////////////////////
//
// We manage multiple instances of each pin up to this limit
//
#define MAX_PIN_INSTANCES   8
#define BIT(n)              (1L<<(n))
#define BITSIZE(v)          (sizeof(v)*8)
#define SETBIT(array,n)     (array[n/BITSIZE(*array)] |= BIT(n%BITSIZE(*array)))
#define CLEARBIT(array,n)   (array[n/BITSIZE(*array)] &= ~BIT(n%BITSIZE(*array)))


#define MAX_FRAMES 64
#define FRAME_LOW_WATER 5

/////////////////////////////////////////////////////////////////////////////
//
//
//
typedef NTSTATUS (*QUERY_INTERFACE) (PVOID pvContext);
typedef ULONG    (*ADD_REF) (PVOID pvContext);
typedef ULONG    (*RELEASE) (PVOID pvContext);



/////////////////////////////////////////////////////////////////////////////
//
//
//
typedef struct _STATS_
{
    ULONG ulTotalDataSRBWrites;
    ULONG ulTotalBadPinSRBWrites;
    ULONG ulTotalDataSRBReads;
    ULONG ulTotalBadPinSRBReads;

    ULONG ulTotalSlipBuffersReceived;
    ULONG ulTotalSlipBuffersDropped;
    ULONG ulTotalSlipZeroLengthBuffers;
    ULONG ulTotalSlipBytesReceived;
    ULONG ulTotalSlipBytesDropped;
    ULONG ulTotalSlipFramesReceived;
    ULONG ulTotalSlipOldProtoFramesStarted;
    ULONG ulTotalSlipNewProtoFramesStarted;
    ULONG ulTotalSlipFramesIncomplete;
    ULONG ulTotalSlipFramesBadCRC;
    ULONG ulTotalSlipFramesTooBig;
    ULONG ulTotalSlipFramesTooSmall;

    ULONG ulTotalIPPacketsFound;
    ULONG ulTotalIPBytesFound;
    ULONG ulTotalIPPacketsSent;
    ULONG ulTotalIPBytesSent;
    ULONG ulTotalIPPacketsTooBig;
    ULONG ulTotalIPPacketsTooSmall;
    ULONG ulTotalIPPacketsDropped;
    ULONG ulTotalIPBytesDropped;

    ULONG ulTotalNabStreamsCreated;
    ULONG ulTotalNabStreamsTimedOut;

} STATS, *PSTATS;


/////////////////////////////////////////////////////////////////////////////
//
//
//
typedef struct
{
    QUERY_INTERFACE          QueryInterface;
    ADD_REF                  AddRef;
    RELEASE                  Release;

} FILTER_VTABLE, *PFILTER_VTABLE;


/////////////////////////////////////////////////////////////////////////////
//
//
// definition of the full HW device extension structure This is the structure
// that will be allocated in HW_INITIALIZATION by the stream class driver
// Any information that is used in processing a device request (as opposed to
// a STREAM based request) should be in this structure.  A pointer to this
// structure will be passed in all requests to the minidriver. (See
// HW_STREAM_REQUEST_BLOCK in STRMINI.H)
//
typedef struct _SLIP_FILTER_
{

    LIST_ENTRY                          AdapterSRBQueue;
    KSPIN_LOCK                          AdapterSRBSpinLock;
    BOOLEAN                             bAdapterQueueInitialized;

    //
    //
    //
    BOOLEAN                             bInitializationComplete;

    //
    // Statistics
    //
    STATS                               Stats;

    //
    //
    //
    PDEVICE_OBJECT                      DeviceObject;

    //
    //
    //
    PDRIVER_OBJECT                      DriverObject;

    //
    //
    //
    PFILTER_VTABLE                      lpVTable;

    //
    //
    //
    ULONG                               ulRefCount;

    //
    //
    //
    PVOID                               pStream [2][1];

    //
    //
    //
    ULONG                               ulActualInstances [2];   // Count of instances per stream

    //
    //
    //
    KSPIN_LOCK                          IpV4StreamDataSpinLock; // Data queue spin lock
    LIST_ENTRY                          IpV4StreamDataQueue;    // Stream data queue

    KSPIN_LOCK                          StreamControlSpinLock;  // Command queue spin lock
    LIST_ENTRY                          StreamControlQueue;     // Stream command queue

    KSPIN_LOCK                          StreamDataSpinLock;     // Data queue spin lock
    LIST_ENTRY                          StreamDataQueue;        // Stream data queue

    //
    //
    //
    KSPIN_LOCK                          StreamUserSpinLock;
    LIST_ENTRY                          StreamContxList;
    LARGE_INTEGER                       liLastTimeChecked;
    LARGE_INTEGER                       liLastTimeStatsDumped;

    BOOLEAN                             bDiscontinuity;

} SLIP_FILTER, *PSLIP_FILTER;

/////////////////////////////////////////////////////////////////////////////
//
// this structure is our per stream extension structure.  This stores
// information that is relevant on a per stream basis.  Whenever a new stream
// is opened, the stream class driver will allocate whatever extension size
// is specified in the HwInitData.PerStreamExtensionSize.
//

typedef struct _STREAM_
{
    PSLIP_FILTER                        pFilter;
    PHW_STREAM_OBJECT                   pStreamObject;          // For timer use
    KSSTATE                             KSState;                // Run, Stop, Pause
    HANDLE                              hMasterClock;
    HANDLE                              hClock;
    ULONG                               ulStreamInstance;       // 0..NumberOfPossibleInstances-1
    KSDATAFORMAT                        OpenedFormat;           // Based on the actual open request.

    KSDATARANGE                         MatchedFormat;

    ULONG                               Type;                   // type of this structure
    ULONG                               Size;                   // size of this structure

} STREAM, *PSTREAM;

///////////////////////////////////////////////////////////////////////////////
//
// This structure is our per SRB extension, and carries the forward and backward
// links for the pending SRB queue.
//
typedef struct _SRB_EXTENSION
{
    LIST_ENTRY                      ListEntry;
    PHW_STREAM_REQUEST_BLOCK        pSrb;

} SRB_EXTENSION, *PSRB_EXTENSION;


//////////////////////////////////////////////////////////////////////////////
//
// the following section defines prototypes for the minidriver initialization
// routines
//

BOOLEAN
CodecInitialize (
    IN OUT PHW_STREAM_REQUEST_BLOCK pSrb
    );


BOOLEAN
CodecUnInitialize(
    PHW_STREAM_REQUEST_BLOCK pSrb
    );


BOOLEAN
CodecQueryUnload (
    PHW_STREAM_REQUEST_BLOCK pSrb
    );      // Not implemented currently

BOOLEAN
HwInterrupt (
    IN PSLIP_FILTER pFilter
    );

VOID
CodecStreamInfo(
    PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID
CodecOpenStream(
    PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID
CodecCloseStream(
    PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID STREAMAPI
CodecReceivePacket(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    );

VOID STREAMAPI
CodecCancelPacket(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    );

VOID STREAMAPI
CodecTimeoutPacket(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    );

VOID STREAMAPI
CodecGetProperty(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    );

VOID STREAMAPI
CodecSetProperty(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    );

BOOL
CodecVerifyFormat(
    IN KSDATAFORMAT *pKSDataFormat,
    UINT StreamNumber,
    PKSDATARANGE pMatchedFormat
    );

BOOL
CodecFormatFromRange(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    );

void
CompleteStreamSRB (
    IN PHW_STREAM_REQUEST_BLOCK pSrb,
    STREAM_MINIDRIVER_STREAM_NOTIFICATION_TYPE NotificationType1,
    BOOL fUseNotification2,
    STREAM_MINIDRIVER_STREAM_NOTIFICATION_TYPE NotificationType2
    );

void
CompleteDeviceSRB (
    IN PHW_STREAM_REQUEST_BLOCK pSrb,
    IN STREAM_MINIDRIVER_DEVICE_NOTIFICATION_TYPE NotificationType,
    BOOL fReadyForNext
    );

/////////////////////////////////////////////////////////////////////////////////////
//
// SRB Queue Management functions
//
BOOL STREAMAPI
QueueAddIfNotEmpty(
    IN PHW_STREAM_REQUEST_BLOCK,
    IN PKSPIN_LOCK,
    IN PLIST_ENTRY
    );

BOOL STREAMAPI
QueueAdd(
    IN PHW_STREAM_REQUEST_BLOCK,
    IN PKSPIN_LOCK,
    IN PLIST_ENTRY
    );

BOOL STREAMAPI
QueueRemove(
    IN OUT PHW_STREAM_REQUEST_BLOCK *,
    IN PKSPIN_LOCK,
    IN PLIST_ENTRY
    );

BOOL STREAMAPI
QueuePush (
    IN PHW_STREAM_REQUEST_BLOCK pSrb,
    IN PKSPIN_LOCK pQueueSpinLock,
    IN PLIST_ENTRY pQueue
    );

BOOL STREAMAPI
QueueRemoveSpecific(
    IN PHW_STREAM_REQUEST_BLOCK,
    IN PKSPIN_LOCK,
    IN PLIST_ENTRY
    );

BOOL STREAMAPI
QueueEmpty(
    IN PKSPIN_LOCK,
    IN PLIST_ENTRY
    );

VOID
STREAMAPI
CodecReceivePacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    );

BOOLEAN
CodecInitialize (
    IN OUT PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID
STREAMAPI
CodecCancelPacket(
    PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID
STREAMAPI
CodecTimeoutPacket(
    PHW_STREAM_REQUEST_BLOCK pSrb
    );


BOOL
CompareGUIDsAndFormatSize(
    IN PKSDATARANGE pDataRange1,
    IN PKSDATARANGE pDataRange2,
    BOOLEAN bCheckSize
    );

BOOL
CompareStreamFormat (
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    );

BOOLEAN
VerifyFormat(
    IN KSDATAFORMAT *pKSDataFormat,
    UINT StreamNumber,
    PKSDATARANGE pMatchedFormat
    );

VOID
OpenStream (
    PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID
CloseStream (
    PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID
STREAMAPI
ReceiveDataPacket (
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID
STREAMAPI
ReceiveCtrlPacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID
IpSinkSetState(
    PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID
SlipSetState(
    PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID
SlipGetState(
    PHW_STREAM_REQUEST_BLOCK pSrb
    );


#endif  // _SLIP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\slip\slipstream.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#ifndef __SLIP_STREAM_H__
#define __SLIP_STREAM_H__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus


// ------------------------------------------------------------------------
// Property set for all video capture streams
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_TABLE(SlipConnectionProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_CONNECTION_ALLOCATORFRAMING,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSALLOCATOR_FRAMING),            // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    )
};

// ------------------------------------------------------------------------
// Array of all of the property sets supported by video streams
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_SET_TABLE(SlipStreamProperties)
{
    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_Connection,                        // Set
        SIZEOF_ARRAY(SlipConnectionProperties),       // PropertiesCount
        SlipConnectionProperties,                     // PropertyItems
        0,                                              // FastIoCount
        NULL                                            // FastIoTable
    ),
};


#define NUMBER_SLIP_STREAM_PROPERTIES (SIZEOF_ARRAY(SlipStreamProperties))


//---------------------------------------------------------------------------
// All of the video and vbi data formats we might use
//---------------------------------------------------------------------------

KSDATARANGE StreamFormatSlip =
{
    //
    // KSDATARANGE
    //
    sizeof (KSDATAFORMAT),
    0,
    1548,               // sizeof a SLIP Packet
    0,                  // Reserved
    { STATIC_KSDATAFORMAT_TYPE_BDA_IP },
    { STATIC_KSDATAFORMAT_SUBTYPE_BDA_IP },
    { STATIC_KSDATAFORMAT_SPECIFIER_BDA_IP }
};

KSDATARANGE StreamFormatIPv4 =
{
    //
    // KSDATARANGE
    //
    sizeof (KSDATAFORMAT),
    0,
    1548,               // sizeof a IPv4 Packet
    0,                  // Reserved
    { STATIC_KSDATAFORMAT_TYPE_BDA_IP },
    { STATIC_KSDATAFORMAT_SUBTYPE_BDA_IP },
    { STATIC_KSDATAFORMAT_SPECIFIER_BDA_IP }
};


KSDATARANGE StreamFormatNABTS =
{
    sizeof (KSDATARANGE),
    0,
    sizeof (NABTS_BUFFER) + 8,      //$$BUG  NOTE Add 8
    0,                  // Reserved
    { STATIC_KSDATAFORMAT_TYPE_NABTS },
    { STATIC_KSDATAFORMAT_SUBTYPE_NABTS },
    { STATIC_KSDATAFORMAT_SPECIFIER_NONE }
};

KSDATARANGE StreamFormatNABTSFEC =
{
    sizeof (KSDATARANGE),
    0,
    sizeof (NABTSFEC_BUFFER),
    0,                  // Reserved
    { STATIC_KSDATAFORMAT_TYPE_NABTS },
    { STATIC_KSDATAFORMAT_SUBTYPE_NABTS_FEC },
    { STATIC_KSDATAFORMAT_SPECIFIER_NONE }
};


//---------------------------------------------------------------------------
//  STREAM_Input Formats
//---------------------------------------------------------------------------

static PKSDATAFORMAT Stream0Formats[] =
{
//    (PKSDATAFORMAT) &StreamFormatNABTS,
    (PKSDATAFORMAT) &StreamFormatNABTSFEC


    // Add more formats here for to mirror output formats for "passthrough" mode
    // The idea is that upstream capture drivers may have done some decoding already
    // or downstream drivers may wish to have the raw data without any decoding at all.
    // In that case all we need to do is copy the data(if there is a pending SRB) OR
    // forward the SRB to the downstream client.
};

#define NUM_STREAM_0_FORMATS (SIZEOF_ARRAY(Stream0Formats))


//---------------------------------------------------------------------------
//  STREAM_Output Formats
//---------------------------------------------------------------------------

static PKSDATAFORMAT Stream1Formats[] =
{
    (PKSDATAFORMAT) &StreamFormatIPv4,

    //
    // Add more formats here for whatever output formats are supported.
    //
};
#define NUM_STREAM_1_FORMATS (SIZEOF_ARRAY (Stream1Formats))

//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Create an array that holds the list of all of the streams supported
//---------------------------------------------------------------------------

typedef struct _ALL_STREAM_INFO
{
    HW_STREAM_INFORMATION   hwStreamInfo;
    HW_STREAM_OBJECT        hwStreamObject;

} ALL_STREAM_INFO, *PALL_STREAM_INFO;

static ALL_STREAM_INFO Streams [] =
{
    //
    // NABTS input stream
    //

    {
        // HW_STREAM_INFORMATION -------------------------------------------
        {
            1,                                        // NumberOfPossibleInstances
            KSPIN_DATAFLOW_IN,                        // DataFlow
            TRUE,                                     // DataAccessible
            NUM_STREAM_0_FORMATS,                     // NumberOfFormatArrayEntries
            Stream0Formats,                           // StreamFormatsArray
            0,                                        // ClassReserved[0]
            0,                                        // ClassReserved[1]
            0,                                        // ClassReserved[2]
            0,                                        // ClassReserved[3]
            NUMBER_SLIP_STREAM_PROPERTIES,            // Number of stream properties
            (PKSPROPERTY_SET) SlipStreamProperties,   // Stream Property Array
            0,                                        // NumStreamEventArrayEntries
            0,                                        // StreamEventsArray
            NULL,                                     // Category
            (GUID *)&PINNAME_VIDEO_NABTS,             // Name
            0,                                        // MediumsCount
            NULL,                                     // Mediums
        },

        // HW_STREAM_OBJECT ------------------------------------------------
        {
            sizeof (HW_STREAM_OBJECT),              // SizeOfThisPacket
            0,                                      // StreamNumber
            (PVOID)NULL,                            // HwStreamExtension
            ReceiveDataPacket,
            ReceiveCtrlPacket,
            {                                       // HW_CLOCK_OBJECT
                NULL,                               // .HWClockFunction
                0,                                  // .ClockSupportFlags
            },
            FALSE,                                  // Dma
            TRUE,                                   // Pio
            (PVOID)NULL,                            // HwDeviceExtension
            0,                                      // StreamHeaderMediaSpecific
            0,                                      // StreamHeaderWorkspace
            TRUE,                                   // Allocator
            NULL,                                   // HwEventRoutine
        },
    },

    //
    // IPv4 Control Interface Pin
    //
    {
        // HW_STREAM_INFORMATION -------------------------------------------
        {
            1,                                      // NumberOfPossibleInstances
            KSPIN_DATAFLOW_OUT,                     // DataFlow
            TRUE,                                   // DataAccessible
            NUM_STREAM_1_FORMATS,                   // NumberOfFormatArrayEntries
            Stream1Formats,                         // StreamFormatsArray
            0,                                      // ClassReserved[0]
            0,                                      // ClassReserved[1]
            0,                                      // ClassReserved[2]
            0,                                      // ClassReserved[3]
            NUMBER_SLIP_STREAM_PROPERTIES,          // Number of stream properties
            (PKSPROPERTY_SET) SlipStreamProperties, // Stream Property Array
            0,                                      // NumStreamEventArrayEntries
            0,                                      // StreamEventsArray
            NULL,                                   // Category
            (GUID *)&PINNAME_IPSINK_INPUT,          // Name
            0,                                      // MediumsCount
            NULL,                                   // Mediums
        },

        // HW_STREAM_OBJECT ------------------------------------------------
        {
            sizeof (HW_STREAM_OBJECT),              // SizeOfThisPacket
            0,                                      // StreamNumber
            (PVOID)NULL,                            // HwStreamExtension
            ReceiveDataPacket,                      // HwReceiveDataPacket Handler
            ReceiveCtrlPacket,                      // HwReceiveControlPacket Handler
            {                                       // HW_CLOCK_OBJECT
                NULL,                                // .HWClockFunction
                0,                                   // .ClockSupportFlags
            },
            FALSE,                                  // Dma
            TRUE,                                   // Pio
            (PVOID)NULL,                            // HwDeviceExtension
            0,                                      // StreamHeaderMediaSpecific
            0,                                      // StreamHeaderWorkspace
            TRUE,                                   // Allocator
            NULL,                                   // HwEventRoutine
        },
    }

};

#define DRIVER_STREAM_COUNT (SIZEOF_ARRAY (Streams))


//---------------------------------------------------------------------------
// Topology
//---------------------------------------------------------------------------

// Categories define what the device does.

static GUID Categories[] =
{
    STATIC_KSCATEGORY_BDA_RECEIVER_COMPONENT
};

#define NUMBER_OF_CATEGORIES  SIZEOF_ARRAY (Categories)

static KSTOPOLOGY Topology = {
    NUMBER_OF_CATEGORIES,
    (GUID*) &Categories,
    0,
    (GUID*) NULL,
    0,
    NULL
};


//---------------------------------------------------------------------------
// The Main stream header
//---------------------------------------------------------------------------

static HW_STREAM_HEADER StreamHeader =
{
    DRIVER_STREAM_COUNT,                // NumberOfStreams
    sizeof (HW_STREAM_INFORMATION),     // Future proofing
    0,                                  // NumDevPropArrayEntries set at init time
    NULL,                               // DevicePropertiesArray  set at init time
    0,                                  // NumDevEventArrayEntries;
    NULL,                               // DeviceEventsArray;
    &Topology                           // Pointer to Device Topology
};

#ifdef    __cplusplus
}
#endif // __cplusplus

#endif //  __SLIP_STREAM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\slip\slipmedia.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#ifndef __MY_MEDIA_H__
#define __MY_MEDIA_H__


#ifdef DEFINE_GUIDEX
#undef DEFINE_GUIDEX
#include <ksguid.h>
#endif

/////////////////////////////////////////////////////////////
//
// OUTPUT PINNAME GUID
//
#define STATIC_PINNAME_IPSINK_INPUT \
    0x3fdffa70L, 0xac9a, 0x11d2, 0x8f, 0x17, 0x00, 0xc0, 0x4f, 0x79, 0x71, 0xe2
DEFINE_GUIDSTRUCT("3fdffa70-ac9a-11d2-8f17-00c04f7971e2", PINNAME_IPSINK_INPUT);
#define PINNAME_IPSINK_INPUT   DEFINE_GUIDNAMED(PINNAME_IPSINK_INPUT)


/////////////////////////////////////////////////////////////
//
// NET CONTROL PINNAME GUID
//
#define STATIC_PINNAME_NET_CONTROL \
    0x390B713BL, 0xEB7D, 0x11d2, 0x8F, 0x37, 0x00, 0xC0, 0x4F, 0x79, 0x71, 0xE2
DEFINE_GUIDSTRUCT("390B713B-EB7D-11d2-8F37-00C04F7971E2", PINNAME_NET_CONTROL);
#define PINNAME_NET_CONTROL   DEFINE_GUIDNAMED(PINNAME_NET_CONTROL)

/////////////////////////////////////////////////////////////
//
// Slip Data Format structure
//
typedef struct tagKS_DATAFORMAT_SLIP
{
   KSDATAFORMAT                 DataFormat;

} KS_DATAFORMAT_SLIP, *PKS_DATAFORMAT_SLIP;




#endif // __MY_MEDIA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\slip\recv.c ===
///////////////////////////////////////////////////////////////////////////
//
//
// Copyright (c) 1996, 1997  Microsoft Corporation
//
//
// Module Name:
//      recv.c
//
// Abstract:
//
//
// Author:
//
//      P Porzuczek
//
// Environment:
//
// Revision History:
//
//
//////////////////////////////////////////////////////////////////////////////

#include <wdm.h>
#include <strmini.h>
#include <ksmedia.h>

#include "slip.h"
#include "main.h"
#include "recv.h"



//////////////////////////////////////////////////////////////////////////////
//
// Init 802.3 header template
//
Header802_3 h802_3Template =
{
    {0x01, 0x00, 0x5e, 0, 0, 0}
  , {0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
  , {0x08, 0x00}
};


#if DBG
UCHAR MyBuffer [1600] = {0};

UCHAR TestBuffer [] = { 0xC0, 0xC0, 0x00, 0xC7, 0xD3, 0x97, 0x00, 0x00, 0x5E, 0x56,
                        0x23, 0x11, 0x07, 0x00, 0x00, 0x00, 0x2C, 0x01, 0x00, 0x00, 0xAA, 0x58, 0x00, 0x00, 0x3D, 0xC5,
                        0x00, 0x00, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33,
                        0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33,
                        0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33,
                        0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33,
                        0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33,
                        0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33,
                        0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33,
                        0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33,
                        0x22, 0x11, 0x44, 0x33, 0xDC, 0xA2, 0x3B, 0x82, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33,
                        0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0xE9, 0xCE,
                        0xFA, 0x7D, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33,
                        0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33,
                        0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33,
                        0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33,
                        0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33,
                        0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33,
                        0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33,
                        0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33,
                        0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33,
                        0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33,
                        0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33,
                        0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33,
                        0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33,
                        0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33,
                        0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33,
                        0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33,
                        0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33,
                        0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33,
                        0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33,
                        0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33,
                        0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x44, 0x33, 0x22, 0x11, 0x53, 0x60, 0xBB, 0x03, 0xC0   };


//////////////////////////////////////////////////////////////////////////////
VOID
DumpData (
    PUCHAR pData,
    ULONG  ulSize
    )
//////////////////////////////////////////////////////////////////////////////
{
  ULONG  ulCount;
  ULONG  ul;
  UCHAR  uc;

  DbgPrint("Dump - Data: %x, Size: %x\n", pData, ulSize);
  while (ulSize)
  {
      ulCount = 16 < ulSize ? 16 : ulSize;

      for (ul = 0; ul < ulCount; ul++)
      {
          uc = *pData;

          DbgPrint("%02X ", uc);
          ulSize -= 1;
          pData  += 1;
      }

      DbgPrint("\n");
  }
  if(TestDebugFlag & TEST_DBG_ASSERT)
  {
      DEBUG_BREAKPOINT();
  }
}


///////////////////////////////////////////////////////////////////////////////////////
VOID
DumpNabStream (
    PNAB_STREAM pNabStream
    )
///////////////////////////////////////////////////////////////////////////////////////
{

    TEST_DEBUG (TEST_DBG_NAB, ("pszBuffer......: %08X\n", pNabStream->pszBuffer));
    TEST_DEBUG (TEST_DBG_NAB, ("ulcbSize.......: %08X\n", pNabStream->ulcbSize));
    TEST_DEBUG (TEST_DBG_NAB, ("ulOffset.......: %08X\n", pNabStream->ulOffset));
    TEST_DEBUG (TEST_DBG_NAB, ("ulMpegCrc......: %08X\n", pNabStream->ulMpegCrc));
    TEST_DEBUG (TEST_DBG_NAB, ("ulCrcBytesIndex: %08X\n", pNabStream->ulCrcBytesIndex));
    TEST_DEBUG (TEST_DBG_NAB, ("ulLastCrcBytes.: %08X\n", pNabStream->ulLastCrcBytes));
    TEST_DEBUG (TEST_DBG_NAB, ("ulIPStreamIndex: %08X\n", pNabStream->ulIPStreamIndex));

    return;
}

ULONG
Checksum ( char * psz, ULONG ulSize )
//////////////////////////////////////////////////////////////////////////////
{
    ULONG           Checksum = 0;
    ULONG           uli = 0;

    if(ulSize < 0x41d && ulSize)
    {
        for ( uli=0; uli <= ulSize-2; uli += 2)
        {
            Checksum += ((ULONG) (psz[uli]) << 8) + (ULONG) (psz[uli+1]);
        }

        Checksum = (Checksum >> 16) + (Checksum & 0xffff);
        Checksum += (Checksum >> 16);
        Checksum = ~Checksum;
    }
    return Checksum;
}

ULONG ulNumPacketsSent = 0;
ULONG ulIndicateEvery = 10;
ULONG ulIndicated = 0;

#endif   //DBG

///////////////////////////////////////////////////////////////////////////////////////
VOID
ResetNabStream (
    PSLIP_FILTER pFilter,
    PNAB_STREAM pNabStream,
    PHW_STREAM_REQUEST_BLOCK pSrb,
    PVOID pBuffer,
    ULONG ulBufSize
    )
///////////////////////////////////////////////////////////////////////////////////////
{

    if (pNabStream->ulOffset > sizeof (Header802_3))
    {
        pFilter->Stats.ulTotalSlipFramesIncomplete += 1;
        pFilter->Stats.ulTotalSlipBytesDropped += pNabStream->ulOffset - sizeof (Header802_3);
    }

    //
    // Reset the NAB_STREAM structure for this group ID
    //
    pNabStream->pSrb             = pSrb;
    pNabStream->pszBuffer        = pBuffer;
    pNabStream->ulcbSize         = ulBufSize;
    pNabStream->ulOffset         = 0;
    pNabStream->ulMpegCrc        = 0xFFFFFFFF;
    pNabStream->ulCrcBytesIndex  = 0l;
    pNabStream->ulLastCrcBytes   = 0l;

    if(pBuffer)
    {
        //  Copy the 802.3 header template into the frame.  We will replace
        //  the destination address and protocol on receive.
        //
        RtlCopyMemory (pNabStream->pszBuffer, &h802_3Template, sizeof (Header802_3));

        //
        //$$PFP update buffer offset
        //
        pNabStream->ulOffset = sizeof (Header802_3);
    }

    return;

}

///////////////////////////////////////////////////////////////////////////////////////
VOID
CancelNabStreamSrb (
    PSLIP_FILTER pFilter,
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
///////////////////////////////////////////////////////////////////////////////////////
{
    PLIST_ENTRY pFlink     = NULL;
    PLIST_ENTRY pQueue     = NULL;
    BOOLEAN bFound         = FALSE;
    PNAB_STREAM pNSTemp    = NULL;

    pQueue = &pFilter->StreamContxList;

    if ( !IsListEmpty (pQueue))
    {
        pFlink = pQueue->Flink;
        while ((pFlink != pQueue ) && !bFound)
        {
            pNSTemp = CONTAINING_RECORD (pFlink, NAB_STREAM, Linkage);

            if (pSrb && pSrb == pNSTemp->pSrb)
            {
                pNSTemp->pSrb->Status = STATUS_CANCELLED;
                StreamClassStreamNotification (StreamRequestComplete, pNSTemp->pSrb->StreamObject, pNSTemp->pSrb);
                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: StreamRequestComplete on pSrb: %08X\n", pNSTemp->pSrb));

                pNSTemp->pSrb  = NULL;
                bFound         = TRUE;
            }

            pFlink = pFlink->Flink;
        }

        if (bFound)
        {
            vDestroyNabStreamContext (pFilter, pNSTemp, TRUE);
        }

    }
}
///////////////////////////////////////////////////////////////////////////////////////
VOID
DeleteNabStreamQueue (
    PSLIP_FILTER pFilter
    )
///////////////////////////////////////////////////////////////////////////////////////
{
    PLIST_ENTRY pFlink     = NULL;
    PLIST_ENTRY pQueue     = NULL;
    PNAB_STREAM pNSTemp    = NULL;

    pQueue = &pFilter->StreamContxList;

    while ( !IsListEmpty (pQueue))
    {
        pFlink = RemoveHeadList (pQueue);
        pNSTemp = CONTAINING_RECORD (pFlink, NAB_STREAM, Linkage);

        if(pNSTemp && pNSTemp->pSrb)
        {
            pNSTemp->pSrb->Status = STATUS_CANCELLED;
            StreamClassStreamNotification (StreamRequestComplete, pNSTemp->pSrb->StreamObject, pNSTemp->pSrb);
            TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: StreamRequestComplete on pSrb: %08X\n", pNSTemp->pSrb));

            pNSTemp->pSrb = NULL;

            vDestroyNabStreamContext (pFilter, pNSTemp, TRUE);
        }
    }

    return;
}


//////////////////////////////////////////////////////////////////////////////
ULONG
CalculateCrc (
    PUCHAR pPacket,
    ULONG  ulSize
    )
//////////////////////////////////////////////////////////////////////////////
{
    ULONG  ul            = 0;
    ULONG ulLastCrcBytes = 0;
    ULONG ulMpegCrc      = 0xFFFFFFFF;
    PUCHAR ptr           = NULL;
    PCL pcl              = (PCL)&ulLastCrcBytes;

    for (ptr = pPacket, ul = 0; ul < ulSize; ul++, ptr++)
    {
        //if (ul > 3)
        //{
            //MpegCrcUpdate (&ulMpegCrc, 1, &pcl->c.uc[3]);
            MpegCrcUpdate (&ulMpegCrc, 1, ptr);
        //}

        //pcl->l.ul = (ULONG)(pcl->l.ul) << 8;
        //pcl->c.uc[0] = *ptr;

        TEST_DEBUG( TEST_DBG_CRC, ("SLIP:  char: %02X   ul: %d  MpegCrc: %08X\n", *ptr, ul, ulMpegCrc));

    }

    return ulMpegCrc;
}


//////////////////////////////////////////////////////////////////////////////
VOID
vNabtsUpdateCrc (
    PNAB_STREAM pNabStream,
    UCHAR ucToCopy
    )
//////////////////////////////////////////////////////////////////////////////
{

    PCL pcl = (PCL)&pNabStream->ulLastCrcBytes;


    if (pNabStream->ulCrcBytesIndex++ > 3)
    {
        MpegCrcUpdate (&pNabStream->ulMpegCrc, 1, &pcl->c.uc[3]);
    }

    pcl->l.ul = (ULONG)(pcl->l.ul) << 8;
    pcl->c.uc[0] = ucToCopy;

    #ifdef DUMP_CRC

        TEST_DEBUG( TEST_DBG_CRC, ("SLIP:  char: %02X   ulLastCrcBytes: %08X  MpegCrc: %08X  ulCrcBytesIndex: %d\n",
             ucToCopy, pNabStream->ulLastCrcBytes, pNabStream->ulMpegCrc, pNabStream->ulCrcBytesIndex));

    #endif // DUMP_CRC

}

//////////////////////////////////////////////////////////////////////////////
VOID
ComputeIPChecksum (
    PHeaderIP    pIPHeader
    )
//////////////////////////////////////////////////////////////////////////////
{
    ULONG           Checksum;
    PUCHAR          NextChar;

    pIPHeader->ucChecksumHigh = pIPHeader->ucChecksumLow = 0;
    Checksum = 0;
    for ( NextChar = (PUCHAR) pIPHeader
        ; (NextChar - (PUCHAR) pIPHeader) <= (sizeof(HeaderIP) - 2)
        ; NextChar += 2)
    {
        Checksum += ((ULONG) (NextChar[0]) << 8) + (ULONG) (NextChar[1]);
    }

    Checksum = (Checksum >> 16) + (Checksum & 0xffff);
    Checksum += (Checksum >> 16);
    Checksum = ~Checksum;

    pIPHeader->ucChecksumHigh = (UCHAR) ((Checksum >> 8) & 0xff);
    pIPHeader->ucChecksumLow = (UCHAR) (Checksum & 0xff);
}


//////////////////////////////////////////////////////////////////////////////
//
// Looks in the user's StreamContxList for a matching
// Nabts Group ID.
// It uses it if it finds one - otherwise we allocate one.
//
NTSTATUS
ntFindNabtsStream(
    PSLIP_FILTER pFilter,
    PNABTSFEC_BUFFER pNabData,
    PNAB_STREAM *ppNabStream
    )
//////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS status  = STATUS_SUCCESS;
    PLIST_ENTRY pFlink;
    PNAB_STREAM pNabStream = NULL;


    //
    // Check to see if the groupid is within the valid range.
    //
    if(pNabData->groupID > NABTSIP_GROUP_ID_RANGE_HI )
    {
        status = STATUS_INVALID_PARAMETER;
        ASSERT(status == STATUS_INVALID_PARAMETER);
        *ppNabStream = NULL;
        return status;
    }

    //
    // Go through the list one stream context at a time.
    //

    for (pFlink = pFilter->StreamContxList.Flink;
         pFlink != &pFilter->StreamContxList;
         pFlink = pFlink->Flink)
    {
        PNAB_STREAM pNSTemp;

        pNSTemp = CONTAINING_RECORD (pFlink, NAB_STREAM, Linkage);
        if(pNSTemp->groupID == pNabData->groupID)
        {
            pNabStream = pNSTemp;

            //
            // Mark the stream as having been used.  This flag is checked
            // in vCheckNabStreamLife.
            //
            pNabStream->fUsed = TRUE;

            break;
        }
    }

    //
    // if we did not find a stream then create one.
    //
    if (pNabStream == NULL)
    {
        status = ntCreateNabStreamContext(pFilter, pNabData->groupID, &pNabStream);
        if(status == STATUS_SUCCESS)
        {
            #if DBG

            TEST_DEBUG( TEST_DBG_NAB, ("SLIP Creating new NAB_STREAM for data...Group ID: %08X\n", pNabStream->groupID));

            #ifdef TEST_DBG_NAB
                DumpNabStream (pNabStream);
            #endif

            #endif //DBG
        }
    }
    else
    {
        TEST_DEBUG( TEST_DBG_NAB, ("SLIP Using existing NAB_STREAM for data.  Group ID: %08X\n", pNabStream->groupID));
        #ifdef TEST_DBG_NAB
            DumpNabStream (pNabStream);
        #endif
    }

    *ppNabStream = pNabStream;

    return status;
}

///////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
GetOutputSrbForStream (
    PSLIP_FILTER pFilter,
    PNAB_STREAM  pNabStream
    )
///////////////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS status                   = STATUS_INSUFFICIENT_RESOURCES;
    PKSSTREAM_HEADER  pStreamHdr      = NULL;
    PHW_STREAM_REQUEST_BLOCK pSrbIPv4 = NULL;


    if (QueueRemove( &pSrbIPv4, &pFilter->IpV4StreamDataSpinLock, &pFilter->IpV4StreamDataQueue))
    {
        //
        // Save the SRB References.
        //

        pNabStream->pSrb = pSrbIPv4;
        pStreamHdr = pSrbIPv4->CommandData.DataBufferArray;

        TEST_DEBUG (TEST_DBG_WRITE_DATA, ("SLIP: OUTPUT SRB...FrameExtent: %d  DataUsed: %d  Data: %08X\n",
                                          pStreamHdr->FrameExtent,
                                          pStreamHdr->DataUsed,
                                          pStreamHdr->Data
                                          ));
        status = STATUS_SUCCESS;

    }
    return status;
}



//////////////////////////////////////////////////////////////////////////////
void
UpdateMACHeader (
    PHeader802_3 pMAC,
    PHeaderIP    pIP
    )
//////////////////////////////////////////////////////////////////////////////
{
    ASSERT (pMAC);
    ASSERT (pIP);

    //
    // Now we copy the low order 23 bits of the IP destination addresss to the 802.3 Header
    //
    if (pMAC && pIP)
    {
        pMAC->DestAddress [3] = pIP->ipaddrDst.ucHighLSB & 0x7F;
        pMAC->DestAddress [4] = pIP->ipaddrDst.ucLowMSB  & 0xFF;
        pMAC->DestAddress [5] = pIP->ipaddrDst.ucLowLSB  & 0xFF;
    }
}



//////////////////////////////////////////////////////////////////////////////
void
vRebuildIPPacketHeader (
    PNAB_STREAM pNabStream
    )
//////////////////////////////////////////////////////////////////////////////
{
    PNAB_HEADER_CACHE pPacketHeader;
    PNAB_HEADER_CACHE pSavedHeader = &pNabStream->NabHeader[pNabStream->ulIPStreamIndex];
    PUCHAR psz;

    //
    // Copy the uncompressed packet header to the buffer.
    //

    RtlCopyMemory((pNabStream->pszBuffer + sizeof(Header802_3)),
                  ((PUCHAR)&pNabStream->NabHeader[pNabStream->ulIPStreamIndex]),
                  sizeof(HeaderIP) + sizeof(HeaderUDP));

    //
    // Copy the compressed header items into the uncompressed packet header.
    //

    pPacketHeader = (PNAB_HEADER_CACHE)pNabStream->pszBuffer + sizeof(Header802_3);

    //
    // Copy IP Packet ID.
    //
    psz = (PUCHAR)pNabStream->NabCState[pNabStream->ulIPStreamIndex].usrgCompressedHeader;
    RtlCopyMemory(&pPacketHeader->ipHeader.ucIDHigh, psz, IP_ID_SIZE);

    //
    // Copy UDP Check Sum.
    //
    psz = (PUCHAR)(pNabStream->NabCState[pNabStream->ulIPStreamIndex].usrgCompressedHeader + 2);
    RtlCopyMemory(&pPacketHeader->udpHeader.ucChecksumHigh, psz, UDP_CHKSUM_SIZE);

}

//////////////////////////////////////////////////////////////////////////////
__inline VOID
CopyNabToPacketNew(
    UCHAR               uchToCopy,
    PNAB_STREAM         pNabStream,
    PSLIP_FILTER        pFilter
    )
//////////////////////////////////////////////////////////////////////////////
{
    if (pNabStream->ulOffset >= pNabStream->ulcbSize)
    {
        //
        //  The packet is too big.  Resync the SLIP stream.
        //
        pNabStream->ulFrameState = NABTS_FS_SYNC;
        pFilter->Stats.ulTotalSlipFramesTooBig += 1;
    }
    else
    {
        ULONG ulIPStream = pNabStream->ulIPStreamIndex;

        if(pNabStream->NabCState[ulIPStream].usCompressionState == NABTS_CS_UNCOMPRESSED)
        {
            //
            //  Copy the byte to the actual Packet buffer.
            //

            pNabStream->pszBuffer[pNabStream->ulOffset] = uchToCopy;

            //
            // Update the MpegCrc check.
            //

            vNabtsUpdateCrc (pNabStream, uchToCopy);

            //
            // If we are collecting the IP Header data then copy it to
            // a buffer so that we can use it later for uncompression.
            //
            if(pNabStream->ulOffset < sizeof (Header802_3) + sizeof(HeaderIP) + sizeof(HeaderUDP))
            {
                PUCHAR psz = (PUCHAR)&pNabStream->NabHeader[pNabStream->ulIPStreamIndex].ipHeader;
                *(psz + pNabStream->ulOffset - sizeof (Header802_3)) = uchToCopy;
            }

            //
            // Increment the data pointer.
            //

            pNabStream->ulOffset++;
        }
        else if(pNabStream->NabCState[ulIPStream].usCompressionState == NABTS_CS_COMPRESSED)
        {
            if(pNabStream->NabCState[ulIPStream].uscbHeaderOffset <
               pNabStream->NabCState[ulIPStream].uscbRequiredSize)
            {
                PUCHAR psz = (PUCHAR)pNabStream->NabCState[ulIPStream].usrgCompressedHeader;

                *(psz + pNabStream->NabCState[ulIPStream].uscbHeaderOffset++) = uchToCopy;

                //
                // Update the MpegCrc check.
                //

                vNabtsUpdateCrc (pNabStream, uchToCopy);

                if(pNabStream->NabCState[ulIPStream].uscbHeaderOffset ==
                   pNabStream->NabCState[ulIPStream].uscbRequiredSize)
                {

                    ASSERT(pNabStream->ulOffset == sizeof(Header802_3));
                    //
                    // Use the saved IP Packet header and the compressed IP Header
                    // to rebuil the IP Header to send up.
                    //

                    vRebuildIPPacketHeader( pNabStream );

                    //
                    // Set the buffer offset past the end of the IP/UDP headers
                    // We should start coping data now.
                    //

                    pNabStream->ulOffset += (sizeof(HeaderIP) + sizeof(HeaderUDP));

                }
            }
            else
            {
                //
                // We already have the header rebuilt.  Now copy the payload.
                //

                pNabStream->pszBuffer[pNabStream->ulOffset++] = uchToCopy;


                //
                // Update the MpegCrc check.
                //

                vNabtsUpdateCrc (pNabStream, uchToCopy);
            }
        }
        else
        {
            DbgBreakPoint();
        }
    }
}

//////////////////////////////////////////////////////////////////////////////
__inline VOID
CopyNabToPacketOld(
    UCHAR               uchToCopy,
    PNAB_STREAM         pNabStream,
    PSLIP_FILTER        pFilter

    )
//////////////////////////////////////////////////////////////////////////////
{
    if (pNabStream->ulOffset >= pNabStream->ulcbSize)
    {
        //
        //  The packet is too big.  Resync the SLIP stream.
        //

        pNabStream->ulFrameState = NABTS_FS_SYNC;
        pFilter->Stats.ulTotalSlipFramesTooBig += 1;
    }
    else
    {
        //  Copy the byte.
        //
        pNabStream->pszBuffer[pNabStream->ulOffset++] = uchToCopy;
    }
}


//////////////////////////////////////////////////////////////////////////////
__inline VOID
CopyNabToPacket(
    UCHAR               uchToCopy,
    PNAB_STREAM         pNabStream,
    PSLIP_FILTER        pFilter

    )
//////////////////////////////////////////////////////////////////////////////
{


    if(pNabStream->ulProtoID == PROTO_ID)
    {
        CopyNabToPacketNew(uchToCopy, pNabStream, pFilter);
    }
    else
    {
        CopyNabToPacketOld(uchToCopy, pNabStream, pFilter);
    }
}


//////////////////////////////////////////////////////////////////////////////
NTSTATUS
ntNabtsRecv(
    PSLIP_FILTER pFilter,
    PNABTSFEC_BUFFER pNabData
    )
//////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS status              = STATUS_SUCCESS;
    PNAB_STREAM pNabStream       = NULL;
    PUCHAR pszNabIn              = NULL;
    PKSSTREAM_HEADER  pStreamHdr = NULL;
    LARGE_INTEGER liCurrentTime  = {0};
    LARGE_INTEGER liTimeToLive   = {0};
    LARGE_INTEGER liStatusInterval   = {0};
    KIRQL Irql                   = {0};
    ULONG ulIPStream             = 0;
    ULONG ulNabIn                = 0;


    TEST_DEBUG( TEST_DBG_RECV, ("\nEntering - ntNabtsRecv\n"));

    //
    // Get the current system time.
    //
    KeQuerySystemTime(&liCurrentTime);

    //
    // See if it is time the check for dead GroupIDs and Streams.
    // Get a lock so no one else is modifying the Stream list while we are looking.
    //
    KeAcquireSpinLock(&pFilter->StreamUserSpinLock, &Irql);


    liTimeToLive.QuadPart = NAB_STREAM_LIFE;
    if( (LONGLONG)(liCurrentTime.QuadPart - pFilter->liLastTimeChecked.QuadPart) > liTimeToLive.QuadPart)
    {
        vCheckNabStreamLife( pFilter );
        pFilter->liLastTimeChecked = liCurrentTime;
    }

    //
    // Find the Stream Context.
    //
    status = ntFindNabtsStream( pFilter, pNabData, &pNabStream );
    if(status != STATUS_SUCCESS)
    {
        ASSERT( status == STATUS_SUCCESS);
        pFilter->Stats.ulTotalSlipBuffersDropped += 1;
        KeReleaseSpinLock(&pFilter->StreamUserSpinLock, Irql);
        goto ret;
    }

    KeReleaseSpinLock(&pFilter->StreamUserSpinLock, Irql);


    liStatusInterval.QuadPart = NAB_STATUS_INTERVAL;
    if( (LONGLONG)(liCurrentTime.QuadPart - pFilter->liLastTimeStatsDumped.QuadPart) > liStatusInterval.QuadPart)
    {
        pFilter->liLastTimeStatsDumped = liCurrentTime;
        TEST_DEBUG (TEST_DBG_INFO, ("      "));
        TEST_DEBUG (TEST_DBG_INFO, ("SLIP: ulTotalDataSRBWrites: %d\n.", pFilter->Stats.ulTotalDataSRBWrites));
        TEST_DEBUG (TEST_DBG_INFO, ("      ulTotalBadPinSRBWrites: %d\n.", pFilter->Stats.ulTotalBadPinSRBWrites));
        TEST_DEBUG (TEST_DBG_INFO, ("      ulTotalDataSRBReads: %d\n.", pFilter->Stats.ulTotalDataSRBReads));
        TEST_DEBUG (TEST_DBG_INFO, ("      ulTotalBadPinSRBReads: %d\n.", pFilter->Stats.ulTotalBadPinSRBReads));
        TEST_DEBUG (TEST_DBG_INFO, ("      ulTotalSlipBuffersReceived: %d\n.", pFilter->Stats.ulTotalSlipBuffersReceived));
        TEST_DEBUG (TEST_DBG_INFO, ("      ulTotalSlipBuffersDropped: %d\n.", pFilter->Stats.ulTotalSlipBuffersDropped));
        TEST_DEBUG (TEST_DBG_INFO, ("      ulTotalSlipZeroLengthBuffers: %d\n.", pFilter->Stats.ulTotalSlipZeroLengthBuffers));
        TEST_DEBUG (TEST_DBG_INFO, ("      ulTotalSlipBytesReceived: %d\n.", pFilter->Stats.ulTotalSlipBytesReceived));
        TEST_DEBUG (TEST_DBG_INFO, ("      ulTotalSlipBytesDropped: %d\n.", pFilter->Stats.ulTotalSlipBytesDropped));
        TEST_DEBUG (TEST_DBG_INFO, ("      ulTotalSlipFramesReceived: %d\n.", pFilter->Stats.ulTotalSlipFramesReceived));
        TEST_DEBUG (TEST_DBG_INFO, ("      ulTotalSlipOldProtoFramesStarted: %d\n.", pFilter->Stats.ulTotalSlipOldProtoFramesStarted));
        TEST_DEBUG (TEST_DBG_INFO, ("      ulTotalSlipNewProtoFramesStarted: %d\n.", pFilter->Stats.ulTotalSlipNewProtoFramesStarted));
        TEST_DEBUG (TEST_DBG_INFO, ("      ulTotalSlipFramesIncomplete: %d\n.", pFilter->Stats.ulTotalSlipFramesIncomplete));
        TEST_DEBUG (TEST_DBG_INFO, ("      ulTotalSlipFramesBadCRC: %d\n.", pFilter->Stats.ulTotalSlipFramesBadCRC));
        TEST_DEBUG (TEST_DBG_INFO, ("      ulTotalSlipFramesTooBig: %d\n.", pFilter->Stats.ulTotalSlipFramesTooBig));
        TEST_DEBUG (TEST_DBG_INFO, ("      ulTotalSlipFramesTooSmall: %d\n.", pFilter->Stats.ulTotalSlipFramesTooSmall));
        TEST_DEBUG (TEST_DBG_INFO, ("      ulTotalIPPacketsFound: %d\n.", pFilter->Stats.ulTotalIPPacketsFound));
        TEST_DEBUG (TEST_DBG_INFO, ("      ulTotalIPBytesFound: %d\n.", pFilter->Stats.ulTotalIPBytesFound));
        TEST_DEBUG (TEST_DBG_INFO, ("      ulTotalIPPacketsSent: %d\n.", pFilter->Stats.ulTotalIPPacketsSent));
        TEST_DEBUG (TEST_DBG_INFO, ("      ulTotalIPBytesSent: %d\n.", pFilter->Stats.ulTotalIPBytesSent));
        TEST_DEBUG (TEST_DBG_INFO, ("      ulTotalIPPacketsTooBig: %d\n.", pFilter->Stats.ulTotalIPPacketsTooBig));
        TEST_DEBUG (TEST_DBG_INFO, ("      ulTotalIPPacketsTooSmall: %d\n.", pFilter->Stats.ulTotalIPPacketsTooSmall));
        TEST_DEBUG (TEST_DBG_INFO, ("      ulTotalIPPacketsDropped: %d\n.", pFilter->Stats.ulTotalIPPacketsDropped));
        TEST_DEBUG (TEST_DBG_INFO, ("      ulTotalIPBytesDropped: %d\n.", pFilter->Stats.ulTotalIPBytesDropped));
        TEST_DEBUG (TEST_DBG_INFO, ("      ulTotalNabStreamsCreated: %d\n.", pFilter->Stats.ulTotalNabStreamsCreated));
        TEST_DEBUG (TEST_DBG_INFO, ("      ulTotalNabStreamsTimedOut: %d\n.", pFilter->Stats.ulTotalNabStreamsTimedOut));
        TEST_DEBUG (TEST_DBG_INFO, ("      "));

    }

    //
    // Set the last time used for this stream.
    //

    pNabStream->liLastTimeUsed = liCurrentTime;

    //
    // Get a pointer to the input buffer.  We copy data from this pointer to
    // the output buffer
    //

    pszNabIn = (LPSTR) pNabData->data;

    // Validate the data size and that the start+end of the buffer are accessible
    ASSERT(pNabData->dataSize <= sizeof(pNabData->data) );

    //  What is really needed here is something like "MmIsValidAddress()", but for WDM drivers
    //  These assert just look at the start & end addresses of the buffer w/o regard to values.
    // ASSERT( (*(pszNabIn) + 1 > 0) );
    // ASSERT( (*(pszNabIn+pNabData->dataSize-1) + 1 > 0) );

    for (ulNabIn = pNabData->dataSize; ulNabIn; ulNabIn--, pszNabIn++)
    {
        switch (pNabStream->ulFrameState)
        {

            case NABTS_FS_SYNC:

                switch (*pszNabIn)
                {
                    case FRAME_END:
                        //
                        //  We found the start of frame sync.  Look for the
                        //  protocol character.
                        //
                        TEST_DEBUG( TEST_DBG_RECV, ("SLIP   Found Possible Start of Frame... pszNabIn %08X   ulNabIn: %08X\n", pszNabIn, ulNabIn));
                        pNabStream->ulFrameState = NABTS_FS_SYNC_PROTO;

                        ResetNabStream (pFilter, pNabStream, NULL, NULL, 0);

                        break;
                }
                break;

            case NABTS_FS_SYNC_PROTO:

                switch (*pszNabIn)
                {
                    case PROTO_ID:
                    case PROTO_ID_OLD:

                        TEST_DEBUG( TEST_DBG_RECV, ("SLIP   Found Start of Protocol...Building Packet.... pszNabIn %08X   ulNabIn: %08X\n", pszNabIn, ulNabIn));

                        // Record the stream type.
                        //
                        pNabStream->ulProtoID = *pszNabIn;

                        //  This is our protocol. Setup NAB_STREAM with an output
                        //  data buffer from the output SRB Queue
                        //
                        TEST_DEBUG( TEST_DBG_RECV, ("SLIP Setting Up Output buffer\n"));
                        ResetNabStream( pFilter, pNabStream, NULL, pNabStream->rgBuf, sizeof(pNabStream->rgBuf));

                        //  Copy the 802.3 header template into the frame.  We will replace
                        //  the destination address and protocol on receive.
                        //
                        RtlCopyMemory (pNabStream->pszBuffer, &h802_3Template, sizeof (Header802_3));

                        //  Update buffer offset
                        //
                        pNabStream->ulOffset = sizeof (Header802_3);

                        if(pNabStream->ulProtoID == PROTO_ID)
                        {
                            //
                            // Set the state to check the IP compression.
                            //
                            pFilter->Stats.ulTotalSlipNewProtoFramesStarted += 1;
                            TEST_DEBUG( TEST_DBG_RECV, ("SLIP Protocol ID is Compressed\n"));
                            pNabStream->ulFrameState = NABTS_FS_COMPRESSION;
                        }
                        else
                        {
                            //
                            //  Start collecting data.
                            //
                            pFilter->Stats.ulTotalSlipOldProtoFramesStarted += 1;
                            TEST_DEBUG( TEST_DBG_RECV, ("SLIP Protocol ID is not Compressed\n"));
                            pNabStream->ulFrameState = NABTS_FS_COLLECT;
                        }

                        // Update the MpegCrc check.
                        //
                        vNabtsUpdateCrc( pNabStream, *pszNabIn);

                        break;


                    case FRAME_END:
                        TEST_DEBUG( TEST_DBG_RECV, ("SLIP State is FRAME_END....going to FS_SYNC_PROTO\n"));
                        pNabStream->ulFrameState = NABTS_FS_SYNC_PROTO;
                        break;

                    default:
                        TEST_DEBUG( TEST_DBG_RECV, ("SLIP   Protocol Not Found...ReSyncing... pszNabIn %08X   ulNabIn: %08X\n", pszNabIn, ulNabIn));
                        pNabStream->ulFrameState = NABTS_FS_SYNC;
                        break;
                }
                break;


            case NABTS_FS_COMPRESSION:
            {

                TEST_DEBUG( TEST_DBG_RECV, ("SLIP State is NABTS_FS_COMPRESSION\n"));

                //
                // Get the index to the IP Compression Stream.
                //
                ulIPStream = IP_STREAM_INDEX(*pszNabIn);

                //
                // Check to see if this IP Packet has a compressed header.
                //
                if(!PACKET_COMPRESSED(*pszNabIn))
                {
                     pNabStream->NabCState[ulIPStream].usCompressionState = NABTS_CS_UNCOMPRESSED;
                }
                else if (PACKET_COMPRESSED (*pszNabIn))
                {
                    pNabStream->NabCState[ulIPStream].usCompressionState = NABTS_CS_COMPRESSED;
                    pNabStream->NabCState[ulIPStream].uscbRequiredSize = NORMAL_COMPRESSED_HEADER;
                }

                //
                // Retain the IP Stream Index.
                //
                pNabStream->ulIPStreamIndex = ulIPStream;

                //
                // Set the stats Last Used Time for this stream.
                //
                pNabStream->NabCState[pNabStream->ulIPStreamIndex].liLastUsed = liCurrentTime;

                //
                // Set the IP Header Data Length to zero.
                //
                pNabStream->NabCState[pNabStream->ulIPStreamIndex].uscbHeaderOffset = 0;

                //
                //  Start collecting data.
                //
                pNabStream->ulFrameState = NABTS_FS_COLLECT;

                //
                // Update the MpegCrc check.
                //
                vNabtsUpdateCrc (pNabStream, *pszNabIn);

                break;
            }


            case NABTS_FS_COLLECT:

                switch (*pszNabIn)
                {
                    case FRAME_ESCAPE:
                        //
                        //  We want to escape the next character.
                        //
                        TEST_DEBUG( TEST_DBG_RECV, ("SLIP   NABTS_FS_COLLECT_ESCAPE\n"));
                        pNabStream->ulFrameState = NABTS_FS_COLLECT_ESCAPE;
                        break;

                    case FRAME_END:

                        if (pNabStream->ulOffset >= sizeof(HeaderIP))
                        {
                            PHeaderIP pHeaderIp = (PHeaderIP)(PUCHAR)(pNabStream->pszBuffer + sizeof(Header802_3));
                            PUSHORT pusIpLen = (PUSHORT)&pHeaderIp->ucTotalLenHigh;


                            TEST_DEBUG( TEST_DBG_RECV, ("SLIP   End of Packet Found... pszNabIn %08X   ulNabIn: %08X  ulOffset: %d\n", pszNabIn, ulNabIn, pNabStream->ulOffset));

                            TEST_DEBUG( TEST_DBG_RECV, ("SLIP   ulProtoID %d  ulMpegCrc: %08X  ulLastCrcBytes: %08X  IpLen: %d\n",
                                                        pNabStream->ulProtoID, pNabStream->ulMpegCrc, pNabStream->ulLastCrcBytes, *pusIpLen));


                            //  If header compression is being used, we must
                            //  calculate the IP and UDP lengths and regenerate
                            //  the packet checksums.
                            //
                            if (pNabStream->ulProtoID == PROTO_ID)
                            {
                                PHeaderUDP pHeaderUDP = (PHeaderUDP)(PUCHAR)(pNabStream->pszBuffer + sizeof(Header802_3) + sizeof(HeaderIP));
                                PUSHORT pusUdpLen = (PUSHORT)&pHeaderUDP->ucMsgLenHigh;

                                TEST_DEBUG( TEST_DBG_CRC, ("SLIP:  GroupID: %d Stream CRC: %08X   Calculated CRC: %08X", pNabStream->groupID, pNabStream->ulLastCrcBytes, pNabStream->ulMpegCrc));

                                // All PROTO_ID packets have an MpegCrc on the end.  It is not
                                // part of the IP packet and needs to be stripped off.
                                //
                                pNabStream->ulOffset -= 4;

                                if (pNabStream->NabCState[pNabStream->ulIPStreamIndex].usCompressionState == NABTS_CS_COMPRESSED)
                                {
                                    // We use the ulOffset less the MAC Header and IP Header
                                    // sizes for the UDP Packet length.
                                    //
                                    // Note!  Fragmented UDP datagrams cannot be compressed
                                    //
                                    *pusUdpLen = htons ((USHORT)(pNabStream->ulOffset - sizeof(Header802_3) - sizeof(HeaderIP)));
    
                                    // We use the ulOffset less the MAC Header size for the
                                    // IP Packet length.
                                    //
                                    *pusIpLen = htons ((USHORT)(pNabStream->ulOffset - sizeof(Header802_3)));
    
                                    // Recalculate the IP header Checksum
                                    //
                                    ComputeIPChecksum (pHeaderIp);
                                }

                                //  If the CRC was bad then invalidate
                                //  the IP Checksum
                                //
                                if (pNabStream->ulMpegCrc != pNabStream->ulLastCrcBytes)
                                {
                                    TEST_DEBUG (TEST_DBG_CRC, ("   FAILED*****\n"));
                                    
                                    pFilter->Stats.ulTotalSlipFramesBadCRC += 1;

                                    pHeaderIp->ucChecksumHigh = ~(pHeaderIp->ucChecksumHigh);
                                    pHeaderIp->ucChecksumLow = 0xff;
                                }
                                else
                                {
                                    TEST_DEBUG (TEST_DBG_CRC, ("   PASSED\n"));
                                }
                            }
                            else if (pNabStream->ulProtoID != PROTO_ID_OLD)
                            {
                                TEST_DEBUG( TEST_DBG_RECV, ("SLIP   End of Packet Found....Bad PROTO_ID... pszNabIn %08X   ulNabIn: %08X  ulOffset: %d\n", pszNabIn, ulNabIn, pNabStream->ulOffset));
                                ASSERT(   (pNabStream->ulProtoID == PROTO_ID_OLD)
                                       || (pNabStream->ulProtoID == PROTO_ID)
                                      );
                                ResetNabStream (pFilter, pNabStream, NULL, NULL, 0);
                                pNabStream->ulFrameState = NABTS_FS_SYNC;
                                goto ret;
                            }
                            
                            if (NabtsNtoHs(*pusIpLen) <= NABTSIP_MAX_LOOKAHEAD)
                            {
                                //  Update the MAC address
                                //
                                UpdateMACHeader( 
                                    (PHeader802_3)(pNabStream->pszBuffer), 
                                    pHeaderIp
                                    );

                                // Get an SRB for outputting the data.
                                //
                                status = GetOutputSrbForStream(pFilter, 
                                                               pNabStream
                                                               );
                                if(status != STATUS_SUCCESS)
                                {
                                    ASSERT(status == STATUS_SUCCESS);
                                    pFilter->Stats.ulTotalIPPacketsDropped += 1;
                                    ResetNabStream( pFilter, pNabStream, NULL, NULL, 0);
                                    pNabStream->ulFrameState = NABTS_FS_SYNC;
                                    goto ret;
                                }

                                ASSERT(pNabStream->pSrb);
                                if (!pNabStream->pSrb)
                                {
                                    pFilter->Stats.ulTotalIPPacketsDropped += 1;
                                    ResetNabStream (pFilter, pNabStream, NULL, NULL, 0);
                                    pNabStream->ulFrameState = NABTS_FS_SYNC;
                                    goto ret;
                                }

                                // Get the StreamHdr.
                                //
                                pStreamHdr = (PKSSTREAM_HEADER) pNabStream->pSrb->CommandData.DataBufferArray;
                                ASSERT( pStreamHdr);
                                if (!pStreamHdr)
                                {
                                    pFilter->Stats.ulTotalIPPacketsDropped += 1;
                                    ResetNabStream (pFilter, pNabStream, NULL, NULL, 0);
                                    pNabStream->ulFrameState = NABTS_FS_SYNC;
                                    goto ret;
                                }

                                // If we had a discontinuity, we flag it.
                                //
                                if (pFilter->bDiscontinuity)
                                {
                                    pStreamHdr->OptionsFlags |= KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY;
                                    pFilter->bDiscontinuity = FALSE;
                                }

                                // Copy the data from the rgBuf to the Srb.
                                //
                                RtlCopyMemory (pStreamHdr->Data, 
                                               pNabStream->pszBuffer, 
                                               pNabStream->ulOffset
                                               );

                                // Update the datasize field of the Output SRB
                                //
                                pStreamHdr->DataUsed = pNabStream->ulOffset;

                                // Complete the output SRB
                                //
                                pFilter->Stats.ulTotalIPPacketsSent += 1;
                                pNabStream->ulOffset = 0;
                                StreamClassStreamNotification( 
                                    StreamRequestComplete, 
                                    pNabStream->pSrb->StreamObject, 
                                    pNabStream->pSrb
                                    );
                                TEST_DEBUG (TEST_DBG_SRB, ("SLIP: Completed SRB....Ptr %08X  Size %d\n", pStreamHdr->Data, pStreamHdr->DataUsed));

                                TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: StreamRequestComplete on pSrb: %08X\n", pNabStream->pSrb));
                            }
                            else
                            {
                                //  The packet is too big.  Resync the SLIP stream.
                                //
                                pFilter->Stats.ulTotalIPPacketsDropped += 1;
                                pFilter->Stats.ulTotalIPPacketsTooBig += 1;
                                TEST_DEBUG( TEST_DBG_RECV, ("SLIP   End of Packet Found....Packet Too BIG... pszNabIn %08X   ulNabIn: %08X  ulOffset: %d\n", pszNabIn, ulNabIn, pNabStream->ulOffset));
                            }
                        }
                        else
                        {
                            //  The packet is too small.  Resync the SLIP stream.
                            //
                            pFilter->Stats.ulTotalIPPacketsDropped += 1;
                            pFilter->Stats.ulTotalIPPacketsTooSmall += 1;
                            TEST_DEBUG( TEST_DBG_RECV, ("SLIP   End of Packet Found....Packet Too SMALL... pszNabIn %08X   ulNabIn: %08X  ulOffset: %d\n", pszNabIn, ulNabIn, pNabStream->ulOffset));
                        }

                        // Reset state for new packet.
                        //
                        ResetNabStream (pFilter, pNabStream, NULL, NULL, 0);
                        pNabStream->ulFrameState = NABTS_FS_SYNC;
                        break;


                    default:
                        //  Just copy the byte to the NDIS packet.
                        //
                        CopyNabToPacket( *pszNabIn, pNabStream, pFilter);
                        break;

                }
                break;


            case NABTS_FS_COLLECT_ESCAPE:

                pNabStream->ulFrameState = NABTS_FS_COLLECT;

                switch (*pszNabIn)
                {
                    case TRANS_FRAME_ESCAPE:
                        //
                        //  Special way to insert a FRAME_ESCAPE
                        //  character as part of the data.
                        //
                        TEST_DEBUG( TEST_DBG_RECV, ("SLIP   NABTS_FS_COLLECT_ESCAPE....TRANS_FRAME_ESCAPE\n"));
                        CopyNabToPacket( (UCHAR) FRAME_ESCAPE, pNabStream, pFilter);
                        break;


                    case TRANS_FRAME_END:
                        //
                        //  Special way to insert a FRAME_END
                        //  character as part of the data.
                        //
                        TEST_DEBUG( TEST_DBG_RECV, ("SLIP   NABTS_FS_COLLECT_ESCAPE.....TRANS_FRAME_END\n"));
                        CopyNabToPacket( (UCHAR) FRAME_END, pNabStream, pFilter);
                        break;

                    default:
                        //  Any other character that follows FRAME_ESCAPE
                        //  is just inserted into the packet.
                        //
                        CopyNabToPacket( *pszNabIn, pNabStream, pFilter);
                        break;
                }
                break;

            default:
                //
                //  We should never be in an unknown state.
                //
                TEST_DEBUG( TEST_DBG_RECV, ("SLIP   UNKNOWN STATE.....ReSyncing\n"));
                ASSERT( pNabStream->ulFrameState);
                ResetNabStream (pFilter, pNabStream, NULL, NULL, 0);
                pNabStream->ulFrameState = NABTS_FS_SYNC;

                break;
        }

    }

ret:

    TEST_DEBUG( TEST_DBG_RECV, ("SLIP   Completed ntNabtsRecv\n"));
    return status;
}

//////////////////////////////////////////////////////////////////////////////
//
// Create a NAB Stream Context.
//
NTSTATUS
ntCreateNabStreamContext(
    PSLIP_FILTER pFilter,
    ULONG groupID,
    PNAB_STREAM *ppNabStream
    )
//////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS status         = STATUS_SUCCESS;
    PNAB_STREAM pNabStream  = NULL;

    TEST_DEBUG (TEST_DBG_NAB, ("********************************  Creating NAB STREAM for group ID %d\n", groupID));

    //
    // Initialize output paramter
    //
    *ppNabStream = NULL;

    //
    // Allocate a Nab Stream structure.
    //
    status = ntAllocateNabStreamContext (&pNabStream);
    if(status == STATUS_SUCCESS)
    {
        pNabStream->ulType           = (ULONG)NAB_STREAM_SIGNATURE;
        pNabStream->ulSize           = sizeof (NAB_STREAM);
        pNabStream->ulFrameState     = NABTS_FS_SYNC;
        pNabStream->ulMpegCrc        = 0xFFFFFFFF;
        pNabStream->fUsed            = TRUE;
        pNabStream->groupID          = groupID;

        //
        // Add the new Stream Context to the User's Stream Context List.
        //
        InsertTailList (&pFilter->StreamContxList, &pNabStream->Linkage);

        *ppNabStream = pNabStream;
    }

    return status;
}


//////////////////////////////////////////////////////////////////////////////
NTSTATUS
ntAllocateNabStreamContext(
    PNAB_STREAM *ppNabStream
    )
//////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS status         = STATUS_SUCCESS;
    PNAB_STREAM pNabStream  = NULL;

    pNabStream = ExAllocatePool (NonPagedPool, sizeof(NAB_STREAM));

    if (pNabStream == NULL)
    {
        *ppNabStream = NULL;
        return (STATUS_NO_MEMORY);
    }

    RtlZeroMemory (pNabStream, sizeof(NAB_STREAM));

    *ppNabStream = pNabStream;

    return status;
}


//////////////////////////////////////////////////////////////////////////////
VOID
vDestroyNabStreamContext(
   PSLIP_FILTER pFilter,
   PNAB_STREAM pNabStream,
   BOOLEAN fUseSpinLock
   )
//////////////////////////////////////////////////////////////////////////////
{
    KIRQL Irql;

    if(fUseSpinLock)
    {
        //
        // Lock the user.
        //

        KeAcquireSpinLock( &pFilter->StreamUserSpinLock, &Irql);
    }

    //
    // Remove the stream context from the user's list.
    //

    RemoveEntryList (&pNabStream->Linkage);

    if(fUseSpinLock)
    {
        //
        // UnLock the user.
        //

        KeReleaseSpinLock( &pFilter->StreamUserSpinLock, Irql);
    }

    //
    // Free the stream's SRB, if any.
    //
    if (pNabStream->pSrb)
    {
        StreamClassStreamNotification (StreamRequestComplete, pNabStream->pSrb->StreamObject, pNabStream->pSrb);
        TEST_DEBUG (TEST_DBG_TRACE, ("SLIP: StreamRequestComplete on pSrb: %08X\n", pNabStream->pSrb));
        pNabStream->pSrb = NULL;
    }

    //
    // Free the stream context memory.
    //
    TEST_DEBUG (TEST_DBG_NAB, ("Deleting  NAB STREAM for group ID: %d... ", pNabStream->groupID));
    ExFreePool (pNabStream);

}


//////////////////////////////////////////////////////////////////////////////
VOID
vCheckNabStreamLife (
    PSLIP_FILTER pFilter
    )
//////////////////////////////////////////////////////////////////////////////
{
    PNAB_STREAM pNabStream;
    PLIST_ENTRY pFlink;

    TEST_DEBUG( TEST_DBG_RECV, ("Entering - vCheckNabStreamLife - pFilter: %x\n", pFilter));

    //
    // Go through the StreamContextList. Remove any stream context structures that have
    // expired their life span.
    //

    for (pFlink = pFilter->StreamContxList.Flink;
         pFlink != &pFilter->StreamContxList;
         pFlink = pFlink->Flink)
    {
        pNabStream = CONTAINING_RECORD (pFlink, NAB_STREAM, Linkage);

        TEST_DEBUG (TEST_DBG_NAB, ("Checking NAB STREAM life for group ID %d ... ", pNabStream->groupID));

        if (pNabStream->fUsed)
        {
            TEST_DEBUG (TEST_DBG_NAB, ("   USED\n"));
        }
        else
        {
            TEST_DEBUG (TEST_DBG_NAB, ("   NOT USED\n"));
        }


        if(!pNabStream->fUsed)
        {

            //  Point at the previous Stream;

            pFlink = pFlink->Blink;

            //
            // Remove the stream from the User's stream context list.
            //

            //
            // vDestroyNabStreamContext returns the active NDIS Packet (if any) to
            // the adapter's free list, remove the stream context from the user list
            // (if specified) and free the stream context structure memory.
            //

            vDestroyNabStreamContext( pFilter, pNabStream, FALSE);
            pFilter->Stats.ulTotalNabStreamsTimedOut += 1;
        }
        else
        {
            //
            // This flag must be set back to TRUE before the next DPC fires or
            // this stream will be removed.
            //

            pNabStream->fUsed = FALSE;
        }
    }

    TEST_DEBUG ( TEST_DBG_RECV, ("Leaving - vCheckNabStreamLife\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\slip\recv.h ===
/////////////////////////////////////////////////////////////////////////////
//
//
// Copyright (c) 1996, 1997  Microsoft Corporation
//
//
// Module Name:
//      recv.h
//
// Abstract:
//
//
// Author:
//
//      P Porzuczek
//
// Environment:
//
// Revision History:
//
//
//////////////////////////////////////////////////////////////////////////////

#ifndef _RECV_H_
#define _RECV_H_


///////////////////////////////////////////////////////////////////////////////////////
//
// some character values
//
#define FRAME_ESCAPE        0xDB
#define FRAME_END           0xC0
#define TRANS_FRAME_END     0xDC
#define TRANS_FRAME_ESCAPE  0xDD
#define PROTO_ID            0x00
#define PROTO_ID_OLD        0x03

#define NORMAL_COMPRESSED_HEADER      4
#define IP_ID_SIZE                    2
#define UDP_CHKSUM_SIZE               2

#define PACKET_COMPRESSED(x)  (x & 0x80)
#define IP_STREAM_INDEX(x)    (x & 0x7f)


#define NABTSIP_MAX_PACKET         1514
#define NABTSIP_MAX_LOOKAHEAD      (NABTSIP_MAX_PACKET - ETHERNET_HEADER_SIZE)
#define NABTSIP_MAX_PAYLOAD        (NABTSIP_MAX_LOOKAHEAD + MPEG_CRC_SIZE)
#define MPEG_CRC_SIZE              4
#define ETHERNET_HEADER_SIZE       14
#define ETHERNET_LENGTH_OF_ADDRESS 6


///////////////////////////////////////////////////////////////////////////////////////
//
//
//
//
// Size of the ethernet address
//
typedef struct _Header802_3
{
   UCHAR DestAddress[ETHERNET_LENGTH_OF_ADDRESS];
   UCHAR SourceAddress[ETHERNET_LENGTH_OF_ADDRESS];
   UCHAR Type[2];
} Header802_3, * PHeader802_3;

///////////////////////////////////////////////////////////////////////////////////////
//
//
//
#define htons(x)     ((((x) >> 8) & 0x00FF) | (((x) << 8) & 0xFF00))

///////////////////////////////////////////////////////////////////////////////////////
//
//
//
#define NabtsNtoHl(l)                               \
            ( ( ((l) >> 24) & 0x000000FFL ) |       \
              ( ((l) >>  8) & 0x0000FF00L ) |       \
              ( ((l) <<  8) & 0x00FF0000L ) |       \
              ( ((l) << 24) & 0xFF000000L ) )

///////////////////////////////////////////////////////////////////////////////////////
//
//
//
#define NabtsNtoHs(s)                               \
            ( ( ((s) >> 8) & 0x00FF ) |             \
              ( ((s) << 8) & 0xFF00 ) )


///////////////////////////////////////////////////////////////////////////////////////
//
// IP Compression States.
//
typedef enum
{
    NABTS_CS_UNCOMPRESSED = 0,
    NABTS_CS_COMPRESSED,
    NABTS_CS_CHKCRC
};


///////////////////////////////////////////////////////////////////////////////////////
//
//
//
struct _C
{
   UCHAR uc[4];
};

///////////////////////////////////////////////////////////////////////////////////////
//
//
//
struct _L
{
   ULONG ul;
};

///////////////////////////////////////////////////////////////////////////////////////
//
//
//
typedef union
{
   struct _C c;
   struct _L l;
}CL, *PCL;


///////////////////////////////////////////////////////////////////////////////////////
//
//  NABTSIP Group Range
//
#define NABTSIP_GROUP_ID_RANGE_LOW  0
#define NABTSIP_GROUP_ID_RANGE_HI   4096


///////////////////////////////////////////////////////////////////////////////////////
//
//
//
//#define NAB_STREAM_LIFE (LONGLONG)1000 * 1000 * 10 * 60 * 30 // 30 Minutes
#define NAB_STREAM_LIFE (LONGLONG)1000 * 1000 * 10 * 60 * 10 // 10 Minutes
#define NAB_STATUS_INTERVAL (LONGLONG)1000 * 1000 * 10 * 60 * 1 // 1 Minutes
#define NAB_STREAM_SIGNATURE            ((CSHORT)0xab05)

///////////////////////////////////////////////////////////////////////////////////////
//
//  Frame states.
//
typedef enum
{
    NABTS_FS_SYNC,
    NABTS_FS_SYNC_PROTO,
    NABTS_FS_COMPRESSION,
    NABTS_FS_COLLECT,
    NABTS_FS_COLLECT_ESCAPE
};



///////////////////////////////////////////////////////////////////////////////////////
//
//  Frame states.
//
typedef struct _AddrIP
{
   UCHAR ucHighMSB;
   UCHAR ucHighLSB;
   UCHAR ucLowMSB;
   UCHAR ucLowLSB;
} AddrIP, * PAddrIP;


///////////////////////////////////////////////////////////////////////////////////////
//
// IP Header
//
typedef struct _HeaderIP
{
   UCHAR ucVersHlen;
   UCHAR ucServiceType;
   UCHAR ucTotalLenHigh;
   UCHAR ucTotalLenLow;
   UCHAR ucIDHigh;
   UCHAR ucIDLow;
   UCHAR ucFlags;
   UCHAR ucOffsetLow;
   UCHAR ucTimeToLive;
   UCHAR ucProtocol;
   UCHAR ucChecksumHigh;
   UCHAR ucChecksumLow;
   AddrIP ipaddrSrc;
   AddrIP ipaddrDst;
} HeaderIP, * PHeaderIP;

///////////////////////////////////////////////////////////////////////////////////////
//
//
//
typedef struct _HeaderUDP
{
   UCHAR ucSourcePortMSB;
   UCHAR ucSourcePortLSB;
   UCHAR ucDestPortMSB;
   UCHAR ucDestPortLSB;
   UCHAR ucMsgLenHigh;
   UCHAR ucMsgLenLow;
   UCHAR ucChecksumHigh;
   UCHAR ucChecksumLow;
} HeaderUDP, *PHeaderUDP;

///////////////////////////////////////////////////////////////////////////////////////
//
//
//
typedef struct _IP_CACHE {
    HeaderIP    ipHeader;
    HeaderUDP   udpHeader;
    LARGE_INTEGER liLastUsed;
} NAB_HEADER_CACHE, *PNAB_HEADER_CACHE;


//
// IP Compression State Struct.
//
typedef struct _NAB_IP_COMPRESSION
{
    ULONG   usCompressionState;
    USHORT  uscbRequiredSize;
    USHORT  uscbHeaderOffset;
    USHORT  usrgCompressedHeader[3];
    LARGE_INTEGER liLastUsed;
}NAB_COMPRESSION_STATE, *PNAB_COMPRESSION_STATE;


///////////////////////////////////////////////////////////////////////////////////////
//
// NabtsIp Stream Context.
//

#define MAX_IP_STREAMS 128
#define MAX_STREAM_PAYLOAD 1600    

typedef struct _NAB_STREAM
{
    ULONG       ulType;
    ULONG       ulSize;
    ULONG       ulProtoID;
    BOOLEAN     fUsed;
    ULONG       groupID;
    PUCHAR      pszBuffer;
    ULONG       ulcbSize;
    ULONG       ulOffset;
    ULONG       ulFrameState;
    LIST_ENTRY  Linkage;
    ULONG       ulIPStreamIndex;
    PHW_STREAM_REQUEST_BLOCK pSrb;
    NAB_COMPRESSION_STATE NabCState[MAX_IP_STREAMS];
    NAB_HEADER_CACHE NabHeader[MAX_IP_STREAMS];
    ULONG       ulMpegCrc;
    ULONG       ulCrcBytesIndex;
    ULONG       ulLastCrcBytes;
    LARGE_INTEGER liLastTimeUsed;
    CHAR        rgBuf[MAX_STREAM_PAYLOAD];
} NAB_STREAM, *PNAB_STREAM;



///////////////////////////////////////////////////////////////////////////////////////
//
//
// Prototypes
//
//
VOID
vCheckNabStreamLife (
    PSLIP_FILTER pFilter
    );


NTSTATUS
ntCreateNabStreamContext(
    PSLIP_FILTER pFilter,
    ULONG groupID,
    PNAB_STREAM *ppNabStream
    );


NTSTATUS
ntGetNdisPacketForStream (
    PSLIP_FILTER pFilter,
    PNAB_STREAM pNabStream
    );

VOID
vDestroyNabStreamContext(
   PSLIP_FILTER pUser,
   PNAB_STREAM pNabStream,
   BOOLEAN fRemoveFromList
   );

NTSTATUS
ntAllocateNabStreamContext(
    PNAB_STREAM *ppNabStream
    );

NTSTATUS
ntNabtsRecv(
    PSLIP_FILTER pFilter,
    PNABTSFEC_BUFFER pNabData
    );

VOID
CancelNabStreamSrb (
    PSLIP_FILTER pFilter,
    PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID
DeleteNabStreamQueue (
    PSLIP_FILTER pFilter
    );


VOID
MpegCrcUpdate (
    ULONG * crc,
    UINT uiCount,
    UCHAR * pText
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\codec\msyuv\debug.h ===
/*
 * debug macros
 *
 */

#if DBG
   #ifndef _DEBUG
      #define _DEBUG
   #endif
#endif

#ifndef _DEBUGH
#define _DEBUGH

#ifdef _DEBUG

    #define ModuleDebugLevel MsYuvDebugLevel
    #define ModuleDebugStamp MsYuvDebugStamp


    extern DWORD ModuleDebugLevel;
    extern DWORD ModuleStamp;

	void PlaceStamp(TCHAR * lpszFile, int iLineNum);
    void dbgPrintf(TCHAR * szFormat, ...);

    #define dprintf1(_x_) {if (ModuleDebugLevel >= 1) {PlaceStamp(__FILE__,__LINE__);dbgPrintf _x_ ;}}
    #define dprintf2(_x_) {if (ModuleDebugLevel >= 2) {PlaceStamp(__FILE__,__LINE__);dbgPrintf _x_ ;}}
    #define dprintf3(_x_) {if (ModuleDebugLevel >= 3) {PlaceStamp(__FILE__,__LINE__);dbgPrintf _x_ ;}}
    #define dprintf4(_x_) {if (ModuleDebugLevel >= 4) {PlaceStamp(__FILE__,__LINE__);dbgPrintf _x_ ;}}

	//BOOL FAR PASCAL _Assert(BOOL fExpr, LPSTR szFile, int iLine, LPSTR szExpr);
	BOOL FAR PASCAL _Assert(BOOL fExpr, TCHAR * szFile, int iLine, TCHAR * szExpr);

	#define ASSERT(expr)  _Assert((expr), __FILE__, __LINE__, #expr)

#else

	#define ASSERT(expr)

    #define dbgPrintf 0?0:
    #define dprintf(_x_)
    #define dprintf1(_x_)
    #define dprintf2(_x_)
    #define dprintf3(_x_)
    #define dprintf4(_x_)		

#endif

#endif // DEBUGH
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\codec\msyuv\msyuv.h ===
/*
 * msyuv.h   Microsoft YUV Codec
 *
 * Copyright (c) Microsoft 1993.
 */

#include <msviddrv.h>
#include <vfw.h>
#include "vcstruct.h"
#include "vcuser.h"
#include "debug.h"


#ifndef FOURCC_UYVY
#define FOURCC_UYVY		mmioFOURCC('U', 'Y', 'V', 'Y')  // UYVY
#endif

#ifndef FOURCC_YUY2
#define FOURCC_YUY2		mmioFOURCC('Y', 'U', 'Y', '2')  // YUYV
#endif

#ifndef FOURCC_YVYU
#define FOURCC_YVYU		mmioFOURCC('Y', 'V', 'Y', 'U')  // YUYV
#endif

typedef struct {
    DWORD   dwFlags;    // flags from ICOPEN
    DWORD 	dwFormat;	// format that pXlate is built for (FOURCC)
    PVOID	pXlate;		// xlate table (for decompress)
    BOOL 	bRGB565;	// true if 5-6-5 format output (otherwise 555)

    /* support for drawing */
    VCUSER_HANDLE vh;
    HWND	hwnd;
    RECT 	rcSource;
    RECT	rcDest;
    HBRUSH	hKeyBrush;


} INSTINFO, *PINSTINFO;




/*
 * message processing functions in msyuv.c
 */
INSTINFO * NEAR PASCAL Open(ICOPEN FAR * icinfo);
DWORD NEAR PASCAL Close(INSTINFO * pinst);
BOOL NEAR PASCAL QueryAbout(INSTINFO * pinst);
DWORD NEAR PASCAL About(INSTINFO * pinst, HWND hwnd);
BOOL NEAR PASCAL QueryConfigure(INSTINFO * pinst);
DWORD NEAR PASCAL Configure(INSTINFO * pinst, HWND hwnd);
DWORD NEAR PASCAL GetState(INSTINFO * pinst, LPVOID pv, DWORD dwSize);
DWORD NEAR PASCAL SetState(INSTINFO * pinst, LPVOID pv, DWORD dwSize);
DWORD NEAR PASCAL GetInfo(INSTINFO * pinst, ICINFO FAR *icinfo, DWORD dwSize);
DWORD FAR PASCAL CompressQuery(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut);
DWORD FAR PASCAL CompressGetFormat(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut);
DWORD FAR PASCAL CompressBegin(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut);
DWORD FAR PASCAL CompressGetSize(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut);
DWORD FAR PASCAL Compress(INSTINFO * pinst, ICCOMPRESS FAR *icinfo, DWORD dwSize);
DWORD FAR PASCAL CompressEnd(INSTINFO * pinst);
DWORD NEAR PASCAL DecompressQuery(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut);
DWORD NEAR PASCAL DecompressGetFormat(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut);
DWORD NEAR PASCAL DecompressBegin(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut);
DWORD NEAR PASCAL Decompress(INSTINFO * pinst, ICDECOMPRESS FAR *icinfo, DWORD dwSize);
DWORD NEAR PASCAL DecompressGetPalette(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut);
DWORD NEAR PASCAL DecompressEnd(INSTINFO * pinst);

DWORD NEAR PASCAL DecompressExQuery(INSTINFO * pinst, ICDECOMPRESSEX * pICD, DWORD dwICDSize);
DWORD NEAR PASCAL DecompressEx(INSTINFO * pinst, ICDECOMPRESSEX * pICD, DWORD dwICDSize);
DWORD NEAR PASCAL DecompressExBegin(INSTINFO * pinst, ICDECOMPRESSEX * pICD, DWORD dwICDSize);
DWORD NEAR PASCAL DecompressExEnd(INSTINFO * pinst);


DWORD DrawQuery(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut);
DWORD DrawBegin(INSTINFO * pinst,ICDRAWBEGIN FAR *icinfo, DWORD dwSize);
DWORD Draw(INSTINFO * pinst, ICDRAW FAR *icinfo, DWORD dwSize);
DWORD DrawEnd(INSTINFO * pinst);
DWORD DrawWindow(PINSTINFO pinst, PRECT prc);



/*
 * build UYVY -> RGB555 xlate table
 */
LPVOID BuildUYVYToRGB555(PINSTINFO pinst);

// build UYVY -> RGB32 xlate table
LPVOID BuildUYVYToRGB32(PINSTINFO pinst);

// build UYVY -> RGB565
LPVOID BuildUYVYToRGB565(PINSTINFO pinst);


// build UYVY -> RGB8
LPVOID BuildUYVYToRGB8(PINSTINFO pinst);

VOID UYVYToRGB32(PINSTINFO pinst,
		 LPBITMAPINFOHEADER lpbiInput,
		 LPVOID lpInput,
		 LPBITMAPINFOHEADER lpbiOutput,
		 LPVOID lpOutput);

VOID UYVYToRGB24(PINSTINFO pinst,
		 LPBITMAPINFOHEADER lpbiInput,
		 LPVOID lpInput,
		 LPBITMAPINFOHEADER lpbiOutput,
		 LPVOID lpOutput);

/*
 * translate one frame from uyvy to rgb 555 or 565
 */

VOID UYVYToRGB16(PINSTINFO pinst,
		 LPBITMAPINFOHEADER lpbiInput,
		 LPVOID lpInput,
		 LPBITMAPINFOHEADER lpbiOutput,
		 LPVOID lpOutput);

/*
 * translate one frame from uyvy to RGB8
 */

VOID UYVYToRGB8(PINSTINFO pinst,
		 LPBITMAPINFOHEADER lpbiInput,
		 LPVOID lpInput,
		 LPBITMAPINFOHEADER lpbiOutput,
		 LPVOID lpOutput);

VOID FreeXlate(PINSTINFO pinst);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\codec\msyuv\debug.c ===
/* Debug.c
 *
 * Debug printf and assertion functions
 */


#include <windows.h>
#include <stdarg.h>
#include <stdio.h>
#include "debug.h"



#ifdef _DEBUG

DWORD ModuleDebugLevel = 1;  // 0 to turn it off, but valid level go up to 4
DWORD ModuleDebugStamp = 0;  // Turn on to print __FILE__.__LINE__

/* _Assert(fExpr, szFile, iLine)
 *
 * If <fExpr> is TRUE, then do nothing.  If <fExpr> is FALSE, then display
 * an "assertion failed" message box allowing the user to abort the program,
 * enter the debugger (the "Retry" button), or igore the error.
 *
 * <szFile> is the name of the source file; <iLine> is the line number
 * containing the _Assert() call.
 */
#ifdef I386
#pragma optimize("", off)
#endif

BOOL FAR PASCAL
_Assert(
    BOOL fExpr, 
	TCHAR * szFile, //LPSTR szFile, 
	int iLine, 
	TCHAR * szExpr) // LPSTR szExpr)
{
	static TCHAR achTitle[256];
	int		id;

	/* check if assertion failed */
	if (fExpr)
		return fExpr;

	/* display error message */
	wsprintf(achTitle, TEXT("AssertFailed: %d:%s\n"), iLine, (LPSTR) szFile);
	id = MessageBox(NULL, szExpr, achTitle, MB_SYSTEMMODAL | MB_ICONHAND | MB_ABORTRETRYIGNORE);

	/* abort, debug, or ignore */
	switch (id)
	{

	case IDABORT:

		/* kill this application */
		ExitProcess(1);
		break;

	case IDRETRY:

		/* break into the debugger */
		DebugBreak();
		break;

	case IDIGNORE:

		/* ignore the assertion failure */
		break;

	}
	
	return FALSE;
}

#ifdef I386
#pragma optimize("", on)
#endif


DWORD dbgSetDebugLevel(int dbgLevel) {
    DWORD oldlevel = ModuleDebugLevel;
    ModuleDebugLevel = dbgLevel;
    return(oldlevel);
}


void PlaceStamp(
    TCHAR * lpszFile, // LPSTR lpszFile, 
	int iLineNum)
{
	TCHAR	szBuf[256];

	int i;
	TCHAR * lpszFilename = lpszFile;

	if (ModuleDebugLevel == 0) 
		return;

	if(ModuleDebugStamp) {	

    	for (i=0; i < lstrlen(lpszFile); i++)
	    	if (*(lpszFile+i) == '\\')
		    	lpszFilename = (lpszFile+i);
		
		if(wsprintf(szBuf, TEXT("MsYuv %12s %4d "), lpszFilename, iLineNum) > 0)
	         OutputDebugString(szBuf);

	} else {
	     OutputDebugString(TEXT("MsYuv.."));
	}
}

void dbgPrintf(TCHAR * szFormat, ...)
{
 	TCHAR	szBuf[256];
	va_list va;

	if (ModuleDebugLevel == 0)
		return;

	va_start(va, szFormat);
	wvsprintf(
		szBuf, 
		szFormat, 
		va);
	va_end(va);
	OutputDebugString(szBuf);
}


#endif  // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\codec\msyuv\rgb8lut.h ===
//
// Color Look Up Table (cLUTs) used to convert UYVY to RGB8
//
unsigned char const PalTable[] = {
  0,   0,   0,  PC_NOCOLLAPSE,     //    0
128,   0,   0,  PC_NOCOLLAPSE,     //    1
  0, 128,   0,  PC_NOCOLLAPSE,     //    2
128, 128,   0,  PC_NOCOLLAPSE,     //    3
  0,   0, 128,  PC_NOCOLLAPSE,     //    4
128,   0, 128,  PC_NOCOLLAPSE,     //    5
  0, 128, 128,  PC_NOCOLLAPSE,     //    6
192, 192, 192,  PC_NOCOLLAPSE,     //    7
192, 220, 192,  PC_NOCOLLAPSE,     //    8
166, 202, 240,  PC_NOCOLLAPSE,     //    9

  0,   0,   0,  PC_NOCOLLAPSE,     //   10
  0,   0,   0,  PC_NOCOLLAPSE,     //   11
  0,   0,   0,  PC_NOCOLLAPSE,     //   12
  0,   0,   0,  PC_NOCOLLAPSE,     //   13
  0,   0,   0,  PC_NOCOLLAPSE,     //   14
  0,   0,   0,  PC_NOCOLLAPSE,     //   15
  0,  67,   0,  PC_NOCOLLAPSE,     //   16
  0,  41,   0,  PC_NOCOLLAPSE,     //   17
 35,  15,   0,  PC_NOCOLLAPSE,     //   18
 86,   0,   0,  PC_NOCOLLAPSE,     //   19
  0,  55,   0,  PC_NOCOLLAPSE,     //   20
  0,  29,   0,  PC_NOCOLLAPSE,     //   21
 35,   3,   0,  PC_NOCOLLAPSE,     //   22
 86,   0,   0,  PC_NOCOLLAPSE,     //   23
  0,  42,  42,  PC_NOCOLLAPSE,     //   24
  0,  16,  42,  PC_NOCOLLAPSE,     //   25
 35,   0,  42,  PC_NOCOLLAPSE,     //   26
 86,   0,  42,  PC_NOCOLLAPSE,     //   27
  0,  30, 106,  PC_NOCOLLAPSE,     //   28
  0,   4, 106,  PC_NOCOLLAPSE,     //   29
 35,   0, 106,  PC_NOCOLLAPSE,     //   30
 86,   0, 106,  PC_NOCOLLAPSE,     //   31
  0,  86,   0,  PC_NOCOLLAPSE,     //   32
  2,  60,   0,  PC_NOCOLLAPSE,     //   33
 53,  34,   0,  PC_NOCOLLAPSE,     //   34
105,   8,   0,  PC_NOCOLLAPSE,     //   35
  0,  73,   0,  PC_NOCOLLAPSE,     //   36
  2,  47,   0,  PC_NOCOLLAPSE,     //   37
 53,  21,   0,  PC_NOCOLLAPSE,     //   38
105,   0,   0,  PC_NOCOLLAPSE,     //   39
  0,  61,  60,  PC_NOCOLLAPSE,     //   40
  2,  35,  60,  PC_NOCOLLAPSE,     //   41
 53,   9,  60,  PC_NOCOLLAPSE,     //   42
105,   0,  60,  PC_NOCOLLAPSE,     //   43
  0,  48, 125,  PC_NOCOLLAPSE,     //   44
  2,  22, 125,  PC_NOCOLLAPSE,     //   45
 53,   0, 125,  PC_NOCOLLAPSE,     //   46
105,   0, 125,  PC_NOCOLLAPSE,     //   47
  0, 104,   0,  PC_NOCOLLAPSE,     //   48
 21,  78,   0,  PC_NOCOLLAPSE,     //   49
 72,  52,   0,  PC_NOCOLLAPSE,     //   50
123,  26,   0,  PC_NOCOLLAPSE,     //   51
  0,  92,  14,  PC_NOCOLLAPSE,     //   52
 21,  66,  14,  PC_NOCOLLAPSE,     //   53
 72,  40,  14,  PC_NOCOLLAPSE,     //   54
123,  14,  14,  PC_NOCOLLAPSE,     //   55
  0,  79,  79,  PC_NOCOLLAPSE,     //   56
 21,  53,  79,  PC_NOCOLLAPSE,     //   57
 72,  27,  79,  PC_NOCOLLAPSE,     //   58
123,   1,  79,  PC_NOCOLLAPSE,     //   59
  0,  67, 143,  PC_NOCOLLAPSE,     //   60
 21,  41, 143,  PC_NOCOLLAPSE,     //   61
 72,  15, 143,  PC_NOCOLLAPSE,     //   62
123,   0, 143,  PC_NOCOLLAPSE,     //   63
  0, 123,   0,  PC_NOCOLLAPSE,     //   64
 40,  97,   0,  PC_NOCOLLAPSE,     //   65
 91,  71,   0,  PC_NOCOLLAPSE,     //   66
142,  45,   0,  PC_NOCOLLAPSE,     //   67
  0, 110,  33,  PC_NOCOLLAPSE,     //   68
 40,  84,  33,  PC_NOCOLLAPSE,     //   69
 91,  58,  33,  PC_NOCOLLAPSE,     //   70
142,  32,  33,  PC_NOCOLLAPSE,     //   71
  0,  98,  97,  PC_NOCOLLAPSE,     //   72
 40,  72,  97,  PC_NOCOLLAPSE,     //   73
 91,  46,  97,  PC_NOCOLLAPSE,     //   74
142,  20,  97,  PC_NOCOLLAPSE,     //   75
  0,  85, 162,  PC_NOCOLLAPSE,     //   76
 40,  59, 162,  PC_NOCOLLAPSE,     //   77
 91,  33, 162,  PC_NOCOLLAPSE,     //   78
142,   7, 162,  PC_NOCOLLAPSE,     //   79
  7, 142,   0,  PC_NOCOLLAPSE,     //   80
 58, 116,   0,  PC_NOCOLLAPSE,     //   81
109,  90,   0,  PC_NOCOLLAPSE,     //   82
160,  64,   0,  PC_NOCOLLAPSE,     //   83
  7, 129,  52,  PC_NOCOLLAPSE,     //   84
 58, 103,  52,  PC_NOCOLLAPSE,     //   85
109,  77,  52,  PC_NOCOLLAPSE,     //   86
160,  51,  52,  PC_NOCOLLAPSE,     //   87
  7, 117, 116,  PC_NOCOLLAPSE,     //   88
 58,  91, 116,  PC_NOCOLLAPSE,     //   89
109,  65, 116,  PC_NOCOLLAPSE,     //   90
160,  39, 116,  PC_NOCOLLAPSE,     //   91
  7, 104, 181,  PC_NOCOLLAPSE,     //   92
 58,  78, 181,  PC_NOCOLLAPSE,     //   93
109,  52, 181,  PC_NOCOLLAPSE,     //   94
160,  26, 181,  PC_NOCOLLAPSE,     //   95
 26, 160,   6,  PC_NOCOLLAPSE,     //   96
 77, 134,   6,  PC_NOCOLLAPSE,     //   97
128, 108,   6,  PC_NOCOLLAPSE,     //   98
179,  82,   6,  PC_NOCOLLAPSE,     //   99
 26, 148,  70,  PC_NOCOLLAPSE,     //  100
 77, 122,  70,  PC_NOCOLLAPSE,     //  101
128,  96,  70,  PC_NOCOLLAPSE,     //  102
179,  70,  70,  PC_NOCOLLAPSE,     //  103
 26, 135, 135,  PC_NOCOLLAPSE,     //  104
 77, 109, 135,  PC_NOCOLLAPSE,     //  105
128,  83, 135,  PC_NOCOLLAPSE,     //  106
179,  57, 135,  PC_NOCOLLAPSE,     //  107
 26, 123, 199,  PC_NOCOLLAPSE,     //  108
 77,  97, 199,  PC_NOCOLLAPSE,     //  109
128,  71, 199,  PC_NOCOLLAPSE,     //  110
179,  45, 199,  PC_NOCOLLAPSE,     //  111
 44, 179,  24,  PC_NOCOLLAPSE,     //  112
 96, 153,  24,  PC_NOCOLLAPSE,     //  113
147, 127,  24,  PC_NOCOLLAPSE,     //  114
198, 101,  24,  PC_NOCOLLAPSE,     //  115
 44, 166,  89,  PC_NOCOLLAPSE,     //  116
 96, 140,  89,  PC_NOCOLLAPSE,     //  117
147, 114,  89,  PC_NOCOLLAPSE,     //  118
198,  88,  89,  PC_NOCOLLAPSE,     //  119
 44, 154, 153,  PC_NOCOLLAPSE,     //  120
 96, 128, 153,  PC_NOCOLLAPSE,     //  121
147, 102, 153,  PC_NOCOLLAPSE,     //  122
198,  76, 153,  PC_NOCOLLAPSE,     //  123
 44, 141, 218,  PC_NOCOLLAPSE,     //  124
 96, 115, 218,  PC_NOCOLLAPSE,     //  125
147,  89, 218,  PC_NOCOLLAPSE,     //  126
198,  63, 218,  PC_NOCOLLAPSE,     //  127
 63, 198,  43,  PC_NOCOLLAPSE,     //  128
114, 172,  43,  PC_NOCOLLAPSE,     //  129
165, 146,  43,  PC_NOCOLLAPSE,     //  130
216, 120,  43,  PC_NOCOLLAPSE,     //  131
 63, 185, 107,  PC_NOCOLLAPSE,     //  132
114, 159, 107,  PC_NOCOLLAPSE,     //  133
165, 133, 107,  PC_NOCOLLAPSE,     //  134
216, 107, 107,  PC_NOCOLLAPSE,     //  135
 63, 172, 172,  PC_NOCOLLAPSE,     //  136
114, 146, 172,  PC_NOCOLLAPSE,     //  137
165, 120, 172,  PC_NOCOLLAPSE,     //  138
216,  94, 172,  PC_NOCOLLAPSE,     //  139
 63, 160, 237,  PC_NOCOLLAPSE,     //  140
114, 134, 237,  PC_NOCOLLAPSE,     //  141
165, 108, 237,  PC_NOCOLLAPSE,     //  142
216,  82, 237,  PC_NOCOLLAPSE,     //  143
 82, 216,  62,  PC_NOCOLLAPSE,     //  144
133, 190,  62,  PC_NOCOLLAPSE,     //  145
184, 164,  62,  PC_NOCOLLAPSE,     //  146
235, 138,  62,  PC_NOCOLLAPSE,     //  147
 82, 204, 126,  PC_NOCOLLAPSE,     //  148
133, 178, 126,  PC_NOCOLLAPSE,     //  149
184, 152, 126,  PC_NOCOLLAPSE,     //  150
235, 126, 126,  PC_NOCOLLAPSE,     //  151
 82, 191, 191,  PC_NOCOLLAPSE,     //  152
133, 165, 191,  PC_NOCOLLAPSE,     //  153
184, 139, 191,  PC_NOCOLLAPSE,     //  154
235, 113, 191,  PC_NOCOLLAPSE,     //  155
 82, 179, 255,  PC_NOCOLLAPSE,     //  156
133, 153, 255,  PC_NOCOLLAPSE,     //  157
184, 127, 255,  PC_NOCOLLAPSE,     //  158
235, 101, 255,  PC_NOCOLLAPSE,     //  159
100, 235,  80,  PC_NOCOLLAPSE,     //  160
151, 209,  80,  PC_NOCOLLAPSE,     //  161
203, 183,  80,  PC_NOCOLLAPSE,     //  162
254, 157,  80,  PC_NOCOLLAPSE,     //  163
100, 222, 145,  PC_NOCOLLAPSE,     //  164
151, 196, 145,  PC_NOCOLLAPSE,     //  165
203, 170, 145,  PC_NOCOLLAPSE,     //  166
254, 144, 145,  PC_NOCOLLAPSE,     //  167
100, 210, 209,  PC_NOCOLLAPSE,     //  168
151, 184, 209,  PC_NOCOLLAPSE,     //  169
203, 158, 209,  PC_NOCOLLAPSE,     //  170
254, 132, 209,  PC_NOCOLLAPSE,     //  171
100, 197, 255,  PC_NOCOLLAPSE,     //  172
151, 171, 255,  PC_NOCOLLAPSE,     //  173
203, 145, 255,  PC_NOCOLLAPSE,     //  174
254, 119, 255,  PC_NOCOLLAPSE,     //  175
119, 253,  99,  PC_NOCOLLAPSE,     //  176
170, 227,  99,  PC_NOCOLLAPSE,     //  177
221, 201,  99,  PC_NOCOLLAPSE,     //  178
255, 175,  99,  PC_NOCOLLAPSE,     //  179
119, 241, 163,  PC_NOCOLLAPSE,     //  180
170, 215, 163,  PC_NOCOLLAPSE,     //  181
221, 189, 163,  PC_NOCOLLAPSE,     //  182
255, 163, 163,  PC_NOCOLLAPSE,     //  183
119, 228, 228,  PC_NOCOLLAPSE,     //  184
170, 202, 228,  PC_NOCOLLAPSE,     //  185
221, 176, 228,  PC_NOCOLLAPSE,     //  186
255, 150, 228,  PC_NOCOLLAPSE,     //  187
119, 216, 255,  PC_NOCOLLAPSE,     //  188
170, 190, 255,  PC_NOCOLLAPSE,     //  189
221, 164, 255,  PC_NOCOLLAPSE,     //  190
255, 138, 255,  PC_NOCOLLAPSE,     //  191
138, 255, 117,  PC_NOCOLLAPSE,     //  192
189, 246, 117,  PC_NOCOLLAPSE,     //  193
240, 220, 117,  PC_NOCOLLAPSE,     //  194
255, 194, 117,  PC_NOCOLLAPSE,     //  195
138, 255, 182,  PC_NOCOLLAPSE,     //  196
189, 234, 182,  PC_NOCOLLAPSE,     //  197
240, 208, 182,  PC_NOCOLLAPSE,     //  198
255, 181, 182,  PC_NOCOLLAPSE,     //  199
138, 247, 247,  PC_NOCOLLAPSE,     //  200
189, 221, 247,  PC_NOCOLLAPSE,     //  201
240, 195, 247,  PC_NOCOLLAPSE,     //  202
255, 169, 247,  PC_NOCOLLAPSE,     //  203
138, 234, 255,  PC_NOCOLLAPSE,     //  204
189, 208, 255,  PC_NOCOLLAPSE,     //  205
240, 182, 255,  PC_NOCOLLAPSE,     //  206
255, 156, 255,  PC_NOCOLLAPSE,     //  207
156, 255, 136,  PC_NOCOLLAPSE,     //  208
207, 255, 136,  PC_NOCOLLAPSE,     //  209
255, 239, 136,  PC_NOCOLLAPSE,     //  210
255, 213, 136,  PC_NOCOLLAPSE,     //  211
156, 255, 201,  PC_NOCOLLAPSE,     //  212
207, 252, 201,  PC_NOCOLLAPSE,     //  213
255, 226, 201,  PC_NOCOLLAPSE,     //  214
255, 200, 201,  PC_NOCOLLAPSE,     //  215
156, 255, 255,  PC_NOCOLLAPSE,     //  216
207, 240, 255,  PC_NOCOLLAPSE,     //  217
255, 214, 255,  PC_NOCOLLAPSE,     //  218
255, 188, 255,  PC_NOCOLLAPSE,     //  219
156, 253, 255,  PC_NOCOLLAPSE,     //  220
207, 227, 255,  PC_NOCOLLAPSE,     //  221
255, 201, 255,  PC_NOCOLLAPSE,     //  222
255, 175, 255,  PC_NOCOLLAPSE,     //  223
175, 255, 155,  PC_NOCOLLAPSE,     //  224
226, 255, 155,  PC_NOCOLLAPSE,     //  225
255, 255, 155,  PC_NOCOLLAPSE,     //  226
255, 231, 155,  PC_NOCOLLAPSE,     //  227
175, 255, 219,  PC_NOCOLLAPSE,     //  228
226, 255, 219,  PC_NOCOLLAPSE,     //  229
255, 245, 219,  PC_NOCOLLAPSE,     //  230
255, 219, 219,  PC_NOCOLLAPSE,     //  231
175, 255, 255,  PC_NOCOLLAPSE,     //  232
226, 255, 255,  PC_NOCOLLAPSE,     //  233
255, 232, 255,  PC_NOCOLLAPSE,     //  234
255, 206, 255,  PC_NOCOLLAPSE,     //  235
175, 255, 255,  PC_NOCOLLAPSE,     //  236
226, 246, 255,  PC_NOCOLLAPSE,     //  237
255, 220, 255,  PC_NOCOLLAPSE,     //  238
255, 194, 255,  PC_NOCOLLAPSE,     //  239
  0,   0,   0,  PC_NOCOLLAPSE,     //  240
  0,   0,   0,  PC_NOCOLLAPSE,     //  241
  0,   0,   0,  PC_NOCOLLAPSE,     //  242
  0,   0,   0,  PC_NOCOLLAPSE,     //  243
  0,   0,   0,  PC_NOCOLLAPSE,     //  244
  0,   0,   0,  PC_NOCOLLAPSE,     //  245

255, 251, 240,  PC_NOCOLLAPSE,     //  246
160, 160, 164,  PC_NOCOLLAPSE,     //  247
128, 128, 128,  PC_NOCOLLAPSE,     //  248
255,   0,   0,  PC_NOCOLLAPSE,     //  249
  0, 255,   0,  PC_NOCOLLAPSE,     //  250
255, 255,   0,  PC_NOCOLLAPSE,     //  251
  0,   0, 255,  PC_NOCOLLAPSE,     //  252
255,   0, 255,  PC_NOCOLLAPSE,     //  253
  0, 255, 255,  PC_NOCOLLAPSE,     //  254
255, 255, 255,  PC_NOCOLLAPSE      //  255
};

unsigned long yLUT_0[272] = {
    0x00000010, 0x00000010, 0x00000010, 0x00000010, 0x00000010, 0x00000010, 0x00000010, 0x00000010, //  00
    0x00000010, 0x00000010, 0x00000010, 0x00000010, 0x00000010, 0x00000010, 0x00000010, 0x00000010, //  01
    0x00000010, 0x00000010, 0x00000010, 0x00000010, 0x00000010, 0x00000010, 0x00000010, 0x00000010, //  02
    0x00000010, 0x00000010, 0x00000010, 0x00000010, 0x00000010, 0x00000010, 0x00000010, 0x00000010, //  03
    0x00000010, 0x00000010, 0x00000010, 0x00000010, 0x00000010, 0x00000010, 0x00000010, 0x00000010, //  04
    0x00000020, 0x00000020, 0x00000020, 0x00000020, 0x00000020, 0x00000020, 0x00000020, 0x00000020, //  05
    0x00000020, 0x00000020, 0x00000020, 0x00000020, 0x00000030, 0x00000030, 0x00000030, 0x00000030, //  06
    0x00000030, 0x00000030, 0x00000030, 0x00000030, 0x00000030, 0x00000030, 0x00000030, 0x00000030, //  07
    0x00000030, 0x00000030, 0x00000030, 0x00000030, 0x00000040, 0x00000040, 0x00000040, 0x00000040, //  08
    0x00000040, 0x00000040, 0x00000040, 0x00000040, 0x00000040, 0x00000040, 0x00000040, 0x00000040, //  10
    0x00000040, 0x00000040, 0x00000040, 0x00000040, 0x00000050, 0x00000050, 0x00000050, 0x00000050, //  11
    0x00000050, 0x00000050, 0x00000050, 0x00000050, 0x00000050, 0x00000050, 0x00000050, 0x00000050, //  12
    0x00000050, 0x00000050, 0x00000050, 0x00000050, 0x00000060, 0x00000060, 0x00000060, 0x00000060, //  13
    0x00000060, 0x00000060, 0x00000060, 0x00000060, 0x00000060, 0x00000060, 0x00000060, 0x00000060, //  14
    0x00000060, 0x00000060, 0x00000060, 0x00000060, 0x00000070, 0x00000070, 0x00000070, 0x00000070, //  15
    0x00000070, 0x00000070, 0x00000070, 0x00000070, 0x00000070, 0x00000070, 0x00000070, 0x00000070, //  16
    0x00000070, 0x00000070, 0x00000070, 0x00000070, 0x00000080, 0x00000080, 0x00000080, 0x00000080, //  17
    0x00000080, 0x00000080, 0x00000080, 0x00000080, 0x00000080, 0x00000080, 0x00000080, 0x00000080, //  18
    0x00000080, 0x00000080, 0x00000080, 0x00000080, 0x00000090, 0x00000090, 0x00000090, 0x00000090, //  19
    0x00000090, 0x00000090, 0x00000090, 0x00000090, 0x00000090, 0x00000090, 0x00000090, 0x00000090, //  20
    0x00000090, 0x00000090, 0x00000090, 0x00000090, 0x000000A0, 0x000000A0, 0x000000A0, 0x000000A0, //  21
    0x000000A0, 0x000000A0, 0x000000A0, 0x000000A0, 0x000000A0, 0x000000A0, 0x000000A0, 0x000000A0, //  22
    0x000000A0, 0x000000A0, 0x000000A0, 0x000000A0, 0x000000B0, 0x000000B0, 0x000000B0, 0x000000B0, //  23
    0x000000B0, 0x000000B0, 0x000000B0, 0x000000B0, 0x000000B0, 0x000000B0, 0x000000B0, 0x000000B0, //  24
    0x000000B0, 0x000000B0, 0x000000B0, 0x000000B0, 0x000000C0, 0x000000C0, 0x000000C0, 0x000000C0, //  25
    0x000000C0, 0x000000C0, 0x000000C0, 0x000000C0, 0x000000C0, 0x000000C0, 0x000000C0, 0x000000C0, //  26
    0x000000C0, 0x000000C0, 0x000000C0, 0x000000C0, 0x000000D0, 0x000000D0, 0x000000D0, 0x000000D0, //  27
    0x000000D0, 0x000000D0, 0x000000D0, 0x000000D0, 0x000000D0, 0x000000D0, 0x000000D0, 0x000000D0, //  28
    0x000000D0, 0x000000D0, 0x000000D0, 0x000000D0, 0x000000E0, 0x000000E0, 0x000000E0, 0x000000E0, //  29
    0x000000E0, 0x000000E0, 0x000000E0, 0x000000E0, 0x000000E0, 0x000000E0, 0x000000E0, 0x000000E0, //  30
    0x000000E0, 0x000000E0, 0x000000E0, 0x000000E0, 0x000000E0, 0x000000E0, 0x000000E0, 0x000000E0, //  31
    0x000000E0, 0x000000E0, 0x000000E0, 0x000000E0, 0x000000E0, 0x000000E0, 0x000000E0, 0x000000E0, //  32
    0x000000E0, 0x000000E0, 0x000000E0, 0x000000E0, 0x000000E0, 0x000000E0, 0x000000E0, 0x000000E0, //  33
    0x000000E0, 0x000000E0, 0x000000E0, 0x000000E0, 0x000000E0, 0x000000E0, 0x000000E0, 0x000000E0  //  34
};

unsigned long yLUT_1[272] = {
    0x00001000, 0x00001000, 0x00001000, 0x00001000, 0x00001000, 0x00001000, 0x00001000, 0x00001000, //  00
    0x00001000, 0x00001000, 0x00001000, 0x00001000, 0x00001000, 0x00001000, 0x00001000, 0x00001000, //  01
    0x00001000, 0x00001000, 0x00001000, 0x00001000, 0x00001000, 0x00001000, 0x00001000, 0x00001000, //  02
    0x00001000, 0x00001000, 0x00001000, 0x00001000, 0x00001000, 0x00001000, 0x00001000, 0x00001000, //  03
    0x00001000, 0x00001000, 0x00001000, 0x00001000, 0x00001000, 0x00001000, 0x00001000, 0x00001000, //  04
    0x00002000, 0x00002000, 0x00002000, 0x00002000, 0x00002000, 0x00002000, 0x00002000, 0x00002000, //  05
    0x00002000, 0x00002000, 0x00002000, 0x00002000, 0x00003000, 0x00003000, 0x00003000, 0x00003000, //  06
    0x00003000, 0x00003000, 0x00003000, 0x00003000, 0x00003000, 0x00003000, 0x00003000, 0x00003000, //  07
    0x00003000, 0x00003000, 0x00003000, 0x00003000, 0x00004000, 0x00004000, 0x00004000, 0x00004000, //  08
    0x00004000, 0x00004000, 0x00004000, 0x00004000, 0x00004000, 0x00004000, 0x00004000, 0x00004000, //  10
    0x00004000, 0x00004000, 0x00004000, 0x00004000, 0x00005000, 0x00005000, 0x00005000, 0x00005000, //  11
    0x00005000, 0x00005000, 0x00005000, 0x00005000, 0x00005000, 0x00005000, 0x00005000, 0x00005000, //  12
    0x00005000, 0x00005000, 0x00005000, 0x00005000, 0x00006000, 0x00006000, 0x00006000, 0x00006000, //  13
    0x00006000, 0x00006000, 0x00006000, 0x00006000, 0x00006000, 0x00006000, 0x00006000, 0x00006000, //  14
    0x00006000, 0x00006000, 0x00006000, 0x00006000, 0x00007000, 0x00007000, 0x00007000, 0x00007000, //  15
    0x00007000, 0x00007000, 0x00007000, 0x00007000, 0x00007000, 0x00007000, 0x00007000, 0x00007000, //  16
    0x00007000, 0x00007000, 0x00007000, 0x00007000, 0x00008000, 0x00008000, 0x00008000, 0x00008000, //  17
    0x00008000, 0x00008000, 0x00008000, 0x00008000, 0x00008000, 0x00008000, 0x00008000, 0x00008000, //  18
    0x00008000, 0x00008000, 0x00008000, 0x00008000, 0x00009000, 0x00009000, 0x00009000, 0x00009000, //  19
    0x00009000, 0x00009000, 0x00009000, 0x00009000, 0x00009000, 0x00009000, 0x00009000, 0x00009000, //  20
    0x00009000, 0x00009000, 0x00009000, 0x00009000, 0x0000A000, 0x0000A000, 0x0000A000, 0x0000A000, //  21
    0x0000A000, 0x0000A000, 0x0000A000, 0x0000A000, 0x0000A000, 0x0000A000, 0x0000A000, 0x0000A000, //  22
    0x0000A000, 0x0000A000, 0x0000A000, 0x0000A000, 0x0000B000, 0x0000B000, 0x0000B000, 0x0000B000, //  23
    0x0000B000, 0x0000B000, 0x0000B000, 0x0000B000, 0x0000B000, 0x0000B000, 0x0000B000, 0x0000B000, //  24
    0x0000B000, 0x0000B000, 0x0000B000, 0x0000B000, 0x0000C000, 0x0000C000, 0x0000C000, 0x0000C000, //  25
    0x0000C000, 0x0000C000, 0x0000C000, 0x0000C000, 0x0000C000, 0x0000C000, 0x0000C000, 0x0000C000, //  26
    0x0000C000, 0x0000C000, 0x0000C000, 0x0000C000, 0x0000D000, 0x0000D000, 0x0000D000, 0x0000D000, //  27
    0x0000D000, 0x0000D000, 0x0000D000, 0x0000D000, 0x0000D000, 0x0000D000, 0x0000D000, 0x0000D000, //  28
    0x0000D000, 0x0000D000, 0x0000D000, 0x0000D000, 0x0000E000, 0x0000E000, 0x0000E000, 0x0000E000, //  29
    0x0000E000, 0x0000E000, 0x0000E000, 0x0000E000, 0x0000E000, 0x0000E000, 0x0000E000, 0x0000E000, //  30
    0x0000E000, 0x0000E000, 0x0000E000, 0x0000E000, 0x0000E000, 0x0000E000, 0x0000E000, 0x0000E000, //  31
    0x0000E000, 0x0000E000, 0x0000E000, 0x0000E000, 0x0000E000, 0x0000E000, 0x0000E000, 0x0000E000, //  32
    0x0000E000, 0x0000E000, 0x0000E000, 0x0000E000, 0x0000E000, 0x0000E000, 0x0000E000, 0x0000E000, //  33
    0x0000E000, 0x0000E000, 0x0000E000, 0x0000E000, 0x0000E000, 0x0000E000, 0x0000E000, 0x0000E000  //  34
};



unsigned long cLUT_R0[260] = {
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00010000, 0x00010000, 0x00010000, 0x00010000, 0x00010000, 0x00010000, 0x00010000, 0x00010000,
    0x00010100, 0x00010100, 0x00010100, 0x00010100, 0x00010100, 0x00010100, 0x00010100, 0x00010100,
    0x01010100, 0x01010100, 0x01010100, 0x01010100, 0x01010100, 0x01010100, 0x01010100, 0x01010100,
    0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101, 0x01010101,
    0x01020101, 0x01020101, 0x01020101, 0x01020101, 0x01020101, 0x01020101, 0x01020101, 0x01020101,
    0x01020201, 0x01020201, 0x01020201, 0x01020201, 0x01020201, 0x01020201, 0x01020201, 0x01020201,
    0x02020201, 0x02020201, 0x02020201, 0x02020201, 0x02020201, 0x02020201, 0x02020201, 0x02020201,
    0x02020202, 0x02020202, 0x02020202, 0x02020202, 0x02020202, 0x02020202, 0x02020202, 0x02020202,
    0x02030202, 0x02030202, 0x02030202, 0x02030202, 0x02030202, 0x02030202, 0x02030202, 0x02030202,
    0x02030302, 0x02030302, 0x02030302, 0x02030302, 0x02030302, 0x02030302, 0x02030302, 0x02030302,
    0x03030302, 0x03030302, 0x03030302, 0x03030302, 0x03030302, 0x03030302, 0x03030302, 0x03030302,
    0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303,
    0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303,
    0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303,
    0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303,
    0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303,
    0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303,
    0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303,
    0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303,
    0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303,
    0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303, 0x03030303,
    0x03030303, 0x03030303, 0x03030303, 0x03030303
};


unsigned long cLUT_B0[260] = {
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00040000, 0x00040000, 0x00040000, 0x00040000, 0x00040000, 0x00040000, 0x00040000, 0x00040000,
    0x00040400, 0x00040400, 0x00040400, 0x00040400, 0x00040400, 0x00040400, 0x00040400, 0x00040400,
    0x04040400, 0x04040400, 0x04040400, 0x04040400, 0x04040400, 0x04040400, 0x04040400, 0x04040400,
    0x04040404, 0x04040404, 0x04040404, 0x04040404, 0x04040404, 0x04040404, 0x04040404, 0x04040404,
    0x04080404, 0x04080404, 0x04080404, 0x04080404, 0x04080404, 0x04080404, 0x04080404, 0x04080404,
    0x04080804, 0x04080804, 0x04080804, 0x04080804, 0x04080804, 0x04080804, 0x04080804, 0x04080804,
    0x08080804, 0x08080804, 0x08080804, 0x08080804, 0x08080804, 0x08080804, 0x08080804, 0x08080804,
    0x08080808, 0x08080808, 0x08080808, 0x08080808, 0x08080808, 0x08080808, 0x08080808, 0x08080808,
    0x080C0808, 0x080C0808, 0x080C0808, 0x080C0808, 0x080C0808, 0x080C0808, 0x080C0808, 0x080C0808,
    0x080C0C08, 0x080C0C08, 0x080C0C08, 0x080C0C08, 0x080C0C08, 0x080C0C08, 0x080C0C08, 0x080C0C08,
    0x0C0C0C08, 0x0C0C0C08, 0x0C0C0C08, 0x0C0C0C08, 0x0C0C0C08, 0x0C0C0C08, 0x0C0C0C08, 0x0C0C0C08,
    0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C,
    0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C,
    0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C,
    0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C,
    0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C,
    0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C,
    0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C,
    0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C,
    0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C,
    0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C,
    0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C, 0x0C0C0C0C
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\codec\tsbyuv\debug.c ===
/* Debug.c
 *
 * Debug printf and assertion functions
 */


#include <windows.h>
#include <stdarg.h>
#include <stdio.h>
#include "debug.h"



#ifdef _DEBUG

DWORD ModuleDebugLevel = 1;  // 0 to turn it off, but valid level go up to 4
DWORD ModuleDebugStamp = 0;  // Turn on to print __FILE__.__LINE__

/* _Assert(fExpr, szFile, iLine)
 *
 * If <fExpr> is TRUE, then do nothing.  If <fExpr> is FALSE, then display
 * an "assertion failed" message box allowing the user to abort the program,
 * enter the debugger (the "Retry" button), or igore the error.
 *
 * <szFile> is the name of the source file; <iLine> is the line number
 * containing the _Assert() call.
 */
#ifdef I386
#pragma optimize("", off)
#endif

BOOL FAR PASCAL
_Assert(
    BOOL fExpr, 
	TCHAR * szFile, //LPSTR szFile, 
	int iLine, 
	TCHAR * szExpr) // LPSTR szExpr)
{
	static TCHAR achTitle[256];
	int		id;

	/* check if assertion failed */
	if (fExpr)
		return fExpr;

	/* display error message */
	wsprintf(achTitle, TEXT("AssertFailed: %d:%s\n"), iLine, (LPSTR) szFile);
	id = MessageBox(NULL, szExpr, achTitle, MB_SYSTEMMODAL | MB_ICONHAND | MB_ABORTRETRYIGNORE);

	/* abort, debug, or ignore */
	switch (id)
	{

	case IDABORT:

		/* kill this application */
		ExitProcess(1);
		break;

	case IDRETRY:

		/* break into the debugger */
		DebugBreak();
		break;

	case IDIGNORE:

		/* ignore the assertion failure */
		break;

	}
	
	return FALSE;
}

#ifdef I386
#pragma optimize("", on)
#endif


DWORD dbgSetDebugLevel(int dbgLevel) {
    DWORD oldlevel = ModuleDebugLevel;
    ModuleDebugLevel = dbgLevel;
    return(oldlevel);
}


void PlaceStamp(
    TCHAR * lpszFile, // LPSTR lpszFile, 
	int iLineNum)
{
	TCHAR	szBuf[256];

	int i;
	TCHAR * lpszFilename = lpszFile;

	if (ModuleDebugLevel == 0) 
		return;

	if(ModuleDebugStamp) {	

    	for (i=0; i < lstrlen(lpszFile); i++)
	    	if (*(lpszFile+i) == '\\')
		    	lpszFilename = (lpszFile+i);
		
		if(wsprintf(szBuf, TEXT("MsYuv %12s %4d "), lpszFilename, iLineNum) > 0)
	         OutputDebugString(szBuf);

	} else {
	     OutputDebugString(TEXT("MsYuv.."));
	}
}

void dbgPrintf(TCHAR * szFormat, ...)
{
 	TCHAR	szBuf[256];
	va_list va;

	if (ModuleDebugLevel == 0)
		return;

	va_start(va, szFormat);
	wvsprintf(
		szBuf, 
		szFormat, 
		va);
	va_end(va);
	OutputDebugString(szBuf);
}


#endif  // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\codec\msyuv\vcstruct.h ===
/*
 * Copyright (c) Microsoft Corporation 1993. All Rights Reserved.
 */

/*
 * vcstruct.h
 *
 * 32-bit Video Capture Driver
 *
 * This header describes structures used in the interface between the
 * kernel driver and the user-mode dll.
 *
 * Geraint Davies, Feb 93.
 */

#ifndef _VCSTRUCT_
#define _VCSTRUCT_

/* --- configuration ------------------------------------------------- */

/*
 * this structure contains configuration information generated
 * by the hardware-specific dialogs and sent to the hardware-specific
 * kernel-mode code. No one else knows its format.
 *
 * these generic structures are used so that driver writers can
 * change the user-mode dialogs and the supporting hardware-specific code
 * and yet still use the common code for interfacing between the
 * two and dealing with NT.
 */

typedef struct _CONFIG_INFO {
    ULONG ulSize;		/* size of struct including size field */
    BYTE ulData[1];		/* (ulSize - sizeof(ULONG)) bytes of data */
} CONFIG_INFO, *PCONFIG_INFO;



/* --- overlay keying and region setting ---------------------------- */


typedef struct _OVERLAY_MODE {
    ULONG ulMode;
} OVERLAY_MODE, *POVERLAY_MODE;

/* values for overlay mode field - or-ed together */
#define VCO_KEYCOLOUR		1	// true if a key colour supported
#define VCO_KEYCOLOUR_FIXED	2	// if not true, you can change it
#define VCO_KEYCOLOUR_RGB	4	// if not true, use palette index
#define VCO_SIMPLE_RECT		8	// if true, supports a single rect	
#define VCO_COMPLEX_REGION	0x10	// if true, supports complex regions.

/*
 * values indicating whether we can put data back into the frame
 * buffer for overlaying (we support the DrawFrame ioctl for the
 * Y411 and/or S422 formats
 */
#define VCO_CAN_DRAW_Y411	0x20	// 7-bit 4:1:1 yuv ala bravado
#define VCO_CAN_DRAW_S422	0x40	// 8-bit 4:2:2 yuv ala spigot
#define VCO_CAN_DRAW		0x60	// for testing: can he draw anything?


typedef struct _OVERLAY_RECTS {
    ULONG ulCount;	    // total number of rects in array
    RECT rcRects[1];	    // ulCount rectangles.
}OVERLAY_RECTS, *POVERLAY_RECTS;


typedef RGBQUAD * PRGBQUAD;

/* --- frame capture ------------------------------------------------ */

/*
 * declaring a real LPVIDEOHDR in the kernel driver is too much of a
 * pain with header files. So the kernel interface will use this declaration
 */
typedef struct _CAPTUREBUFFER {
    PUCHAR	lpData;		    /* buffer data area */
    ULONG	BufferLength;	    /* length of buffer */
    ULONG 	BytesUsed;	    /* actual bytes of data (size of dib) */
    ULONG	TimeCaptured;	    /* millisec time stamp */
    PVOID	Context;	    /* pointer to user context data */
    DWORD       dwFlags;            /* not used by kernel interface */

    /*
     * remaining are declared as 4 reserved dwords in orig struct
     * we use these fields for partial-frame requests
     */
    DWORD 	dwWindowOffset;	    /* current window offset from
				     * start of buffer
				     */
    DWORD	dwWindowLength;	    /* length of current window */

    DWORD       dwReserved[2];          /* not used */

} CAPTUREBUFFER, * PCAPTUREBUFFER;



/* --- drawing ------------------------------------------------------- */

/*
 * used by sample hardware codec to write data back into frame buffer
 */
typedef struct _DRAWBUFFER {
    PUCHAR	lpData;		/* frame data to be drawn */
    ULONG	ulWidth;	/* width of frame in pixels */
    ULONG	ulHeight;	/* height of frame in pixels */
    ULONG	Format;		/* h/w specific data format code */
    RECT	rcSource;	/* write only this rect to the device */
} DRAWBUFFER, *PDRAWBUFFER;



#endif //_VCSTRUCT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\codec\msyuv\msyuv.c ===
/*----------------------------------------------------------------------+
| msyuv.c - Microsoft YUV Codec                                         |
|                                                                       |
| Copyright (c) 1993 Microsoft Corporation.                             |
| All Rights Reserved.                                                  |
|                                                                       |
+----------------------------------------------------------------------*/

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>

#ifndef _WIN32
#include "stdarg.h"
#endif

#ifdef _WIN32
#include <memory.h>        /* for memcpy */
#endif

#include "msyuv.h"

// ICINFO use WCHAR if _WIN32 is #defined; so force it to use WCHAR; where else are TCHAR
WCHAR    szDescription[] = L"Microsoft YUV";
WCHAR    szName[]        = L"MS-YUV";
WCHAR    szAbout[]       = L"About";

#define VERSION         0x00010000      // 1.0

// pull these in from amvideo.h
#define WIDTHBYTES(bits) ((DWORD)(((bits)+31) & (~31)) / 8)
#define DIBWIDTHBYTES(bi) (DWORD)WIDTHBYTES((DWORD)(bi)->biWidth * (DWORD)(bi)->biBitCount)
#define _DIBSIZE(bi) (DIBWIDTHBYTES(bi) * (DWORD)(bi)->biHeight)
#define DIBSIZE(bi) ((bi)->biHeight < 0 ? (-1)*(_DIBSIZE(bi)) : _DIBSIZE(bi))
        
/*****************************************************************************
 ****************************************************************************/
INSTINFO * NEAR PASCAL Open(ICOPEN FAR * icinfo)
{
    INSTINFO *  pinst;

    //
    // refuse to open if we are not being opened as a Video compressor
    //
    if (icinfo->fccType != ICTYPE_VIDEO)
        return NULL;

    // dwFlags contain wMode
    // Only support Decompress mode (or for Query purpose)
    if(   icinfo->dwFlags != ICMODE_DECOMPRESS              
       && icinfo->dwFlags != ICMODE_QUERY            // Open for infomational purpose
      ) {
        
        dprintf1((TEXT("Open: unsupported wMode=%d\n"), icinfo->dwFlags));
        return NULL;
    }


    pinst = (INSTINFO *)LocalAlloc(LPTR, sizeof(INSTINFO));

    if (!pinst) {
        icinfo->dwError = (DWORD)ICERR_MEMORY;
        return NULL;
    }

    //
    // init structure
    //
    pinst->dwFlags = icinfo->dwFlags;
    pinst->pXlate = NULL;

    //
    // return success.
    //
    icinfo->dwError = ICERR_OK;

    return pinst;
}

/*****************************************************************************
 ****************************************************************************/
DWORD NEAR PASCAL Close(INSTINFO * pinst)
{

    if (pinst->pXlate) {
        DecompressEnd(pinst);
    }

#ifdef ICM_DRAW_SUPPORTED
    if (pinst->vh) {
        dprintf1((TEXT("  pinst->vh = 0x%x\n"), pinst->vh));

        DrawEnd(pinst);
    }
#endif    


    LocalFree((HLOCAL)pinst);

    return 1;
}


/*****************************************************************************
 ****************************************************************************/

BOOL NEAR PASCAL QueryAbout(INSTINFO * pinst)
{
    return TRUE;
}

DWORD NEAR PASCAL About(INSTINFO * pinst, HWND hwnd)
{
    MessageBoxW(hwnd,szDescription,szAbout,MB_OK|MB_ICONINFORMATION);
    return ICERR_OK;
}

/*****************************************************************************
 ****************************************************************************/
BOOL NEAR PASCAL QueryConfigure(INSTINFO * pinst)
{
    return FALSE;
}

DWORD NEAR PASCAL Configure(INSTINFO * pinst, HWND hwnd)
{
    return (TRUE);
}

/*****************************************************************************
 ****************************************************************************/
/*
 * lossless translation - hence no need for state adjustments
 */
DWORD NEAR PASCAL GetState(INSTINFO * pinst, LPVOID pv, DWORD dwSize)
{
        return 0;

}

/*****************************************************************************
 ****************************************************************************/
DWORD NEAR PASCAL SetState(INSTINFO * pinst, LPVOID pv, DWORD dwSize)
{
    return(0);
}

/*****************************************************************************
 ****************************************************************************/
DWORD NEAR PASCAL GetInfo(INSTINFO * pinst, ICINFO FAR *icinfo, DWORD dwSize)
{
    if (icinfo == NULL)
        return sizeof(ICINFO);

    if (dwSize < sizeof(ICINFO))
        return 0;

    icinfo->dwSize            = sizeof(ICINFO);
    icinfo->fccType           = ICTYPE_VIDEO;
    icinfo->fccHandler        = FOURCC_UYVY; // default UYVY and also supports YUYV/YUY2; 
    icinfo->dwFlags           = 0;
    icinfo->dwVersion         = VERSION;
    icinfo->dwVersionICM      = ICVERSION;
    wcscpy(icinfo->szDescription, szDescription);
    wcscpy(icinfo->szName, szName);

    return sizeof(ICINFO);
}

/*****************************************************************************
 ****************************************************************************/
DWORD FAR PASCAL CompressQuery(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut)
{
    return ((DWORD) ICERR_BADFORMAT);
}

/*****************************************************************************
 ****************************************************************************/
DWORD FAR PASCAL CompressGetFormat(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut)
{

    return((DWORD) ICERR_BADFORMAT);

}

/*****************************************************************************
 ****************************************************************************/


DWORD FAR PASCAL CompressBegin(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut)
{

    return((DWORD) ICERR_ERROR);

}

/*****************************************************************************
 ****************************************************************************/
DWORD FAR PASCAL CompressGetSize(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut)
{
    return (0);
}

/*****************************************************************************
 ****************************************************************************/
DWORD FAR PASCAL Compress(INSTINFO * pinst, ICCOMPRESS FAR *icinfo, DWORD dwSize)
{
    return((DWORD) ICERR_ERROR);

}

/*****************************************************************************
 ****************************************************************************/
DWORD FAR PASCAL CompressEnd(INSTINFO * pinst)
{
    return (DWORD)ICERR_ERROR;

}




/*****************************************************************************
 ****************************************************************************/
DWORD NEAR PASCAL DecompressQuery(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut)
{
    //
    // determine if the input DIB data is in a format we like.
    //
    if (lpbiIn                == NULL         ||
        lpbiIn->biBitCount    != 16           ||  
        (lpbiIn->biCompression != FOURCC_UYVY &&
         lpbiIn->biCompression != FOURCC_YUY2 &&
         lpbiIn->biCompression != FOURCC_YVYU )) {
        dprintf1((TEXT("Bad input format: lpbiIn=%x; In.biBitCount=%d; FourCC %x != UYVY or YUY2\n"), 
            lpbiIn, lpbiIn->biBitCount, lpbiIn->biCompression));
        return (DWORD)ICERR_BADFORMAT;
    }


    //
    //  are we being asked to query just the input format?
    //
    if (lpbiOut == NULL) {
        return ICERR_OK;
    }

    /* must be 1:1 (no stretching) */
    if ((lpbiOut->biWidth != lpbiIn->biWidth) ||
        (abs(lpbiOut->biHeight) != abs(lpbiIn->biHeight))) {

        dprintf1((TEXT("##### Can't stretch: %dx%d != %dx%d\n"),
            lpbiIn->biWidth, lpbiIn->biHeight,
            lpbiOut->biWidth, lpbiOut->biHeight));

        return((DWORD) ICERR_BADFORMAT);
    }


    /*
     * we translate to 32/24/16/8 bits RGB
     */

    if (lpbiOut->biBitCount != 16 && lpbiOut->biBitCount != 8 && lpbiOut->biBitCount != 32 && lpbiOut->biBitCount != 24) {
        return((DWORD) ICERR_BADFORMAT);
    }

    dprintf2((TEXT("DeCmQry: In4CC(%x,%s)<==>Out(%x,%s); RGB565(%s);\n"),
           lpbiIn->biCompression,
           (CHAR *) &lpbiOut->biCompression,
           lpbiOut->biCompression,
           lpbiOut->biCompression == BI_RGB ? "RGB" : (CHAR *) &lpbiOut->biCompression,
           pinst->bRGB565?"T":"F"));

   dprintf2((TEXT(" In:%dx%dx%d=%d; Out:%dx%dx%d=%d\n"),
           lpbiIn->biWidth, lpbiIn->biHeight, lpbiIn->biBitCount, lpbiIn->biSizeImage,
           lpbiOut->biWidth, lpbiOut->biHeight, lpbiOut->biBitCount, lpbiOut->biSizeImage));


    // check output format to make sure we can convert to this
    // must be full dib
    if(lpbiOut->biCompression == BI_RGB) {
       dprintf2((TEXT("$$$$$ RGB: BI_RGB output\n")));
        pinst->bRGB565 = FALSE;

    } else if ((lpbiOut->biCompression == BI_BITFIELDS) &&
        (lpbiOut->biBitCount == 16 || lpbiOut->biBitCount == 8) &&
        (((LPDWORD)(lpbiOut+1))[0] == 0x00f800) &&
        (((LPDWORD)(lpbiOut+1))[1] == 0x0007e0) &&
        (((LPDWORD)(lpbiOut+1))[2] == 0x00001f))  {
        dprintf2((TEXT("$$$$$ BITF: rgb565 output\n")));
        pinst->bRGB565 = TRUE;

// Pass thru case:
        // !!! this is broken, since it will allow copying from
        // any of the three YUV formats to any of the others, and
        // we actually don't do this. If the AviDec allowed going from
        // YUV to YUV, we would see odd colors!
    } else if (lpbiOut->biCompression == FOURCC_UYVY || 
               lpbiOut->biCompression == FOURCC_YUY2 ||   
               lpbiOut->biCompression == FOURCC_YVYU ) {  
        if( lpbiIn->biCompression != lpbiOut->biCompression )
        {
            dprintf1((TEXT("cannot convert between YUV formats\n")));
            return (DWORD)ICERR_BADFORMAT;
        }
        dprintf2((TEXT("$$$$$ UYVY: rgb555 output\n")));
        pinst->bRGB565 = FALSE;
    } else {
        dprintf1((TEXT("bad compression for output\n")));
        return (DWORD)ICERR_BADFORMAT;
    }

    return ICERR_OK;
}

/*****************************************************************************
 ****************************************************************************/
DWORD NEAR PASCAL DecompressGetFormat(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut)
{
    DWORD dw;

    // Check input format only since lpbiOut is being asked for
    dw = DecompressQuery(pinst, lpbiIn, NULL);
    if (dw != ICERR_OK) {
        return dw;
    }

    //
    // if lpbiOut == NULL then, return the size required to hold a output
    // format
    //
    if (lpbiOut == NULL) {
        dprintf2((TEXT("get format size query\n")));
        return (int)lpbiIn->biSize + (int)lpbiIn->biClrUsed * sizeof(RGBQUAD);
    }

    memcpy(lpbiOut, lpbiIn, (int)lpbiIn->biSize + (int)lpbiIn->biClrUsed * sizeof(RGBQUAD));
    lpbiOut->biCompression = BI_RGB; 
    lpbiOut->biBitCount = 24; // we suggest 24 bit
    lpbiOut->biSizeImage = DIBSIZE( lpbiOut );

    dprintf2((TEXT("DeCmpGFmt: In:%dx%dx%d=%d; RGB565(%s); Out:%dx%dx%d=%d\n"),
        lpbiIn->biWidth, lpbiIn->biHeight, lpbiIn->biBitCount, lpbiIn->biSizeImage,
        pinst->bRGB565?TEXT("T"):TEXT("F"),
        lpbiOut->biWidth, lpbiOut->biHeight, lpbiOut->biBitCount, lpbiOut->biSizeImage));

    return ICERR_OK;
}



/*****************************************************************************
 ****************************************************************************/
DWORD NEAR PASCAL DecompressBegin(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut)
{
    DWORD dw;


    /* check that the conversion formats are valid */
    dw = DecompressQuery(pinst, lpbiIn, lpbiOut);
    if (dw != ICERR_OK) {
        return dw;
    }

    dprintf2((TEXT("DeCmBegin: In4CC(%x,%s)<==>Out(%x,%s); RGB565(%s);\n"),
        lpbiIn->biCompression,
        (PTCHAR) &lpbiOut->biCompression, //"UYVY",
        lpbiOut->biCompression,
        lpbiOut->biCompression == BI_RGB ? "RGB" : (PTCHAR) &lpbiOut->biCompression,
        pinst->bRGB565?TEXT("T"):TEXT("F")));

    dprintf2((TEXT(" In:%dx%dx%d=%d; Out:%dx%dx%d=%d\n"),
        lpbiIn->biWidth, lpbiIn->biHeight, lpbiIn->biBitCount, lpbiIn->biSizeImage,
        lpbiOut->biWidth, lpbiOut->biHeight, lpbiOut->biBitCount, lpbiOut->biSizeImage));



    /* init the yuv-to-rgb55 xlate table if not already inited */

    /* free up the existing table if the formats differ */
    if (lpbiIn->biCompression != pinst->dwFormat) {
        if (pinst->pXlate != NULL) {
            DecompressEnd(pinst);
       }
    }

    if (pinst->pXlate == NULL) {

        switch(lpbiIn->biCompression) {
        case FOURCC_YUY2:
        case FOURCC_UYVY:
        case FOURCC_YVYU:
        {
            switch( lpbiOut->biBitCount ) {
            case 8:
            {
                dprintf3((TEXT("pinst->pXlate = BuildUYVYToRGB8()\n")));
                pinst->pXlate = BuildUYVYToRGB8(pinst);
                break;
            }
            case 16:
            {
                if (pinst->bRGB565) {
                    dprintf3((TEXT("pinst->pXlate = BuildUYVYToRGB565()\n")));
                    pinst->pXlate = BuildUYVYToRGB565(pinst);

                } else {
                    dprintf3((TEXT("pinst->pXlate = BuildUYVYToRGB555()\n")));
                    pinst->pXlate = BuildUYVYToRGB555(pinst);
                }
                break;
            }
            case 24:
            {
                dprintf3((TEXT("pinst->pXlate = BuildUYVYToRGB32()\n")));
                pinst->pXlate = BuildUYVYToRGB32(pinst);
                break;
            }
            case 32:
            {
                dprintf3((TEXT("pinst->pXlate = BuildUYVYToRGB32()\n")));
                pinst->pXlate = BuildUYVYToRGB32(pinst);
                break;
            }
            default:
            {
                dprintf1((TEXT("Supported UYUV->RGB but unsupported output bitcount (%d); return ICERR_BADFOPRMAT\n"), lpbiOut->biBitCount));
                return((DWORD) ICERR_BADFORMAT);

            }
            } // switch biBitCount

            break;
        } // case FOURCC_ACCEPTABLE

        default:
            dprintf1((TEXT("UnSupported FourCC; return ICERR_BADFOPRMAT\n")));
            return((DWORD) ICERR_BADFORMAT);
        }

        if( ( lpbiOut->biBitCount != 8 ) && ( pinst->pXlate == NULL ) ) {
            dprintf1((TEXT("return ICERR_MEMORY\n")));
            return((DWORD) ICERR_MEMORY);
        }

        pinst->dwFormat = lpbiIn->biCompression;
    }

    return(ICERR_OK);

}

/*****************************************************************************
 ****************************************************************************/
DWORD NEAR PASCAL Decompress(INSTINFO * pinst, ICDECOMPRESS FAR *icinfo, DWORD dwSize)
{
    ASSERT(pinst && icinfo);
    if (!pinst || !icinfo)
        return((DWORD) ICERR_ERROR);

    if (pinst->dwFormat == FOURCC_UYVY ||
        pinst->dwFormat == FOURCC_YUY2 ||
        pinst->dwFormat == FOURCC_YVYU) {

        switch( icinfo->lpbiOutput->biBitCount )
        {
        case 8:
        {
            UYVYToRGB8(pinst,
                icinfo->lpbiInput,
                icinfo->lpInput,
                icinfo->lpbiOutput,
                icinfo->lpOutput);
            break;
        }
        case 16:
        {
            /* must have been a DecompressBegin first */
            if (pinst->pXlate == NULL) {
                dprintf1((TEXT("Decompress: pinst->pXlate == NULL\n")));
                return((DWORD) ICERR_ERROR);
            }
            UYVYToRGB16(pinst,
                icinfo->lpbiInput,
                icinfo->lpInput,
                icinfo->lpbiOutput,
                icinfo->lpOutput);
            break;
        }
        case 24:
        {
            if (pinst->pXlate == NULL) {
                dprintf1((TEXT("Decompress: pinst->pXlate == NULL\n")));
                return((DWORD) ICERR_ERROR);
            }
            UYVYToRGB24(pinst,
                icinfo->lpbiInput,
                icinfo->lpInput,
                icinfo->lpbiOutput,
                icinfo->lpOutput);
            break;
        }
        case 32:
        {
            if (pinst->pXlate == NULL) {
                dprintf1((TEXT("Decompress: pinst->pXlate == NULL\n")));
                return((DWORD) ICERR_ERROR);
            }
            UYVYToRGB32(pinst,
                icinfo->lpbiInput,
                icinfo->lpInput,
                icinfo->lpbiOutput,
                icinfo->lpOutput);
            break;
        }
        default:
        {
            dprintf1((TEXT("Decompress: Unsupported output bitcount(%d)\n"), icinfo->lpbiOutput->biBitCount)); 
        }
        } // switch bit count
    }


    return ICERR_OK;
}



/*****************************************************************************
 ****************************************************************************/
DWORD NEAR PASCAL DecompressEnd(INSTINFO * pinst)
{
    if (pinst->pXlate) {
        // 16bit RGB LUT is built dynamically.
        FreeXlate(pinst);
    }

    pinst->dwFormat = 0;

    return ICERR_OK;
}


/*****************************************************************************
    ehr: DecompressExQuery and DecompressEx don't suppor what they should
    support. DecompressEx should also support "normal" decompressing, that is,
    the same thing that Decompress would support. But it doesn't, it only
    supports memcpying the bitmap, which is really odd.
 ****************************************************************************/

/*
ICM_DECOMPRESSEX_QUERY wParam = (DWORD) (LPVOID) &icdex; 
lParam = sizeof(ICDECOMPRESSEX);

typedef struct {     
    DWORD              dwFlags; 
    LPBITMAPINFOHEADER lpbiSrc;     
    LPVOID             lpSrc; 
    LPBITMAPINFOHEADER lpbiDst;     
    LPVOID             lpDst; 
    int                xDst;     
    int                yDst; 
    int                dxDst;     
    int                dyDst; 
    int                xSrc;     
    int                ySrc; 
    int                dxSrc;     
    int                dySrc; } ICDECOMPRESSEX;  
*/ 
DWORD NEAR PASCAL DecompressExQuery(INSTINFO * pinst, ICDECOMPRESSEX * pICD, DWORD dwICDSize)
{
    LPBITMAPINFOHEADER pbmSrc, pbmDst;

    if (pICD == NULL) {
       dprintf1(("DeCmQEx: pICD== NULL\n"));
       return (DWORD)ICERR_BADFORMAT;
    }

    pbmSrc = pICD->lpbiSrc;
    pbmDst = pICD->lpbiDst;

    //
    // determine if the input DIB data is in a format we like.
    //
    if (pbmSrc                == NULL     ||
        pbmSrc->biBitCount    != 16       ||
        (pbmSrc->biCompression != FOURCC_UYVY &&
         pbmSrc->biCompression != FOURCC_YUY2 &&
         pbmSrc->biCompression != FOURCC_YVYU)) {

        dprintf1((TEXT("Bad input format: pbmSrc=%x; Src.biBitCount=%d; FourCC!= UYVY\n"), pbmSrc, pbmSrc->biBitCount));
        return (DWORD)ICERR_BADFORMAT;
    }

    dprintf2(("DeCmQEx: dwFlags=0x%x Src(%dx%dx%d=%d %s) Dst(%dx%dx%d=%d %s)\n",
        pICD->dwFlags,
        pbmSrc->biWidth, pbmSrc->biHeight, pbmSrc->biBitCount, pbmSrc->biSizeImage, (PTCHAR *) &pbmSrc->biCompression,
        pbmDst->biWidth, pbmDst->biHeight, pbmDst->biBitCount, pbmDst->biSizeImage, (PTCHAR *) &pbmDst->biCompression));
    dprintf2(("DeCmQEx:  SrcPoint(%d,%d) SizeSrc(%d,%d); DstPoint(%d,%d) SizeDst(%d,%d);\n",
        pICD->xSrc, pICD->ySrc, pICD->dxSrc, pICD->dySrc,
        pICD->xDst, pICD->yDst, pICD->dxDst, pICD->dyDst));

    /* must be 1:1 (no stretching) */
    if ((pbmDst->biWidth       != pbmSrc->biWidth)       ||
        (abs(pbmDst->biHeight) != abs(pbmSrc->biHeight)) ||  // Sign is ignored for YUV->YUV
        (pbmDst->biBitCount    != pbmSrc->biBitCount)    ||
        (pbmDst->biCompression != pbmSrc->biCompression) ||  // Pass thru
        // Start from the same origin        
        (pICD->xSrc            != 0                    ) || 
        (pICD->ySrc            != 0                    ) || 
        (pICD->xDst            != 0                    ) ||
        (pICD->yDst            != 0                    ) ||
        // 1:1
        (pICD->dxSrc           != pbmSrc->biWidth      ) ||
        (pICD->dySrc           != abs(pbmSrc->biHeight)) ||
        (pICD->dxDst           != pbmDst->biWidth      ) ||
        (pICD->dyDst           != abs(pbmDst->biHeight)) 
        ) {

        dprintf1((TEXT("DeCmQEx: Src/Dst format does not MATCH!\n")));
        return((DWORD) ICERR_BADFORMAT);
    }


    return (DWORD)ICERR_OK;
}

/*****************************************************************************
  This routine support transferring data to a DirectDraw rendering surface, 
  which always uses a top-down orientation with its lowest video address
  in the upper-left corder.
  Note: no stretching is supported.
 ****************************************************************************/
DWORD NEAR PASCAL DecompressEx(INSTINFO * pinst, ICDECOMPRESSEX * pICD, DWORD dwICDSize)
{
    LPBITMAPINFOHEADER pbmSrc, pbmDst;
    PBYTE pSrc, pDst;
    int Height, Width, WidthBytes, StrideWidthBytes;

    if(pICD == NULL) {
        dprintf1((TEXT("DeCmEx: pICD== NULL\n")));
        return (DWORD)ICERR_BADFORMAT;
    }

    pbmSrc = pICD->lpbiSrc;
    pbmDst = pICD->lpbiDst;

    if(pbmSrc->biCompression != pbmDst->biCompression) {
       dprintf1((TEXT("DeCmEx: Compression does not match! In(%s) != Out(%s)\n"), (PTCHAR) &pbmSrc->biCompression, (PTCHAR) &pbmDst->biCompression));
       return (DWORD)ICERR_BADFORMAT;
    }

    // Since no stretching, 
    //    SrcHeight == DstHeight
    //    SrcWidth  == DstWidth
    Height     = abs(pbmSrc->biHeight);
    Width      = pbmSrc->biWidth;
    WidthBytes = Width * pbmSrc->biBitCount / 8;

    StrideWidthBytes = pbmDst->biWidth * pbmDst->biBitCount / 8;

    pSrc = (PBYTE) pICD->lpSrc;

    /*
     * adjust the destination to point to the start of the last line, 
     * and work upwards (to flip vertically into DIB format) 
     * if biHeight for In/Out are different.  Else Top/down.
     */

    pDst = (PBYTE)pICD->lpDst;

    dprintf2(("DeCmEx: %dx%d; (%x %dx%dx%d=%d); (%x %dx%dx%d=%d); Stride=%d\n",
               Width, Height,
               (PCHAR) &pbmSrc->biCompression,
               pbmSrc->biWidth, pbmSrc->biHeight, pbmSrc->biBitCount, pbmSrc->biSizeImage, 
               (PCHAR) &pbmDst->biCompression,
               pbmDst->biWidth, pbmDst->biHeight, pbmDst->biBitCount, pbmDst->biSizeImage,
               StrideWidthBytes));

    ASSERT((pbmDst->biSizeImage <= pbmSrc->biSizeImage));

    // No stretching
    // pbmSrc->biSizeImage may not been defined so the image size is calculated from its 
    // known value of width, height and bitcount.
    memcpy(pDst, pSrc, Width * Height * pbmSrc->biBitCount / 8);


    return ICERR_OK;
}

/*****************************************************************************
 ****************************************************************************/
DWORD NEAR PASCAL DecompressExBegin(INSTINFO * pinst, ICDECOMPRESSEX * pICD, DWORD dwICDSize)
{
    DWORD dwRtn;
    LPBITMAPINFOHEADER pbmSrc, pbmDst;

    if (pICD == NULL) {
        dprintf1(("DeCmExBegin: pICD== NULL\n"));
        return (DWORD)ICERR_BADFORMAT;
    }

    pbmSrc = pICD->lpbiSrc;
    pbmDst = pICD->lpbiDst;

    /* check that the conversion formats are valid */
    dwRtn = DecompressExQuery(pinst, pICD, dwICDSize);
    if (dwRtn != ICERR_OK) {
        dprintf1(("DeCmExBegin return 0x%x", dwRtn));
        return dwRtn;
    }

    // No need to allocate any buffer

    dprintf1(("DeCmExBegin return ICERR_OK\n"));
    return ICERR_OK;
}

/*****************************************************************************
 ****************************************************************************/
DWORD NEAR PASCAL DecompressExEnd(INSTINFO * pinst)
{
    pinst->dwFormat = 0;

    return ICERR_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\codec\msyuv\drvproc.c ===
/*----------------------------------------------------------------------+
|                                    |
| drvproc.c - driver procedure                        |
|                                    |
| Copyright (c) 1993 Microsoft Corporation.                |
| All Rights Reserved.                            |
|                                    |
+----------------------------------------------------------------------*/

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>

#include "msyuv.h"

HMODULE ghModule;     // Our DLL module handle


/***************************************************************************
 * DriverProc  -  The entry point for an installable driver.
 *
 * PARAMETERS
 * dwDriverId:  For most messages, <dwDriverId> is the DWORD
 *     value that the driver returns in response to a <DRV_OPEN> message.
 *     Each time that the driver is opened, through the <DrvOpen> API,
 *     the driver receives a <DRV_OPEN> message and can return an
 *     arbitrary, non-zero value. The installable driver interface
 *     saves this value and returns a unique driver handle to the
 *     application. Whenever the application sends a message to the
 *     driver using the driver handle, the interface routes the message
 *     to this entry point and passes the corresponding <dwDriverId>.
 *     This mechanism allows the driver to use the same or different
 *     identifiers for multiple opens but ensures that driver handles
 *     are unique at the application interface layer.
 *
 *     The following messages are not related to a particular open
 *     instance of the driver. For these messages, the dwDriverId
 *     will always be zero.
 *
 *         DRV_LOAD, DRV_FREE, DRV_ENABLE, DRV_DISABLE, DRV_OPEN
 *
 * hDriver: This is the handle returned to the application by the
 *    driver interface.
 *
 * uiMessage: The requested action to be performed. Message
 *     values below <DRV_RESERVED> are used for globally defined messages.
 *     Message values from <DRV_RESERVED> to <DRV_USER> are used for
 *     defined driver protocols. Messages above <DRV_USER> are used
 *     for driver specific messages.
 *
 * lParam1: Data for this message.  Defined separately for
 *     each message
 *
 * lParam2: Data for this message.  Defined separately for
 *     each message
 *
 * RETURNS
 *   Defined separately for each message.
 *
 ***************************************************************************/

LRESULT  DriverProc(PINSTINFO pi, HDRVR hDriver, UINT uiMessage, LPARAM lParam1, LPARAM lParam2)
{

    switch (uiMessage)
    {
    case DRV_LOAD:
        dprintf2((TEXT("DRV_LOAD:\n")));
#ifdef _WIN32
            if (ghModule) {
                // AVI explicitly loads us as well, but does not pass the
                // correct (as known by WINMM) driver handle.
            } else {
                ghModule = (HANDLE) GetDriverModuleHandle(hDriver);
            }
#endif
        return (LRESULT) 1L;

    case DRV_FREE:
        dprintf2((TEXT("DRV_FREE:\n")));
        return (LRESULT)1L;

        case DRV_OPEN:
        dprintf2((TEXT("DRV_OPEN\n")));
        // if being opened with no open struct, then return a non-zero
        // value without actually opening
        if (lParam2 == 0L)
                return 0xFFFF0000;

        return (LRESULT)(DWORD_PTR) Open((ICOPEN FAR *) lParam2);

    case DRV_CLOSE:
        dprintf2((TEXT("DRV_CLOSE:\n")));
#ifdef _WIN32
        if (pi != (PINSTINFO)(ULONG_PTR)0xFFFF0000)
#else
        if (pi)
#endif
        Close(pi);

        return (LRESULT)1L;

    /*********************************************************************

        state messages

    *********************************************************************/

    case DRV_QUERYCONFIGURE:    // configuration from drivers applet
        dprintf2((TEXT("DRV_QUERYCONFIGURE:\n")));
        return (LRESULT)0L;

    case DRV_CONFIGURE:
        dprintf2((TEXT("DRV_CONFIGURE:\n")));
        return DRV_OK;

    case ICM_CONFIGURE:
        dprintf2((TEXT("ICM_CONFIGURE:\n")));
        //
        //  return ICERR_OK if you will do a configure box, error otherwise
        //
        if (lParam1 == -1)
           return QueryConfigure(pi) ? ICERR_OK : ICERR_UNSUPPORTED;
        else
           return Configure(pi, (HWND)lParam1);

   case ICM_ABOUT:
        dprintf2((TEXT("ICM_ABOUT:\n")));
        //
        //  return ICERR_OK if you will do a about box, error otherwise
        //
        if (lParam1 == -1)
           return QueryAbout(pi) ? ICERR_OK : ICERR_UNSUPPORTED;
        else
           return About(pi, (HWND)lParam1);

    case ICM_GETSTATE:
        dprintf1((TEXT("ICM_GETSTATE:\n")));
        return GetState(pi, (LPVOID)lParam1, (DWORD)lParam2);

    case ICM_SETSTATE:
        dprintf1((TEXT("ICM_SETSTATE:\n")));
        return SetState(pi, (LPVOID)lParam1, (DWORD)lParam2);

    case ICM_GETINFO:
        dprintf1((TEXT("ICM_GETINFO:\n")));
        return GetInfo(pi, (ICINFO FAR *)lParam1, (DWORD)lParam2);

    case ICM_GETDEFAULTQUALITY:
        dprintf2((TEXT("ICM_GETDEFAULTQUALITY:\n")));
        if (lParam1) {
            *((LPDWORD)lParam1) = 7500;
            return ICERR_OK;
        }
        break;

#if 0
// NOT SUPPORTED
    /*********************************************************************

        compression messages

    *********************************************************************/

    case ICM_COMPRESS_QUERY:
        dprintf2((TEXT("ICM_COMPRESS_QUERY:\n")));
        return CompressQuery(pi,
             (LPBITMAPINFOHEADER)lParam1,
             (LPBITMAPINFOHEADER)lParam2);

    case ICM_COMPRESS_BEGIN:
        dprintf2((TEXT("ICM_COMPRESS_BEGIN:\n")));
        return CompressBegin(pi,
             (LPBITMAPINFOHEADER)lParam1,
             (LPBITMAPINFOHEADER)lParam2);

    case ICM_COMPRESS_GET_FORMAT:
        dprintf2((TEXT("ICM_COMPRESS_GET_FORMAT:\n")));
        return CompressGetFormat(pi,
             (LPBITMAPINFOHEADER)lParam1,
             (LPBITMAPINFOHEADER)lParam2);

    case ICM_COMPRESS_GET_SIZE:
        dprintf2((TEXT("ICM_COMPRESS_GET_SIZE:\n")));
        return CompressGetSize(pi,
             (LPBITMAPINFOHEADER)lParam1,
             (LPBITMAPINFOHEADER)lParam2);

    case ICM_COMPRESS:
        dprintf2((TEXT("ICM_COMPRESS:\n")));
        return Compress(pi,
                (ICCOMPRESS FAR *)lParam1, (DWORD)lParam2);

    case ICM_COMPRESS_END:
        dprintf2((TEXT("ICM_COMPRESS_END:\n")));
        return CompressEnd(pi);

#endif
    /*********************************************************************

        decompress messages

    *********************************************************************/

    case ICM_DECOMPRESS_QUERY:
        dprintf2((TEXT("\nICM_DECOMPRESS_QUERY:----------------\n")));
        return DecompressQuery(pi,
             (LPBITMAPINFOHEADER)lParam1,
             (LPBITMAPINFOHEADER)lParam2);

    case ICM_DECOMPRESS_BEGIN:
        dprintf2((TEXT("\nICM_DECOMPRESS_BEGIN:\n")));
        return DecompressBegin(pi,
             (LPBITMAPINFOHEADER)lParam1,
             (LPBITMAPINFOHEADER)lParam2);

    case ICM_DECOMPRESS_GET_FORMAT:
        dprintf2((TEXT("\nICM_DECOMPRESS_GET_FORMAT:================\n")));
        return DecompressGetFormat(pi,
             (LPBITMAPINFOHEADER)lParam1,
             (LPBITMAPINFOHEADER)lParam2);

    case ICM_DECOMPRESS_GET_PALETTE:
        dprintf2((TEXT("ICM_DECOMPRESS_GET_PALETTE:\n")));
        return DecompressGetPalette(pi,
             (LPBITMAPINFOHEADER)lParam1,
             (LPBITMAPINFOHEADER)lParam2);

    case ICM_DECOMPRESS:
        dprintf4((TEXT("ICM_DECOMPRESS:\n")));
        return Decompress(pi,
             (ICDECOMPRESS FAR *)lParam1, (DWORD)lParam2);

    case ICM_DECOMPRESS_END:
        dprintf2((TEXT("ICM_DECOMPRESS_END:\n")));
        return DecompressEnd(pi);


    // *EX
    case ICM_DECOMPRESSEX_QUERY:
        dprintf2((TEXT("\nICM_DECOMPRESSEX_QUERY:----------------\n")));
        return DecompressExQuery(pi, (ICDECOMPRESSEX *) lParam1,(DWORD) lParam2);

    case ICM_DECOMPRESSEX:
        dprintf4((TEXT("ICM_DECOMPRESSEX:\n")));
        return DecompressEx(pi, (ICDECOMPRESSEX *) lParam1, (DWORD) lParam2);

    case ICM_DECOMPRESSEX_BEGIN:
        dprintf2((TEXT("\nICM_DECOMPRESSEX_BEGIN:\n")));
        return DecompressExBegin(pi, (ICDECOMPRESSEX *) lParam1,(DWORD) lParam2);;

    case ICM_DECOMPRESSEX_END:
        dprintf2((TEXT("\nICM_DECOMPRESSEX_END:\n")));
        return DecompressExEnd(pi);;



    /*********************************************************************

        draw messages:

    *********************************************************************/
#ifdef ICM_DRAW_SUPPORTED
    case ICM_DRAW_BEGIN:
        dprintf2((TEXT("ICM_DRAW_BEGIN:\n")));
        /*
         * sent when a sequence of draw calls are about to start -
         * enable hardware.
         */
        //return DrawBegin(pi,(ICDRAWBEGIN FAR *)lParam1, (DWORD)lParam2);
        return( (DWORD) ICERR_OK);


    case ICM_DRAW:
        dprintf2((TEXT("ICM_DRAW:\n")));
        /*
         * frame ready for decompress. Since we don't have any pre-buffering,
         * it is ok to render the frame at this time too. If we had
         * pre-buffer, we would queue now, and start clocking frames out
         * on the draw-start message.
         */
        return Draw(pi,(ICDRAW FAR *)lParam1, (DWORD)lParam2);

    case ICM_DRAW_END:
        dprintf2((TEXT("ICM_DRAW_END:\n")));
        /*
         * this message is sent when the sequence of draw calls has finished -
         * note that the final frame should remain rendered!! - so we can't
         * disable the hardware yet.
         */
        //return DrawEnd(pi);
        //return((DWORD) ICERR_OK);


    case ICM_DRAW_WINDOW:
        dprintf2(("ICM_DRAW_WINDOW:\n"));
        /*
         * the window has changed position or z-ordering. re-sync the
         * hardware rendering.
         */
        return(DrawWindow(pi, (PRECT)lParam1));


    case ICM_DRAW_QUERY:
        dprintf2((TEXT("ICM_DRAW_QUERY:\n")));
        /*
         * can we draw this format ? (lParam2 may (should?) be null)
         */
        return DrawQuery(pi,
             (LPBITMAPINFOHEADER)lParam1,
             (LPBITMAPINFOHEADER)lParam2);

    case ICM_DRAW_START:
    case ICM_DRAW_STOP:
        dprintf2((TEXT("ICM_DRAW_START/END:\n")));
        /*
         * only relevant if you have pre-buffering.
         */
        return( (DWORD) ICERR_OK);
#endif

    /*********************************************************************

        standard driver messages

    *********************************************************************/

    case DRV_DISABLE:
    case DRV_ENABLE:
        dprintf2((TEXT("DRV_DISABLE/ENABLE:\n")));
        return (LRESULT)1L;

    case DRV_INSTALL:
    case DRV_REMOVE:
        dprintf2((TEXT("DRV_INSTALL/REMOVE:\n")));
        return (LRESULT)DRV_OK;
    }

    if (uiMessage < DRV_USER) {
        return DefDriverProc((UINT_PTR)pi, hDriver, uiMessage,lParam1,lParam2);
    } else {
        dprintf1((TEXT("DriverProc: ICM message ID (ICM_USER+%d) not supported.\n"), uiMessage-ICM_USER));
        return ICERR_UNSUPPORTED;
    }
}


#ifdef _WIN32
#if 0 // done on DRV_LOAD
BOOL DllInstanceInit(PVOID hModule, ULONG Reason, PCONTEXT pContext)
{
    if (Reason == DLL_PROCESS_ATTACH) {
        ghModule = (HANDLE) hModule;
    DisableThreadLibraryCalls(hModule);
    }
    return TRUE;
}
#endif
#endif
// #else

/****************************************************************************
 * LibMain - Library initialization code.
 *
 * PARAMETERS
 * hModule: Our module handle.
 *
 * wHeapSize: The heap size from the .def file.
 *
 * lpCmdLine: The command line.
 *
 * Returns 1 if the initialization was successful and 0 otherwise.
 ***************************************************************************/
//int NEAR PASCAL LibMain(HMODULE hModule, WORD wHeapSize, LPSTR lpCmdLine)
BOOL FAR PASCAL LibMain(HMODULE hModule, WORD wHeapSize, LPSTR lpCmdLine)
{
    ghModule = hModule;

    return 1;
}

// #endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\codec\tsbyuv\vcstruct.h ===
/*
 * Copyright (c) Microsoft Corporation 1993. All Rights Reserved.
 */

/*
 * vcstruct.h
 *
 * 32-bit Video Capture Driver
 *
 * This header describes structures used in the interface between the
 * kernel driver and the user-mode dll.
 *
 * Geraint Davies, Feb 93.
 */

#ifndef _VCSTRUCT_
#define _VCSTRUCT_

/* --- configuration ------------------------------------------------- */

/*
 * this structure contains configuration information generated
 * by the hardware-specific dialogs and sent to the hardware-specific
 * kernel-mode code. No one else knows its format.
 *
 * these generic structures are used so that driver writers can
 * change the user-mode dialogs and the supporting hardware-specific code
 * and yet still use the common code for interfacing between the
 * two and dealing with NT.
 */

typedef struct _CONFIG_INFO {
    ULONG ulSize;		/* size of struct including size field */
    BYTE ulData[1];		/* (ulSize - sizeof(ULONG)) bytes of data */
} CONFIG_INFO, *PCONFIG_INFO;



/* --- overlay keying and region setting ---------------------------- */


typedef struct _OVERLAY_MODE {
    ULONG ulMode;
} OVERLAY_MODE, *POVERLAY_MODE;

/* values for overlay mode field - or-ed together */
#define VCO_KEYCOLOUR		1	// true if a key colour supported
#define VCO_KEYCOLOUR_FIXED	2	// if not true, you can change it
#define VCO_KEYCOLOUR_RGB	4	// if not true, use palette index
#define VCO_SIMPLE_RECT		8	// if true, supports a single rect	
#define VCO_COMPLEX_REGION	0x10	// if true, supports complex regions.

/*
 * values indicating whether we can put data back into the frame
 * buffer for overlaying (we support the DrawFrame ioctl for the
 * Y411 and/or S422 formats
 */
#define VCO_CAN_DRAW_Y411	0x20	// 7-bit 4:1:1 yuv ala bravado
#define VCO_CAN_DRAW_S422	0x40	// 8-bit 4:2:2 yuv ala spigot
#define VCO_CAN_DRAW		0x60	// for testing: can he draw anything?


typedef struct _OVERLAY_RECTS {
    ULONG ulCount;	    // total number of rects in array
    RECT rcRects[1];	    // ulCount rectangles.
}OVERLAY_RECTS, *POVERLAY_RECTS;


typedef RGBQUAD * PRGBQUAD;

/* --- frame capture ------------------------------------------------ */

/*
 * declaring a real LPVIDEOHDR in the kernel driver is too much of a
 * pain with header files. So the kernel interface will use this declaration
 */
typedef struct _CAPTUREBUFFER {
    PUCHAR	lpData;		    /* buffer data area */
    ULONG	BufferLength;	    /* length of buffer */
    ULONG 	BytesUsed;	    /* actual bytes of data (size of dib) */
    ULONG	TimeCaptured;	    /* millisec time stamp */
    PVOID	Context;	    /* pointer to user context data */
    DWORD       dwFlags;            /* not used by kernel interface */

    /*
     * remaining are declared as 4 reserved dwords in orig struct
     * we use these fields for partial-frame requests
     */
    DWORD 	dwWindowOffset;	    /* current window offset from
				     * start of buffer
				     */
    DWORD	dwWindowLength;	    /* length of current window */

    DWORD       dwReserved[2];          /* not used */

} CAPTUREBUFFER, * PCAPTUREBUFFER;



/* --- drawing ------------------------------------------------------- */

/*
 * used by sample hardware codec to write data back into frame buffer
 */
typedef struct _DRAWBUFFER {
    PUCHAR	lpData;		/* frame data to be drawn */
    ULONG	ulWidth;	/* width of frame in pixels */
    ULONG	ulHeight;	/* height of frame in pixels */
    ULONG	Format;		/* h/w specific data format code */
    RECT	rcSource;	/* write only this rect to the device */
} DRAWBUFFER, *PDRAWBUFFER;



#endif //_VCSTRUCT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\codec\msyuv\vcuser.h ===
/*
 * Copyright Microsoft Corporation, 1993 - 1995. All Rights Reserved.
 */

/*
 * vcuser.h
 *
 * 32-bit Video Capture driver
 * User-mode support library
 *
 * define functions providing access to video capture hardware. On NT,
 * these functions will interface to the kernel-mode driver.
 *
 * include vcstruct.h before this.
 *
 * Geraint Davies, Feb 93
 */

#ifndef _VCUSER_H_
#define _VCUSER_H_

/*
 * capture device handle. This structure is opaque to the caller
 */
typedef struct _VCUSER_HANDLE * VCUSER_HANDLE;

/*
 * these are the parameters we need to issue a DriverCallback. A
 * pointer to one of these structs is passed on StreamInit
 * If the pointer is null, we don't need callbacks.
 */
typedef struct _VCCALLBACK {
    DWORD dwCallback;
    DWORD dwFlags;
    HDRVR hDevice;
    DWORD dwUser;
} VCCALLBACK, * PVCCALLBACK;


/*
 * open the device and return a capture device handle that can be used
 * in future calls.
 * The device index is 0 for the first capture device up to N for the
 * Nth installed capture device.
 *
 * If pDriverName is non-null, then we will open the Nth device handled
 * by this driver. (Current implementation supports only one device per
 * drivername.)
 *
 * This function returns NULL if it is not able to open the device.
 */
VCUSER_HANDLE VC_OpenDevice(PTCHAR pDriverName, int DeviceIndex);


/*
 * close a capture device. This will abort any operation in progress and
 * render the device handle invalid.
 */
VOID VC_CloseDevice(VCUSER_HANDLE vh);


/*
 * Configuration.
 *
 * These functions perform device-dependent setup affecting the
 * target format, the source acquisition or the display (overlay).
 *
 * The structures passed are not interpreted by the vcuser and vckernel
 * libraries except that the first ulong of the struct must contain the
 * size in bytes of the entire structure (see vcstruct.h). It is assumed
 * that the structures are defined and agreed between the user-mode
 * hardware-specific code and the kernel-mode hardware specific code
 */
BOOL VC_ConfigFormat(VCUSER_HANDLE, PCONFIG_INFO);
BOOL VC_ConfigSource(VCUSER_HANDLE, PCONFIG_INFO);
BOOL VC_ConfigDisplay(VCUSER_HANDLE, PCONFIG_INFO);


/*
 * overlay and keying
 *
 * Several different methods are used by devices to locate the overlay
 * area on the screen: colour (either rgb or palette index) and/or
 * either a single rectangle, or a series of rectangles defining a complex
 * region. Call GetOverlayMode first to find out which type of overlay
 * keying is available. If this returns 0, this hardware is not capable
 * of overlay.
 */

/*
 * find out the overlay keying method
 */
ULONG VC_GetOverlayMode(VCUSER_HANDLE);

/*
 * set the key colour to a specified RGB colour. This function will only
 * succeed if GetOverlayMode returned  VCO_KEYCOLOUR and VCO_KEYCOLOUR_RGB
 * and not VCO_KEYCOLOUR_FIXED
 */
BOOL VC_SetKeyColourRGB(VCUSER_HANDLE, PRGBQUAD);

/*
 * set the key colour to a specified palette index. This function will only
 * succeed if GetOverlayMode returned VCO_KEYCOLOUR and not either
 * VCO_KEYCOLOUR_RGB or VCO_KEYCOLOUR_FIXED
 */
BOOL VC_SetKeyColourPalIdx(VCUSER_HANDLE, WORD);

/*
 * get the current key colour. This 32-bit value should be interpreted
 * as either a palette index or an RGB value according to the
 * VCO_KEYCOLOUR_RGB flag returned from VC_GetOverlayMode.
 */
DWORD VC_GetKeyColour(VCUSER_HANDLE vh);

/*
 * set the overlay rectangle(s). This rectangle marks the area in device
 * co-ordinates where the overlay video will appear. The video will be
 * panned so that pixel (0,0) will appear at the top-left of this rectangle,
 * and the video will be cropped at the bottom and right.  The video
 * stream will not normally be scaled to fit this window: scaling is normally
 * determined by the destination format set by VC_ConfigFormat.
 *
 * If VCO_KEYCOLOUR was returned, the video
 * will only be shown at those pixels within the rectangle for which the
 * vga display has the key colour (VC_GetKeyColour() for this).
 *
 * Some devices may support complex regions (VCO_COMPLEX_RECT). In that case,
 * the first rectangle in the area must be the bounding rectangle for
 * the overlay area, followed by one rectangle for each region within it in
 * which the overlay should appear.
 */
BOOL VC_SetOverlayRect(VCUSER_HANDLE, POVERLAY_RECTS);


/*
 * set the offset of the overlay. This changes the panning - ie which
 * source co-ordinate appears as the top left pixel in the overlay rectangle.
 * Initially after a call to VC_SetOverlayRect, the source image will be panned
 * so that the top-left of the source image is aligned with the top-left of the
 * overlay rectangle. This call aligns the top-left of the source image
 * with the top-left of this offset rectangle.
 */
BOOL VC_SetOverlayOffset(VCUSER_HANDLE, PRECT);

/* enable or disable overlay. if the BOOL bOverlay is TRUE, and the overlay
 * key colour and rectangle have been set, overlay will be enabled.
 */
BOOL VC_Overlay(VCUSER_HANDLE, BOOL);

/*
 * enable or disable acquisition.
 * If acquisition is disabled, the overlay image will be frozen.
 *
 * this function will have no effect during capture since the acquisition
 * flag is toggled at each frame capture.
 */
BOOL VC_Capture(VCUSER_HANDLE, BOOL);



/*
 * capture a single frame, synchronously. the video header must point
 * to a data buffer large enough to hold one frame of the format set by
 * VC_ConfigFormat.
 */
// BOOL VC_Frame(VCUSER_HANDLE, LPVIDEOHDR);


/*
 * data streaming.
 *
 * Call VC_StreamInit to prepare for streaming.
 * Call VC_StreamStart to initiate capture.
 * Call VC_AddBuffer to add a capture buffer to the list. As each
 * frame capture completes, the callback function specified in
 * VC_StreamInit will be called with the buffer that has completed.
 *
 * If there is no buffer ready when it is time to capture a frame,
 * a callback will occur. In addition, VC_StreamGetError will return
 * a count of the frames missed this session. VC_StreamGetPos will return
 * the position (in millisecs) reached so far.
 *
 * Call VC_StreamStop to terminate streaming. Any buffer currently in
 * progress may still complete. Uncompleted buffers will remain in the
 * queue. Call VC_Reset to release all buffers from the queue.
 *
 * Finally call VC_StreamFini to tidy up.
 */

/*
 * prepare to start capturing frames
 */
BOOL VC_StreamInit(VCUSER_HANDLE,
		PVCCALLBACK,	// pointer to callback function
		ULONG		// desired capture rate: microseconds per frame
);

/*
 * clean up after capturing. You must have stopped capturing first.
 */
BOOL VC_StreamFini(VCUSER_HANDLE);

/*
 * initiate capturing of frames. Must have called VC_StreamInit first.
 */
BOOL VC_StreamStart(VCUSER_HANDLE);

/*
 * stop capturing frames. Current frame may still complete. All other buffers
 * will remain in the queue until capture is re-started, or they are released
 * by VC_StreamReset.
 */
BOOL VC_StreamStop(VCUSER_HANDLE);

/*
 * cancel all buffers that have been 'add-buffered' but have not
 * completed. This will also force VC_StreamStop if it hasn't already been
 * called.
 */
BOOL VC_StreamReset(VCUSER_HANDLE);

/*
 * get the count of frames that have been skipped since the last call
 * to VC_StreamInit.
 */
ULONG VC_GetStreamError(VCUSER_HANDLE);

/*
 * get the current position within the capture stream (ie time
 * in millisecs since capture began)
 */
BOOL VC_GetStreamPos(VCUSER_HANDLE, LPMMTIME);

/*
 * add a buffer to the queue. The buffer should be large enough
 * to hold one frame of the format specified by VC_ConfigFormat.
 */
// BOOL VC_StreamAddBuffer(VCUSER_HANDLE, LPVIDEOHDR);


/*
 * playback
 *
 * Call VC_DrawFrame to draw a frame into the frame buffer. You should
 * call VC_Overlay functions to arrange for the frame buffer to appear
 * on screen.
 */
BOOL VC_DrawFrame(VCUSER_HANDLE, PDRAWBUFFER);



/*
 * installation/configuration
 *
 * on NT, the following functions will start and stop the
 * kernel driver. The callback function can write profile information
 * to the registry between stopping the driver (if already running) and
 * re-starting the driver. The kernel driver DriverEntry routine is responsible
 * for reading these values from the registry before calling VC_Init().
 *
 * The win-16 implementation will (?) call the callback to write
 * values to the profile, and then call the HW_Startup function. This function
 * is responsible for calling VC_Init, initialising the callback table and
 * initialising the hardware.
 */

/*
 * opaque pointer to the information we need to access the registry/profile.
 */
typedef struct _VC_PROFILE_INFO * PVC_PROFILE_INFO;


/*
 * open a handle to whatever functions are needed to access the registry,
 * service controller or profile. Must call this function before
 * calls to the other VC_ configuration routines.
 *
 * The argument is the name of the driver. This should be the name of
 * the kernel driver file (without path or extension). It will also be used
 * as the registry key name or profile section name.
 */
PVC_PROFILE_INFO VC_OpenProfileAccess(PTCHAR DriverName);

/*
 * close a profile access handle
 */
VOID VC_CloseProfileAccess(PVC_PROFILE_INFO);


/*
 * takes a PVC_PROFILE_INFO returned from VC_OpenProfileAccess, and
 * returns TRUE if we currently have sufficient privilege to perform
 * driver configuration operations.
 */
BOOL VC_ConfigAccess(PVC_PROFILE_INFO);


/*
 * This function is called once the driver has definitely been unloaded, and
 * the profile entry created, but before the driver is re-loaded. It can write
 * any configuration information to the registry. It should return TRUE if
 * it is ok to load and start the kernel-mode driver, or false if some
 * error has occured.
 */
typedef BOOL (*PPROFILE_CALLBACK)(PVOID);


/*
 * start the hardware-access portion of the driver. Call the callback
 * function at a moment when it is possible to write configuration information
 * to the profile using VC_WriteProfile.
 * Returns DRVCNF_OK if all is ok, DRVCNF_CANCEL for failure, or DRVCNF_RESTART if
 * all is ok but a system-restart is needed before the driver will load correctly.
 */
LRESULT VC_InstallDriver(
	    PVC_PROFILE_INFO pProfile,		// access info returned by OpenProfileAccess
	    PPROFILE_CALLBACK pCallback,	// callback function
	    PVOID pContext			// context info for callback	
);

/*
 * Write a single string keyword and DWORD value to the registry or profile
 * for this driver.
 * This can be re-read from the h/w driver using VC_ReadProfile (in either
 * the kernel-mode vckernel.lib version or user mode in the vcuser version).
 *
 * return TRUE for success or FALSE for failure.
 */
BOOL VC_WriteProfile(PVC_PROFILE_INFO pProfile, PTCHAR ValueName, DWORD Value);

/*
 * Write a single string keyword and DWORD value to the registry or profile
 * for this driver.
 * This writes to HKEY_CURRENT_USER and is typically used to store user defaults.
 *
 * return TRUE for success or FALSE for failure.
 */
BOOL VC_WriteProfileUser(PVC_PROFILE_INFO pProfile, PTCHAR ValueName, DWORD Value);


/*
 * read back a driver-specific DWORD profile parameter that was written with
 * VC_WriteProfile. If the valuename cannot be found, the default is returned.
 */
DWORD VC_ReadProfile(PVC_PROFILE_INFO pProfile, PTCHAR ValueName, DWORD dwDefault);

/*
 * read back a driver-specific DWORD profile parameter that was written with
 * VC_WriteProfileUser.  If the valuename cannot be found, the default is returned.
 * This reads from HKEY_CURRENT_USER and is typically used to store user defaults.
 */
DWORD VC_ReadProfileUser(PVC_PROFILE_INFO pProfile, PTCHAR ValueName, DWORD dwDefault);

/*
 * read a string parameter from the device's profile. returns FALSE
 * if it fails to read the string.
 */
BOOL VC_ReadProfileString(
    PVC_PROFILE_INFO pProfile,		// access info from OpenProfile
    PTCHAR ValueName,			// name of value to read
    PTCHAR ValueString,			// put value here
    DWORD ValueLength			// size of ValueString in bytes
);


/*
 * unload a driver. On NT, this stops and removes the kernel-mode driver.
 * On win-16, this calls the Cleanup callback.
 *
 * return DRVCNF_OK if the unload was successful, DRVCNF_CANCEL if it failed, and
 * DRVCNF_RESTART if a system-restart is needed before the removal takes effect.
 *
 * note that after this operation, the PVC_PROFILE_INFO information is still held
 * open. A call to VC_CloseProfileAccess is still needed before exiting.
 */
LRESULT VC_RemoveDriver(PVC_PROFILE_INFO pProfile);



#endif //_VCUSER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\codec\tsbyuv\debug.h ===
/*
 * debug macros
 *
 */

#if DBG
   #ifndef _DEBUG
      #define _DEBUG
   #endif
#endif

#ifndef _DEBUGH
#define _DEBUGH

#ifdef _DEBUG

    #define ModuleDebugLevel MsYuvDebugLevel
    #define ModuleDebugStamp MsYuvDebugStamp


    extern DWORD ModuleDebugLevel;
    extern DWORD ModuleStamp;

	void PlaceStamp(TCHAR * lpszFile, int iLineNum);
    void dbgPrintf(TCHAR * szFormat, ...);

    //
    // a ULONG Is always >= 0
    //
    #define dprintf(_x_)  {{PlaceStamp(__FILE__,__LINE__);dbgPrintf _x_ ;}}
    #define dprintf1(_x_) {if (ModuleDebugLevel >= 1) {PlaceStamp(__FILE__,__LINE__);dbgPrintf _x_ ;}}
    #define dprintf2(_x_) {if (ModuleDebugLevel >= 2) {PlaceStamp(__FILE__,__LINE__);dbgPrintf _x_ ;}}
    #define dprintf3(_x_) {if (ModuleDebugLevel >= 3) {PlaceStamp(__FILE__,__LINE__);dbgPrintf _x_ ;}}
    #define dprintf4(_x_) {if (ModuleDebugLevel >= 4) {PlaceStamp(__FILE__,__LINE__);dbgPrintf _x_ ;}}

	//BOOL FAR PASCAL _Assert(BOOL fExpr, LPSTR szFile, int iLine, LPSTR szExpr);
	BOOL FAR PASCAL _Assert(BOOL fExpr, TCHAR * szFile, int iLine, TCHAR * szExpr);

	#define ASSERT(expr)  _Assert((expr), __FILE__, __LINE__, #expr)

#else

	#define ASSERT(expr)

    #define dbgPrintf 0?0:
    #define dprintf(_x_)
    #define dprintf1(_x_)
    #define dprintf2(_x_)
    #define dprintf3(_x_)
    #define dprintf4(_x_)		

#endif

#endif // DEBUGH
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\codec\msyuv\xlate.c ===
/*
 * Microsoft YUV Codec UyVy -> rgb conversion functions
 *
 * Copyright (c) Microsoft Corporation 1993
 * All Rights Reserved
 *
 */

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>

#include "msyuv.h"


#include "rgb8lut.h"  // can only be included once

/*
 * This module provides translation from YUV into RGB. It translates
 * from 8-bit YUV 4:2:2 (as provided by the Spigot video capture driver)
 * or 7-bit YUV 4:1:1 (as provided by the Bravado driver) into 16-bit RGB555
 * or RGB565. All versions use a look-up table built using YUVToRGB555
 * or YUVToRGB565
 */



#define RANGE(x, lo, hi) max(lo, min(hi, x))

/*
 * Convert a YUV colour into a 15-bit RGB colour.
 *
 * The input Y is in the range 16..235; the input U and V components
 * are in the range -128..+127. The conversion equations for this are
 * (according to CCIR 601):
 *
 * R = Y + 1.371 V
 * G = Y - 0.698 V - 0.336 U
 * B = Y + 1.732 U
 *
 * To avoid floating point, we scale all values by 1024.
 *
 * The resulting RGB values are in the range 16..235: we truncate these to
 * 5 bits each. and return a WORD containing 5-bits each for R, G and B
 * with bit 15 set to 0.
 */
WORD
YUVToRGB555(int y, int u, int v)
{
    int ScaledY = RANGE(y, 16, 235) * 1024;
    int red, green, blue;

    red   = RANGE((ScaledY + (1404 * v))             / 1024, 0, 255);
    green = RANGE((ScaledY - ( 715 * v) - (344 * u)) / 1024, 0, 255);
    blue  = RANGE((ScaledY + (1774 * u))             / 1024, 0, 255);

    return (WORD) (((red & 0xf8) << 7) | ((green & 0xf8) << 2) | ((blue & 0xf8) >>3) );
}


// same as above but converts to RGB565 instead
WORD
YUVToRGB565(int y, int u, int v)
{
    int ScaledY = RANGE(y, 16, 235) * 1024;
    int red, green, blue;

    red   = RANGE((ScaledY + (1404 * v))             / 1024, 0, 255);
    green = RANGE((ScaledY - ( 715 * v) - (344 * u)) / 1024, 0, 255);
    blue  = RANGE((ScaledY + (1774 * u))             / 1024, 0, 255);

    return (WORD) (((red & 0xf8) << 8) | ((green & 0xfc) << 3) | ((blue & 0xf8) >>3) );
}

/* YUV 4:2:2 support ------------------------------------------ */

/*
 * The captured data is in YUV 4:2:2, 8-bits per sample.
 * The data is laid out in alternating Y-U-Y-V-Y-U-Y-V format. Thus
 * every DWORD contains two complete pixels, in the
 * form (msb..lsb) V..Y1..U..Y0
 * All 3 components (y, u and v) are all unsigned 8-bit values in the range
 * 16..235.
 *
 * We have to double scan lines for >= 480 line formats since
 * the hardware only captured one field maximum.
 *
 */

LPVOID BuildUYVYToRGB32( PINSTINFO pinst )
{
    LPVOID pXlate;
    long y, u, v;

    // need 5 lookup tables to do the conversions, each is 256 entries long,
    // and each contains short words.
    //
    short * yip;    // Y impact
    short * vrip;   // red's V impact
    short * vgip;   // green's V impact
    short * ugip;   // green's U impact
    short * ubip;   // blue's U impact

    dprintf2((TEXT("In BuildUYVYToRGB32\n")));

    if (pinst->pXlate != NULL) {
       return(pinst->pXlate);
    }

    dprintf1((TEXT("Allocate memory and building table for BuildUYVYToRGB32\n")));

    /*
     * allocate a table big enough for 5 256-byte arrays
     */
    pXlate = VirtualAlloc (NULL, 5 * 256 * sizeof( short ), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

    if(!pXlate)
       return pXlate;

    // set the table offsets
    //
    yip = pXlate;
    vrip = yip + 256;
    vgip = vrip + 256;
    ugip = vgip + 256;
    ubip = ugip + 256;

    // setup Y impact, etc
    //
    for( y = 0 ; y < 256 ; y++ )
    {
        yip[y] = (short)( ( 1.164 * ( y - 16L ) / 1.0 ) + 0 );
    }
    for( v = 0 ; v < 256 ; v++ )
    {
        vrip[v] = (short)( 1.596 * ( v - 128L ) / 1.0 );
        vgip[v] = (short)( -0.813 * ( v - 128L ) / 1.0 );
    }
    for( u = 0 ; u < 256 ; u++ )
    {
        ugip[u] = (short)( -0.391 * ( u - 128L ) / 1.0 );
        ubip[u] = (short)( 2.018 * ( u - 128L ) / 1.0 );
    }

    return(pXlate);
}

/*
 * build a translation table to translate between YUV and RGB555.
 *
 * This builds a lookup table with 32k 1-word entries: truncate the YUV
 * to 15bits (5-5-5) and look-up in this xlate table to produce the
 * 15-bit rgb value.
 */
LPVOID BuildUYVYToRGB555(PINSTINFO pinst)
{
    LPVOID pXlate;
    LPWORD pRGB555;
    WORD w;

    dprintf2((TEXT("In BuildUYVYToRGB555\n")));

    if (pinst->pXlate != NULL) {
       return(pinst->pXlate);
    }

    dprintf2((TEXT("Allocate memory and building table for BuildUYVYToRGB555\n")));

    /*
     * allocate a table big enough for 32k 2-byte entries
     */
    pXlate = VirtualAlloc (NULL, 2 * 32 * 1024, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

    if(!pXlate)
       return pXlate;

    pRGB555 = (LPWORD)pXlate;

    /*
     * build a 15-bit yuv lookup table by stepping through each entry,
     * converting the yuv index to rgb and storing at that index. The index
     * to this table is a 15-bit value with the y component in bits 14..10,
     * u in bits 9..5 and v in bits 4..0. Note that the y component is unsigned,
     * whereas the u and v components are signed.
     */
    for (w = 0; w < 32*1024; w++) {

 /*
  * the YUVtoRGB55 conversion function takes values 0..255 for y,
  * and -128..+127 for u and v. Pick out the relevant bits of the
  * index for this cell, and shift to get values in this range.
  * Subtract 128 from u and v to shift from 0..255 to -128..+127
  */
       *pRGB555++ = YUVToRGB555(
           (w & 0x7c00) >> 7,
          ((w &  0x3e0) >> 2) - 128,
          ((w &   0x1f) << 3) - 128
           );
    }


    return(pXlate);


}

/*
 * build a translation table to translate between YUV and RGB 5-6-5
 *
 * This builds a lookup table with 32k 1-word entries: truncate the YUV
 * to 15bits (5-5-5) and look-up in this xlate table to produce the
 * 16-bit rgb value.
 */
LPVOID BuildUYVYToRGB565(PINSTINFO pinst)
{
    LPVOID pXlate;
    LPWORD pRGB;
    WORD w;

    dprintf2((TEXT("In BuildUYVYToRGB565\n")));

    if (pinst->pXlate != NULL) {
       return(pinst->pXlate);
    }

    dprintf2((TEXT("Allocate memory and building table for BuildUYVYToRGB565\n")));

    /*
     * allocate a table big enough for 32k 2-byte entries
     */
    pXlate = VirtualAlloc (NULL, 2 * 32 * 1024, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);


    if(!pXlate)
       return pXlate;

    pRGB = (LPWORD)pXlate;

    /*
     * build a 15-bit yuv lookup table by stepping through each entry,
     * converting the yuv index to rgb and storing at that index. The index
     * to this table is a 15-bit value with the y component in bits 14..10,
     * u in bits 9..5 and v in bits 4..0. Note that the y component is unsigned,
     * whereas the u and v components are signed.
     */
    for (w = 0; w < 32*1024; w++) {

    /*
     * the YUVtoRGB conversion function takes values 0..255 for y,
     * and -128..+127 for u and v. Pick out the relevant bits of the
     * index for this cell, and shift to get values in this range.
     * Subtract 128 from u and v to shift from 0..255 to -128..+127
     */
    *pRGB++ = YUVToRGB565(
        (w & 0x7c00) >> 7,
       ((w &  0x3e0) >> 2) - 128,
       ((w &   0x1f) << 3) - 128
        );
    }


    return(pXlate);


}


/*
 * build a translation table to translate between YUV and RGB8
 *
 */
LPVOID BuildUYVYToRGB8(PINSTINFO pinst)
{
    dprintf2((TEXT("In BuildUYVYToRGB8: no dynamically built table. Return NULL;\n")));
    return(0);
}


/*
 * translate YUV 4:2:2 into 16-bit RGB using a lookup table. Flip vertically
 * into DIB format during processing. Double scanlines for formats of
 * 480 lines or greater. Produces 565 or 555 format RGB depending on the
 * xlate table.
 */
VOID
UYVYToRGB16(
    PINSTINFO pinst,
    LPBITMAPINFOHEADER lpbiInput,
    LPVOID lpInput,
    LPBITMAPINFOHEADER lpbiOutput,
    LPVOID lpOutput
)
{
    int RowInc;
    int i, j;
    DWORD uv55, dwPixel;
    int WidthBytes;   // width of one line in BYTES
    BOOL bDuplicate = FALSE;
    PDWORD pSrc, pDst;
    int Height, Width;
    PWORD pXlate;
    int InputHeight;



    Height = abs(lpbiInput->biHeight);
    InputHeight = Height;
    Width  = lpbiInput->biWidth;

    WidthBytes = Width * 2 ; 
    ASSERT(lpbiInput->biBitCount / 8 == 2);

    pXlate = pinst->pXlate;
 
    pSrc = (PDWORD) lpInput;

    dprintf3(("UYVYToRGB: %s %dx%d; %s %dx%dx%d=%d; %s %dx%dx%d=%d\n",
            pinst->bRGB565?"RGB565" : "RGB555",
            Width, Height,
            (PCHAR) &lpbiInput->biCompression,
            lpbiInput->biWidth, lpbiInput->biHeight, lpbiInput->biBitCount, lpbiInput->biSizeImage, 
            lpbiOutput->biCompression == 0 ? "RGB": lpbiOutput->biCompression == BI_BITFIELDS ? "BITF" : (PCHAR) &lpbiOutput->biCompression,
            lpbiOutput->biWidth, lpbiOutput->biHeight, lpbiOutput->biBitCount, lpbiOutput->biSizeImage));


    ASSERT((lpbiOutput->biWidth == lpbiInput->biWidth) && abs(lpbiOutput->biHeight) == abs(lpbiInput->biHeight));

    /*
     * calculate the amount to adjust pDst by at the end of one line
     * of copying. At this point we are at the end of line N. We need
     * to move to the start of line N-1.
     */
    RowInc = WidthBytes * 2;  // two lines!!


    /* remember we are adding to a DWORD pointer */
    RowInc /= sizeof(DWORD);


    if(lpbiOutput->biCompression == FOURCC_UYVY ||
       lpbiOutput->biCompression == FOURCC_YUY2 ||
       lpbiOutput->biCompression == FOURCC_YVYU  ) {

       pDst = (PDWORD) lpOutput;          
       memcpy(pDst, pSrc, Width * Height * lpbiInput->biBitCount / 8);  // Top down

    } else {

        // Output BI_RGB or BI_BITFIELD
        // UVYV->RGB; +RGB->Flip

        if(lpbiOutput->biHeight >= 0) 
           pDst = (PDWORD) ( (LPBYTE)lpOutput + (Height - 1) * WidthBytes );
        else 
           pDst = (PDWORD) lpOutput;


        //
        // UyVy
        //
        if(pinst->dwFormat == FOURCC_UYVY) {

            /* loop copying each scanline */
            for (i = InputHeight; i > 0; i--) {

               /* loop copying two pixels at a time */
               for (j = Width ; j > 0; j -= 2) {

                  /*
                   * get two pixels and convert to 15-bpp YUV
                   */

                  dwPixel = *pSrc++;

                  /* 
                   * Convert UYVY (0x y1 V y0 U) to YUYV (0x V y1 U y0) in which the translation table is built for.
                   */
#if defined(_X86_)

                  _asm {                                                                                          
                                              // FourCC                               
                                              // dwPixel 0x y1  V y0  U          U0 Y0 V0 Y1
                      mov     eax, dwPixel    //         0x y1  V y0  U          U0 Y0 V0 Y1              
                      bswap   eax             //         0x  U y0  V y1          Y1 V0 Y0 U0   
                      rol     eax, 16         //         0x  V y1  U y0          Y0 U0 Y1 V0 
                      mov     dwPixel, eax         
                  }
#else

                  dwPixel = (((dwPixel & 0xff00ff00) >> 8) | ((dwPixel & 0x00ff00ff) << 8));
#endif

                 /*
                  * dwPixel now has two pixels, in this layout (MSB..LSB):
                  *
                  *  V Y1 U Y0
                  *
                  * convert to 2 yuv555 words and lookup in xlate table
                  */

                 /* get common u and v components to lower 10 bits */                          //  9 8  7 6 5  4  3 2 1 0 
                 uv55 = ((dwPixel & 0xf8000000) >> 27) | ((dwPixel & 0x0000f800) >> 6);        // U7U6:U5U4U3 V7:V6V5V4V3   


                 /* build each yuv-655 value by truncating
                  * y to 5 bits and adding the common u and v bits,
                  * look up to convert to rgb, and combine two pixels
                  * into one dword
                  */                                                             //  f e d c  b a  9 8  7 6 5  4  3 2 1 0
                 dwPixel = pXlate[((dwPixel & 0x000000f8) << 7) | uv55 ] |       //  0Y7Y6Y5:Y4Y3 U7U6:U5U4U3 V7:V6V5V4V3
                       (pXlate[((dwPixel & 0x00f80000) >> 9) | uv55 ] << 16);    //  0Y7Y6Y5:Y4Y3 U7U6:U5U4U3 V7:V6V5V4V3

                 /* write two pixels to destination */
                 *pDst++ = dwPixel;

              } // loop per 2 pixels


               /*  
                * bottom up need re-adjust its pointer by 
                * moving dest pointer back to next line
                */

                if(lpbiOutput->biHeight >= 0) {
                    pDst -= RowInc;
                }
            } 
        //
        //  yUyV
        //
        } else if(pinst->dwFormat == FOURCC_YUY2) { 

            /* loop copying each scanline */
            for (i = InputHeight; i > 0; i--) {

               /* loop copying two pixels at a time */
               for (j = Width ; j > 0; j -= 2) {

                  /*
                   * get two pixels and convert to 15-bpp YUV
                   */

                  dwPixel = *pSrc++;

                  // We are already in YUYV (0x V y1 U y0) format.

                 /* get common u and v components to lower 10 bits */                          //  9 8  7 6 5  4  3 2 1 0 
                 uv55 = ((dwPixel & 0xf8000000) >> 27) | ((dwPixel & 0x0000f800) >> 6);        // U7U6:U5U4U3 V7:V6V5V4V3   


                 /* build each yuv-655 value by truncating
                  * y to 5 bits and adding the common u and v bits,
                  * look up to convert to rgb, and combine two pixels
                  * into one dword
                  */                                                             //  f e d c  b a  9 8  7 6 5  4  3 2 1 0
                 dwPixel = pXlate[((dwPixel & 0x000000f8) << 7) | uv55 ] |       //  0Y7Y6Y5:Y4Y3 U7U6:U5U4U3 V7:V6V5V4V3
                       (pXlate[((dwPixel & 0x00f80000) >> 9) | uv55 ] << 16);    //  0Y7Y6Y5:Y4Y3 U7U6:U5U4U3 V7:V6V5V4V3

                 /* write two pixels to destination */
                 *pDst++ = dwPixel;

              } // loop per 2 pixels


               /*  
                * bottom up need re-adjust its pointer by 
                * moving dest pointer back to next line
                */

                if(lpbiOutput->biHeight >= 0) {
                    pDst -= RowInc;
                }
            }

        //
        // yVyU
        //
        } else if(pinst->dwFormat == FOURCC_YVYU) {
            /* loop copying each scanline */
            for (i = InputHeight; i > 0; i--) {

               /* loop copying two pixels at a time */
               for (j = Width ; j > 0; j -= 2) {

                  /*
                   * get two pixels and convert to 15-bpp YUV
                   */

                  dwPixel = *pSrc++;

                  /* 
                   * Convert yVyU (0x U y1 V y0) to YUYV (0x V y1 U y0) in which the translation table is built for.
                   */
#if defined(_X86_)

                  _asm {                                                                                          
                                              // FourCC                               
                                              // dwPixel 0x  U y1  V y0              
                      mov     eax, dwPixel    //         0x  U y1  V y0       
                      bswap   eax             //         0x y0  V y1  U  
                      rol     eax, 8          //         0x  V y1  U y0
                      mov     dwPixel, eax         
                  }
#else
                  // y0 and y1 stay and swap U and V
                  dwPixel = (dwPixel & 0x00ff00ff)  | ((dwPixel & 0x0000ff00) << 16) | ((dwPixel & 0xff000000) >> 16);
#endif

                 /* get common u and v components to lower 10 bits */                          //  9 8  7 6 5  4  3 2 1 0 
                 uv55 = ((dwPixel & 0xf8000000) >> 27) | ((dwPixel & 0x0000f800) >> 6);        // U7U6:U5U4U3 V7:V6V5V4V3   


                 /* build each yuv-655 value by truncating
                  * y to 5 bits and adding the common u and v bits,
                  * look up to convert to rgb, and combine two pixels
                  * into one dword
                  */                                                             //  f e d c  b a  9 8  7 6 5  4  3 2 1 0
                 dwPixel = pXlate[((dwPixel & 0x000000f8) << 7) | uv55 ] |       //  0Y7Y6Y5:Y4Y3 U7U6:U5U4U3 V7:V6V5V4V3
                       (pXlate[((dwPixel & 0x00f80000) >> 9) | uv55 ] << 16);    //  0Y7Y6Y5:Y4Y3 U7U6:U5U4U3 V7:V6V5V4V3

                 /* write two pixels to destination */
                 *pDst++ = dwPixel;

              } // loop per 2 pixels


               /*  
                * bottom up need re-adjust its pointer by 
                * moving dest pointer back to next line
                */

                if(lpbiOutput->biHeight >= 0) {
                    pDst -= RowInc;
                }
            }
        }
    }
}




/*
 * translate YUV 4:2:2 into 8-bit RGB using a lookup table. 
 *   i.e. 0x Y1:V:Y0:U -> ox index1;index0
 */
VOID
UYVYToRGB8(
    PINSTINFO pinst,
     LPBITMAPINFOHEADER lpbiInput,
     LPVOID lpInput,
     LPBITMAPINFOHEADER lpbiOutput,
     LPVOID lpOutput
)
{
    register dwPixel;
    int i, j;
    int SrcRawInc, DstRawInc, Dst3RawInc;
    PDWORD pSrc, pSrc1;        // Every 32bit UYVY
    PWORD pDst, pDst1;         // Convert to two 8bit RGB8
    int Height, Width;
    int InputHeight;
    unsigned char   y0, y1, y2, y3, 
                    u0, u1, 
                    v0, v1;
    unsigned long yuv0, yuv1;   


    Height = abs(lpbiInput->biHeight);
    InputHeight = Height;
    Width  = lpbiInput->biWidth;
 

    dprintf3(("UYVYToRGB8: %dx%d; %s %dx%dx%d=%d; %s %dx%dx%d=%d\n",
             Width, Height,
             (PCHAR) &lpbiInput->biCompression,
             lpbiInput->biWidth, lpbiInput->biHeight, lpbiInput->biBitCount, lpbiInput->biSizeImage, 
             lpbiOutput->biCompression == 0 ? "RGB": lpbiOutput->biCompression == BI_BITFIELDS ? "BITF" : (PCHAR) &lpbiOutput->biCompression,
             lpbiOutput->biWidth, lpbiOutput->biHeight, lpbiOutput->biBitCount, lpbiOutput->biSizeImage));

    ASSERT(lpbiInput->biBitCount == 16 && lpbiOutput->biBitCount == 8);
    ASSERT((lpbiOutput->biWidth == lpbiInput->biWidth) && abs(lpbiOutput->biHeight) == abs(lpbiInput->biHeight));
    ASSERT(( lpbiOutput->biWidth % 8 == 0 ));   // Align with pairs of UYVY:UYVY
    ASSERT(( lpbiOutput->biHeight % 2 == 0 ));  // Even number of lines


    /*
     * calculate the amount to adjust pDst by at the end of one line of copying.
     */

    // 2bytes per pixel; pSrc is PDWORD
    SrcRawInc = Width * 2 / sizeof(DWORD);

    // 1 byte per pixel; pDst is PWORD
    DstRawInc = Width * 1 / sizeof(WORD);
    Dst3RawInc = 3 * DstRawInc;

    pSrc  = (PDWORD) lpInput;
    pSrc1 = pSrc + SrcRawInc; 

    // UVYV->RGB8; same sign:flip.

    if(lpbiOutput->biHeight >= 0) {

       pDst  = (PWORD) ( (LPBYTE)lpOutput + (Height - 1) * Width/sizeof(BYTE) );
       pDst1 = (PWORD) ( (LPBYTE)lpOutput + (Height - 2) * Width/sizeof(BYTE) );
    } else {
       pDst  = (PWORD) lpOutput;
       pDst1 = (PWORD) ((LPBYTE)lpOutput+Width/sizeof(BYTE));
    }

    if(pinst->dwFormat == FOURCC_UYVY) {

        // loop copying two scanline 
        for (i = InputHeight; i > 0; i -= 2) {
            // loop copying four (% 8) pixels at a time 
            for (j = Width ; j > 0; j -= 4) {
            
                //
                // Translate TopLeft, TopRight
                //

                dwPixel = *pSrc++;
                // Pixel is in this format: Y1:V:Y0:U 
                y0 = (dwPixel & 0x0000ff00) >> 8;
                y1 = (dwPixel & 0xff000000) >> 24;
                u0 = (dwPixel & 0x000000ff);
                v0 = (dwPixel & 0x00ff0000) >> 16;

                dwPixel = *pSrc++;
                y2 = (dwPixel & 0x0000ff00) >> 8;
                y3 = (dwPixel & 0xff000000) >> 24;
                u1 = (dwPixel & 0x000000ff);
                v1 = (dwPixel & 0x00ff0000) >> 16;

                yuv0 = yLUT_1[y1+2] | yLUT_0[y0+10] | cLUT_B0[u0]   | cLUT_R0[v0];
                yuv1 = yLUT_1[y3+0] | yLUT_0[y2+8]  | cLUT_B0[u1+4] | cLUT_R0[v1+4];  

                *pDst++ = (WORD) yuv0;
                *pDst++ = (WORD) yuv1;

                //
                // Translate BottomLeft, BottomRight
                //

                dwPixel = *pSrc1++;
                // Pixel is in this format: Y1:V:Y0:U
                y0 = (dwPixel & 0x0000ff00) >> 8;
                y1 = (dwPixel & 0xff000000) >> 24;
                u0 = (dwPixel & 0x000000ff);
                v0 = (dwPixel & 0x00ff0000) >> 16;

                dwPixel = *pSrc1++;
                y2 = (dwPixel & 0x0000ff00) >> 8;
                y3 = (dwPixel & 0xff000000) >> 24;
                u1 = (dwPixel & 0x000000ff);
                v1 = (dwPixel & 0x00ff0000) >> 16;

                yuv0 = yLUT_1[y1+0] | yLUT_0[y0+8]  | cLUT_B0[u0+4] | cLUT_R0[v0+4];
                yuv1 = yLUT_1[y3+2] | yLUT_0[y2+10] | cLUT_B0[u1+0] | cLUT_R0[v1+0];  

                *pDst1++ = (WORD) yuv0;
                *pDst1++ = (WORD) yuv1;

            } // 2 * 4 pixel per loops


           /*  
            * bottom up need re-adjust its pointer by 
            * moving dest pointer back to next line
            */
            if (lpbiOutput->biHeight >= 0) {

               pDst  -= Dst3RawInc;    
               pDst1 -= Dst3RawInc;             

            } else {

                pDst  += DstRawInc; 
                pDst1 += DstRawInc; 
            }

            pSrc  += SrcRawInc; 
            pSrc1 += SrcRawInc; 

        } // 2 lines per loop
    } else if(pinst->dwFormat == FOURCC_YUY2) { // YUY2

        // loop copying two scanline 
        for (i = InputHeight; i > 0; i -= 2) {
            // loop copying four (% 8) pixels at a time 
            for (j = Width ; j > 0; j -= 4) {
            
                //
                // Translate TopLeft, TopRight
                //

                dwPixel = *pSrc++;
                // Pixel is in this format: V:Y1:U:Y0
                u0 = (dwPixel & 0x0000ff00) >> 8;
                v0 = (dwPixel & 0xff000000) >> 24;
                y0 = (dwPixel & 0x000000ff);
                y1 = (dwPixel & 0x00ff0000) >> 16;

                dwPixel = *pSrc++;
                u1 = (dwPixel & 0x0000ff00) >> 8;
                v1 = (dwPixel & 0xff000000) >> 24;
                y2 = (dwPixel & 0x000000ff);
                y3 = (dwPixel & 0x00ff0000) >> 16;

                yuv0 = yLUT_1[y1+2] | yLUT_0[y0+10] | cLUT_B0[u0]   | cLUT_R0[v0];
                yuv1 = yLUT_1[y3+0] | yLUT_0[y2+8]  | cLUT_B0[u1+4] | cLUT_R0[v1+4];  

                *pDst++ = (WORD) yuv0;
                *pDst++ = (WORD) yuv1;

                //
                // Translate BottomLeft, BottomRight
                //

                dwPixel = *pSrc1++;
                // Pixel is in this format: V:Y1:U:Y0
                u0 = (dwPixel & 0x0000ff00) >> 8;
                v0 = (dwPixel & 0xff000000) >> 24;
                y0 = (dwPixel & 0x000000ff);
                y1 = (dwPixel & 0x00ff0000) >> 16;

                dwPixel = *pSrc1++;
                u1 = (dwPixel & 0x0000ff00) >> 8;
                v1 = (dwPixel & 0xff000000) >> 24;
                y2 = (dwPixel & 0x000000ff);
                y3 = (dwPixel & 0x00ff0000) >> 16;

                yuv0 = yLUT_1[y1+0] | yLUT_0[y0+8]  | cLUT_B0[u0+4] | cLUT_R0[v0+4];
                yuv1 = yLUT_1[y3+2] | yLUT_0[y2+10] | cLUT_B0[u1+0] | cLUT_R0[v1+0];  

                *pDst1++ = (WORD) yuv0;
                *pDst1++ = (WORD) yuv1;

            } // 2 * 4 pixel per loops


           /*  
            * bottom up need re-adjust its pointer by 
            * moving dest pointer back to next line
            */
            if (lpbiOutput->biHeight >= 0) {

               pDst  -= Dst3RawInc;    
               pDst1 -= Dst3RawInc;             

            } else {

                pDst  += DstRawInc; 
                pDst1 += DstRawInc; 
            }

            pSrc  += SrcRawInc; 
            pSrc1 += SrcRawInc; 

        } // 2 lines per loop


    } else if(pinst->dwFormat == FOURCC_YVYU) {
        // loop copying two scanline 
        for (i = InputHeight; i > 0; i -= 2) {
            // loop copying four (% 8) pixels at a time 
            for (j = Width ; j > 0; j -= 4) {
            
                //
                // Translate TopLeft, TopRight
                //

                dwPixel = *pSrc++;
                // Pixel is in this format: U:Y1:V:Y0
                v0 = (dwPixel & 0x0000ff00) >> 8;
                u0 = (dwPixel & 0xff000000) >> 24;
                y0 = (dwPixel & 0x000000ff);
                y1 = (dwPixel & 0x00ff0000) >> 16;

                dwPixel = *pSrc++;
                v1 = (dwPixel & 0x0000ff00) >> 8;
                u1 = (dwPixel & 0xff000000) >> 24;
                y2 = (dwPixel & 0x000000ff);
                y3 = (dwPixel & 0x00ff0000) >> 16;

                yuv0 = yLUT_1[y1+2] | yLUT_0[y0+10] | cLUT_B0[u0]   | cLUT_R0[v0];
                yuv1 = yLUT_1[y3+0] | yLUT_0[y2+8]  | cLUT_B0[u1+4] | cLUT_R0[v1+4];  

                *pDst++ = (WORD) yuv0;
                *pDst++ = (WORD) yuv1;

                //
                // Translate BottomLeft, BottomRight
                //

                dwPixel = *pSrc1++;
                // Pixel is in this format: U:Y1:V:Y0
                v0 = (dwPixel & 0x0000ff00) >> 8;
                u0 = (dwPixel & 0xff000000) >> 24;
                y0 = (dwPixel & 0x000000ff);
                y1 = (dwPixel & 0x00ff0000) >> 16;

                dwPixel = *pSrc1++;
                v1 = (dwPixel & 0x0000ff00) >> 8;
                u1 = (dwPixel & 0xff000000) >> 24;
                y2 = (dwPixel & 0x000000ff);
                y3 = (dwPixel & 0x00ff0000) >> 16;

                yuv0 = yLUT_1[y1+0] | yLUT_0[y0+8]  | cLUT_B0[u0+4] | cLUT_R0[v0+4];
                yuv1 = yLUT_1[y3+2] | yLUT_0[y2+10] | cLUT_B0[u1+0] | cLUT_R0[v1+0];  

                *pDst1++ = (WORD) yuv0;
                *pDst1++ = (WORD) yuv1;

            } // 2 * 4 pixel per loops


           /*  
            * bottom up need re-adjust its pointer by 
            * moving dest pointer back to next line
            */
            if (lpbiOutput->biHeight >= 0) {

               pDst  -= Dst3RawInc;    
               pDst1 -= Dst3RawInc;             

            } else {

                pDst  += DstRawInc; 
                pDst1 += DstRawInc; 
            }

            pSrc  += SrcRawInc; 
            pSrc1 += SrcRawInc; 

        } // 2 lines per loop

    }

}

VOID
UYVYToRGB32(
    PINSTINFO pinst,
    LPBITMAPINFOHEADER lpbiInput,
    LPVOID lpInput,
    LPBITMAPINFOHEADER lpbiOutput,
    LPVOID lpOutput
)
{
    int Height = abs( lpbiInput->biHeight );
    int Width = lpbiInput->biWidth;
    short U;
    short V;
    short y0, y1;
    short d;
    DWORD * pSrc = lpInput;
    BYTE * pDst = lpOutput;
    long WidthBytes = Width * 4; // ARGB = 4 bytes
    int i, j;
    DWORD dwYUV;
    long l;

    // set up the lookup table arrays
    //
    short * yip = pinst->pXlate;
    short * vrip = yip + 256;
    short * vgip = vrip + 256;
    short * ugip = vgip + 256;
    short * ubip = ugip + 256;

    // if just a straight copy
    //
    if(lpbiOutput->biCompression == FOURCC_UYVY ||
       lpbiOutput->biCompression == FOURCC_YUY2 ||
       lpbiOutput->biCompression == FOURCC_YVYU  ) 
    {
       memcpy( pDst, pSrc, WidthBytes * Height );  // Top down
       return;

    }

    // flip around if necessary
    //
    if(lpbiOutput->biHeight >= 0) 
    {
       pDst += (Height - 1) * WidthBytes;
    }

    if( pinst->dwFormat == FOURCC_UYVY ) // U0 Y0 V0 Y1 U2 Y2 V2 Y3
    {
        for (i = Height; i > 0; i--) 
        {
           /* loop copying two pixels at a time */
           for (j = Width ; j > 0; j -= 2) 
           {
                // get two YUV pixels at a time
                //
                dwYUV = *pSrc++; // U0 Y0 V0 Y1
                U = (short) ( dwYUV & 0xFF ); 
                    dwYUV = dwYUV >> 8;
                y0 = yip[( dwYUV & 0xFF )];
                    dwYUV = dwYUV >> 8;
                V = (short) ( dwYUV & 0xFF );
                    dwYUV = dwYUV >> 8;
                y1 = yip[( dwYUV & 0xFF )];

                d = y0 + ubip[U]; // blue
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                d = y0 + ugip[U] + vgip[V]; // green
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                d = y0 + vrip[V]; // red
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                        pDst++;

                d = y1 + ubip[U]; // blue
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                d = y1 + ugip[U] + vgip[V]; // green
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                d = y1 + vrip[V]; // red
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                        pDst++;
           } // for j

            // back up two rows to get to the next scanline
            //
            if(lpbiOutput->biHeight >= 0) 
            {
                pDst -= WidthBytes * 2;
            }
        } // for i
    } // UYVY
    else if( pinst->dwFormat == FOURCC_YUY2 ) // Y0 U0 Y1 V0...
    {
        for (i = Height; i > 0; i--) 
        {
           /* loop copying two pixels at a time */
           for (j = Width ; j > 0; j -= 2) 
           {
                // We are already in YUYV (0x V y1 U y0) format.

#if 0 // straight computation
                // get two YUV pixels at a time
                //
                dwYUV = *pSrc++; // Y0 U0 Y1 V0
                y0 = (short) ( dwYUV & 0xFF ) - 16;
                    dwYUV = dwYUV >> 8;
                U = (short) ( dwYUV & 0xFF ) - 128;
                    dwYUV = dwYUV >> 8;
                y1 = (short) ( dwYUV & 0xFF ) - 16;
                    dwYUV = dwYUV >> 8;
                V = (short) ( dwYUV & 0xFF ) - 128;

                l = ( ( y0 * 298L ) + ( 517L * U ) ) / 256; // blue
                if( l < 0 ) l = 0;
                if( l > 255 ) l = 255;
                        *pDst++ = (BYTE) l; // blue
                l = ( ( y0 * 298L ) - ( 100L * U ) - ( 208L * V ) ) / 256; // green
                if( l < 0 ) l = 0;
                if( l > 255 ) l = 255;
                        *pDst++ = (BYTE) l; // green
                l = ( ( y0 * 298L ) + ( 409L * V ) ) / 256; // red
                if( l < 0 ) l = 0;
                if( l > 255 ) l = 255;
                        *pDst++ = (BYTE) l; // red
                        pDst++;

                l = ( ( y1 * 298L ) + ( 517L * U ) ) / 256; // blue
                if( l < 0 ) l = 0;
                if( l > 255 ) l = 255;
                        *pDst++ = (BYTE) l; // blue
                l = ( ( y1 * 298L ) - ( 100L * U ) - ( 208L * V ) ) / 256; // green
                if( l < 0 ) l = 0;
                if( l > 255 ) l = 255;
                        *pDst++ = (BYTE) l; // green
                l = ( ( y1 * 298L ) + ( 409L * V ) ) / 256; // red
                if( l < 0 ) l = 0;
                if( l > 255 ) l = 255;
                        *pDst++ = (BYTE) l; // red
                        pDst++;

#else // table lookup
                // get two YUV pixels at a time
                //
                dwYUV = *pSrc++; // Y0 U0 Y1 V0
                y0 = yip[( dwYUV & 0xFF )];
                    dwYUV = dwYUV >> 8;
                U = (short) ( dwYUV & 0xFF );
                    dwYUV = dwYUV >> 8;
                y1 = yip[( dwYUV & 0xFF )];
                    dwYUV = dwYUV >> 8;
                V = (short) ( dwYUV & 0xFF );


                d = y0 + ubip[U]; // blue
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                d = y0 + ugip[U] + vgip[V]; // green
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                d = y0 + vrip[V]; // red
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                        pDst++;


                d = y1 + ubip[U]; // blue
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                d = y1 + ugip[U] + vgip[V]; // green
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                d = y1 + vrip[V]; // red
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                        pDst++;
#endif
           } // for j

            // back up two rows to get to the next scanline
            //
            if(lpbiOutput->biHeight >= 0) 
            {
                pDst -= WidthBytes * 2;
            }
        } // for i  
    }
    else if( pinst->dwFormat == FOURCC_YVYU ) // Y0 V0 Y1 U0...
    {
        for (i = Height; i > 0; i--) 
        {
           /* loop copying two pixels at a time */
           for (j = Width ; j > 0; j -= 2) 
           {
                // get two YUV pixels at a time
                //
                dwYUV = *pSrc++; // Y0 U0 Y1 V0
                y0 = yip[( dwYUV & 0xFF )];
                    dwYUV = dwYUV >> 8;
                V = (short) ( dwYUV & 0xFF );
                    dwYUV = dwYUV >> 8;
                y1 = yip[( dwYUV & 0xFF )];
                    dwYUV = dwYUV >> 8;
                U = (short) ( dwYUV & 0xFF );

                d = y0 + ubip[U]; // blue
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                d = y0 + ugip[U] + vgip[V]; // green
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                d = y0 + vrip[V]; // red
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                        pDst++;


                d = y1 + ubip[U]; // blue
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                d = y1 + ugip[U] + vgip[V]; // green
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                d = y1 + vrip[V]; // red
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                        pDst++;
           } // for j

            // back up two rows to get to the next scanline
            //
            if(lpbiOutput->biHeight >= 0) 
            {
                pDst -= WidthBytes * 2;
            }
        } // for i
    }

}

VOID
UYVYToRGB24(
    PINSTINFO pinst,
    LPBITMAPINFOHEADER lpbiInput,
    LPVOID lpInput,
    LPBITMAPINFOHEADER lpbiOutput,
    LPVOID lpOutput
)
{
    int Height = abs( lpbiInput->biHeight );
    int Width = lpbiInput->biWidth;
    short U;
    short V;
    short y0, y1;
    short d;
    DWORD * pSrc = lpInput;
    BYTE * pDst = lpOutput;
    long WidthBytes = Width * 3; // RGB = 3 bytes
    int i, j;
    DWORD dwYUV;
    long l;
    short maxd = 0;
    short mind = 255;

    // set up the lookup table arrays
    //
    short * yip = pinst->pXlate;
    short * vrip = yip + 256;
    short * vgip = vrip + 256;
    short * ugip = vgip + 256;
    short * ubip = ugip + 256;

    // if just a straight copy
    //
    if(lpbiOutput->biCompression == FOURCC_UYVY ||
       lpbiOutput->biCompression == FOURCC_YUY2 ||
       lpbiOutput->biCompression == FOURCC_YVYU  ) 
    {
       memcpy( pDst, pSrc, WidthBytes * Height );  // Top down
       return;

    }

    // flip around if necessary
    //
    if(lpbiOutput->biHeight >= 0) 
    {
       pDst += (Height - 1) * WidthBytes;
    }

    if( pinst->dwFormat == FOURCC_UYVY ) // U0 Y0 V0 Y1 U2 Y2 V2 Y3
    {
        for (i = Height; i > 0; i--) 
        {
           /* loop copying two pixels at a time */
           for (j = Width ; j > 0; j -= 2) 
           {
                // get two YUV pixels at a time
                //
                dwYUV = *pSrc++; // U0 Y0 V0 Y1
                U = (short) ( dwYUV & 0xFF ); 
                    dwYUV = dwYUV >> 8;
                y0 = yip[( dwYUV & 0xFF )];
                    dwYUV = dwYUV >> 8;
                V = (short) ( dwYUV & 0xFF );
                    dwYUV = dwYUV >> 8;
                y1 = yip[( dwYUV & 0xFF )];

                d = y0 + ubip[U]; // blue
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                d = y0 + ugip[U] + vgip[V]; // green
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                d = y0 + vrip[V]; // red
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;


                d = y1 + ubip[U]; // blue
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                d = y1 + ugip[U] + vgip[V]; // green
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                d = y1 + vrip[V]; // red
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
           } // for j

            // back up two rows to get to the next scanline
            //
            if(lpbiOutput->biHeight >= 0) 
            {
                pDst -= WidthBytes * 2;
            }
        } // for i
    } // UYVY
    else if( pinst->dwFormat == FOURCC_YUY2 ) // Y0 U0 Y1 V0...
    {
        for (i = Height; i > 0; i--) 
        {
           /* loop copying two pixels at a time */
           for (j = Width ; j > 0; j -= 2) 
           {
                // We are already in YUYV (0x V y1 U y0) format.

#if 0 // straight computation
                // get two YUV pixels at a time
                //
                dwYUV = *pSrc++; // Y0 U0 Y1 V0
                y0 = (short) ( dwYUV & 0xFF ) - 16;
                    dwYUV = dwYUV >> 8;
                U = (short) ( dwYUV & 0xFF ) - 128;
                    dwYUV = dwYUV >> 8;
                y1 = (short) ( dwYUV & 0xFF ) - 16;
                    dwYUV = dwYUV >> 8;
                V = (short) ( dwYUV & 0xFF ) - 128;

                l = ( ( y0 * 298L ) + ( 517L * U ) ) / 256; // blue
                if( l < 0 ) l = 0;
                if( l > 255 ) l = 255;
                        *pDst++ = (BYTE) l; // blue
                l = ( ( y0 * 298L ) - ( 100L * U ) - ( 208L * V ) ) / 256; // green
                if( l < 0 ) l = 0;
                if( l > 255 ) l = 255;
                        *pDst++ = (BYTE) l; // green
                l = ( ( y0 * 298L ) + ( 409L * V ) ) / 256; // red
                if( l < 0 ) l = 0;
                if( l > 255 ) l = 255;
                        *pDst++ = (BYTE) l; // red
                l = ( ( y1 * 298L ) + ( 517L * U ) ) / 256; // blue
                if( l < 0 ) l = 0;
                if( l > 255 ) l = 255;
                        *pDst++ = (BYTE) l; // blue
                l = ( ( y1 * 298L ) - ( 100L * U ) - ( 208L * V ) ) / 256; // green
                if( l < 0 ) l = 0;
                if( l > 255 ) l = 255;
                        *pDst++ = (BYTE) l; // green
                l = ( ( y1 * 298L ) + ( 409L * V ) ) / 256; // red
                if( l < 0 ) l = 0;
                if( l > 255 ) l = 255;
                        *pDst++ = (BYTE) l; // red
#else // table lookup
                // get two YUV pixels at a time
                //
                dwYUV = *pSrc++; // Y0 U0 Y1 V0
                y0 = yip[( dwYUV & 0xFF )];
                    dwYUV = dwYUV >> 8;
                U = (short) ( dwYUV & 0xFF );
                    dwYUV = dwYUV >> 8;
                y1 = yip[( dwYUV & 0xFF )];
                    dwYUV = dwYUV >> 8;
                V = (short) ( dwYUV & 0xFF );


                d = y0 + ubip[U]; // blue
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                d = y0 + ugip[U] + vgip[V]; // green
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                d = y0 + vrip[V]; // red
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;


                d = y1 + ubip[U]; // blue
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                d = y1 + ugip[U] + vgip[V]; // green
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                d = y1 + vrip[V]; // red
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
#endif
           } // for j

            // back up two rows to get to the next scanline
            //
            if(lpbiOutput->biHeight >= 0) 
            {
                pDst -= WidthBytes * 2;
            }
        } // for i  
    }
    else if( pinst->dwFormat == FOURCC_YVYU ) // Y0 V0 Y1 U0...
    {
        for (i = Height; i > 0; i--) 
        {
           /* loop copying two pixels at a time */
           for (j = Width ; j > 0; j -= 2) 
           {
                // get two YUV pixels at a time
                //
                dwYUV = *pSrc++; // Y0 U0 Y1 V0
                y0 = yip[( dwYUV & 0xFF )];
                    dwYUV = dwYUV >> 8;
                V = (short) ( dwYUV & 0xFF );
                    dwYUV = dwYUV >> 8;
                y1 = yip[( dwYUV & 0xFF )];
                    dwYUV = dwYUV >> 8;
                U = (short) ( dwYUV & 0xFF );

                d = y0 + ubip[U]; // blue
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                d = y0 + ugip[U] + vgip[V]; // green
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                d = y0 + vrip[V]; // red
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;

                d = y1 + ubip[U]; // blue
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                d = y1 + ugip[U] + vgip[V]; // green
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
                d = y1 + vrip[V]; // red
                        if( d < 0 ) d = 0;
                        if( d > 255 ) d = 255;
                        *pDst++ = (BYTE) d;
           } // for j

            // back up two rows to get to the next scanline
            //
            if(lpbiOutput->biHeight >= 0) 
            {
                pDst -= WidthBytes * 2;
            }
        } // for i
    }

}


#define OFFSET 10
#define STDPALCOLOURS 256
/*****************************************************************************
 *
 * DecompressGetPalette() implements ICM_GET_PALETTE
 *
 * This function has no Compress...() equivalent
 *
 * It is used to pull the palette from a frame in order to possibly do
 * a palette change.
 *
 ****************************************************************************/
DWORD NEAR PASCAL DecompressGetPalette(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut)
{
    DWORD dw;
    unsigned char * lpPalArea;
    long Index, cntEntries;
    HDC hDC;

    PALETTEENTRY apeSystem[STDPALCOLOURS]; // OFFSET];


    dprintf2((TEXT("DecompressGetPalette()\n")));
    if (dw = DecompressQuery(pinst, lpbiIn, NULL))
     return dw;

    if (lpbiOut->biBitCount != 8) {  /* 8-bit only for palettes */ 
        dprintf1(("DecompressGetPalette: Unsupported lpbiOut->biBitCount=%d\n", lpbiOut->biBitCount)); 
     return (DWORD)ICERR_ERROR;
    }

    // Initialise the palette entries in the header

    dprintf1(("DecompressGetPalette(): in->biSize=%d, out->biSize=%d\n", lpbiIn->biSize, lpbiOut->biSize));


    // Get the standard system colours

    if ( hDC = GetDC(GetDesktopWindow()) )
    {
        cntEntries = GetSystemPaletteEntries(hDC,0,STDPALCOLOURS,apeSystem);
        ReleaseDC(GetDesktopWindow(),hDC);
    }

    if (cntEntries == 0) {
        dprintf2(("DecompressGetPalette:cntEntries is 0; GetSystemPaletteEntries failed.\n"));

        lpbiOut->biClrUsed      = 0;
        lpbiOut->biClrImportant = 0; 
        return (DWORD) ICERR_OK;
    }


    lpbiOut->biClrUsed      = STDPALCOLOURS;
    lpbiOut->biClrImportant = 0;

    // Adding system device colours to be dithered
    lpPalArea = (unsigned char *)lpbiOut + (int)lpbiOut->biSize;
    
    // Copy the first ten VGA system colours

    for (Index = 0;Index < OFFSET;Index++) {
        lpPalArea[Index*4+0] = apeSystem[Index].peRed;
        lpPalArea[Index*4+1] = apeSystem[Index].peGreen;
        lpPalArea[Index*4+2] = apeSystem[Index].peBlue;
        lpPalArea[Index*4+3] = 0;
    }


    // Copy the palette we dither to one colour at a time

    for (Index = OFFSET;Index < STDPALCOLOURS-OFFSET;Index++) {
        lpPalArea[Index*4+0] = PalTable[Index*4+2];
        lpPalArea[Index*4+1] = PalTable[Index*4+1];
        lpPalArea[Index*4+2] = PalTable[Index*4+0];
        lpPalArea[Index*4+3] = 0;
    }

     // Copy the last ten VGA system colours

    for (Index = STDPALCOLOURS-OFFSET;Index < STDPALCOLOURS;Index++) {
        lpPalArea[Index*4+0] = apeSystem[Index].peRed;
        lpPalArea[Index*4+1] = apeSystem[Index].peGreen;
        lpPalArea[Index*4+2] = apeSystem[Index].peBlue;
        lpPalArea[Index*4+3] = 0;
    }

 return (DWORD)ICERR_OK;

}


VOID FreeXlate(PINSTINFO pinst)
{

    ASSERT(pinst != NULL);        
    if (pinst && pinst->pXlate != NULL) {
       VirtualFree(pinst->pXlate, 0, MEM_RELEASE); 
       pinst->pXlate = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\codec\tsbyuv\msyuv.h ===
/*
 * msyuv.h   Microsoft YUV Codec
 *
 * Copyright (c) Microsoft 1993.
 */

#include <winmm.h>
#include <vfw.h>
#include "debug.h"

// #define COLOR_MODIFY

#ifndef FOURCC_YUV411
#define FOURCC_YUV411           mmioFOURCC('Y', '4', '1', '1')
#endif

#ifndef FOURCC_YUV422
//
// compatible with the format produced by the 16-bit Spigot driver.
//
#define FOURCC_YUV422           mmioFOURCC('S', '4', '2', '2')
#endif

#ifdef  TOSHIBA
//
// compatible with the format produced by the Pistachio driver.
//
#ifndef FOURCC_YUV12
#if 1
#define FOURCC_YUV12            mmioFOURCC('T', '4', '2', '0')
#else
#define FOURCC_YUV12            mmioFOURCC('I', '4', '2', '0')
#endif
#endif

//
// compatible with the format produced by the Pistachio driver.
//
#ifndef FOURCC_YUV9
#define FOURCC_YUV9             mmioFOURCC('Y', 'V', 'U', '9')
#endif
#endif//TOSHIBA




typedef struct {
    DWORD       dwFlags;        // flags from ICOPEN
    DWORD       dwFormat;       // format that pXlate is built for (FOURCC)
    PVOID       pXlate;         // xlate table (for decompress)
    BOOL        bRGB565;        // true if 5-6-5 format output (otherwise 555)
#ifdef  TOSHIBA
#ifdef  COLOR_MODIFY
    BOOL        bRGB24;         // true if 24 bit format output (otherwise 16 bit)
#endif//COLOR_MODIFY
#endif//TOSHIBA

#if 0
    /* support for drawing */
    VCUSER_HANDLE vh;
    HWND        hwnd;
    RECT        rcSource;
    RECT        rcDest;
    HBRUSH      hKeyBrush;
#endif

} INSTINFO, *PINSTINFO;




/*
 * message processing functions in msyuv.c
 */
INSTINFO * NEAR PASCAL Open(ICOPEN FAR * icinfo);
DWORD NEAR PASCAL Close(INSTINFO * pinst);
BOOL NEAR PASCAL QueryAbout(INSTINFO * pinst);
DWORD NEAR PASCAL About(INSTINFO * pinst, HWND hwnd);
BOOL NEAR PASCAL QueryConfigure(INSTINFO * pinst);
DWORD NEAR PASCAL Configure(INSTINFO * pinst, HWND hwnd);
DWORD NEAR PASCAL GetState(INSTINFO * pinst, LPVOID pv, DWORD dwSize);
DWORD NEAR PASCAL SetState(INSTINFO * pinst, LPVOID pv, DWORD dwSize);
DWORD NEAR PASCAL GetInfo(INSTINFO * pinst, ICINFO FAR *icinfo, DWORD dwSize);
DWORD FAR PASCAL CompressQuery(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut);
DWORD FAR PASCAL CompressGetFormat(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut);
DWORD FAR PASCAL CompressBegin(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut);
DWORD FAR PASCAL CompressGetSize(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut);
DWORD FAR PASCAL Compress(INSTINFO * pinst, ICCOMPRESS FAR *icinfo, DWORD dwSize);
DWORD FAR PASCAL CompressEnd(INSTINFO * pinst);
DWORD NEAR PASCAL DecompressQuery(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut);
DWORD NEAR PASCAL DecompressGetFormat(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut);
DWORD NEAR PASCAL DecompressBegin(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut);
DWORD NEAR PASCAL Decompress(INSTINFO * pinst, ICDECOMPRESS FAR *icinfo, DWORD dwSize);
DWORD NEAR PASCAL DecompressGetPalette(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut);
DWORD NEAR PASCAL DecompressEnd(INSTINFO * pinst);


DWORD DrawQuery(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut);
DWORD DrawBegin(INSTINFO * pinst,ICDRAWBEGIN FAR *icinfo, DWORD dwSize);
DWORD Draw(INSTINFO * pinst, ICDRAW FAR *icinfo, DWORD dwSize);
DWORD DrawEnd(INSTINFO * pinst);
DWORD DrawWindow(PINSTINFO pinst, PRECT prc);


/* yuv411 or yuv422 to rgb translation, in xlate.c */

/*
 * build yuv411->RGB555 xlate table
 */
LPVOID BuildYUVToRGB555(PINSTINFO pinst);

// build yuv411 -> rgb565
LPVOID BuildYUVToRGB565(PINSTINFO pinst);


/*
 * build yuv422 -> RGB555 xlate table
 */
LPVOID BuildYUV422ToRGB555(PINSTINFO pinst);


// build yuv422 -> RGB565
LPVOID BuildYUV422ToRGB565(PINSTINFO pinst);


#ifdef  TOSHIBA
#ifdef  COLOR_MODIFY
/*
 * build yuv12 -> RGB555 xlate table
 */
LPVOID BuildYUVToRB(PINSTINFO pinst);

#else //COLOR_MODIFY
/*
 * build yuv12 -> RGB555 xlate table
 */
LPVOID BuildYUV12ToRGB555(PINSTINFO pinst);


// build yuv12 -> RGB565
LPVOID BuildYUV12ToRGB565(PINSTINFO pinst);
#endif//COLOR_MODIFY
#endif//TOSHIBA


/*
 * translate one frame from yuv411 to rgb 555 or 565
 */
VOID YUV411ToRGB(PINSTINFO pinst,
                 LPBITMAPINFOHEADER lpbiInput,
                 LPVOID lpInput,
                 LPBITMAPINFOHEADER lpbiOutput,
                 LPVOID lpOutput);

VOID YUV422ToRGB(PINSTINFO pinst,
                 LPBITMAPINFOHEADER lpbiInput,
                 LPVOID lpInput,
                 LPBITMAPINFOHEADER lpbiOutput,
                 LPVOID lpOutput);

#ifdef  TOSHIBA
#ifdef  COLOR_MODIFY
VOID YUV12ToRGB24(PINSTINFO pinst,
                 LPBITMAPINFOHEADER lpbiInput,
                 LPVOID lpInput,
                 LPBITMAPINFOHEADER lpbiOutput,
                 LPVOID lpOutput);

VOID YUV12ToRGB565(PINSTINFO pinst,
                 LPBITMAPINFOHEADER lpbiInput,
                 LPVOID lpInput,
                 LPBITMAPINFOHEADER lpbiOutput,
                 LPVOID lpOutput);

VOID YUV12ToRGB555(PINSTINFO pinst,
                 LPBITMAPINFOHEADER lpbiInput,
                 LPVOID lpInput,
                 LPBITMAPINFOHEADER lpbiOutput,
                 LPVOID lpOutput);

VOID YUV9ToRGB24(PINSTINFO pinst,
                 LPBITMAPINFOHEADER lpbiInput,
                 LPVOID lpInput,
                 LPBITMAPINFOHEADER lpbiOutput,
                 LPVOID lpOutput);

VOID YUV9ToRGB565(PINSTINFO pinst,
                 LPBITMAPINFOHEADER lpbiInput,
                 LPVOID lpInput,
                 LPBITMAPINFOHEADER lpbiOutput,
                 LPVOID lpOutput);

VOID YUV9ToRGB555(PINSTINFO pinst,
                 LPBITMAPINFOHEADER lpbiInput,
                 LPVOID lpInput,
                 LPBITMAPINFOHEADER lpbiOutput,
                 LPVOID lpOutput);
#else //COLOR_MODIFY
VOID YUV12ToRGB(PINSTINFO pinst,
                 LPBITMAPINFOHEADER lpbiInput,
                 LPVOID lpInput,
                 LPBITMAPINFOHEADER lpbiOutput,
                 LPVOID lpOutput);

VOID YUV9ToRGB(PINSTINFO pinst,
                 LPBITMAPINFOHEADER lpbiInput,
                 LPVOID lpInput,
                 LPBITMAPINFOHEADER lpbiOutput,
                 LPVOID lpOutput);
#endif//COLOR_MODIFY
#endif//TOSHIBA

VOID FreeXlate(PINSTINFO pinst);




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\codec\tsbyuv\msyuv.c ===
/*----------------------------------------------------------------------+
| msyuv.c - Microsoft YUV Codec                                         |
|                                                                       |
| Copyright (c) 1993 Microsoft Corporation.                             |
| All Rights Reserved.                                                  |
|                                                                       |
+----------------------------------------------------------------------*/

#include <windows.h>
#include <windowsx.h>
//#include <mmsystem.h>

#ifndef _WIN32
#include "stdarg.h"
#endif

#ifdef _WIN32
#include <memory.h>     /* for memcpy */
#endif

#include "msyuv.h"

WCHAR    szDescription[] = L"Toshiba YUV Codec";
WCHAR    szName[]        = L"Toshiba YUV411";
WCHAR    szAbout[]       = L"About";

#define VERSION         0x00010000      // 1.0



/*****************************************************************************
 ****************************************************************************/
INSTINFO * NEAR PASCAL Open(ICOPEN FAR * icinfo)
{
    INSTINFO *  pinst;

    //
    // refuse to open if we are not being opened as a Video compressor
    //
    if (icinfo->fccType != ICTYPE_VIDEO)
        return NULL;

    //
    // dwFlags contain wMode
    //
    if(   icinfo->dwFlags != ICMODE_QUERY            // Open for infomational purpose        
       && icinfo->dwFlags != ICMODE_DECOMPRESS 

       #ifdef ICM_COMPRESS_SUPPORTED
       && icinfo->dwFlags != ICMODE_COMPRESS      
       #endif 

       #ifdef ICM_DRAW_SUPPORTED      
       && icinfo->dwFlags != ICMODE_DRAW          
       #endif 
      ) {
        
        dprintf1((TEXT("Open: unsupported wMode=%d\n"), icinfo->dwFlags));
        return NULL;
    }

    pinst = (INSTINFO *)LocalAlloc(LPTR, sizeof(INSTINFO));

    if (!pinst) {
        icinfo->dwError = (DWORD)ICERR_MEMORY;
        return NULL;
    }

    //
    // init structure
    //
    pinst->dwFlags = icinfo->dwFlags;
    pinst->pXlate = NULL;

    //
    // return success.
    //
    icinfo->dwError = ICERR_OK;

    return pinst;
}

/*****************************************************************************
 ****************************************************************************/
DWORD NEAR PASCAL Close(INSTINFO * pinst)
{

    if (pinst->pXlate) {
        DecompressEnd(pinst);
    }

#if ICM_DRAW_SUPPORTED
    if (pinst->vh) {
        DrawEnd(pinst);
    }
#endif

    LocalFree((HLOCAL)pinst);

    return 1;
}

/*****************************************************************************
 ****************************************************************************/

BOOL NEAR PASCAL QueryAbout(INSTINFO * pinst)
{
    return TRUE;
}

DWORD NEAR PASCAL About(INSTINFO * pinst, HWND hwnd)
{
    MessageBoxW(hwnd,szDescription,szAbout,MB_OK|MB_ICONINFORMATION);
    return ICERR_OK;
}

/*****************************************************************************
 ****************************************************************************/
BOOL NEAR PASCAL QueryConfigure(INSTINFO * pinst)
{
    return FALSE;
}

DWORD NEAR PASCAL Configure(INSTINFO * pinst, HWND hwnd)
{
    return (TRUE);
}

/*****************************************************************************
 ****************************************************************************/
/*
 * lossless translation - hence no need for state adjustments
 */
DWORD NEAR PASCAL GetState(INSTINFO * pinst, LPVOID pv, DWORD dwSize)
{
        return 0;

}

/*****************************************************************************
 ****************************************************************************/
DWORD NEAR PASCAL SetState(INSTINFO * pinst, LPVOID pv, DWORD dwSize)
{
        return(0);
}

/*****************************************************************************
 ****************************************************************************/
DWORD NEAR PASCAL GetInfo(INSTINFO * pinst, ICINFO FAR *icinfo, DWORD dwSize)
{
    if (icinfo == NULL)
        return sizeof(ICINFO);

    if (dwSize < sizeof(ICINFO))
        return 0;

    icinfo->dwSize            = sizeof(ICINFO);
    icinfo->fccType           = ICTYPE_VIDEO;
    icinfo->fccHandler        = FOURCC_YUV411;
    icinfo->dwFlags           = 0;

    icinfo->dwVersion         = VERSION;
    icinfo->dwVersionICM      = ICVERSION;
    wcscpy(icinfo->szDescription, szDescription);
    wcscpy(icinfo->szName, szName);

    return sizeof(ICINFO);
}

/*****************************************************************************
 ****************************************************************************/
DWORD FAR PASCAL CompressQuery(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut)
{
    return ((DWORD) ICERR_BADFORMAT);
}

/*****************************************************************************
 ****************************************************************************/
DWORD FAR PASCAL CompressGetFormat(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut)
{

    return((DWORD) ICERR_BADFORMAT);

}

/*****************************************************************************
 ****************************************************************************/


DWORD FAR PASCAL CompressBegin(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut)
{

    return((DWORD) ICERR_ERROR);

}

/*****************************************************************************
 ****************************************************************************/
DWORD FAR PASCAL CompressGetSize(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut)
{
    return (0);
}

/*****************************************************************************
 ****************************************************************************/
DWORD FAR PASCAL Compress(INSTINFO * pinst, ICCOMPRESS FAR *icinfo, DWORD dwSize)
{
    return((DWORD) ICERR_ERROR);

}

/*****************************************************************************
 ****************************************************************************/
DWORD FAR PASCAL CompressEnd(INSTINFO * pinst)
{
    return (DWORD)ICERR_ERROR;

}

/*****************************************************************************
 ****************************************************************************/
DWORD NEAR PASCAL DecompressQuery(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut)
{
    //
    // determine if the input DIB data is in a format we like.
    //
#ifdef  TOSHIBA
#if DBG
//  DbgBreakPoint();
#endif
    if (lpbiIn == NULL ||
        ( (lpbiIn->biCompression != FOURCC_YUV411)  &&
          (lpbiIn->biCompression != FOURCC_YUV422)  &&
          (lpbiIn->biCompression != FOURCC_YUV9)    &&   // add YUV9
          (lpbiIn->biCompression != FOURCC_YUV12 ))) {   // add YUV12
#else //TOSHIBA
    if (lpbiIn == NULL ||
        (lpbiIn->biBitCount != 16) ||
        ( (lpbiIn->biCompression != FOURCC_YUV411)  &&
          (lpbiIn->biCompression != FOURCC_YUV422))) {
#endif//TOSHIBA
        dprintf((TEXT("bad input format")));
        return (DWORD)ICERR_BADFORMAT;
    }

    //
    //  are we being asked to query just the input format?
    //
    if (lpbiOut == NULL) {
        return ICERR_OK;
    }

    // check output format to make sure we can convert to this

    // must be full dib
    if (lpbiOut->biCompression == BI_RGB) {
        pinst->bRGB565 = FALSE;
#ifdef  TOSHIBA
#ifdef  COLOR_MODIFY
        if (lpbiOut->biBitCount == 24) {
            pinst->bRGB24 = TRUE;
        } else {
            pinst->bRGB24 = FALSE;
        }
#endif//COLOR_MODIFY
#endif//TOSHIBA
    } else if ((lpbiOut->biCompression == BI_BITFIELDS) &&
               (lpbiOut->biBitCount == 16) &&
               (((LPDWORD)(lpbiOut+1))[0] == 0x00f800) &&
               (((LPDWORD)(lpbiOut+1))[1] == 0x0007e0) &&
               (((LPDWORD)(lpbiOut+1))[2] == 0x00001f))  {

        dprintf1((TEXT("rgb565 output")));
        pinst->bRGB565 = TRUE;
#ifdef  TOSHIBA
#ifdef  COLOR_MODIFY
        pinst->bRGB24 = FALSE;
#endif//COLOR_MODIFY
#endif//TOSHIBA
    } else {

        dprintf1((TEXT("bad compression for output")));

        return (DWORD)ICERR_BADFORMAT;
    }

    /* must be 1:1 (no stretching) */
    if ((lpbiOut->biWidth != lpbiIn->biWidth) ||
        (lpbiOut->biHeight != lpbiIn->biHeight)) {
            dprintf1((TEXT("YUV can't stretch: %dx%d->%dx%d"),
                    lpbiIn->biWidth, lpbiIn->biHeight,
                    lpbiOut->biWidth, lpbiOut->biHeight
            ));

            return((DWORD) ICERR_BADFORMAT);
    }

    /*
     * we translate to 16 bits
     */

#ifdef  TOSHIBA
#ifdef  COLOR_MODIFY
    if ((lpbiOut->biBitCount != 16) &&
        (lpbiOut->biBitCount != 24)) {
        dprintf1((TEXT("YUV to 16 or 24 only")));
        return((DWORD) ICERR_BADFORMAT);
    }
#else //COLOR_MODIFY
    if (lpbiOut->biBitCount != 16) {
        dprintf1((TEXT("YUV 16:16 only")));
        return((DWORD) ICERR_BADFORMAT);
    }
#endif//COLOR_MODIFY
#else //TOSHIBA
    if (lpbiOut->biBitCount != 16) {
        dprintf1((TEXT("YUV 16:16 only")));
        return((DWORD) ICERR_BADFORMAT);
    }
#endif//TOSHIBA

    return ICERR_OK;
}

/*****************************************************************************
 ****************************************************************************/
DWORD  DecompressGetFormat(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut)
{
    DWORD dw;
    int dx,dy;

    dw = DecompressQuery(pinst, lpbiIn, NULL);
    if (dw != ICERR_OK) {
        return dw;
    }

    //
    // if lpbiOut == NULL then, return the size required to hold a output
    // format
    //
    if (lpbiOut == NULL) {
        dprintf2((TEXT("get format size query")));
        return (int)lpbiIn->biSize + (int)lpbiIn->biClrUsed * sizeof(RGBQUAD);
    }

    memcpy(lpbiOut, lpbiIn,
        (int)lpbiIn->biSize + (int)lpbiIn->biClrUsed * sizeof(RGBQUAD));

    dx = (int)lpbiIn->biWidth & ~3;
    dy = (int)lpbiIn->biHeight & ~3;

    lpbiOut->biWidth       = dx;
    lpbiOut->biHeight      = dy;
#ifdef  TOSHIBA
    lpbiOut->biBitCount    = 16;
#else //TOSHIBA
    lpbiOut->biBitCount    = lpbiIn->biBitCount;    // convert 16->16
#endif//TOSHIBA

    lpbiOut->biCompression = BI_RGB;
    lpbiOut->biSizeImage   = dx*dy*2;

    return ICERR_OK;
}

/*****************************************************************************
 ****************************************************************************/
DWORD NEAR PASCAL DecompressBegin(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut)
{
    DWORD dw;


    /* check that the conversion formats are valid */
    dw = DecompressQuery(pinst, lpbiIn, lpbiOut);
    if (dw != ICERR_OK) {
        return dw;
    }

    /* init the yuv-to-rgb55 xlate table if not already inited */

    /* free up the existing table if the formats differ */
    if (lpbiIn->biCompression != pinst->dwFormat) {
        if (pinst->pXlate != NULL) {
            DecompressEnd(pinst);
        }
    }

    if (pinst->pXlate == NULL) {

        switch(lpbiIn->biCompression) {
        case FOURCC_YUV411:
            if (pinst->bRGB565) {
                pinst->pXlate = BuildYUVToRGB565(pinst);
            } else {
                pinst->pXlate = BuildYUVToRGB555(pinst);
            }
            break;

        case FOURCC_YUV422:
            if (pinst->bRGB565) {
                pinst->pXlate = BuildYUV422ToRGB565(pinst);
            } else {
                pinst->pXlate = BuildYUV422ToRGB555(pinst);
            }
            break;

#ifdef  TOSHIBA
#ifdef  COLOR_MODIFY
        case FOURCC_YUV12:
            pinst->pXlate = BuildYUVToRB(pinst);
            break;

        case FOURCC_YUV9:
            pinst->pXlate = BuildYUVToRB(pinst);              // same to YUV12
            break;
#else //COLOR_MODIFY
        case FOURCC_YUV12:
            if (pinst->bRGB565) {
                pinst->pXlate = BuildYUV12ToRGB565(pinst);
            } else {
                pinst->pXlate = BuildYUV12ToRGB555(pinst);
            }
            break;

        case FOURCC_YUV9:
            if (pinst->bRGB565) {
                pinst->pXlate = BuildYUV12ToRGB565(pinst);              // same to YUV12
            } else {
                pinst->pXlate = BuildYUV12ToRGB555(pinst);              // same to YUV12
            }
            break;
#endif//COLOR_MODIFY
#endif//TOSHIBA

        default:
            return((DWORD) ICERR_BADFORMAT);
        }

        if (pinst->pXlate == NULL) {
            return((DWORD) ICERR_MEMORY);
        }
        pinst->dwFormat = lpbiIn->biCompression;
    }

    return(ICERR_OK);

}

/*****************************************************************************
 ****************************************************************************/
DWORD NEAR PASCAL Decompress(INSTINFO * pinst, ICDECOMPRESS FAR *icinfo, DWORD dwSize)
{
    /* must have been a DecompressBegin first */
    if (pinst->pXlate == NULL) {
        return((DWORD) ICERR_ERROR);
    }

#ifdef  TOSHIBA
    if (pinst->dwFormat == FOURCC_YUV9) {

#ifdef  COLOR_MODIFY
        if (pinst->bRGB24) {
            YUV9ToRGB24(pinst,
                icinfo->lpbiInput,
                icinfo->lpInput,
                icinfo->lpbiOutput,
                icinfo->lpOutput
            );
        } else {
            if (pinst->bRGB565) {
                YUV9ToRGB565(pinst,
                    icinfo->lpbiInput,
                    icinfo->lpInput,
                    icinfo->lpbiOutput,
                    icinfo->lpOutput
                );
            } else {
                YUV9ToRGB555(pinst,
                    icinfo->lpbiInput,
                    icinfo->lpInput,
                    icinfo->lpbiOutput,
                    icinfo->lpOutput
                );
            }
        }
#else //COLOR_MODIFY
        YUV9ToRGB(pinst,
            icinfo->lpbiInput,
            icinfo->lpInput,
            icinfo->lpbiOutput,
            icinfo->lpOutput
        );
#endif//COLOR_MODIFY

    } else

    if (pinst->dwFormat == FOURCC_YUV12) {

#ifdef  COLOR_MODIFY
        if (pinst->bRGB24) {
            YUV12ToRGB24(pinst,
                icinfo->lpbiInput,
                icinfo->lpInput,
                icinfo->lpbiOutput,
                icinfo->lpOutput
            );
        } else {
            if (pinst->bRGB565) {
                YUV12ToRGB565(pinst,
                    icinfo->lpbiInput,
                    icinfo->lpInput,
                    icinfo->lpbiOutput,
                    icinfo->lpOutput
                );
            } else {
                YUV12ToRGB555(pinst,
                    icinfo->lpbiInput,
                    icinfo->lpInput,
                    icinfo->lpbiOutput,
                    icinfo->lpOutput
                );
            }
        }
#else //COLOR_MODIFY
        YUV12ToRGB(pinst,
            icinfo->lpbiInput,
            icinfo->lpInput,
            icinfo->lpbiOutput,
            icinfo->lpOutput
        );
#endif//COLOR_MODIFY

    } else
#endif//TOSHIBA

    if (pinst->dwFormat == FOURCC_YUV411) {

        YUV411ToRGB(pinst,
            icinfo->lpbiInput,
            icinfo->lpInput,
            icinfo->lpbiOutput,
            icinfo->lpOutput
        );
    } else {

        /*
         * for compatibility with 16-bit Spigot driver,
         * check for Guard field at start of data
         */
        LPDWORD lpInput = icinfo->lpInput;

        if (*lpInput == FOURCC_YUV422) {
            lpInput++;
        }


        YUV422ToRGB(pinst,
            icinfo->lpbiInput,
            icinfo->lpInput,
            icinfo->lpbiOutput,
            icinfo->lpOutput
        );
    }



    return ICERR_OK;
}

/*****************************************************************************
 *
 * DecompressGetPalette() implements ICM_GET_PALETTE
 *
 * This function has no Compress...() equivalent
 *
 * It is used to pull the palette from a frame in order to possibly do
 * a palette change.
 *
 ****************************************************************************/
DWORD NEAR PASCAL DecompressGetPalette(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut)
{

    dprintf2((TEXT("DecompressGetPalette()")));


    /*
     * only applies to 8-bit output formats. We only decompress to 16 bits
     */
    return((DWORD) ICERR_BADFORMAT);

}

/*****************************************************************************
 ****************************************************************************/
DWORD NEAR PASCAL DecompressEnd(INSTINFO * pinst)
{
    if (pinst->pXlate == NULL) {
        return (DWORD)ICERR_ERROR;
    }

    FreeXlate(pinst);
    pinst->dwFormat = 0;

    return ICERR_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\codec\tsbyuv\drvproc.c ===
/*----------------------------------------------------------------------+
|									|
| drvproc.c - driver procedure						|
|									|
| Copyright (c) 1993 Microsoft Corporation.				|
| All Rights Reserved.							|
|									|
+----------------------------------------------------------------------*/

#include <windows.h>

#include "msyuv.h"

HMODULE ghModule;     // Our DLL module handle


/***************************************************************************
 * DriverProc  -  The entry point for an installable driver.
 *
 * PARAMETERS
 * dwDriverId:  For most messages, <dwDriverId> is the DWORD
 *     value that the driver returns in response to a <DRV_OPEN> message.
 *     Each time that the driver is opened, through the <DrvOpen> API,
 *     the driver receives a <DRV_OPEN> message and can return an
 *     arbitrary, non-zero value. The installable driver interface
 *     saves this value and returns a unique driver handle to the
 *     application. Whenever the application sends a message to the
 *     driver using the driver handle, the interface routes the message
 *     to this entry point and passes the corresponding <dwDriverId>.
 *     This mechanism allows the driver to use the same or different
 *     identifiers for multiple opens but ensures that driver handles
 *     are unique at the application interface layer.
 *
 *     The following messages are not related to a particular open
 *     instance of the driver. For these messages, the dwDriverId
 *     will always be zero.
 *
 *         DRV_LOAD, DRV_FREE, DRV_ENABLE, DRV_DISABLE, DRV_OPEN
 *
 * hDriver: This is the handle returned to the application by the
 *    driver interface.
 *
 * uiMessage: The requested action to be performed. Message
 *     values below <DRV_RESERVED> are used for globally defined messages.
 *     Message values from <DRV_RESERVED> to <DRV_USER> are used for
 *     defined driver protocols. Messages above <DRV_USER> are used
 *     for driver specific messages.
 *
 * lParam1: Data for this message.  Defined separately for
 *     each message
 *
 * lParam2: Data for this message.  Defined separately for
 *     each message
 *
 * RETURNS
 *   Defined separately for each message.
 *
 ***************************************************************************/

LRESULT  DriverProc(PINSTINFO pi, HDRVR hDriver, UINT uiMessage, LPARAM lParam1, LPARAM lParam2)
{
    switch (uiMessage)
    {
	case DRV_LOAD:
#ifdef _WIN32
            if (ghModule) {
                // AVI explicitly loads us as well, but does not pass the
                // correct (as known by WINMM) driver handle.
            } else {
                ghModule = (HANDLE) GetDriverModuleHandle(hDriver);
            }
#endif
	    return (LRESULT) 1L;

	case DRV_FREE:
	    return (LRESULT)1L;

        case DRV_OPEN:
	    // if being opened with no open struct, then return a non-zero
	    // value without actually opening
	    if (lParam2 == 0L)
                return 0xFFFF0000;

	    return (LRESULT)(DWORD_PTR) Open((ICOPEN FAR *) lParam2);

	case DRV_CLOSE:
#ifdef _WIN32
	    if (pi != (PINSTINFO)(ULONG_PTR)0xFFFF0000)
#else
	    if (pi)
#endif
		Close(pi);

	    return (LRESULT)1L;

	/*********************************************************************

	    state messages

	*********************************************************************/

        case DRV_QUERYCONFIGURE:    // configuration from drivers applet
            return (LRESULT)0L;

        case DRV_CONFIGURE:
            return DRV_OK;

        case ICM_CONFIGURE:
            //
            //  return ICERR_OK if you will do a configure box, error otherwise
            //
            if (lParam1 == -1)
		return QueryConfigure(pi) ? ICERR_OK : ICERR_UNSUPPORTED;
	    else
		return Configure(pi, (HWND)lParam1);

        case ICM_ABOUT:
            //
            //  return ICERR_OK if you will do a about box, error otherwise
            //
            if (lParam1 == -1)
		return QueryAbout(pi) ? ICERR_OK : ICERR_UNSUPPORTED;
	    else
		return About(pi, (HWND)lParam1);

	case ICM_GETSTATE:
	    return GetState(pi, (LPVOID)lParam1, (DWORD)lParam2);

	case ICM_SETSTATE:
	    return SetState(pi, (LPVOID)lParam1, (DWORD)lParam2);

	case ICM_GETINFO:
            return GetInfo(pi, (ICINFO FAR *)lParam1, (DWORD)lParam2);

        case ICM_GETDEFAULTQUALITY:
            if (lParam1)
            {
                *((LPDWORD)lParam1) = 7500;
                return ICERR_OK;
            }
            break;
	
	/*********************************************************************

	    compression messages

	*********************************************************************/
#ifdef ICM_COMPRESS_SUPPORTED

	case ICM_COMPRESS_QUERY:
	    return CompressQuery(pi,
			 (LPBITMAPINFOHEADER)lParam1,
			 (LPBITMAPINFOHEADER)lParam2);

	case ICM_COMPRESS_BEGIN:
	    return CompressBegin(pi,
			 (LPBITMAPINFOHEADER)lParam1,
			 (LPBITMAPINFOHEADER)lParam2);

	case ICM_COMPRESS_GET_FORMAT:
	    return CompressGetFormat(pi,
			 (LPBITMAPINFOHEADER)lParam1,
			 (LPBITMAPINFOHEADER)lParam2);

	case ICM_COMPRESS_GET_SIZE:
	    return CompressGetSize(pi,
			 (LPBITMAPINFOHEADER)lParam1,
			 (LPBITMAPINFOHEADER)lParam2);
	
	case ICM_COMPRESS:
	    return Compress(pi,
			    (ICCOMPRESS FAR *)lParam1, (DWORD)lParam2);

	case ICM_COMPRESS_END:
	    return CompressEnd(pi);
	
#endif // ICM_DRAW_SUPPORTED

	/*********************************************************************

	    decompress messages

	*********************************************************************/

	case ICM_DECOMPRESS_QUERY:
	    return DecompressQuery(pi,
			 (LPBITMAPINFOHEADER)lParam1,
			 (LPBITMAPINFOHEADER)lParam2);

	case ICM_DECOMPRESS_BEGIN:
	    return DecompressBegin(pi,
			 (LPBITMAPINFOHEADER)lParam1,
			 (LPBITMAPINFOHEADER)lParam2);

	case ICM_DECOMPRESS_GET_FORMAT:
	    return DecompressGetFormat(pi,
			 (LPBITMAPINFOHEADER)lParam1,
                         (LPBITMAPINFOHEADER)lParam2);

        case ICM_DECOMPRESS_GET_PALETTE:
            return DecompressGetPalette(pi,
			 (LPBITMAPINFOHEADER)lParam1,
			 (LPBITMAPINFOHEADER)lParam2);

	case ICM_DECOMPRESS:
	    return Decompress(pi,
			 (ICDECOMPRESS FAR *)lParam1, (DWORD)lParam2);

	case ICM_DECOMPRESS_END:
	    return DecompressEnd(pi);

	/*********************************************************************

	    draw messages

	*********************************************************************/
#ifdef ICM_DRAW_SUPPORTED

	case ICM_DRAW_BEGIN:
	    /*
	     * sent when a sequence of draw calls are about to start -
	     * enable hardware.
	     */
            return DrawBegin(pi,(ICDRAWBEGIN FAR *)lParam1, (DWORD)lParam2);

	case ICM_DRAW:
	    /*
	     * frame ready for decompress. Since we don't have any pre-buffering,
	     * it is ok to render the frame at this time too. If we had
	     * pre-buffer, we would queue now, and start clocking frames out
	     * on the draw-start message.
	     */
            return Draw(pi,(ICDRAW FAR *)lParam1, (DWORD)lParam2);

	case ICM_DRAW_END:
	    /*
	     * this message is sent when the sequence of draw calls has finished -
	     * note that the final frame should remain rendered!! - so we can't
	     * disable the hardware yet.
	     */
	    //return DrawEnd(pi);
	    return((DWORD) ICERR_OK);


	case ICM_DRAW_WINDOW:
	    /*
	     * the window has changed position or z-ordering. re-sync the
	     * hardware rendering.
	     */
	    return(DrawWindow(pi, (PRECT)lParam1));


	case ICM_DRAW_QUERY:
	    /*
	     * can we draw this format ? (lParam2 may (should?) be null)
	     */
	    return DrawQuery(pi,
			 (LPBITMAPINFOHEADER)lParam1,
			 (LPBITMAPINFOHEADER)lParam2);

	case ICM_DRAW_START:
	case ICM_DRAW_STOP:
	    /*
	     * only relevant if you have pre-buffering.
	     */
	    return( (DWORD) ICERR_OK);

#endif // ICM_DRAW_SUPPORTED

	/*********************************************************************

	    standard driver messages

	*********************************************************************/

	case DRV_DISABLE:
	case DRV_ENABLE:
	    return (LRESULT)1L;

	case DRV_INSTALL:
	case DRV_REMOVE:
	    return (LRESULT)DRV_OK;
    }

    if (uiMessage < DRV_USER)
        return DefDriverProc((UINT_PTR)pi, hDriver, uiMessage,lParam1,lParam2);
    else
	return ICERR_UNSUPPORTED;
}


#ifdef _WIN32
#if 0 // done on DRV_LOAD
BOOL DllInstanceInit(PVOID hModule, ULONG Reason, PCONTEXT pContext)
{
    if (Reason == DLL_PROCESS_ATTACH) {
        ghModule = (HANDLE) hModule;
	DisableThreadLibraryCalls(hModule);
    }
    return TRUE;
}
#endif
#else

/****************************************************************************
 * LibMain - Library initialization code.
 *
 * PARAMETERS
 * hModule: Our module handle.
 *
 * wHeapSize: The heap size from the .def file.
 *
 * lpCmdLine: The command line.
 *
 * Returns 1 if the initialization was successful and 0 otherwise.
 ***************************************************************************/
int NEAR PASCAL LibMain(HMODULE hModule, WORD wHeapSize, LPSTR lpCmdLine)
{
    ghModule = hModule;

    return 1;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\codec\tsbyuv\vcuser.h ===
/*
 * Copyright Microsoft Corporation, 1993 - 1995. All Rights Reserved.
 */

/*
 * vcuser.h
 *
 * 32-bit Video Capture driver
 * User-mode support library
 *
 * define functions providing access to video capture hardware. On NT,
 * these functions will interface to the kernel-mode driver.
 *
 * include vcstruct.h before this.
 *
 * Geraint Davies, Feb 93
 */

#ifndef _VCUSER_H_
#define _VCUSER_H_

/*
 * capture device handle. This structure is opaque to the caller
 */
typedef struct _VCUSER_HANDLE * VCUSER_HANDLE;

/*
 * these are the parameters we need to issue a DriverCallback. A
 * pointer to one of these structs is passed on StreamInit
 * If the pointer is null, we don't need callbacks.
 */
typedef struct _VCCALLBACK {
    DWORD dwCallback;
    DWORD dwFlags;
    HDRVR hDevice;
    DWORD dwUser;
} VCCALLBACK, * PVCCALLBACK;


/*
 * open the device and return a capture device handle that can be used
 * in future calls.
 * The device index is 0 for the first capture device up to N for the
 * Nth installed capture device.
 *
 * If pDriverName is non-null, then we will open the Nth device handled
 * by this driver. (Current implementation supports only one device per
 * drivername.)
 *
 * This function returns NULL if it is not able to open the device.
 */
VCUSER_HANDLE VC_OpenDevice(PTCHAR pDriverName, int DeviceIndex);


/*
 * close a capture device. This will abort any operation in progress and
 * render the device handle invalid.
 */
VOID VC_CloseDevice(VCUSER_HANDLE vh);


/*
 * Configuration.
 *
 * These functions perform device-dependent setup affecting the
 * target format, the source acquisition or the display (overlay).
 *
 * The structures passed are not interpreted by the vcuser and vckernel
 * libraries except that the first ulong of the struct must contain the
 * size in bytes of the entire structure (see vcstruct.h). It is assumed
 * that the structures are defined and agreed between the user-mode
 * hardware-specific code and the kernel-mode hardware specific code
 */
BOOL VC_ConfigFormat(VCUSER_HANDLE, PCONFIG_INFO);
BOOL VC_ConfigSource(VCUSER_HANDLE, PCONFIG_INFO);
BOOL VC_ConfigDisplay(VCUSER_HANDLE, PCONFIG_INFO);


/*
 * overlay and keying
 *
 * Several different methods are used by devices to locate the overlay
 * area on the screen: colour (either rgb or palette index) and/or
 * either a single rectangle, or a series of rectangles defining a complex
 * region. Call GetOverlayMode first to find out which type of overlay
 * keying is available. If this returns 0, this hardware is not capable
 * of overlay.
 */

/*
 * find out the overlay keying method
 */
ULONG VC_GetOverlayMode(VCUSER_HANDLE);

/*
 * set the key colour to a specified RGB colour. This function will only
 * succeed if GetOverlayMode returned  VCO_KEYCOLOUR and VCO_KEYCOLOUR_RGB
 * and not VCO_KEYCOLOUR_FIXED
 */
BOOL VC_SetKeyColourRGB(VCUSER_HANDLE, PRGBQUAD);

/*
 * set the key colour to a specified palette index. This function will only
 * succeed if GetOverlayMode returned VCO_KEYCOLOUR and not either
 * VCO_KEYCOLOUR_RGB or VCO_KEYCOLOUR_FIXED
 */
BOOL VC_SetKeyColourPalIdx(VCUSER_HANDLE, WORD);

/*
 * get the current key colour. This 32-bit value should be interpreted
 * as either a palette index or an RGB value according to the
 * VCO_KEYCOLOUR_RGB flag returned from VC_GetOverlayMode.
 */
DWORD VC_GetKeyColour(VCUSER_HANDLE vh);

/*
 * set the overlay rectangle(s). This rectangle marks the area in device
 * co-ordinates where the overlay video will appear. The video will be
 * panned so that pixel (0,0) will appear at the top-left of this rectangle,
 * and the video will be cropped at the bottom and right.  The video
 * stream will not normally be scaled to fit this window: scaling is normally
 * determined by the destination format set by VC_ConfigFormat.
 *
 * If VCO_KEYCOLOUR was returned, the video
 * will only be shown at those pixels within the rectangle for which the
 * vga display has the key colour (VC_GetKeyColour() for this).
 *
 * Some devices may support complex regions (VCO_COMPLEX_RECT). In that case,
 * the first rectangle in the area must be the bounding rectangle for
 * the overlay area, followed by one rectangle for each region within it in
 * which the overlay should appear.
 */
BOOL VC_SetOverlayRect(VCUSER_HANDLE, POVERLAY_RECTS);


/*
 * set the offset of the overlay. This changes the panning - ie which
 * source co-ordinate appears as the top left pixel in the overlay rectangle.
 * Initially after a call to VC_SetOverlayRect, the source image will be panned
 * so that the top-left of the source image is aligned with the top-left of the
 * overlay rectangle. This call aligns the top-left of the source image
 * with the top-left of this offset rectangle.
 */
BOOL VC_SetOverlayOffset(VCUSER_HANDLE, PRECT);

/* enable or disable overlay. if the BOOL bOverlay is TRUE, and the overlay
 * key colour and rectangle have been set, overlay will be enabled.
 */
BOOL VC_Overlay(VCUSER_HANDLE, BOOL);

/*
 * enable or disable acquisition.
 * If acquisition is disabled, the overlay image will be frozen.
 *
 * this function will have no effect during capture since the acquisition
 * flag is toggled at each frame capture.
 */
BOOL VC_Capture(VCUSER_HANDLE, BOOL);



/*
 * capture a single frame, synchronously. the video header must point
 * to a data buffer large enough to hold one frame of the format set by
 * VC_ConfigFormat.
 */
// BOOL VC_Frame(VCUSER_HANDLE, LPVIDEOHDR);


/*
 * data streaming.
 *
 * Call VC_StreamInit to prepare for streaming.
 * Call VC_StreamStart to initiate capture.
 * Call VC_AddBuffer to add a capture buffer to the list. As each
 * frame capture completes, the callback function specified in
 * VC_StreamInit will be called with the buffer that has completed.
 *
 * If there is no buffer ready when it is time to capture a frame,
 * a callback will occur. In addition, VC_StreamGetError will return
 * a count of the frames missed this session. VC_StreamGetPos will return
 * the position (in millisecs) reached so far.
 *
 * Call VC_StreamStop to terminate streaming. Any buffer currently in
 * progress may still complete. Uncompleted buffers will remain in the
 * queue. Call VC_Reset to release all buffers from the queue.
 *
 * Finally call VC_StreamFini to tidy up.
 */

/*
 * prepare to start capturing frames
 */
BOOL VC_StreamInit(VCUSER_HANDLE,
		PVCCALLBACK,	// pointer to callback function
		ULONG		// desired capture rate: microseconds per frame
);

/*
 * clean up after capturing. You must have stopped capturing first.
 */
BOOL VC_StreamFini(VCUSER_HANDLE);

/*
 * initiate capturing of frames. Must have called VC_StreamInit first.
 */
BOOL VC_StreamStart(VCUSER_HANDLE);

/*
 * stop capturing frames. Current frame may still complete. All other buffers
 * will remain in the queue until capture is re-started, or they are released
 * by VC_StreamReset.
 */
BOOL VC_StreamStop(VCUSER_HANDLE);

/*
 * cancel all buffers that have been 'add-buffered' but have not
 * completed. This will also force VC_StreamStop if it hasn't already been
 * called.
 */
BOOL VC_StreamReset(VCUSER_HANDLE);

/*
 * get the count of frames that have been skipped since the last call
 * to VC_StreamInit.
 */
ULONG VC_GetStreamError(VCUSER_HANDLE);

/*
 * get the current position within the capture stream (ie time
 * in millisecs since capture began)
 */
BOOL VC_GetStreamPos(VCUSER_HANDLE, LPMMTIME);

/*
 * add a buffer to the queue. The buffer should be large enough
 * to hold one frame of the format specified by VC_ConfigFormat.
 */
// BOOL VC_StreamAddBuffer(VCUSER_HANDLE, LPVIDEOHDR);


/*
 * playback
 *
 * Call VC_DrawFrame to draw a frame into the frame buffer. You should
 * call VC_Overlay functions to arrange for the frame buffer to appear
 * on screen.
 */
BOOL VC_DrawFrame(VCUSER_HANDLE, PDRAWBUFFER);



/*
 * installation/configuration
 *
 * on NT, the following functions will start and stop the
 * kernel driver. The callback function can write profile information
 * to the registry between stopping the driver (if already running) and
 * re-starting the driver. The kernel driver DriverEntry routine is responsible
 * for reading these values from the registry before calling VC_Init().
 *
 * The win-16 implementation will (?) call the callback to write
 * values to the profile, and then call the HW_Startup function. This function
 * is responsible for calling VC_Init, initialising the callback table and
 * initialising the hardware.
 */

/*
 * opaque pointer to the information we need to access the registry/profile.
 */
typedef struct _VC_PROFILE_INFO * PVC_PROFILE_INFO;


/*
 * open a handle to whatever functions are needed to access the registry,
 * service controller or profile. Must call this function before
 * calls to the other VC_ configuration routines.
 *
 * The argument is the name of the driver. This should be the name of
 * the kernel driver file (without path or extension). It will also be used
 * as the registry key name or profile section name.
 */
PVC_PROFILE_INFO VC_OpenProfileAccess(PTCHAR DriverName);

/*
 * close a profile access handle
 */
VOID VC_CloseProfileAccess(PVC_PROFILE_INFO);


/*
 * takes a PVC_PROFILE_INFO returned from VC_OpenProfileAccess, and
 * returns TRUE if we currently have sufficient privilege to perform
 * driver configuration operations.
 */
BOOL VC_ConfigAccess(PVC_PROFILE_INFO);


/*
 * This function is called once the driver has definitely been unloaded, and
 * the profile entry created, but before the driver is re-loaded. It can write
 * any configuration information to the registry. It should return TRUE if
 * it is ok to load and start the kernel-mode driver, or false if some
 * error has occured.
 */
typedef BOOL (*PPROFILE_CALLBACK)(PVOID);


/*
 * start the hardware-access portion of the driver. Call the callback
 * function at a moment when it is possible to write configuration information
 * to the profile using VC_WriteProfile.
 * Returns DRVCNF_OK if all is ok, DRVCNF_CANCEL for failure, or DRVCNF_RESTART if
 * all is ok but a system-restart is needed before the driver will load correctly.
 */
LRESULT VC_InstallDriver(
	    PVC_PROFILE_INFO pProfile,		// access info returned by OpenProfileAccess
	    PPROFILE_CALLBACK pCallback,	// callback function
	    PVOID pContext			// context info for callback	
);

/*
 * Write a single string keyword and DWORD value to the registry or profile
 * for this driver.
 * This can be re-read from the h/w driver using VC_ReadProfile (in either
 * the kernel-mode vckernel.lib version or user mode in the vcuser version).
 *
 * return TRUE for success or FALSE for failure.
 */
BOOL VC_WriteProfile(PVC_PROFILE_INFO pProfile, PTCHAR ValueName, DWORD Value);

/*
 * Write a single string keyword and DWORD value to the registry or profile
 * for this driver.
 * This writes to HKEY_CURRENT_USER and is typically used to store user defaults.
 *
 * return TRUE for success or FALSE for failure.
 */
BOOL VC_WriteProfileUser(PVC_PROFILE_INFO pProfile, PTCHAR ValueName, DWORD Value);


/*
 * read back a driver-specific DWORD profile parameter that was written with
 * VC_WriteProfile. If the valuename cannot be found, the default is returned.
 */
DWORD VC_ReadProfile(PVC_PROFILE_INFO pProfile, PTCHAR ValueName, DWORD dwDefault);

/*
 * read back a driver-specific DWORD profile parameter that was written with
 * VC_WriteProfileUser.  If the valuename cannot be found, the default is returned.
 * This reads from HKEY_CURRENT_USER and is typically used to store user defaults.
 */
DWORD VC_ReadProfileUser(PVC_PROFILE_INFO pProfile, PTCHAR ValueName, DWORD dwDefault);

/*
 * read a string parameter from the device's profile. returns FALSE
 * if it fails to read the string.
 */
BOOL VC_ReadProfileString(
    PVC_PROFILE_INFO pProfile,		// access info from OpenProfile
    PTCHAR ValueName,			// name of value to read
    PTCHAR ValueString,			// put value here
    DWORD ValueLength			// size of ValueString in bytes
);


/*
 * unload a driver. On NT, this stops and removes the kernel-mode driver.
 * On win-16, this calls the Cleanup callback.
 *
 * return DRVCNF_OK if the unload was successful, DRVCNF_CANCEL if it failed, and
 * DRVCNF_RESTART if a system-restart is needed before the removal takes effect.
 *
 * note that after this operation, the PVC_PROFILE_INFO information is still held
 * open. A call to VC_CloseProfileAccess is still needed before exiting.
 */
LRESULT VC_RemoveDriver(PVC_PROFILE_INFO pProfile);



#endif //_VCUSER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\codec\tsbyuv\xlate.c ===
/*
 * Microsoft YUV Codec -yuv411 -> rgb conversion functions
 *
 * Copyright (c) Microsoft Corporation 1993
 * All Rights Reserved
 *
 */
/*
 * for TOSHIBA Pistachio yuv12 -> rgb conversion functions
 *
 * Programed by Y.Kasai 05/27/97
 *
 * supported type:
 *           YUV411 (for Bravado)
 *           YUV422 (for Spigot)
 *           YUV12  (for Pistachio)
 *           YUV9   (for Pistachio)
 */

#include <windows.h>
#include <windowsx.h>

#include "msyuv.h"

/*
 * This module provides translation from YUV into RGB. It translates
 * from 8-bit YUV 4:2:2 (as provided by the Spigot video capture driver)
 * or 7-bit YUV 4:1:1 (as provided by the Bravado driver) into 16-bit RGB555
 * or RGB565. All versions use a look-up table built using YUVToRGB555
 * or YUVToRGB565
 */



#define RANGE(x, lo, hi)        max(lo, min(hi, x))

/*
 * Convert a YUV colour into a 15-bit RGB colour.
 *
 * The input Y is in the range 16..235; the input U and V components
 * are in the range -128..+127. The conversion equations for this are
 * (according to CCIR 601):
 *
 *      R = Y + 1.371 V
 *      G = Y - 0.698 V - 0.336 U
 *      B = Y + 1.732 U
 *
 * To avoid floating point, we scale all values by 1024.
 *
 * The resulting RGB values are in the range 16..235: we truncate these to
 * 5 bits each. and return a WORD containing 5-bits each for R, G and B
 * with bit 15 set to 0.
 */
WORD
YUVToRGB555(int y, int u, int v)
{
    int ScaledY = RANGE(y, 16, 235) * 1024;
    int red, green, blue;

    red = RANGE((ScaledY + (1404 * v)) / 1024, 0, 255);
    green = RANGE( (ScaledY - (715 * v) - (344 * u)) / 1024, 0, 255);
    blue = RANGE( (ScaledY + (1774 * u)) / 1024, 0, 255);

    return (WORD) (((red & 0xf8) << 7) | ((green & 0xf8) << 2) | ((blue & 0xf8) >>3) );
}


// same as above but converts to RGB565 instead
WORD
YUVToRGB565(int y, int u, int v)
{
    int ScaledY = RANGE(y, 16, 235) * 1024;
    int red, green, blue;

    red = RANGE((ScaledY + (1404 * v)) / 1024, 0, 255);
    green = RANGE( (ScaledY - (715 * v) - (344 * u)) / 1024, 0, 255);
    blue = RANGE( (ScaledY + (1774 * u)) / 1024, 0, 255);

    return (WORD) (((red & 0xf8) << 8) | ((green & 0xfc) << 3) | ((blue & 0xf8) >>3) );
}


#ifdef  TOSHIBA
#ifdef  COLOR_MODIFY
/*
 * TOSHIBA Y.Kasai
 * for Pistachio.
 *
 * Convert a YUV colour into a 15-bit RGB colour.
 *
 * The input Y is in the range 0..255; the input U and V components
 * are in the same range 0..255. The conversion equations for this are
 * (according to CCIR 601):
 *
 *      R = 1.1644Y + 1.5976 V - 223.0089
 *      G = 1.1644Y - 0.8133 V - 0.3921 U + 135.6523
 *      B = 1.1644Y + 2.0184 U - 276.9814
 *
 * To avoid floating point, we scale all values by 1024.
 *
 *  1024R = 1192Y + 1635V - 228361
 *  1024G = 1192Y - 833V - 402U + 138908
 *  1024B = 1192Y + 2067U - 283629
 *
 */
BYTE
TosYVToR(int y, int v)
{
    int ScaledY = y * 1192;
    int red;

    red = RANGE((ScaledY + (1635 * v) -  228361) / 1024, 0, 255);

    return (BYTE) (red);
}


BYTE
TosYUToB(int y, int u)
{
    int ScaledY = y * 1192;
    int blue;

    blue = RANGE( (ScaledY + (2067 * u) - 283629) / 1024, 0, 255);

    return (BYTE) (blue);
}

#else //COLOR_MODIFY
/*
 * TOSHIBA Y.Kasai
 * for Pistachio.
 *
 * Convert a YUV colour into a 15-bit RGB colour.
 *
 * The input Y is in the range 0..255; the input U and V components
 * are in the same range 0..255. The conversion equations for this are
 * (according to CCIR 601):
 *
 *      R = 1.1644Y + 1.5976 V - 223.0089
 *      G = 1.1644Y - 0.8133 V - 0.3921 U + 135.6523
 *      B = 1.1644Y + 2.0184 U - 276.9814
 *
 * To avoid floating point, we scale all values by 1024.
 *
 *  1024R = 1192Y + 1635V - 228361
 *  1024G = 1192Y - 833V - 402U + 138908
 *  1024B = 1192Y + 2067U - 283629
 *
 * The resulting RGB values are in the range 0..255: we truncate these to
 * 5 bits each. and return a WORD containing 5-bits each for R, G and B
 * with bit 15 set to 0.
 */
WORD
TosYUVToRGB555(int y, int u, int v)
{
    int ScaledY = y * 1192;
    int red, green, blue;

    red = RANGE((ScaledY + (1635 * v) -  228361) / 1024, 0, 255);
    green = RANGE( (ScaledY - (833 * v) - (402 * u) + 138908) / 1024, 0, 255);
    blue = RANGE( (ScaledY + (2067 * u) - 283629) / 1024, 0, 255);

    return (WORD) (((red & 0xf8) << 7) | ((green & 0xf8) << 2) | ((blue & 0xf8) >>3) );
}


// same as above but converts to RGB565 instead
WORD
TosYUVToRGB565(int y, int u, int v)
{
    int ScaledY = y * 1192;
    int red, green, blue;

    red = RANGE((ScaledY + (1635 * v) -  228361) / 1024, 0, 255);
    green = RANGE( (ScaledY - (833 * v) - (402 * u) + 138908) / 1024, 0, 255);
    blue = RANGE( (ScaledY + (2067 * u) - 283629) / 1024, 0, 255);

    return (WORD) (((red & 0xf8) << 8) | ((green & 0xfc) << 3) | ((blue & 0xf8) >>3) );
}
#endif//COLOR_MODIFY
#endif//TOSHIBA



/* --- YUV 4:1:1 support ------------------------------------------ */




/*
 * the input data is in YUV411 format. There is one 7 bit Luma sample
 * per pixel, and 1 each 7-bit U and V sample averaged over 4 pixels,
 * in the following layout:
 *
 *              15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
 * Word 0       u6 u5 v6 v5             y6 y5 y4 y3 y2 y1 y0
 *
 * Word 1       u4 u3 v4 v3             y6 y5 y4 y3 y2 y1 y0
 *
 * Word 2       u2 u1 v2 v1             y6 y5 y4 y3 y2 y1 y0
 *
 * Word 3       u0    v0                y6 y5 y4 y3 y2 y1 y0
 *
 * The 7-bit y values are unsigned (0..127), whereas the 7-bit
 * u and V values are signed (-64..+63).
 *
 *
 * For RGB: we truncate the YUV into a 15-bit format and use a prepared
 *         lookup table to convert the 15-bit YUV into a 15- or 16-bit RGB value.
 *
 * The (64 kbyte) rgb555 lookup table is built by BuildYUVToRGB555.
 *
 */


/*
 * the YUV xlate tables use 5-bits per component with y in the ms bits, and
 * v in the ls bits. To convert from the above layout, look up the nibbles
 * containing the chroma bits in these tables and or together the result to
 * get a word with a 5-bit V component in bits 0..4, and a 5-bit
 * U component in bits 5..9. Note you only need three lookups since
 * we discard chroma bits 0 and 1.
 */
WORD ChromaBits65[] = {
    0x000, 0x008, 0x010, 0x018,
    0x100, 0x108, 0x110, 0x118,
    0x200, 0x208, 0x210, 0x218,
    0x300, 0x308, 0x310, 0x318
};

WORD ChromaBits43[] = {
    0x000, 0x002, 0x004, 0x006,
    0x040, 0x042, 0x044, 0x046,
    0x080, 0x082, 0x084, 0x086,
    0x0c0, 0x0c2, 0x0c4, 0x0c6
};

WORD ChromaBits2[] = {
    0x000, 0x000, 0x001, 0x001,
    0x000, 0x000, 0x001, 0x001,
    0x020, 0x020, 0x021, 0x021,
    0x020, 0x020, 0x021, 0x021
};







/*
 * build yuv411->RGB555 xlate table
 */
LPVOID BuildYUVToRGB555(PINSTINFO pinst)
{
    HGLOBAL hMem = NULL;
    LPVOID pXlate = NULL;

    if (pinst->pXlate != NULL) {
        return(pinst->pXlate);
    }

    /*
     * allocate a table big enough for 32k 2-byte entries
     */

    if ( ( hMem = GlobalAlloc(GPTR, 2 * 32 * 1024))
      && ( pXlate = GlobalLock( hMem ) ) )
    {
        WORD w;
        LPWORD pRGB555 = (LPWORD)pXlate;

        /*
         * build a 15-bit yuv lookup table by stepping through each entry,
         * converting the yuv index to rgb and storing at that index. The index
         * to this table is a 15-bit value with the y component in bits 14..10,
         * u in bits 9..5 and v in bits 4..0. Note that the y component is unsigned,
         * whereas the u and v components are signed.
         */
        for (w = 0; w < 32*1024; w++) {
            /*
             * the YUVtoRGB55 conversion function takes values 0..255 for y,
             * and -128..+127 for u and v. Pick out the relevant bits of the
             * index for this cell, and shift to get values in this range.
             * Remember the cast to ensure sign-extension of these (8-bit) values -
             * and don't assume that chars are signed (they're not on MIPS).
             */
            *pRGB555++ = YUVToRGB555(
                                (w &  0x7c00) >> 7,
                                (signed char) ((w & 0x3e0) >> 2),
                                (signed char) ((w & 0x1f) << 3)
                         );
        }
    }

    return(pXlate);
}

/*
 * build yuv411->RGB565 xlate table
 */
LPVOID BuildYUVToRGB565(PINSTINFO pinst)
{
    HGLOBAL hMem = 0;
    LPVOID pXlate = NULL;

    if (pinst->pXlate != NULL) {
        return(pinst->pXlate);
    }

    /*
     * allocate a table big enough for 32k 2-byte entries
     */
    if ( ( hMem = GlobalAlloc(GPTR, 2 * 32 * 1024))
      && ( pXlate = GlobalLock( hMem ) ) )
    {
        WORD w;
        LPWORD pRGB = (LPWORD)pXlate;

        /*
         * build a 15-bit yuv lookup table by stepping through each entry,
         * converting the yuv index to rgb and storing at that index. The index
         * to this table is a 15-bit value with the y component in bits 14..10,
         * u in bits 9..5 and v in bits 4..0. Note that the y component is unsigned,
         * whereas the u and v components are signed.
         */
        for (w = 0; w < 32*1024; w++) {
            /*
             * the YUVtoRGB conversion function takes values 0..255 for y,
             * and -128..+127 for u and v. Pick out the relevant bits of the
             * index for this cell, and shift to get values in this range.
             * Remember the cast to ensure sign-extension of these (8-bit) values -
             * and don't assume that chars are signed (they're not on MIPS).
             */
            *pRGB++ = YUVToRGB565(
                                (w &  0x7c00) >> 7,
                                (signed char) ((w & 0x3e0) >> 2),
                                (signed char) ((w & 0x1f) << 3)
                         );
        }
    }

    return(pXlate);

}




/*
 * translate one frame from yuv411 to 15/16 bit rgb.
 *
 * The YUV data is spread over 4 16-bit pixels in the format described
 * above. Pick out 4 pixels at a time, truncate them to 15-bit yuv,
 * lookup to translate to 15 or 16-bit rgb (depending on the lookup table
 * and write out.
 *
 * Flip vertically into correct dib format during conversion.
 */
VOID
YUV411ToRGB(
    PINSTINFO pinst,
    LPBITMAPINFOHEADER lpbiInput,
    LPVOID lpInput,
    LPBITMAPINFOHEADER lpbiOutput,
    LPVOID lpOutput
)
{
    int RowInc;
    int i, j;
    DWORD Luma01, Luma23;
    DWORD Chroma;
    int Height, Width;
    int WidthBytes;
    PWORD pXlate;
    PWORD pDst;
    PDWORD pSrc;


    Height = lpbiInput->biHeight;
    Width = lpbiInput->biWidth;
    WidthBytes = Width*2;               // size of (input and output) line
    pXlate = pinst->pXlate;


    /*
     * adjust the source to point to the start of the last line,
     * and work upwards (to flip vertically into DIB format)
     */
    pSrc = (PDWORD) ( (PUCHAR) lpInput + ((Height - 1) * WidthBytes));
    pDst = (PWORD) lpOutput;

    /*
     * calculate the amount to adjust source by at the end of one line
     * of copying. At this point we are at the end of line N. We need
     * to move to the start of line N-1.
     */
    RowInc = (WidthBytes * 2) / sizeof(DWORD);

    /* loop copying each scanline */
    for (i = 0; i < Height; i++) {

        /* loop copying four pixels at a time */
        for (j = 0; j < Width; j += 4) {

            /*
             * get four pixels and convert to 15-bpp YUV
             */

            /* get luma for first 2 pixels + higher chroma bits */
            Luma01 = *pSrc++;


            /* pick out u,v components using lookup table.
             * u and v will be the bottom 10 bits of each pixel, so
             * convert to this layout
             */
            Chroma = ChromaBits65[(Luma01 >> 12) & 0xf] |
                        ChromaBits43[ (Luma01 >> 28) & 0xf ];

            /* next two pixels + lower chroma bits */
            Luma23 = *pSrc++;

            /* pickup u and v bits 2 - ignore bits 1, 0 since
             * we only use 5-bits per component for conversion
             */
            Chroma |= ChromaBits2[ ( Luma23 >> 12) & 0xf];

            /*
             * combine luma for pix 0 with common chroma bits to
             * get 15-bit yuv, then lookup to convert to
             * rgb and store.
             */
            *pDst++ = pXlate[ ((Luma01 & 0xf8) << 7) | Chroma];
            *pDst++ = pXlate[ ((Luma01 & 0xf80000) >> 9) | Chroma];
            *pDst++ = pXlate[ ((Luma23 & 0xf8) << 7) | Chroma];
            *pDst++ = pXlate[ ((Luma23 & 0xf80000) >> 9) | Chroma];

        } // loop per 4 pixels

        /* move source pointer back to next line */
        pSrc -= RowInc;
    } // loop per row
}


/* YUV 4:2:2 support ------------------------------------------ */

/*
 * The captured data is in YUV 4:2:2, 8-bits per sample.
 * The data is laid out in alternating Y-U-Y-V-Y-U-Y-V format. Thus
 * every DWORD contains two complete pixels, in the
 * form (msb..lsb) V..Y1..U..Y0
 * All 3 components (y, u and v) are all unsigned 8-bit values in the range
 * 16..235.
 *
 * We have to double scan lines for >= 480 line formats since
 * the hardware only captured one field maximum.
 *
 */





/*
 * build a translation table to translate between YUV and RGB555.
 *
 * This builds a lookup table with 32k 1-word entries: truncate the YUV
 * to 15bits (5-5-5) and look-up in this xlate table to produce the
 * 15-bit rgb value.
 */
LPVOID BuildYUV422ToRGB555(PINSTINFO pinst)
{
    HGLOBAL hMem = 0;
    LPVOID pXlate = NULL;

    if (pinst->pXlate != NULL) {
        return(pinst->pXlate);
    }

    /*
     * allocate a table big enough for 32k 2-byte entries
     */
    if ( ( hMem = GlobalAlloc(GPTR, 2 * 32 * 1024))
      && ( pXlate = GlobalLock( hMem ) ) )
    {
        WORD w;
        LPWORD pRGB555 = (LPWORD)pXlate;

        /*
         * build a 15-bit yuv lookup table by stepping through each entry,
         * converting the yuv index to rgb and storing at that index. The index
         * to this table is a 15-bit value with the y component in bits 14..10,
         * u in bits 9..5 and v in bits 4..0. Note that the y component is unsigned,
         * whereas the u and v components are signed.
         */
        for (w = 0; w < 32*1024; w++) {
            /*
             * the YUVtoRGB55 conversion function takes values 0..255 for y,
             * and -128..+127 for u and v. Pick out the relevant bits of the
             * index for this cell, and shift to get values in this range.
             * Subtract 128 from u and v to shift from 0..255 to -128..+127
             */
            *pRGB555++ = YUVToRGB555(
                                (w &  0x7c00) >> 7,
                                ((w & 0x3e0) >> 2) - 128,
                                ((w & 0x1f) << 3) - 128
                         );
        }
    }

    return(pXlate);


}

/*
 * build a translation table to translate between YUV and RGB 5-6-5
 *
 * This builds a lookup table with 32k 1-word entries: truncate the YUV
 * to 15bits (5-5-5) and look-up in this xlate table to produce the
 * 16-bit rgb value.
 */
LPVOID BuildYUV422ToRGB565(PINSTINFO pinst)
{
    HGLOBAL hMem = 0;
    LPVOID pXlate = NULL;

    if (pinst->pXlate != NULL) {
        return(pinst->pXlate);
    }

    /*
     * allocate a table big enough for 32k 2-byte entries
     */

    if ( ( hMem = GlobalAlloc(GPTR, 2 * 32 * 1024))
      && ( pXlate = GlobalLock( hMem ) ) )
    {
        WORD w;
        LPWORD pRGB = (LPWORD)pXlate;

        /*
         * build a 15-bit yuv lookup table by stepping through each entry,
         * converting the yuv index to rgb and storing at that index. The index
         * to this table is a 15-bit value with the y component in bits 14..10,
         * u in bits 9..5 and v in bits 4..0. Note that the y component is unsigned,
         * whereas the u and v components are signed.
         */
        for (w = 0; w < 32*1024; w++) {
            /*
             * the YUVtoRGB conversion function takes values 0..255 for y,
             * and -128..+127 for u and v. Pick out the relevant bits of the
             * index for this cell, and shift to get values in this range.
             * Subtract 128 from u and v to shift from 0..255 to -128..+127
             */
            *pRGB++ = YUVToRGB565(
                                (w &  0x7c00) >> 7,
                                ((w & 0x3e0) >> 2) - 128,
                                ((w & 0x1f) << 3) - 128
                         );
        }
    }

    return(pXlate);


}

/*
 * translate YUV 4:2:2 into 16-bit RGB using a lookup table. Flip vertically
 * into DIB format during processing. Double scanlines for formats of
 * 480 lines or greater. Produces 565 or 555 format RGB depending on the
 * xlate table.
 */
VOID
YUV422ToRGB(
    PINSTINFO pinst,
     LPBITMAPINFOHEADER lpbiInput,
     LPVOID lpInput,
     LPBITMAPINFOHEADER lpbiOutput,
     LPVOID lpOutput
)
{
    int RowInc;
    int i, j;
    DWORD uv55, dwPixel;
    int WidthBytes;                     // width of one line in BYTES
    BOOL bDuplicate = FALSE;
    PDWORD pSrc, pDst;
    int Height, Width;
    PWORD pXlate;
    int InputHeight;


    Height = lpbiInput->biHeight;
    InputHeight = Height;
    Width = lpbiInput->biWidth;
    WidthBytes = Width*2;               // size of (input and output) line
    pXlate = pinst->pXlate;


    /*
     * adjust the destination to point to the start of the last line,
     * and work upwards (to flip vertically into DIB format)
     */
    pDst = (PDWORD) ( (LPBYTE)lpOutput + (Height - 1) * WidthBytes );
    pSrc = (PDWORD) lpInput;


    /*
     * do we need to duplicate scans to fill the destination ?
     */
    if (Height >= 480) {
        bDuplicate = TRUE;

        /*
         * we need to skip one line each time we copy a line
         */
        RowInc = WidthBytes * 2 + (Width * 2);

        InputHeight = Height/2;

    } else {


        /*
         * calculate the amount to adjust pDst by at the end of one line
         * of copying. At this point we are at the end of line N. We need
         * to move to the start of line N-1.
         */
        RowInc = WidthBytes + (Width * 2);

    }

    /* remember we are adding to a DWORD pointer */
    RowInc /= sizeof(DWORD);



    /* loop copying each scanline */
    for (i = InputHeight; i > 0; i--) {

        /* loop copying two pixels at a time */
        for (j = Width ; j > 0; j -= 2) {

            /*
             * get two pixels and convert to 15-bpp YUV
             */

            dwPixel = *pSrc++;


            /*
             * dwPixel now has two pixels, in this layout (MSB..LSB):
             *
             *  V Y1 U Y0
             *
             * convert to 2 yuv555 words and lookup in xlate table
             */

            /* get common u and v components to lower 10 bits */
            uv55 = ((dwPixel & 0xf8000000) >> 27) |
                    ((dwPixel & 0x0000f800) >> 6);


            /* build each yuv-655 value by truncating
             * y to 5 bits and adding the common u and v bits,
             * look up to convert to rgb, and combine two pixels
             * into one dword
             */
            dwPixel = pXlate[ ((dwPixel & 0xf8) << 7) | uv55 ] |
                      (pXlate[((dwPixel & 0xf80000) >> 9) | uv55 ] << 16);

            /* write two pixels to destination */
            *pDst++ = dwPixel;


        } // loop per 2 pixels


        /* move dest pointer back to next line */
        pDst -= RowInc;

    } // loop per row



    if (bDuplicate) {

        PBYTE pbDst;

        /*
         * Note that since we started at the last line, and didn't duplicate,
         * we placed data in lines 1, 3, 5 etc that needs to be copied
         * to lines 0, 2, 4 etc.
         */
        for (i = 0, pbDst = lpOutput; i < (int) Height; i+= 2) {


            /*
             * duplicate the scan line. We point at the first of the
             * two lines - the data is in the second of the
             * two lines.
             */
            RtlCopyMemory(pbDst, pbDst + WidthBytes, WidthBytes);

            /* skip this pair to get to the next line to be converted */
            pbDst += WidthBytes * 2;
        }
    }
}



#ifdef  TOSHIBA
#ifdef  COLOR_MODIFY
/* YUV12 support ------------------------------------------ */

/*
 * TOSHIBA Y.Kasai
 * for Pistachio
 *
 * The captured data is in YUV12 , 8-bits per.
 * The data is separated each Y,U,V segment.
 * Data format is folow sequence:
 * Y0,Y1,Y2.......Yn,U0,U1,U2.....U(n/4),V0,V1,V2....V(n/4)
 *
 */





/*
 * build a translation table to translate between YUV and RGB555.
 *
 * This builds a lookup table with 32k 1-word entries: truncate the YUV
 * to 15bits (5-5-5) and look-up in this xlate table to produce the
 * 15-bit rgb value.
 */
LPVOID BuildYUVToRB(PINSTINFO pinst)
{
    HGLOBAL hMem = 0;
    LPVOID pXlate = NULL;

    if (pinst->pXlate != NULL) {
        return(pinst->pXlate);
    }

    /*
     * allocate a table big enough for 64k 2-coloer (R, B) entries
     */
    if ( ( hMem = GlobalAlloc(GPTR, 2 * 64 * 1024) )
      && ( pXlate = GlobalLock( hMem ) ) )
    {
        LPBYTE pRB = (LPBYTE)pXlate;
        ULONG  w;

        for (w = 0; w < 64*1024; w++) {
            *pRB++ = TosYVToR( (w &  0xff00) >> 8, ((w & 0xff)) );
        }

        for (w = 0; w < 64*1024; w++) {
            *pRB++ = TosYUToB( (w &  0xff00) >> 8, ((w & 0xff)) );
        }
    }

    return(pXlate);
}

#else //COLOR_MODIFY
/* YUV12 support ------------------------------------------ */

/*
 * TOSHIBA Y.Kasai
 * for Pistachio
 *
 * The captured data is in YUV12 , 8-bits per.
 * The data is separated each Y,U,V segment.
 * Data format is folow sequence:
 * Y0,Y1,Y2.......Yn,U0,U1,U2.....U(n/4),V0,V1,V2....V(n/4)
 *
 */





/*
 * build a translation table to translate between YUV and RGB555.
 *
 * This builds a lookup table with 32k 1-word entries: truncate the YUV
 * to 15bits (5-5-5) and look-up in this xlate table to produce the
 * 15-bit rgb value.
 */
LPVOID BuildYUV12ToRGB555(PINSTINFO pinst)
{
    HGLOBAL hMem = 0;
    LPVOID pXlate = NULL;
    // LPWORD pRGB555;

    if (pinst->pXlate != NULL) {
        return(pinst->pXlate);
    }

    /*
     * allocate a table big enough for 32k 2-byte entries
     */
    if ( ( hMem = GlobalAlloc(GPTR, 2 * 32 * 1024) )
      && ( pXlate = GlobalLock( hMem ) ) )
    {
        WORD w;
        LPWORD pRGB555 = (LPWORD)pXlate;
    
        /*
         * build a 15-bit yuv lookup table by stepping through each entry,
         * converting the yuv index to rgb and storing at that index. The index
         * to this table is a 15-bit value with the y component in bits 14..10,
         * u in bits 9..5 and v in bits 4..0. Note that the y component is unsigned,
         * whereas the u and v components are signed.
         */
        for (w = 0; w < 32*1024; w++) {
            /*
             * the YUVtoRGB55 conversion function takes values 0..255 for y,
             * and 0..255 for u and v. Pick out the relevant bits of the
             * index for this cell, and shift to get values in this range.
             */
            *pRGB555++ = TosYUVToRGB555(
                                (w &  0x7c00) >> 7,
                                ((w & 0x3e0) >> 2),
                                ((w & 0x1f) << 3)
                         );
        }
    }
    return(pXlate);
}

/*
 * build a translation table to translate between YUV and RGB 5-6-5
 *
 * This builds a lookup table with 32k 1-word entries: truncate the YUV
 * to 15bits (5-5-5) and look-up in this xlate table to produce the
 * 16-bit rgb value.
 */
LPVOID BuildYUV12ToRGB565(PINSTINFO pinst)
{
    HGLOBAL hMem = 0;
    LPVOID pXlate = NULL;

    if (pinst->pXlate != NULL) {
        return(pinst->pXlate);
    }

    /*
     * allocate a table big enough for 32k 2-byte entries
     */

    if ( ( hMem = GlobalAlloc(GPTR, 2 * 32 * 1024) )
      && ( pXlate = GlobalLock( hMem ) ) )
    {
        WORD w;
        LPWORD pRGB = (LPWORD)pXlate;

        /*
         * build a 15-bit yuv lookup table by stepping through each entry,
         * converting the yuv index to rgb and storing at that index. The index
         * to this table is a 15-bit value with the y component in bits 14..10,
         * u in bits 9..5 and v in bits 4..0. Note that the y component is unsigned,
         * whereas the u and v components are signed.
         */
        for (w = 0; w < 32*1024; w++) {
    
            /*
             * the YUVtoRGB conversion function takes values 0..255 for y,
             * and 0.255 for u and v. Pick out the relevant bits of the
             * index for this cell, and shift to get values in this range.
             */
            *pRGB++ = TosYUVToRGB565(
                                (w &  0x7c00) >> 7,
                                ((w & 0x3e0) >> 2),
                                ((w & 0x1f) << 3)
                         );
        }
    }

    return(pXlate);
}
#endif//COLOR_MODIFY

/*
 * translate YUV12 into 16-bit RGB using a lookup table. Flip vertically
 * into DIB format during processing. Double scanlines for formats of
 * 240 lines or greater. Produces 565 or 555 format RGB depending on the
 * xlate table.
 */
#ifdef  COLOR_MODIFY
VOID
YUV12ToRGB24(
    PINSTINFO pinst,
     LPBITMAPINFOHEADER lpbiInput,
     LPVOID lpInput,
     LPBITMAPINFOHEADER lpbiOutput,
     LPVOID lpOutput
)
{
    int RowInc;
    int UVRowInc;
    int i, j;
    DWORD dwYPixel;
    int dwParam, dwTemp;
    int WidthBytes;                     // width of one line in BYTES
    BOOL bDuplicate = FALSE;
    PDWORD pYSrc;
    volatile PBYTE pDst;  // '98-12-08 Add volatile attr. for Rep.253570
    PWORD pUSrc, pVSrc;
    WORD wUPixel, wVPixel;
    WORD wUPTemp, wVPTemp;
    int Height, Width;
    PBYTE pXlate;
    int InputHeight;
    BYTE ubR, ubG, ubB;


    Height = lpbiInput->biHeight;
    InputHeight = Height;
    Width = lpbiInput->biWidth;
    WidthBytes = Width*3;               // size of (input and output) line
    pXlate = (PBYTE)pinst->pXlate;


    /*
     * adjust the destination to point to the start of the last line,
     * and work upwards (to flip vertically into DIB format)
     */
    pDst  = (PBYTE) ( (LPBYTE)lpOutput + (Height - 1) * WidthBytes );
    pYSrc = (PDWORD) lpInput;
    pUSrc = (PWORD) ( (LPBYTE)lpInput + Height * Width);
    pVSrc = (PWORD) ( (LPBYTE)lpInput + Height * Width + Height * Width / 4);

    RowInc = WidthBytes + (Width * 3);

    UVRowInc = Width / 2;
    UVRowInc /= sizeof(WORD);

    /* loop copying each scanline */
    for (i = 0; i < InputHeight; i++) {

        /* loop copying two pixels at a time */
        for (j = Width ; j > 0; j -= 4) {

            /*
             * get four pixels and convert to 15-bpp YUV
             */

            dwYPixel = *pYSrc++;
            wUPixel = *pUSrc++;
            wVPixel = *pVSrc++;

            wVPTemp = wVPixel & 0xff;
            wUPTemp = wUPixel & 0xff;
            dwParam = (833 * wVPTemp) + (402 * wUPTemp) - 138908;

            /*
             * dwY(U or V)Pixel now has two pixels, in this layout (MSB..LSB):
             *
             *  Y3 Y2 Y1 Y0
             *  V1 V0
             *  U1 U0
             *
             * convert to 4 yuv555 words and lookup in xlate table
             */

            /* build each yuv-555 value by truncating
             * y to 8 bits and adding the common u and v bits,
             * look up to convert to rgb, and combine two pixels
             * into one dword
             */
            dwTemp = dwYPixel & 0xff;
            ubG = (BYTE)RANGE((dwTemp * 1192 - dwParam) / 1024, 0, 255);
            dwTemp <<= 8;
            ubR = pXlate[ dwTemp | wVPTemp];
            ubB = pXlate[(dwTemp | wUPTemp) + 65536];

            *pDst++ = ubB;
            *pDst++ = ubG;
            *pDst++ = ubR;

            // next pixel
            dwTemp = dwYPixel & 0xff00;
            ubR = pXlate[ dwTemp | wVPTemp];
            ubB = pXlate[(dwTemp | wUPTemp) + 65536];
            ubG = (BYTE)RANGE(((dwTemp >> 8) * 1192 - dwParam) / 1024, 0, 255);

            *pDst++ = ubB;
            *pDst++ = ubG;
            *pDst++ = ubR;

            wVPTemp = (wVPixel >> 8) & 0xff;
            wUPTemp = (wUPixel >> 8) & 0xff;
            dwParam = (833 * wVPTemp) + (402 * wUPTemp) - 138908;

            dwTemp = (dwYPixel & 0xff0000) >> 8;
            ubR = pXlate[ dwTemp | wVPTemp];
            ubB = pXlate[(dwTemp | wUPTemp) + 65536];
            ubG = (BYTE)RANGE(((dwTemp >> 8) * 1192 - dwParam) / 1024, 0, 255);

            *pDst++ = ubB;
            *pDst++ = ubG;
            *pDst++ = ubR;

            // next pixel
            dwTemp = (dwYPixel & 0xff000000) >> 16;
            ubR = pXlate[ dwTemp | wVPTemp];
            ubB = pXlate[(dwTemp | wUPTemp) + 65536];
            ubG = (BYTE)RANGE(((dwTemp >> 8) * 1192 - dwParam) / 1024, 0, 255);

            *pDst++ = ubB;
            *pDst++ = ubG;
            *pDst++ = ubR;

        } // loop per 4 pixels

        if (!(i & 1))
        {
            pUSrc -= UVRowInc;
            pVSrc -= UVRowInc;
        }

        /* move dest pointer back to next line */
        pDst -= RowInc;

    } // loop per row
}

VOID
YUV12ToRGB565(
    PINSTINFO pinst,
     LPBITMAPINFOHEADER lpbiInput,
     LPVOID lpInput,
     LPBITMAPINFOHEADER lpbiOutput,
     LPVOID lpOutput
)
{
    int RowInc;
    int UVRowInc;
    int i, j;
    DWORD uv55, dwPixel, dwYPixel;
    int dwParam, dwTemp;
    int WidthBytes;                     // width of one line in BYTES
    BOOL bDuplicate = FALSE;
    PDWORD pYSrc;
    volatile PDWORD pDst;  // '98-12-08 Add volatile attr. for Rep.253570
    PWORD pUSrc, pVSrc;
    WORD wUPixel, wVPixel;
    WORD wUPTemp, wVPTemp;
    int Height, Width;
    PBYTE pXlate;
    int InputHeight;
    BYTE ubR, ubG, ubB;


    Height = lpbiInput->biHeight;
    InputHeight = Height;
    Width = lpbiInput->biWidth;
    WidthBytes = Width*2;               // size of (input and output) line
    pXlate = (PBYTE)pinst->pXlate;


    /*
     * adjust the destination to point to the start of the last line,
     * and work upwards (to flip vertically into DIB format)
     */
    pDst = (PDWORD) ( (LPBYTE)lpOutput + (Height - 1) * WidthBytes );
    pYSrc = (PDWORD) lpInput;
    pUSrc = (PWORD) ( (LPBYTE)lpInput + Height * Width);
    pVSrc = (PWORD) ( (LPBYTE)lpInput + Height * Width + Height * Width / 4);


    RowInc = WidthBytes + (Width * 2);

    /* remember we are adding to a DWORD pointer */
    RowInc /= sizeof(DWORD);

    UVRowInc = Width / 2;
    UVRowInc /= sizeof(WORD);

    /* loop copying each scanline */
    for (i = 0; i < InputHeight; i++) {

        /* loop copying two pixels at a time */
        for (j = Width ; j > 0; j -= 4) {

            /*
             * get four pixels and convert to 15-bpp YUV
             */

            dwYPixel = *pYSrc++;
            wUPixel = *pUSrc++;
            wVPixel = *pVSrc++;

            wVPTemp = wVPixel & 0xff;
            wUPTemp = wUPixel & 0xff;
            dwParam = (833 * wVPTemp) + (402 * wUPTemp) - 138908;

            /*
             * dwY(U or V)Pixel now has two pixels, in this layout (MSB..LSB):
             *
             *  Y3 Y2 Y1 Y0
             *  V1 V0
             *  U1 U0
             *
             * convert to 4 yuv555 words and lookup in xlate table
             */

            /* build each yuv-555 value by truncating
             * y to 8 bits and adding the common u and v bits,
             * look up to convert to rgb, and combine two pixels
             * into one dword
             */
            dwTemp = dwYPixel & 0xff;
            ubG = (BYTE)RANGE((dwTemp * 1192 - dwParam) / 1024, 0, 255);
            dwTemp <<= 8;
            ubR = pXlate[ dwTemp | wVPTemp];
            ubB = pXlate[(dwTemp | wUPTemp) + 65536];

            dwPixel = (ubR & 0xf8) << 8 | (ubG & 0xfc) << 3 | (ubB & 0xf8) >> 3;

            // next pixel
            dwTemp = dwYPixel & 0xff00;
            ubR = pXlate[ dwTemp | wVPTemp];
            ubB = pXlate[(dwTemp | wUPTemp) + 65536];
            ubG = (BYTE)RANGE(((dwTemp >> 8) * 1192 - dwParam) / 1024, 0, 255);

            dwPixel |= (ubR & 0xf8) << 24 | (ubG & 0xfc) << 19 | (ubB & 0xf8) << 13;

            /* write two pixels to destination */
            *pDst++ = dwPixel;

            wVPTemp = (wVPixel >> 8) & 0xff;
            wUPTemp = (wUPixel >> 8) & 0xff;
            dwParam = (833 * wVPTemp) + (402 * wUPTemp) - 138908;

            dwTemp = (dwYPixel & 0xff0000) >> 8;
            ubR = pXlate[ dwTemp | wVPTemp];
            ubB = pXlate[(dwTemp | wUPTemp) + 65536];
            ubG = (BYTE)RANGE(((dwTemp >> 8) * 1192 - dwParam) / 1024, 0, 255);

            dwPixel = (ubR & 0xf8) << 8 | (ubG & 0xfc) << 3 | (ubB & 0xf8) >> 3;

            // next pixel
            dwTemp = (dwYPixel & 0xff000000) >> 16;
            ubR = pXlate[ dwTemp | wVPTemp];
            ubB = pXlate[(dwTemp | wUPTemp) + 65536];
            ubG = (BYTE)RANGE(((dwTemp >> 8) * 1192 - dwParam) / 1024, 0, 255);

            dwPixel |= (ubR & 0xf8) << 24 | (ubG & 0xfc) << 19 | (ubB & 0xf8) << 13;

            /* write two pixels to destination */
            *pDst++ = dwPixel;

        } // loop per 4 pixels

        if (!(i & 1))
        {
            pUSrc -= UVRowInc;
            pVSrc -= UVRowInc;
        }

        /* move dest pointer back to next line */
        pDst -= RowInc;

    } // loop per row
}

VOID
YUV12ToRGB555(
    PINSTINFO pinst,
     LPBITMAPINFOHEADER lpbiInput,
     LPVOID lpInput,
     LPBITMAPINFOHEADER lpbiOutput,
     LPVOID lpOutput
)
{
    int RowInc;
    int UVRowInc;
    int i, j;
    DWORD uv55, dwPixel, dwYPixel;
    int dwParam, dwTemp;
    int WidthBytes;                     // width of one line in BYTES
    BOOL bDuplicate = FALSE;
    PDWORD pYSrc;
    volatile PDWORD pDst;  // '98-12-08 Add volatile attr. for Rep.253570
    PWORD pUSrc, pVSrc;
    WORD wUPixel, wVPixel;
    WORD wUPTemp, wVPTemp;
    int Height, Width;
    PBYTE pXlate;
    int InputHeight;
    BYTE ubR, ubG, ubB;


    Height = lpbiInput->biHeight;
    InputHeight = Height;
    Width = lpbiInput->biWidth;
    WidthBytes = Width*2;               // size of (input and output) line
    pXlate = (PBYTE)pinst->pXlate;


    /*
     * adjust the destination to point to the start of the last line,
     * and work upwards (to flip vertically into DIB format)
     */
    pDst = (PDWORD) ( (LPBYTE)lpOutput + (Height - 1) * WidthBytes );
    pYSrc = (PDWORD) lpInput;
    pUSrc = (PWORD) ( (LPBYTE)lpInput + Height * Width);
    pVSrc = (PWORD) ( (LPBYTE)lpInput + Height * Width + Height * Width / 4);


    RowInc = WidthBytes + (Width * 2);

    /* remember we are adding to a DWORD pointer */
    RowInc /= sizeof(DWORD);

    UVRowInc = Width / 2;
    UVRowInc /= sizeof(WORD);

    /* loop copying each scanline */
    for (i = 0; i < InputHeight; i++) {

        /* loop copying two pixels at a time */
        for (j = Width ; j > 0; j -= 4) {

            /*
             * get four pixels and convert to 15-bpp YUV
             */

            dwYPixel = *pYSrc++;
            wUPixel = *pUSrc++;
            wVPixel = *pVSrc++;

            wVPTemp = wVPixel & 0xff;
            wUPTemp = wUPixel & 0xff;
            dwParam = (833 * wVPTemp) + (402 * wUPTemp) - 138908;

            /*
             * dwY(U or V)Pixel now has two pixels, in this layout (MSB..LSB):
             *
             *  Y3 Y2 Y1 Y0
             *  V1 V0
             *  U1 U0
             *
             * convert to 4 yuv555 words and lookup in xlate table
             */

            /* build each yuv-555 value by truncating
             * y to 8 bits and adding the common u and v bits,
             * look up to convert to rgb, and combine two pixels
             * into one dword
             */
            dwTemp = dwYPixel & 0xff;
            ubG = (BYTE)RANGE((dwTemp * 1192 - dwParam) / 1024, 0, 255);
            dwTemp <<= 8;
            ubR = pXlate[ dwTemp | wVPTemp];
            ubB = pXlate[(dwTemp | wUPTemp) + 65536];

            dwPixel = (ubR & 0xf8) << 7 | (ubG & 0xf8) << 2 | (ubB & 0xf8) >> 3;

            // next pixel
            dwTemp = dwYPixel & 0xff00;
            ubR = pXlate[ dwTemp | wVPTemp];
            ubB = pXlate[(dwTemp | wUPTemp) + 65536];
            ubG = (BYTE)RANGE(((dwTemp >> 8) * 1192 - dwParam) / 1024, 0, 255);

            dwPixel |= (ubR & 0xf8) << 23 | (ubG & 0xf8) << 18 | (ubB & 0xf8) << 13;

            /* write two pixels to destination */
            *pDst++ = dwPixel;

            wVPTemp = (wVPixel >> 8) & 0xff;
            wUPTemp = (wUPixel >> 8) & 0xff;
            dwParam = (833 * wVPTemp) + (402 * wUPTemp) - 138908;

            dwTemp = (dwYPixel & 0xff0000) >> 8;
            ubR = pXlate[ dwTemp | wVPTemp];
            ubB = pXlate[(dwTemp | wUPTemp) + 65536];
            ubG = (BYTE)RANGE(((dwTemp >> 8) * 1192 - dwParam) / 1024, 0, 255);

            dwPixel = (ubR & 0xf8) << 7 | (ubG & 0xf8) << 2 | (ubB & 0xf8) >> 3;

            // next pixel
            dwTemp = (dwYPixel & 0xff000000) >> 16;
            ubR = pXlate[ dwTemp | wVPTemp];
            ubB = pXlate[(dwTemp | wUPTemp) + 65536];
            ubG = (BYTE)RANGE(((dwTemp >> 8) * 1192 - dwParam) / 1024, 0, 255);

            dwPixel |= (ubR & 0xf8) << 23 | (ubG & 0xf8) << 18 | (ubB & 0xf8) << 13;

            /* write two pixels to destination */
            *pDst++ = dwPixel;

        } // loop per 4 pixels

        if (!(i & 1))
        {
            pUSrc -= UVRowInc;
            pVSrc -= UVRowInc;
        }

        /* move dest pointer back to next line */
        pDst -= RowInc;

    } // loop per row
}
#else //COLOR_MODIFY
VOID
YUV12ToRGB(
    PINSTINFO pinst,
     LPBITMAPINFOHEADER lpbiInput,
     LPVOID lpInput,
     LPBITMAPINFOHEADER lpbiOutput,
     LPVOID lpOutput
)
{
    int RowInc;
        int UVRowInc;
    int i, j;
    DWORD uv55, dwPixel, dwYPixel;
    int WidthBytes;                     // width of one line in BYTES
    BOOL bDuplicate = FALSE;
    PDWORD pYSrc, pDst;
    PWORD pUSrc, pVSrc;
    WORD wUPixel, wVPixel;
    int Height, Width;
    PWORD pXlate;
    int InputHeight;


    Height = lpbiInput->biHeight;
    InputHeight = Height;
    Width = lpbiInput->biWidth;
    WidthBytes = Width*2;               // size of (input and output) line
    pXlate = pinst->pXlate;


    /*
     * adjust the destination to point to the start of the last line,
     * and work upwards (to flip vertically into DIB format)
     */
    pDst = (PDWORD) ( (LPBYTE)lpOutput + (Height - 1) * WidthBytes );
    pYSrc = (PDWORD) lpInput;
#if 1
    pUSrc = (PWORD) ( (LPBYTE)lpInput + Height * Width);
    pVSrc = (PWORD) ( (LPBYTE)lpInput + Height * Width + Height * Width / 4);
#else
    pUSrc = (PWORD) lpInput + Height * Width;
    pVSrc = (PWORD) lpInput + Height * Width + Height * Width / 4;
#endif


#if 1
    RowInc = WidthBytes + (Width * 2);
#else
    /*
     * do we need to duplicate scans to fill the destination ?
     */
    if (Height >= 240) {
        bDuplicate = TRUE;

        /*
         * we need to skip one line each time we copy a line
         */
        RowInc = WidthBytes * 2 + (Width * 2);

        InputHeight = Height/2;

    } else {


        /*
         * calculate the amount to adjust pDst by at the end of one line
         * of copying. At this point we are at the end of line N. We need
         * to move to the start of line N-1.
         */
        RowInc = WidthBytes + (Width * 2);

    }
#endif

    /* remember we are adding to a DWORD pointer */
    RowInc /= sizeof(DWORD);

    UVRowInc = Width / 2;
    UVRowInc /= sizeof(WORD);



    /* loop copying each scanline */
    for (i = 0; i < InputHeight; i++) {

        /* loop copying two pixels at a time */
        for (j = Width ; j > 0; j -= 4) {

            /*
             * get four pixels and convert to 15-bpp YUV
             */

            dwYPixel = *pYSrc++;
            wUPixel = *pUSrc++;
            wVPixel = *pVSrc++;


            /*
             * dwY(U or V)Pixel now has two pixels, in this layout (MSB..LSB):
             *
             *  Y3 Y2 Y1 Y0
             *  V1 V0
             *  U1 U0
             *
             * convert to 4 yuv555 words and lookup in xlate table
             */

            /* get common u0 and v0 components to lower 10 bits */
            uv55 = ((wUPixel & 0xf8) << 2) |
                    ((wVPixel & 0xf8) >> 3);


            /* build each yuv-555 value by truncating
             * y to 5 bits and adding the common u and v bits,
             * look up to convert to rgb, and combine two pixels
             * into one dword
             */
            dwPixel = pXlate[ ((dwYPixel & 0xf8) << 7) | uv55 ] |
                      (pXlate[((dwYPixel & 0xf800) >> 1) | uv55 ] << 16);

            /* write two pixels to destination */
            *pDst++ = dwPixel;

            /* get common u1 and v1 components to lower 10 bits */
            uv55 = ((wUPixel & 0xf800) >> 6) |
                    ((wVPixel & 0xf800) >> 11);


            /* build each yuv-655 value by truncating
             * y to 5 bits and adding the common u and v bits,
             * look up to convert to rgb, and combine two pixels
             * into one dword
             */
            dwPixel = pXlate[ ((dwYPixel & 0xf80000) >> 9) | uv55 ] |
                      (pXlate[((dwYPixel & 0xf8000000) >> 17) | uv55 ] << 16);

            /* write two pixels to destination */
            *pDst++ = dwPixel;



        } // loop per 4 pixels

        if (!(i & 1))
        {
            pUSrc -= UVRowInc;
            pVSrc -= UVRowInc;
        }

        /* move dest pointer back to next line */
        pDst -= RowInc;

    } // loop per row


#if 0 // Pistachio is not support Interlace mode!!

    if (bDuplicate) {

        PBYTE pbDst;

        /*
         * Note that since we started at the last line, and didn't duplicate,
         * we placed data in lines 1, 3, 5 etc that needs to be copied
         * to lines 0, 2, 4 etc.
         */
        for (i = 0, pbDst = lpOutput; i < (int) Height; i+= 2) {


            /*
             * duplicate the scan line. We point at the first of the
             * two lines - the data is in the second of the
             * two lines.
             */
            RtlCopyMemory(pbDst, pbDst + WidthBytes, WidthBytes);

            /* skip this pair to get to the next line to be converted */
            pbDst += WidthBytes * 2;
        }
    }
#endif
}
#endif//COLOR_MODIFY



/* YUV9 Support ------------------------------------------ */

/*
 * TOSHIBA Y.Kasai
 * for Pistachio
 *
 * The captured data is in YUV9 .
 * The data is separated each Y,U,V segment.
 * Data format is folow sequence:
 * Y0,Y1,Y2.......Yn,V0,V1,V2....V(n/16),U0,U1,U2.....U(n/16)
 *
 */


/*
 * translate YUV9 into 16-bit RGB using a lookup table. Flip vertically
 * into DIB format during processing.
 * Produces 565 or 555 format RGB depending on the
 * xlate table.
 */
#ifdef  COLOR_MODIFY
VOID
YUV9ToRGB24(
    PINSTINFO pinst,
     LPBITMAPINFOHEADER lpbiInput,
     LPVOID lpInput,
     LPBITMAPINFOHEADER lpbiOutput,
     LPVOID lpOutput
)
{
    int RowInc;
    int UVRowInc;
    int i, j;
    DWORD dwYPixel;
    int dwParam, dwTemp;
    int WidthBytes;                     // width of one line in BYTES
    BOOL bDuplicate = FALSE;
    PDWORD pYSrc;
    volatile PBYTE pDst;  // '98-12-08 Add volatile attr. for Rep.253570
    PBYTE pUSrc, pVSrc;
    BYTE bUPixel, bVPixel;
    int Height, Width;
    PBYTE pXlate;
    int InputHeight;
    BYTE ubR, ubG, ubB;


    Height = lpbiInput->biHeight;
    InputHeight = Height;
    Width = lpbiInput->biWidth;
    WidthBytes = Width*3;               // size of (input and output) line
    pXlate = (PBYTE)pinst->pXlate;


    /*
     * adjust the destination to point to the start of the last line,
     * and work upwards (to flip vertically into DIB format)
     */
    pDst  = (PBYTE) ( (LPBYTE)lpOutput + (Height - 1) * WidthBytes );
    pYSrc = (PDWORD) lpInput;

    pVSrc = (PBYTE) ( (LPBYTE)lpInput + Height * Width);
    pUSrc = (PBYTE) ( (LPBYTE)lpInput + Height * Width + Height * Width / 16);

    /*
     * calculate the amount to adjust pDst by at the end of one line
     * of copying. At this point we are at the end of line N. We need
     * to move to the start of line N-1.
     */
    RowInc = WidthBytes + (Width * 3);

    UVRowInc = Width / 4;
    UVRowInc /= sizeof(BYTE);

    /* loop copying each scanline */
    for (i = 0; i < InputHeight; i++) {

        /* loop copying two pixels at a time */
        for (j = Width ; j > 0; j -= 4) {

            /*
             * get four pixels and convert to 15-bpp YUV
             */

            dwYPixel = *pYSrc++;
            bUPixel = *pUSrc++;
            bVPixel = *pVSrc++;

            dwParam = (833 * bVPixel) + (402 * bUPixel) - 138908;

            /*
             * dwY(U or V)Pixel now has four pixels, in this layout (MSB..LSB):
             *
             *  Y3 Y2 Y1 Y0
             *  V0
             *  U0
             *
             * convert to 4 yuv555 words and lookup in xlate table
             */

            /* build each yuv-555 value by truncating
             * y to 5 bits and adding the common u and v bits,
             * look up to convert to rgb, and combine two pixels
             * into one dword
             */
            dwTemp = dwYPixel & 0xff;
            ubG = (BYTE)RANGE((dwTemp * 1192 - dwParam) / 1024, 0, 255);
            dwTemp <<= 8;
            ubR = pXlate[ dwTemp | bVPixel];
            ubB = pXlate[(dwTemp | bUPixel) + 65536];

            *pDst++ = ubB;
            *pDst++ = ubG;
            *pDst++ = ubR;

            // next pixel
            dwTemp = dwYPixel & 0xff00;
            ubR = pXlate[ dwTemp | bVPixel];
            ubB = pXlate[(dwTemp | bUPixel) + 65536];
            ubG = (BYTE)RANGE(((dwTemp >> 8) * 1192 - dwParam) / 1024, 0, 255);

            *pDst++ = ubB;
            *pDst++ = ubG;
            *pDst++ = ubR;

            /* build each yuv-655 value by truncating
             * y to 5 bits and adding the common u and v bits,
             * look up to convert to rgb, and combine two pixels
             * into one dword
             */
            dwTemp = (dwYPixel & 0xff0000) >> 8;
            ubR = pXlate[ dwTemp | bVPixel];
            ubB = pXlate[(dwTemp | bUPixel) + 65536];
            ubG = (BYTE)RANGE(((dwTemp >> 8) * 1192 - dwParam) / 1024, 0, 255);

            *pDst++ = ubB;
            *pDst++ = ubG;
            *pDst++ = ubR;

            // next pixel
            dwTemp = (dwYPixel & 0xff000000) >> 16;
            ubR = pXlate[ dwTemp | bVPixel];
            ubB = pXlate[(dwTemp | bUPixel) + 65536];
            ubG = (BYTE)RANGE((((dwTemp >> 8) & 0xff) * 1192 - dwParam) / 1024, 0, 255);

            *pDst++ = ubB;
            *pDst++ = ubG;
            *pDst++ = ubR;

        } // loop per 4 pixels

        if ((i & 0x3) != 0x03)
        {
            pUSrc -= UVRowInc;
            pVSrc -= UVRowInc;
        }

        /* move dest pointer back to next line */
        pDst -= RowInc;

    } // loop per row
}

VOID
YUV9ToRGB565(
    PINSTINFO pinst,
     LPBITMAPINFOHEADER lpbiInput,
     LPVOID lpInput,
     LPBITMAPINFOHEADER lpbiOutput,
     LPVOID lpOutput
)
{
    int RowInc;
    int UVRowInc;
    int i, j;
    DWORD uv55, dwPixel, dwYPixel;
    int dwParam, dwTemp;
    int WidthBytes;                     // width of one line in BYTES
    BOOL bDuplicate = FALSE;
    PDWORD pYSrc;
    volatile PDWORD pDst;  // '98-12-08 Add volatile attr. for Rep.253570
    PBYTE pUSrc, pVSrc;
    BYTE bUPixel, bVPixel;
    int Height, Width;
    PBYTE pXlate;
    int InputHeight;
    BYTE ubR, ubG, ubB;


    Height = lpbiInput->biHeight;
    InputHeight = Height;
    Width = lpbiInput->biWidth;
    WidthBytes = Width*2;               // size of (input and output) line
    pXlate = (PBYTE)pinst->pXlate;


    /*
     * adjust the destination to point to the start of the last line,
     * and work upwards (to flip vertically into DIB format)
     */
    pDst = (PDWORD) ( (LPBYTE)lpOutput + (Height - 1) * WidthBytes );
    pYSrc = (PDWORD) lpInput;

    pVSrc = (PBYTE) ( (LPBYTE)lpInput + Height * Width);
    pUSrc = (PBYTE) ( (LPBYTE)lpInput + Height * Width + Height * Width / 16);

    /*
     * calculate the amount to adjust pDst by at the end of one line
     * of copying. At this point we are at the end of line N. We need
     * to move to the start of line N-1.
     */
    RowInc = WidthBytes + (Width * 2);


    /* remember we are adding to a DWORD pointer */
    RowInc /= sizeof(DWORD);


    UVRowInc = Width / 4;
    UVRowInc /= sizeof(BYTE);

    /* loop copying each scanline */
    for (i = 0; i < InputHeight; i++) {

        /* loop copying two pixels at a time */
        for (j = Width ; j > 0; j -= 4) {

            /*
             * get four pixels and convert to 15-bpp YUV
             */

            dwYPixel = *pYSrc++;
            bUPixel = *pUSrc++;
            bVPixel = *pVSrc++;

            dwParam = (833 * bVPixel) + (402 * bUPixel) - 138908;

            /*
             * dwY(U or V)Pixel now has four pixels, in this layout (MSB..LSB):
             *
             *  Y3 Y2 Y1 Y0
             *  V0
             *  U0
             *
             * convert to 4 yuv555 words and lookup in xlate table
             */

            /* build each yuv-555 value by truncating
             * y to 5 bits and adding the common u and v bits,
             * look up to convert to rgb, and combine two pixels
             * into one dword
             */
            dwTemp = dwYPixel & 0xff;
            ubG = (BYTE)RANGE((dwTemp * 1192 - dwParam) / 1024, 0, 255);
            dwTemp <<= 8;
            ubR = pXlate[ dwTemp | bVPixel];
            ubB = pXlate[(dwTemp | bUPixel) + 65536];

            dwPixel = (ubR & 0xf8) << 8 | (ubG & 0xfc) << 3 | (ubB & 0xf8) >> 3;

            // next pixel
            dwTemp = dwYPixel & 0xff00;
            ubR = pXlate[ dwTemp | bVPixel];
            ubB = pXlate[(dwTemp | bUPixel) + 65536];
            ubG = (BYTE)RANGE(((dwTemp >> 8) * 1192 - dwParam) / 1024, 0, 255);

            dwPixel |= (ubR & 0xf8) << 24 | (ubG & 0xfc) << 19 | (ubB & 0xf8) << 13;

            *pDst++ = dwPixel;

            /* build each yuv-655 value by truncating
             * y to 5 bits and adding the common u and v bits,
             * look up to convert to rgb, and combine two pixels
             * into one dword
             */
            dwTemp = (dwYPixel & 0xff0000) >> 8;
            ubR = pXlate[ dwTemp | bVPixel];
            ubB = pXlate[(dwTemp | bUPixel) + 65536];
            ubG = (BYTE)RANGE(((dwTemp >> 8) * 1192 - dwParam) / 1024, 0, 255);

            dwPixel = (ubR & 0xf8) << 8 | (ubG & 0xfc) << 3 | (ubB & 0xf8) >> 3;

            // next pixel
            dwTemp = (dwYPixel & 0xff000000) >> 16;
            ubR = pXlate[ dwTemp | bVPixel];
            ubB = pXlate[(dwTemp | bUPixel) + 65536];
            ubG = (BYTE)RANGE((((dwTemp >> 8) & 0xff) * 1192 - dwParam) / 1024, 0, 255);

            dwPixel |= (ubR & 0xf8) << 24 | (ubG & 0xfc) << 19 | (ubB & 0xf8) << 13;

            /* write two pixels to destination */
            *pDst++ = dwPixel;

        } // loop per 4 pixels

        if ((i & 0x3) != 0x03)
        {
            pUSrc -= UVRowInc;
            pVSrc -= UVRowInc;
        }

        /* move dest pointer back to next line */
        pDst -= RowInc;

    } // loop per row
}

VOID
YUV9ToRGB555(
    PINSTINFO pinst,
     LPBITMAPINFOHEADER lpbiInput,
     LPVOID lpInput,
     LPBITMAPINFOHEADER lpbiOutput,
     LPVOID lpOutput
)
{
    int RowInc;
    int UVRowInc;
    int i, j;
    DWORD uv55, dwPixel, dwYPixel;
    int dwParam, dwTemp;
    int WidthBytes;                     // width of one line in BYTES
    BOOL bDuplicate = FALSE;
    PDWORD pYSrc;
    volatile PDWORD pDst;  // '98-12-08 Add volatile attr. for Rep.253570
    PBYTE pUSrc, pVSrc;
    BYTE bUPixel, bVPixel;
    int Height, Width;
    PBYTE pXlate;
    int InputHeight;
    BYTE ubR, ubG, ubB;


    Height = lpbiInput->biHeight;
    InputHeight = Height;
    Width = lpbiInput->biWidth;
    WidthBytes = Width*2;               // size of (input and output) line
    pXlate = pinst->pXlate;


    /*
     * adjust the destination to point to the start of the last line,
     * and work upwards (to flip vertically into DIB format)
     */
    pDst = (PDWORD) ( (LPBYTE)lpOutput + (Height - 1) * WidthBytes );
    pYSrc = (PDWORD) lpInput;

    pVSrc = (PBYTE) ( (LPBYTE)lpInput + Height * Width);
    pUSrc = (PBYTE) ( (LPBYTE)lpInput + Height * Width + Height * Width / 16);

    /*
     * calculate the amount to adjust pDst by at the end of one line
     * of copying. At this point we are at the end of line N. We need
     * to move to the start of line N-1.
     */
    RowInc = WidthBytes + (Width * 2);


    /* remember we are adding to a DWORD pointer */
    RowInc /= sizeof(DWORD);


    UVRowInc = Width / 4;
    UVRowInc /= sizeof(BYTE);

    /* loop copying each scanline */
    for (i = 0; i < InputHeight; i++) {

        /* loop copying two pixels at a time */
        for (j = Width ; j > 0; j -= 4) {

            /*
             * get four pixels and convert to 15-bpp YUV
             */

            dwYPixel = *pYSrc++;
            bUPixel = *pUSrc++;
            bVPixel = *pVSrc++;

            dwParam = (833 * bVPixel) + (402 * bUPixel) - 138908;

            /*
             * dwY(U or V)Pixel now has four pixels, in this layout (MSB..LSB):
             *
             *  Y3 Y2 Y1 Y0
             *  V0
             *  U0
             *
             * convert to 4 yuv555 words and lookup in xlate table
             */

            /* build each yuv-555 value by truncating
             * y to 5 bits and adding the common u and v bits,
             * look up to convert to rgb, and combine two pixels
             * into one dword
             */
            dwTemp = dwYPixel & 0xff;
            ubG = (BYTE)RANGE((dwTemp * 1192 - dwParam) / 1024, 0, 255);
            dwTemp <<= 8;
            ubR = pXlate[ dwTemp | bVPixel];
            ubB = pXlate[(dwTemp | bUPixel) + 65536];

            dwPixel = (ubR & 0xf8) << 7 | (ubG & 0xf8) << 2 | (ubB & 0xf8) >> 3;

            // next pixel
            dwTemp = dwYPixel & 0xff00;
            ubR = pXlate[ dwTemp | bVPixel];
            ubB = pXlate[(dwTemp | bUPixel) + 65536];
            ubG = (BYTE)RANGE(((dwTemp >> 8) * 1192 - dwParam) / 1024, 0, 255);

            dwPixel |= (ubR & 0xf8) << 23 | (ubG & 0xf8) << 18 | (ubB & 0xf8) << 13;

            /* write two pixels to destination */
            *pDst++ = dwPixel;


            /* build each yuv-655 value by truncating
             * y to 5 bits and adding the common u and v bits,
             * look up to convert to rgb, and combine two pixels
             * into one dword
             */
            dwTemp = (dwYPixel & 0xff0000) >> 8;
            ubR = pXlate[ dwTemp | bVPixel];
            ubB = pXlate[(dwTemp | bUPixel) + 65536];
            ubG = (BYTE)RANGE(((dwTemp >> 8) * 1192 - dwParam) / 1024, 0, 255);

            dwPixel = (ubR & 0xf8) << 7 | (ubG & 0xf8) << 2 | (ubB & 0xf8) >> 3;

            // next pixel
            dwTemp = (dwYPixel & 0xff000000) >> 16;
            ubR = pXlate[ dwTemp | bVPixel];
            ubB = pXlate[(dwTemp | bUPixel) + 65536];
            ubG = (BYTE)RANGE((((dwTemp >> 8) & 0xff) * 1192 - dwParam) / 1024, 0, 255);

            dwPixel |= (ubR & 0xf8) << 23 | (ubG & 0xf8) << 18 | (ubB & 0xf8) << 13;

            /* write two pixels to destination */
            *pDst++ = dwPixel;

        } // loop per 4 pixels

        if ((i & 0x3) != 0x03)
        {
            pUSrc -= UVRowInc;
            pVSrc -= UVRowInc;
        }

        /* move dest pointer back to next line */
        pDst -= RowInc;

    } // loop per row
}

#else //COLOR_MODIFY
VOID
YUV9ToRGB(
    PINSTINFO pinst,
     LPBITMAPINFOHEADER lpbiInput,
     LPVOID lpInput,
     LPBITMAPINFOHEADER lpbiOutput,
     LPVOID lpOutput
)
{
    int RowInc;
        int UVRowInc;
    int i, j;
    DWORD uv55, dwPixel, dwYPixel;
    int WidthBytes;                     // width of one line in BYTES
    BOOL bDuplicate = FALSE;
    PDWORD pYSrc, pDst;
    PBYTE pUSrc, pVSrc;
    BYTE bUPixel, bVPixel;
    int Height, Width;
    PWORD pXlate;
    int InputHeight;


    Height = lpbiInput->biHeight;
    InputHeight = Height;
    Width = lpbiInput->biWidth;
    WidthBytes = Width*2;               // size of (input and output) line
    pXlate = pinst->pXlate;


    /*
     * adjust the destination to point to the start of the last line,
     * and work upwards (to flip vertically into DIB format)
     */
    pDst = (PDWORD) ( (LPBYTE)lpOutput + (Height - 1) * WidthBytes );
    pYSrc = (PDWORD) lpInput;

#if 1
    pVSrc = (PBYTE) ( (LPBYTE)lpInput + Height * Width);
    pUSrc = (PBYTE) ( (LPBYTE)lpInput + Height * Width + Height * Width / 16);
#else
    pVSrc = (PBYTE) lpInput + Height * Width;
    pUSrc = (PBYTE) lpInput + Height * Width + Height * Width / 16;
#endif



        /*
         * calculate the amount to adjust pDst by at the end of one line
         * of copying. At this point we are at the end of line N. We need
         * to move to the start of line N-1.
         */
        RowInc = WidthBytes + (Width * 2);


    /* remember we are adding to a DWORD pointer */
    RowInc /= sizeof(DWORD);


    UVRowInc = Width / 4;
    UVRowInc /= sizeof(BYTE);



    /* loop copying each scanline */
    for (i = 0; i < InputHeight; i++) {

        /* loop copying two pixels at a time */
        for (j = Width ; j > 0; j -= 4) {

            /*
             * get four pixels and convert to 15-bpp YUV
             */

            dwYPixel = *pYSrc++;
            bUPixel = *pUSrc++;
            bVPixel = *pVSrc++;


            /*
             * dwY(U or V)Pixel now has four pixels, in this layout (MSB..LSB):
             *
             *  Y3 Y2 Y1 Y0
             *  V0
             *  U0
             *
             * convert to 4 yuv555 words and lookup in xlate table
             */

            /* get common u0 and v0 components to lower 10 bits */
            uv55 = ((bUPixel & 0xf8) << 2) |
                    ((bVPixel & 0xf8) >> 3);


            /* build each yuv-555 value by truncating
             * y to 5 bits and adding the common u and v bits,
             * look up to convert to rgb, and combine two pixels
             * into one dword
             */
            dwPixel = pXlate[ ((dwYPixel & 0xf8) << 7) | uv55 ] |
                      (pXlate[((dwYPixel & 0xf800) >> 1) | uv55 ] << 16);

            /* write two pixels to destination */
            *pDst++ = dwPixel;


            /* build each yuv-655 value by truncating
             * y to 5 bits and adding the common u and v bits,
             * look up to convert to rgb, and combine two pixels
             * into one dword
             */
            dwPixel = pXlate[ ((dwYPixel & 0xf80000) >> 9) | uv55 ] |
                      (pXlate[((dwYPixel & 0xf8000000) >> 17) | uv55 ] << 16);

            /* write two pixels to destination */
            *pDst++ = dwPixel;



        } // loop per 4 pixels

        if ((i & 0x3) != 0x03)
        {
            pUSrc -= UVRowInc;
            pVSrc -= UVRowInc;
        }

        /* move dest pointer back to next line */
        pDst -= RowInc;

    } // loop per row

}
#endif//COLOR_MODIFY
#endif//TOSHIBA



VOID FreeXlate(PINSTINFO pinst)
{

    GlobalFree(GlobalHandle(pinst->pXlate));

    pinst->pXlate = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\1394dcam\capprop.c ===
//===========================================================================
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
// PURPOSE.
//
// Copyright (c) 1996 - 2000  Microsoft Corporation.  All Rights Reserved.
//
//===========================================================================
/*++

Module Name:

    CapProp.c

Abstract:

    Stream class based WDM driver for 1934 Desktop Camera.
    This file contains code to handle the video and camera control properties.

Author:
    
    Yee J. Wu 9-Sep-97

Environment:

    Kernel mode only

Revision History:

    Yee J. Wu 16-Nov-00

        Make getting, advertising, and setting device properties more generic 
        by querying feature from the device directly instead of static settings
        based on the vendor.  The default and initial current settings will be 
        read from registry (from the INF).  The current setting will continue 
        to be updated and used thereafter.  For device that does not have its INF
        section, mid-range will be used as its default and initial settings.

--*/

#include "strmini.h"
#include "ksmedia.h"
#include "1394.h"
#include "wdm.h"       // for DbgBreakPoint() defined in dbg.h
#include "dbg.h"
#include "dcamdef.h"
#include "dcampkt.h"

#include "capprop.h"   // Video and camera property function prototype
#include "PropData.h"  // Generic device properties that are readonly


//
// Registry subky and values wide character strings.
//
WCHAR wszSettings[]     = L"Settings";

WCHAR wszVModeInq0[]    = L"VModeInq0";

WCHAR wszBrightness[]   = L"Brightness";
WCHAR wszHue[]          = L"Hue";
WCHAR wszSaturation[]   = L"Saturation";
WCHAR wszSharpness[]    = L"Sharpness";
WCHAR wszWhiteBalance[] = L"WhiteBalance";
WCHAR wszZoom[]         = L"Zoom";
WCHAR wszFocus[]        = L"Focus";

WCHAR wszBrightnessDef[]   = L"BrightnessDef";
WCHAR wszHueDef[]          = L"HueDef";
WCHAR wszSaturationDef[]   = L"SaturationDef";
WCHAR wszSharpnessDef[]    = L"SharpnessDef";
WCHAR wszWhiteBalanceDef[] = L"WhiteBalanceDef";
WCHAR wszZoomDef[]         = L"ZoomDef";
WCHAR wszFocusDef[]        = L"FocusDef";

NTSTATUS
DCamGetProperty(
    IN PIRB pIrb,
    PDCAM_EXTENSION pDevExt, 
    ULONG ulFieldOffset,
    LONG * plValue,
    ULONG * pulCapability,
    ULONG * pulFlags,
    DCamRegArea * pFeature
    )
/*
    Get a device property from its register.  Return the capabilites and current settings.
*/
{
    NTSTATUS status, StatusWait;

    // Make sure that device support this feature.
    if(pFeature->Feature.PresenceInq == 0) {
        DbgMsg1(("\'OffSet:%d not supported!\n", ulFieldOffset));
        return STATUS_NOT_SUPPORTED;
    }

    // Serialize read/write to the device register
    StatusWait = KeWaitForSingleObject( &pDevExt->hMutexProperty, Executive, KernelMode, FALSE, 0 );

    *pulCapability = 0;  
    if (pFeature->Feature.AutoMode)
        *pulCapability |= KSPROPERTY_VIDEOPROCAMP_FLAGS_AUTO;  // or == KSPROPERTY_CAMERACONTROL_FLAGS_AUTO

    if (pFeature->Feature.ManualMode)
        *pulCapability |= KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL;

    pDevExt->RegArea.AsULONG = 0;
    status = DCamReadRegister(pIrb, pDevExt, ulFieldOffset, &(pDevExt->RegArea.AsULONG));
    if(NT_SUCCESS(status)) {

        pDevExt->RegArea.AsULONG = bswap(pDevExt->RegArea.AsULONG);

        DbgMsg1(("\'GetProperty: CurrentSettings: Offset:%d; %x; Pres:%d;OnePush:%d;OnOff:%d;Auto:%d;Value:%d\n", 
            ulFieldOffset,
            pDevExt->RegArea.AsULONG, 
            pDevExt->RegArea.Brightness.PresenceInq,   
            pDevExt->RegArea.Brightness.OnePush,
            pDevExt->RegArea.Brightness.OnOff,
            pDevExt->RegArea.Brightness.AutoMode,          
            pDevExt->RegArea.Brightness.Value            
            ));

        *plValue = (LONG) pDevExt->RegArea.Brightness.Value;

        // These only valid if it has these capabilities.
        if (pDevExt->RegArea.Brightness.AutoMode)
            *pulFlags = KSPROPERTY_VIDEOPROCAMP_FLAGS_AUTO;
        else 
            *pulFlags = KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL;

    } else {
        ERROR_LOG(("\'DCamGetProperty: Failed %x to read setting.  Offset:%x\n", status, ulFieldOffset));
        status = STATUS_UNSUCCESSFUL;
    }

    KeReleaseMutex(&pDevExt->hMutexProperty, FALSE);

    return status;
}




NTSTATUS
DCamSetProperty(
    IN PIRB pIrb,
    PDCAM_EXTENSION pDevExt, 
    ULONG ulFieldOffset,
    ULONG ulFlags,
    LONG  lValue,
    DCamRegArea * pFeature,
    DCamRegArea * pCachedRegArea
    )
/*
    For a supported device, set to a new setting.
*/
{
    NTSTATUS status, StatusWait;
    LONG lRetries = MAX_READ_REG_RETRIES;
    LARGE_INTEGER stableTime;


    // Make sure that device support this feature.
    if(pFeature->Feature.PresenceInq == 0) {
        DbgMsg1(("\'OffSet:%d not supported!\n", ulFieldOffset));
        return STATUS_NOT_SUPPORTED;
    }

    // Validate the supported range
    if((LONG) pFeature->Feature.MAX_Value < lValue || lValue < (LONG) pFeature->Feature.MIN_Value) {
        ERROR_LOG(("\'Invalid value:%d for supported range (%d, %d)\n", lValue, pFeature->Feature.MIN_Value, pFeature->Feature.MAX_Value));
        return STATUS_INVALID_PARAMETER;
    }

    // Serialize read/write to the register
    StatusWait = KeWaitForSingleObject( &pDevExt->hMutexProperty, Executive, KernelMode, FALSE, 0 );

    // Read the current setting of this property
    pDevExt->RegArea.AsULONG = 0;
    do {
        status = DCamReadRegister(pIrb, pDevExt, ulFieldOffset, &(pDevExt->RegArea.AsULONG));
        if (!status) {                          
            pDevExt->RegArea.AsULONG = bswap(pDevExt->RegArea.AsULONG);
            DbgMsg3(("\'SetProperty: Current: %x: Pres:%d;OnePush:%d;OnOff:%d;Auto:%d;Value:%d\n", 
                pDevExt->RegArea.AsULONG, 
                pDevExt->RegArea.Brightness.PresenceInq,   
                pDevExt->RegArea.Brightness.OnePush,
                pDevExt->RegArea.Brightness.OnOff,
                pDevExt->RegArea.Brightness.AutoMode,
                pDevExt->RegArea.Brightness.Value
            ));
            // This feature might be in the transition (such as zoom or focus), 
            // it might return pDevExt->RegArea.Brightness.PresenceInq == 0.
            if(pDevExt->RegArea.Brightness.PresenceInq  == 1)
                break;
            else {
                if(lRetries > 1) {
                    stableTime.LowPart = DCAM_REG_STABLE_DELAY;
                    stableTime.HighPart = -1;
                    KeDelayExecutionThread(KernelMode, TRUE, &stableTime);
                    ERROR_LOG(("\'DCamSetProperty: delay, and try again...\n"));
                };
            }
        } else {
            // No need to retry if we failed to read.
            break;
        }

        lRetries--;
    } while (lRetries > 0);

    if(status || lRetries == 0) {
        KeReleaseMutex(&pDevExt->hMutexProperty, FALSE);
        ERROR_LOG(("\'DCamSetProperty: Failed! ST:%x; exceeded retried while pres is still 0\n", status));
        return STATUS_UNSUCCESSFUL;
    }

    pDevExt->RegArea.Brightness.PresenceInq = 1;  // Should be present.

    if((ulFlags & KSPROPERTY_VIDEOPROCAMP_FLAGS_AUTO) == KSPROPERTY_VIDEOPROCAMP_FLAGS_AUTO) {
        pDevExt->RegArea.Brightness.AutoMode = 1;
        // When Auto is set to 1, Value field is ignored.
    } else {
        pDevExt->RegArea.Brightness.AutoMode = 0;
        // special case for white balance
        if(FIELDOFFSET(CAMERA_REGISTER_MAP, WhiteBalance) == ulFieldOffset) {
            pDevExt->RegArea.WhiteBalance.UValue = pDevExt->RegArea.WhiteBalance.VValue = lValue;
        } else 
            pDevExt->RegArea.Brightness.Value = lValue;    
    }

    DbgMsg2(("\'SetProperty: NewSetting:     Offset:%d; %x; Pres:%d;OnePush:%d;OnOff:%d;Auto:%d;Value:%d\n", 
        ulFieldOffset,
        pDevExt->RegArea.AsULONG, 
        pDevExt->RegArea.Brightness.PresenceInq,   
        pDevExt->RegArea.Brightness.OnePush,
        pDevExt->RegArea.Brightness.OnOff,
        pDevExt->RegArea.Brightness.AutoMode,          
        pDevExt->RegArea.Brightness.Value            
        ));

    pDevExt->RegArea.AsULONG = bswap(pDevExt->RegArea.AsULONG);
    status = DCamWriteRegister(pIrb, pDevExt, ulFieldOffset, pDevExt->RegArea.AsULONG);

    if(status) { 
        ERROR_LOG(("\'DCamGetProperty: failed with status=0x%x\n", status));
    } else {
        // Update the cached setting (saved in the device extension)
        // These cached values will be save to registry as the persisted values for these properties.
        if(pCachedRegArea) {
            // WhiteBalance is an exception
            if(FIELDOFFSET(CAMERA_REGISTER_MAP, WhiteBalance) == ulFieldOffset) {
                pCachedRegArea->WhiteBalance.UValue = pCachedRegArea->WhiteBalance.VValue = lValue;
            } else
                pCachedRegArea->Brightness.Value    = lValue;
             // AutoMode is the 7th bit for all the properties used here.  (we do not use TRIGGER_MODE)
            pCachedRegArea->Brightness.AutoMode = ((ulFlags & KSPROPERTY_VIDEOPROCAMP_FLAGS_AUTO) == KSPROPERTY_VIDEOPROCAMP_FLAGS_AUTO);                    
        }
#if DBG
        // Verify that data were written as expected.
        pDevExt->RegAreaVerify.AsULONG = 0;
        status = DCamReadRegister(pIrb, pDevExt, ulFieldOffset, &(pDevExt->RegAreaVerify.AsULONG));


        if (!status) {    
            // bswap so we can compare.
            pDevExt->RegArea.AsULONG       = bswap(pDevExt->RegArea.AsULONG);
            pDevExt->RegAreaVerify.AsULONG = bswap(pDevExt->RegAreaVerify.AsULONG);

            DbgMsg2(("\'SetProperty: VerifySetting;  Offset:%d; %x; Pres:%d;OnePush:%d;OnOff:%d;Auto:%d;Value:%d\n\n", 
                ulFieldOffset,
                pDevExt->RegAreaVerify.AsULONG, 
                pDevExt->RegAreaVerify.Brightness.PresenceInq,   
                pDevExt->RegAreaVerify.Brightness.OnePush,
                pDevExt->RegAreaVerify.Brightness.OnOff,
                pDevExt->RegAreaVerify.Brightness.AutoMode,
                pDevExt->RegAreaVerify.Brightness.Value 
                ));

            ASSERT(pDevExt->RegArea.Brightness.PresenceInq == pDevExt->RegAreaVerify.Brightness.PresenceInq);
            ASSERT(pDevExt->RegArea.Brightness.OnePush     == pDevExt->RegAreaVerify.Brightness.OnePush);
            ASSERT(pDevExt->RegArea.Brightness.OnOff       == pDevExt->RegAreaVerify.Brightness.OnOff);
            ASSERT(pDevExt->RegArea.Brightness.AutoMode    == pDevExt->RegAreaVerify.Brightness.AutoMode);
            // If not auto mode, Value must match!
            ASSERT( pDevExt->RegArea.Brightness.Value == pDevExt->RegAreaVerify.Brightness.Value || 
                   (pDevExt->RegArea.Brightness.Value != pDevExt->RegAreaVerify.Brightness.Value && pDevExt->RegArea.Brightness.AutoMode == 1));
        }
#endif
    }

    KeReleaseMutex(&pDevExt->hMutexProperty, FALSE);

    return status;

}



/*
** AdapterGetVideoProcAmpProperty ()
**
**    Handles Set operations on the VideoProcAmp property set.
**      Testcap uses this for demo purposes only.
**
** Arguments:
**
**      pSRB -
**          Pointer to the HW_STREAM_REQUEST_BLOCK 
**
** Returns:
**
** Side Effects:  none
*/

VOID 
AdapterGetVideoProcAmpProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    NTSTATUS status;

    PDCAM_EXTENSION pDevExt = (PDCAM_EXTENSION) pSrb->HwDeviceExtension;

    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;

    PKSPROPERTY_VIDEOPROCAMP_S pS = (PKSPROPERTY_VIDEOPROCAMP_S) pSPD->PropertyInfo;    // pointer to the data

    ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_VIDEOPROCAMP_S));   

    switch (pSPD->Property->Id) {

    case KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS:  
        status = DCamGetProperty((PIRB) pSrb->SRBExtension, pDevExt, FIELDOFFSET(CAMERA_REGISTER_MAP, Brightness), &pS->Value, &pS->Capabilities, &pS->Flags, &pDevExt->DevProperty[ENUM_BRIGHTNESS].Feature);
        break;

    case KSPROPERTY_VIDEOPROCAMP_SHARPNESS:  
        status = DCamGetProperty((PIRB) pSrb->SRBExtension, pDevExt, FIELDOFFSET(CAMERA_REGISTER_MAP, Sharpness), &pS->Value, &pS->Capabilities, &pS->Flags, &pDevExt->DevProperty[ENUM_SHARPNESS].Feature);
        break;

    case KSPROPERTY_VIDEOPROCAMP_HUE:  
        status = DCamGetProperty((PIRB) pSrb->SRBExtension, pDevExt, FIELDOFFSET(CAMERA_REGISTER_MAP, Hue), &pS->Value, &pS->Capabilities, &pS->Flags, &pDevExt->DevProperty[ENUM_HUE].Feature); 
        break;
        
    case KSPROPERTY_VIDEOPROCAMP_SATURATION:
        status = DCamGetProperty((PIRB) pSrb->SRBExtension, pDevExt, FIELDOFFSET(CAMERA_REGISTER_MAP, Saturation), &pS->Value, &pS->Capabilities, &pS->Flags, &pDevExt->DevProperty[ENUM_SATURATION].Feature);
        break;

    case KSPROPERTY_VIDEOPROCAMP_WHITEBALANCE:
        status = DCamGetProperty((PIRB) pSrb->SRBExtension, pDevExt, FIELDOFFSET(CAMERA_REGISTER_MAP, WhiteBalance), &pS->Value, &pS->Capabilities, &pS->Flags, &pDevExt->DevProperty[ENUM_WHITEBALANCE].Feature);
        break;


    default:
        DbgMsg2(("\'AdapterGetVideoProcAmpProperty, Id (%x)not supported.\n", pSPD->Property->Id));
        ASSERT(FALSE);
        status = STATUS_NOT_IMPLEMENTED;
        break;
    }

    pSrb->Status = status;
    pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_VIDEOPROCAMP_S);

}

/*
** AdapterGetCameraControlProperty ()
**
**    Handles Set operations on the VideoProcAmp property set.
**      Testcap uses this for demo purposes only.
**
** Arguments:
**
**      pSRB -
**          Pointer to the HW_STREAM_REQUEST_BLOCK 
**
** Returns:
**
** Side Effects:  none
*/

VOID 
AdapterGetCameraControlProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    NTSTATUS status;

    PDCAM_EXTENSION pDevExt = (PDCAM_EXTENSION) pSrb->HwDeviceExtension;

    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;

    PKSPROPERTY_CAMERACONTROL_S pS = (PKSPROPERTY_CAMERACONTROL_S) pSPD->PropertyInfo;    // pointer to the data

    ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_CAMERACONTROL_S));

    switch (pSPD->Property->Id) {

    case KSPROPERTY_CAMERACONTROL_FOCUS:
        status = DCamGetProperty((PIRB) pSrb->SRBExtension, pDevExt, FIELDOFFSET(CAMERA_REGISTER_MAP, Focus), &pS->Value, &pS->Capabilities, &pS->Flags, &pDevExt->DevProperty[ENUM_FOCUS].Feature);
        break;       

    case KSPROPERTY_CAMERACONTROL_ZOOM:
        status = DCamGetProperty((PIRB) pSrb->SRBExtension, pDevExt, FIELDOFFSET(CAMERA_REGISTER_MAP, Zoom), &pS->Value, &pS->Capabilities, &pS->Flags, &pDevExt->DevProperty[ENUM_ZOOM].Feature);
        break;       

    default:     
        DbgMsg2(("\'AdapterGetCameraControlProperty, Id (%x)not supported.\n", pSPD->Property->Id));
        ASSERT(FALSE);
        status = STATUS_NOT_IMPLEMENTED;  
        break;
    }

    pSrb->Status = status;
    pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_CAMERACONTROL_S);

}


/*
** AdapterGetProperty ()
**
**    Handles Get operations for all adapter properties.
**
** Arguments:
**
**      pSRB -
**          Pointer to the HW_STREAM_REQUEST_BLOCK 
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI 
AdapterGetProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )

{
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;

    if (IsEqualGUID(&PROPSETID_VIDCAP_VIDEOPROCAMP, &pSPD->Property->Set)) {
        AdapterGetVideoProcAmpProperty (pSrb);
    } else  if (IsEqualGUID(&PROPSETID_VIDCAP_CAMERACONTROL, &pSPD->Property->Set)) {
        AdapterGetCameraControlProperty (pSrb);
    } else {
        //
        // We should never get here
        //

        ASSERT(FALSE);
    }
}

/*
** AdapterSetVideoProcAmpProperty ()
**
**    Handles Set operations on the VideoProcAmp property set.
**      Testcap uses this for demo purposes only.
**
** Arguments:
**
**      pSRB -
**          Pointer to the HW_STREAM_REQUEST_BLOCK 
**
** Returns:
**
** Side Effects:  none
*/

VOID 
AdapterSetVideoProcAmpProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    NTSTATUS status;

    PDCAM_EXTENSION pDevExt = (PDCAM_EXTENSION) pSrb->HwDeviceExtension;

    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;

    PKSPROPERTY_VIDEOPROCAMP_S pS = (PKSPROPERTY_VIDEOPROCAMP_S) pSPD->PropertyInfo;    // pointer to the data

    ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_VIDEOPROCAMP_S));    

    switch (pSPD->Property->Id) {

    case KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS:    
        status = DCamSetProperty((PIRB) pSrb->SRBExtension, pDevExt, FIELDOFFSET(CAMERA_REGISTER_MAP, Brightness), pS->Flags, pS->Value, &pDevExt->DevProperty[ENUM_BRIGHTNESS].Feature, &pDevExt->DevProperty[ENUM_BRIGHTNESS].StatusNControl);
        break;
        
    case KSPROPERTY_VIDEOPROCAMP_SHARPNESS:
        status = DCamSetProperty((PIRB) pSrb->SRBExtension, pDevExt, FIELDOFFSET(CAMERA_REGISTER_MAP, Sharpness), pS->Flags, pS->Value, &pDevExt->DevProperty[ENUM_SHARPNESS].Feature, &pDevExt->DevProperty[ENUM_SHARPNESS].StatusNControl);
        break;

    case KSPROPERTY_VIDEOPROCAMP_HUE:
        status = DCamSetProperty((PIRB) pSrb->SRBExtension, pDevExt, FIELDOFFSET(CAMERA_REGISTER_MAP, Hue), pS->Flags, pS->Value, &pDevExt->DevProperty[ENUM_HUE].Feature, &pDevExt->DevProperty[ENUM_HUE].StatusNControl);
        break;

    case KSPROPERTY_VIDEOPROCAMP_SATURATION:
        status = DCamSetProperty((PIRB) pSrb->SRBExtension, pDevExt, FIELDOFFSET(CAMERA_REGISTER_MAP, Saturation), pS->Flags, pS->Value, &pDevExt->DevProperty[ENUM_SATURATION].Feature, &pDevExt->DevProperty[ENUM_SATURATION].StatusNControl);
        break;

    case KSPROPERTY_VIDEOPROCAMP_WHITEBALANCE:
        status = DCamSetProperty((PIRB) pSrb->SRBExtension, pDevExt, FIELDOFFSET(CAMERA_REGISTER_MAP, WhiteBalance), pS->Flags, pS->Value, &pDevExt->DevProperty[ENUM_WHITEBALANCE].Feature, &pDevExt->DevProperty[ENUM_WHITEBALANCE].StatusNControl);
        break;

    default:
        status = STATUS_NOT_IMPLEMENTED; 
        break;
    }

    pSrb->Status = status;
    pSrb->ActualBytesTransferred = (status == STATUS_SUCCESS ? sizeof (KSPROPERTY_VIDEOPROCAMP_S) : 0);
 

}


/*
** AdapterSetCameraControlProperty ()
**
**    Handles Set operations on the CameraControl property set.
**
** Arguments:
**
**      pSRB -
**          Pointer to the HW_STREAM_REQUEST_BLOCK 
**
** Returns:
**
** Side Effects:  none
*/

VOID 
AdapterSetCameraControlProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    NTSTATUS status;

    PDCAM_EXTENSION pDevExt = (PDCAM_EXTENSION) pSrb->HwDeviceExtension;

    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;

    PKSPROPERTY_CAMERACONTROL_S pS = (PKSPROPERTY_CAMERACONTROL_S) pSPD->PropertyInfo;    // pointer to the data

    ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_CAMERACONTROL_S));    

    switch (pSPD->Property->Id) {

    case KSPROPERTY_CAMERACONTROL_FOCUS:
        status = DCamSetProperty((PIRB) pSrb->SRBExtension, pDevExt, FIELDOFFSET(CAMERA_REGISTER_MAP, Focus), pS->Flags, pS->Value, &pDevExt->DevProperty[ENUM_FOCUS].Feature, &pDevExt->DevProperty[ENUM_FOCUS].StatusNControl);
        break;

    case KSPROPERTY_CAMERACONTROL_ZOOM:
        status = DCamSetProperty((PIRB) pSrb->SRBExtension, pDevExt, FIELDOFFSET(CAMERA_REGISTER_MAP, Zoom), pS->Flags, pS->Value, &pDevExt->DevProperty[ENUM_ZOOM].Feature, &pDevExt->DevProperty[ENUM_ZOOM].StatusNControl);
        break;
 
    default:
        status = STATUS_NOT_IMPLEMENTED;
        break;
    }

    pSrb->Status = status;
    pSrb->ActualBytesTransferred = (status == STATUS_SUCCESS ? sizeof (KSPROPERTY_CAMERACONTROL_S) : 0);

}


/*
** AdapterSetProperty ()
**
**    Handles Get operations for all adapter properties.
**
** Arguments:
**
**      pSRB -
**          Pointer to the HW_STREAM_REQUEST_BLOCK 
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI 
AdapterSetProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )

{
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;

    if (IsEqualGUID(&PROPSETID_VIDCAP_VIDEOPROCAMP, &pSPD->Property->Set)) {
        AdapterSetVideoProcAmpProperty (pSrb);
    } else  if (IsEqualGUID(&PROPSETID_VIDCAP_CAMERACONTROL, &pSPD->Property->Set)) {
        AdapterSetCameraControlProperty (pSrb);
    } else {
        //
        // We should never get here
        //

        ASSERT(FALSE);
    }
}


NTSTATUS 
CreateRegistryKeySingle(
    IN HANDLE hKey,
    IN ACCESS_MASK desiredAccess,
    PWCHAR pwszSection,
    OUT PHANDLE phKeySection
    )
{
    NTSTATUS status;
    UNICODE_STRING ustr;
    OBJECT_ATTRIBUTES objectAttributes;

    RtlInitUnicodeString(&ustr, pwszSection);
    InitializeObjectAttributes(
        &objectAttributes,
        &ustr,
        OBJ_CASE_INSENSITIVE,
        hKey,
        NULL
        );

    status = 
         ZwCreateKey(
              phKeySection,
              desiredAccess,
              &objectAttributes,
              0,
              NULL,                    /* optional*/
              REG_OPTION_NON_VOLATILE,
              NULL
              );         

    return status;
}



NTSTATUS 
CreateRegistrySubKey(
    IN HANDLE hKey,
    IN ACCESS_MASK desiredAccess,
    PWCHAR pwszSection,
    OUT PHANDLE phKeySection
    )
{
    UNICODE_STRING ustr;
    USHORT usPos = 1;             // Skip first backslash
    static WCHAR wSep = '\\';
    NTSTATUS status = STATUS_SUCCESS;

    RtlInitUnicodeString(&ustr, pwszSection);

    while(usPos < ustr.Length) {
        if(ustr.Buffer[usPos] == wSep) {

            // NULL terminate our partial string
            ustr.Buffer[usPos] = UNICODE_NULL;
            status = 
                CreateRegistryKeySingle(
                    hKey,
                    desiredAccess,
                    ustr.Buffer,
                    phKeySection
                    );
            ustr.Buffer[usPos] = wSep;

            if(NT_SUCCESS(status)) {
                ZwClose(*phKeySection);
            } else {
                break;
            }
        }
        usPos++;
    }

    // Create the full key
    if(NT_SUCCESS(status)) {
        status = 
            CreateRegistryKeySingle(
                 hKey,
                 desiredAccess,
                 ustr.Buffer,
                 phKeySection
                 );
    }

    return status;
}



NTSTATUS 
GetRegistryKeyValue (
    IN HANDLE Handle,
    IN PWCHAR KeyNameString,
    IN ULONG KeyNameStringLength,
    IN PVOID Data,
    IN PULONG DataLength
    )

/*++

Routine Description:
    
    This routine gets the specified value out of the registry

Arguments:

    Handle - Handle to location in registry

    KeyNameString - registry key we're looking for

    KeyNameStringLength - length of registry key we're looking for

    Data - where to return the data

    DataLength - how big the data is

Return Value:

    status is returned from ZwQueryValueKey

--*/

{
    NTSTATUS status = STATUS_INSUFFICIENT_RESOURCES;
    UNICODE_STRING keyName;
    ULONG length;
    PKEY_VALUE_FULL_INFORMATION fullInfo;


    RtlInitUnicodeString(&keyName, KeyNameString);
    
    length = sizeof(KEY_VALUE_FULL_INFORMATION) + 
            KeyNameStringLength + *DataLength;
            
    fullInfo = ExAllocatePool(PagedPool, length); 
     
    if (fullInfo) { 
       
        status = ZwQueryValueKey(
                    Handle,
                   &keyName,
                    KeyValueFullInformation,
                    fullInfo,
                    length,
                   &length
                    );
                        
        if (NT_SUCCESS(status)){

            ASSERT(fullInfo->DataLength <= *DataLength); 

            RtlCopyMemory(
                Data,
                ((PUCHAR) fullInfo) + fullInfo->DataOffset,
                fullInfo->DataLength
                );

        }            

        *DataLength = fullInfo->DataLength;
        ExFreePool(fullInfo);

    }        
    
    return (status);

}



NTSTATUS
SetRegistryKeyValue(
   HANDLE hKey,
   PWCHAR pwszEntry, 
   LONG nValue
   )
{
    NTSTATUS status;
    UNICODE_STRING ustr;

    RtlInitUnicodeString(&ustr, pwszEntry);

    status =        
        ZwSetValueKey(
            hKey,
            &ustr,
            0,   /* optional */
            REG_DWORD,
            &nValue,
            sizeof(nValue)
            );         

   return status;
}

BOOL
DCamQueryPropertyFeaturesAndSettings(
    IN PIRB pIrb,
    PDCAM_EXTENSION pDevExt, 
    ULONG ulFieldOffset,
    DCamRegArea * pFeature,
    HANDLE hKeySettings,
    PWCHAR pwszPropertyName,
    ULONG ulPropertyNameLen,
    DCamRegArea * pPropertySettings,
    PWCHAR pwszPropertyNameDef,
    ULONG ulPropertyNameDefLen,
    LONG * plValueDef
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG ulLength;
    DCamRegArea RegDefault;


    // Reset settings.
    pFeature->AsULONG = 0;
    pPropertySettings->AsULONG = 0;

    // Read feature of this property
    Status = DCamReadRegister(pIrb, pDevExt, ulFieldOffset-QUERY_ADDR_OFFSET, &(pFeature->AsULONG));
    if(NT_SUCCESS(Status)) {
        pFeature->AsULONG = bswap(pFeature->AsULONG);
        if(pFeature->Feature.PresenceInq == 0) {
            ERROR_LOG(("\'%S not supported; Reset property settings\n", pwszPropertyName));
            return FALSE;
        }
    } else {
        ERROR_LOG(("\'ST:%x reading register\n", Status));
        return FALSE;
    }

    // Get persisted settings saved in the registry; (if it not defined, it is initialize to 0).
    ulLength = sizeof(LONG);
    Status = GetRegistryKeyValue(
        hKeySettings, 
        pwszPropertyName, 
        ulPropertyNameLen, 
        (PVOID) pPropertySettings,
        &ulLength
        );

    if(NT_SUCCESS(Status)) { 
        // Detect if AutoMode was mistakenly set by the registry.
        if(pPropertySettings->Brightness.AutoMode == 1 && pFeature->Feature.AutoMode == 0) {
            ERROR_LOG(("\'Detect %s AutoMode mistakenly set\n", pwszPropertyName));
            pPropertySettings->Brightness.AutoMode = 0;
        }
        // Detect out of range and set it to mid range.
        if(pPropertySettings->Brightness.Value < pFeature->Feature.MIN_Value || 
           pFeature->Feature.MAX_Value < pPropertySettings->Brightness.Value) {
            ERROR_LOG(("\'Detect %S out of range %d not within (%d,%d)\n", 
                pwszPropertyName,
                pPropertySettings->Brightness.Value,
                pFeature->Feature.MIN_Value, 
                pFeature->Feature.MAX_Value));
            pPropertySettings->Brightness.Value = (pFeature->Feature.MIN_Value + pFeature->Feature.MAX_Value)/2;
        }

        // Query default value        
        ulLength = sizeof(LONG);
        RegDefault.AsULONG = 0;
        *plValueDef = 0;
        Status = GetRegistryKeyValue(
            hKeySettings, 
            pwszPropertyNameDef,
            ulPropertyNameDefLen,
            (PVOID) &RegDefault,
            &ulLength
            );

        if(NT_SUCCESS(Status)) { 
            // Make sure that the default is within the range
            if(RegDefault.Brightness.Value < pFeature->Feature.MIN_Value || 
               pFeature->Feature.MAX_Value < RegDefault.Brightness.Value) {
                ERROR_LOG(("\'%S %d out of range (%d, %d), set to midrange.\n", 
                    pwszPropertyNameDef,
                    RegDefault.Brightness.Value, 
                    pFeature->Feature.MIN_Value, 
                    pFeature->Feature.MAX_Value));
                *plValueDef = (LONG) (pFeature->Feature.MIN_Value + pFeature->Feature.MAX_Value)/2;
            } else {
                *plValueDef = (LONG) RegDefault.Brightness.Value;
            }
        } else {
            ERROR_LOG(("\'Read Registry failed! ST:%x; %S; Offset:%d\n", Status, pwszPropertyNameDef, ulFieldOffset));
            *plValueDef = (LONG) (pFeature->Feature.MIN_Value + pFeature->Feature.MAX_Value)/2;
            // Set default so return success too.
            Status = STATUS_SUCCESS;
        }

    } else {
        // If registry key is not in the registry key, we will initialize it to 
        // always use the auto mode, and its value (and the default) in midrange.
        ERROR_LOG(("\'Read Registry failed! ST:%x; %S; Offset:%d\n", Status, pwszPropertyName, ulFieldOffset));
        pPropertySettings->Brightness.AutoMode = pFeature->Feature.AutoMode;
        pPropertySettings->Brightness.Value = (pFeature->Feature.MIN_Value + pFeature->Feature.MAX_Value)/2;
        *plValueDef = (LONG) (pFeature->Feature.MIN_Value + pFeature->Feature.MAX_Value)/2;
        // Set default so return success too.
        Status = STATUS_SUCCESS;
    }

#if DBG
    // Print out a summary of this property setting, include:
    // Features, current setting, and persisted values.
    DCamReadRegister(pIrb, pDevExt, ulFieldOffset, &(pDevExt->RegArea.AsULONG));
    pDevExt->RegArea.AsULONG = bswap(pDevExt->RegArea.AsULONG);

    DbgMsg1(("\'***** St:%x; %S (offset:%d)\n", Status, pwszPropertyName, ulFieldOffset));
    DbgMsg1(("\'Feature: %x; Pres:%d; OnePush:%d; ReadOut:%d; OnOff;%d; (A:%d; M:%d); (%d..%d)\n",
        pFeature->AsULONG,
        pFeature->Feature.PresenceInq,
        pFeature->Feature.OnePush,
        pFeature->Feature.ReadOut_Inq,
        pFeature->Feature.OnOff,
        pFeature->Feature.AutoMode,
        pFeature->Feature.ManualMode,
        pFeature->Feature.MIN_Value,
        pFeature->Feature.MAX_Value
        ));
    DbgMsg1(("\'Setting: %.8x; Pres:%d; OnePush:%d;            OnOff;%d; Auto:%d;     (%d;%d)\n",
        pDevExt->RegArea.AsULONG,
        pDevExt->RegArea.WhiteBalance.PresenceInq,
        pDevExt->RegArea.WhiteBalance.OnePush,
        pDevExt->RegArea.WhiteBalance.OnOff,
        pDevExt->RegArea.WhiteBalance.AutoMode,
        pDevExt->RegArea.WhiteBalance.UValue,
        pDevExt->RegArea.WhiteBalance.VValue
        ));
    DbgMsg1(("\'Registry:%.8x; Pres:%d; OnePush:%d;            OnOff;%d; Auto:%d;     (%d;%d)\n\n",
        pPropertySettings->AsULONG,
        pPropertySettings->WhiteBalance.PresenceInq,
        pPropertySettings->WhiteBalance.OnePush,
        pPropertySettings->WhiteBalance.OnOff,
        pPropertySettings->WhiteBalance.AutoMode,
        pPropertySettings->WhiteBalance.UValue,
        pPropertySettings->WhiteBalance.VValue
        ));
#endif

    return NT_SUCCESS(Status);
}



BOOL
DCamGetPropertyValuesFromRegistry(
    PDCAM_EXTENSION pDevExt
    )
{
    NTSTATUS Status;
    HANDLE hPDOKey, hKeySettings;
    PIRB pIrb;
    ULONG ulLength;

    DbgMsg2(("\'GetPropertyValuesFromRegistry: pDevExt=%x; pDevExt->BusDeviceObject=%x\n", pDevExt, pDevExt->BusDeviceObject));

    pIrb = ExAllocatePoolWithTag(NonPagedPool, sizeof(IRB), 'macd');
    if(!pIrb)
        return FALSE;
   

    //
    // Registry key: 
    //   Windows 2000:
    //   HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Class\
    //   {6BDD1FC6-810F-11D0-BEC7-08002BE2092F\000x
    //
    // Win98:
    //    HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Class\Image\000x
    // 
    Status = 
        IoOpenDeviceRegistryKey(
            pDevExt->PhysicalDeviceObject, 
            PLUGPLAY_REGKEY_DRIVER,
            STANDARD_RIGHTS_READ, 
            &hPDOKey);

    // Can fail only if PDO might be deleted due to device removal.        
    ASSERT(!pDevExt->bDevRemoved && Status == STATUS_SUCCESS);    

    //
    // loop through our table of strings,
    // reading the registry for each.
    //
    if(!NT_SUCCESS(Status)) {    
        ERROR_LOG(("\'GetPropertyValuesFromRegistry: IoOpenDeviceRegistryKey failed with Status=%x\n", Status));
        ExFreePool(pIrb); pIrb = NULL; 
        return FALSE;
    }

    //
    // Create or open the settings key
    //
    Status =         
        CreateRegistrySubKey(
            hPDOKey,
            KEY_ALL_ACCESS,
            wszSettings,
            &hKeySettings
            );

    if(!NT_SUCCESS(Status)) {    
        ERROR_LOG(("\'GetPropertyValuesFromRegistry: CreateRegistrySubKey failed with Status=%x\n", Status));       
        ZwClose(hPDOKey);
        return FALSE;
    }

    // Get persisted settings saved in the registry; (if it not defined, it is initialize to 0).
    
    //
    // Read from registry to find out what compression formats are supported 
    // by the decoder installed on this system.  This registry key can be altered
    // if IHV/ISV add additional decoder.  Currently, Microsft's MSYUV supports 
    // only UYVY format.
    //
    pDevExt->DecoderDCamVModeInq0.AsULONG = 0;
    ulLength = sizeof(LONG);
    Status = GetRegistryKeyValue(
        hKeySettings, 
        wszVModeInq0, 
        sizeof(wszVModeInq0), 
        (PVOID) &pDevExt->DecoderDCamVModeInq0,
        &ulLength
        );

    if(NT_SUCCESS(Status)) { 
        pDevExt->DecoderDCamVModeInq0.AsULONG = bswap(pDevExt->DecoderDCamVModeInq0.AsULONG);
        DbgMsg1(("\'Modes supported by the decoder: %x\n  [0]:%d\n  [1]:%d\n  [2]:%d\n  [3]:%d\n  [4]:%d\n  [5]:%d\n",
            pDevExt->DecoderDCamVModeInq0.AsULONG,
            pDevExt->DecoderDCamVModeInq0.VMode.Mode0,
            pDevExt->DecoderDCamVModeInq0.VMode.Mode1,
            pDevExt->DecoderDCamVModeInq0.VMode.Mode2,
            pDevExt->DecoderDCamVModeInq0.VMode.Mode3,
            pDevExt->DecoderDCamVModeInq0.VMode.Mode4,
            pDevExt->DecoderDCamVModeInq0.VMode.Mode5
            ));
    } else {
        ERROR_LOG(("\'Failed to read VModeInq0 registery: %x\n", Status));
    }
    
    // MSYUV supports these modes; always turn them on.
    pDevExt->DecoderDCamVModeInq0.VMode.Mode1 = 1;  // MSYUV.dll:(UYVY:320x480)
    pDevExt->DecoderDCamVModeInq0.VMode.Mode3 = 1;  // MSYUV.dll:(UYVY:640x480)
#ifdef SUPPORT_RGB24
    pDevExt->DecoderDCamVModeInq0.VMode.Mode4 = 1;  // MSYUV.dll:(RGB24:640x480)
#endif
    

#if DBG
    pDevExt->DevFeature1.AsULONG = 0;
    Status = DCamReadRegister(pIrb, pDevExt, FIELDOFFSET(CAMERA_REGISTER_MAP, FeaturePresent1), &pDevExt->DevFeature1.AsULONG);
    if(NT_SUCCESS(Status)) { 
        pDevExt->DevFeature1.AsULONG = bswap(pDevExt->DevFeature1.AsULONG);
        DbgMsg1(("\'Features1: %x:\n  Brightness:%d;\n  Exposure:%d\n  Sharpness:%d\n  WhiteBalance:%d\n  Hue:%d;\n  Saturation:%d;\n  Gamma:%d\n  Shutter:%d\n  Gain:%d\n  Iris:%d\n  Focus:%d\n",
            pDevExt->DevFeature1.AsULONG,
            pDevExt->DevFeature1.CameraCap1.Brightness,
            pDevExt->DevFeature1.CameraCap1.Exposure,
            pDevExt->DevFeature1.CameraCap1.Sharpness,
            pDevExt->DevFeature1.CameraCap1.White_Balance,
            pDevExt->DevFeature1.CameraCap1.Hue,
            pDevExt->DevFeature1.CameraCap1.Saturation,
            pDevExt->DevFeature1.CameraCap1.Gamma,
            pDevExt->DevFeature1.CameraCap1.Shutter,
            pDevExt->DevFeature1.CameraCap1.Gain,
            pDevExt->DevFeature1.CameraCap1.Iris,
            pDevExt->DevFeature1.CameraCap1.Focus
            ));
    } else {
        ERROR_LOG(("\'Failed to read Feature1 register: %x\n", Status));
    }

    pDevExt->DevFeature2.AsULONG = 0;
    Status = DCamReadRegister(pIrb, pDevExt, FIELDOFFSET(CAMERA_REGISTER_MAP, FeaturePresent2), &pDevExt->DevFeature1.AsULONG);
    if(NT_SUCCESS(Status)) { 
        pDevExt->DevFeature2.AsULONG = bswap(pDevExt->DevFeature2.AsULONG);
        DbgMsg1(("\'Features2: %x\n  Zoom:%d\n  Pan:%d\n  Tile:%d\n",
            pDevExt->DevFeature2.AsULONG,
            pDevExt->DevFeature2.CameraCap2.Zoom,
            pDevExt->DevFeature2.CameraCap2.Pan,
            pDevExt->DevFeature1.CameraCap2.Tile
            ));
    } else {
        ERROR_LOG(("\'Failed to read Feature2 register: %x\n", Status));
    }
#endif

    // Brightness
    if(DCamQueryPropertyFeaturesAndSettings(
        pIrb,
        pDevExt,
        FIELDOFFSET(CAMERA_REGISTER_MAP, Brightness),
        &pDevExt->DevProperty[ENUM_BRIGHTNESS].Feature,
        hKeySettings, 
        wszBrightness, 
        sizeof(wszBrightness), 
        &pDevExt->DevProperty[ENUM_BRIGHTNESS].StatusNControl,
        wszBrightnessDef, 
        sizeof(wszBrightnessDef), 
        &pDevExt->DevProperty[ENUM_BRIGHTNESS].DefaultValue
        )) {
        pDevExt->DevProperty[ENUM_BRIGHTNESS].RangeNStep.Bounds.SignedMinimum = pDevExt->DevProperty[ENUM_BRIGHTNESS].Feature.Feature.MIN_Value;
        pDevExt->DevProperty[ENUM_BRIGHTNESS].RangeNStep.Bounds.SignedMaximum = pDevExt->DevProperty[ENUM_BRIGHTNESS].Feature.Feature.MAX_Value;
        pDevExt->DevPropDefine[ENUM_BRIGHTNESS].Range.Members   = (VOID*) &pDevExt->DevProperty[ENUM_BRIGHTNESS].RangeNStep;
        pDevExt->DevPropDefine[ENUM_BRIGHTNESS].Default.Members = (VOID*) &pDevExt->DevProperty[ENUM_BRIGHTNESS].DefaultValue;
    } else {
        pDevExt->VideoProcAmpItems[ENUM_BRIGHTNESS].GetSupported = FALSE;
        pDevExt->VideoProcAmpItems[ENUM_BRIGHTNESS].SetSupported = FALSE;
    }
      // Saturation
    if(DCamQueryPropertyFeaturesAndSettings(
        pIrb,
        pDevExt,
        FIELDOFFSET(CAMERA_REGISTER_MAP, Saturation),
        &pDevExt->DevProperty[ENUM_SATURATION].Feature,
        hKeySettings, 
        wszSaturation, 
        sizeof(wszSaturation), 
        &pDevExt->DevProperty[ENUM_SATURATION].StatusNControl,
        wszSaturationDef, 
        sizeof(wszSaturationDef),
        &pDevExt->DevProperty[ENUM_SATURATION].DefaultValue
        )) {
        pDevExt->DevProperty[ENUM_SATURATION].RangeNStep.Bounds.SignedMinimum = pDevExt->DevProperty[ENUM_SATURATION].Feature.Feature.MIN_Value;
        pDevExt->DevProperty[ENUM_SATURATION].RangeNStep.Bounds.SignedMaximum = pDevExt->DevProperty[ENUM_SATURATION].Feature.Feature.MAX_Value;
        pDevExt->DevPropDefine[ENUM_SATURATION].Range.Members   = (VOID*) &pDevExt->DevProperty[ENUM_SATURATION].RangeNStep;
        pDevExt->DevPropDefine[ENUM_SATURATION].Default.Members = (VOID*) &pDevExt->DevProperty[ENUM_SATURATION].DefaultValue;
    } else {
        pDevExt->VideoProcAmpItems[ENUM_SATURATION].GetSupported = FALSE;
        pDevExt->VideoProcAmpItems[ENUM_SATURATION].SetSupported = FALSE;
    }
      // Hue
    if(DCamQueryPropertyFeaturesAndSettings(
        pIrb,
        pDevExt,
        FIELDOFFSET(CAMERA_REGISTER_MAP, Hue),
        &pDevExt->DevProperty[ENUM_HUE].Feature,
        hKeySettings, 
        wszHue, 
        sizeof(wszHue), 
        &pDevExt->DevProperty[ENUM_HUE].StatusNControl,
        wszHueDef, 
        sizeof(wszHueDef),
        &pDevExt->DevProperty[ENUM_HUE].DefaultValue
        )) {
        pDevExt->DevProperty[ENUM_HUE].RangeNStep.Bounds.SignedMinimum = pDevExt->DevProperty[ENUM_HUE].Feature.Feature.MIN_Value;
        pDevExt->DevProperty[ENUM_HUE].RangeNStep.Bounds.SignedMaximum = pDevExt->DevProperty[ENUM_HUE].Feature.Feature.MAX_Value;
        pDevExt->DevPropDefine[ENUM_HUE].Range.Members   = (VOID*) &pDevExt->DevProperty[ENUM_HUE].RangeNStep;
        pDevExt->DevPropDefine[ENUM_HUE].Default.Members = (VOID*) &pDevExt->DevProperty[ENUM_HUE].DefaultValue;
    } else {
        pDevExt->VideoProcAmpItems[ENUM_HUE].GetSupported = FALSE;
        pDevExt->VideoProcAmpItems[ENUM_HUE].SetSupported = FALSE;
    }
       // Sharpness
    if(DCamQueryPropertyFeaturesAndSettings(
        pIrb,
        pDevExt,
        FIELDOFFSET(CAMERA_REGISTER_MAP, Sharpness),
        &pDevExt->DevProperty[ENUM_SHARPNESS].Feature,
        hKeySettings, 
        wszSharpness, 
        sizeof(wszSharpness), 
        &pDevExt->DevProperty[ENUM_SHARPNESS].StatusNControl,
        wszSharpnessDef, 
        sizeof(wszSharpnessDef),
        &pDevExt->DevProperty[ENUM_SHARPNESS].DefaultValue
        )) {
        pDevExt->DevProperty[ENUM_SHARPNESS].RangeNStep.Bounds.SignedMinimum = pDevExt->DevProperty[ENUM_SHARPNESS].Feature.Feature.MIN_Value;
        pDevExt->DevProperty[ENUM_SHARPNESS].RangeNStep.Bounds.SignedMaximum = pDevExt->DevProperty[ENUM_SHARPNESS].Feature.Feature.MAX_Value;
        pDevExt->DevPropDefine[ENUM_SHARPNESS].Range.Members   = (VOID*) &pDevExt->DevProperty[ENUM_SHARPNESS].RangeNStep;
        pDevExt->DevPropDefine[ENUM_SHARPNESS].Default.Members = (VOID*) &pDevExt->DevProperty[ENUM_SHARPNESS].DefaultValue;
    } else {
        pDevExt->VideoProcAmpItems[ENUM_SHARPNESS].GetSupported = FALSE;
        pDevExt->VideoProcAmpItems[ENUM_SHARPNESS].SetSupported = FALSE;
    }
     // WhiteBalance
    if(DCamQueryPropertyFeaturesAndSettings(
        pIrb,
        pDevExt,
        FIELDOFFSET(CAMERA_REGISTER_MAP, WhiteBalance),
        &pDevExt->DevProperty[ENUM_WHITEBALANCE].Feature,
        hKeySettings, 
        wszWhiteBalance, 
        sizeof(wszWhiteBalance), 
        &pDevExt->DevProperty[ENUM_WHITEBALANCE].StatusNControl,
        wszWhiteBalanceDef, 
        sizeof(wszWhiteBalanceDef),
        &pDevExt->DevProperty[ENUM_WHITEBALANCE].DefaultValue
        )) {
        pDevExt->DevProperty[ENUM_WHITEBALANCE].RangeNStep.Bounds.SignedMinimum = pDevExt->DevProperty[ENUM_WHITEBALANCE].Feature.Feature.MIN_Value;
        pDevExt->DevProperty[ENUM_WHITEBALANCE].RangeNStep.Bounds.SignedMaximum = pDevExt->DevProperty[ENUM_WHITEBALANCE].Feature.Feature.MAX_Value;
        pDevExt->DevPropDefine[ENUM_WHITEBALANCE].Range.Members   = (VOID*) &pDevExt->DevProperty[ENUM_WHITEBALANCE].RangeNStep;
        pDevExt->DevPropDefine[ENUM_WHITEBALANCE].Default.Members = (VOID*) &pDevExt->DevProperty[ENUM_WHITEBALANCE].DefaultValue;
    } else {
        pDevExt->VideoProcAmpItems[ENUM_WHITEBALANCE].GetSupported = FALSE;
        pDevExt->VideoProcAmpItems[ENUM_WHITEBALANCE].SetSupported = FALSE;
    }
     // Zoom
    if(DCamQueryPropertyFeaturesAndSettings(
        pIrb,
        pDevExt,
        FIELDOFFSET(CAMERA_REGISTER_MAP, Zoom),
        &pDevExt->DevProperty[ENUM_ZOOM].Feature,
        hKeySettings, 
        wszZoom, 
        sizeof(wszZoom), 
        &pDevExt->DevProperty[ENUM_ZOOM].StatusNControl,
        wszZoomDef, 
        sizeof(wszZoomDef),
        &pDevExt->DevProperty[ENUM_ZOOM].DefaultValue
        )) {
        pDevExt->DevProperty[ENUM_ZOOM].RangeNStep.Bounds.SignedMinimum = pDevExt->DevProperty[ENUM_ZOOM].Feature.Feature.MIN_Value;
        pDevExt->DevProperty[ENUM_ZOOM].RangeNStep.Bounds.SignedMaximum = pDevExt->DevProperty[ENUM_ZOOM].Feature.Feature.MAX_Value;
        pDevExt->DevPropDefine[ENUM_ZOOM].Range.Members   = (VOID*) &pDevExt->DevProperty[ENUM_ZOOM].RangeNStep;
        pDevExt->DevPropDefine[ENUM_ZOOM].Default.Members = (VOID*) &pDevExt->DevProperty[ENUM_ZOOM].DefaultValue;
    } else {
        pDevExt->VideoProcAmpItems[ENUM_ZOOM].GetSupported = FALSE;
        pDevExt->VideoProcAmpItems[ENUM_ZOOM].SetSupported = FALSE;
    }
      // Focus
    if(DCamQueryPropertyFeaturesAndSettings(
        pIrb,
        pDevExt,
        FIELDOFFSET(CAMERA_REGISTER_MAP, Focus),
        &pDevExt->DevProperty[ENUM_FOCUS].Feature,
        hKeySettings, 
        wszFocus, 
        sizeof(wszFocus), 
        &pDevExt->DevProperty[ENUM_FOCUS].StatusNControl,
        wszFocusDef, 
        sizeof(wszFocusDef),
        &pDevExt->DevProperty[ENUM_FOCUS].DefaultValue
        )) {
        pDevExt->DevProperty[ENUM_FOCUS].RangeNStep.Bounds.SignedMinimum = pDevExt->DevProperty[ENUM_FOCUS].Feature.Feature.MIN_Value;
        pDevExt->DevProperty[ENUM_FOCUS].RangeNStep.Bounds.SignedMaximum = pDevExt->DevProperty[ENUM_FOCUS].Feature.Feature.MAX_Value;
        pDevExt->DevPropDefine[ENUM_FOCUS].Range.Members   = (VOID*) &pDevExt->DevProperty[ENUM_FOCUS].RangeNStep;
        pDevExt->DevPropDefine[ENUM_FOCUS].Default.Members = (VOID*) &pDevExt->DevProperty[ENUM_FOCUS].DefaultValue;
    } else {
        pDevExt->VideoProcAmpItems[ENUM_FOCUS].GetSupported = FALSE;
        pDevExt->VideoProcAmpItems[ENUM_FOCUS].SetSupported = FALSE;
    }


    ZwClose(hKeySettings);
    ZwClose(hPDOKey);

    ExFreePool(pIrb); pIrb = NULL; 

    return TRUE;

}


BOOL
DCamSetPropertyValuesToRegistry( 
    PDCAM_EXTENSION pDevExt
    )
{
    // Set the default to :
    //  HLM\Software\DeviceExtension->pchVendorName\1394DCam

    NTSTATUS Status;
    HANDLE hPDOKey, hKeySettings;

    DbgMsg2(("\'SetPropertyValuesToRegistry: pDevExt=%x; pDevExt->BusDeviceObject=%x\n", pDevExt, pDevExt->BusDeviceObject));


    //
    // Registry key: 
    //   HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Class\
    //   {6BDD1FC6-810F-11D0-BEC7-08002BE2092F\000x
    //
    Status = 
        IoOpenDeviceRegistryKey(
            pDevExt->PhysicalDeviceObject, 
            PLUGPLAY_REGKEY_DRIVER,
            STANDARD_RIGHTS_WRITE, 
            &hPDOKey);

    // PDO might be deleted when it was removed.    
    if(! pDevExt->bDevRemoved) {
        ASSERT(Status == STATUS_SUCCESS);
    }

    //
    // reading the feature and registry setting for each property
    //
    if(NT_SUCCESS(Status)) {

        // Create or open the settings key
        Status =         
            CreateRegistrySubKey(
                hPDOKey,
                KEY_ALL_ACCESS,
                wszSettings,
                &hKeySettings
                );

        if(NT_SUCCESS(Status)) {

            // Brightness
            Status = SetRegistryKeyValue(
                hKeySettings,
                wszBrightness,
                pDevExt->DevProperty[ENUM_BRIGHTNESS].StatusNControl.AsULONG);
            DbgMsg2(("\'SetPropertyValuesToRegistry: Status %x, Brightness %d\n", Status, pDevExt->DevProperty[ENUM_BRIGHTNESS].StatusNControl.AsULONG));

            // Hue
            Status = SetRegistryKeyValue(
                hKeySettings,
                wszHue,
                pDevExt->DevProperty[ENUM_HUE].StatusNControl.AsULONG);
            DbgMsg2(("\'SetPropertyValuesToRegistry: Status %x, Hue %d\n", Status, pDevExt->DevProperty[ENUM_HUE].StatusNControl.AsULONG));

            // Saturation
            Status = SetRegistryKeyValue(
                hKeySettings,
                wszSaturation,
                pDevExt->DevProperty[ENUM_SATURATION].StatusNControl.AsULONG);
            DbgMsg2(("\'SetPropertyValuesToRegistry: Status %x, Saturation %d\n", Status, pDevExt->DevProperty[ENUM_SATURATION].StatusNControl.AsULONG));

            // Sharpness
            Status = SetRegistryKeyValue(
                hKeySettings,
                wszSharpness,
                pDevExt->DevProperty[ENUM_SHARPNESS].StatusNControl.AsULONG);
            DbgMsg2(("\'SetPropertyValuesToRegistry: Status %x, Sharpness %d\n", Status, pDevExt->DevProperty[ENUM_SHARPNESS].StatusNControl.AsULONG));

            // WhiteBalance
            Status = SetRegistryKeyValue(
                hKeySettings,
                wszWhiteBalance,
                pDevExt->DevProperty[ENUM_WHITEBALANCE].StatusNControl.AsULONG);
            DbgMsg2(("\'SetPropertyValuesToRegistry: Status %x, WhiteBalance %d\n", Status, pDevExt->DevProperty[ENUM_WHITEBALANCE].StatusNControl.AsULONG));

            // Zoom
            Status = SetRegistryKeyValue(
                hKeySettings,
                wszZoom,
                pDevExt->DevProperty[ENUM_ZOOM].StatusNControl.AsULONG);
            DbgMsg2(("\'SetPropertyValuesToRegistry: Status %x, Zoom %d\n", Status, pDevExt->DevProperty[ENUM_ZOOM].StatusNControl.AsULONG));

            // Focus
            Status = SetRegistryKeyValue(
                hKeySettings,
                wszFocus,
                pDevExt->DevProperty[ENUM_FOCUS].StatusNControl.AsULONG);
            DbgMsg2(("\'SetPropertyValuesToRegistry: Status %x, Focus %d\n", Status, pDevExt->DevProperty[ENUM_FOCUS].StatusNControl.AsULONG));

            ZwClose(hKeySettings);
            ZwClose(hPDOKey);

            return TRUE;

        } else {

            ERROR_LOG(("\'SetPropertyValuesToRegistry: CreateRegistrySubKey failed with Status=%x\n", Status));

        }

        ZwClose(hPDOKey);

    } else {

        DbgMsg2(("\'SetPropertyValuesToRegistry: IoOpenDeviceRegistryKey failed with Status=%x\n", Status));

    }

    return FALSE;
}


VOID
SetCurrentDevicePropertyValues(
    PDCAM_EXTENSION pDevExt,
    PIRB pIrb
    )
{
    ULONG ulFlags;

    // Set to the last saved values or the defaults

    // VideoProcAmp
    ulFlags = pDevExt->DevProperty[ENUM_BRIGHTNESS].StatusNControl.Brightness.AutoMode ? KSPROPERTY_VIDEOPROCAMP_FLAGS_AUTO : KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL;
    DCamSetProperty(pIrb, pDevExt, FIELDOFFSET(CAMERA_REGISTER_MAP, Brightness),  ulFlags, pDevExt->DevProperty[ENUM_BRIGHTNESS].StatusNControl.Brightness.Value, &pDevExt->DevProperty[ENUM_BRIGHTNESS].Feature, &pDevExt->DevProperty[ENUM_BRIGHTNESS].StatusNControl);

    ulFlags = pDevExt->DevProperty[ENUM_HUE].StatusNControl.Brightness.AutoMode ? KSPROPERTY_VIDEOPROCAMP_FLAGS_AUTO : KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL;
    DCamSetProperty(pIrb, pDevExt, FIELDOFFSET(CAMERA_REGISTER_MAP, Hue),         ulFlags, pDevExt->DevProperty[ENUM_HUE].StatusNControl.Brightness.Value, &pDevExt->DevProperty[ENUM_HUE].Feature, &pDevExt->DevProperty[ENUM_HUE].StatusNControl);

    ulFlags = pDevExt->DevProperty[ENUM_SATURATION].StatusNControl.Brightness.AutoMode ? KSPROPERTY_VIDEOPROCAMP_FLAGS_AUTO : KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL;
    DCamSetProperty(pIrb, pDevExt, FIELDOFFSET(CAMERA_REGISTER_MAP, Saturation),  ulFlags, pDevExt->DevProperty[ENUM_SATURATION].StatusNControl.Brightness.Value, &pDevExt->DevProperty[ENUM_SATURATION].Feature, &pDevExt->DevProperty[ENUM_SATURATION].StatusNControl);  

    ulFlags = pDevExt->DevProperty[ENUM_SHARPNESS].StatusNControl.Brightness.AutoMode ? KSPROPERTY_VIDEOPROCAMP_FLAGS_AUTO : KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL;
    DCamSetProperty(pIrb, pDevExt, FIELDOFFSET(CAMERA_REGISTER_MAP, Sharpness),   ulFlags, pDevExt->DevProperty[ENUM_SHARPNESS].StatusNControl.Brightness.Value, &pDevExt->DevProperty[ENUM_SHARPNESS].Feature, &pDevExt->DevProperty[ENUM_SHARPNESS].StatusNControl);

    ulFlags = pDevExt->DevProperty[ENUM_WHITEBALANCE].StatusNControl.Brightness.AutoMode ? KSPROPERTY_VIDEOPROCAMP_FLAGS_AUTO : KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL;
    DCamSetProperty(pIrb, pDevExt, FIELDOFFSET(CAMERA_REGISTER_MAP, WhiteBalance),ulFlags, pDevExt->DevProperty[ENUM_WHITEBALANCE].StatusNControl.WhiteBalance.UValue, &pDevExt->DevProperty[ENUM_WHITEBALANCE].Feature, &pDevExt->DevProperty[ENUM_WHITEBALANCE].StatusNControl);

    // CameraControl
    ulFlags = pDevExt->DevProperty[ENUM_ZOOM].StatusNControl.Brightness.AutoMode ? KSPROPERTY_CAMERACONTROL_FLAGS_AUTO : KSPROPERTY_CAMERACONTROL_FLAGS_MANUAL;
    DCamSetProperty(pIrb, pDevExt, FIELDOFFSET(CAMERA_REGISTER_MAP, Zoom),        ulFlags, pDevExt->DevProperty[ENUM_ZOOM].StatusNControl.Brightness.Value, &pDevExt->DevProperty[ENUM_ZOOM].Feature, &pDevExt->DevProperty[ENUM_ZOOM].StatusNControl);

    ulFlags = pDevExt->DevProperty[ENUM_FOCUS].StatusNControl.Brightness.AutoMode ? KSPROPERTY_CAMERACONTROL_FLAGS_AUTO : KSPROPERTY_CAMERACONTROL_FLAGS_MANUAL;
    DCamSetProperty(pIrb, pDevExt, FIELDOFFSET(CAMERA_REGISTER_MAP, Focus),       ulFlags, pDevExt->DevProperty[ENUM_FOCUS].StatusNControl.Brightness.Value, &pDevExt->DevProperty[ENUM_FOCUS].Feature, &pDevExt->DevProperty[ENUM_FOCUS].StatusNControl); 
}


BOOL 
DCamPrepareDevProperties(
    PDCAM_EXTENSION pDevExt
    )
/*
    Contruct the property table and initialize them to the default value.
*/
{
    // Initialize property settings (part of the Device Extension)

    // Property Sets: VideoProcAmp and CameraControl sets
    pDevExt->ulPropSetSupported = NUMBER_OF_ADAPTER_PROPERTY_SETS;

    RtlCopyMemory(&pDevExt->VideoProcAmpSet, AdapterPropertyTable, sizeof(KSPROPERTY_SET) * NUMBER_OF_ADAPTER_PROPERTY_SETS);
    pDevExt->VideoProcAmpSet.PropertyItem  = &pDevExt->VideoProcAmpItems[0];
    pDevExt->CameraControlSet.PropertyItem = &pDevExt->CameraControlItems[0];

    // Property Items, VideoProcAmp and CameraControl Items
    RtlCopyMemory(&pDevExt->VideoProcAmpItems,  VideoProcAmpProperties,  sizeof(KSPROPERTY_ITEM) * NUM_VIDEOPROCAMP_ITEMS);
    RtlCopyMemory(&pDevExt->CameraControlItems, CameraControlProperties, sizeof(KSPROPERTY_ITEM) * NUM_CAMERACONTROL_ITEMS);

    // Property values and it member lists (range and default)
    pDevExt->VideoProcAmpItems[ENUM_BRIGHTNESS].Values = &pDevExt->DevPropDefine[ENUM_BRIGHTNESS].Value;
    pDevExt->VideoProcAmpItems[ENUM_SHARPNESS].Values  = &pDevExt->DevPropDefine[ENUM_SHARPNESS].Value;
    pDevExt->VideoProcAmpItems[ENUM_HUE].Values        = &pDevExt->DevPropDefine[ENUM_HUE].Value;
    pDevExt->VideoProcAmpItems[ENUM_SATURATION].Values = &pDevExt->DevPropDefine[ENUM_SATURATION].Value;
    pDevExt->VideoProcAmpItems[ENUM_WHITEBALANCE].Values = &pDevExt->DevPropDefine[ENUM_WHITEBALANCE].Value;
    // 
    pDevExt->VideoProcAmpItems[ENUM_FOCUS].Values      = &pDevExt->DevPropDefine[ENUM_FOCUS].Value;
    pDevExt->VideoProcAmpItems[ENUM_ZOOM].Values       = &pDevExt->DevPropDefine[ENUM_ZOOM].Value;

    pDevExt->DevPropDefine[ENUM_BRIGHTNESS].Value    = BrightnessValues;
    pDevExt->DevPropDefine[ENUM_BRIGHTNESS].Value.MembersList = &pDevExt->DevPropDefine[ENUM_BRIGHTNESS].Range;
    pDevExt->DevPropDefine[ENUM_BRIGHTNESS].Range    = BrightnessMembersList[0];
    pDevExt->DevPropDefine[ENUM_BRIGHTNESS].Default  = BrightnessMembersList[1];
    pDevExt->DevProperty[ENUM_BRIGHTNESS].RangeNStep = BrightnessRangeAndStep[0];


    pDevExt->DevPropDefine[ENUM_SHARPNESS].Value    = SharpnessValues;
    pDevExt->DevPropDefine[ENUM_SHARPNESS].Value.MembersList = &pDevExt->DevPropDefine[ENUM_SHARPNESS].Range;
    pDevExt->DevPropDefine[ENUM_SHARPNESS].Range    = SharpnessMembersList[0];
    pDevExt->DevPropDefine[ENUM_SHARPNESS].Default  = SharpnessMembersList[1];
    pDevExt->DevProperty[ENUM_SHARPNESS].RangeNStep = SharpnessRangeAndStep[0];


    pDevExt->DevPropDefine[ENUM_HUE].Value    = HueValues;
    pDevExt->DevPropDefine[ENUM_HUE].Value.MembersList = &pDevExt->DevPropDefine[ENUM_HUE].Range;
    pDevExt->DevPropDefine[ENUM_HUE].Range    = HueMembersList[0];
    pDevExt->DevPropDefine[ENUM_HUE].Default  = HueMembersList[1];
    pDevExt->DevProperty[ENUM_HUE].RangeNStep = HueRangeAndStep[0];


    pDevExt->DevPropDefine[ENUM_SATURATION].Value    = SaturationValues;
    pDevExt->DevPropDefine[ENUM_SATURATION].Value.MembersList = &pDevExt->DevPropDefine[ENUM_SATURATION].Range;
    pDevExt->DevPropDefine[ENUM_SATURATION].Range    = SaturationMembersList[0];
    pDevExt->DevPropDefine[ENUM_SATURATION].Default  = SaturationMembersList[1];
    pDevExt->DevProperty[ENUM_SATURATION].RangeNStep = SaturationRangeAndStep[0];


    pDevExt->DevPropDefine[ENUM_WHITEBALANCE].Value    = WhiteBalanceValues;
    pDevExt->DevPropDefine[ENUM_WHITEBALANCE].Value.MembersList = &pDevExt->DevPropDefine[ENUM_WHITEBALANCE].Range;
    pDevExt->DevPropDefine[ENUM_WHITEBALANCE].Range    = WhiteBalanceMembersList[0];
    pDevExt->DevPropDefine[ENUM_WHITEBALANCE].Default  = WhiteBalanceMembersList[1];
    pDevExt->DevProperty[ENUM_WHITEBALANCE].RangeNStep = WhiteBalanceRangeAndStep[0];


    pDevExt->DevPropDefine[ENUM_FOCUS].Value    = FocusValues;
    pDevExt->DevPropDefine[ENUM_FOCUS].Value.MembersList = &pDevExt->DevPropDefine[ENUM_FOCUS].Range;
    pDevExt->DevPropDefine[ENUM_FOCUS].Range    = FocusMembersList[0];
    pDevExt->DevPropDefine[ENUM_FOCUS].Default  = FocusMembersList[1];
    pDevExt->DevProperty[ENUM_FOCUS].RangeNStep = FocusRangeAndStep[0];


    pDevExt->DevPropDefine[ENUM_ZOOM].Value    = ZoomValues;
    pDevExt->DevPropDefine[ENUM_ZOOM].Value.MembersList = &pDevExt->DevPropDefine[ENUM_ZOOM].Range;
    pDevExt->DevPropDefine[ENUM_ZOOM].Range    = ZoomMembersList[0];
    pDevExt->DevPropDefine[ENUM_ZOOM].Default  = ZoomMembersList[1];
    pDevExt->DevProperty[ENUM_ZOOM].RangeNStep = ZoomRangeAndStep[0];


    return STATUS_SUCCESS;
}



BOOL
DCamGetVideoMode(
    PDCAM_EXTENSION pDevExt,
    PIRB pIrb
    )
/*
    Query Video format and mode supported by the camera.
*/
{
    NTSTATUS Status;

    // First check if V_MODE_INQ (Format_0) is supported.
    pDevExt->DCamVFormatInq.AsULONG = 0;
    Status = DCamReadRegister(pIrb, pDevExt, FIELDOFFSET(CAMERA_REGISTER_MAP, VFormat), &(pDevExt->DCamVFormatInq.AsULONG));
    if(NT_SUCCESS(Status)) {
        pDevExt->DCamVFormatInq.AsULONG = bswap(pDevExt->DCamVFormatInq.AsULONG);
        if(pDevExt->DCamVFormatInq.VFormat.Format0 == 1) {
            DbgMsg1(("\'V_FORMAT_INQ %x; Format:[0]:%d; [1]:%d; [2]:%d; [6]:%d; [7]:%d\n",           
                pDevExt->DCamVFormatInq.AsULONG, 
                pDevExt->DCamVFormatInq.VFormat.Format0,   
                pDevExt->DCamVFormatInq.VFormat.Format1,
                pDevExt->DCamVFormatInq.VFormat.Format2,
                pDevExt->DCamVFormatInq.VFormat.Format6,          
                pDevExt->DCamVFormatInq.VFormat.Format7            
                ));
            pDevExt->DCamVModeInq0.AsULONG = 0;
            Status = DCamReadRegister(pIrb, pDevExt, FIELDOFFSET(CAMERA_REGISTER_MAP, VModeInq[0]), &(pDevExt->DCamVModeInq0.AsULONG));
            if(NT_SUCCESS(Status)) {
                pDevExt->DCamVModeInq0.AsULONG = bswap(pDevExt->DCamVModeInq0.AsULONG);
                DbgMsg1(("\'V_MODE_INQ[0] %x; Mode[]:\n  [0](160x120 YUV444):%d\n  [1](320x240 YUV422):%d\n  [2](640x480 YUV411):%d\n  [3](640x480 YUV422):%d\n  [4](640x480 RGB24):%d\n  [5](640x480 YMono):%d\n",           
                    pDevExt->DCamVModeInq0.AsULONG, 
                    pDevExt->DCamVModeInq0.VMode.Mode0,   
                    pDevExt->DCamVModeInq0.VMode.Mode1,
                    pDevExt->DCamVModeInq0.VMode.Mode2,
                    pDevExt->DCamVModeInq0.VMode.Mode3,
                    pDevExt->DCamVModeInq0.VMode.Mode4,
                    pDevExt->DCamVModeInq0.VMode.Mode5           
                    ));

            } else {
                ERROR_LOG(("\'Read V_MODE_INQ_0 failed:%x!\n", Status))
            }

        } else {
             ERROR_LOG(("\'V_MODE_INQ Format_0 not supported!\n"))
        }
    } else {
        ERROR_LOG(("\'Read V_MODE_INQ failed:%x!\n", Status));
    }

    return NT_SUCCESS(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\1394dcam\callback.c ===
//===========================================================================
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
// PURPOSE.
//
// Copyright (c) 1996 - 2000  Microsoft Corporation.  All Rights Reserved.
//
//===========================================================================
/*++

Module Name:

    dcampkt.c

Abstract:

    This file contains code to handle callback from the bus/class driver.
    They might be running in DISPATCH level.

Author:   

    Yee J. Wu 15-Oct-97

Environment:

    Kernel mode only

Revision History:


--*/


#include "strmini.h"
#include "ksmedia.h"
#include "1394.h"
#include "wdm.h"       // for DbgBreakPoint() defined in dbg.h
#include "dbg.h"
#include "dcamdef.h"
#include "dcampkt.h"
#include "sonydcam.h"
#include "capprop.h"


NTSTATUS
DCamToInitializeStateCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrp,
    IN PDCAM_IO_CONTEXT pDCamIoContext
    )

/*++

Routine Description:

    Completion routine called after the device is initialize to a known state.

Arguments:

    DriverObject - Pointer to driver object created by system.

    pIrp - Irp that just completed

    pDCamIoContext - A structure that contain the context of this IO completion routine.

Return Value:

    None.

--*/

{
    PDCAM_EXTENSION pDevExt;
    PSTREAMEX pStrmEx;
    PIRB pIrb;

    if(!pDCamIoContext) {
        return STATUS_MORE_PROCESSING_REQUIRED;
    }


    pIrb = pDCamIoContext->pIrb;
    pDevExt = pDCamIoContext->pDevExt;
    
    DbgMsg2(("\'DCamToInitializeStateCompletionRoutine: completed DeviceState=%d; pIrp->IoStatus.Status=%x\n", 
        pDCamIoContext->DeviceState, pIrp->IoStatus.Status));

    // Free MDL
    if(pIrb->FunctionNumber == REQUEST_ASYNC_WRITE) {
        DbgMsg3(("DCamToInitializeStateCompletionRoutine: IoFreeMdl\n"));
        IoFreeMdl(pIrb->u.AsyncWrite.Mdl);
    }


    // CAUTION:
    //     Do we need to retry if the return is STATUS_TIMEOUT or invalid generation number ?
    //


    if(pIrp->IoStatus.Status != STATUS_SUCCESS) {
        ERROR_LOG(("DCamToInitializeStateCompletionRoutine: Status=%x != STATUS_SUCCESS; cannot restart its state.\n", pIrp->IoStatus.Status));

        if(pDCamIoContext->pSrb) {
            pDCamIoContext->pSrb->Status = STATUS_UNSUCCESSFUL;
            StreamClassStreamNotification(StreamRequestComplete, pDCamIoContext->pSrb->StreamObject, pDCamIoContext->pSrb);
        }
        DCamFreeIrbIrpAndContext(pDCamIoContext, pDCamIoContext->pIrb, pIrp);

        return STATUS_MORE_PROCESSING_REQUIRED;      
    }

    //
    // Done here if we are in STOP or PAUSE state;
    // else setting to RUN state.
    //
    pStrmEx = (PSTREAMEX) pDevExt->pStrmEx;

    //
    // No stream is open, job is done.
    //
    if(!pStrmEx) {
        if(pDCamIoContext->pSrb) {
            pDCamIoContext->pSrb->Status = STATUS_SUCCESS;
            StreamClassStreamNotification(StreamRequestComplete, pDCamIoContext->pSrb->StreamObject, pDCamIoContext->pSrb);
        }
        return STATUS_MORE_PROCESSING_REQUIRED;      
    }

    switch(pStrmEx->KSStateFinal) {
    case KSSTATE_STOP:
    case KSSTATE_PAUSE:
        pStrmEx->KSState = pStrmEx->KSStateFinal;
        if(pDCamIoContext->pSrb) {
            pDCamIoContext->pSrb->Status = STATUS_SUCCESS;
            StreamClassStreamNotification(StreamRequestComplete, pDCamIoContext->pSrb->StreamObject, pDCamIoContext->pSrb);
        }
        DCamFreeIrbIrpAndContext(pDCamIoContext, pDCamIoContext->pIrb, pIrp);
        break;

    case KSSTATE_RUN:
        if(pDCamIoContext->pSrb) {
            pDCamIoContext->pSrb->Status = STATUS_SUCCESS;
            StreamClassStreamNotification(StreamRequestComplete, pDCamIoContext->pSrb->StreamObject, pDCamIoContext->pSrb);
        }

        // Restart the stream.
        DCamSetKSStateRUN(pDevExt, pDCamIoContext->pSrb);

        // Need pDCamIoContext->pSrb; so free it after DCamSetKSStateRUN().
        DCamFreeIrbIrpAndContext(pDCamIoContext, pDCamIoContext->pIrb, pIrp);
        break;
    }

    return STATUS_MORE_PROCESSING_REQUIRED;      
}

NTSTATUS
DCamSetKSStateInitialize(
    PDCAM_EXTENSION pDevExt
    )
/*++

Routine Description:

    Set KSSTATE to KSSTATE_RUN.

Arguments:

    pDevExt - 

Return Value:

    Nothing

--*/
{

    PSTREAMEX pStrmEx;
    PIRB pIrb;
    PIRP pIrp;
    PDCAM_IO_CONTEXT pDCamIoContext;
    PIO_STACK_LOCATION NextIrpStack;
    NTSTATUS Status;


    ASSERT(pDevExt);
    pStrmEx = (PSTREAMEX) pDevExt->pStrmEx;                  
    

    if(!DCamAllocateIrbIrpAndContext(&pDCamIoContext, &pIrb, &pIrp, pDevExt->BusDeviceObject->StackSize)) {
        return STATUS_INSUFFICIENT_RESOURCES;
    } 



    //
    // Initialize the device to a known state 
    // may need to do this due to power down??
    //

    pDCamIoContext->DeviceState = DCAM_SET_INITIALIZE;  // Keep track of device state that we just set.
    pDCamIoContext->pDevExt     = pDevExt;
    pDCamIoContext->RegisterWorkArea.AsULONG = 0;
    pDCamIoContext->RegisterWorkArea.Initialize.Initialize = TRUE;
    pDCamIoContext->RegisterWorkArea.AsULONG = bswap(pDevExt->RegisterWorkArea.AsULONG);
    pIrb->FunctionNumber = REQUEST_ASYNC_WRITE;
    pIrb->Flags = 0;
    pIrb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_High = INITIAL_REGISTER_SPACE_HI;
    pIrb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_Low =  
              pDevExt->BaseRegister + FIELDOFFSET(CAMERA_REGISTER_MAP, Initialize);
    pIrb->u.AsyncWrite.nNumberOfBytesToWrite = sizeof(ULONG);
    pIrb->u.AsyncWrite.nBlockSize = 0;
    pIrb->u.AsyncWrite.fulFlags = 0;
    InterlockedExchange(&pIrb->u.AsyncWrite.ulGeneration, pDevExt->CurrentGeneration);        
    pIrb->u.AsyncWrite.Mdl = 
        IoAllocateMdl(&pDCamIoContext->RegisterWorkArea, sizeof(ULONG), FALSE, FALSE, NULL);
    MmBuildMdlForNonPagedPool(pIrb->u.AsyncWrite.Mdl);

    NextIrpStack = IoGetNextIrpStackLocation(pIrp);
    NextIrpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    NextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_1394_CLASS;
    NextIrpStack->Parameters.Others.Argument1 = pIrb;
          
    IoSetCompletionRoutine(
        pIrp,
        DCamToInitializeStateCompletionRoutine,
        pDCamIoContext,
        TRUE,
        TRUE,
        TRUE
        );

    Status = 
        IoCallDriver(
            pDevExt->BusDeviceObject,
            pIrp
            );

    return STATUS_SUCCESS;
}

VOID
DCamBusResetNotification(
    IN PVOID Context
    )
/*++

Routine Description:

    We receive this callback notification after a bus reset and if the device is still attached.
    This can happen when a new device is plugged in or an existing one is removed, or due to 
    awaken from sleep state. We will restore the device to its original streaming state by
    (1) Initialize the device to a known state and then 
    (2) launch a state machine to restart streaming.
    We will stop the state machine if previous state has failed.  This can happen if the generation 
    count is changed before the state mahcine is completed.
    
    The freeing and realocation of isoch bandwidth and channel are done in the bus reset irp.
    It is passed down by stream class in SRB_UNKNOWN_DEVICE_COMMAND. This IRP is guarantee to 
    call after this bus reset notification has returned and while the state machine is going on.   

    This is a callback at IRQL_DPC level; there are many 1394 APIs cannot be called at this level
    if it does blocking using KeWaitFor*Object().  Consult 1394 docuement for the list.

    
Arguments:

    Context - Pointer to the context of this registered notification.

Return Value:

    Nothing

--*/
{

    PDCAM_EXTENSION pDevExt = (PDCAM_EXTENSION) Context;
    PSTREAMEX pStrmEx;
    NTSTATUS Status;
    PIRP pIrp;
    PIRB pIrb;

    
    if(!pDevExt) {
        ERROR_LOG(("DCamBusResetNotification:pDevExt is 0.\n\n"));  
        ASSERT(pDevExt);        
        return;
    }

    //
    // Check a field in the context that must be valid to make sure that it is Ok to continue. 
    //
    if(!pDevExt->BusDeviceObject) {
        ERROR_LOG(("DCamBusResetNotification:pDevExtBusDeviceObject is 0.\n\n"));  
        ASSERT(pDevExt->BusDeviceObject);        
        return;
    }  
    DbgMsg2(("DCamBusResetNotification: pDevExt %x, pDevExt->pStrmEx %x, pDevExt->BusDeviceObject %x\n", 
        pDevExt, pDevExt->pStrmEx, pDevExt->BusDeviceObject));

    //
    //
    // Get the current generation count first
    //
    // CAUTION: 
    //     not all 1394 APIs can be called in DCamSubmitIrpSynch() if in DISPATCH_LEVEL;
    //     Getting generation count require no blocking so it is OK.
    if(!DCamAllocateIrbAndIrp(&pIrb, &pIrp, pDevExt->BusDeviceObject->StackSize)) {
        ERROR_LOG(("DCamBusResetNotification: DcamAllocateIrbAndIrp has failed!!\n\n\n"));
        ASSERT(FALSE);            
        return;   
    } 

    pIrb->FunctionNumber = REQUEST_GET_GENERATION_COUNT;
    pIrb->Flags = 0;
    Status = DCamSubmitIrpSynch(pDevExt, pIrp, pIrb);
    if(Status) {
        ERROR_LOG(("\'DCamBusResetNotification: Status=%x while trying to get generation number\n", Status));
        // Done with them; free resources.
        DCamFreeIrbIrpAndContext(0, pIrb, pIrp);
        return;
    }
    ERROR_LOG(("DCamBusResetNotification: Generation number from %d to %d\n", 
        pDevExt->CurrentGeneration, pIrb->u.GetGenerationCount.GenerationCount));

    InterlockedExchange(&pDevExt->CurrentGeneration, pIrb->u.GetGenerationCount.GenerationCount);


    // Done with them; free resources.
    DCamFreeIrbIrpAndContext(0, pIrb, pIrp);

    pStrmEx = (PSTREAMEX) pDevExt->pStrmEx;
    DbgMsg2(("\'%d:%s) DCamBusResetNotification: !!! pDevExt, %x; pStrmEx, %x !!!\n", 
          pDevExt->idxDev, pDevExt->pchVendorName, pDevExt, pStrmEx));

    //
    // If the stream was open (pStrmEx != NULL && pStrmEx->pVideoInfoHeader != NULL),
    // then we need to restore its streaming state.
    //
    if (pStrmEx &&
        pStrmEx->pVideoInfoHeader != NULL) {
        DbgMsg2(("\'%d:%s) DCamBusResetNotification: Stream was open; Try allocate them again.\n", pDevExt->idxDev, pDevExt->pchVendorName));
    } else {
        DbgMsg2(("DCamBusResetNotification:Stream has not open on this device.  Done!\n"));
        return;
    }


    //
    // Save the original state as the final state.
    //
    if(pStrmEx)
        pStrmEx->KSStateFinal = pStrmEx->KSState;     

    //
    // Initialize the device, and restore to its original streaming state.
    // 
    //
    // CAUTION: 
    //    maybe need to do this only if we are recovered from power loss state.
    //    We can move this to power management function in the future.
    //    In the completion routine, it will invoke other function to restore its streaming state.
    //

    DCamSetKSStateInitialize(pDevExt);
    
    DbgMsg2(("\'DCamBusResetNotification: Leaving...; Task complete in the CompletionRoutine.\n"));

    return;
}


NTSTATUS
DCamDetachBufferCR(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrp,
    IN PIRB pIrb
    )
/*++

Routine Description:

    Detaching a buffer has completed.  Attach next buffer.
    Returns more processing required so the IO Manager will leave us alone

Arguments:

    DriverObject - Pointer to driver object created by system.

    pIrp - Irp that just completed

    pIrb - Context set in DCamIsochCallback()

Return Value:

    None.

--*/

{
    IN PISOCH_DESCRIPTOR IsochDescriptor;
    PDCAM_EXTENSION pDevExt;
    PISOCH_DESCRIPTOR_RESERVED IsochDescriptorReserved;
    KIRQL oldIrql;


    if(!pIrb) {
        ERROR_LOG(("\'DCamDetachBufferCR: pIrb is NULL\n"));
        ASSERT(pIrb);
        IoFreeIrp(pIrp);
        return (STATUS_MORE_PROCESSING_REQUIRED);
    }

    // Get IsochDescriptor from the context (pIrb)
    IsochDescriptor = pIrb->u.IsochDetachBuffers.pIsochDescriptor;
    if(!IsochDescriptor) {
        ERROR_LOG(("\'DCamDetachBufferCR: IsochDescriptor is NULL\n"));
        ASSERT(IsochDescriptor);
        IoFreeIrp(pIrp);
        return (STATUS_MORE_PROCESSING_REQUIRED);
    }

    if(pIrp->IoStatus.Status != STATUS_SUCCESS) {
        ERROR_LOG(("\'DCamDetachBufferCR: pIrp->IoStatus.Status(%x) != STATUS_SUCCESS\n", pIrp->IoStatus.Status));
        ASSERT(pIrp->IoStatus.Status == STATUS_SUCCESS);
        IoFreeIrp(pIrp);
        return STATUS_MORE_PROCESSING_REQUIRED;
    }


    // IsochDescriptorReserved->Srb->Irp->IoStatus = pIrp->IoStatus.Status;
    IoFreeIrp(pIrp);

    // Freed and should not be referenced again!
    IsochDescriptor->DeviceReserved[5] = 0;

    IsochDescriptorReserved = (PISOCH_DESCRIPTOR_RESERVED) &IsochDescriptor->DeviceReserved[0];
    pDevExt = (PDCAM_EXTENSION) IsochDescriptor->Context1;
    DbgMsg3(("\'DCamDetachBufferCR: IsochDescriptorReserved=%x; DevExt=%x\n", IsochDescriptorReserved, pDevExt));   

    ASSERT(IsochDescriptorReserved);
    ASSERT(pDevExt);
     
    if(pDevExt &&
       IsochDescriptorReserved) {
        //
        // Indicate that the Srb should be complete
        //

        IsochDescriptorReserved->Flags |= STATE_SRB_IS_COMPLETE;
        IsochDescriptorReserved->Srb->Status = STATUS_SUCCESS;
        IsochDescriptorReserved->Srb->CommandData.DataBufferArray->DataUsed = IsochDescriptor->ulLength;
        IsochDescriptorReserved->Srb->ActualBytesTransferred = IsochDescriptor->ulLength;

        DbgMsg3(("\'DCamDetachBufferCR: Completing Srb %x\n", IsochDescriptorReserved->Srb));

        KeAcquireSpinLock(&pDevExt->IsochDescriptorLock, &oldIrql);
        RemoveEntryList(&IsochDescriptorReserved->DescriptorList);  InterlockedDecrement(&pDevExt->PendingReadCount);
        KeReleaseSpinLock(&pDevExt->IsochDescriptorLock, oldIrql);

        ASSERT(IsochDescriptorReserved->Srb->StreamObject);
        ASSERT(IsochDescriptorReserved->Srb->Flags & SRB_HW_FLAGS_STREAM_REQUEST);
        StreamClassStreamNotification(
               StreamRequestComplete, 
               IsochDescriptorReserved->Srb->StreamObject, 
               IsochDescriptorReserved->Srb);

        // Free it here instead of in DCamCompletionRoutine.
        ExFreePool(IsochDescriptor);     


        KeAcquireSpinLock(&pDevExt->IsochWaitingLock, &oldIrql);
        if (!IsListEmpty(&pDevExt->IsochWaitingList) && pDevExt->PendingReadCount >= MAX_BUFFERS_SUPPLIED) {

            //
            // We had someone blocked waiting for us to complete.  Pull
            // them off the waiting list and get them running
            //

            DbgMsg3(("DCamDetachBufferCR: Dequeueing request - Read Count = %x\n", pDevExt->PendingReadCount));
            IsochDescriptorReserved = \
                   (PISOCH_DESCRIPTOR_RESERVED) RemoveHeadList(
                   &pDevExt->IsochWaitingList
                   );

            KeReleaseSpinLock(&pDevExt->IsochWaitingLock, oldIrql);

            IsochDescriptor = \
                   (PISOCH_DESCRIPTOR) (((PUCHAR) IsochDescriptorReserved) - 
                   FIELDOFFSET(ISOCH_DESCRIPTOR, DeviceReserved[0]));

            DCamReadStreamWorker(IsochDescriptorReserved->Srb, IsochDescriptor);

        } else {
            KeReleaseSpinLock(&pDevExt->IsochWaitingLock, oldIrql);
        }
    }    

    return (STATUS_MORE_PROCESSING_REQUIRED);
}



VOID
DCamIsochCallback(
    IN PDCAM_EXTENSION pDevExt,
    IN PISOCH_DESCRIPTOR IsochDescriptor
    )

/*++

Routine Description:

    Called when an Isoch Descriptor completes

Arguments:

    pDevExt - Pointer to our DeviceExtension

    IsochDescriptor - IsochDescriptor that completed

Return Value:

    Nothing

--*/

{
    PIRB pIrb;
    PIRP pIrp;
    PSTREAMEX pStrmEx;
    PIO_STACK_LOCATION NextIrpStack;
    PISOCH_DESCRIPTOR_RESERVED IsochDescriptorReserved;
    PKSSTREAM_HEADER pDataPacket;
    PKS_FRAME_INFO pFrameInfo;
    KIRQL oldIrql;




    //
    // Debug check to make sure we're dealing with a real IsochDescriptor
    //

    ASSERT ( IsochDescriptor );
    IsochDescriptorReserved = (PISOCH_DESCRIPTOR_RESERVED) &IsochDescriptor->DeviceReserved[0];


    //
    // All Pending read will be either resubmitted, or cancelled (if out of resource).
    //

    if(pDevExt->bStopIsochCallback) {
        ERROR_LOG(("DCamIsochCallback: bStopCallback is set. IsochDescriptor %x (and Reserved %x) is returned and not processed.\n", 
            IsochDescriptor, IsochDescriptorReserved));
        return;
    }
    

    //
    // Synchronization note:
    //
    // We are competing with cancel packet routine in the 
    // event of device removal or setting to STOP state.
    // which ever got the spin lock to set DEATCH_BUFFER 
    // flag take ownership completing the Irp/IsochDescriptor.
    // 

    KeAcquireSpinLock(&pDevExt->IsochDescriptorLock, &oldIrql);
    if(pDevExt->bDevRemoved ||
       (IsochDescriptorReserved->Flags & (STATE_SRB_IS_COMPLETE | STATE_DETACHING_BUFFERS)) ) {
        ERROR_LOG(("DCamIsochCallback: bDevRemoved || STATE_SRB_IS_COMPLETE | STATE_DETACHING_BUFFERS %x %x\n", 
                IsochDescriptorReserved,IsochDescriptorReserved->Flags));
        ASSERT((!pDevExt->bDevRemoved && !(IsochDescriptorReserved->Flags & (STATE_SRB_IS_COMPLETE | STATE_DETACHING_BUFFERS))));
        KeReleaseSpinLock(&pDevExt->IsochDescriptorLock, oldIrql);    
        return;   
    }
    IsochDescriptorReserved->Flags |= STATE_DETACHING_BUFFERS;        
    KeReleaseSpinLock(&pDevExt->IsochDescriptorLock, oldIrql);    


    pStrmEx = (PSTREAMEX) pDevExt->pStrmEx;

    ASSERT(pStrmEx == (PSTREAMEX)IsochDescriptorReserved->Srb->StreamObject->HwStreamExtension);

    pStrmEx->FrameCaptured++;
    pStrmEx->FrameInfo.PictureNumber = pStrmEx->FrameCaptured + pStrmEx->FrameInfo.DropCount;

    //
    // Return the timestamp for the frame
    //

    pDataPacket = IsochDescriptorReserved->Srb->CommandData.DataBufferArray;
    pFrameInfo = (PKS_FRAME_INFO) (pDataPacket + 1);

    ASSERT ( pDataPacket );
    ASSERT ( pFrameInfo );

    //
    // Return the timestamp for the frame
    //
    pDataPacket->PresentationTime.Numerator = 1;
    pDataPacket->PresentationTime.Denominator = 1;
    pDataPacket->Duration = pStrmEx->pVideoInfoHeader->AvgTimePerFrame;

    //
    // if we have a master clock
    // 
    if (pStrmEx->hMasterClock) {

        ULONGLONG tmStream;
                    
        tmGetStreamTime(IsochDescriptorReserved->Srb, pStrmEx, &tmStream);
        pDataPacket->PresentationTime.Time = tmStream;
        pDataPacket->OptionsFlags = 0;
          
        pDataPacket->OptionsFlags |= 
             KSSTREAM_HEADER_OPTIONSF_TIMEVALID |
             KSSTREAM_HEADER_OPTIONSF_DURATIONVALID |
             KSSTREAM_HEADER_OPTIONSF_SPLICEPOINT;     // Every frame we generate is a key frame (aka SplicePoint)
               
        DbgMsg3(("\'IsochCallback: Time(%dms); P#(%d)=Cap(%d)+Drp(%d); Pend%d\n",
                (ULONG) tmStream/10000,
                (ULONG) pStrmEx->FrameInfo.PictureNumber,
                (ULONG) pStrmEx->FrameCaptured,
                (ULONG) pStrmEx->FrameInfo.DropCount,
                pDevExt->PendingReadCount));

    } else {

        pDataPacket->PresentationTime.Time = 0;
        pDataPacket->OptionsFlags &=                       
            ~(KSSTREAM_HEADER_OPTIONSF_TIMEVALID |
            KSSTREAM_HEADER_OPTIONSF_DURATIONVALID);
    }

    // Set additional info fields about the data captured such as:
    //   Frames Captured
    //   Frames Dropped
    //   Field Polarity
                
    pStrmEx->FrameInfo.ExtendedHeaderSize = pFrameInfo->ExtendedHeaderSize;
    *pFrameInfo = pStrmEx->FrameInfo;

#ifdef SUPPORT_RGB24
    // Swaps B and R or BRG24 to RGB24.
    // There are 640x480 pixels so 307200 swaps are needed.
    if(pDevExt->CurrentModeIndex == VMODE4_RGB24 && pStrmEx->pVideoInfoHeader) {
        PBYTE pbFrameBuffer;
        BYTE bTemp;
        ULONG i, ulLen;

#ifdef USE_WDM110   // Win2000
        // Driver verifier flag to use this but if this is used, this driver will not load for any Win9x OS.
        pbFrameBuffer = (PBYTE) MmGetSystemAddressForMdlSafe(IsochDescriptorReserved->Srb->Irp->MdlAddress, NormalPagePriority);
#else    // Win9x
        pbFrameBuffer = (PBYTE) MmGetSystemAddressForMdl    (IsochDescriptorReserved->Srb->Irp->MdlAddress);
#endif
        if(pbFrameBuffer) {
            // calculate number of pixels
            ulLen = abs(pStrmEx->pVideoInfoHeader->bmiHeader.biWidth) * abs(pStrmEx->pVideoInfoHeader->bmiHeader.biHeight);
            ASSERT(ulLen == pStrmEx->pVideoInfoHeader->bmiHeader.biSizeImage/3);
            if(ulLen > pStrmEx->pVideoInfoHeader->bmiHeader.biSizeImage)
                ulLen = pStrmEx->pVideoInfoHeader->bmiHeader.biSizeImage/3;

            for (i=0; i < ulLen; i++) {
                // swap R and B
                bTemp = pbFrameBuffer[0];
                pbFrameBuffer[0] = pbFrameBuffer[2];
                pbFrameBuffer[2] = bTemp;
                pbFrameBuffer += 3;  // next RGB24 pixel
            }
        }
    }
#endif

    // Reuse the Irp and Irb
    pIrp = (PIRP) IsochDescriptor->DeviceReserved[5];
    ASSERT(pIrp);            

    pIrb = (PIRB) IsochDescriptor->DeviceReserved[6];
    ASSERT(pIrb);            

#if DBG
    // Same isochdescriptor should only be callback once.    
    ASSERT((IsochDescriptor->DeviceReserved[7] == 0x87654321));
    IsochDescriptor->DeviceReserved[7]++;
#endif

    pIrb->FunctionNumber = REQUEST_ISOCH_DETACH_BUFFERS;
    pIrb->u.IsochDetachBuffers.hResource = pDevExt->hResource;
    pIrb->u.IsochDetachBuffers.nNumberOfDescriptors = 1;
    pIrb->u.IsochDetachBuffers.pIsochDescriptor = IsochDescriptor;

    NextIrpStack = IoGetNextIrpStackLocation(pIrp);
    NextIrpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    NextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_1394_CLASS;
    NextIrpStack->Parameters.Others.Argument1 = pIrb;

    IoSetCompletionRoutine(
        pIrp,
        DCamDetachBufferCR,  // Detach complete and will attach queued buffer.
        pIrb,
        TRUE,
        TRUE,
        TRUE
        );
          
    IoCallDriver(pDevExt->BusDeviceObject, pIrp);
            
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\1394dcam\ctrlpkt.c ===
//===========================================================================
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
// PURPOSE.
//
// Copyright (c) 1996 - 2000  Microsoft Corporation.  All Rights Reserved.
//
//===========================================================================
/*++

Module Name:

    CtrlPkt.c

Abstract:

    Stream class based WDM driver for 1934 Desktop Camera.
    This file contains code to handle the stream class control packets.

Author:   

    Yee J. Wu 24-Jun-98

Environment:

    Kernel mode only

Revision History:


--*/


#include "strmini.h"
#include "ksmedia.h"
#include "1394.h"
#include "wdm.h"       // for DbgBreakPoint() defined in dbg.h
#include "dbg.h"
#include "dcamdef.h"
#include "dcampkt.h"
#include "sonydcam.h"

#define WAIT_FOR_SLOW_DEVICE

#ifdef ALLOC_PRAGMA   
     #pragma alloc_text(PAGE, DCamSetKSStateSTOP)
     #pragma alloc_text(PAGE, DCamSetKSStatePAUSE)
     #pragma alloc_text(PAGE, DCamReceiveCtrlPacket)
#endif


NTSTATUS
DCamToStopStateCR(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrp,
    IN PDCAM_IO_CONTEXT pDCamIoContext
    )
/*++

Routine Description:

    
    This is the state machine to set the streaming state to STOP.
    It start at PASSIVE_LEVEL and the lower driver may have raised it to DISPATCH_LEVEL.

Arguments:

    DriverObject - Pointer to driver object created by system.

    pIrp - Irp that just completed

    pDCamIoContext - A structure that contain the context of this IO completion routine.

Return Value:

    None.

--*/

{
    PDCAM_EXTENSION pDevExt;
    PSTREAMEX pStrmEx;
    NTSTATUS Status;
    PIRB pIrb;
    PIO_STACK_LOCATION NextIrpStack;


    if(!pDCamIoContext) {
        return STATUS_MORE_PROCESSING_REQUIRED;
    }


    pIrb    = pDCamIoContext->pIrb;
    pDevExt = pDCamIoContext->pDevExt;
    pStrmEx = (PSTREAMEX) pDevExt->pStrmEx;    

    DbgMsg2(("\'DCamToStopStateCR: completed DeviceState=%d; pIrp->IoStatus.Status=%x\n", 
        pDCamIoContext->DeviceState, pIrp->IoStatus.Status));
    
    // Free MDL
    if(pIrb->FunctionNumber == REQUEST_ASYNC_WRITE) {
        DbgMsg3(("DCamToStopStateCR: IoFreeMdl\n"));
        IoFreeMdl(pIrb->u.AsyncWrite.Mdl);
    }


    // Return error status and free resoruce.
    if(pIrp->IoStatus.Status != STATUS_SUCCESS) {
        if(pDCamIoContext->pSrb) {
            ERROR_LOG(("DCamToStopStateCR: pIrp->IoStatus.Status %x; cancel all packets\n", pIrp->IoStatus.Status));
            // In order to stop streaming, we must cancel all pending IRPs
            // Cancel pending IRPS and complete SRB.
            DCamCancelAllPackets(
                pDCamIoContext->pSrb,
                pDevExt,
                &pDevExt->PendingReadCount
                );
        }
        DCamFreeIrbIrpAndContext(pDCamIoContext, pDCamIoContext->pIrb, pIrp);
        return STATUS_MORE_PROCESSING_REQUIRED; 
    } 

    switch (pDCamIoContext->DeviceState) {   

    case DCAM_STOPSTATE_SET_REQUEST_ISOCH_STOP:
    //
    // Now stop the stream at the device itself
    //
        // Next state:
        pDCamIoContext->DeviceState = DCAM_STOPSTATE_SET_STOP_ISOCH_TRANSMISSION;  // Keep track of device state that we just set.

        pDCamIoContext->RegisterWorkArea.AsULONG = STOP_ISOCH_TRANSMISSION;
        pIrb->FunctionNumber = REQUEST_ASYNC_WRITE;
        pIrb->Flags = 0;
        pIrb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_High = INITIAL_REGISTER_SPACE_HI;
        pIrb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_Low =  
              pDevExt->BaseRegister + FIELDOFFSET(CAMERA_REGISTER_MAP, IsoEnable);
        pIrb->u.AsyncWrite.nNumberOfBytesToWrite = sizeof(ULONG);
        pIrb->u.AsyncWrite.nBlockSize = 0;
        pIrb->u.AsyncWrite.fulFlags = 0;
        InterlockedExchange(&pIrb->u.AsyncWrite.ulGeneration, pDevExt->CurrentGeneration);
        
        pIrb->u.AsyncWrite.Mdl = 
            IoAllocateMdl(&pDCamIoContext->RegisterWorkArea, sizeof(ULONG), FALSE, FALSE, NULL);
        MmBuildMdlForNonPagedPool(pIrb->u.AsyncWrite.Mdl);

        // Set once and used again in the completion routine.
        NextIrpStack = IoGetNextIrpStackLocation(pIrp);
        NextIrpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        NextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_1394_CLASS;
        NextIrpStack->Parameters.Others.Argument1 = pIrb;

        IoSetCompletionRoutine(
            pIrp,
            DCamToStopStateCR,
            pDCamIoContext,
            TRUE,
            TRUE,
            TRUE
            );

        Status = 
            IoCallDriver(
                pDevExt->BusDeviceObject,
                pIrp
                );
        return STATUS_MORE_PROCESSING_REQUIRED; 
        

    case DCAM_STOPSTATE_SET_STOP_ISOCH_TRANSMISSION:
    //
    // Detach all buffers that might still be attached.
    //
        DbgMsg2(("\'DCamToStopStateCR: IsListEmpty()=%s; PendingRead=%d\n",
            IsListEmpty(&pDevExt->IsochDescriptorList) ? "Yes" : "No", pDevExt->PendingReadCount));

        if(pDCamIoContext->pSrb) {
            //
            // Cancel all pending and waiting buffers;
            // and Complete DCamSetKSStateSTOP's SRB
            //
            DCamCancelAllPackets(
                pDCamIoContext->pSrb,
                pDevExt,
                &pDevExt->PendingReadCount
                );            

            // This pDCamIoContext->pSrb will be completed in DCamCancelPacket()
            // But its Irb and Irp and context are freed here.
            DCamFreeIrbIrpAndContext(pDCamIoContext, pDCamIoContext->pIrb, pIrp);
            return STATUS_MORE_PROCESSING_REQUIRED; 

        } else {
            ERROR_LOG(("DCamToStopStateCR:CanNOT call DCamCancelPacket() with a null pSrb\n"));
        }

        break;

    default:
        ERROR_LOG(("\'DCamToStopStateCR: Unknown pDCamIoContext->DeviceState=%d\n", pDCamIoContext->DeviceState));
        ASSERT(FALSE);
        break;
    }

    if(pDCamIoContext->pSrb) {
        pDCamIoContext->pSrb->Status = pIrp->IoStatus.Status == STATUS_SUCCESS ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;        
        COMPLETE_SRB(pDCamIoContext->pSrb)  
    }
    DCamFreeIrbIrpAndContext(pDCamIoContext, pDCamIoContext->pIrb, pIrp);


    return STATUS_MORE_PROCESSING_REQUIRED; 

}



VOID
DCamSetKSStateSTOP(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )

/*++

Routine Description:

    Into STOP streaming state.
       (1) Stop device from steaming (!ISO_ENABLE)
       (2) Stop listening (controller)
       (3) Detach pending read buffer and return with Cancel, and 
           start the waiting read to be put into the pengin read and then Cancel.

Arguments:

    pSrb - Pointer to Stream request block

Return Value:

    Nothing

--*/

{

    PDCAM_EXTENSION pDevExt;
    PSTREAMEX pStrmEx;
    PIRB pIrb;
    PIRP pIrp;
    PDCAM_IO_CONTEXT pDCamIoContext;
    PIO_STACK_LOCATION NextIrpStack;
    NTSTATUS Status, StatusWait;

    PAGED_CODE();

    pDevExt = (PDCAM_EXTENSION) pSrb->HwDeviceExtension; 
    ASSERT(pDevExt);
    pStrmEx = (PSTREAMEX) pDevExt->pStrmEx;                  
    ASSERT(pStrmEx);


    DbgMsg1(("\'DCamSetKSStateSTOP: Frame captured:%d\n", (DWORD) pStrmEx->FrameCaptured));
    //
    // After this, no more read will be accepted.
    //
    pStrmEx->KSState = KSSTATE_STOP;


    //
    // First stop the stream internally inside the PC's 1394
    // stack
    //
    if(!pDevExt->hResource) {
        pSrb->Status = STATUS_INSUFFICIENT_RESOURCES;
        COMPLETE_SRB(pSrb)
        return;
    }

    //
    // Wait for last read to complete.  
    // After KState == KSSTATE_STOP, we will return all SRB_READ.
    //
    StatusWait = KeWaitForSingleObject( &pStrmEx->hMutex, Executive, KernelMode, FALSE, 0 );  
    KeReleaseMutex(&pStrmEx->hMutex, FALSE);


    if(!DCamAllocateIrbIrpAndContext(&pDCamIoContext, &pIrb, &pIrp, pDevExt->BusDeviceObject->StackSize)) {
        pSrb->Status = STATUS_INSUFFICIENT_RESOURCES;
        COMPLETE_SRB(pSrb)
        return;
    } 

    pDCamIoContext->DeviceState = DCAM_STOPSTATE_SET_REQUEST_ISOCH_STOP;
    pDCamIoContext->pSrb        = pSrb;               // To do StreamClassStreamNotification()
    pDCamIoContext->pDevExt     = pDevExt;
    pIrb->FunctionNumber        = REQUEST_ISOCH_STOP;
    pIrb->Flags                 = 0;
    pIrb->u.IsochStop.hResource = pDevExt->hResource;
    pIrb->u.IsochStop.fulFlags  = 0;

    NextIrpStack = IoGetNextIrpStackLocation(pIrp);
    NextIrpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    NextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_1394_CLASS;
    NextIrpStack->Parameters.Others.Argument1 = pIrb;
      
    IoSetCompletionRoutine(
        pIrp,
         DCamToStopStateCR,
        pDCamIoContext,
        TRUE,
        TRUE,
        TRUE
        );

    Status = 
        IoCallDriver(
            pDevExt->BusDeviceObject,
            pIrp
            );

    ASSERT(Status == STATUS_SUCCESS || Status == STATUS_PENDING);

    return;  // Do StreamClassStreamNotification() in IoCompletionRoutine
}



NTSTATUS
DCamToPauseStateCR(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrp,
    IN PDCAM_IO_CONTEXT pDCamIoContext
    )

/*++

Routine Description:

    This routine is for use with synchronous IRP processing.  
    All it does is signal an event, so the driver knows it
    can continue.

Arguments:

    DriverObject - Pointer to driver object created by system.

    pIrp - Irp that just completed

    pDCamIoContext - A structure that contain the context of this IO completion routine.

Return Value:

    None.

--*/

{
    PDCAM_EXTENSION pDevExt;
    PSTREAMEX pStrmEx;
    PIRB pIrb;

    if(!pDCamIoContext) {
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    pIrb    = pDCamIoContext->pIrb;
    pDevExt = pDCamIoContext->pDevExt;
    pStrmEx = (PSTREAMEX) pDevExt->pStrmEx;                  
    ASSERT(pStrmEx);

    DbgMsg2(("\'DCamToPauseStateCR: completed DeviceState=%d; pIrp->IoStatus.Status=%x\n", 
        pDCamIoContext->DeviceState, pIrp->IoStatus.Status));

    // No reason it would failed.
    ASSERT(pIrp->IoStatus.Status == STATUS_SUCCESS);

    switch (pDCamIoContext->DeviceState) {   

    case DCAM_PAUSESTATE_SET_REQUEST_ISOCH_STOP:
         break;
    default:
         ERROR_LOG(("DCamToPauseStateCompletionRoutine: Unknown or unexpected pDCamIoContext->DeviceState=%d\n", pDCamIoContext->DeviceState)); 
         ASSERT(FALSE);
         break;
    }

    //
    // We are here only if switching from RUN->PAUSE,
    // It is alreay set to PAUSE state in DCamSetKSStatePAUSE
    //



    if(pDCamIoContext->pSrb) {
        pDCamIoContext->pSrb->Status = pIrp->IoStatus.Status == STATUS_SUCCESS ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL; 
        COMPLETE_SRB(pDCamIoContext->pSrb)
    }

    DCamFreeIrbIrpAndContext(pDCamIoContext, pDCamIoContext->pIrb, pIrp);
    return STATUS_MORE_PROCESSING_REQUIRED;     

}




VOID
DCamSetKSStatePAUSE(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
/*++

Routine Description:

    Set KSSTATE to KSSTATE_PAUSE.

Arguments:

    Srb - Pointer to Stream request block

Return Value:

    Nothing

--*/
{
    PDCAM_EXTENSION pDevExt;
    PSTREAMEX pStrmEx;
    PIRB pIrb;
    PIRP pIrp;
    PDCAM_IO_CONTEXT pDCamIoContext;
    PIO_STACK_LOCATION NextIrpStack;
    NTSTATUS Status;

    PAGED_CODE();

    pDevExt = (PDCAM_EXTENSION) pSrb->HwDeviceExtension;
    ASSERT(pDevExt);
    pStrmEx = (PSTREAMEX) pDevExt->pStrmEx;
    ASSERT(pStrmEx);

    pSrb->Status = STATUS_SUCCESS;

    switch(pStrmEx->KSState) {
    case KSSTATE_ACQUIRE:
    case KSSTATE_STOP:
    //
    // Out of STOP state, 
    // initialize frame and timestamp information.  
    // (Master's clock's stream time is also reset.)
    //
        pStrmEx->FrameCaptured            = 0;     // Actual count
        pStrmEx->FrameInfo.DropCount      = 0;     
        pStrmEx->FrameInfo.PictureNumber  = 0;
        pStrmEx->FrameInfo.dwFrameFlags   = 0;
       
        // Advanced one frame.
        pStrmEx->FirstFrameTime           = pStrmEx->pVideoInfoHeader->AvgTimePerFrame; 
        DbgMsg2(("\'DCamSetKSStatePAUSE: FirstFrameTime(%d)\n", pStrmEx->FirstFrameTime));
        break;

    case KSSTATE_RUN:
    //
    // Will ask controll to stop listening.
    // All the pening buffer(s) are kept in the controller.
    // Before it completely stop (some latency here), 
    // we might get some IsochCallback() with data.
    //      
        if(!pDevExt->hResource) {
            pSrb->Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        if(!DCamAllocateIrbIrpAndContext(&pDCamIoContext, &pIrb, &pIrp, pDevExt->BusDeviceObject->StackSize)) {
            pSrb->Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        } 

        // Set to KSSTATE_PAUSE at the beginning to prvent CancelPacket being processed thinking
        // it is still in KSSTATE_RUN state.
        pStrmEx->KSState            = KSSTATE_PAUSE;
        pDCamIoContext->DeviceState = DCAM_PAUSESTATE_SET_REQUEST_ISOCH_STOP;
        pDCamIoContext->pSrb        = pSrb;               // To do StreamClassStreamNotification()
        pDCamIoContext->pDevExt     = pDevExt;
        pIrb->FunctionNumber        = REQUEST_ISOCH_STOP;
        pIrb->Flags                 = 0;
        pIrb->u.IsochStop.hResource = pDevExt->hResource;
        pIrb->u.IsochStop.fulFlags  = 0;

        NextIrpStack = IoGetNextIrpStackLocation(pIrp);
        NextIrpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        NextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_1394_CLASS;
        NextIrpStack->Parameters.Others.Argument1 = pIrb;
          
        IoSetCompletionRoutine(
            pIrp,
            DCamToPauseStateCR,
            pDCamIoContext,
            TRUE,
            TRUE,
            TRUE
            );

        Status =\
            IoCallDriver(
                pDevExt->BusDeviceObject,
                pIrp
                );
        return;  // Do StreamClassStreamNotification() in IoCompletionRoutine

    case KSSTATE_PAUSE:
        ERROR_LOG(("DCamSetKSStatePAUSE: Already in KSSTATE_PAUSE state.\n"));
        ASSERT(pStrmEx->KSState != KSSTATE_PAUSE);
        break;
    }     

    pStrmEx->KSState = KSSTATE_PAUSE;

    COMPLETE_SRB(pSrb)
}



NTSTATUS
DCamToRunStateCR(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrp,
    IN PDCAM_IO_CONTEXT pDCamIoContext
    )

/*++

Routine Description:

    This routine is for use with synchronous IRP processing.  
    All it does is signal an event, so the driver knows it
    can continue.

Arguments:

    DriverObject - Pointer to driver object created by system.

    pIrp - Irp that just completed

    pDCamIoContext - A structure that contain the context of this IO completion routine.

Return Value:

    None.

--*/

{
    PDCAM_EXTENSION pDevExt;
    PSTREAMEX pStrmEx;
    NTSTATUS Status;
    PIRB pIrb;
    PIO_STACK_LOCATION NextIrpStack;

    if(!pDCamIoContext) {
        return STATUS_MORE_PROCESSING_REQUIRED;
    }


    pIrb = pDCamIoContext->pIrb;
    pDevExt = pDCamIoContext->pDevExt;
    
    DbgMsg2(("\'DCamToRunStateCR: completed DeviceState=%d; pIrp->IoStatus.Status=%x\n", 
        pDCamIoContext->DeviceState, pIrp->IoStatus.Status));

    // Free MDL
    if(pIrb->FunctionNumber == REQUEST_ASYNC_WRITE) {
        DbgMsg3(("DCamToRunStateCR: IoFreeMdl\n"));
        IoFreeMdl(pIrb->u.AsyncWrite.Mdl);
    }

    //
    // CAUTION:
    //    STATUS_TIMEOUT can be a valid return that we may to try again.
    //    But should it be a HW issue that it is not responding to our write.
    //    Controller should have made many reties before return STATUS_TIMEOUT.
    //       
    if(pIrp->IoStatus.Status != STATUS_SUCCESS) {
       if(DCAM_RUNSTATE_SET_REQUEST_ISOCH_LISTEN != pDCamIoContext->DeviceState ||
           STATUS_INSUFFICIENT_RESOURCES != pIrp->IoStatus.Status  ) {

            ERROR_LOG(("DCamToRunStateCR:  pIrp->IoStatus.Status=%x; free resoruce and STOP\n", pIrp->IoStatus.Status));
            if(pDCamIoContext->pSrb) {
                pDCamIoContext->pSrb->Status = pIrp->IoStatus.Status == STATUS_SUCCESS ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
                COMPLETE_SRB(pDCamIoContext->pSrb);
            }
            DCamFreeIrbIrpAndContext(pDCamIoContext, pDCamIoContext->pIrb, pIrp);

            return STATUS_MORE_PROCESSING_REQUIRED; 
        } else {
            //
            // This is OK:
            //   If we get an insufficient resources error that means
            //   we don't have any Reads down yet.  Set flag to TRUE
            //   indicating that when we do get a Read down we'll 
            //   actually need to begin the listening process.
            //
            pDevExt->bNeedToListen = TRUE;
            DbgMsg1(("DCamToRunStateCR: ##### no read yet! set pDevExt->bNeedToListen = TRUE\n"));
        }
    } 

#ifdef WAIT_FOR_SLOW_DEVICE
    KeStallExecutionProcessor(5000);  // 5 msec
#endif


    switch (pDCamIoContext->DeviceState) {   

    case DCAM_RUNSTATE_SET_REQUEST_ISOCH_LISTEN:
        //
        // Bit[24..26]0:0000 = CurrentFrameRate
        //
        pDCamIoContext->RegisterWorkArea.AsULONG = pDevExt->FrameRate << 5;
        DbgMsg2(("\'DCamToRunState: FrameRate %x\n", pDCamIoContext->RegisterWorkArea.AsULONG));
        pIrb->FunctionNumber = REQUEST_ASYNC_WRITE;
        pIrb->Flags = 0;
        pIrb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_High = INITIAL_REGISTER_SPACE_HI;
        pIrb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_Low =  
              pDevExt->BaseRegister + FIELDOFFSET(CAMERA_REGISTER_MAP, CurrentVFrmRate);
        pIrb->u.AsyncWrite.nNumberOfBytesToWrite = sizeof(ULONG);
        pIrb->u.AsyncWrite.nBlockSize = 0;
        pIrb->u.AsyncWrite.fulFlags = 0;
        InterlockedExchange(&pIrb->u.AsyncWrite.ulGeneration, pDevExt->CurrentGeneration);
        break;

    case DCAM_RUNSTATE_SET_FRAME_RATE:
        //
        // Bit[24..26]0:0000 = CurrentVideoMode
        //
        pDCamIoContext->RegisterWorkArea.AsULONG = pDevExt->CurrentModeIndex << 5;
      DbgMsg2(("\'DCamToRunState: CurrentVideoMode %x\n", pDCamIoContext->RegisterWorkArea.AsULONG));
        pIrb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_Low =  
                  pDevExt->BaseRegister + FIELDOFFSET(CAMERA_REGISTER_MAP, CurrentVMode);
        break;

    case DCAM_RUNSTATE_SET_CURRENT_VIDEO_MODE:
        pDCamIoContext->RegisterWorkArea.AsULONG = FORMAT_VGA_NON_COMPRESSED;
      DbgMsg2(("\'DCamToRunState: VideoFormat %x\n", pDCamIoContext->RegisterWorkArea.AsULONG));
        pIrb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_Low =  
                  pDevExt->BaseRegister +  FIELDOFFSET(CAMERA_REGISTER_MAP, CurrentVFormat);
        break;

    case DCAM_RUNSTATE_SET_CURRENT_VIDEO_FORMAT:
        //
        // Bit [24..27]:00[30..31] = IsoChannel:00SpeedCode
        // 
        pDCamIoContext->RegisterWorkArea.AsULONG = (pDevExt->IsochChannel << 4) | pDevExt->SpeedCode;
      DbgMsg2(("\'DCamToRunState: pDevExt->SpeedCode 0x%x, Channel+SpeedCode %x\n", pDevExt->SpeedCode, pDCamIoContext->RegisterWorkArea.AsULONG));
        pIrb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_Low =  
                  pDevExt->BaseRegister +  FIELDOFFSET(CAMERA_REGISTER_MAP, IsoChannel);         
        break;

    case DCAM_RUNSTATE_SET_SPEED:
        //
        // Bit[24]000:0000 = start ? 1 : 0;
        //

        pDCamIoContext->RegisterWorkArea.AsULONG = START_ISOCH_TRANSMISSION;
        pIrb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_Low =  
                  pDevExt->BaseRegister +  FIELDOFFSET(CAMERA_REGISTER_MAP, IsoEnable);         
        break;


    case DCAM_RUNSTATE_SET_START:
        pStrmEx = (PSTREAMEX) pDevExt->pStrmEx;                  
        ASSERT(pStrmEx);
        pStrmEx->KSState = KSSTATE_RUN; 

        // If this is called from a SRB, then completed it.
        if(pDCamIoContext->pSrb) {
            pDCamIoContext->pSrb->Status = pIrp->IoStatus.Status == STATUS_SUCCESS ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL; 
            COMPLETE_SRB(pDCamIoContext->pSrb);
        }

        //
        // This is last stop; so
        // we free what we allocated.
        //
        DbgMsg2(("\'DCamToRunStateCR: DONE!\n"));
        DCamFreeIrbIrpAndContext(pDCamIoContext, pDCamIoContext->pIrb, pIrp);
        return STATUS_MORE_PROCESSING_REQUIRED; 

    default:
        ERROR_LOG(("DCamToRunStateCR:DeviceState(%d) is not defined!\n\n", pDCamIoContext->DeviceState));        
        ASSERT(FALSE);
        return STATUS_MORE_PROCESSING_REQUIRED;
        
    }

    pDCamIoContext->DeviceState++;  // Keep track of device state that we just set.

    if(pIrb->FunctionNumber == REQUEST_ASYNC_WRITE) {
        pIrb->u.AsyncWrite.Mdl = 
            IoAllocateMdl(&pDCamIoContext->RegisterWorkArea, sizeof(ULONG), FALSE, FALSE, NULL);
        MmBuildMdlForNonPagedPool(pIrb->u.AsyncWrite.Mdl);
    }


    NextIrpStack = IoGetNextIrpStackLocation(pIrp);
    NextIrpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    NextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_1394_CLASS;
    NextIrpStack->Parameters.Others.Argument1 = pIrb;

    IoSetCompletionRoutine(
        pIrp,
        DCamToRunStateCR,
        pDCamIoContext,
        TRUE,
        TRUE,
        TRUE
        );

    Status = 
        IoCallDriver(
            pDevExt->BusDeviceObject,
            pIrp
            );

    DbgMsg2(("\'DCamToRunStateCR: IoCallDriver, Status=%x; STATUS_PENDING(%x)\n", Status, STATUS_PENDING));

    return STATUS_MORE_PROCESSING_REQUIRED;
}



VOID
DCamSetKSStateRUN(
    PDCAM_EXTENSION pDevExt,
    IN PHW_STREAM_REQUEST_BLOCK pSrb // Needed only to complete the SRB; for bus reset, there is no SRB.
    )
/*++

Routine Description:

    Set KSSTATE to KSSTATE_RUN.
    Can be called at DISPATCH level for initializing the device after a bus reset.

Arguments:

    pSrb - Pointer to Stream request block

Return Value:

    Nothing

--*/
{

    PSTREAMEX pStrmEx;
    PIRB pIrb;
    PIRP pIrp;
    PDCAM_IO_CONTEXT pDCamIoContext;
    PIO_STACK_LOCATION NextIrpStack;
    NTSTATUS Status;


    ASSERT(pDevExt);
    pStrmEx = (PSTREAMEX) pDevExt->pStrmEx;                  
    ASSERT(pStrmEx);
    

    if(!DCamAllocateIrbIrpAndContext(&pDCamIoContext, &pIrb, &pIrp, pDevExt->BusDeviceObject->StackSize)) {
        if(pSrb) {
            pSrb->Status = STATUS_INSUFFICIENT_RESOURCES;
            COMPLETE_SRB(pSrb);
        }
        return;       
    } 

    pStrmEx->KSStateFinal       = KSSTATE_RUN;
    pDCamIoContext->DeviceState = DCAM_RUNSTATE_SET_REQUEST_ISOCH_LISTEN;
    pDCamIoContext->pSrb        = pSrb;               // To do StreamClassStreamNotification()
    pDCamIoContext->pDevExt     = pDevExt;
    pIrb->FunctionNumber        = REQUEST_ISOCH_LISTEN;
    pIrb->Flags                 = 0;
    pIrb->u.IsochStop.hResource = pDevExt->hResource;
    pIrb->u.IsochStop.fulFlags  = 0;

    NextIrpStack = IoGetNextIrpStackLocation(pIrp);
    NextIrpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    NextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_1394_CLASS;
    NextIrpStack->Parameters.Others.Argument1 = pIrb;
          
    // In case we time out, we will try again; apply only to start listen;
    // With little change, it can work with other operation as well.
    pDevExt->lRetries = 0;

    IoSetCompletionRoutine(
        pIrp,
        DCamToRunStateCR,
        pDCamIoContext,
        TRUE,
        TRUE,
        TRUE
        );

    Status = 
        IoCallDriver(
            pDevExt->BusDeviceObject,
            pIrp
            );    
}



VOID
DCamReceiveCtrlPacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )

/*++

Routine Description:

    Called with packet commands that control the video stream

Arguments:

    pSrb - Pointer to Stream request block

Return Value:

    Nothing

--*/

{

    PDCAM_EXTENSION pDevExt;
    PSTREAMEX pStrmEx;


    //
    // determine the type of packet.
    //

    PAGED_CODE();

    pSrb->Status = STATUS_SUCCESS;  // default; called functions depends on this.
    pDevExt = (PDCAM_EXTENSION) pSrb->HwDeviceExtension;     
    ASSERT(pDevExt);
    pStrmEx = (PSTREAMEX) pDevExt->pStrmEx;
    ASSERT(pStrmEx);

    switch (pSrb->Command) {
    case SRB_GET_STREAM_STATE:         
         VideoGetState (pSrb);
         break;

    case SRB_SET_STREAM_STATE:   
         if(pStrmEx == NULL) {
            ERROR_LOG(("\'DCamReceiveCtrlPacket: SRB_SET_STREAM_STATE but pStrmEx is NULL.\n"));
            ASSERT(pStrmEx);
            pSrb->Status = STATUS_UNSUCCESSFUL;
            break;      
         }

         DbgMsg2(("\'DCamReceiveCtrlPacket: Setting state from %d to %d; PendingRead %d\n", 
                     pStrmEx->KSState, pSrb->CommandData.StreamState, pDevExt->PendingReadCount));               


         //
         // The control packet and data packet are not serialized by the stream class.
         // We need to watch for PAUSE->STOP transition.
         // In this transition, SRB_READ can still come in in a separate thread if
         // the client application has separate threads for setting state and read data.
         //
         // A "stop data packet" flag and a mutex is used for this synchronization.       
         // So we set "stop data packet" flag to stop future read, and
         // wait to own the mutex (if read is in progress) and then set stream to STOP state.
         // This "stop data packet" flag can be the stream state.
         //
         switch (pSrb->CommandData.StreamState) {
         case KSSTATE_STOP:
              DCamSetKSStateSTOP(pSrb);
              return;  // Complete Asynchronously in IoCompletionRoutine*

         case KSSTATE_PAUSE:
              DCamSetKSStatePAUSE(pSrb);
              return;  // Complete Asynchronously in IoCompletionRoutine*

         case KSSTATE_RUN:
              DCamSetKSStateRUN(pDevExt, pSrb);
              return;  // Complete Asynchronously in IoCompletionRoutine*

         case KSSTATE_ACQUIRE:
              pSrb->Status = STATUS_SUCCESS;
              break;

         default:
              ERROR_LOG(("\'DCamReceiveCtrlPacket: Error unknown state\n"));
              pSrb->Status = STATUS_NOT_IMPLEMENTED;
              break;
         }

         pStrmEx->KSState = pSrb->CommandData.StreamState;
         break;

    case SRB_GET_STREAM_PROPERTY:
         DbgMsg3(("\'DCamReceiveCtrlPacket: SRB_GET_STREAM_PROPERTY\n"));
         VideoGetProperty(pSrb);
         break;

    case SRB_INDICATE_MASTER_CLOCK:
         //
         // Assigns a clock to a stream
         //
         VideoIndicateMasterClock (pSrb);
         break;

    default:
         //
         // invalid / unsupported command. Fail it as such
         //    
         pSrb->Status = STATUS_NOT_IMPLEMENTED;    
         break;
    }

    StreamClassStreamNotification(StreamRequestComplete, pSrb->StreamObject, pSrb);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\1394dcam\datapkt.c ===
//===========================================================================
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
// PURPOSE.
//
// Copyright (c) 1996 - 2000  Microsoft Corporation.  All Rights Reserved.
//
//===========================================================================
/*++

Module Name:

    DataPkt.c

Abstract:

    Stream class based WDM driver for 1934 Desktop Camera.
    This file contains code to handle the stream class packets.

Author:

    Yee J. Wu 24-Jun-98

Environment:

    Kernel mode only

Revision History:


--*/


#include "strmini.h"
#include "ksmedia.h"
#include "1394.h"
#include "wdm.h"       // for DbgBreakPoint() defined in dbg.h
#include "dbg.h"
#include "dcamdef.h"
#include "dcampkt.h"
#include "sonydcam.h"

extern CAMERA_ISOCH_INFO IsochInfoTable[];



#ifdef ALLOC_PRAGMA
    #pragma alloc_text(PAGE, DCamSurpriseRemoval)
    #pragma alloc_text(PAGE, DCamReceiveDataPacket)
#endif



NTSTATUS
DCamCancelOnePacketCR(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrp,
    PISOCH_DESCRIPTOR IsochDescriptor
    )
/*++

Routine Description:

    Completion routine for detach an isoch descriptor associate with a pending read SRB.
    Will cancel the pending SRB here if detaching descriptor has suceeded.

Arguments:

    DriverObject - Pointer to driver object created by system.
    pIrp - Allocated locally, need to be free here.
    IsochDescriptor - Isoch descriptor containing the SRB to be cancelled.

Return Value:

    None.

--*/
{
    PHW_STREAM_REQUEST_BLOCK pSrbToCancel;
    PISOCH_DESCRIPTOR_RESERVED IsochDescriptorReserved;
    PDCAM_EXTENSION pDevExt;


    if(STATUS_SUCCESS != pIrp->IoStatus.Status) {
        ERROR_LOG(("DCamCancelOnePacketCR: Detach buffer failed with pIrp->IoStatus.Status= %x (! STATUS_SUCCESS) \n", pIrp->IoStatus.Status));
        ASSERT(STATUS_SUCCESS == pIrp->IoStatus.Status);

    } else {
        IsochDescriptorReserved = (PISOCH_DESCRIPTOR_RESERVED) &IsochDescriptor->DeviceReserved[0];
        pSrbToCancel = IsochDescriptorReserved->Srb;
        pDevExt = (PDCAM_EXTENSION) pSrbToCancel->HwDeviceExtension;

        IsochDescriptorReserved->Flags |= STATE_SRB_IS_COMPLETE;

        pSrbToCancel->CommandData.DataBufferArray->DataUsed = 0;
        pSrbToCancel->ActualBytesTransferred = 0;
        pSrbToCancel->Status = pDevExt->bDevRemoved ? STATUS_DEVICE_REMOVED : STATUS_CANCELLED;

        DbgMsg2(("DCamCancelOnePacketCR: SRB %x, Status %x, IsochDesc %x, Reserved %x cancelled\n",
            pSrbToCancel, pSrbToCancel->Status, IsochDescriptor, IsochDescriptorReserved));

        StreamClassStreamNotification(
            StreamRequestComplete,
            pSrbToCancel->StreamObject,
            pSrbToCancel);

        ExFreePool(IsochDescriptor);
    }

    // Allocated locally so free it.
    IoFreeIrp(pIrp);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
DCamDetachAndCancelOnePacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrbToCancel,
    PISOCH_DESCRIPTOR           IsochDescriptorToDetach,
    HANDLE                      hResource,
    PDEVICE_OBJECT              pBusDeviceObject
    )
/*++

Routine Description:

    Detach an isoch descriptor and then cancel pending SRB in the completion routine.

Arguments:

    pSrbToCancel - Pointer to SRB to cancel
    IsochDescriptorToDetach - Iosch descriptor to detach
    hResource - isoch resource allocated
    hBusDeviceObject - bus device object

Return Value:

    None.

--*/
{
    PDCAM_EXTENSION pDevExt;
    PIO_STACK_LOCATION NextIrpStack;
    NTSTATUS Status;
    PIRB     pIrb;
    PIRP     pIrp;


    DbgMsg2(("\'DCamDetachAndCancelOnePacket: pSrbTocancel %x, detaching IsochDescriptorToDetach %x\n", pSrbToCancel, IsochDescriptorToDetach));

    pDevExt = (PDCAM_EXTENSION) pSrbToCancel->HwDeviceExtension;
    pIrp = IoAllocateIrp(pDevExt->BusDeviceObject->StackSize, FALSE);
    ASSERT(pIrp);
    if(!pIrp)
        return;

    pIrb = pSrbToCancel->SRBExtension;

    pIrb->Flags           = 0;
    pIrb->FunctionNumber  = REQUEST_ISOCH_DETACH_BUFFERS;
    pIrb->u.IsochDetachBuffers.hResource            = hResource;
    pIrb->u.IsochDetachBuffers.nNumberOfDescriptors = 1;
    pIrb->u.IsochDetachBuffers.pIsochDescriptor     = IsochDescriptorToDetach;

    NextIrpStack = IoGetNextIrpStackLocation(pIrp);
    NextIrpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    NextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_1394_CLASS;
    NextIrpStack->Parameters.Others.Argument1 = pIrb;

    IoSetCompletionRoutine(
        pIrp,
        DCamCancelOnePacketCR,
        IsochDescriptorToDetach,
        TRUE,
        TRUE,
        TRUE
        );

    Status =
        IoCallDriver(
            pBusDeviceObject,
            pIrp
            );

    ASSERT(Status == STATUS_SUCCESS || Status == STATUS_PENDING);
}


VOID
DCamCancelOnePacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrbToCancel
    )
/*++

Routine Description:

    This routine is called to cancel a pending streaming SRB.  This is likely to
    happen when transitioning from PAUSE to STOP state.
    Note: This routine is called at DISPATCH_LEVEL !!

Arguments:

    pSrbToCancel - Pointer to SRB to cancel

Return Value:

    None.

--*/
{
    PHW_STREAM_REQUEST_BLOCK pSrbInQ;
    PISOCH_DESCRIPTOR        IsochDescriptorToDetach;

    PDCAM_EXTENSION pDevExt;
    PSTREAMEX       pStrmEx;
    PLIST_ENTRY     pEntry;  // Pointer to an isoch decriptor reserved structure

    KIRQL oldIrql;
    BOOL  Found;


    pDevExt = (PDCAM_EXTENSION) pSrbToCancel->HwDeviceExtension;
    ASSERT(pDevExt);
    pStrmEx = (PSTREAMEX) pDevExt->pStrmEx;
    ASSERT(pStrmEx);

    // Nothing to cancel
    if(pStrmEx == NULL) {
        return;
    }


    //
    // We only expect stream SRB, but not device SRB.
    //
    if ( (pSrbToCancel->Flags & SRB_HW_FLAGS_STREAM_REQUEST) != SRB_HW_FLAGS_STREAM_REQUEST) {
        ERROR_LOG(("DCamCancelOnePacket: Cannot cancel Device SRB %x\n", pSrbToCancel));
        ASSERT( (pSrbToCancel->Flags & SRB_HW_FLAGS_STREAM_REQUEST) == SRB_HW_FLAGS_STREAM_REQUEST );
        return;
    }


    //
    // Loop through the linked list from the beginning to end,
    // trying to find the SRB to cancel
    //
    KeAcquireSpinLock(&pDevExt->IsochDescriptorLock, &oldIrql);

    Found = FALSE;
    pEntry = pDevExt->IsochDescriptorList.Flink;

    while (pEntry != &pDevExt->IsochDescriptorList) {

        pSrbInQ = ((PISOCH_DESCRIPTOR_RESERVED)pEntry)->Srb;
        IsochDescriptorToDetach = \
            (PISOCH_DESCRIPTOR) ( ((PUCHAR) pEntry) -
            FIELDOFFSET(ISOCH_DESCRIPTOR, DeviceReserved[0]));

        if(pSrbToCancel == pSrbInQ) {
            // If we are in RUN state, we could be competing with IsochCallback;
            // Whichever grabs and change STATE_DETACHING_BUFFERS will detach.
            if(((PISOCH_DESCRIPTOR_RESERVED) pEntry)->Flags & (STATE_SRB_IS_COMPLETE | STATE_DETACHING_BUFFERS)) {
                Found = FALSE; // IsochCallback are detaching it (we lost our chance).
                ERROR_LOG(("DCamCancelOnePacket: pSrbToCancel %x, Descriptor %x,  Reserved %x already detaching or completed\n",
                    pSrbToCancel, IsochDescriptorToDetach, pEntry));

            } else {
                ((PISOCH_DESCRIPTOR_RESERVED) pEntry)->Flags |= STATE_DETACHING_BUFFERS;
#if DBG
                // Should not have been detached.
                ASSERT((IsochDescriptorToDetach->DeviceReserved[7] == 0x87654321));
                IsochDescriptorToDetach->DeviceReserved[7]++;
#endif
                RemoveEntryList(pEntry);
                InterlockedDecrement(&pDevExt->PendingReadCount);
                Found = TRUE;
            }
            break;
        }

        pEntry = pEntry->Flink;  // Next
    }
    KeReleaseSpinLock (&pDevExt->IsochDescriptorLock, oldIrql);


    //
    // Since we are in DISPATCH level, we cannot do sync operation;
    // so we will complete this asynchronously in the completion routine.
    //
    if (Found) {

        DCamDetachAndCancelOnePacket(
            pSrbToCancel,
            IsochDescriptorToDetach,
            pDevExt->hResource,
            pDevExt->BusDeviceObject);

    } else {
        ERROR_LOG(("DCamCancelOnePacket: pSrbToCancel %x is not in our list!\n", pSrbToCancel));
        ASSERT(Found);
    }
}

VOID
DCamCancelAllPackets(
    PHW_STREAM_REQUEST_BLOCK pSrb,
    PDCAM_EXTENSION pDevExt,
    LONG *plPendingReadCount
    )
/*++

Routine Description:

    This routine is use to cancel all pending IRP.
    Can be called at DISPATCH_LEVEL.

Arguments:

    pSrbToCancel - Pointer to SRB to cancel
    pDevExt - Device's contect
    plPendingReadCount - Number of pending read

Return Value:

    None.

--*/
{
    PHW_STREAM_REQUEST_BLOCK pSrbToCancel;
    PISOCH_DESCRIPTOR        IsochDescriptorToDetach;
    PLIST_ENTRY pEntry;
    KIRQL       oldIrql;

    PSTREAMEX pStrmEx;


    pStrmEx = pDevExt->pStrmEx;

    // Nothing to cancel
    if(pStrmEx == NULL) {
        return;
    }


    //
    // Loop through the linked list from the beginning to end,
    // trying to find the SRB to cancel
    //
    KeAcquireSpinLock(&pDevExt->IsochDescriptorLock, &oldIrql);
    pEntry = pDevExt->IsochDescriptorList.Flink;

    while (pEntry != &pDevExt->IsochDescriptorList) {

        pSrbToCancel = ((PISOCH_DESCRIPTOR_RESERVED)pEntry)->Srb;
        IsochDescriptorToDetach = \
            (PISOCH_DESCRIPTOR) ( ((PUCHAR) pEntry) -
            FIELDOFFSET(ISOCH_DESCRIPTOR, DeviceReserved[0]));


        if(((PISOCH_DESCRIPTOR_RESERVED) pEntry)->Flags & (STATE_SRB_IS_COMPLETE | STATE_DETACHING_BUFFERS)) {
            // Skip this one since it is already in detaching phase or completed.
            ERROR_LOG(("DCamCancelAllPacket: pSrbToCancel %x, Descriptor %x,  Reserved %x already detaching or completed\n",
                pSrbToCancel, IsochDescriptorToDetach, pEntry));

            pEntry = pEntry->Flink;  // next

        } else {
            ((PISOCH_DESCRIPTOR_RESERVED) pEntry)->Flags |= STATE_DETACHING_BUFFERS;
#if DBG
            // Should not have been detached.
            ASSERT((IsochDescriptorToDetach->DeviceReserved[7] == 0x87654321));
            IsochDescriptorToDetach->DeviceReserved[7]++;
#endif
            RemoveEntryList(pEntry);
            InterlockedDecrement(plPendingReadCount);
            DbgMsg2(("DCamCancelAllPackets: pSrbToCancel %x, Descriptor %x, Reserved %x\n",
                pSrbToCancel, IsochDescriptorToDetach, pEntry));

            pEntry = pEntry->Flink;  // pEntry is deleted in DCamDetachAndCancelOnePacket(); so get next here.

            DCamDetachAndCancelOnePacket(
                pSrbToCancel,
                IsochDescriptorToDetach,
                pDevExt->hResource,
                pDevExt->BusDeviceObject);
        }
    }

    KeReleaseSpinLock (&pDevExt->IsochDescriptorLock, oldIrql);


    pSrb->Status = STATUS_SUCCESS;
    DbgMsg1(("DCamCancelAllPackets: Complete pSrb %x, Status %x\n", pSrb, pSrb->Status));

    COMPLETE_SRB(pSrb)
}



VOID
DCamSurpriseRemoval(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )

/*++

Routine Description:

    Response to SRB_SURPRISE_REMOVAL.

Arguments:

    pSrb - Pointer to the stream request block


Return Value:

    None.

--*/

{

    PIRP pIrp;
    PIRB pIrb;
    PDCAM_EXTENSION pDevExt;
    PSTREAMEX pStrmEx;
    NTSTATUS Status, StatusWait;

    PAGED_CODE();

    pIrb = (PIRB) pSrb->SRBExtension;
    ASSERT(pIrb);
    pDevExt = (PDCAM_EXTENSION) pSrb->HwDeviceExtension;
    ASSERT(pDevExt);


    //
    // Set this to stop accepting incoming read.
    //

    pDevExt->bDevRemoved = TRUE;


    //
    // Wait for currect read to be attached so we cancel them all.
    //

    pStrmEx = pDevExt->pStrmEx;
    if(pStrmEx) {
        // Make sure that this structure is still valid.
        if(pStrmEx->pVideoInfoHeader) {
            StatusWait = KeWaitForSingleObject( &pStrmEx->hMutex, Executive, KernelMode, FALSE, 0 );
            KeReleaseMutex(&pStrmEx->hMutex, FALSE);
        }
    }

    pIrp = IoAllocateIrp(pDevExt->BusDeviceObject->StackSize, FALSE);
    if(!pIrp) {
        ERROR_LOG(("DCamSurpriseRemovalPacket: faile to get resource; pIrb=%x, pDevExt=%x, pIrp\n", pIrb, pDevExt, pIrp));
        pSrb->Status = STATUS_INSUFFICIENT_RESOURCES;
        StreamClassDeviceNotification(DeviceRequestComplete, pSrb->HwDeviceExtension, pSrb);
        return;
    }


    //
    // un-register a bus reset callback notification
    //

    pIrb->FunctionNumber = REQUEST_BUS_RESET_NOTIFICATION;
    pIrb->Flags = 0;
    pIrb->u.BusResetNotification.fulFlags = DEREGISTER_NOTIFICATION_ROUTINE;
    pIrb->u.BusResetNotification.ResetRoutine = (PBUS_BUS_RESET_NOTIFICATION) DCamBusResetNotification;
    pIrb->u.BusResetNotification.ResetContext = 0;
    Status = DCamSubmitIrpSynch(pDevExt, pIrp, pIrb);
    if(Status) {
        ERROR_LOG(("DCamSurpriseRemoval: Status %x while trying to deregister bus reset notification.\n", Status));
    }


    //
    // Get new generation number
    //

    pIrb->FunctionNumber = REQUEST_GET_GENERATION_COUNT;
    pIrb->Flags = 0;
    Status = DCamSubmitIrpSynch(pDevExt, pIrp, pIrb);
    if(Status) {
        ERROR_LOG(("DCamSurpriseRemoval: Status %x while trying to get generation number.\n", Status));
    } else {
        DbgMsg1(("DCamSurpriseRemoval: pDevExt %x, Generation number from %d to %d\n",
            pDevExt, pDevExt->CurrentGeneration, pIrb->u.GetGenerationCount.GenerationCount));
        InterlockedExchange(&pDevExt->CurrentGeneration, pIrb->u.GetGenerationCount.GenerationCount);
    }


    if(pStrmEx) {
        //
        // Stop isoch transmission so we can detach buffers and cancel pending SRBs
        //
        pIrb->FunctionNumber        = REQUEST_ISOCH_STOP;
        pIrb->Flags                 = 0;
        pIrb->u.IsochStop.hResource = pDevExt->hResource;
        pIrb->u.IsochStop.fulFlags  = 0;
        Status = DCamSubmitIrpSynch(pDevExt, pIrp, pIrb);
        if(Status) {
            ERROR_LOG(("DCamSurpriseRemoval: Status %x while trying to ISOCH_STOP.\n", Status));
        }
        IoFreeIrp(pIrp);

        DCamCancelAllPackets(
            pSrb,
            pDevExt,
            &pDevExt->PendingReadCount
            );

    } else {
        IoFreeIrp(pIrp);
        StreamClassDeviceNotification(DeviceRequestComplete, pSrb->HwDeviceExtension, pSrb);
    }

}


NTSTATUS
DCamAttachBufferCR(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrp,
    IN PISOCH_DESCRIPTOR IsochDescriptor
    )
/*++

Routine Description:

    This routine is the completion routine from attaching a bufffer to lower driver.

Arguments:

    DriverObject - Pointer to driver object created by system.

    pIrp - Irp that just completed

    pDCamIoContext - A structure that contain the context of this IO completion routine.

Return Value:

    None.

--*/

{
    PHW_STREAM_REQUEST_BLOCK pSrb;
    PDCAM_EXTENSION pDevExt;
    PSTREAMEX pStrmEx;
    NTSTATUS Status;
    PIRB pIrb;
    PISOCH_DESCRIPTOR_RESERVED IsochDescriptorReserved;
    KIRQL oldIrql;


    pDevExt = (PDCAM_EXTENSION) IsochDescriptor->Context1;
    ASSERT(pDevExt);
    pStrmEx = (PSTREAMEX) pDevExt->pStrmEx;
    ASSERT(pStrmEx);
    IsochDescriptorReserved = (PISOCH_DESCRIPTOR_RESERVED) &IsochDescriptor->DeviceReserved[0];
    ASSERT(IsochDescriptorReserved);
    pSrb    = IsochDescriptorReserved->Srb;
    ASSERT(pSrb);
    pIrb    = (PIRB) pSrb->SRBExtension;

    DbgMsg3(("\'DCamAttachBufferCR: completed KSSTATE=%d; pIrp->IoStatus.Status=%x; pSrb=%x\n",
        pStrmEx->KSState, pIrp->IoStatus.Status, pSrb));


    //
    // Attaching a buffer return with error.
    //
    if(pIrp->IoStatus.Status) {

        ERROR_LOG(("DCamAttachBufferCR: pIrp->IoStatus.Status=%x (STATUS_PENDING=%x); complete SRB with this status.\n",
             pIrp->IoStatus.Status, STATUS_PENDING));
        ASSERT(pIrp->IoStatus.Status == STATUS_SUCCESS);


        if(!(IsochDescriptorReserved->Flags & STATE_SRB_IS_COMPLETE)) {

            ASSERT(((IsochDescriptorReserved->Flags & STATE_SRB_IS_COMPLETE) != STATE_SRB_IS_COMPLETE));

            IsochDescriptorReserved->Flags |= STATE_SRB_IS_COMPLETE;
            pSrb->Status = pIrp->IoStatus.Status;  // Read is completed with error status.

            KeAcquireSpinLock(&pDevExt->IsochDescriptorLock, &oldIrql);
            RemoveEntryList(&IsochDescriptorReserved->DescriptorList);  InterlockedDecrement(&pDevExt->PendingReadCount);
            KeReleaseSpinLock(&pDevExt->IsochDescriptorLock, oldIrql);

            ExFreePool(IsochDescriptor);
            StreamClassStreamNotification(StreamRequestComplete, pSrb->StreamObject, pSrb);

            KeAcquireSpinLock(&pDevExt->IsochWaitingLock, &oldIrql);

            //
            // If we failed to attach (rtn with failed status),
            // removed this entry, and
            // pull one out of the waiting list if not yet exceeded out limit.
            //
            if (!IsListEmpty(&pDevExt->IsochWaitingList) && pDevExt->PendingReadCount >= MAX_BUFFERS_SUPPLIED) {

                //
                // We had someone blocked waiting for us to complete.  Pull
                // them off the waiting list and get them running
                //
                DbgMsg3(("\'DCamAttachBufferCR: Dequeueing request - Read Count=%d\n", pDevExt->PendingReadCount));
                IsochDescriptorReserved = \
                    (PISOCH_DESCRIPTOR_RESERVED) RemoveHeadList(
                       &pDevExt->IsochWaitingList
                        );

                KeReleaseSpinLock(&pDevExt->IsochWaitingLock, oldIrql);

                IsochDescriptor = \
                    (PISOCH_DESCRIPTOR) (((PUCHAR) IsochDescriptorReserved) -
                        FIELDOFFSET(ISOCH_DESCRIPTOR, DeviceReserved[0]));
                DCamReadStreamWorker(IsochDescriptorReserved->Srb, IsochDescriptor);
            } else {
                KeReleaseSpinLock(&pDevExt->IsochWaitingLock, oldIrql);
            }

        } else {

            // Race condition ?  or a valid error code?
            ERROR_LOG(("DCamAttachBufferCR: IsochDescriptorReserved->Flags contain STATE_SRB_IS_COMPLETE\n"));
            ASSERT(FALSE);
        }

    }


    //
    // Ealier when we set to RUN state, it might have failed with
    // STATUS_INSUFFICIENT_RESOURCE due to no buffer attached;
    // we have at least one now, ask controll to start listen and
    // fill and return our buffer.
    //
    if(pDevExt->bNeedToListen) {
        PIRB pIrb2;
        PIRP pIrp2;
        PDCAM_IO_CONTEXT pDCamIoContext;
        PIO_STACK_LOCATION NextIrpStack;


        if(!DCamAllocateIrbIrpAndContext(&pDCamIoContext, &pIrb2, &pIrp2, pDevExt->BusDeviceObject->StackSize)) {
            ERROR_LOG(("DCamAttachBufferCR: Want to stat Listening but no resource !!\n"));
            return STATUS_MORE_PROCESSING_REQUIRED;
        }
        pDevExt->bNeedToListen = FALSE;
        DbgMsg2(("\'DCamAttachBufferCR: ##### pDevExt->bNeedToListen\n"));
        pDCamIoContext->pDevExt     = pDevExt;
        pDCamIoContext->pIrb        = pIrb2;

        pIrb2->FunctionNumber = REQUEST_ISOCH_LISTEN;
        pIrb2->Flags = 0;
        pIrb2->u.IsochListen.hResource = pDevExt->hResource;
        pIrb2->u.IsochListen.fulFlags = 0;

        NextIrpStack = IoGetNextIrpStackLocation(pIrp2);
        NextIrpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        NextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_1394_CLASS;
        NextIrpStack->Parameters.Others.Argument1 = pIrb2;

        pDevExt->lRetries = RETRY_COUNT;

        IoSetCompletionRoutine(
            pIrp2,
            DCamStartListenCR,
            pDCamIoContext,
            TRUE,
            TRUE,
            TRUE
            );

        Status =
            IoCallDriver(
                pDevExt->BusDeviceObject,
                pIrp2);
    }

    // No resource to freed.
    // Resource (pIrb is from original SRB)


    return STATUS_MORE_PROCESSING_REQUIRED;

    //
    // The attached SRB read will be completed in IoschCallback().
    //
}

NTSTATUS
DCamReSubmitPacketCR(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrp,
    IN PISOCH_DESCRIPTOR IsochDescriptor
    )
/*++

Routine Description:

    This routine is called after a packet is detach and
    will be attached here to complete the resubmission of
    packet after a isoch. resource change.

Arguments:

    DriverObject - Pointer to driver object created by system.
    pIrp - Irp that just completed
    pDCamIoContext - A structure that contain the context of this IO completion routine.

Return Value:

    None.

--*/

{
    PIRB pIrb;
    PIO_STACK_LOCATION NextIrpStack;
    PDCAM_EXTENSION pDevExt;
    PISOCH_DESCRIPTOR_RESERVED IsochDescriptorReserved;
    NTSTATUS Status;



    pDevExt = IsochDescriptor->Context1;
    ASSERT(pDevExt);

    pIrb = (PIRB) IsochDescriptor->DeviceReserved[6];
    ASSERT(pIrb);

    IsochDescriptorReserved = (PISOCH_DESCRIPTOR_RESERVED) &IsochDescriptor->DeviceReserved[0];

    //
    // Detached, so unmark it.
    //

    IsochDescriptorReserved->Flags &= ~STATE_DETACHING_BUFFERS;

    DbgMsg2(("\'DCamReSubmitPacketCR: ReSubmit pDevExt %x, pIrb %x, hResource %x, IsochDescriptor %x, IsochDescriptorReserved %x\n",
        pDevExt, pIrb, pDevExt->hResource, IsochDescriptor, IsochDescriptorReserved));


#if DBG
    //
    // Put signatures and use these count to track if the IsochDescriptor
    // has been attached or detached unexpectely.
    //
    // When attach, [4]++  (DCamReadStreamWorker(), DCamReSumbitPacketCR())
    //      detach, [7]++  (DCamIsochcallback(), DCamCancelPacketCR(), DCamResubmitPacket())
    //

    IsochDescriptor->DeviceReserved[4] = 0x12345678;
    IsochDescriptor->DeviceReserved[7] = 0x87654321;
#endif

    //
    // Attach descriptor onto our pending descriptor list
    //

    ExInterlockedInsertTailList(
       &pDevExt->IsochDescriptorList,
       &IsochDescriptorReserved->DescriptorList,
       &pDevExt->IsochDescriptorLock
       );

    pIrb->FunctionNumber           = REQUEST_ISOCH_ATTACH_BUFFERS;
    pIrb->Flags                    = 0;
    pIrb->u.IsochAttachBuffers.hResource = pDevExt->hResource;
    pIrb->u.IsochAttachBuffers.nNumberOfDescriptors = 1;
    pIrb->u.IsochAttachBuffers.pIsochDescriptor = IsochDescriptor;

    NextIrpStack = IoGetNextIrpStackLocation(pIrp);
    NextIrpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    NextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_1394_CLASS;
    NextIrpStack->Parameters.Others.Argument1 = pIrb;


    IoSetCompletionRoutine(
        pIrp,
        DCamAttachBufferCR,
        IsochDescriptor,
        TRUE,
        TRUE,
        TRUE
        );

    Status =
        IoCallDriver(
            pDevExt->BusDeviceObject,
            pIrp
            );

    ASSERT(Status == STATUS_SUCCESS || Status == STATUS_PENDING);

    return STATUS_MORE_PROCESSING_REQUIRED;  // Complete Asynchronously in DCamAttachBufferCR

}


NTSTATUS
DCamReSubmitPacket(
    HANDLE hStaleResource,
    PDCAM_EXTENSION pDevExt,
    PSTREAMEX pStrmEx,
    LONG cntPendingRead
    )

/*++

Routine Description:

    Due to a bus reset, if a channel number has changed (subsequently, iso resource
    change too), we must detach and re-attach pending packet(s).
    While this function is executed, incoming SRB_READ is blocked and isoch callback
    are returned and not processed (we are resubmiting them).

Arguments:

    hStaleResource - staled isoch resource
    pDevExt - Device's Extension
    pStrmEx - Stremaing extension
    cntPendingRead - Number of pending packets

Return Value:

    NTSTATUS.

--*/

{
    PIRB pIrb;
    PIRP pIrp;
    PIO_STACK_LOCATION NextIrpStack;
    PISOCH_DESCRIPTOR IsochDescriptor;
    PISOCH_DESCRIPTOR_RESERVED IsochDescriptorReserved;
    NTSTATUS Status = STATUS_SUCCESS;
    KIRQL oldIrql;


    DbgMsg1(("DCamReSubmitPacket: pDevExt %x, pStrmEx %x, PendingCount %d\n", pDevExt, pStrmEx, cntPendingRead));

    for(; cntPendingRead > 0; cntPendingRead--) {

        if(!IsListEmpty(&pDevExt->IsochDescriptorList)) {

            //
            // Synchronization note:
            //
            // We are competing with cancel packet routine in the
            // event of device removal or setting to STOP state.
            // which ever got the spin lock to set DEATCH_BUFFER
            // flag take ownership completing the Irp/IsochDescriptor.
            //

            KeAcquireSpinLock(&pDevExt->IsochDescriptorLock, &oldIrql);
            IsochDescriptorReserved = (PISOCH_DESCRIPTOR_RESERVED) RemoveHeadList(&pDevExt->IsochDescriptorList);

            if((IsochDescriptorReserved->Flags & (STATE_SRB_IS_COMPLETE | STATE_DETACHING_BUFFERS))) {
                ERROR_LOG(("DCamReSubmitPacket: Flags %x aleady mark STATE_SRB_IS_COMPLETE | STATE_DETACHING_BUFFERS\n", IsochDescriptorReserved->Flags));
                ASSERT(( !(IsochDescriptorReserved->Flags & (STATE_SRB_IS_COMPLETE | STATE_DETACHING_BUFFERS))));\
                //Put it back since it has been detached.
                InsertTailList(&pDevExt->IsochDescriptorList, &IsochDescriptorReserved->DescriptorList);

                KeReleaseSpinLock(&pDevExt->IsochDescriptorLock, oldIrql);
                continue;
            }
            IsochDescriptorReserved->Flags |= STATE_DETACHING_BUFFERS;
            KeReleaseSpinLock(&pDevExt->IsochDescriptorLock, oldIrql);

            IsochDescriptor = (PISOCH_DESCRIPTOR) (((PUCHAR) IsochDescriptorReserved) - FIELDOFFSET(ISOCH_DESCRIPTOR, DeviceReserved[0]));

            pIrp = (PIRP) IsochDescriptor->DeviceReserved[5];
            ASSERT(pIrp);
            pIrb = (PIRB) IsochDescriptor->DeviceReserved[6];
            ASSERT(pIrb);


            DbgMsg1(("DCamReSubmitPacket: detaching IsochDescriptor %x IsochDescriptorReserved %x, pSrb %x\n",
                        IsochDescriptor, IsochDescriptorReserved, IsochDescriptorReserved->Srb));

#if DBG
            // Should not have been detached
            ASSERT((IsochDescriptor->DeviceReserved[7] == 0x87654321));
            IsochDescriptor->DeviceReserved[7]++;
#endif
            pIrb->FunctionNumber           = REQUEST_ISOCH_DETACH_BUFFERS;
            pIrb->Flags                    = 0;
            pIrb->u.IsochDetachBuffers.hResource = hStaleResource;
            pIrb->u.IsochDetachBuffers.nNumberOfDescriptors = 1;
            pIrb->u.IsochDetachBuffers.pIsochDescriptor = IsochDescriptor;

            NextIrpStack = IoGetNextIrpStackLocation(pIrp);
            NextIrpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
            NextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_1394_CLASS;
            NextIrpStack->Parameters.Others.Argument1 = pIrb;

            IoSetCompletionRoutine(
                pIrp,
                DCamReSubmitPacketCR,
                IsochDescriptor,
                TRUE,
                TRUE,
                TRUE
                );

            Status =
                IoCallDriver(
                    pDevExt->BusDeviceObject,
                    pIrp
                    );

            ASSERT(Status == STATUS_SUCCESS || Status == STATUS_PENDING);

        } else {
            ERROR_LOG(("PendingCount %d, but list is empty!!\n", cntPendingRead));
            ASSERT(cntPendingRead == 0);
        }

    }  // for()

    return Status;
}



VOID
DCamReadStreamWorker(
    IN PHW_STREAM_REQUEST_BLOCK pSrb,
    IN PISOCH_DESCRIPTOR IsochDescriptor
    )

/*++

Routine Description:

    Does most of the work for handling reads via Attach buffers

Arguments:

    Srb - Pointer to Stream request block

    IsochDescriptor - Pointer to IsochDescriptor to be used

Return Value:

    Nothing

--*/

{

    PIRB pIrb;
    PIRP pIrp;
    PIO_STACK_LOCATION NextIrpStack;
    PDCAM_EXTENSION pDevExt;
    PISOCH_DESCRIPTOR_RESERVED IsochDescriptorReserved;
    NTSTATUS Status;


    pDevExt = (PDCAM_EXTENSION) pSrb->HwDeviceExtension;
    pIrp = (PIRP) IsochDescriptor->DeviceReserved[5];
    ASSERT(pIrp);
    pIrb = (PIRB) IsochDescriptor->DeviceReserved[6];
    ASSERT(pIrb);
#if DBG
    // track number time the same IsochDescriptor are attaching; should only be one.
    IsochDescriptor->DeviceReserved[4]++;
#endif

    //
    // It is pending and will be completed in isoch callback or cancelled.
    //

    pSrb->Status = STATUS_PENDING;

    IsochDescriptorReserved = (PISOCH_DESCRIPTOR_RESERVED) &IsochDescriptor->DeviceReserved[0];

    DbgMsg3(("\'DCamReadStreamWorker: enter with pSrb = %x, pDevExt=0x%x\n", pSrb, pDevExt));

    //
    // Attach descriptor onto our pending descriptor list
    //

    ExInterlockedInsertTailList(
       &pDevExt->IsochDescriptorList,
       &IsochDescriptorReserved->DescriptorList,
       &pDevExt->IsochDescriptorLock
       );

    pIrb->FunctionNumber           = REQUEST_ISOCH_ATTACH_BUFFERS;
    pIrb->Flags                    = 0;
    pIrb->u.IsochAttachBuffers.hResource = pDevExt->hResource;
    pIrb->u.IsochAttachBuffers.nNumberOfDescriptors = 1;
    pIrb->u.IsochAttachBuffers.pIsochDescriptor = IsochDescriptor;

    NextIrpStack = IoGetNextIrpStackLocation(pIrp);
    NextIrpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    NextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_1394_CLASS;
    NextIrpStack->Parameters.Others.Argument1 = pIrb;


    IoSetCompletionRoutine(
        pIrp,
        DCamAttachBufferCR,
        IsochDescriptor,
        TRUE,
        TRUE,
        TRUE
        );

    Status =
        IoCallDriver(
            pDevExt->BusDeviceObject,
            pIrp
            );

    ASSERT(Status == STATUS_SUCCESS || Status == STATUS_PENDING);

    return;  // Complete Asynchronously in IoCompletionRoutine*
}




VOID
DCamReadStream(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    Called when an Read Data Srb request is received

Arguments:

    Srb - Pointer to Stream request block

Return Value:

    Nothing

--*/

{

    PIRB pIrb;
    PIRP pIrp;
    KIRQL oldIrql;
    PDCAM_EXTENSION pDevExt;
    PSTREAMEX     pStrmEx;
    PISOCH_DESCRIPTOR IsochDescriptor;
    PISOCH_DESCRIPTOR_RESERVED IsochDescriptorReserved;
    NTSTATUS StatusWait;


    pIrb = (PIRB) Srb->SRBExtension;
    pDevExt = (PDCAM_EXTENSION) Srb->HwDeviceExtension;
    ASSERT(pDevExt != NULL);



    pStrmEx = (PSTREAMEX) pDevExt->pStrmEx;
    ASSERT(pStrmEx);

    if(pDevExt->bDevRemoved ||
       pStrmEx == NULL) {

        Srb->Status = pDevExt->bDevRemoved ? STATUS_DEVICE_REMOVED : STATUS_UNSUCCESSFUL;
        Srb->ActualBytesTransferred = 0;
        Srb->CommandData.DataBufferArray->DataUsed = 0;
        ERROR_LOG(("DCamReadStream: Failed with Status %x or pStrmEx %x\n", Srb->Status, pStrmEx));

        StreamClassStreamNotification(StreamRequestComplete, Srb->StreamObject, Srb);
        return;
    }

    //
    // Mutext for either StreamIo (SRB_READ) ControlIo (SRB_SET_STREAM_STATE)
    //
    // Non-alertable; wait infinite

    StatusWait = KeWaitForSingleObject( &pStrmEx->hMutex, Executive, KernelMode, FALSE, 0 );
    ASSERT(StatusWait == STATUS_SUCCESS);

    DbgMsg3(("\'%d:%s) DCamReadStream: enter with Srb %x, DevExt %x\n",
            pDevExt->idxDev, pDevExt->pchVendorName, Srb, pDevExt));


    // Rule:
    // Only accept read requests when in either the Pause or Run
    // States.  If Stopped, immediately return the SRB.

    if (pStrmEx->KSState == KSSTATE_STOP ||
        pStrmEx->KSState == KSSTATE_ACQUIRE) {

        DbgMsg2(("\'%d:%s)DCamReadStream: Current KSState(%d) < (%d)=KSSTATE_PAUSE; Srb=0x%x; DevExt=0x%x",
                 pDevExt->idxDev, pDevExt->pchVendorName, pStrmEx->KSState,  KSSTATE_PAUSE, Srb, pDevExt));

        DbgMsg2(("\'DCamReadStream: PendingRead=%d, IsochDescriptorList(%s)\n",
              pDevExt->PendingReadCount, IsListEmpty(&pDevExt->IsochDescriptorList)?"Empty":"!Empty"));

        Srb->Status = STATUS_UNSUCCESSFUL;
        Srb->CommandData.DataBufferArray->DataUsed = 0;
        StreamClassStreamNotification(StreamRequestComplete, Srb->StreamObject, Srb);

        KeReleaseMutex(&pStrmEx->hMutex, FALSE);

        return;
    }


    // Buffer need to be big enough
    if (IsochInfoTable[pStrmEx->idxIsochTable].CompletePictureSize > Srb->CommandData.DataBufferArray->FrameExtent) {

        ASSERT(IsochInfoTable[pStrmEx->idxIsochTable].CompletePictureSize <= Srb->CommandData.DataBufferArray->FrameExtent);
        Srb->Status = STATUS_INVALID_PARAMETER;
        StreamClassStreamNotification(StreamRequestComplete, Srb->StreamObject, Srb);

        KeReleaseMutex(&pStrmEx->hMutex, FALSE);

        return;
    }


    //
    // Use our own IRP
    //
    pIrp = IoAllocateIrp(pDevExt->BusDeviceObject->StackSize, FALSE);
    if(!pIrp) {
        ASSERT(pIrp);
        Srb->Status = STATUS_INSUFFICIENT_RESOURCES;
        return;
    }

    //
    // This structure (IsochDescriptor) has (ULONG) DeviceReserved[8];
    // Its first 4 ULONGs are used by IsochDescriptorReserved,
    // The 6th (index[5]), is used to keep pIrp
    //     7th (index[6]), is used to keep pIrb
    //

    IsochDescriptor = ExAllocatePoolWithTag(NonPagedPool, sizeof(ISOCH_DESCRIPTOR), 'macd');
    if (!IsochDescriptor) {

        ASSERT(FALSE);
        Srb->Status = STATUS_INSUFFICIENT_RESOURCES;
        StreamClassStreamNotification(StreamRequestComplete, Srb->StreamObject, Srb);

        KeReleaseMutex(&pStrmEx->hMutex, FALSE);

        return;
    }


    DbgMsg3(("\'DCamReadStream: IsochDescriptor = %x\n", IsochDescriptor));
    IsochDescriptor->fulFlags = SYNCH_ON_SY;

    DbgMsg3(("\'DCamReadStream: Incoming Mdl = %x\n", Srb->Irp->MdlAddress));
    IsochDescriptor->Mdl = Srb->Irp->MdlAddress;

    // Use size match what we originally requested in AllocateIsoch
    IsochDescriptor->ulLength = IsochInfoTable[pStrmEx->idxIsochTable].CompletePictureSize;
    IsochDescriptor->nMaxBytesPerFrame = IsochInfoTable[pStrmEx->idxIsochTable].QuadletPayloadPerPacket << 2;

    IsochDescriptor->ulSynch = START_OF_PICTURE;
    IsochDescriptor->ulTag = 0;
    IsochDescriptor->Callback = DCamIsochCallback;
    IsochDescriptor->Context1 = pDevExt;
    IsochDescriptor->Context2 = IsochDescriptor;

    //
    // IsochDescriptorReserved is pointed to the DeviceReserved[0];
    // The entire, except the links, are kept in the DeviceReserved[]
    //

    IsochDescriptorReserved = (PISOCH_DESCRIPTOR_RESERVED) &IsochDescriptor->DeviceReserved[0];
    IsochDescriptorReserved->Srb = Srb;
    IsochDescriptorReserved->Flags = 0;

    IsochDescriptor->DeviceReserved[5] = (ULONG_PTR) pIrp;
    IsochDescriptor->DeviceReserved[6] = (ULONG_PTR) pIrb;

#if DBG
    //
    // Put signatures and use these count to track if the IsochDescriptor
    // has been attached or detached unexpectely.
    //
    // When attach, [4]++  (DCamReadStreamWorker(), DCamReSumbitPacketCR())
    //      detach, [7]++  (DCamIsochcallback(), DCamCancelPacketCR(), DCamResubmitPacket())
    //

    IsochDescriptor->DeviceReserved[4] = 0x12345678;
    IsochDescriptor->DeviceReserved[7] = 0x87654321;
#endif

    //
    // Checking here to see if we have enuff resources to put this read
    // down right away.  Since we only allocated N amount of resources
    // from the 1394 stack beneath us, we'll have to stay within that
    // limit and do some of the throttling ourself.
    //

    KeAcquireSpinLock(&pDevExt->IsochWaitingLock, &oldIrql);
    if (InterlockedIncrement(&pDevExt->PendingReadCount) > MAX_BUFFERS_SUPPLIED) {

        //
        // don't have enuff resources to do an attach buffers right now.
        // we'll queue this request and pull it off later when another
        // read completes.
        //

        DbgMsg2(("\'DCamReadStream: Queueing request - Read Count = %x\n", pDevExt->PendingReadCount));
        InsertTailList(
           &pDevExt->IsochWaitingList,
           &IsochDescriptorReserved->DescriptorList
           );

        KeReleaseSpinLock(&pDevExt->IsochWaitingLock, oldIrql);

        KeReleaseMutex(&pStrmEx->hMutex, FALSE);

        return;

    }

    if(pStrmEx->KSState == KSSTATE_PAUSE) {
        DbgMsg2(("\'DCamReadStream: Doing Pre-read in _PAUSE state; Srb %x, pDevExt %x, PendingCount %d\n",
                 Srb, pDevExt, pDevExt->PendingReadCount));
    }

    //
    // Do actual read work here via our Read worker function
    //

    KeReleaseSpinLock(&pDevExt->IsochWaitingLock, oldIrql);
    DCamReadStreamWorker(Srb, IsochDescriptor);

    KeReleaseMutex(&pStrmEx->hMutex, FALSE);

}

VOID
DCamReceiveDataPacket(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    Called with video data packet commands

Arguments:

    Srb - Pointer to Stream request block

Return Value:

    Nothing

--*/

{
    PAGED_CODE();

    //
    // determine the type of packet.
    //

    switch (Srb->Command) {

    case SRB_READ_DATA:

         DbgMsg3(("\'DCamReceiveDataPacket: SRB_READ_DATA\n"));
         DCamReadStream(Srb);

         // This request will be completed asynchronously...

         break;

    case SRB_WRITE_DATA:

         DbgMsg3(("\'DCamReceiveDataPacket: SRB_WRITE_DATA, not used for digital camera.\n"));
         ASSERT(FALSE);

    default:

         //
         // invalid / unsupported command. Fail it as such
         //

         Srb->Status = STATUS_NOT_IMPLEMENTED;

         StreamClassStreamNotification(StreamRequestComplete, Srb->StreamObject, Srb);

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\1394dcam\dbg.h ===
//===========================================================================
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
// PURPOSE.
//
// Copyright (c) 1996 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//===========================================================================
/*++

Module Name:

    dbg.h

Abstract:

    Debug Code for 1394 drivers.

Environment:

    kernel mode only

Notes:

Revision History:

    5-Sep-95

--*/



//
// Various definitions
//


#if DBG

ULONG DCamDebugLevel;

#define ERROR_LOG(_x_)           KdPrint(_x_);

// Critical
#define DbgMsg1(_x_)        {if (DCamDebugLevel >= 1) \
                                KdPrint (_x_);}
// Warning/trace
#define DbgMsg2(_x_)        {if (DCamDebugLevel >= 2) \
                                KdPrint (_x_);}
// Information
#define DbgMsg3(_x_)        {if (DCamDebugLevel >= 3) \
                                KdPrint (_x_);}
#else

#define ERROR_LOG(_x_)    
#define DbgMsg1(_x_)
#define DbgMsg2(_x_)
#define DbgMsg3(_x_)

#endif
          
          

//
// Function declarations
//
VOID
Debug_Assert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message
    );

VOID 
Debug_LogEntry(
    IN CHAR *Name, 
    IN ULONG Info1, 
    IN ULONG Info2, 
    IN ULONG Info3
    );

VOID
Debug_LogInit(
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\1394dcam\dbg.c ===
//===========================================================================
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
// PURPOSE.
//
// Copyright (c) 1996 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//===========================================================================
/*++

Module Name:

    dbg.c

Abstract:

    Debug Code for 1394 drivers.

Environment:

    kernel mode only

Notes:

Revision History:

    5-Sep-95

--*/

#include "wdm.h"
#include "dbg.h"


#if DBG

struct LOG_ENTRY {
    CHAR     le_name[4];      // Identifying string
    ULONG    le_info1;        // entry specific info
    ULONG    le_info2;        // entry specific info
    ULONG    le_info3;        // entry specific info
}; 


struct LOG_ENTRY *LogStart = 0;    // No log yet
struct LOG_ENTRY *LogPtr;
struct LOG_ENTRY *LogEnd;


#endif


VOID 
Debug_LogEntry(
    IN CHAR *Name, 
    IN ULONG Info1, 
    IN ULONG Info2, 
    IN ULONG Info3
    )

/*++

Routine Description:

    Adds an Entry to log.

Arguments:

Return Value:

    None.

--*/
{

#if DBG

    if (LogStart == 0)
        return;

    if (LogPtr > LogStart)
        LogPtr -= 1;    // Decrement to next entry
    else
        LogPtr = LogEnd;

    RtlCopyMemory(LogPtr->le_name, Name, 4);
    LogPtr->le_info1 = Info1;
    LogPtr->le_info2 = Info2;
    LogPtr->le_info3 = Info3;

#endif

    return;
}

VOID
Debug_LogInit(
    )

/*++

Routine Description:

    Init the debug log - remember interesting information in a circular buffer

Arguments:
    
Return Value:

    None.

--*/
{
    ULONG logSize = 4096;    //1 page of log entries

#if DBG

    LogStart = ExAllocatePoolWithTag(NonPagedPool, logSize, 'macd'); 

    if (LogStart) {
        LogPtr = LogStart;

        // Point the end (and first entry) 1 entry from the end of the segment
        LogEnd = LogStart + (logSize / sizeof(struct LOG_ENTRY)) - 1;
    }

#endif

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\1394dcam\dcampkt.h ===
//===========================================================================
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
// PURPOSE.
//
// Copyright (c) 1996 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//===========================================================================
/*++

Module Name:

    dcampkt.h

Abstract:

    Header file for dcampkt.c

Author:
    
    Shaun Pierce 25-May-96

Environment:

    Kernel mode only

Revision History:


--*/


//
// Function prototypes
//

void 
tmGetStreamTime(
    IN PHW_STREAM_REQUEST_BLOCK Srb,
    PSTREAMEX pStrmEx, 
    ULONGLONG * ptmStream
    );

BOOL
DCamAllocateIrbAndIrp(
    PIRB * ppIrb,
    PIRP * ppIrp,
    CCHAR StackSize
    );

BOOL
DCamAllocateIrbIrpAndContext(
    PDCAM_IO_CONTEXT * ppDCamIoContext,
    PIRB * ppIrb,
    PIRP * ppIrp,
    CCHAR StackSize
    );

void
DCamFreeIrbIrpAndContext(
    PDCAM_IO_CONTEXT pDCamIoContext,
    PIRB pIrb,
    PIRP pIrp   
    );

BOOL
DCamIsoEnable(
    PIRB pIrb,
    PDCAM_EXTENSION pDevExt,
    BOOL Enable  
    );

VOID
DCamCancelAllPackets(
    PHW_STREAM_REQUEST_BLOCK pSrb,
    PDCAM_EXTENSION pDevExt,
    LONG *plPendingReadCount    
    );

VOID
DCamSurpriseRemoval(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    );


VOID
DCamTimeoutHandler(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    );

VOID
DCamReceivePacket(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    );

VOID
DCamGetStreamInfo(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    );

NTSTATUS
DCamAllocateIsochResource(
    PDCAM_EXTENSION pDevExt,
    PIRB Irb,
    BOOL bAllocateResource
    );

NTSTATUS
DCamFreeIsochResource(    
    PDCAM_EXTENSION pDevExt,
    PIRB Irb,
    BOOL bFreeResource
    );

VOID
DCamOpenStream(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    );

VOID
DCamCloseStream(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    );

VOID
DCamReceiveDataPacket(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    );

VOID
DCamReceiveCtrlPacket(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    );

VOID
DCamReadStream(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    );

VOID
DCamReadStreamWorker(
    IN PHW_STREAM_REQUEST_BLOCK Srb,
    IN PISOCH_DESCRIPTOR IsochDescriptor
    );



VOID
DCamIsochCallback(
    IN PVOID Context1,
    IN PVOID Context2
    );

NTSTATUS
DCamDetachBufferCR(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
DCamStartListenCR(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID SystemArgument
    );

VOID
DCamSetKSStateSTOP(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    );

BOOL 
AdapterCompareGUIDsAndFormatSize(
    IN PKSDATARANGE DataRange1,
    IN PKSDATARANGE DataRange2
    );

BOOL 
AdapterVerifyFormat(
    ULONG VideoModesSupported,
    PKSDATAFORMAT *pDCamStrmModesSupported,
    PKS_DATAFORMAT_VIDEOINFOHEADER pKSDataFormatToVerify, 
    int StreamNumber
    );

BOOL 
AdapterFormatFromRange(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    );

VOID VideoGetProperty(PHW_STREAM_REQUEST_BLOCK Srb);

VOID VideoGetState(PHW_STREAM_REQUEST_BLOCK Srb);

VOID VideoStreamGetConnectionProperty (PHW_STREAM_REQUEST_BLOCK Srb);

VOID VideoStreamGetDroppedFramesProperty(PHW_STREAM_REQUEST_BLOCK Srb);

VOID VideoIndicateMasterClock (PHW_STREAM_REQUEST_BLOCK Srb);

ULONGLONG GetSystemTime();

VOID
DCamSetKSStatePAUSE(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    );

NTSTATUS
DCamToRunStateCoR(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrp,
    IN PDCAM_IO_CONTEXT pDCamIoContext
    );

VOID
DCamSetKSStateRUN(
    PDCAM_EXTENSION pDevExt,
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    );

NTSTATUS
DCamCancelBufferCR(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrp,
    IN PDCAM_IO_CONTEXT pDCamIoContext
    );

BOOL
DCamDeviceInUse(
    PIRB pIrb,
    PDCAM_EXTENSION pDevExt
    );

void
DCamProcessPnpIrp(
    IN PHW_STREAM_REQUEST_BLOCK Srb,
    PIO_STACK_LOCATION IrpStack,
    PDCAM_EXTENSION pDevExt
    );

VOID 
InitializeStreamExtension(
    PDCAM_EXTENSION pDevExt,
    PHW_STREAM_OBJECT   pStreamObject,
    PSTREAMEX           pStrmEx
    );

BOOL 
AdapterFormatFromRange(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    );

NTSTATUS
DCamReSubmitPacket(
    HANDLE hOldResource,
    PDCAM_EXTENSION pDevExt,
    PSTREAMEX pStrmEx,
    LONG PendingReadCount
    );

NTSTATUS
DCamSetKSStateInitialize(
    PDCAM_EXTENSION pDevExt
    );

VOID 
DCamChangePower(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\1394dcam\capprop.h ===
//===========================================================================
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
// PURPOSE.
//
// Copyright (c) 1996 - 2000  Microsoft Corporation.  All Rights Reserved.
//
//===========================================================================

//
// Function prototypes
//
NTSTATUS
DCamReadRegister(
    IN PIRB Irb,
    PDCAM_EXTENSION pDevExt,
    ULONG ulFieldOffset,
    ULONG * pulValue
);  

NTSTATUS
DCamWriteRegister(
    IN PIRB Irb,
    PDCAM_EXTENSION pDevExt,
    ULONG ulFieldOffset,
    ULONG ulValue
);

BOOL
DCamGetPropertyValuesFromRegistry(
    PDCAM_EXTENSION pDevExt
);

BOOL
DCamGetVideoMode(
    PDCAM_EXTENSION pDevExt,
    PIRB pIrb
    );

BOOL
DCamBuildFormatTable(
    PDCAM_EXTENSION pDevExt,
    PIRB pIrb
    );

BOOL
DCamSetPropertyValuesToRegistry(
    PDCAM_EXTENSION pDevExt
);

BOOL 
DCamPrepareDevProperties(
    PDCAM_EXTENSION pDevExt
    );

VOID
STREAMAPI 
AdapterGetProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID
STREAMAPI 
AdapterSetProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    );

NTSTATUS
DCamGetProperty(
    IN PIRB Irb,
    PDCAM_EXTENSION pDevExt, 
    ULONG ulFieldOffset,
    LONG * plValue, 
    ULONG * pulCapability, 
    ULONG * pulFlags,
    DCamRegArea * pFeature
);

NTSTATUS
DCamSetProperty(
    IN PIRB Irb,
    PDCAM_EXTENSION pDevExt, 
    ULONG ulFieldOffset,
    ULONG ulFlags,
    LONG  lValue,
    DCamRegArea * pFeature,
    DCamRegArea * pCachedRegArea
);  

NTSTATUS
DCamGetRange(
    IN PIRB Irb,
    PDCAM_EXTENSION pDevExt,
    ULONG ulFieldOffset,
    LONG * pMinValue,
    LONG * pMaxValue
);

NTSTATUS
DCamSetAutoMode(
    IN PIRB Irb,
    PDCAM_EXTENSION pDevExt, 
    ULONG ulFieldOffset,
    BOOL bAutoMode
);

VOID
SetCurrentDevicePropertyValues(
    PDCAM_EXTENSION pDevExt,
    PIRB pIrb
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\1394dcam\dcamdef.h ===
//===========================================================================
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
// PURPOSE.
//
// Copyright (c) 1996 - 2000  Microsoft Corporation.  All Rights Reserved.
//
//===========================================================================
/*++

Module Name:

    dcamdef.h

Abstract:

    Header file for constants and structures used for this 1394 desktop camera driver

Author:

    Shaun Pierce 25-May-96

Environment:

    Kernel mode only

Revision History:


--*/

//
// Define this to support YUV444
//
#define SUPPORT_YUV444


//
// Define this to support YUV411
//
#define SUPPORT_YUV411


//
// Define this to support RGB24
// This format is the most expensive to support.
// It requires driver to swap R and B og RGB24.
//
// #define SUPPORT_RGB24


//
// Define this to support YMONO
//
#define SUPPORT_YUV800


//
// Various structure definitions
//

typedef struct _INITIALIZE_REGISTER {
        ULONG       Reserved:31;            // Bits 1-31
        ULONG       Initialize:1;           // Bit 0
} INITIALIZE_REGISTER, *PINITIALIZE_REGISTER;

typedef struct _V_FORMAT_INQ_REGISTER {
        ULONG       Reserved:24;            // Bits 8-31
        ULONG       Format7:1;              // Bit 7       Scaleable Image Size Format
        ULONG       Format6:1;              // Bit 6       Still Image format
        ULONG       FormatRsv:3;            // Bits 3-5    Reserved
        ULONG       Format2:1;              // Bit 2       SVGA non-compressed format(2)
        ULONG       Format1:1;              // Bit 1       SVGA non-compressed format(1)
        ULONG       Format0:1;              // Bit 0       VGA non-compressed format (Max 640x480)
} V_FORMAT_INQ_REGISTER, *PV_FORMAT_INQ_REGISTER;

typedef enum {
    VMODE0_YUV444=0,
    VMODE1_YUV422,
    VMODE2_YUV411,
    VMODE3_YUV422,
    VMODE4_RGB24,    
    VMODE5_YUV800
} VMODE_INQ0;

typedef struct _V_MODE_INQ_REGISTER {
        ULONG       Reserved:24;            // Bits 8-31
        ULONG       ModeX:2;                // Bits 6-7
        ULONG       Mode5:1;                // Bit 5
        ULONG       Mode4:1;                // Bit 4
        ULONG       Mode3:1;                // Bit 3
        ULONG       Mode2:1;                // Bit 2
        ULONG       Mode1:1;                // Bit 1
        ULONG       Mode0:1;                // Bit 0
} V_MODE_INQ_REGISTER; *PV_MODE_INQ_REGISTER;

typedef struct _V_RATE_INQ_REGISTER {
        ULONG       Reserved:24;            // Bits 8-31
        ULONG       FrameRateX:2;           // Bits 6-7
        ULONG       FrameRate5:1;           // Bit 5
        ULONG       FrameRate4:1;           // Bit 4
        ULONG       FrameRate3:1;           // Bit 3
        ULONG       FrameRate2:1;           // Bit 2
        ULONG       FrameRate1:1;           // Bit 1
        ULONG       FrameRate0:1;           // Bit 0
} V_RATE_INQ_REGISTER, *PV_RATE_INQ_REGISTER;


typedef struct _FEATURE_PRESENT1 {
        ULONG       Reserved:21;          // Bits 11-31
        ULONG       Focus:1;               // Bit 10
        ULONG       Iris:1;                // Bit 9
        ULONG       Gain:1;                // Bit 8
        ULONG       Shutter:1;             // Bit 7
        ULONG       Gamma:1;               // Bit 6
        ULONG       Saturation:1;          // Bit 5
        ULONG       Hue:1;                 // Bit 4
        ULONG       White_Balance:1;       // Bit 3
        ULONG       Sharpness:1;           // Bit 2
        ULONG       Exposure:1;            // Bit 1
        ULONG       Brightness:1;          // Bit 0
} FEATURE_PRESENT1, *PFEATURE_PRESENT1;

typedef struct _FEATURE_PRESENT2 {
        ULONG       Reserved:29;           // Bits 3-31
        ULONG       Tile:1;                // Bit 2
        ULONG       Pan:1;                 // Bit 1
        ULONG       Zoom:1;                // Bit 0
} FEATURE_PRESENT2, *PFEATURE_PRESENT2;

typedef struct _FEATURE_REGISTER {
        ULONG       MAX_Value:12;           // Bits 20-31
        ULONG       MIN_Value:12;           // Bits 8-19
        ULONG       ManualMode:1;            // Bit 7
        ULONG       AutoMode:1;             // Bit 6
        ULONG       OnOff:1;                // Bit 5
        ULONG       ReadOut_Inq:1;          // Bit 4
        ULONG       OnePush:1;              // Bit 3
        ULONG       Reserved:2;             // Bits 1-2
        ULONG       PresenceInq:1;          // Bit 0
} FEATURE_REGISTER, *PFEATURE_REGISTER;


typedef struct _BRIGHTNESS_REGISTER {
        ULONG       Value:12;               // Bits 20-31
        ULONG       Reserved1:12;           // Bits 8-19
        ULONG       AutoMode:1;             // Bit 7
        ULONG       OnOff:1;                // Bit 6
        ULONG       OnePush:1;              // Bit 5
        ULONG       Reserved2:4;            // Bits 1-4
        ULONG       PresenceInq:1;          // Bit 0
} BRIGHTNESS_REGISTER, *PBRIGHTNESS_REGISTER;

typedef struct _WHITE_BALANCE_REGISTER {
        ULONG       VValue:12;              // Bits 20-31
        ULONG       UValue:12;              // Bits 8-19
        ULONG       AutoMode:1;             // Bit 7
        ULONG       OnOff:1;                // Bit 6
        ULONG       OnePush:1;              // Bit 5
        ULONG       Reserved1:4;            // Bits 1-4
        ULONG       PresenceInq:1;          // Bit 0
} WHITE_BALANCE_REGISTER, *PWHITE_BALANCE_REGISTER;

// A common structure so it is easier to access its elements.
typedef union _DCamRegArea {

        INITIALIZE_REGISTER Initialize;
        V_FORMAT_INQ_REGISTER VFormat;
        V_MODE_INQ_REGISTER VMode;
        V_RATE_INQ_REGISTER VRate;
        BRIGHTNESS_REGISTER Brightness;
        WHITE_BALANCE_REGISTER WhiteBalance;
        FEATURE_REGISTER Feature;
        FEATURE_PRESENT1 CameraCap1;
        FEATURE_PRESENT2 CameraCap2;
        ULONG AsULONG;

} DCamRegArea, * PDCamRegArea;


//
// Structure of the camera's register space
//

typedef struct _CAMERA_REGISTER_MAP {
    INITIALIZE_REGISTER     Initialize;         // @ 0
    ULONG                   Reserved1[63];      // @ 4
    V_FORMAT_INQ_REGISTER   VFormat;            // @ 100
    ULONG                   Reserved2[31];      // @ 104
    V_MODE_INQ_REGISTER     VModeInq[8];        // @ 180-19f
    ULONG                   Reserved3[24];      // @ 1A0-1ff
    V_RATE_INQ_REGISTER     VRateInq[128];      // @ 200-3ff
    ULONG                   Reserved4;          // @ 400-4ff
    FEATURE_PRESENT1        FeaturePresent1;    // @ 404
    FEATURE_PRESENT2        FeaturePresent2;    // @ 408
    ULONG                   Reserved4b[61];     // @ 40c-4ff

    FEATURE_REGISTER        Brightness_Inq;     // @ 500-503
    FEATURE_REGISTER        Exposure_Inq;       // @ 504
    FEATURE_REGISTER        Sharpness_Inq;      // @ 508
    FEATURE_REGISTER        WhiteBalance_Inq;   // @ 50c
    FEATURE_REGISTER        Hue_Inq;            // @ 510
    FEATURE_REGISTER        Saturation_Inq;     // @ 514
    FEATURE_REGISTER        Gamma_Inq;          // @ 518
    FEATURE_REGISTER        Shutter_Inq;        // @ 51c
    FEATURE_REGISTER        Gain_Inq;           // @ 520
    FEATURE_REGISTER        Iris_Inq;           // @ 524
    FEATURE_REGISTER        Focus_Inq;          // @ 528
    ULONG                   Resreved5[(0x580-0x52c)/4];      // @ 52c-57c
    FEATURE_REGISTER        Zoom_Inq;           // @ 580
    FEATURE_REGISTER        Pan_Inq;            // @ 584
    FEATURE_REGISTER        Tilt_Inq;           // @ 588-58b
    ULONG                   Reserved6[(0x600-0x58c)/4];      // @ 58c-5ff
    // Status and control register for camera
    ULONG                   CurrentVFrmRate;    // @ 600
    ULONG                   CurrentVMode;       // @ 604
    ULONG                   CurrentVFormat;     // @ 608
    ULONG                   IsoChannel;         // @ 60C
    ULONG                   CameraPower;        // @ 610
    ULONG                   IsoEnable;          // @ 614
    ULONG                   MemorySave;         // @ 618
    ULONG                   OneShot;            // @ 61C
    ULONG                   MemorySaveChannel;  // @ 620
    ULONG                   CurrentMemChannel;  // @ 624
    ULONG                   Reserved7[(0x800-0x628)/4];     // @ 628-7ff

    // Status and control register for feature
    BRIGHTNESS_REGISTER     Brightness;         // @ 800
    BRIGHTNESS_REGISTER     Exposure;           // @ 804
    BRIGHTNESS_REGISTER     Sharpness;          // @ 808
    WHITE_BALANCE_REGISTER  WhiteBalance;       // @ 80C
    BRIGHTNESS_REGISTER     Hue;                // @ 810
    BRIGHTNESS_REGISTER     Saturation;         // @ 814
    BRIGHTNESS_REGISTER     Gamma;              // @ 818
    BRIGHTNESS_REGISTER     Shutter;            // @ 81C
    BRIGHTNESS_REGISTER     Gain;               // @ 820
    BRIGHTNESS_REGISTER     Iris;               // @ 824
    BRIGHTNESS_REGISTER     Focus;              // @ 828
    ULONG                   Resreved8[(0x880-0x82c)/4];      // @ 82c-87c
    BRIGHTNESS_REGISTER     Zoom;               // @ 880
    BRIGHTNESS_REGISTER     Pan;                // @ 884
    BRIGHTNESS_REGISTER     Tilt;               // @ 888

} CAMERA_REGISTER_MAP, *PCAMERA_REGISTER_MAP;


//
// To make DCAm start streaming,
// it needs to set all these step.
// We will do them one by one in the
// StartDCam's IoCompletionRoutine
//
typedef enum {
    DCAM_STATE_UNDEFINED = 0,
    DCAM_SET_INITIALIZE,

    DCAM_STOPSTATE_SET_REQUEST_ISOCH_STOP,
    DCAM_STOPSTATE_SET_STOP_ISOCH_TRANSMISSION,

    DCAM_PAUSESTATE_SET_REQUEST_ISOCH_STOP,

    DCAM_RUNSTATE_SET_REQUEST_ISOCH_LISTEN,
    DCAM_RUNSTATE_SET_FRAME_RATE,
    DCAM_RUNSTATE_SET_CURRENT_VIDEO_MODE,
    DCAM_RUNSTATE_SET_CURRENT_VIDEO_FORMAT,
    DCAM_RUNSTATE_SET_SPEED,
    DCAM_RUNSTATE_SET_START,

    DCAM_SET_DONE
} DCAM_DEVICE_STATE, *PDCAM_DEVICE_STATE;


//
// Video formats and modes support
//
#define MAX_VMODES               6  // Support at most 6 modes of V_MODE_INQ_0


//
// Support's property, they are used as the index.
//
#define NUM_VIDEOPROCAMP_ITEMS   5
#define NUM_CAMERACONTROL_ITEMS  2
#define NUM_PROPERTY_ITEMS       NUM_VIDEOPROCAMP_ITEMS + NUM_CAMERACONTROL_ITEMS
typedef enum {
    // VideoProcAmp
    ENUM_BRIGHTNESS = 0,
    ENUM_SHARPNESS,
    ENUM_HUE,
    ENUM_SATURATION,
    ENUM_WHITEBALANCE,
    // CameraControl
    ENUM_FOCUS,
    ENUM_ZOOM,

} ENUM_DEV_PROP;


//
// Structure for each device property
//
typedef struct _DEV_PROPERTY {
    // ReadOnly
    KSPROPERTY_STEPPING_LONG RangeNStep;    // Range from the Feature
    LONG  DefaultValue;                     // Read from the registry or midrange if not in registry
#if 0
    ULONG ulFieldOffset;                    // Offset of where the CSR is located
#endif
    // ReadOnly
    DCamRegArea Feature;                    // Register that contain the feature inquery of a property

    // Read/Write
    DCamRegArea StatusNControl;             // Register that is both R/W (Addr has an 0x300 offset from the Feature's)
} DEV_PROPERTY, * PDEV_PROPERTY;


typedef struct _DEV_PROPERTY_DEFINE {
    KSPROPERTY_VALUES Value;
    KSPROPERTY_MEMBERSLIST Range;
    KSPROPERTY_MEMBERSLIST Default;
} DEV_PROPERTY_DEFINE, *PDEV_PROPERTY_DEFINE;


//
// Device Extension for our 1394 Desktop Camera Driver
//

// Circular pointers DevExt<->StrmEx
typedef struct _STREAMEX;
typedef struct _DCAM_EXTENSION;

//
// Context to keep track in the IO Completion routine.
//
typedef struct _DCAM_IO_CONTEXT {
    DWORD               dwSize;

    PHW_STREAM_REQUEST_BLOCK   pSrb;
    struct _DCAM_EXTENSION *pDevExt;
    PIRB                       pIrb;
    PVOID      pReserved[4];   // Maybe used for extra context information.

    DCAM_DEVICE_STATE   DeviceState;

    //
    // Holds an area for us to read/write camera registers to/from here
    //
    union {
        INITIALIZE_REGISTER Initialize;
        V_FORMAT_INQ_REGISTER VFormat;
        V_MODE_INQ_REGISTER VMode;
        V_RATE_INQ_REGISTER VRate;
        BRIGHTNESS_REGISTER Brightness;
        WHITE_BALANCE_REGISTER WhiteBalance;
              FEATURE_REGISTER Feature;
        ULONG AsULONG;
    } RegisterWorkArea;

} DCAM_IO_CONTEXT, *PDCAM_IO_CONTEXT;



typedef struct _DCAM_EXTENSION {

    //
    // Holds the Device Object we share with the stream class
    //
    PDEVICE_OBJECT SharedDeviceObject;

    //
    // Holds the Device Object of our parent (1394 bus driver)
    // pass it in IoCallDriver()
    //
    PDEVICE_OBJECT BusDeviceObject;

    //
    // Holds my Physical Device Object
    // pass it in PnP API, such as IoOpenDeviceRegistryKey()
    //
    PDEVICE_OBJECT PhysicalDeviceObject;

    //
    // Holds the current generation count of the bus
    //
    ULONG CurrentGeneration;

    //
    // Holds the Configuration Rom for this device.  Multi-functional
    // devices (i.e. many units) will share this same Config Rom
    // structure, but they are represented as a different Device Object.
    // This is not the entire Config Rom, but does contain the root directory
    // as well as everything in front of it.
    //
    PCONFIG_ROM ConfigRom;

    //
    // Holds the Unit Directory for this device.  Even on multi-functional
    // devices (i.e. many units) this should be unique to each Device Object.
    //
    PVOID UnitDirectory;

    //
    // Holds the Unit Dependent directory for this device.
    //
    PVOID UnitDependentDirectory;

    //
    // Holds the pointer to the Vendor Leaf information
    //
    PTEXTUAL_LEAF VendorLeaf;

    PCHAR pchVendorName;

    //
    // Holds the pointer to the Model Leaf information
    //
    PTEXTUAL_LEAF ModelLeaf;

    //
    // Holds the Base Register of the camera (lower 32 bit portion only)
    //
    ULONG BaseRegister;

    //
    // Holds an area for us to read/write camera registers to/from here
    //
    union {
        INITIALIZE_REGISTER Initialize;
        V_FORMAT_INQ_REGISTER VFormat;
        V_MODE_INQ_REGISTER VMode;
        V_RATE_INQ_REGISTER VRate;
        BRIGHTNESS_REGISTER Brightness;
        WHITE_BALANCE_REGISTER WhiteBalance;
              FEATURE_REGISTER Feature;
        ULONG AsULONG;
    } RegisterWorkArea;

    //
    // Holds what frame rate we'll display at
    //
    ULONG FrameRate;

    //
    // Holds the resource for the isoch stream we got
    //
    HANDLE hResource;

    //
    // Holds the bandwidth resource handle
    //
    HANDLE hBandwidth;

    //
    // Holds the Isoch channel we'll use to receive data
    //
    ULONG IsochChannel;

    //
    // Got this from the parent's PNODE_DEVICE_EXTENSION;
    // Sinceit is from the 1394bus driver, it is safe to be used to set the xmit speed
    //

    ULONG SpeedCode;

    //
    // Holds the Mode Index that we currently supposed to be running at
    //
    ULONG CurrentModeIndex;

    //
    // Holds whether or not we need to listen (after we said we did)
    // Used only if enable isoch streaming while no buffer is attached.
    //
    BOOLEAN bNeedToListen;

    //
    // Holds the list of isoch descriptors that are currently attached
    //
    LIST_ENTRY IsochDescriptorList;

    //
    // Holds the spin lock that must be acquired before playing around with
    // the IsochDescriptorList
    //
    KSPIN_LOCK IsochDescriptorLock;

    //
    // Set to TRUE if isoch channel and resource have changed due to bus reset,
    // and we must either resubmit the pending reads or cancel them.
    //
    BOOL bStopIsochCallback;

    //
    // Holds the number of reads down at any given moment
    //
    LONG PendingReadCount;

    //
    // Holds the list of isoch descriptors that are waiting for resources
    //
    LIST_ENTRY IsochWaitingList;

    //
    // Holds the spin lock that must be acquired before playing around with
    // the IsochWaitingList
    //
    KSPIN_LOCK IsochWaitingLock;

    //
    // The could be an array if the device support multiple streams.  But we only has one capture pin.
    //
    struct _STREAMEX * pStrmEx;

    //
    // Many IEE 1394 cameras can use the same drivers.  After a streamis open, this is incremented.
    //
    LONG idxDev;

    //
    // Query type of host controller and its capabilities (like stripe Quadlets)
    //
    GET_LOCAL_HOST_INFO2 HostControllerInfomation;

    //
    // Query the DMA capabilities; mainly to determine the max DMA buffer size
    //
    GET_LOCAL_HOST_INFO7 HostDMAInformation;

    //
    // Keep track of power state; know only D0 and D3
    //
    DEVICE_POWER_STATE CurrentPowerState;

    //
    // TRUE only after SRB_SURPRIESE_REMOVAL;
    //
    BOOL bDevRemoved;

    //
    // Sometime the camera is not responding to our request;
    // so we retied.
    //
    LONG lRetries;   // [0.. RETRY_COUNT]

    // ************************** //
    // Streams: Formats and Modes //
    // ************************** //
    
    //
    // Set in the INF to inform driver of what compression format 
    // (VMode) is supported by the decoder installed on the system (by default)
    // 
    DCamRegArea DecoderDCamVModeInq0;

    //
    // cache the device's VFormat and VModeInq0 register values
    //
    DCamRegArea DCamVFormatInq;
    DCamRegArea DCamVModeInq0;

    //
    // These values are retrun in the StreamHeader to advertise the stream formats supported.
    //
    ULONG ModeSupported;  // 0..MAX_VMODE
    PKSDATAFORMAT  DCamStrmModes[MAX_VMODES];  

    // ************** //
    // Device control //
    // ************** //

#if DBG
    //
    // Inquire features supported be this device
    //
    DCamRegArea DevFeature1;   //Brightness, Sharpness, WhiteBalance, Hue, Saturation..Focus...
    DCamRegArea DevFeature2;   // Zoom, Pan, Tilt...
#endif

    //
    // Property sets; when sets are in contiguous memory, they forma a property table.
    //
    ULONG ulPropSetSupported;        // Number of property item supported.
    KSPROPERTY_SET VideoProcAmpSet;  // This is also the beginning of the property set table.
    KSPROPERTY_SET CameraControlSet;

    //
    // Property items of what device supports 
    //
    KSPROPERTY_ITEM VideoProcAmpItems[NUM_VIDEOPROCAMP_ITEMS];
    KSPROPERTY_ITEM CameraControlItems[NUM_CAMERACONTROL_ITEMS];

    //
    // Current settings defined (supported) by the device
    //
    DEV_PROPERTY_DEFINE DevPropDefine[NUM_PROPERTY_ITEMS];

    //
    // VideoProcAmp and CameraControl (range and current value)
    //
    DEV_PROPERTY DevProperty[NUM_PROPERTY_ITEMS];
    
    //
    // Global nonpaged pool memory used to read/write device register values (current value)
    //
    DCamRegArea RegArea;

    //
    // Global nonpaged pool memory used to read/write device register values (verify result)
    //
    DCamRegArea RegAreaVerify;

    //
    // Seralize using the global variables. (just in case we are called from multiple threads)
    //
    KMUTEX hMutexProperty;       

} DCAM_EXTENSION, *PDCAM_EXTENSION;


//
// this structure is our per stream extension structure.  This stores
// information that is relevant on a per stream basis.  Whenever a new stream
// is opened, the stream class driver will allocate whatever extension size
// is specified in the HwInitData.PerStreamExtensionSize.
//

typedef struct _STREAMEX {

    // Index to the table contain the data packet information
    LONG idxIsochTable;

    //
    // Holds the master clock
    //
    HANDLE hMasterClock;

    //
    // Pointer to the data that i'm supposed to be working off of
    //
    PKS_VIDEOINFOHEADER  pVideoInfoHeader;

    //
    // Statistic of the frame information since last start stream
    //
    KS_FRAME_INFO FrameInfo;
    ULONGLONG     FrameCaptured;        // Number of frame return to the client
    ULONGLONG     FirstFrameTime;       // Use to calculate drop frame

    //
    // Holds state
    //
    KSSTATE KSState;
    KSSTATE KSStateFinal;   // Final state that we want to reach using IoCompletion routine

    KMUTEX hMutex;   // MutEx of StreamIo or StreamControl, specifically setting to stop state.

    //
    // For Power Management; valid only in DCamChangePower()
    //
    KSSTATE KSSavedState;

} STREAMEX, *PSTREAMEX;




typedef struct _CAMERA_ISOCH_INFO {

    //
    // Holds the number of quadlets in each Isochronous packet
    //
    ULONG QuadletPayloadPerPacket;

    //
    // Holds the speed required in order to receive this mode
    //
    ULONG SpeedRequired;

    //
    // Holds the size of a complete picture at this resolution and mode
    //
    ULONG CompletePictureSize;

} CAMERA_ISOCH_INFO, *PCAMERA_ISOCH_INFO;


typedef struct _ISOCH_DESCRIPTOR_RESERVED {

    //
    // Holds the list of descriptors that we have in use
    //
    LIST_ENTRY DescriptorList;

    //
    // Holds the pointer to the Srb that's associated with this descriptor
    //
    PHW_STREAM_REQUEST_BLOCK Srb;

    //
    // Holds the flags that we use to remember what state we're in
    //
    ULONG Flags;


} ISOCH_DESCRIPTOR_RESERVED, *PISOCH_DESCRIPTOR_RESERVED;


//
// Various definitions
//


#define FIELDOFFSET(type, field)        (int)((INT_PTR)(&((type *)1)->field)-1)

#define QUERY_ADDR_OFFSET          0x0300   // 0x800 - 0x500 = 0x300

#define MAX_READ_REG_RETRIES           10   // Max retries until Pres is ready

#define NUM_POSSIBLE_RATES              6
#define RETRY_COUNT                     5
#define RETRY_COUNT_IRP_SYNC           20
#define DEFAULT_FRAME_RATE              3
#define STOP_ISOCH_TRANSMISSION         0
#define START_ISOCH_TRANSMISSION        0x80
#define START_OF_PICTURE                1
#define MAX_BUFFERS_SUPPLIED            8
#define DCAM_DELAY_VALUE            (ULONG)(-1 *  100 * 1000)    //  10 ms
#define DCAM_DELAY_VALUE_BUSRESET   (ULONG)(-1 * 2000 * 1000)    // 200 ms


#define DCAM_REG_STABLE_DELAY       (ULONG)(-1 * 500 * 1000)    // 50 ms

#define ISO_ENABLE_BIT         0x00000080


//
// Definitions of the Frame Rate register located at offset 0x600
//
#define FRAME_RATE_0                    0
#define FRAME_RATE_1                    0x20
#define FRAME_RATE_2                    0x40
#define FRAME_RATE_3                    0x60
#define FRAME_RATE_4                    0x80
#define FRAME_RATE_5                    0xa0
#define FRAME_RATE_SHIFT                5

#define FORMAT_VGA_NON_COMPRESSED       0

#define ISOCH_CHANNEL_SHIFT             4

#define VIDEO_MODE_SHIFT                5

#define REGISTERS_TO_SET_TO_AUTO        10

#define STATE_SRB_IS_COMPLETE           1
#define STATE_DETACHING_BUFFERS         2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\1394dcam\dcampkt.c ===
//===========================================================================
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
// PURPOSE.
//
// Copyright (c) 1996 - 2000  Microsoft Corporation.  All Rights Reserved.
//
//===========================================================================
/*++

Module Name:

    dcampkt.c

Abstract:

    Stream class based WDM driver for 1934 Desktop Camera.
    This file contains code to handle the stream class packets.

Author:
    
    Shaun Pierce 25-May-96

Modified:

    Yee J. Wu 15-Oct-97

Environment:

    Kernel mode only

Revision History:


--*/


#include "strmini.h"
#include "ksmedia.h"
#include "1394.h"
#include "wdm.h"       // for DbgBreakPoint() defined in dbg.h
#include "dbg.h"
#include "dcamdef.h"
#include "dcampkt.h"
#include "strmdata.h"  // stream format and data ranges; static data
#include "capprop.h"   // Video and camera property function prototype

#define WAIT_FOR_SLOW_DEVICE


#ifdef ALLOC_PRAGMA
    #pragma alloc_text(PAGE, DCamProcessPnpIrp)
    #pragma alloc_text(PAGE, DCamGetStreamInfo)
    #pragma alloc_text(PAGE, DCamFreeIsochResource)    
    #pragma alloc_text(PAGE, InitializeStreamExtension)    
    #pragma alloc_text(PAGE, DCamOpenStream)   
    #pragma alloc_text(PAGE, DCamCloseStream)           
    #pragma alloc_text(PAGE, AdapterCompareGUIDsAndFormatSize)    
    #pragma alloc_text(PAGE, AdapterVerifyFormat)    
    #pragma alloc_text(PAGE, AdapterFormatFromRange)    
    #pragma alloc_text(PAGE, VideoGetProperty)    
    #pragma alloc_text(PAGE, VideoGetState)    
    #pragma alloc_text(PAGE, VideoStreamGetConnectionProperty)    
    #pragma alloc_text(PAGE, VideoStreamGetDroppedFramesProperty)    
    #pragma alloc_text(PAGE, VideoIndicateMasterClock)    
    #pragma alloc_text(PAGE, DCamReceivePacket)
    #pragma alloc_text(PAGE, DCamChangePower)
#endif

void 
tmGetStreamTime(
    IN PHW_STREAM_REQUEST_BLOCK Srb,
    PSTREAMEX pStrmEx, 
    ULONGLONG * ptmStream) 
/*++

Routine Description:

   Query the current time used to timestamp the frame or calculating the dropped frame.
   This is used in IsochCallback so must be paged in always.

Arguments:

    Srb - Pointer to Stream request block

Return Value:

    Nothing

--*/
{

    HW_TIME_CONTEXT TimeContext;

    TimeContext.HwDeviceExtension = (PVOID) Srb->HwDeviceExtension;
    TimeContext.HwStreamObject    = Srb->StreamObject;
    TimeContext.Function          = TIME_GET_STREAM_TIME;
    TimeContext.Time              = 0;
    TimeContext.SystemTime        = 0;

    StreamClassQueryMasterClockSync(
        pStrmEx->hMasterClock,
        &TimeContext);

    *ptmStream = TimeContext.Time;
}

BOOL
DCamAllocateIrbAndIrp(
    PIRB * ppIrb,
    PIRP * ppIrp,
    CCHAR StackSize
    )
{

    // Allocate Irb and Irp
    *ppIrb = ExAllocatePoolWithTag(NonPagedPool, sizeof(IRB), 'macd');
    if(!*ppIrb) {           
        return FALSE;
    }

    *ppIrp = IoAllocateIrp(StackSize, FALSE);
    if(!*ppIrp) {
        ExFreePool(*ppIrb);
        *ppIrb = NULL;
        return FALSE;
    }

    // Initialize IRB
    RtlZeroMemory(*ppIrb, sizeof(IRB));

    return TRUE;
}


BOOL
DCamAllocateIrbIrpAndContext(
    PDCAM_IO_CONTEXT * ppDCamIoContext,
    PIRB * ppIrb,
    PIRP * ppIrp,
    CCHAR StackSize
    )
{

    // Allocate DCamIoContext
    *ppDCamIoContext = ExAllocatePoolWithTag(NonPagedPool, sizeof(DCAM_IO_CONTEXT), 'macd');
    if(!*ppDCamIoContext) {            
        return FALSE;
    }

    // Allocate Irb and Irp
    *ppIrb = ExAllocatePoolWithTag(NonPagedPool, sizeof(IRB), 'macd');
    if(!*ppIrb) {
        ExFreePool(*ppDCamIoContext);            
        *ppDCamIoContext = NULL;
        return FALSE;
    }

    *ppIrp = IoAllocateIrp(StackSize, FALSE);
    if(!*ppIrp) {
        ExFreePool(*ppDCamIoContext);
        *ppDCamIoContext = NULL;
        ExFreePool(*ppIrb);
        *ppIrb = NULL;
        return FALSE;
    }


    // Initialize this context
    RtlZeroMemory(*ppDCamIoContext, sizeof(DCAM_IO_CONTEXT));
    (*ppDCamIoContext)->dwSize      = sizeof(DCAM_IO_CONTEXT);
    (*ppDCamIoContext)->pIrb        = *ppIrb;

    // Initialize IRB
    RtlZeroMemory(*ppIrb, sizeof(IRB));

    return TRUE;
}

void
DCamFreeIrbIrpAndContext(
    PDCAM_IO_CONTEXT pDCamIoContext,
    PIRB pIrb,
    PIRP pIrp   
    )
{
    if(pIrp)
        IoFreeIrp(pIrp);
    if(pIrb)
        ExFreePool(pIrb);
    if(pDCamIoContext)
        ExFreePool(pDCamIoContext);
}


BOOL
DCamIsoEnable(
    PIRB pIrb,
    PDCAM_EXTENSION pDevExt,
    BOOL Enable  
    ) 
/*
    Start or start isoch transmission by setting the ISOEnable bit.
    TRUE: Start transmission; 
    FALSE: Stop transmission.
*/
{
    BOOL EnableVerify;
    DCamRegArea RegArea;
    NTSTATUS Status;
    LARGE_INTEGER stableTime;
    LONG lRetries = MAX_READ_REG_RETRIES;

    do {
        RegArea.AsULONG = (Enable ? START_ISOCH_TRANSMISSION : STOP_ISOCH_TRANSMISSION);
        Status = DCamWriteRegister(pIrb, pDevExt, FIELDOFFSET(CAMERA_REGISTER_MAP, IsoEnable), RegArea.AsULONG);
        EnableVerify = DCamDeviceInUse(pIrb, pDevExt);
        if(!NT_SUCCESS(Status) || EnableVerify != Enable) {
            ERROR_LOG(("\'DCAmIsoEnable: St:%x; Enable:%d vs EnableVerify:%d\n", Status, Enable, EnableVerify));
            if(lRetries >= 1) {
                stableTime.LowPart = DCAM_REG_STABLE_DELAY;
                stableTime.HighPart = -1;
                KeDelayExecutionThread(KernelMode, TRUE, &stableTime);
                ERROR_LOG(("\'DCamIsoEnable: delayed and try again...\n"))
            }
        }
    } while (--lRetries > 0 && (!NT_SUCCESS(Status) || (EnableVerify != Enable)) );

    return (EnableVerify == Enable);
}

void
DCamProcessPnpIrp(
    IN PHW_STREAM_REQUEST_BLOCK Srb,
    PIO_STACK_LOCATION IrpStack,
    PDCAM_EXTENSION pDevExt
    )

/*++

Routine Description:

    Process PnP Irp. 

Arguments:

    Srb - Pointer to Stream request block

Return Value:

    Nothing

--*/
{
    NTSTATUS Status, StatusWait;
    PIRB pIrb;
    PIRP pIrp;
    PSTREAMEX pStrmEx;

    PAGED_CODE();

    switch (IrpStack->MinorFunction) {
#if 1
    case IRP_MN_QUERY_POWER:
        pStrmEx = (PSTREAMEX) pDevExt->pStrmEx;
        ERROR_LOG(("IRP_MN_QUERY_POWER: pStrmEx:%x\n", pStrmEx));
        if(!pStrmEx) {
            Srb->Status = STATUS_SUCCESS;
            break;
        }

        if(pStrmEx->KSState == KSSTATE_PAUSE || pStrmEx->KSState == KSSTATE_RUN) {
            ERROR_LOG(("Does not support hibernation while streaming!\n"));
            Srb->Status = STATUS_NOT_SUPPORTED;
        } else {
            ERROR_LOG(("OK to hibernation if not streaming\n"));
            Srb->Status = STATUS_SUCCESS;
        }
        break;
#endif
    case IRP_MN_BUS_RESET:
    //
    // We will realocate the resource (bandwith and channel) in IRQL PASSIVE level.
    //
        Srb->Status = STATUS_SUCCESS;
        Status = STATUS_SUCCESS;

        //
        // The generation count is updated in the bus reset callback notification only.
        // Continue iff the generation count has been updated.
        // Else, we are assuming another bus reset has occurred,
        // and we will pass to us later.
        //
        if(pDevExt->CurrentGeneration != *((PULONG) &IrpStack->Parameters.Others.Argument4)) {
            ERROR_LOG(("DCamProcessPnpIrp: Generation count old (%d) != new (%d); STOP!\n", 
               pDevExt->CurrentGeneration, *((PULONG) &IrpStack->Parameters.Others.Argument4)) );
            break;
        }

        pStrmEx = (PSTREAMEX) pDevExt->pStrmEx;
        DbgMsg2(("\'%d:%s) SonyDCamProcessPnpIrp: pDevExt %x; pStrmEx %x; CurGen %d\n", 
            pDevExt->idxDev, pDevExt->pchVendorName, pDevExt, pStrmEx, pDevExt->CurrentGeneration));

        //
        // If the stream was open (pStrmEx != NULL && pStrmEx->pVideoInfoHeader != NULL);
        // We need to ask controller to allocate bandwidth and channel. 
        //
        if(pStrmEx &&
           pStrmEx->pVideoInfoHeader != NULL) {

            DbgMsg2(("\'%d:%s) DCamProcessPnpIrp: Stream was open so re-allocate resource.\n", pDevExt->idxDev, pDevExt->pchVendorName));


            // Allocate Irb 
            pIrb = ExAllocatePoolWithTag(NonPagedPool, sizeof(IRB), 'macd');
            if(!pIrb) {            
                ERROR_LOG(("\'DCamProcessPnpIrp: allocate IRB failed; insufficient resource.\n"));
                Srb->Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            } else {
                ULONG ulChannel;
                HANDLE hResource;

                pIrp = IoAllocateIrp(pDevExt->BusDeviceObject->StackSize, FALSE);
                if(!pIrp) {
                    ExFreePool(pIrb);
                    Srb->Status = STATUS_INSUFFICIENT_RESOURCES;
                    break;
                }

                RtlZeroMemory(pIrb, sizeof(IRB));

                //
                // Bus reset will free the bandwidth but not the bandwidth structure allocated by the lower driver                
                //
                if (pDevExt->hBandwidth) {

                    DbgMsg2(("\'DCamProcessPnpIrp: Attempt to free ->hBandwidth\n"));

                    pIrb->FunctionNumber = REQUEST_ISOCH_FREE_BANDWIDTH;
                    pIrb->Flags = 0;
                    pIrb->u.IsochFreeBandwidth.hBandwidth = pDevExt->hBandwidth;
                    Status = DCamSubmitIrpSynch(pDevExt, pIrp, pIrb);

                    if (Status) {
                        ERROR_LOG(("DCamProcessPnpIrp: Error %x while trying to free Isoch bandwidth\n", Status));
                        ASSERT(Status == STATUS_SUCCESS || Status ==  STATUS_INVALID_GENERATION);
                    }

                    pDevExt->hBandwidth = NULL;
                }


                //
                // Before we assign the new hResource, we wait for it attaching buffer to complete.
                // For buffer that completed with previous hResource,
                // It will complete with error ?
                //

                StatusWait = KeWaitForSingleObject( &pStrmEx->hMutex, Executive, KernelMode, FALSE, 0 ); 


                //
                // Reallocate bandwidth and channel, and resource if necessary.
                // IF THIS FAIL, we are consider illegally streaming, and need to STOP streaming.
                //

                ulChannel = pDevExt->IsochChannel;
                hResource = pDevExt->hResource;

                Status = DCamAllocateIsochResource(pDevExt, pIrb, FALSE);
 
                if(Status) {

                    ERROR_LOG(("\'%d:%s) DCamProcessPnpIrp: Re-AllocateIsochResource failed! Status=%x; Treat as device removed.\n\n", 
                        pDevExt->idxDev, pDevExt->pchVendorName, Status));
                    ASSERT(Status == STATUS_SUCCESS);

                    //
                    // No resource so let's treat this situation as
                    // Device has been removed because there is no
                    // way to restart this.
                    // This will stop future SRB_READ until stream is STOP and RUN again.
                    //

                    pDevExt->bDevRemoved = TRUE;                   
                    Srb->Status = STATUS_INSUFFICIENT_RESOURCES;

                    // 
                    // Stop tranmission so it will not send data to the old channel,
                    // which might be "owned" by other device.
                    //

                    if(pStrmEx->KSState == KSSTATE_RUN) {
                        // Disable EnableISO
                        DCamIsoEnable(pIrb, pDevExt, FALSE);
                    }

                    KeReleaseMutex(&pStrmEx->hMutex, FALSE);                
                    ExFreePool(pIrb);
                    IoFreeIrp(pIrp);
                    return;
                }

                //
                // If channel number change due to bus reset, we must
                //    - continue to blocking incoming SRB_READ (with mutex)
                //    - if RUN state, stop transmission
                //    - detach all pending buffer(s)
                //    - free "stale" isoch resource
                //    - if RUN state, program device to use the new channel
                //    - if RUN state, restart transmission
                //

                if(pDevExt->IsochChannel != ISOCH_ANY_CHANNEL &&
                   ulChannel != pDevExt->IsochChannel) {

                    // 
                    // Stop tranmission so it will not send data to the old channel,
                    // which might be "owned" by other device.
                    //

                    if(pStrmEx->KSState == KSSTATE_RUN) {
                        // Disable EnableISO
                        DCamIsoEnable(pIrb, pDevExt, FALSE);
                    }

 
                    //
                    // Detach pending packets using the hOldRources and reattached using the new hResource
                    // Note: incoming SRB_READ is block right now.
                    //       free old resource after all pending reads are detached.
                    //

                    if(pDevExt->PendingReadCount > 0) {

                        Status = DCamReSubmitPacket(hResource, pDevExt, pStrmEx, pDevExt->PendingReadCount);
                    }


                    //
                    // Free "stale" isoch resource 
                    //

                    if(pDevExt->hResource != hResource) {

                        DbgMsg2(("DCamReSubmitPacket: Attempt to free hStaleResource %x\n", hResource));
                        pIrb->FunctionNumber = REQUEST_ISOCH_FREE_RESOURCES;
                        pIrb->Flags = 0;
                        pIrb->u.IsochFreeResources.hResource = hResource;
                        Status = DCamSubmitIrpSynch(pDevExt, pIrp, pIrb);    
                        if (Status) {
                            ERROR_LOG(("\'DCamFreeIsochResource: Error %x while trying to free Isoch resources\n\n", Status));
                            ASSERT(Status == STATUS_SUCCESS);
                        }    
                    }

                    //
                    // Getting ready to accept callback
                    //
                    pDevExt->bStopIsochCallback = FALSE;
                    
                    //
                    // Restore to its initial Streaming state
                    // mainly, programming device.
                    //

                    DCamSetKSStateInitialize(pDevExt);                    
                }

                KeReleaseMutex(&pStrmEx->hMutex, FALSE);                
                ExFreePool(pIrb);
                IoFreeIrp(pIrp);
            }
        }

        if(Status == STATUS_SUCCESS) {

            //
            // Set to last saved configuration
            //

            SetCurrentDevicePropertyValues(pDevExt, (PIRB) Srb->SRBExtension);
        }

        DbgMsg2(("\'DCamProcessPnpIrp, IRP_MN_BUS_RESET: Done, Status %x\n", Status));

        break;
            
    case IRP_MN_QUERY_CAPABILITIES: 
        ERROR_LOG(("\'SonyDCamProcessPnpIrp: IRP_MN_QUERY_CAPABILITIES: Srb->Status = STATUS_NOT_IMPLEMENTED.\n"));
    default:
        Srb->Status = STATUS_NOT_IMPLEMENTED;
        break;
    }
}


VOID 
DCamChangePower(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
)

/*++

Routine Description:

    Process chnaging this device's power state.  

Arguments:

    Srb - Pointer to Stream request block

Return Value:

    Nothing

--*/
{
    PDCAM_EXTENSION pDevExt;
    PSTREAMEX pStrmEx;
    PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(pSrb->Irp);
    DEVICE_POWER_STATE DevicePowerState = pSrb->CommandData.DeviceState;

    PAGED_CODE();

    pDevExt = (PDCAM_EXTENSION) pSrb->HwDeviceExtension;
    DbgMsg2(("\'DCamChangePower: pSrb=%x; pDevExt=%x\n", pSrb, pDevExt));

    ASSERT(pDevExt != NULL);
    if(!pDevExt) {   
        pSrb->Status = STATUS_INVALID_PARAMETER;
        ERROR_LOG(("DCamChangePower: pDevExt is NULL!\n"));
        return;
    }

    pStrmEx = (PSTREAMEX) pDevExt->pStrmEx;     
    if (pStrmEx ==NULL) {        
        pSrb->Status = STATUS_SUCCESS;
        pDevExt->CurrentPowerState = DevicePowerState;
        DbgMsg2(("DCamChangePower: pStrmEx is NULL => Stream is not open. That is Ok!!\n"));
        return;
    }

   


    // 
    // We can honor power state change:
    //
    //    D0: device is on and running
    //    D1,D2: not implemented.
    //    D3: device is off and not running.  Device context is lost.  
    //        Power can be removed from the device.
    //        when power is back on, we will get a bus reset.
    //
    //    (0) Remove DontSuspendIfStreamsAreRunning from INF
    //    save current state.
    //    (1) ->D3, to PAUSE/STOP state (depends on if pending buffers can be kept by its lower driver)
    //    (2) ->D0, to restore saved state
    //
    // We can do the above but we do not know at this point 
    // how our client application react
    //
    if(IrpStack->MinorFunction == IRP_MN_SET_POWER) {
        DbgMsg2(("DCamChangePower: changin power state from %d to %d.\n", pDevExt->CurrentPowerState, DevicePowerState));

        pSrb->Status = STATUS_SUCCESS;

        if(pDevExt->CurrentPowerState != DevicePowerState) {

            switch (DevicePowerState) {
            case PowerDeviceD3:        // D0->D3: save state, stop streaming and Sleep
                if( pDevExt->CurrentPowerState == PowerDeviceD0 ) {
                    DbgMsg1(("DCamChangePower: Switching from D0 to D3; Save current state.\n"));
                    // Save current state to be restored when awake
                    pStrmEx->KSSavedState = pStrmEx->KSState;
                }
                break;

            case PowerDeviceD0:  // to Wakeup, restore state and running
                if( pDevExt->CurrentPowerState == PowerDeviceD3 ) {
                    DbgMsg1(("DCamChangePower: Switching from D3 to D0; restore state.\n"));
                    pStrmEx->KSState = pStrmEx->KSSavedState;                         
                }
                break;

            // These state are not defined and noe used.
            case PowerDeviceD1:
            case PowerDeviceD2:               
            default:
                ERROR_LOG(("DCamChangePower: Invalid PowerState %d\n", DevicePowerState));                  
                pSrb->Status = STATUS_INVALID_PARAMETER;
                break;
            }
        }            

        if(pSrb->Status == STATUS_SUCCESS) 
            pDevExt->CurrentPowerState = DevicePowerState;         

    } else {
       
        pSrb->Status = STATUS_NOT_IMPLEMENTED;

    }


}




VOID
DCamGetStreamInfo(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    Returns the information of all streams that are supported by the driver

Arguments:

    Srb - Pointer to Stream request block

Return Value:

    Nothing

--*/

{
    //
    // pick up the pointer to the stream information data structure
    //
    PIRB pIrb;
    PHW_STREAM_HEADER StreamHeader = &(Srb->CommandData.StreamBuffer->StreamHeader);        
    PDCAM_EXTENSION pDevExt = (PDCAM_EXTENSION) Srb->HwDeviceExtension;
    PHW_STREAM_INFORMATION StreamInfo = &(Srb->CommandData.StreamBuffer->StreamInfo);

    PAGED_CODE();

    pIrb = (PIRB) Srb->SRBExtension;

    //
    // set number of streams
    //

    ASSERT (Srb->NumberOfBytesToTransfer >= 
            sizeof (HW_STREAM_HEADER) +
            sizeof (HW_STREAM_INFORMATION));

    //
    // initialize stream header
    //

    RtlZeroMemory(StreamHeader, 
                sizeof (HW_STREAM_HEADER) +
                sizeof (HW_STREAM_INFORMATION));

    //
    // initialize the number of streams supported
    //

    StreamHeader->NumberOfStreams = 1;
    StreamHeader->SizeOfHwStreamInformation = sizeof(HW_STREAM_INFORMATION);

    //
    // set the device property info
    // 

    StreamHeader->NumDevPropArrayEntries = pDevExt->ulPropSetSupported;
    StreamHeader->DevicePropertiesArray  = &pDevExt->VideoProcAmpSet;


    //
    // Initialize the stream structure.
    //
    // Number of instances field indicates the number of concurrent streams
    // of this type the device can support.  
    //

    StreamInfo->NumberOfPossibleInstances = 1;

    //
    // indicates the direction of data flow for this stream, relative to 
    // the driver
    //

    StreamInfo->DataFlow = KSPIN_DATAFLOW_OUT;

    //
    // dataAccessible - Indicates whether the data is "seen" by the host
    // processor.
    //

    StreamInfo->DataAccessible = TRUE;

    // 
    // Return number of formats and the table.
    // These information is collected dynamically.
    //
    StreamInfo->NumberOfFormatArrayEntries = pDevExt->ModeSupported;
    StreamInfo->StreamFormatsArray = &pDevExt->DCamStrmModes[0];


    //
    // set the property information for the video stream
    //


    StreamInfo->NumStreamPropArrayEntries = NUMBER_VIDEO_STREAM_PROPERTIES;
    StreamInfo->StreamPropertiesArray = (PKSPROPERTY_SET) VideoStreamProperties;

    //
    // set the pin name and category
    //

    StreamInfo->Name = (GUID *) &PINNAME_VIDEO_CAPTURE;
    StreamInfo->Category = (GUID *) &PINNAME_VIDEO_CAPTURE;


    //
    // store a pointer to the topology for the device
    //
        
    Srb->CommandData.StreamBuffer->StreamHeader.Topology = &Topology;


    //
    // indicate success
    //

    Srb->Status = STATUS_SUCCESS;

    DbgMsg2(("\'DCamGetStreamInfo: NumFormat %d, StreamFormatArray %x\n",
        StreamInfo->NumberOfFormatArrayEntries,  StreamInfo->StreamFormatsArray));

}

#define TIME_ROUNDING                        1000   // Give it some rounding error of 100microsec
#define TIME_0750FPS      (1333333+TIME_ROUNDING)   // 1/7.50 * 10,000,000 (unit=100ns)
#define TIME_1500FPS       (666666+TIME_ROUNDING)   // 1/15.0 * 10,000,000 (unit=100ns)  do not round to 666667
#define TIME_3000FPS       (333333+TIME_ROUNDING)   // 1/30.0 * 10,000,000 (unit=100ns)

NTSTATUS
DCamAllocateIsochResource(
    PDCAM_EXTENSION pDevExt,
    PIRB Irb,
    BOOL bAllocateResource
    )
{
    PIRP Irp;
    CCHAR StackSize;
    ULONG ModeIndex;
    PSTREAMEX pStrmEx;
    DWORD dwAvgTimePerFrame, dwCompression;
    ULONG fulSpeed;
    NTSTATUS Status = STATUS_SUCCESS;


    ASSERT(pDevExt);
    pStrmEx = (PSTREAMEX) pDevExt->pStrmEx;
    ASSERT(pStrmEx);


    DbgMsg2(("\'DCamAllocateIsochResource: enter; pStrmEx %x; pVideoInfo %x\n", pStrmEx, pStrmEx->pVideoInfoHeader));
    //
    // Now if they're on a YUV4:2:2 format, we've gotta check what
    // resolution they want it at, since we support this format
    // but in two different resolutions (modes on the camera).
    //

    // This is the INDEX to the frame rate and resource allocation; see IsochInfoTable.
    // 0 : reserved
    // 1 : 3.75
    // 2 : 7.5
    // 3 : 15 (DEFAULT_FRAME_RATE)
    // 4 : 30 
    // 5 : 60 (Not supported for Mode 1 & 3)
    dwAvgTimePerFrame = (DWORD) pStrmEx->pVideoInfoHeader->AvgTimePerFrame;
    dwCompression = (DWORD) pStrmEx->pVideoInfoHeader->bmiHeader.biCompression;



    // Determine the Frame rate
    if (dwAvgTimePerFrame      > TIME_0750FPS) 
        pDevExt->FrameRate = 1;        //  3.75FPS
    else if (dwAvgTimePerFrame >  TIME_1500FPS) 
        pDevExt->FrameRate = 2;        //  7.5FPS
    else if (dwAvgTimePerFrame >  TIME_3000FPS) 
        pDevExt->FrameRate = 3;        // 15 FPS
    else 
        pDevExt->FrameRate = 4;        // 30 FPS


    DbgMsg2(("\'DCamAllocateIsochResource: FrameRate: %d FPS\n", (1 << (pDevExt->FrameRate-1)) * 15 / 4));

    // Determine the Video Mode
    switch(dwCompression) {
#ifdef SUPPORT_YUV444          
    case FOURCC_Y444:     // Mode 0
         ModeIndex = VMODE0_YUV444;
         break;
#endif
    case FOURCC_UYVY:     // Mode 1 or 3
         if (pStrmEx->pVideoInfoHeader->bmiHeader.biWidth == 640 &&
             (pStrmEx->pVideoInfoHeader->bmiHeader.biHeight == 480 || 
             pStrmEx->pVideoInfoHeader->bmiHeader.biHeight == -480)) {
              ModeIndex = VMODE3_YUV422;
              // Max frame rate is 15
              if(pDevExt->FrameRate > 3)
                 pDevExt->FrameRate = 3;
         } else
              ModeIndex = VMODE1_YUV422;
         break;
#ifdef SUPPORT_YUV411          
    case FOURCC_Y411:     // Mode 2
         ModeIndex = VMODE2_YUV411;
         break;
#endif

#ifdef SUPPORT_RGB24          
    case KS_BI_RGB:  // = 0
         ModeIndex = VMODE4_RGB24;
         // Max frame rate is 15
         if(pDevExt->FrameRate > 3)
            pDevExt->FrameRate = 3;
         break;
#endif

#ifdef SUPPORT_YUV800
    case FOURCC_Y800:  
         ModeIndex = VMODE5_YUV800;
         break;
#endif

    default:          
         Status = STATUS_NOT_IMPLEMENTED;;
         return Status;;
    }


    DbgMsg1(("\'DCamAllocateIsochResource: ModeIndex=%d, AvgTimePerFrame=%d, FrameRate=%d\n", 
             ModeIndex, dwAvgTimePerFrame, pDevExt->FrameRate));

    //
    // Get an Irp so we can send some allocation commands down
    //

    StackSize = pDevExt->BusDeviceObject->StackSize;
    Irp = IoAllocateIrp(StackSize, FALSE);

    if (!Irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Calculate the index to use to reference the ISOCH table
    //
    pStrmEx->idxIsochTable = ModeIndex * NUM_POSSIBLE_RATES + pDevExt->FrameRate;

    ASSERT(pStrmEx->pVideoInfoHeader->bmiHeader.biSizeImage == IsochInfoTable[pStrmEx->idxIsochTable].CompletePictureSize);
    DbgMsg2(("\'DCamAllocateIsochResource: ModeIndex=%d, idxIsochTable=%d, biSizeImage=%d, CompletePictureSize=%d\n", 
             ModeIndex, pStrmEx->idxIsochTable, pStrmEx->pVideoInfoHeader->bmiHeader.biSizeImage, IsochInfoTable[pStrmEx->idxIsochTable].CompletePictureSize));          

    //
    // 0. Determine the MAX_SPEED and not use the speed defined in the static table.
    //
    Irb->FunctionNumber = REQUEST_GET_SPEED_BETWEEN_DEVICES;
    Irb->Flags = 0;
    Irb->u.GetMaxSpeedBetweenDevices.fulFlags = USE_LOCAL_NODE;
    Irb->u.GetMaxSpeedBetweenDevices.ulNumberOfDestinations = 0;
    Status = DCamSubmitIrpSynch(pDevExt, Irp, Irb);
    if(Status) {
        ERROR_LOG(("\'DCamAllocateIsochResource: Error %x while trying to get maximun speed between devices.\n", Status));        

        IoFreeIrp(Irp);
        return STATUS_INSUFFICIENT_RESOURCES;
    }     
    
    fulSpeed = Irb->u.GetMaxSpeedBetweenDevices.fulSpeed;

    //
    // The max speed between devices should be within supported speed range, and
    // must be equal or greater than the required speed for the chosen format.
    //
    if(
        (  fulSpeed != SPEED_FLAGS_100 
        && fulSpeed != SPEED_FLAGS_200 
        && fulSpeed != SPEED_FLAGS_400
        )
        || fulSpeed < IsochInfoTable[pStrmEx->idxIsochTable].SpeedRequired
       ) {

        ASSERT(fulSpeed == SPEED_FLAGS_100 || fulSpeed == SPEED_FLAGS_200 ||  fulSpeed == SPEED_FLAGS_400);
        ASSERT(fulSpeed >= IsochInfoTable[pStrmEx->idxIsochTable].SpeedRequired);

        IoFreeIrp(Irp);
        return STATUS_UNSUCCESSFUL;
    }

    pDevExt->SpeedCode = fulSpeed >> 1;  // Safe for S100, 200 and 400 (is checked above).
    DbgMsg2(("\'GetMaxSpeedBetweenDevices.fulSpeed=%x; SpeedCode:%x\n", fulSpeed, pDevExt->SpeedCode));


    //
    // 1. Allocate CHANNEL
    //       First try to re-allocate the same channel
    //       If it is used, try to get any channel.  1394DCam can only be on channel 0..15
    //
    Irb->FunctionNumber = REQUEST_ISOCH_ALLOCATE_CHANNEL;
    Irb->Flags = 0;

    //
    //      ULONG           nRequestedChannel;      // Need a specific channel
    //      ULONG           Channel;                // Returned channel
    //      LARGE_INTEGER   ChannelsAvailable;      // Channels available
    // Instead of hardcoded '0'; use -1 to ask the bus driver to get the next available channel for us.
    // -1 (any channel) or an existing channel
    Irb->u.IsochAllocateChannel.nRequestedChannel = pDevExt->IsochChannel;  
    Status = DCamSubmitIrpSynch(pDevExt, Irp, Irb);
    if(Status) {

        //
        // Due to channel change, 
        // all Pending read will be either resubmitted, 
        // or cancelled (if out of resource).
        //
        pDevExt->bStopIsochCallback = TRUE;  // Set back to FALSE after pending buffer are attached.


        //
        // If this is an initial request and no channel available,
        // free all resource and abort.
        //
        if(pDevExt->IsochChannel == ISOCH_ANY_CHANNEL)
            goto NoResource_abort;

        DbgMsg1(("DCamAllocateIsochResource: last allocated channel %d is not available; pending count %d.\n",  
            pDevExt->IsochChannel, pDevExt->PendingReadCount));                      

        // Try gettting any channel.
        Irb->FunctionNumber = REQUEST_ISOCH_ALLOCATE_CHANNEL;
        Irb->Flags = 0;
        Irb->u.IsochAllocateChannel.nRequestedChannel = ISOCH_ANY_CHANNEL;  
        Status = DCamSubmitIrpSynch(pDevExt, Irp, Irb);
        if(Status) {
            ERROR_LOG(("DCamAllocateIsochResource: allocate any channel failed, status %x!\n",  Status));
            goto NoResource_abort;           
        }

        //
        // Channel changed, we MUST reallocate resource.
        // The "stale" resrouce will be free later when 
        // pending packet are detached.
        //

        bAllocateResource = TRUE;
    }   
    
    DbgMsg1(("**IsochAlloc: Channel(Old) %d, requested %d, got %d, HiLo(0x%x:%x), PendingRead %d\n", 
         pDevExt->IsochChannel, 
         Irb->u.IsochAllocateChannel.nRequestedChannel, 
         Irb->u.IsochAllocateChannel.Channel, 
         Irb->u.IsochAllocateChannel.ChannelsAvailable.u.HighPart,
         Irb->u.IsochAllocateChannel.ChannelsAvailable.u.LowPart,
         pDevExt->PendingReadCount));

    // New channel
    pDevExt->IsochChannel = Irb->u.IsochAllocateChannel.Channel;  // Used in allocating iso. resource and reallocation


    //
    // 2. Allocate BANDWIDTH
    //
    Irb->FunctionNumber = REQUEST_ISOCH_ALLOCATE_BANDWIDTH;
    Irb->Flags = 0;
    Irb->u.IsochAllocateBandwidth.nMaxBytesPerFrameRequested = IsochInfoTable[pStrmEx->idxIsochTable].QuadletPayloadPerPacket << 2;
    Irb->u.IsochAllocateBandwidth.fulSpeed = fulSpeed;
    Irb->u.IsochAllocateBandwidth.hBandwidth = 0;
    Status = DCamSubmitIrpSynch(pDevExt, Irp, Irb);
    
    if(Status) {
        ERROR_LOG(("DCamAllocateIsochResource: Error %x while trying to allocate Isoch bandwidth\n", Status));                  
        goto NoResource_abort;
    }

    pDevExt->hBandwidth = Irb->u.IsochAllocateBandwidth.hBandwidth;
    DbgMsg2(("**IsochAlloc: nMaxBytesPerFrameRequested %d, fulSpeed %d; hBandWidth 0x%x\n",
         IsochInfoTable[pStrmEx->idxIsochTable].QuadletPayloadPerPacket << 2, fulSpeed, pDevExt->hBandwidth));



    //
    // 3. Allocate RESOURCES
    //    Note: after a bus reset, we need not free and re-allocate this resoruce again.
    //
    if(bAllocateResource) {
        Irb->FunctionNumber = REQUEST_ISOCH_ALLOCATE_RESOURCES;
        Irb->Flags = 0;
        Irb->u.IsochAllocateResources.fulSpeed = fulSpeed;
        Irb->u.IsochAllocateResources.nChannel = pDevExt->IsochChannel;
        Irb->u.IsochAllocateResources.nMaxBytesPerFrame = IsochInfoTable[pStrmEx->idxIsochTable].QuadletPayloadPerPacket << 2;
        // For slower frame rate use smaller quadlets
        // smaller frame size will use more packet to fill the same amount of data
        // this is why smaller frame rate actually demand more resource !!
        Irb->u.IsochAllocateResources.nNumberOfBuffers = MAX_BUFFERS_SUPPLIED + 1;  // "+1" as a "safety"
        Irb->u.IsochAllocateResources.nMaxBufferSize = IsochInfoTable[pStrmEx->idxIsochTable].CompletePictureSize;
        if (pDevExt->HostControllerInfomation.HostCapabilities & HOST_INFO_SUPPORTS_RETURNING_ISO_HDR) {       
            Irb->u.IsochAllocateResources.nQuadletsToStrip = 1;
            Irb->u.IsochAllocateResources.fulFlags = RESOURCE_USED_IN_LISTENING | RESOURCE_STRIP_ADDITIONAL_QUADLETS;

        } else {
            Irb->u.IsochAllocateResources.nQuadletsToStrip = 0;
            Irb->u.IsochAllocateResources.fulFlags = RESOURCE_USED_IN_LISTENING;
        }

        Irb->u.IsochAllocateResources.hResource = 0;
        DbgMsg2(("\'DCamAllocateIsochResource: fullSpeed(%d), nMaxBytesPerFrame(%d), nMaxBufferSize(%d)\n", 
                              Irb->u.IsochAllocateResources.fulSpeed,
                              Irb->u.IsochAllocateResources.nMaxBytesPerFrame,
                              Irb->u.IsochAllocateResources.nMaxBufferSize));
        Status = DCamSubmitIrpSynch(pDevExt, Irp, Irb);          

        if(Status) {
            ERROR_LOG(("DCamAllocateIsochResource: Error %x while trying to allocate Isoch resources\n", Status));
            goto NoResource_abort;
        }


        pDevExt->hResource = Irb->u.IsochAllocateResources.hResource;

    }

    pDevExt->CurrentModeIndex = ModeIndex;
    DbgMsg2(("**IsochAlloc: hResource = %x\n", pDevExt->hResource));

    IoFreeIrp(Irp);     

    return STATUS_SUCCESS;



NoResource_abort:

    // Free bandwidth
    if(pDevExt->hBandwidth != NULL) {

        Irb->FunctionNumber = REQUEST_ISOCH_FREE_BANDWIDTH;
        Irb->Flags = 0;
        Irb->u.IsochFreeBandwidth.hBandwidth = pDevExt->hBandwidth;
        Status = DCamSubmitIrpSynch(pDevExt, Irp, Irb);
        pDevExt->hBandwidth = NULL;
        if(Status) {
            ERROR_LOG(("DCamAllocateIsochResource: Error %x while trying to free Isoch bandwidth\n", Status));
        }
    }

    // Free channel
    if (pDevExt->IsochChannel != ISOCH_ANY_CHANNEL) {

        Irb->FunctionNumber = REQUEST_ISOCH_FREE_CHANNEL;
        Irb->Flags = 0;
        Irb->u.IsochFreeChannel.nChannel = pDevExt->IsochChannel;
        Status = DCamSubmitIrpSynch(pDevExt, Irp, Irb);
        pDevExt->IsochChannel = ISOCH_ANY_CHANNEL;  // Reset it.

        if(Status) {
            ERROR_LOG(("DCamAllocateIsochResource: Error %x while trying to free Isoch channel\n", Status));
        }
    }


    IoFreeIrp(Irp);
    return STATUS_INSUFFICIENT_RESOURCES;
    
}


NTSTATUS
DCamFreeIsochResource (
    PDCAM_EXTENSION pDevExt,
    PIRB Irb,
    BOOL bFreeResource
    )
/*++

Routine Description:

    Free resource allocated in DCamAllocateIsochResource().

Arguments:

    Srb - Pointer to Stream request block

Return Value:

    Nothing

--*/
{
    PIRP Irp;
    CCHAR StackSize;
    NTSTATUS Status = STATUS_SUCCESS;


    PAGED_CODE();

    DbgMsg2(("\'DCamFreeIsochResource: enter; DevExt=%x, Irb=%x\n", pDevExt, Irb));

    ASSERT(pDevExt);
    ASSERT(Irb);


    if(Irb == 0 ||
       pDevExt == 0) {
       DbgMsg2(("\'DCamFreeIsochResource: ABORTED!\n"));
       return STATUS_SUCCESS;
    }
    //
    // Get an Irp so we can send some free commands down
    //
    StackSize = pDevExt->BusDeviceObject->StackSize;
    Irp = IoAllocateIrp(StackSize, FALSE);

    if (!Irp) {   
        ERROR_LOG(("DCamFreeIsochResource: Error %x while trying to allocate an Irp\n\n", Status));
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    //
    // 1. Free Resource
    //
    if (pDevExt->hResource && bFreeResource) {

        DbgMsg2(("\'DCamFreeIsochResource: Attempt to free ->hResource\n"));

        Irb->FunctionNumber = REQUEST_ISOCH_FREE_RESOURCES;
        Irb->Flags = 0;
        Irb->u.IsochFreeResources.hResource = pDevExt->hResource;
        Status = DCamSubmitIrpSynch(pDevExt, Irp, Irb);

        pDevExt->hResource = NULL;
        if (Status) {

            ERROR_LOG(("DCamFreeIsochResource: Error %x while trying to free Isoch resources\n\n", Status));
        }
    }

    //
    // 2. Free Channel
    //
    if (pDevExt->IsochChannel != ISOCH_ANY_CHANNEL) {

        DbgMsg2(("\'DCamFreeIsochResource: Attempt to free ->IsochChannel\n"));

        Irb->FunctionNumber = REQUEST_ISOCH_FREE_CHANNEL;
        Irb->Flags = 0;
        Irb->u.IsochFreeChannel.nChannel = pDevExt->IsochChannel;
        Status = DCamSubmitIrpSynch(pDevExt, Irp, Irb);

        pDevExt->IsochChannel = ISOCH_ANY_CHANNEL;

        if(Status) {
            
            ERROR_LOG(("DCamFreeIsochResource: Error %x while trying to free Isoch channel\n\n", Status));
        }
    }

    //
    // 3. Free Bandwidth
    //
    if (pDevExt->hBandwidth) {

        DbgMsg2(("\'DCamFreeIsochResource: Attempt to free ->hBandwidth\n"));

        Irb->FunctionNumber = REQUEST_ISOCH_FREE_BANDWIDTH;
        Irb->Flags = 0;
        Irb->u.IsochFreeBandwidth.hBandwidth = pDevExt->hBandwidth;
        Status = DCamSubmitIrpSynch(pDevExt, Irp, Irb);

        pDevExt->hBandwidth = NULL;

        if (Status) {

            ERROR_LOG(("DCamFreeIsochResource: Error %x while trying to free Isoch bandwidth\n", Status));
        }
    }

    DbgMsg2(("\'DCamFreeIsochResource: hResource = %x\n", pDevExt->hResource));


    IoFreeIrp(Irp);

    return STATUS_SUCCESS;

}



VOID 
InitializeStreamExtension(
    PDCAM_EXTENSION pDevExt,
    PHW_STREAM_OBJECT   pStreamObject,
    PSTREAMEX           pStrmEx
    )
{
    PAGED_CODE();

    pStrmEx->hMasterClock = 0;
    pStrmEx->FrameInfo.ExtendedHeaderSize = sizeof(KS_FRAME_INFO);
    pStrmEx->FrameInfo.PictureNumber = 0;
    pStrmEx->FrameInfo.DropCount     = 0;
    pStrmEx->FrameInfo.dwFrameFlags  = 0;     
    pStrmEx->FirstFrameTime    = 0;
    pStrmEx->pVideoInfoHeader  = 0;
    pStrmEx->KSState           = KSSTATE_STOP;
    pStrmEx->KSSavedState      = KSSTATE_STOP;


    KeInitializeMutex( &pStrmEx->hMutex, 0);  // Level 0 and in Signal state

}

BOOL
DCamDeviceInUse(
    PIRB pIrb,
    PDCAM_EXTENSION pDevExt
)
/*++

Routine Description:

    See if this device is in used.  
    We check ISO_ENABLE since this is the only register
    in a 1394DCam that we can set/get and 99%+ of time
    this bit is set by its owner.

Arguments:

    pIrb - Pointer to IEEE 1394 Request Block definition (IRB)
    pDevExt - this device extension

Return Value:

    TRUE:  Iso_enable != 0
    FALSE: iso_enable == 0

--*/

{
    DCamRegArea RegArea;
    NTSTATUS status;
    LONG lRetries = MAX_READ_REG_RETRIES;


    // If a device is removed, it is not available.
    if(pDevExt->bDevRemoved)
        return TRUE;

    do {
        RegArea.AsULONG = 0;
        status = DCamReadRegister(pIrb, pDevExt, FIELDOFFSET(CAMERA_REGISTER_MAP, IsoEnable), &(RegArea.AsULONG));
#if DBG
        if(!NT_SUCCESS(status))
            ERROR_LOG(("**** DCamDeviceInUse: Status %x, ISO_ENABLE %x\n", status, RegArea.AsULONG));
#endif
    } while (--lRetries > 0 && !NT_SUCCESS(status));

    if(NT_SUCCESS(status)) 
        return ((RegArea.AsULONG & ISO_ENABLE_BIT) == ISO_ENABLE_BIT);

    // failed to query the device.
    return TRUE;  // Assume it is in use.
}


VOID
DCamOpenStream(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )

/*++

Routine Description:

    Called when an OpenStream Srb request is received

Arguments:

    pSrb - Pointer to Stream request block

Return Value:

    Nothing

--*/

{

    PIRB Irb;
    ULONG nSize;
    PDCAM_EXTENSION pDevExt;
    PSTREAMEX pStrmEx;
    PKS_DATAFORMAT_VIDEOINFOHEADER  pKSDataFormat = 
                (PKS_DATAFORMAT_VIDEOINFOHEADER) pSrb->CommandData.OpenFormat;
    PKS_VIDEOINFOHEADER     pVideoInfoHdrRequested = 
                &pKSDataFormat->VideoInfoHeader;


    PAGED_CODE();

    Irb = (PIRB) pSrb->SRBExtension;
    pDevExt = (PDCAM_EXTENSION) pSrb->HwDeviceExtension;
    pStrmEx = (PSTREAMEX)pSrb->StreamObject->HwStreamExtension;

    DbgMsg2(("\'DCamOpenStream: >>> !!! pDevEx %x; pStrmEx %x !!!\n", pDevExt, pStrmEx));


    //
    // Cache the stream extension.
    //

    pDevExt->pStrmEx = pStrmEx; 


    //
    // default to success
    //

    pSrb->Status = STATUS_SUCCESS;

    //
    // determine which stream number is being opened.  This number indicates
    // the offset into the array of streaminfo structures that was filled out
    // in the AdapterStreamInfo call.
    //
    // So:
    //   0 - Video data from camera
    //

    switch (pSrb->StreamObject->StreamNumber) {

    case 0:

         //
         // Make sure that this device is not in used 
         //
         if(DCamDeviceInUse(Irb, pDevExt)) {
             ERROR_LOG(("Device is in used! Open Stream fail!!\n"));
             pDevExt->pStrmEx = NULL; 
             pSrb->Status = STATUS_UNSUCCESSFUL;
             return;
         }


         //
         // Figure out what format they're trying to open first
         //

         if (!AdapterVerifyFormat (pDevExt->ModeSupported, pDevExt->DCamStrmModes, pKSDataFormat, pSrb->StreamObject->StreamNumber)) {
             pDevExt->pStrmEx = NULL; 
             ERROR_LOG(("DCamOpenStream: AdapterVerifyFormat failed.\n"));
             pSrb->Status = STATUS_INVALID_PARAMETER;
             return;
         }

         InitializeStreamExtension(pDevExt, pSrb->StreamObject, pStrmEx);

         // It should already been freed by DCamCloseStream()
         ASSERT(pStrmEx->pVideoInfoHeader == NULL);
         ASSERT(pVideoInfoHdrRequested != (PKS_VIDEOINFOHEADER) 0);

         // Use this instead of sizeof(KS_VIDEOINFOHEADER) to handle variable size structure
         nSize = KS_SIZE_VIDEOHEADER (pVideoInfoHdrRequested);

         pStrmEx->pVideoInfoHeader = ExAllocatePoolWithTag(NonPagedPool, nSize, 'macd');
         if (pStrmEx->pVideoInfoHeader == NULL) {

             ERROR_LOG(("DCamOpenStream: ExAllocatePool (->pVideoInfoHeader) failed!\n"));
             ASSERT(pStrmEx->pVideoInfoHeader != NULL);

             pDevExt->pStrmEx = NULL;

             pSrb->Status = STATUS_INSUFFICIENT_RESOURCES;
             return;
         }

         // Copy the VIDEOINFOHEADER requested to our storage
         RtlCopyMemory(
                    pStrmEx->pVideoInfoHeader,
                    pVideoInfoHdrRequested,
                    nSize);

         DbgMsg3(("\'DCamOpenStream: Copied biSizeImage=%d Duration=%ld (100ns)\n", 
                    pStrmEx->pVideoInfoHeader->bmiHeader.biSizeImage, (DWORD) pStrmEx->pVideoInfoHeader->AvgTimePerFrame));

         // Allocate ISOCH resource
         pSrb->Status = DCamAllocateIsochResource(pDevExt, pSrb->SRBExtension, TRUE);               
         
         if (pSrb->Status) {

             ERROR_LOG(("DCamOpenStream: !!!! Allocate ISOCH resource failed.  CanNOT STREAM!!!!!\n"));
             
             ExFreePool(pStrmEx->pVideoInfoHeader);
             pStrmEx->pVideoInfoHeader = NULL;             
             pDevExt->pStrmEx = NULL;
             pSrb->Status = STATUS_INSUFFICIENT_RESOURCES;             
             return;
         } 

         pSrb->StreamObject->ReceiveDataPacket    = (PVOID) DCamReceiveDataPacket;
         pSrb->StreamObject->ReceiveControlPacket = (PVOID) DCamReceiveCtrlPacket;

         // If bus reset failed and user close the stream and reopen the stream successfully,
         // This must be reset !!
         if(pDevExt->bDevRemoved || pDevExt->bStopIsochCallback) {
            DbgMsg1(("Stream Open successful, reset bDevRemoved and bStopCallback!!\n"));
            pDevExt->bStopIsochCallback = FALSE;
            pDevExt->bDevRemoved = FALSE;
         }

         //
         // initialize the stream extension data handling information
         //

         break;

    default:
         ERROR_LOG(("DCamOpenStream: Hit a non-support pSrb->StreamObject->StreamNumber (%d).\n", pSrb->StreamObject->StreamNumber));
         ASSERT(FALSE);
         pDevExt->pStrmEx = NULL; 
         pSrb->Status = STATUS_INVALID_PARAMETER;
         return;
    }


    pSrb->StreamObject->HwClockObject.ClockSupportFlags = 0;

    // We don't use DMA.
    pSrb->StreamObject->Dma = FALSE;
    pSrb->StreamObject->StreamHeaderMediaSpecific = sizeof(KS_FRAME_INFO);

    //
    // The PIO flag must be set when the mini driver will be accessing the data
    // buffers passed in using logical addressing.  We are not going to touch these 
    // buffer at all.
    //
    pSrb->StreamObject->Pio = FALSE;


    //
    // Set to last saved configuration
    //
    SetCurrentDevicePropertyValues(pDevExt, (PIRB) pSrb->SRBExtension);


    DbgMsg1((" #OPEN_STREAM#: %s DCam, Status %x, pDevExt %x, pStrmEx %x, IsochDescriptorList is at %x\n", 
              pDevExt->pchVendorName, pSrb->Status, pDevExt, pDevExt->pStrmEx, &pDevExt->IsochDescriptorList));

    ASSERT(pSrb->Status == STATUS_SUCCESS);

}




VOID
DCamCloseStream(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
/*++

Routine Description:

    Called when an CloseStream Srb request is received.  We get this when calling user 
    application do a CloseHandle() on the pin connection handle.  This can happen after
    HwUninitialize().

Arguments:

    pSrb - Pointer to Stream request block

Return Value:

    Nothing

--*/
{
    PDCAM_EXTENSION pDevExt;
    PSTREAMEX     pStrmEx;
    PIRB pIrb;

    PAGED_CODE();

    pSrb->Status = STATUS_SUCCESS;

    pDevExt = (PDCAM_EXTENSION) pSrb->HwDeviceExtension;
    ASSERT(pDevExt);      
    if(!pDevExt) {
        StreamClassDeviceNotification(DeviceRequestComplete, pSrb->HwDeviceExtension, pSrb);
        return;
    }

    pStrmEx = (PSTREAMEX)pDevExt->pStrmEx;
    ASSERT(pStrmEx);
    if(!pStrmEx ) {
        StreamClassDeviceNotification(DeviceRequestComplete, pSrb->HwDeviceExtension, pSrb);
        return;    
    } 

    //
    // pDevExt->Irb might have been freed in HwUninitialize() 
    // due to Surprise removal; so we must use this:
    // 
    pIrb = (PIRB) pSrb->SRBExtension;


    //
    // If it is still in use (setting it to stop failed?),
    // we will diable ISO_ENABLE so other application can use it.
    //

    if(!pDevExt->bDevRemoved && 
       DCamDeviceInUse(pIrb, pDevExt)) {

        DbgMsg1(("DCamCloseStream: Is still in use! Disable it!\n"));
        // Disable EnableISO
        DCamIsoEnable(pIrb, pDevExt, FALSE);
    }


    //
    // Save current state and free resource alllocaed in OpenStream()
    //
    DCamSetPropertyValuesToRegistry(pDevExt);


    //
    // Free Isoch resource and master clock
    //

    DCamFreeIsochResource (pDevExt, pIrb, TRUE);
    if(pStrmEx->pVideoInfoHeader) {
        ExFreePool(pStrmEx->pVideoInfoHeader);
        pStrmEx->pVideoInfoHeader = NULL;
    }

    pStrmEx->hMasterClock = 0;
   

    //                                                 
    // If there are pening read, cancel them all.                                
    //
    if(pDevExt->PendingReadCount > 0) {

        DCamCancelAllPackets(
            pSrb,
            pDevExt,
            &pDevExt->PendingReadCount
            );
        
        pDevExt->pStrmEx = 0;

        return;  // SRB completed in CancelAllPackets       
    }
    
    pDevExt->pStrmEx = 0;

    StreamClassDeviceNotification(DeviceRequestComplete, pSrb->HwDeviceExtension, pSrb);

}




VOID
DCamTimeoutHandler(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
/*++

Routine Description:

    This routine is called when a packet has been in the minidriver too long (Srb->TimeoutCounter == 0).
    We will cancel the SRB if we are in the RUN state; else set ->TimeoutCounter and return.
    We assume the cancel SRB is serialized and in the same order as it is read.  So this timeout is
    applying to the head of the queue.

Arguments:

    pSrb - Pointer to Stream request block that has timeout.

Return Value:

    Nothing

--*/

{
    PDCAM_EXTENSION pDevExt;
    PSTREAMEX pStrmEx;

    // Called from StreamClass at DisptchLevel


    //
    // We only expect stream SRB, but not device SRB.  
    //

    if ( (pSrb->Flags & SRB_HW_FLAGS_STREAM_REQUEST) != SRB_HW_FLAGS_STREAM_REQUEST) {
        ERROR_LOG(("DCamTimeoutHandler: Device SRB %x (cmd:%x) timed out!\n", pSrb, pSrb->Command));
        return;
    } 


    //
    // StreamSRB only valid if we have a stream extension
    //

    pDevExt = (PDCAM_EXTENSION) pSrb->HwDeviceExtension;
    ASSERT(pDevExt);
    pStrmEx = (PSTREAMEX) pDevExt->pStrmEx;

    if(!pStrmEx) {
        ERROR_LOG(("DCamTimeoutHandler: Stream SRB %x timeout with pDevExt %x, pStrmEx %x\n", pSrb, pDevExt, pStrmEx));
        ASSERT(pStrmEx);
        return;
    }
 
    //
    // Cancel IRP only if in RUN state, BUT...
    // Note: if we are TIMEOUT and in RUN state, something is terribley wrong.  
    //       but I guess that can happen when it is being suspended;
    //       so we will extend the time out for all states.
    //

    DbgMsg2(("\'DCamTimeoutHandler: pSrb %x, %s state, PendingReadCount %d.\n", 
        pSrb, 
        pStrmEx->KSState == KSSTATE_RUN   ? "RUN" : 
        pStrmEx->KSState == KSSTATE_PAUSE ? "PAUSE":
        pStrmEx->KSState == KSSTATE_STOP  ? "STOP": "Unknown",
        pDevExt->PendingReadCount));   

    // ASSERT(pStrmEx->KSState == KSSTATE_PAUSE);


    //
    // Reset Timeout counter, or we are going to get this call immediately.
    //

    pSrb->TimeoutCounter = pSrb->TimeoutOriginal;

}


NTSTATUS
DCamStartListenCR(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrp,
    IN PDCAM_IO_CONTEXT pDCamIoContext    
    )

/*++

Routine Description:

    Returns more processing required so the IO Manager will leave us alone

Arguments:

    DriverObject - Pointer to driver object created by system.

    pIrp - Irp that just completed

    pDCamIoContext - Context 

Return Value:

    None.

--*/

{
    PDCAM_EXTENSION pDevExt;
    NTSTATUS Status;
    PIRB pIrb; 
    PIO_STACK_LOCATION NextIrpStack;

#ifdef WAIT_FOR_SLOW_DEVICE
    KeStallExecutionProcessor(5000);  // 5 msec
#endif

    DbgMsg2(("\'DCamStartListenCR: pIrp->IoStatus.Status=%x\n", pIrp->IoStatus.Status));

    if(STATUS_SUCCESS != pIrp->IoStatus.Status) {

        pDevExt = pDCamIoContext->pDevExt;
        pIrb = pDCamIoContext->pIrb;

        if(pDevExt->lRetries > 0) {

            pDevExt->lRetries--;
            DbgMsg1(("DCamStartListenCR: Try DCAM_RUNSTATE_SET_REQUEST_ISOCH_LISTEN again!\n"));
            
            pIrb->FunctionNumber = REQUEST_ISOCH_LISTEN;
            pIrb->Flags = 0;
            pIrb->u.IsochListen.hResource = pDevExt->hResource;
            pIrb->u.IsochListen.fulFlags = 0;

            NextIrpStack = IoGetNextIrpStackLocation(pIrp);
            NextIrpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
            NextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_1394_CLASS;
            NextIrpStack->Parameters.Others.Argument1 = pIrb;

            IoSetCompletionRoutine(
                pIrp,
                DCamStartListenCR,
                pDCamIoContext,
                TRUE,
                TRUE,
                TRUE
                );

            Status =
                IoCallDriver(
                    pDevExt->BusDeviceObject, 
                    pIrp);

            return STATUS_MORE_PROCESSING_REQUIRED;

        } else {
            ERROR_LOG(("Start Listening has failed Status=%x; try again in next read.\n", pIrp->IoStatus.Status)); 
            pDCamIoContext->pDevExt->bNeedToListen = TRUE;
        }
    }

    DCamFreeIrbIrpAndContext(pDCamIoContext, pDCamIoContext->pIrb, pIrp);

    // No StreamClassDeviceNotification() here since 
    // this is local initiated Irb (as part of AttachBufferCR().

    return STATUS_MORE_PROCESSING_REQUIRED;

}





/*
** AdapterCompareGUIDsAndFormatSize()
**
**   Checks for a match on the three GUIDs and FormatSize
**
** Arguments:
**
**         IN DataRange1
**         IN DataRange2
**
** Returns:
** 
**   TRUE if all elements match
**   FALSE if any are different
**
** Side Effects:  none
*/

BOOL 
AdapterCompareGUIDsAndFormatSize(
    IN PKSDATARANGE DataRange1,
    IN PKSDATARANGE DataRange2)
{
    PAGED_CODE();

    return (
        IsEqualGUID (
            &DataRange1->MajorFormat, 
            &DataRange2->MajorFormat) &&
        IsEqualGUID (
            &DataRange1->SubFormat, 
            &DataRange2->SubFormat) &&
        IsEqualGUID (
            &DataRange1->Specifier, 
            &DataRange2->Specifier) &&
        (DataRange1->FormatSize == DataRange2->FormatSize));
}

/*
** AdapterVerifyFormat()
**
**   Checks the validity of a format request by walking through the
**       array of supported PKSDATARANGEs for a given stream.
**
** Arguments:
**
**   pKSDataFormatVideoToVerify - pointer of a KS_DATAFORMAT_VIDEOINFOHEADER structure.
**   StreamNumber - index of the stream being queried / opened.
**
** Returns:
** 
**   TRUE if the format is supported
**   FALSE if the format cannot be suppored
**
** Side Effects:  none
*/

BOOL 
AdapterVerifyFormat(
    ULONG VideoModesSupported,
    PKSDATAFORMAT  *pDCamStrmModesSupported,
    PKS_DATAFORMAT_VIDEOINFOHEADER pDataFormatVideoToVerify, 
    int StreamNumber)
{
    PKS_VIDEOINFOHEADER         pVideoInfoHdrToVerify = &pDataFormatVideoToVerify->VideoInfoHeader;
    PKSDATAFORMAT               *paDataFormatsVideoAvail;  // an array of PKSDATAFORMAT (not PKS_DATARANGE_VIDEO !!)
    PKS_DATARANGE_VIDEO         pDataRangeVideo;
    KS_VIDEO_STREAM_CONFIG_CAPS *pConfigCaps; 
    PKS_BITMAPINFOHEADER        pbmiHeader, 
                                pbmiHeaderToVerify;
    int                         j;

    PAGED_CODE();
    
    //
    // Make sure the stream index is valid
    // We only has one capure pin/stream (index 0).
    //
    if (StreamNumber >= 1) {
        return FALSE;
    }

    //
    // Get the pointer to the array of available formats
    //
    paDataFormatsVideoAvail = &pDCamStrmModesSupported[0]; // &pDevExt->DCamStrmModes[0];


    //
    // Walk the array, searching for a match
    //
    for (j = 0; j < (LONG) VideoModesSupported; j++, paDataFormatsVideoAvail++) {

        pDataRangeVideo = (PKS_DATARANGE_VIDEO) *paDataFormatsVideoAvail;
        
        //
        // Check for matching size, Major Type, Sub Type, and Specifier
        //

        //
        // Check for matching size, Major Type, Sub Type, and Specifier
        //

        if (!IsEqualGUID (&pDataRangeVideo->DataRange.MajorFormat, 
            &pDataFormatVideoToVerify->DataFormat.MajorFormat)) {
               DbgMsg2(("\'%d) AdapterVerifyFormat: MajorFormat mismatch!\n", j));
               continue;
        }

        if (!IsEqualGUID (&pDataRangeVideo->DataRange.SubFormat, 
            &pDataFormatVideoToVerify->DataFormat.SubFormat)) {
               DbgMsg2(("\'%d) AdapterVerifyFormat: SubFormat mismatch!\n", j));
               continue;
        }

        if (!IsEqualGUID (&pDataRangeVideo->DataRange.Specifier,
            &pDataFormatVideoToVerify->DataFormat.Specifier)) {
               DbgMsg2(("\'%d) AdapterVerifyFormat: Specifier mismatch!\n", j));
               continue;
        }

        if(pDataFormatVideoToVerify->DataFormat.FormatSize < 
            sizeof(KS_DATAFORMAT_VIDEOINFOHEADER))
            continue;

        //
        // Only if we get here, we are certain that we are dealing with video info.
        //

        // We do not support scaling or cropping so the dimension 
        // (biWidth, biHeight, biBitCount and biCompression)
        // must match.
        // 
        pbmiHeader         = &pDataRangeVideo->VideoInfoHeader.bmiHeader;
        pbmiHeaderToVerify = &pDataFormatVideoToVerify->VideoInfoHeader.bmiHeader;

        if(pbmiHeader->biWidth       != pbmiHeaderToVerify->biWidth    ||
           pbmiHeader->biHeight      != pbmiHeaderToVerify->biHeight   ||
           pbmiHeader->biBitCount    != pbmiHeaderToVerify->biBitCount ||
           pbmiHeader->biCompression != pbmiHeaderToVerify->biCompression
           ) {

            DbgMsg2(("AdapterVerifyFormat: Supported: %dx%dx%d [%x] != ToVerify: %dx%dx%d [%x]\n",
                    pbmiHeader->biWidth, pbmiHeader->biHeight,  pbmiHeader->biBitCount, pbmiHeader->biCompression,
                    pbmiHeaderToVerify->biWidth, pbmiHeaderToVerify->biHeight,  pbmiHeaderToVerify->biBitCount, pbmiHeaderToVerify->biCompression));
            continue;
        }

        // biSizeImage must be to be BIG ENOUGH
        if(pbmiHeaderToVerify->biSizeImage < pbmiHeader->biSizeImage) {

            DbgMsg2(("AdapterVerifyFormat: biSizeImageToVerify %d < required %x\n", 
                pbmiHeaderToVerify->biSizeImage, pbmiHeader->biSizeImage));
            continue;
        }

        // Frame rate needs to be within range
        pConfigCaps = &pDataRangeVideo->ConfigCaps;
        if(pDataFormatVideoToVerify->VideoInfoHeader.AvgTimePerFrame > pConfigCaps->MaxFrameInterval &&
           pDataFormatVideoToVerify->VideoInfoHeader.AvgTimePerFrame < pConfigCaps->MinFrameInterval) {

           DbgMsg2(("\'format index %d) AdapterVerifyFormat: Frame rate %ld is not within range(%ld, %ld)!\n", 
              j, pDataFormatVideoToVerify->VideoInfoHeader.AvgTimePerFrame,
              pConfigCaps->MaxFrameInterval, pConfigCaps->MinFrameInterval));
           continue;
        }


        //
        // The format passed all of the tests, so we support it
        //

        DbgMsg2(("\'(format idx %d) AdapterVerifyFormat: Verify!! Width=%d, Height=%d, biBitCount=%d, biSizeImage=%d\n", j,
            pbmiHeaderToVerify->biWidth, pbmiHeaderToVerify->biHeight, pbmiHeaderToVerify->biBitCount,pbmiHeaderToVerify->biSizeImage));
        DbgMsg2(("AdapterVerifyFormat: AvgTimePerFrame = %ld\n", pDataFormatVideoToVerify->VideoInfoHeader.AvgTimePerFrame));
        DbgMsg2(("AdapterVerifyFormat: (Max %ld\n", pConfigCaps->MaxFrameInterval));
        DbgMsg2(("AdapterVerifyFormat:               Min %ld)\n", pConfigCaps->MinFrameInterval));

        return TRUE;
    } 

    //
    // The format requested didn't match any of our listed ranges,
    // so refuse the connection.
    //
    DbgMsg2(("AdapterVerifyFormat: This format is not supported!\n"));

    return FALSE;
}



/*
** AdapterFormatFromRange()
**
**   Examine the given data format with many key fields and 
**   return a complete data format that can be used to open a stream.
**
** Arguments:
**
**   IN PHW_STREAM_REQUEST_BLOCK Srb 
**
** Returns:
** 
**   TRUE if the format is supported
**   FALSE if the format cannot be suppored
**
** Side Effects:  none
*/
BOOL 
AdapterFormatFromRange(
    IN PHW_STREAM_REQUEST_BLOCK Srb)
{
    PDCAM_EXTENSION             pDevExt = (PDCAM_EXTENSION) Srb->HwDeviceExtension;
    PSTREAM_DATA_INTERSECT_INFO IntersectInfo;
    PKSDATARANGE                DataRange,
                                *pAvailableFormats;  // KSDATARANGE == KSDATAFORMAT
    PKS_DATARANGE_VIDEO         DataRangeVideoToVerify,
                                DataRangeVideo;
    PKS_BITMAPINFOHEADER        pbmiHeader, 
                                pbmiHeaderToVerify;
    ULONG                       FormatSize;
    BOOL                        MatchFound = FALSE;
    ULONG                       j;


    PAGED_CODE();

    Srb->Status = STATUS_SUCCESS;
    IntersectInfo = Srb->CommandData.IntersectInfo;
    DataRange = IntersectInfo->DataRange;
    DbgMsg2(("IntersectIfo->DataFormatBuffer=%x, size=%d\n", IntersectInfo->DataFormatBuffer, IntersectInfo->SizeOfDataFormatBuffer));


    //
    // Check that the stream number is valid
    // We support only one capture pin/stream (index 0)
    //

    if (IntersectInfo->StreamNumber >= 1) {

        Srb->Status = STATUS_NOT_IMPLEMENTED;
        ERROR_LOG(("\'AdapterFormatFromRange: StreamNumber(=%d) is not implemented.\n", IntersectInfo->StreamNumber));
        ASSERT(FALSE);
        return FALSE;
    }


    //
    // Get the pointer to the array of available formats
    //

    pAvailableFormats = &pDevExt->DCamStrmModes[0];


    //
    // Walk the formats supported by the stream searching for a match
    // of the three GUIDs which together define a DATARANGE
    //
    
    DataRangeVideoToVerify = (PKS_DATARANGE_VIDEO) DataRange;

    for (j = 0; j < pDevExt->ModeSupported; j++, pAvailableFormats++) {
       
        DataRangeVideo = (PKS_DATARANGE_VIDEO) *pAvailableFormats;

        //
        // STREAM_DATA_INTERSECT_INFO
        //  [IN]   ULONG        StreamNumber;
        //  [IN]   PKSDATARANGE DataRange;   
        //  [OUT]  PVOID        DataFormatBuffer;   // == PKS_DATAFORMAT_VIDEOINFOHEADER
        //  [OUT]  ULONG        SizeOfDataFormatBuffer;
        //
        
        //
        // KS_DATAFORMAT_VIDEOINFOHEADER:
        //    fields marked with 'm' must match; 
        //           marked with 'r' must within range;
        //           marked with 'f' is filled by us
        //
        //     KSDATAFORMAT == KSDATARANGE
        //       m ULONG   FormatSize;
        //         ULONG   Flags;
        //         ULONG   SampleSize;
        //         ULONG   Reserved;
        //       m GUID    MajorFormat;
        //       m GUID    SubFormat;
        //       m GUID    Specifier;.
        //  m  BOOL                         bFixedSizeSamples;      // all samples same size?
        //  m  BOOL                         bTemporalCompression;   // all I frames?
        //  m  DWORD                        StreamDescriptionFlags; // KS_VIDEO_DESC_*
        //  m  DWORD                        MemoryAllocationFlags;  // KS_VIDEO_ALLOC_*
        //  m  KS_VIDEO_STREAM_CONFIG_CAPS  ConfigCaps;
        //     KS_VIDEOINFOHEADER 
        //         RECT                rcSource;          // The bit we really want to use
        //         RECT                rcTarget;          // Where the video should go
        //         DWORD               dwBitRate;         // Approximate bit data rate
        //         DWORD               dwBitErrorRate;    // Bit error rate for this stream
        //     r/f REFERENCE_TIME      AvgTimePerFrame;   // Average time per frame (100ns units)
        //         KS_BITMAPINFOHEADER bmiHeader;
        //             DWORD      biSize;
        //       m     LONG       biWidth;
        //       m     LONG       biHeight;
        //             WORD       biPlanes;
        //       m     WORD       biBitCount;
        //       m     DWORD      biCompression;
        //       f     DWORD      biSizeImage;
        //             LONG       biXPelsPerMeter;
        //             LONG       biYPelsPerMeter;
        //             DWORD      biClrUsed;
        //             DWORD      biClrImportant;
        //     

        // Verify that it is a VIDEO format/range.
        if (!AdapterCompareGUIDsAndFormatSize((PKSDATARANGE)DataRangeVideoToVerify, (PKSDATARANGE)DataRangeVideo)) {
            continue;
        }
    
        //
        // It is valid video format/range; now check that the other fields match
        //
        if ((DataRangeVideoToVerify->bFixedSizeSamples      != DataRangeVideo->bFixedSizeSamples)      ||
            (DataRangeVideoToVerify->bTemporalCompression   != DataRangeVideo->bTemporalCompression)   ||
            (DataRangeVideoToVerify->StreamDescriptionFlags != DataRangeVideo->StreamDescriptionFlags) ||
            (DataRangeVideoToVerify->MemoryAllocationFlags  != DataRangeVideo->MemoryAllocationFlags)  ||
            (RtlCompareMemory (&DataRangeVideoToVerify->ConfigCaps, &DataRangeVideo->ConfigCaps, sizeof(KS_VIDEO_STREAM_CONFIG_CAPS)) != sizeof(KS_VIDEO_STREAM_CONFIG_CAPS))) {

            continue;
        }

        //
        // We do not support scaling or cropping so the dimension 
        // (biWidth, biHeight, biBitCount and biCompression)
        // must match, and we will filled in the biSizeImage and others.
        // 
        pbmiHeader         = &DataRangeVideo->VideoInfoHeader.bmiHeader;
        pbmiHeaderToVerify = &DataRangeVideoToVerify->VideoInfoHeader.bmiHeader;

        if(pbmiHeader->biWidth       != pbmiHeaderToVerify->biWidth    ||
           abs(pbmiHeader->biHeight) != abs(pbmiHeaderToVerify->biHeight)  ||
           pbmiHeader->biBitCount    != pbmiHeaderToVerify->biBitCount ||
           pbmiHeader->biCompression != pbmiHeaderToVerify->biCompression
           ) {

            DbgMsg1(("AdapterFormatFromRange: Supported: %dx%dx%d [%x] != ToVerify: %dx%dx%d [%x]\n",
                    pbmiHeader->biWidth, pbmiHeader->biHeight,  pbmiHeader->biBitCount, pbmiHeader->biCompression,
                    pbmiHeaderToVerify->biWidth, pbmiHeaderToVerify->biHeight,  pbmiHeaderToVerify->biBitCount, pbmiHeaderToVerify->biCompression));
            continue;
        }


        // MATCH FOUND!
        MatchFound = TRUE; 
        


        // KS_DATAFORMAT_VIDEOINFOHEADER
        //    KSDATAFORMAT            DataFormat;
        //    KS_VIDEOINFOHEADER      VideoInfoHeader;
        FormatSize = sizeof (KSDATAFORMAT) +  KS_SIZE_VIDEOHEADER (&DataRangeVideo->VideoInfoHeader);

        //    
        // 1st query:  Srb->ActualBytesTransferred = FormatSize
        //

        if(IntersectInfo->SizeOfDataFormatBuffer == 0) {

            Srb->Status = STATUS_BUFFER_OVERFLOW;
            // We actually have not returned this much data,
            // this "size" will be used by Ksproxy to send down 
            // a buffer of that size in next query.
            Srb->ActualBytesTransferred = FormatSize;
            break;
        }


        //
        // 2nd time: pass back the format information
        //

        if (IntersectInfo->SizeOfDataFormatBuffer < FormatSize) {
            Srb->Status = STATUS_BUFFER_TOO_SMALL;
            DbgMsg2(("IntersectInfo->SizeOfDataFormatBuffer=%d, FormatSize=%d\n", IntersectInfo->SizeOfDataFormatBuffer, FormatSize));
            return FALSE;
        }

        //
        // A match is found,  Copy from our supported/matched data range and set frame rate:
        // KS_DATAFORMAT_VIDEOINFOHEADER
        //    KSDATAFORMAT            DataFormat;
        //    KS_VIDEOINFOHEADER      VideoInfoHeader;
        //
        
        RtlCopyMemory(
            &((PKS_DATAFORMAT_VIDEOINFOHEADER)IntersectInfo->DataFormatBuffer)->DataFormat,
            &DataRangeVideo->DataRange,
            sizeof (KSDATAFORMAT));

        RtlCopyMemory(
            &((PKS_DATAFORMAT_VIDEOINFOHEADER) IntersectInfo->DataFormatBuffer)->VideoInfoHeader,  // KS_VIDEOINFOHEADER
            &DataRangeVideo->VideoInfoHeader,                                                      // KS_VIDEOINFOHEADER
            KS_SIZE_VIDEOHEADER (&DataRangeVideo->VideoInfoHeader));  // Use KS_SIZE_VIDEOHEADER() since this is variable size       

        //
        // Special atttention to these two fields: biSizeImage and AvgTimePerFrame.
        // We do not scale or stretch so biSizeImage is fixed.
        // However, AvgTimePerFrame (FrameRate) can/need to be within (ConfigCaps.MinFrameInterval, ConfigCaps.MaxFrameInterval)
        //

        if (DataRangeVideoToVerify->VideoInfoHeader.AvgTimePerFrame > DataRangeVideoToVerify->ConfigCaps.MaxFrameInterval ||      
            DataRangeVideoToVerify->VideoInfoHeader.AvgTimePerFrame < DataRangeVideoToVerify->ConfigCaps.MinFrameInterval) {
         
            ((PKS_DATAFORMAT_VIDEOINFOHEADER) IntersectInfo->DataFormatBuffer)->VideoInfoHeader.AvgTimePerFrame = 
                 DataRangeVideo->VideoInfoHeader.AvgTimePerFrame;
            DbgMsg2(("AdapterFormatFromRange: out of range; so set it to default (%ld)\n",DataRangeVideo->VideoInfoHeader.AvgTimePerFrame));
        } else {

            ((PKS_DATAFORMAT_VIDEOINFOHEADER) IntersectInfo->DataFormatBuffer)->VideoInfoHeader.AvgTimePerFrame = 
                  DataRangeVideoToVerify->VideoInfoHeader.AvgTimePerFrame;
        }

        ((PKSDATAFORMAT)IntersectInfo->DataFormatBuffer)->FormatSize = FormatSize;
        Srb->ActualBytesTransferred = FormatSize;

        DbgMsg2(("AdapterFormatFromRange: match found: [%x], %dx%dx%d=%d, AvgTimePerFrame %ld\n",
                pbmiHeader->biCompression, pbmiHeader->biWidth, pbmiHeader->biHeight,  pbmiHeader->biBitCount, pbmiHeader->biSizeImage,
                ((PKS_DATAFORMAT_VIDEOINFOHEADER) IntersectInfo->DataFormatBuffer)->VideoInfoHeader.AvgTimePerFrame));
        break;

    } // End of loop on all formats for this stream

    if(!MatchFound) {

        DbgMsg2(("AdapterFormatFromRange: No match !!\n"));
        Srb->Status = STATUS_NO_MATCH;
        return FALSE;
    }

    return TRUE;
}

BOOL
DCamBuildFormatTable(
    PDCAM_EXTENSION pDevExt,
    PIRB pIrb
    )
/*
    Description:

        Query Video format and mode supported by the camera.

    Return:

       TRUE: support at least one mode
       FALSE: failed to read mode register or do not support any mode.
*/
{
    // Initialize 
    pDevExt->ModeSupported = 0;

    if(DCamGetVideoMode(pDevExt, pIrb)) {

#ifdef SUPPORT_YUV444
        // Mode0: 160x120 (4:4:4)
        if(pDevExt->DCamVModeInq0.VMode.Mode0 == 1 && pDevExt->DecoderDCamVModeInq0.VMode.Mode0 == 1) {
            pDevExt->DCamStrmModes[pDevExt->ModeSupported] = (PKSDATAFORMAT) &DCAM_StreamMode_0;
            pDevExt->ModeSupported++;
        }
#endif
        // Mode1: 320x240 (4:2:2)
        if(pDevExt->DCamVModeInq0.VMode.Mode1 == 1 && pDevExt->DecoderDCamVModeInq0.VMode.Mode1 == 1) {
            pDevExt->DCamStrmModes[pDevExt->ModeSupported] = (PKSDATAFORMAT) &DCAM_StreamMode_1;
            pDevExt->ModeSupported++;
        }

#ifdef SUPPORT_YUV411
        // Mode2: 640x480 (4:1:1)
        if(pDevExt->DCamVModeInq0.VMode.Mode2 == 1 && pDevExt->DecoderDCamVModeInq0.VMode.Mode2 == 1) {
            pDevExt->DCamStrmModes[pDevExt->ModeSupported] = (PKSDATAFORMAT) &DCAM_StreamMode_2;
            pDevExt->ModeSupported++;
        }
#endif

        // Mode3: 640x480 (4:2:2)
        if(pDevExt->DCamVModeInq0.VMode.Mode3 == 1 && pDevExt->DecoderDCamVModeInq0.VMode.Mode3 == 1) {
            pDevExt->DCamStrmModes[pDevExt->ModeSupported] = (PKSDATAFORMAT) &DCAM_StreamMode_3;        
            pDevExt->ModeSupported++;
        }

#ifdef SUPPORT_RGB24
        // Mode4: 640x480 (RGB24)
        if(pDevExt->DCamVModeInq0.VMode.Mode4 == 1 && pDevExt->DecoderDCamVModeInq0.VMode.Mode4 == 1) {
            pDevExt->DCamStrmModes[pDevExt->ModeSupported] = (PKSDATAFORMAT) &DCAM_StreamMode_4;
            pDevExt->ModeSupported++;
        }
#endif

#ifdef SUPPORT_YUV800
        // Mode5: 640x480 (Y800)
        if(pDevExt->DCamVModeInq0.VMode.Mode5 == 1 && pDevExt->DecoderDCamVModeInq0.VMode.Mode5 == 1) {
            pDevExt->DCamStrmModes[pDevExt->ModeSupported] = (PKSDATAFORMAT) &DCAM_StreamMode_5;
            pDevExt->ModeSupported++;
        }
#endif
    } 

    DbgMsg1(("\'Support %d modes; ->DCamStrmModes[]:%x\n", pDevExt->ModeSupported, &pDevExt->DCamStrmModes[0]));
    ASSERT(pDevExt->ModeSupported > 0);

    return (pDevExt->ModeSupported > 0);
}

/*
** VideoGetProperty()
**
**    Routine to process video property requests
**
** Arguments:
**
**    Srb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID 
VideoGetProperty(
    PHW_STREAM_REQUEST_BLOCK Srb)
{
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = Srb->CommandData.PropertyInfo;


    // preset to success

    Srb->Status = STATUS_SUCCESS;

    if (IsEqualGUID (&KSPROPSETID_Connection, &pSPD->Property->Set)) {
        VideoStreamGetConnectionProperty (Srb);
    } else if (IsEqualGUID (&PROPSETID_VIDCAP_DROPPEDFRAMES, &pSPD->Property->Set)) {
        VideoStreamGetDroppedFramesProperty (Srb);
    } else {
        Srb->Status = STATUS_NOT_IMPLEMENTED;
    }

}


/*
** VideoGetState()
**
**    Gets the current state of the requested stream
**
** Arguments:
**
**    Srb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID 
VideoGetState(
    PHW_STREAM_REQUEST_BLOCK Srb)
{
    PDCAM_EXTENSION pDevExt = (PDCAM_EXTENSION) Srb->HwDeviceExtension;
    PSTREAMEX pStrmEx = pDevExt->pStrmEx;

    PAGED_CODE();

    DbgMsg2(("\'%d:%s) VideoGetState: KSSTATE=%s.\n", 
          pDevExt->idxDev, pDevExt->pchVendorName, 
          pStrmEx->KSState == KSSTATE_STOP ? "STOP" : 
          pStrmEx->KSState == KSSTATE_PAUSE ? "PAUSE" :     
          pStrmEx->KSState == KSSTATE_RUN ? "RUN" : "ACQUIRE"));

    Srb->CommandData.StreamState = pStrmEx->KSState;
    Srb->ActualBytesTransferred = sizeof (KSSTATE);

    // A very odd rule:
    // When transitioning from stop to pause, DShow tries to preroll
    // the graph.  Capture sources can't preroll, and indicate this
    // by returning VFW_S_CANT_CUE in user mode.  To indicate this
    // condition from drivers, they must return ERROR_NO_DATA_DETECTED

    Srb->Status = STATUS_SUCCESS;


    if (pStrmEx->KSState == KSSTATE_PAUSE) {
       Srb->Status = STATUS_NO_DATA_DETECTED;
    }
}


VOID  
VideoStreamGetConnectionProperty (
    PHW_STREAM_REQUEST_BLOCK Srb)
{
    PDCAM_EXTENSION pDevExt = (PDCAM_EXTENSION) Srb->HwDeviceExtension;
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = Srb->CommandData.PropertyInfo;
    ULONG Id = pSPD->Property->Id;              // index of the property
    PSTREAMEX pStrmEx = (PSTREAMEX) pDevExt->pStrmEx;
    ASSERT(pStrmEx == (PSTREAMEX)Srb->StreamObject->HwStreamExtension);

    PAGED_CODE();

    switch (Id) {

    case KSPROPERTY_CONNECTION_ALLOCATORFRAMING:

        if (pStrmEx->pVideoInfoHeader) {

            PKSALLOCATOR_FRAMING Framing = 
                (PKSALLOCATOR_FRAMING) pSPD->PropertyInfo;
            Framing->RequirementsFlags =
                KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY |
                KSALLOCATOR_REQUIREMENTF_INPLACE_MODIFIER |
                KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY;
            Framing->PoolType = PagedPool;
            Framing->Frames = MAX_BUFFERS_SUPPLIED; 
            Framing->FrameSize = pStrmEx->pVideoInfoHeader->bmiHeader.biSizeImage;
            Framing->FileAlignment = FILE_BYTE_ALIGNMENT; // 0: Basically no alignment by spec
            Framing->Reserved = 0;
            Srb->ActualBytesTransferred = sizeof (KSALLOCATOR_FRAMING);
            Srb->Status = STATUS_SUCCESS;
               DbgMsg2(("\'VideoStreamGetConnectionProperty: status=0x%x, Alignment %d, Frame %d, FrameSize %d\n",
                    Srb->Status, Framing->FileAlignment+1, Framing->Frames, Framing->FrameSize));

        } else {

            Srb->Status = STATUS_INVALID_PARAMETER;
            DbgMsg2(("\'VideoStreamGetConnectionProperty: status=0x\n",Srb->Status));
        }
        break;

    default:
        ERROR_LOG(("VideoStreamGetConnectionProperty: Unsupported property id=%d\n",Id));
        ASSERT(FALSE);
        break;
    }
}

/*
** VideoStreamGetConnectionProperty()
**
**    Gets the current state of the requested stream
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID
VideoStreamGetDroppedFramesProperty(
    PHW_STREAM_REQUEST_BLOCK Srb
    )
{
    PSTREAMEX pStrmEx = (PSTREAMEX)Srb->StreamObject->HwStreamExtension;
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = Srb->CommandData.PropertyInfo;
    ULONG Id = pSPD->Property->Id;              // index of the property
    ULONGLONG tmStream;

    PAGED_CODE();

    switch (Id) {

    case KSPROPERTY_DROPPEDFRAMES_CURRENT:
         {

         PKSPROPERTY_DROPPEDFRAMES_CURRENT_S pDroppedFrames = 
                     (PKSPROPERTY_DROPPEDFRAMES_CURRENT_S) pSPD->PropertyInfo;

         if (pStrmEx->hMasterClock) {
                    
             tmGetStreamTime(Srb, pStrmEx, &tmStream);

             if (tmStream < pStrmEx->FirstFrameTime) {
                 DbgMsg2(("\'*DroppedFP: Tm(%dms) < 1stFrameTm(%d)\n",
                           (LONG) tmStream/10000, (LONG)pStrmEx->FirstFrameTime));
                 pDroppedFrames->DropCount = 0;
             } else {
                 pDroppedFrames->DropCount = (tmStream - pStrmEx->FirstFrameTime)
                                / pStrmEx->pVideoInfoHeader->AvgTimePerFrame + 1 - pStrmEx->FrameCaptured;
             }

             if (pDroppedFrames->DropCount < 0)
                 pDroppedFrames->DropCount = 0;
                    
         } else {
             pDroppedFrames->DropCount = 0;
         }

         // Update our drop frame here. "pDroppedFrames->DropCount" is return when a frame is returned. 
         if (pDroppedFrames->DropCount > pStrmEx->FrameInfo.DropCount) {
             pStrmEx->FrameInfo.DropCount = pDroppedFrames->DropCount;
             //pStrmEx->bDiscontinue = TRUE;
         } else {
             pDroppedFrames->DropCount = pStrmEx->FrameInfo.DropCount;
         }

         pDroppedFrames->AverageFrameSize = pStrmEx->pVideoInfoHeader->bmiHeader.biSizeImage;
         pDroppedFrames->PictureNumber = pStrmEx->FrameCaptured + pDroppedFrames->DropCount;

         // Correction if no picture has been successfully capture in the IsochCallback.
         if (pDroppedFrames->PictureNumber < pDroppedFrames->DropCount)
             pDroppedFrames->PictureNumber = pDroppedFrames->DropCount;

         DbgMsg2(("\'*DroppedFP: tm(%d); Pic#(%d)=?Cap(%d)+Drp(%d)\n",
                  (ULONG) tmStream/10000,
                  (LONG) pDroppedFrames->PictureNumber,
                  (LONG) pStrmEx->FrameCaptured,
                  (LONG) pDroppedFrames->DropCount));
               
         Srb->ActualBytesTransferred = sizeof (KSPROPERTY_DROPPEDFRAMES_CURRENT_S);
               Srb->Status = STATUS_SUCCESS;

         }
         break;

    default:
        ERROR_LOG(("VideoStreamGetDroppedFramesProperty: Unsupported property id=%d\n",Id));
        ASSERT(FALSE);
        break;
    }
}




VOID 
VideoIndicateMasterClock(
    PHW_STREAM_REQUEST_BLOCK Srb)
/*++

Routine Description:

    Assign a master clock for this stream.

Arguments:

    pSrb - Pointer to Stream request block

Return Value:

    Nothing

--*/
{


    PDCAM_EXTENSION pDevExt = (PDCAM_EXTENSION) Srb->HwDeviceExtension;
    PSTREAMEX pStrmEx = (PSTREAMEX) pDevExt->pStrmEx;

    PAGED_CODE();

    ASSERT(pStrmEx == (PSTREAMEX)Srb->StreamObject->HwStreamExtension);

    pStrmEx->hMasterClock = Srb->CommandData.MasterClockHandle;

    DbgMsg2(("\'%d:%s)VideoIndicateMasterClock: hMasterClock = 0x%x\n", pDevExt->idxDev, pDevExt->pchVendorName, pStrmEx->hMasterClock));

}


VOID
DCamReceivePacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )

/*++

Routine Description:

    This is where most of the interesting Stream requests come to us

Arguments:

    pSrb - Pointer to Stream request block

Return Value:

    Nothing

--*/

{
    PIO_STACK_LOCATION IrpStack;
    PDCAM_EXTENSION pDevExt = (PDCAM_EXTENSION) pSrb->HwDeviceExtension;


    PAGED_CODE();

    pSrb->Status = STATUS_SUCCESS;

    //
    // Switch on the command within the Srb itself
    //

    switch (pSrb->Command) {

    case SRB_INITIALIZE_DEVICE:     // Per device
          
         pSrb->Status = DCamHwInitialize(pSrb);
         break;

    case SRB_INITIALIZATION_COMPLETE:

         pSrb->Status = STATUS_NOT_IMPLEMENTED;
         break;

    case SRB_GET_STREAM_INFO:     // Per Device

         //
         // this is a request for the driver to enumerate requested streams
         //
         DCamGetStreamInfo(pSrb);
         break;

    case SRB_OPEN_STREAM:          // Per stream

         DCamOpenStream(pSrb);
         break;

    case SRB_CLOSE_STREAM:          // Per Stream
        DbgMsg1((" #CLOSE_STREAM# (%d) camera: pSrb %x, pDevExt %x, pStrmEx %x, PendingRead %d\n", 
              pDevExt->idxDev, pSrb, pDevExt, pDevExt->pStrmEx, pDevExt->PendingReadCount));
        DCamCloseStream(pSrb);
        return;       // SRB will finish asynchronously in its IoCompletionRoutine if there are pending reads to cancel.
     
    case SRB_SURPRISE_REMOVAL:

        DbgMsg1((" #SURPRISE_REMOVAL# (%d) camera: pSrb %x, pDevExt %x, pStrmEx %x, PendingRead %d\n", 
             pDevExt->idxDev, pSrb, pDevExt, pDevExt->pStrmEx, pDevExt->PendingReadCount));
        DCamSurpriseRemoval(pSrb);
        return;       // SRB will finish asynchronously in its IoCompletionRoutine.

    case SRB_UNKNOWN_DEVICE_COMMAND:

         //
         // We might be interested in unknown commands if they pertain
         // to bus resets.  We will reallocate resource (bandwidth and 
         // channel) if this device is streaming.
         //
         IrpStack = IoGetCurrentIrpStackLocation(pSrb->Irp);

         if (IrpStack->MajorFunction == IRP_MJ_PNP)
             DCamProcessPnpIrp(pSrb, IrpStack, pDevExt);
         else            
             pSrb->Status = STATUS_NOT_IMPLEMENTED;
         break;


    case SRB_UNINITIALIZE_DEVICE:     // Per device

         DbgMsg1((" #UNINITIALIZE_DEVICE# (%d) %s camera : pSrb %x, pDevExt %x, pStrmEx %x\n", 
              pDevExt->idxDev, pDevExt->pchVendorName, pSrb, pDevExt, pDevExt->pStrmEx));
         pSrb->Status = DCamHwUnInitialize(pSrb);
         break;

    case SRB_GET_DATA_INTERSECTION:

         //
         // Return a format, given a range
         //
         AdapterFormatFromRange(pSrb);
         StreamClassDeviceNotification(DeviceRequestComplete, pSrb->HwDeviceExtension, pSrb);
         return;

    case SRB_CHANGE_POWER_STATE:

         DCamChangePower(pSrb);
         break;
            
    // VideoProcAmp and CameraControl requests
    case SRB_GET_DEVICE_PROPERTY:

         AdapterGetProperty(pSrb);
         break;
          
    case SRB_SET_DEVICE_PROPERTY:
    
         AdapterSetProperty(pSrb);
         break;

    case SRB_PAGING_OUT_DRIVER:

         // Once we register bus reset, we can be called at any time;
         // So we cannot page out.
         pSrb->Status = STATUS_NOT_IMPLEMENTED;
         break;


    default:   

         DbgMsg1(("DCamReceivePacket: entry with unknown and unsupported SRB command 0x%x\n", pSrb->Command));
         //
         // this is a request that we do not understand.  Indicate invalid
         // command and complete the request
         //

         pSrb->Status = STATUS_NOT_IMPLEMENTED;
         break;
    }

    //
    // NOTE:
    //
    // all of the commands that we do, or do not understand can all be completed
    // synchronously at this point, so we can use a common callback routine here.
    // If any of the above commands require asynchronous processing, this will
    // have to change
    //

#if DBG
    if (pSrb->Status != STATUS_SUCCESS && 
        pSrb->Status != STATUS_NOT_IMPLEMENTED) {
        DbgMsg1(("pSrb->Command(0x%x) does not return STATUS_SUCCESS or NOT_IMPLEMENTED but 0x%x\n", pSrb->Command, pSrb->Status));
    }
#endif

    StreamClassDeviceNotification(DeviceRequestComplete, pSrb->HwDeviceExtension, pSrb);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\1394dcam\device.c ===
//===========================================================================
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
// PURPOSE.
//
// Copyright (c) 1996 - 2000  Microsoft Corporation.  All Rights Reserved.
//
//===========================================================================
/*++

Module Name:

    Device.c

Abstract:

    This file contains code to read/write request from the DCam.

Author:
    
    Yee J. Wu 9-Sep-97

Environment:

    Kernel mode only

Revision History:


--*/
#include "strmini.h"
#include "ksmedia.h"
#include "1394.h"
#include "wdm.h"       // for DbgBreakPoint() defined in dbg.h
#include "dbg.h"
#include "dcamdef.h"
#include "dcampkt.h"
#include "sonydcam.h"




NTSTATUS
DCamReadRegister(
    IN PIRB pIrb,
    PDCAM_EXTENSION pDevExt,
    ULONG ulFieldOffset,
    ULONG * pulValue
)
{
    NTSTATUS status;
    LARGE_INTEGER deltaTime;
       PIRP pIrp;


    //
    // Delay for camera before next request
    //
    ASSERT(pDevExt->BusDeviceObject != NULL);

    pIrp = IoAllocateIrp(pDevExt->BusDeviceObject->StackSize, FALSE);

    if (!pIrp) {

        ASSERT(FALSE);
        return (STATUS_INSUFFICIENT_RESOURCES);

    }

    //
    // Delay for camera before next request
    //
    if(KeGetCurrentIrql() < DISPATCH_LEVEL) {
        deltaTime.LowPart = DCAM_DELAY_VALUE;
        deltaTime.HighPart = -1;
        KeDelayExecutionThread(KernelMode, TRUE, &deltaTime);
    }

    pIrb->FunctionNumber = REQUEST_ASYNC_READ;
    pIrb->Flags = 0;
    pIrb->u.AsyncRead.DestinationAddress.IA_Destination_Offset.Off_High = INITIAL_REGISTER_SPACE_HI;
    pIrb->u.AsyncRead.DestinationAddress.IA_Destination_Offset.Off_Low = pDevExt->BaseRegister + ulFieldOffset;
    pIrb->u.AsyncRead.nNumberOfBytesToRead = sizeof(ULONG);
    pIrb->u.AsyncRead.nBlockSize = 0;
    pIrb->u.AsyncRead.fulFlags = 0;
    InterlockedExchange(&pIrb->u.AsyncRead.ulGeneration, pDevExt->CurrentGeneration);
    pDevExt->RegisterWorkArea.AsULONG = 0;    // Initilize the return buffer.
    pIrb->u.AsyncRead.Mdl = 
    IoAllocateMdl(&pDevExt->RegisterWorkArea, sizeof(ULONG), FALSE, FALSE, NULL);
    MmBuildMdlForNonPagedPool(pIrb->u.AsyncRead.Mdl);

    DbgMsg3(("\'DCamReadRegister: Read from address (%x, %x)\n",
          pIrb->u.AsyncRead.DestinationAddress.IA_Destination_Offset.Off_High,
          pIrb->u.AsyncRead.DestinationAddress.IA_Destination_Offset.Off_Low));    

    status = DCamSubmitIrpSynch(pDevExt, pIrp, pIrb);

    if (status) {

        ERROR_LOG(("DCamRange: Error %x while trying to read from register\n", status));               
    } else {

        *pulValue = pDevExt->RegisterWorkArea.AsULONG;
        DbgMsg3(("\'DCamReadRegister: status=0x%x, value=0x%x\n", status, *pulValue));               
    }


    IoFreeMdl(pIrb->u.AsyncWrite.Mdl);
    IoFreeIrp(pIrp);

    return status;
}


NTSTATUS
DCamWriteRegister(
    IN PIRB pIrb,
    PDCAM_EXTENSION pDevExt,
    ULONG ulFieldOffset,
    ULONG ulValue
)
{
    NTSTATUS status;
    LARGE_INTEGER deltaTime;
    PIRP pIrp;

    ASSERT(pDevExt->BusDeviceObject != NULL);
    pIrp = IoAllocateIrp(pDevExt->BusDeviceObject->StackSize, FALSE);

    if (!pIrp) {

        ASSERT(FALSE);
        return (STATUS_INSUFFICIENT_RESOURCES);

    }

    //
    // Delay for camera before next request
    //
    if(KeGetCurrentIrql() < DISPATCH_LEVEL) {
        deltaTime.LowPart = DCAM_DELAY_VALUE;
        deltaTime.HighPart = -1;
        KeDelayExecutionThread(KernelMode, TRUE, &deltaTime);
    }


    pIrb->FunctionNumber = REQUEST_ASYNC_WRITE;
    pIrb->Flags = 0;
    pIrb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_High = INITIAL_REGISTER_SPACE_HI;
    pIrb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_Low =     pDevExt->BaseRegister + ulFieldOffset;
    pIrb->u.AsyncWrite.nNumberOfBytesToWrite = sizeof(ULONG);
    pIrb->u.AsyncWrite.nBlockSize = 0;
    pIrb->u.AsyncWrite.fulFlags = 0;
    InterlockedExchange(&pIrb->u.AsyncWrite.ulGeneration, pDevExt->CurrentGeneration);
    pDevExt->RegisterWorkArea.AsULONG = ulValue;    // Initilize the return buffer.
    pIrb->u.AsyncWrite.Mdl = 
    IoAllocateMdl(&pDevExt->RegisterWorkArea, sizeof(ULONG), FALSE, FALSE, NULL);
    MmBuildMdlForNonPagedPool(pIrb->u.AsyncWrite.Mdl);
    
    DbgMsg3(("\'DCamWriteRegister: Write to address (%x, %x)\n", pIrb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_High, pIrb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_Low));    

    status = DCamSubmitIrpSynch(pDevExt, pIrp, pIrb);

    if (status) {
        ERROR_LOG(("\'DCamWriteRegister: Error %x while trying to write to register\n", status));               
    } 
    

    IoFreeMdl(pIrb->u.AsyncWrite.Mdl);
    IoFreeIrp(pIrp);
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\1394dcam\sonydcam.h ===
//===========================================================================
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
// PURPOSE.
//
// Copyright (c) 1996 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//===========================================================================
/*++

Module Name:

    sonydcam.h

Abstract:

    Header file for sonydcam.c 

Author:
    
    Shaun Pierce 25-May-96

Environment:

    Kernel mode only

Revision History:


--*/



//
// Function prototypes
//

NTSTATUS
DriverEntry(
    IN PVOID Context1,
    IN PVOID Context2
    );

VOID 
InitializeDeviceExtension(
    PPORT_CONFIGURATION_INFORMATION ConfigInfo
    );

NTSTATUS
DCamHwUnInitialize(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    );

NTSTATUS
DCamHwInitialize(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    );

NTSTATUS
DCamSubmitIrpSynch(
    PDCAM_EXTENSION pDevExt,
    PIRP pIrp,
    PIRB pIrb
    );

NTSTATUS
DCamSynchCR(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrp,
    IN PKEVENT Event
    );

ULONG
bitcount(
    IN ULONG b
    );


#define COMPLETE_SRB(pSrb) if(pSrb->Flags & SRB_HW_FLAGS_STREAM_REQUEST)  \
                              StreamClassStreamNotification(StreamRequestComplete, pSrb->StreamObject, pSrb); \
                           else  \
                              StreamClassDeviceNotification(DeviceRequestComplete, pSrb->HwDeviceExtension, pSrb); 
        


//
// External functions
//

extern 
VOID
DCamReceivePacket(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    );

extern
VOID
DCamCancelAllPackets(
    PHW_STREAM_REQUEST_BLOCK pSrb,
    PDCAM_EXTENSION pDevExt,
    LONG *plPendingReadCount    
    );

extern
VOID
DCamCancelOnePacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    );

extern 
VOID
DCamTimeoutHandler(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    );

extern VOID
DCamBusResetNotification(
    IN PVOID Context
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\1394dcam\strmdata.h ===
//===========================================================================
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
// PURPOSE.
//
// Copyright (c) 1996 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//===========================================================================

//
// External functions
//


#include "sonydcam.h"

//
// Local variables
//

CAMERA_ISOCH_INFO IsochInfoTable[] = {

        0,      SPEED_FLAGS_100,        0,          // Reserved <---+
        0,      SPEED_FLAGS_100,        0,          // 3.75 fps     |
        15,     SPEED_FLAGS_100,        57600,      // 7.5  fps     |
        30,     SPEED_FLAGS_100,        57600,      // 15   fps     +- Mode0
        60,     SPEED_FLAGS_100,        57600,      // 30   fps     |
        0,      SPEED_FLAGS_100,        0,          // 60   fps <---+
        0,      SPEED_FLAGS_100,        0,          // Reserved <---+
        20,     SPEED_FLAGS_100,        153600,     // 3.75 fps     |
        40,     SPEED_FLAGS_100,        153600,     // 7.5  fps     |
        80,     SPEED_FLAGS_100,        153600,     // 15   fps     +- Mode1
        160,    SPEED_FLAGS_100,        153600,     // 30   fps     |
        0,      SPEED_FLAGS_100,        0,          // 60   fps <---+
        0,      SPEED_FLAGS_100,        0,          // Reserved <---+
        60,     SPEED_FLAGS_100,        460800,     // 3.75 fps     |
        120,    SPEED_FLAGS_100,        460800,     // 7.5  fps     |
        240,    SPEED_FLAGS_100,        460800,     // 15   fps     +- Mode2
        480,    SPEED_FLAGS_200,        460800,     // 30   fps     |
        0,      SPEED_FLAGS_100,        0,          // 60   fps <---+
        0,      SPEED_FLAGS_100,        0,          // Reserved <---+
        80,     SPEED_FLAGS_100,        614400,     // 3.75 fps     |
        160,    SPEED_FLAGS_100,        614400,     // 7.5  fps     |
        320,    SPEED_FLAGS_200,        614400,     // 15   fps     +- Mode3
        640,    SPEED_FLAGS_400,        614400,     // 30   fps     |
        0,      SPEED_FLAGS_100,        0,          // 60   fps <---+
        0,      SPEED_FLAGS_100,        0,          // Reserved <---+
        120,    SPEED_FLAGS_100,        921600,     // 3.75 fps     |
        240,    SPEED_FLAGS_100,        921600,     // 7.5  fps     |
        480,    SPEED_FLAGS_200,        921600,     // 15   fps     +- Mode4
        960,    SPEED_FLAGS_400,        921600,     // 30   fps     |
        0,      SPEED_FLAGS_100,        0,          // 60   fps <---+
        0,      SPEED_FLAGS_100,        0,          // Reserved <---+
        40,     SPEED_FLAGS_100,        307200,     // 3.75 fps     |
        80,     SPEED_FLAGS_100,        307200,     // 7.5  fps     |
        160,    SPEED_FLAGS_100,        307200,     // 15   fps     +- Mode5
        320,    SPEED_FLAGS_200,        307200,     // 30   fps     |
        640,    SPEED_FLAGS_400,        307200,     // 60   fps <---+
        
};




// ------------------------------------------------------------------------
// Property set for all video capture streams
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_TABLE(VideoStreamConnectionProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_CONNECTION_ALLOCATORFRAMING,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSALLOCATOR_FRAMING),            // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),
};

DEFINE_KSPROPERTY_TABLE(VideoStreamDroppedFramesProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_DROPPEDFRAMES_CURRENT,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_DROPPEDFRAMES_CURRENT_S),// MinProperty
        sizeof(KSPROPERTY_DROPPEDFRAMES_CURRENT_S),// MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
};



// ------------------------------------------------------------------------
// Array of all of the property sets supported by video streams
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_SET_TABLE(VideoStreamProperties)
{
    DEFINE_KSPROPERTY_SET
    ( 
        &KSPROPSETID_Connection,                        // Set
        SIZEOF_ARRAY(VideoStreamConnectionProperties),  // PropertiesCount
        VideoStreamConnectionProperties,                // PropertyItem
        0,                                              // FastIoCount
        NULL                                            // FastIoTable
    ),
    DEFINE_KSPROPERTY_SET
    ( 
        &PROPSETID_VIDCAP_DROPPEDFRAMES,                // Set
        SIZEOF_ARRAY(VideoStreamDroppedFramesProperties),  // PropertiesCount
        VideoStreamDroppedFramesProperties,                // PropertyItem
        0,                                              // FastIoCount
        NULL                                            // FastIoTable
    ),

};

#define NUMBER_VIDEO_STREAM_PROPERTIES (SIZEOF_ARRAY(VideoStreamProperties))
    
#ifndef mmioFOURCC    
#define mmioFOURCC( ch0, ch1, ch2, ch3 ) 	 	\
 	( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |  \
 	( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )
#endif  

//
// FourCC of the YUV formats
// For information about FourCC, go to http://www.webartz.com/fourcc/indexyuv.htm
//
#define FOURCC_Y444 mmioFOURCC('Y', '4', '4', '4')  // TIYUV: 1394 conferencing camera 4:4:4 mode 0
#define FOURCC_UYVY mmioFOURCC('U', 'Y', 'V', 'Y')  // MSYUV: 1394 conferencing camera 4:4:4 mode 1 and 3
#define FOURCC_Y411 mmioFOURCC('Y', '4', '1', '1')  // TIYUV: 1394 conferencing camera 4:1:1 mode 2
#define FOURCC_Y800 mmioFOURCC('Y', '8', '0', '0')  // TIYUV: 1394 conferencing camera 4:1:1 mode 5




#ifdef SUPPORT_YUV444

#define DX 	        160
#define DY          120
#define DBITCOUNT    32

KS_DATARANGE_VIDEO DCAM_StreamMode_0 = 
{
    // KSDATARANGE
    {   
        sizeof (KS_DATARANGE_VIDEO),     // Flags
        0,
        57600,                          // SampleSize
        0,                               // Reserved
        STATIC_KSDATAFORMAT_TYPE_VIDEO,  
        FOURCC_Y444, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71,
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO
    },

    TRUE,                   // BOOL,  bFixedSizeSamples (all samples same size?)
    TRUE,                   // BOOL,  bTemporalCompression (all I frames?)
    KS_VIDEOSTREAM_CAPTURE, // StreamDescriptionFlags  (KS_VIDEO_DESC_*)
    0,                      // MemoryAllocationFlags   (KS_VIDEO_ALLOC_*)

    // _KS_VIDEO_STREAM_CONFIG_CAPS  
    {
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO, 
        KS_AnalogVideo_None, // AnalogVideoStandard
        DX,DY,   // InputSize, (the inherent size of the incoming signal
                 //             with every digitized pixel unique)
        DX,DY,   // MinCroppingSize, smallest rcSrc cropping rect allowed
        DX,DY,   // MaxCroppingSize, largest  rcSrc cropping rect allowed
        1,       // CropGranularityX, granularity of cropping size
        1,       // CropGranularityY
        1,       // CropAlignX, alignment of cropping rect 
        1,       // CropAlignY;
        DX, DY,  // MinOutputSize, smallest bitmap stream can produce
        DX, DY,  // MaxOutputSize, largest  bitmap stream can produce
        DX,      // OutputGranularityX, granularity of output bitmap size
        DY,      // OutputGranularityY;
        0,       // StretchTapsX  (0 no stretch, 1 pix dup, 2 interp...)
        0,       // StretchTapsY
        0,       // ShrinkTapsX 
        0,       // ShrinkTapsY 
        // Allow 1% difference
        333000,  // MinFrameInterval (10,000,000 / 30.00FPS), 100nS units
        1333333, // MaxFrameInterval (10,000,000 /  7.50FPS), 100nS units
        4608000,  // (DX * DY * DBITCOUNT) * DFPS_MIN,    // MinBitsPerSecond (7.50 FPS);
        36864000, // (DX * DY * DBITCOUNT) * DFPS_MAX     // MaxBitsPerSecond (30.0 FPS);
    }, 
        
    // KS_VIDEOINFOHEADER (default format)
    {
        0,0,0,0,                            // RECT  rcSource; 
        0,0,0,0,                            // RECT  rcTarget; 
        13824000,                           // DWORD dwBitRate; 57600 * 30FPS * 8 bit/Byte
        0L,                                 // DWORD dwBitErrorRate;   
        333333,                             // REFERENCE_TIME  AvgTimePerFrame (30 FPS); 
        sizeof (KS_BITMAPINFOHEADER),       // DWORD biSize;
        DX,                                 // LONG  biWidth;
        DY,                                 // LONG  biHeight;
        1,                        // WORD  biPlanes;
        DBITCOUNT,                // WORD  biBitCount;
        FOURCC_Y444,              // DWORD biCompression;
        57600,                    // DWORD biSizeImage;
        0,                        // LONG  biXPelsPerMeter;
        0,                        // LONG  biYPelsPerMeter;
        0,                        // DWORD biClrUsed;
        0                         // DWORD biClrImportant;
    }
}; 

#endif

#undef DX            
#undef DY            
#undef DBITCOUNT 

#define DX 	        320
#define DY          240
#define DBITCOUNT    16

KS_DATARANGE_VIDEO DCAM_StreamMode_1 = 
{
    // KSDATARANGE
    {   
        sizeof (KS_DATARANGE_VIDEO),     // Flags
        0,
        153600,                          // SampleSize
        0,                               // Reserved
        STATIC_KSDATAFORMAT_TYPE_VIDEO,  
        FOURCC_UYVY, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71,
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO
    },

    TRUE,                   // BOOL,  bFixedSizeSamples (all samples same size?)
    TRUE,                   // BOOL,  bTemporalCompression (all I frames?)
    KS_VIDEOSTREAM_CAPTURE, // StreamDescriptionFlags  (KS_VIDEO_DESC_*)
    0,                      // MemoryAllocationFlags   (KS_VIDEO_ALLOC_*)

    // _KS_VIDEO_STREAM_CONFIG_CAPS  
    {
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO, 
        KS_AnalogVideo_None, // AnalogVideoStandard
        DX,DY,   // InputSize, (the inherent size of the incoming signal
                 //             with every digitized pixel unique)
        DX,DY,   // MinCroppingSize, smallest rcSrc cropping rect allowed
        DX,DY,   // MaxCroppingSize, largest  rcSrc cropping rect allowed
        1,       // CropGranularityX, granularity of cropping size
        1,       // CropGranularityY
        1,       // CropAlignX, alignment of cropping rect 
        1,       // CropAlignY;
        DX, DY,  // MinOutputSize, smallest bitmap stream can produce
        DX, DY,  // MaxOutputSize, largest  bitmap stream can produce
        DX,      // OutputGranularityX, granularity of output bitmap size
        DY,      // OutputGranularityY;
        0,       // StretchTapsX  (0 no stretch, 1 pix dup, 2 interp...)
        0,       // StretchTapsY
        0,       // ShrinkTapsX 
        0,       // ShrinkTapsY 
        // Allow 1% difference
        333000,  // MinFrameInterval (10,000,000 / 30.00FPS), 100nS units
        2666666, // MaxFrameInterval (10,000,000 /  3.75FPS), 100nS units
        4608000, // (DX * DY * DBITCOUNT) * DFPS_MIN,    // MinBitsPerSecond (3.75 FPS);
        36864000, // (DX * DY * DBITCOUNT) * DFPS_MAX     // MaxBitsPerSecond (30.0 FPS);
    }, 
        
    // KS_VIDEOINFOHEADER (default format)
    {
        0,0,0,0,                            // RECT  rcSource; 
        0,0,0,0,                            // RECT  rcTarget; 
        18432000,                           // DWORD dwBitRate; 153600 * 15FPS * 8 bit/Byte
        0L,                                 // DWORD dwBitErrorRate;   
        666666,                             // REFERENCE_TIME  AvgTimePerFrame (15 FPS); 
        sizeof (KS_BITMAPINFOHEADER),       // DWORD biSize;
        DX,                                 // LONG  biWidth;
        DY,                                 // LONG  biHeight;
        1,                        // WORD  biPlanes;
        DBITCOUNT,                // WORD  biBitCount;
        FOURCC_UYVY,              // DWORD biCompression;
        153600,                   // DWORD biSizeImage;
        0,                        // LONG  biXPelsPerMeter;
        0,                        // LONG  biYPelsPerMeter;
        0,                        // DWORD biClrUsed;
        0                         // DWORD biClrImportant;
    }
}; 


#ifdef SUPPORT_YUV411  

#undef DX            
#undef DY            
#undef DBITCOUNT    

//
// This has format of UYYV YYUY YVYY (8Y+2U+2V = 12 bytes = 8 pixels)
//                   
#define DX           640
#define DY           480
#define DBITCOUNT     12

// To support Mode 2, 640x480, FourCC=Y411
KS_DATARANGE_VIDEO DCAM_StreamMode_2 = 
{
    // KSDATARANGE
    {   
        sizeof (KS_DATARANGE_VIDEO),
        0,                           // Flags
        460800,   // SampleSize
        0,                           // Reserved
        STATIC_KSDATAFORMAT_TYPE_VIDEO,
        FOURCC_Y411, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71,
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO
    },

    TRUE,                   // BOOL, bFixedSizeSamples (all samples same size?)
    TRUE,                   // BOOL, bTemporalCompression (all I frames?)
    KS_VIDEOSTREAM_CAPTURE, // StreamDescriptionFlags  (KS_VIDEO_DESC_*)
    0,                      // MemoryAllocationFlags   (KS_VIDEO_ALLOC_*)

    // _KS_VIDEO_STREAM_CONFIG_CAPS  
    {
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO, 
        KS_AnalogVideo_None, // AnalogVideoStandard
        DX,DY,               // InputSize, (the inherent size of the incoming signal
                             //             with every digitized pixel unique)
        DX,DY,   // MinCroppingSize, smallest rcSrc cropping rect allowed
        DX,DY,   // MaxCroppingSize, largest  rcSrc cropping rect allowed
        1,       // CropGranularityX, granularity of cropping size
        1,       // CropGranularityY
        1,       // CropAlignX, alignment of cropping rect 
        1,       // CropAlignY;
        DX, DY,  // MinOutputSize, smallest bitmap stream can produce
        DX, DY,  // MaxOutputSize, largest  bitmap stream can produce
        DX,      // OutputGranularityX, granularity of output bitmap size
        DY,      // OutputGranularityY;
        0,       // StretchTapsX  (0 no stretch, 1 pix dup, 2 interp...)
        0,       // StretchTapsY
        0,       // ShrinkTapsX 
        0,       // ShrinkTapsY 
        // allow 1% difference
        333000,  // MinFrameInterval (10,000,000 / 30.00FPS), 100nS units
        2666666, // MaxFrameInterval (10,000,000 /  3.75FPS), 100nS units
        27648000,  // MinBitsPerSecond (7.5 FPS);
        110592000  // MaxBitsPerSecond (30.0 FPS);
    }, 
        
    // KS_VIDEOINFOHEADER (default format)
    {
        0,0,0,0,                            // RECT  rcSource; 
        0,0,0,0,                            // RECT  rcTarget; 
        110592000,                          // DWORD dwBitRate;
        0L,                                 // DWORD dwBitErrorRate;   
        333333,                             // REFERENCE_TIME  AvgTimePerFrame (30 FPS); 
        sizeof (KS_BITMAPINFOHEADER),       // DWORD biSize;
        DX,                                 // LONG  biWidth;
        DY,                                 // LONG  biHeight;
        1,                        // WORD  biPlanes;
        DBITCOUNT,                // WORD  biBitCount;
        FOURCC_Y411,              // DWORD biCompression;
        460800,                   // DWORD biSizeImage;
        0,                        // LONG  biXPelsPerMeter;
        0,                        // LONG  biYPelsPerMeter;
        0,                        // DWORD biClrUsed;
        0                         // DWORD biClrImportant;
    }
};

#endif  // SUPPORT_YUV411
    
#undef DX            
#undef DY            
#undef DBITCOUNT    

#define DX          640
#define DY          480
#define DBITCOUNT    16

// To support mode3, 640x480
KS_DATARANGE_VIDEO DCAM_StreamMode_3 = 
{
    // KSDATARANGE
    {   
        sizeof (KS_DATARANGE_VIDEO),
        0,                            // Flags
        614400,                       // SampleSize
        0,                            // Reserved
        STATIC_KSDATAFORMAT_TYPE_VIDEO,
        FOURCC_UYVY, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71, 
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO
    },

    TRUE,                   // BOOL, bFixedSizeSamples (all samples same size?)
    TRUE,                   // BOOL, bTemporalCompression (all I frames?)
    KS_VIDEOSTREAM_CAPTURE, // StreamDescriptionFlags  (KS_VIDEO_DESC_*)
    0,                      // MemoryAllocationFlags   (KS_VIDEO_ALLOC_*)

    // _KS_VIDEO_STREAM_CONFIG_CAPS  
    {
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO, 
        KS_AnalogVideo_None, // AnalogVideoStandard
        DX,DY,   // InputSize, (the inherent size of the incoming signal
                 //             with every digitized pixel unique)
        DX,DY,   // MinCroppingSize, smallest rcSrc cropping rect allowed
        DX,DY,   // MaxCroppingSize, largest  rcSrc cropping rect allowed
        1,       // CropGranularityX, granularity of cropping size
        1,       // CropGranularityY
        1,       // CropAlignX, alignment of cropping rect 
        1,       // CropAlignY;
        DX, DY,  // MinOutputSize, smallest bitmap stream can produce
        DX, DY,  // MaxOutputSize, largest  bitmap stream can produce
        DX,      // OutputGranularityX, granularity of output bitmap size
        DY,      // OutputGranularityY;
        0,       // StretchTapsX  (0 no stretch, 1 pix dup, 2 interp...)
        0,       // StretchTapsY
        0,       // ShrinkTapsX 
        0,       // ShrinkTapsY 
        666666,  // MinFrameInterval (10,000,000 / 15.00FPS), 100nS units
        2666666, // MaxFrameInterval (10,000,000 /  3.75FPS), 100nS units
        36864000, // MinBitsPerSecond ( 7.5 FPS);
        73728000, // MaxBitsPerSecond (15 FPS);
    }, 
        
    // KS_VIDEOINFOHEADER (default format)
    {
        0,0,0,0,    // RECT  rcSource; 
        0,0,0,0,    // RECT  rcTarget; 
        73728000,   // DWORD dwBitRate;
        0L,                                 // DWORD dwBitErrorRate;   
        666666,                            // REFERENCE_TIME  AvgTimePerFrame (15 FPS); 
        sizeof (KS_BITMAPINFOHEADER),       // DWORD biSize;
        DX,                                 // LONG  biWidth;
        DY,                                 // LONG  biHeight;
        1,                                  // WORD  biPlanes;
        DBITCOUNT,                          // WORD  biBitCount;
        FOURCC_UYVY,                        // DWORD biCompression;
        614400,                             // DWORD biSizeImage;
        0,                                  // LONG  biXPelsPerMeter;
        0,                                  // LONG  biYPelsPerMeter;
        0,                                  // DWORD biClrUsed;
        0                                   // DWORD biClrImportant;
    }
};


#ifdef SUPPORT_RGB24

#undef DX            
#undef DY            
#undef DBITCOUNT 
   
#undef DFPS_DEF     
#undef DFPS_MAX     
#undef DFPS_MIN

#define DX          640
#define DY          480
#define DBITCOUNT    24

// To support mode4, 640x480, RGB
KS_DATARANGE_VIDEO DCAM_StreamMode_4 = 
{
    // KSDATARANGE
    {   
        sizeof (KS_DATARANGE_VIDEO),
        0,                  // Flags
        921600,             // SampleSize
        0,                  // Reserved
        STATIC_KSDATAFORMAT_TYPE_VIDEO,
        0xe436eb7d, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70, 
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO
    },

    TRUE,                   // BOOL, bFixedSizeSamples (all samples same size?)
    TRUE,                   // BOOL, bTemporalCompression (all I frames?)
    KS_VIDEOSTREAM_CAPTURE, // StreamDescriptionFlags  (KS_VIDEO_DESC_*)
    0,                      // MemoryAllocationFlags   (KS_VIDEO_ALLOC_*)

    // _KS_VIDEO_STREAM_CONFIG_CAPS  
    {
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO, 
        KS_AnalogVideo_None, // AnalogVideoStandard
        DX,DY,   // InputSize, (the inherent size of the incoming signal
                 //             with every digitized pixel unique)
        DX,DY,   // MinCroppingSize, smallest rcSrc cropping rect allowed
        DX,DY,   // MaxCroppingSize, largest  rcSrc cropping rect allowed
        1,       // CropGranularityX, granularity of cropping size
        1,       // CropGranularityY
        1,       // CropAlignX, alignment of cropping rect 
        1,       // CropAlignY;
        DX, DY,  // MinOutputSize, smallest bitmap stream can produce
        DX, DY,  // MaxOutputSize, largest  bitmap stream can produce
        DX,      // OutputGranularityX, granularity of output bitmap size
        DY,      // OutputGranularityY;
        0,       // StretchTapsX  (0 no stretch, 1 pix dup, 2 interp...)
        0,       // StretchTapsY
        0,       // ShrinkTapsX 
        0,       // ShrinkTapsY 
        666666,  // MinFrameInterval (10,000,000 / 15.00FPS), 100nS units
        2666666, // MaxFrameInterval (10,000,000 /  3.75FPS), 100nS units
        55296000,  // MinBitsPerSecond ( 7.50 FPS);
        110592000  // MaxBitsPerSecond (15.00 FPS);
    }, 
        
    // KS_VIDEOINFOHEADER (default format)
    {
        0,0,0,0,                            // RECT  rcSource; 
        0,0,0,0,                            // RECT  rcTarget; 
        110592000,                          // DWORD dwBitRate;
        0L,                                 // DWORD dwBitErrorRate;   
        666666,                             // REFERENCE_TIME  AvgTimePerFrame (15 FPS); 
        sizeof (KS_BITMAPINFOHEADER),       // DWORD biSize;
        DX,                                 // LONG  biWidth;
        -DY,                                // LONG  biHeight; -biHeight indicate TopDown for RGB
        1,                         // WORD  biPlanes;
        DBITCOUNT,                 // WORD  biBitCount;
        KS_BI_RGB,                 // DWORD biCompression;
        921600,                    // DWORD biSizeImage;
        0,                         // LONG  biXPelsPerMeter;
        0,                         // LONG  biYPelsPerMeter;
        0,                         // DWORD biClrUsed;
        0                          // DWORD biClrImportant;
    }
};
    
#endif  // SUPPORT_RGB24

#ifdef SUPPORT_YUV800

#undef DX            
#undef DY            
#undef DBITCOUNT 

#define DX 	        640
#define DY          480
#define DBITCOUNT     8

KS_DATARANGE_VIDEO DCAM_StreamMode_5 = 
{
    // KSDATARANGE
    {   
        sizeof (KS_DATARANGE_VIDEO),     // Flags
        0,
        307200,                          // SampleSize
        0,                               // Reserved
        STATIC_KSDATAFORMAT_TYPE_VIDEO,  
        FOURCC_Y800, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71,
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO
    },

    TRUE,                   // BOOL,  bFixedSizeSamples (all samples same size?)
    TRUE,                   // BOOL,  bTemporalCompression (all I frames?)
    KS_VIDEOSTREAM_CAPTURE, // StreamDescriptionFlags  (KS_VIDEO_DESC_*)
    0,                      // MemoryAllocationFlags   (KS_VIDEO_ALLOC_*)

    // _KS_VIDEO_STREAM_CONFIG_CAPS  
    {
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO, 
        KS_AnalogVideo_None, // AnalogVideoStandard
        DX,DY,   // InputSize, (the inherent size of the incoming signal
                 //             with every digitized pixel unique)
        DX,DY,   // MinCroppingSize, smallest rcSrc cropping rect allowed
        DX,DY,   // MaxCroppingSize, largest  rcSrc cropping rect allowed
        1,       // CropGranularityX, granularity of cropping size
        1,       // CropGranularityY
        1,       // CropAlignX, alignment of cropping rect 
        1,       // CropAlignY;
        DX, DY,  // MinOutputSize, smallest bitmap stream can produce
        DX, DY,  // MaxOutputSize, largest  bitmap stream can produce
        DX,      // OutputGranularityX, granularity of output bitmap size
        DY,      // OutputGranularityY;
        0,       // StretchTapsX  (0 no stretch, 1 pix dup, 2 interp...)
        0,       // StretchTapsY
        0,       // ShrinkTapsX 
        0,       // ShrinkTapsY 
        // Allow 1% difference
        333000,  // MinFrameInterval (10,000,000 / 30.00FPS), 100nS units
        2666666, // MaxFrameInterval (10,000,000 /  3.75FPS), 100nS units
        4608000,  // (DX * DY * DBITCOUNT) * DFPS_MIN,    // MinBitsPerSecond (3.75 FPS);
        36864000, // (DX * DY * DBITCOUNT) * DFPS_MAX     // MaxBitsPerSecond (30.0 FPS);
    }, 
        
    // KS_VIDEOINFOHEADER (default format)
    {
        0,0,0,0,                            // RECT  rcSource; 
        0,0,0,0,                            // RECT  rcTarget; 
        73728000,                           // DWORD dwBitRate; 307200 * 30FPS * 8 bit/Byte
        0L,                                 // DWORD dwBitErrorRate;   
        333333,                             // REFERENCE_TIME  AvgTimePerFrame (30 FPS); 
        sizeof (KS_BITMAPINFOHEADER),       // DWORD biSize;
        DX,                                 // LONG  biWidth;
        DY,                                 // LONG  biHeight;
        1,                        // WORD  biPlanes;
        DBITCOUNT,                // WORD  biBitCount;
        FOURCC_Y800,              // DWORD biCompression;
        307200,                   // DWORD biSizeImage;
        0,                        // LONG  biXPelsPerMeter;
        0,                        // LONG  biYPelsPerMeter;
        0,                        // DWORD biClrUsed;
        0                         // DWORD biClrImportant;
    }
}; 

#endif

//---------------------------------------------------------------------------
// Topology
//---------------------------------------------------------------------------

// Categories define what the device does.

static GUID Categories[] = {
    STATIC_KSCATEGORY_VIDEO,
    STATIC_KSCATEGORY_CAPTURE
};

#define NUMBER_OF_CATEGORIES  SIZEOF_ARRAY (Categories)

static KSTOPOLOGY Topology = {
    NUMBER_OF_CATEGORIES,
    (GUID*) &Categories,
    0,
    NULL,
    0,
    NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\1394dcam\sonydcam.c ===
//===========================================================================
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
// PURPOSE.
//
// Copyright (c) 1996 - 2000  Microsoft Corporation.  All Rights Reserved.
//
//===========================================================================
/*++

Module Name:

    sonydcam.c

Abstract:

    Stream class based WDM driver for 1934 Desktop Camera.
    This driver fits under the WDM stream class.

Author:
    
    Shaun Pierce 25-May-96

Modified:

    Yee J. Wu 15-Oct-97

Environment:

    Kernel mode only

Revision History:


--*/

#include "strmini.h"
#include "1394.h"
#include "dbg.h"
#include "ksmedia.h"
#include "dcamdef.h"
#include "sonydcam.h"
#include "dcampkt.h"
#include "capprop.h"   // Video and camera property function prototype


CHAR szUnknownVendorName[] = "UnknownVendor";


#ifdef ALLOC_PRAGMA
    // #pragma alloc_text(INIT, DriverEntry)
    #pragma alloc_text(PAGE, DCamHwUnInitialize)
    #pragma alloc_text(PAGE, InitializeDeviceExtension)
    #pragma alloc_text(PAGE, DCamHwInitialize)
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This where life begins for a driver.  The stream class takes care
    of alot of stuff for us, but we still need to fill in an initialization
    structure for the stream class and call it.

Arguments:

    DriverObject - Pointer to the driver object created by the system.
    RegistryPath - unused.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{

    HW_INITIALIZATION_DATA HwInitData;
    
    PAGED_CODE();
    DbgMsg1(("SonyDCam DriverEntry: DriverObject=%x; RegistryPath=%x\n",
        DriverObject, RegistryPath));

    ERROR_LOG(("<<<<<<< Sonydcam.sys: %s; %s; %x %x >>>>>>>>\n", 
        __DATE__, __TIME__, DriverObject, RegistryPath));

    //
    // Fill in the HwInitData structure
    //
    RtlZeroMemory( &HwInitData, sizeof(HW_INITIALIZATION_DATA) );

    HwInitData.HwInitializationDataSize = sizeof(HwInitData);
    HwInitData.HwInterrupt              = NULL;
    HwInitData.HwReceivePacket          = DCamReceivePacket;
    HwInitData.HwCancelPacket           = DCamCancelOnePacket;
    HwInitData.HwRequestTimeoutHandler  = DCamTimeoutHandler;
    HwInitData.DeviceExtensionSize      = sizeof(DCAM_EXTENSION);
    HwInitData.PerStreamExtensionSize   = sizeof(STREAMEX); 
    HwInitData.PerRequestExtensionSize  = sizeof(IRB);
    HwInitData.FilterInstanceExtensionSize = 0;
    HwInitData.BusMasterDMA             = FALSE;
    HwInitData.Dma24BitAddresses        = FALSE;
    HwInitData.BufferAlignment          = sizeof(ULONG) - 1;
    HwInitData.TurnOffSynchronization   = TRUE;
    HwInitData.DmaBufferSize            = 0;

    return (StreamClassRegisterAdapter(DriverObject, RegistryPath, &HwInitData));

}



#define DEQUEUE_SETTLE_TIME      (ULONG)(-1 * MAX_BUFFERS_SUPPLIED * 10000) 

NTSTATUS
DCamHwUnInitialize(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    )
/*++

Routine Description:

    Device is asked to be unloaded.
       
    Note: this can be called BEFORE CloseStream in the situation when a DCam 
    is unplugged while streaming in any state (RUN,PAUSE or STOP).  So if we 
    are here and the stream is not yet close, we will stop, close stream and then
    free resource.

Arguments:

    Srb - Pointer to stream request block

Return Value:

    Nothing

--*/
{
    NTSTATUS Status;
    PIRP pIrp;
    PIRB pIrb;    
    PDCAM_EXTENSION pDevExt = (PDCAM_EXTENSION) Srb->HwDeviceExtension;

    PAGED_CODE();

    ASSERT(pDevExt->PendingReadCount == 0);

    //
    // Host controller could be disabled which will cause us to be uninitialized.
    //
    if(DCamAllocateIrbAndIrp(&pIrb, &pIrp, pDevExt->BusDeviceObject->StackSize)) {

        //
        // un-register a bus reset callback notification
        //
        pIrb->FunctionNumber = REQUEST_BUS_RESET_NOTIFICATION;
        pIrb->Flags = 0;
        pIrb->u.BusResetNotification.fulFlags = DEREGISTER_NOTIFICATION_ROUTINE;
        pIrb->u.BusResetNotification.ResetRoutine = (PBUS_BUS_RESET_NOTIFICATION) DCamBusResetNotification;
        pIrb->u.BusResetNotification.ResetContext = 0; 
        Status = DCamSubmitIrpSynch(pDevExt, pIrp, pIrb);
        if(Status) {
            ERROR_LOG(("DCamHwUnInitialize: Error (Status %x) while trying to deregister nus reset callback routine.\n", Status));
        } 

        DbgMsg1(("DCamHwUnInitialize: DeRegister bus reset notification done; status %x.\n", Status));

        DCamFreeIrbIrpAndContext(0, pIrb, pIrp);
    } else {
        ERROR_LOG(("DCamBusResetNotification: DcamAllocateIrbAndIrp has failed!!\n\n\n"));
        ASSERT(FALSE);   
    }

    // Free resource (from below)
    if(pDevExt->UnitDirectory) {
        ExFreePool(pDevExt->UnitDirectory);
        pDevExt->UnitDirectory = 0;
    }

    if(pDevExt->UnitDependentDirectory) {
        ExFreePool(pDevExt->UnitDependentDirectory);
        pDevExt->UnitDependentDirectory = 0;
    }

    if(pDevExt->ModelLeaf) {
        ExFreePool(pDevExt->ModelLeaf);
        pDevExt->ModelLeaf = 0;
    }

    if (pDevExt->ConfigRom) {
        ExFreePool(pDevExt->ConfigRom);
        pDevExt->ConfigRom = 0;
    }

    if (pDevExt->VendorLeaf) {
        ExFreePool(pDevExt->VendorLeaf);
        pDevExt->VendorLeaf = 0;
    }
      
    return STATUS_SUCCESS;
}




VOID 
InitializeDeviceExtension(
    PPORT_CONFIGURATION_INFORMATION ConfigInfo
    )
{
    PDCAM_EXTENSION pDevExt;

    pDevExt = (PDCAM_EXTENSION) ConfigInfo->HwDeviceExtension;
    pDevExt->SharedDeviceObject = ConfigInfo->ClassDeviceObject;
    pDevExt->BusDeviceObject = ConfigInfo->PhysicalDeviceObject;  // Used in IoCallDriver()
    pDevExt->PhysicalDeviceObject = ConfigInfo->RealPhysicalDeviceObject;  // Used in PnP API
    // In case sonydcam is used with old stream.sys, 
    // which has not implemented RealPhysicalDeviceObject.   
    if(!pDevExt->PhysicalDeviceObject)
        pDevExt->PhysicalDeviceObject = pDevExt->BusDeviceObject;
    ASSERT(pDevExt->PhysicalDeviceObject != 0);
    pDevExt->BaseRegister = 0;
    pDevExt->FrameRate = DEFAULT_FRAME_RATE;
    InitializeListHead(&pDevExt->IsochDescriptorList);
    KeInitializeSpinLock(&pDevExt->IsochDescriptorLock);
    pDevExt->bNeedToListen = FALSE;
    pDevExt->hResource = NULL;
    pDevExt->hBandwidth = NULL;
    pDevExt->IsochChannel = ISOCH_ANY_CHANNEL;
    pDevExt->PendingReadCount = 0; 
    pDevExt->pStrmEx = 0;

    InitializeListHead(&pDevExt->IsochWaitingList);
    KeInitializeSpinLock(&pDevExt->IsochWaitingLock);

    pDevExt->bDevRemoved = FALSE;

    pDevExt->CurrentPowerState = PowerDeviceD0;  // full power state.

    KeInitializeMutex( &pDevExt->hMutexProperty, 0);  // Level 0 and in Signal state
}


NTSTATUS
DCamHwInitialize(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    This where we perform the necessary initialization tasks.

Arguments:

    Srb - Pointer to stream request block

Return Value:

    Nothing

--*/

{

    PIRB pIrb;
    PIRP pIrp;
    CCHAR StackSize;
    ULONG i;
    ULONG DirectoryLength;
    NTSTATUS status = STATUS_SUCCESS;
    PDCAM_EXTENSION pDevExt;
    PPORT_CONFIGURATION_INFORMATION ConfigInfo; 

         

    PAGED_CODE();

    ConfigInfo = Srb->CommandData.ConfigInfo;
    pIrb = (PIRB) Srb->SRBExtension;
    pDevExt = (PDCAM_EXTENSION) ConfigInfo->HwDeviceExtension;

    //
    // Initialize DeviceExtension
    //
    InitializeDeviceExtension(ConfigInfo); 


    StackSize = pDevExt->BusDeviceObject->StackSize;
    pIrp = IoAllocateIrp(StackSize, FALSE);
    if (!pIrp) {

        ASSERT(FALSE);
        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // find what the host adaptor below us supports...
    //
    pIrb->FunctionNumber = REQUEST_GET_LOCAL_HOST_INFO;
    pIrb->Flags = 0;
    pIrb->u.GetLocalHostInformation.nLevel = GET_HOST_CAPABILITIES;
    pIrb->u.GetLocalHostInformation.Information = &pDevExt->HostControllerInfomation;
    status = DCamSubmitIrpSynch(pDevExt, pIrp, pIrb);
    if (status) {

        ERROR_LOG(("DCamHwInitialize: Error (Status=%x) while trying to get local hsot info.\n", status));
        status = STATUS_UNSUCCESSFUL;
        goto AbortLoading;
    }        


    //
    // find what the max buffer size is supported by the host.
    //
    pIrb->FunctionNumber = REQUEST_GET_LOCAL_HOST_INFO;
    pIrb->Flags = 0;
    pIrb->u.GetLocalHostInformation.nLevel = GET_HOST_DMA_CAPABILITIES;
    pIrb->u.GetLocalHostInformation.Information = &pDevExt->HostDMAInformation;
    status = DCamSubmitIrpSynch(pDevExt, pIrp, pIrb);
    if (status) {
        ERROR_LOG(("DCamHwInitialize: Error (Status=%x) while trying to get GET_HOST_DMA_CAPABILITIES.\n", status));
        // May not supported in the ealier version of 1394
        // Set default.
    } else {
        ERROR_LOG(("\'GET_HOST_DMA_CAPABILITIES: HostDmaCapabilities;:%x; MaxDmaBufferSize:(Quad:%x; High:%x;Low:%x)\n",
            pDevExt->HostDMAInformation.HostDmaCapabilities, 
            (DWORD) pDevExt->HostDMAInformation.MaxDmaBufferSize.QuadPart,
            pDevExt->HostDMAInformation.MaxDmaBufferSize.u.HighPart,
            pDevExt->HostDMAInformation.MaxDmaBufferSize.u.LowPart
            ));
    }
    

    //
    // Make a call to determine what the generation # is on the bus,
    // followed by a call to find out about ourself (config rom info)
    //
    //
    // Get the current generation count first
    //

    pIrb->FunctionNumber = REQUEST_GET_GENERATION_COUNT;
    pIrb->Flags = 0;

    status = DCamSubmitIrpSynch(pDevExt, pIrp, pIrb);

    if (status) {

        ERROR_LOG(("\'DCamHwInitialize: Error %x while trying to get generation number\n", status));
        status = STATUS_UNSUCCESSFUL;
        goto AbortLoading;
    }

    InterlockedExchange(&pDevExt->CurrentGeneration, pIrb->u.GetGenerationCount.GenerationCount);

    //
    // Now that we have the current generation count, find out how much
    // configuration space we need by setting lengths to zero.
    //

    pIrb->FunctionNumber = REQUEST_GET_CONFIGURATION_INFO;
    pIrb->Flags = 0;
    pIrb->u.GetConfigurationInformation.UnitDirectoryBufferSize = 0;
    pIrb->u.GetConfigurationInformation.UnitDependentDirectoryBufferSize = 0;
    pIrb->u.GetConfigurationInformation.VendorLeafBufferSize = 0;
    pIrb->u.GetConfigurationInformation.ModelLeafBufferSize = 0;

    status = DCamSubmitIrpSynch(pDevExt, pIrp, pIrb);

    if (status) {

        ERROR_LOG(("\'DCamHwInitialize: Error %x while trying to get configuration info (1)\n", status));
        status = STATUS_UNSUCCESSFUL;
        goto AbortLoading;
    }

    //
    // Now go thru and allocate what we need to so we can get our info.
    //

    pDevExt->ConfigRom = ExAllocatePoolWithTag(PagedPool, sizeof(CONFIG_ROM), 'macd');
    if (!pDevExt->ConfigRom) {

        ERROR_LOG(("\'DCamHwInitialize: Couldn't allocate memory for the Config Rom\n"));
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto AbortLoading;
    }


    pDevExt->UnitDirectory = ExAllocatePoolWithTag(PagedPool, pIrb->u.GetConfigurationInformation.UnitDirectoryBufferSize, 'macd');
    if (!pDevExt->UnitDirectory) {

        ERROR_LOG(("\'DCamHwInitialize: Couldn't allocate memory for the UnitDirectory\n"));
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto AbortLoading;
    }


    if (pIrb->u.GetConfigurationInformation.UnitDependentDirectoryBufferSize) {

        pDevExt->UnitDependentDirectory = ExAllocatePoolWithTag(PagedPool, pIrb->u.GetConfigurationInformation.UnitDependentDirectoryBufferSize, 'macd');
        if (!pDevExt->UnitDependentDirectory) {

            ERROR_LOG(("\'DCamHwInitialize: Couldn't allocate memory for the UnitDependentDirectory\n"));
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto AbortLoading;
        }
    }


    if (pIrb->u.GetConfigurationInformation.VendorLeafBufferSize) {

        // From NonPaged pool since vendor name can be used in a func with DISPATCH level
        pDevExt->VendorLeaf = ExAllocatePoolWithTag(NonPagedPool, pIrb->u.GetConfigurationInformation.VendorLeafBufferSize, 'macd');
        if (!pDevExt->VendorLeaf) {

            ERROR_LOG(("\'DCamHwInitialize: Couldn't allocate memory for the VendorLeaf\n"));
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto AbortLoading;
        }
    } 

    if (pIrb->u.GetConfigurationInformation.ModelLeafBufferSize) {

        pDevExt->ModelLeaf = ExAllocatePoolWithTag(NonPagedPool, pIrb->u.GetConfigurationInformation.ModelLeafBufferSize, 'macd');
        if (!pDevExt->ModelLeaf) {

            ERROR_LOG(("\'DCamHwInitialize: Couldn't allocate memory for the ModelLeaf\n"));
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto AbortLoading;
        }
    }

    //
    // Now resubmit the pIrb with the appropriate pointers inside
    //

    pIrb->FunctionNumber = REQUEST_GET_CONFIGURATION_INFO;
    pIrb->Flags = 0;
    pIrb->u.GetConfigurationInformation.ConfigRom = pDevExt->ConfigRom;
    pIrb->u.GetConfigurationInformation.UnitDirectory = pDevExt->UnitDirectory;
    pIrb->u.GetConfigurationInformation.UnitDependentDirectory = pDevExt->UnitDependentDirectory;
    pIrb->u.GetConfigurationInformation.VendorLeaf = pDevExt->VendorLeaf;
    pIrb->u.GetConfigurationInformation.ModelLeaf = pDevExt->ModelLeaf;

    status = DCamSubmitIrpSynch(pDevExt, pIrp, pIrb);

    if (status) {

        ERROR_LOG(("DCamHwInitialize: Error %x while trying to get configuration info (2)\n", status));
        status = STATUS_UNSUCCESSFUL;
        goto AbortLoading;
    }

    //
    // We might be able to return strings about a Device
    //

    if (pDevExt->VendorLeaf) {

        //
        // bswap to get the actual leaf length (in quadlets)
        //

        *((PULONG) pDevExt->VendorLeaf) = bswap(*((PULONG) pDevExt->VendorLeaf));

        DbgMsg1(("\'DCamHwInitialize: BufSize %d (byte); VendorLeaf %x; Len %d (Quad)\n", 
            pIrb->u.GetConfigurationInformation.VendorLeafBufferSize, 
            pDevExt->VendorLeaf, 
            pDevExt->VendorLeaf->TL_Length));

        if(pDevExt->VendorLeaf->TL_Length >= 1) {
            pDevExt->pchVendorName = &pDevExt->VendorLeaf->TL_Data;

        } else {
            pDevExt->pchVendorName = szUnknownVendorName;
        }

        DbgMsg1(("\'DCamHwInitialize: VendorName %s, strLen %d\n", pDevExt->pchVendorName, strlen(pDevExt->pchVendorName)));
    }

    //
    // Now we chew thru the Unit Dependent Directory looking for our command
    // base register key.
    //

    DirectoryLength = pIrb->u.GetConfigurationInformation.UnitDependentDirectoryBufferSize >> 2;
    for (i=1; i < DirectoryLength; i++) {

        if ((*(((PULONG) pDevExt->UnitDependentDirectory)+i) & CONFIG_ROM_KEY_MASK) == COMMAND_BASE_KEY_SIGNATURE) {

            //
            // Found the command base offset.  This is a quadlet offset from
            // the initial register space.  (Should come out to 0xf0f00000)
            //

            pDevExt->BaseRegister = bswap(*(((PULONG) pDevExt->UnitDependentDirectory)+i) & CONFIG_ROM_OFFSET_MASK);
            pDevExt->BaseRegister <<= 2;
            pDevExt->BaseRegister |= INITIAL_REGISTER_SPACE_LO;
            break;

        }
        
    }

    ASSERT( pDevExt->BaseRegister );

    if(!DCamDeviceInUse(pIrb, pDevExt)) {
        //
        // Now let's actually do a write request to initialize the device
        //
        pDevExt->RegisterWorkArea.AsULONG = 0;
        pDevExt->RegisterWorkArea.Initialize.Initialize = TRUE;
        pDevExt->RegisterWorkArea.AsULONG = bswap(pDevExt->RegisterWorkArea.AsULONG);

        status = DCamWriteRegister ((PIRB) Srb->SRBExtension, pDevExt, 
                  FIELDOFFSET(CAMERA_REGISTER_MAP, Initialize), pDevExt->RegisterWorkArea.AsULONG);

        if(status) {

            ERROR_LOG(("DCamHwInitialize: Error %x while trying to write to Initialize register\n", status));
            status = STATUS_UNSUCCESSFUL;
            goto AbortLoading;   
        }
    }

    //
    // Now we initialize the size of stream descriptor information.
    // We have one stream descriptor, and we attempt to dword align the
    // structure.
    //

    ConfigInfo->StreamDescriptorSize = 
        1 * (sizeof (HW_STREAM_INFORMATION)) +      // 1 stream descriptor
        sizeof(HW_STREAM_HEADER);                   // and 1 stream header


    //
    // Construct the device property table from querying the device and registry
    //
    if(!NT_SUCCESS(status = DCamPrepareDevProperties(pDevExt))) {
        goto AbortLoading;
    }

    // Get the features of the properties as well as its persisted value.
    // It will also updated the table.
    // The return is ignored since the default values are set when there is a failure.
    DCamGetPropertyValuesFromRegistry(
        pDevExt
        );

    //
    // Query video mode supported, and then contruct the stream format table.
    //
    if(!DCamBuildFormatTable(pDevExt, pIrb)) {
        ERROR_LOG(("\'Failed to get Video Format and Mode information; return STATUS_NOT_SUPPORTED\n"));
        status = STATUS_NOT_SUPPORTED;    
        goto AbortLoading;
    }

    //
    // register a bus reset callback notification (as the last action in this function)
    //
    // The controller driver will call (at DPC level)
    // if and only if the device is STILL attached.
    //
    // The device that has been removed, its
    // driver will get SRB_SURPRISE_REMOVAL instead.
    //
    
    pIrb->FunctionNumber = REQUEST_BUS_RESET_NOTIFICATION;
    pIrb->Flags = 0;
    pIrb->u.BusResetNotification.fulFlags = REGISTER_NOTIFICATION_ROUTINE;
    pIrb->u.BusResetNotification.ResetRoutine = (PBUS_BUS_RESET_NOTIFICATION) DCamBusResetNotification;
    pIrb->u.BusResetNotification.ResetContext = pDevExt;
    status = DCamSubmitIrpSynch(pDevExt, pIrp, pIrb);
    if (status) {

        ERROR_LOG(("DCamHwInitialize: Error (Status=%x) while trying to get local host info.\n", status));
        status = STATUS_UNSUCCESSFUL;
        goto AbortLoading;
    }

    // This Irp is used locally only.
    IoFreeIrp(pIrp);  pIrp = NULL;


    DbgMsg1(("#### %s DCam loaded. ClassDO %x, PhyDO %x, BusDO %x, pDevExt %x, Gen# %d\n", 
        pDevExt->pchVendorName, pDevExt->SharedDeviceObject, pDevExt->PhysicalDeviceObject, pDevExt->BusDeviceObject, pDevExt, pDevExt->CurrentGeneration));

    return (STATUS_SUCCESS);

AbortLoading:


    if(pIrp) {
        IoFreeIrp(pIrp); pIrp = NULL;
    }

    if(pDevExt->ConfigRom) {
        ExFreePool(pDevExt->ConfigRom); pDevExt->ConfigRom = NULL;
    }

    if(pDevExt->UnitDirectory) {
        ExFreePool(pDevExt->UnitDirectory); pDevExt->UnitDirectory = NULL;
    }

    if(pDevExt->UnitDependentDirectory) {
        ExFreePool(pDevExt->UnitDependentDirectory); pDevExt->UnitDependentDirectory = NULL;
    }

    if(pDevExt->VendorLeaf) {
        ExFreePool(pDevExt->VendorLeaf); pDevExt->VendorLeaf = NULL;
    }

    if(pDevExt->ModelLeaf) {
        ExFreePool(pDevExt->ModelLeaf); pDevExt->ModelLeaf = NULL;
    }

    return status;

}


NTSTATUS
DCamSubmitIrpSynch(
    PDCAM_EXTENSION pDevExt,
    PIRP pIrp,
    PIRB pIrb
    )

/*++

Routine Description:

    This routine submits an Irp synchronously to the bus driver.  We'll
    wait here til the Irp comes back

Arguments:

    pDevExt - Pointer to my local device extension

    pIrp - Pointer to Irp we're sending down to the port driver synchronously

    pIrb - Pointer to Irb we're submitting to the port driver

Return Value:

    Status is returned from Irp

--*/

{


    LONG Retries=RETRY_COUNT_IRP_SYNC;  // Take the worst case of 20 * 100 msec = 1sec
    KEVENT Event;
    NTSTATUS status;
    LARGE_INTEGER deltaTime;
    PIO_STACK_LOCATION NextIrpStack;
    BOOL bCanWait = KeGetCurrentIrql() < DISPATCH_LEVEL;
    BOOL bRetryStatus;
    PIRB pIrbRetry;
    NTSTATUS StatusRetry;
    ULONG ulGeneration;

    

    do {

        NextIrpStack = IoGetNextIrpStackLocation(pIrp);
        NextIrpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        NextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_1394_CLASS;
        NextIrpStack->Parameters.Others.Argument1 = pIrb;

        KeInitializeEvent(&Event, SynchronizationEvent, FALSE);

        IoSetCompletionRoutine(
            pIrp,
            DCamSynchCR,
           &Event,
            TRUE,
            TRUE,
            TRUE
            );

        status = IoCallDriver(
                    pDevExt->BusDeviceObject,
                    pIrp
                    );


        DbgMsg3(("\'DCamSubmitIrpSynch: pIrp is pending(%s); will wait(%s)\n", 
                   status == STATUS_PENDING?"Y":"N", bCanWait?"Y":"N"));

        if (bCanWait &&
            status == STATUS_PENDING) {

            //
            // Still pending, wait for the IRP to complete
            //

            KeWaitForSingleObject(  // Only in <= IRQL_DISPATCH_LEVEL; can only in DISPATCH if Timeout is 0
               &Event,
                Executive,
                KernelMode,
                FALSE,
                NULL
                );

        }

        // Will retry for any of these return status codes.
        bRetryStatus = 
             pIrp->IoStatus.Status == STATUS_TIMEOUT ||
             pIrp->IoStatus.Status == STATUS_IO_TIMEOUT ||
             pIrp->IoStatus.Status == STATUS_DEVICE_BUSY ||
             pIrp->IoStatus.Status == STATUS_INVALID_GENERATION;

        if (bCanWait && bRetryStatus && Retries > 0) {

            // Camera isn't fast enough to respond so delay this thread and try again.
            switch(pIrp->IoStatus.Status) {

            case STATUS_TIMEOUT: 
            case STATUS_IO_TIMEOUT: 
            case STATUS_DEVICE_BUSY: 

                deltaTime.LowPart = DCAM_DELAY_VALUE;
                deltaTime.HighPart = -1;
                KeDelayExecutionThread(KernelMode, TRUE, &deltaTime); 
                break;

            case STATUS_INVALID_GENERATION:

                // Cache obsolete ulGeneration and use it to detect its udpate in busreset callback.               
                if(pIrb->FunctionNumber == REQUEST_ASYNC_READ)
                    ulGeneration = pIrb->u.AsyncRead.ulGeneration;
                else if(pIrb->FunctionNumber == REQUEST_ASYNC_WRITE)
                    ulGeneration = pIrb->u.AsyncWrite.ulGeneration;
                else if(pIrb->FunctionNumber == REQUEST_ASYNC_LOCK)
                    ulGeneration = pIrb->u.AsyncLock.ulGeneration;
                else if(pIrb->FunctionNumber == REQUEST_ISOCH_FREE_BANDWIDTH) {
                    ERROR_LOG(("InvGen when free BW\n"));                    
                    // Special case that we do not need to retry since BW should be free
                    // and 1394 bus should just free the BW structure.
                    Retries = 0;  // no more retry and exit.
                    break;
                }
                else {
                    // Other REQUEST_* that depends on ulGeneration
                    ERROR_LOG(("Unexpected IRB function with InvGen:%d\n", pIrb->FunctionNumber));  
                    ASSERT(FALSE && "New REQUEST that requires ulGeneration");
                    Retries = 0;  // do not know what to do so no more retry and exit.
                    break;
                }
                
                pIrbRetry = ExAllocatePoolWithTag(NonPagedPool, sizeof(IRB), 'macd');
                if (pIrbRetry) {

                    deltaTime.LowPart = DCAM_DELAY_VALUE_BUSRESET;  // Longer than the regular delay
                    deltaTime.HighPart = -1;

                    do {
                        KeDelayExecutionThread(KernelMode, TRUE, &deltaTime);

                        pIrbRetry->FunctionNumber = REQUEST_GET_GENERATION_COUNT;
                        pIrbRetry->u.GetGenerationCount.GenerationCount = 0;
                        pIrbRetry->Flags = 0;
                        StatusRetry = DCamSubmitIrpSynch(pDevExt, pIrp, pIrbRetry);  // Recursive with differnt IRB but same IRP.

                        if(NT_SUCCESS(StatusRetry) && pIrbRetry->u.GetGenerationCount.GenerationCount > ulGeneration) {
                            InterlockedExchange(&pDevExt->CurrentGeneration, pIrbRetry->u.GetGenerationCount.GenerationCount);
                            // Update the generation count for the original IRB request and try again.
                            if(pIrb->FunctionNumber == REQUEST_ASYNC_READ)
                                InterlockedExchange(&pIrb->u.AsyncRead.ulGeneration, pDevExt->CurrentGeneration);
                            else if(pIrb->FunctionNumber == REQUEST_ASYNC_WRITE)
                                InterlockedExchange(&pIrb->u.AsyncWrite.ulGeneration, pDevExt->CurrentGeneration);
                            else if(pIrb->FunctionNumber == REQUEST_ASYNC_LOCK)
                                InterlockedExchange(&pIrb->u.AsyncLock.ulGeneration, pDevExt->CurrentGeneration);
                            else {
                                // Other (new) REQUEST_* that depends on ulGeneration
                            }                        
                        }

                        if(Retries)
                            Retries--;

                    } while (Retries && ulGeneration >= pDevExt->CurrentGeneration);

                    ERROR_LOG(("(%d) IrpSync: StautsRetry %x; Generation %d -> %d\n", 
                        Retries, StatusRetry, ulGeneration, pDevExt->CurrentGeneration));

                    ExFreePool(pIrbRetry); pIrbRetry = 0;
                }  // if
                break;                                            

            // All other status
            default:
                break;      
            }
        }

        if(Retries)
            Retries--;
 
    } while (bCanWait && bRetryStatus && (Retries > 0));

#if DBG
    if(!NT_SUCCESS(pIrp->IoStatus.Status)) {
        ERROR_LOG(("IrpSynch: IoCallDriver Status:%x; pIrp->IoStatus.Status (final):%x; Wait:%d; Retries:%d\n", status, pIrp->IoStatus.Status, bCanWait, Retries)); 
    }
#endif

    return (pIrp->IoStatus.Status);

}


NTSTATUS
DCamSynchCR(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrp,
    IN PKEVENT Event
    )

/*++

Routine Description:

    This routine is for use with synchronous IRP processing.  
    All it does is signal an event, so the driver knows it
    can continue.

Arguments:

    DriverObject - Pointer to driver object created by system.

    pIrp - Irp that just completed

    Event - Event we'll signal to say Irp is done

Return Value:

    None.

--*/

{

    KeSetEvent((PKEVENT) Event, 0, FALSE);
    return (STATUS_MORE_PROCESSING_REQUIRED);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\atishare\atibios.h ===
//==========================================================================;
//
//File:			ATIBIOS.H
//
//Purpose:		Provide definitions for BIOS structures used in the ATI private
//			interfacese exposed via GPIO Interface
//
//Reference:	Ilya Klebanov
//
//Notes:		This file is provided under strict non-disclosure agreements
//			it is and remains the property of ATI Technologies Inc.
//			Any use of this file or the information it contains to
//			develop products commercial or otherwise must be with the
//			permission of ATI Technologies Inc.
//
//Copyright (C) 1997 - 1998, ATI Technologies Inc.
//
//==========================================================================;

#ifndef _ATIBIOS_H_
#define _ATIBIOS_H_

typedef struct tag_ATI_MULTIMEDIAINFO
{
	UCHAR	MMInfo_Byte0;
	UCHAR	MMInfo_Byte1;
	UCHAR	MMInfo_Byte2;
	UCHAR	MMInfo_Byte3;
	UCHAR	MMInfo_Byte4;
	UCHAR	MMInfo_Byte5;
	UCHAR	MMInfo_Byte6;
	UCHAR	MMInfo_Byte7;

} ATI_MULTIMEDIAINFO, * PATI_MULTIMEDIAINFO;


typedef struct tag_ATI_MULTIMEDIAINFO1
{
	UCHAR	MMInfo1_Byte0;
	UCHAR	MMInfo1_Byte1;
	UCHAR	MMInfo1_Byte2;
	UCHAR	MMInfo1_Byte3;
	UCHAR	MMInfo1_Byte4;
	UCHAR	MMInfo1_Byte5;
	UCHAR	MMInfo1_Byte6;
	UCHAR	MMInfo1_Byte7;
	UCHAR	MMInfo1_Byte8;
	UCHAR	MMInfo1_Byte9;
	UCHAR	MMInfo1_Byte10;
	UCHAR	MMInfo1_Byte11;

} ATI_MULTIMEDIAINFO1, * PATI_MULTIMEDIAINFO1;


typedef struct tag_ATI_HARDWAREINFO
{
	UCHAR	I2CHardwareMethod;
	UCHAR	ImpactTVSupport;
	UCHAR	VideoPortType;

} ATI_HARDWAREINFO, * PATI_HARDWAREINFO;

// this structure definition left for compatability purposes with MiniVDD checked in
// for Windows98 Beta3. The latest MiniVDD exposes set of Private Interfaces instead
// of copying the information into the Registry.
typedef struct
{
    UINT    uiSize;
    UINT    uiVersion;
    UINT    uiCardNumber;
    UINT    uiBoardRevision;
    UINT    uiTunerType;
    UINT    uiVideoInputConnectorType;
    UINT    uiVideoOutputConnectorType;
    UINT    uiCDInputConnector;
    UINT    uiCDOutputConnector;
    UINT    uiVideoPassThrough;
    UINT    uiVideoDecoderType;
    UINT    uiVideoDecoderCrystals;
    UINT    uiVideoOutCrystalFrequency;
    UINT    uiAudioCircuitType;
    UCHAR   uchATIProdType;
    UCHAR   uchOEM;
    UCHAR   uchOEMVersion;
    UCHAR   uchReserved3;
    UCHAR   uchReserved4;

} CWDDE32BoardIdBuffer, * PCWDDE32BoardIdBuffer;

#endif	// _ATIBIOS_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\1394dcam\propdata.h ===
//===========================================================================
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
// PURPOSE.
//
// Copyright (c) 1996 - 2000  Microsoft Corporation.  All Rights Reserved.
//
//===========================================================================

//
// Video and camera properties of a 1394 desktop digital camera
//


#ifndef _PROPDATA_H
#define _PROPDATA_H


// ------------------------------------------------------------------------
//  S O N Y    D i g i t a l    C a m e r a
// ------------------------------------------------------------------------

// ------------------------------------------------------------------------
// Property set for VideoProcAmp
// ------------------------------------------------------------------------

// Default values for some of the properties

#define SONYDCAM_DEF_BRIGHTNESS     12
#define SONYDCAM_DEF_HUE           128
#define SONYDCAM_DEF_SATURATION     25
#define SONYDCAM_DEF_SHARPNESS      15
#define SONYDCAM_DEF_WHITEBALANCE  160
#define SONYDCAM_DEF_ZOOM          640
#define SONYDCAM_DEF_FOCUS        1600

//
// First define all of the ranges and stepping values
//

// ------------------------------------------------------------------------
static KSPROPERTY_STEPPING_LONG BrightnessRangeAndStep [] = 
{
    {
        1,                  // SteppingDelta (range / steps)
        0,                  // Reserved
        0,                  // Minimum in (IRE * 100) units
        15                  // Maximum in (IRE * 100) units
    }
};

const static LONG BrightnessDefault = SONYDCAM_DEF_BRIGHTNESS;


static KSPROPERTY_MEMBERSLIST BrightnessMembersList [] = 
{
    {
        {
            KSPROPERTY_MEMBER_RANGES,
            sizeof (BrightnessRangeAndStep),
            SIZEOF_ARRAY (BrightnessRangeAndStep),
            0
        },
        (PVOID) BrightnessRangeAndStep,
     },
     {
        {
            KSPROPERTY_MEMBER_VALUES,
            sizeof (BrightnessDefault),
            sizeof (BrightnessDefault),
            KSPROPERTY_MEMBER_FLAG_DEFAULT
        },
        (PVOID) &BrightnessDefault,
    }    
};

static KSPROPERTY_VALUES BrightnessValues =
{
    {
        STATICGUIDOF (KSPROPTYPESETID_General),
        VT_I4,
        0
    },
    SIZEOF_ARRAY (BrightnessMembersList),
    BrightnessMembersList
};

// ------------------------------------------------------------------------
static KSPROPERTY_STEPPING_LONG SharpnessRangeAndStep [] = 
{
    {
        1,                  // SteppingDelta (range / steps)
        0,                  // Reserved
        0,                  // Minimum in (gain * 100) units
        15                  // Maximum in (gain * 100) units
    }
};

const static LONG SharpnessDefault = SONYDCAM_DEF_SHARPNESS;


static KSPROPERTY_MEMBERSLIST SharpnessMembersList [] = 
{
    {
        {
            KSPROPERTY_MEMBER_RANGES,
            sizeof (SharpnessRangeAndStep),
            SIZEOF_ARRAY (SharpnessRangeAndStep),
            0
        },
        (PVOID) SharpnessRangeAndStep
     },
     {
        {
            KSPROPERTY_MEMBER_VALUES,
            sizeof (SharpnessDefault),
            sizeof (SharpnessDefault),
            KSPROPERTY_MEMBER_FLAG_DEFAULT
        },
        (PVOID) &SharpnessDefault,
    }    
};

static KSPROPERTY_VALUES SharpnessValues =
{
    {
        STATICGUIDOF (KSPROPTYPESETID_General),
        VT_I4,
        0
    },
    SIZEOF_ARRAY (SharpnessMembersList),
    SharpnessMembersList
};

// ------------------------------------------------------------------------
static KSPROPERTY_STEPPING_LONG HueRangeAndStep [] = 
{
    {
        1,                  // SteppingDelta (range / steps)
        0,                  // Reserved
        96,                 // Minimum in (gain * 100) units
        160                 // Maximum in (gain * 100) units
    }
};

const static LONG HueDefault = SONYDCAM_DEF_HUE;


static KSPROPERTY_MEMBERSLIST HueMembersList [] = 
{
    {
        {
            KSPROPERTY_MEMBER_RANGES,
            sizeof (HueRangeAndStep),
            SIZEOF_ARRAY (HueRangeAndStep),
            0
        },
        (PVOID) HueRangeAndStep
     },
     {
        {
            KSPROPERTY_MEMBER_VALUES,
            sizeof (HueDefault),
            sizeof (HueDefault),
            KSPROPERTY_MEMBER_FLAG_DEFAULT
        },
        (PVOID) &HueDefault,
    }    
};

static KSPROPERTY_VALUES HueValues =
{
    {
        STATICGUIDOF (KSPROPTYPESETID_General),
        VT_I4,
        0
    },
    SIZEOF_ARRAY (HueMembersList),
    HueMembersList
};

// ------------------------------------------------------------------------
static KSPROPERTY_STEPPING_LONG SaturationRangeAndStep [] = 
{
    {
        1,                  // SteppingDelta (range / steps)
        0,                  // Reserved
        0,                  // Minimum in (gain * 100) units
        199                 // Maximum in (gain * 100) units
    }
};

const static LONG SaturationDefault = SONYDCAM_DEF_SATURATION;


static KSPROPERTY_MEMBERSLIST SaturationMembersList [] = 
{
    {
        {
            KSPROPERTY_MEMBER_RANGES,
            sizeof (SaturationRangeAndStep),
            SIZEOF_ARRAY (SaturationRangeAndStep),
            0
        },
        (PVOID) SaturationRangeAndStep
     },
     {
        {
            KSPROPERTY_MEMBER_VALUES,
            sizeof (SaturationDefault),
            sizeof (SaturationDefault),
            KSPROPERTY_MEMBER_FLAG_DEFAULT
        },
        (PVOID) &SaturationDefault,
    }    
};

static KSPROPERTY_VALUES SaturationValues =
{
    {
        STATICGUIDOF (KSPROPTYPESETID_General),
        VT_I4,
        0
    },
    SIZEOF_ARRAY (SaturationMembersList),
    SaturationMembersList
};

// ------------------------------------------------------------------------
static KSPROPERTY_STEPPING_LONG WhiteBalanceRangeAndStep [] = 
{
    {
        1,                  // SteppingDelta (range / steps)
        0,                  // Reserved
        32,                 // Minimum in (gain * 100) units
        224                 // Maximum in (gain * 100) units
    }
};

const static LONG WhiteBalanceDefault = SONYDCAM_DEF_WHITEBALANCE;


static KSPROPERTY_MEMBERSLIST WhiteBalanceMembersList [] = 
{
    {
        {
            KSPROPERTY_MEMBER_RANGES,
            sizeof (WhiteBalanceRangeAndStep),
            SIZEOF_ARRAY (WhiteBalanceRangeAndStep),
            0
        },
        (PVOID) WhiteBalanceRangeAndStep
     },
     {
        {
            KSPROPERTY_MEMBER_VALUES,
            sizeof (WhiteBalanceDefault),
            sizeof (WhiteBalanceDefault),
            KSPROPERTY_MEMBER_FLAG_DEFAULT
        },
        (PVOID) &WhiteBalanceDefault,
    }    
};

static KSPROPERTY_VALUES WhiteBalanceValues =
{
    {
        STATICGUIDOF (KSPROPTYPESETID_General),
        VT_I4,
        0
    },
    SIZEOF_ARRAY (WhiteBalanceMembersList),
    WhiteBalanceMembersList
};

// ------------------------------------------------------------------------
static KSPROPERTY_STEPPING_LONG FocusRangeAndStep [] = 
{
    {
        1,                  // SteppingDelta (range / steps)
        0,                  // Reserved
        0,                  // Minimum in (IRE * 100) units
        3456                // Maximum in (IRE * 100) units
    }
};

const static LONG FocusDefault = SONYDCAM_DEF_FOCUS;


static KSPROPERTY_MEMBERSLIST FocusMembersList [] = 
{
    {
        {
            KSPROPERTY_MEMBER_RANGES,
            sizeof (FocusRangeAndStep),
            SIZEOF_ARRAY (FocusRangeAndStep),
            0
        },
        (PVOID) FocusRangeAndStep,
     },
     {
        {
            KSPROPERTY_MEMBER_VALUES,
            sizeof (FocusDefault),
            sizeof (FocusDefault),
            KSPROPERTY_MEMBER_FLAG_DEFAULT
        },
        (PVOID) &FocusDefault,
    }    
};

static KSPROPERTY_VALUES FocusValues =
{
    {
        STATICGUIDOF (KSPROPTYPESETID_General),
        VT_I4,
        0
    },
    SIZEOF_ARRAY (FocusMembersList),
    FocusMembersList
};

// ------------------------------------------------------------------------
static KSPROPERTY_STEPPING_LONG ZoomRangeAndStep [] = 
{
    {
        1,                  // SteppingDelta (range / steps)
        0,                  // Reserved
        64,                 // Minimum in (IRE * 100) units
        1855                // Maximum in (IRE * 100) units
    }
};

const static LONG ZoomDefault = SONYDCAM_DEF_ZOOM;


static KSPROPERTY_MEMBERSLIST ZoomMembersList [] = 
{
    {
        {
            KSPROPERTY_MEMBER_RANGES,
            sizeof (ZoomRangeAndStep),
            SIZEOF_ARRAY (ZoomRangeAndStep),
            0
        },
        (PVOID) ZoomRangeAndStep,
     },
     {
        {
            KSPROPERTY_MEMBER_VALUES,
            sizeof (ZoomDefault),
            sizeof (ZoomDefault),
            KSPROPERTY_MEMBER_FLAG_DEFAULT
        },
        (PVOID) &ZoomDefault,
    }    
};

static KSPROPERTY_VALUES ZoomValues =
{
    {
        STATICGUIDOF (KSPROPTYPESETID_General),
        VT_I4,
        0
    },
    SIZEOF_ARRAY (ZoomMembersList),
    ZoomMembersList
};

// ------------------------------------------------------------------------
DEFINE_KSPROPERTY_TABLE(VideoProcAmpProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinProperty
        sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinData
        TRUE,                                   // SetSupported or Handler
        &BrightnessValues,                      // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),

    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEOPROCAMP_SHARPNESS,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinProperty
        sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinData
        TRUE,                                   // SetSupported or Handler
        &SharpnessValues,                       // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),

    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEOPROCAMP_HUE,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinProperty
        sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinData
        TRUE,                                   // SetSupported or Handler
        &HueValues,                             // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),    

    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEOPROCAMP_SATURATION,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinProperty
        sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinData
        TRUE,                                   // SetSupported or Handler
        &SaturationValues,                      // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),

    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEOPROCAMP_WHITEBALANCE,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinProperty
        sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinData
        TRUE,                                   // SetSupported or Handler
        &WhiteBalanceValues,                    // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),
};

DEFINE_KSPROPERTY_TABLE(CameraControlProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_CAMERACONTROL_FOCUS,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_CAMERACONTROL_S),     // MinProperty
        sizeof(KSPROPERTY_CAMERACONTROL_S),     // MinData
        TRUE,                                   // SetSupported or Handler
        &FocusValues,                            // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_CAMERACONTROL_ZOOM,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_CAMERACONTROL_S),     // MinProperty
        sizeof(KSPROPERTY_CAMERACONTROL_S),     // MinData
        TRUE,                                   // SetSupported or Handler
        &ZoomValues,                            // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),
};


// ------------------------------------------------------------------------
// Array of all of the property sets supported by the adapter
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_SET_TABLE(AdapterPropertyTable)
{
    DEFINE_KSPROPERTY_SET
    ( 
        &PROPSETID_VIDCAP_VIDEOPROCAMP,
        SIZEOF_ARRAY(VideoProcAmpProperties),
        VideoProcAmpProperties,
        0, 
        NULL
    ),

    DEFINE_KSPROPERTY_SET
    ( 
        &PROPSETID_VIDCAP_CAMERACONTROL,
        SIZEOF_ARRAY(CameraControlProperties),
        CameraControlProperties,
        0, 
        NULL
    )
};

#define NUMBER_OF_ADAPTER_PROPERTY_SETS (SIZEOF_ARRAY (AdapterPropertyTable))


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\atishare\aticonfg.h ===
//==========================================================================;
//
//	ATIConfg.H
//		CATIHwConfiguration Class definition.
//  Copyright (c) 1996 - 1998  ATI Technologies Inc.  All Rights Reserved.
//
//		$Date:   16 Nov 1998 13:40:34  $
//	$Revision:   1.9  $
//	  $Author:   minyailo  $
//
//==========================================================================;

#ifndef _ATICONFG_H_

#define _ATICONFG_H_


#include "i2script.h"
#include "tda9850.h"
#include "tda9851.h"
#include "atibios.h"
// this file is included for compatability with MiniVDD checked in for Beta3 of Windows98
#include "registry.h"
#include "mmconfig.h"   //Paul


class CATIHwConfiguration
{
public:
	// constructor
	CATIHwConfiguration		( PDEVICE_OBJECT pDeviceObject, CI2CScript * pCScript, PUINT puiError);
	PVOID operator new		( size_t size, PVOID pAllocation);

// Attributes	
private:
	// tuner's configuration properties
	USHORT			m_usTunerId;
	UCHAR			m_uchTunerAddress;
	USHORT			m_usTunerPowerConfiguration;
	// decoder's configuration properties
	USHORT			m_usDecoderId;
	UCHAR			m_uchDecoderAddress;
	USHORT			m_usDecoderConfiguration;
	// audio's configuration properties
	UCHAR			m_uchAudioAddress;
	UINT			m_uiAudioConfiguration;
	// hardware configuration
	UCHAR			m_uchI2CExpanderAddress;
	USHORT			m_usE2PROMValidation;
	// GPIO Provider related
	GPIOINTERFACE	m_gpioProviderInterface;
	PDEVICE_OBJECT	m_pdoDriver;
	DWORD			m_dwGPIOAccessKey;
    // Paul:  Decide video in standards supported by crystal by looking at MMTable or I2C expander crystal information
    ULONG           m_VideoInStandardsSupported;
    UCHAR           m_CrystalIDInMMTable;           

// Implementation
public:
	BOOL			GetTunerConfiguration		( PUINT puiTunerId, PUCHAR puchTunerAddress);
	BOOL			GetDecoderConfiguration		( PUINT puiDecoderId, PUCHAR puchDecoderAddress);
	BOOL			GetAudioConfiguration		( PUINT puiAudioId, PUCHAR puchAudioAddress);
	UINT			GetDecoderOutputEnableLevel	( void);

#if 0
	void			EnableDecoderOutput			( CI2CScript * pCScript, BOOL bEnable);
#endif	// not compiled
	void			EnableDecoderI2CAccess		( CI2CScript * pCScript, BOOL bEnable);
	BOOL			GetAudioProperties			( PULONG puiNumberOfInputs, PULONG puiNumberOfOutputs);
	BOOL			InitializeAudioConfiguration( CI2CScript * pCScript, UINT uiAudioConfigurationId, UCHAR uchAudioChipAddress);

	BOOL			CanConnectAudioSource		( int nAudioSource);
	BOOL			ConnectAudioSource			( CI2CScript * pCScript, int nAudioSource);
	BOOL			GetTVAudioSignalProperties	( CI2CScript * pCScript, PBOOL pbStereo, PBOOL pbSAP);

	BOOL			SetTunerPowerState			( CI2CScript * pCScript,
											  	  BOOL bPowerState);
    ULONG           GetVideoInStandardsSupportedByCrystal( )
        { return m_VideoInStandardsSupported; }                 //Paul
    ULONG           GetVideoInStandardsSupportedByTuner( )
        { return ReturnTunerVideoStandard( m_usTunerId ); }
    BOOL            GetMMTableCrystalID( PUCHAR pucCrystalID );

private:
	BOOL			FindI2CExpanderAddress		( CI2CScript * pCScript);
	BOOL			FindHardwareProperties		( PDEVICE_OBJECT pDeviceObject, CI2CScript * pCScript);

	BOOL			GetI2CExpanderConfiguration	( CI2CScript * pCScript, PUCHAR puchI2CValue);
	BOOL			SetDefaultVolumeControl		( CI2CScript * pCScript);

	BOOL			ValidateConfigurationE2PROM	( CI2CScript * pCScript);
	BOOL			ReadConfigurationE2PROM		( CI2CScript * pCScript, ULONG nOffset, PUCHAR puchValue);

	BOOL 			InitializeAttachGPIOProvider( GPIOINTERFACE * pGPIOInterface, PDEVICE_OBJECT pDeviceObject);
	BOOL			LocateAttachGPIOProvider	( GPIOINTERFACE * pGPIOInterface, PDEVICE_OBJECT pDeviceObject, UCHAR nIrpMajorFunction);

	BOOL			LockGPIOProviderEx			( PGPIOControl pgpioAccessBlock);
	BOOL			ReleaseGPIOProvider			( PGPIOControl pgpioAccessBlock);
	BOOL			AccessGPIOProvider			( PDEVICE_OBJECT pdoClient, PGPIOControl pgpioAccessBlock);
    ULONG           ReturnTunerVideoStandard    ( USHORT usTunerId );   //Paul:  For PAL support
    ULONG           SetVidStdBasedOnI2CExpander ( UCHAR ucI2CValue );   //Paul
    ULONG           SetVidStdBasedOnMMTable     ( CATIMultimediaTable * pCMultimediaInfo );    //Paul
};


#define ATIHARDWARE_TUNER_WAKEUP_DELAY		-100000		// 10 msec in 100 nsec units

typedef enum
{
	VIDEODECODER_TYPE_NOTINSTALLED = 0,
	VIDEODECODER_TYPE_BT819,
	VIDEODECODER_TYPE_BT829,
	VIDEODECODER_TYPE_BT829A,
	VIDEODECODER_TYPE_PH7111,
	VIDEODECODER_TYPE_PH7112,
	VIDEODECODER_TYPE_RTHEATER	//	RTheater

} ATI_VIDEODECODER_TYPE;

enum
{
	AUDIOSOURCE_MUTE = 0,
	AUDIOSOURCE_TVAUDIO,
	AUDIOSOURCE_LINEIN,
	AUDIOSOURCE_FMAUDIO,
	AUDIOSOURCE_LASTSUPPORTED

};
//****************************************************************************
//	Decoder Configurations			Dec. Type				Dec. Enable Method
//****************************************************************************
typedef enum
{
	ATI_VIDEODECODER_CONFIG_UNDEFINED = 0,
	ATI_VIDEODECODER_CONFIG_1,		//	BT829 on ATI TV or AIW	IO Exp Bit 7
	ATI_VIDEODECODER_CONFIG_2,		//	BT829A and above		BT Reg 0x16, OE=1
	ATI_VIDEODECODER_CONFIG_3,		//	BT829					CPU GPIO 0x7c
	ATI_VIDEODECODER_CONFIG_4,		//	BT829					CPU GPIO 0x78

} ATI_DECODER_CONFIGURATION;

//****************************************************************************
//	Audio Configurations		SAP		STEREO			VOLUME		MUX
//****************************************************************************
enum
{
	ATI_AUDIO_CONFIG_1 = 1,	//	No		IO Exp b6=0		No			IO Exp
							//										  b6:b4
							//										M x:0
							//										T 0:1
							//										L 1:1
							//										F n/a
//****************************************************************************
	ATI_AUDIO_CONFIG_2,		//	TDA9850	TDA9850			Yes			EXT_DAC_REGS
							//										  b6:b4
							//										M 1:0
							//										T 0:1
							//										L 0:0
							//										F 1:1
//****************************************************************************
	ATI_AUDIO_CONFIG_3,		//	No		No				No			IO Exp
							//										  b6
							//										M n/a
							//										T 0
							//										L 1
							//										F n/a
//****************************************************************************
	ATI_AUDIO_CONFIG_4,		//	No		No				Yes			TDA8425
//****************************************************************************
	ATI_AUDIO_CONFIG_5,		//	No		TEA5582			No			IO Exp
							//										  b6:b4
							//										M 1:1
							//										T 0:0
							//										L 1:0
							//										F 0:1
//****************************************************************************
	ATI_AUDIO_CONFIG_6,		//	No		BT829			Automatic	BT829 GPIO
							//			GPIO4			Volume		  0:1
							//			and				Control		M 0:1
							//			TDA9851						T 1:0
							//			for TV						L 0:0
							//										F 1:1
//****************************************************************************
	ATI_AUDIO_CONFIG_7,		//	TDA9850	TDA9850			Yes			BT829 GPIO
							//										AS0:1
							//										M 0:1
							//										T 1:0
							//										L 0:0
							//										F 1:1
//****************************************************************************
	ATI_AUDIO_CONFIG_8		//	MSP3430	MSP3430			Yes			MSP3430
//****************************************************************************

};


//****************************************************************************
//	Tuner Power Mode Configurations		Supported	Control
//****************************************************************************
enum
{
	ATI_TUNER_POWER_CONFIG_0 = 0,	//	No
//****************************************************************************
	ATI_TUNER_POWER_CONFIG_1,		//	Yes			EXT_DAC_REGS
									//					b4
									//				ON	0
									//				OFF	1
//****************************************************************************
	ATI_TUNER_POWER_CONFIG_2		//	Yes			BT829 GPIO
									//					3
									//				ON	0
									//				OFF	1
//****************************************************************************
};


enum 
{
	OEM_ID_ATI = 0,
	OEM_ID_INTEL,
	OEM_ID_APRICOT,
	OEM_ID_COMPAQ,
	OEM_ID_SAMSUNG,
	OEM_ID_BCM,
	OEM_ID_QUANTA,
	OEM_ID_SAMREX,
	OEM_ID_FUJITSU,
	OEM_ID_NEC,

};

enum 
{
	REVISION0 = 0,
	REVISION1,
	REVISION2,
	REVISION3,
	REVISION4,
};

enum 
{
	ATI_PRODUCT_TYPE_AIW = 1,
	ATI_PRODUCT_TYPE_AIW_PRO_NODVD,				// 2
	ATI_PRODUCT_TYPE_AIW_PRO_DVD,				// 3
	ATI_PRODUCT_TYPE_AIW_PLUS,					// 4
	ATI_PRODUCT_TYPE_AIW_PRO_R128_KITCHENER,	// 5
	ATI_PRODUCT_TYPE_AIW_PRO_R128_TORONTO		// 6

};

#define	INTEL_ANCHORAGE							1

#define AIWPRO_CONFIGURATIONE2PROM_ADDRESS		0xA8
#define AIWPRO_CONFIGURATIONE2PROM_LENGTH		128			// 0x80

#endif	// _ATICONFG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\atishare\common.h ===
#pragma once

//==========================================================================;
//
//	Common include file for wdm source modules
//
//		$Date:   15 Apr 1999 11:06:02  $
//	$Revision:   1.1  $
//	  $Author:   Tashjian  $
//
// $Copyright:	(c) 1997 - 1999  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

extern "C"
{
#include "strmini.h"
#include "mmsystem.h"
#include "ksmedia.h"
}

#include "wdmdebug.h"
#include "wdmdrv.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\atishare\aticonfg.cpp ===
//==========================================================================;
//
//	ATIConfg.CPP
//	WDM MiniDrivers development.
//		ATIHwConfiguration class implementation.
//  Copyright (c) 1996 - 1997  ATI Technologies Inc.  All Rights Reserved.
//
//		$Date:   10 Jun 1999 09:54:42  $
//	$Revision:   1.21  $
//	  $Author:   KLEBANOV  $
//
//==========================================================================;

extern"C"
{
#include "conio.h"
#include "strmini.h"
#include "wdmdebug.h"
#include "ksmedia.h"    //Paul
}

#include "aticonfg.h"
#include "wdmdrv.h"
#include "atigpio.h"
#include "mmconfig.h"


/*^^*
 *		operator new
 * Purpose	: CATIHwConfiguration class overloaded operator new.
 *				Provides placement for a CATIHwConfiguration class object from the PADAPTER_DEVICE_EXTENSION
 *				allocated by the StreamClassDriver for the MiniDriver.
 *
 * Inputs	:	size_t size			: size of the object to be placed
 *				PVOID pAllocation	: casted pointer to the CATIHwConfigurationaticonfg.h
 allocated data
 *
 * Outputs	: PVOID : pointer of the CATIHwConfiguration class object
 * Author	: IKLEBANOV
 *^^*/
/*
PVOID CATIHwConfiguration::operator new( size_t size,  PVOID pAllocation)
{

	if( size != sizeof( CATIHwConfiguration))
	{
		OutputDebugError(( "CATIHwConfiguration: operator new() fails\n"));
		return( NULL);
	}
	else
		return( pAllocation);
}
*/


/*^^*
 *		CATIHwConfiguration()
 * Purpose	: CATIHwConfiguration Class constructor
 *				Determines I2CExpander address and all possible hardware IDs and addresses
 *
 * Inputs	: PDEVICE_OBJECT pDeviceObject	: pointer to the creator DeviceObject
 *			  CI2CScript * pCScript			: pointer to the I2CScript class object
 *			  PUINT puiError				: pointer to return Error code
 *
 * Outputs	: none
 * Author	: IKLEBANOV
 *^^*/
CATIHwConfiguration::CATIHwConfiguration( PDEVICE_OBJECT pDeviceObject, CI2CScript * pCScript, PUINT puiError)
{

	ENSURE
	{
        m_VideoInStandardsSupported = 0;
        m_CrystalIDInMMTable = 0xF; //Paul: invalid entry, needs to be set when set with the value from MMTable
		m_gpioProviderInterface.gpioOpen = NULL;
		m_gpioProviderInterface.gpioAccess = NULL;
		m_pdoDriver = NULL;
		
		m_usE2PROMValidation = ( USHORT)-1;

		if( InitializeAttachGPIOProvider( &m_gpioProviderInterface, pDeviceObject))
			// there was no error to get GPIOInterface from the MiniVDD
			m_pdoDriver = pDeviceObject;
		else
		{
			* puiError = WDMMINI_ERROR_NOGPIOPROVIDER;
			FAIL;
		}

		if( !FindI2CExpanderAddress( pCScript))
		{
			* puiError = WDMMINI_NOHARDWARE;
			FAIL;
		}
	
		if( !FindHardwareProperties( pDeviceObject, pCScript))
		{
			* puiError = WDMMINI_NOHARDWARE;
			FAIL;
		}

/*
		// as soon it's a generic class object, we do not check decoder presence
		if( m_uchDecoderAddress == 0)
		{
			* puiError = WDMMINI_UNKNOWNHARDWARE;
			FAIL;
		}
*/

		* puiError = WDMMINI_NOERROR;

		OutputDebugTrace(( "CATIHwConfig:CATIHwConfiguration() exit\n"));

	} END_ENSURE;

	if( * puiError != WDMMINI_NOERROR)
		OutputDebugError(( "CATIHwConfig:CATIHwConfiguration() uiError=%x\n", * puiError));
}


/*^^*
 *		FindHardwareProperties()
 * Purpose	: Determines hardware properties : I2C address and the type
 *
 * Inputs	: PDEVICEOBJECT	pDeviceObject: pointer to device object
 *			  CI2CScript * pCScript	: pointer to the I2CScript object
 *
 * Outputs	: BOOL, TRUE if a valid ATI hardware Configuration was found
 * Author	: IKLEBANOV
 *^^*/
BOOL CATIHwConfiguration::FindHardwareProperties( PDEVICE_OBJECT pDeviceObject, CI2CScript * pCScript)
{
	UCHAR					uchI2CValue;
	UCHAR					uchORMask = 0x00;
	UCHAR					uchANDMask = 0xFF;
	BOOL					bResult = TRUE;
	I2CPacket				i2cPacket;

    m_VideoInStandardsSupported = 0;    //Paul

	m_uchTunerAddress = 0;
	m_usTunerId = 0;
	m_usTunerPowerConfiguration = ATI_TUNER_POWER_CONFIG_0;

	m_uchDecoderAddress = 0;
	m_usDecoderId = VIDEODECODER_TYPE_NOTINSTALLED;
	m_usDecoderConfiguration = 0;

	m_uchAudioAddress = 0;
	m_uiAudioConfiguration = 0;

	switch( m_uchI2CExpanderAddress)
	{
		case 0x70:			// a standard external tuner board

			m_uchTunerAddress	= 0xC0;
			m_uchDecoderAddress = 0x88;
			// we need to determine actual Decoder ID, implement later
			m_usDecoderId = VIDEODECODER_TYPE_BT829;

			if( GetI2CExpanderConfiguration( pCScript, &uchI2CValue))
			{
				m_usTunerId = uchI2CValue & 0x0F;

				m_usDecoderConfiguration = ATI_VIDEODECODER_CONFIG_1;

				if( uchI2CValue & 0x10)
				{
					m_uiAudioConfiguration = ATI_AUDIO_CONFIG_4;
					m_uchAudioAddress = 0x82;
				}
				else
					m_uiAudioConfiguration = ATI_AUDIO_CONFIG_3;
			}

            m_VideoInStandardsSupported = SetVidStdBasedOnI2CExpander( uchI2CValue );   //Paul

			break;

		case 0x78:			// FM tuner
			m_uchTunerAddress	= 0xC0;
			m_uchDecoderAddress = 0x88;
			// we need to determine actual Decoder ID, implement later
			m_usDecoderId = VIDEODECODER_TYPE_BT829;

			if( GetI2CExpanderConfiguration( pCScript, &uchI2CValue))
			{
				m_usTunerId = uchI2CValue & 0x0F;

				m_usDecoderConfiguration	= ATI_VIDEODECODER_CONFIG_1;
				m_uiAudioConfiguration		= ATI_AUDIO_CONFIG_5;
			}

            m_VideoInStandardsSupported = SetVidStdBasedOnI2CExpander( uchI2CValue );   //Paul

			break;
/*
		case 0x72:		// a standard exeternal tuner board + some hardcoded properties
			m_uchTunerAddress = 0xC6;

			if( GetI2CExpanderConfiguration( pCScript, &uchI2CValue))
				m_usTunerId = uchI2CValue & 0x0F;

			break;
*/

		case 0x76:		// AllInWonder, configuration is in the BIOS
			{
				CATIMultimediaTable CMultimediaInfo( pDeviceObject, &m_gpioProviderInterface, &bResult);

				if( bResult)
				{
					// tuner and decoder Info is included
					m_uchTunerAddress	= 0xC6;
					m_uchDecoderAddress	= 0x8A;
					m_usDecoderConfiguration	= ATI_VIDEODECODER_CONFIG_1;
					m_uiAudioConfiguration		= ATI_AUDIO_CONFIG_1;

					if( !CMultimediaInfo.GetTVTunerId( &m_usTunerId) ||
						!CMultimediaInfo.GetVideoDecoderId( &m_usDecoderId))
						bResult = FALSE;
                    else
                        m_VideoInStandardsSupported = SetVidStdBasedOnMMTable( &CMultimediaInfo );  //Paul

				}
				break;
			}

		case 0x7C:
			ENSURE
			{
				i2cPacket.uchChipAddress = m_uchI2CExpanderAddress;
				i2cPacket.cbReadCount = 1;
				i2cPacket.cbWriteCount = 0;
				i2cPacket.puchReadBuffer = &uchI2CValue;
				i2cPacket.puchWriteBuffer = NULL;
				i2cPacket.usFlags = 0;
			
				pCScript->ExecuteI2CPacket( &i2cPacket);
			
				if( i2cPacket.uchI2CResult != I2C_STATUS_NOERROR)
				{
					bResult = FALSE;
					FAIL;
				}

				uchI2CValue |= 0x0F;

				i2cPacket.uchChipAddress = m_uchI2CExpanderAddress;
				i2cPacket.cbReadCount = 0;
				i2cPacket.cbWriteCount = 1;
				i2cPacket.puchReadBuffer = NULL;
				i2cPacket.puchWriteBuffer = &uchI2CValue;
				i2cPacket.usFlags = 0;
			
				pCScript->ExecuteI2CPacket( &i2cPacket);
			
				if (i2cPacket.uchI2CResult != I2C_STATUS_NOERROR)
				{
					bResult = FALSE;
					FAIL;
				}

				// information should be correct now
				if( GetI2CExpanderConfiguration( pCScript, &uchI2CValue))
				{
					m_usTunerId = uchI2CValue & 0x0F;
				}

                m_VideoInStandardsSupported = SetVidStdBasedOnI2CExpander( uchI2CValue );   //Paul


			} END_ENSURE;

			if (!bResult)
				break;
			// For IO Expander address == 0x7c there might be more information in the BIOS Table sto do not return
			// or break at this point

		case 0xFF:		// AllInWonder PRO, configuration is in the BIOS
			ENSURE
			{
				CATIMultimediaTable	CMultimediaInfo( pDeviceObject, &m_gpioProviderInterface, &bResult);
				USHORT				nOEMId, nOEMRevision, nATIProductType;
				BOOL				bATIProduct;
					
				if( !bResult)
					FAIL;

				// OEM Id information is included
				if( !CMultimediaInfo.IsATIProduct( &bATIProduct))
				{
					bResult = FALSE;
					FAIL;
				}

				m_uchDecoderAddress = 0x8A;
				m_uchTunerAddress = 0xC6;

				if( bATIProduct)
				{
					if( !CMultimediaInfo.GetATIProductId( &nATIProductType))
					{
						bResult = FALSE;
						FAIL;
					}

					if( CMultimediaInfo.GetTVTunerId( &m_usTunerId)	&&
						CMultimediaInfo.GetVideoDecoderId( &m_usDecoderId))
					{
						switch( nATIProductType)
						{
							case ATI_PRODUCT_TYPE_AIW_PRO_NODVD:
							case ATI_PRODUCT_TYPE_AIW_PRO_DVD:
								m_usDecoderConfiguration	= ATI_VIDEODECODER_CONFIG_2;
								m_uiAudioConfiguration		= ATI_AUDIO_CONFIG_2;
								m_usTunerPowerConfiguration	= ATI_TUNER_POWER_CONFIG_1;

								m_uchAudioAddress = 0xB4;

								break;

							case ATI_PRODUCT_TYPE_AIW_PLUS:
								m_uiAudioConfiguration		= ATI_AUDIO_CONFIG_6;
								m_usDecoderConfiguration	= ATI_VIDEODECODER_CONFIG_2;

								m_uchAudioAddress = 0xB6;
								break;

							case ATI_PRODUCT_TYPE_AIW_PRO_R128_KITCHENER:
								m_uiAudioConfiguration		= ATI_AUDIO_CONFIG_7;
								m_usDecoderConfiguration	= ATI_VIDEODECODER_CONFIG_2;

								m_uchAudioAddress = 0xB4;
								break;

							case ATI_PRODUCT_TYPE_AIW_PRO_R128_TORONTO:
								m_uiAudioConfiguration		= ATI_AUDIO_CONFIG_8;
								m_usDecoderConfiguration	= ATI_VIDEODECODER_CONFIG_UNDEFINED;

								m_uchAudioAddress = 0x80;
								break;

							default:
								bResult = FALSE;
								break;
						}
					}
					else
						bResult = FALSE;
				}
				else
				{
					// non ATI Product
					if( !CMultimediaInfo.GetOEMId( &nOEMId)				||
						!CMultimediaInfo.GetOEMRevisionId( &nOEMRevision))
					{
						bResult = FALSE;
						FAIL;
					}

					m_uchDecoderAddress = 0x8A;
					m_uchTunerAddress = 0xC6;
					
					switch( nOEMId)
					{
						case OEM_ID_INTEL:
							switch( nOEMRevision)
							{
								case INTEL_ANCHORAGE:
									if( CMultimediaInfo.GetVideoDecoderId( &m_usDecoderId) &&
										CMultimediaInfo.GetTVTunerId( &m_usTunerId))
									{
										m_uiAudioConfiguration	= ATI_AUDIO_CONFIG_1;
										switch( m_usDecoderId)
										{
											case VIDEODECODER_TYPE_BT829:
												m_usDecoderConfiguration = ATI_VIDEODECODER_CONFIG_3;
												break;

											case VIDEODECODER_TYPE_BT829A:
												m_usDecoderConfiguration = ATI_VIDEODECODER_CONFIG_2;
												break;

											default:
												bResult = FALSE;
												break;
										}
									}
									else
										bResult = FALSE;
									break;

								default:
									bResult = FALSE;
									break;
							}
							break;

						case OEM_ID_APRICOT:
							switch( nOEMRevision)
							{
								case REVISION1:
								case REVISION2:
									if( CMultimediaInfo.GetTVTunerId( &m_usTunerId))
									{
										switch( m_usDecoderId)
										{
											case VIDEODECODER_TYPE_BT829:
												m_usDecoderConfiguration = ATI_VIDEODECODER_CONFIG_4;
												break;

											case VIDEODECODER_TYPE_BT829A:
												m_usDecoderConfiguration = ATI_VIDEODECODER_CONFIG_2;
												break;
										}
									}
									else
										bResult = FALSE;
									break;

								default:
									bResult = FALSE;
									break;
							}
							break;

						case OEM_ID_FUJITSU:
							m_uchDecoderAddress = 0x88;
							switch( nOEMRevision)
							{
								case REVISION1:
									if( CMultimediaInfo.GetVideoDecoderId( &m_usDecoderId))
									{
										switch( m_usDecoderId)
										{
											case VIDEODECODER_TYPE_BT829A:
												m_usDecoderConfiguration = ATI_VIDEODECODER_CONFIG_2;
												break;

											default:
												bResult = FALSE;
												break;
										}
									}
									else
										bResult = FALSE;
									break;

								default:
									bResult = FALSE;
									break;
							}
							break;

						case OEM_ID_COMPAQ:
							switch( nOEMRevision)
							{
								case REVISION1:
									if( CMultimediaInfo.GetVideoDecoderId( &m_usDecoderId))
									{
										switch( m_usDecoderId)
										{
											case VIDEODECODER_TYPE_BT829:
												m_usDecoderConfiguration = ATI_VIDEODECODER_CONFIG_3;
												break;

											case VIDEODECODER_TYPE_BT829A:
												m_usDecoderConfiguration = ATI_VIDEODECODER_CONFIG_2;
												break;

											default:
												bResult = FALSE;
												break;
										}
									}
									else
										bResult = FALSE;
									break;

								default:
									bResult = FALSE;
									break;
							}
							break;

						case OEM_ID_BCM:
						case OEM_ID_SAMSUNG:
							switch( nOEMRevision)
							{
								case REVISION0:
									if( CMultimediaInfo.GetVideoDecoderId( &m_usDecoderId))
									{
										switch( m_usDecoderId)
										{
											case VIDEODECODER_TYPE_BT829A:
												m_usDecoderConfiguration = ATI_VIDEODECODER_CONFIG_2;
												break;

											default:
												bResult = FALSE;
										}
									}
									else
										bResult = FALSE;
									break;

								default:
									bResult = FALSE;
									break;
							}
							break;

						case OEM_ID_SAMREX:
							switch( nOEMRevision)
							{
								case REVISION0:
									if( CMultimediaInfo.GetVideoDecoderId( &m_usDecoderId))
									{
										switch( m_usDecoderId)
										{
											case VIDEODECODER_TYPE_BT829A:
												m_usDecoderConfiguration = ATI_VIDEODECODER_CONFIG_2;
												break;

											default:
												bResult = FALSE;
												break;
										}
									}
									else
										bResult = FALSE;
									break;

								default:
									bResult = FALSE;
									break;
							}
							break;

						case OEM_ID_NEC:
							switch( nOEMRevision)
							{
								case REVISION0:
								case REVISION1:
									if( CMultimediaInfo.GetVideoDecoderId( &m_usDecoderId))
									{
										switch( m_usDecoderId)
										{
											case VIDEODECODER_TYPE_BT829A:
												m_usDecoderConfiguration = ATI_VIDEODECODER_CONFIG_2;
												break;

											default:
												bResult = FALSE;
												break;
										}
									}
									else
										bResult = FALSE;
									break;

								default:
									bResult = FALSE;
									break;
							}
							break;

						default:
                                                        if( CMultimediaInfo.GetVideoDecoderId( &m_usDecoderId))
                                                        {
                                                            if( m_usDecoderId == VIDEODECODER_TYPE_RTHEATER)
                                                            {
                                                                // default the configuration to Toronto board
                                                                m_uiAudioConfiguration   = ATI_AUDIO_CONFIG_8;
                                                                m_usDecoderConfiguration = ATI_VIDEODECODER_CONFIG_UNDEFINED;

								m_uchAudioAddress = 0x80;
                                                            }
                                                            else
                                                            {
                                                                // default the configuration to Kitchener board
                                                                m_uiAudioConfiguration   = ATI_AUDIO_CONFIG_7;
                                                                m_usDecoderConfiguration = ATI_VIDEODECODER_CONFIG_2;

								m_uchAudioAddress = 0xB4;
                                                            }

                                                            bResult = TRUE;
                                                            
                                                        }
                                                        else
                                                            bResult = FALSE;

							break;
					}
				}

                m_VideoInStandardsSupported = SetVidStdBasedOnMMTable( &CMultimediaInfo );  //Paul

			} END_ENSURE;

			break;
	}
    
    OutputDebugInfo(( "CATIHwConfig:FindHardwareConfiguration() found:\n"));
	OutputDebugInfo(( "Tuner:   Id = %d, I2CAddress = 0x%x\n",
		m_usTunerId, m_uchTunerAddress));
	OutputDebugInfo(( "Decoder: Id = %d, I2CAddress = 0x%x, Configuration = %d\n",
		m_usDecoderId, m_uchDecoderAddress,	m_usDecoderConfiguration));
	OutputDebugInfo(( "Audio:           I2CAddress = 0x%x, Configuration = %d\n",
		m_uchAudioAddress, m_uiAudioConfiguration));

	return( bResult);
}


/*^^*
 *		GetTunerConfiguration()
 * Purpose	: Gets tuner Id and i2C address
 * Inputs	:	PUINT  puiTunerId		: pointer to return tuner Id
 *				PUCHAR puchTunerAddress	: pointer to return tuner I2C address
 *
 * Outputs	: BOOL : returns TRUE
 *				also sets the requested values into the input pointers
 * Author	: IKLEBANOV
 *^^*/
BOOL CATIHwConfiguration::GetTunerConfiguration( PUINT puiTunerId, PUCHAR puchTunerAddress)
{

	if(( puiTunerId != NULL) && ( puchTunerAddress != NULL))
	{
		* puiTunerId = ( UINT)m_usTunerId;
		* puchTunerAddress = m_uchTunerAddress;

		return( TRUE);
	}
	else
		return( FALSE);
}



/*^^*
 *		GetDecoderConfiguration()
 * Purpose	: Gets decoder Id and i2C address
 *
 * Inputs	:	puiDecoderId		: pointer to return Decoder Id
 *
 * Outputs	: BOOL : returns TRUE
 *				also sets the requested values into the input pointer
 * Author	: IKLEBANOV
 *^^*/
BOOL CATIHwConfiguration::GetDecoderConfiguration( PUINT puiDecoderId, PUCHAR puchDecoderAddress)
{

	if(( puiDecoderId != NULL) && ( puchDecoderAddress != NULL))
	{
		* puiDecoderId = ( UINT)m_usDecoderId;
		* puchDecoderAddress = m_uchDecoderAddress;

		return( TRUE);
	}
	else
		return( FALSE);
}



/*^^*
 *		GetAudioConfiguration()
 * Purpose	: Gets Audio solution Id and i2C address
 *
 * Inputs	: PUINT puiAudioConfiguration	: pointer to return Audio configuration Id
 *			  PUCHAR puchAudioAddress		: pointer to return audio hardware
 *												I2C address
 *
 * Outputs	: BOOL : returns TRUE
 *				also sets the requested values into the input pointer
 * Author	: IKLEBANOV
 *^^*/
BOOL CATIHwConfiguration::GetAudioConfiguration( PUINT puiAudioConfiguration, PUCHAR puchAudioAddress)
{

	if(( puiAudioConfiguration != NULL) && ( puchAudioAddress != NULL))
	{
		* puiAudioConfiguration = ( UINT)m_uiAudioConfiguration;
		* puchAudioAddress = m_uchAudioAddress;

		return( TRUE);
	}
	else
		return( FALSE);
}



/*^^*
 *		InitializeAudioConfiguration()
 * Purpose	: Initializes Audio Chip with default / power up values. This function will
 *				be called at Low priority with i2CProvider locked
 *
 * Inputs	:	CI2CScript * pCScript		: pointer to the I2CScript object
 *				UINT uiAudioConfigurationId	: detected Audio configuration
 *				UCHAR uchAudioChipAddress	: detected Audio chip I2C address
 * Outputs	: none
 * Author	: IKLEBANOV
 *^^*/
BOOL CATIHwConfiguration::InitializeAudioConfiguration( CI2CScript * pCScript, UINT uiAudioConfigurationId, UCHAR uchAudioChipAddress)
{
	I2CPacket i2cPacket;
	UCHAR uchWrite16Value[5];
#ifdef  I2S_CAPTURE
	UCHAR uchRead16Value[5];
#endif // I2S_CAPTURE
	BOOL		bResult;


	switch( uiAudioConfigurationId)
	{
		case ATI_AUDIO_CONFIG_2:
		case ATI_AUDIO_CONFIG_7:
			// TDA9850 has to be initialized with the values from I2C EEPROM, if
			// those answers the CheckSum. If not, take hardcoded default values
			{
				UINT	nIndex, nNumberOfRegs;
				PUCHAR	puchInitializationBuffer = NULL;
				UCHAR	uchWriteBuffer[2];
				BOOL	bResult = FALSE;

				nNumberOfRegs = AUDIO_TDA9850_Reg_Align3 - AUDIO_TDA9850_Reg_Control1 + 1;

				puchInitializationBuffer = ( PUCHAR) \
					::ExAllocatePool( NonPagedPool, nNumberOfRegs * sizeof( PUCHAR));

				if( puchInitializationBuffer == NULL)
					return( bResult);

				// fill in the Initialization buffer with the defaults values
				puchInitializationBuffer[0] = AUDIO_TDA9850_Control1_DefaultValue;
				puchInitializationBuffer[1] = AUDIO_TDA9850_Control2_DefaultValue;
				puchInitializationBuffer[2] = AUDIO_TDA9850_Control3_DefaultValue;
				puchInitializationBuffer[3] = AUDIO_TDA9850_Control4_DefaultValue;
				puchInitializationBuffer[4] = AUDIO_TDA9850_Align1_DefaultValue;
				puchInitializationBuffer[5] = AUDIO_TDA9850_Align2_DefaultValue;
				puchInitializationBuffer[6] = AUDIO_TDA9850_Align3_DefaultValue;

				// we have to see if anything in I2C EEPROM is waiting for us to
				// overwrite the default values
				if( ValidateConfigurationE2PROM( pCScript))
				{
					// The configuration E2PROM kept its integrity. Let's read the
					// initialization values from the device
					ReadConfigurationE2PROM( pCScript, 3, &puchInitializationBuffer[4]);
					ReadConfigurationE2PROM( pCScript, 4, &puchInitializationBuffer[5]);
				}

				// write the power-up defaults values into the chip
				i2cPacket.uchChipAddress = uchAudioChipAddress;
				i2cPacket.cbReadCount = 0;
				i2cPacket.cbWriteCount = 2;
				i2cPacket.puchReadBuffer = NULL;
				i2cPacket.puchWriteBuffer = uchWriteBuffer;
				i2cPacket.usFlags = I2COPERATION_WRITE;

				for( nIndex = 0; nIndex < nNumberOfRegs; nIndex ++)
				{
					uchWriteBuffer[0] = AUDIO_TDA9850_Reg_Control1 + nIndex;
					uchWriteBuffer[1] = puchInitializationBuffer[nIndex];
					if( !( bResult = pCScript->ExecuteI2CPacket( &i2cPacket)))
						break;
				}

				if( puchInitializationBuffer != NULL)
					::ExFreePool( puchInitializationBuffer);

				return( bResult);
			}
			break;

		case ATI_AUDIO_CONFIG_4:
				// TDA8425 volume control should be initialized
				return( SetDefaultVolumeControl( pCScript));
			break;

		case ATI_AUDIO_CONFIG_6:
			{
				UCHAR	uchWriteBuffer;

				// write the power-up defaults values into the chip
				i2cPacket.uchChipAddress = uchAudioChipAddress;
				i2cPacket.cbReadCount = 0;
				i2cPacket.cbWriteCount = 1;
				i2cPacket.puchReadBuffer = NULL;
				i2cPacket.puchWriteBuffer = &uchWriteBuffer;
				i2cPacket.usFlags = I2COPERATION_WRITE;
				uchWriteBuffer = AUDIO_TDA9851_DefaultValue;

				return(	pCScript->ExecuteI2CPacket( &i2cPacket));
			}
			break;

		case ATI_AUDIO_CONFIG_8:
			//Reset MSP3430
			
					i2cPacket.uchChipAddress = m_uchAudioAddress;
					i2cPacket.cbReadCount = 0;
					i2cPacket.usFlags = I2COPERATION_WRITE;
					i2cPacket.puchWriteBuffer = uchWrite16Value;


					//Write 0x80 - 00 to Subaddr 0x00
					i2cPacket.cbWriteCount = 3;
					uchWrite16Value[0] = 0x00;
					uchWrite16Value[1] = 0x80;
					uchWrite16Value[2] = 0x00;

					bResult = pCScript->PerformI2CPacketOperation( &i2cPacket);
					if(bResult)
					{
						if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
							return(FALSE);
					}
					else
						return(FALSE);

					//Write 0x00 - 00 to Subaddr 0x00
					i2cPacket.cbWriteCount = 3;
					uchWrite16Value[0] = 0x00;
					uchWrite16Value[1] = 0x00;
					uchWrite16Value[2] = 0x00;

					bResult = pCScript->PerformI2CPacketOperation( &i2cPacket);
					if(bResult)
					{
						if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
							return(FALSE);
					}
					else
						return(FALSE);

					//SubAddr 0x12 Reg 0x13 Val 0x3f60
					i2cPacket.cbWriteCount = 5;
					uchWrite16Value[0] = 0x12;
					uchWrite16Value[1] = 0x00;
					uchWrite16Value[2] = 0x13;
					uchWrite16Value[3] = 0x3f;
					uchWrite16Value[4] = 0x60;

					bResult = pCScript->PerformI2CPacketOperation( &i2cPacket);
					if(bResult)
					{
						if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
							return(FALSE);
					}
					else
						return(FALSE);

					//SubAddr 0x12 Reg 0x00 Val 0x0000
					i2cPacket.cbWriteCount = 5;
					uchWrite16Value[0] = 0x12;
					uchWrite16Value[1] = 0x00;
					uchWrite16Value[2] = 0x00;
					uchWrite16Value[3] = 0x00;
					uchWrite16Value[4] = 0x00;

					bResult = pCScript->PerformI2CPacketOperation( &i2cPacket);
					if(bResult)
					{
						if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
							return(FALSE);
					}
					else
						return(FALSE);
#ifdef  I2S_CAPTURE
#pragma message ("\n!!! PAY ATTENTION: Driver has been build with ITT CHIP I2S CAPTURE CONFIGURED !!!\n")


					i2cPacket.uchChipAddress = m_uchAudioAddress;
					i2cPacket.usFlags = I2COPERATION_WRITE;
					i2cPacket.puchWriteBuffer = uchWrite16Value;
					i2cPacket.puchReadBuffer = uchRead16Value;

					//Setup I2S Source Select and Output Channel Matrix

					//SubAddr 0x12 Reg 0x0b Val 0x0320
					i2cPacket.cbWriteCount = 5;
					i2cPacket.cbReadCount = 0;
					uchWrite16Value[0] = 0x12;
					uchWrite16Value[1] = 0x00;
					uchWrite16Value[2] = 0x0b;
					uchWrite16Value[3] = 0x03;
					uchWrite16Value[4] = 0x20;

					bResult = pCScript->PerformI2CPacketOperation( &i2cPacket);
					if(bResult)
					{
						if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
							return(FALSE);
					}
					else
						return(FALSE);



					//Setup MODUS 

					i2cPacket.cbWriteCount = 5;
					i2cPacket.cbReadCount = 0;
					uchWrite16Value[0] = 0x10;
					uchWrite16Value[1] = 0x00;
					uchWrite16Value[2] = 0x30;
					uchWrite16Value[3] = 0x20;
					uchWrite16Value[4] = 0xe3;

					bResult = pCScript->PerformI2CPacketOperation( &i2cPacket);
					if(bResult)
					{
						if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
							return(FALSE);
					}
					else
						return(FALSE);

#endif // I2S_CAPTURE

			break;

		default:
			break;
	}

	return( TRUE);
}



/*^^*
 *		GetTVAudioSignalProperties()
 * Purpose	: Gets Audio signal properties readable from ATI dependand hardware,
 *				like I2C expander. This call is always synchronous.
 *
 * Inputs	:	CI2CScript * pCScript	: pointer to the I2CScript object
 *				PBOOL pbStereo			: pointer to the Stereo Indicator
 *				PBOOL pbSAP				: pointer to the SAP Indicator
 *
 * Outputs	: BOOL, returns TRUE, if successful
 * Author	: IKLEBANOV
 *^^*/
BOOL CATIHwConfiguration::GetTVAudioSignalProperties( CI2CScript * pCScript, PBOOL pbStereo, PBOOL pbSAP)
{
	I2CPacket	i2cPacket;
	UCHAR		uchReadValue, uchWriteValue;
	BOOL		bResult;

	switch( m_uiAudioConfiguration)
	{
		case ATI_AUDIO_CONFIG_1:
		case ATI_AUDIO_CONFIG_5:
			// Stereo property is read back from I2C expander
			i2cPacket.uchChipAddress = m_uchI2CExpanderAddress;
			i2cPacket.cbReadCount = 1;
			i2cPacket.cbWriteCount = 1;
			i2cPacket.puchReadBuffer = &uchReadValue;
			i2cPacket.puchWriteBuffer = &uchWriteValue;
			i2cPacket.usFlags = I2COPERATION_READWRITE;
			i2cPacket.uchORValue = 0x40;
			i2cPacket.uchANDValue = 0xFF;

			bResult = FALSE;

			ENSURE
			{
				if( !pCScript->LockI2CProviderEx())
					FAIL;

				pCScript->ExecuteI2CPacket( &i2cPacket);
				if( !( bResult = ( i2cPacket.uchI2CResult == I2C_STATUS_NOERROR)))
					FAIL;

				i2cPacket.puchWriteBuffer = NULL;
				i2cPacket.usFlags = I2COPERATION_READ;

				pCScript->ExecuteI2CPacket( &i2cPacket);
				if( !( bResult = ( i2cPacket.uchI2CResult == I2C_STATUS_NOERROR)))
					FAIL;

				* pbStereo = uchReadValue & 0x40;

				bResult = TRUE;

			} END_ENSURE;

			pCScript->ReleaseI2CProvider();

			break;

		default:
			bResult = FALSE;
			break;
	}

	if( bResult)
		// no case, where SAP property is read back from ATI's hardware
		* pbSAP = FALSE;

	return( bResult);
}



/*^^*
 *		GetDecoderOutputEnableLevel()
 * Purpose	: Retrieves ATI dependent hardware configuration property of the logical level
 *				should be applied on OUTEN field of Bt829x decoder in order to enable
 *				output stream
 *
 * Inputs	: none
 *
 * Outputs	: UINT,
 *				UINT( -1) value is returned if an error occures
 * Author	: IKLEBANOV
 *^^*/
UINT CATIHwConfiguration::GetDecoderOutputEnableLevel( void)
{
	UINT uiEnableLevel;

	switch( m_usDecoderConfiguration)
	{
		case ATI_VIDEODECODER_CONFIG_1:
		case ATI_VIDEODECODER_CONFIG_3:
		case ATI_VIDEODECODER_CONFIG_4:
			uiEnableLevel = 0;
			break;

		case ATI_VIDEODECODER_CONFIG_2:
			uiEnableLevel = 1;
			break;

		default:
			uiEnableLevel = UINT( -1);
			break;
	}

	return( uiEnableLevel);
}



/*^^*
 *		EnableDecoderI2CAccess()
 * Purpose	: Enables/disables I2C access to the decoder chip
 *
 * Inputs	: CI2CScript * pCScript	: pointer to the I2CScript object
 *			  BOOL bEnable			: defines what to do - enable/disable the decoder's outputs
 *
 * Outputs	: none
 * Author	: IKLEBANOV
 *^^*/
void CATIHwConfiguration::EnableDecoderI2CAccess( CI2CScript * pCScript, BOOL bEnable)
{
	UCHAR		uchORMask	= 0;
	UCHAR		uchANDMask	= 0xFF;
	UCHAR		uchReadValue, uchWriteValue;
	I2CPacket	i2cPacket;

	switch( m_usDecoderConfiguration)
	{
		case ATI_VIDEODECODER_CONFIG_1:		// Add-On TV Tuner board - ATI TV requires certain actions to be taken
			i2cPacket.uchChipAddress = m_uchI2CExpanderAddress;
			i2cPacket.cbReadCount = 1;
			i2cPacket.cbWriteCount = 1;
			if( bEnable)
				uchANDMask &= 0x7F;
			else
				uchORMask |= 0x80;

			i2cPacket.puchReadBuffer = &uchReadValue;
			i2cPacket.puchWriteBuffer = &uchWriteValue;
			i2cPacket.usFlags = I2COPERATION_READWRITE;
			i2cPacket.uchORValue = uchORMask;
			i2cPacket.uchANDValue = uchANDMask;

			pCScript->PerformI2CPacketOperation( &i2cPacket);

			break;

#ifdef _X86_
		case ATI_VIDEODECODER_CONFIG_3:
			_outp( 0x7D, ( _inp( 0x7D) | 0x80));
			if( bEnable)
				_outp( 0x7C, ( _inp( 0x7C) & 0x7F));
			else
				_outp( 0x7C, ( _inp( 0x7C) | 0x80));
			return;

		case ATI_VIDEODECODER_CONFIG_4:
			if( bEnable)
				_outp( 0x78, ( _inp( 0x78) & 0xF7));
			else
				_outp( 0x78, ( _inp( 0x78) | 0x08));
			return;
#endif

		default:
			break;
	}
}


#if 0

/*^^*
 *		EnableDecoderOutput()
 * Purpose	: Enables/disables decoder chip
 *				AM bus might have multiple users, it's important to have this feature.
 *
 * Inputs	: CI2CScript * pCScript	: pointer to the I2CScript object
 *			  BOOL bEnable			: defines what to do - enable/disable the decoder's outputs
 *
 * Outputs	: none
 * Author	: IKLEBANOV
 *^^*/
void CATIHwConfiguration::EnableDecoderOutput( CI2CScript * pCScript, BOOL bEnable)
{
	UCHAR		uchORMask	= 0;
	UCHAR		uchANDMask	= 0xFF;
	UCHAR		uchReadValue, uchWriteValue[2];
	I2CPacket	i2cPacket;
	BOOL		bI2CAccess;

	switch( m_usDecoderConfiguration)
	{
		case ATI_VIDEODECODER_CONFIG_1:
			bI2CAccess = TRUE;
			uchWriteValue[0] = 0x16;
			i2cPacket.uchChipAddress = m_uchDecoderAddress;
			i2cPacket.cbReadCount = 1;
			i2cPacket.cbWriteCount = 2;
			if( bEnable)
				uchANDMask &= 0x7F;
			else
				uchORMask |= 0x80;

			break;

		case ATI_VIDEODECODER_CONFIG_2:
			bI2CAccess = TRUE;
			uchWriteValue[0] = 0x16;
			i2cPacket.uchChipAddress = m_uchDecoderAddress;
			i2cPacket.cbReadCount = 1;
			i2cPacket.cbWriteCount = 2;
			if( bEnable)
				uchORMask |= 0x80;
			else
				uchANDMask &= 0x7F;

			break;

#ifdef _X86_
		case ATI_VIDEODECODER_CONFIG_3:
			_outp( 0x7D, ( _inp( 0x7D) | 0x80));
			if( bEnable)
				_outp( 0x7C, ( _inp( 0x7C) & 0x7F));
			else
				_outp( 0x7C, ( _inp( 0x7C) | 0x80));
			return;

		case ATI_VIDEODECODER_CONFIG_4:
			if( bEnable)
				_outp( 0x78, ( _inp( 0x78) & 0xF7));
			else
				_outp( 0x78, ( _inp( 0x78) | 0x08));
			return;
#endif

		default:
			return;
	}

	if( bI2CAccess)
	{
		i2cPacket.puchReadBuffer = &uchReadValue;
		i2cPacket.puchWriteBuffer = uchWriteValue;
		i2cPacket.usFlags = I2COPERATION_READWRITE;
		i2cPacket.uchORValue = uchORMask;
		i2cPacket.uchANDValue = uchANDMask;

		pCScript->PerformI2CPacketOperation( &i2cPacket);
	}
}

#endif	// not compiled




/*^^*
 *		GetI2CExpanderConfiguration()
 * Purpose	: Gets board configuration via I2C expander
 *				Reads the configuration registers back
 * Inputs	:	CI2CScript * pCScript	: pointer to CI2CScript object
 *				PUCHAR puchI2CValue		: pointer to read the I2C value into	
 *
 * Outputs	: BOOL : returns TRUE
 *				also sets the requested values into the input pointers
 * Author	: IKLEBANOV
 *^^*/
BOOL CATIHwConfiguration::GetI2CExpanderConfiguration( CI2CScript * pCScript, PUCHAR puchI2CValue)
{
	I2CPacket	i2cPacket;

	if( puchI2CValue == NULL)
		return( FALSE);

	i2cPacket.uchChipAddress = m_uchI2CExpanderAddress;
	i2cPacket.cbReadCount = 1;
	i2cPacket.cbWriteCount = 0;
	i2cPacket.puchReadBuffer = puchI2CValue;
	i2cPacket.puchWriteBuffer = NULL;
	i2cPacket.usFlags = 0;

	pCScript->ExecuteI2CPacket( &i2cPacket);

	return(( i2cPacket.uchI2CResult == I2C_STATUS_NOERROR) ? TRUE : FALSE);
}



/*^^*
 *		FindI2CExpanderAddress()
 * Purpose	: Determines I2C expander address.
 *
 * Inputs	:	CI2CScript * pCScript	: pointer to the I2CScript class object
 *
 * Outputs	: BOOL : returns TRUE, if no I2C access error;
 *				also sets m_uchI2CExpanderAddress class member. If any was not found, set it as 0xFF
 * Author	: IKLEBANOV
 *^^*/
BOOL CATIHwConfiguration::FindI2CExpanderAddress( CI2CScript * pCScript)
{
	USHORT		nIndex;
	UCHAR		uchI2CValue;
	I2CPacket	i2cPacket;
	// table of the possible I2C expender addresses
	UCHAR		auchI2CExpenderAddress[] = { 0x70, 0x78, 0x7c, 0x76};

	// unknown I2C expender address
	m_uchI2CExpanderAddress = 0xFF;
	for( nIndex = 0; nIndex < sizeof( auchI2CExpenderAddress); nIndex ++)
	{
		i2cPacket.uchChipAddress = auchI2CExpenderAddress[nIndex];
		i2cPacket.cbReadCount = 1;
		i2cPacket.cbWriteCount = 0;
		i2cPacket.puchReadBuffer = &uchI2CValue;
		i2cPacket.puchWriteBuffer = NULL;
		i2cPacket.usFlags = 0;

		pCScript->ExecuteI2CPacket( &i2cPacket);
		if( i2cPacket.uchI2CResult == I2C_STATUS_NOERROR)
		{
			m_uchI2CExpanderAddress = auchI2CExpenderAddress[nIndex];
			break;
		}
	}

    OutputDebugInfo(( "CATIHwConfig:FindI2CExpanderAddress() exit address = %x\n", m_uchI2CExpanderAddress));

	return( TRUE);
}



/*^^*
 *		GetAudioProperties()
 * Purpose	: Gets numbers of Audio inputs and outputs
 * Inputs	:	PULONG pulNumberOfInputs	: pointer to return number of Audio inputs
 *				PULONG pulNumberOfOutputs	: pointer to return number of Audio outputs
 *
 * Outputs	: BOOL : returns TRUE
 *				also sets the requested values into the input pointers
 * Author	: IKLEBANOV
 *^^*/
BOOL CATIHwConfiguration::GetAudioProperties( PULONG pulNumberOfInputs, PULONG pulNumberOfOutputs)
{

	if(( pulNumberOfInputs != NULL) && ( pulNumberOfOutputs != NULL))
	{
		// Hardcoded for AIW with no FM support - FM stuff has not been defined by Microsoft yet 
		* pulNumberOfInputs = 2;
		* pulNumberOfOutputs = 1;

		return( TRUE);
	}
	else
		return( FALSE);
}



/*^^*
 *		CanConnectAudioSource()
 * Purpose	: Determines possibility to connect the specified Audio source to the audio output.
 *
 * Inputs	: int nAudioSource	: the audio source the function is asked about
 *
 * Outputs	: BOOL : returns TRUE, the connection is possible;
 * Author	: IKLEBANOV
 *^^*/
BOOL CATIHwConfiguration::CanConnectAudioSource( int nAudioSource)
{
	BOOL bResult;

	if( nAudioSource != AUDIOSOURCE_MUTE)
		bResult = nAudioSource < AUDIOSOURCE_LASTSUPPORTED;
	else
		switch( m_uiAudioConfiguration)
		{
			case ATI_AUDIO_CONFIG_1:
			case ATI_AUDIO_CONFIG_2:
			case ATI_AUDIO_CONFIG_4:
			case ATI_AUDIO_CONFIG_5:
			case ATI_AUDIO_CONFIG_6:
			case ATI_AUDIO_CONFIG_7:
			case ATI_AUDIO_CONFIG_8:
				bResult = TRUE;
				break;

			case ATI_AUDIO_CONFIG_3:
			default:
				bResult = FALSE;
				break;
		}

	return( bResult);
}


/*^^*
 *		SetDefaultVolumeControl()
 * Purpose	: Set the default volume level, if the hardware support volume control
 *
 * Inputs	:	CI2CScript * pCScript	: pointer to I2CScript class object
 *
 * Outputs	: BOOL : returns FALSE, if either unknown audio source or I2C access error;
 * Author	: IKLEBANOV
 *^^*/
BOOL CATIHwConfiguration::SetDefaultVolumeControl( CI2CScript * pCScript)
{
	BOOL		bResult;
	I2CPacket	i2cPacket;
	UCHAR		uchWriteBuffer[3];

	switch( m_uiAudioConfiguration)
	{
		case ATI_AUDIO_CONFIG_4:

			ENSURE
			{
				i2cPacket.uchChipAddress = m_uchAudioAddress;
				i2cPacket.cbReadCount = 0;
				i2cPacket.cbWriteCount = 3;
				i2cPacket.puchReadBuffer = NULL;
				i2cPacket.puchWriteBuffer = uchWriteBuffer;
				i2cPacket.usFlags = I2COPERATION_WRITE;

				uchWriteBuffer[0] = 0x00;		// volume left + right
				uchWriteBuffer[1] = 0xFA;
				uchWriteBuffer[2] = 0xFA;

				bResult = pCScript->PerformI2CPacketOperation( &i2cPacket);

			} END_ENSURE;

			break;

		default:
			bResult = TRUE;
			break;
	}

	return( bResult);
}



/*^^*
 *		ConnectAudioSource()
 * Purpose	: Connects the specified Audio input to the Audio output.
 *
 * Inputs	:	CI2CScript * pCScript	: pointer to I2CScript class object
 *				int nAudioSource		: the audio source to be connected to the audio output
 *
 * Outputs	: BOOL : returns FALSE, if either unknown audio source or I2C access error;
 * Author	: IKLEBANOV
 *^^*/
BOOL CATIHwConfiguration::ConnectAudioSource( CI2CScript *	pCScript, 
											  int			nAudioSource)
{
	UCHAR		uchORMask = 0;
	UCHAR		uchANDMask = 0xFF;
	UCHAR		uchReadValue, uchWriteValue[2];
	UCHAR		uchWrite16Value[5]; 
	I2CPacket	i2cPacket;
	BOOL		bI2CAccess, bResult;
	GPIOControl	gpioAccessBlock;
	UCHAR		uchI2CAddr;
	USHORT		cbWRCount;
	USHORT		cbRDCount;
	USHORT		usI2CMode;

	switch( m_uiAudioConfiguration)
	{
		case ATI_AUDIO_CONFIG_1:
			bI2CAccess = TRUE;
			uchI2CAddr = m_uchI2CExpanderAddress;
			cbWRCount = 1;
			cbRDCount = 1;
			usI2CMode = I2COPERATION_READWRITE;

			uchANDMask &= 0xAF;
			switch( nAudioSource)
			{
				case AUDIOSOURCE_MUTE:
					uchORMask |= 0x00;
					break;
			
				case AUDIOSOURCE_TVAUDIO:
					uchORMask |= 0x10;
					break;
			
				case AUDIOSOURCE_LINEIN:
					uchORMask |= 0x50;
					break;
			
				case AUDIOSOURCE_FMAUDIO:
					// no FM is supported

				default:
					return( FALSE);
			}
			break;

		case ATI_AUDIO_CONFIG_2:
			bI2CAccess = FALSE;
			uchANDMask &= 0xFC;
			switch( nAudioSource)
			{
				case AUDIOSOURCE_MUTE:
					uchORMask |= 0x02;
					break;
			
				case AUDIOSOURCE_TVAUDIO:
					uchORMask |= 0x01;
					break;
			
				case AUDIOSOURCE_LINEIN:
					uchORMask |= 0x00;
					break;
			
				case AUDIOSOURCE_FMAUDIO:
					uchORMask |= 0x03;

				default:
					return( FALSE);
			}
			break;


		case ATI_AUDIO_CONFIG_3:
			bI2CAccess = TRUE;
			uchI2CAddr = m_uchI2CExpanderAddress;
			cbWRCount = 1;
			cbRDCount = 1;
			usI2CMode = I2COPERATION_READWRITE;

			uchANDMask &= 0xDF;
			switch( nAudioSource)
			{
				case AUDIOSOURCE_TVAUDIO:
					uchORMask |= 0x00;
					break;
			
				case AUDIOSOURCE_LINEIN:
					uchORMask |= 0x40;
					break;
			
				case AUDIOSOURCE_FMAUDIO:
					// no FM is supported
				case AUDIOSOURCE_MUTE:
					// no mute is supported
				default:
					return( FALSE);
			}
			break;

		case ATI_AUDIO_CONFIG_4:
			bI2CAccess = TRUE;
			uchI2CAddr = m_uchAudioAddress;
			cbWRCount = 2;
			cbRDCount = 0;
			usI2CMode = I2COPERATION_WRITE;

			uchWriteValue[0] = 0x08;
			switch( nAudioSource)
			{
				case AUDIOSOURCE_MUTE:
					uchWriteValue[1] = 0xF7;
					break;

				case AUDIOSOURCE_TVAUDIO:
					SetDefaultVolumeControl( pCScript);
					uchWriteValue[1] = 0xD7;
					break;
			
				case AUDIOSOURCE_LINEIN:
					SetDefaultVolumeControl( pCScript);
					uchWriteValue[1] = 0xCE;
					break;
			
				case AUDIOSOURCE_FMAUDIO:
					// no FM is supported
				default:
					return( FALSE);
			}
			break;

		case ATI_AUDIO_CONFIG_5:
			bI2CAccess = TRUE;
			uchI2CAddr = m_uchI2CExpanderAddress;
			cbWRCount = 1;
			cbRDCount = 1;
			usI2CMode = I2COPERATION_READWRITE;

			uchANDMask &= 0xAF;
			switch( nAudioSource)
			{
				case AUDIOSOURCE_MUTE:
					uchORMask |= 0x50;
					break;
			
				case AUDIOSOURCE_TVAUDIO:
					uchORMask |= 0x00;
					break;
			
				case AUDIOSOURCE_LINEIN:
					uchORMask |= 0x40;
					break;
			
				case AUDIOSOURCE_FMAUDIO:
					uchORMask |= 0x10;

				default:
					return( FALSE);
			}
			break;

		case ATI_AUDIO_CONFIG_6:
		case ATI_AUDIO_CONFIG_7:
			bI2CAccess = TRUE;
			uchI2CAddr = m_uchDecoderAddress;
			cbWRCount = 2;
			cbRDCount = 1;
			usI2CMode = I2COPERATION_READWRITE;
			uchWriteValue[0] = 0x3F;

			uchANDMask &= 0xFC;
			switch( nAudioSource)
			{
				case AUDIOSOURCE_MUTE:
					uchORMask |= 0x02;
					break;
			
				case AUDIOSOURCE_TVAUDIO:
					uchORMask |= 0x01;
					break;
			
				case AUDIOSOURCE_LINEIN:
					uchORMask |= 0x00;
					break;
			
				case AUDIOSOURCE_FMAUDIO:
					uchORMask |= 0x03;

				default:
					return( FALSE);
			}
			break;

		case ATI_AUDIO_CONFIG_8:

			switch( nAudioSource)
			{

				case AUDIOSOURCE_MUTE:

					i2cPacket.uchChipAddress = m_uchAudioAddress;
					i2cPacket.cbReadCount = 0;
					i2cPacket.cbWriteCount = 5;
					i2cPacket.usFlags = I2COPERATION_WRITE;
					i2cPacket.puchWriteBuffer = uchWrite16Value;


					//SubAddr 0x12 Reg 0x13 Val 0x3f60
					uchWrite16Value[0] = 0x12;
					uchWrite16Value[1] = 0x00;
					uchWrite16Value[2] = 0x13;
					uchWrite16Value[3] = 0x3f;
					uchWrite16Value[4] = 0x60;

					bResult = pCScript->PerformI2CPacketOperation( &i2cPacket);
					if(bResult)
					{
						if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
							return(FALSE);
					}
					else
						return(FALSE);

					//SubAddr 0x12 Reg 0xD Val 0x0000

					uchWrite16Value[0] = 0x12;
					uchWrite16Value[1] = 0x00;
					uchWrite16Value[2] = 0x0d;
					uchWrite16Value[3] = 0x00;
					uchWrite16Value[4] = 0x00;

					bResult = pCScript->PerformI2CPacketOperation( &i2cPacket);
					if(bResult)
					{
						if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
							return(FALSE);
					}
					else
						return(FALSE);

					//SubAddr 0x12 Reg 0x8 Val 0x0220

					uchWrite16Value[0] = 0x12;
					uchWrite16Value[1] = 0x00;
					uchWrite16Value[2] = 0x08;
					uchWrite16Value[3] = 0x02;
					uchWrite16Value[4] = 0x20;

					bResult = pCScript->PerformI2CPacketOperation( &i2cPacket);
					if(bResult)
					{
						if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
							return(FALSE);
					}
					else
						return(FALSE);

					//SubAddr 0x12 Reg 0x00 Val 0x0000

					uchWrite16Value[0] = 0x12;
					uchWrite16Value[1] = 0x00;
					uchWrite16Value[2] = 0x00;
					uchWrite16Value[3] = 0x00;
					uchWrite16Value[4] = 0x00;

					bResult = pCScript->PerformI2CPacketOperation( &i2cPacket);
					if(bResult)
					{
						if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
							return(FALSE);
					}
					else
						return(FALSE);


					break;


				case AUDIOSOURCE_LINEIN:

					i2cPacket.uchChipAddress = m_uchAudioAddress;
					i2cPacket.cbReadCount = 0;
					i2cPacket.cbWriteCount = 5;
					i2cPacket.usFlags = I2COPERATION_WRITE;
					i2cPacket.puchWriteBuffer = uchWrite16Value;


					//SubAddr 0x10 Reg 0x30 Val 0x0000
					uchWrite16Value[0] = 0x10;
					uchWrite16Value[1] = 0x00;
					uchWrite16Value[2] = 0x30;
					uchWrite16Value[3] = 0x00;
#ifdef	I2S_CAPTURE
#pragma message ("\n!!! PAY ATTENTION: Driver has been build with ITT CHIP I2S CAPTURE CONFIGURED !!!\n")
					uchWrite16Value[4] = 0xe0;
#else
					uchWrite16Value[4] = 0x00;
#endif

					bResult = pCScript->PerformI2CPacketOperation( &i2cPacket);
					if(bResult)
					{
						if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
							return(FALSE);
					}
					else
						return(FALSE);


					//SubAddr 0x10 Reg 0x20 Val 0x0000
					uchWrite16Value[0] = 0x10;
					uchWrite16Value[1] = 0x00;
					uchWrite16Value[2] = 0x20;
					uchWrite16Value[3] = 0x00;
					uchWrite16Value[4] = 0x00;

					bResult = pCScript->PerformI2CPacketOperation( &i2cPacket);
					if(bResult)
					{
						if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
							return(FALSE);
					}
					else
						return(FALSE);


					//SubAddr 0x12 Reg 0xe Val 0x0000
					uchWrite16Value[0] = 0x12;
					uchWrite16Value[1] = 0x00;
					uchWrite16Value[2] = 0x0e;
					uchWrite16Value[3] = 0x00;
					uchWrite16Value[4] = 0x00;

					bResult = pCScript->PerformI2CPacketOperation( &i2cPacket);
					if(bResult)
					{
						if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
							return(FALSE);
					}
					else
						return(FALSE);


					//SubAddr 0x12 Reg 0x13 Val 0x3c40
					uchWrite16Value[0] = 0x12;
					uchWrite16Value[1] = 0x00;
					uchWrite16Value[2] = 0x13;
					uchWrite16Value[3] = 0x3c;
					uchWrite16Value[4] = 0x40;

					bResult = pCScript->PerformI2CPacketOperation( &i2cPacket);
					if(bResult)
					{
						if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
							return(FALSE);
					}
					else
						return(FALSE);


					//SubAddr 0x12 Reg 0x8 Val 0x3c40
					uchWrite16Value[0] = 0x12;
					uchWrite16Value[1] = 0x00;
					uchWrite16Value[2] = 0x08;
					uchWrite16Value[3] = 0x02;
					uchWrite16Value[4] = 0x20;

					bResult = pCScript->PerformI2CPacketOperation( &i2cPacket);
					if(bResult)
					{
						if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
							return(FALSE);
					}
					else
						return(FALSE);

					//SubAddr 0x12 Reg 0xd Val 0x1900
					uchWrite16Value[0] = 0x12;
					uchWrite16Value[1] = 0x00;
					uchWrite16Value[2] = 0x0d;
					uchWrite16Value[3] = 0x19;
					uchWrite16Value[4] = 0x00;

					bResult = pCScript->PerformI2CPacketOperation( &i2cPacket);
					if(bResult)
					{
						if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
							return(FALSE);
					}
					else
						return(FALSE);

					//SubAddr 0x12 Reg 0x00 Val 0x7300
					uchWrite16Value[0] = 0x12;
					uchWrite16Value[1] = 0x00;
					uchWrite16Value[2] = 0x00;
					uchWrite16Value[3] = 0x73;
					uchWrite16Value[4] = 0x00;

					bResult = pCScript->PerformI2CPacketOperation( &i2cPacket);
					if(bResult)
					{
						if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
							return(FALSE);
					}
					else
						return(FALSE);


					break;

				case AUDIOSOURCE_TVAUDIO:
					i2cPacket.uchChipAddress = m_uchAudioAddress;
					i2cPacket.cbReadCount = 0;
					i2cPacket.cbWriteCount = 5;
					i2cPacket.usFlags = I2COPERATION_WRITE;
					i2cPacket.puchWriteBuffer = uchWrite16Value;

					//SubAddr 0x12 Reg 0x13 Val 0x3f60
					uchWrite16Value[0] = 0x12;
					uchWrite16Value[1] = 0x00;
					uchWrite16Value[2] = 0x13;
					uchWrite16Value[3] = 0x3f;
					uchWrite16Value[4] = 0x60;

					bResult = pCScript->PerformI2CPacketOperation( &i2cPacket);
					if(bResult)
					{
						if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
							return(FALSE);
					}
					else
						return(FALSE);


					//SubAddr 0x12 Reg 0xD Val 0x0000
					uchWrite16Value[0] = 0x12;
					uchWrite16Value[1] = 0x00;
					uchWrite16Value[2] = 0x0d;
					uchWrite16Value[3] = 0x00;
					uchWrite16Value[4] = 0x00;

					bResult = pCScript->PerformI2CPacketOperation( &i2cPacket);
					if(bResult)
					{
						if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
							return(FALSE);
					}
					else
						return(FALSE);


					//SubAddr 0x10 Reg 0x30 Val 0x2003
					uchWrite16Value[0] = 0x10;
					uchWrite16Value[1] = 0x00;
					uchWrite16Value[2] = 0x30;
					uchWrite16Value[3] = 0x20;
#ifdef	I2S_CAPTURE
#pragma message ("\n!!! PAY ATTENTION: Driver has been build with ITT CHIP I2S CAPTURE CONFIGURED !!!\n")
					uchWrite16Value[4] = 0xe3;
#else
					uchWrite16Value[4] = 0x03;
#endif

					bResult = pCScript->PerformI2CPacketOperation( &i2cPacket);
					if(bResult)
					{
						if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
							return(FALSE);
					}
					else
						return(FALSE);

					//SubAddr 0x10 Reg 0x20 Val 0x0020

					uchWrite16Value[0] = 0x10;
					uchWrite16Value[1] = 0x00;
					uchWrite16Value[2] = 0x20;
					uchWrite16Value[3] = 0x00;
					uchWrite16Value[4] = 0x20;

					bResult = pCScript->PerformI2CPacketOperation( &i2cPacket);
					if(bResult)
					{
						if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
							return(FALSE);
					}
					else
						return(FALSE);


					//SubAddr 0x12 Reg 0xE Val 0x2403
					uchWrite16Value[0] = 0x12;
					uchWrite16Value[1] = 0x00;
					uchWrite16Value[2] = 0x0e;
					uchWrite16Value[3] = 0x24;
					uchWrite16Value[4] = 0x03;

					bResult = pCScript->PerformI2CPacketOperation( &i2cPacket);
					if(bResult)
					{
						if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
							return(FALSE);
					}
					else
						return(FALSE);

					//SubAddr 0x12 Reg 0x08 Val 0x0320
					uchWrite16Value[0] = 0x12;
					uchWrite16Value[1] = 0x00;
					uchWrite16Value[2] = 0x08;
					uchWrite16Value[3] = 0x03;
					uchWrite16Value[4] = 0x20;

					bResult = pCScript->PerformI2CPacketOperation( &i2cPacket);
					if(bResult)
					{
						if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
							return(FALSE);
					}
					else
						return(FALSE);

					//SubAddr 0x12 Reg 0x00 Val 0x7300

					uchWrite16Value[0] = 0x12;
					uchWrite16Value[1] = 0x00;
					uchWrite16Value[2] = 0x00;
					uchWrite16Value[3] = 0x73;
					uchWrite16Value[4] = 0x00;

					bResult = pCScript->PerformI2CPacketOperation( &i2cPacket);
					if(bResult)
					{
						if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
							return(FALSE);
					}
					else
						return(FALSE);

					break;

				default:
					return(FALSE);
				
			}//switch
		
			return(TRUE);
			//break;

		default :
			return( FALSE);
	}

	if( bI2CAccess)
	{
		if( pCScript == NULL)
			return( FALSE);

		i2cPacket.uchChipAddress = uchI2CAddr;
		i2cPacket.cbReadCount = cbRDCount;
		i2cPacket.cbWriteCount = cbWRCount; 
		i2cPacket.puchReadBuffer = &uchReadValue;
		i2cPacket.puchWriteBuffer = uchWriteValue;
		i2cPacket.usFlags = usI2CMode;
		i2cPacket.uchORValue = uchORMask;
		i2cPacket.uchANDValue = uchANDMask;				   	

		// synchronous execution
		bResult = pCScript->PerformI2CPacketOperation( &i2cPacket);
		OutputDebugInfo(( "CATIHwConfig: ConnectAudioSource( %d) = %d\n", nAudioSource, bResult));

		if( bResult)
			bResult = ( i2cPacket.uchI2CResult == I2CSCRIPT_NOERROR);

		return( bResult);
	}
	else	
	{
		// use GPIO interface to switch Audio source
		bResult = FALSE;

		ENSURE 
		{
			if(( m_gpioProviderInterface.gpioOpen == NULL) ||
				( m_gpioProviderInterface.gpioAccess == NULL))
				FAIL;

			uchReadValue = AUDIO_MUX_PINS;			// use as a PinMask
			gpioAccessBlock.Pins = &uchReadValue;
			gpioAccessBlock.Flags = GPIO_FLAGS_BYTE;
			gpioAccessBlock.nBytes = 1;
			gpioAccessBlock.nBufferSize = 1;
			gpioAccessBlock.AsynchCompleteCallback = NULL;

			// lock GPIO provider
			if( !LockGPIOProviderEx( &gpioAccessBlock))
				FAIL;

			uchReadValue = AUDIO_MUX_PINS;			// use as a PinMask
			gpioAccessBlock.Command = GPIO_COMMAND_READ_BUFFER;
			gpioAccessBlock.Flags = GPIO_FLAGS_BYTE;
			gpioAccessBlock.dwCookie = m_dwGPIOAccessKey;
			gpioAccessBlock.nBytes = 1;
			gpioAccessBlock.nBufferSize = 1;
			gpioAccessBlock.Pins = &uchReadValue;
			gpioAccessBlock.Buffer = uchWriteValue;
			gpioAccessBlock.AsynchCompleteCallback = NULL;

			if( !AccessGPIOProvider( m_pdoDriver, &gpioAccessBlock))
				FAIL;

			uchWriteValue[0] &= uchANDMask;
			uchWriteValue[0] |= uchORMask;

			gpioAccessBlock.Command = GPIO_COMMAND_WRITE_BUFFER;

			if( !AccessGPIOProvider( m_pdoDriver, &gpioAccessBlock))
				FAIL;

			bResult = TRUE;

		}END_ENSURE;

		// nothing bad will happen if we try to release the provider even we
		// have not obtained it at the first place
		uchReadValue = AUDIO_MUX_PINS;			// use as a PinMask
		gpioAccessBlock.Pins = &uchReadValue;
		gpioAccessBlock.Flags = GPIO_FLAGS_BYTE;
		gpioAccessBlock.nBytes = 1;
		gpioAccessBlock.nBufferSize = 1;
		gpioAccessBlock.AsynchCompleteCallback = NULL;

		ReleaseGPIOProvider( &gpioAccessBlock);

		return( bResult);
	}
}



/*^^*
 *		GPIOIoSynchCompletionRoutine()
 * Purpose	: This routine is for use with synchronous IRP processing.
 *			All it does is signal an event, so the driver knows it and can continue.
 *
 * Inputs	:	PDEVICE_OBJECT DriverObject	: Pointer to driver object created by system
 *				PIRP pIrp					: Irp that just completed
 *				PVOID Event					: Event we'll signal to say Irp is done
 *
 * Outputs	: none
 * Author	: IKLEBANOV
 *^^*/
extern "C"
NTSTATUS GPIOIoSynchCompletionRoutine( IN PDEVICE_OBJECT pDeviceObject,
									   IN PIRP pIrp,
									   IN PVOID Event)
{

    KeSetEvent(( PKEVENT)Event, 0, FALSE);
    return( STATUS_MORE_PROCESSING_REQUIRED);
}



/*^^*
 *		InitializeAttachGPIOProvider()
 * Purpose	: determines the pointer to the parent GPIO Provider interface
 *				This function will be called at Low priority
 *
 * Inputs	:	GPIOINTERFACE * pGPIOInterface	: pointer to the Interface to be filled in
 *				PDEVICE_OBJECT pDeviceObject	: MiniDriver device object, which is a child of GPIO Master
 *
 * Outputs	: BOOL  - returns TRUE, if the interface was found
 * Author	: IKLEBANOV
 *^^*/
BOOL CATIHwConfiguration::InitializeAttachGPIOProvider( GPIOINTERFACE * pGPIOInterface, PDEVICE_OBJECT pDeviceObject)
{
	BOOL bResult;

	bResult = LocateAttachGPIOProvider( pGPIOInterface, pDeviceObject, IRP_MJ_PNP);
	if(( pGPIOInterface->gpioOpen == NULL) || ( pGPIOInterface->gpioAccess == NULL))
	{
		OutputDebugError(( "CATIHwConfig(): GPIO interface has NULL pointers\n"));
		bResult = FALSE;
	}

	return( bResult);
}



/*^^*
 *		LocateAttachGPIOProvider()
 * Purpose	: gets the pointer to the parent GPIO Provider interface
 *				This function will be called at Low priority
 *
 * Inputs	:	GPIOINTERFACE * pGPIOInterface	: pointer to the Interface to be filled in
 *				PDEVICE_OBJECT pDeviceObject	: MiniDriver device object, which is a child of I2C Master
 *				int 		nIrpMajorFunction	: IRP major function to query the GPIO Interface
 *
 * Outputs	: BOOL  - returns TRUE, if the interface was found
 * Author	: IKLEBANOV
 *^^*/
BOOL CATIHwConfiguration::LocateAttachGPIOProvider( GPIOINTERFACE * pGPIOInterface, PDEVICE_OBJECT pDeviceObject, UCHAR nIrpMajorFunction)
{
	PIRP	pIrp;
	BOOL	bResult = FALSE;

	ENSURE
	{
		PIO_STACK_LOCATION	pNextStack;
		NTSTATUS			ntStatus;
		KEVENT				Event;
			
			
		pIrp = IoAllocateIrp( pDeviceObject->StackSize, FALSE);
		if( pIrp == NULL)
		{
			OutputDebugError(( "CATIHwConfig(): can not allocate IRP\n"));
			FAIL;
		}

		pNextStack = IoGetNextIrpStackLocation( pIrp);
		if( pNextStack == NULL)
		{
			OutputDebugError(( "CATIHwConfig(): can not allocate NextStack\n"));
			FAIL;
		}

		pIrp->IoStatus.Status = STATUS_NOT_SUPPORTED;
		pNextStack->MajorFunction = nIrpMajorFunction;
		pNextStack->MinorFunction = IRP_MN_QUERY_INTERFACE;
		KeInitializeEvent( &Event, NotificationEvent, FALSE);

		IoSetCompletionRoutine(	pIrp,
								GPIOIoSynchCompletionRoutine,
								&Event, TRUE, TRUE, TRUE);

		pNextStack->Parameters.QueryInterface.InterfaceType = ( struct _GUID *)&GUID_GPIO_INTERFACE;
		pNextStack->Parameters.QueryInterface.Size = sizeof( GPIOINTERFACE);
		pNextStack->Parameters.QueryInterface.Version = 1;
		pNextStack->Parameters.QueryInterface.Interface = ( PINTERFACE)pGPIOInterface;
		pNextStack->Parameters.QueryInterface.InterfaceSpecificData = NULL;

		ntStatus = IoCallDriver( pDeviceObject, pIrp);

		if( ntStatus == STATUS_PENDING)
			KeWaitForSingleObject(	&Event,
									Suspended, KernelMode, FALSE, NULL);
		if(( pGPIOInterface->gpioOpen == NULL) || ( pGPIOInterface->gpioAccess == NULL))
			FAIL;

		bResult = TRUE;

	} END_ENSURE;
 
	if( pIrp != NULL)
		IoFreeIrp( pIrp);

	return( bResult);
}



/*^^*
 *		LockGPIOProviderEx()
 * Purpose	: locks the GPIOProvider for exclusive use
 *
 * Inputs	: PGPIOControl pgpioAccessBlock	: pointer to GPIO control structure
 *
 * Outputs	: BOOL : retunrs TRUE, if the GPIOProvider is locked
 * Author	: IKLEBANOV
 *^^*/
BOOL CATIHwConfiguration::LockGPIOProviderEx( PGPIOControl pgpioAccessBlock)
{
	NTSTATUS		ntStatus;
	LARGE_INTEGER	liStartTime, liCurrentTime;

	KeQuerySystemTime( &liStartTime);

	ENSURE
	{
		if(( m_gpioProviderInterface.gpioOpen == NULL)		|| 
			( m_gpioProviderInterface.gpioAccess == NULL)	||
			( m_pdoDriver == NULL))
			FAIL;

		pgpioAccessBlock->Status = GPIO_STATUS_NOERROR;
		pgpioAccessBlock->Command = GPIO_COMMAND_OPEN_PINS;

		while( TRUE)
		{
			KeQuerySystemTime( &liCurrentTime);

			if(( liCurrentTime.QuadPart - liStartTime.QuadPart) >= GPIO_TIMELIMIT_OPENPROVIDER)
			{
				// time has expired for attempting to lock GPIO provider
				return (FALSE);
			}

			ntStatus = m_gpioProviderInterface.gpioOpen( m_pdoDriver, TRUE, pgpioAccessBlock);

		    if(( NT_SUCCESS( ntStatus)) && ( pgpioAccessBlock->Status == GPIO_STATUS_NOERROR))
				break;
		}

		// the GPIO Provider has granted access - save dwCookie for further use
		m_dwGPIOAccessKey = pgpioAccessBlock->dwCookie;

		return( TRUE);

	} END_ENSURE;

	return( FALSE);
}



/*^^*
 *		ReleaseGPIOProvider()
 * Purpose	: releases the GPIOProvider for other clients' use
 *
 * Inputs	: PGPIOControl pgpioAccessBlock	: pointer to a composed GPIO access block
 *
 * Outputs	: BOOL : retunrs TRUE, if the GPIOProvider is released
 * Author	: IKLEBANOV
 *^^*/
BOOL CATIHwConfiguration::ReleaseGPIOProvider( PGPIOControl pgpioAccessBlock)
{
	NTSTATUS	ntStatus;

	ENSURE
	{
		if(( m_gpioProviderInterface.gpioOpen == NULL)		||
			( m_gpioProviderInterface.gpioAccess == NULL)	||
			( m_pdoDriver == NULL))
			FAIL;

		pgpioAccessBlock->Status = GPIO_STATUS_NOERROR;
		pgpioAccessBlock->Command = GPIO_COMMAND_CLOSE_PINS;
		pgpioAccessBlock->dwCookie = m_dwGPIOAccessKey;

		ntStatus = m_gpioProviderInterface.gpioOpen( m_pdoDriver, FALSE, pgpioAccessBlock);

	    if( !NT_SUCCESS( ntStatus)) 
		{
            OutputDebugError(( "CATIHwConfig: ReleaseGPIOProvider() NTSTATUS = %x\n", ntStatus));
			FAIL;
		}

		if( pgpioAccessBlock->Status != GPIO_STATUS_NOERROR)
		{
            OutputDebugError(( "CATIHwConfig: ReleaseGPIOProvider() Status = %x\n", pgpioAccessBlock->Status));
			FAIL;
		}

		m_dwGPIOAccessKey = 0;
		return ( TRUE);

	} END_ENSURE;

	return( FALSE);
}



/*^^*
 *		AccessGPIOProvider()
 * Purpose	: provide synchronous type of access to GPIOProvider
 *
 * Inputs	:	PDEVICE_OBJECT pdoDriver	: pointer to the client's device object
 *				PGPIOControl pgpioAccessBlock	: pointer to a composed GPIO access block
 *
 * Outputs	: BOOL, TRUE if acsepted by the GPIO Provider
 *
 * Author	: IKLEBANOV
 *^^*/
BOOL CATIHwConfiguration::AccessGPIOProvider( PDEVICE_OBJECT pdoClient, PGPIOControl pgpioAccessBlock)
{
	NTSTATUS	ntStatus;

	ENSURE 
	{

		if(( m_gpioProviderInterface.gpioOpen == NULL)		|| 
			( m_gpioProviderInterface.gpioAccess == NULL)	||
			( m_pdoDriver == NULL))
			FAIL;

		ntStatus = m_gpioProviderInterface.gpioAccess( pdoClient, pgpioAccessBlock);

	    if( !NT_SUCCESS( ntStatus)) 
		{
            OutputDebugError(( "CATIHwConfig: AccessGPIOProvider() NTSTATUS = %x\n", ntStatus));
			FAIL;
		}

		if( pgpioAccessBlock->Status != GPIO_STATUS_NOERROR)
		{
            OutputDebugError(( "CATIHwConfig: AccessGPIOProvider() Status = %x\n", pgpioAccessBlock->Status));
			FAIL;
		}

		return TRUE;

	} END_ENSURE;

	return( FALSE);
}



/*^^*
 *		SetTunerPowerState
 * Purpose	: Sets Tuner power mode
 * Inputs	: CI2CScript * pCScript	: pointer to the I2C Provider class
 *			  BOOL bPowerState		: TRUE, if turne the power on
 *
 * Outputs	: BOOL, TRUE if successfull
 * Author	: TOM
 *^^*/
BOOL CATIHwConfiguration::SetTunerPowerState( CI2CScript *	pCScript,
											  BOOL			bPowerState)
{
	UCHAR		uchORMask = 0x0;
	UCHAR		uchANDMask = 0xFF;
	UCHAR		uchPinsMask, uchValue;
	BOOL		bResult;
	GPIOControl	gpioAccessBlock;

	switch( m_usTunerPowerConfiguration)
	{
		case ATI_TUNER_POWER_CONFIG_1:

			if( bPowerState)
				uchANDMask &= 0xF7;
			else
				uchORMask |= 0x08;
			break;

		default :
			return( FALSE);
	}

	// use GPIO interface to turn Tuner power ON / OFF
	bResult = FALSE;

	ENSURE 
	{
		if(( m_gpioProviderInterface.gpioOpen == NULL) ||
			( m_gpioProviderInterface.gpioAccess == NULL))
			FAIL;

		uchPinsMask = TUNER_PM_PINS;				// use as a PinMask
		gpioAccessBlock.Pins = &uchPinsMask;
		gpioAccessBlock.Flags = GPIO_FLAGS_BYTE;
		gpioAccessBlock.nBytes = 1;
		gpioAccessBlock.nBufferSize = 1;
		gpioAccessBlock.AsynchCompleteCallback = NULL;

		// try to get GPIO Provider
		if( !LockGPIOProviderEx( &gpioAccessBlock))
			FAIL;

		uchPinsMask = TUNER_PM_PINS;				// use as a PinMask
		gpioAccessBlock.Command = GPIO_COMMAND_READ_BUFFER;
		gpioAccessBlock.Flags = GPIO_FLAGS_BYTE;
		gpioAccessBlock.dwCookie = m_dwGPIOAccessKey;
		gpioAccessBlock.nBytes = 1;
		gpioAccessBlock.nBufferSize = 1;
		gpioAccessBlock.Pins = &uchPinsMask;
		gpioAccessBlock.Buffer = &uchValue;
		gpioAccessBlock.AsynchCompleteCallback = NULL;

		if( !AccessGPIOProvider( m_pdoDriver, &gpioAccessBlock))
			FAIL;

		uchValue &= uchANDMask;
		uchValue |= uchORMask;

		gpioAccessBlock.Command = GPIO_COMMAND_WRITE_BUFFER;

		if( !AccessGPIOProvider( m_pdoDriver, &gpioAccessBlock))
			FAIL;

		bResult = TRUE;

	} END_ENSURE;

	// nothing bad will happen if we try to release the provider even we
	// have not obtained it at the first place
	uchValue = TUNER_PM_PINS;						// use as a PinMask
	gpioAccessBlock.Pins = &uchValue;
	gpioAccessBlock.Flags = GPIO_FLAGS_BYTE;
	gpioAccessBlock.nBytes = 1;
	gpioAccessBlock.nBufferSize = 1;
	gpioAccessBlock.AsynchCompleteCallback = NULL;
	
	ReleaseGPIOProvider( &gpioAccessBlock);

	return( bResult);
}



/*^^*
 *		ValidateConfigurationE2PROM
 * Purpose	: Checks the integrity ( check-sum) of I2C driven configuration EEPROM
 * Inputs	: CI2CScript * pCScript	: pointer to the I2C Provider class
 *
 * Outputs	: BOOL, TRUE if the information inside EEPROM is valid
 * Author	: TOM
 *^^*/
BOOL CATIHwConfiguration::ValidateConfigurationE2PROM( CI2CScript * pCScript)
{
	I2CPacket	i2cPacket;
	UCHAR		uchReadValue=0, uchWriteValue, uchCheckSum=0;
	UINT		nIndex;
	BOOL		bResult = ( BOOL)m_usE2PROMValidation;

	if( m_usE2PROMValidation == ( USHORT)-1)
	{
		// the validation has not been done yet.
		bResult = FALSE;

		ENSURE
		{
			// Let's always start from byte 0.
			i2cPacket.uchChipAddress = AIWPRO_CONFIGURATIONE2PROM_ADDRESS;
			i2cPacket.cbWriteCount = 1;
			i2cPacket.cbReadCount = 1;
			i2cPacket.puchReadBuffer = &uchCheckSum;
			uchWriteValue = 0;
			i2cPacket.puchWriteBuffer = &uchWriteValue;
			i2cPacket.usFlags = I2COPERATION_READ | I2COPERATION_RANDOMACCESS;

			if( !pCScript->ExecuteI2CPacket( &i2cPacket))
				FAIL;

			for( nIndex = 1; nIndex < AIWPRO_CONFIGURATIONE2PROM_LENGTH; nIndex ++)
			{
				// let's use auto-increment address mode
				i2cPacket.usFlags = I2COPERATION_READ;
				i2cPacket.cbWriteCount = 0;
				i2cPacket.puchWriteBuffer = NULL;
				i2cPacket.puchReadBuffer = &uchReadValue;

				if( !pCScript->ExecuteI2CPacket( &i2cPacket))
					FAIL;

				uchCheckSum ^= uchReadValue;
			}

			if( nIndex != AIWPRO_CONFIGURATIONE2PROM_LENGTH)
				FAIL;

			bResult = ( uchCheckSum == 0);


		} END_ENSURE;

		m_usE2PROMValidation = ( USHORT)bResult;
	}

	return( bResult);
}



/*^^*
 *		ReadConfigurationE2PROM
 * Purpose	: Reads a single byte from I2C driver configuration EEPROM by offset
 * Inputs	: CI2CScript * pCScript	: pointer to the I2C Provider class
 *			  ULONG ulOffset		: byte offset within the EEPROM
 *			  PUCHAR puchValue		: pointer to the buffer to read into
 *
 * Outputs	: BOOL, TRUE if I2C read operation succeeded
 * Author	: TOM
 *^^*/
BOOL CATIHwConfiguration::ReadConfigurationE2PROM( CI2CScript * pCScript, ULONG ulOffset, PUCHAR puchValue)
{
	I2CPacket	i2cPacket;
	UCHAR		uchReadValue=0, uchWriteValue;

	ENSURE
	{
		if( ulOffset >= AIWPRO_CONFIGURATIONE2PROM_LENGTH)
			FAIL;

		uchWriteValue = ( UCHAR)ulOffset;
		i2cPacket.uchChipAddress = AIWPRO_CONFIGURATIONE2PROM_ADDRESS;
		i2cPacket.cbWriteCount = 1;
		i2cPacket.cbReadCount = 1;
		i2cPacket.puchReadBuffer = &uchReadValue;
		i2cPacket.puchWriteBuffer = &uchWriteValue;
		i2cPacket.usFlags = I2COPERATION_READ | I2COPERATION_RANDOMACCESS;

		if( !pCScript->ExecuteI2CPacket( &i2cPacket))
			FAIL;

		* puchValue = uchReadValue;

		return( TRUE);

	} END_ENSURE;

	return( FALSE);
}


//Paul
ULONG CATIHwConfiguration::ReturnTunerVideoStandard( USHORT usTunerId )   //Paul:  For PAL support
{
    switch( usTunerId )
    {
    case 1:
        return KS_AnalogVideo_NTSC_M;
        break;
    case 2:
        return KS_AnalogVideo_NTSC_M_J;
        break;
    case 3:
        return KS_AnalogVideo_PAL_B | KS_AnalogVideo_PAL_G;
        break;
    case 4:
        return KS_AnalogVideo_PAL_I;
        break;
    case 5:
        return KS_AnalogVideo_PAL_B | KS_AnalogVideo_PAL_G | KS_AnalogVideo_SECAM_L | KS_AnalogVideo_SECAM_L1;
        break;
    case 6:
        return KS_AnalogVideo_NTSC_M;
        break;
    case 7:
        return KS_AnalogVideo_SECAM_D | KS_AnalogVideo_SECAM_K;
        break;
    case 8:
        return KS_AnalogVideo_NTSC_M;
        break;
    case 9:
        return KS_AnalogVideo_PAL_B | KS_AnalogVideo_PAL_G;
        break;
    case 10:
        return KS_AnalogVideo_PAL_I;
        break;
    case 11:
        return KS_AnalogVideo_PAL_B | KS_AnalogVideo_PAL_G | KS_AnalogVideo_SECAM_L | KS_AnalogVideo_SECAM_L1;
        break;
    case 12:
        return KS_AnalogVideo_NTSC_M;
        break;
    case 13:
        return KS_AnalogVideo_PAL_B | KS_AnalogVideo_PAL_D | KS_AnalogVideo_PAL_G | KS_AnalogVideo_PAL_I | KS_AnalogVideo_SECAM_D | KS_AnalogVideo_SECAM_K;
        break;
    case 14:
        return 0;
        break;
    case 15:
        return 0;
        break;
    case 16:
        return KS_AnalogVideo_NTSC_M;
        break;
    case 17:
        return KS_AnalogVideo_NTSC_M;
        break;
    case 18:
        return KS_AnalogVideo_NTSC_M;
        break;
    default:
        return 0;   // if we don't recognize the tuner, we say that no video standard is supported
    }
}

//Paul
// bit 5 indicates the number of crystals installed.  0 means we have 2 crystals,
// 1 means we only have 1, so the tuner determines the standard
ULONG CATIHwConfiguration::SetVidStdBasedOnI2CExpander( UCHAR ucI2CValue )
{
    if ( ucI2CValue & 0x20 )    // only 1 crystal
    {
        ULONG ulTunerStd = ReturnTunerVideoStandard( ucI2CValue & 0x0F );
        if ( ulTunerStd & ( KS_AnalogVideo_NTSC_Mask & ~KS_AnalogVideo_NTSC_433 | KS_AnalogVideo_PAL_60 ) ) // Then we should have NTSC-type crystal
        {
            return KS_AnalogVideo_NTSC_Mask & ~KS_AnalogVideo_NTSC_433 | KS_AnalogVideo_PAL_60 | KS_AnalogVideo_PAL_M | KS_AnalogVideo_PAL_N;
        }
        else
        {
            return KS_AnalogVideo_PAL_Mask & ~KS_AnalogVideo_PAL_60 & ~KS_AnalogVideo_PAL_M & ~KS_AnalogVideo_PAL_N | KS_AnalogVideo_SECAM_Mask | KS_AnalogVideo_NTSC_433;
        }
    }
    else
        return KS_AnalogVideo_NTSC_Mask | KS_AnalogVideo_PAL_Mask | KS_AnalogVideo_SECAM_Mask;  // we support all standards (is this testable?)
}

//Paul
// The Video In crystal type in MMTable will tell us whether we support NTSC, PAL/SECAM, or both
ULONG CATIHwConfiguration::SetVidStdBasedOnMMTable( CATIMultimediaTable * pCMultimediaInfo )
{
    if ( pCMultimediaInfo )
    {
        if ( pCMultimediaInfo->GetVideoInCrystalId( &m_CrystalIDInMMTable ) )
        {
            switch ( m_CrystalIDInMMTable )
            {
            // "NTSC and PAL Crystals Installed (for Bt8xx)"
            case 0:
                return KS_AnalogVideo_NTSC_Mask | KS_AnalogVideo_PAL_Mask;  // may need to add SECAM.  We will see
                break;
            // "NTSC Crystal Only (for Bt8xx)"
            case 1:
                return KS_AnalogVideo_NTSC_Mask & ~KS_AnalogVideo_NTSC_433 | KS_AnalogVideo_PAL_60 | KS_AnalogVideo_PAL_M | KS_AnalogVideo_PAL_N;   // standards that use "NTSC" clock
                break;
            // "PAL Crystal Only (for Bt8xx)"
            case 2:
                return KS_AnalogVideo_PAL_Mask & ~KS_AnalogVideo_PAL_60 & ~KS_AnalogVideo_PAL_M & ~KS_AnalogVideo_PAL_N | KS_AnalogVideo_SECAM_Mask | KS_AnalogVideo_NTSC_433; // standards that use "PAL" clock
                break;
            // "NTSC, PAL, SECAM (for Bt829)"
            case 3:
                return KS_AnalogVideo_NTSC_Mask | KS_AnalogVideo_PAL_Mask | KS_AnalogVideo_SECAM_Mask;
                break;
            }
        }
    }
    return 0;
            

}

//Paul:  Used by RT WDM to determine the VIN PLL
BOOL CATIHwConfiguration::GetMMTableCrystalID( PUCHAR pucCrystalID )
{   if ( ( m_uchI2CExpanderAddress==0xFF ) || ( !pucCrystalID ) )
    {
        return FALSE;
    }
    else
    {
        *pucCrystalID = m_CrystalIDInMMTable;
        return TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\atishare\i2clog.h ===
//==========================================================================;
//
//	I2CLog.H
//	WDM MiniDrivers development.
//		I2CScript implementation.
//			I2CLog Class definition.
//  Copyright (c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.
//
//		$Date:   28 Apr 1998 09:34:40  $
//	$Revision:   1.0  $
//	  $Author:   KLEBANOV  $
//
//==========================================================================;

#ifndef _I2CLOG_H_
#define _I2CLOG_H_


#include "i2cgpio.h"


class CI2CLog
{
public:
	CI2CLog					( PDEVICE_OBJECT pDeviceObject);
	~CI2CLog				( void);

	// Attributes	
private:
	BOOL	m_bLogStarted;
	HANDLE	m_hLogFile;

	// Implementation
public:
	inline BOOL	GetLogStatus	( void) { return( m_bLogStarted); };

private:

};


#endif	// _I2CLOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\atishare\atigpio.h ===
//==========================================================================;
//
// File:		ATIGPIO.H
//
// Notes:	This file is provided under strict non-disclosure agreements
//				it is and remains the property of ATI Technologies Inc.
//				Any use of this file or the information it contains to
//				develop products commercial or otherwise must be with the
//				permission of ATI Technologies Inc.
//
// Copyright (C) 1997 - 1998, ATI Technologies Inc.
//
//==========================================================================;

#ifndef _ATIGPIO_H_
#define _ATIGPIO_H_

#define GPIO_TIMELIMIT_OPENPROVIDER		50000000	// 5 seconds in 100 nsec.

#define	AUDIO_MUX_PINS					0x0003
#define	TUNER_PM_PINS					0x0004

#define AVAILABLE_GPIOPINS				AUDIO_MUX_PINS | TUNER_PM_PINS

#endif	// _ATIGPIO_H_



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\atishare\atidigad.h ===
//==========================================================================;
//
// File:		ATIDIGAD.H
//
// Notes:	This file is provided under strict non-disclosure agreements
//				it is and remains the property of ATI Technologies Inc.
//				Any use of this file or the information it contains to
//				develop products commercial or otherwise must be with the
//				permission of ATI Technologies Inc.
//
// Copyright (C) 1997 - 1998, ATI Technologies Inc.
//
//==========================================================================;

#ifndef _ATIDIGAD_H_

#define _ATIDIGAD_H_

typedef struct tag_DIGITAL_AUD_INFO
{
	BOOL	bI2SInSupported;
	BOOL	bI2SOutSupported;
	WORD	wI2S_DAC_Device;
	WORD	wReference_Clock;
	BOOL	bSPDIFSupported;

} DIGITAL_AUD_INFO, * PDIGITAL_AUD_INFO;


// Start enum value matches value in MM Table
enum
{
	TDA1309_32 = 0,
	TDA1309_64,
	ITTMSP3430,
};

// Start enum value matches value in MM Table
enum
{
	REF_286MHZ = 4,
	REF_295MHZ,
	REF_270MHZ,
	REF_143MHZ,
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\atishare\atiguids.h ===
/*^^*
 * File:		ATIGUIDS.H
 *
 * Purpose:		Defines the GUIDS of ATI private interfaces exposed
 *				by the MiniVDD via GPIO Interface.
 *
 * Reference:	Ilya Klebanov
 *
 * Notes:	This file is provided under strict non-disclosure agreements
 *				it is and remains the property of ATI Technologies Inc.
 *				Any use of this file or the information it contains to
 *				develop products commercial or otherwise must be with the
 *				permission of ATI Technologies Inc.
 *
 * Copyright (C) December 1997, ATI Technologies Inc.
*
*	Please, come to talk to Ilya before you're making any changes to thos file
*
 *^^*/

#ifndef _ATIGUIDS_H_
#define _ATIGUIDS_H_

#include "atibios.h"

#ifndef DEVNODE
#define DEVNODE DWORD
#endif

/*
	This interface is an entry point to all possible ATI Private interfaces
	This GUID is reported back at GPIOOpen command via GPIO Microsoft defined
	interface. Among this GUID there is a PVOID pointer exposed, which we'll
	cast to the ATIQueryPrivateInterface function pointer as defined below.
	The function should return pointer to the specific interface if supported,
	or NULL based upon the GUID passed in.
*/
// {E3F5D200-6714-11d1-9065-00A02481E06C}
DEFINE_GUID( GUID_ATI_PRIVATE_INTERFACES_QueryInterface, 
	0xe3f5d200L, 0x6714, 0x11d1, 0x90, 0x65, 0x0, 0xa0, 0x24, 0x81, 0xe0, 0x6c);

typedef VOID ( STDMETHODCALLTYPE * ATI_QueryPrivateInterface)( PDEVICE_OBJECT, REFGUID, PVOID *);
typedef VOID ( STDMETHODCALLTYPE * ATI_QueryPrivateInterfaceOne)( DEVNODE, REFGUID, PVOID *);


/*
	This Interface allows to client get MultiMedia related information from
	the BIOS. Usual client is a WDM MiniDriver.
*/
// {AD5D6C00-673A-11d1-9065-00A02481E06C}
DEFINE_GUID( GUID_ATI_PRIVATE_INTERFACES_Configuration,
	0xad5d6c00, 0x673a, 0x11d1, 0x90, 0x65, 0x0, 0xa0, 0x24, 0x81, 0xe0, 0x6c);

// {D24AB480-B4D5-11d1-9065-00A02481E06C}
DEFINE_GUID( GUID_ATI_PRIVATE_INTERFACES_Configuration_One, 
	0xd24ab480, 0xb4d5, 0x11d1, 0x90, 0x65, 0x0, 0xa0, 0x24, 0x81, 0xe0, 0x6c);

// {299D9CA0-69C3-11d2-BE4D-008029E75CEB}
DEFINE_GUID( GUID_ATI_PRIVATE_INTERFACES_Configuration_Two,
	0x299d9ca0, 0x69c3, 0x11d2, 0xbe, 0x4d, 0x0, 0x80, 0x29, 0xe7, 0x5c, 0xeb);

// {58AEE200-FBBA-11d1-A419-00104B712355}
DEFINE_GUID( GUID_ATI_PRIVATE_INTERFACES_MPP, 
	0x58aee200, 0xfbba, 0x11d1, 0xa4, 0x19, 0x0, 0x10, 0x4b, 0x71, 0x23, 0x55);

// {7CF92CA0-06CE-11d2-A419-00104B712355}
DEFINE_GUID( GUID_ATI_PRIVATE_INTERFACES_StreamServices,
	0x7cf92ca0, 0x6ce, 0x11d2, 0xa4, 0x19, 0x0, 0x10, 0x4b, 0x71, 0x23, 0x55);

// {038D2B00-D6DF-11d2-BE4D-008029E75CEB}
DEFINE_GUID( GUID_ATI_PRIVATE_INTERFACES_MVProtection, 
	0x38d2b00, 0xd6df, 0x11d2, 0xbe, 0x4d, 0x0, 0x80, 0x29, 0xe7, 0x5c, 0xeb);


typedef NTSTATUS ( STDMETHODCALLTYPE * GETCONFIGURATION_MULTIMEDIA)	\
	( PVOID, PUCHAR, PULONG pulSize);
typedef NTSTATUS ( STDMETHODCALLTYPE * GETCONFIGURATION_HARDWARE)	\
	( PVOID, PUCHAR, PULONG pulSize);

typedef struct
{
	ATI_QueryPrivateInterface	pfnQueryPrivateInterface;
	GETCONFIGURATION_MULTIMEDIA	pfnGetMultimediaConfiguration;
	GETCONFIGURATION_HARDWARE	pfnGetHardwareConfiguration;

} ATI_PRIVATE_INTERFACE_CONFIGURATION, * PATI_PRIVATE_INTERFACE_CONFIGURATION;

typedef struct
{
    USHORT                  	usSize;
    USHORT                  	nVersion;
    PVOID                   	pvContext;
    PVOID                   	pvInterfaceReference;
    PVOID                   	pvInterfaceDereference;

	GETCONFIGURATION_MULTIMEDIA	pfnGetMultimediaConfiguration;
	GETCONFIGURATION_HARDWARE	pfnGetHardwareConfiguration;

} ATI_PRIVATE_INTERFACE_CONFIGURATION_One, * PATI_PRIVATE_INTERFACE_CONFIGURATION_One;


// Definitions for ulTable
typedef enum
{
	ATI_BIOS_CONFIGURATIONTABLE_MULTIMEDIA = 1,
	ATI_BIOS_CONFIGURATIONTABLE_HARDWARE

} ATI_CONFIGURATION_TABLE;

typedef NTSTATUS ( STDMETHODCALLTYPE * GETCONFIGURATION_DATA)		\
	( PVOID pvContext, ULONG ulTable, PUCHAR puchData, PULONG pulSize);
typedef NTSTATUS ( STDMETHODCALLTYPE * GETCONFIGURATION_REVISION)	\
	( PVOID pvContext, ULONG ulTable, PULONG pulRevision);

typedef struct
{
    USHORT                  	usSize;
    USHORT                  	nVersion;
    PVOID                   	pvContext;
    PVOID                   	pvInterfaceReference;
    PVOID                   	pvInterfaceDereference;

	GETCONFIGURATION_REVISION	pfnGetConfigurationRevision;
	GETCONFIGURATION_DATA		pfnGetConfigurationData;

} ATI_PRIVATE_INTERFACE_CONFIGURATION_Two, * PATI_PRIVATE_INTERFACE_CONFIGURATION_Two;


typedef NTSTATUS ( STDMETHODCALLTYPE * MACROVISIONPROTECTION_SETLEVEL) \
	( PVOID, ULONG ulProtectionLevel);
typedef NTSTATUS ( STDMETHODCALLTYPE * MACROVISIONPROTECTION_GETLEVEL) \
	( PVOID, PULONG pulProtectionLevel);

typedef struct
{
    USHORT                  		usSize;
    USHORT                  		nVersion;
    PVOID                   		pvContext;
    PVOID                   		pvInterfaceReference;
    PVOID                   		pvInterfaceDereference;

	MACROVISIONPROTECTION_SETLEVEL	pfnSetProtectionLevel;
	MACROVISIONPROTECTION_GETLEVEL	pfnGetProtectionLevel;

} ATI_PRIVATE_INTERFACE_MVProtection, *PATI_PRIVATE_INTERFACE_MVProtection;


#endif	// _ATIGUIDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\atishare\i2clog.cpp ===
//==========================================================================;
//
//	I2CLog.CPP
//	WDM MiniDrivers development.
//		I2CScript implementation.
//			I2CLog Class implemenation.
//  Copyright (c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.
//
//		$Date:   28 Apr 1998 09:34:38  $
//	$Revision:   1.0  $
//	  $Author:   KLEBANOV  $
//
//==========================================================================;

extern"C"
{
#include "strmini.h"

#include "wdmdebug.h"
}

#include "i2script.h"
#include "i2clog.h"
#include "wdmdrv.h"
#include "registry.h"


/*^^*
 *		~CI2CLog() destructor
 * Purpose	: close I2C Log file
 *
 * Inputs	: none
 * Outputs	: none
 * Author	: IKLEBANOV
 *^^*/
CI2CLog::~CI2CLog( void)
{

	if( m_hLogFile != NULL)
		::ZwClose( m_hLogFile);
}


/*^^*
 *		CI2CLog() constructor
 * Purpose	: Finds out from the Registry, if the I2C Log option is enabled, and
 *				gets teh Log file name ( if not specified the default log file name
 *				is used). The Log file is overwritten every system reboot.
 *
 * Inputs	: PDEVICE_OBJECT pDeviceObject	: pointer to DeviceObject
 *			  PBOOL pbLogStarted			: poinetr to return BOOL
 * Outputs	: none
 * Author	: IKLEBANOV
 *^^*/
CI2CLog::CI2CLog( PDEVICE_OBJECT pDeviceObject)
{
#if 0
	HANDLE				hDevice;
	NTSTATUS			ntStatus;
	WCHAR				wchFileName[MAXIMUM_FILENAME_LENGTH];
	PWCHAR				pwchLogFileName;
	ULONG				ulEnable, ulLength;
    UNICODE_STRING  	unicodeFullName, unicodeName;
	OBJECT_ATTRIBUTES	objectAttributes;
    IO_STATUS_BLOCK		ioStatus;

	hDevice = NULL;
	m_bLogStarted = FALSE;
	unicodeFullName.Buffer = NULL;

	ENSURE
	{
		ntStatus = ::IoOpenDeviceRegistryKey( pDeviceObject,
											  PLUGPLAY_REGKEY_DRIVER, STANDARD_RIGHTS_ALL,
											  &hDevice);

    	if( !NT_SUCCESS( ntStatus) || ( hDevice == NULL))
			FAIL;

		if( !NT_SUCCESS( ::ReadStringFromRegistryFolder( hDevice,
														 UNICODE_WDM_I2CLOG_ENABLE,
														 ( PWCHAR)&ulEnable,
														 sizeof( ULONG))))
			FAIL;

		if( !ulEnable)
			FAIL;

		if( NT_SUCCESS( ::ReadStringFromRegistryFolder( hDevice,
														UNICODE_WDM_I2CLOG_FILENAME,
														wchFileName,
														sizeof( wchFileName))))
			pwchLogFileName = wchFileName;
		else
			// the default file name is used
			if( NT_SUCCESS( ::ReadStringFromRegistryFolder( hDevice,
															L"NTMPDriver",
															wchFileName,
															sizeof( wchFileName))))
			{
				ulLength = 0;
				while( ulLength < MAXIMUM_FILENAME_LENGTH)
					if( wchFileName[ulLength ++] == L'.')
						break;
				if( ulLength >= MAXIMUM_FILENAME_LENGTH)
					FAIL;

		        ::RtlMoveMemory( &wchFileName[ulLength],
								 UNICODE_WDM_I2CLOG_DEFAULTEXTENSION,
								 sizeof( UNICODE_WDM_I2CLOG_DEFAULTEXTENSION));

				pwchLogFileName = wchFileName;
			}
			else
				FAIL;

		::RtlInitUnicodeString( &unicodeName, pwchLogFileName);

		ulLength = sizeof( UNICODE_WDM_I2CLOG_ABSOLUTEPATH) - sizeof( WCHAR) + unicodeName.MaximumLength;

		unicodeFullName.Buffer = ( USHORT *)::ExAllocatePool( NonPagedPool, ulLength);
		if( unicodeFullName.Buffer == NULL)
		{
			OutputDebugError(( "CI2CLog: Full file name buffer allocation failure ulLength = %d\n", ulLength));
			FAIL;
		}

		unicodeFullName.MaximumLength = ( USHORT)ulLength;
		 // don't copy the trailing NULL
		ulLength = sizeof( UNICODE_WDM_I2CLOG_ABSOLUTEPATH) - sizeof( WCHAR);

        ::RtlMoveMemory( unicodeFullName.Buffer,
						 UNICODE_WDM_I2CLOG_ABSOLUTEPATH,
						 ulLength);
		unicodeFullName.Length = ( USHORT)ulLength;

		if( !NT_SUCCESS( ::RtlAppendUnicodeStringToString( &unicodeFullName, &unicodeName)))
			FAIL;

	    InitializeObjectAttributes( &objectAttributes, 
									&unicodeFullName,
									OBJ_CASE_INSENSITIVE,
									NULL,
									NULL);

		OutputDebugTrace(( "CI2CLog: creating I2C Private Log file %wZ\n", pwchLogFileName));

		FAIL;

        ntStatus = ::ZwCreateFile( &m_hLogFile, 
								   GENERIC_WRITE | SYNCHRONIZE | FILE_APPEND_DATA, 
								   &objectAttributes,
								   &ioStatus,
								   NULL,
								   FILE_ATTRIBUTE_NORMAL,
								   0,
								   FILE_OVERWRITE_IF,
								   FILE_SYNCHRONOUS_IO_NONALERT,
								   NULL,
								   0);

		if( !NT_SUCCESS( ntStatus))
			FAIL;

		m_bLogStarted = TRUE;

	} END_ENSURE;

	if( !m_bLogStarted)
		OutputDebugError(( "CI2CLog: creating I2C Private Log failure\n"));

	if( hDevice != NULL)
		::ZwClose( hDevice);

	if( unicodeFullName.Buffer != NULL)
		::ExFreePool( unicodeFullName.Buffer);
#else
	OutputDebugError(( "I2C Log feature is yet not available\n"));
#endif	// not compiled
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\atishare\i2script.h ===
//==========================================================================;
//
//	I2CSCRPT.H
//	I2CScript class definitions. 
//		Main Include Module.
//  Copyright (c) 1996 - 1998  ATI Technologies Inc.  All Rights Reserved.
//
//==========================================================================;

#ifndef _I2CSCRIPT_H_
#define _I2CSCRIPT_H_


#include "i2cgpio.h"


#define	I2CSCRIPT_LENGTH_MAXIMUM	100
#define I2C_FIXED_CLOCK_RATE		10000


// The I2CScript is build from the following primitives
typedef struct tagI2CScriptPrimitive
{
	BYTE	byData;				// Data to be used in the I2C operation
	BYTE	byORData;			// Data to be used for a logical OR operation
	BYTE	byANDData;			// Data to be used for a logical AND operation
	BYTE	byFlags;			// implementation specific internal Script flags for I2C operation
	ULONG	ulProviderFlags;	// I2CProvider specific flags
	ULONG	ulCommand;			// I2CProvider specific command

} I2CScriptPrimitive, * PI2CScriptPrimitive;

typedef struct
{
	UCHAR uchModifyORValue;
	UCHAR uchModifyANDValue;

} I2C_MODIFY_VALUES, * PI2C_MODIFY_VALUES;

// New I2CScript control structure - extension to the old I2C access structure
typedef struct tagI2CPacket
{
	UCHAR	uchChipAddress;		// I2C Address
	UCHAR	uchI2CResult;		// valid in synchronous operation only
	USHORT	cbWriteCount;		// bytes to write ( included SubAddress, if exist)
	USHORT	cbReadCount;		// bytes to read ( usually one)
	USHORT	usFlags;			// describes the desired operation
	PUCHAR	puchWriteBuffer;	// buffer to write
	PUCHAR	puchReadBuffer;		// buffer to read
	UCHAR	uchORValue;			// applied only in Read-Modify-Write cycle
	UCHAR	uchANDValue;		// applied only in Read-Modify-Write cycle
	USHORT	usReserved;			//

} I2CPacket, * PI2CPacket;

// possible flags applied to usFlags
#define I2COPERATION_READ			0x0001	// might not be needed - use bcReadCount
#define I2COPERATION_WRITE			0x0002	// might be not needed - use bcReadCount
#define I2COPERATION_READWRITE		0x0004	
#define I2COPERATION_RANDOMACCESS	0x0100	// to indicate 16 bits emulation to provide
											// built-in support for ITT decoder and ST24 series
											// of I2C driven EEPROM

#include "i2clog.h"

extern "C"
{
typedef VOID ( STREAMAPI * PHWCompletionRoutine)( IN PVOID pSrb);
}

class CI2CScript
{
public:
	CI2CScript				( PDEVICE_OBJECT pDeviceObject, PUINT puiError);
	PVOID operator new		( size_t stSize, PVOID pAllocation);

// Attributes	
public:
	
private:
	// I2C Provider related
	I2CINTERFACE				m_i2cProviderInterface;
	PDEVICE_OBJECT				m_pdoDriver;
	ULONG						m_ulI2CAccessClockRate;
	DWORD						m_dwI2CAccessKey;
	CI2CLog						m_CI2CLog;

	// I2CScript management related
	BOOL						m_bExecutionInProcess;
	UINT						m_nExecutionIndex;
	UINT						m_nCompletionIndex;
	UINT						m_nScriptLength;
	PHWCompletionRoutine		m_pfnReturnWhenDone;
	I2CScriptPrimitive			m_i2cScript[I2CSCRIPT_LENGTH_MAXIMUM];

// Implementation
public:
	BOOL	LockI2CProviderEx				( void);
	BOOL	ReleaseI2CProvider				( void);

	BOOL	ExecuteI2CPacket				( IN OUT PI2CPacket);
	BOOL	PerformI2CPacketOperation		( IN OUT PI2CPacket pI2CPacket);

	BOOL	AppendToScript					( IN PI2CPacket);
	void	ClearScript						( void);
	BOOL	ExecuteScript					( IN PHW_STREAM_REQUEST_BLOCK	pSrb,
											  IN PHWCompletionRoutine		pfnScriptCompletion);
	void	InterpreterScript				( void);
	UINT	GetScriptResults				( PUINT puiReadCount, PUCHAR puchReadBuffer);

private:
	BOOL	LockI2CProvider					( void);
	UINT	AccessI2CProvider				( PDEVICE_OBJECT pdoClient, PI2CControl pi2cAccessBlock);
	BOOL 	InitializeAttachI2CProvider		( I2CINTERFACE * pI2CInterface, PDEVICE_OBJECT pDeviceObject);
	BOOL	LocateAttachI2CProvider			( I2CINTERFACE * pI2CInterface, PDEVICE_OBJECT pDeviceObject, int nIrpMajorFunction);
	UINT	CheckI2CScriptPacket			( IN PI2CPacket pI2CPacket);
	BOOL	GetI2CProviderLockStatus		( void);
};


extern "C"
NTSTATUS I2CScriptIoSynchCompletionRoutine	( IN PDEVICE_OBJECT pDeviceObject,
											  IN PIRP pIrp,
											  IN PVOID Event);

// errors definition for internal use
#define	I2CSCRIPT_NOERROR				0x00
#define I2CSCRIPT_ERROR_NOPROVIDER		0x01
#define I2CSCRIPT_ERROR_NODATA			0x02
#define I2CSCRIPT_ERROR_NOBUFFER		0x03
#define I2CSCRIPT_ERROR_READWRITE		0x04
#define I2CSCRIPT_ERROR_OVERFLOW		0x05

// time definitions
#define I2CSCRIPT_DELAY_OPENPROVIDER		-2000
#define I2CSCRIPT_DELAY_GETPROVIDERSTATUS	-2000

// time limits
#define I2CSCRIPT_TIMELIMIT_OPENPROVIDER	50000000	// 5 seconds in 100 nsec.


#endif	// _I2CSCRIPT_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\atishare\mmconfig.cpp ===
//==========================================================================;
//
//	MMCONFIG.CPP
//		CATIMultimediaTable Class implementation.
//  Copyright (c) 1996 - 1998  ATI Technologies Inc.  All Rights Reserved.
//
//		$Date:   23 Jun 1999 11:58:20  $
//	$Revision:   1.8  $
//	  $Author:   pleung  $
//
//==========================================================================;

extern"C"
{
#include "conio.h"
#include "strmini.h"
#include "wdmdebug.h"
}

#include "wdmdrv.h"
#include "i2cgpio.h"

#include "initguid.h"
#include "mmconfig.h"

#include "atiguids.h"
#include "aticonfg.h"


/*^^*
 *		operator new
 * Purpose	: called, before the class constructor, when the class object is created
 *				by invoking the operator new
 *
 * Inputs	: UINT size_t	: size of the object to be placed
 *
 * Outputs	: none
 * Author	: IKLEBANOV
 *^^*/
PVOID CATIMultimediaTable::operator new( size_t stSize)
{
	PVOID pvAllocation = NULL;

	ENSURE
	{
		if( stSize != sizeof( CATIMultimediaTable))
			FAIL;

		pvAllocation = ::ExAllocatePool( PagedPool, stSize);

	} END_ENSURE;

	return( pvAllocation);
}


/*^^*
 *		operator delete
 * Purpose	: called, after the class destructor, when the class object is killed
 *				by invoking the operator delete
 *
 * Inputs	: PVOID pvAllocation	: memory assisiated with the class object
 *
 * Outputs	: none
 * Author	: IKLEBANOV
 *^^*/
void CATIMultimediaTable::operator delete( PVOID pvAllocation)
{

	if( pvAllocation != NULL)
		::ExFreePool( pvAllocation);
}


/*^^*
 *		CATIMultimediaTable()
 * Purpose	: CATIMultimediaTable Class constructor
 *
 * Inputs	: PDEVICE_OBJECT pDeviceObject		: pointer to the creator DeviceObject
 *			  GPIOINTERFACE * pGPIOInterface	: pointer to GPIO Interface
 *			  PBOOL pbResult					: pointer to return success indicator
 *
 * Outputs	: none
 * Author	: IKLEBANOV
 *^^*/
CATIMultimediaTable::CATIMultimediaTable( PDEVICE_OBJECT	pDeviceObject,
										  GPIOINTERFACE *	pGPIOInterface,
										  PBOOL				pbResult)
{
	GPIOControl					gpioAccessBlock;
	ATI_QueryPrivateInterface	pfnQueryInterface;
	BOOL						bResult = FALSE;

	m_ulRevision = ( DWORD)-1;
	m_ulSize = 0;
	m_pvConfigurationData = NULL;

	// Let's get MultiMedia data using private interfaces exposed by MiniVDD via
	// the standard Microsoft-defined GPIO interface
	ENSURE
	{
		if( !QueryGPIOProvider( pDeviceObject, pGPIOInterface, &gpioAccessBlock))
			FAIL;

		if( !::IsEqualGUID( ( const struct _GUID &)gpioAccessBlock.PrivateInterfaceType,
							( const struct _GUID &)GUID_ATI_PRIVATE_INTERFACES_QueryInterface))
			FAIL;

		pfnQueryInterface = ( ATI_QueryPrivateInterface)gpioAccessBlock.PrivateInterface;

		if( pfnQueryInterface == NULL)
			FAIL;

		if( !GetMultimediaInfo_IConfiguration2( pDeviceObject,
												pfnQueryInterface))
		{
		    OutputDebugError(( "CATIMultimediaTable constructor fails to access IConfiguration2 for pDO = %x\n",
				pDeviceObject));

			if( !GetMultimediaInfo_IConfiguration1( pDeviceObject,
													pfnQueryInterface))
			{
			    OutputDebugError(( "CATIMultimediaTable constructor fails to access IConfiguration1 for pDO = %x\n",
					pDeviceObject));

				if( !GetMultimediaInfo_IConfiguration( pDeviceObject,
													   pfnQueryInterface))
				{
				    OutputDebugError(( "CATIMultimediaTable constructor fails to access IConfiguration for pDO = %x\n",
						pDeviceObject));

					FAIL;
				}
			}
		}

		bResult = TRUE;

	} END_ENSURE;

	* pbResult = bResult;
}


/*^^*
 *		CATIMultimediaTable()
 * Purpose	: CATIMultimediaTable Class destructor
 *
 * Inputs	: none
 *
 * Outputs	: none
 * Author	: IKLEBANOV
 *^^*/
CATIMultimediaTable::~CATIMultimediaTable()

{

	if( m_pvConfigurationData != NULL)
	{
		::ExFreePool( m_pvConfigurationData);
		m_pvConfigurationData = NULL;
	}

	m_ulSize = 0;
	m_ulRevision = ( DWORD)-1;
}


/*^^*
 *		GetMultimediaInfo_IConfiguration2()
 * Purpose	: Get ATI Multimedia table, using IConfiguration2 interface
 *
 * Inputs	: PDEVICE_OBJECT pDeviceObject					: pointer to the creator DeviceObject
 *			  ATI_QueryPrivateInterface	pfnQueryInterface	: pointer to Query interface function
 *
 * Outputs	: BOOL, returns TRUE, if succeeded
 * Author	: IKLEBANOV
 *^^*/
BOOL CATIMultimediaTable::GetMultimediaInfo_IConfiguration2( PDEVICE_OBJECT				pDeviceObject,
															 ATI_QueryPrivateInterface	pfnQueryInterface)
{
	BOOL										bResult = FALSE;
	ATI_PRIVATE_INTERFACE_CONFIGURATION_Two		iConfigurationTwo;
	PATI_PRIVATE_INTERFACE_CONFIGURATION_Two	pIConfigurationTwo = &iConfigurationTwo;

	ENSURE
	{
		iConfigurationTwo.usSize = sizeof( ATI_PRIVATE_INTERFACE_CONFIGURATION_Two);
		pfnQueryInterface( pDeviceObject,
						   ( const struct _GUID &)GUID_ATI_PRIVATE_INTERFACES_Configuration_Two,
						   ( PVOID *)&pIConfigurationTwo);

		if(( pIConfigurationTwo == NULL)								||
			( pIConfigurationTwo->pfnGetConfigurationRevision == NULL)	||
			( pIConfigurationTwo->pfnGetConfigurationData == NULL))
			FAIL;

		//let's query GetConfigurationRevision Interface member first
		if( !( NT_SUCCESS( pIConfigurationTwo->pfnGetConfigurationRevision( pIConfigurationTwo->pvContext,
																			ATI_BIOS_CONFIGURATIONTABLE_MULTIMEDIA,
																			&m_ulRevision))))
			FAIL;

		if( !( NT_SUCCESS( pIConfigurationTwo->pfnGetConfigurationData( pIConfigurationTwo->pvContext,
																		ATI_BIOS_CONFIGURATIONTABLE_MULTIMEDIA,
																		NULL,
																		&m_ulSize))))
			FAIL;

		m_pvConfigurationData = ( PUCHAR)::ExAllocatePool( PagedPool, m_ulSize);
		if( m_pvConfigurationData == NULL)
			FAIL;

		if( !( NT_SUCCESS( pIConfigurationTwo->pfnGetConfigurationData( pIConfigurationTwo->pvContext,
																		ATI_BIOS_CONFIGURATIONTABLE_MULTIMEDIA,
																		m_pvConfigurationData,
																		&m_ulSize))))
			FAIL;

		bResult = TRUE;

	} END_ENSURE;

	return( bResult);
}


/*^^*
 *		GetMultimediaInfo_IConfiguration1()
 * Purpose	: Get ATI Multimedia table, using IConfiguration1 interface
 *
 * Inputs	: PDEVICE_OBJECT pDeviceObject					: pointer to the creator DeviceObject
 *			  ATI_QueryPrivateInterface	pfnQueryInterface	: pointer to Query interface function
 *
 * Outputs	: BOOL, returns TRUE, if succeeded
 * Author	: IKLEBANOV
 *^^*/
BOOL CATIMultimediaTable::GetMultimediaInfo_IConfiguration1( PDEVICE_OBJECT				pDeviceObject,
															 ATI_QueryPrivateInterface	pfnQueryInterface)
{
	BOOL										bResult = FALSE;
	ATI_PRIVATE_INTERFACE_CONFIGURATION_One		iConfigurationOne;
	PATI_PRIVATE_INTERFACE_CONFIGURATION_One	pIConfigurationOne = &iConfigurationOne;

	ENSURE
	{
		iConfigurationOne.usSize = sizeof( ATI_PRIVATE_INTERFACE_CONFIGURATION_One);
		pfnQueryInterface( pDeviceObject,
						   ( const struct _GUID &)GUID_ATI_PRIVATE_INTERFACES_Configuration_One,
						   ( PVOID *)&pIConfigurationOne);

		if(( pIConfigurationOne == NULL) ||
			( pIConfigurationOne->pfnGetMultimediaConfiguration == NULL))
			FAIL;

		if( !( NT_SUCCESS( pIConfigurationOne->pfnGetMultimediaConfiguration( pIConfigurationOne->pvContext,
																			  NULL,
																			  &m_ulSize))))
			FAIL;

		if( m_ulSize != sizeof( ATI_MULTIMEDIAINFO))
			FAIL;

		m_pvConfigurationData = ( PUCHAR)::ExAllocatePool( PagedPool, m_ulSize);
		if( m_pvConfigurationData == NULL)
			FAIL;

		if( !( NT_SUCCESS( pIConfigurationOne->pfnGetMultimediaConfiguration( pIConfigurationOne->pvContext,
																			  m_pvConfigurationData,
																			  &m_ulSize))))
			FAIL;

		m_ulRevision = 0;

		bResult = TRUE;

	} END_ENSURE;

	return( bResult);
}


/*^^*
 *		GetMultimediaInfo_IConfiguration()
 * Purpose	: Get ATI Multimedia table, using IConfiguration interface
 *
 * Inputs	: PDEVICE_OBJECT pDeviceObject					: pointer to the creator DeviceObject
 *			  ATI_QueryPrivateInterface	pfnQueryInterface	: pointer to Query interface function
 *
 * Outputs	: BOOL, returns TRUE, if succeeded
 * Author	: IKLEBANOV
 *^^*/
BOOL CATIMultimediaTable::GetMultimediaInfo_IConfiguration( PDEVICE_OBJECT				pDeviceObject,
															ATI_QueryPrivateInterface	pfnQueryInterface)
{
	BOOL									bResult = FALSE;
	PATI_PRIVATE_INTERFACE_CONFIGURATION	pIConfiguration = NULL;

	ENSURE
	{
		pfnQueryInterface( pDeviceObject,
						   ( const struct _GUID &)GUID_ATI_PRIVATE_INTERFACES_Configuration,
						   ( PVOID *)&pIConfiguration);

		if(( pIConfiguration == NULL) ||
			( pIConfiguration->pfnGetMultimediaConfiguration == NULL))
			FAIL;

		if( !( NT_SUCCESS( pIConfiguration->pfnGetMultimediaConfiguration( pDeviceObject,
																		   NULL,
																		   &m_ulSize))))
			FAIL;

		if( m_ulSize != sizeof( ATI_MULTIMEDIAINFO))
			FAIL;

		m_pvConfigurationData = ( PUCHAR)::ExAllocatePool( PagedPool, m_ulSize);
		if( m_pvConfigurationData == NULL)
			FAIL;

		if( !( NT_SUCCESS( pIConfiguration->pfnGetMultimediaConfiguration( pDeviceObject,
																		   m_pvConfigurationData,
																		   &m_ulSize))))
			FAIL;

		m_ulRevision = 0;

		bResult = TRUE;

	} END_ENSURE;

	return( bResult);
}


/*^^*
 *		GetTVTunerId()
 * Purpose	: Retrieves TVTuner Id from the Multimedia configuration table
 *
 * Inputs	: PUSHORT pusTVTunerId	: pointer to return TVTuner Id
 *
 * Outputs	: BOOL, returns TRUE, if succeeded
 * Author	: IKLEBANOV
 *^^*/
BOOL CATIMultimediaTable::GetTVTunerId( PUSHORT pusTVTunerId)
{
	USHORT	usValue;
	BOOL	bResult = TRUE;

	if(( m_pvConfigurationData != NULL) && ( m_ulSize) && ( pusTVTunerId != NULL))
	{
		switch( m_ulRevision)
		{
			case 0:
				usValue = ( USHORT)(( PATI_MULTIMEDIAINFO)m_pvConfigurationData)->MMInfo_Byte0;
				break;

			case 1:
				usValue = ( USHORT)(((( PATI_MULTIMEDIAINFO1)m_pvConfigurationData)->MMInfo1_Byte0) & 0x1F);
				break;

			default:
				bResult = FALSE;
				break;
		}
	}
	else
		bResult = FALSE;

	if( bResult)
		* pusTVTunerId = usValue;
	else
	    OutputDebugError(( "CATIMultimediaTable::GetTVTunerId() fails\n"));

	return( bResult);
}


/*^^*
 *		GetVideoDecoderId()
 * Purpose	: Retrieves Video decoder Id from the Multimedia configuration table
 *
 * Inputs	: PUSHORT pusDecoderId	: pointer to return Video decoder Id
 *
 * Outputs	: BOOL, returns TRUE, if succeeded
 * Author	: IKLEBANOV
 *^^*/
BOOL CATIMultimediaTable::GetVideoDecoderId( PUSHORT pusDecoderId)
{
	USHORT	usValue;
	BOOL	bResult = TRUE;

	if(( m_pvConfigurationData != NULL) && ( m_ulSize) && ( pusDecoderId != NULL))
	{
		switch( m_ulRevision)
		{
			case 0:
				usValue = ( USHORT)(((( PATI_MULTIMEDIAINFO)m_pvConfigurationData)->MMInfo_Byte2) & 0x07);
				break;

			case 1:
				usValue = ( USHORT)(((( PATI_MULTIMEDIAINFO1)m_pvConfigurationData)->MMInfo1_Byte5) & 0x0F);
				break;

			default:
				bResult = FALSE;
				break;
		}
	}
	else
		bResult = FALSE;

	if( bResult)
		* pusDecoderId = usValue;
	else
	    OutputDebugError(( "CATIMultimediaTable::GetVideoDecoderId() fails\n"));

	return( bResult);
}


/*^^*
 *		GetOEMId()
 * Purpose	: Retrieves OEM Id from the Multimedia configuration table
 *
 * Inputs	: PUSHORT pusOEMId	: pointer to return OEM Id
 *
 * Outputs	: BOOL, returns TRUE, if succeeded
 * Author	: IKLEBANOV
 *^^*/
BOOL CATIMultimediaTable::GetOEMId( PUSHORT	pusOEMId)
{
	USHORT	usValue;
	BOOL	bResult = TRUE;

	if(( m_pvConfigurationData != NULL) && ( m_ulSize) && ( pusOEMId != NULL))
	{
		switch( m_ulRevision)
		{
			case 0:
				usValue = ( USHORT)((( PATI_MULTIMEDIAINFO)m_pvConfigurationData)->MMInfo_Byte4);
				break;

			case 1:
				usValue = ( USHORT)((( PATI_MULTIMEDIAINFO1)m_pvConfigurationData)->MMInfo1_Byte2);
				break;

			default:
				bResult = FALSE;
				break;
		}
	}
	else
		bResult = FALSE;

	if( bResult)
		* pusOEMId = usValue;
	else
	    OutputDebugError(( "CATIMultimediaTable::GetOEMId() fails\n"));

	return( bResult);
}


/*^^*
 *		GetATIProductId()
 * Purpose	: Retrieves ATI Product Id from the Multimedia configuration table
 *
 * Inputs	: PUSHORT pusProductId: pointer to return Product Id
 *
 * Outputs	: BOOL, returns TRUE, if succeeded
 * Author	: IKLEBANOV
 *^^*/
BOOL CATIMultimediaTable::GetATIProductId( PUSHORT	pusProductId)
{
	USHORT	usValue;
	BOOL	bResult = TRUE;

	if(( m_pvConfigurationData != NULL) && ( m_ulSize) && ( pusProductId != NULL))
	{
		switch( m_ulRevision)
		{
			case 0:
				usValue = ( USHORT)((((( PATI_MULTIMEDIAINFO)m_pvConfigurationData)->MMInfo_Byte3) >> 4) & 0x0F);
				break;

			case 1:
				usValue = ( USHORT)((( PATI_MULTIMEDIAINFO1)m_pvConfigurationData)->MMInfo1_Byte2);
				break;

			default:
				bResult = FALSE;
				break;
		}
	}
	else
		bResult = FALSE;

	if( bResult)
		* pusProductId = usValue;
	else
	    OutputDebugError(( "CATIMultimediaTable::GetVideoDecoderId() fails\n"));

	return( bResult);
}



/*^^*
 *		GetOEMRevisionId()
 * Purpose	: Retrieves OEM Revision Id from the Multimedia configuration table
 *
 * Inputs	: PUSHORT pusOEMRevisionId	: pointer to return OEM Revision Id
 *
 * Outputs	: BOOL, returns TRUE, if succeeded
 * Author	: IKLEBANOV
 *^^*/
BOOL CATIMultimediaTable::GetOEMRevisionId( PUSHORT	pusOEMRevisionId)
{
	USHORT	usValue;
	BOOL	bResult = TRUE;

	if(( m_pvConfigurationData != NULL) && ( m_ulSize) && ( pusOEMRevisionId != NULL))
	{
		switch( m_ulRevision)
		{
			case 0:
				usValue = ( USHORT)((( PATI_MULTIMEDIAINFO)m_pvConfigurationData)->MMInfo_Byte5);
				break;

			case 1:
				usValue = ( USHORT)((((( PATI_MULTIMEDIAINFO1)m_pvConfigurationData)->MMInfo1_Byte1) >> 5) & 0x07);
				break;

			default:
				bResult = FALSE;
				break;
		}
	}
	else
		bResult = FALSE;

	if( bResult)
		* pusOEMRevisionId = usValue;
	else
	    OutputDebugError(( "CATIMultimediaTable::GetVideoDecoderId() fails\n"));

	return( bResult);
}


/*^^*
 *		IsATIProduct()
 * Purpose	: Returnes ATI ownership
 *
 * Inputs	: PUSHORT pusProductId: pointer to return ATI Product ownership
 *
 * Outputs	: BOOL, returns TRUE, if succeeded
 * Author	: IKLEBANOV
 *^^*/
BOOL CATIMultimediaTable::IsATIProduct( PBOOL pbATIProduct)
{
	BOOL	bATIOwnership;
	BOOL	bResult = TRUE;

	if(( m_pvConfigurationData != NULL) && ( m_ulSize) && ( pbATIProduct != NULL))
	{
		switch( m_ulRevision)
		{
			case 0:
				bATIOwnership = (( PATI_MULTIMEDIAINFO)m_pvConfigurationData)->MMInfo_Byte4 == OEM_ID_ATI;
				break;

			case 1:
				bATIOwnership = ( BOOL)(((( PATI_MULTIMEDIAINFO1)m_pvConfigurationData)->MMInfo1_Byte1) & 0x10);
				break;

			default:
				bResult = FALSE;
				break;
		}
	}
	else
		bResult = FALSE;

	if( bResult)
		* pbATIProduct = bATIOwnership;
	else
	    OutputDebugError(( "CATIMultimediaTable::GetVideoDecoderId() fails\n"));

	return( bResult);
}


/*^^*
 *		QueryGPIOProvider()
 * Purpose	: queries the GPIOProvider for the pins supported and private interfaces
 *
 * Inputs	: PDEVICE_OBJECT pDeviceObject		: pointer to accosiated Device Object
 *			  GPIOINTERFACE * pGPIOInterface	: pointer to GPIO interface
 *			  PGPIOControl pgpioAccessBlock		: pointer to GPIO control structure
 *
 * Outputs	: BOOL : retunrs TRUE, if the query function was carried on successfully
 * Author	: IKLEBANOV
 *^^*/
BOOL CATIMultimediaTable::QueryGPIOProvider( PDEVICE_OBJECT		pDeviceObject,
											 GPIOINTERFACE *	pGPIOInterface,
											 PGPIOControl		pgpioAccessBlock)
{

	ENSURE
	{
		if(( pGPIOInterface->gpioOpen == NULL)		|| 
			( pGPIOInterface->gpioAccess == NULL)	||
			( pDeviceObject == NULL))
			FAIL;

		pgpioAccessBlock->Status = GPIO_STATUS_NOERROR;
		pgpioAccessBlock->Command = GPIO_COMMAND_QUERY;
		pgpioAccessBlock->AsynchCompleteCallback = NULL;
        pgpioAccessBlock->Pins = NULL;

	    if(( !NT_SUCCESS( pGPIOInterface->gpioOpen( pDeviceObject, TRUE, pgpioAccessBlock))) ||
			( pgpioAccessBlock->Status != GPIO_STATUS_NOERROR))
			FAIL;

		return( TRUE);

	} END_ENSURE;

	return( FALSE);
}


/*^^*
 *		GetDigitalAudioProperties()
 * Purpose	: Gets Digital Audio support and information
 * Inputs	: Pointer to Digital Audio Info structure	
 *
 * Outputs	: BOOL : returns TRUE
 *				also sets the requested values into the input pointer
 * Author	: TOM
 *^^*/
BOOL CATIMultimediaTable::GetDigialAudioConfiguration( PDIGITAL_AUD_INFO pInput)
{
	BOOL bResult = FALSE;

	ENSURE
	{
		if (pInput == NULL)
			FAIL;
#if 1
		if (m_pvConfigurationData == NULL)
			FAIL;
	

		switch( m_ulRevision)
		{
			case 1:

			// Disable I2S in support for the time being - TL
//				pInput->bI2SInSupported  = ( BOOL)(((( PATI_MULTIMEDIAINFO1)m_pvConfigurationData)->MMInfo1_Byte4) & 0x01);
				pInput->bI2SInSupported  = 0;
				pInput->bI2SOutSupported  = ( BOOL)(((( PATI_MULTIMEDIAINFO1)m_pvConfigurationData)->MMInfo1_Byte4) & 0x02);
				pInput->wI2S_DAC_Device = ( WORD)((((( PATI_MULTIMEDIAINFO1)m_pvConfigurationData)->MMInfo1_Byte4) & 0x1c) >> 2);
				pInput->bSPDIFSupported = ( BOOL)(((( PATI_MULTIMEDIAINFO1)m_pvConfigurationData)->MMInfo1_Byte4) & 0x20);
				pInput->wReference_Clock = ( WORD)((((( PATI_MULTIMEDIAINFO1)m_pvConfigurationData)->MMInfo1_Byte5) & 0xf0) >> 4);
				bResult = TRUE;
				break;
	
			default:
				bResult = FALSE;
				break;
		}

#else
		pInput->bI2SInSupported = TRUE;
		pInput->bI2SOutSupported = TRUE;
		pInput->wI2S_DAC_Device = TDA1309_32;
		pInput->wReference_Clock = REF_295MHZ;
		pInput->bSPDIFSupported = TRUE;
		bResult = TRUE;
#endif

	} END_ENSURE;

	return (bResult);
}


/*^^*
 *		GetVideoInCrystalId()
 * Purpose	: Retrieves Video in crystal ID from the Multimedia configuration table
 *
 * Inputs	: PUSHORT pusVInCrystalId	: pointer to return Video in crystal Id
 *
 * Outputs	: BOOL, returns TRUE, if succeeded
 * Author	: Paul
 *^^*/
BOOL CATIMultimediaTable::GetVideoInCrystalId( PUCHAR pucVInCrystalId)
{
	UCHAR	ucValue;
	BOOL	bResult = TRUE;

	if(( m_pvConfigurationData != NULL) && ( m_ulSize) && ( pucVInCrystalId != NULL))
	{
		switch( m_ulRevision)
		{
			case 0:
				ucValue = ( UCHAR)((((( PATI_MULTIMEDIAINFO)m_pvConfigurationData)->MMInfo_Byte2) & 0x18) >> 3);
				break;

			case 1:
				ucValue = ( UCHAR)((((( PATI_MULTIMEDIAINFO1)m_pvConfigurationData)->MMInfo1_Byte5) & 0xF0) >> 4);
				break;

			default:
				bResult = FALSE;
				break;
		}
	}
	else
		bResult = FALSE;

	if( bResult)
		* pucVInCrystalId = ucValue;
	else
	    OutputDebugError(( "CATIMultimediaTable::GetVideoInCrystalId() fails\n"));

	return( bResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\atishare\mmconfig.h ===
//==========================================================================;
//
//	MMCONFIG.H
//		CATIMultimediaTable Class definition.
//  Copyright (c) 1996 - 1998  ATI Technologies Inc.  All Rights Reserved.
//
//		$Date:   23 Jun 1999 11:59:52  $
//	$Revision:   1.3  $
//	  $Author:   pleung  $
//
//==========================================================================;

#ifndef _MMCONFIG_H_
#define _MMCONFIG_H_


#include "i2cgpio.h"
#include "atibios.h"
#include "atiguids.h"
#include "atidigad.h"


class CATIMultimediaTable
{
public:
	// constructor
			CATIMultimediaTable		( PDEVICE_OBJECT pDeviceObject, GPIOINTERFACE * pGPIOInterface, PBOOL pbResult);
			~CATIMultimediaTable	();
	PVOID	operator new			( size_t stSize);
	void	operator delete			( PVOID pvAllocation);

// Attributes	
private:
	ULONG		m_ulRevision;
	ULONG		m_ulSize;
	PUCHAR		m_pvConfigurationData;

// Implementation
public:
	BOOL	GetTVTunerId						( PUSHORT	pusTVTunerId);
	BOOL	GetVideoDecoderId					( PUSHORT	pusDecoderId);
	BOOL	GetOEMId							( PUSHORT	pusOEMId);
	BOOL	GetOEMRevisionId					( PUSHORT	pusOEMRevisionId);
	BOOL	GetATIProductId						( PUSHORT	pusProductId);
	BOOL	IsATIProduct						( PBOOL		pbATIProduct);
	BOOL	GetDigialAudioConfiguration			( PDIGITAL_AUD_INFO pInput);
    BOOL    GetVideoInCrystalId                 ( PUCHAR   pucVInCrystalId );  //Paul

private:
	BOOL	GetMultimediaInfo_IConfiguration2	( PDEVICE_OBJECT			pDeviceObject,
												  ATI_QueryPrivateInterface	pfnQueryInterface);
	BOOL	GetMultimediaInfo_IConfiguration1	( PDEVICE_OBJECT			pDeviceObject,
												  ATI_QueryPrivateInterface	pfnQueryInterface);
	BOOL	GetMultimediaInfo_IConfiguration	( PDEVICE_OBJECT			pDeviceObject,
												  ATI_QueryPrivateInterface	pfnQueryInterface);
	BOOL	QueryGPIOProvider					( PDEVICE_OBJECT			pDeviceObject,
												  GPIOINTERFACE *			pGPIOInterface,
												  PGPIOControl				pGPIOControl);
};

#endif // _MMCONFIG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\atishare\pinmedia.cpp ===
//==========================================================================;
//
//	PinMedia.CPP
//	WDM MiniDrivers.
//		AIW Hardware platform. 
//			Global shared in Mediums support functions inplementation
//  Copyright (c) 1996 - 1997  ATI Technologies Inc.  All Rights Reserved.
//
//==========================================================================;

extern "C"
{
#include "strmini.h"
#include "ksmedia.h"

#include "wdmdebug.h"
}

#include "wdmdrv.h"
#include "pinmedia.h"


/*^^*
 *		GetDriverInstanceNumber()
 * Purpose	: gets the instance number of the driver. I think it can be retrived from the
 *				Registry path, where Instance is a part of the PCI device address
 *
 * Inputs	:	PDEVICE_OBJECT pDeviceObject	: pointer to DeviceObject
 *
 * Outputs	: ULONG Instance of the driver
 * Author	: IKLEBANOV
 *^^*/
ULONG GetDriverInstanceNumber( PDEVICE_OBJECT pDeviceObject)
{

	return( 0);
}



/*^^*
 *		ReadPinMediumFromRegistryFolder()
 * Purpose	: Reads the pin GUID from the Registry if the default is overwritten
 *				by user .INF file. Also construct medium from this GUID and two ULONG 0.
 *
 * Inputs	:	HANDLE hFolder				: Registry folder handle
 *				ULONG nPin					: pin number to get Medium data of
 *				PKSPIN_MEDIUM pMediumKSPin	: pointer to return pin Medium data
 *
 * Outputs	: BOOL, TRUE if Registry Medium data found for this pin and valid
 * Author	: IKLEBANOV
 *^^*/
BOOL ReadPinMediumFromRegistryFolder( HANDLE hFolder, ULONG nPin, PKSPIN_MEDIUM pPinMedium)
{
    NTSTATUS        			ntStatus;
    UNICODE_STRING  			unicodeValueName, unicodeNumber, unicodeResult, unicodeGUID;
	ULONG						ulBufLength;
	PKEY_VALUE_FULL_INFORMATION pRegistryFullInfo = NULL;
	GUID						guidPin;
	WCHAR						wchBuffer[PINMEDIA_REGISTRY_BUFFER_LENGTH];
	WCHAR						wchResultBuffer[PINMEDIA_REGISTRY_BUFFER_LENGTH];

	ENSURE 
	{
		if( hFolder == NULL)
			FAIL;

		unicodeNumber.Buffer		= wchBuffer;
		unicodeNumber.MaximumLength	= sizeof( wchBuffer);
		unicodeNumber.Length		= 0;
		ntStatus = ::RtlIntegerToUnicodeString( nPin, 10, &unicodeNumber);
		if( !NT_SUCCESS( ntStatus))
			FAIL;

		::RtlInitUnicodeString( &unicodeValueName, UNICODE_WDM_REG_PIN_NUMBER);

		unicodeResult.Buffer		= wchResultBuffer;
		unicodeResult.MaximumLength	= sizeof( wchResultBuffer);
		unicodeResult.Length		= 0;

		::RtlCopyUnicodeString( &unicodeResult,
							    &unicodeValueName);

		ntStatus = ::RtlAppendUnicodeStringToString( &unicodeResult,
													 &unicodeNumber);
		if( !NT_SUCCESS( ntStatus))
			FAIL;

		ulBufLength = 0;
		ntStatus = ::ZwQueryValueKey( hFolder,
									  &unicodeResult,
									  KeyValueFullInformation,
									  pRegistryFullInfo,
									  ulBufLength, &ulBufLength);
		//
		// This call is expected to fail. It's called only to retrieve the required
		// buffer length
		//
		if( !ulBufLength || ( ulBufLength >= sizeof( KEY_VALUE_FULL_INFORMATION) + 100))
			FAIL;

		pRegistryFullInfo = ( PKEY_VALUE_FULL_INFORMATION) \
			::ExAllocatePool( PagedPool, ulBufLength);

		if( pRegistryFullInfo == NULL)
			FAIL;

		ntStatus = ::ZwQueryValueKey( hFolder,
									  &unicodeResult,
									  KeyValueFullInformation,
									  pRegistryFullInfo,
									  ulBufLength, &ulBufLength);
		if( !NT_SUCCESS( ntStatus))
			FAIL;

		if( !pRegistryFullInfo->DataLength || !pRegistryFullInfo->DataOffset)
			FAIL;

		::RtlInitUnicodeString( &unicodeGUID,
								( WCHAR*)((( PUCHAR)pRegistryFullInfo) + pRegistryFullInfo->DataOffset));

		ntStatus = ::RtlGUIDFromString( &unicodeGUID, &guidPin);
		if( !NT_SUCCESS( ntStatus))
			FAIL;

		::RtlCopyMemory( &pPinMedium->Set,
						 ( PUCHAR)&guidPin,
						 sizeof( GUID));
		pPinMedium->Id = 0;
		pPinMedium->Flags = 0;

		::ExFreePool( pRegistryFullInfo);

		return( TRUE);

	} END_ENSURE;

	if( pRegistryFullInfo != NULL)
		::ExFreePool( pRegistryFullInfo);

	return( FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\atishare\i2script.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//	I2CSCRPT.C
//	I2CScript class implementation. 
//		Main Include Module.
//
//==========================================================================;

extern "C"
{
#define INITGUID

#include "strmini.h"
#include "ksmedia.h"
#include "wdm.h"

#include "wdmdebug.h"
}

#include "i2script.h"
#include "wdmdrv.h"


/*^^*
 *		operator new
 * Purpose	: CI2CScript class overloaded operator new.
 *				Provides placement for a CI2CScript class object from the PADAPTER_DEVICE_EXTENSION
 *				allocated by the StreamClassDriver for the MiniDriver.
 *
 * Inputs	:	UINT size_t			: size of the object to be placed
 *				PVOID pAllocation	: casted pointer to the CI2CScript allocated data
 *
 * Outputs	: PVOID : pointer of the CI2CScript class object
 * Author	: IKLEBANOV
 *^^*/
PVOID CI2CScript::operator new( size_t stSize,  PVOID pAllocation)
{

	if( stSize != sizeof( CI2CScript))
	{
		OutputDebugError(( "CI2CScript: operator new() fails\n"));
		return( NULL);
	}
	else
		return( pAllocation);
}



/*^^*
 *		CI2CScript()
 * Purpose	: CI2CScript class constructor.
 *				Performs checking of the I2C provider presence. Sets the script in the initial state.
 *
 * Inputs	:	PUINT puiError						: pointer to return a completion error code
 *				PHW_STREAM_REQUEST_BLOCK	pSrb	: pointer to HW_INITIALIZE SRB
 *
 * Outputs	: none
 * Author	: IKLEBANOV
 *^^*/
CI2CScript::CI2CScript( PDEVICE_OBJECT pDeviceObject,
						PUINT puiErrorCode)
		: m_CI2CLog( pDeviceObject)
{
	m_dwI2CAccessKey = 0;

	m_i2cProviderInterface.i2cOpen = NULL;
	m_i2cProviderInterface.i2cAccess = NULL;

	m_pdoDriver = NULL;

	if( !InitializeAttachI2CProvider( &m_i2cProviderInterface, pDeviceObject))
		* puiErrorCode = WDMMINI_ERROR_NOI2CPROVIDER;
	else
	{
		// there was no error to get I2CInterface from the MiniVDD
		m_pdoDriver = pDeviceObject;
		m_ulI2CAccessClockRate = I2C_FIXED_CLOCK_RATE;
		* puiErrorCode = WDMMINI_NOERROR;
	}

    OutputDebugTrace(( "CI2CScript:CI2CScript() exit Error = %x\n", * puiErrorCode));
}



/*^^*
 *		LockI2CProvider()
 * Purpose	: locks the I2CProvider for exclusive use
 *
 * Inputs	: none
 *
 * Outputs	: BOOL : retunrs TRUE, if the I2CProvider is locked
 * Author	: IKLEBANOV
 *^^*/
BOOL CI2CScript::LockI2CProvider( void)
{
	BOOL		bResult;
	I2CControl	i2cAccessBlock;

	bResult = FALSE;

	ENSURE
	{
		if(( m_i2cProviderInterface.i2cOpen == NULL)	|| 
			( m_i2cProviderInterface.i2cAccess == NULL)	||
			( m_pdoDriver == NULL))
			FAIL;

		i2cAccessBlock.Status = I2C_STATUS_NOERROR;
		if( m_i2cProviderInterface.i2cOpen( m_pdoDriver, TRUE, &i2cAccessBlock) != STATUS_SUCCESS)
        {
            OutputDebugError(( "CI2CScript: LockI2CProvider() bResult = %x\n", bResult));
			FAIL;
        }

		if( i2cAccessBlock.Status != I2C_STATUS_NOERROR)
        {
            OutputDebugError(( "CI2CScript: LockI2CProvider() Status = %x\n", i2cAccessBlock.Status));
			FAIL;
        }

		// the I2C Provider has granted access - save dwCookie for further use
		m_dwI2CAccessKey = i2cAccessBlock.dwCookie;

		bResult = TRUE;

	} END_ENSURE;

	return( bResult);
}



/*^^*
 *		LockI2CProvider()
 * Purpose	: locks the I2CProvider for exclusive use. Provides attempts to lock the
 *				provider unless either the time-out condition or the attempt succeeded.
 *
 * Inputs	: none
 *
 * Outputs	: BOOL : retunrs TRUE, if the I2CProvider is locked
 * Author	: IKLEBANOV
 *^^*/
BOOL CI2CScript::LockI2CProviderEx( void)
{
	LARGE_INTEGER liTime, liOperationStartTime;

	liOperationStartTime.QuadPart = 0;

	while( !LockI2CProvider())
	{
		KeQuerySystemTime( &liTime);

		if( !liOperationStartTime.QuadPart)
			liOperationStartTime.QuadPart = liTime.QuadPart;
		else
			if( liTime.QuadPart - liOperationStartTime.QuadPart >
				I2CSCRIPT_TIMELIMIT_OPENPROVIDER)
			{
				// the time is expired - abort the initialization
				return( FALSE);
			}

		liTime.QuadPart = I2CSCRIPT_DELAY_OPENPROVIDER;
		KeDelayExecutionThread( KernelMode, FALSE, &liTime);
	}

	return( TRUE);
}




/*^^*
 *		GetI2CProviderLockStatus()
 * Purpose	: retrieves I2CProvider lock status
 *
 * Inputs	: none
 *
 * Outputs	: BOOL : retunrs TRUE, if the I2CProvider has been locked
 * Author	: IKLEBANOV
 *^^*/
BOOL CI2CScript::GetI2CProviderLockStatus( void)
{

	return( m_dwI2CAccessKey);
}




/*^^*
 *		ReleaseI2CProvider()
 * Purpose	: releases the I2CProvider for other clients' use
 *
 * Inputs	: none
 *
 * Outputs	: BOOL : retunrs TRUE, if the I2CProvider is released
 * Author	: IKLEBANOV
 *^^*/
BOOL CI2CScript::ReleaseI2CProvider( void)
{
	BOOL		bResult;
	I2CControl	i2cAccessBlock;

	bResult = FALSE;

	ENSURE
	{
		if(( m_i2cProviderInterface.i2cOpen == NULL)	||
			( m_i2cProviderInterface.i2cAccess == NULL) ||
			( m_pdoDriver == NULL))
			// the I2CProvider was not found
			FAIL;

		i2cAccessBlock.Status = I2C_STATUS_NOERROR;
		i2cAccessBlock.dwCookie = m_dwI2CAccessKey;
		i2cAccessBlock.ClockRate = m_ulI2CAccessClockRate;
		if( m_i2cProviderInterface.i2cOpen( m_pdoDriver, FALSE, &i2cAccessBlock) != STATUS_SUCCESS)
        {
        	OutputDebugError(( "CI2CScript: ReleaseI2CProvider() bResult = %x\n", bResult));
			FAIL;
        }

		if( i2cAccessBlock.Status != I2C_STATUS_NOERROR)
        {
        	OutputDebugError(( "CI2CScript: ReleaseI2CProvider() bResult = %x\n", bResult));
			FAIL;
        }

		m_dwI2CAccessKey = 0;
		bResult = TRUE;

	} END_ENSURE;

	return( bResult);
}



/*^^*
 *		PerformI2CPacketOperation()
 * Purpose	: synchronosly executes I2C access packet. It assumed to be executed at Low priority.
 *				The function does not return until the I2C session is done. The execution
 *				is not dependent on the I2C Provider lock status
 *		
 * Inputs	:	PI2CPacket pI2CPacket : pointer to I2C access packet
 *
 * Outputs	: BOOL : returns TRUE, if I2C operation was carried out successfuly
 *				The error status is returned via uchI2CResult field of the PI2CPacket
 * Author	: IKLEBANOV
 *^^*/
BOOL CI2CScript::PerformI2CPacketOperation( IN OUT PI2CPacket pI2CPacket)
{
	BOOL bResult;

	if( GetI2CProviderLockStatus())
		// the Provider was locked before and we're not going to change it
		bResult = ExecuteI2CPacket( pI2CPacket);
	else
	{
		// the Provider was not locked and it's our responsibility to lock it first,
		// execute I2C operation and release it after the use
		if( LockI2CProviderEx())
		{
			bResult = ExecuteI2CPacket( pI2CPacket);
			ReleaseI2CProvider();
		}
		else
			bResult = FALSE;
	}

	return( bResult);
}



/*^^*
 *		ExecuteI2CPacket()
 * Purpose	: synchronosly executes I2C access packet. It assumed to be executed at Low priority.
 *				The function does not return until the I2C session is done. This kind of access
 *				is used during initialization ( boot up) time only. This function should be
 *				called only after the I2CProvider was locked for exclusive service
 *		
 * Inputs	:	PI2CPacket pI2CPacket : pointer to I2C access packet
 *
 * Outputs	: BOOL : returns TRUE, if I2C operation was carried out successfuly
 *				The error status is returned via uchI2CResult field of the PI2CPacket
 * Author	: IKLEBANOV
 *^^*/
BOOL CI2CScript::ExecuteI2CPacket( IN OUT PI2CPacket pI2CPacket)
{
	UINT	nError, cbCount;
	UCHAR	uchValue;
	UCHAR	uchI2CResult = I2C_STATUS_ERROR;

	ENSURE
	{
		I2CControl	i2cAccessBlock;

		if(( nError = CheckI2CScriptPacket( pI2CPacket)) != I2CSCRIPT_NOERROR)
			FAIL;

		// we'll use I2CProvider interface, assuming there is a syncronous provider
		// for asynchronous provider some work has to be added. 16 bits emulation is
		// not supported at this time either. This implementation does not support
		// Read-Modify-Write request either
		ENSURE
		{
			UINT		nIndex;

			i2cAccessBlock.dwCookie = m_dwI2CAccessKey;
			i2cAccessBlock.ClockRate = m_ulI2CAccessClockRate;

			// We assume the last byte in the buffer belongs to the Write operation 
			// after Read-Modify, is specified.
			cbCount = ( pI2CPacket->usFlags & I2COPERATION_READWRITE) ?
							( pI2CPacket->cbWriteCount - 1) : ( pI2CPacket->cbWriteCount);

			if( cbCount)
			{
				// implement a write request
				// apply START condition with the I2C chip address first
				i2cAccessBlock.Flags = I2C_FLAGS_START | I2C_FLAGS_ACK;
				i2cAccessBlock.Command = I2C_COMMAND_WRITE;
				i2cAccessBlock.Data = pI2CPacket->uchChipAddress & 0xFE;
				if( AccessI2CProvider( m_pdoDriver, &i2cAccessBlock) != I2C_STATUS_NOERROR)
					FAIL;

				i2cAccessBlock.Flags = I2C_FLAGS_ACK;
				for( nIndex = 0; nIndex < cbCount; nIndex ++)
				{
					// write the data from the buffer
					i2cAccessBlock.Data = pI2CPacket->puchWriteBuffer[nIndex];
					if(( nIndex == cbCount - 1) &&
						!( pI2CPacket->usFlags & I2COPERATION_RANDOMACCESS))
						// the last byte to write - apply STOP condition, if no
						// I2COPERATION_RANDOMACCESS flag is specified
						i2cAccessBlock.Flags |= I2C_FLAGS_STOP;

					if( AccessI2CProvider( m_pdoDriver, &i2cAccessBlock) != I2C_STATUS_NOERROR)
						break;
				}
				if( nIndex != cbCount)
					FAIL;
/*	// STOP condition is applied withe the last byte to be written
				// apply stop condition as the end of write operation
				i2cAccessBlock.Flags = I2C_FLAGS_STOP;
				i2cAccessBlock.Command = I2C_COMMAND_NULL;
				m_i2cProviderInterface.i2cAccess( m_pdoDriver, &i2cAccessBlock);
*/
			}

			if( pI2CPacket->cbReadCount)
			{
				// implement a read request
				// apply START condition with the I2C chip address first
				i2cAccessBlock.Flags = I2C_FLAGS_START | I2C_FLAGS_ACK;
				i2cAccessBlock.Command = I2C_COMMAND_WRITE;
				i2cAccessBlock.Data = pI2CPacket->uchChipAddress | 0x01;
				if( AccessI2CProvider( m_pdoDriver, &i2cAccessBlock) != I2C_STATUS_NOERROR)
					FAIL;

				i2cAccessBlock.Flags = I2C_FLAGS_ACK;
				i2cAccessBlock.Command = I2C_COMMAND_READ;
				for( nIndex = 0; nIndex < pI2CPacket->cbReadCount; nIndex ++)
				{
					// read the data to the buffer
					if( nIndex == ( UINT)( pI2CPacket->cbReadCount - 1))
					{
						// don't apply ACK at the last read - read operation termination
						i2cAccessBlock.Flags &= ~I2C_FLAGS_ACK;
						// also apply STOP condition for the last byte
						i2cAccessBlock.Flags |= I2C_FLAGS_STOP;
					}

					if( AccessI2CProvider( m_pdoDriver, &i2cAccessBlock) != I2C_STATUS_NOERROR)
						break;
					pI2CPacket->puchReadBuffer[nIndex] = i2cAccessBlock.Data;
				}
				if( nIndex != pI2CPacket->cbReadCount)
					FAIL;

/*	// STOP condition is applied with the last byte to be read
				// apply stop condition as the end of read operation
				i2cAccessBlock.Flags = I2C_FLAGS_STOP;
				i2cAccessBlock.Command = I2C_COMMAND_NULL;
				m_i2cProviderInterface.i2cAccess( m_pdoDriver, &i2cAccessBlock);
*/
				if( pI2CPacket->usFlags & I2COPERATION_READWRITE)
				{
					// write operation should be taken care again, the last byte in the pbyWriteBuffer
					// should be constructed from the value read back and the binary operations OR and AND
					// with the values specified in the packet
					uchValue = pI2CPacket->puchReadBuffer[pI2CPacket->cbReadCount - 1];
					uchValue &= pI2CPacket->uchANDValue;
					pI2CPacket->puchWriteBuffer[pI2CPacket->cbWriteCount - 1] = uchValue | pI2CPacket->uchORValue;

					if( pI2CPacket->cbWriteCount)
					{
						// implement a write request
						// apply START condition with the I2C chip address first
						i2cAccessBlock.Flags = I2C_FLAGS_START | I2C_FLAGS_ACK;
						i2cAccessBlock.Command = I2C_COMMAND_WRITE;
						i2cAccessBlock.Data = pI2CPacket->uchChipAddress & 0xFE;
						if( AccessI2CProvider( m_pdoDriver, &i2cAccessBlock) != I2C_STATUS_NOERROR)
							FAIL;

						i2cAccessBlock.Flags = I2C_FLAGS_ACK;
						for( nIndex = 0; nIndex < pI2CPacket->cbWriteCount; nIndex ++)
						{
							// write the data from the buffer
							i2cAccessBlock.Data = pI2CPacket->puchWriteBuffer[nIndex];
							if( nIndex == ( UINT)( pI2CPacket->cbWriteCount - 1))
								// the last byte to write - apply STOP condition
								i2cAccessBlock.Flags |= I2C_FLAGS_STOP;

							if( AccessI2CProvider( m_pdoDriver, &i2cAccessBlock) != I2C_STATUS_NOERROR)
								break;
						}

						if( nIndex != pI2CPacket->cbWriteCount)
							FAIL;
/*	// STOP condition is applied withe the last byte to be written
						// apply stop condition as the end of write operation
						i2cAccessBlock.Flags = I2C_FLAGS_STOP;
						i2cAccessBlock.Command = I2C_COMMAND_NULL;
						m_i2cProviderInterface.i2cAccess( m_pdoDriver, &i2cAccessBlock);
*/
					}
				}
			}

			uchI2CResult = I2C_STATUS_NOERROR;

		} END_ENSURE;

		if( uchI2CResult == I2C_STATUS_ERROR)
		{
			// there was an error during accessing I2C - issue Reset command
			i2cAccessBlock.Command = I2C_COMMAND_RESET;
			AccessI2CProvider( m_pdoDriver, &i2cAccessBlock);
		}
		
		pI2CPacket->uchI2CResult = uchI2CResult;

		return( TRUE);

	} END_ENSURE;

	OutputDebugTrace(( "CI2CScript:ExecuteI2CPacket() nError = %x", nError));
	return( FALSE);
}



/*^^*
 *		CheckI2CScriptPacket()
 * Purpose	: checks integrity of the I2C control package
 *
 * Inputs	:	PI2CPacket pI2CPacket	: pointer to I2C access packet
 *
 * Outputs	: BOOL : returns TRUE, if I2C control package is a valid one
 *
 * Author	: IKLEBANOV
 *^^*/
UINT CI2CScript::CheckI2CScriptPacket( IN PI2CPacket pI2CPacket)
{
	UINT nPacketError;

	ENSURE
	{
		if(( m_i2cProviderInterface.i2cOpen == NULL)	||
			( m_i2cProviderInterface.i2cAccess == NULL)	||
			( m_pdoDriver == NULL))
		{
			// the I2CProvider was not found
			nPacketError = I2CSCRIPT_ERROR_NOPROVIDER;
			FAIL;
		}

		if(( !pI2CPacket->cbWriteCount) && ( !pI2CPacket->cbReadCount))
		{
			// nothing to do
			nPacketError = I2CSCRIPT_ERROR_NODATA;
			FAIL;
		}

		if((( pI2CPacket->cbWriteCount) && ( pI2CPacket->puchWriteBuffer == NULL))
			|| (( pI2CPacket->cbReadCount) && ( pI2CPacket->puchReadBuffer == NULL)))
		{
			// NULL pointer, when the data is specified
			nPacketError = I2CSCRIPT_ERROR_NOBUFFER;
			FAIL;
		}

		if(( pI2CPacket->usFlags & I2COPERATION_READWRITE) && ( !pI2CPacket->cbWriteCount))
		{
			// if Read-Modify-Write is specified, the Write data should be present
			nPacketError = I2CSCRIPT_ERROR_READWRITE;
			FAIL;
		}

		nPacketError = I2CSCRIPT_NOERROR;

	} END_ENSURE;

	return( nPacketError);
}




/*^^*
 *		ClearScript()
 * Purpose	: clears I2CScript to the NULL state - no I2C operations are on hold.
 *
 * Inputs	:	none
 *
 * Outputs	: none
 * Author	: IKLEBANOV
 *^^*/
void CI2CScript::ClearScript( void)
{

	m_nExecutionIndex = 0;
	m_nScriptLength = 0;
	m_pfnReturnWhenDone = NULL;
	m_bExecutionInProcess = FALSE;
}



/*^^*
 *		AppendToScript()
 * Purpose	: appends a I2CPacket to the bottom of the I2CScript.
 *				The 16 bits emulation is not implemented at this time.
 *
 * Inputs	:	PI2CPacket pI2CPacket - pointer to the I2C packet to append
 *
 * Outputs	: BOOL : returns TRUE, if the packet was successfully appended.
 *				FALSE might happend if the I2CPacket is a bad one, or overflow occurs
 * Author	: IKLEBANOV
 *^^*/
BOOL CI2CScript::AppendToScript( PI2CPacket pI2CPacket)
{
	UINT	nError, nScriptIndex;
	UINT	nIndex, cbCount;
	
	ENSURE
	{
		PI2CScriptPrimitive pI2CPrimitive;

		if(( nError = CheckI2CScriptPacket( pI2CPacket)) != I2CSCRIPT_NOERROR)
			FAIL;
		nError = I2CSCRIPT_ERROR_OVERFLOW;

		// m_nExecutionIndex is used as a Script build index. We will work with a local copy of it
		// first to ensure we have no overflow
		nScriptIndex = m_nExecutionIndex;
		pI2CPrimitive = &m_i2cScript[nScriptIndex];

		// We assume the last byte in the buffer belongs to the Write operation 
		// after Read-Modify, is specified.
		cbCount = ( pI2CPacket->usFlags & I2COPERATION_READWRITE) ?	\
						( pI2CPacket->cbWriteCount - 1) : ( pI2CPacket->cbWriteCount);

		if( cbCount)
		{
			// I2C Chip address should be taken care of first
			pI2CPrimitive->ulCommand = I2C_COMMAND_WRITE;
			pI2CPrimitive->byData = pI2CPacket->uchChipAddress;
			pI2CPrimitive->byANDData = 0xFE;
			pI2CPrimitive->byORData = 0x00;
			pI2CPrimitive->ulProviderFlags = I2C_FLAGS_START | I2C_FLAGS_ACK;
			pI2CPrimitive->byFlags = 0x0;

			// check the Script length
			if( ++ nScriptIndex >= I2CSCRIPT_LENGTH_MAXIMUM)
				FAIL;
			pI2CPrimitive ++;

			// I2C write buffer should be taken care of.
			for( nIndex = 0; nIndex < cbCount; nIndex ++)
			{
				pI2CPrimitive->ulCommand = I2C_COMMAND_WRITE;
				pI2CPrimitive->byData = pI2CPacket->puchWriteBuffer[nIndex];
				pI2CPrimitive->byORData = 0x00;
				pI2CPrimitive->byANDData = 0xFF;
				pI2CPrimitive->ulProviderFlags = I2C_FLAGS_ACK;
				pI2CPrimitive->byFlags = 0x0;

				if( nIndex == cbCount - 1)
					// this is the last byte to be written - apply STOP
					pI2CPrimitive->ulProviderFlags |= I2C_FLAGS_STOP;

				// check the Script length
				if( ++ nScriptIndex >= I2CSCRIPT_LENGTH_MAXIMUM)
					break;
				pI2CPrimitive ++;
			}

			// check the Script length
			if( nScriptIndex >= I2CSCRIPT_LENGTH_MAXIMUM)
				FAIL;

/*
	// Stop condition is applied with the last byte to be written
	// We finished Write portion here, whether it's a Write only, Read-Modify-Write operation
			pI2CPrimitive->ulCommand = I2C_COMMAND_NULL;
			pI2CPrimitive->ulProviderFlags = I2C_FLAGS_STOP;
			pI2CPrimitive->byFlags = 0x0;
		
			// check the Script length
			if( ++ nScriptIndex >= I2CSCRIPT_LENGTH_MAXIMUM)
				FAIL;
			pI2CPrimitive ++;
*/
		}

		// We have to see, if there is a Read operation involved
		if( pI2CPacket->cbReadCount)
		{
			// I2C Chip address should be taken care of first
			pI2CPrimitive->ulCommand = I2C_COMMAND_WRITE;
			pI2CPrimitive->byData = pI2CPacket->uchChipAddress;
			pI2CPrimitive->byANDData = 0xFE;
			pI2CPrimitive->byORData = 0x01;
			pI2CPrimitive->ulProviderFlags = I2C_FLAGS_START | I2C_FLAGS_ACK;
			pI2CPrimitive->byFlags = 0x0;

			// check the Script length
			if( ++ nScriptIndex >= I2CSCRIPT_LENGTH_MAXIMUM)
				FAIL;
			pI2CPrimitive ++;

			// I2C read buffer should be taken care of. We assume the last byte in the buffer belongs to
			// the Write operation after Read-Modify, is specified.
			for( nIndex = 0; nIndex < pI2CPacket->cbReadCount; nIndex ++)
			{
				pI2CPrimitive->ulCommand = I2C_COMMAND_READ;
				if( nIndex == ( UINT)( pI2CPacket->cbReadCount - 1))
				{
					pI2CPrimitive->ulProviderFlags = I2C_FLAGS_STOP;
					pI2CPrimitive->byFlags = pI2CPacket->usFlags & I2COPERATION_READWRITE;
				}
				else
				{
					pI2CPrimitive->ulProviderFlags = I2C_FLAGS_ACK;
					pI2CPrimitive->byFlags = 0x0;
				}

				// check the Script length
				if( ++ nScriptIndex >= I2CSCRIPT_LENGTH_MAXIMUM)
					break;
				pI2CPrimitive ++;
			}

			// check the Script length
			if( nScriptIndex >= I2CSCRIPT_LENGTH_MAXIMUM)
				FAIL;

/*	// Stop condition is applied with the last byte to be read
			// We finished Read portion here, whether it's a Read only, Read-Modify-Write operation
			pI2CPrimitive->ulCommand = I2C_COMMAND_NULL;
			pI2CPrimitive->ulProviderFlags = I2C_FLAGS_STOP;
			pI2CPrimitive->byFlags = 0x0;
		
			// check the Script length
			if( ++ nScriptIndex >= I2CSCRIPT_LENGTH_MAXIMUM)
				FAIL;
			pI2CPrimitive ++;
*/
		}
		
		// the last thing left to do, is to implement Write after Read-Modify, if specified
		if( pI2CPacket->usFlags & I2COPERATION_READWRITE)
		{
			// I2C Chip address should be taken care of first
			pI2CPrimitive->ulCommand = I2C_COMMAND_WRITE;
			pI2CPrimitive->byData = pI2CPacket->uchChipAddress;
			pI2CPrimitive->byANDData = 0xFE;
			pI2CPrimitive->byORData = 0x00;
			pI2CPrimitive->ulProviderFlags = I2C_FLAGS_START | I2C_FLAGS_ACK;
			pI2CPrimitive->byFlags = 0x0;

			// check the Script length
			if( ++ nScriptIndex >= I2CSCRIPT_LENGTH_MAXIMUM)
				FAIL;
			pI2CPrimitive ++;

			// I2C write buffer should be taken care of.
			for( nIndex = 0; nIndex < pI2CPacket->cbWriteCount; nIndex ++)
			{
				pI2CPrimitive->ulCommand = I2C_COMMAND_WRITE;
				pI2CPrimitive->byData = pI2CPacket->puchWriteBuffer[nIndex];
				pI2CPrimitive->ulProviderFlags = I2C_FLAGS_ACK;
				if( nIndex == ( UINT)( pI2CPacket->cbWriteCount - 1))
				{
					// it's time to write the byte modified after the Read operation
					pI2CPrimitive->byORData = pI2CPacket->uchORValue;
					pI2CPrimitive->byANDData = pI2CPacket->uchANDValue;
					pI2CPrimitive->byFlags = I2COPERATION_READWRITE;
					// apply STOP condition with the last byte to be read
					pI2CPrimitive->ulProviderFlags |= I2C_FLAGS_STOP;
				}
				else
				{
					pI2CPrimitive->byORData = 0x00;
					pI2CPrimitive->byANDData = 0xFF;
					pI2CPrimitive->byFlags = 0x0;
				}

				// check the Script length
				if( ++ nScriptIndex >= I2CSCRIPT_LENGTH_MAXIMUM)
					break;
				pI2CPrimitive ++;
			}

			// check the Script length
			if( nScriptIndex >= I2CSCRIPT_LENGTH_MAXIMUM)
				FAIL;

/*	// Stop condition is applied with the last byte to be written
			// We finished Write portion here, whether it's a Write only, Read-Modify-Write operation
			pI2CPrimitive->ulCommand = I2C_COMMAND_NULL;
			pI2CPrimitive->ulProviderFlags = I2C_FLAGS_STOP;
			pI2CPrimitive->byFlags = 0x0;
		
			// check the Script length
			if( ++ nScriptIndex >= I2CSCRIPT_LENGTH_MAXIMUM)
				FAIL;
			pI2CPrimitive ++;
*/
		}

		// the Packet was added succesfully to the Script. Modify the Script propertirs
		m_nExecutionIndex = nScriptIndex;
		m_nScriptLength = nScriptIndex;
		return( TRUE);

	} END_ENSURE;

	OutputDebugTrace(( "CI2CScript:AppendToScript() nError = %x", nError));
	return( FALSE);
}



/*^^*
 *		ExecuteScript()
 * Purpose	: triggers the execution of previously built I2CScript. This function is also
 *				responsible for allocating I2CProvider for its own exclusive use.
 *
 * Inputs	:	PHW_STREAM_REQUEST_BLOCK	pSrb		: pointer to the current SRB
 *				PHWCompletionRoutine pfnScriptCompletion: function pointer will be called,
 *					when the script execution is completed. Indicates the Script execution
 *					is to be carried out asynchronously.
 *
 * Outputs	: BOOL : returns TRUE, if the execution was successfully triggered.
 *				FALSE might happend if the Script has not been built by the time of the call
 *
 * Note		: if pfnScriptExecuted is NULL pointer, the Script will be executed synchronously
 *
 * Author	: IKLEBANOV
 *^^*/
BOOL CI2CScript::ExecuteScript(	IN PHW_STREAM_REQUEST_BLOCK	pSrb,
								IN PHWCompletionRoutine		pfnScriptCompletion)
{

	ENSURE
	{
		if( pfnScriptCompletion != NULL)
			// not supported at this point. The idea is to create a new system thread,
			// where the Script to be executed. When the Script will be copleted,
			// call-back is called and the thred terminates itself.
			FAIL;

		if( !m_nExecutionIndex)
			FAIL;

		// there is not a NULL Script - proceed
		m_nScriptLength = m_nExecutionIndex;
		m_nExecutionIndex = m_nCompletionIndex = 0;

		if( !GetI2CProviderLockStatus())
			// The provider was not locked prior the Script execution
			if( !LockI2CProviderEx())
				FAIL;

		InterpreterScript();

		ReleaseI2CProvider();
	
		return( TRUE);

	} END_ENSURE;

	return( FALSE);
}



/*^^*
 *		InterpreterScript()
 * Purpose	: interpreters the I2CScript line by line. The Script is not cleaned up 
 *				after the completion to allow to client retrive the results of 
 *				the script execution. It's the client responsibility to clean it up
 *				upon the results retrieving
 *
 * Inputs	: none
 * Outputs	: none
 *
 * Author	: IKLEBANOV
 *^^*/
void CI2CScript::InterpreterScript( void)
{
	UINT		nScriptIndex, nIndex;
	I2CControl	i2cAccessBlock;

	m_bExecutionInProcess = TRUE;
	
	i2cAccessBlock.dwCookie = m_dwI2CAccessKey;
	i2cAccessBlock.ClockRate = m_ulI2CAccessClockRate;
		
	// We'll interpreter every line of the Script and call the I2C Provider to
	// execute it. It's assumed the I2CProvider is a syncronous one. If it's not the
	// case, the special care should be taken of based upon returned value I2C_STATUS_BUSY
	// in the Status.
	for( nScriptIndex = 0; nScriptIndex < m_nScriptLength; nScriptIndex ++)
	{
		i2cAccessBlock.Command = m_i2cScript[nScriptIndex].ulCommand;
		i2cAccessBlock.Flags = m_i2cScript[nScriptIndex].ulProviderFlags;
		if( i2cAccessBlock.Command == I2C_COMMAND_WRITE)
		{
			i2cAccessBlock.Data = m_i2cScript[nScriptIndex].byData;
			i2cAccessBlock.Data &= m_i2cScript[nScriptIndex].byANDData;
			i2cAccessBlock.Data |= m_i2cScript[nScriptIndex].byORData;
		}

		if( AccessI2CProvider( m_pdoDriver, &i2cAccessBlock) == I2C_STATUS_ERROR)
			break;

		// check, wether it's a Read operation - save result
		if( i2cAccessBlock.Command == I2C_COMMAND_READ)
		{
			m_i2cScript[nScriptIndex].byData = i2cAccessBlock.Data;
			// check, if this data belongs to Read-Modify-Write operation
			if( m_i2cScript[nScriptIndex].byFlags & I2COPERATION_READWRITE)
			{
				// let's look for the next I2COPERATION_READWRITE flag - it is the pair
				for( nIndex = nScriptIndex; nIndex < m_nScriptLength; nIndex ++)
					if(( m_i2cScript[nIndex].ulCommand == I2C_COMMAND_WRITE) &&
						( m_i2cScript[nIndex].byFlags & I2COPERATION_READWRITE))
						break;

				if( nIndex >= m_nScriptLength)
					// the Script got corrupted
					break;

				m_i2cScript[nIndex].byData = i2cAccessBlock.Data;
			}
		}
	}

	m_nCompletionIndex = nScriptIndex;

	m_bExecutionInProcess = FALSE;
}



/*^^*
 *		AccessI2CProvider()
 * Purpose	: provide synchronous type of access to I2CProvider
 *
 * Inputs	:	PDEVICE_OBJECT pdoDriver	: pointer to the client's device object
 *				PI2CControl pi2cAccessBlock	: pointer to a composed I2C access block
 *
 * Outputs	: UINT : status of the I2C operation I2C_STATUS_NOERROR or I2C_STATUS_ERROR
 *
 * Author	: IKLEBANOV
 *^^*/
UINT CI2CScript::AccessI2CProvider( PDEVICE_OBJECT pdoClient, PI2CControl pi2cAccessBlock)
{
	UINT			uiStatus;
	LARGE_INTEGER	liTime;

	do
	{
		// this loop is infinitive. It has to be taken care of
		if( m_i2cProviderInterface.i2cAccess( pdoClient, pi2cAccessBlock) != STATUS_SUCCESS)
		{
			uiStatus = I2C_STATUS_ERROR;
			break;
		}

		if( pi2cAccessBlock->Status != I2C_STATUS_BUSY)
		{
			uiStatus = pi2cAccessBlock->Status;
			break;
		}

		liTime.QuadPart = I2CSCRIPT_DELAY_GETPROVIDERSTATUS;
		::KeDelayExecutionThread( KernelMode, FALSE, &liTime);

		pi2cAccessBlock->Command = I2C_COMMAND_STATUS;

	} while( TRUE);

	return( uiStatus);
}



/*^^*
 *		GetScriptResults()
 * Purpose	: returns result of the executed Script
 *				This function idealy is called twice:
 *					first time with the puchReadBuffer = NULL to retrive the number of bytes read
 *					second time - to fill in the pointer
 * Inputs	:	PUINT puiReadCount	: pointer to the counter of the bytes were read
 *				PUCH puchReadBuffer	: pointer to the buffer to put the data
 *
 * Outputs	: UINT : status of the I2C operation
 *				If the status is I2C_STATUS_ERROR, puiReadCount will contain the step, where
 *				I2CScript failed
 * Author	: IKLEBANOV
 *^^*/
UINT CI2CScript::GetScriptResults( PUINT puiReadCount, PUCHAR puchReadBuffer)
{
	UINT nScriptIndex, nCount;

	ASSERT( puiReadCount != NULL);

	if( m_bExecutionInProcess)
		return( I2C_STATUS_BUSY);

	if( m_nScriptLength != m_nCompletionIndex)
	{
		// if the case of failure, step where I2CScript failed is return
		// instead of Read Counter. The returned status indicates the
		// failure
		* puiReadCount = m_nCompletionIndex;

		return( I2C_STATUS_ERROR);
	}
	else
	{
		nCount = 0;

		for( nScriptIndex = 0; nScriptIndex < m_nCompletionIndex; nScriptIndex ++)
		{
			if( m_i2cScript[nScriptIndex].ulCommand == I2C_COMMAND_READ)
			{
				if( puchReadBuffer != NULL)
					// fill in the supplied buffer
					puchReadBuffer[nCount] = m_i2cScript[nScriptIndex].byData;
				nCount ++;
			}
		}

		* puiReadCount = nCount;

		return( I2C_STATUS_NOERROR);
	}
}



/*^^*
 *		InitializeAttachI2CProvider()
 * Purpose	: gets the pointer to the parent I2C Provider interface using
 *				several IRP_MJ_??? functions.
 *				This function will be called at Low priority
 *
 * Inputs	:	I2CINTERFACE * pI2CInterface	: pointer to the Interface to be filled in
 *				PDEVICE_OBJECT pDeviceObject	: MiniDriver device object, which is a child of I2C Master
 *
 * Outputs	: BOOL  - returns TRUE, if the interface was found
 * Author	: IKLEBANOV
 *^^*/
BOOL CI2CScript::InitializeAttachI2CProvider( I2CINTERFACE * pI2CInterface, PDEVICE_OBJECT pDeviceObject)
{
	BOOL bResult;

	bResult = LocateAttachI2CProvider( pI2CInterface, pDeviceObject, IRP_MJ_PNP);
	if(( pI2CInterface->i2cOpen == NULL) || ( pI2CInterface->i2cAccess == NULL))
	{
		TRAP;
		OutputDebugError(( "CI2CScript(): interface has NULL pointers\n"));
		bResult = FALSE;
	}

	return( bResult);
}



/*^^*
 *		LocateAttachI2CProvider()
 * Purpose	: gets the pointer to the parent I2C Provider interface
 *				This function will be called at Low priority
 *
 * Inputs	:	I2CINTERFACE * pI2CInterface	: pointer to the Interface to be filled in
 *				PDEVICE_OBJECT pDeviceObject	: MiniDriver device object, which is a child of I2C Master
 *				int 		nIrpMajorFunction	: IRP major function to query the I2C Interface
 *
 * Outputs	: BOOL  - returns TRUE, if the interface was found
 * Author	: IKLEBANOV
 *^^*/
BOOL CI2CScript::LocateAttachI2CProvider( I2CINTERFACE * pI2CInterface, PDEVICE_OBJECT pDeviceObject, int nIrpMajorFunction)
{
	PIRP	pIrp;
	BOOL	bResult = FALSE;

	ENSURE
	{
		PIO_STACK_LOCATION	pNextStack;
		NTSTATUS			ntStatus;
		KEVENT				Event;
			
			
		pIrp = IoAllocateIrp( pDeviceObject->StackSize, FALSE);
		if( pIrp == NULL)
		{
			TRAP;
			OutputDebugError(( "CI2CScript(): can not allocate IRP\n"));
			FAIL;
		}

		pNextStack = IoGetNextIrpStackLocation( pIrp);
		if( pNextStack == NULL)
		{
			TRAP;
			OutputDebugError(( "CI2CScript(): can not allocate NextStack\n"));
			FAIL;
		}

		pIrp->IoStatus.Status = STATUS_NOT_SUPPORTED;
		pNextStack->MajorFunction = (UCHAR)nIrpMajorFunction;
		pNextStack->MinorFunction = IRP_MN_QUERY_INTERFACE;
		KeInitializeEvent( &Event, NotificationEvent, FALSE);

		IoSetCompletionRoutine(	pIrp,
								I2CScriptIoSynchCompletionRoutine,
								&Event, TRUE, TRUE, TRUE);

		pNextStack->Parameters.QueryInterface.InterfaceType = ( struct _GUID *)&GUID_I2C_INTERFACE;
		pNextStack->Parameters.QueryInterface.Size = sizeof( I2CINTERFACE);
		pNextStack->Parameters.QueryInterface.Version = 1;
		pNextStack->Parameters.QueryInterface.Interface = ( PINTERFACE)pI2CInterface;
		pNextStack->Parameters.QueryInterface.InterfaceSpecificData = NULL;

		ntStatus = IoCallDriver( pDeviceObject, pIrp);

		if( ntStatus == STATUS_PENDING)
			KeWaitForSingleObject(	&Event,
									Suspended, KernelMode, FALSE, NULL);
		if(( pI2CInterface->i2cOpen == NULL) || ( pI2CInterface->i2cAccess == NULL))
			FAIL;

		bResult = TRUE;

	} END_ENSURE;
 
	if( pIrp != NULL)
		IoFreeIrp( pIrp);

	return( bResult);
}


/*^^*
 *		I2CScriptIoSynchCompletionRoutine()
 * Purpose	: This routine is for use with synchronous IRP processing.
 *				All it does is signal an event, so the driver knows it and can continue.
 *
 * Inputs	:	PDEVICE_OBJECT DriverObject	: Pointer to driver object created by system
 *				PIRP pIrp					: Irp that just completed
 *				PVOID Event					: Event we'll signal to say Irp is done
 *
 * Outputs	: none
 * Author	: IKLEBANOV
 *^^*/
extern "C"
NTSTATUS I2CScriptIoSynchCompletionRoutine(	IN PDEVICE_OBJECT pDeviceObject,
											IN PIRP pIrp,
											IN PVOID Event)
{

    KeSetEvent(( PKEVENT)Event, 0, FALSE);
    return( STATUS_MORE_PROCESSING_REQUIRED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\atishare\registry.cpp ===
//==========================================================================;
//
//	Registry.CPP
//	WDM MiniDrivers development.
//		Global space.
//			Registry data management.
//  Copyright (c) 1996 - 1997  ATI Technologies Inc.  All Rights Reserved.
//
//		$Date:   15 Apr 1999 11:08:06  $
//	$Revision:   1.6  $
//	  $Author:   Tashjian  $
//
//==========================================================================;

#include "common.h"

#include "registry.h"


ULONG	g_DebugLevel;
PCHAR	g_DebugComponent = WDM_DRIVER_NAME " not set in registry: ";


/*^^*
 *		OpenRegistryFolder()
 * Purpose	: Gets the specified Registry folder handle ( opens the folder) to be used later on
 *
 * Inputs	: PDEVICE_OBJECT pDeviceObject	: pointer to DeviceObject
 *			  PWCHAR pwchFolderName			: name of the Registry folder to open, might be NULL
 * Outputs	: HANDLE, NULL if the Registry folder has not been opened
 * Author	: IKLEBANOV
 *^^*/
HANDLE OpenRegistryFolder( PDEVICE_OBJECT pDeviceObject, PWCHAR pwchFolderName)
{
	HANDLE				hFolder, hDevice;
	NTSTATUS			ntStatus;
    UNICODE_STRING		FolderName;
	OBJECT_ATTRIBUTES	attr;

	hFolder = hDevice = NULL;

	ENSURE
	{
		ntStatus = ::IoOpenDeviceRegistryKey( pDeviceObject,
											  PLUGPLAY_REGKEY_DRIVER, STANDARD_RIGHTS_ALL,
											  &hDevice);

    	if( !NT_SUCCESS( ntStatus) || ( hDevice == NULL))
			FAIL;

		if( pwchFolderName != NULL)
		{
			::RtlInitUnicodeString( &FolderName, pwchFolderName);
			InitializeObjectAttributes( &attr, &FolderName, OBJ_INHERIT, hDevice, NULL);

			ntStatus = ::ZwOpenKey( &hFolder, KEY_QUERY_VALUE, &attr);
			::ZwClose( hDevice);

			if( !NT_SUCCESS( ntStatus)) 
				FAIL;
		}
		else
			hFolder = hDevice;

		return( hFolder);

	} END_ENSURE;

	return( NULL);
}



/*^^*
 *		SetMiniDriverDebugLevel()
 * Purpose	: Sets the Debugging level required by user
 *
 * Inputs	: PUNICODE_STRING pRegistryPath	: MiniDriver's private Registry path
 * Outputs	: none
 *
 * Author	: IKLEBANOV
 *^^*/
extern "C"
void SetMiniDriverDebugLevel( PUNICODE_STRING pRegistryPath)
{
	OBJECT_ATTRIBUTES	objectAttributes;
	HANDLE				hFolder;
	ULONG				ulValue;
	WCHAR				wcDriverName[20];

	// Set the default value as no Debug
	g_DebugLevel = 0;

    InitializeObjectAttributes( &objectAttributes, 
		                        pRegistryPath, 
				                OBJ_CASE_INSENSITIVE, 
						        NULL, 
							    NULL); 

	if( NT_SUCCESS( ZwOpenKey( &hFolder, KEY_READ, &objectAttributes)))
	{
		ulValue = 0;

		if( NT_SUCCESS( ReadStringFromRegistryFolder( hFolder,
													  UNICODE_WDM_DEBUGLEVEL_INFO,
													  ( PWCHAR)&ulValue,
													  sizeof( ULONG))))
			g_DebugLevel = ulValue;

		// fetch the driver name from the registry
		if( NT_SUCCESS( ReadStringFromRegistryFolder( hFolder,
													  UNICODE_WDM_DRIVER_NAME,
													  wcDriverName,
													  sizeof(wcDriverName)))) {

			// set g_DebugComponent by using driver name
			ANSI_STRING		stringDriverName;
			UNICODE_STRING  unicodeDriverName;

			// convert unicode driver name to ansi
			RtlInitAnsiString(&stringDriverName, g_DebugComponent);
			RtlInitUnicodeString(&unicodeDriverName, wcDriverName);
			RtlUnicodeStringToAnsiString(&stringDriverName, &unicodeDriverName, FALSE);

			// remove extension and put a colon 
			PCHAR pExt = strchr(g_DebugComponent, '.');
			if (pExt) {
				*pExt++ = ':';
				*pExt++	= ' ';
				*pExt	= 0;
			}

			// convert to upper case (or lower case... whatever your fancy)
			//_strupr(g_DebugComponent);  
			//_strlwr(g_DebugComponent);  
		}
		ZwClose( hFolder);
	}

}



/*^^*
 *		ReadStringFromRegistryFolder
 * Purpose	: Read ASCII string from the Registry folder
 *
 * Inputs	: HANDLE hFolder			: Registry folder handle to read the values from
 *			  PWCHAR pwcKeyNameString	: pointer to the StringValue to read
 *			  PWCHAR pwchBuffer			: pointer to the buffer to read into
 *			  ULONG ulDataLength		: length of the data to be expected to read
 *
 * Outputs	: NTSTATUS of the registry read operation
 * Author	: IKLEBANOV
 *^^*/
NTSTATUS ReadStringFromRegistryFolder( HANDLE hFolder, PWCHAR pwcKeyNameString, PWCHAR pwchBuffer, ULONG ulDataLength)
{
    NTSTATUS        			ntStatus = STATUS_UNSUCCESSFUL;
    UNICODE_STRING  			unicodeKeyName;
    ULONG           			ulLength;
    PKEY_VALUE_FULL_INFORMATION FullInfo;

	ENSURE 
	{
		::RtlInitUnicodeString( &unicodeKeyName, pwcKeyNameString);

    	ulLength = sizeof( KEY_VALUE_FULL_INFORMATION) + unicodeKeyName.MaximumLength + ulDataLength;

		FullInfo = ( PKEY_VALUE_FULL_INFORMATION)::ExAllocatePool( PagedPool, ulLength);

    	if( FullInfo) 
		{
			ntStatus = ::ZwQueryValueKey( hFolder,
										  &unicodeKeyName,
										  KeyValueFullInformation,
										  FullInfo,
										  ulLength,
										  &ulLength);

        	if( NT_SUCCESS( ntStatus)) 
			{
            	if( ulDataLength >= FullInfo->DataLength) 
                	RtlCopyMemory( pwchBuffer, (( PUCHAR)FullInfo) + FullInfo->DataOffset, FullInfo->DataLength);
				else 
				{
                	TRAP;
                	ntStatus = STATUS_BUFFER_TOO_SMALL;
				} // buffer right length

			} // if success

			::ExFreePool( FullInfo);
    	}
		else
		{
			ntStatus = STATUS_NO_MEMORY;
		}

	} END_ENSURE;

    return( ntStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\atishare\register.h ===
#pragma once

//==========================================================================;
//
//	Declarations of the RT Register manipulation classes
//
//		$Date:   11 Mar 1999 12:48:20  $
//	$Revision:   1.1  $
//	  $Author:   Tashjian  $
//
// $Copyright:	(c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

extern "C" {
	#include "strmini.h"
	#include "ksmedia.h"
}

#include "Provider.h"

/*
 * Type: RegisterType
 * Purpose: A type to differentiate between diferent kinds of registers.
 *   Depending on the type register may not peforms certain operations
 *   RW - read/write, RO - read-only, WO - write-only
*/
typedef enum { RW, RO, WO, RR } RegisterType;


class Register
{
public:
	Register(Provider * provider, DWORD offset, RegisterType type) :
		m_Provider(provider),
		m_dwOffset(offset),
		m_Type(type),
		m_bShadow(false) {};

	DWORD Read() {
		m_bShadow = true;
		return m_dwShadow = m_Provider->Read(m_dwOffset);
	}

	void Write(DWORD dwValue) {
		m_bShadow = true;
		m_Provider->Write(m_dwOffset, m_dwShadow = dwValue);
	}

	operator DWORD() 
	{
#if 1 //def _DEBUG
		return Read();
#else
		return m_bShadow ? m_dwShadow : Read();
#endif
	}

	DWORD operator=(DWORD dwValue) {
		Write(dwValue);
		return dwValue;
	}

private:
	static DWORD m_dwBaseAddress;

	Provider*	m_Provider;
	DWORD		m_dwOffset;
	bool		m_bShadow;
	DWORD		m_dwShadow;
	RegisterType m_Type;
};


class BitField
{
	private:
		Register&	m_Register;
		DWORD		m_FieldMask;
		BYTE		m_LowBit;

	public:
		BitField(Register& reg, DWORD fieldMask, BYTE lowBit) :
			m_Register(reg), m_FieldMask(fieldMask), m_LowBit(lowBit) {}

		operator DWORD() {
			return (m_Register & m_FieldMask) >> m_LowBit;
		}

		DWORD operator=(DWORD dwValue) { 
			m_Register = m_Register & ~m_FieldMask | dwValue << m_LowBit;
			return dwValue;
		}

		DWORD Read() {
			m_Register.Read();
			return DWORD();
		}
};


class IntField
{
	private:
		Register&	m_Register;
		DWORD		m_FieldMask;
		DWORD		m_HighBitMask;
		BYTE		m_LowBit;

	public:
		IntField(Register& reg, LONG fieldMask, BYTE lowBit, DWORD highBitMask) :
			m_Register(reg), m_FieldMask(fieldMask), m_LowBit(lowBit), m_HighBitMask(highBitMask) {}

		operator LONG() {
			if (m_HighBitMask & m_Register)
				return -1 * (((~m_Register & m_FieldMask) >> m_LowBit) + 1);
			else
				return (m_Register & m_FieldMask) >> m_LowBit;
		}

		LONG operator=(LONG lValue) {
			m_Register = (m_Register & ~m_FieldMask) | ((lValue << m_LowBit) & m_FieldMask);
			return lValue;
		}

		DWORD Read() {
			m_Register.Read();
			return LONG();
		}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\atishare\pinmedia.h ===
//==========================================================================;
//
//	PinMedia.H
//	WDM MiniDriver development
//		AIW / AIWPro hardware platform. 
//			ATI connections GUIDs Include Module.
//  Copyright (c) 1996 - 1998  ATI Technologies Inc.  All Rights Reserved.
//
//==========================================================================;

#ifndef _PINMEDIA_H_
#define _PINMEDIA_H_


#define WDM_REG_PIN_MEDIUMS					"Mediums"
#define UNICODE_WDM_REG_PIN_MEDIUMS			L"Mediums"

#define WDM_REG_PIN_NUMBER					"Pin"
#define UNICODE_WDM_REG_PIN_NUMBER			L"Pin"

#define PINMEDIA_REGISTRY_BUFFER_LENGTH		16


/*
	TVTuner, XBar, and TVAudio Medium definitions
*/

// {F3954420-34F6-11d1-821D-0000F8300212}
#define STATIC_MEDIUM_ATIXBAR_VIDEOTUNERIN \
 0xf3954420, 0x34f6, 0x11d1,  0x82, 0x1d, 0x0, 0x0, 0xf8, 0x30, 0x2, 0x12
DEFINE_GUIDSTRUCT( "F3954420-34F6-11D1-821D-0000F8300212", MEDIUM_ATIXBAR_VIDEOTUNERIN);
#define MEDIUM_ATXBAR_VIDEOTUNERIN DEFINE_GUIDNAMED( MEDIUM_ATIXBAR_VIDEOTUNERIN)


// {F3954421-34F6-11d1-821D-0000F8300212}
#define STATIC_MEDIUM_ATIXBAR_AUDIOTUNERIN \
 0xf3954421, 0x34f6, 0x11d1,  0x82, 0x1d, 0x0, 0x0, 0xf8, 0x30, 0x2, 0x12 
DEFINE_GUIDSTRUCT( "F3954421-34F6-11D1-821D-0000F8300212", MEDIUM_VIDEO_ATIXBAR_AUDIOTUNERIN);
#define MEDIUM_ATXBAR_AUDIOTUNERIN DEFINE_GUIDNAMED( MEDIUM_ATIXBAR_AUDIOTUNERIN)


// {6001AFE0-39A7-11D1-821D-0000F8300212}
#define STATIC_MEDIUM_ATIXBAR_VIDEOCOMPOSITEOUT \
	0x6001afe0, 0x39a7, 0x11d1,  0x82, 0x1d, 0x0, 0x0, 0xf8, 0x30, 0x2, 0x12
DEFINE_GUIDSTRUCT( "6001AFE0-39A7-11D1-821D-0000F8300212", MEDIUM_ATIXBAR_VIDEOCOMPOSITEOUT);
#define MEDIUM_ATXBAR_VIDEOCOMPOSITEOUT DEFINE_GUIDNAMED( MEDIUM_ATIXBAR_VIDEOCOMPOSITEOUT)


// {6001AFE1-39A7-11D1-821D-0000F8300212}
#define STATIC_MEDIUM_ATIXBAR_VIDEOSVIDEOOUT \
	0x6001afe1, 0x39a7, 0x11d1,  0x82, 0x1d, 0x0, 0x0, 0xf8, 0x30, 0x2, 0x12
DEFINE_GUIDSTRUCT( "6001AFE1-39A7-11D1-821D-0000F8300212", MEDIUM_ATIXBAR_VIDEOSVIDEOOUT);
#define MEDIUM_ATXBAR_VIDEOSVIDEOOUT DEFINE_GUIDNAMED( MEDIUM_ATIXBAR_VIDEOSVIDEOOUT)


// {AE8F28C0-3346-11D1-821D-0000F8300212}
#define STATIC_MEDIUM_ATIXBAR_VIDEOTUNEROUT \
	0xae8f28c0, 0x3346, 0x11d1,  0x82, 0x1d, 0x0, 0x0, 0xf8, 0x30, 0x2, 0x12
DEFINE_GUIDSTRUCT( "AE8F28C0-3346-11D1-821D-0000F8300212", MEDIUM_ATIXBAR_VIDEOTUNEROUT);
#define MEDIUM_ATXBAR_VIDEOTUNEROUT DEFINE_GUIDNAMED( MEDIUM_ATIXBAR_VIDEOTUNEROUT)


// {AE8F28C1-3346-11D1-821D-0000F8300212}
#define STATIC_MEDIUM_ATIXBAR_AUDIODECODEROUT \
	0xae8f28c1, 0x3346, 0x11d1,  0x82, 0x1d, 0x0, 0x0, 0xf8, 0x30, 0x2, 0x12 
DEFINE_GUIDSTRUCT( "AE8F28C1-3346-11D1-821D-0000F8300212", MEDIUM_ATIXBAR_AUDIODECODEROUT);
#define MEDIUM_ATXBAR_AUDIODECODEROUT DEFINE_GUIDNAMED( MEDIUM_ATIXBAR_AUDIODECODEROUT)


// {F3954422-34F6-11D1-821D-0000F8300212}
#define STATIC_MEDIUM_ATITVTUNER_RADIOAUDIOOUT \
 0xf3954422, 0x34f6, 0x11d1,  0x82, 0x1d, 0x0, 0x0, 0xf8, 0x30, 0x2, 0x12 
DEFINE_GUIDSTRUCT("F3954422-34F6-11D1-821D-0000F8300212", MEDIUM_VIDEO_ATITVTUNER_RADIOAUDIOOUT);
#define MEDIUM_ATXBAR_RADIOAUDIOOUT DEFINE_GUIDNAMED( MEDIUM_ATITVTUNER_RADIOAUDIOOUT)


// {F3954423-34F6-11d1-821D-0000F8300212}
#define STATIC_MEDIUM_ATITVTUNER_TVAUDIOOUT \
 0xf3954423, 0x34f6, 0x11d1,  0x82, 0x1d, 0x0, 0x0, 0xf8, 0x30, 0x2, 0x12 
DEFINE_GUIDSTRUCT( "F3954423-34F6-11D1-821D-0000F8300212", MEDIUM_VIDEO_ATITVTUNER_TVAUDIOOUT);
#define MEDIUM_ATITVTUNER_TVAUDIOOUT DEFINE_GUIDNAMED( MEDIUM_ATITVTUNER_TVAUDIOOUT)


const KSPIN_MEDIUM ATIXBarVideoTunerInMedium =
{
	STATIC_MEDIUM_ATIXBAR_VIDEOTUNERIN,
	0,
	0
};

const KSPIN_MEDIUM ATIXBarAudioTunerInMedium =
{
	STATIC_MEDIUM_ATIXBAR_AUDIOTUNERIN,
	0,
	0
};

const KSPIN_MEDIUM ATIXBarVideoCompositeOutMedium =
{
	STATIC_MEDIUM_ATIXBAR_VIDEOCOMPOSITEOUT,
	0,
	0
};

const KSPIN_MEDIUM ATIXBarVideoSVideoOutMedium =
{
	STATIC_MEDIUM_ATIXBAR_VIDEOSVIDEOOUT,
	0,
	0
};

const KSPIN_MEDIUM ATIXBarVideoTunerOutMedium =
{
	STATIC_MEDIUM_ATIXBAR_VIDEOTUNEROUT,
	0,
	0
};

const KSPIN_MEDIUM ATIXBarAudioDecoderOutMedium =
{
	STATIC_GUID_NULL,
	0,
	0
};

const KSPIN_MEDIUM ATITVTunerRadioAudioOutMedium =
{
	STATIC_MEDIUM_ATITVTUNER_RADIOAUDIOOUT,
	0,
	0
};

const KSPIN_MEDIUM ATITVTunerTVAudioOutMedium =
{
	STATIC_MEDIUM_ATITVTUNER_TVAUDIOOUT,
	0,
	0
};

const KSPIN_MEDIUM MEDIUM_WILDCARD =
{
    STATIC_GUID_NULL,
    0,
	0
};

// compatible mediums between ATITVTuner and ATIXBar
#define ATITVTunerVideoOutMedium	ATIXBarVideoTunerInMedium
#define ATITVAudioInMedium			ATITVTunerTVAudioOutMedium			
#define ATITVAudioOutMedium			ATIXBarAudioTunerInMedium

// Pin Mediums support functions prototypes
ULONG		GetDriverInstanceNumber			( PDEVICE_OBJECT pDeviceObject);
HANDLE		OpenRegistryPinMediumFolder		( PDEVICE_OBJECT pDeviceObject, PWCHAR pwchFolderName);
BOOL		ReadPinMediumFromRegistryFolder	( HANDLE hFolder, ULONG nPin, PKSPIN_MEDIUM pMediumKSPin);


#endif	// _PINMEDIA_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\atishare\tda9851.h ===
//==========================================================================;
//
//	TDA98501.H
//	WDM TVAudio MiniDriver.
//		AIW / AIWPro hardware platform. 
//			Philips TDA9851 Stereo decoder Include Module.
//  Copyright (c) 1996 - 1998  ATI Technologies Inc.  All Rights Reserved.
//
//		$Date:   15 Apr 1998 14:05:54  $
//	$Revision:   1.1  $
//	  $Author:   KLEBANOV  $
//
//==========================================================================;

#ifndef _ATIAUDIO_TDA9851_H_
#define _ATIAUDIO_TDA9851_H_

// TDA9851 CONTROL SETTINGS:                                    
#define	TDA9851_AU_MODE_MASK			0xFE	// Mask for Audio Mode Selection (Bit0)
#define	TDA9851_STEREO					0x01	// Set Stereo
#define	TDA9851_MONO					0x00	// Set Mono	
#define	TDA9851_STEREO_DETECTED			0x01 	// Stereo is detected.

#define	TDA9851_MUTE_MASK				0xFD	// Mask for Mute on TDA9851.(Bit1)
#define	TDA9851_MUTE					0x02    // Mute   at OUTR and OUTL.
#define	TDA9851_UNMUTE					0x00    // Unmute at OUTR and OUTL.

#define	TDA9851_AVL_MASK				0xFB	// Mask for AVL. (Bit2)
#define	TDA9851_AVL_ON					0x04	// Auto Volume Level Addjustment ON.
#define	TDA9851_AVL_OFF					0x00	// Auto Volume Level Addjustment OFF.
                                             
#define	TDA9851_CCD_MASK				0xF7	// Mask for CCD bit setting. (Bit3)
#define	TDA9851_NORMAL_CURRENT			0x00	// Load current for normal AVL decay.
#define	TDA9851_INCREASED_CURRENT		0x08	// Increased load current.           

#define TDA9851_AVL_ATTACK_MASK			0xCF	// Mask for AVL ATTACK. (Bit4,5)
#define	TDA9851_AVL_ATTACK_420			0x00	// AVL Attack time 420  ohm.
#define	TDA9851_AVL_ATTACK_730			0x10    // AVL Attack time 730  ohm.
#define	TDA9851_AVL_ATTACK_1200			0x20    // AVL Attack time 1200 ohm.
#define	TDA9851_AVL_ATTACK_2100			0x30	// AVL Attack time 2100 ohm.

					 
#define AUDIO_TDA9851_DefaultValue		( TDA9851_AVL_ATTACK_730	|	\
										  TDA9851_STEREO)

// Status register definitions
#define AUDIO_TDA9851_Indicator_Stereo	0x01

#define	AUDIO_TDA9851_Control_Stereo	TDA9851_STEREO

#endif // _ATIAUDIO_TDA9851_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\atishare\tda9850.h ===
//==========================================================================;
//
//	TDA9850.H
//	WDM TVAudio MiniDriver.
//		AIW / AIWPro hardware platform. 
//			Philips TDA9850 Stereo/SAP decoder Include Module.
//  Copyright (c) 1996 - 1998  ATI Technologies Inc.  All Rights Reserved.
//
//==========================================================================;

#ifndef _ATIAUDIO_TDA9850_H_
#define _ATIAUDIO_TDA9850_H_

enum
{
	AUDIO_TDA9850_Reg_Control1 = 0x04,
	AUDIO_TDA9850_Reg_Control2,
	AUDIO_TDA9850_Reg_Control3,
	AUDIO_TDA9850_Reg_Control4,
	AUDIO_TDA9850_Reg_Align1,
	AUDIO_TDA9850_Reg_Align2,
	AUDIO_TDA9850_Reg_Align3

};

// Control3 register definitions
#define AUDIO_TDA9850_Control_SAP				0x80
#define AUDIO_TDA9850_Control_Stereo			0x40
#define AUDIO_TDA9850_Control_SAP_Mute			0x10
#define AUDIO_TDA9850_Control_Mute				0x08

// Status register definitions
#define AUDIO_TDA9850_Indicator_Stereo			0x20
#define AUDIO_TDA9850_Indicator_SAP				0x40


#define AUDIO_TDA9850_Control1_DefaultValue		0x0F		// stereo 16
#define AUDIO_TDA9850_Control2_DefaultValue		0x0F		// sap 16
#define AUDIO_TDA9850_Control3_DefaultValue		AUDIO_TDA9850_Control_Stereo		// stereo, no mute
#define AUDIO_TDA9850_Control4_DefaultValue		0x07		// +2.5
#define AUDIO_TDA9850_Align1_DefaultValue		0x00		// normal gain
#define AUDIO_TDA9850_Align2_DefaultValue		0x00		// normal gain
#define AUDIO_TDA9850_Align3_DefaultValue		0x03		// stereo decoder operation mode / nominal

#endif // _ATIAUDIO_TDA9850_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\atishare\registry.h ===
//==========================================================================;
//
// File:		REGISTRY.H
//
// Purpose:		To provide Header file for ATI WDM Registry configurations
//
// Notes:		This file is provided under strict non-disclosure agreements
//				it is and remains the property of ATI Technologies Inc.
//				Any use of this file or the information it contains to
//				develop products commercial or otherwise must be with the
//				permission of ATI Technologies Inc.
//
// Copyright (C) 1997 - 1998, ATI Technologies Inc.
//
//==========================================================================;

#define	REGISTRY_BUFFER_SIZE				6

#define	WDM_REGISTRY_KEY					"ATI WDM Configurations"

#define	WDM_REG_MULTIMEDIA					"ATI WDM Configurations\\Multimedia Table"
#define	UNICODE_WDM_REG_MULTIMEDIA			L"ATI WDM Configurations\\Multimedia Table"

#define	WDM_REG_MM_TUNER					"Tuner Type"
#define	UNICODE_WDM_REG_MM_TUNER			L"Tuner Type"

#define	WDM_REG_MM_DECODER					"Decoder Type"
#define	UNICODE_WDM_REG_MM_DECODER			L"Decoder Type"

#define WDM_REG_MM_DECODER_CRYSTALS			"Decoder Crystals Type"
#define UNICODE_WDM_REG_MM_DECODER_CRYSTALS	L"Decoder Crystals Type"

#define	WDM_REG_MM_AUDIO					"Audio Chip Type"
#define	UNICODE_WDM_REG_MM_AUDIO			L"Audio Chip Type"

#define	WDM_REG_MM_OEM						"OEM Id"
#define	UNICODE_WDM_REG_MM_OEM				L"OEM Id"

#define	WDM_REG_MM_ATI_PRODUCT				"ATI Product Id"
#define	UNICODE_WDM_REG_MM_ATI_PRODUCT		L"ATI Product Id"

#define WDM_REG_MM_PRODUCT_REVISION			"Product Revision Id"
#define UNICODE_WDM_REG_MM_PRODUCT_REVISION	L"Product Revision Id"

#define WDM_REG_MM_BYTE1					"MMTableByte1"
#define UNICODE_WDM_REG_MM_BYTE1			L"MMTableByte1"

#define WDM_REG_MM_BYTE6					"MMTableByte6"
#define UNICODE_WDM_REG_MM_BYTE6			L"MMTableByte6"

#define WDM_REG_MM_BYTE7					"MMTableByte7"
#define UNICODE_WDM_REG_MM_BYTE7			L"MMTableByte7"

#define WDM_REG_I2C							"ATI WDM Configurations\\I2C Configuration"
#define UNICODE_WDM_REG_I2C					L"ATI WDM Configurations\\I2C Configuration"

#define WDM_REG_I2C_METHOD					"I2C Method"
#define UNICODE_WDM_REG_I2C_METHOD			L"I2C Method"

#define WDM_REG_TVOUT						"ATI WDM Configurations\\TVOut Configuration"
#define UNICODE_WDM_REG_TVOUT				L"ATI WDM Configurations\\TVOut Configuration"

#define WDM_REG_TVOUT_INFO					"TVOut Information"
#define UNICODE_WDM_REG_TVOUT_INFO			L"TVOut Information"

#define WDM_DEBUGLEVEL_INFO					"DebugLevel"
#define UNICODE_WDM_DEBUGLEVEL_INFO			L"DebugLevel"

#define WDM_DRIVER_NAME						"NTMPDriver"
#define UNICODE_WDM_DRIVER_NAME				L"NTMPDriver"

#define WDM_I2CLOG_ENABLE					"I2CLog Enable"
#define UNICODE_WDM_I2CLOG_ENABLE			L"I2CLog Enable"

#define WDM_I2CLOG_FILENAME					"I2CLog FileName"
#define UNICODE_WDM_I2CLOG_FILENAME			L"I2CLog FileName"

#define WDM_I2CLOG_DEFAULTEXTENSION			"i2c"
#define UNICODE_WDM_I2CLOG_DEFAULTEXTENSION	L"i2c"

#define WDM_I2CLOG_ABSOLUTEPATH				"\\SystemRoot\\system32\\drivers\\"
#define UNICODE_WDM_I2CLOG_ABSOLUTEPATH		L"\\SystemRoot\\system32\\drivers\\"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\atishare\wdmdebug.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996 - 1998  ATI Technologies Inc.  All Rights Reserved.
//
//==========================================================================;


#ifndef _WDMDEBUG_H_
#define _WDMDEBUG_H_

#define TRAP DEBUG_BREAKPOINT();

// global variables
extern "C" ULONG	g_DebugLevel;


#define OutputDebugTrace(x)	{ if( g_DebugLevel >= MINIDRIVER_DEBUGLEVEL_MESSAGE)	DbgPrint x; }

#define OutputDebugInfo(x)	{ if( g_DebugLevel >= MINIDRIVER_DEBUGLEVEL_INFO)	DbgPrint x; }

#define OutputDebugError(x)	{ if( g_DebugLevel >= MINIDRIVER_DEBUGLEVEL_ERROR)	DbgPrint x; }


#endif // #ifndef _WDMDEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\atishare\wdmdrv.h ===
//==========================================================================;
//
//	WDMDRV.H
//	WDM Capture Class Driver definitions. 
//		Main Include Module.
//  Copyright (c) 1996 - 1998  ATI Technologies Inc.  All Rights Reserved.
//
//==========================================================================;

#ifndef _WDMDRV_H_
#define _WDMDRV_H_


#define ENSURE		do
#define END_ENSURE	while( FALSE)
#define FAIL		break

// WDM MiniDriver Error codes
#define WDMMINI_NOERROR					0x0000
#define WDMMINI_INVALIDPARAM			0x0010
#define WDMMINI_NOHARDWARE				0x0020
#define WDMMINI_UNKNOWNHARDWARE			0x0021
#define WDMMINI_HARDWAREFAILURE			0x0022
#define WDMMINI_ERROR_NOI2CPROVIDER		0x0040
#define WDMMINI_ERROR_NOGPIOPROVIDER	0x0041
#define WDMMINI_ERROR_MEMORYALLOCATION	0x0080

// global space functions definition
ULONG		GetDriverInstanceNumber			( PDEVICE_OBJECT pDeviceObject);
HANDLE		OpenRegistryFolder				( PDEVICE_OBJECT pDeviceObject, PWCHAR pwchFolderName);
NTSTATUS	ReadStringFromRegistryFolder	( HANDLE hFolder, PWCHAR pwcKeyNameString, PWCHAR pwchBuffer, ULONG ulDataLength);
void		OutputDebugMessage				( ULONG ulDebugLevel, PCCHAR DebugMessage, ...);
											 
extern "C"
void		SetMiniDriverDebugLevel			( PUNICODE_STRING pRegistryPath);

// DebugLevel
#define MINIDRIVER_DEBUGLEVEL_ERROR		0x0001
#define MINIDRIVER_DEBUGLEVEL_INFO		0x0003
#define MINIDRIVER_DEBUGLEVEL_MESSAGE	0x0005


#endif	// _WDMDRV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\bt-829\capdebug.h ===
#pragma once

//==========================================================================;
//
//	WDM Video Decoder debug tools
//
//		$Date:   05 Aug 1998 11:22:36  $
//	$Revision:   1.0  $
//	  $Author:   Tashjian  $
//
// $Copyright:	(c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;


#ifdef DEBUG

#include "debugdef.h"

#ifdef _X86_
#define TRAP()          __asm int 3
#else
#define TRAP()          KdBreakPoint()
#endif

extern "C" ULONG g_DebugLevel;

#define DBGPRINTF(x)    {KdPrint(x);}
#define DBGERROR(x)     {KdPrint((DBG_COMPONENT)); KdPrint(x);}
#define DBGWARN(x)      {if (g_DebugLevel >= 1) {KdPrint((DBG_COMPONENT)); KdPrint(x);}}
#define DBGINFO(x)      {if (g_DebugLevel >= 2) {KdPrint((DBG_COMPONENT)); KdPrint(x);}}
#define DBGTRACE(x)     {if (g_DebugLevel >= 3) {KdPrint((DBG_COMPONENT)); KdPrint(x);}}

#else

#define TRAP()

#define DBGPRINTF(x)
#define DBGERROR(x)
#define DBGWARN(x)
#define DBGINFO(x)
#define DBGTRACE(x)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\bt-829\capstrm.h ===
#pragma once

//==========================================================================;
//
//	CWDMCaptureStream - Capture Stream base class declarations
//
//		$Date:   22 Feb 1999 15:48:16  $
//	$Revision:   1.1  $
//	  $Author:   KLEBANOV  $
//
// $Copyright:	(c) 1997 - 1999  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

#include "i2script.h"
#include "aticonfg.h"

#include "VidStrm.h"


typedef enum {
    ChangeComplete,
    Starting,
    Closing,
    Running,
    Pausing,
    Stopping,
    Initializing
};


#define DD_OK 0


class CWDMCaptureStream : public CWDMVideoStream
{
public:
	CWDMCaptureStream(PHW_STREAM_OBJECT pStreamObject,
						CWDMVideoDecoder * pCWDMVideoDecoder,
						PUINT puiErrorCode)
		:	CWDMVideoStream(pStreamObject, pCWDMVideoDecoder, puiErrorCode) {}

	void Startup(PUINT puiErrorCode);
	void Shutdown();

	VOID STREAMAPI VideoReceiveDataPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb);
	void TimeoutPacket(IN OUT PHW_STREAM_REQUEST_BLOCK pSrb);

	VOID VideoSetState(PHW_STREAM_REQUEST_BLOCK, BOOL bVPConnected, BOOL bVPVBIConnected);
	VOID VideoGetProperty(PHW_STREAM_REQUEST_BLOCK);

	VOID VideoStreamGetConnectionProperty (PHW_STREAM_REQUEST_BLOCK);
	VOID VideoStreamGetDroppedFramesProperty(PHW_STREAM_REQUEST_BLOCK);

	VOID DataLock(PKIRQL pIrql) {
	    KeAcquireSpinLock(&m_streamDataLock, pIrql);
	}

	VOID DataUnLock(KIRQL Irql) {
	    KeReleaseSpinLock(&m_streamDataLock, Irql);
	}

	void CloseCapture();

	void CancelPacket( PHW_STREAM_REQUEST_BLOCK);

protected:
    UINT                        m_stateChange;

    KSPIN_LOCK                  m_streamDataLock;

    // Incoming SRBs go here
    LIST_ENTRY                  m_incomingDataSrbQueue;

    // SRBs in DDraw-land are moved to this queue
    LIST_ENTRY                  m_waitQueue;

    // During some state transitions, we need to 
    // temporarily move SRBs here (purely for the
    // purpose of reordering them) before being
    // returned to the incomingDataSrbQueue.
    LIST_ENTRY                  m_reversalQueue;

    // for synchronizing state changes
    KEVENT                      m_specialEvent;
    KEVENT                      m_SrbAvailableEvent;
    KEVENT                      m_stateTransitionEvent;
    
    // We get this from Ddraw
    HANDLE                      m_hCapture;

private:

	BOOL FlushBuffers();
	BOOL ResetFieldNumber();
	BOOL ReleaseCaptureHandle();
	VOID EmptyIncomingDataSrbQueue();
	VOID HandleStateTransition();
	void AddBuffersToDirectDraw();
	BOOL AddBuffer(PHW_STREAM_REQUEST_BLOCK);
	VOID HandleBusmasterCompletion(PHW_STREAM_REQUEST_BLOCK);
	VOID TimeStampSrb(PHW_STREAM_REQUEST_BLOCK);

	virtual void ResetFrameCounters() = 0;
	virtual ULONG GetFrameSize() = 0;
	virtual void GetDroppedFrames(PKSPROPERTY_DROPPEDFRAMES_CURRENT_S pDroppedFrames) = 0;
	virtual BOOL GetCaptureHandle() = 0;
	virtual ULONG GetFieldInterval() = 0;
	virtual void SetFrameInfo(PHW_STREAM_REQUEST_BLOCK) = 0;

	void ThreadProc();
	static void ThreadStart(CWDMCaptureStream *pStream)
			{	pStream->ThreadProc();	}

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\bt-829\capvbi.h ===
#pragma once

//==========================================================================;
//
//	CWDMVBICaptureStream - VBI Capture Stream class declarations
//
//		$Date:   05 Aug 1998 11:22:46  $
//	$Revision:   1.0  $
//	  $Author:   Tashjian  $
//
// $Copyright:	(c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

#include "i2script.h"
#include "aticonfg.h"

#include "CapStrm.h"


class CWDMVBICaptureStream : public CWDMCaptureStream
{
public:
	CWDMVBICaptureStream(PHW_STREAM_OBJECT pStreamObject,
						CWDMVideoDecoder * pCWDMVideoDecoder,
						PKSDATAFORMAT pKSDataFormat,
						PUINT puiErrorCode);
	~CWDMVBICaptureStream();

	void * operator new(size_t size, void * pAllocation) { return(pAllocation);}
	void operator delete(void * pAllocation) {}

private:
	PKS_VBIINFOHEADER		m_pVBIInfoHeader;    //
	KS_VBI_FRAME_INFO       m_VBIFrameInfo;
	BOOL					m_bVBIinitialized;

	void ResetFrameCounters();
	ULONG GetFrameSize() { return m_pVBIInfoHeader->BufferSize; }
	void GetDroppedFrames(PKSPROPERTY_DROPPEDFRAMES_CURRENT_S pDroppedFrames);
	BOOL GetCaptureHandle();
	VOID SetFrameInfo(PHW_STREAM_REQUEST_BLOCK);
	ULONG GetFieldInterval() { return 1; }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\bt-829\capvideo.cpp ===
//==========================================================================;
//
//	CWDMVideoCaptureStream - Video Capture Stream class implementation
//
//		$Date:   05 Aug 1998 11:11:00  $
//	$Revision:   1.0  $
//	  $Author:   Tashjian  $
//
// $Copyright:	(c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

extern "C"
{
#include "strmini.h"
#include "ksmedia.h"

#include "ddkmapi.h"
}

#include "wdmvdec.h"
#include "wdmdrv.h"
#include "aticonfg.h"
#include "capdebug.h"
#include "defaults.h"
#include "winerror.h"

CWDMVideoCaptureStream::CWDMVideoCaptureStream(PHW_STREAM_OBJECT pStreamObject,
						CWDMVideoDecoder * pCWDMVideoDecoder,
						PKSDATAFORMAT pKSDataFormat,
						PUINT puiErrorCode)
		:	CWDMCaptureStream(pStreamObject, pCWDMVideoDecoder, puiErrorCode)
{
    m_stateChange = Initializing;

	DBGTRACE(("CWDMVideoCaptureStream::Startup()\n"));

    PKS_DATAFORMAT_VIDEOINFOHEADER  pVideoInfoHeader = 
                (PKS_DATAFORMAT_VIDEOINFOHEADER) pKSDataFormat;
    PKS_VIDEOINFOHEADER     pVideoInfoHdrRequested = 
                &pVideoInfoHeader->VideoInfoHeader;

    // Since the VIDEOINFOHEADER is of potentially variable size
    // allocate memory for it

    UINT nSize = KS_SIZE_VIDEOHEADER(pVideoInfoHdrRequested);

    DBGINFO(("pVideoInfoHdrRequested=%x\n", pVideoInfoHdrRequested));
    DBGINFO(("KS_VIDEOINFOHEADER size=%d\n", nSize));
    DBGINFO(("Width=%d  Height=%d  BitCount=%d\n", 
                pVideoInfoHdrRequested->bmiHeader.biWidth,
                pVideoInfoHdrRequested->bmiHeader.biHeight,
                pVideoInfoHdrRequested->bmiHeader.biBitCount));
    DBGINFO(("biSizeImage=%d\n", 
                pVideoInfoHdrRequested->bmiHeader.biSizeImage));
    DBGINFO(("AvgTimePerFrame=%d\n", 
                pVideoInfoHdrRequested->AvgTimePerFrame));

    m_pVideoInfoHeader = (PKS_VIDEOINFOHEADER)ExAllocatePool(NonPagedPool, nSize);

    if (m_pVideoInfoHeader == NULL) {
        DBGERROR(("ExAllocatePool failed\n"));
		*puiErrorCode = WDMMINI_ERROR_MEMORYALLOCATION;
		return;
    }

    // Copy the VIDEOINFOHEADER requested to our storage
    RtlCopyMemory(
            m_pVideoInfoHeader,
            pVideoInfoHdrRequested,
            nSize);

	MRect t(0, 0,   pVideoInfoHdrRequested->bmiHeader.biWidth,
					pVideoInfoHdrRequested->bmiHeader.biHeight);
	m_pDevice->SetRect(t);

	Startup(puiErrorCode);
}

CWDMVideoCaptureStream::~CWDMVideoCaptureStream()
{
	DBGTRACE(("CWDMVideoCaptureStream::~CWDMVideoCaptureStream()\n"));

	Shutdown();

    if (m_pVideoInfoHeader) {
        ExFreePool(m_pVideoInfoHeader);
        m_pVideoInfoHeader = NULL;
    }
}


BOOL CWDMVideoCaptureStream::GetCaptureHandle()
{    
    int streamNumber = m_pStreamObject->StreamNumber;

    if (m_hCapture == 0)
    {
        DBGTRACE(("Stream %d getting capture handle\n", streamNumber));
        
        DDOPENVPCAPTUREDEVICEIN  ddOpenCaptureIn;
        DDOPENVPCAPTUREDEVICEOUT ddOpenCaptureOut;

        RtlZeroMemory(&ddOpenCaptureIn, sizeof(ddOpenCaptureIn));
        RtlZeroMemory(&ddOpenCaptureOut, sizeof(ddOpenCaptureOut));

        ddOpenCaptureIn.hDirectDraw = m_pVideoPort->GetDirectDrawHandle();
        ddOpenCaptureIn.hVideoPort = m_pVideoPort->GetVideoPortHandle();
        ddOpenCaptureIn.pfnCaptureClose = DirectDrawEventCallback;
        ddOpenCaptureIn.pContext = this;

        if ((!ddOpenCaptureIn.hDirectDraw)||
            (!ddOpenCaptureIn.hVideoPort)||
            (!ddOpenCaptureIn.pfnCaptureClose)||
            (!ddOpenCaptureIn.pContext))
        {
            return FALSE;
        }
        // Now to get the size, etc
        RECT                rcImage;

        /* 
        **  HOW BIG IS THE IMAGE REQUESTED (pseudocode follows)
        **
        **  if (IsRectEmpty (&rcTarget) {
        **      SetRect (&rcImage, 0, 0, 
        **              BITMAPINFOHEADER.biWidth,
                        BITMAPINFOHEADER.biHeight);
        **  }
        **  else {
        **      // Probably rendering to a DirectDraw surface,
        **      // where biWidth is used to expressed the "stride" 
        **      // in units of pixels (not bytes) of the destination surface.
        **      // Therefore, use rcTarget to get the actual image size 
        **      
        **      rcImage = rcTarget;
        **  }
        */

        if ((m_pVideoInfoHeader->rcTarget.right - 
             m_pVideoInfoHeader->rcTarget.left <= 0) ||
            (m_pVideoInfoHeader->rcTarget.bottom - 
             m_pVideoInfoHeader->rcTarget.top <= 0)) {

             rcImage.left = rcImage.top = 0;
             rcImage.right = m_pVideoInfoHeader->bmiHeader.biWidth - 1;
             rcImage.bottom = m_pVideoInfoHeader->bmiHeader.biHeight - 1;
        }
        else {
             rcImage = m_pVideoInfoHeader->rcTarget;
        }

		int xOrigin, yOrigin;
		m_pDevice->GetVideoSurfaceOrigin(&xOrigin, &yOrigin);
        ddOpenCaptureIn.dwStartLine = rcImage.top + yOrigin;
        ddOpenCaptureIn.dwEndLine = rcImage.bottom + yOrigin;

        // Fail-safe
        if (ddOpenCaptureIn.dwStartLine > 500)
        {
            DBGERROR(("Unexpected capture start line. Using default\n"));
            ddOpenCaptureIn.dwStartLine = 0;
        }

        if (ddOpenCaptureIn.dwEndLine > 500)
        {
            DBGERROR(("Unexpected capture end line. Using default\n"));
            ddOpenCaptureIn.dwEndLine = m_pDevice->GetDecoderHeight() - 1;
        }
        DBGINFO(("Video surface: %d, %d\n",
            ddOpenCaptureIn.dwStartLine,
            ddOpenCaptureIn.dwEndLine));

        ddOpenCaptureIn.dwFlags = DDOPENCAPTURE_VIDEO;

        // Integer math, so it will throw away fractional part
        m_everyNFields = min (max ( 1,
                        (ULONG) m_pVideoInfoHeader->AvgTimePerFrame/NTSCFieldDuration),
                        MAXULONG);

        // Now look at that fractional part. If there was a significant
        // amount, we'll need to round down to the next nearest
        // frame rate (i.e., skip additional field)

        // 'Significant' is currently assumed to be 1 uS. That
        // is '10' in units of 100ns 
        if ((m_pVideoInfoHeader->AvgTimePerFrame -
             (NTSCFieldDuration * m_everyNFields)) > 10)
        {
            m_everyNFields++;
        }

        ddOpenCaptureIn.dwCaptureEveryNFields = m_everyNFields;
               
        DBGINFO(("Capturing every %d fields\n",
                        ddOpenCaptureIn.dwCaptureEveryNFields));

        DxApi(DD_DXAPI_OPENVPCAPTUREDEVICE, &ddOpenCaptureIn, sizeof(ddOpenCaptureIn), &ddOpenCaptureOut, sizeof(ddOpenCaptureOut));

        if (ddOpenCaptureOut.ddRVal != DD_OK)
        {
            m_hCapture = 0;
            DBGERROR(("DD_DXAPI_OPENVPCAPTUREDEVICE failed.\n"));
            // TRAP();
            return FALSE;
        }
        else
        {
            m_hCapture = ddOpenCaptureOut.hCapture;
        }
    }
    return TRUE;
}   

    
VOID CWDMVideoCaptureStream::SetFrameInfo(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    int streamNumber = m_pStreamObject->StreamNumber;
    PSRB_DATA_EXTENSION      pSrbExt = (PSRB_DATA_EXTENSION)pSrb->SRBExtension;
    PKSSTREAM_HEADER    pDataPacket = pSrb->CommandData.DataBufferArray;
    
    LONGLONG droppedThisTime = 0;

    PKS_FRAME_INFO pFrameInfo = (PKS_FRAME_INFO) (pDataPacket + 1);

    m_FrameInfo.dwFrameFlags = 0;
    m_FrameInfo.ExtendedHeaderSize = pFrameInfo->ExtendedHeaderSize;

    // Set the discontinuity flag if frames have been previously dropped.
    if ((m_FrameInfo.PictureNumber + 1) <
        pSrbExt->ddCapBuffInfo.dwFieldNumber/m_everyNFields)
    {
        droppedThisTime =
        pSrbExt->ddCapBuffInfo.dwFieldNumber/m_everyNFields -
        (m_FrameInfo.PictureNumber + 1);
        m_FrameInfo.DropCount += droppedThisTime;
        pDataPacket->OptionsFlags |= KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY;
#ifdef DEBUG
        static int j;
        DBGPRINTF((" D%d ", droppedThisTime));
        if ((++j % 10) == 0)
        {
            DBGERROR(("\n"));
        }
#endif
    }
    m_FrameInfo.PictureNumber = pSrbExt->ddCapBuffInfo.dwFieldNumber/m_everyNFields;
    m_FrameInfo.dwFrameFlags |= KS_VIDEO_FLAG_FRAME;
    *pFrameInfo = (KS_FRAME_INFO)m_FrameInfo;
}


void CWDMVideoCaptureStream::ResetFrameCounters()
{
	m_FrameInfo.PictureNumber = 0;
	m_FrameInfo.DropCount = 0;
}

void CWDMVideoCaptureStream::GetDroppedFrames(PKSPROPERTY_DROPPEDFRAMES_CURRENT_S pDroppedFrames)
{
	pDroppedFrames->PictureNumber = m_FrameInfo.PictureNumber;
	pDroppedFrames->DropCount = m_FrameInfo.DropCount;
	pDroppedFrames->AverageFrameSize = m_pVideoInfoHeader->bmiHeader.biSizeImage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\bt-829\capvideo.h ===
#pragma once

//==========================================================================;
//
//	CWDMVideoCaptureStream - Video Capture Stream class declarations
//
//		$Date:   05 Aug 1998 11:22:44  $
//	$Revision:   1.0  $
//	  $Author:   Tashjian  $
//
// $Copyright:	(c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

#include "i2script.h"
#include "aticonfg.h"

#include "CapStrm.h"



class CWDMVideoCaptureStream : public CWDMCaptureStream
{
public:
	CWDMVideoCaptureStream(PHW_STREAM_OBJECT pStreamObject,
						CWDMVideoDecoder * pCWDMVideoDecoder,
						PKSDATAFORMAT pKSDataFormat,
						PUINT puiErrorCode);
	~CWDMVideoCaptureStream();

	void * operator new(size_t size, void * pAllocation) { return(pAllocation);}
	void operator delete(void * pAllocation) {}

private:
	PKS_VIDEOINFOHEADER		m_pVideoInfoHeader;  // format (variable size!)
    KS_FRAME_INFO           m_FrameInfo;          // PictureNumber, etc.
	ULONG					m_everyNFields;

	void ResetFrameCounters();
	ULONG GetFrameSize() { return m_pVideoInfoHeader->bmiHeader.biSizeImage; }
	void GetDroppedFrames(PKSPROPERTY_DROPPEDFRAMES_CURRENT_S pDroppedFrames);
	BOOL GetCaptureHandle();
	VOID SetFrameInfo(PHW_STREAM_REQUEST_BLOCK);
	ULONG GetFieldInterval() { return m_everyNFields; }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\bt-829\capstrm.cpp ===
//==========================================================================;
//
//	CWDMCaptureStream - Capture Stream base class implementation
//
//		$Date:   22 Feb 1999 15:13:58  $
//	$Revision:   1.1  $
//	  $Author:   KLEBANOV  $
//
// $Copyright:	(c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

extern "C"
{
#include "strmini.h"
#include "ksmedia.h"

#include "ddkmapi.h"
}

#include "wdmvdec.h"
#include "wdmdrv.h"
#include "aticonfg.h"
#include "capdebug.h"
#include "defaults.h"
#include "winerror.h"


void CWDMCaptureStream::TimeoutPacket(IN OUT PHW_STREAM_REQUEST_BLOCK pSrb)
{
    if (m_KSState == KSSTATE_STOP || !m_pVideoDecoder->PreEventOccurred())
    {
        DBGTRACE(("Attempting to complete Srbs.\n"));
        EmptyIncomingDataSrbQueue();
    }
}


void CWDMCaptureStream::Startup(PUINT puiErrorCode) 
{
    KIRQL Irql;
	DBGTRACE(("CWDMCaptureStream::Startup()\n"));

    KeInitializeEvent(&m_specialEvent, SynchronizationEvent, FALSE);
    KeInitializeEvent(&m_stateTransitionEvent, SynchronizationEvent, FALSE);
    KeInitializeEvent(&m_SrbAvailableEvent, SynchronizationEvent, FALSE);

    KeInitializeSpinLock(&m_streamDataLock);

    KeAcquireSpinLock(&m_streamDataLock, &Irql);

    InitializeListHead(&m_incomingDataSrbQueue);
    InitializeListHead(&m_waitQueue);
    InitializeListHead(&m_reversalQueue);

    KeReleaseSpinLock(&m_streamDataLock, Irql);
    
    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);
    
    ASSERT(m_stateChange == Initializing);
    m_stateChange = Starting;
    
	HANDLE  threadHandle;
	NTSTATUS status = PsCreateSystemThread(&threadHandle,
                                    (ACCESS_MASK) 0L,
                                    NULL,
                                    NULL,
                                    NULL,
                                    (PKSTART_ROUTINE) ThreadStart,
                                    (PVOID) this);
    if (status != STATUS_SUCCESS)
    {
        DBGERROR(("CreateStreamThread failed\n"));
		*puiErrorCode = WDMMINI_ERROR_MEMORYALLOCATION;
        return;
    }

    // Don't need this for anything, so might as well close it now.
    // The thread will call PsTerminateThread on itself when it
    // is done.
    ZwClose(threadHandle);

    KeWaitForSingleObject(&m_specialEvent, Suspended, KernelMode, FALSE, NULL);
    ASSERT(m_stateChange == ChangeComplete);
    
    DBGTRACE(("SrbOpenStream got notification that thread started\n"));
	*puiErrorCode = WDMMINI_NOERROR;
}


void CWDMCaptureStream::Shutdown()
{
    KIRQL                   Irql;

	  DBGTRACE(("CWDMCaptureStream::Shutdown()\n"));

    if ( m_stateChange != Initializing )
    {
        ASSERT(m_stateChange == ChangeComplete);
        m_stateChange = Closing;
        KeResetEvent(&m_specialEvent);
        KeSetEvent(&m_stateTransitionEvent, 0, TRUE);
        KeWaitForSingleObject(&m_specialEvent, Suspended, KernelMode, FALSE, NULL);
        ASSERT(m_stateChange == ChangeComplete);
    

        KeAcquireSpinLock(&m_streamDataLock, &Irql);
        if (!IsListEmpty(&m_incomingDataSrbQueue))
        {
            TRAP();
        }

        if (!IsListEmpty(&m_waitQueue))
        {
            TRAP();
        }
        KeReleaseSpinLock(&m_streamDataLock, Irql);
    }

    ReleaseCaptureHandle();
}


void CWDMCaptureStream::ThreadProc()
{
    PHW_STREAM_REQUEST_BLOCK pCurrentSrb = NULL;
    PSRB_DATA_EXTENSION pSrbExt = NULL;
    KEVENT DummyEvent;
    const int numEvents = 3;

    NTSTATUS status;

    // Wo unto you if you overrun this array
    PVOID eventArray[numEvents];

    KeInitializeEvent(&DummyEvent, SynchronizationEvent, FALSE);

    ASSERT(m_stateChange == Starting);

    // Indicates to SrbOpenStream() to continue
    m_stateChange = ChangeComplete;
    KeSetEvent(&m_specialEvent, 0, FALSE);

    // These should remain constant the whole time
    eventArray[0] = &m_stateTransitionEvent;
    eventArray[1] = &m_SrbAvailableEvent;

    // eventArray[2] changes, so it is set below

    // This runs until the thread terminates itself
    // inside of HandleStateTransition
    while (1)
    {
// May not be necessary
#define ENABLE_TIMEOUT
#ifdef ENABLE_TIMEOUT
        LARGE_INTEGER i;
#endif

		if (pCurrentSrb == NULL)
        {
            pSrbExt = (PSRB_DATA_EXTENSION)ExInterlockedRemoveHeadList(&m_waitQueue, &m_streamDataLock);

            if (pSrbExt)
            {
                pCurrentSrb = pSrbExt->pSrb;
                eventArray[2] = &pSrbExt->bufferDoneEvent;
            }
            else
            {
#ifdef DEBUG
                if (m_KSState == KSSTATE_RUN &&
                    m_stateChange == ChangeComplete &&
                    m_pVideoDecoder->PreEventOccurred() == FALSE)
                {
                    static int j;

                    // Indicates that we are starved for buffers. Probably
                    // a higher level is not handing them to us in a timely
                    // fashion for some reason
                    DBGPRINTF((" S "));
                    if ((++j % 10) == 0)
                    {
                        DBGPRINTF(("\n"));
                    }
                }
#endif
                pCurrentSrb = NULL;
                eventArray[2] = &DummyEvent;
            }
        }

#ifdef ENABLE_TIMEOUT
        // This is meant mainly as a failsafe measure.
        i.QuadPart = -2000000;      // 200 ms
#endif
        
        status = KeWaitForMultipleObjects(  numEvents,  // count
                                            eventArray, // DispatcherObjectArray
                                            WaitAny,    // WaitType
                                            Executive,  // WaitReason
                                            KernelMode, // WaitMode
                                            FALSE,      // Alertable
#ifdef ENABLE_TIMEOUT
                                            &i,         // Timeout (Optional)
#else
                                            NULL,
#endif
                                            NULL);      // WaitBlockArray (Optional)

        switch (status)
        {
            // State transition. May including killing this very thread
            case 0:
                if ( pCurrentSrb )
                {
                  ExInterlockedInsertHeadList( &m_waitQueue, &pSrbExt->srbListEntry, &m_streamDataLock );
                  pCurrentSrb = NULL;
                }
                HandleStateTransition();
                break;

            // New Srb available
            case 1:
                if ( pCurrentSrb )
                {
                  ExInterlockedInsertHeadList( &m_waitQueue, &pSrbExt->srbListEntry, &m_streamDataLock );
                  pCurrentSrb = NULL;
                }
                if (m_KSState == KSSTATE_RUN && m_stateChange == ChangeComplete)
                {
                    AddBuffersToDirectDraw();
                }
                break;

            // Busmaster complete
            case 2:
				if ( pCurrentSrb )
				{
					HandleBusmasterCompletion(pCurrentSrb);
	                pCurrentSrb = NULL;
				}
                break;

#ifdef ENABLE_TIMEOUT
            // If we timeout in the RUN state, this is our chance to try again
            // to add buffers. May not be necessary, since currently, we go
            // through a state transition for DOS boxes, etc.
            case STATUS_TIMEOUT:
                if ( pCurrentSrb )
                {
                  ExInterlockedInsertHeadList( &m_waitQueue, &pSrbExt->srbListEntry, &m_streamDataLock );
                  pCurrentSrb = NULL;
                }
                if (m_KSState == KSSTATE_RUN &&
                    m_stateChange == ChangeComplete &&
                    m_pVideoDecoder->PreEventOccurred() == FALSE)
                {
                    AddBuffersToDirectDraw();
                }
                break;
#endif

            default:
                TRAP();
                break;
        }
    }
}


VOID STREAMAPI CWDMCaptureStream::VideoReceiveDataPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb)
{
    KIRQL                   Irql;
    PSRB_DATA_EXTENSION          pSrbExt;

    ASSERT(pSrb->Irp->MdlAddress);
    
    DBGINFO(("Receiving SD---- SRB=%x\n", pSrb));

    pSrb->Status = STATUS_SUCCESS;

    switch (pSrb->Command) {

        case SRB_READ_DATA:

            // Rule: 
            // Only accept read requests when in either the Pause or Run
            // States.  If Stopped, immediately return the SRB.

            if ( (m_KSState == KSSTATE_STOP) || ( m_stateChange == Initializing ) ) {
                StreamClassStreamNotification(  StreamRequestComplete,
                                                pSrb->StreamObject,
                                                pSrb);
                break;
            } 

            pSrbExt = (PSRB_DATA_EXTENSION)pSrb->SRBExtension;
            RtlZeroMemory (pSrbExt, sizeof (SRB_DATA_EXTENSION));
            pSrbExt->pSrb = pSrb;
            KeInitializeEvent(&pSrbExt->bufferDoneEvent, SynchronizationEvent, FALSE);

            DBGINFO(("Adding 0x%x to data queue\n", pSrb));

            KeAcquireSpinLock(&m_streamDataLock, &Irql);
            InsertTailList(&m_incomingDataSrbQueue, &pSrbExt->srbListEntry);
            KeReleaseSpinLock(&m_streamDataLock, Irql);
            KeSetEvent(&m_SrbAvailableEvent, 0, FALSE);

            break;

        default:

            //
            // invalid / unsupported command. Fail it as such
            //

            TRAP();

            pSrb->Status = STATUS_NOT_IMPLEMENTED;
            StreamClassStreamNotification(  StreamRequestComplete,
                                            pSrb->StreamObject,
                                            pSrb);
            break;
    }
}

/*
** VideoGetProperty()
**
**    Routine to process video property requests
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID CWDMCaptureStream::VideoGetProperty(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;

    if (IsEqualGUID (KSPROPSETID_Connection, pSPD->Property->Set)) {
        VideoStreamGetConnectionProperty (pSrb);
    }
    else if (IsEqualGUID (PROPSETID_VIDCAP_DROPPEDFRAMES, pSPD->Property->Set)) {
        VideoStreamGetDroppedFramesProperty (pSrb);
    }
    else {
       pSrb->Status = STATUS_NOT_IMPLEMENTED;
    }
}


/*
** VideoSetState()
**
**    Sets the current state of the requested stream
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**	  BOOL bVPVBIConnected
**	  BOOL bVPConnected
**
** Returns:
**
** Side Effects:  none
*/

VOID CWDMCaptureStream::VideoSetState(PHW_STREAM_REQUEST_BLOCK pSrb, BOOL bVPConnected, BOOL bVPVBIConnected)
{
    //
    // For each stream, the following states are used:
    // 
    // Stop:    Absolute minimum resources are used.  No outstanding IRPs.
    // Pause:   Getting ready to run.  Allocate needed resources so that 
    //          the eventual transition to Run is as fast as possible.
    //          SRBs will be queued at either the Stream class or in your
    //          driver.
    // Run:     Streaming. 
    //
    // Moving to Stop or Run ALWAYS transitions through Pause, so that ONLY 
    // the following transitions are possible:
    //
    // Stop -> Pause
    // Pause -> Run
    // Run -> Pause
    // Pause -> Stop
    //
    // Note that it is quite possible to transition repeatedly between states:
    // Stop -> Pause -> Stop -> Pause -> Run -> Pause -> Run -> Pause -> Stop
    //
	BOOL bStreamCondition;

    DBGINFO(("CWDMCaptureStream::VideoSetState for stream %d\n", pSrb->StreamObject->StreamNumber));

	pSrb->Status = STATUS_SUCCESS;

    switch (pSrb->CommandData.StreamState)  
    {
        case KSSTATE_STOP:
            DBGINFO(("   state KSSTATE_STOP"));

            ASSERT(m_stateChange == ChangeComplete);
            m_stateChange = Stopping;
            FlushBuffers();
            KeResetEvent(&m_specialEvent);
            KeSetEvent(&m_stateTransitionEvent, 0, TRUE);
            KeWaitForSingleObject(&m_specialEvent, Suspended, KernelMode, FALSE, NULL);
            ASSERT(m_stateChange == ChangeComplete);
            break;

        case KSSTATE_ACQUIRE:
            DBGINFO(("   state KSSTATE_ACQUIRE"));
            ASSERT(m_KSState == KSSTATE_STOP);
            break;

        case KSSTATE_PAUSE:
			DBGINFO(("   state KSSTATE_PAUSE"));
            
			switch( pSrb->StreamObject->StreamNumber)
			{
				case STREAM_VideoCapture:
					bStreamCondition = bVPConnected;
					break;

				case STREAM_VBICapture:
					bStreamCondition = bVPVBIConnected;
					break;

				default:
					bStreamCondition = FALSE;
					break;
			}
			
			if( !bStreamCondition)
            {
                pSrb->Status = STATUS_UNSUCCESSFUL;
            }
			else 

            if (m_pVideoDecoder->PreEventOccurred() &&
                        (m_KSState == KSSTATE_STOP || m_KSState == KSSTATE_ACQUIRE))
            {
                pSrb->Status = STATUS_UNSUCCESSFUL;
            }
            else if (m_KSState == KSSTATE_STOP || m_KSState == KSSTATE_ACQUIRE)
            {
				ResetFrameCounters();
                ResetFieldNumber();
                
                if (!GetCaptureHandle())
                    pSrb->Status = STATUS_UNSUCCESSFUL;
            }
            else if (m_KSState == KSSTATE_RUN)
            {
                // Transitioning from run to pause
                ASSERT(m_stateChange == ChangeComplete);
                m_stateChange = Pausing;
                FlushBuffers();
                KeResetEvent(&m_specialEvent);
                KeSetEvent(&m_stateTransitionEvent, 0, TRUE);
                KeWaitForSingleObject(&m_specialEvent, Suspended, KernelMode, FALSE, NULL);
                ASSERT(m_stateChange == ChangeComplete);
            }
            
            break;

        case KSSTATE_RUN:
            DBGINFO(("   state KSSTATE_RUN"));

            ASSERT(m_KSState == KSSTATE_ACQUIRE || m_KSState == KSSTATE_PAUSE);

            if (m_pVideoDecoder->PreEventOccurred())
            {
                pSrb->Status = STATUS_UNSUCCESSFUL;
            }
            else
            {
                ResetFieldNumber();

                // Transitioning from pause to run
                ASSERT(m_stateChange == ChangeComplete);
                m_stateChange = Running;
                KeResetEvent(&m_specialEvent);
                KeSetEvent(&m_stateTransitionEvent, 0, TRUE);
                KeWaitForSingleObject(&m_specialEvent, Suspended, KernelMode, FALSE, NULL);
                ASSERT(m_stateChange == ChangeComplete);
            }
            break;
    }

	if (pSrb->Status == STATUS_SUCCESS) {
		m_KSState = pSrb->CommandData.StreamState;
        DBGINFO((" entered\n"));
	}
	else
        DBGINFO((" NOT entered ***\n"));
}


VOID CWDMCaptureStream::VideoStreamGetConnectionProperty (PHW_STREAM_REQUEST_BLOCK pSrb)
{
	PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
	PKSALLOCATOR_FRAMING Framing = (PKSALLOCATOR_FRAMING) pSPD->PropertyInfo;

    ASSERT(pSPD->Property->Id == KSPROPERTY_CONNECTION_ALLOCATORFRAMING);

	Framing->RequirementsFlags   =
		KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY |
		KSALLOCATOR_REQUIREMENTF_INPLACE_MODIFIER |
		KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY;
	Framing->PoolType = NonPagedPool;
	Framing->Frames = NumBuffers;
	Framing->FileAlignment = 0;//FILE_QUAD_ALIGNMENT;// PAGE_SIZE - 1;
	Framing->Reserved = 0;
	Framing->FrameSize = GetFrameSize();

	pSrb->ActualBytesTransferred = sizeof(KSALLOCATOR_FRAMING);
}

/*
** VideoStreamGetDroppedFramesProperty
**
**    Gets dropped frame information
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID CWDMCaptureStream::VideoStreamGetDroppedFramesProperty(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
	PKSPROPERTY_DROPPEDFRAMES_CURRENT_S pDroppedFrames = 
		(PKSPROPERTY_DROPPEDFRAMES_CURRENT_S) pSPD->PropertyInfo;

    ASSERT(pSPD->Property->Id == KSPROPERTY_DROPPEDFRAMES_CURRENT);

	GetDroppedFrames(pDroppedFrames);

	DBGINFO(("PictNumber: 0x%x; DropCount: 0x%x; BufSize: 0x%x\n",
		(ULONG) pDroppedFrames->PictureNumber,
		(ULONG) pDroppedFrames->DropCount,
		(ULONG) pDroppedFrames->AverageFrameSize));

	pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_DROPPEDFRAMES_CURRENT_S);
}


VOID CWDMCaptureStream::CloseCapture()
{
	DBGTRACE(("DDNOTIFY_CLOSECAPTURE; stream = %d\n", m_pStreamObject->StreamNumber));

    m_hCapture = 0;
}    


VOID CWDMCaptureStream::EmptyIncomingDataSrbQueue()
{
    KIRQL Irql;
    PKSSTREAM_HEADER pDataPacket;
    
    if ( m_stateChange == Initializing )
    {
        return; // queue not setup yet, so we can return knowing that nothing is in the queue
    }
    
    // Think about replacing with ExInterlockedRemoveHeadList. 
    KeAcquireSpinLock(&m_streamDataLock, &Irql);
    
    while (!IsListEmpty(&m_incomingDataSrbQueue))
    {
        PSRB_DATA_EXTENSION pSrbExt = (PSRB_DATA_EXTENSION)RemoveHeadList(&m_incomingDataSrbQueue);
        PHW_STREAM_REQUEST_BLOCK pSrb = pSrbExt->pSrb;
        
        pSrb->Status = STATUS_SUCCESS;
        pDataPacket = pSrb->CommandData.DataBufferArray;
        pDataPacket->DataUsed = 0;
        
        KeReleaseSpinLock(&m_streamDataLock, Irql);
        DBGINFO(("Completing Srb 0x%x in STATE_STOP\n", pSrb));
        StreamClassStreamNotification(  StreamRequestComplete,
                                        pSrb->StreamObject,
                                        pSrb);
        KeAcquireSpinLock(&m_streamDataLock, &Irql);
    }
    
    KeReleaseSpinLock(&m_streamDataLock, Irql);
}


BOOL CWDMCaptureStream::ReleaseCaptureHandle()
{
    int streamNumber = m_pStreamObject->StreamNumber;
    DWORD ddOut = DD_OK;
    DDCLOSEHANDLE ddClose;

    if (m_hCapture != 0)
    {
        DBGTRACE(("Stream %d releasing capture handle\n", streamNumber));
        
        ddClose.hHandle = m_hCapture;

        DxApi(DD_DXAPI_CLOSEHANDLE, &ddClose, sizeof(ddClose), &ddOut, sizeof(ddOut));

        if (ddOut != DD_OK)
        {
            DBGERROR(("DD_DXAPI_CLOSEHANDLE failed.\n"));
            TRAP();
            return FALSE;
        }
        m_hCapture = 0;
    }
    return TRUE;
}

VOID CWDMCaptureStream::HandleBusmasterCompletion(PHW_STREAM_REQUEST_BLOCK pCurrentSrb)
{
    int streamNumber =	m_pStreamObject->StreamNumber;
    PSRB_DATA_EXTENSION pSrbExt = (PSRB_DATA_EXTENSION)pCurrentSrb->SRBExtension;
    PKSSTREAM_HEADER    pDataPacket = pCurrentSrb->CommandData.DataBufferArray;
    KIRQL Irql;
    // This function is called as a result of DD completing a BM.  That means
    // m_stateChange will not be in the Initializing state for sure

    // First handle case where we get a Busmaster completion
    // indication while we are trying to pause or stop
    if (m_stateChange == Pausing || m_stateChange == Stopping)
    {
        PUCHAR ptr;
        KeAcquireSpinLock(&m_streamDataLock, &Irql);

        // Put it at the head of the temporary 'reversal' queue.
        InsertHeadList(&m_reversalQueue, &pSrbExt->srbListEntry);
        
        if (IsListEmpty(&m_waitQueue))
        {
            // if there is nothing left in the wait queue we can now
            // proceed to move everything back to the incoming queue.
            // This whole ugly ordeal is to
            // make sure that they end up in the original order
            while (!IsListEmpty(&m_reversalQueue))
            {
                ptr = (PUCHAR)RemoveHeadList(&m_reversalQueue);
                InsertHeadList(&m_incomingDataSrbQueue, (PLIST_ENTRY) ptr);
            }
            
            KeReleaseSpinLock(&m_streamDataLock, Irql);
            
            if (m_stateChange == Stopping)
            {
                EmptyIncomingDataSrbQueue();
            }
            
            // Indicate that we have successfully completed this part
            // of the transition to the pause state.
            m_stateChange = ChangeComplete;
            KeSetEvent(&m_specialEvent, 0, FALSE);
            return;
        }

        KeReleaseSpinLock(&m_streamDataLock, Irql);
        return;
    }

    // else it is a regular busmaster completion while in the run state
    else
    {
        ASSERT (pCurrentSrb);
        PKSSTREAM_HEADER    pDataPacket = pCurrentSrb->CommandData.DataBufferArray;
        pDataPacket->OptionsFlags = 0;

        pSrbExt = (PSRB_DATA_EXTENSION)pCurrentSrb->SRBExtension;

        DBGINFO(("FieldNum: %d; ddRVal: 0x%x; polarity: 0x%x\n",
                 pSrbExt->ddCapBuffInfo.dwFieldNumber,
                 pSrbExt->ddCapBuffInfo.ddRVal,
                 pSrbExt->ddCapBuffInfo.bPolarity));

        // It's possible that the srb got cancelled while we were waiting.
        // Currently, this status is reset below
        if (pCurrentSrb->Status == STATUS_CANCELLED)
        {
            DBGINFO(("pCurrentSrb 0x%x was cancelled while we were waiting\n", pCurrentSrb));
            pDataPacket->DataUsed = 0;
        }

        // It's also possible that there was a problem in DD-land
        else if (pSrbExt->ddCapBuffInfo.ddRVal != DD_OK)
        {
            // Two cases of which I am aware.
            // 1) flushed buffers
            if (pSrbExt->ddCapBuffInfo.ddRVal == E_FAIL)
            {
                DBGINFO(("ddRVal = 0x%x. Assuming we flushed\n", pSrbExt->ddCapBuffInfo.ddRVal));
                pDataPacket->DataUsed = 0;
            }
            // 2) something else
            else
            {
                DBGERROR(("= 0x%x. Problem in Busmastering?\n", pSrbExt->ddCapBuffInfo.ddRVal));
                pDataPacket->DataUsed = 0;
            }
        }

        // There is also the remote possibility that everything is OK
        else
        {
            SetFrameInfo(pCurrentSrb);
            TimeStampSrb(pCurrentSrb);
            pDataPacket->DataUsed = pDataPacket->FrameExtent;
        }
        
        DBGINFO(("StreamRequestComplete for SRB 0x%x\n", pCurrentSrb));

        // Always return success. Failure
        // is indicated by setting DataUsed to 0.
        pCurrentSrb->Status = STATUS_SUCCESS;

        ASSERT(pCurrentSrb->Irp->MdlAddress);

        StreamClassStreamNotification(  StreamRequestComplete,
                                        pCurrentSrb->StreamObject,
                                        pCurrentSrb);
    }
}

void CWDMCaptureStream::AddBuffersToDirectDraw()
{
    KIRQL Irql;
    BOOL  fAdded;
    
    KeAcquireSpinLock(&m_streamDataLock, &Irql);
    
    while (!IsListEmpty(&m_incomingDataSrbQueue))
    {
        // So if we've reached this point, we are in the run state, and
        // we have an SRB on our incoming queue, and we are holding the
        // the stream lock
        PSRB_DATA_EXTENSION pSrbExt = (PSRB_DATA_EXTENSION)RemoveHeadList(&m_incomingDataSrbQueue);
        PHW_STREAM_REQUEST_BLOCK pSrb = pSrbExt->pSrb;

        // Calls to DXAPI must be at Passive level, so release the spinlock temporarily

        KeReleaseSpinLock(&m_streamDataLock, Irql);

        DBGINFO(("Removed 0x%x from data queue\n", pSrb));

        fAdded = AddBuffer(pSrb);

        KeAcquireSpinLock(&m_streamDataLock, &Irql);

        if (fAdded)
        {
            DBGINFO(("Adding 0x%x to wait queue\n", pSrb));
            InsertTailList(&m_waitQueue, &pSrbExt->srbListEntry);
        }
        else
        {
            DBGINFO(("Adding 0x%x back to dataqueue\n", pSrb));

            // put it back where it was
            InsertHeadList(&m_incomingDataSrbQueue, &pSrbExt->srbListEntry);
            break;
        }
    }
    KeReleaseSpinLock(&m_streamDataLock, Irql);
}


BOOL CWDMCaptureStream::AddBuffer(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    DDADDVPCAPTUREBUFF ddAddVPCaptureBuffIn;
    DWORD ddOut = DD_OK;

    PIRP irp = pSrb->Irp;
    PSRB_DATA_EXTENSION pSrbExt = (PSRB_DATA_EXTENSION)pSrb->SRBExtension;
    
    DBGINFO(("In AddBuffer. pSrb: 0x%x.\n", pSrb));

    // For handling full-screen DOS, res changes, etc.
    if (m_hCapture == 0)
    {
        if (!GetCaptureHandle())
        {
            return FALSE;
        }
    }

    ddAddVPCaptureBuffIn.hCapture = m_hCapture;
    ddAddVPCaptureBuffIn.dwFlags = DDADDBUFF_SYSTEMMEMORY;
    ddAddVPCaptureBuffIn.pMDL = irp->MdlAddress;

    ddAddVPCaptureBuffIn.lpBuffInfo = &pSrbExt->ddCapBuffInfo;
    ddAddVPCaptureBuffIn.pKEvent = &pSrbExt->bufferDoneEvent;

    DxApi(DD_DXAPI_ADDVPCAPTUREBUFFER, &ddAddVPCaptureBuffIn, sizeof(ddAddVPCaptureBuffIn), &ddOut, sizeof(ddOut));

    if (ddOut != DD_OK)
    {
        // Not necessarily an error.
        DBGINFO(("DD_DXAPI_ADDVPCAPTUREBUFFER failed.\n"));
        // TRAP();
        return FALSE;
    }

    return TRUE;
}


VOID CWDMCaptureStream::HandleStateTransition()
{
    KIRQL Irql;
    switch (m_stateChange)
    {
        case Running:
            AddBuffersToDirectDraw();
            m_stateChange = ChangeComplete;
            KeSetEvent(&m_specialEvent, 0, FALSE);
            break;

        case Pausing:
            KeAcquireSpinLock(&m_streamDataLock, &Irql);
            if (IsListEmpty(&m_waitQueue))
            {
                KeReleaseSpinLock(&m_streamDataLock, Irql);
                m_stateChange = ChangeComplete;
                KeSetEvent(&m_specialEvent, 0, FALSE);
            }
            else
            {
                KeReleaseSpinLock(&m_streamDataLock, Irql);
            }
            break;

        case Stopping:
            KeAcquireSpinLock(&m_streamDataLock, &Irql);
            if (IsListEmpty(&m_waitQueue))
            {
                KeReleaseSpinLock(&m_streamDataLock, Irql);
                EmptyIncomingDataSrbQueue();
                m_stateChange = ChangeComplete;
                KeSetEvent(&m_specialEvent, 0, FALSE);
            }
            else
            {
                KeReleaseSpinLock(&m_streamDataLock, Irql);
            }
            break;

        case Closing:
            m_stateChange = ChangeComplete;
            KeSetEvent(&m_specialEvent, 0, FALSE);
            DBGTRACE(("StreamThread exiting\n"));
            
            PsTerminateSystemThread(STATUS_SUCCESS);

            DBGERROR(("Shouldn't get here\n"));
            TRAP();
            break;

        case ChangeComplete:
            DBGTRACE(("Must have completed transition in HandleBusMasterCompletion\n"));
            break;

        default:
            TRAP();
            break;
    }
}

    
BOOL CWDMCaptureStream::ResetFieldNumber()
{
    int                     streamNumber = m_pStreamObject->StreamNumber;
    DDSETFIELDNUM           ddSetFieldNum;
    DWORD                   ddOut;

    ASSERT(streamNumber == STREAM_VideoCapture || streamNumber == STREAM_VBICapture);

    if (m_pVideoPort->GetDirectDrawHandle() == 0) {
        DBGERROR(("Didn't expect ring0DirectDrawHandle to be zero.\n"));
        TRAP();
        return FALSE;
    }
    
    if (m_pVideoPort->GetVideoPortHandle() == 0) {
        DBGERROR(("Didn't expect ring0VideoPortHandle to be zero.\n"));
        TRAP();
        return FALSE;
    }
    
    RtlZeroMemory(&ddSetFieldNum, sizeof(ddSetFieldNum));
    RtlZeroMemory(&ddOut, sizeof(ddOut));

	KSPROPERTY_DROPPEDFRAMES_CURRENT_S DroppedFrames;
	GetDroppedFrames(&DroppedFrames);

    ddSetFieldNum.hDirectDraw = m_pVideoPort->GetDirectDrawHandle();
    ddSetFieldNum.hVideoPort = m_pVideoPort->GetVideoPortHandle();
	ddSetFieldNum.dwFieldNum = ((ULONG)DroppedFrames.PictureNumber + 1) * GetFieldInterval();
    
    DxApi(DD_DXAPI_SET_VP_FIELD_NUMBER, &ddSetFieldNum, sizeof(ddSetFieldNum), &ddOut, sizeof(ddOut));

    if (ddOut != DD_OK)
    {
        DBGERROR(("DD_DXAPI_SET_VP_FIELD_NUMBER failed.\n"));
        TRAP();
        return FALSE;
    }
    else
    {
#ifdef DEBUG
        DBGINFO(("PictureNumber: %d; ", DroppedFrames.PictureNumber));
        DBGINFO(("DropCount: %d\n", DroppedFrames.DropCount));
        DBGINFO(("AverageFrameSize: %d\n", DroppedFrames.AverageFrameSize));
#endif
        return TRUE;
    }
}

BOOL CWDMCaptureStream::FlushBuffers()
{
    DWORD ddOut = DD_OK;

    // commented out the trap because it is possible that capture handle is closed in DD before flushbuffer is called during mode switch
    if (m_hCapture == NULL) {
       //DBGERROR(("m_hCapture === NULL in FlushBuffers.\n"));
       //TRAP();
       return FALSE;
    }

    DxApi(DD_DXAPI_FLUSHVPCAPTUREBUFFERS, &m_hCapture, sizeof(HANDLE), &ddOut, sizeof(ddOut));

    if (ddOut != DD_OK)
    {
        DBGERROR(("DD_DXAPI_FLUSHVPCAPTUREBUFFERS failed.\n"));
        TRAP();
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}
    

VOID CWDMCaptureStream::TimeStampSrb(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PKSSTREAM_HEADER    pDataPacket = pSrb->CommandData.DataBufferArray;
    PSRB_DATA_EXTENSION      pSrbExt = (PSRB_DATA_EXTENSION)pSrb->SRBExtension;

    pDataPacket->Duration = GetFieldInterval() * NTSCFieldDuration;

    pDataPacket->OptionsFlags |= 
        KSSTREAM_HEADER_OPTIONSF_DURATIONVALID |
        KSSTREAM_HEADER_OPTIONSF_SPLICEPOINT;

    // Find out what time it is, if we're using a clock

    if (m_hMasterClock) {
        LARGE_INTEGER Delta;

        HW_TIME_CONTEXT TimeContext;

//        TimeContext.HwDeviceExtension = pHwDevExt; 
        TimeContext.HwDeviceExtension = (struct _HW_DEVICE_EXTENSION *)m_pVideoDecoder; 
        TimeContext.HwStreamObject = m_pStreamObject;
        TimeContext.Function = TIME_GET_STREAM_TIME;

        StreamClassQueryMasterClockSync (
            m_hMasterClock,
            &TimeContext);

        // This calculation should result in the stream time WHEN the buffer
        // was filled.
        Delta.QuadPart = TimeContext.SystemTime -
                            pSrbExt->ddCapBuffInfo.liTimeStamp.QuadPart;

        // Be safe, just use the current stream time, without the correction for when
        // DDraw actually returned the buffer to us.
        pDataPacket->PresentationTime.Time = TimeContext.Time; 

#ifdef THIS_SHOULD_WORK_BUT_IT_DOESNT
        if (TimeContext.Time > (ULONGLONG) Delta.QuadPart)
        {
            pDataPacket->PresentationTime.Time = TimeContext.Time - Delta.QuadPart;
        }
        else
        {
            // There's a bug in Ks or Stream after running for 2 hours
            // that makes this hack necessary.  Will be fixed soon...
            pDataPacket->PresentationTime.Time = TimeContext.Time;
        }
#endif

#ifdef DEBUG
        ULONG *tmp1, *tmp2;

        tmp1 = (ULONG *)&pDataPacket->PresentationTime.Time;
        tmp2 = (ULONG *)&TimeContext.Time;
        DBGINFO(("PT: 0x%x%x; ST: 0x%x%x\n", tmp1[1], tmp1[0], tmp2[1], tmp2[0]));
#endif

        pDataPacket->PresentationTime.Numerator = 1;
        pDataPacket->PresentationTime.Denominator = 1;

        pDataPacket->OptionsFlags |= 
            KSSTREAM_HEADER_OPTIONSF_TIMEVALID;
    }
    else
    {
        pDataPacket->OptionsFlags &= 
            ~KSSTREAM_HEADER_OPTIONSF_TIMEVALID;
    }
}


void CWDMCaptureStream::CancelPacket( PHW_STREAM_REQUEST_BLOCK pSrbToCancel)
{
	PHW_STREAM_REQUEST_BLOCK	pCurrentSrb;
	KIRQL                   	Irql;
	PLIST_ENTRY             	Entry;
	BOOL                    	bFound = FALSE;

    if ( m_stateChange == Initializing )  // Stream not completely setup, so nothing in the queue
    {
        DBGINFO(( "Bt829: Didn't find Srb 0x%x\n", pSrbToCancel));
        return;
    }

	KeAcquireSpinLock( &m_streamDataLock, &Irql);

	Entry = m_incomingDataSrbQueue.Flink;

	// 
	// Loop through the linked list from the beginning to end,
	// trying to find the SRB to cancel
	//
	while( Entry != &m_incomingDataSrbQueue)
	{
    	PSRB_DATA_EXTENSION pSrbExt;
    
		pSrbExt = ( PSRB_DATA_EXTENSION)Entry;
        pCurrentSrb = pSrbExt->pSrb;
        
        if( pCurrentSrb == pSrbToCancel)
		{
            RemoveEntryList( Entry);
            bFound = TRUE;
            break;
        }
        Entry = Entry->Flink;
    }

    KeReleaseSpinLock( &m_streamDataLock, Irql);

    if( bFound)
	{
        pCurrentSrb->Status = STATUS_CANCELLED;
        pCurrentSrb->CommandData.DataBufferArray->DataUsed = 0;
        
        DBGINFO(( "Bt829: Cancelled Srb 0x%x\n", pCurrentSrb));
        StreamClassStreamNotification( StreamRequestComplete,
                                       pCurrentSrb->StreamObject,
                                       pCurrentSrb);
    }
    else
	{
        // If this is a DATA_TRANSFER and a STREAM_REQUEST SRB, 
        // then it must be in the waitQueue, being filled by DDraw.

        // If so, mark it cancelled, and it will 
        // be returned when  DDraw is finished with it.
        if(( pSrbToCancel->Flags & (SRB_HW_FLAGS_DATA_TRANSFER | SRB_HW_FLAGS_STREAM_REQUEST)) ==
                                  (SRB_HW_FLAGS_DATA_TRANSFER | SRB_HW_FLAGS_STREAM_REQUEST))
		{
            pSrbToCancel->Status = STATUS_CANCELLED;
            DBGINFO(( "Bt829: Cancelled Srb on waitQueue 0x%x\n", pSrbToCancel));
        }
        else 
        {
           DBGINFO(( "Bt829: Didn't find Srb 0x%x\n", pSrbToCancel));
    	}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\bt-829\capvbi.cpp ===
//==========================================================================;
//
//	CWDMVBICaptureStream - VBI Capture Stream class implementation
//
//		$Date:   05 Aug 1998 11:11:20  $
//	$Revision:   1.0  $
//	  $Author:   Tashjian  $
//
// $Copyright:	(c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

extern "C"
{
#include "strmini.h"
#include "ksmedia.h"

#include "ddkmapi.h"
}

#include "wdmvdec.h"
#include "wdmdrv.h"
#include "aticonfg.h"
#include "capdebug.h"
#include "defaults.h"


CWDMVBICaptureStream::CWDMVBICaptureStream(PHW_STREAM_OBJECT pStreamObject,
						CWDMVideoDecoder * pCWDMVideoDecoder,
						PKSDATAFORMAT pKSDataFormat,
						PUINT puiErrorCode)
		:	CWDMCaptureStream(pStreamObject, pCWDMVideoDecoder, puiErrorCode)
{
    m_stateChange = Initializing;

	DBGTRACE(("CWDMVBICaptureStream::Startup()\n"));

    PKS_DATAFORMAT_VBIINFOHEADER  pVBIInfoHeader = 
                (PKS_DATAFORMAT_VBIINFOHEADER) pKSDataFormat;

    PKS_VBIINFOHEADER     pVBIInfoHdrRequested = 
                &pVBIInfoHeader->VBIInfoHeader;
    
    DBGINFO(("pVBIInfoHdrRequested->StartLine = %d\n", pVBIInfoHdrRequested->StartLine));
    DBGINFO(("pVBIInfoHdrRequested->EndLine = %d\n", pVBIInfoHdrRequested->EndLine));
    DBGINFO(("pVBIInfoHdrRequested->MinLineStartTime = %d\n", pVBIInfoHdrRequested->MinLineStartTime));
    DBGINFO(("pVBIInfoHdrRequested->MaxLineStartTime = %d\n", pVBIInfoHdrRequested->MaxLineStartTime));
    DBGINFO(("pVBIInfoHdrRequested->ActualLineStartTime = %d\n", pVBIInfoHdrRequested->ActualLineStartTime));
    DBGINFO(("pVBIInfoHdrRequested->VideoStandard = 0x%x\n", pVBIInfoHdrRequested->VideoStandard));
    DBGINFO(("pVBIInfoHdrRequested->SamplesPerLine = %d\n", pVBIInfoHdrRequested->SamplesPerLine));
    DBGINFO(("pVBIInfoHdrRequested->StrideInBytes = %d\n", pVBIInfoHdrRequested->StrideInBytes));
    DBGINFO(("pVBIInfoHdrRequested->BufferSize = %d\n", pVBIInfoHdrRequested->BufferSize));

	m_pVBIInfoHeader = &m_VBIFrameInfo.VBIInfoHeader;

    // Copy the VBIINFOHEADER requested to our storage
    RtlCopyMemory(
            m_pVBIInfoHeader,
            pVBIInfoHdrRequested,
            sizeof(KS_VBIINFOHEADER));

	Startup(puiErrorCode);
}

CWDMVBICaptureStream::~CWDMVBICaptureStream()
{
	DBGTRACE(("CWDMVBICaptureStream::~CWDMVBICaptureStream()\n"));
	Shutdown();
}


BOOL CWDMVBICaptureStream::GetCaptureHandle()
{    

    if (m_hCapture == 0)
    {
        DBGTRACE(("Stream %d getting capture handle\n", m_pStreamObject->StreamNumber));
        
        DDOPENVPCAPTUREDEVICEIN  ddOpenCaptureIn;
        DDOPENVPCAPTUREDEVICEOUT ddOpenCaptureOut;

        RtlZeroMemory(&ddOpenCaptureIn, sizeof(ddOpenCaptureIn));
        RtlZeroMemory(&ddOpenCaptureOut, sizeof(ddOpenCaptureOut));

        ddOpenCaptureIn.hDirectDraw = m_pVideoPort->GetDirectDrawHandle();
        ddOpenCaptureIn.hVideoPort = m_pVideoPort->GetVideoPortHandle();
        ddOpenCaptureIn.pfnCaptureClose = DirectDrawEventCallback;
        ddOpenCaptureIn.pContext = this;

        if ((!ddOpenCaptureIn.hDirectDraw)||
            (!ddOpenCaptureIn.hVideoPort)||
            (!ddOpenCaptureIn.pfnCaptureClose)||
            (!ddOpenCaptureIn.pContext))
        {
            return FALSE;
        }
        // Now to get the size, etc
		int xOrigin, yOrigin;
		m_pDevice->GetVBISurfaceOrigin(&xOrigin, &yOrigin);
        ddOpenCaptureIn.dwStartLine = 0 + yOrigin;
        ddOpenCaptureIn.dwEndLine = NTSCVBILines - 1 + yOrigin;

        // Fail-safe
        if (ddOpenCaptureIn.dwStartLine > 500)
        {
            DBGERROR(("Unexpected VBI start line = %d. Using default\n"));
            ddOpenCaptureIn.dwStartLine = m_pVBIInfoHeader->StartLine - VREFDiscard - 1;

        }

        if (ddOpenCaptureIn.dwEndLine > 500)
        {
            DBGERROR(("Unexpected VBI end line. Using default\n"));
            ddOpenCaptureIn.dwEndLine = m_pVBIInfoHeader->EndLine - VREFDiscard - 1;
        }

        DBGINFO(("VBI surface: %d, %d\n",
            ddOpenCaptureIn.dwStartLine,
            ddOpenCaptureIn.dwEndLine));

        ddOpenCaptureIn.dwFlags = DDOPENCAPTURE_VBI;
        ddOpenCaptureIn.dwCaptureEveryNFields = 1;
            
        DxApi(DD_DXAPI_OPENVPCAPTUREDEVICE, &ddOpenCaptureIn, sizeof(ddOpenCaptureIn), &ddOpenCaptureOut, sizeof(ddOpenCaptureOut));

        if (ddOpenCaptureOut.ddRVal != DD_OK)
        {
            m_hCapture = 0;
            DBGERROR(("DD_DXAPI_OPENVPCAPTUREDEVICE failed.\n"));
            // TRAP();
            return FALSE;
        }
        else
        {
            m_hCapture = ddOpenCaptureOut.hCapture;
        }
    }
    return TRUE;
}   


VOID CWDMVBICaptureStream::SetFrameInfo(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PSRB_DATA_EXTENSION      pSrbExt = (PSRB_DATA_EXTENSION)pSrb->SRBExtension;
    PKSSTREAM_HEADER    pDataPacket = pSrb->CommandData.DataBufferArray;
    
    LONGLONG droppedThisTime = 0;
    PKS_VBI_FRAME_INFO  pFrameInfo = (PKS_VBI_FRAME_INFO) (pDataPacket + 1);

    m_VBIFrameInfo.dwFrameFlags = 0;
    m_VBIFrameInfo.ExtendedHeaderSize = pFrameInfo->ExtendedHeaderSize;

    // Set the discontinuity flag if frames have been previously dropped.
    if ((m_VBIFrameInfo.PictureNumber + 1) <
        pSrbExt->ddCapBuffInfo.dwFieldNumber)
    {
        droppedThisTime =
        pSrbExt->ddCapBuffInfo.dwFieldNumber -
        (m_VBIFrameInfo.PictureNumber + 1);
        m_VBIFrameInfo.DropCount += droppedThisTime;
        pDataPacket->OptionsFlags |= KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY;
#ifdef DEBUG
        static int j;
        DBGERROR((" D%d ", droppedThisTime));
        if ((++j % 10) == 0)
        {
            DBGERROR(("\n"));
        }
#endif
    }
    m_VBIFrameInfo.PictureNumber = pSrbExt->ddCapBuffInfo.dwFieldNumber;
    m_VBIFrameInfo.dwSamplingFrequency = SamplingFrequency;

    if (m_pVideoDecoder->GetTunerInfo(&m_VBIFrameInfo.TvTunerChangeInfo))
    {
        m_VBIFrameInfo.dwFrameFlags |= KS_VBI_FLAG_TVTUNER_CHANGE;
#ifdef DEBUG
        if (m_VBIFrameInfo.TvTunerChangeInfo.dwFlags & KS_TVTUNER_CHANGE_BEGIN_TUNE)
        {
            DBGTRACE(("Sending KS_TVTUNER_CHANGE_BEGIN_TUNE.\n"));
        }
        else if (m_VBIFrameInfo.TvTunerChangeInfo.dwFlags & KS_TVTUNER_CHANGE_END_TUNE)
        {
            DBGTRACE(("Sending KS_TVTUNER_CHANGE_END_TUNE.\n"));
        }
        else
        {
            DBGERROR(("Unexpected value in TVTunerChangeInfo.dwFlags\n"));
        }
#endif
    }

    if (!m_bVBIinitialized)
    {
        m_VBIFrameInfo.dwFrameFlags |= KS_VBI_FLAG_VBIINFOHEADER_CHANGE;
		m_bVBIinitialized = TRUE;
    }

    if (pSrbExt->ddCapBuffInfo.bPolarity)
    {
        m_VBIFrameInfo.dwFrameFlags |= KS_VIDEO_FLAG_FIELD2;
    }
    else
    {
        m_VBIFrameInfo.dwFrameFlags |= KS_VIDEO_FLAG_FIELD1;
    }

    *pFrameInfo = (KS_VBI_FRAME_INFO)m_VBIFrameInfo;
}

void CWDMVBICaptureStream::ResetFrameCounters()
{
	m_VBIFrameInfo.PictureNumber = 0;
	m_VBIFrameInfo.DropCount = 0;
}

void CWDMVBICaptureStream::GetDroppedFrames(PKSPROPERTY_DROPPEDFRAMES_CURRENT_S pDroppedFrames)
{
	pDroppedFrames->PictureNumber = m_VBIFrameInfo.PictureNumber;
	pDroppedFrames->DropCount = m_VBIFrameInfo.DropCount;
	pDroppedFrames->AverageFrameSize = m_pVBIInfoHeader->BufferSize;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\bt-829\decdev.cpp ===
//==========================================================================;
//
//	Video Decoder Device abstract base class implementation
//
//		$Date:   28 Aug 1998 14:43:00  $
//	$Revision:   1.2  $
//	  $Author:   Tashjian  $
//
// $Copyright:	(c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;


extern "C"
{
#include "strmini.h"
#include "ksmedia.h"
}

#include "wdmdrv.h"
#include "decdev.h"

#include "capdebug.h"

#include "wdmvdec.h"

/*^^*
 *		CVideoDecoderDevice()
 * Purpose	: CVideoDecoderDevice class constructor
 *
 * Inputs	: PDEVICE_OBJECT pDeviceObject		: pointer to the Driver object to access the Registry
 *
 * Outputs	: none
 * Author	: IKLEBANOV
 *^^*/

CVideoDecoderDevice::CVideoDecoderDevice()
        : m_pDecoder(NULL),
          m_bOutputEnabledSet(FALSE)
{
}

CVideoDecoderDevice::~CVideoDecoderDevice()
{
}

// -------------------------------------------------------------------
// XBar Property Set functions
// -------------------------------------------------------------------

//
// The only property to set on the XBar selects the input to use
//

/* Method: CVideoDecoderDevice::GetCrossbarProperty
 * Purpose:
 */
VOID CVideoDecoderDevice::SetCrossbarProperty(PHW_STREAM_REQUEST_BLOCK pSrb)
{
   PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
   ULONG Id  = pSPD->Property->Id;              // index of the property
   ULONG nS  = pSPD->PropertyOutputSize;        // size of data supplied

   pSrb->Status = STATUS_SUCCESS;

   switch (Id) {
   case KSPROPERTY_CROSSBAR_ROUTE:
      {
         PKSPROPERTY_CROSSBAR_ROUTE_S  pRoute =
            (PKSPROPERTY_CROSSBAR_ROUTE_S)pSPD->PropertyInfo;

         ASSERT (nS >= sizeof (KSPROPERTY_CROSSBAR_ROUTE_S));

         // Copy the input property info to the output property info
         RtlCopyMemory(pRoute, pSPD->Property, sizeof KSPROPERTY_CROSSBAR_ROUTE_S);

         ULONG InPin, OutPin;
         InPin  = pRoute->IndexInputPin;
         OutPin = pRoute->IndexOutputPin;

         if (GoodPins(InPin, OutPin)) {

            if (TestRoute(InPin, OutPin)) {
               pRoute->CanRoute = TRUE;
               SetVideoInput(InPin);

               // this just sets the association
               Route(OutPin, InPin);
            } else
               pRoute->CanRoute = FALSE;
         } else
            pRoute->CanRoute = 0;
      }
      pSrb->ActualBytesTransferred = sizeof KSPROPERTY_CROSSBAR_ROUTE_S;
      break;
   default:
      TRAP();
      pSrb->Status = STATUS_NOT_IMPLEMENTED;
      pSrb->ActualBytesTransferred = 0;
      break;
   }
}

/* Method: CVideoDecoderDevice::GetCrossbarProperty
 * Purpose:
 */
VOID CVideoDecoderDevice::GetCrossbarProperty(PHW_STREAM_REQUEST_BLOCK pSrb)
{
   PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
   ULONG Id = pSPD->Property->Id;              // index of the property
   PLONG pL = (PLONG) pSPD->PropertyInfo;     // pointer to the data
   ULONG nS = pSPD->PropertyOutputSize;        // size of data supplied

   pSrb->Status = STATUS_SUCCESS;

   // Property set specific structure

   switch (Id) {
   case KSPROPERTY_CROSSBAR_CAPS:                  // R
      if (nS >= sizeof KSPROPERTY_CROSSBAR_CAPS_S) {

         PKSPROPERTY_CROSSBAR_CAPS_S  pCaps =
            (PKSPROPERTY_CROSSBAR_CAPS_S)pSPD->PropertyInfo;

         // Copy the input property info to the output property info
         RtlCopyMemory(pCaps, pSPD->Property, sizeof KSPROPERTY_CROSSBAR_CAPS_S);

         pCaps->NumberOfInputs  = GetNoInputs();
         pCaps->NumberOfOutputs = GetNoOutputs();

         pSrb->ActualBytesTransferred = sizeof KSPROPERTY_CROSSBAR_CAPS_S;
      }
      break;
   case KSPROPERTY_CROSSBAR_CAN_ROUTE:
      if (nS >= sizeof KSPROPERTY_CROSSBAR_ROUTE_S) {

         PKSPROPERTY_CROSSBAR_ROUTE_S  pRoute =
            (PKSPROPERTY_CROSSBAR_ROUTE_S)pSPD->PropertyInfo;

         // Copy the input property info to the output property info
         RtlCopyMemory(pRoute, pSPD->Property, sizeof KSPROPERTY_CROSSBAR_ROUTE_S);

         int InPin, OutPin;
         InPin  = pRoute->IndexInputPin;
         OutPin = pRoute->IndexOutputPin;

         if (GoodPins(InPin, OutPin)) {
            pRoute->CanRoute = TestRoute(InPin, OutPin);
         } else {
            pRoute->CanRoute = FALSE;
         }
         pSrb->ActualBytesTransferred = sizeof KSPROPERTY_CROSSBAR_ROUTE_S;
      }
      break;
   case KSPROPERTY_CROSSBAR_ROUTE:
      if (nS >= sizeof KSPROPERTY_CROSSBAR_ROUTE_S) {

         PKSPROPERTY_CROSSBAR_ROUTE_S  pRoute =
            (PKSPROPERTY_CROSSBAR_ROUTE_S)pSPD->PropertyInfo;

         // Copy the input property info to the output property info
         RtlCopyMemory(pRoute, pSPD->Property, sizeof KSPROPERTY_CROSSBAR_ROUTE_S);

         int OutPin = pRoute->IndexOutputPin;

         if (OutPin < GetNoOutputs())
            pRoute->IndexInputPin = GetRoute(OutPin);
         else
            pRoute->IndexInputPin = -1;

         pSrb->ActualBytesTransferred = sizeof KSPROPERTY_CROSSBAR_ROUTE_S;
      }
      break;
   case KSPROPERTY_CROSSBAR_PININFO:                     // R
      if (nS >= sizeof KSPROPERTY_CROSSBAR_PININFO_S) {

         PKSPROPERTY_CROSSBAR_PININFO_S  pPinInfo =
            (PKSPROPERTY_CROSSBAR_PININFO_S)pSPD->PropertyInfo;

         // Copy the input property info to the output property info
         RtlCopyMemory(pPinInfo, pSPD->Property, sizeof KSPROPERTY_CROSSBAR_PININFO_S);

         pPinInfo->PinType = GetPinInfo(pPinInfo->Direction,
                pPinInfo->Index, 
                pPinInfo->RelatedPinIndex);

         pPinInfo->Medium = * GetPinMedium(pPinInfo->Direction,
                pPinInfo->Index);

         pSrb->ActualBytesTransferred = sizeof KSPROPERTY_CROSSBAR_PININFO_S;
      }
   break;
   default:
       TRAP();
       pSrb->Status = STATUS_NOT_IMPLEMENTED;
       pSrb->ActualBytesTransferred = 0;
       break;
   }
}

// -------------------------------------------------------------------
// Decoder functions
// -------------------------------------------------------------------

/*
** CVideoDecoderDevice::SetDecoderProperty ()
**
**    Handles Set operations on the Decoder property set.
**
** Arguments:
**
**      pSRB -
**          Pointer to the HW_STREAM_REQUEST_BLOCK 
**
** Returns:
**
** Side Effects:  none
*/

VOID CVideoDecoderDevice::SetDecoderProperty(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    ULONG Id = pSPD->Property->Id;              // index of the property
    PKSPROPERTY_VIDEODECODER_S pS = (PKSPROPERTY_VIDEODECODER_S) pSPD->PropertyInfo;

    ASSERT (pSPD->PropertyInputSize >= sizeof (PKSPROPERTY_VIDEODECODER_S));

    pSrb->Status = STATUS_SUCCESS;

    switch (Id) {

        case KSPROPERTY_VIDEODECODER_STANDARD:
            DBGTRACE(("KSPROPERTY_VIDEODECODER_STANDARD.\n"));

			if (!SetVideoDecoderStandard(pS->Value))
            {
                DBGERROR(("Unsupported video standard.\n"));
                pSrb->Status = STATUS_UNSUCCESSFUL;
            }
            break;

        case KSPROPERTY_VIDEODECODER_OUTPUT_ENABLE:
            DBGTRACE(("KSPROPERTY_VIDEODECODER_OUTPUT_ENABLE.\n"));

            // Should we leave this property as it was and add a new
            // property that supports the new behavior? 

            // We probably should allow this if the filter is stopped because
            // the transition to Acquire/Pause/Run will fail if the
            // PreEvent has not been cleared by then. We'll have to add
            // some logic to this class to track the filter's state.

            if (pS->Value && m_pDecoder && m_pDecoder->PreEventOccurred())
            {
                DBGERROR(("Output enabled when preevent has occurred.\n"));
                pSrb->Status = STATUS_UNSUCCESSFUL;
            }
            else
            {
                SetOutputEnabled(pS->Value);
                SetOutputEnabledOverridden(TRUE);
            }
            break;

        default:
            TRAP();
            break;
    }
}

/*
** CVideoDecoderDevice::GetDecoderProperty ()
**
**    Handles Get operations on the Decoder property set.
**
** Arguments:
**
**      pSRB -
**          Pointer to the HW_STREAM_REQUEST_BLOCK 
**
** Returns:
**
** Side Effects:  none
*/

VOID CVideoDecoderDevice::GetDecoderProperty(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    ULONG Id = pSPD->Property->Id;              // index of the property

    switch (Id) {

        case KSPROPERTY_VIDEODECODER_CAPS:
        {
            DBGTRACE(("KSPROPERTY_VIDEODECODER_CAPS\n"));
            ASSERT (pSPD->PropertyOutputSize >= sizeof (PKSPROPERTY_VIDEODECODER_CAPS_S));

			GetVideoDecoderCaps((PKSPROPERTY_VIDEODECODER_CAPS_S)pSPD->PropertyInfo);

            pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_VIDEODECODER_CAPS_S);
        }
        break;
        
        case KSPROPERTY_VIDEODECODER_STANDARD:
        {
            DBGTRACE(("KSPROPERTY_VIDEODECODER_STANDARD\n"));
            ASSERT (pSPD->PropertyOutputSize >= sizeof (PKSPROPERTY_VIDEODECODER_S));

            PKSPROPERTY_VIDEODECODER_S pS = (PKSPROPERTY_VIDEODECODER_S) pSPD->PropertyInfo;    // pointer to the data

            pS->Value = GetVideoDecoderStandard();

            pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_VIDEODECODER_S);
        }
        break;

        case KSPROPERTY_VIDEODECODER_STATUS:
        {
            DBGTRACE(("KSPROPERTY_VIDEODECODER_STATUS\n"));
            ASSERT (pSPD->PropertyOutputSize >= sizeof (PKSPROPERTY_VIDEODECODER_STATUS_S));

			GetVideoDecoderStatus((PKSPROPERTY_VIDEODECODER_STATUS_S)pSPD->PropertyInfo);

            pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_VIDEODECODER_S);
        }
        break;

        case KSPROPERTY_VIDEODECODER_OUTPUT_ENABLE:
        {
            DBGTRACE(("KSPROPERTY_VIDEODECODER_OUTPUT_ENABLE\n"));
            ASSERT (pSPD->PropertyOutputSize >= sizeof (PKSPROPERTY_VIDEODECODER_S));

            PKSPROPERTY_VIDEODECODER_S pS = (PKSPROPERTY_VIDEODECODER_S) pSPD->PropertyInfo;    // pointer to the data

            pS->Value = IsOutputEnabled();

            pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_VIDEODECODER_S);
        }
        break;

        default:
            TRAP();
            break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\bt-829\drventry.cpp ===
//==========================================================================;
//
//	MiniDriver entry points for stream class driver
//
//		$Date:   05 Aug 1998 11:11:18  $
//	$Revision:   1.0  $
//	  $Author:   Tashjian  $
//
// $Copyright:	(c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

extern "C"
{
#include "strmini.h"
#include "ksmedia.h"
}


#include "DrvEntry.h"
#include "wdmvdec.h"
#include "wdmdrv.h"
#include "capdebug.h"
#include "VidStrm.h"


/*^^*
 *		DriverEntry()
 * Purpose	: Called when an SRB_INITIALIZE_DEVICE request is received
 *
 * Inputs	: IN PDRIVER_OBJECT		pDriverObject
 *			  IN PUNICODE_STRING	pRegistryPath
 *
 * Outputs	: result of StreamClassregisterAdapter()
 * Author	: IKLEBANOV
 *^^*/
extern "C" 
ULONG DriverEntry (	IN PDRIVER_OBJECT	pDriverObject,
					IN PUNICODE_STRING	pRegistryPath )
{
	HW_INITIALIZATION_DATA HwInitData;

	SetMiniDriverDebugLevel(pRegistryPath);

 	DBGTRACE(("DriverEntry\n"));
     
	RtlZeroMemory(&HwInitData, sizeof(HwInitData));

	HwInitData.HwInitializationDataSize = sizeof(HwInitData);

	// Entry points for Port Driver

	HwInitData.HwInterrupt					= NULL; // HwInterrupt;

	HwInitData.HwReceivePacket				= ReceivePacket;
	HwInitData.HwCancelPacket				= CancelPacket;
	HwInitData.HwRequestTimeoutHandler		= TimeoutPacket;

	HwInitData.DeviceExtensionSize			= DeivceExtensionSize();
	HwInitData.PerRequestExtensionSize		= sizeof(SRB_DATA_EXTENSION); 
	HwInitData.FilterInstanceExtensionSize	= 0;
	HwInitData.PerStreamExtensionSize		= streamDataExtensionSize;
	HwInitData.BusMasterDMA					= FALSE;  
	HwInitData.Dma24BitAddresses			= FALSE;
	HwInitData.BufferAlignment				= 3;
	HwInitData.TurnOffSynchronization		= TRUE;
	HwInitData.DmaBufferSize				= 0;

	DBGTRACE(("StreamClassRegisterAdapter\n"));

	return(StreamClassRegisterAdapter(pDriverObject, pRegistryPath, &HwInitData));
}

/*^^*
 *		ReceivePacket()
 * Purpose	: Main entry point for receiving adapter based request SRBs from the Class Driver.
 *				Will always be called at High Priority.
 * Note		: This is an asyncronous entry point.  The request does not complete on return from 
 *				this function, the request only completes when a StreamClassDeviceNotification 
 *				on this request block, of type  DeviceRequestComplete, is issued.
 *
 * Inputs	: PHW_STREAM_REQUEST_BLOCK pSrb	: pointer to the current Srb
 *
 * Outputs	: none
 * Author	: IKLEBANOV
 *^^*/

void STREAMAPI ReceivePacket(IN OUT PHW_STREAM_REQUEST_BLOCK pSrb)
{
    DBGINFO(("ReceivePacket() SRB = %x, Command = %x\n",
		pSrb, pSrb->Command));

    // This needs to be a special case because no spinlocks, etc
    // have been initialized until HwInitialize runs. Even though
    // this minidriver handles synchronization itself, it assumes
    // that no adapter SRBs will arrive until after this one
    // completes.
    if (pSrb->Command == SRB_INITIALIZE_DEVICE)
    {
        DBGTRACE(("SRB_INITIALIZE_DEVICE; SRB=%x\n", pSrb));

        SrbInitializeDevice(pSrb);
        StreamClassDeviceNotification(DeviceRequestComplete, pSrb->HwDeviceExtension, pSrb);
    }
	else
	{
		CWDMVideoDecoder* pCWDMVideoDecoder = (CWDMVideoDecoder*)pSrb->HwDeviceExtension;

		// check the device extension pointer
		if(pCWDMVideoDecoder == NULL)
		{
	        DBGERROR(("ReceivePacket(): Device extension pointer is null!\n"));
			TRAP();
			pSrb->Status = STATUS_INVALID_PARAMETER;
			StreamClassDeviceNotification(DeviceRequestComplete, pSrb->HwDeviceExtension, pSrb);
		}

		pCWDMVideoDecoder->ReceivePacket(pSrb);
	}
}


void STREAMAPI CancelPacket(IN OUT PHW_STREAM_REQUEST_BLOCK pSrb)
{
    CWDMVideoDecoder* pCWDMVideoDecoder = (CWDMVideoDecoder*)pSrb->HwDeviceExtension;

	pCWDMVideoDecoder->CancelPacket(pSrb);
}


void STREAMAPI TimeoutPacket(IN OUT PHW_STREAM_REQUEST_BLOCK pSrb)
{
    CWDMVideoDecoder* pCWDMVideoDecoder = (CWDMVideoDecoder*)pSrb->HwDeviceExtension;

	pCWDMVideoDecoder->TimeoutPacket(pSrb);
}



/*^^*
 *		SrbInitializeDevice()
 * Purpose	: Called when SRB_INITIALIZE_DEVICE SRB is received.
 *				Performs checking of the hardware presence and I2C provider availability.
 *				Sets the hardware in an initial state.
 * Note		: The request does not completed unless we know everything
 *				about the hardware and we are sure it is capable to work in the current configuration.
 *				The hardware Caps are also aquised at this point.
 *
 * Inputs	:	PHW_STREAM_REQUEST_BLOCK pSrb	: pointer to the current Srb
 *
 * Outputs	: none
 * Author	: IKLEBANOV
 *^^*/

void SrbInitializeDevice(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    DBGTRACE(("SrbInitializeDevice()\n"));

	PPORT_CONFIGURATION_INFORMATION pConfigInfo = pSrb->CommandData.ConfigInfo;

    pSrb->Status = STATUS_SUCCESS;

	ENSURE
	{
	    PBYTE pHwDevExt = (PBYTE)pConfigInfo->HwDeviceExtension;

		if (pConfigInfo->NumberOfAccessRanges != 0) {
			DBGERROR(("Illegal config info!\n"));
			pSrb->Status = STATUS_NO_SUCH_DEVICE;
			TRAP();
			FAIL;
		}

		CVideoDecoderDevice * pDevice = InitializeDevice(pConfigInfo, pHwDevExt);
		if (!pDevice)
		{
			DBGERROR(("CI2CScript creation failure!\n"));
			pSrb->Status = STATUS_NO_SUCH_DEVICE;
			TRAP();
			FAIL;
		}

	    CWDMVideoDecoder *pCWDMVideoDecoder = (CWDMVideoDecoder *) new ((PVOID)pHwDevExt)
				CWDMVideoDecoder(pConfigInfo, pDevice);
    
	} END_ENSURE;
    
    DBGTRACE(("Exit : SrbInitializeDevice()\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\bt-829\decdev.h ===
#pragma once

//==========================================================================;
//
//	Video Decoder Device abstract base class definition
//
//		$Date:   28 Aug 1998 14:43:46  $
//	$Revision:   1.1  $
//	  $Author:   Tashjian  $
//
// $Copyright:	(c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;


#include "viddefs.h"
#include "mytypes.h"

class CWDMVideoDecoder;

class CVideoDecoderDevice
{
private:
    BOOL m_bOutputEnabledSet;
    CWDMVideoDecoder* m_pDecoder;


public:
    CVideoDecoderDevice();
    virtual ~CVideoDecoderDevice();

    virtual int GetDefaultDecoderWidth() = 0;
    virtual int GetDefaultDecoderHeight() = 0;

    virtual void SetRect(MRect &) = 0;

    virtual void SetVBIEN(BOOL b) = 0;
    virtual void SetVBIFMT(BOOL b) = 0;

	virtual void SaveState() = 0;
    virtual void RestoreState(DWORD dwStreamsOpen = -1) = 0;


    void GetCrossbarProperty(PHW_STREAM_REQUEST_BLOCK);
    void SetCrossbarProperty(PHW_STREAM_REQUEST_BLOCK);
		virtual BOOL GoodPins(int InPin, int OutPin) = 0;
		virtual BOOL TestRoute(int InPin, int OutPin) = 0;
		virtual void Route(int OutPin, int InPin) = 0;
		virtual int GetNoInputs() = 0;
		virtual int GetNoOutputs() = 0;
		virtual ULONG GetPinInfo(int dir, int idx, ULONG &related) = 0;
		virtual int GetRoute(int OutPin) = 0;
		virtual KSPIN_MEDIUM * GetPinMedium(int dir, int idx) = 0;

		virtual ErrorCode SetVideoInput(ULONG c) = 0;

    
	virtual NTSTATUS GetProcAmpProperty(ULONG, PLONG) = 0;
    virtual NTSTATUS SetProcAmpProperty(ULONG, LONG) = 0;


    void GetDecoderProperty(PHW_STREAM_REQUEST_BLOCK);
		virtual void GetVideoDecoderCaps(PKSPROPERTY_VIDEODECODER_CAPS_S) = 0;
		virtual DWORD GetVideoDecoderStandard() = 0;
		virtual void GetVideoDecoderStatus(PKSPROPERTY_VIDEODECODER_STATUS_S) = 0;
		virtual BOOL IsOutputEnabled() = 0;
    void SetDecoderProperty(PHW_STREAM_REQUEST_BLOCK);
		virtual BOOL SetVideoDecoderStandard(DWORD) = 0;
		virtual void SetOutputEnabled(BOOL) = 0;
                void SetOutputEnabledOverridden(BOOL bOutputEnabledSet)
                {
                    m_bOutputEnabledSet = bOutputEnabledSet;
                }
                BOOL IsOutputEnabledOverridden()
                {
                    return m_bOutputEnabledSet;
                }


	virtual ULONG GetVideoPortProperty(PSTREAM_PROPERTY_DESCRIPTOR pSPD) = 0;
	virtual ULONG GetVideoPortVBIProperty(PSTREAM_PROPERTY_DESCRIPTOR pSPD) = 0;

	virtual void Set16BitDataStream(BOOL b) = 0;
    virtual void SetHighOdd(BOOL b) = 0;
	virtual void ConfigVPSurfaceParams(PKSVPSURFACEPARAMS pSurfaceParams) = 0;
	virtual void ConfigVPVBISurfaceParams(PKSVPSURFACEPARAMS pSurfaceParams) = 0;

    virtual int GetDecoderHeight() = 0;

	virtual void GetVideoSurfaceOrigin(int*, int*) = 0;
	virtual void GetVBISurfaceOrigin(int*, int*) = 0;
        void SetVideoDecoder(CWDMVideoDecoder* pDecoder)
        {
            m_pDecoder = pDecoder;
        }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\bt-829\mediums.cpp ===
//==========================================================================;
//
//	WDM Video Decoder Mediums
//
//		$Date:   05 Aug 1998 11:11:12  $
//	$Revision:   1.0  $
//	  $Author:   Tashjian  $
//
// $Copyright:	(c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

extern "C"
{
#include "strmini.h"
#include "ksmedia.h"
}

#include "mediums.h"


KSPIN_MEDIUM CrossbarMediums[] = {
    {STATIC_MEDIUM_ATIXBAR_VIDEOCOMPOUT,        0, 0},  // Pin 0
    {STATIC_MEDIUM_ATIXBAR_VIDEOTUNEROUT,       0, 0},  // Pin 1
    {STATIC_MEDIUM_ATIXBAR_SVIDEOOUT,           0, 0},  // Pin 2
    {STATIC_MEDIUM_VIDEO_BT829_ANALOGVIDEOIN,   0, 0},  // Pin 3
};

BOOL CrossbarPinDirection [] = {
    FALSE,                      // Input  Pin 0
    FALSE,                      // Input  Pin 1
    FALSE,                      // Input  Pin 2
    TRUE,                       // Output Pin 3
};

// -----------------------------------------------

KSPIN_MEDIUM CaptureMediums[] = {
    {STATIC_GUID_NULL,                          0, 0},  // Pin 0  Vid Capture
    {STATIC_GUID_NULL,                          0, 0},  // Pin 1  Vid VP
    {STATIC_GUID_NULL,                          0, 0},  // Pin 2  VBI Capture
    {STATIC_GUID_NULL,                          0, 0},  // Pin 3  VBI VP
    {STATIC_MEDIUM_VIDEO_BT829_ANALOGVIDEOIN,   0, 0},  // Pin 4  Analog Video In
};

BOOL CapturePinDirection [] = {
    TRUE,                       // Output Pin 0
    TRUE,                       // Output Pin 1
    TRUE,                       // Output Pin 2
    TRUE,                       // Output Pin 3
    FALSE,                      // Input  Pin 4
};

ULONG CrossbarPins()
{
	return SIZEOF_ARRAY (CrossbarMediums);
}

ULONG CapturePins()
{
	return SIZEOF_ARRAY (CaptureMediums);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\bt-829\decvport.cpp ===
//==========================================================================;
//
//	CDecoderVideoPort - Video Port interface implementation
//
//		$Date:   14 Oct 1998 15:09:54  $
//	$Revision:   1.1  $
//	  $Author:   Tashjian  $
//
// $Copyright:	(c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;


extern "C"
{
#include "strmini.h"
#include "ksmedia.h"
#include "ddkmapi.h"
}

#include "wdmdrv.h"
#include "decvport.h"
#include "capdebug.h"
#include "vidstrm.h"


/*^^*
 *		CDecoderVideoPort()
 * Purpose	: CDecoderVideoPort class constructor
 *
 * Inputs	: PDEVICE_OBJECT pDeviceObject		: pointer to the Driver object to access the Registry
 *			  CI2CScript * pCScript 			: pointer to CI2CScript class object
 *
 * Outputs	: none
 * Author	: IKLEBANOV
 *^^*/
CDecoderVideoPort::CDecoderVideoPort(PDEVICE_OBJECT pDeviceObject)
{

	// It's a right place to provide Video Port connection parameters
	// initialization. The custom parameters should be placed in the Registry
	// in a standard way.
	// The list of custom parameters includes:
	//	- Clock type, the decoder runs off : single, double, QCLK
	//	- VACTIVE / VRESET configuration
	//	- HACTIVE / HRESET configuration
	//	- 8 / 16 bits VideoPort connection
	//	- connection type : SPI / embedded (in the case of 8 bits also called ByteSream)

	m_pDeviceObject = pDeviceObject;

	// zero is a valid ID, therefore, set to something
		// else to initialize it.
	m_ring3VideoPortHandle = -1;
}


void CDecoderVideoPort::Open()
{
}

void CDecoderVideoPort::Close()
{
    ReleaseRing0VideoPortHandle();
    m_ring3VideoPortHandle = -1;
    
    ReleaseRing0DirectDrawHandle();
    m_ring3DirectDrawHandle = 0;
}


BOOL CDecoderVideoPort::ReleaseRing0VideoPortHandle()
{
    DWORD ddOut = DD_OK;

    DDCLOSEHANDLE ddClose;

    if (m_ring0VideoPortHandle != 0)
    {
        //DBGTRACE(("Stream %d releasing ring0 vport handle\n", streamNumber));
        
        ddClose.hHandle = m_ring0VideoPortHandle;

        DxApi(DD_DXAPI_CLOSEHANDLE, &ddClose, sizeof(ddClose), &ddOut, sizeof(ddOut));

        if (ddOut != DD_OK)
        {
            DBGERROR(("DD_DXAPI_CLOSEHANDLE failed.\n"));
            TRAP();
            return FALSE;
        }
        m_ring0VideoPortHandle = 0;
    }
    return TRUE;
}

BOOL CDecoderVideoPort::ReleaseRing0DirectDrawHandle()
{
    DWORD ddOut = DD_OK;
    DDCLOSEHANDLE ddClose;

    if (m_ring0DirectDrawHandle != 0)
    {
        //DBGTRACE(("Bt829: Stream %d releasing ring0 ddraw handle\n", streamNumber));
        
        ddClose.hHandle = m_ring0DirectDrawHandle;

        DxApi(DD_DXAPI_CLOSEHANDLE, &ddClose, sizeof(ddClose), &ddOut, sizeof(ddOut));

        if (ddOut != DD_OK)
        {
            DBGERROR(("DD_DXAPI_CLOSEHANDLE failed.\n"));
            TRAP();
            return FALSE;
        }
        m_ring0DirectDrawHandle = 0;
    }
    return TRUE;
}


BOOL CDecoderVideoPort::RegisterForDirectDrawEvents(CWDMVideoPortStream* pStream)
{
    DDREGISTERCALLBACK ddRegisterCallback;
    DWORD ddOut;

//    DBGTRACE(("Stream %d registering for DirectDraw events\n", streamNumber));
    
    // =============== DDEVENT_PRERESCHANGE ===============
    RtlZeroMemory(&ddRegisterCallback, sizeof(ddRegisterCallback));
    RtlZeroMemory(&ddOut, sizeof(ddOut));

    ddRegisterCallback.hDirectDraw = m_ring0DirectDrawHandle;
    ddRegisterCallback.dwEvents = DDEVENT_PRERESCHANGE;
    ddRegisterCallback.pfnCallback = DirectDrawEventCallback;
    ddRegisterCallback.pContext = pStream;

    DxApi(DD_DXAPI_REGISTER_CALLBACK, &ddRegisterCallback, sizeof(ddRegisterCallback), &ddOut, sizeof(ddOut));

    if (ddOut != DD_OK)
    {
        DBGERROR(("DD_DXAPI_REGISTER_CALLBACK failed.\n"));
        TRAP();
        return FALSE;
    }

    // =============== DDEVENT_POSTRESCHANGE ==============
    RtlZeroMemory(&ddRegisterCallback, sizeof(ddRegisterCallback));
    RtlZeroMemory(&ddOut, sizeof(ddOut));

    ddRegisterCallback.hDirectDraw = m_ring0DirectDrawHandle;
    ddRegisterCallback.dwEvents = DDEVENT_POSTRESCHANGE;
    ddRegisterCallback.pfnCallback = DirectDrawEventCallback;
    ddRegisterCallback.pContext = pStream;

    DxApi(DD_DXAPI_REGISTER_CALLBACK, &ddRegisterCallback, sizeof(ddRegisterCallback), &ddOut, sizeof(ddOut));

    if (ddOut != DD_OK)
    {
        DBGERROR(("DD_DXAPI_REGISTER_CALLBACK failed.\n"));
        TRAP();
        return FALSE;
    }

    // =============== DDEVENT_PREDOSBOX =================
    RtlZeroMemory(&ddRegisterCallback, sizeof(ddRegisterCallback));
    RtlZeroMemory(&ddOut, sizeof(ddOut));

    ddRegisterCallback.hDirectDraw = m_ring0DirectDrawHandle;
    ddRegisterCallback.dwEvents = DDEVENT_PREDOSBOX;
    ddRegisterCallback.pfnCallback = DirectDrawEventCallback;
    ddRegisterCallback.pContext = pStream;

    DxApi(DD_DXAPI_REGISTER_CALLBACK, &ddRegisterCallback, sizeof(ddRegisterCallback), &ddOut, sizeof(ddOut));

    if (ddOut != DD_OK)
    {
        DBGERROR(("DD_DXAPI_REGISTER_CALLBACK failed.\n"));
        TRAP();
        return FALSE;
    }

    // =============== DDEVENT_POSTDOSBOX ================
    RtlZeroMemory(&ddRegisterCallback, sizeof(ddRegisterCallback));
    RtlZeroMemory(&ddOut, sizeof(ddOut));

    ddRegisterCallback.hDirectDraw = m_ring0DirectDrawHandle;
    ddRegisterCallback.dwEvents = DDEVENT_POSTDOSBOX;
    ddRegisterCallback.pfnCallback = DirectDrawEventCallback;
    ddRegisterCallback.pContext = pStream;

    DxApi(DD_DXAPI_REGISTER_CALLBACK, &ddRegisterCallback, sizeof(ddRegisterCallback), &ddOut, sizeof(ddOut));

    if (ddOut != DD_OK)
    {
        DBGERROR(("DD_DXAPI_REGISTER_CALLBACK failed.\n"));
        TRAP();
        return FALSE;
    }

    return TRUE;
}


BOOL CDecoderVideoPort::UnregisterForDirectDrawEvents( CWDMVideoPortStream* pStream)
{
    DDREGISTERCALLBACK ddRegisterCallback;
    DWORD ddOut;

//    DBGTRACE(("Stream %d UNregistering for DirectDraw events\n", m_pStreamObject->StreamNumber));
    
    // =============== DDEVENT_PRERESCHANGE ===============
    RtlZeroMemory(&ddRegisterCallback, sizeof(ddRegisterCallback));
    RtlZeroMemory(&ddOut, sizeof(ddOut));

    ddRegisterCallback.hDirectDraw = m_ring0DirectDrawHandle;
    ddRegisterCallback.dwEvents = DDEVENT_PRERESCHANGE ;
    ddRegisterCallback.pfnCallback = DirectDrawEventCallback;
    ddRegisterCallback.pContext = pStream;

    DxApi(DD_DXAPI_UNREGISTER_CALLBACK, &ddRegisterCallback, sizeof(ddRegisterCallback), &ddOut, sizeof(ddOut));

    if (ddOut != DD_OK)
    {
        DBGERROR(("DD_DXAPI_UNREGISTER_CALLBACK failed.\n"));
        TRAP();
        return FALSE;
    }

    // =============== DDEVENT_POSTRESCHANGE ==============
    RtlZeroMemory(&ddRegisterCallback, sizeof(ddRegisterCallback));
    RtlZeroMemory(&ddOut, sizeof(ddOut));

    ddRegisterCallback.hDirectDraw = m_ring0DirectDrawHandle;
    ddRegisterCallback.dwEvents = DDEVENT_POSTRESCHANGE;
    ddRegisterCallback.pfnCallback = DirectDrawEventCallback;
    ddRegisterCallback.pContext = pStream;

    DxApi(DD_DXAPI_UNREGISTER_CALLBACK, &ddRegisterCallback, sizeof(ddRegisterCallback), &ddOut, sizeof(ddOut));

    if (ddOut != DD_OK)
    {
        DBGERROR(("DD_DXAPI_UNREGISTER_CALLBACK failed.\n"));
        TRAP();
        return FALSE;
    }

    // =============== DDEVENT_PREDOSBOX ==================
    RtlZeroMemory(&ddRegisterCallback, sizeof(ddRegisterCallback));
    RtlZeroMemory(&ddOut, sizeof(ddOut));

    ddRegisterCallback.hDirectDraw = m_ring0DirectDrawHandle;
    ddRegisterCallback.dwEvents = DDEVENT_PREDOSBOX;
    ddRegisterCallback.pfnCallback = DirectDrawEventCallback;
    ddRegisterCallback.pContext = pStream;

    DxApi(DD_DXAPI_UNREGISTER_CALLBACK, &ddRegisterCallback, sizeof(ddRegisterCallback), &ddOut, sizeof(ddOut));

    if (ddOut != DD_OK)
    {
        DBGERROR(("DD_DXAPI_UNREGISTER_CALLBACK failed.\n"));
        TRAP();
        return FALSE;
    }

    // =============== DDEVENT_POSTDOSBOX =================
    RtlZeroMemory(&ddRegisterCallback, sizeof(ddRegisterCallback));
    RtlZeroMemory(&ddOut, sizeof(ddOut));

    ddRegisterCallback.hDirectDraw = m_ring0DirectDrawHandle;
    ddRegisterCallback.dwEvents = DDEVENT_POSTDOSBOX;
    ddRegisterCallback.pfnCallback = DirectDrawEventCallback;
    ddRegisterCallback.pContext = pStream;

    DxApi(DD_DXAPI_UNREGISTER_CALLBACK, &ddRegisterCallback, sizeof(ddRegisterCallback), &ddOut, sizeof(ddOut));

    if (ddOut != DD_OK)
    {
        DBGERROR(("DD_DXAPI_UNREGISTER_CALLBACK failed.\n"));
        TRAP();
        return FALSE;
    }
    
    return TRUE;
}


BOOL CDecoderVideoPort::GetRing0DirectDrawHandle()
{
    if (m_ring0DirectDrawHandle == 0)
    {
//        DBGTRACE(("Stream %d getting ring0 ddraw handle\n", streamNumber));
        
        DDOPENDIRECTDRAWIN  ddOpenIn;
        DDOPENDIRECTDRAWOUT ddOpenOut;

        RtlZeroMemory(&ddOpenIn, sizeof(ddOpenIn));
        RtlZeroMemory(&ddOpenOut, sizeof(ddOpenOut));

        ddOpenIn.dwDirectDrawHandle = m_ring3DirectDrawHandle;
        ddOpenIn.pfnDirectDrawClose = DirectDrawEventCallback;
        ddOpenIn.pContext = this;

        DxApi(DD_DXAPI_OPENDIRECTDRAW, &ddOpenIn, sizeof(ddOpenIn), &ddOpenOut, sizeof(ddOpenOut));

        if (ddOpenOut.ddRVal != DD_OK)
        {
            m_ring0DirectDrawHandle = 0;
            DBGERROR(("DD_DXAPI_OPENDIRECTDRAW failed.\n"));
            TRAP();
            return FALSE;
        }
        else
        {
            m_ring0DirectDrawHandle = ddOpenOut.hDirectDraw;
        }
    }
    return TRUE;
}
    

BOOL CDecoderVideoPort::GetRing0VideoPortHandle()
{
    if (m_ring0VideoPortHandle == 0)
    {
//        DBGTRACE(("Stream %d getting ring0 vport handle\n", streamNumber));
        
        DDOPENVIDEOPORTIN  ddOpenVPIn;
        DDOPENVIDEOPORTOUT ddOpenVPOut;
        RtlZeroMemory(&ddOpenVPIn, sizeof(ddOpenVPIn));
        RtlZeroMemory(&ddOpenVPOut, sizeof(ddOpenVPOut));

        ddOpenVPIn.hDirectDraw = m_ring0DirectDrawHandle;
        ddOpenVPIn.pfnVideoPortClose = DirectDrawEventCallback;
        ddOpenVPIn.pContext = this;

        ddOpenVPIn.dwVideoPortHandle = m_ring3VideoPortHandle;
        
        DxApi(DD_DXAPI_OPENVIDEOPORT, &ddOpenVPIn, sizeof(ddOpenVPIn), &ddOpenVPOut, sizeof(ddOpenVPOut));

        if (ddOpenVPOut.ddRVal != DD_OK)
        {
            m_ring0VideoPortHandle = 0;
            DBGERROR(("DD_DXAPI_OPENVIDEOPORT failed.\n"));
            TRAP();
            return FALSE;
        }
        else
        {
            m_ring0VideoPortHandle = ddOpenVPOut.hVideoPort;
        }
    }    
    return TRUE;
}


BOOL CDecoderVideoPort::ConfigVideoPortHandle(ULONG info)
{
    if (m_ring3VideoPortHandle == -1)
    {
        m_ring3VideoPortHandle = info;
        
        if (!GetRing0VideoPortHandle())
        {
            return FALSE;
        }
    }
	return TRUE;
}


BOOL CDecoderVideoPort::ConfigDirectDrawHandle(ULONG info)
{
    if (m_ring3DirectDrawHandle == NULL)
    {
        m_ring3DirectDrawHandle = info;
        
        if (!GetRing0DirectDrawHandle())
        {
            return FALSE;
        }
    }
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\bt-829\decvport.h ===
#pragma once

//==========================================================================;
//
//	CDecoderVideoPort - Video Port interface definitions
//
//		$Date:   14 Oct 1998 15:11:14  $
//	$Revision:   1.1  $
//	  $Author:   Tashjian  $
//
// $Copyright:	(c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;


#include "i2script.h"
#include "aticonfg.h"


#define DD_OK 0


class CWDMVideoPortStream;

class CDecoderVideoPort
{
public:
	CDecoderVideoPort(PDEVICE_OBJECT pDeviceObject);

// Attributes	
private:
	PDEVICE_OBJECT			m_pDeviceObject;	

	CATIHwConfiguration *	m_pCATIConfig;

    ULONG                   m_ring3VideoPortHandle;
    ULONG                   m_ring3DirectDrawHandle;

    HANDLE                  m_ring0VideoPortHandle;
    HANDLE                  m_ring0DirectDrawHandle;

	BOOL GetRing0VideoPortHandle();
	BOOL GetRing0DirectDrawHandle();
	
	// Implementation
public:
	void Open();
	void Close();

	BOOL RegisterForDirectDrawEvents( CWDMVideoPortStream* pStream);
	BOOL UnregisterForDirectDrawEvents( CWDMVideoPortStream* pStream);

	BOOL ReleaseRing0VideoPortHandle();
	BOOL ReleaseRing0DirectDrawHandle();		

	BOOL ConfigVideoPortHandle(ULONG info);
	BOOL ConfigDirectDrawHandle(ULONG info);

	HANDLE GetVideoPortHandle()		{ return m_ring0VideoPortHandle; }
	HANDLE GetDirectDrawHandle()	{ return m_ring0DirectDrawHandle; }

	void CloseDirectDraw() {
                m_ring0DirectDrawHandle = 0;
                m_ring3DirectDrawHandle = 0;
		}

	void CloseVideoPort()  {
                m_ring0VideoPortHandle = 0;
                m_ring3VideoPortHandle = -1;
		}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\bt-829\mediums.h ===
#pragma once

//==========================================================================;
//
//	WDM Video Decoder Mediums
//
//		$Date:   05 Aug 1998 11:22:40  $
//	$Revision:   1.0  $
//	  $Author:   Tashjian  $
//
// $Copyright:	(c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

/*
-----------------------------------------------------------

                            PinDir  FilterPin#
    Crossbar
        CompositeIn         in          0
        TunerIn             in          1
        SVideo              in          2
        Decoder             out         3
        
-----------------------------------------------------------
*/

// {6001AFE0-39A7-11d1-821D-0000F8300212}
#define STATIC_MEDIUM_ATIXBAR_VIDEOCOMPOUT \
0x6001afe0, 0x39a7, 0x11d1, 0x82, 0x1d, 0x0, 0x0, 0xf8, 0x30, 0x2, 0x12
//  0x6001afe0, 0x39a7, 0x11d1, 0x82, 0x1d, 0x0, 0x0, 0xf8, 0x30, 0x2, 0x12
DEFINE_GUIDSTRUCT("6001AFE0-39A7-11d1-821D-0000F8300212", MEDIUM_ATIXBAR_VIDEOCOMPOUT);
#define MEDIUM_ATIXBAR_VIDEOCOMPOUT DEFINE_GUIDNAMED(MEDIUM_ATIXBAR_VIDEOCOMPOUT)

// {AE8F28C0-3346-11d1-821D-0000F8300212}
#define STATIC_MEDIUM_ATIXBAR_VIDEOTUNEROUT \
    0xae8f28c0, 0x3346, 0x11d1,  0x82, 0x1d, 0x0, 0x0, 0xf8, 0x30, 0x2, 0x12 
DEFINE_GUIDSTRUCT("AE8F28C0-3346-11d1-821D-0000F8300212", MEDIUM_ATIXBAR_VIDEOTUNEROUT);
#define MEDIUM_ATIXBAR_VIDEOTUNEROUT DEFINE_GUIDNAMED(MEDIUM_ATIXBAR_VIDEOTUNEROUT)

// {6001AFE1-39A7-11d1-821D-0000F8300212}
#define STATIC_MEDIUM_ATIXBAR_SVIDEOOUT \
0x6001afe1, 0x39a7, 0x11d1, 0x82, 0x1d, 0x0, 0x0, 0xf8, 0x30, 0x2, 0x12 
DEFINE_GUIDSTRUCT("6001AFE1-39A7-11d1-821D-0000F8300212", MEDIUM_ATIXBAR_SVIDEOOUT);
#define MEDIUM_ATIXBAR_SVIDEOOUT DEFINE_GUIDNAMED(MEDIUM_ATIXBAR_SVIDEOOUT)

// {CEA3DBE0-0A58-11d1-A317-00A0C90C484A}
#define STATIC_MEDIUM_VIDEO_BT829_ANALOGVIDEOIN \
    0xcea3dbe0, 0xa58, 0x11d1, 0xa3, 0x17, 0x0, 0xa0, 0xc9, 0xc, 0x48, 0x4a
DEFINE_GUIDSTRUCT("CEA3DBE0-0A58-11d1-A317-00A0C90C484A", MEDIUM_VIDEO_BT829_ANALOGVIDEOIN);
#define MEDIUM_VIDEO_BT829_ANALOGVIDEOIN DEFINE_GUIDNAMED(MEDIUM_VIDEO_BT829_ANALOGVIDEOIN)


extern KSPIN_MEDIUM CrossbarMediums[];
extern KSPIN_MEDIUM CaptureMediums[];

extern BOOL CrossbarPinDirection [];
extern BOOL CapturePinDirection [];

extern ULONG CrossbarPins();
extern ULONG CapturePins();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\bt-829\drventry.h ===
#pragma once

//==========================================================================;
//
//	MiniDriver entry points for stream class driver
//
//		$Date:   05 Aug 1998 11:22:42  $
//	$Revision:   1.0  $
//	  $Author:   Tashjian  $
//
// $Copyright:	(c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

extern "C"
{
#include "strmini.h"
#include "ksmedia.h"
}

#include "wdmvdec.h"

//	Call-backs from the StreamClass
void STREAMAPI ReceivePacket		(PHW_STREAM_REQUEST_BLOCK pSrb);
void STREAMAPI CancelPacket			(PHW_STREAM_REQUEST_BLOCK pSrb);
void STREAMAPI TimeoutPacket		(PHW_STREAM_REQUEST_BLOCK pSrb);


// Local prototypes
void SrbInitializeDevice(PHW_STREAM_REQUEST_BLOCK pSrb);
CVideoDecoderDevice * InitializeDevice(PPORT_CONFIGURATION_INFORMATION, PBYTE);
size_t DeivceExtensionSize();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\bt-829\ourcrt.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#ifdef __cplusplus
extern "C" {

#include "strmini.h"
#include "ksmedia.h"
}
#endif

extern "C" const int _fltused = 0;

/*
 * This function serves to avoid linking CRT code
 */

int __cdecl  _purecall(void)
{
    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\bt-829\vidstrm.h ===
#pragma once

//==========================================================================;
//
//	CWDMVideoStream - WDM Video Stream base class definition
//
//		$Date:   22 Feb 1999 15:48:34  $
//	$Revision:   1.2  $
//	  $Author:   KLEBANOV  $
//
// $Copyright:	(c) 1997 - 1999  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

#include "i2script.h"
#include "aticonfg.h"


#include "decdev.h"
#include "decvport.h"


typedef enum {
    STREAM_VideoCapture,
    STREAM_VPVideo,
    STREAM_VBICapture,
    STREAM_VPVBI,
    STREAM_AnalogVideoInput
}; 


class CWDMVideoDecoder;

class CWDMVideoStream
{
public:

	CWDMVideoStream(PHW_STREAM_OBJECT pStreamObject,
					CWDMVideoDecoder * pCWDMVideoDecoder,
					PUINT puiError);
	virtual ~CWDMVideoStream();

	void * operator new(size_t size, void * pAllocation) { return(pAllocation);}
	void operator delete(void * pAllocation) {}

	virtual VOID STREAMAPI VideoReceiveDataPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb);
	VOID STREAMAPI VideoReceiveCtrlPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb);
	virtual void TimeoutPacket(IN OUT PHW_STREAM_REQUEST_BLOCK pSrb);

	VOID VideoGetState(PHW_STREAM_REQUEST_BLOCK);
	virtual VOID VideoSetState(PHW_STREAM_REQUEST_BLOCK, BOOL bVPConnected, BOOL bVPVBIConnected);

	virtual VOID VideoGetProperty(PHW_STREAM_REQUEST_BLOCK);
	virtual VOID VideoSetProperty(PHW_STREAM_REQUEST_BLOCK);

	VOID VideoStreamGetConnectionProperty (PHW_STREAM_REQUEST_BLOCK);
	VOID VideoIndicateMasterClock (PHW_STREAM_REQUEST_BLOCK);

	virtual void CancelPacket( PHW_STREAM_REQUEST_BLOCK)
	{
	};

protected:
	PHW_STREAM_OBJECT			m_pStreamObject;

    // General purpose lock. We could use a separate one
    // for each queue, but this keeps things a little
    // more simple. Since it is never held for very long,
    // this shouldn't be a big performance hit.

    KSSTATE                     m_KSState;            // Run, Stop, Pause

    HANDLE                      m_hMasterClock;       // 
	
	// -------------------


    CWDMVideoDecoder *			m_pVideoDecoder;
	CDecoderVideoPort *			m_pVideoPort;
	CVideoDecoderDevice *		m_pDevice;

private:

    // Control SRBs go here
    LIST_ENTRY                  m_ctrlSrbQueue;
    KSPIN_LOCK                  m_ctrlSrbLock;

    // Flag to indicate whether or not we are currently
    // busy processing a control SRB
    BOOL                        m_processingCtrlSrb;
};


//
// prototypes for data handling routines
//

VOID STREAMAPI VideoReceiveDataPacket(IN PHW_STREAM_REQUEST_BLOCK);
VOID STREAMAPI VideoReceiveCtrlPacket(IN PHW_STREAM_REQUEST_BLOCK);

DWORD FAR PASCAL DirectDrawEventCallback(DWORD dwEvent, PVOID pContext, DWORD dwParam1, DWORD dwParam2);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\bt-829\vidstrm.cpp ===
//==========================================================================;
//
//	CWDMVideoStream - WDM Video Stream base class implementation
//
//		$Date:   05 Aug 1998 11:10:52  $
//	$Revision:   1.0  $
//	  $Author:   Tashjian  $
//
// $Copyright:	(c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

extern "C"
{
#include "strmini.h"
#include "ksmedia.h"
}

#include "wdmvdec.h"
#include "wdmdrv.h"
#include "device.h"
#include "aticonfg.h"
#include "capdebug.h"
#include "StrmInfo.h"


/*
** VideoReceiveDataPacket()
**
**   Receives Video data packet commands
**
** Arguments:
**
**   pSrb - Stream request block for the Video stream
**
** Returns: nothing
**
** Side Effects:  none
*/

VOID STREAMAPI VideoReceiveDataPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb)
{
	CWDMVideoStream * pVideoStream = (CWDMVideoStream *)pSrb->StreamObject->HwStreamExtension;
	pVideoStream->VideoReceiveDataPacket(pSrb);
}


/*
** VideoReceiveCtrlPacket()
**
**   Receives packet commands that control the Video stream
**
** Arguments:
**
**   pSrb - The stream request block for the Video stream
**
** Returns: nothing
**
** Side Effects:  none
*/

VOID STREAMAPI VideoReceiveCtrlPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb)
{
	CWDMVideoStream * pVideoStream = (CWDMVideoStream *)pSrb->StreamObject->HwStreamExtension;
	pVideoStream->VideoReceiveCtrlPacket(pSrb);
}




void CWDMVideoStream::TimeoutPacket(IN OUT PHW_STREAM_REQUEST_BLOCK pSrb)
{
    if (m_KSState == KSSTATE_STOP || !m_pVideoDecoder->PreEventOccurred())
    {
        DBGTRACE(("Suspicious timeout. SRB %8x. \n", pSrb));
	}
}



CWDMVideoStream::CWDMVideoStream(PHW_STREAM_OBJECT pStreamObject, 
						CWDMVideoDecoder * pVideoDecoder,
						PUINT puiErrorCode)
	:	m_pStreamObject(pStreamObject),
		m_pVideoDecoder(pVideoDecoder)
{
	DBGTRACE(("CWDMVideoStream::CWDMVideoStream\n"));

	m_pVideoPort = m_pVideoDecoder->GetVideoPort();
	m_pDevice = m_pVideoDecoder->GetDevice();

    KeInitializeSpinLock(&m_ctrlSrbLock);
    InitializeListHead(&m_ctrlSrbQueue);

	m_KSState = KSSTATE_STOP;
 
	*puiErrorCode = WDMMINI_NOERROR;
}


CWDMVideoStream::~CWDMVideoStream()
{
    KIRQL Irql;

	DBGTRACE(("CWDMVideoStream::~CWDMVideoStream()\n"));

    KeAcquireSpinLock(&m_ctrlSrbLock, &Irql);
    if (!IsListEmpty(&m_ctrlSrbQueue))
    {
        TRAP();
    }
    KeReleaseSpinLock(&m_ctrlSrbLock, Irql);
}


/*
** VideoReceiveDataPacket()
**
**   Receives Video data packet commands
**
** Arguments:
**
**   pSrb - Stream request block for the Video stream
**
** Returns: nothing
**
** Side Effects:  none
*/

VOID STREAMAPI CWDMVideoStream::VideoReceiveDataPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb)
{
    ASSERT(pSrb->StreamObject->StreamNumber == STREAM_AnalogVideoInput);

    ASSERT(pSrb->Irp->MdlAddress);
    
    DBGINFO(("Receiving SD---- SRB=%x\n", pSrb));

    pSrb->Status = STATUS_SUCCESS;
    
	switch (pSrb->Command) {

        case SRB_WRITE_DATA:
            
			m_pVideoDecoder->ReceivePacket(pSrb);
			break;

        default:

            //
            // invalid / unsupported command. Fail it as such
            //

            TRAP();

            pSrb->Status = STATUS_NOT_IMPLEMENTED;
            StreamClassStreamNotification(  StreamRequestComplete,
                                            pSrb->StreamObject,
                                            pSrb);
            break;
    }
}

/*
** VideoReceiveCtrlPacket()
**
**   Receives packet commands that control the Video stream
**
** Arguments:
**
**   pSrb - The stream request block for the Video stream
**
** Returns: nothing
**
** Side Effects:  none
*/

VOID STREAMAPI CWDMVideoStream::VideoReceiveCtrlPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb)
{
    KIRQL Irql;
    PSRB_DATA_EXTENSION pSrbExt;

    KeAcquireSpinLock(&m_ctrlSrbLock, &Irql);
    if (m_processingCtrlSrb)
    {
        pSrbExt = (PSRB_DATA_EXTENSION)pSrb->SRBExtension;
        pSrbExt->pSrb = pSrb;
        InsertTailList(&m_ctrlSrbQueue, &pSrbExt->srbListEntry);
        KeReleaseSpinLock(&m_ctrlSrbLock, Irql);
        return;
    }

    m_processingCtrlSrb = TRUE;
    KeReleaseSpinLock(&m_ctrlSrbLock, Irql);

    // This will run until the queue is empty
    while (TRUE)
    {
        // Assume success. Might be changed below
    
        pSrb->Status = STATUS_SUCCESS;

        switch (pSrb->Command)
        {
            case SRB_GET_STREAM_STATE:
                VideoGetState(pSrb);
                break;

            case SRB_SET_STREAM_STATE:
				{
					BOOL bVPConnected, bVPVBIConnected;
					PDEVICE_DATA_EXTENSION pDevExt = (PDEVICE_DATA_EXTENSION)pSrb->HwDeviceExtension;

					bVPConnected = pDevExt->CWDMDecoder.IsVideoPortPinConnected();
					bVPVBIConnected = pDevExt->CDevice.IsVBIEN();

					VideoSetState(pSrb, bVPConnected, bVPVBIConnected);
				}
                break;

            case SRB_GET_STREAM_PROPERTY:
                VideoGetProperty(pSrb);
                break;

            case SRB_SET_STREAM_PROPERTY:
                VideoSetProperty(pSrb);
                break;

            case SRB_INDICATE_MASTER_CLOCK:
                VideoIndicateMasterClock (pSrb);
                break;

           case SRB_PROPOSE_DATA_FORMAT:
                // This may be inappropriate for Bt829. CHECK!!!
                DBGERROR(("Propose Data format\n"));

                if (!(AdapterVerifyFormat (
                    pSrb->CommandData.OpenFormat, 
                    pSrb->StreamObject->StreamNumber))) {
                    pSrb->Status = STATUS_NO_MATCH;
                }
                break;
            default:
                TRAP();
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;
        }

        StreamClassStreamNotification(StreamRequestComplete, pSrb->StreamObject, pSrb);

        KeAcquireSpinLock(&m_ctrlSrbLock, &Irql);
        if (IsListEmpty(&m_ctrlSrbQueue))
        {
            m_processingCtrlSrb = FALSE;
            KeReleaseSpinLock(&m_ctrlSrbLock, Irql);
            return;
        }
        else
        {
            pSrbExt = (PSRB_DATA_EXTENSION)RemoveHeadList(&m_ctrlSrbQueue);
            KeReleaseSpinLock(&m_ctrlSrbLock, Irql);
            pSrb = pSrbExt->pSrb;
        }
    }
}


/*
** VideoSetProperty()
**
**    Routine to process video property requests
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID CWDMVideoStream::VideoSetProperty(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    DBGERROR(("CWDMVideoStream::VideoSetProperty called"));
    pSrb->Status = STATUS_NOT_IMPLEMENTED;
}

/*
** VideoGetProperty()
**
**    Routine to process video property requests
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID CWDMVideoStream::VideoGetProperty(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;

    if (IsEqualGUID (KSPROPSETID_Connection, pSPD->Property->Set)) {
        VideoStreamGetConnectionProperty (pSrb);
    }
    else {
       pSrb->Status = STATUS_NOT_IMPLEMENTED;
    }
}

/*
** VideoSetState()
**
**    Sets the current state of the requested stream
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID CWDMVideoStream::VideoSetState(PHW_STREAM_REQUEST_BLOCK pSrb, BOOL bVPConnected, BOOL bVPVBIConnected)
{
    //
    // For each stream, the following states are used:
    // 
    // Stop:    Absolute minimum resources are used.  No outstanding IRPs.
    // Pause:   Getting ready to run.  Allocate needed resources so that 
    //          the eventual transition to Run is as fast as possible.
    //          SRBs will be queued at either the Stream class or in your
    //          driver.
    // Run:     Streaming. 
    //
    // Moving to Stop or Run ALWAYS transitions through Pause, so that ONLY 
    // the following transitions are possible:
    //
    // Stop -> Pause
    // Pause -> Run
    // Run -> Pause
    // Pause -> Stop
    //
    // Note that it is quite possible to transition repeatedly between states:
    // Stop -> Pause -> Stop -> Pause -> Run -> Pause -> Run -> Pause -> Stop
    //

    DBGINFO(("CWDMVideoStream::VideoSetState for stream %d\n", pSrb->StreamObject->StreamNumber));

    pSrb->Status = STATUS_SUCCESS;

    switch (pSrb->CommandData.StreamState)  

    {
        case KSSTATE_STOP:
            DBGINFO(("   state KSSTATE_STOP"));

            // Reset the overridden flag so that the next time we go to the
            // Run state, output will be enabled (unless the app overrides
            // it again later). We should really do this after the graph
            // has been stopped so that if a filter that has yet to be stopped
            // cleans up by clearing the flag, it is not considered to be
            // overriding it again. Since we are not called after the graph
            // has been fully stopped, this is the best we can do.
            //
            // An alternative (and probably less confusing) approach is to
            // leave the overridden flag set and force the app to control
            // the output enabled feature if it changes it once.
            //
            // We have decided to follow the latter approach.

            // m_pDevice->SetOutputEnabledOverridden(FALSE);
            break;

        case KSSTATE_ACQUIRE:
            DBGINFO(("   state KSSTATE_ACQUIRE"));
            ASSERT(m_KSState == KSSTATE_STOP);
            break;

        case KSSTATE_PAUSE:
			DBGINFO(("   state KSSTATE_PAUSE"));
           
            if (m_pVideoDecoder->PreEventOccurred() &&
                (!m_pDevice->IsOutputEnabledOverridden() || m_pDevice->IsOutputEnabled()) &&
                        (m_KSState == KSSTATE_STOP || m_KSState == KSSTATE_ACQUIRE))
            {
                DBGERROR(("VidStrm Pause: Overridden = %d, OutputEnabled = %d",
                          m_pDevice->IsOutputEnabledOverridden(),
                          m_pDevice->IsOutputEnabled()
                        ));
                pSrb->Status = STATUS_UNSUCCESSFUL;
            }
            break;

        case KSSTATE_RUN:
            DBGINFO(("   state KSSTATE_RUN"));
            ASSERT(m_KSState == KSSTATE_ACQUIRE || m_KSState == KSSTATE_PAUSE);

            if (m_pVideoDecoder->PreEventOccurred() &&
                (!m_pDevice->IsOutputEnabledOverridden() || m_pDevice->IsOutputEnabled()))
            {
                DBGERROR(("VidStrm Run: Overridden = %d, OutputEnabled = %d",
                          m_pDevice->IsOutputEnabledOverridden(),
                          m_pDevice->IsOutputEnabled()
                        ));
                pSrb->Status = STATUS_UNSUCCESSFUL;
            }
            break;
    }

	if (pSrb->Status == STATUS_SUCCESS) {
		m_KSState = pSrb->CommandData.StreamState;
        DBGINFO((" entered\n"));
	}
	else
        DBGINFO((" NOT entered ***\n"));
}

/*
** VideoGetState()
**
**    Gets the current state of the requested stream
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID CWDMVideoStream::VideoGetState(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    pSrb->CommandData.StreamState = m_KSState;
    pSrb->ActualBytesTransferred = sizeof (KSSTATE);

    // A very odd rule:
    // When transitioning from stop to pause, DShow tries to preroll
    // the graph.  Capture sources can't preroll, and indicate this
    // by returning VFW_S_CANT_CUE in user mode.  To indicate this
    // condition from drivers, they must return ERROR_NO_DATA_DETECTED

    if (m_KSState == KSSTATE_PAUSE) {
       pSrb->Status = STATUS_NO_DATA_DETECTED;
    }
}


VOID CWDMVideoStream::VideoStreamGetConnectionProperty (PHW_STREAM_REQUEST_BLOCK pSrb)
{
	PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
	PKSALLOCATOR_FRAMING Framing = (PKSALLOCATOR_FRAMING) pSPD->PropertyInfo;

    ASSERT(pSPD->Property->Id == KSPROPERTY_CONNECTION_ALLOCATORFRAMING);

	Framing->RequirementsFlags   =
		KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY |
		KSALLOCATOR_REQUIREMENTF_INPLACE_MODIFIER |
		KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY;
	Framing->PoolType = NonPagedPool;
	Framing->Frames = 1;
	Framing->FileAlignment = 0;//FILE_QUAD_ALIGNMENT;// PAGE_SIZE - 1;
	Framing->Reserved = 0;
	Framing->FrameSize = 
		pSrb->StreamObject->StreamNumber == STREAM_AnalogVideoInput ?
			sizeof(KS_TVTUNER_CHANGE_INFO) : 1;

    pSrb->ActualBytesTransferred = sizeof(KSALLOCATOR_FRAMING);
}


//==========================================================================;
//                   Clock Handling Routines
//==========================================================================;


/*
** VideoIndicateMasterClock ()
**
**    If this stream is not being used as the master clock, this function
**      is used to provide us with a handle to the clock to use.
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID CWDMVideoStream::VideoIndicateMasterClock(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    m_hMasterClock = pSrb->CommandData.MasterClockHandle;
}



DWORD FAR PASCAL DirectDrawEventCallback(DWORD dwEvent, PVOID pContext, DWORD dwParam1, DWORD dwParam2)
{
	CDecoderVideoPort* pCDecoderVideoPort = (CDecoderVideoPort*) pContext;
	CWDMVideoPortStream* pCWDMVideoPortStream = (CWDMVideoPortStream*) pContext;
	CWDMCaptureStream* pCWDMCaptureStream = (CWDMVideoCaptureStream*) pContext;

    switch (dwEvent)
    {
        case DDNOTIFY_PRERESCHANGE:
			pCWDMVideoPortStream->PreResChange();
            break;

        case DDNOTIFY_POSTRESCHANGE:
			pCWDMVideoPortStream->PostResChange();
            break;

        case DDNOTIFY_PREDOSBOX:
			pCWDMVideoPortStream->PreDosBox();
            break;

        case DDNOTIFY_POSTDOSBOX:
			pCWDMVideoPortStream->PostDosBox();
            break;

        case DDNOTIFY_CLOSECAPTURE:
			pCWDMCaptureStream->CloseCapture();
            break;

        case DDNOTIFY_CLOSEDIRECTDRAW:
			pCDecoderVideoPort->CloseDirectDraw();
            break;

        case DDNOTIFY_CLOSEVIDEOPORT:
			pCDecoderVideoPort->CloseVideoPort();
            break;

        default:
            TRAP();
            break;
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\bt-829\vpstrm.h ===
#pragma once

//==========================================================================;
//
//	CWDMVideoPortStream - Video Port Stream class declarations
//
//		$Date:   22 Feb 1999 15:48:40  $
//	$Revision:   1.1  $
//	  $Author:   KLEBANOV  $
//
// $Copyright:	(c) 1997 - 1999  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

#include "i2script.h"
#include "aticonfg.h"


#include "VidStrm.h"



class CWDMVideoPortStream : public CWDMVideoStream
{
public:
	CWDMVideoPortStream(PHW_STREAM_OBJECT pStreamObject,
						CWDMVideoDecoder * pCWDMVideoDecoder,
						PUINT puiError);
	~CWDMVideoPortStream	();

	void * operator new(size_t size, void * pAllocation) { return(pAllocation);}
	void operator delete(void * pAllocation) {}

	VOID STREAMAPI VideoReceiveDataPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb);

	VOID VideoSetState(PHW_STREAM_REQUEST_BLOCK, BOOL bVPConnected, BOOL bVPVBIConnected);
	VOID VideoGetProperty(PHW_STREAM_REQUEST_BLOCK);
	VOID VideoSetProperty(PHW_STREAM_REQUEST_BLOCK);
	VOID AttemptRenegotiation();

	VOID PreResChange();
	VOID PostResChange();
	VOID PreDosBox();
	VOID PostDosBox();

	VOID StreamEventProc (PHW_EVENT_DESCRIPTOR pEvent)
	{
		if (pEvent->Enable)
		{
			m_EventCount++;
		}
		else
		{
			m_EventCount--;
		}
	}

	void CancelPacket(PHW_STREAM_REQUEST_BLOCK pSrbToCancel)
	{
		DBGERROR(("CancelPacket(): came to VideoPort stream object\n"));
	}

private:

	VOID SetVideoPortProperty(PHW_STREAM_REQUEST_BLOCK);
	VOID GetVideoPortProperty(PHW_STREAM_REQUEST_BLOCK);

	VOID SetVideoPortVBIProperty(PHW_STREAM_REQUEST_BLOCK);
	VOID GetVideoPortVBIProperty(PHW_STREAM_REQUEST_BLOCK);
    
	
	// internal flag to indicate whether or not we
    // have registered for DirectDraw events
    BOOL        m_Registered;

    UINT		m_EventCount;                                // for IVPNotify interface

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\bt-829\atibt\capmain.cpp ===
//==========================================================================;
//
//	Decoder specific initialization routines
//
//		$Date:   21 Aug 1998 21:46:10  $
//	$Revision:   1.1  $
//	  $Author:   Tashjian  $
//
// $Copyright:	(c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

extern "C"
{
#include "strmini.h"
#include "ksmedia.h"

}

#include "wdmvdec.h"
#include "capmain.h"
#include "wdmdrv.h"
#include "Device.h"
#include "capdebug.h"


CVideoDecoderDevice * InitializeDevice(PPORT_CONFIGURATION_INFORMATION pConfigInfo, 
									   PBYTE pWorkspace)
{
    UINT					nErrorCode = 0;
    PDEVICE_OBJECT			pDeviceObject = pConfigInfo->PhysicalDeviceObject;
	Device *				pDevice = NULL;
	
	PDEVICE_DATA_EXTENSION pDevExt = (PDEVICE_DATA_EXTENSION) pWorkspace;

    DBGTRACE(("InitializeDevice()\n"));


	ENSURE
	{
	    CI2CScript *pI2cScript = (CI2CScript *) new ((PVOID)&pDevExt->CScript)
				CI2CScript(pDeviceObject, &nErrorCode);
    
		if (nErrorCode != WDMMINI_NOERROR)
		{
			DBGERROR(("CI2CScript creation failure = %lx\n", nErrorCode));
			TRAP();
			FAIL;
		}
	
		if (!pI2cScript->LockI2CProviderEx())
		{
			DBGERROR(("Couldn't get I2CProvider.\n"));
			TRAP();
			FAIL;
		}
	
		{
			CATIHwConfiguration	CATIHwConfig(pDeviceObject, pI2cScript, &nErrorCode);

			pI2cScript->ReleaseI2CProvider();

			if(nErrorCode != WDMMINI_NOERROR)
			{
				DBGERROR(("CATIHwConfig constructor failure = %lx\n", nErrorCode));
				TRAP();
				FAIL;
			}

			UINT uiDecoderId;
			UCHAR chipAddr;
			CATIHwConfig.GetDecoderConfiguration(&uiDecoderId, &chipAddr);
			// check the device installed before enabling any access to it
			if((uiDecoderId != VIDEODECODER_TYPE_BT829) &&
				(uiDecoderId != VIDEODECODER_TYPE_BT829A)) {
				TRAP();
				FAIL;
			}

			CATIHwConfig.EnableDecoderI2CAccess(pI2cScript, TRUE);

			int outputEnablePolarity = CATIHwConfig.GetDecoderOutputEnableLevel();
			if(outputEnablePolarity == UINT(-1))
			{
				DBGERROR(("Unexpected outputEnablePolarity"));
				TRAP();
				FAIL;
			}

			pDevExt->deviceParms.pI2cScript = pI2cScript;
			pDevExt->deviceParms.chipAddr	= chipAddr;
			pDevExt->deviceParms.outputEnablePolarity = outputEnablePolarity;
            pDevExt->deviceParms.ulVideoInStandardsSupportedByCrystal = CATIHwConfig.GetVideoInStandardsSupportedByCrystal(); //Paul
            pDevExt->deviceParms.ulVideoInStandardsSupportedByTuner = CATIHwConfig.GetVideoInStandardsSupportedByTuner(); //Paul
		}

		pDevice = (Device*) new ((PVOID)&pDevExt->CDevice)
			Device(pConfigInfo, &pDevExt->deviceParms, &nErrorCode);

		if (nErrorCode)
		{
			pDevice = NULL;
			TRAP();
			FAIL;
		}
    
	} END_ENSURE;
    
    DBGTRACE(("Exit : InitializeDevice()\n"));
	
	return pDevice;
}


size_t DeivceExtensionSize()
{
	return (sizeof(DEVICE_DATA_EXTENSION));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\bt-829\vpstrm.cpp ===
//==========================================================================;
//
//	CWDMVideoPortStream - Video Port Stream class implementation
//
//		$Date:   05 Aug 1998 11:11:22  $
//	$Revision:   1.0  $
//	  $Author:   Tashjian  $
//
// $Copyright:	(c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

extern "C"
{
#include "strmini.h"
#include "ksmedia.h"
}

#include "wdmvdec.h"
#include "wdmdrv.h"
#include "aticonfg.h"
#include "capdebug.h"


CWDMVideoPortStream::CWDMVideoPortStream(PHW_STREAM_OBJECT pStreamObject, 
						CWDMVideoDecoder * pVideoDecoder,
						PUINT puiErrorCode)
	:	CWDMVideoStream(pStreamObject, pVideoDecoder, puiErrorCode)
{
	DBGTRACE(("CWDMVideoPortStream::CWDMVideoPortStream()\n"));

    int StreamNumber = pStreamObject->StreamNumber;
		
    if (StreamNumber == STREAM_VPVideo)
    {
    }
	else if (StreamNumber == STREAM_VPVBI)
	{
	}

	*puiErrorCode = WDMMINI_NOERROR;
}


CWDMVideoPortStream::~CWDMVideoPortStream()
{
	DBGTRACE(("CWDMVideoPortStream::~CWDMVideoPortStream()\n"));

    if (m_Registered)
    {
        m_pVideoPort->UnregisterForDirectDrawEvents( this);
    }
}


VOID STREAMAPI CWDMVideoPortStream::VideoReceiveDataPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb)
{  
	DBGERROR(("Unexpected data packet on non VP stream.\n"));
	ASSERT(0);
}

/*
** VideoSetProperty()
**
**    Routine to process video property requests
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID CWDMVideoPortStream::VideoSetProperty(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;

    if (IsEqualGUID (KSPROPSETID_VPConfig, pSPD->Property->Set)) {
        SetVideoPortProperty (pSrb);
    }
    else if (IsEqualGUID (KSPROPSETID_VPVBIConfig, pSPD->Property->Set)) {
        SetVideoPortVBIProperty (pSrb);
    }
    else {
       pSrb->Status = STATUS_NOT_IMPLEMENTED;
    }
}

/*
** VideoGetProperty()
**
**    Routine to process video property requests
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID CWDMVideoPortStream::VideoGetProperty(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;

    if (IsEqualGUID (KSPROPSETID_Connection, pSPD->Property->Set)) {
        VideoStreamGetConnectionProperty (pSrb);
    }
    else if (IsEqualGUID (KSPROPSETID_VPConfig, pSPD->Property->Set)) {
        pSrb->ActualBytesTransferred = m_pDevice->GetVideoPortProperty (pSPD);
        pSrb->Status = pSrb->ActualBytesTransferred ? STATUS_SUCCESS : STATUS_NOT_IMPLEMENTED;
    }
    else if (IsEqualGUID (KSPROPSETID_VPVBIConfig, pSPD->Property->Set)) {
        pSrb->ActualBytesTransferred = m_pDevice->GetVideoPortVBIProperty (pSPD);
        pSrb->Status = pSrb->ActualBytesTransferred ? STATUS_SUCCESS : STATUS_NOT_IMPLEMENTED;
    }
    else {
		pSrb->Status = STATUS_NOT_IMPLEMENTED;
    }
}

/*
** VideoSetState()
**
**    Sets the current state of the requested stream
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID CWDMVideoPortStream::VideoSetState(PHW_STREAM_REQUEST_BLOCK pSrb, BOOL bVPConnected, BOOL bVPVBIConnected)
{
    //
    // For each stream, the following states are used:
    // 
    // Stop:    Absolute minimum resources are used.  No outstanding IRPs.
    // Pause:   Getting ready to run.  Allocate needed resources so that 
    //          the eventual transition to Run is as fast as possible.
    //          SRBs will be queued at either the Stream class or in your
    //          driver.
    // Run:     Streaming. 
    //
    // Moving to Stop or Run ALWAYS transitions through Pause, so that ONLY 
    // the following transitions are possible:
    //
    // Stop -> Pause
    // Pause -> Run
    // Run -> Pause
    // Pause -> Stop
    //
    // Note that it is quite possible to transition repeatedly between states:
    // Stop -> Pause -> Stop -> Pause -> Run -> Pause -> Run -> Pause -> Stop
    //

    DBGINFO(("CWDMVideoPortStream::VideoSetState for stream %d\n", pSrb->StreamObject->StreamNumber));

    pSrb->Status = STATUS_SUCCESS;

    switch (pSrb->CommandData.StreamState)  

    {
        case KSSTATE_STOP:
            DBGINFO(("   state KSSTATE_STOP"));
            m_pDevice->SetOutputEnabled(FALSE);

            // Reset the overridden flag so that the next time we go to the
            // Run state, output will be enabled (unless the app overrides
            // it again later). We should really do this after the graph
            // has been stopped so that if a filter that has yet to be stopped
            // cleans up by clearing the flag, it is not considered to be
            // overriding it again. Since we are not called after the graph
            // has been fully stopped, this is the best we can do.
            //
            // An alternative (and probably less confusing) approach is to
            // leave the overridden flag set and force the app to control
            // the output enabled feature if it changes it once.
            //
            // We have decided to follow the latter approach.

            // m_pDevice->SetOutputEnabledOverridden(FALSE);
            break;

        case KSSTATE_ACQUIRE:
            DBGINFO(("   state KSSTATE_ACQUIRE"));
            ASSERT(m_KSState == KSSTATE_STOP);
            break;

        case KSSTATE_PAUSE:
			DBGINFO(("   state KSSTATE_PAUSE"));
            
            if (m_pVideoDecoder->PreEventOccurred() &&
                (!m_pDevice->IsOutputEnabledOverridden() || m_pDevice->IsOutputEnabled()) &&
                        (m_KSState == KSSTATE_STOP || m_KSState == KSSTATE_ACQUIRE))
            {
                DBGERROR(("VpStrm Pause: Overridden = %d, OutputEnabled = %d",
                          m_pDevice->IsOutputEnabledOverridden(),
                          m_pDevice->IsOutputEnabled()
                        ));

                pSrb->Status = STATUS_UNSUCCESSFUL;
            }
            break;

        case KSSTATE_RUN:
            DBGINFO(("   state KSSTATE_RUN"));

            ASSERT(m_KSState == KSSTATE_ACQUIRE || m_KSState == KSSTATE_PAUSE);

            if (m_pVideoDecoder->PreEventOccurred() &&
                (!m_pDevice->IsOutputEnabledOverridden() ||
                                        m_pDevice->IsOutputEnabled()))
            {
                DBGERROR(("VpStrm Run: Overridden = %d, OutputEnabled = %d",
                          m_pDevice->IsOutputEnabledOverridden(),
                          m_pDevice->IsOutputEnabled()
                        ));
                pSrb->Status = STATUS_UNSUCCESSFUL;
            }
            else if (!m_pDevice->IsOutputEnabledOverridden())
                m_pDevice->SetOutputEnabled(TRUE);
            break;
    }

	if (pSrb->Status == STATUS_SUCCESS) {
		m_KSState = pSrb->CommandData.StreamState;
        DBGINFO((" entered\n"));
	}
	else
        DBGINFO((" NOT entered ***\n"));
}


VOID CWDMVideoPortStream::SetVideoPortProperty(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PSTREAM_PROPERTY_DESCRIPTOR pSpd = pSrb->CommandData.PropertyInfo;
    ULONG Id  = pSpd->Property->Id;            // index of the property
    ULONG nS  = pSpd->PropertyOutputSize;        // size of data supplied

    pSrb->Status = STATUS_SUCCESS;

    ASSERT (m_pDevice != NULL);
    switch (Id)
    {
        case KSPROPERTY_VPCONFIG_DDRAWHANDLE:

			if (!m_pVideoPort->ConfigDirectDrawHandle(*(PULONG)pSrb->CommandData.PropertyInfo->PropertyInfo)) {
                pSrb->Status = STATUS_UNSUCCESSFUL;
	            break;
			}
            
            if (!m_Registered) {
				m_Registered = m_pVideoPort->RegisterForDirectDrawEvents(this);
                if (!m_Registered)
                {
                    pSrb->Status = STATUS_UNSUCCESSFUL;
                    break;
                }
            }
            break;

        case KSPROPERTY_VPCONFIG_VIDEOPORTID:

			if (!m_pVideoPort->ConfigVideoPortHandle(*(PULONG)pSrb->CommandData.PropertyInfo->PropertyInfo)) {
                pSrb->Status = STATUS_UNSUCCESSFUL;
			}
            break;

        case KSPROPERTY_VPCONFIG_DDRAWSURFACEHANDLE:

            m_pVideoDecoder->ResetEvents();
            
            break;

        case KSPROPERTY_VPCONFIG_SETCONNECTINFO :
            {
                LPDDVIDEOPORTCONNECT pConnectInfo;

                pConnectInfo = (LPDDVIDEOPORTCONNECT)  \
                               (pSrb->CommandData.PropertyInfo->PropertyInfo);

                m_pDevice->Set16BitDataStream(pConnectInfo->dwPortWidth == 16);
            } 
            break;

        case KSPROPERTY_VPCONFIG_INVERTPOLARITY :

            m_pDevice->SetHighOdd(*(PBOOL)(pSpd->PropertyInfo) != TRUE);
            break;

        case KSPROPERTY_VPCONFIG_SETVIDEOFORMAT :
            //
            // pSrb->CommandData.PropertInfo->PropertyInfo
            // points to a ULONG which is an index into the array of
            // VIDEOFORMAT structs returned to the caller from the
            // Get call to FORMATINFO
            //
            // Since the sample only supports one FORMAT type right
            // now, we will ensure that the requested index is 0.
            //

            switch (*(PULONG)pSrb->CommandData.PropertyInfo->PropertyInfo)
            {
                case 0:

                    //
                    // at this point, we would program the hardware to use
                    // the right connection information for the videoport.
                    // since we are only supporting one connection, we don't
                    // need to do anything, so we will just indicate success
                    //

                    break;

                default:

                    pSrb->Status = STATUS_NO_MATCH;
                    break;
            }

            break;

		case KSPROPERTY_VPCONFIG_SCALEFACTOR :
			{
				PKS_AMVPSIZE	pAMVPSize;

				pAMVPSize = (PKS_AMVPSIZE)(pSrb->CommandData.PropertyInfo->PropertyInfo);

				MRect t(0, 0,   pAMVPSize->dwWidth, pAMVPSize->dwHeight);
	//			MRect t(0, 0,   pAMVPSize->dwWidth, m_pDevice->GetDecoderHeight());

				m_pDevice->SetRect(t);
			}
            break;

        case KSPROPERTY_VPCONFIG_SURFACEPARAMS :

            ASSERT(nS >= sizeof(PKSVPSURFACEPARAMS));
			m_pDevice->ConfigVPSurfaceParams((PKSVPSURFACEPARAMS)pSpd->PropertyInfo);
            break;

        default:
            TRAP();
            pSrb->Status = STATUS_NOT_IMPLEMENTED;
            break;
    }
}




VOID CWDMVideoPortStream::SetVideoPortVBIProperty(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PSTREAM_PROPERTY_DESCRIPTOR pSpd = pSrb->CommandData.PropertyInfo;
    ULONG Id  = pSpd->Property->Id;             // index of the property
    ULONG nS  = pSpd->PropertyOutputSize;       // size of data supplied

    pSrb->Status = STATUS_SUCCESS;

    ASSERT (m_pDevice != NULL);
    switch (Id)
    {
        case KSPROPERTY_VPCONFIG_DDRAWHANDLE:

			if (!m_pVideoPort->ConfigDirectDrawHandle(*(PULONG)pSrb->CommandData.PropertyInfo->PropertyInfo)) {
                pSrb->Status = STATUS_UNSUCCESSFUL;
	            break;
			}
            
            if (!m_Registered) {
				m_Registered = m_pVideoPort->RegisterForDirectDrawEvents(this);
                if (!m_Registered)
                {
                    pSrb->Status = STATUS_UNSUCCESSFUL;
                    break;
                }
            }
            break;

        case KSPROPERTY_VPCONFIG_VIDEOPORTID:

			if (!m_pVideoPort->ConfigVideoPortHandle(*(PULONG)pSrb->CommandData.PropertyInfo->PropertyInfo)) {
                pSrb->Status = STATUS_UNSUCCESSFUL;
			}
            break;

        case KSPROPERTY_VPCONFIG_DDRAWSURFACEHANDLE:

            m_pVideoDecoder->ResetEvents();

            break;

        case KSPROPERTY_VPCONFIG_SETCONNECTINFO :
            {
                LPDDVIDEOPORTCONNECT pConnectInfo;

                pConnectInfo = (LPDDVIDEOPORTCONNECT)  \
                               (pSrb->CommandData.PropertyInfo->PropertyInfo);

                m_pDevice->Set16BitDataStream(pConnectInfo->dwPortWidth == 16);
            } 
            break;

        case KSPROPERTY_VPCONFIG_INVERTPOLARITY :

            m_pDevice->SetHighOdd(*(PBOOL)(pSpd->PropertyInfo) != TRUE);
            break;

        case KSPROPERTY_VPCONFIG_SETVIDEOFORMAT :
            //
            // pSrb->CommandData.PropertInfo->PropertyInfo
            // points to a ULONG which is an index into the array of
            // VIDEOFORMAT structs returned to the caller from the
            // Get call to FORMATINFO
            //
            // Since the sample only supports one FORMAT type right
            // now, we will ensure that the requested index is 0.
            //

            switch (*(PULONG)pSrb->CommandData.PropertyInfo->PropertyInfo)
            {
                case 0:

                    //
                    // at this point, we would program the hardware to use
                    // the right connection information for the videoport.
                    // since we are only supporting one connection, we don't
                    // need to do anything, so we will just indicate success
                    //

                    break;

                default:

                    pSrb->Status = STATUS_NO_MATCH;
                    break;
            }

            break;

        case KSPROPERTY_VPCONFIG_SCALEFACTOR :
            // TBD
            pSrb->Status = STATUS_NOT_IMPLEMENTED;
            break;

        case KSPROPERTY_VPCONFIG_SURFACEPARAMS :

            ASSERT(nS >= sizeof(PKSVPSURFACEPARAMS));
			m_pDevice->ConfigVPVBISurfaceParams((PKSVPSURFACEPARAMS)pSpd->PropertyInfo);
            break;

        default:
            TRAP();
            pSrb->Status = STATUS_NOT_IMPLEMENTED;
            break;
    }
}


VOID CWDMVideoPortStream::PreResChange()
{
    DBGTRACE(("DDNOTIFY_PRERESCHANGE; stream = %d\n", m_pStreamObject->StreamNumber));

    m_pVideoDecoder->SetPreEvent();
}


VOID CWDMVideoPortStream::PostResChange()
{
    DBGTRACE(("DDNOTIFY_POSTRESCHANGE; stream = %d\n", m_pStreamObject->StreamNumber));

    m_pVideoDecoder->SetPostEvent();
    DBGTRACE(("Before Attempted Renegotiation due to DDNOTIFY_POSTRESCHANGE\n"));
    AttemptRenegotiation();
    DBGTRACE(("Afer Attempted Renegotiation due to DDNOTIFY_POSTRESCHANGE\n"));
}




VOID CWDMVideoPortStream::PreDosBox()
{
    DBGTRACE(("DDNOTIFY_PREDOSBOX; stream = %d\n", m_pStreamObject->StreamNumber));

    m_pVideoDecoder->SetPreEvent();
}



VOID CWDMVideoPortStream::PostDosBox()
{
    DBGTRACE(("DDNOTIFY_POSTDOSBOX; stream = %d\n", m_pStreamObject->StreamNumber));

    m_pVideoDecoder->SetPostEvent();
    DBGTRACE(("Before Attempted Renegotiation due to DDNOTIFY_POSTDOSBOX\n"));
    AttemptRenegotiation();
    DBGTRACE(("After Attempted Renegotiation due to DDNOTIFY_POSTDOSBOX\n"));
}

NTSTATUS STREAMAPI VPStreamEventProc (PHW_EVENT_DESCRIPTOR pEvent)
{
    CWDMVideoPortStream* pstrm=(CWDMVideoPortStream*)pEvent->StreamObject->HwStreamExtension;
	pstrm->StreamEventProc(pEvent);
    return STATUS_SUCCESS;
}

NTSTATUS STREAMAPI VPVBIStreamEventProc (PHW_EVENT_DESCRIPTOR pEvent)
{
    CWDMVideoPortStream* pstrm=(CWDMVideoPortStream*)pEvent->StreamObject->HwStreamExtension;
	pstrm->StreamEventProc(pEvent);
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\bt-829\wdmvdec.cpp ===
//==========================================================================;
//
//	WDM Video Decoder common SRB dispatcher
//
//		$Date:   02 Oct 1998 23:00:24  $
//	$Revision:   1.2  $
//	  $Author:   KLEBANOV  $
//
// $Copyright:	(c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

extern "C"
{
#include "strmini.h"
#include "ksmedia.h"
}


#include "wdmvdec.h"
#include "wdmdrv.h"
#include "capdebug.h"
#include "VidStrm.h"

#include "DecProp.h"
#include "StrmInfo.h"

#include "Mediums.h"
#include "mytypes.h"

extern NTSTATUS STREAMAPI DeviceEventProc( PHW_EVENT_DESCRIPTOR pEventDescriptor);

CWDMVideoDecoder::CWDMVideoDecoder(PPORT_CONFIGURATION_INFORMATION pConfigInfo,
								   CVideoDecoderDevice* pDevice)
	:	m_pDeviceObject(pConfigInfo->PhysicalDeviceObject),
		m_CDecoderVPort(m_pDeviceObject),
		m_pDevice(pDevice),
		m_TVTunerChangedSrb( NULL)
{
	DBGTRACE(("CWDMVideoDecoder:CWDMVideoDecoder() enter\n"));
    DBGINFO(("Physical Device Object = %lx\n", m_pDeviceObject));

	pConfigInfo->StreamDescriptorSize = sizeof (HW_STREAM_HEADER) +
			NumStreams * sizeof (HW_STREAM_INFORMATION);

	InitializeListHead(&m_srbQueue);
	KeInitializeSpinLock(&m_spinLock);
	m_bSrbInProcess = FALSE;
        if (pDevice)
        {
            pDevice->SetVideoDecoder(this);
        }
}


CWDMVideoDecoder::~CWDMVideoDecoder()
{

	DBGTRACE(("CWDMVideoDecoder:~CWDMVideoDecoder()\n"));
}


void CWDMVideoDecoder::ReceivePacket(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    KIRQL Irql;
    PSRB_DATA_EXTENSION pSrbExt;

    KeAcquireSpinLock(&m_spinLock, &Irql);
    if (m_bSrbInProcess)
    {
        pSrbExt = (PSRB_DATA_EXTENSION)pSrb->SRBExtension;
        pSrbExt->pSrb = pSrb;
        InsertTailList(&m_srbQueue, &pSrbExt->srbListEntry);
        KeReleaseSpinLock(&m_spinLock, Irql);
        return;
    }

    m_bSrbInProcess = TRUE;
    KeReleaseSpinLock(&m_spinLock, Irql);


	for (;;) {

        // Assume success. Might be changed below

        pSrb->Status = STATUS_SUCCESS;
		BOOL notify = TRUE;
		
		// determine the type of packet.
		switch(pSrb->Command)
		{
			case SRB_INITIALIZATION_COMPLETE:
				DBGTRACE(("SRB_INITIALIZATION_COMPLETE; SRB=%x\n", pSrb));

				// Stream class has finished initialization.
				// Now create DShow Medium interface BLOBs.
				// This needs to be done at low priority since it uses the registry
				//
				// Do we need to worry about synchronization here?

				SrbInitializationComplete(pSrb);
				break;
			case SRB_UNINITIALIZE_DEVICE:
				DBGTRACE(("SRB_UNINITIALIZE_DEVICE; SRB=%x\n", pSrb));
				// close the device.  

				break;
			case SRB_PAGING_OUT_DRIVER:
				DBGTRACE(("SRB_PAGING_OUT_DRIVER; SRB=%x\n", pSrb));
				//
				// The driver is being paged out
				// Disable Interrupts if you have them!
				//
				break;
			case SRB_CHANGE_POWER_STATE:
				DBGTRACE(("SRB_CHANGE_POWER_STATE. SRB=%x. State=%d\n",
												pSrb, pSrb->CommandData.DeviceState));

				SrbChangePowerState(pSrb);
				break;
    
			case SRB_OPEN_STREAM:
				DBGTRACE(("SRB_OPEN_STREAM; SRB=%x\n", pSrb));

				SrbOpenStream(pSrb);
				break;

			case SRB_CLOSE_STREAM:
				DBGTRACE(("SRB_CLOSE_STREAM; SRB=%x\n", pSrb));

				if (!IsListEmpty(&m_srbQueue))	// is this necessary ???
				{
					TRAP();
				}

				SrbCloseStream(pSrb);
				break;
			case SRB_GET_DATA_INTERSECTION:
				DBGTRACE(("SRB_GET_DATA_INTERSECTION; SRB=%x\n", pSrb));

				SrbGetDataIntersection(pSrb);
				break;

			case SRB_GET_STREAM_INFO:
				SrbGetStreamInfo(pSrb);
				break;

			case SRB_GET_DEVICE_PROPERTY:
				SrbGetProperty(pSrb);
				break;        

			case SRB_SET_DEVICE_PROPERTY:
				SrbSetProperty(pSrb);
				break;

	        case SRB_WRITE_DATA:

				DBGTRACE(("SRB_WRITE_DATA; SRB=%x\n", pSrb));

				SetTunerInfo(pSrb);
				StreamClassStreamNotification(StreamRequestComplete, pSrb->StreamObject, pSrb);
				notify = FALSE;
				break;

			case SRB_UNKNOWN_DEVICE_COMMAND:
				// not sure why this gets called every time.
				DBGTRACE(("SRB_UNKNOWN_DEVICE_COMMAND; SRB=%x\n", pSrb));

				// TRAP()();
				pSrb->Status = STATUS_NOT_IMPLEMENTED;
				break;

			case SRB_OPEN_DEVICE_INSTANCE:
			case SRB_CLOSE_DEVICE_INSTANCE:
			default:
				TRAP();
				// this is a request that we do not understand.  Indicate invalid command and complete the request
				pSrb->Status = STATUS_NOT_IMPLEMENTED;
		}

		if (notify)
			StreamClassDeviceNotification(DeviceRequestComplete, pSrb->HwDeviceExtension, pSrb);

        KeAcquireSpinLock(&m_spinLock, &Irql);
        if (IsListEmpty(&m_srbQueue))
        {
            m_bSrbInProcess = FALSE;
            KeReleaseSpinLock(&m_spinLock, Irql);
            return;
        }
        else
        {
            pSrbExt = (PSRB_DATA_EXTENSION)RemoveHeadList(&m_srbQueue);
            KeReleaseSpinLock(&m_spinLock, Irql);
            pSrb = pSrbExt->pSrb;
        }
	}
}


void CWDMVideoDecoder::CancelPacket( PHW_STREAM_REQUEST_BLOCK pSrbToCancel)
{
	CWDMVideoStream*	pVideoStream = ( CWDMVideoStream*)pSrbToCancel->StreamObject->HwStreamExtension;
 
	DBGINFO(( "Bt829: AdapterCancelPacket, Starting attempting to cancel Srb 0x%x\n",
		pSrbToCancel));

	if( pVideoStream == NULL)
	{
		//
		// Device command IRPs are not queued, so nothing to do
		//
		DBGINFO(( "Bt829: AdapterCancelPacketStart, no pVideoStream Srb 0x%x\n",
			pSrbToCancel));

        return;
    } 

	pVideoStream->CancelPacket( pSrbToCancel);

    DBGINFO(( "Bt829: AdapterCancelPacket, Exiting\n"));
}



void CWDMVideoDecoder::TimeoutPacket(PHW_STREAM_REQUEST_BLOCK pSrb)
{
	CWDMVideoStream * pVideoStream = (CWDMVideoStream *)pSrb->StreamObject->HwStreamExtension;

    DBGTRACE(("Timeout. SRB %8x. \n", pSrb));
	pVideoStream->TimeoutPacket(pSrb);

    DBGTRACE(("TimeoutPacket: SRB %8x. Resetting.\n", pSrb));
    pSrb->TimeoutCounter = pSrb->TimeoutOriginal;
}


BOOL CWDMVideoDecoder::SrbInitializationComplete(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    NTSTATUS                Status;
    ULONG *tmp = (ULONG *) &CrossbarPinDirection[0];

    // Create the Registry blobs that DShow uses to create
    // graphs via Mediums

    Status = StreamClassRegisterFilterWithNoKSPins (
                    m_pDeviceObject,                    // IN PDEVICE_OBJECT   DeviceObject,
                    &KSCATEGORY_CROSSBAR,               // IN GUID           * InterfaceClassGUID,
                    CrossbarPins(),     // IN ULONG            PinCount,
                    (int *) CrossbarPinDirection,       // IN ULONG          * Flags,
                    (KSPIN_MEDIUM *) CrossbarMediums,   // IN KSPIN_MEDIUM   * MediumList,
                    NULL                                // IN GUID           * CategoryList
            );

    // Register the Capture filter
    // Note:  This should be done automatically be MSKsSrv.sys, 
    // when that component comes on line (if ever) ...
    Status = StreamClassRegisterFilterWithNoKSPins (
                    m_pDeviceObject,                    // IN PDEVICE_OBJECT   DeviceObject,
                    &KSCATEGORY_CAPTURE,                // IN GUID           * InterfaceClassGUID,
                    CapturePins(),      // IN ULONG            PinCount,
                    (int *) CapturePinDirection,        // IN ULONG          * Flags,
                    (KSPIN_MEDIUM *) CaptureMediums,    // IN KSPIN_MEDIUM   * MediumList,
                    NULL                                // IN GUID           * CategoryList
            );
    pSrb->Status = STATUS_SUCCESS;
	return(TRUE);
}


BOOL CWDMVideoDecoder::SrbOpenStream(PHW_STREAM_REQUEST_BLOCK pSrb)
{
	DBGTRACE(("CWDMVideoDecoder:SrbOpenStream()\n"));
	PHW_STREAM_OBJECT		pStreamObject = pSrb->StreamObject;
    void *					pStrmEx = pStreamObject->HwStreamExtension;
    int                     StreamNumber = pStreamObject->StreamNumber;
    PKSDATAFORMAT           pKSDataFormat = pSrb->CommandData.OpenFormat;
	CWDMVideoStream *		pVideoStream;
	CWDMVideoPortStream *	pVPVBIStream;
	UINT	nErrorCode;

    RtlZeroMemory(pStrmEx, streamDataExtensionSize);

    DBGINFO(("SRBOPENSTREAM ------- StreamNumber=%d\n", StreamNumber));

    //
    // check that the stream index requested isn't too high
    // or that the maximum number of instances hasn't been exceeded
    //

    if (StreamNumber >= (int)NumStreams || StreamNumber < 0) {

        pSrb->Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }


    //
    // Check the validity of the format being requested
    //

    if (!AdapterVerifyFormat (pKSDataFormat, StreamNumber)) {

        pSrb->Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

	//
	// Set up pointers to the handlers for the stream data and control handlers
	//

    pStreamObject->ReceiveDataPacket = VideoReceiveDataPacket;
    pStreamObject->ReceiveControlPacket = VideoReceiveCtrlPacket;

    //
    // Indicate the clock support available on this stream
    //

    pStreamObject->HwClockObject.HwClockFunction = NULL;
    pStreamObject->HwClockObject.ClockSupportFlags = 0;

    //
    // The DMA flag must be set when the device will be performing DMA directly
    // to the data buffer addresses passed in to the ReceiceDataPacket routines.
    //
    pStreamObject->Dma = Streams[StreamNumber].hwStreamObjectInfo.Dma;

    //
    // The PIO flag must be set when the mini driver will be accessing the data
    // buffers passed in using logical addressing
    //
    pStreamObject->Pio = Streams[StreamNumber].hwStreamObjectInfo.Pio;

    //
    // How many extra bytes will be passed up from the driver for each frame?
    //
    pStreamObject->StreamHeaderMediaSpecific = 
        Streams[StreamNumber].hwStreamObjectInfo.StreamHeaderMediaSpecific;

    pStreamObject->StreamHeaderWorkspace =
        Streams[StreamNumber].hwStreamObjectInfo.StreamHeaderWorkspace;

    //
    // Indicate the allocator support available on this stream
    //

    pStreamObject->Allocator = Streams[StreamNumber].hwStreamObjectInfo.Allocator;

    //
    // Indicate the event support available on this stream
    //

    pStreamObject->HwEventRoutine = 
        Streams[StreamNumber].hwStreamObjectInfo.HwEventRoutine;

	switch (StreamNumber)
	{
		case STREAM_AnalogVideoInput:
			ASSERT(IsEqualGUID(pKSDataFormat->Specifier, KSDATAFORMAT_SPECIFIER_ANALOGVIDEO));
			pVideoStream = (CWDMVideoStream *)new(pStrmEx)
				CWDMVideoStream(pStreamObject, this, &nErrorCode);
			break;
		case STREAM_VideoCapture:
			ASSERT(IsEqualGUID(pKSDataFormat->Specifier, KSDATAFORMAT_SPECIFIER_VIDEOINFO));
			m_pVideoCaptureStream = (CWDMVideoCaptureStream *)new(pStrmEx)
				CWDMVideoCaptureStream(pStreamObject, this, pKSDataFormat, &nErrorCode);
			if (m_pVideoPortStream)
			{
				m_pVideoPortStream->AttemptRenegotiation();
			}
			break;
		case STREAM_VBICapture:
			ASSERT(IsEqualGUID(pKSDataFormat->Specifier, KSDATAFORMAT_SPECIFIER_VBI));
			m_pVBICaptureStream = (CWDMVBICaptureStream *)new(pStrmEx)
				CWDMVBICaptureStream(pStreamObject, this, pKSDataFormat, &nErrorCode);
			break;
		case STREAM_VPVideo:
			ASSERT(IsEqualGUID(pKSDataFormat->Specifier, KSDATAFORMAT_SPECIFIER_NONE) &&
				   IsEqualGUID(pKSDataFormat->SubFormat, KSDATAFORMAT_SUBTYPE_VPVideo));
			m_pVideoPortStream = (CWDMVideoPortStream *)new(pStrmEx)
				CWDMVideoPortStream(pStreamObject, this, &nErrorCode);
			if (m_pVideoCaptureStream == NULL)
			{
				MRect t(0, 0,   m_pDevice->GetDefaultDecoderWidth(),
								m_pDevice->GetDefaultDecoderHeight());
				m_pDevice->SetRect(t);
			}
			break;
		case STREAM_VPVBI:
			ASSERT(IsEqualGUID(pKSDataFormat->Specifier, KSDATAFORMAT_SPECIFIER_NONE) &&
				   IsEqualGUID(pKSDataFormat->SubFormat, KSDATAFORMAT_SUBTYPE_VPVBI));
			pVPVBIStream = (CWDMVideoPortStream *)new(pStrmEx)
				CWDMVideoPortStream(pStreamObject, this, &nErrorCode);
	        m_pDevice->SetVBIEN(TRUE);
		    m_pDevice->SetVBIFMT(TRUE);
			break;
		default:
	        pSrb->Status = STATUS_UNSUCCESSFUL;
		    goto Exit;
	}

	if(nErrorCode == WDMMINI_NOERROR)
		m_OpenStreams++;
	else
		pSrb->Status = STATUS_INSUFFICIENT_RESOURCES;

Exit:
 
    DBGTRACE(("SrbOpenStream Exit\n"));
	return(TRUE);
}


BOOL CWDMVideoDecoder::SrbCloseStream(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    int                     StreamNumber = pSrb->StreamObject->StreamNumber;

	DBGTRACE(("CWDMVideoDecoder:SrbCloseStream()\n"));
    DBGINFO(("SRBCLOSESTREAM ------- StreamNumber=%d\n", StreamNumber));
    
    //
    // the minidriver may wish to free any resources that were allocated at
    // open stream time etc.
    //

	CWDMVideoStream * pVideoStream = (CWDMVideoStream *)pSrb->StreamObject->HwStreamExtension;

	delete pVideoStream;

	switch (StreamNumber)
	{
		case STREAM_AnalogVideoInput:
			break;
		case STREAM_VideoCapture:
			m_pVideoCaptureStream = NULL;
			break;
		case STREAM_VBICapture:
			m_pVBICaptureStream = NULL;
			break;
		case STREAM_VPVideo:
	        m_pVideoPortStream = NULL;
			break;
		case STREAM_VPVBI:
	        m_pDevice->SetVBIEN(FALSE);
		    m_pDevice->SetVBIFMT(FALSE);
			break;
		default:
	        pSrb->Status = STATUS_UNSUCCESSFUL;
		    return FALSE;
	}

    if (--m_OpenStreams == 0)
    {
        DBGINFO(("Last one out turns off the lights\n"));

		m_CDecoderVPort.Close();

        m_preEventOccurred = FALSE;
        m_postEventOccurred = FALSE;

        m_pDevice->SaveState();
    }

	pSrb->Status = STATUS_SUCCESS;

	return TRUE;
}


BOOL CWDMVideoDecoder::SrbGetDataIntersection(PHW_STREAM_REQUEST_BLOCK pSrb)
{

	DBGTRACE(("CWDMVideoDecoder:SrbGetDataIntersection()\n"));

    PSTREAM_DATA_INTERSECT_INFO IntersectInfo;
    PKSDATARANGE                DataRange;
    BOOL                        OnlyWantsSize;
    BOOL                        MatchFound = FALSE;
    ULONG                       FormatSize;
    ULONG                       StreamNumber;
    ULONG                       j;
    ULONG                       NumberOfFormatArrayEntries;
    PKSDATAFORMAT               *pAvailableFormats;

    IntersectInfo = pSrb->CommandData.IntersectInfo;
    StreamNumber = IntersectInfo->StreamNumber;
    DataRange = IntersectInfo->DataRange;

    //
    // Check that the stream number is valid
    //

    if (StreamNumber >= NumStreams) {
        pSrb->Status = STATUS_NOT_IMPLEMENTED;
        TRAP();
        return FALSE;
    }
    
    NumberOfFormatArrayEntries = 
            Streams[StreamNumber].hwStreamInfo.NumberOfFormatArrayEntries;

    //
    // Get the pointer to the array of available formats
    //

    pAvailableFormats = Streams[StreamNumber].hwStreamInfo.StreamFormatsArray;

    //
    // Is the caller trying to get the format, or the size of the format?
    //

    OnlyWantsSize = ( (IntersectInfo->SizeOfDataFormatBuffer == sizeof(ULONG)) ||
                      (IntersectInfo->SizeOfDataFormatBuffer == 0) );

    //
    // Walk the formats supported by the stream searching for a match
    // of the three GUIDs which together define a DATARANGE
    //

    for (j = 0; j < NumberOfFormatArrayEntries; j++, pAvailableFormats++) {

        if (!AdapterCompareGUIDsAndFormatSize(
                        DataRange, 
                        *pAvailableFormats,
                        TRUE /* CompareFormatSize */)) {
            continue;
        }

        //
        // Now that the three GUIDs match, switch on the Specifier
        // to do a further type-specific check
        //

        // -------------------------------------------------------------------
        // Specifier FORMAT_VideoInfo for VIDEOINFOHEADER
        // -------------------------------------------------------------------

        if (IsEqualGUID (DataRange->Specifier, 
                KSDATAFORMAT_SPECIFIER_VIDEOINFO)) {
                
            PKS_DATARANGE_VIDEO DataRangeVideoToVerify = 
                    (PKS_DATARANGE_VIDEO) DataRange;
            PKS_DATARANGE_VIDEO DataRangeVideo = 
                    (PKS_DATARANGE_VIDEO) *pAvailableFormats;
            PKS_DATAFORMAT_VIDEOINFOHEADER DataFormatVideoInfoHeaderOut;

            //
            // Check that the other fields match
            //
            if ((DataRangeVideoToVerify->bFixedSizeSamples != DataRangeVideo->bFixedSizeSamples) ||
                (DataRangeVideoToVerify->bTemporalCompression != DataRangeVideo->bTemporalCompression) ||
                (DataRangeVideoToVerify->StreamDescriptionFlags != DataRangeVideo->StreamDescriptionFlags) ||
                (DataRangeVideoToVerify->MemoryAllocationFlags != DataRangeVideo->MemoryAllocationFlags) ||
                (RtlCompareMemory (&DataRangeVideoToVerify->ConfigCaps,
                        &DataRangeVideo->ConfigCaps,
                        sizeof (KS_VIDEO_STREAM_CONFIG_CAPS)) != 
                        sizeof (KS_VIDEO_STREAM_CONFIG_CAPS))) {
                continue;
            }
            
            // MATCH FOUND!
            MatchFound = TRUE;            
            FormatSize = sizeof (KSDATAFORMAT) + 
                KS_SIZE_VIDEOHEADER (&DataRangeVideoToVerify->VideoInfoHeader);

            if (OnlyWantsSize) {
                break;
            }
            

            
            // Caller wants the full data format
            if (IntersectInfo->SizeOfDataFormatBuffer < FormatSize) {
                pSrb->Status = STATUS_BUFFER_TOO_SMALL;
                return FALSE;
            }

            // Copy over the KSDATAFORMAT, followed by the 
            // actual VideoInfoHeader
                
            DataFormatVideoInfoHeaderOut = (PKS_DATAFORMAT_VIDEOINFOHEADER) IntersectInfo->DataFormatBuffer;

            // Copy over the KSDATAFORMAT 
            RtlCopyMemory(
                &DataFormatVideoInfoHeaderOut->DataFormat,
                &DataRangeVideoToVerify->DataRange,
                sizeof (KSDATARANGE));

            DataFormatVideoInfoHeaderOut->DataFormat.FormatSize = FormatSize;

            // Copy over the callers requested VIDEOINFOHEADER

            RtlCopyMemory(
                &DataFormatVideoInfoHeaderOut->VideoInfoHeader,
                &DataRangeVideoToVerify->VideoInfoHeader,
                KS_SIZE_VIDEOHEADER (&DataRangeVideoToVerify->VideoInfoHeader));

            // Calculate biSizeImage for this request, and put the result in both
            // the biSizeImage field of the bmiHeader AND in the SampleSize field
            // of the DataFormat.
            //
            // Note that for compressed sizes, this calculation will probably not
            // be just width * height * bitdepth

            DataFormatVideoInfoHeaderOut->VideoInfoHeader.bmiHeader.biSizeImage =
                DataFormatVideoInfoHeaderOut->DataFormat.SampleSize = 
                KS_DIBSIZE(DataFormatVideoInfoHeaderOut->VideoInfoHeader.bmiHeader);

            //
            // Perform other validation such as cropping and scaling checks
            // 

            break;

        } // End of VIDEOINFOHEADER specifier

        // -------------------------------------------------------------------
        // Specifier FORMAT_AnalogVideo for KS_ANALOGVIDEOINFO
        // -------------------------------------------------------------------

        else if (IsEqualGUID (DataRange->Specifier, 
                KSDATAFORMAT_SPECIFIER_ANALOGVIDEO)) {
      
            //
            // For analog video, the DataRange and DataFormat
            // are identical, so just copy the whole structure
            //

            PKS_DATARANGE_ANALOGVIDEO DataRangeVideo = 
                    (PKS_DATARANGE_ANALOGVIDEO) *pAvailableFormats;

            // MATCH FOUND!
            MatchFound = TRUE;            
            FormatSize = sizeof (KS_DATARANGE_ANALOGVIDEO);

            if (OnlyWantsSize) {
                break;
            }
            
            // Caller wants the full data format
            if (IntersectInfo->SizeOfDataFormatBuffer < FormatSize) {
                pSrb->Status = STATUS_BUFFER_TOO_SMALL;
                return FALSE;
            }

            RtlCopyMemory(
                IntersectInfo->DataFormatBuffer,
                DataRangeVideo,
                sizeof (KS_DATARANGE_ANALOGVIDEO));

            ((PKSDATAFORMAT)IntersectInfo->DataFormatBuffer)->FormatSize = FormatSize;

            break;

        } // End of KS_ANALOGVIDEOINFO specifier

        // -------------------------------------------------------------------
        // Specifier STATIC_KSDATAFORMAT_TYPE_VIDEO for Video Port
        // -------------------------------------------------------------------

        else if (IsEqualGUID (DataRange->Specifier, 
                      KSDATAFORMAT_SPECIFIER_NONE) &&
                      IsEqualGUID (DataRange->SubFormat, KSDATAFORMAT_SUBTYPE_VPVideo)) {
      
      
            // MATCH FOUND!
            MatchFound = TRUE;            
            FormatSize = sizeof (KSDATAFORMAT);

            if (OnlyWantsSize) {
                break;
            }
            
            // Caller wants the full data format
            if (IntersectInfo->SizeOfDataFormatBuffer < FormatSize) {
                pSrb->Status = STATUS_BUFFER_TOO_SMALL;
                return FALSE;
            }

   
            RtlCopyMemory(
            IntersectInfo->DataFormatBuffer,
            &StreamFormatVideoPort,
            sizeof (KSDATAFORMAT));

            ((PKSDATAFORMAT)IntersectInfo->DataFormatBuffer)->FormatSize = FormatSize;

            break;
        }

        // -------------------------------------------------------------------
        // Specifier KSDATAFORMAT_SPECIFIER_NONE for VP VBI
        // -------------------------------------------------------------------

        else if (IsEqualGUID (DataRange->Specifier, 
                      KSDATAFORMAT_SPECIFIER_NONE) &&
                      IsEqualGUID (DataRange->SubFormat, KSDATAFORMAT_SUBTYPE_VPVBI)) {
      
            // MATCH FOUND!
            MatchFound = TRUE;            
            FormatSize = sizeof (KSDATAFORMAT);

            if (OnlyWantsSize) {
                break;
            }
            
            // Caller wants the full data format
            if (IntersectInfo->SizeOfDataFormatBuffer < FormatSize) {
                pSrb->Status = STATUS_BUFFER_TOO_SMALL;
                return FALSE;
            }

   
            RtlCopyMemory(
            IntersectInfo->DataFormatBuffer,
            &StreamFormatVideoPortVBI,
            sizeof (KSDATAFORMAT));

            ((PKSDATAFORMAT)IntersectInfo->DataFormatBuffer)->FormatSize = FormatSize;

            break;
        }

        // -------------------------------------------------------------------
        // Specifier STATIC_KSDATAFORMAT_TYPE_NONE for VBI capture stream
        // -------------------------------------------------------------------

        else if (IsEqualGUID (DataRange->Specifier, 
                      KSDATAFORMAT_SPECIFIER_VBI)) {
      
            PKS_DATARANGE_VIDEO_VBI DataRangeVBIToVerify = 
                    (PKS_DATARANGE_VIDEO_VBI) DataRange;
            PKS_DATARANGE_VIDEO_VBI DataRangeVBI = 
                    (PKS_DATARANGE_VIDEO_VBI) *pAvailableFormats;

            //
            // Check that the other fields match
            //
            if ((DataRangeVBIToVerify->bFixedSizeSamples != DataRangeVBI->bFixedSizeSamples) ||
                (DataRangeVBIToVerify->bTemporalCompression != DataRangeVBI->bTemporalCompression) ||
                (DataRangeVBIToVerify->StreamDescriptionFlags != DataRangeVBI->StreamDescriptionFlags) ||
                (DataRangeVBIToVerify->MemoryAllocationFlags != DataRangeVBI->MemoryAllocationFlags) ||
                (RtlCompareMemory (&DataRangeVBIToVerify->ConfigCaps,
                        &DataRangeVBI->ConfigCaps,
                        sizeof (KS_VIDEO_STREAM_CONFIG_CAPS)) != 
                        sizeof (KS_VIDEO_STREAM_CONFIG_CAPS))) {
                continue;
            }
            
            // MATCH FOUND!
            MatchFound = TRUE;            
            FormatSize = sizeof (KS_DATAFORMAT_VBIINFOHEADER);

            if (OnlyWantsSize) {
                break;
            }
            
            // Caller wants the full data format
            if (IntersectInfo->SizeOfDataFormatBuffer < FormatSize) {
                pSrb->Status = STATUS_BUFFER_TOO_SMALL;
                return FALSE;
            }

            // Copy over the KSDATAFORMAT, followed by the 
            // actual VBIInfoHeader
                
            RtlCopyMemory(
                &((PKS_DATAFORMAT_VBIINFOHEADER)IntersectInfo->DataFormatBuffer)->DataFormat,
                &DataRangeVBIToVerify->DataRange,
                sizeof (KSDATARANGE));

            ((PKSDATAFORMAT)IntersectInfo->DataFormatBuffer)->FormatSize = FormatSize;

            RtlCopyMemory(
                &((PKS_DATAFORMAT_VBIINFOHEADER) IntersectInfo->DataFormatBuffer)->VBIInfoHeader,
                &DataRangeVBIToVerify->VBIInfoHeader,
                sizeof (KS_VBIINFOHEADER));
        }

        else {
            pSrb->Status = STATUS_NO_MATCH;
            return FALSE;
        }

    } // End of loop on all formats for this stream
    
    if (OnlyWantsSize) {

        // Checking a special case where there is no buffer being passed, even for size.
        // In this case, I think I am supposed to return the size of the format in 
        // Actual Bytes Transferred, then set the status to STATUS_BUFFER_OVERFLOW
        // This is done to appease the grapher.  Personally I think this is confusing.
        // Why are we handling this case when there is a better way of acquiring the
        // size by passing a buffer of ULONG length?
        if ( IntersectInfo->SizeOfDataFormatBuffer == 0 )
        {
            pSrb->Status = STATUS_BUFFER_OVERFLOW;
            pSrb->ActualBytesTransferred = FormatSize;
            return FALSE;
        }

        
        *(PULONG) IntersectInfo->DataFormatBuffer = FormatSize;
        pSrb->ActualBytesTransferred = sizeof(ULONG);
        return TRUE;
    }        
    pSrb->ActualBytesTransferred = FormatSize;
    return TRUE;
}


void CWDMVideoDecoder::SrbGetStreamInfo(PHW_STREAM_REQUEST_BLOCK pSrb)
{
	DBGTRACE(("CWDMVideoDecoder:SrbGetStreamInfo()\n"));

    // 
    // verify that the buffer is large enough to hold our return data
    //
    DEBUG_ASSERT (pSrb->NumberOfBytesToTransfer >= 
        sizeof (HW_STREAM_HEADER) +
        sizeof (HW_STREAM_INFORMATION) * NumStreams);

    //
    // Set the header
    // 

    PHW_STREAM_HEADER pstrhdr =
        (PHW_STREAM_HEADER)&(pSrb->CommandData.StreamBuffer->StreamHeader);

    pstrhdr->NumberOfStreams = NumStreams;
    pstrhdr->SizeOfHwStreamInformation = sizeof (HW_STREAM_INFORMATION);
    pstrhdr->NumDevPropArrayEntries = NumAdapterProperties();
    pstrhdr->DevicePropertiesArray = (PKSPROPERTY_SET)AdapterProperties;
	pstrhdr->Topology = &Topology;

	//
    // stuff the contents of each HW_STREAM_INFORMATION struct 
    //
    PHW_STREAM_INFORMATION pstrinfo =
		(PHW_STREAM_INFORMATION)&(pSrb->CommandData.StreamBuffer->StreamInfo);

    for (unsigned j = 0; j < NumStreams; j++) {
        *pstrinfo++ = Streams[j].hwStreamInfo;
    }

	DBGTRACE(("Exit: CWDMVideoDecoder:SrbGetStreamInfo()\n"));
}


VOID CWDMVideoDecoder::SrbSetProperty (PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;

    if (IsEqualGUID(PROPSETID_VIDCAP_CROSSBAR, pSPD->Property->Set)) {
        m_pDevice->SetCrossbarProperty (pSrb);
    }
    else if (IsEqualGUID(PROPSETID_VIDCAP_VIDEOPROCAMP, pSPD->Property->Set)) {
		ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_VIDEOPROCAMP_S));

		ULONG Id = pSPD->Property->Id;              // index of the property
		PKSPROPERTY_VIDEOPROCAMP_S pS = (PKSPROPERTY_VIDEOPROCAMP_S) pSPD->PropertyInfo;    // pointer to the data

		pSrb->Status = m_pDevice->SetProcAmpProperty(Id, pS->Value);
    }
    else if (IsEqualGUID(PROPSETID_VIDCAP_VIDEODECODER, pSPD->Property->Set)) {
        m_pDevice->SetDecoderProperty (pSrb);
    }
	else
	    DBGERROR(("CWDMVideoDecoder:SrbSetProperty() unknown property\n"));
}


VOID CWDMVideoDecoder::SrbGetProperty (PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;

    if (IsEqualGUID (PROPSETID_VIDCAP_CROSSBAR, pSPD->Property->Set)) {
        m_pDevice->GetCrossbarProperty (pSrb);
    }
    else if (IsEqualGUID(PROPSETID_VIDCAP_VIDEOPROCAMP, pSPD->Property->Set)) {
		ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_VIDEOPROCAMP_S));

		ULONG Id = pSPD->Property->Id;              // index of the property
		PKSPROPERTY_VIDEOPROCAMP_S pS = (PKSPROPERTY_VIDEOPROCAMP_S) pSPD->PropertyInfo;    // pointer to the data

		pS->Capabilities = KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL;
		pSrb->Status = m_pDevice->GetProcAmpProperty(Id, &pS->Value);
	    pSrb->ActualBytesTransferred = pSrb->Status == STATUS_SUCCESS ?
			sizeof (KSPROPERTY_VIDEOPROCAMP_S) : 0;
    }
    else if (IsEqualGUID(PROPSETID_VIDCAP_VIDEODECODER, pSPD->Property->Set)) {
        m_pDevice->GetDecoderProperty (pSrb);
    }
	else
	    DBGERROR(("CWDMVideoDecoder:SrbGetProperty() unknown property\n"));
}


void CWDMVideoDecoder::SetTunerInfo( PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PKSSTREAM_HEADER pDataPacket = pSrb->CommandData.DataBufferArray;

    ASSERT (pDataPacket->FrameExtent == sizeof (KS_TVTUNER_CHANGE_INFO));

    KIRQL Irql;

	if (m_pVBICaptureStream)
		m_pVBICaptureStream->DataLock(&Irql); 

    RtlCopyMemory(  &m_TVTunerChangeInfo,
                    pDataPacket->Data,
                    sizeof (KS_TVTUNER_CHANGE_INFO));

	m_TVTunerChanged = TRUE;

	if (m_pVBICaptureStream)
		m_pVBICaptureStream->DataUnLock(Irql); 
}


BOOL CWDMVideoDecoder::GetTunerInfo(KS_TVTUNER_CHANGE_INFO* pTVChangeInfo)
{
	if (m_TVTunerChanged) {
	    KIRQL Irql;
		m_pVBICaptureStream->DataLock(&Irql); 
		RtlCopyMemory(pTVChangeInfo, &m_TVTunerChangeInfo, sizeof (KS_TVTUNER_CHANGE_INFO));
		m_TVTunerChanged = FALSE;
		m_pVBICaptureStream->DataUnLock(Irql); 
		return TRUE;
	}
	else
		return FALSE;
}


BOOL CWDMVideoDecoder::SrbChangePowerState(PHW_STREAM_REQUEST_BLOCK pSrb)
{

	DBGTRACE(("CWDMVideoDecoder:SrbChangePowerState()\n"));

	switch (pSrb->CommandData.DeviceState)
	{
		case PowerDeviceD3:
			m_preEventOccurred = TRUE;
			m_pDevice->SaveState();
			break;
		case PowerDeviceD2:
			m_preEventOccurred = TRUE;
			m_pDevice->SaveState();
			break;
		case PowerDeviceD1:
			m_preEventOccurred = TRUE;
			m_pDevice->SaveState();
			break;
		case PowerDeviceD0:
			m_postEventOccurred = TRUE;
			m_pDevice->RestoreState(m_OpenStreams);
			break;
	}

	pSrb->Status = STATUS_SUCCESS;

	return(TRUE);
}


VOID CWDMVideoPortStream::AttemptRenegotiation()
{
    int streamNumber = m_pStreamObject->StreamNumber;
    if (m_EventCount)
    {
        DBGINFO(("Attempting renegotiation on stream %d\n", streamNumber));

        if (streamNumber == STREAM_VPVideo)
        {
            StreamClassStreamNotification(
                SignalMultipleStreamEvents,
                m_pStreamObject,
                &MY_KSEVENTSETID_VPNOTIFY,
                KSEVENT_VPNOTIFY_FORMATCHANGE);
        }
        else if (streamNumber == STREAM_VPVBI)
        {
            StreamClassStreamNotification(
                SignalMultipleStreamEvents,
                m_pStreamObject,
                &MY_KSEVENTSETID_VPVBINOTIFY,
                KSEVENT_VPVBINOTIFY_FORMATCHANGE);
        }
		else
			ASSERT(0);
    }
    else
    {
        DBGINFO(("NOT attempting renegotiation on stream %d\n", streamNumber));
    }
}


NTSTATUS CWDMVideoDecoder::EventProc( IN PHW_EVENT_DESCRIPTOR pEventDescriptor)
{

	if( pEventDescriptor->Enable)
		m_nMVDetectionEventCount++;
	else
		m_nMVDetectionEventCount--;

	return( STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\bt-829\wdmvdec.h ===
#pragma once

//==========================================================================;
//
//	WDM Video Decoder common SRB dispatcher
//
//		$Date:   05 Aug 1998 11:22:30  $
//	$Revision:   1.0  $
//	  $Author:   Tashjian  $
//
// $Copyright:	(c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;


#include "CapStrm.h"
#include "VPStrm.h"
#include "CapVBI.h"
#include "CapVideo.h"
#include "decvport.h"

#include "ddkmapi.h"


typedef struct
{
	// Please don't move srbListEntry from its first place in the structure
	LIST_ENTRY					srbListEntry;

	PHW_STREAM_REQUEST_BLOCK	pSrb;
    KEVENT                      bufferDoneEvent;
    DDCAPBUFFINFO               ddCapBuffInfo;
} SRB_DATA_EXTENSION, * PSRB_DATA_EXTENSION;


class CWDMVideoDecoder
{
public:
	CWDMVideoDecoder( PPORT_CONFIGURATION_INFORMATION pConfigInfo, 
					  CVideoDecoderDevice* pDevice );
	virtual ~CWDMVideoDecoder();

	void * operator new(size_t size, void * pAllocation) { return(pAllocation);}
	void operator delete(void * pAllocation) {}

	void	ReceivePacket		(PHW_STREAM_REQUEST_BLOCK pSrb);
	void	CancelPacket		(PHW_STREAM_REQUEST_BLOCK pSrb);
	void	TimeoutPacket		(PHW_STREAM_REQUEST_BLOCK pSrb);

	void	SetTunerInfo		(PHW_STREAM_REQUEST_BLOCK pSrb);
    BOOL	GetTunerInfo		(KS_TVTUNER_CHANGE_INFO *);

	NTSTATUS
		EventProc				( IN PHW_EVENT_DESCRIPTOR pEventDescriptor);

	void	ResetEvents()		{ m_preEventOccurred = m_postEventOccurred = FALSE; }
	void	SetPreEvent()		{ m_preEventOccurred = TRUE; }
	void	SetPostEvent()		{ m_postEventOccurred = TRUE; }
	BOOL	PreEventOccurred()	{ return m_preEventOccurred; }

	CVideoDecoderDevice* GetDevice() { return m_pDevice; }
	CDecoderVideoPort*	GetVideoPort() { return &m_CDecoderVPort; }	// video port

	BOOL    IsVideoPortPinConnected()       { return( m_pVideoPortStream != NULL); }
private:
	// for serializing SRB arriving into driver synchronization
	BOOL				m_bSrbInProcess;
	LIST_ENTRY			m_srbQueue;
	KSPIN_LOCK			m_spinLock;

	CVideoDecoderDevice *		m_pDevice;
	CDecoderVideoPort			m_CDecoderVPort;	// video port

	PDEVICE_OBJECT				m_pDeviceObject;

    // Channel Change information
    KS_TVTUNER_CHANGE_INFO		m_TVTunerChangeInfo;
    BOOL						m_TVTunerChanged;
	PHW_STREAM_REQUEST_BLOCK	m_TVTunerChangedSrb;

    // shared between full-screen DOS and res changes
    BOOL						m_preEventOccurred;
    BOOL						m_postEventOccurred;

	// Streams
    UINT						m_OpenStreams;
    CWDMVideoPortStream *		m_pVideoPortStream;
    CWDMVBICaptureStream *		m_pVBICaptureStream;
    CWDMVideoCaptureStream *	m_pVideoCaptureStream;

	UINT						m_nMVDetectionEventCount;

	BOOL SrbInitializationComplete	(PHW_STREAM_REQUEST_BLOCK pSrb);
	BOOL SrbChangePowerState		(PHW_STREAM_REQUEST_BLOCK pSrb);
	BOOL SrbGetDataIntersection		(PHW_STREAM_REQUEST_BLOCK pSrb);
	void SrbGetStreamInfo			(PHW_STREAM_REQUEST_BLOCK pSrb);
	void SrbGetProperty				(PHW_STREAM_REQUEST_BLOCK pSrb);
	void SrbSetProperty				(PHW_STREAM_REQUEST_BLOCK pSrb);
	BOOL SrbOpenStream				(PHW_STREAM_REQUEST_BLOCK pSrb);
	BOOL SrbCloseStream				(PHW_STREAM_REQUEST_BLOCK pSrb);
};

const size_t streamDataExtensionSize = 
	max(
		max(sizeof(CWDMVideoStream), sizeof(CWDMVideoPortStream)), 
		max(sizeof(CWDMVideoCaptureStream), sizeof(CWDMVBICaptureStream))
	);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\bt-829\atibt\capmain.h ===
#pragma once

//==========================================================================;
//
//	Decoder specific declarations
//
//		$Date:   21 Aug 1998 21:46:20  $
//	$Revision:   1.1  $
//	  $Author:   Tashjian  $
//
// $Copyright:	(c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#include "ddkmapi.h"

#include "i2script.h"
#include "aticonfg.h"

#ifdef    __cplusplus
}
#endif // __cplusplus


typedef struct {
    CI2CScript *			pI2cScript;
    UINT                    chipAddr;
    UINT                    chipID;
    UINT                    chipRev;
	int						outputEnablePolarity;
    ULONG                   ulVideoInStandardsSupportedByCrystal;   //Paul
    ULONG                   ulVideoInStandardsSupportedByTuner;     //Paul
} DEVICE_PARMS, *PDEVICE_PARMS;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\bt-829\atibt\debugdef.h ===
#pragma once

//==========================================================================;
//
//	Decoder specific debug declarations
//
//		$Date:   05 Aug 1998 11:31:52  $
//	$Revision:   1.0  $
//	  $Author:   Tashjian  $
//
// $Copyright:	(c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

#define DBG_COMPONENT "ATIBT: "
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\bt-829\atibt\dcdrvals.h ===
#pragma once

//==========================================================================;
//
//	Decoder specific constants
//
//		$Date:   05 Aug 1998 11:31:52  $
//	$Revision:   1.0  $
//	  $Author:   Tashjian  $
//
// $Copyright:	(c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

#ifdef __cplusplus

const int HueMin = -90;
const int HueMax = 90;
const int HueDef = 0;

const int SatMinNTSC = 0;
const int SatMaxNTSC = 0x1FF;
const int SatDefNTSC = 0xFE;

const int SatMinSECAM = 0;
const int SatMaxSECAM = 0x1FF;
const int SatDefSECAM = 0x87;

const int ConMin = 0;
const int ConMax = 236;
const int ConDef = 100;

const int BrtMin = -50;
const int BrtMax = 50;
const int BrtDef = 0;

const int ParamMin = 0;
const int ParamMax = 255;
const int ParamDef = 128;

#else
#define HueMin -90
#define HueMax 90
#define HueDef 0

#define SatMinNTSC 0
#define SatMaxNTSC 0x1FF
#define SatDefNTSC 0xFE

#define SatMinSECAM 0
#define SatMaxSECAM 0x1FF
#define SatDefSECAM 0x87

#define ConMin 0
#define ConMax 236
#define ConDef 100

#define BrtMin -50
#define BrtMax 50
#define BrtDef 0

#define ParamMin 0
#define ParamMax 255
#define ParamDef 128

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\bt-829\atibt\decprop.h ===
//==========================================================================;
//
//	WDM Video Decoder adapter properties definitions
//
//		$Date:   02 Oct 1998 22:59:36  $
//	$Revision:   1.1  $
//	  $Author:   KLEBANOV  $
//
// $Copyright:	(c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

#ifdef _DEC_PROP_H_
#pragma message("DecProp.h INCLUDED MORE THAN ONCE")
#else
#define _DEC_PROP_H_
#endif

// ------------------------------------------------------------------------
// Property set for the Video Crossbar
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_TABLE(XBarProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_CROSSBAR_CAPS,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_CROSSBAR_CAPS_S),    // MinProperty
        sizeof(KSPROPERTY_CROSSBAR_CAPS_S),    // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_CROSSBAR_CAN_ROUTE,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_CROSSBAR_ROUTE_S),    // MinProperty
        sizeof(KSPROPERTY_CROSSBAR_ROUTE_S),    // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_CROSSBAR_ROUTE,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_CROSSBAR_ROUTE_S),    // MinProperty
        sizeof(KSPROPERTY_CROSSBAR_ROUTE_S),    // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_CROSSBAR_PININFO,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_CROSSBAR_PININFO_S),    // MinProperty
        sizeof(KSPROPERTY_CROSSBAR_PININFO_S),    // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),

};


// ------------------------------------------------------------------------
// Property set for VideoProcAmp
// ------------------------------------------------------------------------

// defaults
static const ULONG BrightnessDefault = 128;
static const ULONG ContrastDefault = 128;
static const ULONG HueDefault = 128;
static const ULONG SaturationDefault = 128;

//
// First define all of the ranges and stepping values
//

// ------------------------------------------------------------------------
static KSPROPERTY_STEPPING_LONG BrightnessRangeAndStep [] = 
{
    {
        // Eventually need to convert these to IRE * 100 unites
        256/1,              // SteppingDelta (range / steps)
        0,                  // Reserved
        0,                  // Minimum
        255                 // Maximum
    }
};

static KSPROPERTY_MEMBERSLIST BrightnessMembersList [] = 
{
    {
        {
            KSPROPERTY_MEMBER_RANGES,
            sizeof (BrightnessRangeAndStep),
            SIZEOF_ARRAY (BrightnessRangeAndStep),
            0
        },
        (PVOID) BrightnessRangeAndStep
    },
    {
        {
            KSPROPERTY_MEMBER_VALUES,
            sizeof (BrightnessDefault),
			1,
            KSPROPERTY_MEMBER_FLAG_DEFAULT
        },
        (PVOID) &BrightnessDefault
    }
};

static KSPROPERTY_VALUES BrightnessValues =
{
    {
        STATICGUIDOF (KSPROPTYPESETID_General),
        VT_I4,
        0
    },
    SIZEOF_ARRAY (BrightnessMembersList),
    BrightnessMembersList
};

// ------------------------------------------------------------------------
static KSPROPERTY_STEPPING_LONG ContrastRangeAndStep [] = 
{
    {
        256/1,        // SteppingDelta (range / steps)
        0,                  // Reserved
        0,                  // Minimum in (gain * 100) units
        255               // Maximum in (gain * 100) units
    }
};

static KSPROPERTY_MEMBERSLIST ContrastMembersList [] = 
{
    {
        {
            KSPROPERTY_MEMBER_RANGES,
            sizeof (ContrastRangeAndStep),
            SIZEOF_ARRAY (ContrastRangeAndStep),
            0
        },
        (PVOID) ContrastRangeAndStep
    },
    {
        {
            KSPROPERTY_MEMBER_VALUES,
            sizeof (ContrastDefault),
            sizeof (ContrastDefault),
            KSPROPERTY_MEMBER_FLAG_DEFAULT
        },
        (PVOID) &ContrastDefault
    }    
};

static KSPROPERTY_VALUES ContrastValues =
{
    {
        STATICGUIDOF (KSPROPTYPESETID_General),
        VT_I4,
        0
    },
    SIZEOF_ARRAY (ContrastMembersList),
    ContrastMembersList
};

KSPROPERTY_STEPPING_LONG HueRangeAndStep [] = 
{
    {
        256/1,        // SteppingDelta
        0,                                // Reserved
        0,                                // Minimum 
        255         // Maximum 
    }
};

KSPROPERTY_MEMBERSLIST HueMembersList [] = 
{
    {
        {
            KSPROPERTY_MEMBER_RANGES,
            sizeof (HueRangeAndStep),
            SIZEOF_ARRAY (HueRangeAndStep),
            0
        },
        (PVOID) HueRangeAndStep
    },
    {
        {
            KSPROPERTY_MEMBER_VALUES,
            sizeof (HueDefault),
            sizeof (HueDefault),
            KSPROPERTY_MEMBER_FLAG_DEFAULT
        },
        (PVOID) &HueDefault
    }
};

KSPROPERTY_VALUES HueValues =
{
    {
        STATICGUIDOF (KSPROPTYPESETID_General),
        VT_I4,
        0
    },
    SIZEOF_ARRAY (HueMembersList),
    HueMembersList
};

KSPROPERTY_STEPPING_LONG SaturationRangeAndStep [] = 
{
    {
        256/1,        // SteppingDelta
        0,                                // Reserved
        0,                                // Minimum 
        255         // Maximum 
    }
};

KSPROPERTY_MEMBERSLIST SaturationMembersList [] = 
{
    {
        {
            KSPROPERTY_MEMBER_RANGES,
            sizeof (SaturationRangeAndStep),
            SIZEOF_ARRAY (SaturationRangeAndStep),
            0
        },
        (PVOID) SaturationRangeAndStep
    },
    {
        {
            KSPROPERTY_MEMBER_VALUES,
            sizeof (SaturationDefault),
            sizeof (SaturationDefault),
            KSPROPERTY_MEMBER_FLAG_DEFAULT
        },
        (PVOID) &SaturationDefault
    }    
};

KSPROPERTY_VALUES SaturationValues =
{
    {
        STATICGUIDOF (KSPROPTYPESETID_General),
        VT_I4,
        0
    },
    SIZEOF_ARRAY (SaturationMembersList),
    SaturationMembersList
};

// ------------------------------------------------------------------------
DEFINE_KSPROPERTY_TABLE(VideoProcAmpProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEOPROCAMP_CONTRAST,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinProperty
        sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinData
        TRUE,                                   // SetSupported or Handler
        &ContrastValues,                        // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinProperty
        sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinData
        TRUE,                                   // SetSupported or Handler
        &BrightnessValues,                       // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEOPROCAMP_HUE,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinProperty
        sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinData
        TRUE,                                   // SetSupported or Handler
        &HueValues,                       // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEOPROCAMP_SATURATION,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinProperty
        sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinData
        TRUE,                                   // SetSupported or Handler
        &SaturationValues,                       // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),
};

// ------------------------------------------------------------------------
// Property set for AnalogVideoDecoder
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_TABLE(AnalogVideoDecoder)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEODECODER_CAPS,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEODECODER_CAPS_S), // MinProperty
        sizeof(KSPROPERTY_VIDEODECODER_CAPS_S), // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEODECODER_STANDARD,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEODECODER_S),      // MinProperty
        sizeof(KSPROPERTY_VIDEODECODER_S),      // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEODECODER_STATUS,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEODECODER_STATUS_S),// MinProperty
        sizeof(KSPROPERTY_VIDEODECODER_STATUS_S),// MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEODECODER_OUTPUT_ENABLE,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEODECODER_S),      // MinProperty
        sizeof(KSPROPERTY_VIDEODECODER_S),      // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
};

// ------------------------------------------------------------------------
// Array of all of the property sets supported by the adapter
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_SET_TABLE(AdapterProperties)
{
    DEFINE_KSPROPERTY_SET
    ( 
        &PROPSETID_VIDCAP_VIDEOPROCAMP,
        SIZEOF_ARRAY(VideoProcAmpProperties),
        VideoProcAmpProperties,
        0, 
        NULL,
    ),
    DEFINE_KSPROPERTY_SET
    ( 
        &PROPSETID_VIDCAP_CROSSBAR,             // Set
        SIZEOF_ARRAY(XBarProperties),           // PropertiesCount
        XBarProperties,                         // PropertyItem
        0,                                      // FastIoCount
        NULL                                    // FastIoTable
    ),
    DEFINE_KSPROPERTY_SET
    ( 
        &PROPSETID_VIDCAP_VIDEODECODER,
        SIZEOF_ARRAY(AnalogVideoDecoder),
        AnalogVideoDecoder,
        0, 
        NULL,
    )
};

ULONG NumAdapterProperties()
{
	return SIZEOF_ARRAY(AdapterProperties);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\bt-829\atibt\decoder.cpp ===
//==========================================================================;
//
//	Decoder - Main decoder implementation
//
//		$Date:   21 Aug 1998 21:46:26  $
//	$Revision:   1.1  $
//	  $Author:   Tashjian  $
//
// $Copyright:	(c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

#include "mytypes.h"
#include "Scaler.h"
#include "decoder.h"
#include "dcdrvals.h"

#include "capmain.h"

#define CON_vs_BRI   // HW does contrast incorrectly, try to adjust in SW


//===========================================================================
// Bt848 Decoder Class Implementation
//===========================================================================

#define REGALIGNMENT 1

/////////////////////////////////////////////////////////////////////////////
// Constructor
/////////////////////////////////////////////////////////////////////////////
Decoder::Decoder(PDEVICE_PARMS pDeviceParms) :
   // init register min, max, default
   m_regHue(HueMin, HueMax, HueDef),
   m_regSaturationNTSC(SatMinNTSC, SatMaxNTSC, SatDefNTSC),
   m_regSaturationSECAM(SatMinSECAM, SatMaxSECAM, SatDefSECAM),
   m_regContrast(ConMin, ConMax, ConDef),
   m_regBrightness(BrtMin, BrtMax, BrtDef),
   m_param(ParamMin, ParamMax, ParamDef),

	decRegSTATUS (((0x00 + 0) * REGALIGNMENT) + 0, RW, pDeviceParms) ,
	decFieldHLOC(decRegSTATUS, 6, 1, RW) ,
	decFieldNUML(decRegSTATUS, 4, 1, RW) ,
	decFieldCSEL(decRegSTATUS, 3, 1, RW) ,
	decFieldSTATUS_RES(decRegSTATUS, 2, 1, RW) ,
	decFieldLOF(decRegSTATUS, 1, 1, RW) ,
	decFieldCOF(decRegSTATUS, 0, 1, RW) ,
	decRegIFORM (((0x01 + 0) * REGALIGNMENT) + 0, RW, pDeviceParms) ,
	decFieldHACTIVE(decRegIFORM, 7, 1, RW) ,
	decFieldMUXSEL(decRegIFORM, 5, 2, RW) ,
	decFieldXTSEL(decRegIFORM, 3, 2, RW) ,
	decFieldFORMAT(decRegIFORM, 0, 3, RW) ,
	decRegTDEC (((0x02 + 0) * REGALIGNMENT) + 0, RW, pDeviceParms) ,
	decFieldDEC_FIELD(decRegTDEC, 7, 1, RW) ,
	decFieldDEC_FIELDALIGN(decRegTDEC, 6, 1, RW) ,
	decFieldDEC_RAT(decRegTDEC, 0, 6, RW) ,
	decRegBRIGHT (((0x0A + 0) * REGALIGNMENT) + 0, RW, pDeviceParms) ,
	decRegMISCCONTROL (((0x0B + 0) * REGALIGNMENT) + 0, RW, pDeviceParms) ,
	decFieldLNOTCH(decRegMISCCONTROL, 7, 1, RW) ,
	decFieldCOMP(decRegMISCCONTROL, 6, 1, RW) ,
	decFieldLDEC(decRegMISCCONTROL, 5, 1, RW) ,
	decFieldMISCCONTROL_RES(decRegMISCCONTROL, 3, 1, RW) ,
	decFieldCON_MSB(decRegMISCCONTROL, 2, 1, RW) ,
	decFieldSAT_U_MSB(decRegMISCCONTROL, 1, 1, RW) ,
	decFieldSAT_V_MSB(decRegMISCCONTROL, 0, 1, RW) ,
	decRegCONTRAST_LO (((0x0C + 0) * REGALIGNMENT) + 0, RW, pDeviceParms) ,
	decRegSAT_U_LO (((0x0D + 0) * REGALIGNMENT) + 0, RW, pDeviceParms) ,
	decRegSAT_V_LO (((0x0E + 0) * REGALIGNMENT) + 0, RW, pDeviceParms) ,
	decRegHUE (((0x0F + 0) * REGALIGNMENT) + 0, RW, pDeviceParms) ,
	decRegSCLOOP (((0x10 + 0) * REGALIGNMENT) + 0, RW, pDeviceParms) ,
	decFieldCAGC(decRegSCLOOP, 6, 1, RW) ,
	decFieldCKILL(decRegSCLOOP, 5, 1, RW) ,
	decRegWC_UP(((0x11 + 0) * REGALIGNMENT) + 0, RW, pDeviceParms) ,
	decRegOFORM (((0x12 + 0) * REGALIGNMENT) + 0, RW, pDeviceParms) ,
	decFieldVBI_FRAME(decRegOFORM, 4, 1, RW) ,
	decFieldCODE(decRegOFORM, 3, 1, RW) ,
	decFieldLEN(decRegOFORM, 2, 1, RW) ,
	decRegVSCALE_HI (((0x13 + 0) * REGALIGNMENT) + 0, RW, pDeviceParms) ,
	decFieldYCOMB(decRegVSCALE_HI, 7, 1, RW) ,
	decFieldCOMB(decRegVSCALE_HI, 6, 1, RW) ,
	decFieldINT(decRegVSCALE_HI, 5, 1, RW) ,
	decRegTEST (((0x15 + 0) * REGALIGNMENT) + 0, RW, pDeviceParms) ,
	decRegVPOLE (((0x16 + 0) * REGALIGNMENT) + 0, RW, pDeviceParms) ,
	decFieldOUT_EN (decRegVPOLE, 7, 1, RW), 
	decFieldDVALID (decRegVPOLE, 6, 1, RW), 
	decFieldVACTIVE (decRegVPOLE, 5, 1, RW), 
	decFieldCBFLAG (decRegVPOLE, 4, 1, RW), 
	decFieldFIELD (decRegVPOLE, 3, 1, RW), 
	decFieldACTIVE (decRegVPOLE, 2, 1, RW), 
	decFieldHRESET (decRegVPOLE, 1, 1, RW), 
	decFieldVRESET (decRegVPOLE, 0, 1, RW), 
	decRegADELAY (((0x18 + 0) * REGALIGNMENT) + 0, RW, pDeviceParms) ,
	decRegBDELAY (((0x19 + 0) * REGALIGNMENT) + 0, RW, pDeviceParms) ,
	decRegADC (((0x1A + 0) * REGALIGNMENT) + 0, RW, pDeviceParms) ,
	decFieldCLK_SLEEP(decRegADC, 3, 1, RW) ,
	decFieldC_SLEEP(decRegADC, 1, 1, RW) ,
	decFieldCRUSH(decRegADC, 0, 1, RW),
	decRegVTC (((0x1B + 0) * REGALIGNMENT) + 0, RW, pDeviceParms) ,
	decFieldHSFMT(decRegVTC, 7, 1, RW) ,
	decRegWC_DN(((0x1E + 0) * REGALIGNMENT) + 0, RW, pDeviceParms) ,
	decRegSRESET (((0x1F + 0) * REGALIGNMENT) + 0, RW, pDeviceParms), 
	decRegODD_MISCCONTROL (((0x0B + -0x03) * REGALIGNMENT) + 0x8C, RW, pDeviceParms) ,
	decFieldODD_LNOTCH(decRegODD_MISCCONTROL, 7, 1, RW) ,
	decFieldODD_COMP(decRegODD_MISCCONTROL, 6, 1, RW) ,
	decFieldODD_LDEC(decRegODD_MISCCONTROL, 5, 1, RW) ,
	decFieldODD_CBSENSE(decRegODD_MISCCONTROL, 4, 1, RW) ,
	decFieldODD_MISCCONTROL_RES(decRegODD_MISCCONTROL, 3, 1, RW) ,
	decFieldODD_CON_MSB(decRegODD_MISCCONTROL, 2, 1, RW) ,
	decFieldODD_SAT_U_MSB(decRegODD_MISCCONTROL, 1, 1, RW) ,
	decFieldODD_SAT_V_MSB(decRegODD_MISCCONTROL, 0, 1, RW) ,
	decRegODD_SCLOOP (((0x10 + -0x03) * REGALIGNMENT) + 0x8C, RW, pDeviceParms) ,
	decFieldODD_CAGC(decRegODD_SCLOOP, 6, 1, RW) ,
	decFieldODD_CKILL(decRegODD_SCLOOP, 5, 1, RW) ,
	decFieldODD_HFILT(decRegODD_SCLOOP, 3, 2, RW) ,
	decRegODD_VSCALE_HI (((0x13 + -0x03) * REGALIGNMENT) + 0x8C, RW, pDeviceParms) ,
	decFieldODD_YCOMB(decRegODD_VSCALE_HI, 7, 1, RW) ,
	decFieldODD_COMB(decRegODD_VSCALE_HI, 6, 1, RW) ,
	decFieldODD_INT(decRegODD_VSCALE_HI, 5, 1, RW) ,
	decRegODD_VTC (((0x1B + -0x03) * REGALIGNMENT) + 0x8C, RW, pDeviceParms) ,
	decFieldODD_HSFMT(decRegODD_VTC, 7, 1, RW)
{
   if(!(pDeviceParms->chipRev < 4))
   {
	   // need to set this to 0x4F
	   decRegWC_UP = 0x4F;
	   // and this one to 0x7F to make sure CRUSH bit works for not plain vanila BT829
	   decRegWC_DN = 0x7F;
   }

   // HACTIVE should always be 0
   decFieldHACTIVE = 0;

   decFieldHSFMT = 0;

   // The following lines were commented out in an attempt to
   // have a picture which closely matches what an ordinary TV would
   // show. However, it should be noted that Brooktree recommended to
   // comment out only the 'SetLowColorAutoRemoval' line. Probably the
   // best solution of all would be to somehow expose these options
   // to the application.

   // Instead of using default values, set some registers fields to optimum values
/*
   SetLumaDecimation(TRUE);
   SetChromaAGC(TRUE);
   SetLowColorAutoRemoval(FALSE);
   SetAdaptiveAGC(FALSE);
*/

   // for contrast adjustment purpose
   regBright = 0x00;     // brightness register value before adjustment
   regContrast = 0xD8;   // contrast register value before adjustment
   m_supportedVideoStandards = KS_AnalogVideo_NTSC_M |
                               KS_AnalogVideo_NTSC_M_J |
                               KS_AnalogVideo_PAL_B |
                               KS_AnalogVideo_PAL_D |
                               KS_AnalogVideo_PAL_G |
                               KS_AnalogVideo_PAL_H |
                               KS_AnalogVideo_PAL_I |
                               KS_AnalogVideo_PAL_M |
                               KS_AnalogVideo_PAL_N;   //Paul: what BT 829 can support (from L829A_A functional Description)

   if(!(pDeviceParms->chipRev < 4))
		   m_supportedVideoStandards |= KS_AnalogVideo_SECAM_B		|
									 KS_AnalogVideo_SECAM_D		|
									 KS_AnalogVideo_SECAM_G		|
									 KS_AnalogVideo_SECAM_H		|
									 KS_AnalogVideo_SECAM_K		|
									 KS_AnalogVideo_SECAM_K1	|
									 KS_AnalogVideo_SECAM_L		|
									 KS_AnalogVideo_SECAM_L1;
      
   m_supportedVideoStandards &= pDeviceParms->ulVideoInStandardsSupportedByCrystal;   //Paul: AND with whatever supported by the onboard crystal

   // jaybo 
   // loop until we find a supported TV standard, and use that to init
   UINT k;
   for (k = 1; k; k += k) {
      if (k & m_supportedVideoStandards) {
         SetVideoDecoderStandard(k);
         break; 
      }
   }
   // end jaybo
}

/////////////////////////////////////////////////////////////////////////////
// Destructor
/////////////////////////////////////////////////////////////////////////////
Decoder::~Decoder()
{
}


void Decoder::GetVideoDecoderCaps(PKSPROPERTY_VIDEODECODER_CAPS_S pS)
{
    pS->StandardsSupported = m_supportedVideoStandards;

    pS->Capabilities = KS_VIDEODECODER_FLAGS_CAN_DISABLE_OUTPUT  |
                       KS_VIDEODECODER_FLAGS_CAN_INDICATE_LOCKED ;

    // How long (ms) til locked indicator is valid.
    // 31 line periods * 63.5uS per line.
    pS->SettlingTime = 2;       

    // Not sure about this
    // HSync per VSync
    pS->HSyncPerVSync = 6;
}

void Decoder::GetVideoDecoderStatus(PKSPROPERTY_VIDEODECODER_STATUS_S pS)
{
	pS->NumberOfLines = Is525LinesVideo() ? 525 : 625;
	pS->SignalLocked = decFieldHLOC == 1;
}

DWORD Decoder::GetVideoDecoderStandard()
{
	return m_videoStandard; //Paul
}

BOOL Decoder::SetVideoDecoderStandard(DWORD standard)
{
    if (m_supportedVideoStandards & standard) //Paul: standard must be a supported standard
    {
        m_videoStandard = standard;

        switch ( m_videoStandard )
        {
        case KS_AnalogVideo_NTSC_M:
            Decoder::SetVideoFormat(VFormat_NTSC);
            break;
        case KS_AnalogVideo_NTSC_M_J:
            Decoder::SetVideoFormat(VFormat_NTSC_J);
            break;
			case KS_AnalogVideo_PAL_B:
			case KS_AnalogVideo_PAL_D:
			case KS_AnalogVideo_PAL_G:
			case KS_AnalogVideo_PAL_H:
			case KS_AnalogVideo_PAL_I:
            Decoder::SetVideoFormat(VFormat_PAL_BDGHI);    // PAL_BDGHI covers most areas 
            break;
        case KS_AnalogVideo_PAL_M:
            Decoder::SetVideoFormat(VFormat_PAL_M); 
            break;
        case KS_AnalogVideo_PAL_N:
            Decoder::SetVideoFormat(VFormat_PAL_N_COMB); 
            break;
        default:    //Paul:  SECAM
            Decoder::SetVideoFormat(VFormat_SECAM);

        }
        return TRUE;
    }
    else
        return FALSE;

}


//===== Device Status register ==============================================

/////////////////////////////////////////////////////////////////////////////
// Method:  BOOL Decoder::Is525LinesVideo()
// Purpose: Check to see if we are dealing with 525 lines video signal
// Input:   None
// Output:  None
// Return:  TRUE if 525 lines detected; else FALSE (assume 625 lines)
/////////////////////////////////////////////////////////////////////////////
BOOL Decoder::Is525LinesVideo()
{
  return (BOOL) (decFieldNUML == 0);  //525
}

/////////////////////////////////////////////////////////////////////////////
// Method:  BOOL Decoder::IsCrystal0Selected()
// Purpose: Reflect whether XTAL0 or XTAL1 is selected
// Input:   None
// Output:  None
// Return:  TRUE if XTAL0 selected; else FALSE (XTAL1 selected)
/////////////////////////////////////////////////////////////////////////////
BOOL Decoder::IsCrystal0Selected()
{
  return (BOOL) (decFieldCSEL == 0);
}


/////////////////////////////////////////////////////////////////////////////
// Method:  BOOL Decoder::IsLumaOverflow()
// Purpose: Indicates if luma ADC overflow
// Input:   None
// Output:  None
// Return:  TRUE if luma ADC overflow; else FALSE
/////////////////////////////////////////////////////////////////////////////
BOOL Decoder::IsLumaOverflow()
{
  return (BOOL) (decFieldLOF == 1);
}


/////////////////////////////////////////////////////////////////////////////
// Method:  void Decoder::ResetLumaOverflow()
// Purpose: Reset luma ADC overflow bit
// Input:   None
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Decoder::ResetLumaOverflow()
{
  decFieldLOF = 0;  // write to it will reset the bit
}

/////////////////////////////////////////////////////////////////////////////
// Method:  BOOL Decoder::IsChromaOverflow()
// Purpose: Indicates if chroma ADC overflow
// Input:   None
// Output:  None
// Return:  TRUE if chroma ADC overflow; else FALSE
/////////////////////////////////////////////////////////////////////////////
BOOL Decoder::IsChromaOverflow()
{
  return (BOOL) (decFieldCOF == 1);
}

/////////////////////////////////////////////////////////////////////////////
// Method:  void Decoder::ResetChromaOverflow()
// Purpose: Reset chroma ADC overflow bit
// Input:   None
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Decoder::ResetChromaOverflow()
{
  decFieldCOF = 0;  // write to it will reset the bit
}


//===== Input Format register ===============================================

/////////////////////////////////////////////////////////////////////////////
// Method:  ErrorCode Decoder::SetVideoInput(ULONG source)
// Purpose: Select which connector as input
// Input:   Connector source - SVideo, Tuner, Composite
// Output:  None
// Return:  Fail if error in parameter, else Success
/////////////////////////////////////////////////////////////////////////////
ErrorCode Decoder::SetVideoInput(ULONG source)
{
  if ((source != ConSVideo) &&
       (source != ConTuner) &&
       (source != ConComposite))
    return Fail;

  decFieldMUXSEL = source + 1;

  // set to composite or Y/C component video depends on video source
  SetCompositeVideo((source == ConSVideo) ? FALSE : TRUE);
  return Success;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  int Decoder::GetVideoInput()
// Purpose: Get which connector is input
// Input:   None
// Output:  None
// Return:  Video source - SVideo, Tuner, Composite
/////////////////////////////////////////////////////////////////////////////
int Decoder::GetVideoInput()
{
  return ((int)decFieldMUXSEL);
}

/////////////////////////////////////////////////////////////////////////////
// Method:  ErrorCode Decoder::SetCrystal(Crystal crystalNo)
// Purpose: Select which crystal as input
// Input:   Crystal crystalNo:
//            XT0         - Crystal_XT0
//            XT1         - Crystal_XT1
//            Auto select - Crystal_AutoSelect
// Output:  None
// Return:  Fail if error in parameter, else Success
/////////////////////////////////////////////////////////////////////////////
ErrorCode Decoder::SetCrystal(Crystal crystalNo)
{
  if ((crystalNo < Crystal_XT0) || (crystalNo >  Crystal_AutoSelect))
    return Fail;

  decFieldXTSEL = crystalNo;
  return Success;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  int Decoder::GetCrystal()
// Purpose: Get which crystal is input
// Input:   None
// Output:  None
// Return:   Crystal Number:
//            XT0         - Crystal_XT0
//            XT1         - Crystal_XT1
//            Auto select - Crystal_AutoSelect
/////////////////////////////////////////////////////////////////////////////
int Decoder::GetCrystal()
{
  return ((int)decFieldXTSEL);
}


/////////////////////////////////////////////////////////////////////////////
// Method:  ErrorCode Decoder::SetVideoFormat(VideoFormat format)
// Purpose: Set video format
// Input:   Video format -
//            Auto format:          VFormat_AutoDetect
//            NTSC (M):             VFormat_NTSC
//            NTSC Japan:           VFormat_NTSC_J
//            PAL (B, D, G, H, I):  VFormat_PAL_BDGHI
//            PAL (M):              VFormat_PAL_M
//            PAL(N):               VFormat_PAL_N
//            SECAM:                VFormat_SECAM
//            PAN(N Combo)          VFormat_PAL_N_COMB
// Output:  None
// Return:  Fail if error in parameter, else Success
// Notes:   Available video formats are: NTSC, PAL(B, D, G, H, I), PAL(M),
//                                       PAL(N), SECAM
//          This function also sets the AGCDelay (ADELAY) and BrustDelay
//          (BDELAY) registers
/////////////////////////////////////////////////////////////////////////////
ErrorCode Decoder::SetVideoFormat(VideoFormat format)
{
  if ((format <  VFormat_AutoDetect)  ||
       (format >  VFormat_PAL_N_COMB))
    return Fail;

  switch (format)
  {
    case VFormat_PAL_M:
    case VFormat_NTSC:
    case VFormat_NTSC_J:
      decFieldFORMAT = format;
      decRegADELAY = 0x68;
      decRegBDELAY = 0x5D;
      SetChromaComb(TRUE);        // enable chroma comb
      SelectCrystal('N');         // select NTSC crystal
      break;

    case VFormat_PAL_BDGHI:
    case VFormat_PAL_N:
      decFieldFORMAT = format;
      decRegADELAY = 0x7F;
      decRegBDELAY = 0x72;
      SetChromaComb(TRUE);        // enable chroma comb
      SelectCrystal('P');         // select PAL crystal
      break;

    case VFormat_PAL_N_COMB:
      decFieldFORMAT = format;
      decRegADELAY = 0x7F;
      decRegBDELAY = 0x72;
      SetChromaComb(TRUE);        // enable chroma comb
      SelectCrystal('N');         // select NTSC crystal
      break;

    case VFormat_SECAM:
      decFieldFORMAT = format;
      decRegADELAY = 0x7F;
      decRegBDELAY = 0xA0;
      SetChromaComb(FALSE);       // disable chroma comb
      SelectCrystal('P');         // select PAL crystal
      break;
      
    default: // VFormat_AutoDetect
      // auto format detect by examining the number of lines
      if (Decoder::Is525LinesVideo()) // lines == 525 -> NTSC
        Decoder::SetVideoFormat(VFormat_NTSC);
      else  // lines == 625 -> PAL/SECAM
        Decoder::SetVideoFormat(VFormat_PAL_BDGHI);    // PAL_BDGHI covers most areas 
  }

  SetSaturation(m_satParam);
  return Success;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  int Decoder::GetVideoFormat()
// Purpose: Obtain video format
// Input:   None
// Output:  None
// Return:  Video format
//            Auto format:          VFormat_AutoDetect
//            NTSC (M):             VFormat_NTSC
//            PAL (B, D, G, H, I):  VFormat_PAL_BDGHI
//            PAL (M):              VFormat_PAL_M
//            PAL(N):               VFormat_PAL_N
//            SECAM:                VFormat_SECAM
//            PAN(N Combo)          VFormat_PAL_N_COMB
/////////////////////////////////////////////////////////////////////////////
int Decoder::GetVideoFormat()
{
   BYTE bFormat = (BYTE)decFieldFORMAT;
   if (!bFormat) // autodetection enabled
      return Is525LinesVideo() ? VFormat_NTSC : VFormat_SECAM;
   else
     return bFormat;
}


//===== Temporal Decimation register ========================================

/////////////////////////////////////////////////////////////////////////////
// Method:  ErrorCode Decoder::SetRate(BOOL fields, VidField even, int rate)
// Purpose: Set frames or fields rate
// Input:   BOOL fields   - TRUE for fields, FALSE for frames
//          VidField even - TRUE to start decimation with even field, FALSE odd
//          int  rate     - decimation rate: frames (1-50/60); fields(1-25/30)
// Output:  None
// Return:  Fail if error in parameter, else Success
/////////////////////////////////////////////////////////////////////////////
ErrorCode Decoder::SetRate(BOOL fields, VidField vf, int rate)
{
  int nMax;
  if (Is525LinesVideo() == TRUE)
    nMax = 30;  // NTSC
  else
    nMax = 25;  // PAL/SECAM

  // if setting frame rate, double the max value
  if (fields == FALSE)
    nMax *= 2;

  if (rate < 0 || rate > nMax)
    return Fail;

  decFieldDEC_FIELD = (fields == FALSE) ? Off : On;
  decFieldDEC_FIELDALIGN = (vf == VF_Even) ? On : Off;
  int nDrop = (BYTE) nMax - rate;
  decFieldDEC_RAT = (BYTE) (fields == FALSE) ? nDrop : nDrop * 2;

  return Success;
}


//===== Brightness Control register =========================================

/////////////////////////////////////////////////////////////////////////////
// Method:  ErrorCode Decoder::SetBrightness(int param)
// Purpose: Set video brightness
// Input:   int param - parameter value (0-255; default 128)
// Output:  None
// Return:  Fail if error in parameter, else Success
// Note:    See IsAdjustContrast() for detailed description of the contrast
//          adjustment calculation
/////////////////////////////////////////////////////////////////////////////
ErrorCode Decoder::SetBrightness(int param)
{
  if(m_param.OutOfRange(param))
    return Fail;

  // perform mapping to our range
  int mapped;
  if (Mapping(param, m_param, &mapped, m_regBrightness) == Fail)
    return Fail;

  m_briParam = (WORD)param;

  // calculate brightness value
  int value = (128 * mapped) / m_regBrightness.Max() ;

  // need to limit the value to 0x7F (+50%) because 0x80 is -50%!
  if ((mapped > 0) && (value == 0x80))
    value = 0x7F;

  // perform adjustment of brightness register if adjustment is needed
  if (IsAdjustContrast())
  {
    regBright = value;   // brightness value before adjustment

    long A = (long)regBright * (long)0xD8;
    long B = 64 * ((long)0xD8 - (long)regContrast);
    long temp = 0x00;
    if (regContrast != 0)  // already limit contrast > zero; just in case here
       temp = ((A + B) / (long)regContrast);
    temp = (temp < -128) ? -128 : ((temp > 127) ? 127 : temp);
    value = (BYTE)temp;

  }

  decRegBRIGHT = (BYTE)value;

  return Success;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  int Decoder::GetBrightness()
// Purpose: Obtain brightness value
// Input:   None
// Output:  None
// Return:  Brightness parameter (0-255)
/////////////////////////////////////////////////////////////////////////////
int Decoder::GetBrightness()
{
  return m_briParam;
}


//===== Miscellaneous Control register (E_CONTROL, O_CONTROL) ===============

/////////////////////////////////////////////////////////////////////////////
// Method:  void Decoder::SetLumaNotchFilter(BOOL mode)
// Purpose: Enable/Disable luma notch filter
// Input:   BOOL mode - TRUE = Enable; FALSE = Disable
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Decoder::SetLumaNotchFilter(BOOL mode)
{
  decFieldLNOTCH = (mode == FALSE) ? On : Off;  // reverse
}


/////////////////////////////////////////////////////////////////////////////
// Method:  BOOL Decoder::IsLumaNotchFilter()
// Purpose: Check if luma notch filter is enable or disable
// Input:   None
// Output:  None
// Return:  TRUE = Enable; FALSE = Disable
/////////////////////////////////////////////////////////////////////////////
BOOL Decoder::IsLumaNotchFilter()
{
  return (decFieldLNOTCH == Off) ? TRUE : FALSE;  // reverse
}


/////////////////////////////////////////////////////////////////////////////
// Method:  void Decoder::SetCompositeVideo(BOOL mode)
// Purpose: Select composite or Y/C component video
// Input:   BOOL mode - TRUE = Composite; FALSE = Y/C Component
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Decoder::SetCompositeVideo(BOOL mode)
{
  if (mode == TRUE)
  {
    // composite video
    decFieldCOMP = Off;
    Decoder::SetChromaADC(FALSE);  // disable chroma ADC
    Decoder::SetLumaNotchFilter(TRUE);  // enable luma notch filter
  }
  else
  {
    // Y/C Component video
    decFieldCOMP = On;
    Decoder::SetChromaADC(TRUE);  // enable chroma ADC
    Decoder::SetLumaNotchFilter(FALSE);  // disable luma notch filter
  }
}


/////////////////////////////////////////////////////////////////////////////
// Method:  void Decoder::SetLumaDecimation(BOOL mode)
// Purpose: Enable/Disable luma decimation filter
// Input:   BOOL mode - TRUE = Enable; FALSE = Disable
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Decoder::SetLumaDecimation(BOOL mode)
{
   // value of 0 turns the decimation on
   decFieldLDEC = (mode == TRUE) ? 0 : 1;
}


//===== Luma Gain register (CON_MSB, CONTRAST_LO) ===========================

/////////////////////////////////////////////////////////////////////////////
// Method:  ErrorCode Decoder::SetContrast(int param)
// Purpose: Set video contrast
// Input:   int param - parameter value (0-255; default 128)
// Output:  None
// Return:  Fail if error in parameter, else Success
// Note:    See IsAdjustContrast() for detailed description of the contrast
//          adjustment calculation
/////////////////////////////////////////////////////////////////////////////
ErrorCode Decoder::SetContrast(int param)
{
  if(m_param.OutOfRange(param))
    return Fail;

  BOOL adjustContrast = IsAdjustContrast(); // is contrast need to be adjusted

  // if adjust contrast is needed, make sure contrast reg value != 0
  if (adjustContrast)
    m_regContrast = CRegInfo(1, ConMax, ConDef);

  // perform mapping to our range
  int mapped;
  if (Mapping(param, m_param, &mapped, m_regContrast) == Fail)
    return Fail;

  m_conParam = (WORD)param;

  // calculate contrast
  DWORD value =  (DWORD)0x1FF * (DWORD)mapped;
  value /= (DWORD)m_regContrast.Max();
  if (value > 0x1FF)
    value = 0x1FF;

  // contrast is set by a 9 bit value; set LSB first
  decRegCONTRAST_LO = value;

  // now set the Miscellaneous Control Register CON_V_MSB to the 9th bit value
  decFieldCON_MSB = ((value & 0x0100) ? On : Off);

  // perform adjustment of brightness register if adjustment is needed
  if (adjustContrast)
  {
    regContrast = (WORD)value;    // contrast value

    long A = (long)regBright * (long)0xD8;
    long B = 64 * ((long)0xD8 - (long)regContrast);
    long temp = 0x00;
    if (regContrast != 0)  // already limit contrast > zero; just in case here
       temp = ((A + B) / (long)regContrast);
    temp = (temp < -128) ? -128 : ((temp > 127) ? 127 : temp);
    decRegBRIGHT = (BYTE)temp;

  }

  return Success;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  int Decoder::GetContrast()
// Purpose: Obtain contrast value
// Input:   None
// Output:  None
// Return:  Contrast parameter (0-255)
/////////////////////////////////////////////////////////////////////////////
int Decoder::GetContrast()
{
  return m_conParam;
}


//===== Chroma Gain register (SAT_U_MSB, SAT_V_MSB, SAT_U_LO, SAT_V_LO) =====

/////////////////////////////////////////////////////////////////////////////
// Method:  ErrorCode Decoder::SetSaturation(int param)
// Purpose: Set color saturation by modifying U and V values
// Input:   int param - parameter value (0-255; default 128)
// Output:  None
// Return:  Fail if error in parameter, else Success
/////////////////////////////////////////////////////////////////////////////
ErrorCode Decoder::SetSaturation(int param)
{
  if(m_param.OutOfRange(param))
    return Fail;

  // color saturation is controlled by two nine bit values:
  // ChromaU & ChromaV
  // To maintain normal color balance, the ratio between the 2 register
  // values should be kept at the power-up default ratio

  // Note that U & V values for NTSC and PAL are the same, SECAM is different

  WORD nominalNTSC_U = 0xFE;     // nominal value (i.e. 100%) for NTSC/PAL
  WORD nominalNTSC_V = 0xB4;
  WORD nominalSECAM_U = 0x87;    // nominal value (i.e. 100%) for SECAM
  WORD nominalSECAM_V = 0x85;

  CRegInfo regSat;               // selected saturation register; NTSC/PAL or SECAM
  WORD nominal_U, nominal_V;     // selected nominal U and V value; NTSC/PAL or SECAM

  // select U & V values of either NTSC/PAL or SECAM to be used for calculation
  if (GetVideoFormat() == VFormat_SECAM)
  {
    nominal_U = nominalSECAM_U;
    nominal_V = nominalSECAM_V;
    regSat = m_regSaturationSECAM;
  }
  else
  {
    nominal_U = nominalNTSC_U;
    nominal_V = nominalNTSC_V;
    regSat = m_regSaturationNTSC;
  }

  // perform mapping to our range
  int mapped;
  if (Mapping(param, m_param, &mapped, regSat) == Fail)
    return Fail;

  m_satParam = (WORD)param;

  WORD max_nominal = max(nominal_U, nominal_V);

  // calculate U and V values
  WORD Uvalue = (WORD) ((DWORD)mapped * (DWORD)nominal_U / (DWORD)max_nominal);
  WORD Vvalue = (WORD) ((DWORD)mapped * (DWORD)nominal_V / (DWORD)max_nominal);

  // set U
  decRegSAT_U_LO = Uvalue;

  // now set the Miscellaneous Control Register SAT_U_MSB to the 9th bit value
  decFieldSAT_U_MSB = ((Uvalue & 0x0100) ? On : Off);

  // set V
  decRegSAT_V_LO = Vvalue;

  // now set the Miscellaneous Control Register SAT_V_MSB to the 9th bit value
  decFieldSAT_V_MSB = ((Vvalue & 0x0100) ? On : Off);

  return Success;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  int Decoder::GetSaturation()
// Purpose: Obtain saturation value
// Input:   None
// Output:  None
// Return:  Saturation parameter (0-255)
/////////////////////////////////////////////////////////////////////////////
int Decoder::GetSaturation()
{
  return m_satParam;
}


//===== Hue Control register (HUE) ==========================================

/////////////////////////////////////////////////////////////////////////////
// Method:  ErrorCode Decoder::SetHue(int param)
// Purpose: Set video hue
// Input:   int param - parameter value (0-255; default 128)
// Output:  None
// Return:  Fail if error in parameter, else Success
/////////////////////////////////////////////////////////////////////////////
ErrorCode Decoder::SetHue(int param)
{
  if(m_param.OutOfRange(param))
    return Fail;

  // perform mapping to our range
  int mapped;
  if (Mapping(param, m_param, &mapped, m_regHue) == Fail)
    return Fail;

  m_hueParam = (WORD)param;

  int value = (-128 * mapped) / m_regHue.Max();

  if (value > 127)
    value = 127;
  else if (value < -128)
    value = -128;

  decRegHUE = value;

  return Success;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  int Decoder::GetHue()
// Purpose: Obtain hue value
// Input:   None
// Output:  None
// Return:  Hue parameter (0-255)
/////////////////////////////////////////////////////////////////////////////
int Decoder::GetHue()
{
  return m_hueParam;
}


//===== SC Loop Control register (E_SCLOOP, O_SCLOOP) =======================


/////////////////////////////////////////////////////////////////////////////
// Method:  void Decoder::SetChromaAGC(BOOL mode)
// Purpose: Enable/Disable Chroma AGC compensation
// Input:   BOOL mode - TRUE = Enable, FALSE = Disable
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Decoder::SetChromaAGC(BOOL mode)
{
  decFieldCAGC = (mode == FALSE) ? Off : On;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  BOOL Decoder::IsChromaAGC()
// Purpose: Check if Chroma AGC compensation is enable or disable
// Input:   None
// Output:  None
// Return:  TRUE = Enable, FALSE = Disable
/////////////////////////////////////////////////////////////////////////////
BOOL Decoder::IsChromaAGC()
{
  return (decFieldCAGC == On) ? TRUE : FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  void Decoder::SetLowColorAutoRemoval(BOOL mode)
// Purpose: Enable/Disable low color detection and removal
// Input:   BOOL mode - TRUE = Enable, FALSE = Disable
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Decoder::SetLowColorAutoRemoval(BOOL mode)
{
  decFieldCKILL = (mode == FALSE) ? Off : On;
}


//===== Output Format register (OFORM) ======================================

/////////////////////////////////////////////////////////////////////////////
// Method:  void Decoder::SetVBIFrameMode(BOOL mode)
// Purpose: Enable/Disable VBI frame output mode
// Input:   BOOL mode - TRUE = Enable, FALSE = Disable
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Decoder::SetVBIFrameMode(BOOL mode)
{
  decFieldVBI_FRAME = (mode == FALSE) ? Off : On;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  BOOL Decoder::IsVBIFrameMode()
// Purpose: Check if VBI frame output mode is enabled
// Input:   None
// Output:  None
// Return:  TRUE = Enable, FALSE = Disable
/////////////////////////////////////////////////////////////////////////////
BOOL Decoder::IsVBIFrameMode()
{
  return (decFieldVBI_FRAME == On) ? TRUE : FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  void Decoder::SetCodeInsertionEnabled(BOOL mode)
// Purpose: 
// Input:   BOOL mode - TRUE = Disabled, FALSE = Enabled
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Decoder::SetCodeInsertionEnabled(BOOL mode)
{
  decFieldCODE = (mode == TRUE) ? On : Off;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  BOOL Decoder::IsCodeInsertionEnabled()
// Purpose: Check if code insertion in data stream is enabled
// Input:   None
// Output:  None
// Return:  TRUE = enabled, FALSE = disabled
/////////////////////////////////////////////////////////////////////////////
BOOL Decoder::IsCodeInsertionEnabled()
{
  return (decFieldCODE == On) ? TRUE : FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Method:  void Decoder::Set16BitDataStream(BOOL mode)
// Purpose: 8 or 16 bit data stream
// Input:   BOOL mode - TRUE = 16, FALSE = 8
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Decoder::Set16BitDataStream(BOOL mode)
{
  decFieldLEN = (mode == TRUE) ? On : Off;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  BOOL Decoder::Is16BitDatastream()
// Purpose: Check if 16 bit data stream
// Input:   None
// Output:  None
// Return:  TRUE = 16, FALSE = 8
/////////////////////////////////////////////////////////////////////////////
BOOL Decoder::Is16BitDataStream()
{
  return (decFieldLEN == On) ? TRUE : FALSE;
}


//===== Vertical Scaling register (E_VSCALE_HI, O_VSCALE_HI) ================

/////////////////////////////////////////////////////////////////////////////
// Method:  void Decoder::SetChromaComb(BOOL mode)
// Purpose: Enable/Disable chroma comb
// Input:   BOOL mode - TRUE = Enable, FALSE = Disable
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Decoder::SetChromaComb(BOOL mode)
{
  decFieldCOMB = (mode == FALSE) ? Off : On;
}

/////////////////////////////////////////////////////////////////////////////
// Method:  BOOL Decoder::IsChromaComb()
// Purpose: Check if chroma comb is enable or disable
// Input:   None
// Output:  None
// Return:  TRUE = Enable, FALSE = Disable
/////////////////////////////////////////////////////////////////////////////
BOOL Decoder::IsChromaComb()
{
  return (decFieldCOMB == On) ? TRUE : FALSE;
}
   
/////////////////////////////////////////////////////////////////////////////
// Method:  void Decoder::SetInterlaced(BOOL mode)
// Purpose: Enable/Disable Interlace
// Input:   BOOL mode - TRUE = Interlaced
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Decoder::SetInterlaced(BOOL mode)
{
  decFieldINT = (mode == FALSE) ? Off : On;
}

/////////////////////////////////////////////////////////////////////////////
// Method:  BOOL Decoder::IsInterlaced()
// Purpose: Check if interlaced or non-interlaced
// Input:   None
// Output:  None
// Return:  TRUE = Interlaced
/////////////////////////////////////////////////////////////////////////////
BOOL Decoder::IsInterlaced()
{
  return (decFieldINT == On) ? TRUE : FALSE;
}
   
//===== VPOLE register ==================================================

BOOL Decoder::IsOutputEnabled ()
{
    return (decFieldOUT_EN == m_outputEnablePolarity);
}

void Decoder::SetOutputEnabled (BOOL mode)
{
    decFieldOUT_EN = (mode == TRUE) ? m_outputEnablePolarity : !m_outputEnablePolarity;
}

BOOL Decoder::IsHighOdd ()
{
    return (decFieldFIELD == 0); // 0 enabled; 1 even
}

void Decoder::SetHighOdd (BOOL mode)
{
    decFieldFIELD = (mode == TRUE) ? 0 : 1; // 0 enabled; 1 even
}

//===== ADC Interface register (ADC) =========================================

/////////////////////////////////////////////////////////////////////////////
// Method:  void Decoder::PowerDown(BOOL mode)
// Purpose: Select normal or shut down clock operation
// Input:   BOOL mode - TRUE = shut down, FALSE = normal operation
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Decoder::PowerDown(BOOL mode)
{
  decFieldCLK_SLEEP = (mode == FALSE) ? Off : On;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  BOOL Decoder::IsPowerDown()
// Purpose: Check if clock operation has been shut down
// Input:   None
// Output:  None
// Return:  TRUE = shut down, FALSE = normal operation
/////////////////////////////////////////////////////////////////////////////
BOOL Decoder::IsPowerDown()
{
  return (decFieldCLK_SLEEP == On) ? TRUE : FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  void Decoder::SetChromaADC(BOOL mode)
// Purpose: Select normal or sleep C ADC operation
// Input:   BOOL mode - TRUE = normal, FALSE = sleep
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Decoder::SetChromaADC(BOOL mode)
{
  decFieldC_SLEEP = (mode == FALSE) ? On : Off; // reverse
}


/*^^////////////////////////////////////////////////////////////////////////////
// Method:  void Decoder::SetAdaptiveAGC(BOOL mode)
// Purpose: Set adaptive or non-adaptive AGC operation
// Input:   BOOL mode - TRUE = Adaptive, FALSE = Non-adaptive
// Output:  None
// Return:  None
*////////////////////////////////////////////////////////////////////////////
void Decoder::SetAdaptiveAGC(BOOL mode)
{
   decFieldCRUSH = (mode == FALSE) ? Off : On;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  BOOL Decoder::IsAdaptiveAGC()
// Purpose: Check if adaptive or non-adaptive AGC operation is selected
// Input:   None
// Output:  None
// Return:  TRUE = Adaptive, FALSE = Non-adaptive
/////////////////////////////////////////////////////////////////////////////
BOOL Decoder::IsAdaptiveAGC()
{
  return (decFieldCRUSH == On) ? TRUE : FALSE;
}


//===== Software Reset register (SRESET) ====================================

/////////////////////////////////////////////////////////////////////////////
// Method:  void Decoder::SoftwareReset()
// Purpose: Perform software reset; all registers set to default values
// Input:   None
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Decoder::SoftwareReset()
{
  decRegSRESET = 0x00;  // write any value will do
}


//===== Test Control register (TEST) ========================================

/////////////////////////////////////////////////////////////////////////////
// Method:  void Decoder::AdjustInertialDampener(BOOL mode)
// Purpose: for factory diagnostics only
// Input:   TRUE or FALSE
// Output:  None
// Return:  None
// NOTE:    For factory diagnostics only!!!!!!!
//          John Welch's dirty little secret
/////////////////////////////////////////////////////////////////////////////
void Decoder::AdjustInertialDampener(BOOL mode)
{
#pragma message ("FOR TEST DIAGNOSTICS ONLY!  ")
  decRegTEST = (mode == FALSE) ? 0x00 : 0x01;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  void Decoder::SelectCrystal(char useCrystal)
// Purpose: Select correct crystal for NTSC or PAL
// Input:   char useCrystal - 'N' for NTSC; 'P' for PAL
// Output:  None
// Return:  None
// NOTE:    Assume at most 2 crystals installed in hardware. i.e. 1 for NTSC
//          and the other for PAL/SECAM.
//          If there is only 1 crystal exists (which must be crystal XT0),
//          do nothing since it is already selected.
/////////////////////////////////////////////////////////////////////////////
void Decoder::SelectCrystal(char useCrystal)
{
#pragma message("do something about registry")
/*
   // locate crystal information in the registry
   // the keys to look for in registry are:
   //    1. Bt848\NumXTAL - number of crystal installed
   //                       possible values are "1" or "2"
   //    2. Bt848\XT0     - what crystal type is for crystal 0
   //                       possible values are "NTSC", "PAL"
   // There is another key exist which may be useful in the future:
   //    Bt848\XT1        - what crystal type is for crystal 1
   //                       possible values are "NTSC", "PAL", and "NONE"

   VRegistryKey vkey(PRK_CLASSES_ROOT, "Bt848");

   // make sure the key exists
   if (vkey.lastError() == ERROR_SUCCESS)
   {
      char * numCrystalKey = "NumXTAL";
      char   nCrystal[5];
      DWORD  nCrystalLen = 2;    // need only first char; '1' or '2'

      // get number of crystal exists
      if (vkey.getSubkeyValue(numCrystalKey, nCrystal, (DWORD *)&nCrystalLen))
      {
         // if there is only 1 crystal, no other crystal to change to
         if (nCrystal[0] == '2')
         {
            char * crystalTypeKey = "XT0";    // crystal 0 type
            char   crystalType[10];
            DWORD  crystalTypeLen = 6;    // need only first char: 'N' or 'P'

            // get the crystal 0 information
            if (vkey.getSubkeyValue(crystalTypeKey, crystalType, (DWORD *)&crystalTypeLen))
               // compare with what we want to use
               if ((IsCrystal0Selected() && (crystalType[0] != useCrystal)) ||
                    (!IsCrystal0Selected() && (crystalType[0] == useCrystal)))
                  // need to change crystal
                  SetCrystal(IsCrystal0Selected() ? Crystal_XT1 : Crystal_XT0);
         }
      }
   }
*/   
}

/////////////////////////////////////////////////////////////////////////////
// Method:  ErrorCode Decoder::Mapping(int fromValue, CRegInfo fromRange,
//                                           int * toValue, CRegInfo toRange)
// Purpose: Map a value in certain range to a value in another range
// Input:   int fromValue - value to be mapped from
//          CRegInfo fromRange - range of value mapping from
//          CRegInfo toRange   - range of value mapping to
// Output:  int * toValue - mapped value
// Return:  Fail if error in parameter, else Success
// Comment: No range checking is performed here. Assume parameters are in
//          valid ranges.
//          The mapping function does not assume default is always the mid
//          point of the whole range. It only assumes default values of the
//          two ranges correspond to each other.
//          
//          The mapping formula is:
//
//            For fromRange.Min() <= fromValue <= fromRange.Default():
//
//               fromValue (fromRange.Default() - fromRange.Min())
//               ------------------------------------------------ + fromRange.Min()
//                     toRange.Default() - toRange.Min()
//
//            For fromRange.Default() < fromValue <= fromRange.Max():
//
//               (fromValue - fromRange.Default()) (toRange.Max() - toRange.Default())
//               --------------------------------------------------------------------- + toRange.Default()
//                           toRange.Max() - toRange.Default()
//
////////////////////////////////////////////////////////////////////////////
ErrorCode Decoder::Mapping(int fromValue, CRegInfo fromRange,
                                 int * toValue, CRegInfo toRange)
{
   // calculate intermediate values
   DWORD a = toRange.Default() - toRange.Min();
   DWORD b = fromRange.Default() - fromRange.Min();
   DWORD c = toRange.Max() - toRange.Default();
   DWORD d = fromRange.Max() - fromRange.Default();

   // prevent divide by zero
   if ((b == 0) || (d == 0))
      return (Fail);

   // perform mapping
   if (fromValue <= fromRange.Default())
      *toValue = (int) (DWORD)fromValue * a / b + (DWORD)toRange.Min();
   else
      *toValue = (int) ((DWORD)fromValue - (DWORD)fromRange.Default()) * c / d
                       + (DWORD)toRange.Default();

   return (Success);
}


/////////////////////////////////////////////////////////////////////////////
// Method:  BOOL Decoder::IsAdjustContrast()
// Purpose: Check registry key whether adjust contrast is needed
// Input:   None
// Output:  None
// Return:  TRUE = adjust contrast, FALSE = don't adjust contrast
// Note:    If adjust contrast is turn on, brightness register value will be
//          adjusted such that it remains a constant after the calculation
//          performed by the hardware.
//
//          The formula is:
//             To keep brightness constant (i.e. not affect by changing contrast)
//             set brightness to B/(C/C0)
//             where B is value of brightness before adjustment
//                   C is contrast value
//                   C0 is nominal contrast value (0xD8)
//
//             To adjust the contrast level such that it is at the middle of
//             black and white: set brightness to (B * C0 + 64 * (C0 - C))/C
//             (this is what Intel wants)
//
//             Currently there is still limitation of how much adjustment
//             can be performed. For example, if brightness is already high,
//             (i.e. brightness reg value close to 0x7F), lowering contrast
//             until a certain level will have no adjustment effect on brightness.
//             In fact, it would even bring down brightness to darkness.
//
//             Example 1: if brightness is at nominal value (0x00), contrast can
//                        only go down to 0x47 (brightness adjustment is already
//                        at max of 0x7F) before it starts affecting brightness
//                        which takes it darkness.
//             Example 2: if brightness is at nominal value (0x00), contrast can
//                        go all the way up with brightness adjusted correctly.
//                        However, the max adjustment used is only 0xDC and
//                        the max adjustment we can use is 0x&F.
//             Example 3: if brightness is at max (0x7F), lowering contrast
//                        cannot be compensated by adjusting brightness anymore.
//                        The result is gradually taking brightness to darkness.
//             Example 4: if brightness is at min (0x80), lowering contrast has
//                        no visual effect. Bringing contrast to max is using
//                        0xA5 in brightness for compensation.
//
//             One last note, the center is defined as the middle of the
//             gamma adjusted luminance level. Changing it to use the middle of
//             the linear (RGB) luminance level is possible.
/////////////////////////////////////////////////////////////////////////////
BOOL Decoder::IsAdjustContrast()
{
   return FALSE;
/*
   // locate adjust contrast information in the registry
   // the key to look for in registry is:
   //    Bt848\AdjustContrast - 0 = don't adjust contrast
   //                           1 = adjust contrast

   VRegistryKey vkey(PRK_CLASSES_ROOT, "Bt848");

   // make sure the key exists
   if (vkey.lastError() == ERROR_SUCCESS)
   {
      char * adjustContrastKey = "AdjustContrast";
      char   key[3];
      DWORD  keyLen = 2;    // need only first char; '0' or '1'

      // get the registry value and check it, if exist
      if ((vkey.getSubkeyValue(adjustContrastKey, key, (DWORD *)&keyLen)) &&
           (key[0] == '1'))
         return (TRUE);
   }
   return (FALSE);
*/   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\bt-829\atibt\device.cpp ===
//==========================================================================;
//
//	Device - Implementation of the Bt829 CVideoDecoderDevice
//
//		$Date:   28 Aug 1998 14:44:20  $
//	$Revision:   1.2  $
//	  $Author:   Tashjian  $
//
// $Copyright:	(c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

#include "register.h"
#include "defaults.h"
#include "device.h"
#include "mediums.h"
#include "capdebug.h"
#include "StrmInfo.h"

#include "initguid.h"
DEFINE_GUID(DDVPTYPE_BROOKTREE,     0x1352A560L,0xDA61,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8);


// #define BT829_VPCONNECTIONS_NUMBER  2
#define BT829_VPCONNECTIONS_NUMBER  1
#define BT829_PIXELFORMATS_NUMBER   1
#define NTSC_FRAME_RATE 30
#define PAL_FRAME_RATE 25
#define BT829_LOST_LINES	2  // BT829
#define BT829A_LOST_LINES	3   // BT829a


Device::Device( PPORT_CONFIGURATION_INFORMATION ConfigInfo,
			    PDEVICE_PARMS pDeviceParms, 
				PUINT puiError) :

		m_pDeviceParms(pDeviceParms),

        // Corresponds to KS_DEFAULTs
        hue(128),
        saturation(128),
        contrast(128),
        brightness(128),
        source(ConTuner),
        VBIEN(FALSE),
        VBIFMT(FALSE),

        // Beware of these hardcoded values

        //Paul:  Setup default for NTSC and PAL
        NTSCDecoderWidth(720),
        NTSCDecoderHeight(240),
        PALDecoderWidth(720),
        PALDecoderHeight(288),
        // Now set via registry
        defaultDecoderWidth(720),
        defaultDecoderHeight(240)
{
	*puiError = 0;

    RegisterB devRegIDCODE (0x17, RO, pDeviceParms);
    RegField devFieldPART_ID (devRegIDCODE, 4, 4);
    RegField devFieldPART_REV (devRegIDCODE, 0, 4);

    m_pDeviceParms->chipID = (int)devFieldPART_ID;
    m_pDeviceParms->chipRev = (int)devFieldPART_REV;

	DBGINFO(("Chip ID: 0x%x\n", m_pDeviceParms->chipID));
	DBGINFO(("Chip revision: 0x%x\n", m_pDeviceParms->chipRev));

    // Bt829 should have a PartID of 1110b (0xe).
    if (m_pDeviceParms->chipID != 0xe)
    {
		DBGERROR(("I2c failure or wrong decoder.\n"));
		*puiError = 1;
        return;
    }

    PDEVICE_DATA_EXTENSION pHwExt = (PDEVICE_DATA_EXTENSION)ConfigInfo->HwDeviceExtension;
    decoder = (Decoder *)	new ((PVOID)&pHwExt->CDecoder) Decoder(m_pDeviceParms);
    scaler =  (Scaler *)	new ((PVOID)&pHwExt->CScaler) Scaler(m_pDeviceParms);
    xbar =	  (CrossBar *)	new ((PVOID)&pHwExt->CXbar) CrossBar();

    UseRegistryValues(ConfigInfo);

    // According to Brooktree, 4 is the magic dividing line
    // between 829 and 829a. Apparently, there is an 829b on the
    // horizon, but I don't have the details yet.
    // This is meant to be a kind of fail-safe
/*
    if (pHwExt->chipRev < 4) {
        outputEnablePolarity = 0;
    }
*/
 
    if (defaultDecoderWidth != 360 && defaultDecoderWidth != 720)
    {
        DBGERROR(("Unexpected defaultDecoderWidth: %d.\n", defaultDecoderWidth));
        TRAP();
    }

    destRect = MRect(0, 0, defaultDecoderWidth, defaultDecoderHeight);

    RestoreState();

    // by default, outputs will be tri-stated. Transitioning to the run state will enable it.
	SetOutputEnabled(FALSE);
}

Device::~Device()
{
    delete decoder;
    delete scaler;
    delete xbar;
}

void Device::SaveState()
{
    // save picture attributes
    hue = decoder->GetHue();
    saturation = decoder->GetSaturation();
    contrast =  decoder->GetContrast();
    brightness = decoder->GetBrightness();

    // save video source
    source = (Connector) GetVideoInput();

    // save configuration of data stream to video port
    isCodeInDataStream = IsCodeInsertionEnabled();
    is16 = Is16BitDataStream();
    
    // save VBI related settings
    VBIEN = IsVBIEN();
    VBIFMT = IsVBIFMT();

    // save scaling dimensions
    scaler->GetDigitalWin(destRect);
}

void Device::RestoreState(DWORD dwStreamsOpen)
{
    Reset();
    
    // (re)initialize image 
    decoder->SetInterlaced(FALSE);
    decoder->SetHue(hue);
    decoder->SetSaturation(saturation);
    decoder->SetContrast(contrast);
    decoder->SetBrightness(brightness);

    // (re)initialize video source
    SetVideoInput(source);

    SetOutputEnablePolarity(m_pDeviceParms->outputEnablePolarity);

    // (re)initialize corresponding xbar setting.
    // 'source' is one-based; Route expects zero-based
    Route(0, source);

    // (re)initialize configuration of data stream to video port
    SetCodeInsertionEnabled(isCodeInDataStream);
    Set16BitDataStream(is16);

    // restore VBI settings
    SetVBIEN(VBIEN);
    SetVBIFMT(VBIFMT);

    SetVideoDecoderStandard( GetVideoDecoderStandard() );
    // initialize scaling dimensions
    //SetRect(destRect);    Paul:  Use set video decoder standard instead

	if(!dwStreamsOpen)
		SetOutputEnabled(IsOutputEnabled());
}

void Device::SetRect(MRect &rect)
{
    destRect = rect;
    scaler->SetAnalogWin(rect);
    scaler->SetDigitalWin(rect);

    // for Debugging
#ifdef DBG
    scaler->DumpSomeState();
#endif
}

void Device::Reset()
{
    SoftwareReset();
}

int Device::GetDecoderWidth()
{
    MRect tmpRect;
    scaler->GetDigitalWin(tmpRect);

    return tmpRect.right;
}

int Device::GetDecoderHeight()
{
    MRect tmpRect;
    scaler->GetDigitalWin(tmpRect);

    return tmpRect.bottom;
}

int Device::GetDefaultDecoderWidth()
{
    return defaultDecoderWidth;
}

int Device::GetDefaultDecoderHeight()
{
    return defaultDecoderHeight;
}

int Device::GetPartID()
{
  return m_pDeviceParms->chipID;
}

int Device::GetPartRev()
{
  return m_pDeviceParms->chipRev;
}

NTSTATUS
Device::GetRegistryValue(
                   IN HANDLE Handle,
                   IN PWCHAR KeyNameString,
                   IN ULONG KeyNameStringLength,
                   IN PWCHAR Data,
                   IN ULONG DataLength
)
/*++

Routine Description:

    Reads the specified registry value

Arguments:

    Handle - handle to the registry key
    KeyNameString - value to read
    KeyNameStringLength - length of string
    Data - buffer to read data into
    DataLength - length of data buffer

Return Value:

    NTSTATUS returned as appropriate

--*/
{
    NTSTATUS        Status = STATUS_INSUFFICIENT_RESOURCES;
    UNICODE_STRING  KeyName;
    ULONG           Length;
    PKEY_VALUE_FULL_INFORMATION FullInfo;

    RtlInitUnicodeString(&KeyName, KeyNameString);

    Length = sizeof(KEY_VALUE_FULL_INFORMATION) +
        KeyNameStringLength + DataLength;

    FullInfo = (struct _KEY_VALUE_FULL_INFORMATION *)ExAllocatePool(PagedPool, Length);

    if (FullInfo) {
        Status = ZwQueryValueKey(Handle,
                                 &KeyName,
                                 KeyValueFullInformation,
                                 FullInfo,
                                 Length,
                                 &Length);

        if (NT_SUCCESS(Status)) {

            if (DataLength >= FullInfo->DataLength) {
                RtlCopyMemory(Data, ((PUCHAR) FullInfo) + FullInfo->DataOffset, FullInfo->DataLength);

            } else {

                TRAP();
                Status = STATUS_BUFFER_TOO_SMALL;
            }                   // buffer right length

        }                       // if success
        ExFreePool(FullInfo);

    }                           // if fullinfo
    return Status;

}

#define MAX_REG_STRING_LENGTH  128


VOID
Device::UseRegistryValues(PPORT_CONFIGURATION_INFORMATION ConfigInfo)
/*++

Routine Description:

    Reads all registry values for the device

Arguments:

    PhysicalDeviceObject - pointer to the PDO

Return Value:

     None.

--*/

{
    NTSTATUS        Status;
    HANDLE          handle;

    WCHAR   MUX0String[] =              L"MUX0";
    WCHAR   MUX1String[] =              L"MUX1";
    WCHAR   MUX2String[] =              L"MUX2";
    WCHAR   buf[MAX_REG_STRING_LENGTH];

    ASSERT(KeGetCurrentIrql() <= PASSIVE_LEVEL);

    Status = IoOpenDeviceRegistryKey(ConfigInfo->PhysicalDeviceObject,
                                     PLUGPLAY_REGKEY_DRIVER,
                                     STANDARD_RIGHTS_ALL,
                                     &handle);

    //
    // now get all of the registry settings for
    // initializing the decoder
    //

     if (NT_SUCCESS(Status)) {
        // =========================
        // Does NOT check that the registry settings "make sense";
        // e.g., that all three inputs aren't set to SVideo.


        // =========================
        // Do MUX0
        // =========================
        Status = GetRegistryValue(handle,
                                    MUX0String,
                                    sizeof(MUX0String),
                                    buf,
                                    sizeof(buf));

        if ((NT_SUCCESS(Status)) && (buf))
        {
            if (stringsEqual(buf, L"svideo"))
                {xbar->InputPins[0] = _XBAR_PIN_DESCRIPTION(KS_PhysConn_Video_SVideo,     -1, &CrossbarMediums[2]);}
            else if (stringsEqual(buf, L"tuner"))
                {xbar->InputPins[0] = _XBAR_PIN_DESCRIPTION(KS_PhysConn_Video_Tuner,      -1, &CrossbarMediums[1]);}
            else if (stringsEqual(buf, L"composite"))
                {xbar->InputPins[0] = _XBAR_PIN_DESCRIPTION(KS_PhysConn_Video_Composite,  -1, &CrossbarMediums[0]);}
            else if (stringsEqual(buf, L"none"))
            {
                TRAP(); 
            }
            else
            {
                TRAP();
            }
        }
        else
        {
            TRAP();
        }


        // =========================
        // Do MUX1
        // =========================
        Status = GetRegistryValue(handle,
                                    MUX1String,
                                    sizeof(MUX1String),
                                    buf,
                                    sizeof(buf));

        if ((NT_SUCCESS(Status)) && (buf))
        {
            if (stringsEqual(buf, L"svideo"))
                {xbar->InputPins[1] = _XBAR_PIN_DESCRIPTION(KS_PhysConn_Video_SVideo,     -1, &CrossbarMediums[2]);}
            else if (stringsEqual(buf, L"tuner"))
                {xbar->InputPins[1] = _XBAR_PIN_DESCRIPTION(KS_PhysConn_Video_Tuner,      -1, &CrossbarMediums[1]);}
            else if (stringsEqual(buf, L"composite"))
                {xbar->InputPins[1] = _XBAR_PIN_DESCRIPTION(KS_PhysConn_Video_Composite,  -1, &CrossbarMediums[0]);}
            else if (stringsEqual(buf, L"none"))
            {
                TRAP();
            }
            else
            {
                TRAP();
            }
        }
        else
        {
            TRAP();
        }


        // =========================
        // Do MUX2
        // =========================
        Status = GetRegistryValue(handle,
                                    MUX2String,
                                    sizeof(MUX2String),
                                    buf,
                                    sizeof(buf));

        if ((NT_SUCCESS(Status)) && (buf))
        {
            if (stringsEqual(buf, L"svideo"))
                {xbar->InputPins[2] = _XBAR_PIN_DESCRIPTION(KS_PhysConn_Video_SVideo,     -1, &CrossbarMediums[2]);}
            else if (stringsEqual(buf, L"tuner"))
                {xbar->InputPins[2] = _XBAR_PIN_DESCRIPTION(KS_PhysConn_Video_Tuner,      -1, &CrossbarMediums[1]);}
            else if (stringsEqual(buf, L"composite"))
                {xbar->InputPins[2] = _XBAR_PIN_DESCRIPTION(KS_PhysConn_Video_Composite,  -1, &CrossbarMediums[0]);}
            else if (stringsEqual(buf, L"none"))
            {
                TRAP();
            }
            else
            {
                TRAP();
            }
        }
        else
        {
            TRAP();
        }


		// =========================
        // 8 or 16 bit data width
        // =========================

		is16 = FALSE;


        // =========================
        // Control codes embedded in data stream?
        // =========================

		isCodeInDataStream = TRUE;


        //Paul:  If hardcoding, might as well leave this with the constructor
		//defaultDecoderWidth = 720;

        //
        // close the registry handle.
        //

        ZwClose(handle);

    }                           // status = success
}

BOOL Device::stringsEqual(PWCHAR pwc1, PWCHAR pwc2)
{
    UNICODE_STRING us1, us2;
    RtlInitUnicodeString(&us1, pwc1);
    RtlInitUnicodeString(&us2, pwc2);

    // case INsensitive
    return (RtlEqualUnicodeString(&us1, &us2, TRUE));
}
// ==========================================

ULONG Device::GetVideoPortProperty(PSTREAM_PROPERTY_DESCRIPTOR pSpd)
{
    ULONG Id  = pSpd->Property->Id;              // index of the property
    ULONG nS  = pSpd->PropertyOutputSize;        // size of data supplied
    ULONG standard = GetVideoDecoderStandard();

    ASSERT(nS >= sizeof(ULONG));

    ULONG ActualBytesTransferred;

    switch (Id)
    {
        case KSPROPERTY_VPCONFIG_NUMCONNECTINFO :
            // 2 VideoPort connections are possible
            *(PULONG)(pSpd->PropertyInfo) = BT829_VPCONNECTIONS_NUMBER;

            ActualBytesTransferred = sizeof(ULONG);
            break;

        case KSPROPERTY_VPCONFIG_GETCONNECTINFO :

            ASSERT(nS >= BT829_VPCONNECTIONS_NUMBER * sizeof(DDVIDEOPORTCONNECT));

            {
                LPDDVIDEOPORTCONNECT pConnectInfo;

                pConnectInfo = (LPDDVIDEOPORTCONNECT) pSpd->PropertyInfo;

                // fill in the DDVIDEOPORTCONNECT structure 1
                pConnectInfo->dwSize = sizeof(DDVIDEOPORTCONNECT);
                pConnectInfo->guidTypeID = DDVPTYPE_BROOKTREE;
                pConnectInfo->dwPortWidth = 8;
                pConnectInfo->dwFlags = DDVPCONNECT_INVERTPOLARITY;
                pConnectInfo->dwReserved1 = 0;

#if 0
                // fill in the DDVIDEOPORTCONNECT structure 2
                pConnectInfo ++;
                pConnectInfo->dwSize = sizeof(DDVIDEOPORTCONNECT);
                pConnectInfo->guidTypeID = DDVPTYPE_BROOKTREE;
                pConnectInfo->dwPortWidth = 16;
                pConnectInfo->dwFlags = DDVPCONNECT_INVERTPOLARITY;
                pConnectInfo->dwReserved1 = 0;
#endif
            }

            ActualBytesTransferred = BT829_VPCONNECTIONS_NUMBER * sizeof(DDVIDEOPORTCONNECT);
            break;

        case KSPROPERTY_VPCONFIG_NUMVIDEOFORMAT :
            // 2 output pixel formats are possible
            *(PULONG)(pSpd->PropertyInfo) = BT829_PIXELFORMATS_NUMBER;

            ActualBytesTransferred = sizeof(ULONG);
            break;

        case KSPROPERTY_VPCONFIG_GETVIDEOFORMAT :

            ASSERT(nS >= BT829_PIXELFORMATS_NUMBER * sizeof(DDPIXELFORMAT));

            {
                LPDDPIXELFORMAT pPixelFormat;

                pPixelFormat = (LPDDPIXELFORMAT) pSpd->PropertyInfo;

                // fill in the DDPIXELFORMAT structure
                pPixelFormat->dwSize = sizeof(DDPIXELFORMAT);
                pPixelFormat->dwFourCC = FOURCC_UYVY;
                pPixelFormat->dwYUVBitCount = 16;
                pPixelFormat->dwFlags = DDPF_FOURCC;
                pPixelFormat->dwYBitMask = (DWORD)0xFF00FF00;
                pPixelFormat->dwUBitMask = (DWORD)0x000000FF;
                pPixelFormat->dwVBitMask = (DWORD)0x00FF0000;
            }

            ActualBytesTransferred = BT829_PIXELFORMATS_NUMBER * sizeof(DDPIXELFORMAT);
            break;

        case KSPROPERTY_VPCONFIG_VPDATAINFO :

            ASSERT(nS >= sizeof(KS_AMVPDATAINFO));

            {
                PKS_AMVPDATAINFO pAMVPDataInfo;

                pAMVPDataInfo = (PKS_AMVPDATAINFO) pSpd->PropertyInfo;

				int decoderLostLines = (GetPartRev() >= 4) ?
					BT829A_LOST_LINES : BT829_LOST_LINES;

                // the values are sortof hardcoded for NTSC at this point
                // VBI values will need to be tweaked
                pAMVPDataInfo->dwSize = sizeof(KS_AMVPDATAINFO);

                if ( standard & ( KS_AnalogVideo_NTSC_Mask | KS_AnalogVideo_PAL_M ) )   // NTSC rectangle?
                    pAMVPDataInfo->dwMicrosecondsPerField = 16667;
                else
                    pAMVPDataInfo->dwMicrosecondsPerField = 20000;

                pAMVPDataInfo->bEnableDoubleClock = FALSE;
                pAMVPDataInfo->bEnableVACT = FALSE;

                pAMVPDataInfo->lHalfLinesOdd = 0;
                pAMVPDataInfo->lHalfLinesEven = 1;

                pAMVPDataInfo->bFieldPolarityInverted = FALSE;
                pAMVPDataInfo->bDataIsInterlaced = TRUE;
                pAMVPDataInfo->dwNumLinesInVREF = 6 - decoderLostLines;

                pAMVPDataInfo->amvpDimInfo.dwFieldWidth = GetDecoderWidth();
                
                // Beware of hard-coded numbers
                pAMVPDataInfo->amvpDimInfo.dwVBIWidth = VBISamples;

                if ( standard & ( KS_AnalogVideo_NTSC_Mask | KS_AnalogVideo_PAL_M ) )   // NTSC rectangle?
                {
                    pAMVPDataInfo->amvpDimInfo.dwVBIHeight = NTSCVBIEnd - decoderLostLines;
                    pAMVPDataInfo->amvpDimInfo.dwFieldHeight =
                        GetDecoderHeight() +
                        pAMVPDataInfo->amvpDimInfo.dwVBIHeight;
                    /*
                        (NTSCVBIEnd - 1) -  // the '- 1' makes VBIEnd zero-based
                        decoderLostLines -
                        pAMVPDataInfo->dwNumLinesInVREF;
                    */
                
                    pAMVPDataInfo->amvpDimInfo.rcValidRegion.top = NTSCVBIEnd - decoderLostLines;
                }
                else
                {
                    pAMVPDataInfo->amvpDimInfo.dwVBIHeight = PALVBIEnd - decoderLostLines;
                    pAMVPDataInfo->amvpDimInfo.dwFieldHeight =
                        GetDecoderHeight() +
                        pAMVPDataInfo->amvpDimInfo.dwVBIHeight;
                    /*
                        (PALVBIEnd - 1) -  // the '- 1' makes VBIEnd zero-based
                        decoderLostLines -
                        pAMVPDataInfo->dwNumLinesInVREF;
                    */
                
                    pAMVPDataInfo->amvpDimInfo.rcValidRegion.top = PALVBIEnd - decoderLostLines;
                }

                pAMVPDataInfo->amvpDimInfo.rcValidRegion.left = 0;
                pAMVPDataInfo->amvpDimInfo.rcValidRegion.right = pAMVPDataInfo->amvpDimInfo.dwFieldWidth;
                pAMVPDataInfo->amvpDimInfo.rcValidRegion.bottom = pAMVPDataInfo->amvpDimInfo.dwFieldHeight;

                pAMVPDataInfo->dwPictAspectRatioX = 4;
                pAMVPDataInfo->dwPictAspectRatioY = 3;
            }

            ActualBytesTransferred = sizeof(KS_AMVPDATAINFO);
            break;

        case KSPROPERTY_VPCONFIG_MAXPIXELRATE :
            ASSERT(nS >= sizeof(KSVPMAXPIXELRATE));

            {

                PKSVPMAXPIXELRATE pKSPixelRate;

                int decoderHeight = GetDecoderHeight();
                int decoderWidth = GetDecoderWidth();

                pKSPixelRate = (PKSVPMAXPIXELRATE) pSpd->PropertyInfo;

                pKSPixelRate->Size.dwWidth = decoderWidth;
                pKSPixelRate->Size.dwHeight = decoderHeight;
                if ( standard & ( KS_AnalogVideo_NTSC_Mask | KS_AnalogVideo_PAL_M ) )   // NTSC rectangle?
                    pKSPixelRate->MaxPixelsPerSecond = decoderWidth * decoderHeight * NTSC_FRAME_RATE;
                else
                    pKSPixelRate->MaxPixelsPerSecond = decoderWidth * decoderHeight * PAL_FRAME_RATE;
            }
            ActualBytesTransferred = sizeof(KSVPMAXPIXELRATE);
            break;

        case KSPROPERTY_VPCONFIG_INFORMVPINPUT :
            ActualBytesTransferred = 0;
			break;

        case KSPROPERTY_VPCONFIG_DECIMATIONCAPABILITY :
            *(PBOOL)(pSpd->PropertyInfo) = TRUE;
            ActualBytesTransferred = sizeof(BOOL);
            break;

        default:
            TRAP();
            ActualBytesTransferred = 0;
            break;
    }
	return ActualBytesTransferred;
}       

ULONG Device::GetVideoPortVBIProperty(PSTREAM_PROPERTY_DESCRIPTOR pSpd)
{
    ULONG Id  = pSpd->Property->Id;              // index of the property
    ULONG nS  = pSpd->PropertyOutputSize;        // size of data supplied
    ULONG standard = GetVideoDecoderStandard();

    ASSERT(nS >= sizeof(ULONG));

    ULONG ActualBytesTransferred;

    switch (Id)
    {
        case KSPROPERTY_VPCONFIG_NUMCONNECTINFO :
            // 2 VideoPort connections are possible
            *(PULONG)(pSpd->PropertyInfo) = BT829_VPCONNECTIONS_NUMBER;

            ActualBytesTransferred = sizeof(ULONG);
            break;

        case KSPROPERTY_VPCONFIG_GETCONNECTINFO :

            ASSERT(nS >= BT829_VPCONNECTIONS_NUMBER * sizeof(DDVIDEOPORTCONNECT));

            {
                LPDDVIDEOPORTCONNECT pConnectInfo;

                pConnectInfo = (LPDDVIDEOPORTCONNECT) pSpd->PropertyInfo;

                // fill in the DDVIDEOPORTCONNECT structure 1
                pConnectInfo->dwSize = sizeof(DDVIDEOPORTCONNECT);
                pConnectInfo->guidTypeID = DDVPTYPE_BROOKTREE;
                pConnectInfo->dwPortWidth = 8;
                pConnectInfo->dwFlags = DDVPCONNECT_INVERTPOLARITY;
                pConnectInfo->dwReserved1 = 0;

#if 0
                // fill in the DDVIDEOPORTCONNECT structure 2
                pConnectInfo ++;
                pConnectInfo->dwSize = sizeof(DDVIDEOPORTCONNECT);
                pConnectInfo->guidTypeID = DDVPTYPE_BROOKTREE;
                pConnectInfo->dwPortWidth = 16;
                pConnectInfo->dwFlags = DDVPCONNECT_INVERTPOLARITY;
                pConnectInfo->dwReserved1 = 0;
#endif
            }

            ActualBytesTransferred = BT829_VPCONNECTIONS_NUMBER * sizeof(DDVIDEOPORTCONNECT);
            break;

        case KSPROPERTY_VPCONFIG_NUMVIDEOFORMAT :
            // 2 output pixel formats are possible
            *(PULONG)(pSpd->PropertyInfo) = BT829_PIXELFORMATS_NUMBER;

            ActualBytesTransferred = sizeof(ULONG);
            break;

        case KSPROPERTY_VPCONFIG_GETVIDEOFORMAT :

            ASSERT(nS >= BT829_PIXELFORMATS_NUMBER * sizeof(DDPIXELFORMAT));

            {
                LPDDPIXELFORMAT pPixelFormat;

                pPixelFormat = (LPDDPIXELFORMAT) pSpd->PropertyInfo;

                // fill in the DDPIXELFORMAT structure
                pPixelFormat->dwSize = sizeof(DDPIXELFORMAT);
                pPixelFormat->dwFourCC = FOURCC_VBID;
                pPixelFormat->dwYUVBitCount = 8;
                pPixelFormat->dwFlags = DDPF_FOURCC;
            }

            ActualBytesTransferred = BT829_PIXELFORMATS_NUMBER * sizeof(DDPIXELFORMAT);
            break;

        case KSPROPERTY_VPCONFIG_VPDATAINFO :

            ASSERT(nS >= sizeof(KS_AMVPDATAINFO));

            {
                PKS_AMVPDATAINFO pAMVPDataInfo;

                pAMVPDataInfo = (PKS_AMVPDATAINFO) pSpd->PropertyInfo;

				int decoderLostLines = (GetPartRev() >= 4) ?
					BT829A_LOST_LINES : BT829_LOST_LINES;

                // the values are sortof hardcoded for NTSC at this point
                // VBI values will need to be tweaked
                pAMVPDataInfo->dwSize = sizeof(KS_AMVPDATAINFO);
                if ( standard & ( KS_AnalogVideo_NTSC_Mask | KS_AnalogVideo_PAL_M ) )   // NTSC rectangle?
                    pAMVPDataInfo->dwMicrosecondsPerField = 16667;
                else
                    pAMVPDataInfo->dwMicrosecondsPerField = 20000;

                pAMVPDataInfo->bEnableDoubleClock = FALSE;
                pAMVPDataInfo->bEnableVACT = FALSE;

                pAMVPDataInfo->lHalfLinesOdd = 0;
                pAMVPDataInfo->lHalfLinesEven = 1;

                pAMVPDataInfo->bFieldPolarityInverted = FALSE;
                pAMVPDataInfo->bDataIsInterlaced = TRUE;
                pAMVPDataInfo->dwNumLinesInVREF = 6 - decoderLostLines;

                pAMVPDataInfo->amvpDimInfo.dwFieldWidth = GetDecoderWidth();
                
                // Beware of hard-coded numbers
                pAMVPDataInfo->amvpDimInfo.dwVBIWidth = VBISamples;
                pAMVPDataInfo->amvpDimInfo.rcValidRegion.left = 0;

                if ( standard & ( KS_AnalogVideo_NTSC_Mask | KS_AnalogVideo_PAL_M ) )   // NTSC rectangle?
                {
                    pAMVPDataInfo->amvpDimInfo.dwVBIHeight = NTSCVBIEnd - decoderLostLines;
                    pAMVPDataInfo->amvpDimInfo.dwFieldHeight =
                        GetDecoderHeight() +
                        pAMVPDataInfo->amvpDimInfo.dwVBIHeight;
                    /*
                        (NTSCVBIEnd - 1) -  // the '- 1' makes VBIEnd zero-based
                        decoderLostLines -
                        pAMVPDataInfo->dwNumLinesInVREF;
                    */
                
                    pAMVPDataInfo->amvpDimInfo.rcValidRegion.top = NTSCVBIStart - 1 - decoderLostLines;
                }
                else
                {
                    pAMVPDataInfo->amvpDimInfo.dwVBIHeight = PALVBIEnd - decoderLostLines;
                    pAMVPDataInfo->amvpDimInfo.dwFieldHeight =
                        GetDecoderHeight() +
                        pAMVPDataInfo->amvpDimInfo.dwVBIHeight;
                    /*
                        (PALVBIEnd - 1) -  // the '- 1' makes VBIEnd zero-based
                        decoderLostLines -
                        pAMVPDataInfo->dwNumLinesInVREF;
                    */
                
                    pAMVPDataInfo->amvpDimInfo.rcValidRegion.top = PALVBIStart - 1 - decoderLostLines;
                }

                pAMVPDataInfo->amvpDimInfo.rcValidRegion.right = pAMVPDataInfo->amvpDimInfo.dwVBIWidth;
                pAMVPDataInfo->amvpDimInfo.rcValidRegion.bottom = pAMVPDataInfo->amvpDimInfo.dwVBIHeight;
            }

            ActualBytesTransferred = sizeof(KS_AMVPDATAINFO);
            break;

        case KSPROPERTY_VPCONFIG_MAXPIXELRATE :
            ASSERT(nS >= sizeof(KSVPMAXPIXELRATE));

            {

                PKSVPMAXPIXELRATE pKSPixelRate;

                int decoderHeight = GetDecoderHeight();
                int decoderWidth = GetDecoderWidth();

                pKSPixelRate = (PKSVPMAXPIXELRATE) pSpd->PropertyInfo;

                pKSPixelRate->Size.dwWidth = decoderWidth;
                pKSPixelRate->Size.dwHeight = decoderHeight;
                if ( standard & ( KS_AnalogVideo_NTSC_Mask | KS_AnalogVideo_PAL_M ) )   // NTSC rectangle?
                    pKSPixelRate->MaxPixelsPerSecond = decoderWidth * decoderHeight * NTSC_FRAME_RATE;
                else
                    pKSPixelRate->MaxPixelsPerSecond = decoderWidth * decoderHeight * PAL_FRAME_RATE;
            }
            ActualBytesTransferred = sizeof(KSVPMAXPIXELRATE);
            break;

        case KSPROPERTY_VPCONFIG_INFORMVPINPUT :
            ActualBytesTransferred = 0;
            break;

        case KSPROPERTY_VPCONFIG_DECIMATIONCAPABILITY :
            ActualBytesTransferred = 0;
            break;

        default:
            TRAP();
            ActualBytesTransferred = 0;
            break;
    }
	return ActualBytesTransferred;
}       



void Device::ConfigVPSurfaceParams(PKSVPSURFACEPARAMS pSurfaceParams)
{
	DBGINFO(("VP Surface Params:\n"));
	DBGINFO(("dwPitch    = %d\n",pSurfaceParams->dwPitch));
	DBGINFO(("dwXOrigin  = %d\n",pSurfaceParams->dwXOrigin));
	DBGINFO(("dwYOrigin  = %d\n",pSurfaceParams->dwYOrigin));

	VideoSurfaceOriginX = pSurfaceParams->dwXOrigin;
	VideoSurfaceOriginY = pSurfaceParams->dwYOrigin;
	VideoSurfacePitch = pSurfaceParams->dwPitch;
}



void Device::ConfigVPVBISurfaceParams(PKSVPSURFACEPARAMS pSurfaceParams)
{
    DBGINFO(("VP VBI Surface Params:\n"));
    DBGINFO(("dwPitch    = %d\n",pSurfaceParams->dwPitch));
    DBGINFO(("dwXOrigin  = %d\n",pSurfaceParams->dwXOrigin));
    DBGINFO(("dwYOrigin  = %d\n",pSurfaceParams->dwYOrigin));

    VBISurfaceOriginX = pSurfaceParams->dwXOrigin;
    VBISurfaceOriginY = pSurfaceParams->dwYOrigin;
    VBISurfacePitch = pSurfaceParams->dwPitch;
}


// -------------------------------------------------------------------
// VideoProcAmp functions
// -------------------------------------------------------------------

NTSTATUS Device::SetProcAmpProperty(ULONG Id, LONG Value)
{
    switch (Id) {
		case KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS:

			decoder->SetBrightness(Value);
			break;
        
		case KSPROPERTY_VIDEOPROCAMP_CONTRAST:

			decoder->SetContrast(Value);
			break;

		case KSPROPERTY_VIDEOPROCAMP_HUE:

			decoder->SetHue(Value);
			break;

		case KSPROPERTY_VIDEOPROCAMP_SATURATION:

			decoder->SetSaturation(Value);
			break;

		default:
			TRAP();
			return STATUS_NOT_IMPLEMENTED;
			break;
    }

	return STATUS_SUCCESS;
}

NTSTATUS Device::GetProcAmpProperty(ULONG Id, PLONG pValue)
{
    switch (Id) {

		case KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS:
			*pValue = decoder->GetBrightness();
			break;
        
		case KSPROPERTY_VIDEOPROCAMP_CONTRAST:
			*pValue = decoder->GetContrast();
			break;

		case KSPROPERTY_VIDEOPROCAMP_HUE:
			*pValue = decoder->GetHue();
			break;

		case KSPROPERTY_VIDEOPROCAMP_SATURATION:
			*pValue = decoder->GetSaturation();
			break;

		default:
			TRAP();
			return STATUS_NOT_IMPLEMENTED;
			break;
		}

	return STATUS_SUCCESS;
}

BOOL Device::SetVideoDecoderStandard(DWORD standard)    //Paul:  Changed
{
    if ( decoder->SetVideoDecoderStandard(standard) )
    {
        switch (standard)
        {
        case KS_AnalogVideo_NTSC_M:
            scaler->VideoFormatChanged( VFormat_NTSC );
            break;
        case KS_AnalogVideo_NTSC_M_J:
            scaler->VideoFormatChanged( VFormat_NTSC_J );
            break;
		case KS_AnalogVideo_PAL_B:
		case KS_AnalogVideo_PAL_D:
		case KS_AnalogVideo_PAL_G:
		case KS_AnalogVideo_PAL_H:
		case KS_AnalogVideo_PAL_I:
            scaler->VideoFormatChanged( VFormat_PAL_BDGHI );    // PAL_BDGHI covers most areas 
            break;
        case KS_AnalogVideo_PAL_M:
            scaler->VideoFormatChanged( VFormat_PAL_M ); 
            break;
        case KS_AnalogVideo_PAL_N:
            scaler->VideoFormatChanged( VFormat_PAL_N_COMB ); 
            break;
        default:    //Paul:  SECAM
            scaler->VideoFormatChanged( VFormat_SECAM );
        }
        //SetRect(destRect);
        return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\bt-829\atibt\device.h ===
#pragma once

//==========================================================================;
//
//	Device - Declaration of the Bt829 CVideoDecoderDevice
//
//		$Date:   28 Aug 1998 14:44:36  $
//	$Revision:   1.2  $
//	  $Author:   Tashjian  $
//
// $Copyright:	(c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

#include "decoder.h"
#include "scaler.h"
#include "xbar.h"
#include "capmain.h"
#include "capdebug.h"
#include "wdmvdec.h"
#include "decdev.h"

class Device: public CVideoDecoderDevice
{
private:
    NTSTATUS GetRegistryValue(HANDLE, PWCHAR, ULONG, PWCHAR, ULONG);
    VOID UseRegistryValues(PPORT_CONFIGURATION_INFORMATION);
    BOOL stringsEqual(PWCHAR, PWCHAR);

	PDEVICE_PARMS	m_pDeviceParms;

    int hue;
    int saturation;
    int contrast;
    int brightness;
    int NTSCDecoderWidth;
    int NTSCDecoderHeight;
    int PALDecoderWidth;
    int PALDecoderHeight;
    int defaultDecoderWidth;
    int defaultDecoderHeight;
    int VBIEN;
    int VBIFMT;
    BOOL isCodeInDataStream;
    BOOL is16;
    MRect destRect;
    ULONG source;

    int VBISurfaceOriginX;
    int VBISurfaceOriginY;
    int VBISurfacePitch;
    int VideoSurfaceOriginX;
    int VideoSurfaceOriginY;
    int VideoSurfacePitch;
	
	Decoder *decoder;
    Scaler *scaler;
    CrossBar *xbar;


public:
    Device(PPORT_CONFIGURATION_INFORMATION, 
		PDEVICE_PARMS, 
		PUINT puiError);

	void * operator new(size_t size, void * pAllocation) { return(pAllocation);}
	void operator delete(void * pAllocation) {}

    void SaveState();
    void RestoreState(DWORD dwStreamsOpen = -1);
    void SetRect(MRect &);
    int GetDecoderWidth();
    int GetDecoderHeight();
    int GetDefaultDecoderWidth();
    int GetDefaultDecoderHeight();
    int GetPartID();
    int GetPartRev();

    //
    // --------------- decoder functions
    //

    void SoftwareReset() 
        {decoder->SoftwareReset();}

    void SetOutputEnabled(BOOL b)
		{
			decoder->SetOutputEnabled( b);
		}
    
    BOOL IsOutputEnabled()
        {return decoder->IsOutputEnabled();}


	void GetVideoDecoderCaps(PKSPROPERTY_VIDEODECODER_CAPS_S caps)
		{decoder->GetVideoDecoderCaps(caps);}
	void GetVideoDecoderStatus(PKSPROPERTY_VIDEODECODER_STATUS_S status)
		{decoder->GetVideoDecoderStatus(status);}
	DWORD GetVideoDecoderStandard()
		{return decoder->GetVideoDecoderStandard();}

    BOOL SetVideoDecoderStandard(DWORD standard);    //Paul:  Changed
   
	
	void SetHighOdd(BOOL b)
        {decoder->SetHighOdd(b);}

    BOOL IsHighOdd()
        {return decoder->IsHighOdd();}

    ErrorCode SetVideoInput(ULONG i)
        {source = i; return decoder->SetVideoInput(i);}

    int GetVideoInput()
        {return decoder->GetVideoInput();}


	NTSTATUS GetProcAmpProperty(ULONG, PLONG);
    NTSTATUS SetProcAmpProperty(ULONG, LONG);

	
    void Set16BitDataStream(BOOL b)
        {decoder->Set16BitDataStream(b);}
    
    BOOL Is16BitDataStream()
        {return decoder->Is16BitDataStream();}

    void SetCodeInsertionEnabled(BOOL b)
        {decoder->SetCodeInsertionEnabled(b);}
    
    BOOL IsCodeInsertionEnabled()
        {return decoder->IsCodeInsertionEnabled();}

    void SetOutputEnablePolarity(int i)
        {decoder->SetOutputEnablePolarity(i);}
    
    int GetOutputEnablePolarity()
        {return decoder->GetOutputEnablePolarity();}

    //
    // --------------- scaler functions
    //
    void SetVBIEN(BOOL b)
        {scaler->SetVBIEN(b);}
    
    BOOL IsVBIEN()
        {return scaler->IsVBIEN();}

    void SetVBIFMT(BOOL b)
        {scaler->SetVBIFMT(b);}
    
    BOOL IsVBIFMT()
        {return scaler->IsVBIFMT();}

    //
    // --------------- xbar functions
    //
    BOOL GoodPins(int InPin, int OutPin)
        {return xbar->GoodPins(InPin, OutPin);}

    BOOL TestRoute(int InPin, int OutPin)
        {return xbar->TestRoute(InPin, OutPin);}

    void Route(int OutPin, int InPin)
        {xbar->Route(OutPin, InPin);}

    int GetNoInputs()
        {return xbar->GetNoInputs();}

    int GetNoOutputs()
        {return xbar->GetNoOutputs();}

    ULONG GetPinInfo(int dir, int idx, ULONG &related)
        {return xbar->GetPinInfo(dir, idx, related);}

    int GetRoute(int OutPin)
        {return xbar->GetRoute(OutPin);}

    KSPIN_MEDIUM * GetPinMedium(int dir, int idx)
        {return xbar->GetPinMedium(dir, idx);}

    void Reset();
    ~Device();


	ULONG GetVideoPortProperty(PSTREAM_PROPERTY_DESCRIPTOR pSPD);
	ULONG GetVideoPortVBIProperty(PSTREAM_PROPERTY_DESCRIPTOR pSPD);
	void ConfigVPSurfaceParams(PKSVPSURFACEPARAMS pSurfaceParams);
	void ConfigVPVBISurfaceParams(PKSVPSURFACEPARAMS pSurfaceParams);

	void GetVideoSurfaceOrigin(int* pX, int* pY)
		{ *pX = VideoSurfaceOriginX; *pY = VideoSurfaceOriginY; }
	void GetVBISurfaceOrigin(int* pX, int* pY)
		{ *pX = VBISurfaceOriginX; *pY = VBISurfaceOriginY; }
};  


typedef struct
{
	CWDMVideoDecoder		CWDMDecoder;
	Device					CDevice;
	Decoder					CDecoder;
	Scaler					CScaler;
	CrossBar				CXbar;
    CI2CScript              CScript;
	DEVICE_PARMS			deviceParms;
} DEVICE_DATA_EXTENSION, * PDEVICE_DATA_EXTENSION;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\bt-829\atibt\decoder.h ===
#pragma once

//==========================================================================;
//
//	Decoder - Main decoder declarations
//
//		$Date:   21 Aug 1998 21:46:28  $
//	$Revision:   1.1  $
//	  $Author:   Tashjian  $
//
// $Copyright:	(c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

#include "viddefs.h"
#include "retcode.h"

#include "capmain.h"
#include "register.h"

/////////////////////////////////////////////////////////////////////////////
// CLASS CRegInfo
//
// Description:
//    Provides min, max, and default values for a register. To use this class,
//    user will declare an object of this class and provide min, max and default
//    values of the register.
//
// Attributes:
//    int intMin - minumum value
//    int intMax - maximum value
//    int intDefault - default value
//
// Methods:
//    Min() : return minimum value of the register
//    Max() : return maximum value of the register
//    Default(): return default value of the register
//    OutOfRange() : check if an value is out of range
//
/////////////////////////////////////////////////////////////////////////////
class CRegInfo
{
   int intMin;       // minumum value
   int intMax;       // maximum value
   int intDefault;   // default value

public:
   CRegInfo()
   {
      intMin = 0;
      intMax = 0;
      intDefault = 0;
   }

   CRegInfo(int min, int max, int def)
   {
      intMin = min;
      intMax = max;
      intDefault = def;
   }

   // return min, max and default value of a register
   inline int Min() const { return intMin; }
   inline int Max() const { return intMax; }
   inline int Default() const { return intDefault; }

   // check if an value is out of range of a register
   inline BOOL OutOfRange(int x)
   {
      if((x > intMax) || (x < intMin))
         return TRUE;
      return FALSE;
   }
};


/////////////////////////////////////////////////////////////////////////////
// CLASS Decoder
//
// Description:
//    This class encapsulates the register fields in the decoder portion of
//    the Bt848.
//    A complete set of functions are developed to manipulate all the
//    register fields in the decoder for the Bt848.
//    For Read-Write register field, "Set..." function is provided to modify
//    the content of the reigster field. And either "Get..." (for more
//    than 1 bit) or "Is..." (for 1 bit) function is provided to obtain the
//    value of the register field.
//    For Read-Only register field, only "Get..." (for more than 1 bit) or
//    "Is..." (for 1 bit) function is provided to obtain the content of the
//    register field.
//    When there are odd-field complements to the even-field register field,
//    same value is set to both odd and even register fields.
//    Several direct register content modifying/retrieval functions are
//    implemented for direct access to the register contents. They were
//    originally developed for testing purpose only. They are retained in the
//    class for convenience only and usage of these functions must be very cautious.
//
// Methods:
//    See below
//
// Note: 1) Scaling registers are not implemented.
//       2) Odd-fields are set to the same value as the even-field registers
/////////////////////////////////////////////////////////////////////////////

class Decoder
{
protected:
	RegisterB decRegSTATUS;
	RegField  decFieldHLOC;
	RegField  decFieldNUML;
	RegField  decFieldCSEL;
	RegField  decFieldSTATUS_RES;
	RegField  decFieldLOF;
	RegField  decFieldCOF;
	RegisterB decRegIFORM;
	RegField  decFieldHACTIVE;
	RegField  decFieldMUXSEL;
	RegField  decFieldXTSEL;
	RegField  decFieldFORMAT;
	RegisterB decRegTDEC;
	RegField  decFieldDEC_FIELD;
	RegField  decFieldDEC_FIELDALIGN;
	RegField  decFieldDEC_RAT;
	RegisterB decRegBRIGHT;
	RegisterB decRegMISCCONTROL;
	RegField  decFieldLNOTCH;
	RegField  decFieldCOMP;
	RegField  decFieldLDEC;
	RegField  decFieldMISCCONTROL_RES;
	RegField  decFieldCON_MSB;
	RegField  decFieldSAT_U_MSB;
	RegField  decFieldSAT_V_MSB;
	RegisterB decRegCONTRAST_LO;
	RegisterB decRegSAT_U_LO;
	RegisterB decRegSAT_V_LO;
	RegisterB decRegHUE;
	RegisterB decRegSCLOOP;
	RegField  decFieldCAGC;
	RegField  decFieldCKILL;
	RegisterB decRegWC_UP;
	RegisterB decRegOFORM;
	RegField  decFieldVBI_FRAME;
	RegField  decFieldCODE;
	RegField  decFieldLEN;
	RegisterB decRegVSCALE_HI;
	RegField  decFieldYCOMB;
	RegField  decFieldCOMB;
	RegField  decFieldINT;
	RegisterB decRegTEST;
	RegisterB decRegVPOLE;
	RegField  decFieldOUT_EN;
	RegField  decFieldDVALID;
	RegField  decFieldVACTIVE;
	RegField  decFieldCBFLAG;
	RegField  decFieldFIELD;
	RegField  decFieldACTIVE;
	RegField  decFieldHRESET;
	RegField  decFieldVRESET;
	RegisterB decRegADELAY;
	RegisterB decRegBDELAY;
	RegisterB decRegADC;
	RegField  decFieldCLK_SLEEP;
	RegField  decFieldC_SLEEP;
	RegField  decFieldCRUSH;
	RegisterB decRegVTC;
	RegField  decFieldHSFMT;
	RegisterB decRegWC_DN;
	RegisterB decRegSRESET;
	RegisterB decRegODD_MISCCONTROL;
	RegField  decFieldODD_LNOTCH;
	RegField  decFieldODD_COMP;
	RegField  decFieldODD_LDEC;
	RegField  decFieldODD_CBSENSE;
	RegField  decFieldODD_MISCCONTROL_RES;
	RegField  decFieldODD_CON_MSB;
	RegField  decFieldODD_SAT_U_MSB;
	RegField  decFieldODD_SAT_V_MSB;
	RegisterB decRegODD_SCLOOP;
	RegField  decFieldODD_CAGC;
	RegField  decFieldODD_CKILL;
	RegField  decFieldODD_HFILT;
	RegisterB decRegODD_VSCALE_HI;
	RegField  decFieldODD_YCOMB;
	RegField  decFieldODD_COMB;
	RegField  decFieldODD_INT;
	RegisterB decRegODD_VTC;
	RegField  decFieldODD_HSFMT;

   // used for checking if parameter out of register's range
    CRegInfo m_regHue, m_regSaturationNTSC, m_regSaturationSECAM,
            m_regContrast,  m_regBrightness;

   // used for checking parameter range
   CRegInfo m_param;

   // value set to after calculations
   WORD m_satParam, m_conParam, m_hueParam, m_briParam;

   // to be used to adjust contrast
   int  regBright;      // brightness register value before adjustment
   WORD regContrast;    // contrast register value before adjustment

   // for 829 vs 829a setup
   unsigned m_outputEnablePolarity;

   DWORD m_videoStandard;   //Paul
   DWORD m_supportedVideoStandards;  //Paul:  The standards supported by the decoder AND'd with standards supported by Crystal
public:
   // constructor and destructor
    Decoder(PDEVICE_PARMS);
    virtual ~Decoder();

	void * operator new(size_t size, void * pAllocation) { return(pAllocation);}
	void operator delete(void * pAllocation) {}


	void GetVideoDecoderCaps(PKSPROPERTY_VIDEODECODER_CAPS_S caps);
	void GetVideoDecoderStatus(PKSPROPERTY_VIDEODECODER_STATUS_S status);
	DWORD GetVideoDecoderStandard();
    ULONG GetVideoDeocderStandardsSupportedInThisConfiguration()
        { return m_supportedVideoStandards; }

	BOOL SetVideoDecoderStandard(DWORD standard);


   // Device Status register (DSTATUS)
   virtual BOOL      Is525LinesVideo();
   virtual BOOL      IsCrystal0Selected();
   virtual BOOL      IsLumaOverflow();
   virtual void      ResetLumaOverflow();
   virtual BOOL      IsChromaOverflow();
   virtual void      ResetChromaOverflow();

   // Input Format register (IFORM)
   virtual ErrorCode SetVideoInput(ULONG);
   virtual int       GetVideoInput();
   virtual ErrorCode SetCrystal(Crystal);
   virtual int       GetCrystal();
   virtual ErrorCode SetVideoFormat(VideoFormat);
   virtual int       GetVideoFormat();

   // Temporal Decimation register (TDEC)
   virtual ErrorCode SetRate(BOOL, VidField, int);

   // Brightness Control register (BRIGHT)
   virtual ErrorCode SetBrightness(int);
   virtual int       GetBrightness();

   // Miscellaneous Control register (E_CONTROL, O_CONTROL)
   virtual void      SetLumaNotchFilter(BOOL);
   virtual BOOL      IsLumaNotchFilter();
   virtual void      SetCompositeVideo(BOOL);
   virtual void      SetLumaDecimation(BOOL);

   // Luma Gain register (CON_MSB, CONTRAST_LO)
   virtual ErrorCode SetContrast(int);
   virtual int       GetContrast();

   // Chroma Gain register (SAT_U_MSB, SAT_V_MSB, SAT_U_LO, SAT_V_LO)
   virtual ErrorCode SetSaturation(int);
   virtual int       GetSaturation();

   // Hue Control register (HUE)
   virtual ErrorCode SetHue(int);
   virtual int       GetHue();

   // SC Loop Control register (E_SCLOOP, O_SCLOOP)
   virtual void      SetChromaAGC(BOOL);
   virtual BOOL      IsChromaAGC();
   virtual void      SetLowColorAutoRemoval(BOOL);

   // Output Format register (OFORM)
   virtual void      SetVBIFrameMode(BOOL);
   virtual BOOL      IsVBIFrameMode();
   virtual void      SetCodeInsertionEnabled(BOOL);
   virtual BOOL      IsCodeInsertionEnabled();
   virtual void      Set16BitDataStream(BOOL);
   virtual BOOL      Is16BitDataStream();

   // Vertical Scaling register (E_VSCALE_HI, O_VSCALE_HI)
   virtual void      SetChromaComb(BOOL);
   virtual BOOL      IsChromaComb();
   virtual void      SetInterlaced(BOOL);
   virtual BOOL      IsInterlaced();
   
   // VPOLE register
   void SetOutputEnablePolarity(int i)
        {m_outputEnablePolarity = i;}
    
   int GetOutputEnablePolarity()
        {return m_outputEnablePolarity;}
    
   virtual void      SetOutputEnabled(BOOL);
   virtual BOOL      IsOutputEnabled();
   virtual void      SetHighOdd(BOOL);
   virtual BOOL      IsHighOdd();

   // ADC Interface register (ADC)
   virtual void      PowerDown(BOOL);
   virtual BOOL      IsPowerDown();
   virtual void      SetChromaADC(BOOL);
   virtual void      SetAdaptiveAGC(BOOL);
   virtual BOOL      IsAdaptiveAGC();

   // Software Reset register (SRESET)
   virtual void      SoftwareReset();

   // Test Control register (TEST)
   virtual void      AdjustInertialDampener(BOOL);

protected:
   // mapping function
   virtual ErrorCode Mapping(int, CRegInfo, int *, CRegInfo);

   // check registry key value to determine if contrast should be adjusted
   virtual BOOL IsAdjustContrast();

private:
   void              SelectCrystal(char);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\bt-829\atibt\regbase.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#include "regbase.h"

// static; holds the base address of the PCI registers
DWORD RegBase::dwBaseAddress_ = 0;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\bt-829\atibt\mytypes.h ===
#pragma once

//==========================================================================;
//
//	Various declarations
//
//		$Date:   05 Aug 1998 11:31:58  $
//	$Revision:   1.0  $
//	  $Author:   Tashjian  $
//
// $Copyright:	(c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

#ifdef __cplusplus
extern "C" {

#ifndef _STREAM_H
#include "strmini.h"
#endif
#ifndef _KSMEDIA_
#include "ksmedia.h"
#endif
}
#endif


#ifndef __RETCODE_H
#include "retcode.h"
#endif

#include "capdebug.h"

inline void * _cdecl operator new(size_t size)
{
    PVOID p = ExAllocatePool(NonPagedPool, size);
    DBGINFO(("Bt829: Global operator new: %d bytes; address: %x\n", size, p));
#ifdef DBG
    if (!p) {
        TRAP();
    }
#endif      
    return p;
}

inline void _cdecl operator delete(void *p)
{
    DBGINFO(("Bt829: Global operator delete: address: %x\n", p));
    if (p)
    {
        ExFreePool(p);
    }
}


class MSize;
class MRect;

#if NEED_CLIPPING
typedef struct _RGNDATAHEADER
{
    DWORD   dwSize;
    DWORD   iType;
    DWORD   nCount;
    DWORD   nRgnSize;
    MRect    rcBound;
} RGNDATAHEADER, *PRGNDATAHEADER;

typedef struct _RGNDATA
{
    RGNDATAHEADER   rdh;
    char            Buffer[1];
} RGNDATA, *PRGNDATA;

#endif

class  MPoint : public tagPOINT
{
public:
    // Constructors
};

//
// class MSize
// ----- -----
//
class  MSize : public tagSIZE
{
public:
    // Constructors
    MSize()
    {}
    MSize(int dx, int dy)
    {cx = dx; cy = dy;}
};


class  MRect : public tagRECT
{
public:
    // Constructors
    MRect()
    {}
    MRect(int _left, int _top, int _right, int _bottom);
    MRect(const MPoint& origin, const MSize& extent);

    void        Set(int _left, int _top, int _right, int _bottom);

    // Information/access functions(const and non-const)
    const MPoint& TopLeft() const
    {return *(MPoint*)&left;}
    int          Width() const
    {return right-left;}
    int          Height() const
    {return bottom-top;}
    MSize        Size() const
    {return MSize(Width(), Height());}

};

//----------------------------------------------------------------------------
// Inlines
//----------------------------------------------------------------------------
inline void MRect::Set(int _left, int _top, int _right, int _bottom)
{
    left = _left;
    top = _top;
    right = _right;
    bottom = _bottom;
}

inline MRect::MRect(int _left, int _top, int _right, int _bottom)
{
    Set(_left, _top, _right, _bottom);
}
inline MRect::MRect(const MPoint& origin, const MSize& extent)
{
    Set(origin.x, origin.y, origin.x+extent.cx, origin.y+extent.cy);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\bt-829\atibt\retcode.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#ifndef __RETCODE_H
#define __RETCODE_H

/* Type: ErrorCode
 * Purpose: Defines the error codes
 */
typedef enum { Success, Fail } ErrorCode;
#define ERROR_CODE_DEFINED



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\bt-829\atibt\register.h ===
#pragma once

//==========================================================================;
//
//	Declarations of the Bt829 Register manipulation classes
//
//		$Date:   21 Aug 1998 21:46:42  $
//	$Revision:   1.1  $
//	  $Author:   Tashjian  $
//
// $Copyright:	(c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

#include "regbase.h"
#include "capmain.h"

/* Type: Register
 * Purpose: An intermediate class between the RegBase and actual usable classes.
 *   Actual classes are RegisterB, RegisterW, RegisterDW
 * Attributes:
 *   uOffset_: unsigned int - an offset of the register from the base
 * Operations:
 *   GetOffset(): returns the offset value. Protected
 *   operator DWORD(): data access method. Always returns -1
 *   DWORD operator=(DWORD): assignment operator. Always returns -1
 * Note:
 *   The reason to have operators in this class is for the register field class
 *   to have a member of type 'reference to Register'. Otherwise RegField is not
 *   able to use access methods.
 */
class Register : public RegBase
{
   private:
      unsigned int uOffset_;
      Register();
    protected:

    public:
         unsigned int GetOffset() { return uOffset_; }

         virtual operator DWORD();
      virtual DWORD operator=(DWORD dwValue);

         Register(unsigned int uOff, RegisterType aType) :
            RegBase(aType), uOffset_(uOff) {}
};

/* Type: RegisterB
 * Purpose: A register that performs the BYTE I/O
 * Note:
 *   This class has no additional data members, it just overloads operators
 */
class RegisterB : public Register
{
    private:
         RegisterB();
         DWORD ReadReg(BYTE);
         DWORD WriteReg(BYTE, BYTE);
         PDEVICE_PARMS m_pDeviceParms;
    public:
         virtual operator DWORD();
         virtual DWORD operator=(DWORD dwValue);
         RegisterB(unsigned int uOff, RegisterType aType, PDEVICE_PARMS pDeviceParms) :
            Register(uOff, aType) {m_pDeviceParms = pDeviceParms;};
};


// maximum size of a register in bits
const BYTE MaxWidth = 32;

/* Class: RegField
 * Purpose: This class encapsulates the behaviour of a register which is a set
 *   of bits withing a larger register
 * Attributes:
 *   Owner_: Register & - reference to the register that contains this field.
 *   It is a reference to Register class because actual register can be either one of
 *   byte, word or dword registers.
 *   StartBit_: BYTE - starting position of this field
 *   FieldWidth_: BYTE - width of this field in bits
 * Operations:
 *   operator DWORD(): data access method. Returns a value of the register
 *   DWORD operator=(DWORD): assignment operator. Used to set the register
 *   These operations assume that a parent register has RW attribute set, though
 *   not all register fields of it are read-write. If RW is not used for the parent
 *   this class may be in error.
 * Note: the error handling provided by the class is minimal. It is a responibility
 *   of the user to pass correct parameters to the constructor. The class has
 *   no way of knowing if the correct owning registe passed in is correct,
 *   for example. If starting bit or width is beyond the maximum field width
 *   the mask used to isolate the field will be 0xFFFFFFFF
 */
class RegField : public RegBase
{
   private:
      Register &Owner_;
      BYTE      StartBit_;
      BYTE      FieldWidth_;
      DWORD     MakeAMask();
      RegField();
   public:
      virtual operator DWORD();
      virtual DWORD operator=(DWORD dwValue);
      RegField(Register &AnOwner, BYTE nStart, BYTE nWidth, RegisterType aType) :
         RegBase(aType), Owner_(AnOwner), StartBit_(nStart),
         FieldWidth_(nWidth) {}
      RegField(Register &AnOwner, BYTE nStart, BYTE nWidth) :
         RegBase(AnOwner), Owner_(AnOwner), StartBit_(nStart),
         FieldWidth_(nWidth) {}
};

/* Function: MakeAMask
 * Purpose: Creates a bit mask to be used in different register classes
 * Input:
 *   bWidth: BYTE - width of a mask in bits
 * Output:
 *   DWORD
 * Note: This function is inline
 */
inline DWORD MakeAMask(BYTE bWidth)
{
   return (bWidth >= 32 ? 0 : (DWORD)1 << bWidth) - 1;
}


/* Class: CompositeReg
 * Purpose: This class encapsulates the registers that have their bits in two
 *          different places (registers)
 * Attributes:
 *   LSBPart_:  Register & - least significant bits part of a composite register
 *   HighPart_: RegField & - most significant bits part of a composite register
 *   LowPartWidth_: BYTE - width of the low portion in bits
 * Operations:
 *   operator DWORD(): data access method. Returns a value of the register
 *   DWORD operator=(DWORD): assignment operator. Used to set the register
 * Note: the error handling provided by the class is minimal. It is a responibility
 *   of the user to pass correct parameters to the constructor. The class has
 *   no way of knowing if the correct low and high registers passed in are correct,
 *   for example. If low part size in bits passed in is not less then MaxWidth (32)
 *   the mask used to isolate the low portion will be 0xFFFFFFFF
 */
class CompositeReg : public RegBase
{
   private:
      Register &LSBPart_;
      RegField &MSBPart_;
      BYTE      LowPartWidth_;
      CompositeReg();
   public:
      virtual operator DWORD();
      virtual DWORD operator=(DWORD dwValue);
      CompositeReg(Register &LowReg, BYTE LowWidth, RegField &HighReg, RegisterType aType) :
         RegBase(aType), LSBPart_(LowReg), MSBPart_(HighReg),
         LowPartWidth_(LowWidth) {}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\bt-829\atibt\regbase.h ===
#pragma once

//==========================================================================;
//
//	Declaration of the Bt829 Register manipulation classes
//
//		$Date:   05 Aug 1998 11:31:48  $
//	$Revision:   1.0  $
//	  $Author:   Tashjian  $
//
// $Copyright:	(c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

#include "mytypes.h"

/* Type: AllFs
 * Purpose: To be used as an error return value from register accessing
 *   functions. All bits are set to 1.
 */
const DWORD AllFs = ~0L;

/* Function: ReturnAllFs
 * Purpose: This function is used in the register access methods to indicate
 *   that some sort of error has occured. Used for easing the debugging, as
 *   it contains a macro to print the error if DEBUG is #defined
 */
inline DWORD ReturnAllFs()
{
//    OUTPUT_MESS(ALLFS);
    return  AllFs;
}

/*
 * Type: RegisterType
 * Purpose: A type to differentiate between diferent kinds of registers.
 *   Depending on the type register may not peforms certain operations
 *   RW - read/write, RO - read-only, WO - write-only
*/
typedef enum { RW, RO, WO, RR } RegisterType;

/* Class: RegBase
 * Purpose:
 *   Defines the interface and encapsulates the register access.
 * Attributes:
 *   pBaseAddress_: DWORD, static. Holds the base address of the registers. On the
 *   PCI bus it is a 32 bit memory address. On the ISA bus it is a 16 bit I/O address.
 *   type_: RegisterType - defines the access permission for the register.
 *   dwShadow_: DWORD - a local copy of the register. Used for returning a value
 *   of write-only registers
 * Operations:
 *   operator DWORD(): data access method. Pure virtual
 *   DWORD operator=(DWORD): assignment operator. Pure virtual. This assignment
 *      operator does not return a reference to the class because of the performance reasons
 *   void SetBaseAddress(DWORD)
 *   DWORD GetBaseAddress()
 *   RegisterType GetRegisterType()
 *   void SetShadow(DWORD): assigns a value of a register to a shadow
 *   DWORD GetShadow(): retrieves a value from a shadow
 */
class RegBase
{
    private:
         static DWORD dwBaseAddress_;
         RegisterType type_;
         DWORD        dwShadow_;

         RegBase();

    protected:
         void  SetShadow(DWORD dwValue);
         DWORD GetShadow();
    public:
         RegBase(RegisterType aType) :
            type_(aType), dwShadow_(0)
         {}

         RegBase(RegBase& aReg) :
            type_(aReg.GetRegisterType()), dwShadow_(0)
         {}

         static void SetBaseAddress(DWORD dwBase) { dwBaseAddress_ = dwBase; }
         static LPBYTE GetBaseAddress() { return (LPBYTE)(ULONG_PTR)dwBaseAddress_; }
         RegisterType GetRegisterType() { return type_; }
         virtual operator DWORD() = 0;
         virtual DWORD operator=(DWORD dwValue) = 0;
         virtual ~RegBase() {}
};

/* Method: RegBase::SetShadow
 * Purpose: Used to store the value of a register in the shadow
 * Input: dwValue: DWORD - new value of a register
 * Output: None
 * Note: inline
 */
inline void  RegBase::SetShadow(DWORD dwValue) { dwShadow_ = dwValue; }

/* Method: RegBase::GetShadow
 * Purpose: Used to obtain the last value written to a write-only register
 *    from the shadow
 * Input: None
 * Output: DWORD
 * Note: inline
 */
inline DWORD RegBase::GetShadow() { return dwShadow_; }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\bt-829\atibt\register.cpp ===
//==========================================================================;
//
//	Implementation of the Bt829 Register manipulation classes
//
//		$Date:   21 Aug 1998 21:46:42  $
//	$Revision:   1.1  $
//	  $Author:   Tashjian  $
//
// $Copyright:	(c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

#include "register.h"
#include "i2script.h"
#include "capdebug.h"


/* Method: Register::operator DWORD()
 * Purpose: a dummy function. Always returns -1
*/
Register::operator DWORD()
{
   return ReturnAllFs();
}


/* Method: Register::operator=
 * Purpose: a dummy function. Does not perform an assignment. Always returns -1
*/
DWORD Register::operator=(DWORD)
{
   return ReturnAllFs();
}

/* Method: RegisterB::operator DWORD()
 * Purpose: Performs the read from a byte register
*/
RegisterB::operator DWORD()
{
   // if write-only return the shadow
   if (GetRegisterType() == WO)
      return GetShadow();

   // for RO and RW do the actual read
   LPBYTE pRegAddr = GetBaseAddress() + GetOffset();
   // Not really an address; just a number indicating which reg
   return ReadReg((BYTE)pRegAddr);
}


/* Method: RegisterB::operator=
 * Purpose: performs the assignment to a byte register
*/
DWORD RegisterB::operator=(DWORD dwValue)
{
// if a register is read-only nothing is done. This is an error
   if (GetRegisterType() == RO)
      return ReturnAllFs();

   // keep a shadow around
   SetShadow(dwValue);

   LPBYTE pRegAddr = GetBaseAddress() + GetOffset();

   // Not really an address; just a number indicating which reg
   WriteReg((BYTE) pRegAddr, (BYTE)dwValue);

   return dwValue;
}

DWORD RegisterB::ReadReg(BYTE reg)
{
    I2CPacket   i2cPacket;
    BYTE outBuf = reg;
    BYTE inBuf = I2C_STATUS_NOERROR;

    CI2CScript *pI2cScript = m_pDeviceParms->pI2cScript;

    i2cPacket.uchChipAddress = (UCHAR)(m_pDeviceParms->chipAddr);
    i2cPacket.cbReadCount = sizeof(inBuf);
    i2cPacket.cbWriteCount = sizeof(outBuf);
    i2cPacket.puchReadBuffer = &inBuf;
    i2cPacket.puchWriteBuffer = &outBuf;
    i2cPacket.usFlags = I2COPERATION_READ;
    i2cPacket.uchORValue = 0;
    i2cPacket.uchANDValue = 0;

    if (!pI2cScript->LockI2CProviderEx())
    {
        DBGERROR(("Couldn't get I2CProvider.\n"));
        TRAP();
        return ReturnAllFs();
    }
    
    // Now  I know I have I2c services.

    pI2cScript->ExecuteI2CPacket(&i2cPacket);

    pI2cScript->ReleaseI2CProvider();
    if (i2cPacket.uchI2CResult == I2C_STATUS_NOERROR)
    {
        return (DWORD) inBuf;
    }
    else
    {
        TRAP();

        return ReturnAllFs();
    }
}

DWORD RegisterB::WriteReg(BYTE reg, BYTE value)
{
    I2CPacket   i2cPacket;
    BYTE outBuf[2];

    CI2CScript *pI2cScript = m_pDeviceParms->pI2cScript;

    outBuf[0] = reg;
    outBuf[1] = value;
    i2cPacket.uchChipAddress = (UCHAR)(m_pDeviceParms->chipAddr);
    i2cPacket.cbReadCount = 0;
    i2cPacket.cbWriteCount = sizeof(outBuf);
    i2cPacket.puchReadBuffer = NULL;
    i2cPacket.puchWriteBuffer = &outBuf[0];
    i2cPacket.usFlags = I2COPERATION_WRITE;
    i2cPacket.uchORValue = 0;
    i2cPacket.uchANDValue = 0;

    if (!pI2cScript->LockI2CProviderEx())
    {
        DBGERROR(("Bt829: Couldn't get I2CProvider.\n"));
        TRAP();
        return ReturnAllFs();
    }
    // Now  I know I have I2c services.

    pI2cScript->ExecuteI2CPacket(&i2cPacket);

    pI2cScript->ReleaseI2CProvider();

    if (i2cPacket.uchI2CResult == I2C_STATUS_NOERROR)
    {
        return value;
    }
    else
    {
        TRAP();

        return ReturnAllFs();
    }
}


/* Method: RegField::MakeAMask
 * Purpose: Computes a mask used to isolate a field withing a register based
 *   on the width of a field
 */
inline DWORD RegField::MakeAMask()
{
//   compute the mask to apply to the owner register to reset
//   all bits that are part of a field. Mask is based on the size of a field
   return ::MakeAMask(FieldWidth_);
}

/* Method: RegField::operator DWORD()
 * Purpose: Performs the read from a field of register
*/
RegField::operator DWORD()
{
   // if write-only, get the shadow
   if (GetRegisterType() == WO)
      return GetShadow();

   // for RO and RW do the actual read
   // get the register data and move it to the right position
   DWORD dwValue = (Owner_ >> StartBit_);

   DWORD dwMask = MakeAMask();

   return dwValue & dwMask;
}


/* Method: RegField::operator=
 * Purpose: performs the assignment to a field of register
 * Note:
   This function computes the mask to apply to the owner register to reset
   all bits that are part of a field. Mask is based on the start position and size
   Then it calculates the proper value from the passed argument (moves the size
   number of bits to the starting position) and ORs these bits in the owner register.
*/
DWORD RegField::operator=(DWORD dwValue)
{
// if a register is read-only nothing is done. This is an error
   if (GetRegisterType() == RO)
      return ReturnAllFs();

   SetShadow(dwValue);

   // get a mask
   DWORD dwMask = MakeAMask();

   // move mask to a proper position
   dwMask = dwMask << StartBit_;

//   calculate the proper value from the passed argument (move the size
//   number of bits to the starting position)
   DWORD dwFieldValue = dwValue << StartBit_;
   dwFieldValue &= dwMask;

   // do not perform intermediate steps on the owner; rather use a temp and update
   // the owner at once
   DWORD dwRegContent = Owner_;

   // reset the relevant bits
   if (GetRegisterType() == RR)
      dwRegContent = 0;
   else
      dwRegContent &= ~dwMask;

   // OR these bits in the owner register.
   dwRegContent |= dwFieldValue;

   Owner_ = dwRegContent;
   return dwValue;
}


/* Method: CompositeReg::operator DWORD()
 * Purpose: Performs the read from a composite register
*/
CompositeReg::operator DWORD()
{
   // if write-only return the shadow
   if (GetRegisterType() == WO)
      return GetShadow();

// obtain the low and high values
   DWORD dwLowBits  = (DWORD)LSBPart_;
   DWORD dwHighBits = (DWORD)MSBPart_;

   // put high part to the proper place
   dwHighBits <<= LowPartWidth_;

   // done !
   return dwHighBits | dwLowBits;
}


/* Method: CompositeReg::operator=
 * Purpose: performs the assignment to a composite register
*/
DWORD CompositeReg::operator=(DWORD dwValue)
{
// if a register is read-only nothing is done. This is an error
   if (GetRegisterType() == RO)
      return ReturnAllFs();

   // keep a shadow around
   SetShadow(dwValue);
 // compute the mask to apply to the passed value, so it can be...
   DWORD dwMask = ::MakeAMask(LowPartWidth_);

 // ... assigned to the low portion register
   LSBPart_ = dwValue & dwMask;

   // shift is enough to get the high part
   MSBPart_ = (dwValue >> LowPartWidth_);
   return dwValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\bt-829\atibt\scaler.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#ifndef __SCALER_H
#define __SCALER_H

#include "mytypes.h"

#define HDROP       HANDLE

#include "viddefs.h"

#include "capmain.h"
#include "register.h"

// structure contains video information
struct VideoInfoStruct
{
   WORD Clkx1_HACTIVE;
   WORD Clkx1_HDELAY;
   WORD Min_Pixels;
   WORD Active_lines_per_field;
   WORD Min_UncroppedPixels;
   WORD Max_Pixels;
   WORD Min_Lines;
   WORD Max_Lines;
   WORD Max_VFilter1_Pixels;
   WORD Max_VFilter2_Pixels;
   WORD Max_VFilter3_Pixels;
   WORD Max_VFilter1_Lines;
   WORD Max_VFilter2_Lines;
   WORD Max_VFilter3_Lines;
};


/////////////////////////////////////////////////////////////////////////////
// CLASS Scaler
//
// Description:
//    This class encapsulates the register fields in the scaler portion of
//    the Bt848.
//    A complete set of functions are developed to manipulate all the
//    register fields in the scaler registers for the Bt848.
//
// Methods:
//    See below
//
// Note:
//    For Bt848, instantiate as ...
//       Scaler evenScaler(VF_Even);
//       Scaler oddScaler(VF_Odd);
//
/////////////////////////////////////////////////////////////////////////////

class Scaler
{
    public:
        Scaler(PDEVICE_PARMS);
        ~Scaler();

	void * operator new(size_t size, void * pAllocation) { return(pAllocation);}
	void operator delete(void * pAllocation) {}

		void VideoFormatChanged(VideoFormat);
        void TurnVFilter(State st) { VFilterFlag_ = st; }
                     
        void      Scale(MRect &);
        ErrorCode SetAnalogWin(const MRect &);
        void      GetAnalogWin(MRect &) const;
        ErrorCode SetDigitalWin(const MRect &);
        void      GetDigitalWin(MRect &) const;

        // member functions for VBI support
        virtual void SetVBIEN(BOOL);
        virtual BOOL IsVBIEN();
        virtual void SetVBIFMT(BOOL);
        virtual BOOL IsVBIFMT();

        void      DumpSomeState();

   protected:

		//===========================================================================
		// Scaler registers
		//===========================================================================
		RegisterB regCROP;
		RegField  fieldVDELAY_MSB;
		RegField  fieldVACTIVE_MSB;
		RegField  fieldHDELAY_MSB;
		RegField  fieldHACTIVE_MSB;
		RegisterB regVDELAY_LO;
		RegisterB regVACTIVE_LO;
		RegisterB regHDELAY_LO;
		RegisterB regHACTIVE_LO;
		RegisterB regHSCALE_HI;
		RegField  fieldHSCALE_MSB;
		RegisterB regHSCALE_LO;
		RegisterB regSCLOOP;
		RegField  fieldHFILT;
		RegisterB regVSCALE_HI;
		RegField  fieldVSCALE_MSB;
		RegisterB regVSCALE_LO;
		RegisterB regVTC;
		RegField  fieldVBIEN;
		RegField  fieldVBIFMT;
		RegField  fieldVFILT;
		CompositeReg regVDelay;
		CompositeReg regVActive;
		CompositeReg regVScale;
		CompositeReg regHDelay;
		CompositeReg regHActive;
		CompositeReg regHScale;

		// Since VDelay register in hardware is reversed;
		// i.e. odd reg is really even field and vice versa, need an extra cropping reg
		// for the opposite field
		RegisterB regReverse_CROP;


        VideoInfoStruct * m_ptrVideoIn;
        MRect AnalogWin_;
        MRect DigitalWin_;

        // member functions to set scaling registers
        virtual void SetHActive(MRect &);
        virtual void SetHDelay();
        virtual void SetHScale();
        virtual void SetHFilter();
        virtual void SetVActive();
        virtual void SetVDelay();
        virtual void SetVScale(MRect &);
        virtual void SetVFilter();

    private:
        VideoFormat  m_videoFormat;   // video format

        // this is to battle junk lines at the top of the video
        State VFilterFlag_;

        WORD  m_HActive;  // calcuated intermediate value
        WORD  m_pixels;   // calcuated intermediate value
        WORD  m_lines;    // calcuated intermediate value
        WORD  m_VFilter;  // calcuated intermediate value

};


#endif __SCALER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\bt-829\atibt\defaults.h ===
//==========================================================================;
//
//	Default values
//
//		$Date:   18 Mar 1999 14:30:18  $
//	$Revision:   1.1  $
//	  $Author:   KLEBANOV  $
//
// $Copyright:	(c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

const int NumBuffers = 8;

// Hardcoded for NTSC for now
const int SamplingFrequency = 28636363;
const int NTSCFrameDuration = 333667;
const int NTSCFieldDuration = NTSCFrameDuration/2;

const int NTSCFrameRate = 30;

const int PALFrameDuration = 400000;
const int PALFieldDuration = PALFrameDuration/2;

const int PALFrameRate = 25;

const int DefWidth = 320;
const int DefHeight = 240;

const int QCIFWidth = 176;
const int QCIFHeight = 144;


const int NTSCMaxInWidth = 720;
const int NTSCMinInWidth = 80;

const int NTSCMaxInHeight = 480;
const int NTSCMinInHeight = 60;

const int NTSCMaxOutWidth = 720;	// 320
const int NTSCMinOutWidth = 80;

const int NTSCMaxOutHeight = 240;	// 240
const int NTSCMinOutHeight = 60;

const int PALMaxInWidth = 720;
const int PALMinInWidth = 80;//90;

const int PALMaxInHeight = 480;//576;
const int PALMinInHeight = 60;//72;

const int PALMaxOutWidth = 720;	// 320
const int PALMinOutWidth = 80;//90;

const int PALMaxOutHeight = 240;//288;	// 240
const int PALMinOutHeight = 30;//72;

const int VBISamples  = 800 * 2;

// hack
const int VREFDiscard = 8;

const int NTSCVBIStart    =  10; // inclusive
const int NTSCVBIEnd      =  21; // inclusive
const int NTSCVBILines    = (NTSCVBIEnd - NTSCVBIStart) + 1;

const int PALVBIStart    =  10; // Paultest
const int PALVBIEnd      =  25; // Paultest
const int PALVBILines    = (PALVBIEnd - PALVBIStart) + 1;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\bt-829\atibt\strminfo.cpp ===
//==========================================================================;
//
//	WDM Video Decoder stream informaition declarations
//
//		$Date:   17 Aug 1998 15:00:38  $
//	$Revision:   1.0  $
//	  $Author:   Tashjian  $
//
// $Copyright:	(c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

extern "C" {
#include "strmini.h"
#include "ksmedia.h"
}

#include "defaults.h"
#include "mediums.h"
#include "StrmInfo.h"
#include "StrmProp.h"
#include "capdebug.h"


// devine MEDIASUBTYPE_UYVY here... can be removed if someday defined in ksmedia.h
#define STATIC_KSDATAFORMAT_SUBTYPE_UYVY\
    0x59565955, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71  // MEDIASUBTYPE_UYVY
DEFINE_GUIDSTRUCT("59565955-0000-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_UYVY);
#define KSDATAFORMAT_SUBTYPE_UYVY DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_UYVY)


//
// For event handling on the VP stream
//
NTSTATUS STREAMAPI VPStreamEventProc (PHW_EVENT_DESCRIPTOR);

//
// For event handling on the VP VBI stream
//
NTSTATUS STREAMAPI VPVBIStreamEventProc (PHW_EVENT_DESCRIPTOR);


// ------------------------------------------------------------------------
// The master list of all streams supported by this driver
// ------------------------------------------------------------------------

KSEVENT_ITEM VPEventItm[] =
{
    {
        KSEVENT_VPNOTIFY_FORMATCHANGE,
        0,
        0,
        NULL,
        NULL,
        NULL
    }
};

GUID MY_KSEVENTSETID_VPNOTIFY = {STATIC_KSEVENTSETID_VPNotify};

KSEVENT_SET VPEventSet[] =
{
    {
        &MY_KSEVENTSETID_VPNOTIFY,
        SIZEOF_ARRAY(VPEventItm),
        VPEventItm,
    }
};


KSEVENT_ITEM VPVBIEventItm[] =
{
    {
        KSEVENT_VPVBINOTIFY_FORMATCHANGE,
        0,
        0,
        NULL,
        NULL,
        NULL
    }
};

GUID MY_KSEVENTSETID_VPVBINOTIFY = {STATIC_KSEVENTSETID_VPVBINotify};

KSEVENT_SET VPVBIEventSet[] =
{
    {
        &MY_KSEVENTSETID_VPVBINOTIFY,
        SIZEOF_ARRAY(VPVBIEventItm),
        VPVBIEventItm,
    }
};


//---------------------------------------------------------------------------
// All of the video and vbi data formats we might use
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//  Capture Stream Formats
//---------------------------------------------------------------------------
KS_DATARANGE_VIDEO StreamFormatUYVY_Capture_NTSC =
{
    // KSDATARANGE
    {
        sizeof(KS_DATARANGE_VIDEO),     // FormatSize
        0,                                // Flags
        0,//DefWidth * DefHeight * 2,         // SampleSize
        0,                                // Reserved
        STATIC_KSDATAFORMAT_TYPE_VIDEO,                 // aka. MEDIATYPE_Video
        STATIC_KSDATAFORMAT_SUBTYPE_UYVY,				// aka. MEDIASUBTYPE_UYVY
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO         // aka. FORMAT_VideoInfo
    },

    TRUE,                                // BOOL,  bFixedSizeSamples (all samples same size?)
    TRUE,                                // BOOL,  bTemporalCompression (all I frames?)
    0,//KS_VIDEOSTREAM_CAPTURE,              // StreamDescriptionFlags  (KS_VIDEO_DESC_*)
    0,                                   // MemoryAllocationFlags   (KS_VIDEO_ALLOC_*)

    // _KS_VIDEO_STREAM_CONFIG_CAPS
    {
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO,      // GUID
        KS_AnalogVideo_NTSC_Mask & ~KS_AnalogVideo_NTSC_433 | KS_AnalogVideo_PAL_60 | KS_AnalogVideo_PAL_M, // AnalogVideoStandard
        {
            NTSCMaxInWidth, NTSCMaxInHeight      // SIZE InputSize
        },
        {
            NTSCMinInWidth, NTSCMinInHeight      // SIZE MinCroppingSize;       smallest rcSrc cropping rect allowed
        },
        {
            NTSCMaxInWidth, NTSCMaxInHeight      // SIZE MaxCroppingSize;       largest rcSrc cropping rect allowed
        },
        2,                               // int CropGranularityX;       // granularity of cropping size
        2,                               // int CropGranularityY;
        2,                               // int CropAlignX;             // alignment of cropping rect
        2,                               // int CropAlignY;
        {
            NTSCMinOutWidth, NTSCMinOutHeight    // SIZE MinOutputSize;         // smallest bitmap stream can produce
        },
        {
            NTSCMaxOutWidth, NTSCMaxOutHeight    // SIZE MaxOutputSize;         // largest  bitmap stream can produce
        },      
        80,                              // int OutputGranularityX;     // granularity of output bitmap size
        60,                              // int OutputGranularityY;
        0,                               // StretchTapsX  (0 no stretch, 1 pix dup, 2 interp...)
        0,                               // StretchTapsY
        2,                               // ShrinkTapsX 
        2,                               // ShrinkTapsY 
        (LONGLONG)NTSCFieldDuration,               // LONGLONG MinFrameInterval;  // 100 nS units
        (LONGLONG)NTSCFieldDuration*MAXULONG,   // LONGLONG MaxFrameInterval;
        NTSCFrameRate * 80 * 40 * 2 * 8,            // LONG MinBitsPerSecond;
        NTSCFrameRate * 720 * 480 * 2 * 8           // LONG MaxBitsPerSecond;
    },

    // KS_VIDEOINFOHEADER (default format)
    {
        0,0,0,0,                          //    RECT            rcSource;          // The bit we really want to use
        0,0,0,0,                          //    RECT            rcTarget;          // Where the video should go
        DefWidth * DefHeight * 2 * NTSCFrameRate,   //    DWORD           dwBitRate;         // Approximate bit data rate
        0L,                               //    DWORD           dwBitErrorRate;    // Bit error rate for this stream
        
        // 30 fps
        NTSCFieldDuration * 2,            //    REFERENCE_TIME  AvgTimePerFrame;   // Average time per frame (100ns units)
        
        sizeof(KS_BITMAPINFOHEADER),       //    DWORD      biSize;
        DefWidth,                         //    LONG       biWidth;
        DefHeight,                        //    LONG       biHeight;
        1,                                //    WORD       biPlanes;
        16,                               //    WORD       biBitCount;
        FOURCC_UYVY,                      //    DWORD      biCompression;
        DefWidth * DefHeight * 2,         //    DWORD      biSizeImage;
        0,                                //    LONG       biXPelsPerMeter;
        0,                                //    LONG       biYPelsPerMeter;
        0,                                //    DWORD      biClrUsed;
        0                                 //    DWORD      biClrImportant;
    }
};

KS_DATARANGE_VIDEO StreamFormatUYVY_Capture_PAL =
{
    // KSDATARANGE
    {
        sizeof(KS_DATARANGE_VIDEO),     // FormatSize
        0,                                // Flags
        0,//QCIFWidth * QCIFHeight * 2,         // SampleSize
        0,                                // Reserved
        STATIC_KSDATAFORMAT_TYPE_VIDEO,                 // aka. MEDIATYPE_Video
        STATIC_KSDATAFORMAT_SUBTYPE_UYVY,				// aka. MEDIASUBTYPE_UYVY
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO         // aka. FORMAT_VideoInfo
    },

    TRUE,                                // BOOL,  bFixedSizeSamples (all samples same size?)
    TRUE,                                // BOOL,  bTemporalCompression (all I frames?)
    KS_VIDEOSTREAM_CAPTURE,              // StreamDescriptionFlags (KS_VIDEO_DESC_*)
    0,                                   // MemoryAllocationFlags (KS_VIDEO_ALLOC_*)

    // _KS_VIDEO_STREAM_CONFIG_CAPS
    {
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO,      // GUID 
        KS_AnalogVideo_PAL_Mask & ~KS_AnalogVideo_PAL_60 & ~KS_AnalogVideo_PAL_M | KS_AnalogVideo_SECAM_Mask | KS_AnalogVideo_NTSC_433, // AnalogVideoStandard
        {
            720, 576        // SIZE InputSize
        },
        {
            QCIFWidth, QCIFHeight        // SIZE MinCroppingSize; smallest rcSrc cropping rect allowed
        },
        {
            QCIFWidth * 4, QCIFHeight * 4        // SIZE MaxCroppingSize; largest rcSrc cropping rect allowed
        },
        1,                               // int CropGranularityX;       // granularity of cropping size
        1,                               // int CropGranularityY;
        1,                               // int CropAlignX;             // alignment of cropping rect
        1,                               // int CropAlignY;
        {
            QCIFWidth, QCIFHeight        // SIZE MinOutputSize;         // smallest bitmap stream can produce
        },
        {
            QCIFWidth * 2, QCIFHeight * 2        // SIZE MaxOutputSize;         // largest  bitmap stream can produce
        },      
        QCIFWidth,                               // int OutputGranularityX;     // granularity of output bitmap size
        QCIFHeight,                               // int OutputGranularityY;
        0,                               // StretchTapsX  (0 no stretch, 1 pix dup, 2 interp...)
        0,                               // StretchTapsY
        2,                               // ShrinkTapsX 
        2,                               // ShrinkTapsY 
        (LONGLONG)PALFieldDuration,               // LONGLONG MinFrameInterval;  // 100 nS units
        (LONGLONG)PALFieldDuration*MAXULONG,   // LONGLONG MaxFrameInterval;
        1  * QCIFWidth * QCIFHeight * 2 * 8,    // LONG MinBitsPerSecond;
        25 * QCIFWidth * QCIFHeight * 16 * 2 * 8     // LONG MaxBitsPerSecond;
    },

    // KS_VIDEOINFOHEADER (default format)
    {
        0,0,0,0,                          //    RECT            rcSource; // The bit we really want to use
        0,0,0,0,                          //    RECT            rcTarget; // Where the video should go
        QCIFWidth * 4 * QCIFHeight * 2 * 25L, //    DWORD           dwBitRate; // Approximate bit data rate
        0L,                               //    DWORD           dwBitErrorRate;    // Bit error rate for this stream
        
        // 30 fps
        PALFieldDuration * 2,            //    REFERENCE_TIME AvgTimePerFrame;   // Average time per frame (100ns units)
        
        sizeof KS_BITMAPINFOHEADER,       //    DWORD      biSize;
        QCIFWidth * 2,                        //    LONG       biWidth;
        QCIFHeight * 2,                       //    LONG       biHeight;
        1,                                //    WORD       biPlanes;
        16,                               //    WORD       biBitCount;
        FOURCC_UYVY,                      //    DWORD      biCompression;
        QCIFWidth * QCIFHeight * 2 * 4,       //    DWORD      biSizeImage;
        0,                                //    LONG       biXPelsPerMeter;
        0,                                //    LONG       biYPelsPerMeter;
        0,                                //    DWORD      biClrUsed;
        0                                 //    DWORD      biClrImportant;
    }
};


KS_DATARANGE_VIDEO StreamFormatUYVY_Capture_NTSC_QCIF =
{
    // KSDATARANGE
    {
        sizeof(KS_DATARANGE_VIDEO),     // FormatSize
        0,                                // Flags
        QCIFWidth * QCIFHeight * 2,         // SampleSize
        0,                                // Reserved
        STATIC_KSDATAFORMAT_TYPE_VIDEO,                 // aka. MEDIATYPE_Video
        STATIC_KSDATAFORMAT_SUBTYPE_UYVY,				// aka. MEDIASUBTYPE_UYVY
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO         // aka. FORMAT_VideoInfo
    },

    TRUE,                                // BOOL,  bFixedSizeSamples (all samples same size?)
    TRUE,                                // BOOL,  bTemporalCompression (all I frames?)
    KS_VIDEOSTREAM_CAPTURE,              // StreamDescriptionFlags (KS_VIDEO_DESC_*)
    0,                                   // MemoryAllocationFlags (KS_VIDEO_ALLOC_*)

    // _KS_VIDEO_STREAM_CONFIG_CAPS
    {
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO,      // GUID 
        KS_AnalogVideo_NTSC_Mask & ~KS_AnalogVideo_NTSC_433 | KS_AnalogVideo_PAL_60 | KS_AnalogVideo_PAL_M, // AnalogVideoStandard
        {
            NTSCMaxInWidth, NTSCMaxInHeight      // SIZE InputSize
        },
        {
            QCIFWidth, QCIFHeight        // SIZE MinCroppingSize; smallest rcSrc cropping rect allowed
        },
        {
            QCIFWidth, QCIFHeight        // SIZE MaxCroppingSize; largest rcSrc cropping rect allowed
        },
        1,                               // int CropGranularityX;       // granularity of cropping size
        1,                               // int CropGranularityY;
        1,                               // int CropAlignX;             // alignment of cropping rect
        1,                               // int CropAlignY;
        {
            QCIFWidth, QCIFHeight        // SIZE MinOutputSize;         // smallest bitmap stream can produce
        },
        {
            QCIFWidth, QCIFHeight        // SIZE MaxOutputSize;         // largest  bitmap stream can produce
        },      
        1,                               // int OutputGranularityX;     // granularity of output bitmap size
        1,                               // int OutputGranularityY;
        0,                               // StretchTapsX  (0 no stretch, 1 pix dup, 2 interp...)
        0,                               // StretchTapsY
        2,                               // ShrinkTapsX 
        2,                               // ShrinkTapsY 
        (LONGLONG)NTSCFieldDuration,               // LONGLONG MinFrameInterval;  // 100 nS units
        (LONGLONG)NTSCFieldDuration*MAXULONG,   // LONGLONG MaxFrameInterval;
        1  * QCIFWidth * QCIFHeight * 2 * 8,    // LONG MinBitsPerSecond;
        30 * QCIFWidth * QCIFHeight * 2 * 8     // LONG MaxBitsPerSecond;
    },

    // KS_VIDEOINFOHEADER (default format)
    {
        0,0,0,0,                          //    RECT            rcSource; // The bit we really want to use
        0,0,0,0,                          //    RECT            rcTarget; // Where the video should go
        QCIFWidth * QCIFHeight * 2 * 30L, //    DWORD           dwBitRate; // Approximate bit data rate
        0L,                               //    DWORD           dwBitErrorRate;    // Bit error rate for this stream
        
        // 30 fps
        NTSCFieldDuration * 2,            //    REFERENCE_TIME AvgTimePerFrame;   // Average time per frame (100ns units)
        
        sizeof KS_BITMAPINFOHEADER,       //    DWORD      biSize;
        QCIFWidth,                        //    LONG       biWidth;
        QCIFHeight,                       //    LONG       biHeight;
        1,                                //    WORD       biPlanes;
        16,                               //    WORD       biBitCount;
        FOURCC_UYVY,                      //    DWORD      biCompression;
        QCIFWidth * QCIFHeight * 2,       //    DWORD      biSizeImage;
        0,                                //    LONG       biXPelsPerMeter;
        0,                                //    LONG       biYPelsPerMeter;
        0,                                //    DWORD      biClrUsed;
        0                                 //    DWORD      biClrImportant;
    }
};

KSDATAFORMAT StreamFormatVideoPort = 
{
    {
        sizeof(KSDATAFORMAT),
        0,
        0,
        0,
        STATIC_KSDATAFORMAT_TYPE_VIDEO,
        STATIC_KSDATAFORMAT_SUBTYPE_VPVideo,
        STATIC_KSDATAFORMAT_SPECIFIER_NONE
    }
};

KS_DATARANGE_VIDEO_VBI StreamFormatVBI_NTSC =
{
    // KSDATARANGE
    {
        {
            sizeof(KS_DATARANGE_VIDEO_VBI),
            0,
            VBISamples * NTSCVBILines,         // SampleSize
            0,                             // Reserved
            { STATIC_KSDATAFORMAT_TYPE_VBI },
            { STATIC_KSDATAFORMAT_SUBTYPE_RAW8 },
            { STATIC_KSDATAFORMAT_SPECIFIER_VBI }
        }
    },
    TRUE,                                // BOOL,  bFixedSizeSamples (all samples same size?)
    TRUE,                                // BOOL,  bTemporalCompression (all I frames?)
    KS_VIDEOSTREAM_VBI,                  // StreamDescriptionFlags  (KS_VIDEO_DESC_*)
    0,                                   // MemoryAllocationFlags   (KS_VIDEO_ALLOC_*)

    // _KS_VIDEO_STREAM_CONFIG_CAPS
    {
        { STATIC_KSDATAFORMAT_SPECIFIER_VBI },
        KS_AnalogVideo_NTSC_M,                             // AnalogVideoStandard
        {
            VBISamples, NTSCVBILines  // SIZE InputSize
        },
        {
            VBISamples, NTSCVBILines  // SIZE MinCroppingSize;       smallest rcSrc cropping rect allowed
        },
        {
            VBISamples, NTSCVBILines  // SIZE MaxCroppingSize;       largest rcSrc cropping rect allowed
        },
        1,                  // int CropGranularityX;       // granularity of cropping size
        1,                  // int CropGranularityY;
        1,                  // int CropAlignX;             // alignment of cropping rect
        1,                  // int CropAlignY;
        {
            VBISamples, NTSCVBILines  // SIZE MinOutputSize;   // smallest bitmap stream can produce
        },
        {
            VBISamples, NTSCVBILines  // SIZE MaxOutputSize;   // largest  bitmap stream can produce
        },
        1,                  // int OutputGranularityX;     // granularity of output bitmap size
        2,                  // int OutputGranularityY;
        0,                  // StretchTapsX  (0 no stretch, 1 pix dup, 2 interp...)
        0,                  // StretchTapsY
        0,                  // ShrinkTapsX
        0,                  // ShrinkTapsY
        NTSCFieldDuration,  // LONGLONG MinFrameInterval;  // 100 nS units
        NTSCFieldDuration,  // LONGLONG MaxFrameInterval;
        VBISamples * 30 * NTSCVBILines * 2 * 8, // LONG MinBitsPerSecond;
        VBISamples * 30 * NTSCVBILines * 2 * 8  // LONG MaxBitsPerSecond;
    },

    // KS_VBIINFOHEADER (default format)
    {
        NTSCVBIStart,               // StartLine  -- inclusive
        NTSCVBIEnd,                 // EndLine    -- inclusive
        SamplingFrequency,      // SamplingFrequency
        454,                    // MinLineStartTime;    // (uS past HR LE) * 100
        900,                    // MaxLineStartTime;    // (uS past HR LE) * 100

        // empirically discovered
        780,                    // ActualLineStartTime  // (uS past HR LE) * 100

        5902,                   // ActualLineEndTime;   // (uS past HR LE) * 100
        KS_AnalogVideo_NTSC_M,  // VideoStandard;
        VBISamples,             // SamplesPerLine;
        VBISamples,             // StrideInBytes;
        VBISamples * NTSCVBILines   // BufferSize;
    }
};

KSDATAFORMAT StreamFormatVideoPortVBI = 
{
    {
        sizeof(KSDATAFORMAT),
        0,
        0,
        0,
        STATIC_KSDATAFORMAT_TYPE_VIDEO,
        STATIC_KSDATAFORMAT_SUBTYPE_VPVBI,
        STATIC_KSDATAFORMAT_SPECIFIER_NONE
    }
};

static KS_DATARANGE_ANALOGVIDEO StreamFormatAnalogVideo = 
{
    // KS_DATARANGE_ANALOGVIDEO
    {   
        sizeof (KS_DATARANGE_ANALOGVIDEO),      // FormatSize
        0,                                      // Flags
        sizeof (KS_TVTUNER_CHANGE_INFO),        // SampleSize
        0,                                      // Reserved

        STATIC_KSDATAFORMAT_TYPE_ANALOGVIDEO,   // aka MEDIATYPE_AnalogVideo
        STATIC_KSDATAFORMAT_SUBTYPE_NONE,       // ie. Wildcard
        STATIC_KSDATAFORMAT_SPECIFIER_ANALOGVIDEO, // aka FORMAT_AnalogVideo
    },
    // KS_ANALOGVIDEOINFO
    {
        0, 0, 720, 480,         // rcSource;                
        0, 0, 720, 480,         // rcTarget;        
        720,                    // dwActiveWidth;   
        480,                    // dwActiveHeight;  
        NTSCFrameDuration,      // REFERENCE_TIME  AvgTimePerFrame; 
    }
};

//---------------------------------------------------------------------------
//  Capture Stream Formats, Mediums, and PinNames
//---------------------------------------------------------------------------

static PKSDATAFORMAT CaptureStreamFormats[] = 
{
    (PKSDATAFORMAT) &StreamFormatUYVY_Capture_NTSC,
    (PKSDATAFORMAT) &StreamFormatUYVY_Capture_NTSC_QCIF,
    (PKSDATAFORMAT) &StreamFormatUYVY_Capture_PAL,
};
#define NUM_CAPTURE_STREAM_FORMATS (SIZEOF_ARRAY (CaptureStreamFormats))

static GUID CaptureStreamPinName = {STATIC_PINNAME_VIDEO_CAPTURE};


//---------------------------------------------------------------------------
//  Video Port Stream Formats, Mediums, and PinNames
//---------------------------------------------------------------------------

static PKSDATAFORMAT VPStreamFormats[] = 
{
    (PKSDATAFORMAT) &StreamFormatVideoPort,
};
#define NUM_VP_STREAM_FORMATS (SIZEOF_ARRAY (VPStreamFormats))

static GUID VideoPortPinName = {STATIC_PINNAME_VIDEO_VIDEOPORT};


//---------------------------------------------------------------------------
//  VBI Stream Formats, Mediums, and PinNames
//---------------------------------------------------------------------------

static PKSDATAFORMAT VBIStreamFormats[] = 
{
    (PKSDATAFORMAT) &StreamFormatVBI_NTSC,
};
#define NUM_VBI_STREAM_FORMATS (SIZEOF_ARRAY (VBIStreamFormats))

static GUID VBIStreamPinName = {STATIC_PINNAME_VIDEO_VBI};


//---------------------------------------------------------------------------
//  Video Port VBI Stream Formats, Mediums, and PinNames
//---------------------------------------------------------------------------

static PKSDATAFORMAT VPVBIStreamFormats[] = 
{
    (PKSDATAFORMAT) &StreamFormatVideoPortVBI,
};
#define NUM_VPVBI_STREAM_FORMATS (SIZEOF_ARRAY (VPVBIStreamFormats))

static GUID VPVBIPinName = {STATIC_PINNAME_VIDEO_VIDEOPORT_VBI};


//---------------------------------------------------------------------------
//  Analog Video Stream Formats, Mediums, and PinNames
//---------------------------------------------------------------------------

static PKSDATAFORMAT AnalogVideoFormats[] = 
{
    (PKSDATAFORMAT) &StreamFormatAnalogVideo,
};
#define NUM_ANALOG_VIDEO_FORMATS (SIZEOF_ARRAY (AnalogVideoFormats))

static GUID AnalogVideoStreamPinName = {STATIC_PINNAME_VIDEO_ANALOGVIDEOIN};

ALL_STREAM_INFO Streams [] =
{
    // -----------------------------------------------------------------
    // The Video Capture output stream
    // -----------------------------------------------------------------
    {
        // HW_STREAM_INFORMATION -------------------------------------------
        {
            1,                                      // NumberOfPossibleInstances
            KSPIN_DATAFLOW_OUT,                     // DataFlow
            TRUE,                                   // DataAccessible
            NUM_CAPTURE_STREAM_FORMATS,             // NumberOfFormatArrayEntries
            CaptureStreamFormats,                   // StreamFormatsArray
            0,                                      // ClassReserved[0]
            0,                                      // ClassReserved[1]
            0,                                      // ClassReserved[2]
            0,                                      // ClassReserved[3]
            NumVideoStreamProperties,				// NumStreamPropArrayEntries
            (PKSPROPERTY_SET)VideoStreamProperties, // StreamPropertiesArray
            0,                                      // NumStreamEventArrayEntries;
            0,                                      // StreamEventsArray;
            &CaptureStreamPinName,                  // Category
            &CaptureStreamPinName,                  // Name
            0,                                      // MediumsCount
            NULL,                                   // Mediums
        },

        // STREAM_OBJECT_INFO ------------------------------------------------
        {
            FALSE,                                  // Dma
            TRUE,                                   // Pio
            sizeof (KS_FRAME_INFO),                 // StreamHeaderMediaSpecific
            0,                                      // StreamHeaderWorkspace 
            TRUE,                                   // Allocator 
            NULL,                                   // HwEventRoutine
        }
    },

    // -----------------------------------------------------------------
    // The Video Port output stream
    // -----------------------------------------------------------------
    {
        // HW_STREAM_INFORMATION -------------------------------------------
        {
            1,                                      // NumberOfPossibleInstances
            KSPIN_DATAFLOW_OUT,                     // DataFlow
            TRUE,                                   // DataAccessible.
            NUM_VP_STREAM_FORMATS,                  // NumberOfFormatArrayEntries
            VPStreamFormats,                        // StreamFormatsArray
            0,                                      // ClassReserved[0]
            0,                                      // ClassReserved[1]
            0,                                      // ClassReserved[2]
            0,                                      // ClassReserved[3]
            NumVideoPortProperties,				// NumStreamPropArrayEntries
            (PKSPROPERTY_SET)VideoPortProperties,	// StreamPropertiesArray
            SIZEOF_ARRAY(VPEventSet),               // NumStreamEventArrayEntries
            VPEventSet,                             // StreamEventsArray
            &VideoPortPinName,                      // Category
            &VideoPortPinName,                      // Name
            0,                                      // MediumsCount
            NULL,                                   // Mediums
        },

        // STREAM_OBJECT_INFO ------------------------------------------------
        {
            FALSE,                                  // Dma
            FALSE,                                   // Pio
            0,                                      // StreamHeaderMediaSpecific
            0,                                      // StreamHeaderWorkspace 
            FALSE,                                  // Allocator 
            VPStreamEventProc,                      // HwEventRoutine;
        }
    },

    // -----------------------------------------------------------------
    // The VBI Capture output stream
    // -----------------------------------------------------------------
    {
        // HW_STREAM_INFORMATION -------------------------------------------
        {
            1,                                      // NumberOfPossibleInstances
            KSPIN_DATAFLOW_OUT,                     // DataFlow
            TRUE,                                   // DataAccessible
            NUM_VBI_STREAM_FORMATS,                 // NumberOfFormatArrayEntries
            VBIStreamFormats,                       // StreamFormatsArray
            0,                                      // ClassReserved[0]
            0,                                      // ClassReserved[1]
            0,                                      // ClassReserved[2]
            0,                                      // ClassReserved[3]
            NumVideoStreamProperties,				// NumStreamPropArrayEntries
            (PKSPROPERTY_SET)VideoStreamProperties, // StreamPropertiesArray
            0,                                      // NumStreamEventArrayEntries;
            0,                                      // StreamEventsArray;
            &VBIStreamPinName,                      // Category
            &VBIStreamPinName,                      // Name
            0,                                      // MediumsCount
            NULL,                                   // Mediums
        },

        // STREAM_OBJECT_INFO ------------------------------------------------
        {
            FALSE,                                  // Dma
            TRUE,                                   // Pio
            sizeof (KS_VBI_FRAME_INFO),             // StreamHeaderMediaSpecific
            0,                                      // StreamHeaderWorkspace 
            TRUE,                                   // Allocator 
            NULL,                                   // HwEventRoutine
        }
    },

    // -----------------------------------------------------------------
    // The Video Port VBI output stream
    // -----------------------------------------------------------------
    {
        // HW_STREAM_INFORMATION -------------------------------------------
        {
            1,                                      // NumberOfPossibleInstances
            KSPIN_DATAFLOW_OUT,                     // DataFlow
            TRUE,                                   // DataAccessible.
            NUM_VPVBI_STREAM_FORMATS,               // NumberOfFormatArrayEntries
            VPVBIStreamFormats,                     // StreamFormatsArray
            0,                                      // ClassReserved[0]
            0,                                      // ClassReserved[1]
            0,                                      // ClassReserved[2]
            0,                                      // ClassReserved[3]
            NumVideoPortVBIProperties,				// NumStreamPropArrayEntries
            (PKSPROPERTY_SET)VideoPortVBIProperties,// StreamPropertiesArray
            SIZEOF_ARRAY(VPVBIEventSet),            // NumStreamEventArrayEntries
            VPVBIEventSet,                          // StreamEventsArray
            &VPVBIPinName,                          // Category
            &VPVBIPinName,                          // Name
            0,                                      // MediumsCount
            NULL,                                   // Mediums
        },

        // STREAM_OBJECT_INFO ------------------------------------------------
        {
            FALSE,                                  // Dma
            FALSE,                                   // Pio
            0,                                      // StreamHeaderMediaSpecific
            0,                                      // StreamHeaderWorkspace 
            FALSE,                                  // Allocator 
            VPVBIStreamEventProc,                   // HwEventRoutine;
        }
    },

    // -----------------------------------------------------------------
    // The Analog Video Input Stream 
    // -----------------------------------------------------------------
    {
        // HW_STREAM_INFORMATION -------------------------------------------
        {
            1,                                      // NumberOfPossibleInstances
            KSPIN_DATAFLOW_IN,                      // DataFlow
            TRUE,                                   // DataAccessible
            NUM_ANALOG_VIDEO_FORMATS,               // NumberOfFormatArrayEntries
            AnalogVideoFormats,                     // StreamFormatsArray
            0,                                      // ClassReserved[0]
            0,                                      // ClassReserved[1]
            0,                                      // ClassReserved[2]
            0,                                      // ClassReserved[3]
            0,                                      // NumStreamPropArrayEntries
            0,                                      // StreamPropertiesArray
            0,                                      // NumStreamEventArrayEntries;
            0,                                      // StreamEventsArray;
            &AnalogVideoStreamPinName,              // Category
            &AnalogVideoStreamPinName,              // Name
            1,                                      // MediumsCount
            &CrossbarMediums[3],                    // Mediums
        },
           
        // STREAM_OBJECT_INFO ------------------------------------------------
        {
            FALSE,                                  // Dma
            TRUE,                                   // Pio
            0,                                      // StreamHeaderMediaSpecific
            0,                                      // StreamHeaderWorkspace 
            FALSE,                                  // Allocator 
            NULL,                                   // HwEventRoutine
        },
    }
};

extern const ULONG NumStreams = SIZEOF_ARRAY(Streams);


//---------------------------------------------------------------------------
// Topology
//---------------------------------------------------------------------------

// Categories define what the device does.

static GUID Categories[] = {
    STATIC_KSCATEGORY_VIDEO,
    STATIC_KSCATEGORY_CAPTURE,
    STATIC_KSCATEGORY_CROSSBAR,
};

#define NUMBER_OF_CATEGORIES  SIZEOF_ARRAY (Categories)

KSTOPOLOGY Topology = {
    NUMBER_OF_CATEGORIES,               // CategoriesCount
    (GUID*) &Categories,                // Categories
    0,                                  // TopologyNodesCount
    NULL,                               // TopologyNodes
    0,                                  // TopologyConnectionsCount
    NULL,                               // TopologyConnections
    NULL,                               // TopologyNodesNames
    0,                                  // Reserved
};



/*
** AdapterCompareGUIDsAndFormatSize()
**
**   Checks for a match on the three GUIDs and FormatSize
**
** Arguments:
**
**         IN DataRange1
**         IN DataRange2
**         BOOL fCompareFormatSize - TRUE when comparing ranges
**                                 - FALSE when comparing formats
**
** Returns:
** 
**   TRUE if all elements match
**   FALSE if any are different
**
** Side Effects:  none
*/

BOOL AdapterCompareGUIDsAndFormatSize(
    IN PKSDATARANGE DataRange1,
    IN PKSDATARANGE DataRange2,
    BOOL fCompareFormatSize
    )
{
    return (
        IsEqualGUID (
            DataRange1->MajorFormat, 
            DataRange2->MajorFormat) &&
        IsEqualGUID (
            DataRange1->SubFormat, 
            DataRange2->SubFormat) &&
        IsEqualGUID (
            DataRange1->Specifier, 
            DataRange2->Specifier) && 
        (fCompareFormatSize ? 
                (DataRange1->FormatSize == DataRange2->FormatSize) : TRUE));
}


/*
** AdapterVerifyFormat()
**
**   Checks the validity of a format request by walking through the
**       array of supported KSDATA_RANGEs for a given stream.
**
** Arguments:
**
**   pKSDataFormat - pointer of a KSDATAFORMAT structure.
**   StreamNumber - index of the stream being queried / opened.
**
** Returns:
** 
**   TRUE if the format is supported
**   FALSE if the format cannot be suppored
**
** Side Effects:  none
*/

BOOL AdapterVerifyFormat(PKSDATAFORMAT pKSDataFormatToVerify, int StreamNumber)
{
    BOOL                        fOK = FALSE;
    ULONG                       j;
    ULONG                       NumberOfFormatArrayEntries;
    PKSDATAFORMAT               *pAvailableFormats;


    //
    // Check that the stream number is valid
    //

    if (StreamNumber >= NumStreams) {
        TRAP();
        return FALSE;
    }
    
    NumberOfFormatArrayEntries = 
            Streams[StreamNumber].hwStreamInfo.NumberOfFormatArrayEntries;

    //
    // Get the pointer to the array of available formats
    //

    pAvailableFormats = Streams[StreamNumber].hwStreamInfo.StreamFormatsArray;

    DBGINFO(("AdapterVerifyFormat, Stream=%d\n", StreamNumber));
    DBGINFO(("FormatSize=%d\n", 
            pKSDataFormatToVerify->FormatSize));
    DBGINFO(("MajorFormat=%x\n", 
            pKSDataFormatToVerify->MajorFormat));

    //
    // Walk the formats supported by the stream
    //

    for (j = 0; j < NumberOfFormatArrayEntries; j++, pAvailableFormats++) {

        // Check for a match on the three GUIDs and format size

        if (!AdapterCompareGUIDsAndFormatSize(
                        pKSDataFormatToVerify, 
                        *pAvailableFormats,
                        FALSE /* CompareFormatSize */)) {
            continue;
        }

        //
        // Now that the three GUIDs match, switch on the Specifier
        // to do a further type-specific check
        //

        // -------------------------------------------------------------------
        // Specifier FORMAT_VideoInfo for VIDEOINFOHEADER
        // -------------------------------------------------------------------

        if (IsEqualGUID (pKSDataFormatToVerify->Specifier, 
                KSDATAFORMAT_SPECIFIER_VIDEOINFO)) {
                
            PKS_DATAFORMAT_VIDEOINFOHEADER  pDataFormatVideoInfoHeader = 
                    (PKS_DATAFORMAT_VIDEOINFOHEADER) pKSDataFormatToVerify;
            PKS_VIDEOINFOHEADER  pVideoInfoHdrToVerify = 
                     (PKS_VIDEOINFOHEADER) &pDataFormatVideoInfoHeader->VideoInfoHeader;
            PKS_DATARANGE_VIDEO             pKSDataRangeVideo = (PKS_DATARANGE_VIDEO) *pAvailableFormats;
            KS_VIDEO_STREAM_CONFIG_CAPS    *pConfigCaps = &pKSDataRangeVideo->ConfigCaps;

            //
            // Perform some verification tests here!!!
            //

            fOK = TRUE;
            break;

        } // End of VIDEOINFOHEADER specifier

        // -------------------------------------------------------------------
        // Specifier FORMAT_VideoInfo for VBIINFOHEADER
        // -------------------------------------------------------------------

        if (IsEqualGUID (pKSDataFormatToVerify->Specifier, 
                KSDATAFORMAT_SPECIFIER_VBI)) {
                
            //
            // Perform some verification tests here!!!
            //

            fOK = TRUE;
            break;

        } // End of VBI specifier

        // -------------------------------------------------------------------
        // Specifier FORMAT_AnalogVideo for KS_ANALOGVIDEOINFO
        // -------------------------------------------------------------------

        else if (IsEqualGUID (pKSDataFormatToVerify->Specifier, 
                KSDATAFORMAT_SPECIFIER_ANALOGVIDEO)) {
      
            //
            // Perform some verification tests here!!!
            //

            fOK = TRUE;
            break;

        } // End of KS_ANALOGVIDEOINFO specifier

        // -------------------------------------------------------------------
        // Specifier STATIC_KSDATAFORMAT_TYPE_VIDEO for Video Port
        // -------------------------------------------------------------------

        else if (IsEqualGUID (pKSDataFormatToVerify->Specifier, 
                      KSDATAFORMAT_SPECIFIER_NONE) &&
                      IsEqualGUID (pKSDataFormatToVerify->SubFormat, KSDATAFORMAT_SUBTYPE_VPVideo)) {
      
      
            //
            // Perform some verification tests here!!!
            //

            fOK = TRUE;
            break;
        }  // End of Video port section
        
        // -------------------------------------------------------------------
        // Specifier KSDATAFORMAT_SPECIFIER_NONE for VP VBI
        // -------------------------------------------------------------------

        else if (IsEqualGUID (pKSDataFormatToVerify->Specifier, 
                      KSDATAFORMAT_SPECIFIER_NONE) &&
                      IsEqualGUID (pKSDataFormatToVerify->SubFormat, KSDATAFORMAT_SUBTYPE_VPVBI)) {
            //
            // Perform some verification tests here!!!
            //

            fOK = TRUE;
            break;
        }  // End of VP VBI section
      
    } // End of loop on all formats for this stream
    
    return fOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\bt-829\atibt\scaler.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#include "Scaler.h"

#include "capdebug.h"

#include "capmain.h"

#include "defaults.h"

// video information for PAL
VideoInfoStruct NTSCVideoInfo =
{
   730,     // Clkx1_HACTIVE          = 746
   148,     // Clkx1_HDELAY           = 140
   44,      // Min_Pixels             =  44
   240,     // Active_lines_per_field = 240
   144,     // Min_UncroppedPixels    = Min_Pixels + 100
   724,     // Max_Pixels             = ((Clkx1_HACTIVE < 774) ? Clkx1_HACTIVE - 6 : 768)
   32,      // Min_Lines              = (Active_lines_per_field / 16 + 1) * 2
   240,     // Max_Lines              = Active_lines_per_field
   352,     // Max_VFilter1_Pixels    = ((Clkx1_HACTIVE > 796) ? 384 : (Clkx1_HACTIVE * 14 / 29))
   176,     // Max_VFilter2_Pixels    = Clkx1_HACTIVE * 8 / 33
   176,     // Max_VFilter3_Pixels    = Clkx1_HACTIVE * 8 / 33
   240,     // Max_VFilter1_Lines     = Active_lines_per_field
   120,     // Max_VFilter2_Lines     = Active_lines_per_field / 2
   96,      // Max_VFilter3_Lines     = Active_lines_per_field * 2 / 5
};

// video information for PAL
VideoInfoStruct PALVideoInfo = 
{
   914,     // Clkx1_HACTIVE          = 914
   190,     // Clkx1_HDELAY           = 190
   48,      // Min_Pixels             =  48
   284,     // Active_lines_per_field = 284
   148,     // Min_UncroppedPixels    = Min_Pixels + 100
   768,     // Max_Pixels             = ((Clkx1_HACTIVE < 774) ? Clkx1_HACTIVE - 6 : 768)
   36,      // Min_Lines              = (Active_lines_per_field / 16 + 1) * 2
   284,     // Max_Lines              = Active_lines_per_field
   384,     // Max_VFilter1_Pixels    = ((Clkx1_HACTIVE > 796) ? 384 : (Clkx1_HACTIVE * 14 / 29))
   221,     // Max_VFilter2_Pixels    = Clkx1_HACTIVE * 8 / 33
   221,     // Max_VFilter3_Pixels    = Clkx1_HACTIVE * 8 / 33
   284,     // Max_VFilter1_Lines     = Active_lines_per_field
   142,     // Max_VFilter2_Lines     = Active_lines_per_field / 2
   113,     // Max_VFilter3_Lines     = Active_lines_per_field * 2 / 5
};

//===========================================================================
// Bt848 Scaler Class Implementation
//===========================================================================

/////////////////////////////////////////////////////////////////////////////
// Constructor
/////////////////////////////////////////////////////////////////////////////
#define REGALIGNMENT 1

#define offset 0


Scaler::Scaler(PDEVICE_PARMS pDeviceParms):
	regCROP ((0x03 * REGALIGNMENT) + (offset), RW, pDeviceParms) ,
	fieldVACTIVE_MSB(regCROP, 4, 2, RW) ,
	fieldHDELAY_MSB(regCROP, 2, 2, RW) ,
	fieldHACTIVE_MSB(regCROP, 0, 2, RW) ,
	regVACTIVE_LO ((0x05 * REGALIGNMENT) + (offset), RW, pDeviceParms) ,
	regHDELAY_LO ((0x06 * REGALIGNMENT) + (offset), RW, pDeviceParms) ,
	regHACTIVE_LO ((0x07 * REGALIGNMENT) + (offset), RW, pDeviceParms) ,
	regHSCALE_HI ((0x08 * REGALIGNMENT) + (offset), RW, pDeviceParms) ,
	fieldHSCALE_MSB(regHSCALE_HI, 0, 8, RW) ,
	regHSCALE_LO ((0x09 * REGALIGNMENT) + (offset), RW, pDeviceParms) ,
	regSCLOOP ((0x10 * REGALIGNMENT) + (offset), RW, pDeviceParms) ,
	fieldHFILT(regSCLOOP, 3, 2, RW) ,
	regVSCALE_HI ((0x13 * REGALIGNMENT) + (offset), RW, pDeviceParms) ,
	fieldVSCALE_MSB(regVSCALE_HI, 0, 5, RW) ,
	regVSCALE_LO ((0x14 * REGALIGNMENT) + (offset), RW, pDeviceParms) ,
	regVActive(regVACTIVE_LO, 8, fieldVACTIVE_MSB, RW),
	regVScale(regVSCALE_LO, 8, fieldVSCALE_MSB, RW),
	regHDelay(regHDELAY_LO, 8, fieldHDELAY_MSB, RW),
	regHActive(regHACTIVE_LO, 8, fieldHACTIVE_MSB, RW),
	regHScale(regHSCALE_LO, 8, fieldHSCALE_MSB, RW),
	regVTC ((0x1B * REGALIGNMENT) + (offset), RW, pDeviceParms) ,
	fieldVBIEN  (regVTC, 4, 1, RW), 
	fieldVBIFMT (regVTC, 3, 1, RW), 
	fieldVFILT  (regVTC, 0, 2, RW),

   regReverse_CROP (0x03, RW, pDeviceParms),
   fieldVDELAY_MSB(regReverse_CROP, 6, 2, RW),
   regVDELAY_LO (0x04, RW, pDeviceParms),
   regVDelay(regVDELAY_LO, 8, fieldVDELAY_MSB, RW),
   m_videoFormat(VFormat_NTSC), VFilterFlag_(On),
   DigitalWin_(0,0,NTSCMaxOutWidth,NTSCMaxOutHeight)
{
   m_HActive = 0;
   m_pixels = 0;
   m_lines = 0;
   m_VFilter = 0;
}   


/////////////////////////////////////////////////////////////////////////////
// Destructor
/////////////////////////////////////////////////////////////////////////////
Scaler::~Scaler()
{
}

/////////////////////////////////////////////////////////////////////////////
// Method:  void Scaler::VideoFormatChanged(VideoFormat format)
// Purpose: Set which video format is using
// Input:   Video format -
//            Auto format:          VFormat_AutoDetect
//            NTSC (M):             VFormat_NTSC
//            PAL (B, D, G, H, I):  VFormat_PAL_BDGHI
//            PAL (M):              VFormat_PAL_M
//            PAL(N):               VFormat_PAL_N
//            SECAM:                VFormat_SECAM
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Scaler::VideoFormatChanged(VideoFormat format)
{
    m_videoFormat = format;
    Scale(DigitalWin_);
}


/////////////////////////////////////////////////////////////////////////////
// Method:  void Scaler::Scale(MRect & clientScr)
// Purpose: Perform scaling
// Input:   MRect & clientScr - rectangle to scale to
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Scaler::Scale(MRect & clientScr)
{
   switch (m_videoFormat)
   {
   case VFormat_NTSC:
   case VFormat_NTSC_J:
   case VFormat_PAL_M:
       m_ptrVideoIn = &NTSCVideoInfo;   //  set scaling constants for NTSC
       break;
   case VFormat_PAL_BDGHI:
   case VFormat_PAL_N:
   case VFormat_SECAM:
   case VFormat_PAL_N_COMB:
       m_ptrVideoIn = &PALVideoInfo;    // set scaling constants for PAL/SECAM
       if ( m_videoFormat == VFormat_PAL_N_COMB )
       {
           m_ptrVideoIn->Clkx1_HACTIVE = NTSCVideoInfo.Clkx1_HACTIVE;   // p. 26 of BT guide
           m_ptrVideoIn->Clkx1_HDELAY = NTSCVideoInfo.Clkx1_HDELAY;     // empirical
       }

       break;
   }


   // the order of functions calling here is important because some
   // calculations are based on previous results
   SetHActive(clientScr); 
   SetVActive();
   SetVScale(clientScr);
   SetVFilter();
   SetVDelay();
   SetHDelay();
   SetHScale();
   SetHFilter();

}

/////////////////////////////////////////////////////////////////////////////
// Method:  void Scaler::SetHActive(MRect & clientScr)
// Purpose: Set HActive register
// Input:   MRect & clientScr - rectangle to scale to
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Scaler::SetHActive(MRect & clientScr)
{
    m_HActive = min(m_ptrVideoIn->Max_Pixels,
                max((WORD)clientScr.Width(), m_ptrVideoIn->Min_Pixels));

    regHActive = m_HActive;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  void Scaler::SetHDelay()
// Purpose: Set HDelay register
// Input:   None
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Scaler::SetHDelay()
{
   // calculations here requires calculation of HActive first!
   m_pixels = m_HActive;
   if (m_pixels < m_ptrVideoIn->Min_UncroppedPixels)
      m_pixels += (WORD) ((m_ptrVideoIn->Min_UncroppedPixels - m_pixels + 9) / 10);

   LONG a = (LONG)m_pixels * (LONG)m_ptrVideoIn->Clkx1_HDELAY;
   LONG b = (LONG)m_ptrVideoIn->Clkx1_HACTIVE * 2L;
   WORD HDelay = (WORD) ((a + (LONG)m_ptrVideoIn->Clkx1_HACTIVE * 2 - 1) / b * 2L);

   // now add the cropping region into HDelay register; i.e. skip some pixels
   // before we start taking them as real image
   HDelay += (WORD)AnalogWin_.left;

   // HDelay must be even or else color would be wrong
   HDelay &= ~01;

   regHDelay = HDelay;

   // since we increase HDelay, we should decrease HActive by the same amount
   m_HActive -= (WORD)AnalogWin_.left;
   regHActive = m_HActive;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  void Scaler::SetHScale()
// Purpose: Set HScale register
// Input:   None
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Scaler::SetHScale()
{
   regHScale = (WORD) ((((LONG)m_ptrVideoIn->Clkx1_HACTIVE * 4096L) /
                                            (LONG)m_pixels) - 4096L);
}


/////////////////////////////////////////////////////////////////////////////
// Method:  void Scaler::SetHFilter()
// Purpose: Set HFilt register field
// Input:   None
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Scaler::SetHFilter()
{
   if (m_videoFormat != VFormat_SECAM)
      fieldHFILT = HFilter_AutoFormat;
   else  // SECAM
      if (m_pixels < m_ptrVideoIn->Clkx1_HACTIVE / 7)
         fieldHFILT = HFilter_ICON;
      else
         fieldHFILT = HFilter_QCIF;
}         

/////////////////////////////////////////////////////////////////////////////
// Method:  void Scaler::SetVScale(MRect & clientScr)
// Purpose: Set VScale register
// Input:   MRect & clientScr - rectangle to scale to
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Scaler::SetVScale(MRect & clientScr)
{
   m_lines = min(m_ptrVideoIn->Max_Lines,
                  max((WORD)clientScr.Height(), m_ptrVideoIn->Min_Lines));

   WORD LPB_VScale_Factor = (WORD) (1 + (m_lines - 1) / m_ptrVideoIn->Active_lines_per_field);

   m_lines = (WORD) ((m_lines + LPB_VScale_Factor - 1) / LPB_VScale_Factor);

   LONG a = (LONG)m_ptrVideoIn->Active_lines_per_field * 512L / (LONG)m_lines;
   WORD VScale = (WORD) ((0x10000L - a + 512L) & 0x1FFFL);
   regVScale = VScale;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  void Scaler::SetVDelay()
// Purpose: Set VDelay register
// Input:   None
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Scaler::SetVDelay()
{
   WORD VDelay, moreDelay;

   // increase VDelay will eliminate garbage lines at top of image
   switch (m_VFilter)
   {
      case 3:
         moreDelay = 4;
         break;

      case 2:
         moreDelay = 2;
         break;
             
      case 1:
      case 0:
      default:
         moreDelay = 0;
         break;
   }

   if ( ( m_videoFormat == VFormat_NTSC ) ||
        ( m_videoFormat == VFormat_NTSC_J ) ||
        ( m_videoFormat == VFormat_PAL_M ) ||
        ( m_videoFormat == VFormat_PAL_N_COMB ) )   // the reason that PAL_N_COMB is here is purely empirical
      VDelay = 0x001A + moreDelay;    // NTSC
   else
      VDelay = 0x0026 + moreDelay;    // PAL/SECAM
                            
   // now add the cropping region into VDelay register; i.e. skip some pixels
   // before we start taking them as real image
   VDelay += (WORD)(((LONG)m_ptrVideoIn->Max_Lines * (LONG)AnalogWin_.top + m_lines - 1) / (LONG)m_lines * 2);

   regVDelay = VDelay;
}

/////////////////////////////////////////////////////////////////////////////
// Method:  void Scaler::SetVActive()
// Purpose: Set VActive register
// Input:   None
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Scaler::SetVActive()
{
   // No calculation needed for VActive register since it based on the UNSCALED image
   if ( ( m_videoFormat == VFormat_NTSC ) ||
        ( m_videoFormat == VFormat_NTSC_J ) ||
        ( m_videoFormat == VFormat_PAL_M ) )
      regVActive = 0x1F4;
   else
      regVActive = 0x238;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  void Scaler::SetVBIEN(BOOL)
// Purpose: Set VBIEN register field
// Input:   None
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Scaler::SetVBIEN(BOOL enable)
{
    if (enable)
    {
        fieldVBIEN = 1;
    }
    else
    {
        fieldVBIEN = 0;
    }
}


/////////////////////////////////////////////////////////////////////////////
// Method:  BOOL void Scaler::IsVBIEN()
// Purpose: Set VBIEN register field
// Input:   None
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
BOOL Scaler::IsVBIEN()
{
    if (fieldVBIEN)
        return TRUE;
    else
        return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  void Scaler::SetVBIFMT(BOOL)
// Purpose: Set VBIFMT register field
// Input:   None
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Scaler::SetVBIFMT(BOOL enable)
{
    if (enable)
    {
        fieldVBIFMT = 1;
    }
    else
    {
        fieldVBIFMT = 0;
    }
}


/////////////////////////////////////////////////////////////////////////////
// Method:  BOOL void Scaler::IsVBIFMT()
// Purpose: Set VBIFMT register field
// Input:   None
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
BOOL Scaler::IsVBIFMT()
{
    if (fieldVBIFMT)
        return TRUE;
    else
        return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  void Scaler::SetVFilter()
// Purpose: Set VFilt register field
// Input:   None
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Scaler::SetVFilter()
{
   // this is to remove junk lines at the top of video. flag set to off
   // when image hight is above CIF
   if (VFilterFlag_ == Off) {
      fieldVFILT = 0;
      m_VFilter  = 0;
      return;
   }
   if ((m_HActive <= m_ptrVideoIn->Max_VFilter3_Pixels) &&
        (m_lines   <= m_ptrVideoIn->Max_VFilter3_Lines))
      m_VFilter = 3;
   else if ((m_HActive <= m_ptrVideoIn->Max_VFilter2_Pixels) &&
             (m_lines   <= m_ptrVideoIn->Max_VFilter2_Lines))
      m_VFilter = 2;
   else if ((m_HActive <= m_ptrVideoIn->Max_VFilter1_Pixels) &&
             (m_lines   <= m_ptrVideoIn->Max_VFilter1_Lines))
      m_VFilter = 1;
   else
      m_VFilter = 0;

   fieldVFILT = m_VFilter;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  void Scaler::GetDigitalWin(MRect &DigWin) const
// Purpose: Retreives the size of digital window
// Input:   None
// Output:  MRect &DigWin - retrieved value
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Scaler::GetDigitalWin(MRect &DigWin) const
{
   DigWin = DigitalWin_;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  ErrorCode Scaler::SetDigitalWin(const MRect &DigWin)
// Purpose: Sets the size and location of the digital window
// Input:   const MRect &DigWin - window size to set to
// Output:  None
// Return:  Success or Fail if passed rect is bigger then analog window
// Note:    This function can affect the scaling, so Scale() is called
/////////////////////////////////////////////////////////////////////////////
ErrorCode Scaler::SetDigitalWin(const MRect &DigWin)
{
   // we can not scale up
   if ((DigWin.Height() > AnalogWin_.Height()) ||
        (DigWin.Width() > AnalogWin_.Width()))
      return Fail;

   DigitalWin_ = DigWin;

   // every invocation of SetDigitalWin potentially changes the scaling
   Scale(DigitalWin_);

   return Success;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  void Scaler::GetAnalogWin(MRect &AWin) const
// Purpose: Retreives the size of analog window
// Input:   None
// Output:  MRect &DigWin - retrieved value
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Scaler::GetAnalogWin(MRect &AWin) const
{
   AWin = AnalogWin_;
}

/////////////////////////////////////////////////////////////////////////////
// Method:  ErrorCode Scaler::SetAnalogWin(const MRect &AWin)
// Purpose: Sets the size and location of the analog window
// Input:   const MRect &AWin - window size to set to
// Output:  None
// Return:  Success or Fail if passed rect is bigger then analog window
/////////////////////////////////////////////////////////////////////////////
ErrorCode Scaler::SetAnalogWin(const MRect &AWin)
{
   AnalogWin_ = AWin;
   return Success;
}

void Scaler::DumpSomeState()
{
    UINT vDelay = regVDelay;
    UINT vActive = regVActive;
    UINT vScale = regVScale;
    UINT hDelay = regHDelay;
    UINT hActive = regHActive;
    UINT hScale = regHScale;

    MRect rect;
    GetDigitalWin(rect);

    DBGINFO(("vDelay = 0x%x\n", vDelay));
    DBGINFO(("vActive = 0x%x\n", vActive));
    DBGINFO(("vScale = 0x%x\n", vScale));
    DBGINFO(("hDelay = 0x%x\n", hDelay));
    DBGINFO(("hActive = 0x%x\n", hActive));
    DBGINFO(("hScale = 0x%x\n", hScale));
    DBGINFO(("top = 0x%x\n", rect.top));
    DBGINFO(("left = 0x%x\n", rect.left));
    DBGINFO(("right = 0x%x\n", rect.right));
    DBGINFO(("bottom = 0x%x\n", rect.bottom));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\bt-829\atibt\xbar.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#ifdef __cplusplus
extern "C" {
#endif

#include "strmini.h"
#include "ksmedia.h"

#ifdef __cplusplus
}
#endif

#include "capmain.h"
#include "capdebug.h"

#include "device.h"

#include "xbar.h"

BOOL CrossBar::TestRoute(int InPin, int OutPin)
{
   if ((InputPins [InPin].PinType == KS_PhysConn_Video_Tuner ||
        InputPins [InPin].PinType == KS_PhysConn_Video_Composite ||
        InputPins [InPin].PinType == KS_PhysConn_Video_SVideo) &&
        (OutputPins [OutPin].PinType == KS_PhysConn_Video_VideoDecoder)) {
      return TRUE;
   }
   else
      return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\bt-829\atibt\viddefs.h ===
#pragma once

//==========================================================================;
//
//	Definitions for video settings.
//
//		$Date:   21 Aug 1998 14:58:10  $
//	$Revision:   1.0  $
//	  $Author:   Tashjian  $
//
// $Copyright:	(c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;


/* Type: Connector
 * Purpose: Defines a video source
 */
typedef enum { ConComposite, ConTuner, ConSVideo } Connector;

/* Type: State
 * Purpose: used to define on-off operations
 */
typedef enum { Off, On } State;

/* Type: Level
 * Purpose: used to define a pin state
 */
//typedef enum { Low, Hi } Level;

/* Type: Field
 * Purpose: defines fields
 */
typedef enum { VF_Both, VF_Even, VF_Odd } VidField;

/* Type: VideoFormat
 * Purpose: Used to define video format
 */
typedef enum {  VFormat_AutoDetect,
                VFormat_NTSC,
                VFormat_NTSC_J,
                VFormat_PAL_BDGHI,
                VFormat_PAL_M,
                VFormat_PAL_N,
                VFormat_SECAM,
                VFormat_PAL_N_COMB } VideoFormat;

/* Type: LumaRange
 * Purpose: Used to define Luma Output Range
 */
typedef enum { LumaNormal, LumaFull } LumaRange;

/* Type: OutputRounding
 * Purpose: Controls the number of bits output
 */
typedef enum { RND_Normal, RND_6Luma4Chroma, RND_7Luma5Chroma } OutputRounding;

/* Type: ClampLevel
 * Purpose: Defines the clamp levels
 */
typedef enum { ClampLow, ClampMiddle, ClampNormal, ClampHi } ClampLevel;


/*
 * Type: Crystal
 * Purpose: Defines which crystal to use
 */
typedef enum { Crystal_XT0 = 1, Crystal_XT1, Crystal_AutoSelect } Crystal;


/*
 * Type: HoriFilter
 * Purpose: Defines horizontal low-pass filter
 */
typedef enum { HFilter_AutoFormat,
               HFilter_CIF,
               HFilter_QCIF,
               HFilter_ICON } HorizFilter;

/*
 * Type: CoringLevel
 * Purpose: Defines Luma coring level
 */
typedef enum { Coring_None,
               Coring_8,
               Coring_16,
               Coring_32 } CoringLevel;

/*
 * Type: ThreeState
 * Purpose: Defines output three-states for the OE pin
 */
typedef enum { TS_Timing_Data,
               TS_Data,
               TS_Timing_Data_Clock,
               TS_Clock_Data } ThreeState;

/*
 * Type: SCLoopGain
 * Purpose: Defines subcarrier loop gain
 */
typedef enum { SC_Normal, SC_DivBy8, SC_DivBy16, SC_DivBy32 } SCLoopGain;

/*
 * Type: ComparePt
 * Purpose: Defines the majority comparison point for the White Crush Up function
 */
typedef enum { CompPt_3Q, CompPt_2Q, CompPt_1Q, CompPt_Auto } ComparePt;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\bt-829\atibt\strmprop.h ===
//==========================================================================;
//
//	WDM Video Decoder stream properties definitions
//
//		$Date:   17 Aug 1998 14:59:50  $
//	$Revision:   1.0  $
//	  $Author:   Tashjian  $
//
// $Copyright:	(c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

#ifdef _STRM_PROP_H_
#pragma message("StrmProp.h INCLUDED MORE THAN ONCE")
#else
#define _STRM_PROP_H_
#endif

// ------------------------------------------------------------------------
// Property set for Video and VBI capture streams
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_TABLE(VideoStreamConnectionProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_CONNECTION_ALLOCATORFRAMING,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSALLOCATOR_FRAMING),            // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),
};


DEFINE_KSPROPERTY_TABLE(VideoStreamDroppedFramesProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_DROPPEDFRAMES_CURRENT,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_DROPPEDFRAMES_CURRENT_S),// MinProperty
        sizeof(KSPROPERTY_DROPPEDFRAMES_CURRENT_S),// MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
};

// ------------------------------------------------------------------------
// Array of the property sets supported by Video and VBI capture streams
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_SET_TABLE(VideoStreamProperties)
{
    DEFINE_KSPROPERTY_SET
    ( 
        &KSPROPSETID_Connection,                        // Set
        SIZEOF_ARRAY(VideoStreamConnectionProperties),  // PropertiesCount
        VideoStreamConnectionProperties,                // PropertyItem
        0,                                              // FastIoCount
        NULL                                            // FastIoTable
    ),
    DEFINE_KSPROPERTY_SET
    ( 
        &PROPSETID_VIDCAP_DROPPEDFRAMES,                // Set
        SIZEOF_ARRAY(VideoStreamDroppedFramesProperties),  // PropertiesCount
        VideoStreamDroppedFramesProperties,                // PropertyItem
        0,                                              // FastIoCount
        NULL                                            // FastIoTable
    ),
};

const ULONG NumVideoStreamProperties =	SIZEOF_ARRAY(VideoStreamProperties);


// ------------------------------------------------------------------------
// Property set for the VideoPort
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_TABLE(VideoPortConfiguration)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_NUMCONNECTINFO,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(ULONG),                          // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_NUMVIDEOFORMAT,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(ULONG),                          // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_GETCONNECTINFO,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSMULTIPLE_DATA_PROP),           // MinProperty
        sizeof(ULONG),                          // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_SETCONNECTINFO,
        FALSE,                                  // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(ULONG),                          // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_VPDATAINFO,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KS_AMVPDATAINFO),                // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_MAXPIXELRATE,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSVPSIZE_PROP),                  // MinProperty
        sizeof(KSVPMAXPIXELRATE),               // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_INFORMVPINPUT,
        TRUE,                                   // GetSupported or Handler
        sizeof(PKSPROPERTY),                    // MinProperty
        sizeof(DDPIXELFORMAT),                  // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_DDRAWHANDLE,
        (PFNKSHANDLER)FALSE,
        sizeof (PKSPROPERTY),
        sizeof (ULONG),    // could be 0 too
        (PFNKSHANDLER) TRUE,
        NULL,
        0,
        NULL,
        NULL,
        0
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_VIDEOPORTID,
        (PFNKSHANDLER)FALSE,
        sizeof (PKSPROPERTY),
        sizeof (ULONG),    // could be 0 too
        (PFNKSHANDLER) TRUE,
        NULL,
        0,
        NULL,
        NULL,
        0
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_DDRAWSURFACEHANDLE,
        (PFNKSHANDLER)FALSE,
        sizeof (PKSPROPERTY),
        sizeof (ULONG),    // could be 0 too
        (PFNKSHANDLER) TRUE,
        NULL,
        0,
        NULL,
        NULL,
        0
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_GETVIDEOFORMAT,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSMULTIPLE_DATA_PROP),           // MinProperty
        sizeof(ULONG),                          // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_SETVIDEOFORMAT,
        FALSE,                                  // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(ULONG),                          // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_INVERTPOLARITY,
        FALSE,                                  // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        0,                                      // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_SURFACEPARAMS,
        FALSE,                                  // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSVPSURFACEPARAMS),              // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_DECIMATIONCAPABILITY,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(BOOL),                           // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_SCALEFACTOR,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KS_AMVPSIZE),                    // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
};

DEFINE_KSPROPERTY_SET_TABLE(VideoPortProperties)
{
    DEFINE_KSPROPERTY_SET
    ( 
        &KSPROPSETID_VPConfig,                  // Set
        SIZEOF_ARRAY(VideoPortConfiguration),   // PropertiesCount
        VideoPortConfiguration,                 // PropertyItem
        0,                                      // FastIoCount
        NULL                                    // FastIoTable
    )
};

const ULONG NumVideoPortProperties = SIZEOF_ARRAY(VideoPortProperties);


// ------------------------------------------------------------------------
// Property set for the VideoPort VBI stream
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_TABLE(VideoPortVBIConfiguration)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_NUMCONNECTINFO,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(ULONG),                          // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_NUMVIDEOFORMAT,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(ULONG),                          // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_GETCONNECTINFO,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSMULTIPLE_DATA_PROP),           // MinProperty
        sizeof(ULONG),                          // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_SETCONNECTINFO,
        FALSE,                                  // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(ULONG),                          // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_VPDATAINFO,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KS_AMVPDATAINFO),                // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_MAXPIXELRATE,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSVPSIZE_PROP),                  // MinProperty
        sizeof(KSVPMAXPIXELRATE),               // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_INFORMVPINPUT,
        TRUE,                                   // GetSupported or Handler
        sizeof(PKSPROPERTY),                    // MinProperty
        sizeof(DDPIXELFORMAT),                  // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_DDRAWHANDLE,
        (PFNKSHANDLER)FALSE,
        sizeof (PKSPROPERTY),
        sizeof (ULONG),    // could be 0 too
        (PFNKSHANDLER) TRUE,
        NULL,
        0,
        NULL,
        NULL,
        0
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_VIDEOPORTID,
        (PFNKSHANDLER)FALSE,
        sizeof (PKSPROPERTY),
        sizeof (ULONG),    // could be 0 too
        (PFNKSHANDLER) TRUE,
        NULL,
        0,
        NULL,
        NULL,
        0
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_DDRAWSURFACEHANDLE,
        (PFNKSHANDLER)FALSE,
        sizeof (PKSPROPERTY),
        sizeof (ULONG),    // could be 0 too
        (PFNKSHANDLER) TRUE,
        NULL,
        0,
        NULL,
        NULL,
        0
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_GETVIDEOFORMAT,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSMULTIPLE_DATA_PROP),           // MinProperty
        sizeof(ULONG),                          // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_SETVIDEOFORMAT,
        FALSE,                                  // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(ULONG),                          // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_INVERTPOLARITY,
        FALSE,                                  // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        0,                                      // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_SURFACEPARAMS,
        FALSE,                                  // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSVPSURFACEPARAMS),              // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_DECIMATIONCAPABILITY,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(BOOL),                           // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_SCALEFACTOR,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KS_AMVPSIZE),                    // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
};

DEFINE_KSPROPERTY_SET_TABLE(VideoPortVBIProperties)
{
    DEFINE_KSPROPERTY_SET
    ( 
        &KSPROPSETID_VPVBIConfig,               // Set
        SIZEOF_ARRAY(VideoPortVBIConfiguration),// PropertiesCount
        VideoPortVBIConfiguration,              // PropertyItem
        0,                                      // FastIoCount
        NULL                                    // FastIoTable
    )
};

const ULONG NumVideoPortVBIProperties	= SIZEOF_ARRAY(VideoPortVBIProperties);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\bt-829\atibt\xbar.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#ifndef __XBAR_H
#define __XBAR_H

#include "capmain.h"

#include "mediums.h"

struct _XBAR_PIN_DESCRIPTION {
    ULONG PinType;
    ULONG RelatedPinIndex;
    ULONG IsRoutedTo;                 // Index of input pin in use
    KSPIN_MEDIUM Medium;
    _XBAR_PIN_DESCRIPTION(ULONG type, ULONG rel, const KSPIN_MEDIUM * PinMedium);
    _XBAR_PIN_DESCRIPTION(){}
};

inline _XBAR_PIN_DESCRIPTION::_XBAR_PIN_DESCRIPTION(ULONG type, ULONG rel , const KSPIN_MEDIUM * PinMedium) : 
    PinType(type), RelatedPinIndex(rel), IsRoutedTo(0) // , Medium(PinMedium)
{
    Medium = *PinMedium;
}

const NUMBER_OF_XBAR_OUTPUTS = 1;
const NUMBER_OF_XBAR_INPUTS = 3;

class CrossBar
{
    friend class Device;

    _XBAR_PIN_DESCRIPTION OutputPins [NUMBER_OF_XBAR_OUTPUTS];
    _XBAR_PIN_DESCRIPTION InputPins [NUMBER_OF_XBAR_INPUTS];

    public:
        int GetNoInputs();
        int GetNoOutputs();

	void * operator new(size_t size, void * pAllocation) { return(pAllocation);}
	void operator delete(void * pAllocation) {}

        
		BOOL TestRoute(int InPin, int OutPin);
        ULONG  GetPinInfo(int dir, int idx, ULONG &related);
        KSPIN_MEDIUM * GetPinMedium(int dir, int idx);

        void Route(int OutPin, int InPin);
        BOOL GoodPins(int InPin, int OutPin);

        int GetRoute(int OutPin);

        CrossBar();
};

inline CrossBar::CrossBar()
{
    OutputPins [0] = _XBAR_PIN_DESCRIPTION(KS_PhysConn_Video_VideoDecoder, 1 , &CrossbarMediums[3]);
    // InputPins are set in device.cpp
}

inline int CrossBar::GetNoInputs()
{
    return NUMBER_OF_XBAR_INPUTS;
}

inline int CrossBar::GetNoOutputs()
{
    return NUMBER_OF_XBAR_OUTPUTS;
}

inline BOOL CrossBar::GoodPins(int InPin, int OutPin)
{
    return BOOL(InPin < NUMBER_OF_XBAR_INPUTS && OutPin < NUMBER_OF_XBAR_OUTPUTS);
}

inline void CrossBar::Route(int OutPin, int InPin)
{
    OutputPins [OutPin].IsRoutedTo = InPin;
}

inline int CrossBar::GetRoute(int OutPin)
{
    return OutputPins [OutPin].IsRoutedTo;
}

inline KSPIN_MEDIUM * CrossBar::GetPinMedium(int dir, int idx)
{
    _XBAR_PIN_DESCRIPTION *pPinDesc;

    if (dir == KSPIN_DATAFLOW_IN) {
        pPinDesc = InputPins;
        ASSERT(idx < NUMBER_OF_XBAR_INPUTS);
    } else {
        pPinDesc = OutputPins;
        ASSERT(idx < NUMBER_OF_XBAR_OUTPUTS);
    }

    return &pPinDesc [idx].Medium;
}

inline ULONG CrossBar::GetPinInfo(int dir, int idx, ULONG &related)
{
    _XBAR_PIN_DESCRIPTION *pPinDesc;

    if (dir == KSPIN_DATAFLOW_IN) {
        pPinDesc = InputPins;
        ASSERT(idx < NUMBER_OF_XBAR_INPUTS);
    } else {
        pPinDesc = OutputPins;
        ASSERT(idx < NUMBER_OF_XBAR_OUTPUTS);
    }
    related = pPinDesc [idx].RelatedPinIndex;
    return pPinDesc [idx].PinType;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\bt-829\atibt\strminfo.h ===
#pragma once

//==========================================================================;
//
//	WDM Video Decoder stream informaition defintitions
//
//		$Date:   17 Aug 1998 15:00:10  $
//	$Revision:   1.0  $
//	  $Author:   Tashjian  $
//
// $Copyright:	(c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;


/*
 * When this is set by the driver and passed to the client, this
 * indicates that the video port is capable of treating even fields
 * like odd fields and visa versa.  When this is set by the client,
 * this indicates that the video port should treat even fields like odd
 * fields.
 */
#define DDVPCONNECT_INVERTPOLARITY      0x00000004l

// derived from "fourcc.h"

#define MAKE_FOURCC(ch0, ch1, ch2, ch3)                       \
        ((DWORD)(BYTE)(ch0) | ((DWORD)(BYTE)(ch1) << 8) |    \
        ((DWORD)(BYTE)(ch2) << 16) | ((DWORD)(BYTE)(ch3) << 24))

#define FOURCC_YUV422   MAKE_FOURCC('S','4','2','2')
#define FOURCC_VBID	    MAKE_FOURCC('V','B','I','D')
#define FOURCC_YUY2     MAKE_FOURCC('Y','U','Y','2')
#define FOURCC_UYVY     MAKE_FOURCC('U','Y','V','Y')
#define FOURCC_YV12     MAKE_FOURCC('Y','V','1','2')
#define FOURCC_YUV12    FOURCC_YV12
#define FOURCC_Y12G     MAKE_FOURCC('Y','1','2','G')
#define FOURCC_YV10     MAKE_FOURCC('Y','V','1','0')
#define FOURCC_YUV10    FOURCC_YV10
#define FOURCC_YVU9     MAKE_FOURCC('Y','V','U','9')
#define FOURCC_IF09     MAKE_FOURCC('I','F','0','9')
#define FOURCC_Y10F     MAKE_FOURCC('Y','1','0','F')
#define FOURCC_Y12F     MAKE_FOURCC('Y','1','2','F')
#define FOURCC_YVUM     MAKE_FOURCC('Y','V','U','M')


//---------------------------------------------------------------------------
// Create an array that holds the list of all of the streams supported
//---------------------------------------------------------------------------

typedef struct _STREAM_OBJECT_INFO {
    BOOLEAN         Dma;        // device uses busmaster DMA for this stream
    BOOLEAN         Pio;        // device uses PIO for this
    ULONG   StreamHeaderMediaSpecific; // Size of media specific per stream header expansion. 
    ULONG   StreamHeaderWorkspace;		// Size of per-stream header workspace.
    BOOLEAN	Allocator;  // Set to TRUE if allocator is needed for this stream.    
    PHW_EVENT_ROUTINE HwEventRoutine;
} STREAM_OBJECT_INFO;


typedef struct _ALL_STREAM_INFO {
    HW_STREAM_INFORMATION   hwStreamInfo;
    STREAM_OBJECT_INFO      hwStreamObjectInfo;
} ALL_STREAM_INFO, *PALL_STREAM_INFO;

extern ALL_STREAM_INFO Streams[];
extern const ULONG NumStreams;

extern KSDATAFORMAT StreamFormatVideoPort;
extern KSDATAFORMAT StreamFormatVideoPortVBI;

extern GUID MY_KSEVENTSETID_VPNOTIFY;
extern GUID MY_KSEVENTSETID_VPVBINOTIFY;

extern KSTOPOLOGY Topology;

BOOL AdapterVerifyFormat(PKSDATAFORMAT, int);
BOOL AdapterCompareGUIDsAndFormatSize(IN PKSDATARANGE DataRange1,
										IN PKSDATARANGE DataRange2,
										BOOL fCompareFormatSize);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\crossbar\atixbar\atixbar.h ===
//==========================================================================;
//
//	ATIXBar.H
//	WDM Analog/Video CrossBar MiniDriver. 
//		AllInWonder/AllInWonderPro hardware platform. 
//			Main Include Module.
//  Copyright (c) 1996 - 1997  ATI Technologies Inc.  All Rights Reserved.
//
//==========================================================================;

#ifndef _ATIXBAR_H_
#define _ATIXBAR_H_

#include "wdmxbar.h"
#include "pinmedia.h"

typedef struct
{
	CI2CScript		CScript;
	CWDMAVXBar		CAVXBar;

	PDEVICE_OBJECT	PhysicalDeviceObject;

	// for managing SRB Queue and internal driver synchronization
	BOOL			bSrbInProcess;
	LIST_ENTRY		adapterSrbQueueHead;
	KSPIN_LOCK		adapterSpinLock;

} ADAPTER_DATA_EXTENSION, * PADAPTER_DATA_EXTENSION;


typedef struct
{
	// please, don't move this member from its first place in the structure
	// if you do, change the code to use FIELDOFFSET macro to retrieve pSrb
	// member offset within this structure. The code as it's written assumes
	// LIST_ENTRY * == SRB_DATA_EXTENSION *
	LIST_ENTRY					srbListEntry;
	PHW_STREAM_REQUEST_BLOCK	pSrb;

} SRB_DATA_EXTENSION, * PSRB_DATA_EXTENSION;


/*
	Call-backs from the StreamClass
*/
extern "C"
void STREAMAPI XBarReceivePacket				( PHW_STREAM_REQUEST_BLOCK pSrb);
extern "C"
void STREAMAPI XBarCancelPacket					( PHW_STREAM_REQUEST_BLOCK pSrb);
extern "C" 
void STREAMAPI XBarTimeoutPacket				( PHW_STREAM_REQUEST_BLOCK pSrb);



/*
	Local prototypes
*/
void XBarAdapterInitialize						( PHW_STREAM_REQUEST_BLOCK pSrb);


#endif	// _ATIXBAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\crossbar\atixbar\wdmxbar.cpp ===
//==========================================================================;
//
//	WDMXBar.CPP
//	WDM Audio/Video CrossBar MiniDriver. 
//		AIW Hardware platform. 
//			CWDMAVXBar class implementation.
//  Copyright (c) 1996 - 1997  ATI Technologies Inc.  All Rights Reserved.
//
//==========================================================================;

extern "C"
{
#include "strmini.h"
#include "ksmedia.h"

#include "wdmdebug.h"
}

#include "atixbar.h"
#include "wdmdrv.h"
#include "aticonfg.h"



/*^^*
 *		AdapterCompleteInitialization()
 * Purpose	: Called when SRB_COMPLETE_INITIALIZATION SRB is received.
 *
 * Inputs	:	PHW_STREAM_REQUEST_BLOCK pSrb	: pointer to the current Srb
 *
 * Outputs	: BOOL : returns TRUE
 * Author	: IKLEBANOV
 *^^*/
NTSTATUS CWDMAVXBar::AdapterCompleteInitialization( PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PADAPTER_DATA_EXTENSION pPrivateData = ( PADAPTER_DATA_EXTENSION)( pSrb->HwDeviceExtension);
	NTSTATUS				ntStatus;
	ULONG					nPinsNumber;

	nPinsNumber = m_nNumberOfVideoInputs + m_nNumberOfAudioInputs +
		m_nNumberOfVideoOutputs + m_nNumberOfAudioOutputs;

	ENSURE
	{
		ntStatus = StreamClassRegisterFilterWithNoKSPins( \
						pPrivateData->PhysicalDeviceObject,		// IN PDEVICE_OBJECT   DeviceObject,
						&KSCATEGORY_CROSSBAR,					// IN GUID           * InterfaceClassGUID
						nPinsNumber,							// IN ULONG            PinCount,
						m_pXBarPinsDirectionInfo,				// IN ULONG          * Flags,
						m_pXBarPinsMediumInfo,					// IN KSPIN_MEDIUM   * MediumList,
						NULL);									// IN GUID           * CategoryList

		if( !NT_SUCCESS( ntStatus))
			FAIL;

		OutputDebugTrace(( "CWDMAVXBar:AdapterCompleteInitialization() exit\n"));

	} END_ENSURE;

	if( !NT_SUCCESS( ntStatus))
		OutputDebugError(( "CWDMAVXBar:AdapterCompleteInitialization() ntStatus=%x\n", ntStatus));

	return( ntStatus);
}



/*^^*
 *		AdapterUnInitialize()
 * Purpose	: Called when SRB_UNINITIALIZE_DEVICE SRB is received.
 *
 * Inputs	:	PHW_STREAM_REQUEST_BLOCK pSrb	: pointer to the current Srb
 *
 * Outputs	: BOOL : returns TRUE
 * Author	: IKLEBANOV
 *^^*/
BOOL CWDMAVXBar::AdapterUnInitialize( PHW_STREAM_REQUEST_BLOCK pSrb)
{

	OutputDebugTrace(( "CWDMAVXBar:AdapterUnInitialize()\n"));

	if( m_pXBarInputPinsInfo != NULL)
	{
		::ExFreePool( m_pXBarInputPinsInfo);
		m_pXBarInputPinsInfo = NULL;
	}

	if( m_pXBarPinsMediumInfo != NULL)
	{
		::ExFreePool( m_pXBarPinsMediumInfo);
		m_pXBarPinsMediumInfo = NULL;
	}

	if( m_pXBarPinsDirectionInfo != NULL)
	{
		::ExFreePool( m_pXBarPinsDirectionInfo);
		m_pXBarPinsDirectionInfo = NULL;
	}

	pSrb->Status = STATUS_SUCCESS;

	return( TRUE);
}


/*^^*
 *		AdapterGetStreamInfo()
 * Purpose	: Calles during StreamClass initialization procedure to get the information
 *				about data streams exposed by the MiniDriver
 *
 * Inputs	:	PHW_STREAM_REQUEST_BLOCK pSrb	: pointer to the current Srb
 *
 * Outputs	: BOOL : returns TRUE
 * Author	: IKLEBANOV
 *^^*/
BOOL CWDMAVXBar::AdapterGetStreamInfo( PHW_STREAM_REQUEST_BLOCK pSrb)
{
     // pick up the pointer to the stream header data structure
	PHW_STREAM_HEADER pStreamHeader = ( PHW_STREAM_HEADER) \
										&( pSrb->CommandData.StreamBuffer->StreamHeader);
     // pick up the pointer to the stream information data structure
	PHW_STREAM_INFORMATION pStreamInfo = ( PHW_STREAM_INFORMATION) \
										&( pSrb->CommandData.StreamBuffer->StreamInfo);

	// no streams are supported
    DEBUG_ASSERT( pSrb->NumberOfBytesToTransfer >= sizeof( HW_STREAM_HEADER));

	OutputDebugTrace(( "CWDMAVXBar:AdapterGetStreamInfo()\n"));

	m_wdmAVXBarStreamHeader.NumberOfStreams = 0;
	m_wdmAVXBarStreamHeader.SizeOfHwStreamInformation = sizeof( HW_STREAM_INFORMATION);
	m_wdmAVXBarStreamHeader.NumDevPropArrayEntries = KSPROPERTIES_AVXBAR_NUMBER_SET;
	m_wdmAVXBarStreamHeader.DevicePropertiesArray = m_wdmAVXBarPropertySet;
	m_wdmAVXBarStreamHeader.NumDevEventArrayEntries = 0;
	m_wdmAVXBarStreamHeader.DeviceEventsArray = NULL;
	m_wdmAVXBarStreamHeader.Topology = &m_wdmAVXBarTopology;

	* pStreamHeader = m_wdmAVXBarStreamHeader;

	pSrb->Status = STATUS_SUCCESS;
	return( TRUE);
}


/*^^*
 *		AdapterQueryUnload()
 * Purpose	: Called when the class driver is about to unload the MiniDriver
 *				The MiniDriver checks if any open stream left.
 *
 * Inputs	:	PHW_STREAM_REQUEST_BLOCK pSrb	: pointer to the current Srb
 *
 * Outputs	: BOOL : returns TRUE
 * Author	: IKLEBANOV
 *^^*/
BOOL CWDMAVXBar::AdapterQueryUnload( PHW_STREAM_REQUEST_BLOCK pSrb)
{

	OutputDebugTrace(( "CWDMAVXBar:AdapterQueryUnload()\n"));

	pSrb->Status = STATUS_SUCCESS;

	return( TRUE);
}



/*^^*
 *		operator new
 * Purpose	: CWDMAVXBar class overloaded operator new.
 *				Provides placement for a CWDMAVXBar class object from the PADAPTER_DEVICE_EXTENSION
 *				allocated by the StreamClassDriver for the MiniDriver.
 *
 * Inputs	:	UINT size_t			: size of the object to be placed
 *				PVOID pAllocation	: casted pointer to the CWDMAVXBar allocated data
 *
 * Outputs	: PVOID : pointer of the CWDMAVXBar class object
 * Author	: IKLEBANOV
 *^^*/
PVOID CWDMAVXBar::operator new( size_t size_t,  PVOID pAllocation)
{

	if( size_t != sizeof( CWDMAVXBar))
	{
		OutputDebugTrace(( "CWDMAVXBar: operator new() fails\n"));
		return( NULL);
	}
	else
		return( pAllocation);
}



/*^^*
 *		~CWDMAVXBar()
 * Purpose	: CWDMAVXBar class destructor.
 *				Frees the allocated memory.
 *
 * Inputs	: none
 *
 * Outputs	: none
 * Author	: IKLEBANOV
 *^^*/
CWDMAVXBar::~CWDMAVXBar()
{

	OutputDebugTrace(( "CWDMAVXBar:~CWDMAVXBar() m_pXBarPinsInfo = %x\n", m_pXBarInputPinsInfo));

	if( m_pXBarInputPinsInfo != NULL)
	{
		::ExFreePool( m_pXBarInputPinsInfo);
		m_pXBarInputPinsInfo = NULL;
	}
	
	if( m_pXBarPinsMediumInfo != NULL)
	{
		::ExFreePool( m_pXBarPinsMediumInfo);
		m_pXBarPinsMediumInfo = NULL;
	}

	if( m_pXBarPinsDirectionInfo != NULL)
	{
		::ExFreePool( m_pXBarPinsDirectionInfo);
		m_pXBarPinsDirectionInfo = NULL;
	}
}



/*^^*
 *		CWDMAVXBar()
 * Purpose	: CWDMAVXBar class constructor.
 *				Performs checking of the hardware presence. Sets the hardware in an initial state.
 *
 * Inputs	:	CI2CScript * pCScript	: pointer to the I2CScript class object
 *				PUINT puiError			: pointer to return a completion error code
 *
 * Outputs	: none
 * Author	: IKLEBANOV
 *^^*/
CWDMAVXBar::CWDMAVXBar( PDEVICE_OBJECT pDeviceObject, CI2CScript * pCScript, PUINT puiErrorCode)
	:m_CATIConfiguration( pDeviceObject, pCScript, puiErrorCode)
{
	UINT	uiError;
	ULONG	ulInstance;
	HANDLE	hFolder = NULL;

	OutputDebugTrace(( "CWDMAVXBar:CWDMAVXBar() enter\n"));

	m_pXBarInputPinsInfo = m_pXBarOutputPinsInfo = NULL;
	m_pXBarPinsMediumInfo = NULL;
	m_pXBarPinsDirectionInfo = NULL;
	m_ulPowerState = PowerDeviceD0;

	// error code was caried over from ATIConfiguration class constructor
	uiError = * puiErrorCode;

	ENSURE
	{
		ULONG					ulNumberOfPins, nPinIndex;
		UINT					uiTunerId, nIndex;
		UCHAR					uchTunerAddress;
		KSPIN_MEDIUM			mediumKSPin;
		const KSPIN_MEDIUM *	pMediumKSPin;

		if( uiError != WDMMINI_NOERROR)
			FAIL;

		if( pCScript == NULL)
		{
			uiError = WDMMINI_INVALIDPARAM;
			FAIL;
		}

		// first, find out whether any tuner type is installed. If not, we have only 2 video sources.
		m_CATIConfiguration.GetTunerConfiguration( &uiTunerId, &uchTunerAddress);
		m_nNumberOfVideoInputs = ( uchTunerAddress) ? 3 : 2;
		m_nNumberOfVideoOutputs = m_nNumberOfVideoInputs;

		m_CATIConfiguration.GetAudioProperties( &m_nNumberOfAudioInputs, &m_nNumberOfAudioOutputs);
		if( !uchTunerAddress)
			// if there is no tuner - no TVAudio input
			m_nNumberOfAudioInputs --;	

		ulNumberOfPins = m_nNumberOfAudioInputs + m_nNumberOfVideoInputs + m_nNumberOfVideoOutputs + m_nNumberOfAudioOutputs;
		m_pXBarInputPinsInfo = ( PXBAR_PIN_INFORMATION) \
			::ExAllocatePool( NonPagedPool, sizeof( XBAR_PIN_INFORMATION) * ulNumberOfPins);
		if( m_pXBarInputPinsInfo == NULL)
		{
			uiError = WDMMINI_ERROR_MEMORYALLOCATION;
			FAIL;
		}

		m_pXBarPinsMediumInfo = ( PKSPIN_MEDIUM) \
			::ExAllocatePool( NonPagedPool, sizeof( KSPIN_MEDIUM) * ulNumberOfPins);
		if( m_pXBarPinsMediumInfo == NULL)
		{
			uiError = WDMMINI_ERROR_MEMORYALLOCATION;
			FAIL;
		}
		
		m_pXBarPinsDirectionInfo = ( PBOOL) \
			::ExAllocatePool( NonPagedPool, sizeof( BOOL) * ulNumberOfPins);
		if( m_pXBarPinsDirectionInfo == NULL)
		{
			uiError = WDMMINI_ERROR_MEMORYALLOCATION;
			FAIL;
		}

		m_pI2CScript = pCScript;

		m_pXBarOutputPinsInfo = &m_pXBarInputPinsInfo[m_nNumberOfAudioInputs + m_nNumberOfVideoInputs];

		// Medium pin data has an Instance number inside
		ulInstance = ::GetDriverInstanceNumber( pDeviceObject);

		hFolder = ::OpenRegistryFolder( pDeviceObject, &UNICODE_WDM_REG_PIN_MEDIUMS);
		
		// initialize video input pins, TVTuner input is always the last one
		for( nIndex = 0; nIndex < m_nNumberOfVideoInputs; nIndex ++)
		{
			switch( nIndex)
			{
				case 0:
					// Composite
					m_pXBarInputPinsInfo[nIndex].AudioVideoPinType = KS_PhysConn_Video_Composite;
					// put the default value for the Medium first
					::RtlCopyMemory( &m_pXBarPinsMediumInfo[nIndex], &MEDIUM_WILDCARD, sizeof( KSPIN_MEDIUM));
					// LineIn is always the first audio pin
					m_pXBarInputPinsInfo[nIndex].nRelatedPinNumber = m_nNumberOfVideoInputs;
					break;

				case 1:
					// SVideo
					m_pXBarInputPinsInfo[nIndex].AudioVideoPinType = KS_PhysConn_Video_SVideo;
					// put the default value for the Medium first
					::RtlCopyMemory( &m_pXBarPinsMediumInfo[nIndex], &MEDIUM_WILDCARD, sizeof( KSPIN_MEDIUM));
					// LineIn is always the first audio pin
					m_pXBarInputPinsInfo[nIndex].nRelatedPinNumber = m_nNumberOfVideoInputs;
					break;

				case 2:
					// TVTuner
					m_pXBarInputPinsInfo[nIndex].AudioVideoPinType = KS_PhysConn_Video_Tuner;
					// put the default value for the Medium first
					::RtlCopyMemory( &m_pXBarPinsMediumInfo[nIndex], &ATIXBarVideoTunerInMedium, sizeof( KSPIN_MEDIUM));
					// TVAudio is always the last audio pin
					m_pXBarInputPinsInfo[nIndex].nRelatedPinNumber = m_nNumberOfVideoInputs + m_nNumberOfAudioInputs - 1;
					break;

				default:
					TRAP;
					break;
			}

			// let's put another Medium value from the registry, if present
			if( ::ReadPinMediumFromRegistryFolder( hFolder, nIndex, &mediumKSPin))
				::RtlCopyMemory( &m_pXBarPinsMediumInfo[nIndex], &mediumKSPin, sizeof( KSPIN_MEDIUM));
			m_pXBarInputPinsInfo[nIndex].pMedium = &m_pXBarPinsMediumInfo[nIndex];
			m_pXBarPinsMediumInfo[nIndex].Id = ulInstance;
			// all the pins here are inputs
			m_pXBarPinsDirectionInfo[nIndex] = FALSE;	
		}

		// initialize audio input pins, TV Audio input is always the last one
		for( nIndex = 0; nIndex < m_nNumberOfAudioInputs; nIndex ++)
		{
			nPinIndex = nIndex + m_nNumberOfVideoInputs;

			switch( nIndex)
			{
				case 0:
					m_pXBarInputPinsInfo[nPinIndex].AudioVideoPinType = KS_PhysConn_Audio_Line;
					// put the default value for the Medium first
					::RtlCopyMemory( &m_pXBarPinsMediumInfo[nPinIndex], &MEDIUM_WILDCARD, sizeof( KSPIN_MEDIUM));
					m_pXBarInputPinsInfo[nPinIndex].nRelatedPinNumber = 0;
					break;


				case 1:
					m_pXBarInputPinsInfo[nPinIndex].AudioVideoPinType = KS_PhysConn_Audio_Tuner;
					// put the default value for the Medium first
					::RtlCopyMemory( &m_pXBarPinsMediumInfo[nPinIndex], &ATIXBarAudioTunerInMedium, sizeof( KSPIN_MEDIUM));
					m_pXBarInputPinsInfo[nPinIndex].nRelatedPinNumber = m_nNumberOfVideoInputs - 1;
					break;

				default:
					TRAP;
					break;
			}

			// let's put another Medium value from the registry, if present
			if( ::ReadPinMediumFromRegistryFolder( hFolder, nPinIndex, &mediumKSPin))
				::RtlCopyMemory( &m_pXBarPinsMediumInfo[nPinIndex], &mediumKSPin, sizeof( KSPIN_MEDIUM));
			m_pXBarInputPinsInfo[nPinIndex].pMedium = &m_pXBarPinsMediumInfo[nPinIndex];
			m_pXBarPinsMediumInfo[nPinIndex].Id = ulInstance;
			// all the pins here are inputs
			m_pXBarPinsDirectionInfo[nPinIndex] = FALSE;
		}

		// initialize outputs video pins, no X-connection for Video
		for( nIndex = 0; nIndex < m_nNumberOfVideoOutputs; nIndex ++)
		{
			nPinIndex = nIndex + m_nNumberOfVideoInputs + m_nNumberOfAudioInputs;
			m_pXBarOutputPinsInfo[nIndex].AudioVideoPinType = m_pXBarInputPinsInfo[nIndex].AudioVideoPinType;
			m_pXBarOutputPinsInfo[nIndex].nConnectedToPin = nIndex;
         m_pXBarOutputPinsInfo[nIndex].nRelatedPinNumber = m_nNumberOfVideoOutputs; // jaybo

			switch( m_pXBarOutputPinsInfo[nIndex].AudioVideoPinType)
			{
				case KS_PhysConn_Video_Tuner:
					pMediumKSPin = &ATIXBarVideoTunerOutMedium;
					break;

				case KS_PhysConn_Video_SVideo:
					pMediumKSPin = &ATIXBarVideoSVideoOutMedium;
					break;

				case KS_PhysConn_Video_Composite:
					pMediumKSPin = &ATIXBarVideoCompositeOutMedium;
					break;

				default:
					pMediumKSPin = &MEDIUM_WILDCARD;
					break;
			}
			
			::RtlCopyMemory( &m_pXBarPinsMediumInfo[nPinIndex], pMediumKSPin, sizeof( KSPIN_MEDIUM));

			// let's put another Medium value from the registry, if present
			if( ::ReadPinMediumFromRegistryFolder( hFolder, nPinIndex, &mediumKSPin))
				::RtlCopyMemory( &m_pXBarPinsMediumInfo[nPinIndex], &mediumKSPin, sizeof( KSPIN_MEDIUM));

			m_pXBarOutputPinsInfo[nIndex].pMedium = &m_pXBarPinsMediumInfo[nPinIndex];
			m_pXBarPinsMediumInfo[nPinIndex].Id = ulInstance;
			// all the pins here are outputs
			m_pXBarPinsDirectionInfo[nPinIndex] = TRUE;
		}

		// initialize outputs audio pins
		for( nIndex = 0; nIndex < m_nNumberOfAudioOutputs; nIndex ++)
		{
			nPinIndex = nIndex + m_nNumberOfVideoInputs + m_nNumberOfAudioInputs + m_nNumberOfVideoOutputs;

			m_pXBarOutputPinsInfo[nIndex + m_nNumberOfVideoInputs].AudioVideoPinType = KS_PhysConn_Audio_AudioDecoder;

			// put the default value for the Medium first
/*	jaybo
			::RtlCopyMemory( &m_pXBarPinsMediumInfo[nPinIndex], ATIXBarAudioDecoderOutMedium, sizeof( KSPIN_MEDIUM));
*/
			::RtlCopyMemory( &m_pXBarPinsMediumInfo[nPinIndex], &MEDIUM_WILDCARD, sizeof( KSPIN_MEDIUM));
			// let's put another Medium value from the registry, if present
			if( ::ReadPinMediumFromRegistryFolder( hFolder, nPinIndex, &mediumKSPin))
				::RtlCopyMemory( &m_pXBarPinsMediumInfo[nPinIndex], &mediumKSPin, sizeof( KSPIN_MEDIUM));

			m_pXBarOutputPinsInfo[nIndex + m_nNumberOfVideoInputs].nConnectedToPin = ( ULONG)-1;
            m_pXBarOutputPinsInfo[nIndex + m_nNumberOfVideoInputs].nRelatedPinNumber = (ULONG)-1;
			m_pXBarOutputPinsInfo[nIndex + m_nNumberOfVideoInputs].pMedium = &m_pXBarPinsMediumInfo[nPinIndex];
			m_pXBarPinsMediumInfo[nPinIndex].Id = ulInstance;
			// all the pins here are outputs
			m_pXBarPinsDirectionInfo[nPinIndex] = TRUE;

		}

		if( hFolder != NULL)
			::ZwClose( hFolder);

		// mute the audio as the default power-up behaviour
		m_CATIConfiguration.ConnectAudioSource( m_pI2CScript, AUDIOSOURCE_MUTE);

		// these two functions has to be called after the CWDMAVXBar class object was build on
		// on the stack and copied over into the DeviceExtension
		// This commant was true for the case, where the class object was build on the stack first.
		// There is an overloaded operator new provided for this class, and we can call it from here
		SetWDMAVXBarKSProperties();
		SetWDMAVXBarKSTopology();

		// Set run-time WDM properties at the last

		 * puiErrorCode = WDMMINI_NOERROR;
		 OutputDebugTrace(( "CWDMAVXBar:CWDMAVXBar() exit\n"));

		return;

	} END_ENSURE;

	* puiErrorCode = uiError;
    OutputDebugError(( "CWDMAVXBar:CWDMAVXBar() Error = %x\n", uiError));
}



/*^^*
 *		AdapterSetPowerState()
 * Purpose	: Sets Power Management state for deviec
 *
 * Inputs	:	PHW_STREAM_REQUEST_BLOCK pSrb	: pointer to the current Srb
 *
 * Outputs	: NTSTATUS as the operation result
 * Author	: TOM
 *^^*/
NTSTATUS CWDMAVXBar::AdapterSetPowerState( PHW_STREAM_REQUEST_BLOCK pSrb)
{
	ULONG				nAudioSource;
	ULONG				nInputPin;
	NTSTATUS			ntStatus;
	UINT				nIndex;
    DEVICE_POWER_STATE	nDeviceState = pSrb->CommandData.DeviceState;

	ntStatus = STATUS_ADAPTER_HARDWARE_ERROR;

	switch( nDeviceState)
	{
		case PowerDeviceD0:
		case PowerDeviceD3:
			if( nDeviceState != m_ulPowerState)
			{
				// if transition form D3 to D0 we have to restore audio connections
				if(( nDeviceState == PowerDeviceD0) && ( m_ulPowerState == PowerDeviceD3))
				{
					for( nIndex = 0; nIndex < m_nNumberOfAudioOutputs; nIndex ++)
					{
						// we need to restore every audio output pin connection,
						// video output pins are hardwired 
						nInputPin = m_pXBarOutputPinsInfo[nIndex + m_nNumberOfVideoOutputs].nConnectedToPin;

						switch( m_pXBarInputPinsInfo[nInputPin].AudioVideoPinType)
						{
							case KS_PhysConn_Audio_Line:
								nAudioSource = AUDIOSOURCE_LINEIN;
								break;

							case KS_PhysConn_Audio_Tuner:
								nAudioSource = AUDIOSOURCE_TVAUDIO;
								break;

							case 0xFFFFFFFF:
								nAudioSource = AUDIOSOURCE_MUTE;
								return( STATUS_SUCCESS);

							default:
								OutputDebugError(( "CWDMAVXBar:AdapterSetPowerState() Audio Pin type=%x\n", m_pXBarInputPinsInfo[nInputPin].AudioVideoPinType));
								return STATUS_SUCCESS;
						}

						if( m_CATIConfiguration.ConnectAudioSource( m_pI2CScript, nAudioSource))
							ntStatus = STATUS_SUCCESS;
						else
						{
							// error
							ntStatus = STATUS_ADAPTER_HARDWARE_ERROR;
							break;
						}
					}
				}
				else
					ntStatus = STATUS_SUCCESS;
				}
			else
				ntStatus = STATUS_SUCCESS;

			m_ulPowerState = nDeviceState;
			break;

		case PowerDeviceUnspecified:
		case PowerDeviceD1:
		case PowerDeviceD2:
			ntStatus = STATUS_SUCCESS;
			break;

		default:
			ntStatus = STATUS_INVALID_PARAMETER;
			break;
	}

	return( ntStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\crossbar\atixbar\atixbar.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//	ATIXBar.CPP
//	WDM Video/Audio CrossBar MiniDriver. 
//		AllInWonder/AllInWonderPro hardware platform.
//			Main Source Module.
//==========================================================================;

extern "C"
{
#include "strmini.h"
#include "ksmedia.h"

#include "wdmdebug.h"
}

#include "atixbar.h"
#include "wdmdrv.h"



/*^^*
 *		DriverEntry()
 * Purpose	: Called when an SRB_INITIALIZE_DEVICE request is received
 *
 * Inputs	: PVOID Arg1, PVOID Arg2
 *
 * Outputs	: result of StreamClassregisterAdapter()
 * Author	: IKLEBANOV
 *^^*/
extern "C" 
ULONG DriverEntry (	IN PDRIVER_OBJECT	pDriverObject,
					IN PUNICODE_STRING	pRegistryPath )
//ULONG DriverEntry( PVOID Arg1, PVOID Arg2)
{
	HW_INITIALIZATION_DATA HwInitData;

	SetMiniDriverDebugLevel( pRegistryPath);
	
 	OutputDebugTrace(( "ATIXBar: DriverEntry\n"));
     
	RtlZeroMemory( &HwInitData, sizeof( HwInitData));

	HwInitData.HwInitializationDataSize = sizeof(HwInitData);

	// Entry points for Port Driver

	HwInitData.HwInterrupt					= NULL; // HwInterrupt;

	HwInitData.HwReceivePacket				= XBarReceivePacket;
	HwInitData.HwCancelPacket				= XBarCancelPacket;
	HwInitData.HwRequestTimeoutHandler		= XBarTimeoutPacket;

	HwInitData.DeviceExtensionSize			= sizeof( ADAPTER_DATA_EXTENSION);
	HwInitData.PerRequestExtensionSize		= sizeof( SRB_DATA_EXTENSION); 
	HwInitData.FilterInstanceExtensionSize	= 0;
	HwInitData.PerStreamExtensionSize		= 0;
	HwInitData.BusMasterDMA					= FALSE;  
	HwInitData.Dma24BitAddresses			= FALSE;
	HwInitData.BufferAlignment				= 3;
//	HwInitData.TurnOffSynchronization		= FALSE;
	// we turn the synchronization ON. StreamClass is expected to call the MiniDriver
	// at passive level only
	HwInitData.TurnOffSynchronization		= TRUE;
	HwInitData.DmaBufferSize				= 0;

	OutputDebugTrace(( "ATIXBar: StreamClassRegisterAdapter\n"));

//	return( StreamClassRegisterAdapter( Arg1, Arg2, &HwInitData));
	return( StreamClassRegisterAdapter( pDriverObject, pRegistryPath, &HwInitData));
}



/*^^*
 *		XbarReceivePacket()
 * Purpose	: Main entry point for receiving adapter based request SRBs from the Class Driver.
 *				Will always be called at passive level, because the drivers
 *				turned the synchronization ON.
 * Note		: This is an asyncronous entry point. The request only completes when a 
 *				StreamClassDeviceNotification on this SRB, of type  DeviceRequestComplete,
 *				is issued. As soon we're running at passive level, we can do everything 
 *				synchronously during the response to the SRBs with no worry
 *				to block somebody else for a long timer during I2C access
 *
 * Inputs	: PHW_STREAM_REQUEST_BLOCK pSrb	: pointer to the current Srb
 *
 * Outputs	: none
 * Author	: IKLEBANOV
 *^^*/
extern "C" 
void STREAMAPI XBarReceivePacket( IN OUT PHW_STREAM_REQUEST_BLOCK pSrb)
{
	CWDMAVXBar *			pCAVXBar;
	KIRQL					irqlCurrent;
    PADAPTER_DATA_EXTENSION pPrivateData = ( PADAPTER_DATA_EXTENSION)( pSrb->HwDeviceExtension);
    PSRB_DATA_EXTENSION		pSrbPrivate = ( PSRB_DATA_EXTENSION)( pSrb->SRBExtension);

	// check the device extension pointer
	if(( pPrivateData == NULL) || ( pSrbPrivate == NULL))
	{
		TRAP;
		pSrb->Status = STATUS_INVALID_PARAMETER;
		StreamClassDeviceNotification( DeviceRequestComplete, pSrb->HwDeviceExtension, pSrb);
	}

    OutputDebugInfo(( "ATIXBar: XBarReceivePacket() SRB = %x\n", pSrb));

	if( pSrb->Command == SRB_INITIALIZE_DEVICE)
	{
		// this is the special case for SRB_INITIALIZE_DEVICE, because
		// no Queue has been initialized yet. Everything we need later on
		// is initialized during this SRB response
		XBarAdapterInitialize( pSrb);

		StreamClassDeviceNotification( DeviceRequestComplete, pSrb->HwDeviceExtension, pSrb);
		return;
	}

	// the rest of the SRBs are coming after SpinLock and SRBQueue have been initialized
	// during DRB_INITIALIZE_DEVICE SRB response.
	// I'll insert the SRB in the Queue first of all. The processing SRB from the Queue
	// can be triggered by finishing processing and SRB, or by the fact there is no SRB
	// is in process down here
	pSrbPrivate->pSrb = pSrb;

	// Everything we're doing with the Queue has to be protected from being interrupted
	KeAcquireSpinLock( &pPrivateData->adapterSpinLock, &irqlCurrent);
	InsertTailList( &pPrivateData->adapterSrbQueueHead, &pSrbPrivate->srbListEntry);

	if( pPrivateData->bSrbInProcess)
	{
		// there is another SRB being processed, and the new one will be picked up from
		// the Queue when it's its turn.
		KeReleaseSpinLock( &pPrivateData->adapterSpinLock, irqlCurrent);
		return;
	}

	while( !IsListEmpty( &pPrivateData->adapterSrbQueueHead))
	{
		// turn on the semaphore for the others coming after
		pPrivateData->bSrbInProcess = TRUE;

		// be carefull here, if you've changed the place where srbListEntry is defined
		// within the SRB_DATA_EXTENSION structure
		pSrbPrivate = ( PSRB_DATA_EXTENSION)RemoveHeadList( &pPrivateData->adapterSrbQueueHead);
		KeReleaseSpinLock( &pPrivateData->adapterSpinLock, irqlCurrent);

		// here is the place to process the SRB we have retrieved from the Queue
		pSrb = pSrbPrivate->pSrb;
		pPrivateData = ( PADAPTER_DATA_EXTENSION)( pSrb->HwDeviceExtension);
		pCAVXBar = &pPrivateData->CAVXBar;

		ASSERT( pSrb->Status != STATUS_CANCELLED);

	    switch( pSrb->Command)
		{
			case SRB_INITIALIZATION_COMPLETE:
				// StreamClass has completed the initialization
				pSrb->Status = pCAVXBar->AdapterCompleteInitialization( pSrb);
				break;

			case SRB_UNINITIALIZE_DEVICE:
				// close the device.  
				pCAVXBar->AdapterUnInitialize( pSrb);
				break;

			case SRB_OPEN_STREAM:
			case SRB_CLOSE_STREAM:
				pSrb->Status = STATUS_NOT_IMPLEMENTED;
				break;

			case SRB_GET_STREAM_INFO:
				// return a block describing STREAM_INFO_HEADER and all the streams supported
				pCAVXBar->AdapterGetStreamInfo( pSrb);
				break;

			case SRB_CHANGE_POWER_STATE:
				pSrb->Status = pCAVXBar->AdapterSetPowerState( pSrb);
				break;

			case SRB_GET_DEVICE_PROPERTY:
				if( pCAVXBar->AdapterGetProperty( pSrb))
					pSrb->Status = STATUS_SUCCESS;
				else
					pSrb->Status = STATUS_INVALID_PARAMETER;
				break;        

			case SRB_SET_DEVICE_PROPERTY:
				if( pCAVXBar->AdapterSetProperty( pSrb))
					pSrb->Status = STATUS_SUCCESS;
				else
					pSrb->Status = STATUS_INVALID_PARAMETER;
				break;

			// We should never get the following since this is a single instance device
			case SRB_OPEN_DEVICE_INSTANCE:
			case SRB_CLOSE_DEVICE_INSTANCE:
				TRAP
				pSrb->Status = STATUS_NOT_IMPLEMENTED;
				break;

			case SRB_UNKNOWN_DEVICE_COMMAND:
				// we know we're getting some of these. Why should we?
				pSrb->Status = STATUS_NOT_IMPLEMENTED;
				break;

			default:
				// TRAP
				// this is a request that we do not understand.  Indicate invalid command and complete the request
				pSrb->Status = STATUS_NOT_IMPLEMENTED;
		}

		StreamClassDeviceNotification( DeviceRequestComplete, pPrivateData, pSrb);

		KeAcquireSpinLock( &pPrivateData->adapterSpinLock, &irqlCurrent);
	}

	// turn off the semaphore to enable the others coming after
	pPrivateData->bSrbInProcess = FALSE;

	KeReleaseSpinLock( &pPrivateData->adapterSpinLock, irqlCurrent);
	// there is no other SRB being processed at this time, let's start processing

}


extern "C" 
void STREAMAPI XBarCancelPacket( IN OUT PHW_STREAM_REQUEST_BLOCK pSrb)
{

	pSrb->Status = STATUS_CANCELLED;
}


extern "C" 
void STREAMAPI XBarTimeoutPacket( IN OUT PHW_STREAM_REQUEST_BLOCK pSrb)
{

	// not sure what to do here.
}


/*^^*
 *		XBarAdapterInitialize()
 * Purpose	: Called when SRB_INITIALIZE_DEVICE SRB is received.
 *				Performs checking of the hardware presence and I2C provider availability.
 *				Sets the hardware in an initial state.
 * Note		: The request does not completed unless we know everything
 *				about the hardware and we are sure it is capable to work in the current configuration.
 *				The hardware Caps are also aquised at this point. As soon this
 *				function is called at passive level, do everything synchronously
 *
 * Inputs	: PHW_STREAM_REQUEST_BLOCK pSrb	: pointer to the current Srb
 *
 * Outputs	: none
 * Author	: IKLEBANOV
 *^^*/
void XBarAdapterInitialize( IN OUT PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PPORT_CONFIGURATION_INFORMATION pConfigInfo = pSrb->CommandData.ConfigInfo;
    PADAPTER_DATA_EXTENSION pPrivateData = ( PADAPTER_DATA_EXTENSION)( pConfigInfo->HwDeviceExtension);
	NTSTATUS		ntStatus = STATUS_NO_SUCH_DEVICE;
	CWDMAVXBar *	pCAVXBar;
	CI2CScript *	pCScript;
	UINT			nErrorCode;

    OutputDebugTrace(( "ATIXBar: XBarAdapterInitialize()\n"));

    ENSURE
	{
		if( pConfigInfo->NumberOfAccessRanges != 0) 
		{
			OutputDebugError(( "ATIXBar: illegal NumberOfAccessRanges = %lx\n", pConfigInfo->NumberOfAccessRanges));
			FAIL;
		}

		// if we have I2CProvider implemented inside the MiniVDD, we have to
		// get a pointer to I2CInterface from the Provider.

		// There is an overloaded operator new provided for the CI2CScript Class.
		pCScript = ( CI2CScript *)new(( PVOID)&pPrivateData->CScript)		\
						CI2CScript( pConfigInfo->PhysicalDeviceObject, &nErrorCode);
		if( nErrorCode != WDMMINI_NOERROR)
		{
			OutputDebugError(( "ATIXBar: CI2CScript creation failure = %lx\n", nErrorCode));
			FAIL;
		}
		
		// The CI2CScript object was created successfully.
		// We'll try to allocate I2CProvider here for future possible I2C
		// operations needed at Initialization time.
		if( !pCScript->LockI2CProviderEx())
		{
			OutputDebugError(( "ATIXBar: unable to lock I2CProvider"));
			FAIL;
		}

		// we did lock the provider.
		// There is an overloaded operator new provided for the CWDMAVXBar Class.
		pCAVXBar = ( CWDMAVXBar *)new(( PVOID)&pPrivateData->CAVXBar) CWDMAVXBar( pConfigInfo->PhysicalDeviceObject,pCScript, &nErrorCode);
		if( nErrorCode)
		{
			OutputDebugError(( "ATIXBar: CWDMAVXBar constructor failure = %lx\n", nErrorCode));
			FAIL;
		}

	    InitializeListHead ( &pPrivateData->adapterSrbQueueHead);
		KeInitializeSpinLock ( &pPrivateData->adapterSpinLock);

		pPrivateData->PhysicalDeviceObject = pConfigInfo->PhysicalDeviceObject;
		// no streams are supported
		pConfigInfo->StreamDescriptorSize = sizeof( HW_STREAM_HEADER);

		OutputDebugTrace(( "XBarAdapterInitialize(): exit\n"));

		ntStatus = STATUS_SUCCESS;

	} END_ENSURE;

    pCScript->ReleaseI2CProvider();

	pSrb->Status = ntStatus;
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\tuners\1236\atitunep.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//	ATITuneP.H
//	WDM Tuner MiniDriver. 
//		Philips Tuner. 
//			Main Include Module.
//
//==========================================================================;

#ifndef _ATITUNEP_H_
#define _ATITUNEP_H_

#include "wdmtuner.h"

typedef struct
{
	CI2CScript		CScript;
	CATIWDMTuner	CTuner;

	PDEVICE_OBJECT	PhysicalDeviceObject;

	// for managing SRB Queue and internal driver synchronization
	BOOL			bSrbInProcess;
	LIST_ENTRY		adapterSrbQueueHead;
	KSPIN_LOCK		adapterSpinLock;

} ADAPTER_DATA_EXTENSION, * PADAPTER_DATA_EXTENSION;


typedef struct
{
	// please, don't move this member from its first place in the structure
	// if you do, change the code to use FIELDOFFSET macro to retrieve pSrb
	// member offset within this structure. The code as it's written assumes
	// LIST_ENTRY * == SRB_DATA_EXTENSION *
	LIST_ENTRY					srbListEntry;
	PHW_STREAM_REQUEST_BLOCK	pSrb;

} SRB_DATA_EXTENSION, * PSRB_DATA_EXTENSION;


/*
	Call-backs from the StreamClass
*/
extern "C"
void STREAMAPI TunerReceivePacket				( PHW_STREAM_REQUEST_BLOCK pSrb);
extern "C"
void STREAMAPI TunerCancelPacket				( PHW_STREAM_REQUEST_BLOCK pSrb);
extern "C" 
void STREAMAPI TunerTimeoutPacket				( PHW_STREAM_REQUEST_BLOCK pSrb);



/*
	Local prototypes
*/
void TunerAdapterInitialize						( PHW_STREAM_REQUEST_BLOCK pSrb);


#endif	// _ATITUNEP_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\tuners\1236\tunerhdw.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

extern "C"
{
#include "strmini.h"
#include "ksmedia.h"

#include "wdmdebug.h"
}

#include "wdmdrv.h"
#include "atitunep.h"
#include "aticonfg.h"
#include "tunerhdw.h"


/*^^*
 *		GetTunerPLLOffsetBusyStatus()
 * Purpose	: Returns tuner Busy status and PLLOffset, if the tuner is not busy
 *				The function reads the hardware in order to accomplish the task
 *				The operation might be carried on either synchronously or asynchronously
 * Inputs	:	PLONG plPLLOffset	: a pointer to write a PLLOffset value
 *				PBOOL pbBusyStatus	: a pointer to write a Busy status
 *
 * Outputs	: BOOL : returns TRUE, if the operation succeded
 * Author	: IKLEBANOV
 *^^*/
BOOL CATIWDMTuner::GetTunerPLLOffsetBusyStatus( PLONG plPLLOffset, PBOOL pbBusyStatus)
{
	UCHAR		uchI2CValue;
	I2CPacket	i2cPacket;
	BOOL		bResult;

	i2cPacket.uchChipAddress = m_uchTunerI2CAddress;
	i2cPacket.cbReadCount = 1;
	i2cPacket.cbWriteCount = 0;
	i2cPacket.puchReadBuffer = &uchI2CValue;
	i2cPacket.puchWriteBuffer = NULL;
	i2cPacket.usFlags = 0;

	bResult = m_pI2CScript->PerformI2CPacketOperation( &i2cPacket);
	if( bResult)
		bResult = ( i2cPacket.uchI2CResult == I2C_STATUS_NOERROR);

	if( bResult)
	{
		* pbBusyStatus = !(( BOOL)( uchI2CValue & 0x40));		// bit 6 - PLL locked indicator
		if( !( * pbBusyStatus))
		{
			uchI2CValue &= 0x07;								// only 3 LSBits are PLLOffset
			// let's map the result into MS defined values from -2 to 2
			* plPLLOffset = uchI2CValue - 2;
		}
	}

	return( bResult);
}



/*^^*
 *		SetTunerMode()
 * Purpose	: Sets one of the possible Tuner modes to operate
 * Inputs	: ULONG ulModeToSet	: an operation mode required to be set
 *
 * Outputs	: BOOL : returns TRUE, if the operation succeded
 * Author	: IKLEBANOV
 *^^*/
BOOL CATIWDMTuner::SetTunerMode( ULONG ulModeToSet)
{

	return( TRUE);
}



/*^^*
 *		SetTunerVideoStandard()
 * Purpose	: Sets one of the possible Tuner standards as an active one
 * Inputs	:	ULONG ulStandard	: a standard required to be set
 *
 * Outputs	: BOOL : returns TRUE, if the operation succeded
 * Author	: IKLEBANOV
 *^^*/
BOOL CATIWDMTuner::SetTunerVideoStandard( ULONG ulStandard)
{

	return( TRUE);
}



/*^^*
 *		SetTunerFrequency()
 * Purpose	: Sets a new Tuner frequency
 *				The operation might be carried on either synchronously or asynchronously
 * Inputs	:	ULONG ulFrequency		: a frequency required to be set
 *
 * Outputs	: BOOL : returns TRUE, if the operation succeded
 * Author	: IKLEBANOV
 *^^*/
BOOL CATIWDMTuner::SetTunerFrequency( ULONG ulFrequency)
{
	ULONG		ulFrequenceDivider;
	USHORT		usControlCode;
	UCHAR		auchI2CBuffer[4];
	I2CPacket	i2cPacket;
	BOOL		bResult;

	ASSERT( m_ulIntermediateFrequency != 0L);
	
	// Set the video carrier frequency by controlling the programmable divider
	// N = ( 16 * ( FreqRF + FreqIntermediate)) / 1000000
	ulFrequenceDivider = ( ulFrequency + m_ulIntermediateFrequency);
	ulFrequenceDivider /= ( 1000000 / 16);

	usControlCode = GetTunerControlCode( ulFrequenceDivider);
	if( !usControlCode)
		return( FALSE);
	
	auchI2CBuffer[0] = ( UCHAR)( ulFrequenceDivider >> 8);
	auchI2CBuffer[1] = ( UCHAR)ulFrequenceDivider;
	auchI2CBuffer[2] = ( UCHAR)( usControlCode >> 8);
	auchI2CBuffer[3] = ( UCHAR)usControlCode;

	i2cPacket.uchChipAddress = m_uchTunerI2CAddress;
	i2cPacket.cbReadCount = 0;
	i2cPacket.cbWriteCount = 4;
	i2cPacket.puchReadBuffer = NULL;
	i2cPacket.puchWriteBuffer = auchI2CBuffer;
	i2cPacket.usFlags = 0;

	bResult = m_pI2CScript->PerformI2CPacketOperation( &i2cPacket);

	if( bResult)
		bResult = ( i2cPacket.uchI2CResult == I2C_STATUS_NOERROR) ? TRUE : FALSE;

	return( bResult);
}



/*^^*
 *		SetTunerInput()
 * Purpose	: Sets one of the possible Tuner inputs as an active one
 * Inputs	:	ULONG nInput				: input number required to be set as an active ( begins from 0)
 *
 * Outputs	: BOOL : returns TRUE, if the operation succeded
 * Author	: IKLEBANOV
 *^^*/
BOOL CATIWDMTuner::SetTunerInput( ULONG nInput)
{
	
	// no real things to do at all
	return( TRUE);
}




/*^^*
 *		GetTunerControlCode()
 * Purpose	: Determines the Tuner control code to be send to tuner with a new frequency value
 *
 * Inputs	:	ULONG ulFrequencyDivider	: new frequency divider
 *
 * Outputs	: USHORT : value, the tuner should be programmed, when the new frequency is set
 *				id the is no valid uiTunerId is passed as paramter, 0 is returned
 * Author	: IKLEBANOV
 *^^*/
USHORT CATIWDMTuner::GetTunerControlCode( ULONG ulFrequencyDivider)
{
            
	USHORT	usLowBandFrequencyHigh, usMiddleBandFrequencyHigh;
	USHORT	usLowBandControl, usMiddleBandControl, usHighBandControl;
	USHORT	usControlCode = 0;

	usLowBandFrequencyHigh 		= kUpperLowBand;
	usMiddleBandFrequencyHigh 	= kUpperMidBand;  
	usLowBandControl 			= kLowBand;
	usMiddleBandControl 		= kMidBand;
	usHighBandControl 			= kHighBand;
			
	switch( m_uiTunerId)
	{
		case 0x01 : 	// NTSC N/A
		case 0x02 :		// NTSC Japan
		case 0x06 : 	// NTSC Japan Philips MK2, PAL 
			// these tuners support NTSC standard
			if(( m_ulVideoStandard == KS_AnalogVideo_NTSC_M) &&
			   (( ulFrequencyDivider == kAirChannel63) ||
				( ulFrequencyDivider == kAirChannel64)))
			{
				// special case for TEMIC tuner
				return( kTemicControl);
			}
			break;

		case 0x08 :		// FM Tuner
			usLowBandControl	= kLowBand_NTSC_FM;
			usMiddleBandControl = kMidBand_NTSC_FM;
			usHighBandControl	= kHighBand_NTSC_FM;
			break;
			
		case 0x03 :		// PAL B/G
		case 0x04 :		// PAL I
			break;
			
		case 0x05 : 	// SECAM & PAL B/G
			if ( m_ulVideoStandard == KS_AnalogVideo_SECAM_L)
			{
				usLowBandFrequencyHigh		= kUpperLowBand_SECAM;
				usMiddleBandFrequencyHigh	= kUpperMidBand_SECAM;
				usLowBandControl			= kLowBand_SECAM;
				usMiddleBandControl			= kMidBand_SECAM;
				usHighBandControl			= kHighBand_SECAM;
			}
			else
			{
				usLowBandControl	= kLowBand_PALBG;
				usMiddleBandControl	= kMidBand_PALBG;
				usHighBandControl	= kHighBand_PALBG;
			}
			break;
			
		case 0x07 :		// PAL D China
			usLowBandFrequencyHigh		= kUpperLowBand_PALD;
			usMiddleBandFrequencyHigh	= kUpperMidBand_PALD;
			break;
			
		case 0x10:		// NTSC NA Alps Tuner
		case 0x11:
		case 0x12:
				usLowBandFrequencyHigh		= kUpperLowBand_ALPS;
				usMiddleBandFrequencyHigh	= kUpperMidBand_ALPS;
				usLowBandControl			= kLowBand_ALPS;
				usMiddleBandControl			= kMidBand_ALPS;
				usHighBandControl			= kHighBand_ALPS;
				break;

		case 0x0D:		// PAL B/G + PAL/I + PAL D + SECAM D/K
			break;

		default :
			return( usControlCode);
	}
	
	if( ulFrequencyDivider <= ( ULONG)usLowBandFrequencyHigh)
		usControlCode = usLowBandControl;
	else
	{
		if( ulFrequencyDivider <= ( ULONG)usMiddleBandFrequencyHigh)
			usControlCode = usMiddleBandControl;
		else
			usControlCode = usHighBandControl;
	}

	return( usControlCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\crossbar\atixbar\xbarprop.cpp ===
//==========================================================================;
//
//	XBarProp.CPP
//	WDM Audio/Video CrossBar MiniDriver. 
//		AIW hardware platform. 
//			WDM Properties management.
//  Copyright (c) 1996 - 1997  ATI Technologies Inc.  All Rights Reserved.
//
//==========================================================================;

extern "C"
{
#include "strmini.h"
#include "ksmedia.h"

#include "wdmdebug.h"
}

#include "wdmdrv.h"
#include "atixbar.h"
#include "aticonfg.h"




/*^^*
 *		AdapterGetProperty()
 * Purpose	: Called when SRB_GET_PROPERTY SRB is received.
 *
 * Inputs	:	PHW_STREAM_REQUEST_BLOCK pSrb	: pointer to the current Srb
 *
 * Outputs	: BOOL : returns returns FALSE, if it is not a XBar property
 *				it also returns the required property
 * Author	: IKLEBANOV
 *^^*/
BOOL CWDMAVXBar::AdapterGetProperty( PHW_STREAM_REQUEST_BLOCK pSrb)
{
	PSTREAM_PROPERTY_DESCRIPTOR pSpd = pSrb->CommandData.PropertyInfo;
	ULONG uiPropertyId = pSpd->Property->Id;				// index of the property
	ULONG nPropertyOutSize = pSpd->PropertyOutputSize;		// size of data requested

	if( !::IsEqualGUID(( const struct _GUID &)PROPSETID_VIDCAP_CROSSBAR, ( const struct _GUID &)pSpd->Property->Set))
		return( FALSE);

	ASSERT( pSpd != NULL);
	ASSERT( pSpd->PropertyInfo != NULL);
	
	OutputDebugInfo(( "CWDMAVXBar:AdapterGetProperty() Id = %d\n", uiPropertyId));

	switch( uiPropertyId)
	{
		case KSPROPERTY_CROSSBAR_CAPS:
			{
				PKSPROPERTY_CROSSBAR_CAPS_S pAVXBarCaps = ( PKSPROPERTY_CROSSBAR_CAPS_S)pSpd->PropertyInfo;

				if( nPropertyOutSize < sizeof( PKSPROPERTY_CROSSBAR_CAPS_S))
					return( FALSE);

				// Copy the input property info to the output property info
				::RtlCopyMemory( pAVXBarCaps, pSpd->Property, sizeof( PKSPROPERTY_CROSSBAR_CAPS_S));

				pAVXBarCaps->NumberOfInputs = m_nNumberOfVideoInputs + m_nNumberOfAudioInputs;
				pAVXBarCaps->NumberOfOutputs = m_nNumberOfVideoOutputs + m_nNumberOfAudioOutputs;

			}
			pSrb->ActualBytesTransferred = sizeof( KSPROPERTY_CROSSBAR_CAPS_S);
			break;

		case KSPROPERTY_CROSSBAR_PININFO:
			{
				PKSPROPERTY_CROSSBAR_PININFO_S pPinInfo = ( PKSPROPERTY_CROSSBAR_PININFO_S)pSpd->PropertyInfo;
				ULONG nPinIndex;

				if( nPropertyOutSize < sizeof( KSPROPERTY_CROSSBAR_PININFO_S))
					return( FALSE);

				// Copy the input property info to the output property info
				::RtlCopyMemory( pPinInfo, pSpd->Property, sizeof( KSPROPERTY_CROSSBAR_PININFO_S));

				nPinIndex = pPinInfo->Index;

				if( pPinInfo->Direction == KSPIN_DATAFLOW_IN)
				{
					// input pin info is required
					ASSERT( nPinIndex < m_nNumberOfVideoInputs + m_nNumberOfAudioInputs);
					pPinInfo->RelatedPinIndex = m_pXBarInputPinsInfo[nPinIndex].nRelatedPinNumber;
					pPinInfo->PinType = m_pXBarInputPinsInfo[nPinIndex].AudioVideoPinType;
					pPinInfo->Medium  = * m_pXBarInputPinsInfo[nPinIndex].pMedium;
				}
				else
				{
					// output pin info is required
					ASSERT( nPinIndex < m_nNumberOfVideoInputs + m_nNumberOfAudioInputs);
					pPinInfo->RelatedPinIndex = m_pXBarOutputPinsInfo[nPinIndex].nRelatedPinNumber;
					pPinInfo->PinType = m_pXBarOutputPinsInfo[nPinIndex].AudioVideoPinType;
					pPinInfo->Medium  = * m_pXBarOutputPinsInfo[nPinIndex].pMedium;
				}

			}
			pSrb->ActualBytesTransferred = sizeof( KSPROPERTY_CROSSBAR_PININFO_S);
			break;

		case KSPROPERTY_CROSSBAR_CAN_ROUTE:
			{
				PKSPROPERTY_CROSSBAR_ROUTE_S pRouteInfo = ( PKSPROPERTY_CROSSBAR_ROUTE_S)pSpd->PropertyInfo;
				ULONG nInputPin, nOutputPin;
				int nAudioSource;

				if( nPropertyOutSize < sizeof( KSPROPERTY_CROSSBAR_ROUTE_S))
					return( FALSE);

				// Copy the input property info to the output property info
				::RtlCopyMemory( pRouteInfo, pSpd->Property, sizeof( KSPROPERTY_CROSSBAR_ROUTE_S));

				nInputPin = pRouteInfo->IndexInputPin;
				nOutputPin = pRouteInfo->IndexOutputPin;

				if( nInputPin != -1)
				{
					if(( nInputPin < ( m_nNumberOfVideoInputs + m_nNumberOfAudioInputs)) && 
						( nOutputPin < ( m_nNumberOfVideoOutputs + m_nNumberOfAudioOutputs)))
					{
						// both input and output pins index are valid
						if(( m_pXBarInputPinsInfo[nInputPin].AudioVideoPinType <= KS_PhysConn_Video_SCART) &&
							( m_pXBarOutputPinsInfo[nOutputPin].AudioVideoPinType <= KS_PhysConn_Video_SCART))
							// Video pins connection is required
							pRouteInfo->CanRoute = ( m_pXBarInputPinsInfo[nInputPin].AudioVideoPinType ==
								m_pXBarOutputPinsInfo[nOutputPin].AudioVideoPinType);
						else	// is video pins connection required?
						{
							if(( m_pXBarInputPinsInfo[nInputPin].AudioVideoPinType >= KS_PhysConn_Audio_Tuner) && 
								( m_pXBarOutputPinsInfo[nOutputPin].AudioVideoPinType >= KS_PhysConn_Audio_Tuner))
							{
									// Audio pins connection is required
								switch( m_pXBarInputPinsInfo[nInputPin].AudioVideoPinType)
								{
									case KS_PhysConn_Audio_Line:
										nAudioSource = AUDIOSOURCE_LINEIN;
										break;

									case KS_PhysConn_Audio_Tuner:
										nAudioSource = AUDIOSOURCE_TVAUDIO;
										break;

									default:
										TRAP;
										return( FALSE);
								}

								pRouteInfo->CanRoute = m_CATIConfiguration.CanConnectAudioSource( nAudioSource);
							}
							else
								// mixed video - audio connection is required
								pRouteInfo->CanRoute = FALSE;
						}
					}
					else	// are the pins index valid?
					{
						// either input and output pins index is invalid
						TRAP;
						OutputDebugError(( "CWDMAVXBar:Get...CAN_ROUTE() InPin = %d, OutPin = %d\n",
							nInputPin, nOutputPin));
						return( FALSE);
					}
				}
				else	// if( nInputPin != -1)
				{
					// There is a new notion of nInputPin = -1. It's valid only for Audio muting
					if( nOutputPin < ( m_nNumberOfVideoOutputs + m_nNumberOfAudioOutputs))
					{
						if( m_pXBarOutputPinsInfo[nOutputPin].AudioVideoPinType >= KS_PhysConn_Audio_Tuner)
							pRouteInfo->CanRoute = m_CATIConfiguration.CanConnectAudioSource( AUDIOSOURCE_MUTE);
						else
							// we support muting for Audio output pin only
							pRouteInfo->CanRoute = FALSE;
					}
					else
					{
						// output pin index is invalid
						TRAP;
						OutputDebugError(( "CWDMAVXBar:Get...CAN_ROUTE() InPin = %d, OutPin = %d\n",
							nInputPin, nOutputPin));
						return( FALSE);
					}
				}
			}
			pSrb->ActualBytesTransferred = sizeof( KSPROPERTY_CROSSBAR_ROUTE_S);
			break;

		case KSPROPERTY_CROSSBAR_ROUTE:
			{
				PKSPROPERTY_CROSSBAR_ROUTE_S pRouteInfo = ( PKSPROPERTY_CROSSBAR_ROUTE_S)pSpd->PropertyInfo;
				ULONG nOutputPin;

				if( nPropertyOutSize < sizeof( KSPROPERTY_CROSSBAR_ROUTE_S))
					return( FALSE);

				// Copy the input property info to the output property info
				::RtlCopyMemory( pRouteInfo, pSpd->Property, sizeof( KSPROPERTY_CROSSBAR_ROUTE_S));

				nOutputPin = pRouteInfo->IndexOutputPin;

				if( nOutputPin < m_nNumberOfVideoOutputs + m_nNumberOfAudioOutputs)
					pRouteInfo->IndexInputPin = m_pXBarOutputPinsInfo[nOutputPin].nConnectedToPin;
				else
				{
					TRAP;
					OutputDebugError(( "CWDMAVXBar:Get...ROUTE() OutPin = %d\n",
						nOutputPin));
					pRouteInfo->IndexInputPin = -1;
				}
			}
			pSrb->ActualBytesTransferred = sizeof( KSPROPERTY_CROSSBAR_ROUTE_S);
			break;

		default:
			TRAP;
			return( FALSE);
	}

	return( TRUE);
}



/*^^*
 *		AdapterSetProperty()
 * Purpose	: Called when SRB_GET_PROPERTY SRB is received.
 *
 * Inputs	:	PHW_STREAM_REQUEST_BLOCK pSrb	: pointer to the current Srb
 *
 * Outputs	: BOOL : returns FALSE, if it is not a XBar property
 *				it also sets the required property
 * Author	: IKLEBANOV
 *^^*/
BOOL CWDMAVXBar::AdapterSetProperty( PHW_STREAM_REQUEST_BLOCK pSrb)
{
	PSTREAM_PROPERTY_DESCRIPTOR pSpd = pSrb->CommandData.PropertyInfo;
	ULONG	uiPropertyId = pSpd->Property->Id;			// index of the property
	ULONG	nPropertyInSize = pSpd->PropertyOutputSize;	// size of data supplied
	BOOL	bResult = TRUE;

	if( !::IsEqualGUID( ( const struct _GUID &)PROPSETID_VIDCAP_CROSSBAR, ( const struct _GUID &)pSpd->Property->Set))
		return( FALSE);

	ASSERT( pSpd != NULL);
	ASSERT( pSpd->PropertyInfo != NULL);
	ASSERT( nPropertyInSize >= sizeof( ULONG));
	
	OutputDebugInfo(( "CWDMAVXBar:AdapterSetProperty() Id = %d\n", uiPropertyId));

	switch( uiPropertyId)
	{
		case KSPROPERTY_CROSSBAR_ROUTE:
			{
				PKSPROPERTY_CROSSBAR_ROUTE_S pRouteInfo = ( PKSPROPERTY_CROSSBAR_ROUTE_S)pSpd->PropertyInfo;
				ULONG nInputPin, nOutputPin;
				int nAudioSource;

				ASSERT( nPropertyInSize >= sizeof( KSPROPERTY_CROSSBAR_ROUTE_S));
				// Copy the input property info to the output property info
				::RtlCopyMemory( pRouteInfo, pSpd->Property, sizeof( KSPROPERTY_CROSSBAR_ROUTE_S));

				nInputPin = pRouteInfo->IndexInputPin;
				nOutputPin = pRouteInfo->IndexOutputPin;

				if( nInputPin != -1)
				{
					if(( nInputPin < ( m_nNumberOfVideoInputs + m_nNumberOfAudioInputs)) && 
						( nOutputPin < ( m_nNumberOfVideoOutputs + m_nNumberOfAudioOutputs)))
					{
						// both input and output pins index are valid
						if(( m_pXBarInputPinsInfo[nInputPin].AudioVideoPinType <= KS_PhysConn_Video_SCART) &&
							( m_pXBarOutputPinsInfo[nOutputPin].AudioVideoPinType <= KS_PhysConn_Video_SCART))
							// Video pins connection is required
							pRouteInfo->CanRoute = ( m_pXBarInputPinsInfo[nInputPin].AudioVideoPinType ==
								m_pXBarOutputPinsInfo[nOutputPin].AudioVideoPinType);
						else	// is video pins connection required?
						{
							if(( m_pXBarInputPinsInfo[nInputPin].AudioVideoPinType >= KS_PhysConn_Audio_Tuner) && 
								( m_pXBarOutputPinsInfo[nOutputPin].AudioVideoPinType >= KS_PhysConn_Audio_Tuner))
							{
								// Audio pins connection is required
								switch( m_pXBarInputPinsInfo[nInputPin].AudioVideoPinType)
								{
									case KS_PhysConn_Audio_Line:
										nAudioSource = AUDIOSOURCE_LINEIN;
										break;

									case KS_PhysConn_Audio_Tuner:
										nAudioSource = AUDIOSOURCE_TVAUDIO;
										break;

									default:
										TRAP;
										return( FALSE);
								}

								if( m_pXBarOutputPinsInfo[nOutputPin].nConnectedToPin == nInputPin)
									// the connection has been made already
									pRouteInfo->CanRoute = TRUE;
								else	// are Audio pins connected already?
								{
									// the connection has to be made
									pRouteInfo->CanRoute = m_CATIConfiguration.CanConnectAudioSource( nAudioSource);
									if( pRouteInfo->CanRoute)
									{
										if( m_CATIConfiguration.ConnectAudioSource( m_pI2CScript,
																					nAudioSource))
                                        {
											// update driver state after routing
											m_pXBarOutputPinsInfo[nOutputPin].nConnectedToPin = nInputPin;
                                            m_pXBarOutputPinsInfo[nOutputPin].nRelatedPinNumber = m_pXBarInputPinsInfo[nInputPin].nRelatedPinNumber;
                                        }
										else
											bResult = FALSE;
									}
								}
							}
							else
								// mixed audio - video connection is required, fail
								pRouteInfo->CanRoute = FALSE;
						}
					}
					else	// are the pins index valid?
					{
						// either input and output pins index is invalid
						TRAP;
						OutputDebugError(( "CWDMAVXBar:Set...ROUTE() In = %d, Out = %d\n",
							nInputPin, nOutputPin));
						return( FALSE);
					}
				}
				else	// if( nInputPin != -1)
				{
					// There is a new notion of nInputPin = -1. It's valid only for Audio muting
					if( nOutputPin < ( m_nNumberOfVideoOutputs + m_nNumberOfAudioOutputs))
					{
						if( m_pXBarOutputPinsInfo[nOutputPin].AudioVideoPinType >= KS_PhysConn_Audio_Tuner)
							if( m_pXBarOutputPinsInfo[nOutputPin].nConnectedToPin == nInputPin)
								// the connection has been made already
								pRouteInfo->CanRoute = TRUE;
							else	// are Audio pins connected already?
							{
								// the connection has to be made
								pRouteInfo->CanRoute = m_CATIConfiguration.CanConnectAudioSource( AUDIOSOURCE_MUTE);
								if( pRouteInfo->CanRoute)
								{
									if( m_CATIConfiguration.ConnectAudioSource( m_pI2CScript,
																				AUDIOSOURCE_MUTE))
									// update driver state after routing
										m_pXBarOutputPinsInfo[nOutputPin].nConnectedToPin = nInputPin;
									else
										bResult = FALSE;
								}
							}
						else
							// we support muting for Audio output pin only
							pRouteInfo->CanRoute = FALSE;
					}
					else
					{
						// output pin index is invalid
						TRAP;
						OutputDebugError(( "CWDMAVXBar:Get...CAN_ROUTE() InPin = %d, OutPin = %d\n",
							nInputPin, nOutputPin));
						return( FALSE);
					}
				}
			}

			pSrb->ActualBytesTransferred = sizeof( KSPROPERTY_CROSSBAR_ROUTE_S);
			break;

		default:
			TRAP;
			return( FALSE);
	}

	return( bResult);
}



/*^^*
 *		SetWDMAVXBarKSTopology()
 * Purpose	: Sets the KSTopology structure
 *				Called during CWDMAVXBar class construction time.
 *
 * Inputs	: none
 *
 * Outputs	: none
 * Author	: IKLEBANOV
 *^^*/
void CWDMAVXBar::SetWDMAVXBarKSTopology( void)
{
	GUID wdmXBarTopologyCategory[] =
	{
		STATIC_KSCATEGORY_CROSSBAR
	};
	
	::RtlCopyMemory( &m_wdmAVXBarTopologyCategory, wdmXBarTopologyCategory, sizeof( wdmXBarTopologyCategory));

	m_wdmAVXBarTopology.CategoriesCount = 1;
	m_wdmAVXBarTopology.Categories = &m_wdmAVXBarTopologyCategory;
	m_wdmAVXBarTopology.TopologyNodesCount = 0;
	m_wdmAVXBarTopology.TopologyNodes = NULL;
	m_wdmAVXBarTopology.TopologyConnectionsCount = 0;
	m_wdmAVXBarTopology.TopologyConnections = NULL;
}



/*^^*
 *		SetWDMAVXBarProperties()
 * Purpose	: Sets the KSProperty structures array
 *				Called during CWDMAVXBar class construction time.
 *
 * Inputs	: none
 *
 * Outputs	: none
 * Author	: IKLEBANOV
 *^^*/
void CWDMAVXBar::SetWDMAVXBarKSProperties( void)
{

	DEFINE_KSPROPERTY_TABLE( wdmAVXBarPropertiesCrossBar)
	{
		DEFINE_KSPROPERTY_ITEM								
		(
			KSPROPERTY_CROSSBAR_CAPS,						// 1
			TRUE,											// GetSupported or Handler
			sizeof(KSPROPERTY_CROSSBAR_CAPS_S),				// MinProperty
			sizeof(KSPROPERTY_CROSSBAR_CAPS_S),				// MinData
			FALSE,											// SetSupported or Handler
			NULL,											// Values
			0,												// RelationsCount
			NULL,											// Relations
			NULL,											// SupportHandler
			sizeof( ULONG)									// SerializedSize
		),
		DEFINE_KSPROPERTY_ITEM								
		(
			KSPROPERTY_CROSSBAR_PININFO,						// 1
			TRUE,											// GetSupported or Handler
			sizeof(KSPROPERTY_CROSSBAR_PININFO_S),			// MinProperty
			sizeof(KSPROPERTY_CROSSBAR_PININFO_S),			// MinData
			FALSE,											// SetSupported or Handler
			NULL,											// Values
			0,												// RelationsCount
			NULL,											// Relations
			NULL,											// SupportHandler
			0												// SerializedSize
		),
		DEFINE_KSPROPERTY_ITEM								
		(
			KSPROPERTY_CROSSBAR_CAN_ROUTE,					// 1
			TRUE,											// GetSupported or Handler
			sizeof(KSPROPERTY_CROSSBAR_ROUTE_S),			// MinProperty
			sizeof(KSPROPERTY_CROSSBAR_ROUTE_S),			// MinData
			FALSE,											// SetSupported or Handler
			NULL,											// Values
			0,												// RelationsCount
			NULL,											// Relations
			NULL,											// SupportHandler
			sizeof( ULONG)									// SerializedSize
		),
		DEFINE_KSPROPERTY_ITEM								
		(
			KSPROPERTY_CROSSBAR_ROUTE,						// 1
			TRUE,											// GetSupported or Handler
			sizeof(KSPROPERTY_CROSSBAR_ROUTE_S),			// MinProperty
			sizeof(KSPROPERTY_CROSSBAR_ROUTE_S),			// MinData
			TRUE,											// SetSupported or Handler
			NULL,											// Values
			0,												// RelationsCount
			NULL,											// Relations
			NULL,											// SupportHandler
			sizeof( ULONG)									// SerializedSize
		),
	};

	DEFINE_KSPROPERTY_SET_TABLE( wdmAVXBarPropertySet)
	{
		DEFINE_KSPROPERTY_SET
		(
			&PROPSETID_VIDCAP_CROSSBAR,						// Set
			KSPROPERTIES_AVXBAR_NUMBER_CROSSBAR,			// PropertiesCount
			m_wdmAVXBarPropertiesCrossBar,					// PropertyItems
			0,												// FastIoCount
			NULL,											// FastIoTable
		),
	};

	::RtlCopyMemory( m_wdmAVXBarPropertiesCrossBar,	wdmAVXBarPropertiesCrossBar, sizeof( wdmAVXBarPropertiesCrossBar));
	::RtlCopyMemory( &m_wdmAVXBarPropertySet, wdmAVXBarPropertySet, sizeof( wdmAVXBarPropertySet));
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\tuners\1236\tuneprop.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

extern "C"
{
#include "strmini.h"
#include "ksmedia.h"

#include "wdmdebug.h"
}

#include "wdmdrv.h"
#include "atitunep.h"
#include "aticonfg.h"


/*^^*
 *		AdapterGetProperty()
 * Purpose	: Called when SRB_GET_PROPERTY SRB is received.
 *
 * Inputs	:	PHW_STREAM_REQUEST_BLOCK pSrb	: pointer to the current Srb
 *
 * Outputs	: BOOL : returns returns FALSE, if it is not a TVTuner property
 *				it also returns the required property
 * Author	: IKLEBANOV
 *^^*/
BOOL CATIWDMTuner::AdapterGetProperty( PHW_STREAM_REQUEST_BLOCK pSrb)
{
	PSTREAM_PROPERTY_DESCRIPTOR pSpd = pSrb->CommandData.PropertyInfo;
	ULONG	uiPropertyId = pSpd->Property->Id;				// index of the property
	ULONG	nPropertyOutSize = pSpd->PropertyOutputSize;		// size of data requested
	BOOL	bResult = FALSE;

	if( !::IsEqualGUID(( const struct _GUID &)PROPSETID_TUNER, ( const struct _GUID &)pSpd->Property->Set))
		return( bResult);

	if(( pSpd == NULL) || ( pSpd->PropertyInfo == NULL))
		return( bResult);
	
	OutputDebugInfo(( "CATIWDMTuner:AdapterGetProperty() Id = %d\n", uiPropertyId));

	bResult = TRUE;

	switch( uiPropertyId)
	{
		case KSPROPERTY_TUNER_CAPS:
			{
				KSPIN_MEDIUM NoPinMedium;
				PKSPROPERTY_TUNER_CAPS_S pTunerCaps = ( PKSPROPERTY_TUNER_CAPS_S)pSpd->PropertyInfo;

				ASSERT( nPropertyOutSize >= sizeof( KSPROPERTY_TUNER_CAPS_S));

				// Copy the input property info to the output property info
				::RtlCopyMemory( pTunerCaps, pSpd->Property, sizeof( KSPROPERTY_TUNER_CAPS_S));

				pTunerCaps->ModesSupported = m_ulSupportedModes;

				NoPinMedium.Set = GUID_NULL;
				NoPinMedium.Id = 0;
				NoPinMedium.Flags = 0;

				switch( m_ulNumberOfPins)
				{
					case 2:
					case 3:
						// TVTuner with TVAudio
/*
						pTunerCaps->VideoMedium = &m_pTVTunerPinsMediumInfo[0];
						pTunerCaps->TVAudioMedium = &m_pTVTunerPinsMediumInfo[1];
						pTunerCaps->RadioAudioMedium = ( m_ulNumberOfPins == 3) ?
							&m_pTVTunerPinsMediumInfo[2] : NULL;
*/
						pTunerCaps->VideoMedium = m_pTVTunerPinsMediumInfo[0];
						pTunerCaps->TVAudioMedium = m_pTVTunerPinsMediumInfo[1];
						pTunerCaps->RadioAudioMedium = ( m_ulNumberOfPins == 3) ?
							m_pTVTunerPinsMediumInfo[2] : NoPinMedium;
						break;

					case 1:
						// it can be FM Tuner only.
/*
						pTunerCaps->VideoMedium = NULL;
						pTunerCaps->TVAudioMedium = NULL;
						pTunerCaps->RadioAudioMedium = &m_pTVTunerPinsMediumInfo[0];
*/
						pTunerCaps->VideoMedium = NoPinMedium;
						pTunerCaps->TVAudioMedium = NoPinMedium;
						pTunerCaps->RadioAudioMedium = m_pTVTunerPinsMediumInfo[0];
						break;
				}

				pSrb->ActualBytesTransferred = sizeof( KSPROPERTY_TUNER_CAPS_S);
			}
			break;

		case KSPROPERTY_TUNER_MODE_CAPS:
			{
				PKSPROPERTY_TUNER_MODE_CAPS_S	pTunerModeCaps = ( PKSPROPERTY_TUNER_MODE_CAPS_S)pSpd->PropertyInfo;
				ULONG							ulOperationMode = (( PKSPROPERTY_TUNER_MODE_CAPS_S)pSpd->Property)->Mode;

				ASSERT( nPropertyOutSize >= sizeof( KSPROPERTY_TUNER_MODE_CAPS_S));

				// Copy the input property info to the output property info
				::RtlCopyMemory( pTunerModeCaps, pSpd->Property, sizeof( PKSPROPERTY_TUNER_MODE_CAPS_S));

				if( !( ulOperationMode & m_ulSupportedModes))
				{
					TRAP;
					bResult = FALSE;
					break;
				}

				// There is support for TVTuner at this tinme only. It will be enchanced later on to
				// support FM Tuner as well.
				switch( ulOperationMode)
				{
					case KSPROPERTY_TUNER_MODE_TV :
						::RtlCopyMemory( &pTunerModeCaps->StandardsSupported, &m_wdmTunerCaps, sizeof( ATI_KSPROPERTY_TUNER_CAPS));
						break;

					default:
						bResult = FALSE;
						break;
				}

				pSrb->ActualBytesTransferred = sizeof( KSPROPERTY_TUNER_MODE_CAPS_S);
			}
			break;

		case KSPROPERTY_TUNER_MODE:
	    	ASSERT( nPropertyOutSize >= sizeof( ULONG));
			
			(( PKSPROPERTY_TUNER_MODE_S)pSpd->PropertyInfo)->Mode = m_ulTunerMode;

		    pSrb->ActualBytesTransferred = sizeof( ULONG);
		    break;

		case KSPROPERTY_TUNER_STANDARD:
			{
				PKSPROPERTY_TUNER_STANDARD_S pTunerStandard = ( PKSPROPERTY_TUNER_STANDARD_S)pSpd->PropertyInfo;

	    		ASSERT( nPropertyOutSize >= sizeof( ULONG));

				// Copy the input property info to the output property info
				::RtlCopyMemory( pTunerStandard, pSpd->Property, sizeof( KSPROPERTY_TUNER_STANDARD_S));

				pTunerStandard->Standard = m_ulVideoStandard;

				pSrb->ActualBytesTransferred = sizeof( ULONG);
			}
		    break;

		case KSPROPERTY_TUNER_INPUT:
	    	ASSERT( nPropertyOutSize >= sizeof( ULONG));
			
			(( PKSPROPERTY_TUNER_INPUT_S)pSpd->PropertyInfo)->InputIndex = m_ulTunerInput;

		    pSrb->ActualBytesTransferred = sizeof( ULONG);
		    break;

		case KSPROPERTY_TUNER_STATUS:
			{
				BOOL	bBusy;
				LONG	lPLLOffset;
				PKSPROPERTY_TUNER_STATUS_S pTunerStatus = ( PKSPROPERTY_TUNER_STATUS_S)pSpd->PropertyInfo;

				ASSERT( nPropertyOutSize >= sizeof( KSPROPERTY_TUNER_STATUS_S));

				if(( bResult = GetTunerPLLOffsetBusyStatus( &lPLLOffset, &bBusy)))
				{
					OutputDebugInfo(( "CATIWDMTuner:GetStatus() Busy = %d, Quality = %d, Frequency = %ld\n",
						bBusy, lPLLOffset, m_ulTuningFrequency));

					pTunerStatus->Busy = bBusy;
					if( !bBusy)
					{
						pTunerStatus->PLLOffset = lPLLOffset;
						pTunerStatus->CurrentFrequency = m_ulTuningFrequency;
					}

					pSrb->ActualBytesTransferred = sizeof( KSPROPERTY_TUNER_STATUS_S);
				}
				else
				{
					bResult = FALSE;
					OutputDebugError(( "CATIWDMTuner:GetStatus() fails\n"));
				}
			}
			break;

		default:
			TRAP;
			bResult = FALSE;
			break;
	}

	return( bResult);
}



/*^^*
 *		AdapterSetProperty()
 * Purpose	: Called when SRB_GET_PROPERTY SRB is received.
 *
 * Inputs	:	PHW_STREAM_REQUEST_BLOCK pSrb	: pointer to the current Srb
 *
 * Outputs	: BOOL : returns FALSE, if it is not a TVTuner property
 *				it also sets the required property
 * Author	: IKLEBANOV
 *^^*/
BOOL CATIWDMTuner::AdapterSetProperty( PHW_STREAM_REQUEST_BLOCK pSrb)
{

	PSTREAM_PROPERTY_DESCRIPTOR pSpd = pSrb->CommandData.PropertyInfo;
	ULONG uiPropertyId = pSpd->Property->Id;			// index of the property
	ULONG nPropertyInSize = pSpd->PropertyOutputSize;		// size of data supplied

	if( !::IsEqualGUID( ( const struct _GUID &)PROPSETID_TUNER, ( const struct _GUID &)pSpd->Property->Set))
		return( FALSE);

	if(( pSpd == NULL) || ( pSpd->PropertyInfo == NULL))
		return( FALSE);
	
	ASSERT( nPropertyInSize >= sizeof( ULONG));
	
	OutputDebugInfo(( "CATIWDMTuner:AdapterSetProperty() Id = %d\n", uiPropertyId));

	switch( uiPropertyId)
	{
		case KSPROPERTY_TUNER_MODE:
			{
				ULONG ulModeToSet = (( PKSPROPERTY_TUNER_MODE_S)pSpd->PropertyInfo)->Mode;

				if( ulModeToSet & m_ulSupportedModes)
				{
					if( ulModeToSet != m_ulTunerMode)
						if( SetTunerMode( ulModeToSet))
							m_ulTunerMode = ulModeToSet;
				}
				else
					return( FALSE);
			}
			break;

		case KSPROPERTY_TUNER_STANDARD:
			{
				ULONG ulStandardToSet = (( PKSPROPERTY_TUNER_STANDARD_S)pSpd->PropertyInfo)->Standard;

				if( ulStandardToSet & m_wdmTunerCaps.ulStandardsSupported)
				{
					if( ulStandardToSet != m_ulVideoStandard)
						if( SetTunerVideoStandard( ulStandardToSet))
							m_ulVideoStandard = ulStandardToSet;
				}
				else
					return( FALSE);
			}
			break;

		case KSPROPERTY_TUNER_FREQUENCY:
			{
				ULONG	ulFrequencyToSet = (( PKSPROPERTY_TUNER_FREQUENCY_S)pSpd->PropertyInfo)->Frequency;
				BOOL	bResult = FALSE;

				ENSURE
				{
					if(( ulFrequencyToSet < m_wdmTunerCaps.ulMinFrequency) ||
						( ulFrequencyToSet > m_wdmTunerCaps.ulMaxFrequency))
							FAIL;

					if( ulFrequencyToSet != m_ulTuningFrequency)
					{
						if( !SetTunerFrequency( ulFrequencyToSet))
							FAIL;

						// update driver
						m_ulTuningFrequency = ulFrequencyToSet;
					}

					bResult = TRUE;

				} END_ENSURE;

				if( !bResult)
				{
					OutputDebugError(( "CATIWDMTuner:SetFrequency() fails Frequency = %ld\n", ulFrequencyToSet));

					return( FALSE);
				}

				OutputDebugInfo(( "CATIWDMTuner:SetFrequency() new TuningFrequency = %ld\n", ulFrequencyToSet));
			}
			break;

		case KSPROPERTY_TUNER_INPUT:
			{
				ULONG nInputToSet = (( PKSPROPERTY_TUNER_INPUT_S)pSpd->PropertyInfo)->InputIndex;

				if( nInputToSet < m_wdmTunerCaps.ulNumberOfInputs)
				{
					if( nInputToSet != m_ulTunerInput)
						if( SetTunerInput( nInputToSet))
							m_ulTunerInput = nInputToSet;
						else
							return( FALSE);
				}
				else
					return( FALSE);
			}
			break;

		default:
			TRAP;
			return( FALSE);
	}

	return( TRUE);
}



/*^^*
 *		SetWDMTunerKSTopology()
 * Purpose	: Sets the KSTopology structure
 *				Called during CWDMTuner class construction time.
 *
 * Inputs	: none
 *
 * Outputs	: none
 * Author	: IKLEBANOV
 *^^*/
void CATIWDMTuner::SetWDMTunerKSTopology( void)
{
	GUID wdmTunerTopologyCategory[] =
	{
		STATIC_KSCATEGORY_TVTUNER
	};
	
	::RtlCopyMemory( &m_wdmTunerTopologyCategory, wdmTunerTopologyCategory, sizeof( wdmTunerTopologyCategory));

	m_wdmTunerTopology.CategoriesCount = 1;
	m_wdmTunerTopology.Categories = &m_wdmTunerTopologyCategory;
	m_wdmTunerTopology.TopologyNodesCount = 0;
	m_wdmTunerTopology.TopologyNodes = NULL;
	m_wdmTunerTopology.TopologyConnectionsCount = 0;
	m_wdmTunerTopology.TopologyConnections = NULL;
}



/*^^*
 *		SetWDMTunerKSProperties()
 * Purpose	: Sets the KSProperty structures array
 *				Called during CWDMTuner class construction time.
 *
 * Inputs	: none
 *
 * Outputs	: none
 * Author	: IKLEBANOV
 *^^*/
void CATIWDMTuner::SetWDMTunerKSProperties( void)
{

	DEFINE_KSPROPERTY_TABLE( wdmTunerProperties)
	{
		DEFINE_KSPROPERTY_ITEM								
		(
			KSPROPERTY_TUNER_CAPS,							// 1
			TRUE,											// GetSupported or Handler
			sizeof(KSPROPERTY_TUNER_CAPS_S),				// MinProperty
			sizeof(KSPROPERTY_TUNER_CAPS_S),				// MinData
			FALSE,											// SetSupported or Handler
			NULL,											// Values
			0,												// RelationsCount
			NULL,											// Relations
			NULL,											// SupportHandler
			0												// SerializedSize
		),
		DEFINE_KSPROPERTY_ITEM								
		(
			KSPROPERTY_TUNER_MODE_CAPS,						// 2
			TRUE,											// GetSupported or Handler
			sizeof(KSPROPERTY_TUNER_MODE_CAPS_S),			// MinProperty
			sizeof(KSPROPERTY_TUNER_MODE_CAPS_S),			// MinData
			FALSE,											// SetSupported or Handler
			NULL,											// Values
			0,												// RelationsCount
			NULL,											// Relations
			NULL,											// SupportHandler
			0												// SerializedSize
		),
		DEFINE_KSPROPERTY_ITEM								
		(
			KSPROPERTY_TUNER_MODE,							// 3
			TRUE,											// GetSupported or Handler
			sizeof(KSPROPERTY_TUNER_MODE_S),				// MinProperty
			sizeof(KSPROPERTY_TUNER_MODE_S),				// MinData
			TRUE,											// SetSupported or Handler
			NULL,											// Values
			0,												// RelationsCount
			NULL,											// Relations
			NULL,											// SupportHandler
			0												// SerializedSize
		),
		DEFINE_KSPROPERTY_ITEM
		(
			KSPROPERTY_TUNER_STANDARD,						// 4
			TRUE,											// GetSupported or Handler
			sizeof(KSPROPERTY_TUNER_STANDARD_S),			// MinProperty
			sizeof(KSPROPERTY_TUNER_STANDARD_S),			// MinData
			TRUE,											// SetSupported or Handler
			NULL,											// Values
			0,												// RelationsCount
			NULL,											// Relations
			NULL,											// SupportHandler
			sizeof(KSPROPERTY_TUNER_STANDARD_S)			// SerializedSize
		),
		DEFINE_KSPROPERTY_ITEM
		(
			KSPROPERTY_TUNER_FREQUENCY,						// 5
			TRUE,											// GetSupported or Handler
			sizeof(KSPROPERTY_TUNER_FREQUENCY_S),			// MinProperty
			sizeof(KSPROPERTY_TUNER_FREQUENCY_S),			// MinData
			TRUE,											// SetSupported or Handler
			NULL,											// Values
			0,												// RelationsCount
			NULL,											// Relations
			NULL,											// SupportHandler
			sizeof(KSPROPERTY_TUNER_FREQUENCY_S)			// SerializedSize
		),
		DEFINE_KSPROPERTY_ITEM
		(
			KSPROPERTY_TUNER_INPUT,							// 6
			TRUE,											// GetSupported or Handler
			sizeof(KSPROPERTY_TUNER_INPUT_S),				// MinProperty
			sizeof(KSPROPERTY_TUNER_INPUT_S),				// MinData
			TRUE,											// SetSupported or Handler
			NULL,											// Values
			0,												// RelationsCount
			NULL,											// Relations
			NULL,											// SupportHandler
			sizeof(KSPROPERTY_TUNER_INPUT_S)				// SerializedSize
		),
		DEFINE_KSPROPERTY_ITEM
		(
			KSPROPERTY_TUNER_STATUS,						// 6
			TRUE,											// GetSupported or Handler
			sizeof(KSPROPERTY_TUNER_STATUS_S),				// MinProperty
			sizeof(KSPROPERTY_TUNER_STATUS_S),				// MinData
			FALSE,											// SetSupported or Handler
			NULL,											// Values
			0,												// RelationsCount
			NULL,											// Relations
			NULL,											// SupportHandler
			sizeof(KSPROPERTY_TUNER_STATUS_S)				// SerializedSize
		),
	};

	DEFINE_KSPROPERTY_SET_TABLE( wdmTunerPropertySet)
	{
		DEFINE_KSPROPERTY_SET
		(
			&PROPSETID_TUNER,								// Set
			KSPROPERTIES_TUNER_LAST,						// PropertiesCount
			m_wdmTunerProperties,							// PropertyItems
			0,												// FastIoCount
			NULL,											// FastIoTable
		)
	};

	::RtlCopyMemory( m_wdmTunerProperties,  wdmTunerProperties, sizeof( wdmTunerProperties));
	::RtlCopyMemory( &m_wdmTunerPropertySet, wdmTunerPropertySet, sizeof( wdmTunerPropertySet));
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\tuners\1236\tunerhdw.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//	TuneProp.H
//	WDM Tuner MiniDriver. 
//		Philips Tuner. 
//			Tuner Hardware access definitions.
//==========================================================================;

#ifndef _TUNERHDW_H_
#define _TUNERHDW_H_


// Special case for Temic Tuner, Channels 63, 64
#define kTemicControl			0x8E34
#define kAirChannel63			0x32B0
#define kAirChannel64			0x3310

// Upper low and upper mid range band definitions
#define kUpperLowBand			0x0CB0
#define kUpperMidBand			0x1F10
#define kUpperLowBand_PALD		0x0CE4
#define kUpperMidBand_PALD		0x1ED4
#define kUpperLowBand_SECAM		0x0CE4
#define kUpperMidBand_SECAM		0x1ED4 
#define kUpperLowBand_ALPS		0x0AD0
#define kUpperMidBand_ALPS		0x1970 

// Low, Mid and High band control definitions
#define kLowBand				0x8EA0
#define kMidBand				0x8E90
#define kHighBand				0x8E30
#define kLowBand_SECAM			0x8EA3
#define kMidBand_SECAM			0x8E93
#define kHighBand_SECAM			0x8E33
#define kLowBand_ALPS			0xC214		// Bigger charge pump current
#define kMidBand_ALPS			0xC212		// Bigger charge pump current
#define kHighBand_ALPS			0xC211		// Bigger charge pump current
#define kLowBand_PALBG			0x8EA1
#define kMidBand_PALBG			0x8E91
#define kHighBand_PALBG			0x8E31
#define kLowBand_NTSC_FM		0x8EA0
#define kMidBand_NTSC_FM		0x8E90
#define kHighBand_NTSC_FM		0x8E30


#endif	// _TUNERHDW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\crossbar\atixbar\wdmxbar.h ===
//==========================================================================;
//
//	WDMXBar.H
//	WDM Analog/Video CrossBar MiniDriver. 
//		CWDMAVXBar Class definition.
//  Copyright (c) 1996 - 1997  ATI Technologies Inc.  All Rights Reserved.
//
//==========================================================================;

#ifndef _WDMXBAR_H_
#define _WDMXBAR_H_

#include "i2script.h"
#include "aticonfg.h"


#define	KSPROPERTIES_AVXBAR_NUMBER_SET			1		// CrossBar with no TVAudio
#define KSPROPERTIES_AVXBAR_NUMBER_CROSSBAR		( KSPROPERTY_CROSSBAR_ROUTE + 1)


typedef struct
{
	UINT						AudioVideoPinType;
   ULONG					   nRelatedPinNumber;		// for all pins
	ULONG					   nConnectedToPin;		   // for output pins only
	PKSPIN_MEDIUM			pMedium;				      // describes hardware connectivity

} XBAR_PIN_INFORMATION, * PXBAR_PIN_INFORMATION;


class CWDMAVXBar
{
public:
	CWDMAVXBar			( PDEVICE_OBJECT pDeviceObject,CI2CScript * pCScript, PUINT puiError);
	~CWDMAVXBar			();
	PVOID operator new	( size_t size_t, PVOID pAllocation);

// Attributes	
private:
	// WDM global topology headers
	GUID						m_wdmAVXBarTopologyCategory;
	KSTOPOLOGY					m_wdmAVXBarTopology;
	// WDM global property headers
	KSPROPERTY_ITEM				m_wdmAVXBarPropertiesCrossBar[KSPROPERTIES_AVXBAR_NUMBER_CROSSBAR];
	KSPROPERTY_SET				m_wdmAVXBarPropertySet[KSPROPERTIES_AVXBAR_NUMBER_SET];

	// WDM global stream headers
	HW_STREAM_HEADER			m_wdmAVXBarStreamHeader;

	// configuration properties
	CATIHwConfiguration			m_CATIConfiguration;
	ULONG						m_nNumberOfVideoInputs;
	ULONG						m_nNumberOfVideoOutputs;
	ULONG						m_nNumberOfAudioInputs;
	ULONG						m_nNumberOfAudioOutputs;

	// power management configuration
	DEVICE_POWER_STATE			m_ulPowerState;

	// pins information
	PKSPIN_MEDIUM				m_pXBarPinsMediumInfo;
	PBOOL						m_pXBarPinsDirectionInfo;
	PXBAR_PIN_INFORMATION		m_pXBarInputPinsInfo;
	PXBAR_PIN_INFORMATION		m_pXBarOutputPinsInfo;

	// I2C provider properties
	CI2CScript *				m_pI2CScript;

// Implementation
public:
	BOOL		AdapterUnInitialize				( PHW_STREAM_REQUEST_BLOCK pSrb);
	BOOL		AdapterGetStreamInfo			( PHW_STREAM_REQUEST_BLOCK pSrb);
	BOOL		AdapterQueryUnload				( PHW_STREAM_REQUEST_BLOCK pSrb);
	BOOL		AdapterGetProperty				( PHW_STREAM_REQUEST_BLOCK pSrb);
	BOOL		AdapterSetProperty				( PHW_STREAM_REQUEST_BLOCK pSrb);
	NTSTATUS	AdapterCompleteInitialization	( PHW_STREAM_REQUEST_BLOCK pSrb);
	NTSTATUS	AdapterSetPowerState			( PHW_STREAM_REQUEST_BLOCK pSrb);
	
	// the functions for asynchronous operations completion
	void		UpdateAudioConnectionAfterChange( void);

private:
	void		SetWDMAVXBarKSProperties		( void);
	void		SetWDMAVXBarKSTopology			( void);
};


#endif	// _WDMXBAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\tuners\1236\atitunep.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//	ATITuneP.CPP
//	WDM Tuner MiniDriver. 
//		Philips Tuner. 
//			Main Source Module.
//
//		$Date:   01 Apr 1998 12:59:30  $
//	$Revision:   1.2  $
//	  $Author:   KLEBANOV  $
//
//==========================================================================;

extern "C"
{
#include "strmini.h"
#include "ksmedia.h"

#include "wdmdebug.h"
}

#include "wdmdrv.h"
#include "atitunep.h"



/*^^*
 *		DriverEntry()
 * Purpose	: Called when an SRB_INITIALIZE_DEVICE request is received
 *
 * Inputs	: PVOID Arg1, PVOID Arg2
 *
 * Outputs	: result of StreamClassregisterAdapter()
 * Author	: IKLEBANOV
 *^^*/
extern "C" 
ULONG DriverEntry (	IN PDRIVER_OBJECT	pDriverObject,
					IN PUNICODE_STRING	pRegistryPath)
//ULONG DriverEntry( PVOID Arg1, PVOID Arg2)
{
	HW_INITIALIZATION_DATA HwInitData;

	SetMiniDriverDebugLevel( pRegistryPath);
	
	OutputDebugTrace(( "ATITuneP: DriverEntry\n"));
     
	RtlZeroMemory( &HwInitData, sizeof( HwInitData));

	HwInitData.HwInitializationDataSize = sizeof( HwInitData);

	// Entry points for Port Driver

	HwInitData.HwInterrupt					= NULL; // HwInterrupt;

	HwInitData.HwReceivePacket				= TunerReceivePacket;
	HwInitData.HwCancelPacket				= TunerCancelPacket;
	HwInitData.HwRequestTimeoutHandler		= TunerTimeoutPacket;

	HwInitData.DeviceExtensionSize			= sizeof( ADAPTER_DATA_EXTENSION);
	HwInitData.PerRequestExtensionSize		= sizeof( SRB_DATA_EXTENSION); 
	HwInitData.FilterInstanceExtensionSize	= 0;
	HwInitData.PerStreamExtensionSize		= 0;
	HwInitData.BusMasterDMA					= FALSE;  
	HwInitData.Dma24BitAddresses			= FALSE;
	HwInitData.BufferAlignment				= 3;
//	HwInitData.TurnOffSynchronization		= FALSE;
	// we turn the synchronization ON. StreamClass is expected to call the MiniDriver
	// at passive level only
	HwInitData.TurnOffSynchronization		= TRUE;
	HwInitData.DmaBufferSize				= 0;

	OutputDebugTrace(( "ATITuneP: StreamClassRegisterAdapter\n"));

//	return( StreamClassRegisterAdapter( Arg1, Arg2, &HwInitData));
	return( StreamClassRegisterAdapter( pDriverObject, pRegistryPath, &HwInitData));
}



/*^^*
 *		TunerReceivePacket()
 * Purpose	: Main entry point for receiving adapter based request SRBs from the Class Driver.
 *				Will always be called at passive level, because the drivers
 *				turned the synchronization ON.
 * Note		: This is an asyncronous entry point. The request only completes when a 
 *				StreamClassDeviceNotification on this SRB, of type  DeviceRequestComplete,
 *				is issued. As soon we're running at passive level, we can do everything 
 *				synchronously during the response to the SRBs with no worry
 *				to block somebody else for a long timer during I2C access
 *
 * Inputs	: PHW_STREAM_REQUEST_BLOCK pSrb	: pointer to the current Srb
 *
 * Outputs	: none
 * Author	: IKLEBANOV
 *^^*/
extern "C" 
void STREAMAPI TunerReceivePacket( IN OUT PHW_STREAM_REQUEST_BLOCK pSrb)
{
    CATIWDMTuner *			pCTuner;
	KIRQL					irqlCurrent;
    PADAPTER_DATA_EXTENSION pPrivateData = ( PADAPTER_DATA_EXTENSION)( pSrb->HwDeviceExtension);
    PSRB_DATA_EXTENSION		pSrbPrivate = ( PSRB_DATA_EXTENSION)( pSrb->SRBExtension);

	// check the device extension pointer
	if(( pPrivateData == NULL) || ( pSrbPrivate == NULL))
	{
		TRAP;
		pSrb->Status = STATUS_INVALID_PARAMETER;
		StreamClassDeviceNotification( DeviceRequestComplete, pSrb->HwDeviceExtension, pSrb);
	}

    OutputDebugInfo(( "ATITuneP: TunerReceivePacket() SRB = %x\n", pSrb));

	if( pSrb->Command == SRB_INITIALIZE_DEVICE)
	{
		// this is the special case for SRB_INITIALIZE_DEVICE, because
		// no Queue has been initialized yet. Everything we need later on
		// is initialized during this SRB response
		TunerAdapterInitialize( pSrb);

		StreamClassDeviceNotification( DeviceRequestComplete, pSrb->HwDeviceExtension, pSrb);
		return;
	}

	// the rest of the SRBs are coming after SpinLock and SRBQueue have been initialized
	// during DRB_INITIALIZE_DEVICE SRB response.
	// I'll insert the SRB in the Queue first of all. The processing SRB from the Queue
	// can be triggered by finishing processing and SRB, or by the fact there is no SRB
	// is in process down here
	pSrbPrivate->pSrb = pSrb;

	// Everything we're doing with the Queue has to be protected from being interrupted
	KeAcquireSpinLock( &pPrivateData->adapterSpinLock, &irqlCurrent);
	InsertTailList( &pPrivateData->adapterSrbQueueHead, &pSrbPrivate->srbListEntry);

	if( pPrivateData->bSrbInProcess)
	{
		// there is another SRB being processed, and the new one will be picked up from
		// the Queue when it's its turn.
		KeReleaseSpinLock( &pPrivateData->adapterSpinLock, irqlCurrent);
		return;
	}

	while( !IsListEmpty( &pPrivateData->adapterSrbQueueHead))
	{
		// turn on the semaphore for the others coming after
		pPrivateData->bSrbInProcess = TRUE;

		// be carefull here, if you've changed the place where srbListEntry is defined
		// within the SRB_DATA_EXTENSION structure
		pSrbPrivate = ( PSRB_DATA_EXTENSION)RemoveHeadList( &pPrivateData->adapterSrbQueueHead);
		KeReleaseSpinLock( &pPrivateData->adapterSpinLock, irqlCurrent);

		// here is the place to process the SRB we have retrieved from the Queue
		pSrb = pSrbPrivate->pSrb;
		pPrivateData = ( PADAPTER_DATA_EXTENSION)( pSrb->HwDeviceExtension);
		pCTuner = &pPrivateData->CTuner;

		ASSERT( pSrb->Status != STATUS_CANCELLED);

	    switch( pSrb->Command)
		{
			case SRB_INITIALIZATION_COMPLETE:
				// StreamClass has completed the initialization
				pSrb->Status = pCTuner->AdapterCompleteInitialization( pSrb);
				break;

			case SRB_UNINITIALIZE_DEVICE:
				// close the device.  
				pCTuner->AdapterUnInitialize( pSrb);
				break;

			case SRB_OPEN_STREAM:
			case SRB_CLOSE_STREAM:
				pSrb->Status = STATUS_NOT_IMPLEMENTED;
				break;

			case SRB_GET_STREAM_INFO:
				// return a block describing STREAM_INFO_HEADER and all the streams supported
				pCTuner->AdapterGetStreamInfo( pSrb);
				break;

			case SRB_CHANGE_POWER_STATE:
				pSrb->Status = pCTuner->AdapterSetPowerState( pSrb);
				break;

			case SRB_GET_DEVICE_PROPERTY:
				if( pCTuner->AdapterGetProperty( pSrb))
					pSrb->Status = STATUS_SUCCESS;
				else
					pSrb->Status = STATUS_INVALID_PARAMETER;
				break;        

			case SRB_SET_DEVICE_PROPERTY:
				if( pCTuner->AdapterSetProperty( pSrb))
					pSrb->Status = STATUS_SUCCESS;
				else
					pSrb->Status = STATUS_INVALID_PARAMETER;
				break;

			// We should never get the following since this is a single instance device
			case SRB_OPEN_DEVICE_INSTANCE:
			case SRB_CLOSE_DEVICE_INSTANCE:
				TRAP
				pSrb->Status = STATUS_NOT_IMPLEMENTED;
				break;

			case SRB_UNKNOWN_DEVICE_COMMAND:
				// we know we're getting some of these. Why should we?
				pSrb->Status = STATUS_NOT_IMPLEMENTED;
				break;

			default:
				// TRAP
				// this is a request that we do not understand.  Indicate invalid command and complete the request
				pSrb->Status = STATUS_NOT_IMPLEMENTED;
		}

		StreamClassDeviceNotification( DeviceRequestComplete, pPrivateData, pSrb);

		KeAcquireSpinLock( &pPrivateData->adapterSpinLock, &irqlCurrent);
	}

	// turn off the semaphore to enable the others coming after
	pPrivateData->bSrbInProcess = FALSE;

	KeReleaseSpinLock( &pPrivateData->adapterSpinLock, irqlCurrent);
	// there is no other SRB being processed at this time, let's start processing

}


extern "C" 
void STREAMAPI TunerCancelPacket( IN OUT PHW_STREAM_REQUEST_BLOCK pSrb)
{

	pSrb->Status = STATUS_CANCELLED;
}


extern "C" 
void STREAMAPI TunerTimeoutPacket( IN OUT PHW_STREAM_REQUEST_BLOCK pSrb)
{

	// not sure what to do here.
}


/*^^*
 *		TunerAdapterInitialize()
 * Purpose	: Called when SRB_INITIALIZE_DEVICE SRB is received.
 *				Performs checking of the hardware presence and I2C provider availability.
 *				Sets the hardware in an initial state.
 * Note		: The request does not completed unless we know everything
 *				about the hardware and we are sure it is capable to work in the current configuration.
 *				The hardware Caps are also aquised at this point. As soon this
 *				function is called at passive level, do everything synchronously
 *
 * Inputs	: PHW_STREAM_REQUEST_BLOCK pSrb	: pointer to the current Srb
 *
 * Outputs	: none
 * Author	: IKLEBANOV
 *^^*/
void TunerAdapterInitialize( IN OUT PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PPORT_CONFIGURATION_INFORMATION pConfigInfo = pSrb->CommandData.ConfigInfo;
    PADAPTER_DATA_EXTENSION pPrivateData = ( PADAPTER_DATA_EXTENSION)( pConfigInfo->HwDeviceExtension);
	NTSTATUS		ntStatus = STATUS_NO_SUCH_DEVICE;
	CATIWDMTuner *	pCTuner = NULL;
	CI2CScript *	pCScript = NULL;
	UINT			nErrorCode;

    OutputDebugTrace(( "ATITuneP: TunerAdapterInitialize()\n"));

    ENSURE
	{
		if( pConfigInfo->NumberOfAccessRanges != 0) 
		{
			OutputDebugError(( "ATITuneP: illegal NumberOfAccessRanges = %lx\n", pConfigInfo->NumberOfAccessRanges));
			FAIL;
		}

		// if we have I2CProvider implemented inside the MiniVDD, we have to
		// get a pointer to I2CInterface from the Provider.

		// There is an overloaded operator new provided for the CI2CScript Class.
		pCScript = ( CI2CScript *)new(( PVOID)&pPrivateData->CScript)		\
						CI2CScript( pConfigInfo->PhysicalDeviceObject, &nErrorCode);
		if( nErrorCode != WDMMINI_NOERROR)
		{
			OutputDebugError(( "ATITuneP: CI2CScript creation failure = %lx\n", nErrorCode));
			FAIL;
		}
		
		// The CI2CScript object was created successfully.
		// We'll try to allocate I2CProvider here for future possible I2C
		// operations needed at Initialization time.
		if( !pCScript->LockI2CProviderEx())
		{
			OutputDebugError(( "ATITuneP: unable to lock I2CProvider"));
			FAIL;
		}

		// we did lock the provider.
		// There is an overloaded operator new provided for the CATIWDMTuner Class.
		pCTuner = ( CATIWDMTuner *)new(( PVOID)&pPrivateData->CTuner) CATIWDMTuner( pConfigInfo->PhysicalDeviceObject, pCScript, &nErrorCode);
		if( nErrorCode)
		{
			OutputDebugError(( "ATITuneP: CATIWDMTuner constructor failure = %lx\n", nErrorCode));
			FAIL;
		}

	    InitializeListHead ( &pPrivateData->adapterSrbQueueHead);
		KeInitializeSpinLock ( &pPrivateData->adapterSpinLock);

		pPrivateData->PhysicalDeviceObject = pConfigInfo->PhysicalDeviceObject;
		// no streams are supported
		pConfigInfo->StreamDescriptorSize = sizeof( HW_STREAM_HEADER);

		OutputDebugTrace(( "TunerAdapterInitialize(): exit\n"));

		ntStatus = STATUS_SUCCESS;

	} END_ENSURE;

	if ( pCScript )
	    pCScript->ReleaseI2CProvider();

	pSrb->Status = ntStatus;
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\tuners\1236\wdmtuner.cpp ===
//==========================================================================;
//
//	WDMTuner.CPP
//	WDM Tuner MiniDriver. 
//		Philips Tuner. 
//			CATIWDMTuner class implementation.
//  Copyright (c) 1996 - 1997  ATI Technologies Inc.  All Rights Reserved.
//
//		$Date:   10 Aug 1999 16:15:44  $
//	$Revision:   1.6  $
//	  $Author:   KLEBANOV  $
//
//==========================================================================;

extern "C"
{
#include "strmini.h"
#include "ksmedia.h"

#include "wdmdebug.h"
}

#include "atitunep.h"
#include "wdmdrv.h"
#include "aticonfg.h"


#define ATI_TVAUDIO_SUPPORT


/*^^*
 *		AdapterCompleteInitialization()
 * Purpose	: Called when SRB_COMPLETE_UNINITIALIZATION SRB is received.
 *
 * Inputs	:	PHW_STREAM_REQUEST_BLOCK pSrb	: pointer to the current Srb
 *
 * Outputs	: BOOL : returns TRUE
 * Author	: IKLEBANOV
 *^^*/
NTSTATUS CATIWDMTuner::AdapterCompleteInitialization( PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PADAPTER_DATA_EXTENSION pPrivateData = ( PADAPTER_DATA_EXTENSION)( pSrb->HwDeviceExtension);
	PDEVICE_OBJECT pDeviceObject = pPrivateData->PhysicalDeviceObject;
	KSPIN_MEDIUM	mediumKSPin;
	NTSTATUS		ntStatus;
	UINT			nIndex;
	HANDLE			hFolder;
	ULONG			ulInstance;

	ENSURE
	{
		nIndex = 0;

		switch( m_ulNumberOfPins)
		{
			case 2:
				// TVTuner with TVAudio
				::RtlCopyMemory( &m_pTVTunerPinsMediumInfo[nIndex ++], &ATITVTunerVideoOutMedium, sizeof( KSPIN_MEDIUM));
#ifdef ATI_TVAUDIO_SUPPORT
#pragma message ("\n!!! PAY ATTENTION: Tuner PinMedium is compiled with TVAudio support !!!\n")
				::RtlCopyMemory( &m_pTVTunerPinsMediumInfo[nIndex], &ATITVTunerTVAudioOutMedium, sizeof( KSPIN_MEDIUM));
#else
#pragma message ("\n!!! PAY ATTENTION: Tuner PinMedium is compiled without TVAudio support !!!\n")
				::RtlCopyMemory( &m_pTVTunerPinsMediumInfo[nIndex ++], &ATIXBarAudioTunerInMedium, sizeof( KSPIN_MEDIUM));
#endif
				break;

			case 3:
				// TVTuner with TVAudio with separate FM Audio output
				::RtlCopyMemory( &m_pTVTunerPinsMediumInfo[nIndex ++], &ATITVTunerVideoOutMedium, sizeof( KSPIN_MEDIUM));
#ifdef ATI_TVAUDIO_SUPPORT
				::RtlCopyMemory( &m_pTVTunerPinsMediumInfo[nIndex ++], &ATITVTunerTVAudioOutMedium, sizeof( KSPIN_MEDIUM));
#else
				::RtlCopyMemory( &m_pTVTunerPinsMediumInfo[nIndex ++], &ATIXBarAudioTunerInMedium, sizeof( KSPIN_MEDIUM));
#endif

			case 1:
				// it can be FM Tuner only.
				::RtlCopyMemory( &m_pTVTunerPinsMediumInfo[nIndex], &ATITVTunerRadioAudioOutMedium, sizeof( KSPIN_MEDIUM));
				break;
		}

		ulInstance = ::GetDriverInstanceNumber( pDeviceObject);
		hFolder = ::OpenRegistryFolder( pDeviceObject, UNICODE_WDM_REG_PIN_MEDIUMS);

		for( nIndex = 0; nIndex < m_ulNumberOfPins; nIndex ++)
		{
			if( ::ReadPinMediumFromRegistryFolder( hFolder, nIndex, &mediumKSPin))
				::RtlCopyMemory( &m_pTVTunerPinsMediumInfo[nIndex], &mediumKSPin, sizeof( KSPIN_MEDIUM));
			m_pTVTunerPinsMediumInfo[nIndex].Id = ulInstance;

			// all the possible pins exposed are the outputs
			m_pTVTunerPinsDirectionInfo[nIndex] = TRUE;
		}

		if( hFolder != NULL)
			::ZwClose( hFolder);

		ntStatus = StreamClassRegisterFilterWithNoKSPins( \
						pDeviceObject					,		// IN PDEVICE_OBJECT   DeviceObject,
						&KSCATEGORY_TVTUNER,					// IN GUID           * InterfaceClassGUID
						m_ulNumberOfPins,						// IN ULONG            PinCount,
						m_pTVTunerPinsDirectionInfo,			// IN ULONG          * Flags,
						m_pTVTunerPinsMediumInfo,				// IN KSPIN_MEDIUM   * MediumList,
						NULL);									// IN GUID           * CategoryList

		if( !NT_SUCCESS( ntStatus))
			FAIL;

		OutputDebugInfo(( "CATIWDMTuner:AdapterCompleteInitialization() exit\n"));

	} END_ENSURE;

	if( !NT_SUCCESS( ntStatus))
		OutputDebugError(( "CATIWDMTuner:AdapterCompleteInitialization() ntStatus=%x\n",	ntStatus));

	return( ntStatus);
}



/*^^*
 *		AdapterUnInitialize()
 * Purpose	: Called when SRB_UNINITIALIZE_DEVICE SRB is received.
 *
 * Inputs	:	PHW_STREAM_REQUEST_BLOCK pSrb	: pointer to the current Srb
 *
 * Outputs	: BOOL : returns TRUE
 * Author	: IKLEBANOV
 *^^*/
BOOL CATIWDMTuner::AdapterUnInitialize( PHW_STREAM_REQUEST_BLOCK pSrb)
{

	OutputDebugTrace(( "CATIWDMTuner:AdapterUnInitialize()\n"));

	// just deallocate the any memory was allocated at run-time
	if( m_pTVTunerPinsMediumInfo != NULL)
	{
		::ExFreePool( m_pTVTunerPinsMediumInfo);
		m_pTVTunerPinsMediumInfo = NULL;
	}

	if( m_pTVTunerPinsDirectionInfo != NULL)
	{
		::ExFreePool( m_pTVTunerPinsDirectionInfo);
		m_pTVTunerPinsDirectionInfo = NULL;
	}

	pSrb->Status = STATUS_SUCCESS;
	return( TRUE);
}


/*^^*
 *		AdapterGetStreamInfo()
 * Purpose	: fills in HW_STREAM_HEADER for StreamClass driver
 *
 * Inputs	: PHW_STREAM_REQUEST_BLOCK pSrb	: pointer to the current Srb
 *
 * Outputs	: BOOL : returns TRUE
 * Author	: IKLEBANOV
 *^^*/
BOOL CATIWDMTuner::AdapterGetStreamInfo( PHW_STREAM_REQUEST_BLOCK pSrb)
{
     // pick up the pointer to the stream header data structure
	PHW_STREAM_HEADER pStreamHeader = ( PHW_STREAM_HEADER)&( pSrb->CommandData.StreamBuffer->StreamHeader);

	// no streams are supported
    DEBUG_ASSERT( pSrb->NumberOfBytesToTransfer >= sizeof( HW_STREAM_HEADER));

	OutputDebugTrace(( "CATIWDMTuner:AdapterGetStreamInfo()\n"));

	m_wdmTunerStreamHeader.NumberOfStreams = 0;
	m_wdmTunerStreamHeader.SizeOfHwStreamInformation = sizeof( HW_STREAM_INFORMATION);
	m_wdmTunerStreamHeader.NumDevPropArrayEntries = 1;
	m_wdmTunerStreamHeader.DevicePropertiesArray = &m_wdmTunerPropertySet;
	m_wdmTunerStreamHeader.NumDevEventArrayEntries = 0;
	m_wdmTunerStreamHeader.DeviceEventsArray = NULL;
	m_wdmTunerStreamHeader.Topology = &m_wdmTunerTopology;

	* pStreamHeader = m_wdmTunerStreamHeader;

	pSrb->Status = STATUS_SUCCESS;
	return( TRUE);
}


/*^^*
 *		AdapterQueryUnload()
 * Purpose	: Called when the class driver is about to unload the MiniDriver
 *				The MiniDriver checks if any open stream left.
 *
 * Inputs	:	PHW_STREAM_REQUEST_BLOCK pSrb	: pointer to the current Srb
 *
 * Outputs	: BOOL : returns TRUE
 * Author	: IKLEBANOV
 *^^*/
BOOL CATIWDMTuner::AdapterQueryUnload( PHW_STREAM_REQUEST_BLOCK pSrb)
{

	OutputDebugTrace(( "CATIWDMTuner:AdapterQueryUnload()\n"));

	pSrb->Status = STATUS_SUCCESS;
	return( TRUE);
}



/*^^*
 *		operator new
 * Purpose	: CATIWDMTuner class overloaded operator new.
 *				Provides placement for a CATIWDMTuner class object from the PADAPTER_DEVICE_EXTENSION
 *				allocated by the StreamClassDriver for the MiniDriver.
 *
 * Inputs	:	UINT size_t			: size of the object to be placed
 *				PVOID pAllocation	: casted pointer to the CWDMTuner allocated data
 *
 * Outputs	: PVOID : pointer of the CATIWDMTuner class object
 * Author	: IKLEBANOV
 *^^*/
PVOID CATIWDMTuner::operator new( size_t size_t, PVOID pAllocation)
{

	if( size_t != sizeof( CATIWDMTuner))
	{
		OutputDebugError(( "CATIWDMTuner: operator new() fails\n"));
		return( NULL);
	}
	else
		return( pAllocation);
}



/*^^*
 *		~CATIWDMTuner()
 * Purpose	: CATIWDMTuner class destructor.
 *				Frees the allocated memory.
 *
 * Inputs	: none
 *
 * Outputs	: none
 * Author	: IKLEBANOV
 *^^*/
CATIWDMTuner::~CATIWDMTuner()
{

	OutputDebugTrace(( "CATIWDMTuner:~CATIWDMTuner()\n"));

	if( m_pTVTunerPinsMediumInfo != NULL)
	{
		::ExFreePool( m_pTVTunerPinsMediumInfo);
		m_pTVTunerPinsMediumInfo = NULL;
	}

	if( m_pTVTunerPinsDirectionInfo != NULL)
	{
		::ExFreePool( m_pTVTunerPinsDirectionInfo);
		m_pTVTunerPinsDirectionInfo = NULL;
	}
}



/*^^*
 *		CATIWDMTuner()
 * Purpose	: CATIWDMTuner class constructor.
 *				Performs checking of the hardware presence. Sets the hardware in an initial state.
 *
 * Inputs	:	CI2CScript * pCScript	: pointer to the I2CScript class object
 *				PUINT puiError			: pointer to return a completion error code
 *
 * Outputs	: none
 * Author	: IKLEBANOV
 *^^*/
CATIWDMTuner::CATIWDMTuner( PDEVICE_OBJECT pDeviceObject, CI2CScript * pCScript, PUINT puiErrorCode)
	:m_CATIConfiguration( pDeviceObject, pCScript, puiErrorCode)
{
	UINT uiError;

	OutputDebugTrace(( "CATIWDMTuner:CATIWDMTuner() enter\n"));

	// error code was carried over from ATIConfiguration class constructor
	uiError = * puiErrorCode;

	m_pTVTunerPinsMediumInfo = NULL;
	m_pTVTunerPinsDirectionInfo = NULL;
	m_ulPowerState = PowerDeviceD0;
	
	ENSURE
	{
		if( uiError != WDMMINI_NOERROR)
			// ATIConfiguration Class object was constructed with an error
			FAIL;

		if( pCScript == NULL)
		{
			uiError = WDMMINI_INVALIDPARAM;
			FAIL;
		}

		if( !m_CATIConfiguration.GetTunerConfiguration( &m_uiTunerId, &m_uchTunerI2CAddress) ||
			( !m_uchTunerI2CAddress))
		{
			// there was no hardware information found
			uiError = WDMMINI_NOHARDWARE;
			FAIL;
		}

		// Set tuner capabilities ( RO properties) based upon the TunerId
		if( !SetTunerWDMCapabilities( m_uiTunerId) || ( !m_ulNumberOfPins))
		{
			// there is unsupported hardware was found
			uiError = WDMMINI_UNKNOWNHARDWARE;
			FAIL;
		}

		m_pTVTunerPinsMediumInfo = ( PKSPIN_MEDIUM) \
			::ExAllocatePool( NonPagedPool, sizeof( KSPIN_MEDIUM) * m_ulNumberOfPins);
		if( m_pTVTunerPinsMediumInfo == NULL)
		{
			uiError = WDMMINI_ERROR_MEMORYALLOCATION;
			FAIL;
		}
		
		m_pTVTunerPinsDirectionInfo = ( PBOOL) \
			::ExAllocatePool( NonPagedPool, sizeof( BOOL) * m_ulNumberOfPins);
		if( m_pTVTunerPinsDirectionInfo == NULL)
		{
			uiError = WDMMINI_ERROR_MEMORYALLOCATION;
			FAIL;
		}

		m_pI2CScript = pCScript;

		SetWDMTunerKSProperties();
		SetWDMTunerKSTopology();

		// Set run-time WDM properties at the last
		m_ulVideoStandard = ( m_ulNumberOfStandards == 1) ?
			// unknown standard or the only one
			m_wdmTunerCaps.ulStandardsSupported : 0x0L;
		m_ulTunerInput = 0L;				// unknown input or the only one
		m_ulTuningFrequency = 0L;			// unknown tuning frequency

#ifndef ATI_TVAUDIO_SUPPORT
		{
			// this code is needed to initilaize TVAudio path off the tuner
			// if there is no separate MiniDriver for TVAudio is assumed
			UINT	uiAudioConfiguration;
			UCHAR	uchAudioI2CAddress;

			if( m_CATIConfiguration.GetAudioConfiguration( &uiAudioConfiguration,
														   &uchAudioI2CAddress))
			{
				m_CATIConfiguration.InitializeAudioConfiguration( pCScript,
																  uiAudioConfiguration,
																  uchAudioI2CAddress);
			}
		}
#endif	// ATI_TVAUDIO_SUPPORT

		* puiErrorCode = WDMMINI_NOERROR;

		OutputDebugTrace(( "CATIWDMTuner:CATIWDMTuner() exit\n"));

		return;

	} END_ENSURE;

	* puiErrorCode = uiError;

    OutputDebugError(( "CATIWDMTuner:CATIWDMTuner() Error = %x\n", uiError));
}



/*^^*
 *		SetTunerCapabilities()
 * Purpose	:  Sets the capabilities ( RO properties) based upon the Tuner Id
 *
 * Inputs	:	UINT puiTunerId	: Tuner Id
 *
 * Outputs	: returns TRUE, if there is a supported Tuner Id specified;
 *				also sets the following WDM Tuner properities:
 * Author	: IKLEBANOV
 *^^*/
BOOL CATIWDMTuner::SetTunerWDMCapabilities( UINT uiTunerId)
{
	
	::RtlZeroMemory( &m_wdmTunerCaps, sizeof( ATI_KSPROPERTY_TUNER_CAPS));
	m_ulIntermediateFrequency = 0x0L;

	switch( uiTunerId)
	{
		case 0x01:		// FI1236 NTSC M/N North America
			m_ulNumberOfStandards = 3;
			m_wdmTunerCaps.ulStandardsSupported = KS_AnalogVideo_NTSC_M	|
												  KS_AnalogVideo_PAL_M |
                                                  KS_AnalogVideo_PAL_N;
			m_wdmTunerCaps.ulNumberOfInputs = 1;
			m_wdmTunerCaps.ulMinFrequency =  54000000L;
			m_wdmTunerCaps.ulMaxFrequency = 801250000L;
			m_ulIntermediateFrequency = 45750000L;
			m_ulSupportedModes = KSPROPERTY_TUNER_MODE_TV;
			m_ulNumberOfPins = 2;
				break;

		case 0x02:		// FI1236J NTSC M/N Japan
			m_ulNumberOfStandards = 1;
			m_wdmTunerCaps.ulStandardsSupported = KS_AnalogVideo_NTSC_M_J;
			m_wdmTunerCaps.ulNumberOfInputs = 1;
			m_wdmTunerCaps.ulMinFrequency =  54000000L;
			m_wdmTunerCaps.ulMaxFrequency = 765250000L;
			m_ulIntermediateFrequency = 45750000L; 
			m_ulSupportedModes = KSPROPERTY_TUNER_MODE_TV;
			m_ulNumberOfPins = 2;
			break;

		case 0x03:		// FI1216 PAL B/G
			m_ulNumberOfStandards = 2;
			m_wdmTunerCaps.ulStandardsSupported = KS_AnalogVideo_PAL_B	|
												  KS_AnalogVideo_PAL_G;
			m_wdmTunerCaps.ulNumberOfInputs = 1;
			m_wdmTunerCaps.ulMinFrequency =  54000000L;
			m_wdmTunerCaps.ulMaxFrequency = 855250000L;
			m_ulIntermediateFrequency = 38900000L; 
			m_ulSupportedModes = KSPROPERTY_TUNER_MODE_TV;
			m_ulNumberOfPins = 2;
			break;

		case 0x04:		// FI1246 MK2 PAL I
			m_ulNumberOfStandards = 1;
			m_wdmTunerCaps.ulStandardsSupported = KS_AnalogVideo_PAL_I;
			m_wdmTunerCaps.ulNumberOfInputs = 1;
			m_wdmTunerCaps.ulMinFrequency =  45750000L;
			m_wdmTunerCaps.ulMaxFrequency = 855250000L;
			m_ulIntermediateFrequency = 38900000L; 
			m_ulSupportedModes = KSPROPERTY_TUNER_MODE_TV;
			m_ulNumberOfPins = 2;
			break;

		case 0x05:		// FI1216 PAL B/G, SECAM L/L'
			m_ulNumberOfStandards = 3;
			m_wdmTunerCaps.ulStandardsSupported =	KS_AnalogVideo_PAL_B |
													KS_AnalogVideo_PAL_G |
													KS_AnalogVideo_SECAM_L;
			m_wdmTunerCaps.ulNumberOfInputs = 1;
			m_wdmTunerCaps.ulMinFrequency =  54000000L;
			m_wdmTunerCaps.ulMaxFrequency = 855250000L;
			m_ulIntermediateFrequency = 38900000L; 
			m_ulSupportedModes = KSPROPERTY_TUNER_MODE_TV;
			m_ulNumberOfPins = 2;
			break;

		case 0x06:		// FR1236MK2 NTSC M/N North America + Japan
			m_ulNumberOfStandards = 4;
			m_wdmTunerCaps.ulStandardsSupported = KS_AnalogVideo_NTSC_M	|
												  KS_AnalogVideo_PAL_M	|
												  KS_AnalogVideo_NTSC_M_J |
                                                  KS_AnalogVideo_PAL_N;
			m_wdmTunerCaps.ulNumberOfInputs = 1;
			m_wdmTunerCaps.ulMinFrequency =  54000000L;
			m_wdmTunerCaps.ulMaxFrequency = 801250000L;
			m_ulIntermediateFrequency = 45750000L; 
			m_ulSupportedModes = KSPROPERTY_TUNER_MODE_TV;
			m_ulNumberOfPins = 2;
			break;

		case 0x07:		// FI1256 PAL D/K China
			m_ulNumberOfStandards = 1;
			m_wdmTunerCaps.ulStandardsSupported =	KS_AnalogVideo_PAL_D |
													KS_AnalogVideo_SECAM_D;
			m_wdmTunerCaps.ulNumberOfInputs = 1;
			m_wdmTunerCaps.ulMinFrequency =  48250000L;
			m_wdmTunerCaps.ulMaxFrequency = 855250000L;
			m_ulIntermediateFrequency = 38000000L; 
			m_ulSupportedModes = KSPROPERTY_TUNER_MODE_TV;
			m_ulNumberOfPins = 2;
			break;

		case 0x08:		// NTSC North America NEC FM Tuner
			m_ulNumberOfStandards = 3;
			m_wdmTunerCaps.ulStandardsSupported = KS_AnalogVideo_NTSC_M |
												  KS_AnalogVideo_PAL_M |
                                                  KS_AnalogVideo_PAL_N;
			m_wdmTunerCaps.ulNumberOfInputs = 2;
			m_wdmTunerCaps.ulMinFrequency =  54000000L;
			m_wdmTunerCaps.ulMaxFrequency = 801250000L;
			m_ulIntermediateFrequency = 45750000L; 
			m_ulSupportedModes = KSPROPERTY_TUNER_MODE_TV |
								 KSPROPERTY_TUNER_MODE_FM_RADIO;
			m_ulNumberOfPins = 2;
			break;

		case 0x10:		// NTSC North America Alps Tuner
		case 0x11:		// NTSC North America Alps Tuner
			m_ulNumberOfStandards = 3;
			m_wdmTunerCaps.ulStandardsSupported = KS_AnalogVideo_NTSC_M |
												  KS_AnalogVideo_PAL_M |
                                                  KS_AnalogVideo_PAL_N;
			m_wdmTunerCaps.ulNumberOfInputs = 1;
			m_wdmTunerCaps.ulMinFrequency =  54000000L;
			m_wdmTunerCaps.ulMaxFrequency = 801250000L;
			m_ulIntermediateFrequency = 45750000L; 
			m_ulSupportedModes = KSPROPERTY_TUNER_MODE_TV;
			m_ulNumberOfPins = 2;
			break;

		case 0x12:		// NTSC North America Alps Tuner with FM
			m_ulNumberOfStandards = 3;
			m_wdmTunerCaps.ulStandardsSupported = KS_AnalogVideo_NTSC_M |
												  KS_AnalogVideo_PAL_M |
                                                  KS_AnalogVideo_PAL_N;
			m_wdmTunerCaps.ulNumberOfInputs = 1;
			m_wdmTunerCaps.ulMinFrequency =  54000000L;
			m_wdmTunerCaps.ulMaxFrequency = 801250000L;
			m_ulIntermediateFrequency = 45750000L; 
			m_ulSupportedModes = KSPROPERTY_TUNER_MODE_TV |
								 KSPROPERTY_TUNER_MODE_FM_RADIO;
			m_ulNumberOfPins = 2;
			break;

		case 0x0D:		// Temic 4006 FN5 PAL B/G + PAL/I + PAL D + SECAM D/K
			m_ulNumberOfStandards = 6;
			m_wdmTunerCaps.ulStandardsSupported =	KS_AnalogVideo_PAL_B	|
													KS_AnalogVideo_PAL_G	|
													KS_AnalogVideo_PAL_I	|
													KS_AnalogVideo_PAL_D	|
													KS_AnalogVideo_SECAM_D	|
													KS_AnalogVideo_SECAM_K;
			m_wdmTunerCaps.ulNumberOfInputs = 1;
			m_wdmTunerCaps.ulMinFrequency =  45000000L;
			m_wdmTunerCaps.ulMaxFrequency = 868000000L;
			m_ulIntermediateFrequency = 38900000L; 
			m_ulSupportedModes = KSPROPERTY_TUNER_MODE_TV;
			m_ulNumberOfPins = 2;
			break;


		default:
			return( FALSE);
	}

	m_ulTunerMode = KSPROPERTY_TUNER_MODE_TV;

	m_wdmTunerCaps.ulTuningGranularity = 62500L;
	m_wdmTunerCaps.ulSettlingTime = 150;
	m_wdmTunerCaps.ulStrategy = KS_TUNER_STRATEGY_PLL;

	return( TRUE);
}



/*^^*
 *		AdapterSetPowerState()
 * Purpose	:	Sets Power Managemeny mode
 *
 * Inputs	:	PHW_STREAM_REQUEST_BLOCK pSrb	: pointer to the current Srb
 *
 * Outputs	:	NTSTATUS as the result of operation
 * Author	:	TOM
 *^^*/
NTSTATUS CATIWDMTuner::AdapterSetPowerState( PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PADAPTER_DATA_EXTENSION pPrivateData = 
		( PADAPTER_DATA_EXTENSION)(( PHW_STREAM_REQUEST_BLOCK)pSrb)->HwDeviceExtension;
	CI2CScript *		pCScript	= &pPrivateData->CScript;
    DEVICE_POWER_STATE	nDeviceState = pSrb->CommandData.DeviceState;
	LARGE_INTEGER		liWakeUpTime;
	NTSTATUS			ntStatus;

	m_pPendingDeviceSrb = pSrb;
	ntStatus = STATUS_ADAPTER_HARDWARE_ERROR;

	switch( nDeviceState)
	{
		case PowerDeviceD0:
		case PowerDeviceD3:
			if( nDeviceState != m_ulPowerState)
			{
				m_CATIConfiguration.SetTunerPowerState( m_pI2CScript,
										( nDeviceState == PowerDeviceD0 ? TRUE : FALSE));

				// if transition form D3 to D0 we have to restore frequency
				if(( nDeviceState == PowerDeviceD0) && ( m_ulPowerState == PowerDeviceD3))
				{
					// we have to wait approx. 10ms for tuner to power up
					liWakeUpTime.QuadPart = ATIHARDWARE_TUNER_WAKEUP_DELAY;
					KeDelayExecutionThread( KernelMode, FALSE, &liWakeUpTime);

					// now we have to restore frequency
					if( SetTunerFrequency( m_ulTuningFrequency))
						ntStatus = STATUS_SUCCESS;
					else
						ntStatus = STATUS_ADAPTER_HARDWARE_ERROR;
				}
				else
					ntStatus = STATUS_SUCCESS;

				m_ulPowerState = nDeviceState;
			}
			else
				ntStatus = STATUS_SUCCESS;
			break;

		case PowerDeviceD1:
		case PowerDeviceD2:
			ntStatus = STATUS_SUCCESS;
			break;

		default:
			ntStatus = STATUS_INVALID_PARAMETER;
			break;
	}

	return( ntStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\tvaudio\atitvsnd\atitvsnd.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//	ATIVSnd.H
//	WDM TV Audio MiniDriver. 
//		AllInWonder/AllInWonderPro hardware development platform. 
//			Main Include Module.
//
//==========================================================================;

#ifndef _ATITVSND_H_
#define _ATITVSND_H_

#include "wdmtvsnd.h"

typedef struct
{
	CI2CScript		CScript;
	CWDMTVAudio		CTVAudio;

	PDEVICE_OBJECT	PhysicalDeviceObject;

	// for managing SRB Queue and internal driver synchronization
	BOOL			bSrbInProcess;
	LIST_ENTRY		adapterSrbQueueHead;
	KSPIN_LOCK		adapterSpinLock;

} ADAPTER_DATA_EXTENSION, * PADAPTER_DATA_EXTENSION;


typedef struct
{
	// please, don't move this member from its first place in the structure
	// if you do, change the code to use FIELDOFFSET macro to retrieve pSrb
	// member offset within this structure. The code as it's written assumes
	// LIST_ENTRY * == SRB_DATA_EXTENSION *
	LIST_ENTRY					srbListEntry;
	PHW_STREAM_REQUEST_BLOCK	pSrb;

} SRB_DATA_EXTENSION, * PSRB_DATA_EXTENSION;


/*
	Call-backs from the StreamClass
*/
extern "C"
void STREAMAPI TVAudioReceivePacket				( PHW_STREAM_REQUEST_BLOCK pSrb);
extern "C"
void STREAMAPI TVAudioCancelPacket				( PHW_STREAM_REQUEST_BLOCK pSrb);
extern "C" 
void STREAMAPI TVAudioTimeoutPacket				( PHW_STREAM_REQUEST_BLOCK pSrb);



/*
	Local prototypes
*/
void TVAudioAdapterInitialize					( PHW_STREAM_REQUEST_BLOCK pSrb);


#endif	// _ATITVSND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\tuners\1236\wdmtuner.h ===
//==========================================================================;
//
//	WDMTuner.H
//	WDM Tuner MiniDriver. 
//		CWDMTuner Class definition.
//  Copyright (c) 1996 - 1997  ATI Technologies Inc.  All Rights Reserved.
//
//==========================================================================;

#ifndef _WDMTUNER_H_
#define _WDMTUNER_H_

#include "i2script.h"
#include "aticonfg.h"
#include "pinmedia.h"

#define	KSPROPERTIES_TUNER_LAST			( KSPROPERTY_TUNER_STATUS + 1) 

typedef struct							// this structure is derived from MS KSPROPERTY_TUNER_CAPS_S
{
    ULONG  ulStandardsSupported;		// KS_AnalogVideo_*
    ULONG  ulMinFrequency;				// Hz
    ULONG  ulMaxFrequency;				// Hz
    ULONG  ulTuningGranularity;			// Hz
    ULONG  ulNumberOfInputs;			// count of inputs
    ULONG  ulSettlingTime;				// milliSeconds
    ULONG  ulStrategy;					// KS_TUNER_STRATEGY

} ATI_KSPROPERTY_TUNER_CAPS, * PATI_KSPROPERTY_TUNER_CAPS;


class CATIWDMTuner
{
public:
	CATIWDMTuner		( PDEVICE_OBJECT pDeviceObject, CI2CScript * pCScript, PUINT puiErrorCode);
	~CATIWDMTuner		();
	PVOID operator new	( size_t stSize, PVOID pAllocation);

// Attributes	
private:
	// pending device Srb
	PHW_STREAM_REQUEST_BLOCK	m_pPendingDeviceSrb;

	// WDM global topology headers
	GUID						m_wdmTunerTopologyCategory;
	KSTOPOLOGY					m_wdmTunerTopology;

	// WDM global property headers
	PKSPIN_MEDIUM				m_pTVTunerPinsMediumInfo;
	PBOOL						m_pTVTunerPinsDirectionInfo;
	KSPROPERTY_ITEM				m_wdmTunerProperties[KSPROPERTIES_TUNER_LAST];
	KSPROPERTY_SET				m_wdmTunerPropertySet;

	// WDM global stream headers
	HW_STREAM_HEADER			m_wdmTunerStreamHeader;

	// WDM adapter properties
	// configuration properties
	CATIHwConfiguration			m_CATIConfiguration;
	ULONG						m_ulNumberOfStandards;
	ATI_KSPROPERTY_TUNER_CAPS	m_wdmTunerCaps;
	ULONG						m_ulVideoStandard;
	ULONG						m_ulTuningFrequency;
	ULONG						m_ulSupportedModes;
	ULONG						m_ulTunerMode;
	ULONG						m_ulNumberOfPins;
	ULONG						m_ulTunerInput;
	DEVICE_POWER_STATE			m_ulPowerState;

	// configuration properties
	UINT						m_uiTunerId;
	ULONG						m_ulIntermediateFrequency;
	UCHAR						m_uchTunerI2CAddress;

	// I2C client properties
	CI2CScript *				m_pI2CScript;

// Implementation
public:
	BOOL		AdapterUnInitialize				( PHW_STREAM_REQUEST_BLOCK pSrb);
	BOOL		AdapterGetStreamInfo			( PHW_STREAM_REQUEST_BLOCK pSrb);
	BOOL		AdapterQueryUnload				( PHW_STREAM_REQUEST_BLOCK pSrb);
	BOOL		AdapterGetProperty				( PHW_STREAM_REQUEST_BLOCK pSrb);
	BOOL		AdapterSetProperty				( PHW_STREAM_REQUEST_BLOCK pSrb);
	NTSTATUS	AdapterSetPowerState			( PHW_STREAM_REQUEST_BLOCK pSrb);
	NTSTATUS	AdapterCompleteInitialization	( PHW_STREAM_REQUEST_BLOCK pSrb);

private:
	BOOL		SetTunerWDMCapabilities			( UINT uiTunerId);
	void		SetWDMTunerKSProperties			( void);
	void		SetWDMTunerKSTopology			( void);

	BOOL		SetTunerVideoStandard			( ULONG ulStandard);
	BOOL		SetTunerInput					( ULONG nInput);
	BOOL		SetTunerFrequency				( ULONG ulFrequency);
	BOOL		SetTunerMode					( ULONG ulModeToSet);

	BOOL		GetTunerPLLOffsetBusyStatus		( PLONG plPLLOffset, PBOOL pbBusyStatus);

	USHORT		GetTunerControlCode				( ULONG ulFrequencyDivider);
};


#endif	// _WDMTUNER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\tvaudio\atitvsnd\atitvsnd.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//	ATITVSnd.CPP
//	WDM TV Audio MiniDriver. 
//		AllInWonder/AllInWonderPro development platform. 
//			Main Source Module.
//
//		$Date:   01 Apr 1998 13:29:14  $
//	$Revision:   1.1  $
//	  $Author:   KLEBANOV  $
//
//==========================================================================;

extern "C"
{
#include "strmini.h"
#include "ksmedia.h"

#include "wdmdebug.h"
}

#include "atitvsnd.h"
#include "wdmdrv.h"



/*^^*
 *		DriverEntry()
 * Purpose	: Called when an SRB_INITIALIZE_DEVICE request is received
 *
 * Inputs	: PVOID Arg1, PVOID Arg2
 *
 * Outputs	: result of StreamClassregisterAdapter()
 * Author	: IKLEBANOV
 *^^*/
extern "C" 
ULONG DriverEntry (	IN PDRIVER_OBJECT	pDriverObject,
					IN PUNICODE_STRING	pRegistryPath )
{
	HW_INITIALIZATION_DATA HwInitData;

	SetMiniDriverDebugLevel( pRegistryPath);

 	OutputDebugTrace(( "ATITVSnd: DriverEntry\n"));
     
	RtlZeroMemory( &HwInitData, sizeof( HwInitData));

	HwInitData.HwInitializationDataSize = sizeof(HwInitData);

	// Entry points for Port Driver

	HwInitData.HwInterrupt					= NULL; // HwInterrupt;

	HwInitData.HwReceivePacket				= TVAudioReceivePacket;
	HwInitData.HwCancelPacket				= TVAudioCancelPacket;
	HwInitData.HwRequestTimeoutHandler		= TVAudioTimeoutPacket;

	HwInitData.DeviceExtensionSize			= sizeof( ADAPTER_DATA_EXTENSION);
	HwInitData.PerRequestExtensionSize		= sizeof( SRB_DATA_EXTENSION); 
	HwInitData.FilterInstanceExtensionSize	= 0;
	HwInitData.PerStreamExtensionSize		= 0;
	HwInitData.BusMasterDMA					= FALSE;  
	HwInitData.Dma24BitAddresses			= FALSE;
	HwInitData.BufferAlignment				= 3;
//	HwInitData.TurnOffSynchronization		= FALSE;
	// we turn the synchronization ON. StreamClass is expected to call the MiniDriver
	// at passive level only
	HwInitData.TurnOffSynchronization		= TRUE;
	HwInitData.DmaBufferSize				= 0;

	OutputDebugTrace(( "ATITVSnd: StreamClassRegisterAdapter\n"));

	return( StreamClassRegisterAdapter( pDriverObject, pRegistryPath, &HwInitData));
}



/*^^*
 *		TVAudioReceivePacket()
 * Purpose	: Main entry point for receiving adapter based request SRBs from the Class Driver.
 *				Will always be called at passive level, because the drivers
 *				turned the synchronization ON.
 * Note		: This is an asyncronous entry point. The request only completes when a 
 *				StreamClassDeviceNotification on this SRB, of type  DeviceRequestComplete,
 *				is issued. As soon we're running at passive level, we can do everything 
 *				synchronously during the response to the SRBs with no worry
 *				to block somebody else for a long timer during I2C access
 *
 * Inputs	: PHW_STREAM_REQUEST_BLOCK pSrb	: pointer to the current Srb
 *
 * Outputs	: none
 * Author	: IKLEBANOV
 *^^*/
extern "C" 
void STREAMAPI TVAudioReceivePacket( IN OUT PHW_STREAM_REQUEST_BLOCK pSrb)
{
    CWDMTVAudio *			pCTVAudio;
	KIRQL					irqlCurrent;
    PADAPTER_DATA_EXTENSION pPrivateData = ( PADAPTER_DATA_EXTENSION)( pSrb->HwDeviceExtension);
    PSRB_DATA_EXTENSION		pSrbPrivate = ( PSRB_DATA_EXTENSION)( pSrb->SRBExtension);

	// check the device extension pointer
	if(( pPrivateData == NULL) || ( pSrbPrivate == NULL))
	{
		TRAP;
		pSrb->Status = STATUS_INVALID_PARAMETER;
		StreamClassDeviceNotification( DeviceRequestComplete, pSrb->HwDeviceExtension, pSrb);
	}

    OutputDebugInfo(( "ATITVSnd: TVAudioReceivePacket() SRB = %x\n", pSrb));

	if( pSrb->Command == SRB_INITIALIZE_DEVICE)
	{
		// this is the special case for SRB_INITIALIZE_DEVICE, because
		// no Queue has been initialized yet. Everything we need later on
		// is initialized during this SRB response
		TVAudioAdapterInitialize( pSrb);

		StreamClassDeviceNotification( DeviceRequestComplete, pSrb->HwDeviceExtension, pSrb);
		return;
	}

	// the rest of the SRBs are coming after SpinLock and SRBQueue have been initialized
	// during DRB_INITIALIZE_DEVICE SRB response.
	// I'll insert the SRB in the Queue first of all. The processing SRB from the Queue
	// can be triggered by finishing processing and SRB, or by the fact there is no SRB
	// is in process down here
	pSrbPrivate->pSrb = pSrb;

	// Everything we're doing with the Queue has to be protected from being interrupted
	KeAcquireSpinLock( &pPrivateData->adapterSpinLock, &irqlCurrent);
	InsertTailList( &pPrivateData->adapterSrbQueueHead, &pSrbPrivate->srbListEntry);

	if( pPrivateData->bSrbInProcess)
	{
		// there is another SRB being processed, and the new one will be picked up from
		// the Queue when it's its turn.
		KeReleaseSpinLock( &pPrivateData->adapterSpinLock, irqlCurrent);
		return;
	}

	while( !IsListEmpty( &pPrivateData->adapterSrbQueueHead))
	{
		// turn on the semaphore for the others coming after
		pPrivateData->bSrbInProcess = TRUE;

		// be carefull here, if you've changed the place where srbListEntry is defined
		// within the SRB_DATA_EXTENSION structure
		pSrbPrivate = ( PSRB_DATA_EXTENSION)RemoveHeadList( &pPrivateData->adapterSrbQueueHead);
		KeReleaseSpinLock( &pPrivateData->adapterSpinLock, irqlCurrent);

		// here is the place to process the SRB we have retrieved from the Queue
		pSrb = pSrbPrivate->pSrb;
		pPrivateData = ( PADAPTER_DATA_EXTENSION)( pSrb->HwDeviceExtension);
		pCTVAudio = &pPrivateData->CTVAudio;

		ASSERT( pSrb->Status != STATUS_CANCELLED);

	    switch( pSrb->Command)
		{
			case SRB_INITIALIZATION_COMPLETE:
				// StreamClass has completed the initialization
				pSrb->Status = pCTVAudio->AdapterCompleteInitialization( pSrb);
				break;

			case SRB_UNINITIALIZE_DEVICE:
				// close the device.  
				pCTVAudio->AdapterUnInitialize( pSrb);
				break;

			case SRB_OPEN_STREAM:
			case SRB_CLOSE_STREAM:
				pSrb->Status = STATUS_NOT_IMPLEMENTED;
				break;

			case SRB_GET_STREAM_INFO:
				// return a block describing STREAM_INFO_HEADER and all the streams supported
				pCTVAudio->AdapterGetStreamInfo( pSrb);
				break;

			case SRB_CHANGE_POWER_STATE:
				pSrb->Status = pCTVAudio->AdapterSetPowerState( pSrb);
				break;

			case SRB_GET_DEVICE_PROPERTY:
				if( pCTVAudio->AdapterGetProperty( pSrb))
					pSrb->Status = STATUS_SUCCESS;
				else
					pSrb->Status = STATUS_INVALID_PARAMETER;
				break;        

			case SRB_SET_DEVICE_PROPERTY:
				if( pCTVAudio->AdapterSetProperty( pSrb))
					pSrb->Status = STATUS_SUCCESS;
				else
					pSrb->Status = STATUS_INVALID_PARAMETER;
				break;

			// We should never get the following since this is a single instance device
			case SRB_OPEN_DEVICE_INSTANCE:
			case SRB_CLOSE_DEVICE_INSTANCE:
				TRAP
				pSrb->Status = STATUS_NOT_IMPLEMENTED;
				break;

			case SRB_UNKNOWN_DEVICE_COMMAND:
				// we know we're getting some of these. Why should we?
				pSrb->Status = STATUS_NOT_IMPLEMENTED;
				break;

			default:
				// TRAP
				// this is a request that we do not understand.  Indicate invalid command and complete the request
				pSrb->Status = STATUS_NOT_IMPLEMENTED;
		}

		StreamClassDeviceNotification( DeviceRequestComplete, pPrivateData, pSrb);

		KeAcquireSpinLock( &pPrivateData->adapterSpinLock, &irqlCurrent);
	}

	// turn off the semaphore to enable the others coming after
	pPrivateData->bSrbInProcess = FALSE;

	KeReleaseSpinLock( &pPrivateData->adapterSpinLock, irqlCurrent);
	// there is no other SRB being processed at this time, let's start processing

}


extern "C" 
void STREAMAPI TVAudioCancelPacket( IN OUT PHW_STREAM_REQUEST_BLOCK pSrb)
{

	pSrb->Status = STATUS_CANCELLED;
}


extern "C" 
void STREAMAPI TVAudioTimeoutPacket( IN OUT PHW_STREAM_REQUEST_BLOCK pSrb)
{

	// not sure what to do here.
}


/*^^*
 *		TVAudioAdapterInitialize()
 * Purpose	: Called when SRB_INITIALIZE_DEVICE SRB is received.
 *				Performs checking of the hardware presence and I2C provider availability.
 *				Sets the hardware in an initial state.
 * Note		: The request does not completed unless we know everything
 *				about the hardware and we are sure it is capable to work in the current configuration.
 *				The hardware Caps are also aquised at this point. As soon this
 *				function is called at passive level, do everything synchronously
 *
 * Inputs	: PHW_STREAM_REQUEST_BLOCK pSrb	: pointer to the current Srb
 *
 * Outputs	: none
 * Author	: IKLEBANOV
 *^^*/
void TVAudioAdapterInitialize( IN OUT PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PPORT_CONFIGURATION_INFORMATION pConfigInfo = pSrb->CommandData.ConfigInfo;
    PADAPTER_DATA_EXTENSION pPrivateData = ( PADAPTER_DATA_EXTENSION)( pConfigInfo->HwDeviceExtension);
	NTSTATUS		ntStatus = STATUS_NO_SUCH_DEVICE;
	CWDMTVAudio *	pCTVAudio;
	CI2CScript *	pCScript;
	UINT			nErrorCode;

    OutputDebugTrace(( "ATITVSnd: TVAudioAdapterInitialize()\n"));

    ENSURE
	{
		if( pConfigInfo->NumberOfAccessRanges != 0) 
		{
			OutputDebugError(( "ATITVSnd: illegal NumberOfAccessRanges = %lx\n", pConfigInfo->NumberOfAccessRanges));
			FAIL;
		}

		// if we have I2CProvider implemented inside the MiniVDD, we have to
		// get a pointer to I2CInterface from the Provider.

		// There is an overloaded operator new provided for the CI2CScript Class.
		pCScript = ( CI2CScript *)new(( PVOID)&pPrivateData->CScript)		\
						CI2CScript( pConfigInfo->PhysicalDeviceObject, &nErrorCode);
		if( nErrorCode != WDMMINI_NOERROR)
		{
			OutputDebugError(( "ATITVSnd: CI2CScript creation failure = %lx\n", nErrorCode));
			FAIL;
		}
		
		// The CI2CScript object was created successfully.
		// We'll try to allocate I2CProvider here for future possible I2C
		// operations needed at Initialization time.
		if( !pCScript->LockI2CProviderEx())
		{
			OutputDebugError(( "ATITVSnd: unable to lock I2CProvider"));
			FAIL;
		}

		// we did lock the provider.
		// There is an overloaded operator new provided for the CWDMTVAudio Class.
		pCTVAudio = ( CWDMTVAudio *)new(( PVOID)&pPrivateData->CTVAudio) CWDMTVAudio( pConfigInfo->PhysicalDeviceObject,pCScript, &nErrorCode);
		if( nErrorCode)
		{
			OutputDebugError(( "ATITVSnd: CWDMTVAudio constructor failure = %lx\n", nErrorCode));
			FAIL;
		}

	    InitializeListHead ( &pPrivateData->adapterSrbQueueHead);
		KeInitializeSpinLock ( &pPrivateData->adapterSpinLock);

		pPrivateData->PhysicalDeviceObject = pConfigInfo->PhysicalDeviceObject;
		// no streams are supported
		pConfigInfo->StreamDescriptorSize = sizeof( HW_STREAM_HEADER);

		OutputDebugTrace(( "TVAudioAdapterInitialize(): exit\n"));

		ntStatus = STATUS_SUCCESS;

	} END_ENSURE;

    pCScript->ReleaseI2CProvider();

	pSrb->Status = ntStatus;
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\tvaudio\atitvsnd\tsndprop.cpp ===
//==========================================================================;
//
//	TSndProp.CPP
//	WDM TVAudio MiniDriver. 
//		AIW / AIWPro hardware platform. 
//			WDM Properties management.
//  Copyright (c) 1996 - 1997  ATI Technologies Inc.  All Rights Reserved.
//
//		$Date:   30 Jul 1998 17:36:30  $
//	$Revision:   1.2  $
//	  $Author:   KLEBANOV  $
//
//==========================================================================;

extern "C"
{
#include "strmini.h"
#include "ksmedia.h"

#include "wdmdebug.h"
}

#include "wdmdrv.h"
#include "atitvsnd.h"
#include "aticonfg.h"




/*^^*
 *		AdapterGetProperty()
 * Purpose	: Called when SRB_GET_PROPERTY SRB is received.
 *
 * Inputs	:	PHW_STREAM_REQUEST_BLOCK pSrb	: pointer to the current Srb
 *
 * Outputs	: BOOL : returns returns FALSE, if it is not a Tv Audio property
 *				it also returns the required property
 * Author	: IKLEBANOV
 *^^*/
BOOL CWDMTVAudio::AdapterGetProperty( PHW_STREAM_REQUEST_BLOCK pSrb)
{
	PSTREAM_PROPERTY_DESCRIPTOR pSpd = pSrb->CommandData.PropertyInfo;
	ULONG uiPropertyId = pSpd->Property->Id;				// index of the property
	ULONG nPropertyOutSize = pSpd->PropertyOutputSize;		// size of data requested

	if( !::IsEqualGUID(( const struct _GUID &)PROPSETID_VIDCAP_TVAUDIO, ( const struct _GUID &)pSpd->Property->Set))
		return( FALSE);

	ASSERT( pSpd != NULL);
	ASSERT( pSpd->PropertyInfo != NULL);
	
	OutputDebugInfo(( "CWDMAVXBar:AdapterGetProperty() Id = %d\n", uiPropertyId));

	switch( uiPropertyId)
	{
		case KSPROPERTY_TVAUDIO_CAPS:
			{
				PKSPROPERTY_TVAUDIO_CAPS_S pTVAudioCaps = ( PKSPROPERTY_TVAUDIO_CAPS_S)pSpd->PropertyInfo;

				ASSERT( nPropertyOutSize >= sizeof( KSPROPERTY_TVAUDIO_CAPS_S));

				// Copy the input property info to the output property info
				::RtlCopyMemory( pTVAudioCaps, pSpd->Property, sizeof( KSPROPERTY_TVAUDIO_CAPS_S));
				
				pTVAudioCaps->Capabilities = m_ulModesSupported;
/*
				pTVAudioCaps->InputMedium = &m_wdmTVAudioPinsMediumInfo[0];
				pTVAudioCaps->OutputMedium = &m_wdmTVAudioPinsMediumInfo[1];
*/
				pTVAudioCaps->InputMedium = m_wdmTVAudioPinsMediumInfo[0];
				pTVAudioCaps->OutputMedium = m_wdmTVAudioPinsMediumInfo[1];
			}

			pSrb->ActualBytesTransferred = sizeof( KSPROPERTY_TVAUDIO_CAPS_S);
			break;

		case KSPROPERTY_TVAUDIO_MODE:
			{
				PKSPROPERTY_TVAUDIO_S	pTVAudioMode = ( PKSPROPERTY_TVAUDIO_S)pSpd->PropertyInfo;

				ASSERT( nPropertyOutSize >= sizeof( KSPROPERTY_TVAUDIO_S));

				// Copy the input property info to the output property info
				::RtlCopyMemory( pTVAudioMode, pSpd->Property, sizeof( KSPROPERTY_TVAUDIO_S));
			
				// GetMode returns the mode the device was set up with,  not the current read back from
				// the device itself ( current AudioSignal Properties)
				pTVAudioMode->Mode = m_ulTVAudioMode;
				pSrb->ActualBytesTransferred = sizeof( KSPROPERTY_TVAUDIO_S);
			}
			break;

		case KSPROPERTY_TVAUDIO_CURRENTLY_AVAILABLE_MODES:
			{
				ULONG					ulAudioMode;
				PKSPROPERTY_TVAUDIO_S	pTVAudioMode = ( PKSPROPERTY_TVAUDIO_S)pSpd->PropertyInfo;

				ASSERT( nPropertyOutSize >= sizeof( KSPROPERTY_TVAUDIO_S));

				// Copy the input property info to the output property info
				::RtlCopyMemory( pTVAudioMode, pSpd->Property, sizeof( KSPROPERTY_TVAUDIO_S));

				if( !GetAudioOperationMode( &ulAudioMode))
					return( FALSE);

				m_ulTVAudioSignalProperties = ulAudioMode;
				pTVAudioMode->Mode = ulAudioMode;
				pSrb->ActualBytesTransferred = sizeof( KSPROPERTY_TVAUDIO_S);
			}
			break;

		default:
			TRAP;
			return( FALSE);
	}

	return( TRUE);
}



/*^^*
 *		AdapterSetProperty()
 * Purpose	: Called when SRB_GET_PROPERTY SRB is received.
 *
 * Inputs	:	PHW_STREAM_REQUEST_BLOCK pSrb	: pointer to the current Srb
 *
 * Outputs	: BOOL : returns FALSE, if it is not a TV Audio property
 *				it also sets the required property
 * Author	: IKLEBANOV
 *^^*/
BOOL CWDMTVAudio::AdapterSetProperty( PHW_STREAM_REQUEST_BLOCK pSrb)
{
	PSTREAM_PROPERTY_DESCRIPTOR pSpd = pSrb->CommandData.PropertyInfo;
	ULONG uiPropertyId = pSpd->Property->Id;			// index of the property
	ULONG nPropertyInSize = pSpd->PropertyOutputSize;	// size of data supplied

	if( !::IsEqualGUID( ( const struct _GUID &)PROPSETID_VIDCAP_TVAUDIO, ( const struct _GUID &)pSpd->Property->Set))
		return( FALSE);

	ASSERT( pSpd != NULL);
	ASSERT( pSpd->PropertyInfo != NULL);
	ASSERT( nPropertyInSize >= sizeof( ULONG));
	
	OutputDebugInfo(( "CWDMAVXBar:AdapterSetProperty() Id = %d\n", uiPropertyId));

	switch( uiPropertyId)
	{
		case KSPROPERTY_TVAUDIO_MODE:
			{
				ULONG ulModeToSet = (( PKSPROPERTY_TVAUDIO_S)pSpd->PropertyInfo)->Mode;

				if( ulModeToSet == ( ulModeToSet & m_ulModesSupported))
				{
					// every mode we're asked to set is supported
					if( ulModeToSet != m_ulTVAudioMode)
					{
						if( !SetAudioOperationMode( ulModeToSet))
							return( FALSE);
						else
							// update the driver
							m_ulTVAudioMode = ulModeToSet;
					}
				}
				else
					return( FALSE);
			}
			break;

		default:
			TRAP;
			return( FALSE);
	}

	return( TRUE);
}



/*^^*
 *		SetWDMTVAudioKSTopology()
 * Purpose	: Sets the KSTopology structure
 *				Called during CWDMTVAudio class construction time.
 *
 * Inputs	: none
 *
 * Outputs	: none
 * Author	: IKLEBANOV
 *^^*/
void CWDMTVAudio::SetWDMTVAudioKSTopology( void)
{
	GUID wdmTVAudioTopologyCategory[] =
	{
		STATIC_KSCATEGORY_TVAUDIO
	};
	
	::RtlCopyMemory( &m_wdmTVAudioTopologyCategory, wdmTVAudioTopologyCategory, sizeof( wdmTVAudioTopologyCategory));

	m_wdmTVAudioTopology.CategoriesCount = 1;
	m_wdmTVAudioTopology.Categories = &m_wdmTVAudioTopologyCategory;
	m_wdmTVAudioTopology.TopologyNodesCount = 0;
	m_wdmTVAudioTopology.TopologyNodes = NULL;
	m_wdmTVAudioTopology.TopologyConnectionsCount = 0;
	m_wdmTVAudioTopology.TopologyConnections = NULL;
}



/*^^*
 *		SetWDMTVAudioKSProperties()
 * Purpose	: Sets the KSProperty structures array
 *				Called during CWDMTVAudio class construction time.
 *
 * Inputs	: none
 *
 * Outputs	: none
 * Author	: IKLEBANOV
 *^^*/
void CWDMTVAudio::SetWDMTVAudioKSProperties( void)
{

	DEFINE_KSPROPERTY_TABLE( wdmTVAudioProperties)
	{
		DEFINE_KSPROPERTY_ITEM
		(
    		KSPROPERTY_TVAUDIO_CAPS,
    		TRUE,									// GetSupported or Handler
    		sizeof( KSPROPERTY_TVAUDIO_CAPS_S),		// MinProperty
    		sizeof( KSPROPERTY_TVAUDIO_CAPS_S),		// MinData
    		FALSE,									// SetSupported or Handler
    		NULL,									// Values
    		0,										// RelationsCount
    		NULL,									// Relations
    		NULL,									// SupportHandler
    		0										// SerializedSize
		),

		DEFINE_KSPROPERTY_ITEM
		(
    		KSPROPERTY_TVAUDIO_MODE,
    		TRUE,									// GetSupported or Handler
    		sizeof( KSPROPERTY_TVAUDIO_S),			// MinProperty
    		sizeof( KSPROPERTY_TVAUDIO_S),			// MinData
    		TRUE,									// SetSupported or Handler
    		NULL,									// Values
    		0,										// RelationsCount
    		NULL,									// Relations
    		NULL,									// SupportHandler
    		0										// SerializedSize
		),

		DEFINE_KSPROPERTY_ITEM
		(
    		KSPROPERTY_TVAUDIO_CURRENTLY_AVAILABLE_MODES,
    		TRUE,									// GetSupported or Handler
    		sizeof( KSPROPERTY_TVAUDIO_S),			// MinProperty
    		sizeof( KSPROPERTY_TVAUDIO_S),			// MinData
    		FALSE,									// SetSupported or Handler
    		NULL,									// Values
    		0,										// RelationsCount
    		NULL,									// Relations
    		NULL,									// SupportHandler
    		0										// SerializedSize
		)
	};

	DEFINE_KSPROPERTY_SET_TABLE( wdmTVAudioPropertySet)
	{
		DEFINE_KSPROPERTY_SET
		(
			&PROPSETID_VIDCAP_TVAUDIO,						// Set
			KSPROPERTIES_TVAUDIO_NUMBER,					// PropertiesCount
			m_wdmTVAudioProperties,							// PropertyItems
			0,												// FastIoCount
			NULL,											// FastIoTable
		),
	};

	::RtlCopyMemory( &m_wdmTVAudioProperties, wdmTVAudioProperties, sizeof( wdmTVAudioProperties));
	::RtlCopyMemory( &m_wdmTVAudioPropertySet, wdmTVAudioPropertySet, sizeof( wdmTVAudioPropertySet));
}



/*^^*
 *		SetWDMTVAudioKSEvents()
 * Purpose	: Sets the KSEvent structures array
 *				Called during CWDMTVAudio class construction time.
 *
 * Inputs	: none
 *
 * Outputs	: none
 * Author	: IKLEBANOV
 *^^*/
void CWDMTVAudio::SetWDMTVAudioKSEvents( void)
{
	PKSEVENT_ITEM pKSEventItem = &m_wdmTVAudioEvents[0];

    pKSEventItem->EventId = KSEVENT_TVAUDIO_CHANGED;
    pKSEventItem->DataInput = pKSEventItem->ExtraEntryData = 0;
    pKSEventItem->AddHandler = NULL;
	pKSEventItem->RemoveHandler = NULL;
	pKSEventItem->SupportHandler = NULL;
    
	m_wdmTVAudioEventsSet[0].Set = &KSEVENTSETID_VIDCAP_TVAUDIO;
	m_wdmTVAudioEventsSet[0].EventsCount = 0;
	m_wdmTVAudioEventsSet[0].EventItem = pKSEventItem;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\avcstrm\avcdefs.h ===
//
// Differnt level of WDM supports may use different API
//
// e.g. MmGetSystemAddressForMdl (win9x) 
//          Return NULL for Win9x; bugcheck for Win2000 if NULL would have returned.
//
//      MmGetSystemAddressForMdlSafe (win2000)
//          Not supported in Win9x or Millen
//
// This is defined in SOURCES file.


#define NUM_BUF_ATTACHED_THEN_ISOCH         4   // number of buffers attached before streaming and also as the water mark.


//
// These definition and macros are used to calculate the picture numbers.
// With OHCI spec, the data is returned with the 16bit Cycle time, which includes
// 3 bits of SecondCount and 13 bits of the CycleCount.  This "timer" will wrap in 8 seconds.
//
#define TIME_PER_CYCLE     1250   // One 1394 cycle; unit = 100 nsec
#define CYCLES_PER_SECOND  8000
#define MAX_SECOND_COUNTS     7   // The returned CycleTime contains 3 bits of SecondCount; that is 0..7
#define MAX_CYCLES        (MAX_SECOND_COUNTS + 1) * CYCLES_PER_SECOND    // 0..MAX_CYCLES-1
#define MAX_CYCLES_TIME   (MAX_CYCLES * TIME_PER_CYCLE)                  // unit = 100nsec

#define VALIDATE_CYCLE_COUNTS(CT) ASSERT(CT.CL_SecondCount <= 7 && CT.CL_CycleCount < CYCLES_PER_SECOND && CT.CL_CycleOffset == 0);

#define CALCULATE_CYCLE_COUNTS(CT) (CT.CL_SecondCount * CYCLES_PER_SECOND + CT.CL_CycleCount);

#define CALCULATE_DELTA_CYCLE_COUNT(prev, now) ((now > prev) ? now - prev : now + MAX_CYCLES - prev)

//
// Return avg time per frame in the unit of 100 nsec; 
// for calculation accuracy using only integer calculation, 
// we should do do multimplcation before division.
// That is why the application can request to get numerator and denominator separately.
// 
#define GET_AVG_TIME_PER_FRAME(format)       ((format == AVCSTRM_FORMAT_SDDV_NTSC) ? (1001000/3)  : FRAME_TIME_PAL)
#define GET_AVG_TIME_PER_FRAME_NUM(format)   ((format == AVCSTRM_FORMAT_SDDV_NTSC) ? 1001000      : 400000)
#define GET_AVG_TIME_PER_FRAME_DENOM(format) ((format == AVCSTRM_FORMAT_SDDV_NTSC) ? 3            : 1)


#define GET_NUM_PACKETS_PER_FRAME(format)       ((format == AVCSTRM_FORMAT_SDDV_NTSC) ? 4004/15 /* 100100/375 */ : MAX_SRC_PACKETS_PER_PAL_FRAME)
#define GET_NUM_PACKETS_PER_FRAME_NUM(format)   ((format == AVCSTRM_FORMAT_SDDV_NTSC) ? 4004                     : MAX_SRC_PACKETS_PER_PAL_FRAME)
#define GET_NUM_PACKETS_PER_FRAME_DENOM(format) ((format == AVCSTRM_FORMAT_SDDV_NTSC) ? 15                       : 1)


//
// Structure used to keep track of and to perform stream data queuing
//
typedef struct _AVC_STREAM_DATA_STRUCT {

    ULONG  SizeOfThisPacket;

    //
    // Frame size is calculated based on
    //    CIP_DBS * 4 * (CIP_FN==0? 1 : (CIP_FN==1 ? 2 : (CIP_FN==2 ? 4 : 8)))
    //
    ULONG  SourcePacketSize;

    //
    // Frame size is calculated based on
    //    SourcePacketSize * SRC_PACKETS_PER_***
    //
    ULONG  FrameSize;

    //
    //  Current stream time
    //
    LONGLONG CurrentStreamTime;
    ULONG  LastCycleCount;  // Used only for MPEG2TS stream

    //
    // Statistic of the frame information since last start stream
    // PictureNumber = FramesProcessed + FramesDropped + cndSRBCancelled.
    //    
    LONGLONG  PictureNumber;     
    LONGLONG  FramesProcessed;   // Frame made it to 1394 serial bus.
    LONGLONG  FramesDropped;

#if DBG
    LONGLONG  FramesAttached;
#endif

    LONGLONG  cntFrameCancelled;

    //
    // Count number of Data IRP received
    //
    LONGLONG  cntDataReceived;

    //
    // Count and list for the attach list
    //
    LONG       cntDataAttached;
    LIST_ENTRY DataAttachedListHead;

    //
    // Count and list for the SRB list
    //
    LONG       cntDataQueued;        // Used only with SRB_WRITE_DATA
    LIST_ENTRY DataQueuedListHead;   // Used only with SRB_WRITE_DATA

    //
    // Count and list for the detach list
    //
    LONG       cntDataDetached;
    LIST_ENTRY DataDetachedListHead;

    //
    // Lock to serialize attach and detach of list
    //
    KSPIN_LOCK DataListLock;

    //
    // Memory blocked allocated at passive level for queuing data IOs.
    //
    PBYTE pMemoryBlock;

    //
    // Signalled when there is no more attach frame; mainoy used to guarantee that all
    // data attached are transmitted before isoch is stopped for transmitting data
    // from PC to AVC device.
    //  
    KEVENT hNoAttachEvent;


} AVC_STREAM_DATA_STRUCT, * PAVC_STREAM_DATA_STRUCT;


typedef struct DEVICE_EXTENSION;

//
// An AVC stream extension is created per stream opened.  This will be returned to the caller,
// when it will be used as the context (like a HANDLE) for subsequent call.
// The allocation will include
//
//     AVC_STREAM_EXTENSION
//     AV1394_FORMAT_INFO
//     AV_CLIENT_REQ
//
typedef struct _AVC_STREAM_EXTENSION {

    ULONG  SizeOfThisPacket;

    //
    // This driver's device extension
    //
    struct DEVICE_EXTENSION  * pDevExt;

    //
    // Data flow direction
    //
    KSPIN_DATAFLOW  DataFlow;  // Determine in or output pin

    //
    // Holds state
    //
    KSSTATE StreamState;

    //
    // This flag indicate if isoch is TALK/LISTEN or STOPPED
    //
    BOOLEAN IsochIsActive;  // Close associated with StreamState

    //
    // Abstrction i/oPCR of an AVC device and PC itself as a plug handles
    // Connection handle is used when two plugs are connected.
    // 
    HANDLE  hPlugRemote;  // Target (DVCR,D-VHS) device plug;
    HANDLE  hPlugLocal;   //.Local i/oPCR;
    HANDLE  hConnect;     // Connect two plugs

    //
    // Structure for specifing an AVC stream
    //
    PAVCSTRM_FORMAT_INFO  pAVCStrmFormatInfo;

    //
    // Structure for data flow control (IsochActive, IOQueues..etc)
    //
    PAVC_STREAM_DATA_STRUCT pAVCStrmDataStruc;

    //
    // Synchronizing setting stream control and processing data
    //
    KMUTEX  hMutexControl;


    //
    // Synchronize sharing the below AV_61883_REQUEST structure
    // Since all the stream control are synchronouse so we can use the same 
    // AV61883Req structure to issue 61883 request
    //
    KMUTEX  hMutexAVReq;
    PIRP  pIrpAVReq;
    AV_61883_REQUEST  AVReq;


    //
    // Counter used to indicate starting of an work item to cancel 
    //
    LONG lAbortToken;

    //
    // Hold the work item
    //
#ifdef USE_WDM110  // Win2000 code base
    PIO_WORKITEM       pIoWorkItem;
#else
    WORK_QUEUE_ITEM    IoWorkItem;
#endif

    //
    // TO signal that an work item is completed.
    //
    KEVENT hAbortDoneEvent;

    //
    // Cached plug state (these are dynamic values)
    //
    CMP_GET_PLUG_STATE  RemotePlugState;

#ifdef NT51_61883
    //
    // Cyclic cycle count of last DV frame
    //
    ULONG  CycleCount16bits;
#endif  // NT51_61883

    //
    // Keep track of the last system time when the stream time was updated.
    // This is used to calibrate the current stream time when it is queries.
    //
    ULONGLONG LastSystemTime;


    //
    // Discontinuity is introduced when traistioning from RUN->PAUSE->RUN.
    // The stream time will not increment in PAUSE state but system time (1394 CycleTime) does.
    //
    BOOL  b1stNewFrameFromPauseState;

} AVC_STREAM_EXTENSION, *PAVC_STREAM_EXTENSION;


//
// Valid data entry states for a data request and they
// can be Or'ed to show their code path.
//
// Examples of different possible code path: 
//
//    (A) Attached -> Pending -> Callback -> Completed 
//    (B) Callback -> Attached -> Completed
//    (C) Attached -> Cancelled -> Completed
//

enum DATA_ENTRY_STATE {
    DE_PREPARED                     = 0x01,
    DE_IRP_LOWER_ATTACHED_COMPLETED = 0x02,
    DE_IRP_UPPER_PENDING_COMPLETED  = 0x04,
    DE_IRP_LOWER_CALLBACK_COMPLETED = 0x08,
    DE_IRP_UPPER_COMPLETED          = 0x10,    
    DE_IRP_ERROR                    = 0x20,    
    DE_IRP_CANCELLED                = 0x40,    
};

#define IsStateSet(state, bitmask) ((state & (bitmask)) == bitmask)

//
// This is the data entry used to attach a frame 
//
typedef struct _AVCSTRM_DATA_ENTRY {

    LIST_ENTRY  ListEntry;

    // 
    // Keep track of data entry state
    //
    enum DATA_ENTRY_STATE  State;

    //
    // IRP from client of upper layer
    //
    PIRP  pIrpUpper;

    //
    // Clock provider information
    //
    BOOL  ClockProvider;  // Client is a clock provider?
    HANDLE  ClockHandle;  // This is used only if !ClockProvider; it is possible that there is no clock used.

    //
    // Contain information about this streaming buffer
    //
    PKSSTREAM_HEADER  StreamHeader;

    //
    // Frame buffer
    //
    PVOID  FrameBuffer;

    //
    // Stream extension (Context) of the stream of this frame 
    //
    PAVC_STREAM_EXTENSION  pAVCStrmExt;
   
#if DBG
    //
    // Add debug related info here
    //
    LONGLONG  FrameNumber;
#endif

    //
    // 61883 CIP frame structure
    //
    struct _CIP_FRAME *  Frame;

    //
    // IRP used to send to 61883 (lower layer) for AV request, such as attach and release
    //
    PIRP  pIrpLower;

    //
    // Use to send 61883 AV data request
    //
    AV_61883_REQUEST  AVReq;

} AVCSTRM_DATA_ENTRY, *PAVCSTRM_DATA_ENTRY;



//
// To open a stream.
//    A context is created and return to the caller.  This context is need for all 
//    stream operation.
//

NTSTATUS
AVCStreamOpen(
    IN PIRP  pIrp,  // The Irp from its client
    IN struct DEVICE_EXTENSION * pDevExt,
    IN OUT AVCSTRM_OPEN_STRUCT * pOpenStruct
    );


// To Close a stram.
NTSTATUS
AVCStreamClose(
    IN PIRP  pIrp,  // The Irp from its client
    IN struct DEVICE_EXTENSION * pDevExt,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt
    );

//
// Process stream control
// 
NTSTATUS
AVCStreamControlGetState(
    IN PIRP  pIrp,  // The Irp from its client
    IN struct DEVICE_EXTENSION * pDevExt,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt,
    OUT KSSTATE * pKSState
    );
NTSTATUS
AVCStreamControlSetState(
    IN PIRP  pIrp,  // The Irp from its client
    IN struct DEVICE_EXTENSION * pDevExt,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt,
    IN KSSTATE KSState
    );

NTSTATUS
AVCStreamControlGetProperty(
    IN PIRP  pIrp,  // The Irp from its client
    IN struct DEVICE_EXTENSION * pDevExt,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt,
    IN PSTREAM_PROPERTY_DESCRIPTOR pSPD  // BUGBUG StreamClass specific
    );
NTSTATUS
AVCStreamControlSetProperty(
    IN PIRP  pIrp,  // The Irp from its client
    IN struct DEVICE_EXTENSION * pDevExt,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt,
    IN PSTREAM_PROPERTY_DESCRIPTOR pSPD  // BUGBUG StreamClass specific
    );


// Process SRB_READ/WRITE_DATA; this is the only IRPs that will operate asychronously 
// with. and STATUS_PENDING is returned.  
NTSTATUS
AVCStreamRead(
    IN PIRP  pIrpUpper,
    IN struct DEVICE_EXTENSION * pDevExt,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt,
    IN AVCSTRM_BUFFER_STRUCT  * pBufferStruct
    );

NTSTATUS
AVCStreamWrite(
    IN PIRP  pIrpUpper,
    IN struct DEVICE_EXTENSION * pDevExt,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt,
    IN AVCSTRM_BUFFER_STRUCT  * pBufferStruct
    );

/*
  This will stop streaming and cancel all pending data irps. This is typically used
  to cancel all Irps.  To cancel a single Irp, use IoCancelIrp().
 */
NTSTATUS
AVCStreamAbortStreaming(
    IN PIRP  pIrp,  // The Irp from its client
    IN struct DEVICE_EXTENSION * pDevExt,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt
    );

/*
 Process surprise removal of a device
 */
NTSTATUS
AVCStreamSurpriseRemoval(
    IN struct DEVICE_EXTENSION * pDevExt  
    );

////////////////////////////////
// AvcUtil.c function prototypes
////////////////////////////////

ULONGLONG 
GetSystemTime(
    )
    ;

NTSTATUS
AVCStrmAttachFrameCR(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrp,
    IN PAVCSTRM_DATA_ENTRY  pDataEntry
    );

VOID
AVCStrmFormatAttachFrame(
    IN KSPIN_DATAFLOW  DataFlow,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt,
    IN AVCSTRM_FORMAT AVCStrmFormat,
    IN PAV_61883_REQUEST  pAVReq,
    IN PAVCSTRM_DATA_ENTRY  pDataEntry,
    IN ULONG  ulSourcePacketSize,    // Packet length in bytes
    IN ULONG  ulFrameSize,           // Buffer size; may contain one or multiple source packets
    IN PIRP  pIrpUpper,
    IN PKSSTREAM_HEADER  StreamHeader,
    IN PVOID  FrameBuffer
    );

NTSTATUS
AVCStrmGetPlugHandle(
    IN PDEVICE_OBJECT  DeviceObject,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt
    );

NTSTATUS
AVCStrmGetPlugState(
    IN PDEVICE_OBJECT  DeviceObject,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt
    );

NTSTATUS 
AVCStrmGetConnectionProperty(
    IN struct DEVICE_EXTENSION * pDevExt,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt,
    PSTREAM_PROPERTY_DESCRIPTOR pSPD,
    PULONG pulActualBytesTransferred
    );

NTSTATUS
AVCStrmGetDroppedFramesProperty(  
    IN struct DEVICE_EXTENSION * pDevExt,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt,
    PSTREAM_PROPERTY_DESCRIPTOR pSPD,
    PULONG pulBytesTransferred
    );

NTSTATUS
AVCStrmMakeConnection(
    IN PDEVICE_OBJECT  DeviceObject,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt
    );

NTSTATUS
AVCStrmBreakConnection(
    IN PDEVICE_OBJECT  DeviceObject,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt
    );

NTSTATUS
AVCStrmStartIsoch(
    IN PDEVICE_OBJECT  DeviceObject,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt
    );
NTSTATUS
AVCStrmStopIsoch(
    IN PDEVICE_OBJECT  DeviceObject,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt
    );
VOID
AVCStrmWaitUntilAttachedAreCompleted(
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt
    );
NTSTATUS
AVCStrmAllocateQueues(
    IN struct DEVICE_EXTENSION * pDevExt,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt,
    IN KSPIN_DATAFLOW  DataFlow,
    IN PAVC_STREAM_DATA_STRUCT pDataStruc,
    PAVCSTRM_FORMAT_INFO  pAVCStrmFormatInfo
    );
NTSTATUS
AVCStrmFreeQueues(
    IN PAVC_STREAM_DATA_STRUCT pDataStruc
    );

NTSTATUS
AVCStrmCancelIO(
    IN PDEVICE_OBJECT  DeviceObject,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt
    );

NTSTATUS
AVCStrmValidateFormat(
    PAVCSTRM_FORMAT_INFO  pAVCFormatInfo
    );

void
AVCStrmAbortStreamingWorkItemRoutine(
#ifdef USE_WDM110  // Win2000 code base
    // Extra parameter if using WDM10
    PDEVICE_OBJECT DeviceObject,
#endif
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\tvaudio\atitvsnd\wdmtvsnd.h ===
//==========================================================================;
//
//	WDMTVSnd.H
//	WDM TVAudio MiniDriver. 
//		CWDMTVAudio Class definition.
//  Copyright (c) 1996 - 1997  ATI Technologies Inc.  All Rights Reserved.
//
//==========================================================================;

#ifndef _WDMTVSND_H_
#define _WDMTVSND_H_

#include "i2script.h"
#include "aticonfg.h"
#include "pinmedia.h"


#define WDMTVAUDIO_PINS_NUMBER					2		// 1 input and 1 output

#define	KSPROPERTIES_TVAUDIO_NUMBER_SET			1
#define KSPROPERTIES_TVAUDIO_NUMBER				( KSPROPERTY_TVAUDIO_CURRENTLY_AVAILABLE_MODES + 1)

#define	KSEVENTS_TVAUDIO_NUMBER_SET				1
#define KSEVENTS_TVAUDIO_NUMBER					1


class CWDMTVAudio
{
public:
	CWDMTVAudio			( PDEVICE_OBJECT pDeviceObject, CI2CScript * pCScript, PUINT puiError);
	PVOID operator new	( size_t stSize, PVOID pAllocation);

// Attributes	
private:
	// WDM global topology headers
	GUID						m_wdmTVAudioTopologyCategory;
	KSTOPOLOGY					m_wdmTVAudioTopology;
	// WDM global pins Medium information
	KSPIN_MEDIUM				m_wdmTVAudioPinsMediumInfo[WDMTVAUDIO_PINS_NUMBER];
	BOOL						m_wdmTVAudioPinsDirectionInfo[WDMTVAUDIO_PINS_NUMBER];
	// WDM global property headers
	KSPROPERTY_ITEM				m_wdmTVAudioProperties[KSPROPERTIES_TVAUDIO_NUMBER];
	KSPROPERTY_SET				m_wdmTVAudioPropertySet[KSPROPERTIES_TVAUDIO_NUMBER_SET];

	// WDM global event properties
	KSEVENT_ITEM				m_wdmTVAudioEvents[KSEVENTS_TVAUDIO_NUMBER];
	KSEVENT_SET					m_wdmTVAudioEventsSet[KSEVENTS_TVAUDIO_NUMBER_SET];

	// WDM global stream headers
	HW_STREAM_HEADER			m_wdmTVAudioStreamHeader;

	// I2C provider properties
	CI2CScript *				m_pI2CScript;

	// Configurations
	CATIHwConfiguration			m_CATIConfiguration;
	ULONG						m_ulModesSupported;
	UINT						m_uiAudioConfiguration;
	UCHAR						m_uchAudioChipAddress;

	// Run-time properties
	ULONG						m_ulTVAudioMode;
	ULONG						m_ulTVAudioSignalProperties;

	DEVICE_POWER_STATE			m_ulPowerState;

// Implementation
public:
	BOOL		AdapterUnInitialize				( PHW_STREAM_REQUEST_BLOCK pSrb);
	BOOL		AdapterGetStreamInfo			( PHW_STREAM_REQUEST_BLOCK pSrb);
	BOOL		AdapterQueryUnload				( PHW_STREAM_REQUEST_BLOCK pSrb);
	BOOL		AdapterGetProperty				( PHW_STREAM_REQUEST_BLOCK pSrb);
	BOOL		AdapterSetProperty				( PHW_STREAM_REQUEST_BLOCK pSrb);
	NTSTATUS	AdapterCompleteInitialization	( PHW_STREAM_REQUEST_BLOCK pSrb);
	NTSTATUS	AdapterSetPowerState			( PHW_STREAM_REQUEST_BLOCK pSrb);

private:
	void		SetWDMTVAudioKSEvents			( void);
	void		SetWDMTVAudioKSProperties		( void);
	void		SetWDMTVAudioKSTopology			( void);

	BOOL		SetAudioOperationMode			( ULONG ulModeToSet);
	BOOL		GetAudioOperationMode			( PULONG pulMode);
};



#endif	// _WDMTVSND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\tvaudio\atitvsnd\tsndhdw.cpp ===
//==========================================================================;
//
//	TSndHdw.CPP
//	WDM TVAudio MiniDriver. 
//		AIW / AIWPro hardware platform. 
//			WDM Properties required hardware settings.
//  Copyright (c) 1996 - 1997  ATI Technologies Inc.  All Rights Reserved.
//
//		$Date:   03 Jun 1999 13:40:00  $
//	$Revision:   1.7  $
//	  $Author:   tom  $
//
//==========================================================================;

extern "C"
{
#include "strmini.h"
#include "ksmedia.h"

#include "wdmdebug.h"
}

#include "wdmdrv.h"
#include "atitvsnd.h"
#include "aticonfg.h"



/*^^*
 *		GetAudioOperationMode()
 * Purpose	: Called when SRB_GET_PROPERTY SRB SetMode is received. Sets the requested
 *				audio operation mode ( Stereo/SAP). The function will always try to carry the
 *				request on in asynchronous mode. It fails, it will response synchronous mode
 *				of execution.
 *
 * Inputs	:	PULONG pulMode		: the pointer to return current Mode
 *
 * Outputs	: BOOL : returns FALSE, if it is not a XBar property
 *				it also sets the required property
 * Author	: IKLEBANOV
 *^^*/
BOOL CWDMTVAudio::GetAudioOperationMode( PULONG pulAudioMode)
{
	I2CPacket	i2cPacket;
	UCHAR		uchReadValue;
	UCHAR		uchWriteValue;
	BOOL		bResult, bStereoIndicator, bSAPIndicator;
	UCHAR		uchRead16Value[2];
	UCHAR		uchWrite16Value[3];

	if( pulAudioMode == NULL)
		return( FALSE);

	switch( m_uiAudioConfiguration)
	{
		case ATI_AUDIO_CONFIG_1:
		case ATI_AUDIO_CONFIG_5:
			// stereo indication is read back from I2C expander
			if( m_CATIConfiguration.GetTVAudioSignalProperties( m_pI2CScript, 
															    &bStereoIndicator,
															    &bSAPIndicator))
			{
				// language A and mono alsways present
				*pulAudioMode = KS_TVAUDIO_MODE_LANG_A | KS_TVAUDIO_MODE_MONO;
				if( bStereoIndicator)
					*pulAudioMode |= KS_TVAUDIO_MODE_STEREO;
				if( bSAPIndicator)
					*pulAudioMode |= KS_TVAUDIO_MODE_LANG_B;

				bResult = TRUE;
			}
			else
				bResult = FALSE;

			break;

		case ATI_AUDIO_CONFIG_2:
		case ATI_AUDIO_CONFIG_7:
			// Signal properties are read back from the Audio chip itself
			uchWriteValue = 0;				// register 0 should be read
			i2cPacket.uchChipAddress	= m_uchAudioChipAddress;
			i2cPacket.puchWriteBuffer	= &uchWriteValue;
			i2cPacket.puchReadBuffer	= &uchReadValue;
			i2cPacket.cbWriteCount		= 1;
			i2cPacket.cbReadCount		= 1;
			i2cPacket.usFlags			= I2COPERATION_READ;

			m_pI2CScript->PerformI2CPacketOperation( &i2cPacket);
			if( i2cPacket.uchI2CResult == I2C_STATUS_NOERROR)
			{
				// language A and mono alsways present
				*pulAudioMode = KS_TVAUDIO_MODE_LANG_A | KS_TVAUDIO_MODE_MONO;
				if( uchReadValue & AUDIO_TDA9850_Indicator_Stereo)
					*pulAudioMode |= KS_TVAUDIO_MODE_STEREO;
				if( uchReadValue & AUDIO_TDA9850_Indicator_SAP)
					*pulAudioMode |= KS_TVAUDIO_MODE_LANG_B;

				bResult = TRUE;
			}
			else
				bResult = FALSE;

			break;

		case ATI_AUDIO_CONFIG_3:
		case ATI_AUDIO_CONFIG_4:
			// Stereo nor SAP are supported
			*pulAudioMode = KS_TVAUDIO_MODE_MONO;
			bResult = TRUE;
			break;

		case ATI_AUDIO_CONFIG_6:
			// Signal properties are read back from the Audio chip itself
			i2cPacket.uchChipAddress	= m_uchAudioChipAddress;
			i2cPacket.puchWriteBuffer	= NULL;
			i2cPacket.puchReadBuffer	= &uchReadValue;
			i2cPacket.cbWriteCount		= 0;
			i2cPacket.cbReadCount		= 1;
			i2cPacket.usFlags			= I2COPERATION_READ;

			m_pI2CScript->PerformI2CPacketOperation( &i2cPacket);
			if( i2cPacket.uchI2CResult == I2C_STATUS_NOERROR)
			{
				// mono alsways present
				*pulAudioMode = KS_TVAUDIO_MODE_MONO;
				if( uchReadValue & AUDIO_TDA9851_Indicator_Stereo)
					*pulAudioMode |= KS_TVAUDIO_MODE_STEREO;

				bResult = TRUE;
			}
			else
				bResult = FALSE;

			break;

		case ATI_AUDIO_CONFIG_8:

			i2cPacket.uchChipAddress	= m_uchAudioChipAddress;
			i2cPacket.puchWriteBuffer	= uchWrite16Value;
			i2cPacket.puchReadBuffer	= uchRead16Value;
			i2cPacket.cbWriteCount		= 3;
			i2cPacket.cbReadCount		= 2;
			i2cPacket.usFlags			= I2COPERATION_READ;


			uchWrite16Value[0] = 0x11;
			uchWrite16Value[1] = 0x02;
			uchWrite16Value[2] = 0x00;

			bResult = m_pI2CScript->PerformI2CPacketOperation(&i2cPacket);
			if(bResult)
			{
				if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
					return(FALSE);
			}
			else
				return(FALSE);

			// language A and mono alsways present
			*pulAudioMode = KS_TVAUDIO_MODE_LANG_A | KS_TVAUDIO_MODE_MONO;

			//Determine STEREO/SAP
			
			if(uchRead16Value[0] & 0x40)
				*pulAudioMode |= KS_TVAUDIO_MODE_LANG_B;

			if(uchRead16Value[1] & 0x01)
				*pulAudioMode |= KS_TVAUDIO_MODE_STEREO;

			break;

		default:
			bResult = FALSE;
			break;
	}

	return( bResult);
}



/*^^*
 *		SetAudioOperationMode()
 * Purpose	: Called when SRB_SET_PROPERTY SRB SetMode is received. Sets the requested
 *				audio operation mode ( Stereo/SAP). The function will always try to carry the
 *				request on in asynchronous mode. It fails, it will response synchronous mode
 *				of execution.
 *
 * Inputs	:	ULONG ulModeToSet	: the requested mode to set
 *
 * Outputs	: BOOL : returns FALSE, if it is not a XBar property
 *				it also sets the required property
 * Author	: IKLEBANOV
 *^^*/
BOOL CWDMTVAudio::SetAudioOperationMode( ULONG ulModeToSet)
{
	I2CPacket	i2cPacket;
	USHORT		cbWriteLength;
	UCHAR		auchI2CBuffer[2];
	UCHAR		uchDeviceMode = 0;
	UCHAR		uchWrite16Value[5];
	BOOL		bResult;
	
	switch( m_uiAudioConfiguration)
	{
		case ATI_AUDIO_CONFIG_5:
			// TEA5571
		case ATI_AUDIO_CONFIG_1:
			// TEA5582 can not be forced in mono mode; nothing to do
			m_ulTVAudioMode = ulModeToSet;
			return( TRUE);

		case ATI_AUDIO_CONFIG_2:
		case ATI_AUDIO_CONFIG_7:
			// TDA9850
			if( ulModeToSet & KS_TVAUDIO_MODE_STEREO)
				uchDeviceMode |= AUDIO_TDA9850_Control_Stereo;
			if( ulModeToSet & KS_TVAUDIO_MODE_LANG_B)
				uchDeviceMode |= AUDIO_TDA9850_Control_SAP;

			auchI2CBuffer[0] = AUDIO_TDA9850_Reg_Control3;
			auchI2CBuffer[1] = uchDeviceMode;
			cbWriteLength = 2;		// SubAddress + Control Register value

			break;

		case ATI_AUDIO_CONFIG_6:
			// TDA9851
			uchDeviceMode = TDA9851_AVL_ATTACK_730;
			if( ulModeToSet & KS_TVAUDIO_MODE_STEREO)
				uchDeviceMode |= AUDIO_TDA9851_Control_Stereo;
			auchI2CBuffer[0] = uchDeviceMode;
			cbWriteLength = 1;		// Control Register value
			break;

		case ATI_AUDIO_CONFIG_8:

			if( ulModeToSet & KS_TVAUDIO_MODE_STEREO)
			{
				i2cPacket.uchChipAddress = m_uchAudioChipAddress;
				i2cPacket.cbReadCount = 0;
				i2cPacket.usFlags = I2COPERATION_WRITE;
				i2cPacket.puchWriteBuffer = uchWrite16Value;
				i2cPacket.cbWriteCount = 5;


				//SubAddr 0x10 Reg 0x30 Val 0x2003
				uchWrite16Value[0] = 0x10;
				uchWrite16Value[1] = 0x00;
				uchWrite16Value[2] = 0x30;
				uchWrite16Value[3] = 0x20;
#ifdef	I2S_CAPTURE
#pragma message ("\n!!! PAY ATTENTION: Driver has been build with ITT CHIP I2S CAPTURE CONFIGURED !!!\n")
				uchWrite16Value[4] = 0xe3;
#else
				uchWrite16Value[4] = 0x03;
#endif

				bResult = m_pI2CScript->PerformI2CPacketOperation( &i2cPacket);
				if(bResult)
				{
					if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
						return(FALSE);
				}
				else
					return(FALSE);

				//SubAddr 0x10 Reg 0x20 Val 0x0020

				uchWrite16Value[0] = 0x10;
				uchWrite16Value[1] = 0x00;
				uchWrite16Value[2] = 0x20;
				uchWrite16Value[3] = 0x00;
				uchWrite16Value[4] = 0x20;

				bResult = m_pI2CScript->PerformI2CPacketOperation( &i2cPacket);
				if(bResult)
				{
					if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
						return(FALSE);
				}
				else
					return(FALSE);

				//SubAddr 0x12 Reg 0xE Val 0x2403
				uchWrite16Value[0] = 0x12;
				uchWrite16Value[1] = 0x00;
				uchWrite16Value[2] = 0x0e;
				uchWrite16Value[3] = 0x24;
				uchWrite16Value[4] = 0x03;

				bResult = m_pI2CScript->PerformI2CPacketOperation( &i2cPacket);
				if(bResult)
				{
					if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
						return(FALSE);
				}
				else
					return(FALSE);

				//SubAddr 0x12 Reg 0x08 Val 0x0320
				uchWrite16Value[0] = 0x12;
				uchWrite16Value[1] = 0x00;
				uchWrite16Value[2] = 0x08;
				uchWrite16Value[3] = 0x03;
				uchWrite16Value[4] = 0x20;

				bResult = m_pI2CScript->PerformI2CPacketOperation( &i2cPacket);
				if(bResult)
				{
					if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
						return(FALSE);
				}
				else
					return(FALSE);

				return(TRUE);
			}

			if(ulModeToSet & KS_TVAUDIO_MODE_MONO) 
			{
			
				if(ulModeToSet & KS_TVAUDIO_MODE_LANG_A)
				{
					i2cPacket.uchChipAddress = m_uchAudioChipAddress;
					i2cPacket.cbReadCount = 0;
					i2cPacket.usFlags = I2COPERATION_WRITE;
					i2cPacket.puchWriteBuffer = uchWrite16Value;
					i2cPacket.cbWriteCount = 5;


					//SubAddr 0x10 Reg 0x30 Val 0x2003
					uchWrite16Value[0] = 0x10;
					uchWrite16Value[1] = 0x00;
					uchWrite16Value[2] = 0x30;
					uchWrite16Value[3] = 0x20;
#ifdef	I2S_CAPTURE
#pragma message ("\n!!! PAY ATTENTION: Driver has been build with ITT CHIP I2S CAPTURE CONFIGURED !!!\n")
					uchWrite16Value[4] = 0xe3;
#else
					uchWrite16Value[4] = 0x03;
#endif

					bResult = m_pI2CScript->PerformI2CPacketOperation( &i2cPacket);
					if(bResult)
					{
						if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
							return(FALSE);
					}
					else
						return(FALSE);

					//SubAddr 0x10 Reg 0x20 Val 0x0020

					uchWrite16Value[0] = 0x10;
					uchWrite16Value[1] = 0x00;
					uchWrite16Value[2] = 0x20;
					uchWrite16Value[3] = 0x00;
					uchWrite16Value[4] = 0x20;

					bResult = m_pI2CScript->PerformI2CPacketOperation( &i2cPacket);
					if(bResult)
					{
						if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
							return(FALSE);
					}
					else
						return(FALSE);

					//SubAddr 0x12 Reg 0xE Val 0x2403
					uchWrite16Value[0] = 0x12;
					uchWrite16Value[1] = 0x00;
					uchWrite16Value[2] = 0x0e;
					uchWrite16Value[3] = 0x24;
					uchWrite16Value[4] = 0x03;

					bResult = m_pI2CScript->PerformI2CPacketOperation( &i2cPacket);
					if(bResult)
					{
						if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
							return(FALSE);
					}
					else
						return(FALSE);

					//SubAddr 0x12 Reg 0x08 Val 0x0330
					uchWrite16Value[0] = 0x12;
					uchWrite16Value[1] = 0x00;
					uchWrite16Value[2] = 0x08;
					uchWrite16Value[3] = 0x03;
					uchWrite16Value[4] = 0x30; //Mono

					bResult = m_pI2CScript->PerformI2CPacketOperation( &i2cPacket);
					if(bResult)
					{
						if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
							return(FALSE);
					}
					else
						return(FALSE);

					return(TRUE);
				}


				if( ulModeToSet & KS_TVAUDIO_MODE_LANG_B)
				{

					i2cPacket.uchChipAddress = m_uchAudioChipAddress;
					i2cPacket.cbReadCount = 0;
					i2cPacket.usFlags = I2COPERATION_WRITE;
					i2cPacket.puchWriteBuffer = uchWrite16Value;
					i2cPacket.cbWriteCount = 5;

					//SubAddr 0x10 Reg 0x30 Val 0x2003
					uchWrite16Value[0] = 0x10;
					uchWrite16Value[1] = 0x00;
					uchWrite16Value[2] = 0x30;
					uchWrite16Value[3] = 0x20;
#ifdef	I2S_CAPTURE
#pragma message ("\n!!! PAY ATTENTION: Driver has been build with ITT CHIP I2S CAPTURE CONFIGURED !!!\n")
					uchWrite16Value[4] = 0xe3;
#else
					uchWrite16Value[4] = 0x03;
#endif

					bResult = m_pI2CScript->PerformI2CPacketOperation( &i2cPacket);
					if(bResult)
					{
						if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
							return(FALSE);
					}
					else
						return(FALSE);

					//SubAddr 0x10 Reg 0x20 Val 0x0021

					uchWrite16Value[0] = 0x10;
					uchWrite16Value[1] = 0x00;
					uchWrite16Value[2] = 0x20;
					uchWrite16Value[3] = 0x00;
					uchWrite16Value[4] = 0x21;

					bResult = m_pI2CScript->PerformI2CPacketOperation( &i2cPacket);
					if(bResult)
					{
						if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
							return(FALSE);
					}
					else
						return(FALSE);

					//SubAddr 0x12 Reg 0xE Val 0x2400
					uchWrite16Value[0] = 0x12;
					uchWrite16Value[1] = 0x00;
					uchWrite16Value[2] = 0x0e;
					uchWrite16Value[3] = 0x24;
					uchWrite16Value[4] = 0x00;

					bResult = m_pI2CScript->PerformI2CPacketOperation( &i2cPacket);
					if(bResult)
					{
						if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
							return(FALSE);
					}
					else
						return(FALSE);

					//SubAddr 0x12 Reg 0x08 Val 0x0110
					uchWrite16Value[0] = 0x12;
					uchWrite16Value[1] = 0x00;
					uchWrite16Value[2] = 0x08;
					uchWrite16Value[3] = 0x01;
					uchWrite16Value[4] = 0x10;

					bResult = m_pI2CScript->PerformI2CPacketOperation( &i2cPacket);
					if(bResult)
					{
						if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
							return(FALSE);
					}
					else
						return(FALSE);


					return(TRUE);
				}
			}

			return(FALSE);


		default:
			return( FALSE);
	}

	i2cPacket.uchChipAddress = m_uchAudioChipAddress;
	i2cPacket.cbReadCount = 0;
	i2cPacket.cbWriteCount = cbWriteLength;
	i2cPacket.puchReadBuffer = NULL;
	i2cPacket.puchWriteBuffer = auchI2CBuffer;
	i2cPacket.usFlags = 0;

	// synchronous mode of operation
	return( m_pI2CScript->PerformI2CPacketOperation( &i2cPacket));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\atiwdm\tvaudio\atitvsnd\wdmtvsnd.cpp ===
//==========================================================================;
//
//	WDMTVSnd.CPP
//	WDM TVAudio MiniDriver. 
//		AllInWonder / AIWPro Hardware platform. 
//			CWDMTVAudio class implementation.
//  Copyright (c) 1996 - 1997  ATI Technologies Inc.  All Rights Reserved.
//
//		$Date:   23 Nov 1998 13:22:00  $
//	$Revision:   1.4  $
//	  $Author:   minyailo  $
//
//==========================================================================;

extern "C"
{
#include "strmini.h"
#include "ksmedia.h"

#include "wdmdebug.h"
}

#include "atitvsnd.h"
#include "wdmdrv.h"
#include "aticonfg.h"


/*^^*
 *		AdapterCompleteInitialization()
 * Purpose	: Called when SRB_COMPLETE_UNINITIALIZATION SRB is received.
 *
 * Inputs	:	PHW_STREAM_REQUEST_BLOCK pSrb	: pointer to the current Srb
 *
 * Outputs	: BOOL : returns TRUE
 * Author	: IKLEBANOV
 *^^*/
NTSTATUS CWDMTVAudio::AdapterCompleteInitialization( PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PADAPTER_DATA_EXTENSION pPrivateData = ( PADAPTER_DATA_EXTENSION)( pSrb->HwDeviceExtension);
	PDEVICE_OBJECT	pDeviceObject = pPrivateData->PhysicalDeviceObject;
	KSPIN_MEDIUM	mediumKSPin;
	NTSTATUS		ntStatus;
	UINT			nIndex;
	HANDLE			hFolder;
	ULONG			ulInstance;

	ENSURE
	{
		nIndex = 0;

		ulInstance = ::GetDriverInstanceNumber( pDeviceObject);
		hFolder = ::OpenRegistryFolder( pDeviceObject, UNICODE_WDM_REG_PIN_MEDIUMS);

		// put the hardcoded Medium values first
		::RtlCopyMemory( &m_wdmTVAudioPinsMediumInfo[0], &ATITVAudioInMedium, sizeof( KSPIN_MEDIUM));
		::RtlCopyMemory( &m_wdmTVAudioPinsMediumInfo[1], &ATITVAudioOutMedium, sizeof( KSPIN_MEDIUM));

		for( nIndex = 0; nIndex < WDMTVAUDIO_PINS_NUMBER; nIndex ++)
		{
			if( ::ReadPinMediumFromRegistryFolder( hFolder, nIndex, &mediumKSPin))
				::RtlCopyMemory( &m_wdmTVAudioPinsMediumInfo[nIndex], &mediumKSPin, sizeof( KSPIN_MEDIUM));
			m_wdmTVAudioPinsMediumInfo[nIndex].Id = ulInstance;
		}

		m_wdmTVAudioPinsDirectionInfo[0] = FALSE;
		m_wdmTVAudioPinsDirectionInfo[1] = TRUE;

		if( hFolder != NULL)
			::ZwClose( hFolder);

		ntStatus = StreamClassRegisterFilterWithNoKSPins( \
						pDeviceObject,							// IN PDEVICE_OBJECT   DeviceObject,
						&KSCATEGORY_TVAUDIO,					// IN GUID           * InterfaceClassGUID
						WDMTVAUDIO_PINS_NUMBER,					// IN ULONG            PinCount,
						m_wdmTVAudioPinsDirectionInfo,			// IN ULONG          * Flags,
						m_wdmTVAudioPinsMediumInfo,				// IN KSPIN_MEDIUM   * MediumList,
						NULL);									// IN GUID           * CategoryList

		if( !NT_SUCCESS( ntStatus))
			FAIL;

		OutputDebugTrace(( "CATIWDMTVAudio:AdapterCompleteInitialization() exit\n"));

	} END_ENSURE;

	if( !NT_SUCCESS( ntStatus))
		OutputDebugError(( "CATIWDMTVAudio:AdapterCompleteInitialization() ntStatus=%x\n",
			ntStatus));

	return( ntStatus);
}



/*^^*
 *		AdapterUnInitialize()
 * Purpose	: Called when SRB_UNINITIALIZE_DEVICE SRB is received.
 *
 * Inputs	:	PHW_STREAM_REQUEST_BLOCK pSrb	: pointer to the current Srb
 *
 * Outputs	: BOOL : returns TRUE
 * Author	: IKLEBANOV
 *^^*/
BOOL CWDMTVAudio::AdapterUnInitialize( PHW_STREAM_REQUEST_BLOCK pSrb)
{

	OutputDebugTrace(( "CWDMTVAudio:AdapterUnInitialize()\n"));

	pSrb->Status = STATUS_SUCCESS;

	return( TRUE);
}


/*^^*
 *		AdapterGetStreamInfo()
 * Purpose	: 
 *
 * Inputs	:	PHW_STREAM_REQUEST_BLOCK pSrb	: pointer to the current Srb
 *
 * Outputs	: BOOL : returns TRUE
 * Author	: IKLEBANOV
 *^^*/
BOOL CWDMTVAudio::AdapterGetStreamInfo( PHW_STREAM_REQUEST_BLOCK pSrb)
{
     // pick up the pointer to the stream header data structure
	PHW_STREAM_HEADER pStreamHeader = ( PHW_STREAM_HEADER) \
										&( pSrb->CommandData.StreamBuffer->StreamHeader);
     // pick up the pointer to the stream information data structure
	PHW_STREAM_INFORMATION pStreamInfo = ( PHW_STREAM_INFORMATION) \
										&( pSrb->CommandData.StreamBuffer->StreamInfo);

	// no streams are supported
    DEBUG_ASSERT( pSrb->NumberOfBytesToTransfer >= sizeof( HW_STREAM_HEADER));

	OutputDebugTrace(( "CWDMTVAudio:AdapterGetStreamInfo()\n"));

	m_wdmTVAudioStreamHeader.NumberOfStreams = 0;
	m_wdmTVAudioStreamHeader.SizeOfHwStreamInformation = sizeof( HW_STREAM_INFORMATION);
	m_wdmTVAudioStreamHeader.NumDevPropArrayEntries = KSPROPERTIES_TVAUDIO_NUMBER_SET;
	m_wdmTVAudioStreamHeader.DevicePropertiesArray = m_wdmTVAudioPropertySet;
	m_wdmTVAudioStreamHeader.NumDevEventArrayEntries = KSEVENTS_TVAUDIO_NUMBER_SET;
	m_wdmTVAudioStreamHeader.DeviceEventsArray = m_wdmTVAudioEventsSet;
	m_wdmTVAudioStreamHeader.Topology = &m_wdmTVAudioTopology;

	* pStreamHeader = m_wdmTVAudioStreamHeader;

	pSrb->Status = STATUS_SUCCESS;

	return( TRUE);
}


/*^^*
 *		AdapterQueryUnload()
 * Purpose	: Called when the class driver is about to unload the MiniDriver
 *				The MiniDriver checks if any open stream left.
 *
 * Inputs	:	PHW_STREAM_REQUEST_BLOCK pSrb	: pointer to the current Srb
 *
 * Outputs	: BOOL : returns TRUE
 * Author	: IKLEBANOV
 *^^*/
BOOL CWDMTVAudio::AdapterQueryUnload( PHW_STREAM_REQUEST_BLOCK pSrb)
{

	OutputDebugTrace(( "CWDMTVAudio:AdapterQueryUnload()\n"));

	pSrb->Status = STATUS_SUCCESS;

	return( TRUE);
}



/*^^*
 *		operator new
 * Purpose	: CWDMTVAudio class overloaded operator new.
 *				Provides placement for a CWDMTVAudio class object from the PADAPTER_DEVICE_EXTENSION
 *				allocated by the StreamClassDriver for the MiniDriver.
 *
 * Inputs	:	UINT size_t			: size of the object to be placed
 *				PVOID pAllocation	: casted pointer to the CWDMTVAudio allocated data
 *
 * Outputs	: PVOID : pointer of the CWDMTVAudio class object
 * Author	: IKLEBANOV
 *^^*/
PVOID CWDMTVAudio::operator new( size_t stSize,  PVOID pAllocation)
{

	if( stSize != sizeof( CWDMTVAudio))
	{
		OutputDebugError(( "CWDMTVAudio: operator new() fails\n"));
		return( NULL);
	}
	else
		return( pAllocation);
}



/*^^*
 *		CWDMTVAudio()
 * Purpose	: CWDMTVAudio class constructor.
 *				Performs checking of the hardware presence. Sets the hardware in an initial state.
 *
 * Inputs	:	CI2CScript * pCScript	: pointer to the I2CScript class object
 *				PUINT puiError			: pointer to return a completion error code
 *
 * Outputs	: none
 * Author	: IKLEBANOV
 *^^*/
CWDMTVAudio::CWDMTVAudio( PDEVICE_OBJECT pDeviceObject, CI2CScript * pCScript, PUINT puiErrorCode)
	:m_CATIConfiguration( pDeviceObject, pCScript, puiErrorCode)
{
	UINT uiError;

	OutputDebugTrace(( "CWDMTVAudio:CWDMTVAudio() enter\n"));

	m_ulModesSupported = KS_TVAUDIO_MODE_MONO;
	
	// error code was carried over from ATIConfiguration class constructor
	uiError = * puiErrorCode;

	ENSURE
	{
		UINT	uiAudioConfigurationId;
		UCHAR	uchAudioChipAddress;

		if( uiError != WDMMINI_NOERROR)
			FAIL;

		if( pCScript == NULL)
		{
			uiError = WDMMINI_INVALIDPARAM;
			FAIL;
		}

		if( !m_CATIConfiguration.GetAudioConfiguration( &uiAudioConfigurationId, &uchAudioChipAddress))
		{
			uiError = WDMMINI_UNKNOWNHARDWARE;
			FAIL;
		}

		m_uiAudioConfiguration = uiAudioConfigurationId;
		m_uchAudioChipAddress = uchAudioChipAddress;

		if( !m_CATIConfiguration.InitializeAudioConfiguration( pCScript,
															   uiAudioConfigurationId,
															   uchAudioChipAddress))
		{
			uiError = WDMMINI_HARDWAREFAILURE;
			FAIL;
		}

		switch( uiAudioConfigurationId)
		{
			case ATI_AUDIO_CONFIG_1:
				m_ulModesSupported |= KS_TVAUDIO_MODE_STEREO;
				break;

			case ATI_AUDIO_CONFIG_2:
			case ATI_AUDIO_CONFIG_7:
				m_ulModesSupported |= KS_TVAUDIO_MODE_STEREO |
					KS_TVAUDIO_MODE_LANG_A | KS_TVAUDIO_MODE_LANG_B;
				break;

			case ATI_AUDIO_CONFIG_5:
			case ATI_AUDIO_CONFIG_6:
				m_ulModesSupported |= KS_TVAUDIO_MODE_STEREO;
				break;

			case ATI_AUDIO_CONFIG_8:
				m_ulModesSupported |= KS_TVAUDIO_MODE_STEREO |
					KS_TVAUDIO_MODE_LANG_A | KS_TVAUDIO_MODE_LANG_B;
				break;

			case ATI_AUDIO_CONFIG_3:
			case ATI_AUDIO_CONFIG_4:
			default:
				break;
		}

		// set stereo mode as the power up default, if supported
		m_ulTVAudioMode = ( m_ulModesSupported & KS_TVAUDIO_MODE_STEREO) ?
			KS_TVAUDIO_MODE_STEREO : KS_TVAUDIO_MODE_MONO;
		if( m_ulModesSupported & KS_TVAUDIO_MODE_LANG_A)
			m_ulTVAudioMode |= KS_TVAUDIO_MODE_LANG_A;

		// these two functions has to be called after the CWDMTVAudio class object was build on
		// on the stack and copied over into the DeviceExtension
		// This comment was true for the case, where the class object was build on the stack first.
		// There is an overloaded operator new provided for this class, and we can call it from here
		SetWDMTVAudioKSProperties();
		SetWDMTVAudioKSTopology();

		m_pI2CScript = pCScript;

		 * puiErrorCode = WDMMINI_NOERROR;
		 OutputDebugTrace(( "CWDMTVAudio:CWDMTVAudio() exit\n"));

		return;

	} END_ENSURE;

	* puiErrorCode = uiError;

    OutputDebugError(( "CWDMTVAudio:CWDMTVAudio() Error = %x\n", uiError));
}



/*^^*
 *		AdapterSetPowerState()
 * Purpose	: Sets Power Management state for deviec
 *
 * Inputs	:	PHW_STREAM_REQUEST_BLOCK pSrb	: pointer to the current Srb
 *				PBOOL pbSynchronous				: pointer to return Synchronous/Asynchronous flag
 *
 * Outputs	: NTSTATUS as the operation result
 * Author	: IKLEBANOV
 *^^*/
NTSTATUS CWDMTVAudio::AdapterSetPowerState( PHW_STREAM_REQUEST_BLOCK pSrb)
{
    DEVICE_POWER_STATE	nDeviceState = pSrb->CommandData.DeviceState;
	NTSTATUS			ntStatus;

	switch( nDeviceState)
	{
		case PowerDeviceD0:
		case PowerDeviceD3:
			// if transition form D3 to D0 we have to restore audio connections
			if(( nDeviceState == PowerDeviceD0) && ( m_ulPowerState == PowerDeviceD3))
			{
				if( SetAudioOperationMode( m_ulTVAudioMode))
					ntStatus = STATUS_SUCCESS;
				else
					ntStatus = STATUS_ADAPTER_HARDWARE_ERROR;
			}
			else
				ntStatus = STATUS_SUCCESS;

			m_ulPowerState = nDeviceState;
			break;

		case PowerDeviceD1:
		case PowerDeviceD2:
			ntStatus = STATUS_SUCCESS;
			break;

		default:
			ntStatus = STATUS_INVALID_PARAMETER;
			break;
	}

	return( ntStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\avcstrm\sources.inc ===
#############################################################################
#
#       Confidential Microsoft
#       Copyright (C) Microsoft Corporation 2000-2001
#       All Rights Reserved.
#                                                                          
#       Sources for AVC streaming filter driver
#
##########################################################################
TARGETNAME=avcstrm
TARGETPATH=obj
TARGETTYPE=DRIVER
DRIVERTYPE=WDM

MSC_WARNING_LEVEL=-W3 -WX
USE_MAPSYM       = 1

INCLUDES= \
    $(MULTIMEDIA_INC_PATH)

TARGETLIBS= \
    $(DDK_LIB_PATH)\ksguid.lib

SOURCES= \
    filter.c \
    stream.c \
    avcutil.c \
    pnp.c \
    power.c \
    util.c \
    filter.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\avcstrm\filter.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    filter.h

Abstract: NULL filter driver -- boilerplate code

Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/

#include "strmini.h"  // Stream class header file

#include "1394.h"
#include "61883.h"
#include "avc.h"
#include "avcstrm.h"
#include "avcdefs.h"  

//
// If this driver is going to be a filter in the paging, hibernation, or dump
// file path, then HANDLE_DEVICE_USAGE should be defined.
//
// #define HANDLE_DEVICE_USAGE

enum deviceState {
        STATE_INITIALIZED,
        STATE_STARTING,
        STATE_STARTED,
        STATE_START_FAILED,
        STATE_STOPPED,  // implies device was previously started successfully
        STATE_SUSPENDED,
        STATE_REMOVING,
        STATE_REMOVED
};


/*
 *  Memory tag for memory blocks allocated by this driver
 *  (used in ExAllocatePoolWithTag() call).
 *  This DWORD appears as "Filt" in a little-endian memory byte dump.
 *
 *  NOTE:  PLEASE change this value to be unique for your driver!  Otherwise,
 *  your allocations will show up with every other driver that uses 'tliF' as
 *  an allocation tag.
 *  
 */
#define FILTER_TAG (ULONG)'SCVA'

#undef ExAllocatePool
#define ExAllocatePool(type, size) \
            ExAllocatePoolWithTag (type, size, FILTER_TAG)



#define DEVICE_EXTENSION_SIGNATURE 'SCVA'

#define MAX_STREAMS_PER_DEVICE    4  // We probably run out of bandwidth after this.

typedef struct DEVICE_EXTENSION {

    /*
     *  Stream extension; we can support up to MAX_STREAMS_PER_DEVICE streams.
     */
    ULONG  NumberOfStreams;  // [0..MAX_STREAMS_PER_DEVICE-1]
    ULONG  NextStreamIndex;  // [0..MAX_STREAMS_PER_DEVICE-1] and can wrap arond as long as NumberOfStreams is < MAX_STREAMS_PER_DEVICE
    PAVC_STREAM_EXTENSION pAVCStrmExt[MAX_STREAMS_PER_DEVICE];

    /*
     *  Memory signature of a device extension, for debugging.
     */
    ULONG signature;

    /*
     *  Plug-and-play state of this device object.
     */
    enum deviceState state;

    /*
     *  The device object that this filter driver created.
     */
    PDEVICE_OBJECT filterDevObj;

    /*
     *  The device object created by the next lower driver.
     */
    PDEVICE_OBJECT physicalDevObj;

    /*
     *  The device object at the top of the stack that we attached to.
     *  This is often (but not always) the same as physicalDevObj.
     */
    PDEVICE_OBJECT topDevObj;

    /*
     *  deviceCapabilities includes a
     *  table mapping system power states to device power states.
     */
    DEVICE_CAPABILITIES deviceCapabilities;

    /*
     *  pendingActionCount is used to keep track of outstanding actions.
     *  removeEvent is used to wait until all pending actions are
     *  completed before complete the REMOVE_DEVICE IRP and let the
     *  driver get unloaded.
     */
    LONG pendingActionCount;
    KEVENT removeEvent;

#ifdef HANDLE_DEVICE_USAGE
    /*
     *  Keep track of the number of paging/hibernation/crashdump
     *  files that are opened on this device.
     */
    ULONG  pagingFileCount, hibernationFileCount, crashdumpFileCount;
    KEVENT deviceUsageNotificationEvent;
    PVOID  pagingPathUnlockHandle;  /* handle to lock certain code as non-pageable */

    /*
     *  Also, might need to lock certain driver code as non-pageable, based on
     *  initial conditions (as opposed to paging-file considerations).
     */
    PVOID  initUnlockHandle;
    ULONG  initialFlags;
#endif // HANDLE_DEVICE_USAGE 

};


#if DBG
    #define _DRIVERNAME_ "AVCStrm"

    // PnP: loading, power state, surprise removal, device SRB
    #define TL_PNP_MASK         0x0000000F
    #define TL_PNP_INFO         0x00000001
    #define TL_PNP_TRACE        0x00000002
    #define TL_PNP_WARNING      0x00000004
    #define TL_PNP_ERROR        0x00000008

    // Connection, plug and 61883 info (get/set)
    #define TL_61883_MASK       0x000000F0
    #define TL_61883_INFO       0x00000010
    #define TL_61883_TRACE      0x00000020
    #define TL_61883_WARNING    0x00000040
    #define TL_61883_ERROR      0x00000080

    // Data
    #define TL_CIP_MASK         0x00000F00
    #define TL_CIP_INFO         0x00000100
    #define TL_CIP_TRACE        0x00000200
    #define TL_CIP_WARNING      0x00000400
    #define TL_CIP_ERROR        0x00000800

    // AVC commands
    #define TL_FCP_MASK         0x0000F000
    #define TL_FCP_INFO         0x00001000
    #define TL_FCP_TRACE        0x00002000
    #define TL_FCP_WARNING      0x00004000
    #define TL_FCP_ERROR        0x00008000

    // Stream (data intersection, open/close, stream state (get/set))
    #define TL_STRM_MASK        0x000F0000
    #define TL_STRM_INFO        0x00010000
    #define TL_STRM_TRACE       0x00020000
    #define TL_STRM_WARNING     0x00040000
    #define TL_STRM_ERROR       0x00080000

    // clock and clock event
    #define TL_CLK_MASK         0x00F00000
    #define TL_CLK_INFO         0x00100000
    #define TL_CLK_TRACE        0x00200000
    #define TL_CLK_WARNING      0x00400000
    #define TL_CLK_ERROR        0x00800000


    extern ULONG AVCStrmTraceMask;
    extern ULONG AVCStrmAssertLevel;

    #define ENTER(ModName)
    #define EXIT(ModName,Status)

    #define TRACE( l, x )                       \
        if( (l) & AVCStrmTraceMask ) {              \
            KdPrint( (_DRIVERNAME_ ": ") );     \
            KdPrint( x );                       \
        }

    #ifdef ASSERT
    #undef ASSERT
    #endif
    #define ASSERT( exp ) \
        if (AVCStrmAssertLevel && !(exp)) \
            RtlAssert( #exp, __FILE__, __LINE__, NULL )


#else

    #define ENTER(ModName)
    #define EXIT(ModName,Status) 
    #define TRACE( l, x )

#endif


/*
 *  Function externs
 */
NTSTATUS    DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath);
NTSTATUS    VA_AddDevice(IN PDRIVER_OBJECT driverObj, IN PDEVICE_OBJECT pdo);
VOID        VA_DriverUnload(IN PDRIVER_OBJECT DriverObject);
NTSTATUS    VA_Dispatch(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS    VA_PnP(struct DEVICE_EXTENSION *devExt, PIRP irp);
#ifdef HANDLE_DEVICE_USAGE
NTSTATUS    VA_DeviceUsageNotification(struct DEVICE_EXTENSION *devExt, PIRP irp);
#endif // HANDLE_DEVICE_USAGE 
NTSTATUS    VA_Power(struct DEVICE_EXTENSION *devExt, PIRP irp);
NTSTATUS    VA_PowerComplete(IN PDEVICE_OBJECT devObj, IN PIRP irp, IN PVOID context);
NTSTATUS    GetDeviceCapabilities(struct DEVICE_EXTENSION *devExt);
NTSTATUS    CallNextDriverSync(struct DEVICE_EXTENSION *devExt, PIRP irp);
NTSTATUS    CallDriverSync(PDEVICE_OBJECT devObj, PIRP irp);
NTSTATUS    CallDriverSyncCompletion(IN PDEVICE_OBJECT devObj, IN PIRP irp, IN PVOID Context);
VOID        IncrementPendingActionCount(struct DEVICE_EXTENSION *devExt);
VOID        DecrementPendingActionCount(struct DEVICE_EXTENSION *devExt);
NTSTATUS    QueryDeviceKey(HANDLE Handle, PWCHAR ValueNameString, PVOID Data, ULONG DataLength);
VOID        RegistryAccessSample(struct DEVICE_EXTENSION *devExt, PDEVICE_OBJECT devObj);

NTSTATUS
AvcStrm_IoControl(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\avcstrm\filter.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    filter.c

Abstract: NULL filter driver -- boilerplate code

Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/


#include "filter.h"

#ifdef TIME_BOMB
#include "..\..\inc\timebomb.c"
#endif

#if DBG
#define TraceMaskCheckIn  TL_PNP_ERROR | TL_STRM_ERROR

#define TraceMaskDefault  TL_PNP_ERROR   | TL_PNP_WARNING \
                          | TL_61883_ERROR | TL_61883_WARNING \
                          | TL_CIP_ERROR  \
                          | TL_FCP_ERROR  \
                          | TL_STRM_ERROR  | TL_STRM_WARNING \
                          | TL_CLK_ERROR

#define TraceMaskDebug  TL_PNP_ERROR  | TL_PNP_WARNING \
                          | TL_61883_ERROR| TL_61883_WARNING \
                          | TL_CIP_ERROR  \
                          | TL_FCP_ERROR  | TL_FCP_WARNING \
                          | TL_STRM_ERROR | TL_STRM_WARNING \
                          | TL_CLK_ERROR


ULONG AVCStrmTraceMask = TraceMaskCheckIn;
ULONG AVCStrmAssertLevel = 1;
#endif

#ifdef ALLOC_PRAGMA
        // #pragma alloc_text(INIT, DriverEntry)  // Comment out or facing Win9x loader bug
        #pragma alloc_text(PAGE, VA_AddDevice)
        #pragma alloc_text(PAGE, VA_DriverUnload)
#endif



NTSTATUS DriverEntry(
                        IN PDRIVER_OBJECT DriverObject, 
                        IN PUNICODE_STRING RegistryPath
                    )
/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    DriverObject - pointer to the driver object

    RegistryPath - pointer to a unicode string representing the path,
                   to driver-specific key in the registry.

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    ULONG i;

    PAGED_CODE();

    TRACE(TL_PNP_ERROR,("<<<<<<< AVCStrm.sys: %s; %s; %x %x >>>>>>>>\n", 
        __DATE__, __TIME__, DriverObject, RegistryPath));

#ifdef TIME_BOMB
    if (HasEvaluationTimeExpired()) {
        TRACE(TL_PNP_ERROR, ("Evaluation period expired!") );
        return STATUS_EVALUATION_EXPIRATION;
    }
#endif

    TRACE(TL_PNP_ERROR,("===================================================================\n"));
    TRACE(TL_PNP_ERROR,("AVCStrmTraceMask=0x%.8x = 0x[7][6][5][4][3][2][1][0] where\n", AVCStrmTraceMask));
    TRACE(TL_PNP_ERROR,("\n"));
    TRACE(TL_PNP_ERROR,("PNP:   [0]:Loading, power state, surprise removal, device SRB..etc.\n"));
    TRACE(TL_PNP_ERROR,("61883: [1]:Plugs, connection, CMP info and call to 61883.\n"));
    TRACE(TL_PNP_ERROR,("CIP:   [2]:Isoch data transfer.\n"));
    TRACE(TL_PNP_ERROR,("AVC:   [3]:AVC commands.\n"));
    TRACE(TL_PNP_ERROR,("Stream:[4]:Data intersec, open/close,.state, property etc.\n"));
    TRACE(TL_PNP_ERROR,("Clock: [5]:Clock (event and signal)etc.\n"));
    TRACE(TL_PNP_ERROR,("===================================================================\n"));
    TRACE(TL_PNP_ERROR,("dd avcstrm!AVCStrmTraceMask L1\n"));
    TRACE(TL_PNP_ERROR,("e avcstrm!AVCStrmTraceMask <new value> <enter>\n"));
    TRACE(TL_PNP_ERROR,("<for each nibble: ERROR:8, WARNING:4, TRACE:2, INFO:1, MASK:f>\n"));
    TRACE(TL_PNP_ERROR,("===================================================================\n\n"));


    /*
     *  Route all IRPs on device objects created by this driver
     *  to our IRP dispatch routine.
     */
    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++){
        DriverObject->MajorFunction[i] = VA_Dispatch; 
    }

    DriverObject->DriverExtension->AddDevice = VA_AddDevice;
    DriverObject->DriverUnload = VA_DriverUnload;

    return STATUS_SUCCESS;
}


NTSTATUS VA_AddDevice(
                        IN PDRIVER_OBJECT driverObj, 
                        IN PDEVICE_OBJECT physicalDevObj
                     )
/*++

Routine Description:

    The PlugPlay subsystem is handing us a brand new 
    PDO (Physical Device Object), for which we
    (by means of INF registration) have been asked to filter.

    We need to determine if we should attach or not.
    Create a filter device object to attach to the stack
    Initialize that device object
    Return status success.

    Remember: we can NOT actually send ANY non pnp IRPS to the given driver
    stack, UNTIL we have received an IRP_MN_START_DEVICE.

Arguments:

    driverObj - pointer to a device object.

    physicalDevObj -    pointer to a physical device object pointer 
                        created by the  underlying bus driver.

Return Value:

    NT status code.

--*/

{
    NTSTATUS status;
    PDEVICE_OBJECT filterDevObj = NULL;
    
    PAGED_CODE();

    TRACE(TL_PNP_WARNING,("VA_AddDevice: drvObj=%ph, pdo=%ph\n", driverObj, physicalDevObj)); 

    status = IoCreateDevice(    driverObj, 
                                sizeof(struct DEVICE_EXTENSION),
                                NULL,           // name for this device
                                FILE_DEVICE_UNKNOWN, 
                                FILE_AUTOGENERATED_DEVICE_NAME,                // device characteristics
                                FALSE,          // not exclusive
                                &filterDevObj); // our device object

    if (NT_SUCCESS(status)){
        struct DEVICE_EXTENSION *devExt;

        ASSERT(filterDevObj);

        /*
         *  Initialize device extension for new device object
         */
        devExt = (struct DEVICE_EXTENSION *)filterDevObj->DeviceExtension;
        RtlZeroMemory(devExt, sizeof(struct DEVICE_EXTENSION));
        devExt->signature = DEVICE_EXTENSION_SIGNATURE;
        devExt->state = STATE_INITIALIZED;
        devExt->filterDevObj = filterDevObj;
        devExt->physicalDevObj = physicalDevObj;
        
        devExt->pendingActionCount = 0;
        KeInitializeEvent(&devExt->removeEvent, NotificationEvent, FALSE);
#ifdef HANDLE_DEVICE_USAGE
        KeInitializeEvent(&devExt->deviceUsageNotificationEvent, SynchronizationEvent, TRUE);
#endif // HANDLE_DEVICE_USAGE

        /*
         *  Attach the new device object to the top of the device stack.
         */
        devExt->topDevObj = IoAttachDeviceToDeviceStack(filterDevObj, physicalDevObj);

        ASSERT(devExt->topDevObj);
        TRACE(TL_PNP_WARNING,("created filterDevObj %ph attached to %ph.\n", filterDevObj, devExt->topDevObj));


        //
        // As a filter driver, we do not want to change the power or I/O
        // behavior of the driver stack in any way.  Recall that a filter
        // driver should "appear" the same (almost) as the underlying device.
        // Therefore we must copy some bits from the device object _directly_
        // below us in the device stack (notice: DON'T copy from the PDO!)
        //


        /* Various I/O-related flags which should be maintained */
        /* (copy from lower device object) */
        filterDevObj->Flags |=
            (devExt->topDevObj->Flags & (DO_BUFFERED_IO | DO_DIRECT_IO));

        /* Various Power-related flags which should be maintained */
        /* (copy from lower device object) */
        filterDevObj->Flags |= (devExt->topDevObj->Flags &
            (DO_POWER_INRUSH | DO_POWER_PAGABLE /*| DO_POWER_NOOP*/)); 

#ifdef HANDLE_DEVICE_USAGE
        //
        // To determine whether some of our routines should initially be
        // pageable, we must consider the DO_POWER_xxxx flags of the
        // device object directly below us in the device stack.
        //
        // * We make ourselves pageable if:
        //     - that devobj has its PAGABLE bit set (so we know our power
        //       routines won't be called at DISPATCH_LEVEL)
        // -OR-
        //     - that devobj has its NOOP bit set (so we know we won't be
        //       participating in power-management at all).  NOTE, currently
        //       DO_POWER_NOOP is not implemented.
        //
        // * Otherwise, we make ourselves non-pageable because either:
        //     - that devobj has its INRUSH bit set (so we also have to be
        //       INRUSH, and code that handles INRUSH irps can't be pageable)
        // -OR-
        //     - that devobj does NOT have its PAGABLE bit set (and NOOP isn't
        //       set, so some of our code might be called at DISPATCH_LEVEL)
        //
        if ((devExt->topDevObj->Flags & DO_POWER_PAGABLE)
             /*|| (devExt->topDevObj->Flags & DO_POWER_NOOP)*/)
        {
            // We're initially pageable.
            //
            // Don't need to do anything else here, for now.
        }
        else
        {
            // We're initially non-pageable.
            //
            // We need to lock-down the code for all routines
            // that could be called at IRQL >= DISPATCH_LEVEL.
            TRACE(TL_STRM_TRACE,("LOCKing some driver code (non-pageable) (b/c init conditions)\n" ));
            devExt->initUnlockHandle = MmLockPagableCodeSection( VA_Power );  // some func that's inside the code section that we want to lock
            ASSERT( NULL != devExt->initUnlockHandle );
        }

        /*
         *  Remember our initial flag settings.
         *  (Need remember initial settings to correctly handle
         *  setting of PAGABLE bit later.)
         */
        devExt->initialFlags = filterDevObj->Flags & ~DO_DEVICE_INITIALIZING;
#endif // HANDLE_DEVICE_USAGE

        /*
         *  Clear the initializing bit from the new device object's flags.
         *  NOTE: must not do this until *after* setting DO_POWER_xxxx flags
         */
        filterDevObj->Flags &= ~DO_DEVICE_INITIALIZING;

        /*
         *  This is a do-nothing call to a sample function which
         *  demonstrates how to read the device's registry area.
         *  Note that you cannot make this call on devExt->filterDevObj
         *  because a filter device object does not have a devNode.
         *  We pass devExt->physicalDevObj, which is the device object
         *  for which this driver is a filter driver.
         */
        RegistryAccessSample(devExt, devExt->physicalDevObj);
    } 

    ASSERT(NT_SUCCESS(status));
    return status;
}


VOID VA_DriverUnload(IN PDRIVER_OBJECT DriverObject)
/*++

Routine Description:

    Free all the allocated resources, etc.

    Note:  Although the DriverUnload function often does nothing,
           the driver must set a DriverUnload function in 
           DriverEntry; otherwise, the kernel will never unload
           the driver.

Arguments:

    DriverObject - pointer to a driver object.

Return Value:

    VOID.

--*/
{
    PAGED_CODE();

    TRACE(TL_PNP_WARNING,("VA_DriverUnload\n")); 
}


NTSTATUS VA_Dispatch(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
/*++

Routine Description:

    Common entrypoint for all Io Request Packets

Arguments:

    DeviceObject - pointer to a device object.
    Irp - Io Request Packet

Return Value:

    NT status code.

--*/

{
    struct DEVICE_EXTENSION *devExt;
    PIO_STACK_LOCATION irpSp;
    BOOLEAN passIrpDown = TRUE;
    UCHAR majorFunc, minorFunc;
    NTSTATUS status;

    devExt = DeviceObject->DeviceExtension;
    ASSERT(devExt->signature == DEVICE_EXTENSION_SIGNATURE);

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    /*
     *  Get major/minor function codes in private variables
     *  so we can access them after the IRP is completed.
     */
    majorFunc = irpSp->MajorFunction;
    minorFunc = irpSp->MinorFunction;

    TRACE(TL_PNP_TRACE,("VA_Dispatch: majorFunc=%d, minorFunc=%d\n", 
            (ULONG)majorFunc, (ULONG)minorFunc)); 

    /*
     *  For all IRPs except REMOVE, we increment the PendingActionCount
     *  across the dispatch routine in order to prevent a race condition with
     *  the REMOVE_DEVICE IRP (without this increment, if REMOVE_DEVICE
     *  preempted another IRP, device object and extension might get
     *  freed while the second thread was still using it).
     */
    if (!((majorFunc == IRP_MJ_PNP) && (minorFunc == IRP_MN_REMOVE_DEVICE))){
        IncrementPendingActionCount(devExt);
    }

    if ((majorFunc != IRP_MJ_PNP) &&
        (majorFunc != IRP_MJ_CLOSE) &&
        (majorFunc != IRP_MJ_INTERNAL_DEVICE_CONTROL) &&
        ((devExt->state == STATE_REMOVING) ||
         (devExt->state == STATE_REMOVED))){

        /*
         *  While the device is being removed, 
         *  we only pass down the PNP and CLOSE IRPs.
         *  We fail all other IRPs.
         */
        status = Irp->IoStatus.Status = STATUS_DELETE_PENDING;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        passIrpDown = FALSE;
        TRACE(TL_PNP_WARNING,("Dev is removing/removed: majorFunc:%x; DevExt->state:%d\n", majorFunc, devExt->state ));
    }
    else {
        switch (majorFunc){

            case IRP_MJ_PNP:
                status = VA_PnP(devExt, Irp);
                passIrpDown = FALSE;
                break;

            case IRP_MJ_POWER:
                status = VA_Power(devExt, Irp);
                passIrpDown = FALSE;
                break;

            case IRP_MJ_DEVICE_CONTROL:  // Resue the user IRP
                TRACE(TL_PNP_ERROR,("IRP_MJ_DEVICE_CONTROL: Irp:%x\n", Irp));
                break;

            case IRP_MJ_INTERNAL_DEVICE_CONTROL: 
                switch (irpSp->Parameters.DeviceIoControl.IoControlCode)
                {
                case IOCTL_AVCSTRM_CLASS:   
                    status = AvcStrm_IoControl(DeviceObject, Irp);
                    passIrpDown = FALSE;  // Completed or marked pending in AvcStrm_IoControl().
                    break;  // to decrement pending action count
                default:
                    TRACE(TL_PNP_TRACE,("IRP_MJ_INTERNAL_DEVICE_CONTROL: IoControlCode:%x; !Support by AVCStrm; Pass it down.\n", irpSp->Parameters.DeviceIoControl.IoControlCode));
                    break;
                }

            case IRP_MJ_CREATE:
            case IRP_MJ_CLOSE:
            case IRP_MJ_SYSTEM_CONTROL:
            default:
                /*
                 *  For unsupported IRPs, we simply send the IRP
                 *  down the driver stack.
                 */
                break;
        }
    }

    if (passIrpDown){
        IoCopyCurrentIrpStackLocationToNext(Irp);
        status = IoCallDriver(devExt->topDevObj, Irp);
    }

    /*
     *  Balance the increment to PendingActionCount above.
     */
    if (!((majorFunc == IRP_MJ_PNP) && (minorFunc == IRP_MN_REMOVE_DEVICE))){
        DecrementPendingActionCount(devExt);
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\avcstrm\stream.c ===
/*++

Copyright (C) 1999  Microsoft Corporation

Module Name: 

    stream.c

Abstract

    MS AVC streaming filter driver

Author:

    Yee Wu    01/27/2000

Revision    History:
Date        Who         What
----------- --------- ------------------------------------------------------------
01/27/2000  YJW         created
--*/

 
#include "filter.h"
#include "ksmedia.h"


NTSTATUS
AVCStreamOpen(
    IN PIRP  pIrp,  // The Irp from its client
    IN struct DEVICE_EXTENSION * pDevExt,
    IN OUT AVCSTRM_OPEN_STRUCT * pOpenStruct
    )
/*++

Routine Description:

    Open a stream for a client based on the information in the OpenStruct.

Arguments:

    Irp -
        The irp client sent us.

    pDevExt -
        This driver's extension.

    pOpenStruct-
        Strcture contains information on how to open this stream.
        The stream context allocated will be returned and this will be the context 
        to be passed for subsequent call.

Return Value:

    Status
        STATUS_SUCCESS
        STATUS_INVALID_PARAMETER
        STATUS_INSUFFICIENT_RESOURCES

--*/
{
    NTSTATUS Status;
    ULONG ulSizeAllocated;
    PAVC_STREAM_EXTENSION pAVCStrmExt;


    PAGED_CODE();
    ENTER("AVCStreamOpen");


    Status = STATUS_SUCCESS;

    // Validate open structures.
    if(pOpenStruct == NULL) 
        return STATUS_INVALID_PARAMETER;
    if(pOpenStruct->AVCFormatInfo == NULL)
        return STATUS_INVALID_PARAMETER;

    // Validate open format.
    if(STATUS_SUCCESS != AVCStrmValidateFormat(pOpenStruct->AVCFormatInfo)) {
        TRACE(TL_STRM_ERROR,("StreamOpen: pAVCFormatInfo:%x; contain invalid data\n", pOpenStruct->AVCFormatInfo ));
        ASSERT(FALSE && "AVCFormatInfo contain invalid parameter!");
        return STATUS_INVALID_PARAMETER;
    }

    // If supported, open a stream based on this stream information.
    // Allocate a contiguous data strcutre for a 
    ulSizeAllocated = 
        sizeof(AVC_STREAM_EXTENSION) +
        sizeof(AVCSTRM_FORMAT_INFO) +
        sizeof(AVC_STREAM_DATA_STRUCT);

    pAVCStrmExt = (PAVC_STREAM_EXTENSION) ExAllocatePool(NonPagedPool, ulSizeAllocated);
    if(NULL == pAVCStrmExt) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Initialize stream extension:
    //    Copy the stream format information which is continuation of the stream extension.
    //
    RtlZeroMemory(pAVCStrmExt, ulSizeAllocated);
    pAVCStrmExt->SizeOfThisPacket = sizeof(AVC_STREAM_EXTENSION);

    (PBYTE) pAVCStrmExt->pAVCStrmFormatInfo = ((PBYTE) pAVCStrmExt) + sizeof(AVC_STREAM_EXTENSION);
    RtlCopyMemory(pAVCStrmExt->pAVCStrmFormatInfo, pOpenStruct->AVCFormatInfo, sizeof(AVCSTRM_FORMAT_INFO));

    (PBYTE) pAVCStrmExt->pAVCStrmDataStruc  = ((PBYTE) pAVCStrmExt->pAVCStrmFormatInfo) + sizeof(AVCSTRM_FORMAT_INFO);
    pAVCStrmExt->pAVCStrmDataStruc->SizeOfThisPacket = sizeof(AVC_STREAM_DATA_STRUCT);

    TRACE(TL_STRM_TRACE,("pAVCStrmExt:%x; pAVCStrmFormatInfo:%x; pAVCStrmDataStruc:%x\n", pAVCStrmExt, pAVCStrmExt->pAVCStrmFormatInfo, pAVCStrmExt->pAVCStrmDataStruc));

    pAVCStrmExt->hPlugLocal     = pOpenStruct->hPlugLocal;
    pAVCStrmExt->DataFlow       = pOpenStruct->DataFlow;
    pAVCStrmExt->StreamState    = KSSTATE_STOP;
    pAVCStrmExt->IsochIsActive  = FALSE;

    // Mutext for serialize setting stream state and accepting data packet 
    KeInitializeMutex(&pAVCStrmExt->hMutexControl, 0); 

    // Allocate resource for the common Request structure
    pAVCStrmExt->pIrpAVReq = IoAllocateIrp(pDevExt->physicalDevObj->StackSize, FALSE);
    if(!pAVCStrmExt->pIrpAVReq) {
        ExFreePool(pAVCStrmExt);  pAVCStrmExt = NULL;
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    KeInitializeMutex(&pAVCStrmExt->hMutexAVReq, 0);
    KeInitializeEvent(&pAVCStrmExt->hAbortDoneEvent, NotificationEvent, TRUE);   // Signal!
    pAVCStrmExt->pDevExt = pDevExt;

    //
    // Get target device's plug handle
    //
    if(!NT_SUCCESS(Status = 
        AVCStrmGetPlugHandle(
            pDevExt->physicalDevObj,
            pAVCStrmExt
            ))) {
        IoFreeIrp(pAVCStrmExt->pIrpAVReq);  pAVCStrmExt->pIrpAVReq = NULL;
        ExFreePool(pAVCStrmExt);  pAVCStrmExt = NULL;
        return Status;
    }

    //
    // Set stream state related flags
    //
    pAVCStrmExt->b1stNewFrameFromPauseState = TRUE;


    // Allocate PC resources
    //     Queues
    //
    if(!NT_SUCCESS(Status = 
        AVCStrmAllocateQueues(
            pDevExt,
            pAVCStrmExt,
            pAVCStrmExt->DataFlow,
            pAVCStrmExt->pAVCStrmDataStruc,
            pAVCStrmExt->pAVCStrmFormatInfo
            ))) {
        IoFreeIrp(pAVCStrmExt->pIrpAVReq);  pAVCStrmExt->pIrpAVReq = NULL;
        ExFreePool(pAVCStrmExt);  pAVCStrmExt = NULL;
        return Status;
    }

    // Return stream extension
    pOpenStruct->AVCStreamContext = pAVCStrmExt;
    TRACE(TL_STRM_TRACE,("Open: AVCStreamContext:%x\n", pOpenStruct->AVCStreamContext));

    // Cache it. This stream extension will be the context that will be
    // check when we are asked to provide service.
    pDevExt->NumberOfStreams++;  pDevExt->pAVCStrmExt[pDevExt->NextStreamIndex] = pAVCStrmExt;
    pDevExt->NextStreamIndex = ((pDevExt->NextStreamIndex + 1) % MAX_STREAMS_PER_DEVICE);

    return Status;
}

NTSTATUS
AVCStreamClose(
    IN PIRP  pIrp,  // The Irp from its client
    IN struct DEVICE_EXTENSION * pDevExt,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt
    )
/*++

Routine Description:

    Close a stream.

Arguments:

    Irp -
        The irp client sent us.

    pDevExt -
        This driver's extension.

    pAVCStrmExt -
        The stream context created when a stream is open.

    pOpenStruct-
        Strcture contains information on how to open this stream.
        The stream context allocated will be returned and this will be the context 
        to be passed for subsequent call.

Return Value:

    Status
        STATUS_SUCCESS
        STATUS_INVALID_PARAMETER

--*/
{
    NTSTATUS  Status;
    BOOL  Found;
    ULONG  i;

    PAGED_CODE();
    ENTER("AVCStreamClose");

    Status = STATUS_SUCCESS;

    Found = FALSE;
    for (i=0; i < MAX_STREAMS_PER_DEVICE; i++) {
        // Free stream extension
        if(pDevExt->pAVCStrmExt[i] == pAVCStrmExt) {
            Found = TRUE;
            break;
        }
    }

    if(!Found) {
        TRACE(TL_STRM_ERROR,("AVCStreamClose: pAVCStrmExt %x not found; pDevExt:%x\n", pAVCStrmExt, pDevExt));
        ASSERT(Found && "pAVCStrmExt not found!\n");
        return STATUS_INVALID_PARAMETER;
    }


    // Stop stream if not already
    if(pAVCStrmExt->StreamState != KSSTATE_STOP) {
        // Stop isoch if necessary and then Cancel all pending IOs
        AVCStrmCancelIO(pDevExt->physicalDevObj, pAVCStrmExt);
    }

    // Free queue allocated if they are not being used.
    if(NT_SUCCESS(Status = AVCStrmFreeQueues(pAVCStrmExt->pAVCStrmDataStruc))) {
        ExFreePool(pAVCStrmExt); pDevExt->pAVCStrmExt[i] = NULL;  pDevExt->NumberOfStreams--;
    } else {
        TRACE(TL_STRM_ERROR,("*** StreamClose: AVCStrmExt is not freed!\n"));
    }

    return Status;
}

NTSTATUS
AVCStreamControlGetState(
    IN PIRP  pIrp,  // The Irp from its client
    IN struct DEVICE_EXTENSION * pDevExt,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt,
    OUT KSSTATE * pKSState
    )
/*++

Routine Description:

    Get current stream state

Arguments:

    Irp -
        The irp client sent us.

    pDevExt -
        This driver's extension.

    pAVCStrmExt -
        The stream context created when a stream is open.

    pKSState -
        Get current stream state and return.

Return Value:

    Status
        STATUS_SUCCESS
        STATUS_INVALID_PARAMETER

--*/
{
    NTSTATUS Status;
    PAGED_CODE();
    ENTER("AVCStreamControlGetState");

    Status = STATUS_SUCCESS;

    *pKSState = pAVCStrmExt->StreamState;
    return Status;
}

NTSTATUS
AVCStreamControlSetState(
    IN PIRP  pIrp,  // The Irp from its client
    IN struct DEVICE_EXTENSION * pDevExt,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt,
    IN KSSTATE KSState
    )
/*++

Routine Description:

    Set to a new stream state

Arguments:

    Irp -
        The irp client sent us.

    pDevExt -
        This driver's extension.

    pAVCStrmExt -
        The stream context created when a stream is open.

    pKSState -
        Get current stream state.

Return Value:

    Status
        STATUS_SUCCESS
        STATUS_INVALID_PARAMETER

--*/
{
    NTSTATUS Status;
    PAGED_CODE();
    ENTER("AVCStreamControlSetState");

    TRACE(TL_STRM_WARNING,("Set stream state %d -> %d\n", pAVCStrmExt->StreamState, KSState));
    if(pAVCStrmExt->StreamState == KSState) 
        return STATUS_SUCCESS;

    Status = STATUS_SUCCESS;

    switch (KSState) {
    case KSSTATE_STOP:

        if(pAVCStrmExt->StreamState != KSSTATE_STOP) { 
            KeWaitForMutexObject(&pAVCStrmExt->hMutexControl, Executive, KernelMode, FALSE, NULL);
            // Once this is set, data stream will reject SRB_WRITE/READ_DATA
            pAVCStrmExt->StreamState = KSSTATE_STOP;
            KeReleaseMutex(&pAVCStrmExt->hMutexControl, FALSE);

            // Cancel all pending IOs
            AVCStrmCancelIO(pDevExt->physicalDevObj, pAVCStrmExt);

            // Breeak Isoch connection
            AVCStrmBreakConnection(pDevExt->physicalDevObj, pAVCStrmExt);
        }
        break;

    case KSSTATE_ACQUIRE:

        // Get Isoch resource
        if(pAVCStrmExt->StreamState == KSSTATE_STOP) {
            //
            // Reset values.for the case that the graph restart 
            //
            pAVCStrmExt->pAVCStrmDataStruc->CurrentStreamTime  = 0;
            pAVCStrmExt->pAVCStrmDataStruc->FramesProcessed    = 0;
            pAVCStrmExt->pAVCStrmDataStruc->FramesDropped      = 0;
            pAVCStrmExt->pAVCStrmDataStruc->cntFrameCancelled  = 0;
#if DBG
            pAVCStrmExt->pAVCStrmDataStruc->FramesAttached     = 0;
#endif

            pAVCStrmExt->pAVCStrmDataStruc->cntDataReceived    = 0;
            // All the list should be initialized (count:0, and List is empty)
            TRACE(TL_STRM_TRACE,("Set to ACQUIRE state: flow %d; AQD [%d:%d:%d]\n", pAVCStrmExt->DataFlow, 
                pAVCStrmExt->pAVCStrmDataStruc->cntDataAttached, pAVCStrmExt->pAVCStrmDataStruc->cntDataQueued, pAVCStrmExt->pAVCStrmDataStruc->cntDataDetached));
            ASSERT(pAVCStrmExt->pAVCStrmDataStruc->cntDataAttached == 0 && IsListEmpty(&pAVCStrmExt->pAVCStrmDataStruc->DataAttachedListHead));
            ASSERT(pAVCStrmExt->pAVCStrmDataStruc->cntDataQueued   == 0 && IsListEmpty(&pAVCStrmExt->pAVCStrmDataStruc->DataQueuedListHead));
            ASSERT(pAVCStrmExt->pAVCStrmDataStruc->cntDataDetached  > 0 && !IsListEmpty(&pAVCStrmExt->pAVCStrmDataStruc->DataDetachedListHead));
            // Cannot stream using previous stream data !!!
            if(pAVCStrmExt->pAVCStrmDataStruc->cntDataAttached != 0 ||  // Stale data ??
               pAVCStrmExt->pAVCStrmDataStruc->cntDataQueued   != 0 ||  // NO data unil PAUSE ??
               pAVCStrmExt->pAVCStrmDataStruc->cntDataDetached == 0) {  // NO avaialble queue ?
                TRACE(TL_STRM_ERROR,("Set to ACQUIRE State: queues not empty (stale data?); Failed!\n"));
                return STATUS_UNSUCCESSFUL;
            }
            
            //
            // Make connection
            //
            Status = 
                AVCStrmMakeConnection(
                    pDevExt->physicalDevObj,
                    pAVCStrmExt
                    );

            if(!NT_SUCCESS(Status)) {

                TRACE(TL_STRM_ERROR,("Acquire failed:%x\n", Status));
                ASSERT(NT_SUCCESS(Status));

                //
                // Change to generic insufficient resource status.
                //
                Status = STATUS_INSUFFICIENT_RESOURCES;

                //
                // Note: even setting to this state failed, KSSTATE_PAUSE will still be called;
                // Since hConnect is NULL, STATUS_INSUFFICIENT_RESOURCES will be returned.
                //
            }
            else {
                //
                // Can verify connection by query the plug state 
                //            
                Status = 
                    AVCStrmGetPlugState(
                        pDevExt->physicalDevObj,
                        pAVCStrmExt
                        );
                if(NT_SUCCESS(Status)) {
                    ASSERT(pAVCStrmExt->RemotePlugState.BC_Connections == 1 || pAVCStrmExt->RemotePlugState.PP_Connections > 0);
                }
                else {
                    ASSERT(NT_SUCCESS(Status) && "Failed to get Plug State");
                }
            }
        }
        break;

    case KSSTATE_PAUSE:

        if(pAVCStrmExt->hConnect == NULL) {
            // Cannot stream without connection!  
            // failed to get hConnect at ACQUIRE state.
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }
           
        // The system time (1394 CycleTime) will reset when enter PAUSE state.        
        if(pAVCStrmExt->StreamState != KSSTATE_PAUSE) {
            pAVCStrmExt->b1stNewFrameFromPauseState = TRUE;
            pAVCStrmExt->pAVCStrmDataStruc->PictureNumber = 0;
        }
            

        if(pAVCStrmExt->StreamState == KSSTATE_ACQUIRE || 
           pAVCStrmExt->StreamState == KSSTATE_STOP)   {             
 
        } 
        else if (pAVCStrmExt->StreamState == KSSTATE_RUN) {

            //
            // Stop isoch transfer            
            //          
            AVCStrmStopIsoch(pDevExt->physicalDevObj, pAVCStrmExt);
        }
        break;

    case KSSTATE_RUN:

        // Even there is no attach data request,
        // 61883 has its own buffers so isoch can start now.
        Status = 
            AVCStrmStartIsoch(
                pDevExt->physicalDevObj,
                pAVCStrmExt
                );
        ASSERT(NT_SUCCESS(Status));
        
        pAVCStrmExt->LastSystemTime = GetSystemTime();

        break;

    default:
        Status = STATUS_NOT_SUPPORTED;
    }

    if(NT_SUCCESS(Status)) 
        pAVCStrmExt->StreamState = KSState;

    return Status;
}

#if 0
NTSTATUS
AVCStreamControlGetProperty(
    IN PIRP  pIrp,  // The Irp from its client
    IN struct DEVICE_EXTENSION * pDevExt,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt,
    IN PSTREAM_PROPERTY_DESCRIPTOR pSPD  // BUGBUG StreamClass specific
    )
/*++

Routine Description:

    Get control property

Arguments:

    Irp -
        The irp client sent us.

    pDevExt -
        This driver's extension.

    pAVCStrmExt -
        The stream context created when a stream is open.

    pSPD -
        Stream property descriptor

Return Value:

    Status
        STATUS_SUCCESS
        STATUS_INVALID_PARAMETER

--*/
{
    NTSTATUS  Status;
    ULONG  ulActualBytesTransferred;
    PAGED_CODE();
    ENTER("AVCStreamControlGetProperty");


    Status = STATUS_NOT_SUPPORTED;

    if(IsEqualGUID (&KSPROPSETID_Connection, &pSPD->Property->Set)) {

        Status = 
            AVCStrmGetConnectionProperty(
                pDevExt,
                pAVCStrmExt,
                pSPD,
                &ulActualBytesTransferred
                );
    } 
    else if (IsEqualGUID (&PROPSETID_VIDCAP_DROPPEDFRAMES, &pSPD->Property->Set)) {

        Status = 
            AVCStrmGetDroppedFramesProperty(
                pDevExt,
                pAVCStrmExt,
                pSPD,
                &ulActualBytesTransferred
                );
    } 

    return Status;
}

NTSTATUS
AVCStreamControlSetProperty(
    IN PIRP  pIrp,  // The Irp from its client
    IN struct DEVICE_EXTENSION * pDevExt,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt,
    IN PSTREAM_PROPERTY_DESCRIPTOR pSPD  // BUGBUG StreamClass specific
    )
/*++

Routine Description:

    Set control property

Arguments:

    Irp -
        The irp client sent us.

    pDevExt -
        This driver's extension.

    pAVCStrmExt -
        The stream context created when a stream is open.

    pSPD -
        Stream property descriptor

Return Value:

    Status
        STATUS_SUCCESS
        STATUS_INVALID_PARAMETER

--*/
{
    NTSTATUS Status;
    PAGED_CODE();
    ENTER("AVCStreamControlSetProperty");

    Status = STATUS_NOT_SUPPORTED;

    return Status;
}
#endif

NTSTATUS
AVCStreamRead(
    IN PIRP  pIrpUpper,  // The Irp from its client
    IN struct DEVICE_EXTENSION * pDevExt,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt,
    IN AVCSTRM_BUFFER_STRUCT  * pBufferStruct
    )
/*++

Routine Description:

    Submit a read buffer to be filled.

Arguments:

    Irp -
        The irp client sent us.

    pDevExt -
        This driver's extension.

    pAVCStrmExt -
        The stream context created when a stream is open.

    BufferStruct -
        Buffer structure

Return Value:

    Status
        STATUS_SUCCESS
        STATUS_INVALID_PARAMETER

--*/
{
    PAVC_STREAM_DATA_STRUCT  pDataStruc;
    KIRQL  oldIrql;
    PIO_STACK_LOCATION  NextIrpStack;
    NTSTATUS  Status;
    PAVCSTRM_DATA_ENTRY  pDataEntry;


    PAGED_CODE();
    ENTER("AVCStreamRead");

    // Cancel data request if device is being removed.
    if(   pDevExt->state == STATE_REMOVING
       || pDevExt->state == STATE_REMOVED) {
        TRACE(TL_STRM_WARNING,("Read: device is remvoved; cancel read/write request!!\n"));
        Status = STATUS_DEVICE_REMOVED;  goto DoneStreamRead;
    }

    // If we are in the abort state, we will reject incoming data request.
    if(pAVCStrmExt->lAbortToken) {
        TRACE(TL_STRM_WARNING,("Read: aborting a stream; stop receiving data reqest!!\n"));
        Status = STATUS_CANCELLED;  goto DoneStreamRead;
    }

    // Validate basic parameters
    if(pAVCStrmExt->DataFlow != KSPIN_DATAFLOW_OUT) {
        TRACE(TL_STRM_ERROR,("Read: invalid Wrong data flow (%d) direction!!\n", pAVCStrmExt->DataFlow));
        Status = STATUS_INVALID_PARAMETER;  goto DoneStreamRead;
    }
    pDataStruc = pAVCStrmExt->pAVCStrmDataStruc;
    if(!pDataStruc) {
        TRACE(TL_STRM_ERROR,("Read: invalid pDataStruc:%x\n", pDataStruc));
        Status = STATUS_INVALID_PARAMETER;  goto DoneStreamRead;
    }
    if(pBufferStruct->StreamHeader->FrameExtent < pDataStruc->FrameSize) {
        TRACE(TL_STRM_ERROR,("Read: invalid buffer size:%d < FrameSize:%d\n", pBufferStruct->StreamHeader->FrameExtent, pDataStruc->FrameSize));
        Status = STATUS_INVALID_PARAMETER;  goto DoneStreamRead;
    }
    if(!pBufferStruct->FrameBuffer) {
        TRACE(TL_STRM_ERROR,("Read: invalid FrameBuffer:%x\n", pBufferStruct->FrameBuffer));
        Status = STATUS_INVALID_PARAMETER;  goto DoneStreamRead;
    }

    // Only accept read requests when in either the Pause or Run state and is connected.
    if( pAVCStrmExt->StreamState == KSSTATE_STOP       ||
        pAVCStrmExt->StreamState == KSSTATE_ACQUIRE    ||
        pAVCStrmExt->hConnect == NULL        
        ) {
        TRACE(TL_STRM_WARNING,("Read: StrmSt:%d and Connected:%x!!\n", pAVCStrmExt->StreamState, pAVCStrmExt->hConnect));
        Status = STATUS_CANCELLED;  goto DoneStreamRead;
    }


    KeAcquireSpinLock(&pDataStruc->DataListLock, &oldIrql);
    if(IsListEmpty(&pDataStruc->DataDetachedListHead)) {      
        TRACE(TL_STRM_ERROR,("Read:no detached buffers!\n"));
        ASSERT(!IsListEmpty(&pDataStruc->DataDetachedListHead));
        KeReleaseSpinLock(&pDataStruc->DataListLock, oldIrql);  
        Status = STATUS_INSUFFICIENT_RESOURCES;  goto DoneStreamRead;
    }

    pDataEntry = (PAVCSTRM_DATA_ENTRY) 
        RemoveHeadList(&pDataStruc->DataDetachedListHead); InterlockedDecrement(&pDataStruc->cntDataDetached);

    pDataStruc->cntDataReceived++;

    //
    // Format an attach frame request
    //
    AVCStrmFormatAttachFrame(
        pAVCStrmExt->DataFlow,
        pAVCStrmExt,
        pAVCStrmExt->pAVCStrmFormatInfo->AVCStrmFormat,
        &pDataEntry->AVReq,
        pDataEntry,
        pDataStruc->SourcePacketSize,
        pDataStruc->FrameSize,
        pIrpUpper,
        pBufferStruct->StreamHeader,
        pBufferStruct->FrameBuffer
        );

    // Client's clock information
    pDataEntry->ClockProvider = pBufferStruct->ClockProvider;
    pDataEntry->ClockHandle   = pBufferStruct->ClockHandle;

    // Add this to the attached list before it is completed since
    // the completion callback can be called before the IRP completion rooutine!
    InsertTailList(&pDataStruc->DataAttachedListHead, &pDataEntry->ListEntry); InterlockedIncrement(&pDataStruc->cntDataAttached);
    KeReleaseSpinLock(&pDataStruc->DataListLock, oldIrql);        

    NextIrpStack = IoGetNextIrpStackLocation(pDataEntry->pIrpLower);
    NextIrpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    NextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_61883_CLASS;
    NextIrpStack->Parameters.Others.Argument1 = &pDataEntry->AVReq;

    IoSetCompletionRoutine(
        pDataEntry->pIrpLower, 
        AVCStrmAttachFrameCR, 
        pDataEntry,   // Context
        TRUE,   // Success
        TRUE,   // Error
        TRUE    // Cancel
        );

    pDataEntry->pIrpLower->IoStatus.Status = STATUS_SUCCESS;  // Initialize it 

    if(!NT_SUCCESS(Status = IoCallDriver( 
        pDevExt->physicalDevObj,
        pDataEntry->pIrpLower
        ))) {

        //
        // Completion routine should have take care of this.
        //

        return Status;
    }


    //
    // Check the flag in pDataEntry to know the status of the IRP.
    //

    KeAcquireSpinLock(&pDataStruc->DataListLock, &oldIrql);

    ASSERT(IsStateSet(pDataEntry->State, DE_IRP_LOWER_ATTACHED_COMPLETED));  // Must be attached

    if(IsStateSet(pDataEntry->State, DE_IRP_LOWER_CALLBACK_COMPLETED)) {

        if(IsStateSet(pDataEntry->State, DE_IRP_UPPER_COMPLETED)) {

            //
            // How does this happen?  It should be protected by spinlock! Assert() to understand!
            //
            TRACE(TL_STRM_ERROR,("Watch out! Read: pDataEntry:%x\n", pDataEntry));        

            ASSERT(!IsStateSet(pDataEntry->State, DE_IRP_UPPER_COMPLETED)); 
        }
        else {

            IoCompleteRequest( pDataEntry->pIrpUpper, IO_NO_INCREMENT );  pDataEntry->State |= DE_IRP_UPPER_COMPLETED;

            //
            // Transfer from attach to detach list
            //
            RemoveEntryList(&pDataEntry->ListEntry); InterlockedDecrement(&pDataStruc->cntDataAttached);        
#if DBG
            if(pDataStruc->cntDataAttached < 0) {
                TRACE(TL_STRM_ERROR,("Read: pDataStruc:%x; pDataEntry:%x\n", pDataStruc, pDataEntry));        
                ASSERT(pDataStruc->cntDataAttached >= 0);  
            }
#endif
            InsertTailList(&pDataStruc->DataDetachedListHead, &pDataEntry->ListEntry); InterlockedIncrement(&pDataStruc->cntDataDetached);
        }
    }
    else {

        //
        // Normal case: IrpUpper will be pending until the callback routine is called or cancelled.
        //

        IoMarkIrpPending(pDataEntry->pIrpUpper);  pDataEntry->State |= DE_IRP_UPPER_PENDING_COMPLETED;

        Status = STATUS_PENDING; // This will be returned to IoCallDriver() from the client.
    }

    KeReleaseSpinLock(&pDataStruc->DataListLock, oldIrql);        


    EXIT("AVCStreamRead", Status);

    //
    // If the data was attached siccessful, we must return STATUS_PENDING
    //
    return Status;

DoneStreamRead:

    // Note: pDataStruc and pDataEntry may not be valid!
    pIrpUpper->IoStatus.Status = Status;
    IoCompleteRequest( pIrpUpper, IO_NO_INCREMENT );        

    EXIT("AVCStreamRead", Status);

    return Status;
}

#if DBG
typedef union {
    CYCLE_TIME CycleTime;
    ULONG ulCycleTime;
    } U_CYCLE_TIME, * PU_CYCLE_TIME;
#endif

NTSTATUS
AVCStreamWrite(
    IN PIRP  pIrpUpper,  // The Irp from its client
    IN struct DEVICE_EXTENSION * pDevExt,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt,
    IN AVCSTRM_BUFFER_STRUCT  * pBufferStruct
    )
/*++

Routine Description:

    Submit a write buffer to be transmitted.

Arguments:

    Irp -
        The irp client sent us.

    pDevExt -
        This driver's extension.

    pAVCStrmExt -
        The stream context created when a stream is open.

    BufferStruct -
        Buffer structure

Return Value:

    Status
        STATUS_SUCCESS
        STATUS_INVALID_PARAMETER

--*/
{
    PAVC_STREAM_DATA_STRUCT  pDataStruc;
    KIRQL  oldIrql;
    PIO_STACK_LOCATION  NextIrpStack;
    NTSTATUS  Status;
    PAVCSTRM_DATA_ENTRY  pDataEntry;

    PAGED_CODE();
    ENTER("AVCStreamWrite");

    // Cancel data request if device is being removed.
    if(   pDevExt->state == STATE_REMOVING
       || pDevExt->state == STATE_REMOVED) {
        TRACE(TL_STRM_WARNING,("Write: device is remvoved; cancel read/write request!!\n"));
        Status = STATUS_DEVICE_REMOVED;  goto DoneStreamWrite;
    }

    // If we are in the abort state, we will reject incoming data request.
    if(pAVCStrmExt->lAbortToken) {
        TRACE(TL_STRM_WARNING,("Write: aborting a stream; stop receiving data reqest!!\n"));
        Status = STATUS_CANCELLED;  goto DoneStreamWrite;
    }

    // Validate basic parameters
    if(pAVCStrmExt->DataFlow != KSPIN_DATAFLOW_IN) {
        TRACE(TL_STRM_ERROR,("Write: invalid Wrong data flow (%d) direction!!\n", pAVCStrmExt->DataFlow));
        Status = STATUS_INVALID_PARAMETER;  goto DoneStreamWrite;
    }
    pDataStruc = pAVCStrmExt->pAVCStrmDataStruc;
    if(!pDataStruc) {
        TRACE(TL_STRM_ERROR,("Write: invalid pDataStruc:%x\n", pDataStruc));
        Status = STATUS_INVALID_PARAMETER;  goto DoneStreamWrite;
    }

    // The client should take care of END OF stream buffer;
    // If we get this flag, we will ignore it for now.
    if((pBufferStruct->StreamHeader->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM)) {
        TRACE(TL_STRM_TRACE,("Write: End of stream\n"));

        // Wait until all transmit are completed.
        AVCStrmWaitUntilAttachedAreCompleted(pAVCStrmExt);

        Status = STATUS_SUCCESS;  goto DoneStreamWrite;
    }

    // The client should take care of format change;
    // If we get this flag, we will ignore it for now.
    if((pBufferStruct->StreamHeader->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_TYPECHANGED)) {
        TRACE(TL_STRM_WARNING,("Write: Format change reuqested\n"));
        Status = STATUS_SUCCESS;  goto DoneStreamWrite;
    }

    if(pBufferStruct->StreamHeader->FrameExtent < pDataStruc->FrameSize) {
        TRACE(TL_STRM_ERROR,("Write: invalid buffer size:%d < FrameSize:%d\n", pBufferStruct->StreamHeader->FrameExtent, pDataStruc->FrameSize));
        Status = STATUS_INVALID_PARAMETER;  goto DoneStreamWrite;
    }
    if(!pBufferStruct->FrameBuffer) {
        TRACE(TL_STRM_ERROR,("Write: invalid FrameBuffer:%x\n", pBufferStruct->FrameBuffer));
        Status = STATUS_INVALID_PARAMETER;  goto DoneStreamWrite;
    }

    // Only accept write requests when in either the Pause or Run state and is connected.
    if( pAVCStrmExt->StreamState == KSSTATE_STOP       ||
        pAVCStrmExt->StreamState == KSSTATE_ACQUIRE    ||
        pAVCStrmExt->hConnect == NULL
        ) {
        TRACE(TL_STRM_ERROR,("Write: StrmSt:%d or hConnect:%x!!\n", pAVCStrmExt->StreamState, pAVCStrmExt->hConnect));
        Status = STATUS_CANCELLED;  goto DoneStreamWrite;
    }

#if DBG
#define MASK_LOWER_25BIT  0x01ffffff
    if(pAVCStrmExt->pAVCStrmFormatInfo->AVCStrmFormat == AVCSTRM_FORMAT_MPEG2TS) {
        U_CYCLE_TIME TimeStamp25Bits;
        TimeStamp25Bits.ulCycleTime = *((PDWORD) pBufferStruct->FrameBuffer);
        TimeStamp25Bits.ulCycleTime = bswap(TimeStamp25Bits.ulCycleTime);
        TRACE(TL_CIP_TRACE,("\t%d \t%d \t%d \t%x \t%d \t%d\n", 
            (DWORD) pDataStruc->cntDataReceived, 
            pDataStruc->FrameSize,
            pDataStruc->SourcePacketSize,
            TimeStamp25Bits.ulCycleTime & MASK_LOWER_25BIT,
            TimeStamp25Bits.CycleTime.CL_CycleCount, 
            TimeStamp25Bits.CycleTime.CL_CycleOffset));   
    }
#endif

    KeAcquireSpinLock(&pDataStruc->DataListLock, &oldIrql);
    if(IsListEmpty(&pDataStruc->DataDetachedListHead)) {
        KeReleaseSpinLock(&pDataStruc->DataListLock, oldIrql);        
        TRACE(TL_STRM_ERROR,("Write:no detached buffers!\n"));
        ASSERT(!IsListEmpty(&pDataStruc->DataDetachedListHead));
        Status = STATUS_INSUFFICIENT_RESOURCES;  goto DoneStreamWrite;
    }

#if DBG
    //
    // For write operation, DataUsed <= FrameSize <= FrameExt
    //
    if(pBufferStruct->StreamHeader->DataUsed < pDataStruc->FrameSize) {
        // Jut to detect if this ever happen.
        TRACE(TL_PNP_ERROR,("**** Write: DataUsed:%d < FrameSize:%d; DataRcv:%d; AQD [%d:%d:%d]\n", 
            pBufferStruct->StreamHeader->DataUsed, pDataStruc->FrameSize,
            (DWORD) pDataStruc->cntDataReceived,
            pAVCStrmExt->pAVCStrmDataStruc->cntDataAttached,
            pAVCStrmExt->pAVCStrmDataStruc->cntDataQueued,
            pAVCStrmExt->pAVCStrmDataStruc->cntDataDetached
            ));
    }
#endif


    pDataEntry = (PAVCSTRM_DATA_ENTRY) 
        RemoveHeadList(&pDataStruc->DataDetachedListHead); InterlockedDecrement(&pDataStruc->cntDataDetached);

    pDataStruc->cntDataReceived++;

    //
    // Format an attach frame request
    //
    AVCStrmFormatAttachFrame(
        pAVCStrmExt->DataFlow,
        pAVCStrmExt,
        pAVCStrmExt->pAVCStrmFormatInfo->AVCStrmFormat,
        &pDataEntry->AVReq,
        pDataEntry,
        pDataStruc->SourcePacketSize,
#if 0
        pDataStruc->FrameSize,
#else
        pBufferStruct->StreamHeader->DataUsed,  // For write operation, DataUsed <= FrameSize <= FrameExt
#endif
        pIrpUpper,
        pBufferStruct->StreamHeader,
        pBufferStruct->FrameBuffer
        );

    // Client's clock information
    pDataEntry->ClockProvider = pBufferStruct->ClockProvider;
    pDataEntry->ClockHandle   = pBufferStruct->ClockHandle;

    // Add this to the attached list before it is completed since
    // the completion callback can be called before the IRP completion rooutine!
    InsertTailList(&pDataStruc->DataAttachedListHead, &pDataEntry->ListEntry); InterlockedIncrement(&pDataStruc->cntDataAttached);
    KeReleaseSpinLock(&pDataStruc->DataListLock, oldIrql);        

    NextIrpStack = IoGetNextIrpStackLocation(pDataEntry->pIrpLower);
    NextIrpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    NextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_61883_CLASS;
    NextIrpStack->Parameters.Others.Argument1 = &pDataEntry->AVReq;

    IoSetCompletionRoutine(
        pDataEntry->pIrpLower, 
        AVCStrmAttachFrameCR, 
        pDataEntry, 
        TRUE, 
        TRUE, 
        TRUE
        );

    IoSetCancelRoutine(
        pDataEntry->pIrpLower,
        NULL
        );

    pDataEntry->pIrpLower->IoStatus.Status = STATUS_SUCCESS;  // Initialize it 

    if(!NT_SUCCESS(Status = IoCallDriver( 
        pDevExt->physicalDevObj,
        pDataEntry->pIrpLower
        ))) {

        //
        // Completion routine should have take care of this.
        //

        return Status;
    }


    //
    // Check the flag in pDataEntry to know the status of the IRP.
    //

    KeAcquireSpinLock(&pDataStruc->DataListLock, &oldIrql);

    ASSERT(IsStateSet(pDataEntry->State, DE_IRP_LOWER_ATTACHED_COMPLETED));  // Must be attached

    if(IsStateSet(pDataEntry->State, DE_IRP_LOWER_CALLBACK_COMPLETED)) {

        if(IsStateSet(pDataEntry->State, DE_IRP_UPPER_COMPLETED)) {

            //
            // How does this happen?  It should be protected by spinlock! Assert() to understand!
            //
            TRACE(TL_STRM_ERROR,("Watch out! Write: pDataEntry:%x\n", pDataEntry));        

            ASSERT(!IsStateSet(pDataEntry->State, DE_IRP_UPPER_COMPLETED)); 
        }
        else {

            IoCompleteRequest( pDataEntry->pIrpUpper, IO_NO_INCREMENT );  pDataEntry->State |= DE_IRP_UPPER_COMPLETED;

            //
            // Transfer from attach to detach list
            //
            RemoveEntryList(&pDataEntry->ListEntry); InterlockedDecrement(&pDataStruc->cntDataAttached);        

            //
            // Signal when there is no more data buffer attached.
            //
            if(pDataStruc->cntDataAttached == 0) 
                KeSetEvent(&pDataStruc->hNoAttachEvent, 0, FALSE); 

#if DBG
            if(pDataStruc->cntDataAttached < 0) {
                TRACE(TL_STRM_ERROR,("Write: pDataStruc:%x; pDataEntry:%x\n", pDataStruc, pDataEntry));        
                ASSERT(pDataStruc->cntDataAttached >= 0);  
            }
#endif
            InsertTailList(&pDataStruc->DataDetachedListHead, &pDataEntry->ListEntry); InterlockedIncrement(&pDataStruc->cntDataDetached);
        }
    }
    else {

        //
        // Normal case: IrpUpper will be pending until the callback routine is called or cancelled.
        //

        IoMarkIrpPending(pDataEntry->pIrpUpper);  pDataEntry->State |= DE_IRP_UPPER_PENDING_COMPLETED;

        Status = STATUS_PENDING; // This will be returned to IoCallDriver() from the client.
    }

    KeReleaseSpinLock(&pDataStruc->DataListLock, oldIrql);     

    EXIT("AVCStreamWrite", Status);

    //
    // If the data was attached siccessful, we must return STATUS_PENDING
    //
    return Status;

DoneStreamWrite:

    // Note: pDataStruc and pDataEntry may not be valid!
    pIrpUpper->IoStatus.Status = Status;
    IoCompleteRequest( pIrpUpper, IO_NO_INCREMENT );        

    EXIT("AVCStreamWrite", Status);

    return Status;
}


NTSTATUS
AVCStreamAbortStreaming(
    IN PIRP  pIrp,  // The Irp from its client
    IN struct DEVICE_EXTENSION * pDevExt,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt
    )
/*++

Routine Description:

    This routine could be called at DISPATCH_LEVEL so it will create a work item 
    to stop isoch and then cancel all pennding buffers.
    To cancel each individual buffer, IoCancelIrp() should be used..

Arguments:

    Irp -
        The irp client sent us.

    pDevExt -
        This driver's extension.

    pAVCStrmExt -
        The stream context created when a stream is open.

Return Value:

    Status
        STATUS_SUCCESS
        STATUS_INVALID_PARAMETER

--*/
{
    NTSTATUS Status;
    PAGED_CODE();
    ENTER("AVCStreamAbortStreaming");

    TRACE(TL_STRM_WARNING,("AbortStreaming: Active:%d; State:%d\n", pAVCStrmExt->IsochIsActive, pAVCStrmExt->StreamState));

    // Claim this token
    if(InterlockedExchange(&pAVCStrmExt->lAbortToken, 1) == 1) {
        TRACE(TL_STRM_WARNING,("AbortStreaming: One already issued.\n"));
        return STATUS_SUCCESS;  
    }

    Status = STATUS_SUCCESS;

#ifdef USE_WDM110  // Win2000 code base
    ASSERT(pAVCStrmExt->pIoWorkItem == NULL);  // Have not yet queued work item.

    // We will queue work item to stop and cancel all SRBs
    if(pAVCStrmExt->pIoWorkItem = IoAllocateWorkItem(pDevExt->physicalDevObj)) { 

        // Set to non-signal
        KeClearEvent(&pAVCStrmExt->hAbortDoneEvent);  // Before queuing; just in case it return the work item is completed.
        IoQueueWorkItem(
            pAVCStrmExt->pIoWorkItem,
            AVCStrmAbortStreamingWorkItemRoutine,
            DelayedWorkQueue, // CriticalWorkQueue 
            pAVCStrmExt
            );

#else              // Win9x code base
    ExInitializeWorkItem( &pAVCStrmExt->IoWorkItem, AVCStrmAbortStreamingWorkItemRoutine, pAVCStrmExt);
    if(TRUE) {

        // Set to non-signal
        KeClearEvent(&pAVCStrmExt->hAbortDoneEvent);  // Before queuing; just in case it return the work item is completed.

        ExQueueWorkItem( 
            &pAVCStrmExt->IoWorkItem,
            DelayedWorkQueue // CriticalWorkQueue 
            ); 
#endif

        TRACE(TL_STRM_TRACE,("AbortStreaming: CancelWorkItm queued; Pic#:%d;Prc:%d;;Drop:%d; AQD [%d:%d:%d]\n",
            (DWORD) pAVCStrmExt->pAVCStrmDataStruc->PictureNumber,
            (DWORD) pAVCStrmExt->pAVCStrmDataStruc->FramesProcessed, 
            (DWORD) pAVCStrmExt->pAVCStrmDataStruc->FramesDropped,
            pAVCStrmExt->pAVCStrmDataStruc->cntDataAttached,
            pAVCStrmExt->pAVCStrmDataStruc->cntDataQueued,
            pAVCStrmExt->pAVCStrmDataStruc->cntDataDetached
            ));

    } 
#ifdef USE_WDM110  // Win2000 code base
    else {
        Status = STATUS_INSUFFICIENT_RESOURCES;  // Only reason IoAllocateWorkItem can fail.
        InterlockedExchange(&pAVCStrmExt->lAbortToken, 0);
        ASSERT(pAVCStrmExt->pIoWorkItem && "IoAllocateWorkItem failed.\n");
    }
#endif

#define MAX_ABORT_WAIT  50000000   // max wait time (100nsec unit)

    if(NT_SUCCESS(Status)) {

        NTSTATUS StatusWait;
        LARGE_INTEGER tmMaxWait;

        tmMaxWait = RtlConvertLongToLargeInteger(-(MAX_ABORT_WAIT));

        //
        // Wait with timeout until the work item has completed.
        //
        StatusWait = 
            KeWaitForSingleObject( 
                &pAVCStrmExt->hAbortDoneEvent,
                Executive,
                KernelMode,
                FALSE,
                &tmMaxWait
                );

        TRACE(TL_STRM_ERROR,("**WorkItem completed! StatusWait:%x; pAVStrmExt:%x; AQD [%d:%d:%d]\n",
            StatusWait, pAVCStrmExt,
            pAVCStrmExt->pAVCStrmDataStruc->cntDataAttached,
            pAVCStrmExt->pAVCStrmDataStruc->cntDataQueued,
            pAVCStrmExt->pAVCStrmDataStruc->cntDataDetached
            ));

        ASSERT(StatusWait == STATUS_SUCCESS);
    }

    return Status;
}


NTSTATUS
AVCStreamSurpriseRemoval(
    IN struct DEVICE_EXTENSION * pDevExt  
    )
/*++

Routine Description:

    This routine is called when this device is being surprise removed 
    with IRP_MN_SURPRISE_REMOVAL. We need to clean up and cancel any 
    pending request before passing irp down to lower driver.

Arguments:

    pDevExt -
        This driver's extension.

Return Value:

    Status
        STATUS_SUCCESS
        STATUS_INVALID_PARAMETER

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG i;    

    for (i=0; i < pDevExt->NumberOfStreams; i++) {
        if(pDevExt->pAVCStrmExt[i]) {
            if(pDevExt->pAVCStrmExt[i]->lAbortToken == 1) {
                PAVC_STREAM_EXTENSION  pAVCStrmExt = pDevExt->pAVCStrmExt[i];
#if DBG
                ULONGLONG tmStart = GetSystemTime();
#endif
                KeWaitForSingleObject( 
                    &pAVCStrmExt->hAbortDoneEvent,
                    Executive,
                    KernelMode,
                    FALSE,
                    NULL
                    );         
                TRACE(TL_PNP_WARNING,("** Waited %d for AbortStream to complete\n", (DWORD) (GetSystemTime() - tmStart) ));                    
            } 

            //
            // Since we are already removed, go ahead and break the connection.
            //
            AVCStrmBreakConnection(pDevExt->physicalDevObj, pDevExt->pAVCStrmExt[i]);
        }
    }

    return Status;
}

NTSTATUS
AVCStrmValidateStreamRequest(
    struct DEVICE_EXTENSION *pDevExt,
    PAVC_STREAM_REQUEST_BLOCK pAVCStrmReqBlk
    )
/*++

Routine Description:

    Validate the StreamIndex of an AVC Stream Extension according to a AVC Stream function.

Arguments:

    pDevExt -
        This driver's extension.

    pAVCStrmReqBlk -
        AVC Stream reuqest block.

Return Value:

    Status
        STATUS_SUCCESS
        STATUS_INVALID_PARAMETER

--*/
{
    NTSTATUS Status;
    
    PAGED_CODE();
    ENTER("AVCStrmValidateStreamRequest");
    
    Status = STATUS_SUCCESS;

    // Validate pointer
    if(!pAVCStrmReqBlk)
        return STATUS_INVALID_PARAMETER;  

    // Validate block size
    if(pAVCStrmReqBlk->SizeOfThisBlock != sizeof(AVC_STREAM_REQUEST_BLOCK))
        return STATUS_INVALID_PARAMETER;
    
#if 0
    // Validate version supported
    if(   pAVCStrmReqBlk->Version != '15TN' 
       && pAVCStrmReqBlk->Version != ' 8XD'
       )
        return STATUS_INVALID_PARAMETER;
#endif

    if(pAVCStrmReqBlk->Function == AVCSTRM_OPEN) {
        if(pDevExt->NumberOfStreams >= MAX_STREAMS_PER_DEVICE) {
            ASSERT(pDevExt->NumberOfStreams < MAX_STREAMS_PER_DEVICE && "AVCStreamOpen: Too many stream open!\n");
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    } else {
        if(pAVCStrmReqBlk->AVCStreamContext == NULL) {
            ASSERT(pAVCStrmReqBlk->AVCStreamContext != NULL && "Invalid pAVCStrmExt\n");
            return STATUS_INVALID_PARAMETER;    
        }

        // To be more robust, we may need to make sure this is 
        // one of the cached stream extension created by us.
        // ......
    }

    return Status;
}

NTSTATUS
AvcStrm_IoControl(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    struct DEVICE_EXTENSION *pDevExt;
    PIO_STACK_LOCATION irpSp;
    BOOLEAN passIrpDown = TRUE;
    NTSTATUS Status;
    PAVC_STREAM_REQUEST_BLOCK pAvcStrmIrb;

    PAGED_CODE();
    ENTER("AvcStrm_IoControl");


    Status = STATUS_SUCCESS;
    pDevExt = DeviceObject->DeviceExtension;
    ASSERT(pDevExt->signature == DEVICE_EXTENSION_SIGNATURE);

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    pAvcStrmIrb = irpSp->Parameters.Others.Argument1;

    // Validate the stream context
    if(!NT_SUCCESS(Status = 
        AVCStrmValidateStreamRequest(
            pDevExt, 
            pAvcStrmIrb))) {

        goto DoneIoControl;
    }

    switch(pAvcStrmIrb->Function) {
    case AVCSTRM_OPEN:
        Status = AVCStreamOpen(
            Irp,
            pDevExt,
            &pAvcStrmIrb->CommandData.OpenStruct
            );
        break;
    case AVCSTRM_CLOSE:
        Status = AVCStreamClose(
            Irp,
            pDevExt,
            (PAVC_STREAM_EXTENSION) pAvcStrmIrb->AVCStreamContext
            );
         break;


    case AVCSTRM_GET_STATE:
        Status = AVCStreamControlGetState(
            Irp,
            pDevExt,
            (PAVC_STREAM_EXTENSION) pAvcStrmIrb->AVCStreamContext,
            &pAvcStrmIrb->CommandData.StreamState
            );
         break;
    case AVCSTRM_SET_STATE:
        Status = AVCStreamControlSetState(
            Irp,
            pDevExt,
            (PAVC_STREAM_EXTENSION) pAvcStrmIrb->AVCStreamContext,
            pAvcStrmIrb->CommandData.StreamState
            );
         break;

#if 0  // Later...
    case AVCSTRM_GET_PROPERTY:
        Status = AVCStreamControlGetProperty(
            Irp,
            pDevExt,
            (PAVC_STREAM_EXTENSION) pAvcStrmIrb->AVCStreamContext,
            pAvcStrmIrb->CommandData.PropertyDescriptor
            );
         break;
    case AVCSTRM_SET_PROPERTY:
        Status = AVCStreamControlSetProperty(
            Irp,
            pDevExt,
            (PAVC_STREAM_EXTENSION) pAvcStrmIrb->AVCStreamContext,
            pAvcStrmIrb->CommandData.PropertyDescriptor
            );
         break;
#endif

    case AVCSTRM_READ:
        // Mutex with Cancel or setting to stop state.
        KeWaitForMutexObject(&((PAVC_STREAM_EXTENSION) pAvcStrmIrb->AVCStreamContext)->hMutexControl, Executive, KernelMode, FALSE, NULL);
        Status = AVCStreamRead(
            Irp,
            pDevExt,
            (PAVC_STREAM_EXTENSION) pAvcStrmIrb->AVCStreamContext,
            &pAvcStrmIrb->CommandData.BufferStruct
            );
        KeReleaseMutex(&((PAVC_STREAM_EXTENSION) pAvcStrmIrb->AVCStreamContext)->hMutexControl, FALSE);
        return Status;
        break;
    case AVCSTRM_WRITE:
        KeWaitForMutexObject(&((PAVC_STREAM_EXTENSION) pAvcStrmIrb->AVCStreamContext)->hMutexControl, Executive, KernelMode, FALSE, NULL);
        Status = AVCStreamWrite(
            Irp,
            pDevExt,
            (PAVC_STREAM_EXTENSION) pAvcStrmIrb->AVCStreamContext,
            &pAvcStrmIrb->CommandData.BufferStruct
            );
        KeReleaseMutex(&((PAVC_STREAM_EXTENSION) pAvcStrmIrb->AVCStreamContext)->hMutexControl, FALSE);
        return Status;
        break;


    case AVCSTRM_ABORT_STREAMING:
        Status = AVCStreamAbortStreaming(
            Irp,
            pDevExt,
            (PAVC_STREAM_EXTENSION) pAvcStrmIrb->AVCStreamContext
            );
        break;


    default:
        Status = STATUS_INVALID_PARAMETER;
        break;
    }

DoneIoControl:

#if DBG
    if(!NT_SUCCESS(Status)) {
        TRACE(TL_PNP_WARNING,("Av_IoControl return Status:%x\n", Status));
    }
#endif

    if (Status == STATUS_PENDING) {
        TRACE(TL_PNP_TRACE,("Av_IoControl: returning STATUS_PENDING."));
        IoMarkIrpPending(Irp);        
    } else {
        Irp->IoStatus.Status = Status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\avcstrm\pnp.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    pnp.c

Abstract: NULL filter driver -- boilerplate code

Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/

#include <WDM.H>

#include "filter.h"

#ifdef ALLOC_PRAGMA
        #pragma alloc_text(PAGE, VA_PnP)
        #pragma alloc_text(PAGE, GetDeviceCapabilities)
        #ifdef HANDLE_DEVICE_USAGE
            #pragma alloc_text(PAGE, VA_DeviceUsageNotification)
        #endif // HANDLE_DEVICE_USAGE
#endif

            
NTSTATUS VA_PnP(struct DEVICE_EXTENSION *devExt, PIRP irp)
/*++

Routine Description:

    Dispatch routine for PnP IRPs (MajorFunction == IRP_MJ_PNP)

Arguments:

    devExt - device extension for the targetted device object
    irp - IO Request Packet

Return Value:

    NT status code

--*/
{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status = STATUS_SUCCESS;
    BOOLEAN completeIrpHere = FALSE;
    BOOLEAN justReturnStatus = FALSE;

    PAGED_CODE();

    irpSp = IoGetCurrentIrpStackLocation(irp);

    TRACE(TL_PNP_TRACE,("VA_PnP, minorFunc = %d \n", (ULONG)irpSp->MinorFunction)); 

    switch (irpSp->MinorFunction){

    case IRP_MN_START_DEVICE:
        TRACE(TL_PNP_WARNING,("START_DEVICE\n")); 

        devExt->state = STATE_STARTING;

        /*
         *  First, send the START_DEVICE irp down the stack
         *  synchronously to start the lower stack.
         *  We cannot do anything with our device object
         *  before propagating the START_DEVICE this way.
         */
        IoCopyCurrentIrpStackLocationToNext(irp);
        status = CallNextDriverSync(devExt, irp);

        if (NT_SUCCESS(status)){
            /*
             *  Now that the lower stack is started,
             *  do any initialization required by this device object.
             */
            status = GetDeviceCapabilities(devExt);
            if (NT_SUCCESS(status)){
                devExt->state = STATE_STARTED;
            }
            else {
                devExt->state = STATE_START_FAILED;
            }
        }
        else {
            devExt->state = STATE_START_FAILED;
        }
        completeIrpHere = TRUE;
        break;

    case IRP_MN_QUERY_STOP_DEVICE:
    case IRP_MN_QUERY_REMOVE_DEVICE:
        TRACE(TL_PNP_WARNING,("QUERY_STOP_DEVICE (%d)or QUERY_REMOVE_DEVICE(%d)\n", IRP_MN_QUERY_STOP_DEVICE, IRP_MN_QUERY_REMOVE_DEVICE)); 
#ifdef HANDLE_DEVICE_USAGE
        //
        // Need to fail these IRPs if a paging, hibernation, or crashdump
        // file is currently open on this device
        //
        if(    devExt->pagingFileCount      != 0
            || devExt->hibernationFileCount != 0
            || devExt->crashdumpFileCount   != 0 )
        {
            // Fail the IRP
            TRACE(TL_PNP_WARNING,("Failing QUERY_(STOP,REMOVE)_DEVICE request b/c \n"
                     "paging, hiber, or crashdump file is present on device." ));
            status = STATUS_UNSUCCESSFUL;
            completeIrpHere = TRUE;
        }
        else
        {
            // We'll just pass this IRP down the driver stack.  But
            // first, must change the IRP's status to STATUS_SUCCESS
            // (default is STATUS_NOT_SUPPORTED)
            irp->IoStatus.Status = STATUS_SUCCESS;
        }
#else
        /*
         *  We will pass this IRP down the driver stack.
         *  However, we need to change the default status
         *  from STATUS_NOT_SUPPORTED to STATUS_SUCCESS.
         */
        irp->IoStatus.Status = STATUS_SUCCESS;
#endif

        break;

    case IRP_MN_STOP_DEVICE:
        TRACE(TL_PNP_WARNING,("STOP_DEVICE\n")); 
        if (devExt->state == STATE_SUSPENDED){
            status = STATUS_DEVICE_POWER_FAILURE;
            completeIrpHere = TRUE;
        }
        else {
            /*
             *  Only set state to STOPPED if the device was
             *  previously started successfully.
             */
            if (devExt->state == STATE_STARTED){
                devExt->state = STATE_STOPPED;
            }
        }
        break;
  

    case IRP_MN_SURPRISE_REMOVAL:  // Win2000 code base only
        TRACE(TL_PNP_WARNING,("SURPRISE_REMOVAL\n")); 

        /*
         *  We will pass this IRP down the driver stack.
         *  However, we need to change the default status
         *  from STATUS_NOT_SUPPORTED to STATUS_SUCCESS.
         */
        irp->IoStatus.Status = STATUS_SUCCESS;

        /*
         *  For now just set the STATE_REMOVING state so that
         *  we don't do any more IO.  We are guaranteed to get
         *  IRP_MN_REMOVE_DEVICE soon; we'll do the rest of
         *  the remove processing there.
         */

        devExt->state = STATE_REMOVING;

        /*
         * Clean up and make sure to cancel pending request
         */

        AVCStreamSurpriseRemoval(devExt);


        break;

    case IRP_MN_REMOVE_DEVICE:
        /*
         *  Check the current state to guard against multiple
         *  REMOVE_DEVICE IRPs.
         */
        TRACE(TL_PNP_WARNING,("REMOVE_DEVICE\n")); 
        if (devExt->state != STATE_REMOVED){

            devExt->state = STATE_REMOVED;

            /*
             * Clean up and make sure to cancel pending request
             * Note: there is no IRP_MN_SURPRISE_REMOVAL for Win9X
             */

            AVCStreamSurpriseRemoval(devExt);


            /*
             *  Send the REMOVE IRP down the stack asynchronously.
             *  Do not synchronize sending down the REMOVE_DEVICE
             *  IRP, because the REMOVE_DEVICE IRP must be sent
             *  down and completed all the way back up to the sender
             *  before we continue.
             */
            IoCopyCurrentIrpStackLocationToNext(irp);
            status = IoCallDriver(devExt->topDevObj, irp);
            justReturnStatus = TRUE;

            TRACE(TL_PNP_WARNING,("REMOVE_DEVICE - waiting for %d irps to complete...\n",
                    devExt->pendingActionCount));  

            /*
             *  We must for all outstanding IO to complete before
             *  completing the REMOVE_DEVICE IRP.
             *
             *  First do an extra decrement on the pendingActionCount.
             *  This will cause pendingActionCount to eventually
             *  go to -1 once all asynchronous actions on this
             *  device object are complete.
             *  Then wait on the event that gets set when the
             *  pendingActionCount actually reaches -1.
             */
            DecrementPendingActionCount(devExt);
            KeWaitForSingleObject(  &devExt->removeEvent,
                                    Executive,      // wait reason
                                    KernelMode,
                                    FALSE,          // not alertable
                                    NULL );         // no timeout

            TRACE(TL_PNP_WARNING,("REMOVE_DEVICE - ... DONE waiting. \n")); 

#ifdef HANDLE_DEVICE_USAGE
            /*
             *  If we locked-down certain paged code sections earlier
             *  because of this device, then need to unlock them now
             *  (before calling IoDeleteDevice)
             */
            if( NULL != devExt->pagingPathUnlockHandle )
            {
                TRACE(TL_PNP_WARNING,("UNLOCKing some driver code (non-pageable) (b/c paging path)\n" ));
                MmUnlockPagableImageSection( devExt->pagingPathUnlockHandle );
                devExt->pagingPathUnlockHandle = NULL;
            }

            if( NULL != devExt->initUnlockHandle )
            {
                TRACE(TL_PNP_WARNING,("UNLOCKing some driver code (non-pageable) (b/c init conditions)\n" ));
                MmUnlockPagableImageSection( devExt->initUnlockHandle );
                devExt->initUnlockHandle = NULL;
            }
#endif // HANDLE_DEVICE_USAGE

            /*
             *  Detach our device object from the lower 
             *  device object stack.
             */
            IoDetachDevice(devExt->topDevObj);

            /*
             *  Delete our device object.
             *  This will also delete the associated device extension.
             */
            IoDeleteDevice(devExt->filterDevObj);
        }
        break;

#ifdef HANDLE_DEVICE_USAGE
    case IRP_MN_DEVICE_USAGE_NOTIFICATION:


        //
        // Make sure the Type of this UsageNotification is one that we handle
        //
        if(    irpSp->Parameters.UsageNotification.Type != DeviceUsageTypePaging
            && irpSp->Parameters.UsageNotification.Type != DeviceUsageTypeHibernation
            && irpSp->Parameters.UsageNotification.Type != DeviceUsageTypeDumpFile )
        {
            break; // out of the big switch statement (and just forward this IRP)
        }

        status = VA_DeviceUsageNotification(devExt, irp);
        justReturnStatus = TRUE;
        break;
#endif // HANDLE_DEVICE_USAGE

#ifdef HANDLE_DEVICE_USAGE
    case IRP_MN_QUERY_PNP_DEVICE_STATE:
        //
        // If a paging, hibernation, or crashdump file is currently open
        // on this device, must set NOT_DISABLEABLE flag in DeviceState
        //
        if(    devExt->pagingFileCount      != 0
            || devExt->hibernationFileCount != 0
            || devExt->crashdumpFileCount   != 0  )
        {
            // Mark the device as not disableable
            PPNP_DEVICE_STATE pDeviceState;
            pDeviceState = (PPNP_DEVICE_STATE) &irp->IoStatus.Information;
            *pDeviceState |= PNP_DEVICE_NOT_DISABLEABLE;
        }

        //
        // We _did_ handle this IRP (as best we could), so set IRP's
        // status to STATUS_SUCCESS (default is STATUS_NOT_SUPPORTED)
        // before passing it down the driver stack
        //
        irp->IoStatus.Status = STATUS_SUCCESS;

        break;
#endif // HANDLE_DEVICE_USAGE

    case IRP_MN_QUERY_DEVICE_RELATIONS:
        TRACE(TL_PNP_WARNING,("QUERY_DEVICE_RELATIONS\n"));
        break;
    default:
        TRACE(TL_PNP_WARNING,("Unprocessed PnP minorFunc (%d)\n", irpSp->MinorFunction));
        break;


    }

    if (justReturnStatus){
        /*
         *  We've already sent this IRP down the stack.
         */
        TRACE(TL_PNP_WARNING,("VA_PnP: St:%x; minor:%d; Already sent down the irp.\n", status, (ULONG)irpSp->MinorFunction));
    }
    else if (completeIrpHere){
        TRACE(TL_PNP_WARNING,("VA_PnP: St:%x; minor:%d; Completed Status:%x\n", status, (ULONG)irpSp->MinorFunction, status));
        irp->IoStatus.Status = status;
        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }
    else {
        TRACE(TL_PNP_WARNING,("VA_PnP: ST:%x; minor:%d; Pass down irp:%x; devObj:%x\n", status, (ULONG)irpSp->MinorFunction, irp, devExt->topDevObj));
        IoCopyCurrentIrpStackLocationToNext(irp);
        status = IoCallDriver(devExt->topDevObj, irp);
    }

    EXIT("VA_PnP",status);

    return status;
}

#ifdef HANDLE_DEVICE_USAGE
NTSTATUS
VA_DeviceUsageNotification(struct DEVICE_EXTENSION *devExt, PIRP irp)
{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;
    BOOLEAN fSetPagable = FALSE;  // whether we set the PAGABLE bit
                                  /// before we passed-on this IRP

    PAGED_CODE();

    irpSp = IoGetCurrentIrpStackLocation(irp);

    TRACE(TL_PNP_WARNING,("DEVICE_USAGE_NOTIFICATION (Type==%d , InPath==%d)\n"
             , irpSp->Parameters.UsageNotification.Type
             , irpSp->Parameters.UsageNotification.InPath
          ));
    TRACE(TL_PNP_WARNING,("    [devExt=0x%08X fltrDevObj=0x%08X]\n", devExt, devExt->filterDevObj ));

    //
    // Wait on the paging path event (to prevent several instances of
    // this IRP from being processed at once)
    //
    status = KeWaitForSingleObject( &devExt->deviceUsageNotificationEvent
                                    , Executive    // wait reason
                                    , KernelMode
                                    , FALSE        // not alertable
                                    , NULL         // no timeout
                                  );


    /*
     * IMPORTANT NOTE: When to modify our DO_POWER_PAGABLE bit depends
     * on whether it needs to be set or cleared.  If the IRP indicates
     * our PAGABLE bit should be set, then we must set it _before_
     * forwarding the IRP down the driver stack (and possibly clear it
     * afterward, if lower drivers fail the IRP).  But if the IRP
     * indicates that our PAGABLE bit should be cleared, then we must
     * first forward the IRP to lower drivers, and then clear our bit
     * only if the lower drivers return STATUS_SUCCESS.
     */

    //
    // If removing last paging file from this device...
    //
    if(    irpSp->Parameters.UsageNotification.Type == DeviceUsageTypePaging
        && !irpSp->Parameters.UsageNotification.InPath
        && devExt->pagingFileCount == 1       )
    {
        //
        // Set DO_POWER_PAGABLE bit (if it was set at startup).
        // If lower drivers fail this IRP, we'll clear it later.
        //
        TRACE(TL_PNP_WARNING,("Removing last paging file...\n" ));

        if( devExt->initialFlags & DO_POWER_PAGABLE )
        {
            TRACE(TL_PNP_WARNING,( "...so RE-setting PAGABLE bit\n" ));
            devExt->filterDevObj->Flags |= DO_POWER_PAGABLE;
            fSetPagable = TRUE;
        }
        else
        {
            TRACE(TL_PNP_WARNING,( "...but PAGABLE bit wasn't set initially, so not setting it now.\n" ));
        }

    }


    //
    // Forward the irp synchronously
    //
    IoCopyCurrentIrpStackLocationToNext( irp );
    status = CallNextDriverSync( devExt, irp );


    //
    // Now deal with the failure and success cases.
    //
    if( ! NT_SUCCESS(status) )
    {
        //
        // Lower drivers failed the IRP, so _undo_ any changes we
        // made before passing-on the IRP to those drivers.
        //
        if( fSetPagable )
        {
            TRACE(TL_PNP_WARNING,("IRP was failed, so UN-setting PAGABLE bit\n" ));
            devExt->filterDevObj->Flags &= ~DO_POWER_PAGABLE;
        }
    }
    else
    {
        //
        // Lower drivers returned SUCCESS, so we can do everything
        // that must be done in response to this IRP...
        //

        switch( irpSp->Parameters.UsageNotification.Type )
        {
        case DeviceUsageTypeHibernation:

            // Adjust counter
            IoAdjustPagingPathCount( &devExt->hibernationFileCount,
                                     irpSp->Parameters.UsageNotification.InPath );
            TRACE(TL_PNP_WARNING,("Num. Hibernation files is now %d\n", devExt->hibernationFileCount ));
            ASSERT( devExt->hibernationFileCount >= 0 );
            break;

        case DeviceUsageTypeDumpFile:
            
            // Adjust counter
            IoAdjustPagingPathCount( &devExt->crashdumpFileCount,
                                     irpSp->Parameters.UsageNotification.InPath );
            TRACE(TL_PNP_WARNING,("Num. Crashdump files is now %d\n", devExt->crashdumpFileCount ));
            ASSERT( devExt->crashdumpFileCount >= 0 );
            break;

        case DeviceUsageTypePaging:
            
            // Adjust counter
            IoAdjustPagingPathCount( &devExt->pagingFileCount,
                                     irpSp->Parameters.UsageNotification.InPath );
            TRACE(TL_PNP_WARNING,("Num. Paging files is now %d\n", devExt->pagingFileCount ));
            ASSERT( devExt->pagingFileCount >= 0 );

            //
            // If we've just switched between being pageable<->nonpageable...
            //
            if(    irpSp->Parameters.UsageNotification.InPath
                && devExt->pagingFileCount == 1  )
            {
                //
                // Just added a paging file, so clear the PAGABLE
                // flag, and lock-down the code for all routines
                // that could be called at IRQL >= DISPATCH_LEVEL
                // (so that they're _non-pageable_).
                //
                TRACE(TL_PNP_WARNING,("Just added first paging file...\n" ));
                TRACE(TL_PNP_WARNING,("...so clearing PAGABLE bit\n" ));
                devExt->filterDevObj->Flags &= ~DO_POWER_PAGABLE;

                TRACE(TL_PNP_WARNING,("LOCKing some driver code (non-pageable) (b/c paging path)\n" ));
                devExt->pagingPathUnlockHandle = MmLockPagableCodeSection( VA_Power );  // some func that's inside the code section that we want to lock
                ASSERT( NULL != devExt->pagingPathUnlockHandle );
            }
            else if (    !irpSp->Parameters.UsageNotification.InPath
                      && devExt->pagingFileCount == 0  )
            {
                //
                // Just removed the last paging file, but we
                // already set the PAGABLE flag (if necessary)
                // before forwarding IRP, so just remove the
                // _paging-path_ lock from this driver. (NOTE:
                // initial-condition lock might still be in place,
                // but that's what we want.)
                //
                TRACE(TL_PNP_WARNING,("UNLOCKing some driver code (pageable) (b/c paging path)\n" ));
                ASSERT( NULL != devExt->pagingPathUnlockHandle );
                MmUnlockPagableImageSection( devExt->pagingPathUnlockHandle );
                devExt->pagingPathUnlockHandle = NULL;
            }
            break;

        default:
            ASSERT( FALSE );  // should never get here (b/c checked for invalid Type earlier)

        } //END: switch on Type of special-file


        //
        // Invalidate state, so that certain flags will get updated
        //
        IoInvalidateDeviceState( devExt->physicalDevObj );

    }//END: handling of irp success/failure cases


    //
    // Set event so that the next DEVICE_USAGE_NOTIFICATION IRP that
    // comes along can be processed.
    //
    KeSetEvent( &devExt->deviceUsageNotificationEvent
                , IO_NO_INCREMENT
                , FALSE
              );

    //
    // Complete the irp
    //
    IoCompleteRequest( irp, IO_NO_INCREMENT );
    return status;
}
#endif // HANDLE_DEVICE_USAGE



NTSTATUS GetDeviceCapabilities(struct DEVICE_EXTENSION *devExt)
/*++

Routine Description:

    Function retrieves the DEVICE_CAPABILITIES descriptor from the device

Arguments:

    devExt - device extension for targetted device object

Return Value:

    NT status code

--*/
{
    NTSTATUS status;
    PIRP irp;

    PAGED_CODE();

    irp = IoAllocateIrp(devExt->topDevObj->StackSize, FALSE);
    if (irp){
        PIO_STACK_LOCATION nextSp = IoGetNextIrpStackLocation(irp);

        // must initialize DeviceCapabilities before sending...
        RtlZeroMemory(  &devExt->deviceCapabilities, 
                        sizeof(DEVICE_CAPABILITIES));
        devExt->deviceCapabilities.Size = sizeof(DEVICE_CAPABILITIES);
        devExt->deviceCapabilities.Version = 1;
        devExt->deviceCapabilities.Address = -1;
        devExt->deviceCapabilities.UINumber= -1;


        // setup irp stack location...
        nextSp->MajorFunction = IRP_MJ_PNP;
        nextSp->MinorFunction = IRP_MN_QUERY_CAPABILITIES;
        nextSp->Parameters.DeviceCapabilities.Capabilities = 
                        &devExt->deviceCapabilities;

        /*
         *  For any IRP you create, you must set the default status
         *  to STATUS_NOT_SUPPORTED before sending it.
         */
        irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

        status = CallNextDriverSync(devExt, irp);

        IoFreeIrp(irp);
    }
    else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    ASSERT(NT_SUCCESS(status));
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\avcstrm\util.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    util.c

Abstract: NULL filter driver -- boilerplate code

Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/

#include <WDM.H>

#include "filter.h"


#ifdef ALLOC_PRAGMA
        #pragma alloc_text(PAGE, CallNextDriverSync)
        #pragma alloc_text(PAGE, CallDriverSync)
        #pragma alloc_text(PAGE, QueryDeviceKey)
        #pragma alloc_text(PAGE, RegistryAccessSample)
#endif


NTSTATUS CallNextDriverSync(struct DEVICE_EXTENSION *devExt, PIRP irp)
/*++

Routine Description:

        Pass the IRP down to the next device object in the stack
        synchronously, and bump the pendingActionCount around
        the call to prevent the current device object from getting
        removed before the IRP completes.

Arguments:

    devExt - device extension of one of our device objects
    irp - Io Request Packet

Return Value:

    NT status code, indicates result returned by lower driver for this IRP.

--*/
{
    NTSTATUS status;

    PAGED_CODE();

    IncrementPendingActionCount(devExt);
    status = CallDriverSync(devExt->topDevObj, irp);
    DecrementPendingActionCount(devExt);

    return status;
}



NTSTATUS CallDriverSync(PDEVICE_OBJECT devObj, PIRP irp)
/*++

Routine Description:

      Call IoCallDriver to send the irp to the device object;
      then, synchronize with the completion routine.
      When CallDriverSync returns, the action has completed
      and the irp again belongs to the current driver.

      NOTE:  In order to keep the device object from getting freed
             while this IRP is pending, you should call
             IncrementPendingActionCount() and 
             DecrementPendingActionCount()
             around the CallDriverSync call.

Arguments:

    devObj - targetted device object
    irp - Io Request Packet

Return Value:

    NT status code, indicates result returned by lower driver for this IRP.

--*/
{
    KEVENT event;
    NTSTATUS status;

    PAGED_CODE();

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    IoSetCompletionRoutine( irp, 
                            CallDriverSyncCompletion, 
                            &event,     // context
                            TRUE, TRUE, TRUE);

    status = IoCallDriver(devObj, irp);

    KeWaitForSingleObject(  &event,
                            Executive,      // wait reason
                            KernelMode,
                            FALSE,          // not alertable
                            NULL );         // no timeout

    status = irp->IoStatus.Status;

    ASSERT(NT_SUCCESS(status));

    return status;
}


NTSTATUS CallDriverSyncCompletion(
                                    IN PDEVICE_OBJECT devObjOrNULL, 
                                    IN PIRP irp, 
                                    IN PVOID context)
/*++

Routine Description:

      Completion routine for CallDriverSync.

Arguments:

    devObjOrNULL - 
            Usually, this is this driver's device object.
             However, if this driver created the IRP, 
             there is no stack location in the IRP for this driver;
             so the kernel has no place to store the device object;
             ** so devObj will be NULL in this case **.

    irp - completed Io Request Packet
    context - context passed to IoSetCompletionRoutine by CallDriverSync. 

    
Return Value:

    NT status code, indicates result returned by lower driver for this IRP.

--*/
{
    PKEVENT event = context;

    ASSERT(irp->IoStatus.Status != STATUS_IO_TIMEOUT);

    KeSetEvent(event, 0, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}



VOID IncrementPendingActionCount(struct DEVICE_EXTENSION *devExt)
/*++

Routine Description:

      Increment the pendingActionCount for a device object.
      This keeps the device object from getting freed before
      the action is completed.

Arguments:

    devExt - device extension of device object

Return Value:

    VOID

--*/
{
    ASSERT(devExt->pendingActionCount >= 0);
    InterlockedIncrement(&devExt->pendingActionCount);    
}



VOID DecrementPendingActionCount(struct DEVICE_EXTENSION *devExt)
/*++

Routine Description:

      Decrement the pendingActionCount for a device object.
      This is called when an asynchronous action is completed
      AND ALSO when we get the REMOVE_DEVICE IRP.
      If the pendingActionCount goes to -1, that means that all
      actions are completed and we've gotten the REMOVE_DEVICE IRP;
      in this case, set the removeEvent event so we can finish
      unloading.

Arguments:

    devExt - device extension of device object

Return Value:

    VOID

--*/
{
    ASSERT(devExt->pendingActionCount >= 0);
    InterlockedDecrement(&devExt->pendingActionCount);    

    if (devExt->pendingActionCount < 0){
        /*
         *  All pending actions have completed and we've gotten
         *  the REMOVE_DEVICE IRP.
         *  Set the removeEvent so we'll stop waiting on REMOVE_DEVICE.
         */
        ASSERT((devExt->state == STATE_REMOVING) || 
               (devExt->state == STATE_REMOVED));
        KeSetEvent(&devExt->removeEvent, 0, FALSE);
    }
}


NTSTATUS
QueryDeviceKey (
    IN  HANDLE  Handle,
    IN  PWCHAR  ValueNameString,
    OUT PVOID   Data,
    IN  ULONG   DataLength
    )
/*++

Routine Description:

    Retrieve the data associated with a specified registry value.

Arguments:

    Handle - handle of key for which value entry is to be read
    ValueNameString - name of value whose data is to be retrieved
    Data - buffer to receive the data
    DataLength - length of data buffer

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS        status;
    UNICODE_STRING  valueName;
    ULONG           length;
    PKEY_VALUE_FULL_INFORMATION fullInfo;

    PAGED_CODE();

    RtlInitUnicodeString (&valueName, ValueNameString);

    length = sizeof (KEY_VALUE_FULL_INFORMATION)
           + valueName.MaximumLength
           + DataLength;

    fullInfo = ExAllocatePool (PagedPool, length);

    if (fullInfo) {
        status = ZwQueryValueKey (Handle,
                                  &valueName,
                                  KeyValueFullInformation,
                                  fullInfo,
                                  length,
                                  &length);

        if (NT_SUCCESS (status)) {
            ASSERT (DataLength == fullInfo->DataLength);
            RtlCopyMemory (Data,
                           ((PUCHAR) fullInfo) + fullInfo->DataOffset,
                           fullInfo->DataLength);
        }

        ExFreePool (fullInfo);
    } else {
        status = STATUS_NO_MEMORY;
    }

    return status;
}


VOID RegistryAccessSample(struct DEVICE_EXTENSION *devExt,
                          PDEVICE_OBJECT devObj)
/*++

Routine Description:

    SAMPLE showing how to access the device-specific registry key 

Arguments:

    devExt - device extension (for our _filter_ device object)
    devObj - device object pointer
             NOTE: This must not be the functional device object
                   created by this filter driver, because that
                   device object does not have a devnode area
                   in the registry; pass the device object of
                   the device object for which this driver is
                   a filter.  This is the device object passed
                   to VA_AddDevice.

Return Value:

    VOID

--*/
{
    NTSTATUS status;
    HANDLE hRegDevice;

    PAGED_CODE();

    status = IoOpenDeviceRegistryKey(   devObj, 
                                        PLUGPLAY_REGKEY_DEVICE, 
                                        KEY_READ, 
                                        &hRegDevice);

    if (NT_SUCCESS(status)){
        ULONG value, otherValue;

        if (NT_SUCCESS(QueryDeviceKey( hRegDevice,
                                       L"SampleFilterParam",
                                       &value,
                                       sizeof(value)))) {
            //
            // Perform whatever operation is necessary 
            //
        }

        if (NT_SUCCESS(QueryDeviceKey( hRegDevice,
                                       L"SampleFilterParam2",
                                       &otherValue,
                                       sizeof(otherValue)))) {
            //
            // Perform whatever operation is necessary 
            //
        }

        ZwClose(hRegDevice);
    }
    else {
        TRACE(TL_PNP_ERROR,("IoOpenDeviceRegistryKey failed with %xh.", status));
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\capture\mini\avcstrm\avcutil.c ===
/*++

Copyright (C) 1999  Microsoft Corporation

Module Name: 

    avcutil.c

Abstract

    MS AVC streaming utility functions

Author:

    Yee Wu    03/17/2000

Revision    History:
Date        Who         What
----------- --------- ------------------------------------------------------------
03/17/2000  YJW         created
--*/

 
#include "filter.h"
#include "ksmedia.h" // KSPROERTY_DROPPEDFRAMES_CURRENT


/************************************
 * Synchronous IOCall to lower driver
 ************************************/

NTSTATUS
IrpSynchCR(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp,
    IN PKEVENT         