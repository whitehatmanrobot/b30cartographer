stError() returned 0x%08x.  This is an error.  FaxSendDocument() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_HANDLE);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
		fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
    }
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;
    fnWriteLogFile(TEXT("szDocument = NULL.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"szDocument = NULL\" id=\"%d\">"), *pnNumCasesAttempted);

    if (g_ApiInterface.FaxSendDocument(hFaxSvcHandle, NULL, &FaxJobParam, NULL, &dwFaxId)) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxSendDocument() returned TRUE.  This is an error.  FaxSendDocument() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).</result>\r\n"), ERROR_INVALID_PARAMETER);
        g_ApiInterface.FaxAbort(hFaxSvcHandle, dwFaxId);
    }
    else if (GetLastError() != ERROR_INVALID_PARAMETER) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">GetLastError() returned 0x%08x.  This is an error.  FaxSendDocument() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
		fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
    }
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;
    fnWriteLogFile(TEXT("pFaxJobParam = NULL.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"pFaxJobParam = NULL\" id=\"%d\">"), *pnNumCasesAttempted);

    if (g_ApiInterface.FaxSendDocument(hFaxSvcHandle, TEXT("fax.tif"), NULL, NULL, &dwFaxId)) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxSendDocument() returned TRUE.  This is an error.  FaxSendDocument() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).</result>\r\n"), ERROR_INVALID_PARAMETER);
        g_ApiInterface.FaxAbort(hFaxSvcHandle, dwFaxId);
    }
    else if (GetLastError() != ERROR_INVALID_PARAMETER) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">GetLastError() returned 0x%08x.  This is an error.  FaxSendDocument() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
		fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
    }
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;
    fnWriteLogFile(TEXT("Invalid document.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"Invalid document\" id=\"%d\">"), *pnNumCasesAttempted);

    if (g_ApiInterface.FaxSendDocument(hFaxSvcHandle, TEXT("InvalidDocumentName"), &FaxJobParam, NULL, &dwFaxId)) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxSendDocument() returned TRUE.  This is an error.  FaxSendDocument() should return FALSE and GetLastError() should return ERROR_FILE_NOT_FOUND (0x%08x).</result>\r\n"), ERROR_FILE_NOT_FOUND);
        g_ApiInterface.FaxAbort(hFaxSvcHandle, dwFaxId);
    }
    else if (GetLastError() != ERROR_FILE_NOT_FOUND) {
        fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxSendDocument() should return FALSE and GetLastError() should return ERROR_FILE_NOT_FOUND (0x%08x).\r\n"), GetLastError(), ERROR_FILE_NOT_FOUND);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
		fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
    }
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;
    fnWriteLogFile(TEXT("Invalid document type (.bad).  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"Invalid document type (.bad)\" id=\"%d\">"), *pnNumCasesAttempted);

    if (g_ApiInterface.FaxSendDocument(hFaxSvcHandle, TEXT("printapi.bad"), &FaxJobParam, NULL, &dwFaxId)) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxSendDocument() returned TRUE.  This is an error.  FaxSendDocument() should return FALSE and GetLastError() should return ERROR_INVALID_DATA (0x%08x).</result>\r\n"), ERROR_INVALID_DATA);
        g_ApiInterface.FaxAbort(hFaxSvcHandle, dwFaxId);
    }
    else if (GetLastError() != ERROR_INVALID_DATA) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">GetLastError() returned 0x%08x.  This is an error.  FaxSendDocument() should return FALSE and GetLastError() should return ERROR_INVALID_DATA (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_DATA);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
		fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
    }
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

    FaxJobParam.SizeOfStruct = 0;
    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;
    fnWriteLogFile(TEXT("pFaxJobParam->SizeOfStruct = 0.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"pFaxJobParam->SizeOfStruct = 0\" id=\"%d\">"), *pnNumCasesAttempted);

    if (g_ApiInterface.FaxSendDocument(hFaxSvcHandle, TEXT("fax.tif"), &FaxJobParam, NULL, &dwFaxId)) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxSendDocument() returned TRUE.  This is an error.  FaxSendDocument() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).</result>\r\n"), ERROR_INVALID_PARAMETER);
        g_ApiInterface.FaxAbort(hFaxSvcHandle, dwFaxId);
    }
    else if (GetLastError() != ERROR_INVALID_PARAMETER) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">GetLastError() returned 0x%08x.  This is an error.  FaxSendDocument() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
		fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
    }
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));
    FaxJobParam.SizeOfStruct = sizeof(FAX_JOB_PARAM);

    FaxJobParam.RecipientNumber = NULL;
    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;
    fnWriteLogFile(TEXT("pFaxJobParam->RecipientNumber = NULL.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"pFaxJobParam->RecipientNumber = NULL\" id=\"%d\">"), *pnNumCasesAttempted);

    if (g_ApiInterface.FaxSendDocument(hFaxSvcHandle, TEXT("fax.tif"), &FaxJobParam, NULL, &dwFaxId)) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxSendDocument() returned TRUE.  This is an error.  FaxSendDocument() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).</result>\r\n"), ERROR_INVALID_PARAMETER);
        g_ApiInterface.FaxAbort(hFaxSvcHandle, dwFaxId);
    }
    else if (GetLastError() != ERROR_INVALID_PARAMETER) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">GetLastError() returned 0x%08x.  This is an error.  FaxSendDocument() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
		fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
    }
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));
    FaxJobParam.RecipientNumber = g_szWhisPhoneNumber;

	fnWriteLogFile(TEXT("WHIS> Setting recipient number to %s\r\n"), g_szWhisPhoneNumber);

    FaxJobParam.ScheduleAction = -1;
    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;
    fnWriteLogFile(TEXT("pFaxJobParam->ScheduleAction = -1.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"pFaxJobParam->ScheduleAction = -1\" id=\"%d\">"), *pnNumCasesAttempted);

    if (g_ApiInterface.FaxSendDocument(hFaxSvcHandle, TEXT("fax.tif"), &FaxJobParam, NULL, &dwFaxId)) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxSendDocument() returned TRUE.  This is an error.  FaxSendDocument() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).</result>\r\n"), ERROR_INVALID_PARAMETER);
        g_ApiInterface.FaxAbort(hFaxSvcHandle, dwFaxId);
    }
    else if (GetLastError() != ERROR_INVALID_PARAMETER) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">GetLastError() returned 0x%08x.  This is an error.  FaxSendDocument() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
		fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
    }
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));
    FaxJobParam.ScheduleAction = 0;

    FaxJobParam.DeliveryReportType = -1;
    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;
    fnWriteLogFile(TEXT("pFaxJobParam->DeliveryReportType = -1.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"pFaxJobParam->DeliveryReportType = -1\" id=\"%d\">"), *pnNumCasesAttempted);

    if (g_ApiInterface.FaxSendDocument(hFaxSvcHandle, TEXT("fax.tif"), &FaxJobParam, NULL, &dwFaxId)) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxSendDocument() returned TRUE.  This is an error.  FaxSendDocument() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).</result>\r\n"), ERROR_INVALID_PARAMETER);
        g_ApiInterface.FaxAbort(hFaxSvcHandle, dwFaxId);
    }
    else if (GetLastError() != ERROR_INVALID_PARAMETER) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">GetLastError() returned 0x%08x.  This is an error.  FaxSendDocument() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
		fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
    }
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));
    FaxJobParam.DeliveryReportType = DRT_NONE;

    CoverPageInfo.SizeOfStruct = 0;
    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;
    fnWriteLogFile(TEXT("pCoverPageInfo->SizeOfStruct = 0.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"pCoverPageInfo->SizeOfStruct = 0\" id=\"%d\">"), *pnNumCasesAttempted);

    if (g_ApiInterface.FaxSendDocument(hFaxSvcHandle, TEXT("fax.tif"), &FaxJobParam, &CoverPageInfo, &dwFaxId)) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxSendDocument() returned TRUE.  This is an error.  FaxSendDocument() should return FALSE and GetLastError() should return ERROR_INVALID_DATA (0x%08x).</result>\r\n"), ERROR_INVALID_DATA);
        g_ApiInterface.FaxAbort(hFaxSvcHandle, dwFaxId);
    }
    else if (GetLastError() != ERROR_INVALID_DATA) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">GetLastError() returned 0x%08x.  This is an error.  FaxSendDocument() should return FALSE and GetLastError() should return ERROR_INVALID_DATA (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_DATA);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
		fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
    }
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));
    CoverPageInfo.SizeOfStruct = sizeof(FAX_COVERPAGE_INFO);

    CoverPageInfo.CoverPageName = NULL;
    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;
    fnWriteLogFile(TEXT("pCoverPageInfo->CoverPageName = NULL.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"pCoverPageInfo->CoverPageName = NULL\" id=\"%d\">"), *pnNumCasesAttempted);

    if (g_ApiInterface.FaxSendDocument(hFaxSvcHandle, TEXT("fax.tif"), &FaxJobParam, &CoverPageInfo, &dwFaxId)) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxSendDocument() returned TRUE.  This is an error.  FaxSendDocument() should return FALSE and GetLastError() should return ERROR_FILE_NOT_FOUND (0x%08x).</result>\r\n"), ERROR_FILE_NOT_FOUND);
        g_ApiInterface.FaxAbort(hFaxSvcHandle, dwFaxId);
    }
    else if (GetLastError() != ERROR_FILE_NOT_FOUND) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">GetLastError() returned 0x%08x.  This is an error.  FaxSendDocument() should return FALSE and GetLastError() should return ERROR_FILE_NOT_FOUND (0x%08x).</result>\r\n"), GetLastError(), ERROR_FILE_NOT_FOUND);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
		fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
    }
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

    CoverPageInfo.CoverPageName = TEXT("InvalidCoverPageName");
    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;
    fnWriteLogFile(TEXT("Invalid pCoverPageInfo->CoverPageName.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"Invalid pCoverPageInfo->CoverPageName\" id=\"%d\">"), *pnNumCasesAttempted);

    if (g_ApiInterface.FaxSendDocument(hFaxSvcHandle, TEXT("fax.tif"), &FaxJobParam, &CoverPageInfo, &dwFaxId)) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxSendDocument() returned TRUE.  This is an error.  FaxSendDocument() should return FALSE and GetLastError() should return ERROR_FILE_NOT_FOUND (0x%08x).</result>\r\n"), ERROR_FILE_NOT_FOUND);
        g_ApiInterface.FaxAbort(hFaxSvcHandle, dwFaxId);
    }
    else if (GetLastError() != ERROR_FILE_NOT_FOUND) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">GetLastError() returned 0x%08x.  This is an error.  FaxSendDocument() should return FALSE and GetLastError() should return ERROR_FILE_NOT_FOUND (0x%08x).</result>\r\n"), GetLastError(), ERROR_FILE_NOT_FOUND);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
		fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
    }
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

    pFaxConfig->PauseServerQueue = FALSE;
    g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig);
    g_ApiInterface.FaxFreeBuffer(pFaxConfig);

    // Disconnect from the fax server
    g_ApiInterface.FaxClose(hFaxSvcHandle);

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;
    fnWriteLogFile(TEXT("Invalid hFaxSvcHandle.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"Invalid hFaxSvcHandle\" id=\"%d\">"), *pnNumCasesAttempted);

    if (g_ApiInterface.FaxSendDocument(hFaxSvcHandle, TEXT("fax.tif"), &FaxJobParam, NULL, &dwFaxId)) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxSendDocument() returned TRUE.  This is an error.  FaxSendDocument() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).</result>\r\n"), ERROR_INVALID_HANDLE);
        g_ApiInterface.FaxAbort(hFaxSvcHandle, dwFaxId);
    }
    else if (GetLastError() != ERROR_INVALID_HANDLE) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">GetLastError() returned 0x%08x.  This is an error.  FaxSendDocument() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_HANDLE);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
    	fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
	}
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

//    not used, design changed so all suite will run in remote mode
//    if (szServerName) {
//		fnWriteLogFile(TEXT("WHIS> REMOTE CASE(s):\r\n"));
        // Connect to the fax server
//        if (!g_ApiInterface.FaxConnectFaxServer(szServerName, &hFaxSvcHandle)) {
//   		   fnWriteLogFile(TEXT("WHIS> ERROR: Can not connect to fax server %s, The error code is 0x%08x.\r\n"),szServerName, GetLastError());
//           return;
 //      }
//		else
//		{
//			fnWriteLogFile(TEXT("WHIS> Connected to fax server %s. \r\n"),szServerName);
//		}
//
  //      if (!g_ApiInterface.FaxGetConfiguration(hFaxSvcHandle, &pFaxConfig)) {
	//		fnWriteLogFile(TEXT("WHIS> ERROR: Can not GET configuration, The error code is 0x%08x.\r\n"), GetLastError());
      //      // Disconnect from the fax server
        //    g_ApiInterface.FaxClose(hFaxSvcHandle);
            //return;
        //}

        //pFaxConfig->PauseServerQueue = TRUE;

        //if (!g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig)) {
		//	fnWriteLogFile(TEXT("WHIS> ERROR: Can not SET configuration, The error code is 0x%08x.\r\n"), GetLastError());
        //    g_ApiInterface.FaxFreeBuffer(pFaxConfig);
            // Disconnect from the fax server
        //    g_ApiInterface.FaxClose(hFaxSvcHandle);
        //    return;
        //}

        //(*pnNumCasesAttempted)++;
        //fnWriteLogFile(TEXT("Remote hFaxSvcHandle.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
        //if (!g_ApiInterface.FaxSendDocument(hFaxSvcHandle, TEXT("kodak.tif"), &FaxJobParam, NULL, &dwFaxId)) {
        //    fnWriteLogFile(TEXT("FaxSendDocument() failed.  The error code is 0x%08x.  This is an error.  FaxSendDocument() should succeed.\r\n"), GetLastError());
        //}
        //else {
		//	if (!g_bRealSend)	{
		//					g_ApiInterface.FaxAbort(hFaxSvcHandle, dwFaxId);
		//	}
        //    (*pnNumCasesPassed)++;
        //}

        //pFaxConfig->PauseServerQueue = FALSE;
        //g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig);
        //g_ApiInterface.FaxFreeBuffer(pFaxConfig);

        // Disconnect from the fax server
        //g_ApiInterface.FaxClose(hFaxSvcHandle);
    //}
fnWriteLogFile(TEXT("$$$ Summery for FaxSendDocument, Attempt:%d, Pass:%d, Fail:%d\n"),dwFuncCasesAtt,dwFuncCasesPass,dwFuncCasesAtt-dwFuncCasesPass);
fnWriteLogFile(TEXT("\n\t<summary attempt=\"%d\" pass=\"%d\" fail=\"%d\"></summary>\n"),dwFuncCasesAtt,dwFuncCasesPass,dwFuncCasesAtt-dwFuncCasesPass);
fnWriteLogFile(TEXT("\n\t</function>"));
}

BOOL CALLBACK
fnBroadcastCallback(
    HANDLE               hFaxSvcHandle,
    DWORD                dwRecipientNumber,
    LPVOID               lpContext,
    PFAX_JOB_PARAM       pFaxJobParam,
    PFAX_COVERPAGE_INFO  pCoverPageInfo
)
/*++

Routine Description:

  FaxSendDocumentForBroadcast() callback

Return Value:

  TRUE to enumerate another recipient

--*/
{
    BOOL     bRet;
    LPDWORD  pdwIndex;

    pdwIndex = (LPDWORD) lpContext;

    if (*pdwIndex != (dwRecipientNumber - 1)) {
        return FALSE;
    }

    switch (*pdwIndex) {
        case 0:
            pFaxJobParam->RecipientNumber = g_szWhisPhoneNumber;

			fnWriteLogFile(TEXT("WHIS> Setting recipient number to %s\r\n"), g_szWhisPhoneNumber);

            pCoverPageInfo->UseServerCoverPage = TRUE;
            pCoverPageInfo->CoverPageName = TEXT("confdent.cov");
            bRet = TRUE;
            break;

        case 1:
            pFaxJobParam->RecipientNumber = g_szWhisPhoneNumber;

			fnWriteLogFile(TEXT("WHIS> Setting recipient number to %s\r\n"), g_szWhisPhoneNumber);

            pCoverPageInfo->UseServerCoverPage = TRUE;
            pCoverPageInfo->CoverPageName = TEXT("confdent.cov");
            bRet = TRUE;
            break;

        default:
            bRet = FALSE;
            break;
    }

    (*pdwIndex)++;
    return bRet;
}

VOID
fnFaxSendDocumentForBroadcast(
    LPCTSTR  szServerName,
    PUINT    pnNumCasesAttempted,
    PUINT    pnNumCasesPassed
)
/*++

Routine Description:

  FaxSendDocumentForBroadcast()

Return Value:

  None

--*/
{
    // hFaxSvcHandle is the handle to the fax server
    HANDLE              hFaxSvcHandle;
    // pFaxConfig is a pointer to the fax configuration
    PFAX_CONFIGURATION  pFaxConfig;
    // dwFaxId is the fax job id
    DWORD               dwFaxId;

    DWORD               dwIndex;

	// internat Attempt/Pass counters (to display EVAL)
	DWORD			dwFuncCasesAtt=0;
	DWORD			dwFuncCasesPass=0;

	fnWriteLogFile(TEXT(  "\n--------------------------"));
    fnWriteLogFile(TEXT("### FaxSendDocumentForBroadcast().\r\n"));
	fnWriteLogFile(TEXT("\n\t<function name=\"FaxSendDocumentForBroadcast\">"));



    // Connect to the fax server
    if (!g_ApiInterface.FaxConnectFaxServer(szServerName, &hFaxSvcHandle)) {
		fnWriteLogFile(TEXT("WHIS> ERROR: Can not connect to fax server %s, The error code is 0x%08x.\r\n"),szServerName, GetLastError());
		fnWriteLogFile(TEXT("\n\t<summary attempt=\"-1\" pass=\"-1\" fail=\"-1\"></summary>\n"));
		fnWriteLogFile(TEXT("\n\t</function>"));
        return;
    }
	else
	{
		fnWriteLogFile(TEXT("WHIS> Connected to fax server %s. \r\n"),szServerName);
	}

    if (!g_ApiInterface.FaxGetConfiguration(hFaxSvcHandle, &pFaxConfig)) {
		fnWriteLogFile(TEXT("WHIS> ERROR: Can not GET configuration, The error code is 0x%08x.\r\n"), GetLastError());
        // Disconnect from the fax server
        g_ApiInterface.FaxClose(hFaxSvcHandle);
		fnWriteLogFile(TEXT("\n\t<summary attempt=\"-1\" pass=\"-1\" fail=\"-1\"></summary>\n"));
		fnWriteLogFile(TEXT("\n\t</function>"));
        return;
    }

    pFaxConfig->PauseServerQueue = TRUE;

    if (!g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig)) {
		fnWriteLogFile(TEXT("WHIS> ERROR: Can not SET configuration, The error code is 0x%08x.\r\n"), GetLastError());
        g_ApiInterface.FaxFreeBuffer(pFaxConfig);
        // Disconnect from the fax server
        g_ApiInterface.FaxClose(hFaxSvcHandle);
		fnWriteLogFile(TEXT("\n\t<summary attempt=\"-1\" pass=\"-1\" fail=\"-1\"></summary>\n"));
		fnWriteLogFile(TEXT("\n\t</function>"));
        return;
    }


    // Send a document
    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;
    dwIndex = 0;
    fnWriteLogFile(TEXT("Valid Case.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"Valid Case\" id=\"%d\">"), *pnNumCasesAttempted);

    if (!g_ApiInterface.FaxSendDocumentForBroadcast(hFaxSvcHandle, TEXT("fax.tif"), &dwFaxId, fnBroadcastCallback, &dwIndex)) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxSendDocumentForBroadcast() failed.  The error code is 0x%08x.  This is an error.  FaxSendDocumentForBroadcast() should succeed.</result>\r\n"), GetLastError());
    }
    else {
        if (dwIndex != 3) {
            fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxSendDocumentForBroadcast() failed.  fnBroadcastCallback() was only called %d times.  This is an error.  fnBroadcastCallback() should have been called 3 times.</result>\r\n"), dwIndex);
        }
        else if (g_ApiInterface.FaxAbort(hFaxSvcHandle, dwFaxId)) {
            fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxAbort() of owner job returned TRUE.  This is an error.  FaxAbort() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).</result>\r\n"), ERROR_INVALID_PARAMETER);
        }
        else if (GetLastError() != ERROR_INVALID_PARAMETER) {
            fnWriteLogFile(TEXT("\n\t<result value=\"0\">GetLastError() returned 0x%08x.  This is an error.  FaxAbort() of owner job should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
        }
        else {
            (*pnNumCasesPassed)++;
			dwFuncCasesPass++;
			fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
        }	
		
		if (!g_bRealSend)	{
							g_ApiInterface.FaxAbort(hFaxSvcHandle, (dwFaxId + 2));
							g_ApiInterface.FaxAbort(hFaxSvcHandle, (dwFaxId + 1));
							g_ApiInterface.FaxAbort(hFaxSvcHandle, dwFaxId);
		}
	}
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;
    fnWriteLogFile(TEXT("hFaxSvcHandle = NULL.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"hFaxSvcHandle = NULL\" id=\"%d\">"), *pnNumCasesAttempted);

    if (g_ApiInterface.FaxSendDocumentForBroadcast(NULL, TEXT("fax.tif"), &dwFaxId, fnBroadcastCallback, &dwIndex)) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxSendDocumentForBroadcast() returned TRUE.  This is an error.  FaxSendDocumentForBroadcast() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).</result>\r\n"), ERROR_INVALID_HANDLE);
        g_ApiInterface.FaxAbort(hFaxSvcHandle, (dwFaxId + 2));
        g_ApiInterface.FaxAbort(hFaxSvcHandle, (dwFaxId + 1));
        g_ApiInterface.FaxAbort(hFaxSvcHandle, dwFaxId);
    }
    else if (GetLastError() != ERROR_INVALID_HANDLE) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">GetLastError() returned 0x%08x.  This is an error.  FaxSendDocumentForBroadcast() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_HANDLE);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
		fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));

    }
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;
    fnWriteLogFile(TEXT("szDocument = NULL.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"szDocument = NULL\" id=\"%d\">"), *pnNumCasesAttempted);

    if (g_ApiInterface.FaxSendDocumentForBroadcast(hFaxSvcHandle, NULL, &dwFaxId, fnBroadcastCallback, &dwIndex)) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxSendDocumentForBroadcast() returned TRUE.  This is an error.  FaxSendDocumentForBroadcast() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).</result>\r\n"), ERROR_INVALID_PARAMETER);
        g_ApiInterface.FaxAbort(hFaxSvcHandle, (dwFaxId + 2));
        g_ApiInterface.FaxAbort(hFaxSvcHandle, (dwFaxId + 1));
        g_ApiInterface.FaxAbort(hFaxSvcHandle, dwFaxId);
    }
    else if (GetLastError() != ERROR_INVALID_PARAMETER) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">GetLastError() returned 0x%08x.  This is an error.  FaxSendDocumentForBroadcast() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
		fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
    }
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;
    fnWriteLogFile(TEXT("fnBroadcastCallback = NULL.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"fnBroadcastCallback = NULL\" id=\"%d\">"), *pnNumCasesAttempted);

    if (g_ApiInterface.FaxSendDocumentForBroadcast(hFaxSvcHandle, TEXT("fax.tif"), &dwFaxId, NULL, &dwIndex)) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxSendDocumentForBroadcast() returned TRUE.  This is an error.  FaxSendDocumentForBroadcast() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).</result>\r\n"), ERROR_INVALID_PARAMETER);
        g_ApiInterface.FaxAbort(hFaxSvcHandle, (dwFaxId + 2));
        g_ApiInterface.FaxAbort(hFaxSvcHandle, (dwFaxId + 1));
        g_ApiInterface.FaxAbort(hFaxSvcHandle, dwFaxId);
    }
    else if (GetLastError() != ERROR_INVALID_PARAMETER) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">GetLastError() returned 0x%08x.  This is an error.  FaxSendDocumentForBroadcast() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
		fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
    }
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

    pFaxConfig->PauseServerQueue = FALSE;
    g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig);
    g_ApiInterface.FaxFreeBuffer(pFaxConfig);

    // Disconnect from the fax server
    g_ApiInterface.FaxClose(hFaxSvcHandle);

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;
    fnWriteLogFile(TEXT("Invalid hFaxSvcHandle.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"Invalid hFaxSvcHandle\" id=\"%d\">"), *pnNumCasesAttempted);

    if (g_ApiInterface.FaxSendDocumentForBroadcast(hFaxSvcHandle, TEXT("fax.tif"), &dwFaxId, fnBroadcastCallback, &dwIndex)) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxSendDocumentForBroadcast() returned TRUE.  This is an error.  FaxSendDocumentForBroadcast() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).</result>\r\n"), ERROR_INVALID_HANDLE);
        g_ApiInterface.FaxAbort(hFaxSvcHandle, (dwFaxId + 2));
        g_ApiInterface.FaxAbort(hFaxSvcHandle, (dwFaxId + 1));
        g_ApiInterface.FaxAbort(hFaxSvcHandle, dwFaxId);
    }
    else if (GetLastError() != ERROR_INVALID_HANDLE) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">GetLastError() returned 0x%08x.  This is an error.  FaxSendDocumentForBroadcast() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_HANDLE);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
		fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
    }
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

    //if (szServerName) {
	//	fnWriteLogFile(TEXT("WHIS> REMOTE CASE(s):\r\n"));
        // Connect to the fax server
    //    if (!g_ApiInterface.FaxConnectFaxServer(szServerName, &hFaxSvcHandle)) {
    //        return;
    //    }

    //    if (!g_ApiInterface.FaxGetConfiguration(hFaxSvcHandle, &pFaxConfig)) {
            // Disconnect from the fax server
    //        g_ApiInterface.FaxClose(hFaxSvcHandle);
    //        return;
    //    }

     //   pFaxConfig->PauseServerQueue = TRUE;

        //if (!g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig)) {
          //  g_ApiInterface.FaxFreeBuffer(pFaxConfig);
            // Disconnect from the fax server
            //g_ApiInterface.FaxClose(hFaxSvcHandle);
            //return;
        //}

        //(*pnNumCasesAttempted)++;
        //dwIndex = 0;
        //fnWriteLogFile(TEXT("Remote hFaxSvcHandle.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
        //if (!g_ApiInterface.FaxSendDocumentForBroadcast(hFaxSvcHandle, TEXT("fax.tif"), &dwFaxId, fnBroadcastCallback, &dwIndex)) {
            //fnWriteLogFile(TEXT("FaxSendDocumentForBroadcast() failed.  The error code is 0x%08x.  This is an error.  FaxSendDocumentForBroadcast() should succeed.\r\n"), GetLastError());
        //}
        //else {
            //(*pnNumCasesPassed)++;

//			if (!g_bRealSend)	{
//		            g_ApiInterface.FaxAbort(hFaxSvcHandle, (dwFaxId + 2));
//			        g_ApiInterface.FaxAbort(hFaxSvcHandle, (dwFaxId + 1));
//					g_ApiInterface.FaxAbort(hFaxSvcHandle, dwFaxId);
//			}
        //}

//        pFaxConfig->PauseServerQueue = FALSE;
        //g_ApiInterface.FaxSetConfiguration(hFaxSvcHandle, pFaxConfig);
        //g_ApiInterface.FaxFreeBuffer(pFaxConfig);

        // Disconnect from the fax server
//        g_ApiInterface.FaxClose(hFaxSvcHandle);
    //}

fnWriteLogFile(TEXT("$$$ Summery for FaxSendDocumentForBroadcast, Attempt:%d, Pass:%d, Fail:%d\n"),dwFuncCasesAtt,dwFuncCasesPass,dwFuncCasesAtt-dwFuncCasesPass);
fnWriteLogFile(TEXT("\n\t<summary attempt=\"%d\" pass=\"%d\" fail=\"%d\"></summary>\n"),dwFuncCasesAtt,dwFuncCasesPass,dwFuncCasesAtt-dwFuncCasesPass);
fnWriteLogFile(TEXT("\n\t</function>"));
}



BOOL WINAPI
FaxAPIDllTest(
	LPCWSTR  szWhisPhoneNumberW,
	LPCSTR   szWhisPhoneNumberA,
    LPCWSTR  szServerNameW,
    LPCSTR   szServerNameA,
    UINT     nNumCasesLocal,
    UINT     nNumCasesServer,
    PUINT    pnNumCasesAttempted,
    PUINT    pnNumCasesPassed,
	DWORD	 dwTestMode
)
{
    LPCTSTR  szServerName;
    UINT     nNumCases;


	// for Whis-extended only
#ifdef UNICODE
    if (lstrlen(szWhisPhoneNumberW)>0) { 
		g_szWhisPhoneNumber = szWhisPhoneNumberW; 
	}
	else {
		g_szWhisPhoneNumber=TEXT(WHIS_DEFAULT_PHONE_NUMBER);
	}
#else
	if (lstrlen(szWhisPhoneNumberA)>0) {
		g_szWhisPhoneNumber = szWhisPhoneNumberA;
	}
	else {
		g_szWhisPhoneNumber=TEXT(WHIS_DEFAULT_PHONE_NUMBER);
	}
		
#endif

#ifdef UNICODE
    szServerName = szServerNameW;
#else
    szServerName = szServerNameA;
#endif

    if (szServerName) {
        nNumCases = nNumCasesServer;
		fnWriteLogFile(TEXT("WHIS> REMOTE SERVER MODE:\r\n"));
    }
    else {
        nNumCases = nNumCasesLocal;
    }

	if (dwTestMode==WHIS_TEST_MODE_REAL_SEND) g_bRealSend=TRUE;


    // FaxStartPrintJob()
    fnFaxStartPrintJob(szServerName, pnNumCasesAttempted, pnNumCasesPassed);

    // FaxPrintCoverPage()
    fnFaxPrintCoverPage(szServerName, pnNumCasesAttempted, pnNumCasesPassed,TRUE);

    // FaxSendDocument()
    fnFaxSendDocument(szServerName, pnNumCasesAttempted, pnNumCasesPassed);

    // FaxSendDocumentForBroadcast()
    fnFaxSendDocumentForBroadcast(szServerName, pnNumCasesAttempted, pnNumCasesPassed);

    if ((*pnNumCasesAttempted == nNumCases) && (*pnNumCasesPassed == *pnNumCasesAttempted)) {
        return TRUE;
    }
    else {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\faxcapi\legwin32_whis_xml\routeapi\routeapi.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  routeapi.c

Abstract:

  RouteApi: Fax API Test Dll: Client Routing APIs
    1) FaxRegisterServiceProvider()
    2) FaxRegisterRoutingExtension()
    3) FaxEnumGlobalRoutingInfo()
    4) FaxSetGlobalRoutingInfo()
    5) FaxEnumRoutingMethods()
    6) FaxEnableRoutingMethod()
    7) FaxGetRoutingInfo()
    8) FaxSetRoutingInfo()

Author:

  Steven Kehrli (steveke) 8/28/1998

--*/

/*++

  Whistler Version:

  Lior Shmueli (liors) 23/11/2000

 ++*/

#include <wtypes.h>
#include <tchar.h>

#include "dllapi.h"
#include "routeapi.h"



// g_hHeap is the handle to the heap
HANDLE           g_hHeap = NULL;
// g_ApiInterface is the API_INTERFACE structure
API_INTERFACE    g_ApiInterface;
// fnWriteLogFile is the pointer to the function to write a string to the log file
PFNWRITELOGFILE  fnWriteLogFile = NULL;

// number of global routing methods
DWORD	 g_dwNumMethods=0;
DWORD	 g_dwIndexAPIMethod1=0;
DWORD	 g_dwIndexAPIMethod2=0;

#define FAX_DEVICEPROVIDERS_REGKEY        TEXT("Software\\Microsoft\\Fax\\Device Providers")
#define FAX_ROUTINGEXTENSIONS_REGKEY      TEXT("Software\\Microsoft\\Fax\\Routing Extensions")
#define FAX_ROUTINGMETHODS_REGKEY         TEXT("Routing Methods")
#define FAX_SERVICE                       TEXT("Fax")

#define ROUTEAPI_PROVIDER_W               L"RouteApi Modem Device Provider"
#define ROUTEAPI_PROVIDER                 TEXT("RouteApi Modem Device Provider")
#define ROUTEAPI_PROVIDER_FRIENDLYNAME_W  L"RouteApi Modem Device Provider Friendly Name"
#define ROUTEAPI_PROVIDER_FRIENDLYNAME    TEXT("RouteApi Modem Device Provider Friendly Name")
#define ROUTEAPI_PROVIDER_IMAGENAME_W     L"%SystemRoot%\\system32\\faxt30.dll"
#define ROUTEAPI_PROVIDER_IMAGENAME       TEXT("%SystemRoot%\\system32\\faxt30.dll")
#define ROUTEAPI_PROVIDER_PROVIDERNAME_W  L"Windows Telephony Service Provider for Universal Modem Driver"
#define ROUTEAPI_PROVIDER_PROVIDERNAME    TEXT("Windows Telephony Service Provider for Universal Modem Driver")

#define ROUTEAPI_INVALID_GUID             TEXT("{00000000-0000-0000-0000-000000000000}")

DWORD
DllEntry(
    HINSTANCE  hInstance,
    DWORD      dwReason,
    LPVOID     pContext
)
/*++

Routine Description:

  DLL entry point

Arguments:

  hInstance - handle to the module
  dwReason - indicates the reason for being called
  pContext - context

Return Value:

  TRUE on success

--*/
{
    return TRUE;
}

VOID WINAPI
FaxAPIDllInit(
    HANDLE            hHeap,
    API_INTERFACE     ApiInterface,
    PFNWRITELOGFILEW  pfnWriteLogFileW,
    PFNWRITELOGFILEA  pfnWriteLogFileA
)
/*++

Routine Description:

  Initialize Fax API Dll Test

Arguments:

  hHeap - handle to the heap
  ApiInterface - API_INTERFACE structure
  pfnWriteLogFile - pointer to function to write a string to the log file

Return Value:

  None

--*/
{
    // Set g_hHeap
    g_hHeap = hHeap;
    // Set g_ApiInterface
    g_ApiInterface = ApiInterface;
#ifdef UNICODE
    // Set fnWriteLogFile
    fnWriteLogFile = pfnWriteLogFileW;
#else
    // Set fnWriteLogFile
    fnWriteLogFile = pfnWriteLogFileA;
#endif

    return;
}

BOOL
fnRegQuerySz(
    HKEY    hKey,
    LPTSTR  szValue,
    LPTSTR  *pszData
)
/*++

Routine Description:

  Queries a Registry data as a REG_SZ

Arguments:

  hKey - handle to the Registry key
  szValue - value to be queried
  pszData - pointer to the data to be queried

Return Value:

  TRUE on success

--*/
{
    DWORD  cb;

    cb = 0;
    // Determine the memory required by pszData
    if (RegQueryValueEx(hKey, szValue, NULL, NULL, NULL, &cb)) {
        return FALSE;
    }

    // Allocate the memory for pszData
    *pszData = HeapAlloc(g_hHeap, HEAP_GENERATE_EXCEPTIONS | HEAP_ZERO_MEMORY, cb);

    if (RegQueryValueEx(hKey, szValue, NULL, NULL, (PBYTE) *pszData, &cb)) {
        HeapFree(g_hHeap, 0, *pszData);
        *pszData = NULL;
        return FALSE;
    }

    return TRUE;
}

VOID
fnFaxRegisterServiceProvider(
    LPCTSTR  szServerName,
    PUINT    pnNumCasesAttempted,
    PUINT    pnNumCasesPassed
)
/*++

Routine Description:

  FaxRegisterServiceProvider()

Return Value:

  None

--*/
{
    // hFaxDeviceProvidersKey is the handle to the fax device providers registry key
    HKEY    hFaxDeviceProvidersKey;
    // hFaxSvcProviderKey is the handle to the fax service provider registry key
    HKEY    hFaxSvcProviderKey;
    // szFriendlyName is the service provider friendly name registry value
    LPTSTR  szFriendlyName;
    // szImageName is the service provider image name registry value
    LPTSTR  szImageName;
    // szProviderName is the service provider provider name registry value
    LPTSTR  szProviderName;

	// internat Attempt/Pass counters (to display EVAL)
	DWORD			dwFuncCasesAtt=0;
	DWORD			dwFuncCasesPass=0;

	fnWriteLogFile(TEXT(  "\n--------------------------"));
    fnWriteLogFile(TEXT("### FaxRegisterServiceProvider().\r\n"));
	fnWriteLogFile(TEXT("\n\t<function name=\"FaxRegisterServiceProvider\">"));

    // Register the service provider
    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("Valid Case.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"Valid Case\" id=\"%d\">"), *pnNumCasesAttempted);

    if (!g_ApiInterface.FaxRegisterServiceProvider(ROUTEAPI_PROVIDER_W, ROUTEAPI_PROVIDER_FRIENDLYNAME_W, ROUTEAPI_PROVIDER_IMAGENAME_W, ROUTEAPI_PROVIDER_PROVIDERNAME_W)) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxRegisterServiceProvider() failed.  The error code is 0x%08x.  This is an error.  FaxRegisterServiceProvider() should succeed.</result>\r\n"), GetLastError());
    }
    else {
        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, FAX_DEVICEPROVIDERS_REGKEY, 0, KEY_ALL_ACCESS, &hFaxDeviceProvidersKey)) {
            fnWriteLogFile(TEXT("\n\t<result value=\"0\">Could not open the Registry Key %s, ec = 0x%08x.</result>\r\n"), FAX_DEVICEPROVIDERS_REGKEY, GetLastError());
            goto RegFailed0;
        }

        if (RegOpenKeyEx(hFaxDeviceProvidersKey, ROUTEAPI_PROVIDER, 0, KEY_ALL_ACCESS, &hFaxSvcProviderKey)) {
            fnWriteLogFile(TEXT("\n\t<result value=\"0\">Could not open the Registry Key %s, ec = 0x%08x.</result>\r\n"), ROUTEAPI_PROVIDER, GetLastError());
            goto RegFailed1;
        }

        if (!fnRegQuerySz(hFaxSvcProviderKey, TEXT("FriendlyName"), &szFriendlyName)) {
            fnWriteLogFile(TEXT("\n\t<result value=\"0\">Could not query the Registry Value %s, ec = 0x%08x.</result>\r\n"), TEXT("FriendlyName"), GetLastError());
            goto RegFailed2;
        }
        if (lstrcmp(ROUTEAPI_PROVIDER_FRIENDLYNAME, szFriendlyName)!=0) {
            fnWriteLogFile(TEXT("\n\t<result value=\"0\">FriendlyName: Received: %s, Expected: %s.</result>\r\n"), szFriendlyName, ROUTEAPI_PROVIDER_FRIENDLYNAME);
            goto RegFailed2;
        }
        HeapFree(g_hHeap, 0, szFriendlyName);

        if (!fnRegQuerySz(hFaxSvcProviderKey, TEXT("ImageName"), &szImageName)) {
            fnWriteLogFile(TEXT("\n\t<result value=\"0\">Could not query the Registry Value %s, ec = 0x%08x.</result>\r\n"), TEXT("ImageName"), GetLastError());
            goto RegFailed2;
        }
        if (lstrcmp(ROUTEAPI_PROVIDER_IMAGENAME, szImageName)!=0) {
            fnWriteLogFile(TEXT("\n\t<result value=\"0\">ImageName: Received: %s, Expected: %s.</result>\r\n"), szImageName, ROUTEAPI_PROVIDER_IMAGENAME);
            goto RegFailed2;
        }
        HeapFree(g_hHeap, 0, szImageName);

        if (!fnRegQuerySz(hFaxSvcProviderKey, TEXT("ProviderName"), &szProviderName)) {
            fnWriteLogFile(TEXT("\n\t<result value=\"0\">Could not query the Registry Value %s, ec = 0x%08x.</result>\r\n"), TEXT("ProviderName"), GetLastError());
            goto RegFailed2;
        }
        if (lstrcmp(ROUTEAPI_PROVIDER_PROVIDERNAME, szProviderName)!=0) {
            fnWriteLogFile(TEXT("\n\t<result value=\"0\">ProviderName: Received: %s, Expected: %s.</result>\r\n"), szProviderName, ROUTEAPI_PROVIDER_PROVIDERNAME);
            goto RegFailed2;
        }
        HeapFree(g_hHeap, 0, szProviderName);

        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
		fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));

goto RegFailed0;
RegFailed2:
        RegCloseKey(hFaxSvcProviderKey);
        RegDeleteKey(hFaxDeviceProvidersKey, ROUTEAPI_PROVIDER);

RegFailed1:
        RegCloseKey(hFaxDeviceProvidersKey);
    }
	
RegFailed0:
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("ROUTEAPI_PROVIDER = NULL.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"ROUTEAPI_PROVIDER = NULL\" id=\"%d\">"), *pnNumCasesAttempted);

    if (g_ApiInterface.FaxRegisterServiceProvider(NULL, ROUTEAPI_PROVIDER_FRIENDLYNAME_W, ROUTEAPI_PROVIDER_IMAGENAME_W, ROUTEAPI_PROVIDER_PROVIDERNAME_W)) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxRegisterServiceProvider() returned TRUE.  This is an error.  FaxRegisterServiceProvider() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).</result>\r\n"), ERROR_INVALID_PARAMETER);
    }
    else if (GetLastError() != ERROR_INVALID_PARAMETER) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">GetLastError() returned 0x%08x.  This is an error.  FaxRegisterServiceProvider() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
		fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
    }
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("ROUTEAPI_PROVIDER_FRIENDLYNAME = NULL.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"ROUTEAPI_PROVIDER_FRIENDLYNAME = NULL\" id=\"%d\">"), *pnNumCasesAttempted);

    if (g_ApiInterface.FaxRegisterServiceProvider(ROUTEAPI_PROVIDER_W, NULL, ROUTEAPI_PROVIDER_IMAGENAME_W, ROUTEAPI_PROVIDER_PROVIDERNAME_W)) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxRegisterServiceProvider() returned TRUE.  This is an error.  FaxRegisterServiceProvider() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).</result>\r\n"), ERROR_INVALID_PARAMETER);
    }
    else if (GetLastError() != ERROR_INVALID_PARAMETER) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">GetLastError() returned 0x%08x.  This is an error.  FaxRegisterServiceProvider() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
		fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
    }
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("ROUTEAPI_PROVIDER_IMAGENAME = NULL.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"ROUTEAPI_PROVIDER_IMAGENAME = NULL\" id=\"%d\">"), *pnNumCasesAttempted);

    if (g_ApiInterface.FaxRegisterServiceProvider(ROUTEAPI_PROVIDER_W, ROUTEAPI_PROVIDER_FRIENDLYNAME_W, NULL, ROUTEAPI_PROVIDER_PROVIDERNAME_W)) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxRegisterServiceProvider() returned TRUE.  This is an error.  FaxRegisterServiceProvider() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).</result>\r\n"), ERROR_INVALID_PARAMETER);
    }
    else if (GetLastError() != ERROR_INVALID_PARAMETER) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">GetLastError() returned 0x%08x.  This is an error.  FaxRegisterServiceProvider() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
		fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
    }
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("ROUTEAPI_PROVIDER_PROVIDERNAME = NULL.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"ROUTEAPI_PROVIDER_PROVIDERNAME = NULL\" id=\"%d\">"), *pnNumCasesAttempted);

    if (g_ApiInterface.FaxRegisterServiceProvider(ROUTEAPI_PROVIDER_W, ROUTEAPI_PROVIDER_FRIENDLYNAME_W, ROUTEAPI_PROVIDER_IMAGENAME_W, NULL)) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxRegisterServiceProvider() returned TRUE.  This is an error.  FaxRegisterServiceProvider() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).</result>\r\n"), ERROR_INVALID_PARAMETER);
    }
    else if (GetLastError() != ERROR_INVALID_PARAMETER) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">GetLastError() returned 0x%08x.  This is an error.  FaxRegisterServiceProvider() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
		fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
    }
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, FAX_DEVICEPROVIDERS_REGKEY, 0, KEY_ALL_ACCESS, &hFaxDeviceProvidersKey)) {
        return;
    }

    RegDeleteKey(hFaxDeviceProvidersKey, ROUTEAPI_PROVIDER);
    RegCloseKey(hFaxDeviceProvidersKey);
fnWriteLogFile(TEXT("$$$ Summery for FaxRegisterServiceProvider, Attempt:%d, Pass:%d, Fail:%d\n"),dwFuncCasesAtt,dwFuncCasesPass,dwFuncCasesAtt-dwFuncCasesPass);
fnWriteLogFile(TEXT("\n\t<summary attempt=\"%d\" pass=\"%d\" fail=\"%d\"></summary>\n"),dwFuncCasesAtt,dwFuncCasesPass,dwFuncCasesAtt-dwFuncCasesPass);
fnWriteLogFile(TEXT("\n\t</function>"));
}

BOOL CALLBACK
fnRouteApiExtensionCallback(
    HANDLE  hFaxSvcHandle,
    LPVOID  lpContext,
    LPWSTR  szMethodBuffer,
    LPWSTR  szMethodFriendlyNameBuffer,
    LPWSTR  szMethodFunctionNameBuffer,
    LPWSTR  szGUIDBuffer
)
/*++

Routine Description:

  FaxRegisterRoutingExtension() callback

Return Value:

  TRUE to enumerate another Routing Method

--*/
{
    BOOL     bRet;
    LPDWORD  pdwIndex;

	

    pdwIndex = (LPDWORD) lpContext;

    switch (*pdwIndex) {
        case 0:
            lstrcpyW(szMethodBuffer, ROUTEAPI_METHOD1_W);
            lstrcpyW(szMethodFriendlyNameBuffer, ROUTEAPI_METHOD_FRIENDLYNAME1_W);
            lstrcpyW(szMethodFunctionNameBuffer, ROUTEAPI_METHOD_FUNCTIONNAME1_W);
            lstrcpyW(szGUIDBuffer, ROUTEAPI_METHOD_GUID1_W);
            bRet = TRUE;
            break;

        case 1:
            lstrcpyW(szMethodBuffer, ROUTEAPI_METHOD2_W);
            lstrcpyW(szMethodFriendlyNameBuffer, ROUTEAPI_METHOD_FRIENDLYNAME2_W);
            lstrcpyW(szMethodFunctionNameBuffer, ROUTEAPI_METHOD_FUNCTIONNAME2_W);
            lstrcpyW(szGUIDBuffer, ROUTEAPI_METHOD_GUID2_W);
            bRet = TRUE;
            break;

        default:
            bRet = FALSE;
            break;
    }

    (*pdwIndex)++;
    return bRet;
}

VOID
fnFaxRegisterRoutingExtension(
    LPCTSTR  szServerName,
    PUINT    pnNumCasesAttempted,
    PUINT    pnNumCasesPassed
)
/*++

Routine Description:

  FaxRegisterRoutingExtension()

Return Value:

  None

--*/
{
    // hFaxSvcHandle is the handle to the fax server
    HANDLE  hFaxSvcHandle;

    // hFaxRoutingExtensionsKey is the handle to the fax routing extensions registry key
    HKEY    hFaxRoutingExtensionsKey;
    // hFaxExtensionKey is the handle to the fax extension registry key
    HKEY    hFaxExtensionKey;
    // hFaxRoutingMethodsKey is the handle to the fax routing methods registry key
    HKEY    hFaxRoutingMethodsKey;
    // hFaxMethodKey is the handle to the fax method registry key
    HKEY    hFaxMethodKey;
    // szFriendlyName is the routing extension or routing method friendly name registry value
    LPTSTR  szFriendlyName;
    // szImageName is the routing extension image name registry value
    LPTSTR  szImageName;
    // szFunctionName is the routing method function name registry value
    LPTSTR  szFunctionName;
    // szGUID is the routing method GUD registry value
    LPTSTR  szGUID;

    DWORD   dwIndex;
	DWORD   dwWhisErrorCode=0;

	// internat Attempt/Pass counters (to display EVAL)
	DWORD			dwFuncCasesAtt=0;
	DWORD			dwFuncCasesPass=0;

	fnWriteLogFile(TEXT(  "\n--------------------------"));
    fnWriteLogFile(TEXT("### FaxRegisterRoutingExtension().\r\n"));
	fnWriteLogFile(TEXT("\n\t<function name=\"FaxRegisterRoutingExtension\">"));

    // Connect to the fax server
    if (!g_ApiInterface.FaxConnectFaxServer(szServerName, &hFaxSvcHandle)) {
		fnWriteLogFile(TEXT("WHIS> ERROR: Can not connect to fax server %s, The error code is 0x%08x.\r\n"),szServerName, GetLastError());
		fnWriteLogFile(TEXT("\n\t<summary attempt=\"-1\" pass=\"-1\" fail=\"-1\"></summary>\n"));
		fnWriteLogFile(TEXT("\n\t</function>"));
        return;
    }
	else
	{
		fnWriteLogFile(TEXT("WHIS> Connected to fax server %s. \r\n"),szServerName);
	}
    // Register the routing extension
    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;
    dwIndex = 0;
	fnWriteLogFile(TEXT("WHIS> Starting extension registration...\n"));
	
						
	fnWriteLogFile(TEXT("\nValid Case.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"Valid Case\" id=\"%d\">"), *pnNumCasesAttempted);

    if (!g_ApiInterface.FaxRegisterRoutingExtension(hFaxSvcHandle, ROUTEAPI_EXTENSION_W, ROUTEAPI_EXTENSION_FRIENDLYNAME_W, ROUTEAPI_EXTENSION_IMAGENAME_W, fnRouteApiExtensionCallback, &dwIndex)) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxRegisterRoutingExtension() failed.  The error code is 0x%08x.  This is an error.  FaxRegisterRoutingExtension() should succeed.</result>\r\n"), GetLastError());
    }
    else {
        if (dwIndex != 3) {
            fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxRegisterRoutingExtension() failed.  fnRouteApiExtensionCallback() was only called %d times.  This is an error.  fnRouteApiExtensionCallback() should have been called 3 times.</result>\r\n"), dwIndex);
			dwWhisErrorCode=1;
            goto RegFailed0;
        }

        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, FAX_ROUTINGEXTENSIONS_REGKEY, 0, KEY_ALL_ACCESS, &hFaxRoutingExtensionsKey)) {
            fnWriteLogFile(TEXT("\n\t<result value=\"0\">Could not open the Registry Key %s, ec = 0x%08x.</result>\r\n"), FAX_ROUTINGEXTENSIONS_REGKEY, GetLastError());
			dwWhisErrorCode=2;
            goto RegFailed0;
        }

        if (RegOpenKeyEx(hFaxRoutingExtensionsKey, ROUTEAPI_EXTENSION, 0, KEY_ALL_ACCESS, &hFaxExtensionKey)) {
            fnWriteLogFile(TEXT("\n\t<result value=\"0\">Could not open the Registry Key %s, ec = 0x%08x.</result>\r\n"), ROUTEAPI_EXTENSION, GetLastError());
			dwWhisErrorCode=3;
            goto RegFailed1;
        }

        if (!fnRegQuerySz(hFaxExtensionKey, TEXT("FriendlyName"), &szFriendlyName)) {
            fnWriteLogFile(TEXT("\n\t<result value=\"0\">Could not query the Registry Value %s, ec = 0x%08x.</result>\r\n"), TEXT("FriendlyName"), GetLastError());
			dwWhisErrorCode=4;
            goto RegFailed2;
        }
        if (lstrcmp(ROUTEAPI_EXTENSION_FRIENDLYNAME, szFriendlyName)!=0) {
            fnWriteLogFile(TEXT("\n\t<result value=\"0\">FriendlyName: Received: %s, Expected: %s.</result>\r\n"), szFriendlyName, ROUTEAPI_EXTENSION_FRIENDLYNAME);
			dwWhisErrorCode=5;
            goto RegFailed2;
        }
        HeapFree(g_hHeap, 0, szFriendlyName);

        if (!fnRegQuerySz(hFaxExtensionKey, TEXT("ImageName"), &szImageName)) {
            fnWriteLogFile(TEXT("\n\t<result value=\"0\">Could not query the Registry Value %s, ec = 0x%08x.</result>\r\n"), TEXT("ImageName"), GetLastError());
			dwWhisErrorCode=6;
            goto RegFailed2;
        }
        if (lstrcmp(ROUTEAPI_EXTENSION_IMAGENAME, szImageName)!=0) {
            fnWriteLogFile(TEXT("\n\t<result value=\"0\">ImageName: Received: %s, Expected: %s.</result>\r\n"), szImageName, ROUTEAPI_EXTENSION_IMAGENAME);
			dwWhisErrorCode=7;
            goto RegFailed2;
        }
        HeapFree(g_hHeap, 0, szImageName);

        if (RegOpenKeyEx(hFaxExtensionKey, FAX_ROUTINGMETHODS_REGKEY, 0, KEY_ALL_ACCESS, &hFaxRoutingMethodsKey)) {
            fnWriteLogFile(TEXT("\n\t<result value=\"0\">Could not open the Registry Key %s, ec = 0x%08x.</result>\r\n"), FAX_ROUTINGMETHODS_REGKEY, GetLastError());
			dwWhisErrorCode=8;
            goto RegFailed2;
        }

        if (RegOpenKeyEx(hFaxRoutingMethodsKey, ROUTEAPI_METHOD1, 0, KEY_ALL_ACCESS, &hFaxMethodKey)) {
            fnWriteLogFile(TEXT("\n\t<result value=\"0\">Could not open the Registry Key %s, ec = 0x%08x.</result>\r\n"), ROUTEAPI_METHOD1, GetLastError());
			dwWhisErrorCode=9;
            goto NextMethod0;
        }

        if (!fnRegQuerySz(hFaxMethodKey, TEXT("FriendlyName"), &szFriendlyName)) {
            fnWriteLogFile(TEXT("\n\t<result value=\"0\">Could not query the Registry Value %s, ec = 0x%08x.</result>\r\n"), TEXT("FriendlyName"), GetLastError());
			dwWhisErrorCode=10;
            goto NextMethod1;
        }
        if (lstrcmp(ROUTEAPI_METHOD_FRIENDLYNAME1, szFriendlyName)!=0) {
            fnWriteLogFile(TEXT("\n\t<result value=\"0\">FriendlyName: Received: %s, Expected: %s.</result>\r\n"), szFriendlyName, ROUTEAPI_METHOD_FRIENDLYNAME1);
			dwWhisErrorCode=11;
            goto NextMethod1;
        }
        HeapFree(g_hHeap, 0, szFriendlyName);

        if (!fnRegQuerySz(hFaxMethodKey, TEXT("Function Name"), &szFunctionName)) {
            fnWriteLogFile(TEXT("\n\t<result value=\"0\">Could not query the Registry Value %s, ec = 0x%08x.</result>\r\n"), TEXT("Function Name"), GetLastError());
			dwWhisErrorCode=12;
            goto NextMethod1;
        }
        if (lstrcmp(ROUTEAPI_METHOD_FUNCTIONNAME1, szFunctionName)!=0) {
            fnWriteLogFile(TEXT("\n\t<result value=\"0\">Function Name: Received: %s, Expected: %s.</result>\r\n"), szFunctionName, ROUTEAPI_METHOD_FUNCTIONNAME1);
			dwWhisErrorCode=13;
            goto NextMethod1;
        }
        HeapFree(g_hHeap, 0, szFunctionName);

        if (!fnRegQuerySz(hFaxMethodKey, TEXT("Guid"), &szGUID)) {
            fnWriteLogFile(TEXT("\n\t<result value=\"0\">Could not query the Registry Value %s, ec = 0x%08x.</result>\r\n"), TEXT("Guid"), GetLastError());
			dwWhisErrorCode=14;
            goto NextMethod1;
        }
        if (lstrcmp(ROUTEAPI_METHOD_GUID1, szGUID)!=0) {
            fnWriteLogFile(TEXT("\n\t<result value=\"0\">Guid: Received: %s, Expected: %s.</result>\r\n"), szGUID, ROUTEAPI_METHOD_GUID1);
			dwWhisErrorCode=15;
            goto NextMethod1;
        }
        HeapFree(g_hHeap, 0, szGUID);

goto NextMethod0;
NextMethod1:
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">There was an error with the 1st routing extenstion registration (code %d), and it will be deleted. IGNORE ALL CASES.</result>\r\n"),dwWhisErrorCode);
        RegCloseKey(hFaxMethodKey);
		RegDeleteKey(hFaxRoutingMethodsKey, ROUTEAPI_METHOD1);

NextMethod0:
        if (RegOpenKeyEx(hFaxRoutingMethodsKey, ROUTEAPI_METHOD2, 0, KEY_ALL_ACCESS, &hFaxMethodKey)) {
            fnWriteLogFile(TEXT("\n\t<result value=\"0\">Could not open the Registry Key %s, ec = 0x%08x.</result>\r\n"), ROUTEAPI_METHOD2, GetLastError());
            goto RegFailed3;
        }

        if (!fnRegQuerySz(hFaxMethodKey, TEXT("FriendlyName"), &szFriendlyName)) {
            fnWriteLogFile(TEXT("\n\t<result value=\"0\">Could not query the Registry Value %s, ec = 0x%08x.</result>\r\n"), TEXT("FriendlyName"), GetLastError());
            goto RegFailed4;
        }
        if (lstrcmp(ROUTEAPI_METHOD_FRIENDLYNAME2, szFriendlyName)!=0) {
            fnWriteLogFile(TEXT("\n\t<result value=\"0\">FriendlyName: Received: %s, Expected: %s.</result>\r\n"), szFriendlyName, ROUTEAPI_METHOD_FRIENDLYNAME2);
            goto RegFailed4;
        }
        HeapFree(g_hHeap, 0, szFriendlyName);

        if (!fnRegQuerySz(hFaxMethodKey, TEXT("Function Name"), &szFunctionName)) {
            fnWriteLogFile(TEXT("\n\t<result value=\"0\">Could not query the Registry Value %s, ec = 0x%08x.</result>\r\n"), TEXT("Function Name"), GetLastError());
            goto RegFailed4;
        }
        if (lstrcmp(ROUTEAPI_METHOD_FUNCTIONNAME2, szFunctionName)!=0) {
            fnWriteLogFile(TEXT("\n\t<result value=\"0\">Function Name: Received: %s, Expected: %s.</result>\r\n"), szFunctionName, ROUTEAPI_METHOD_FUNCTIONNAME2);
            goto RegFailed4;
        }
        HeapFree(g_hHeap, 0, szFunctionName);

        if (!fnRegQuerySz(hFaxMethodKey, TEXT("Guid"), &szGUID)) {
            fnWriteLogFile(TEXT("\n\t<result value=\"0\">Could not query the Registry Value %s, ec = 0x%08x.</result>\r\n"), TEXT("Guid"), GetLastError());
            goto RegFailed4;
        }
        if (lstrcmp(ROUTEAPI_METHOD_GUID2, szGUID)!=0) {
            fnWriteLogFile(TEXT("\n\t<result value=\"0\">Guid: Received: %s, Expected: %s.</result>\r\n"), szGUID, ROUTEAPI_METHOD_GUID2);
            goto RegFailed4;
        }
        HeapFree(g_hHeap, 0, szGUID);

        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
		fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));

goto RegFailed0;
RegFailed4:
        RegCloseKey(hFaxMethodKey);
	    RegDeleteKey(hFaxRoutingMethodsKey, ROUTEAPI_METHOD2);

RegFailed3:
        RegCloseKey(hFaxRoutingMethodsKey);
	    RegDeleteKey(hFaxExtensionKey, FAX_ROUTINGMETHODS_REGKEY);

RegFailed2:
        RegCloseKey(hFaxExtensionKey);
        RegDeleteKey(hFaxRoutingExtensionsKey, ROUTEAPI_EXTENSION);

RegFailed1:
        RegCloseKey(hFaxRoutingExtensionsKey);
    }

RegFailed0:
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    dwIndex = 0;
    fnWriteLogFile(TEXT("hFaxSvcHandle = NULL.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"hFaxSvcHandle = NULL\" id=\"%d\">"), *pnNumCasesAttempted);

    if (g_ApiInterface.FaxRegisterRoutingExtension(NULL, ROUTEAPI_EXTENSION_W, ROUTEAPI_EXTENSION_FRIENDLYNAME_W, ROUTEAPI_EXTENSION_IMAGENAME_W, fnRouteApiExtensionCallback, &dwIndex)) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxRegisterRoutingExtension() returned TRUE.  This is an error.  FaxRegisterRoutingExtension() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).</result>\r\n"), ERROR_INVALID_HANDLE);
    }
    else if (GetLastError() != ERROR_INVALID_HANDLE) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">GetLastError() returned 0x%08x.  This is an error.  FaxRegisterRoutingExtension() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_HANDLE);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
		fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
    }
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    dwIndex = 0;
    fnWriteLogFile(TEXT("ROUTEAPI_EXTENSION = NULL.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"ROUTEAPI_EXTENSION = NULL\" id=\"%d\">"), *pnNumCasesAttempted);

    if (g_ApiInterface.FaxRegisterRoutingExtension(hFaxSvcHandle, NULL, ROUTEAPI_EXTENSION_FRIENDLYNAME_W, ROUTEAPI_EXTENSION_IMAGENAME_W, fnRouteApiExtensionCallback, &dwIndex)) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxRegisterRoutingExtension() returned TRUE.  This is an error.  FaxRegisterRoutingExtension() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).</result>\r\n"), ERROR_INVALID_PARAMETER);
    }
    else if (GetLastError() != ERROR_INVALID_PARAMETER) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">GetLastError() returned 0x%08x.  This is an error.  FaxRegisterRoutingExtension() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
		fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
    }
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    dwIndex = 0;
    fnWriteLogFile(TEXT("ROUTEAPI_EXTENSION_FRIENDLYNAME = NULL.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"ROUTEAPI_EXTENSION_FRIENDLYNAME = NULL\" id=\"%d\">"), *pnNumCasesAttempted);

    if (g_ApiInterface.FaxRegisterRoutingExtension(hFaxSvcHandle, ROUTEAPI_EXTENSION_W, NULL, ROUTEAPI_EXTENSION_IMAGENAME_W, fnRouteApiExtensionCallback, &dwIndex)) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxRegisterRoutingExtension() returned TRUE.  This is an error.  FaxRegisterRoutingExtension() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).</result>\r\n"), ERROR_INVALID_PARAMETER);
    }
    else if (GetLastError() != ERROR_INVALID_PARAMETER) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">GetLastError() returned 0x%08x.  This is an error.  FaxRegisterRoutingExtension() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
		fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
    }
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    dwIndex = 0;
    fnWriteLogFile(TEXT("ROUTEAPI_EXTENSION_IMAGENAME = NULL.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"ROUTEAPI_EXTENSION_IMAGENAME = NULL\" id=\"%d\">"), *pnNumCasesAttempted);

    if (g_ApiInterface.FaxRegisterRoutingExtension(hFaxSvcHandle, ROUTEAPI_EXTENSION_W, ROUTEAPI_EXTENSION_FRIENDLYNAME_W, NULL, fnRouteApiExtensionCallback, &dwIndex)) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxRegisterRoutingExtension() returned TRUE.  This is an error.  FaxRegisterRoutingExtension() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).</result>\r\n"), ERROR_INVALID_PARAMETER);
    }
    else if (GetLastError() != ERROR_INVALID_PARAMETER) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">GetLastError() returned 0x%08x.  This is an error.  FaxRegisterRoutingExtension() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
		fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
    }
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    dwIndex = 0;
    fnWriteLogFile(TEXT("fnRouteApiExtensionCallback = NULL.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"fnRouteApiExtensionCallback = NULL\" id=\"%d\">"), *pnNumCasesAttempted);

    if (g_ApiInterface.FaxRegisterRoutingExtension(hFaxSvcHandle, ROUTEAPI_EXTENSION_W, ROUTEAPI_EXTENSION_FRIENDLYNAME_W, ROUTEAPI_EXTENSION_IMAGENAME_W, NULL, &dwIndex)) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxRegisterRoutingExtension() returned TRUE.  This is an error.  FaxRegisterRoutingExtension() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).</result>\r\n"), ERROR_INVALID_PARAMETER);
    }
    else if (GetLastError() != ERROR_INVALID_PARAMETER) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">GetLastError() returned 0x%08x.  This is an error.  FaxRegisterRoutingExtension() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
		fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
    }
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

    // Disconnect from the fax server
    g_ApiInterface.FaxClose(hFaxSvcHandle);

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    dwIndex = 0;
    fnWriteLogFile(TEXT("Invalid hFaxSvcHandle (fax server not connected).  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"Invalid hFaxSvcHandle (fax server not connected)\" id=\"%d\">"), *pnNumCasesAttempted);

    if (g_ApiInterface.FaxRegisterRoutingExtension(hFaxSvcHandle, ROUTEAPI_EXTENSION_W, ROUTEAPI_EXTENSION_FRIENDLYNAME_W, ROUTEAPI_EXTENSION_IMAGENAME_W, fnRouteApiExtensionCallback, &dwIndex)) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxRegisterRoutingExtension() returned TRUE.  This is an error.  FaxRegisterRoutingExtension() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).</result>\r\n"), ERROR_INVALID_HANDLE);
    }
    else if (GetLastError() != ERROR_INVALID_HANDLE) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">GetLastError() returned 0x%08x.  This is an error.  FaxRegisterRoutingExtension() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_HANDLE);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
		fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
    }
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

    //if (szServerName) {
	//	fnWriteLogFile(TEXT("WHIS> SERVER CASE(s):\r\n"));
        // Connect to the fax server
      //  if (!g_ApiInterface.FaxConnectFaxServer(szServerName, &hFaxSvcHandle)) {
        //    return;
        //}

    //    (*pnNumCasesAttempted)++;

    //    dwIndex = 0;
    //    fnWriteLogFile(TEXT("Remote hFaxSvcHandle.  Test Case: %d.\r\n"), *pnNumCasesAttempted);

    //    if (g_ApiInterface.FaxRegisterRoutingExtension(hFaxSvcHandle, ROUTEAPI_EXTENSION_W, ROUTEAPI_EXTENSION_FRIENDLYNAME_W, ROUTEAPI_EXTENSION_IMAGENAME_W, fnRouteApiExtensionCallback, &dwIndex)) {
    //        fnWriteLogFile(TEXT("FaxRegisterRoutingExtension() returned TRUE.  This is an error.  FaxRegisterRoutingExtension() should return FALSE and GetLastError() should return ERROR_INVALID_FUNCTION (0x%08x).\r\n"), ERROR_INVALID_FUNCTION);
    //    }
    //    else if (GetLastError() != ERROR_INVALID_FUNCTION) {
    //        fnWriteLogFile(TEXT("GetLastError() returned 0x%08x.  This is an error.  FaxRegisterRoutingExtension() should return FALSE and GetLastError() should return ERROR_INVALID_FUNCTION (0x%08x).\r\n"), GetLastError(), ERROR_INVALID_FUNCTION);
    //    }
    //    else {
    //        (*pnNumCasesPassed)++;


    //    }

    // Disconnect from the fax server
    //    g_ApiInterface.FaxClose(hFaxSvcHandle);
    //}


	fnWriteLogFile(TEXT("$$$ Summery for FaxRegisterRoutingExtension, Attempt %d, Pass %d, Fail %d\n"),dwFuncCasesAtt,dwFuncCasesPass,dwFuncCasesAtt-dwFuncCasesPass);
	fnWriteLogFile(TEXT("\n\t<summary attempt=\"%d\" pass=\"%d\" fail=\"%d\"></summary>\n"),dwFuncCasesAtt,dwFuncCasesPass,dwFuncCasesAtt-dwFuncCasesPass);
	fnWriteLogFile(TEXT("\n\t</function>"));
	

    
	
	// un registration...
	if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, FAX_ROUTINGEXTENSIONS_REGKEY, 0, KEY_ALL_ACCESS, &hFaxRoutingExtensionsKey)) {
		return;
    }

    if (RegOpenKeyEx(hFaxRoutingExtensionsKey, ROUTEAPI_EXTENSION, 0, KEY_ALL_ACCESS, &hFaxExtensionKey)) {
        RegCloseKey(hFaxRoutingExtensionsKey);
        return;
    }

    if (RegOpenKeyEx(hFaxExtensionKey, FAX_ROUTINGMETHODS_REGKEY, 0, KEY_ALL_ACCESS, &hFaxRoutingMethodsKey)) {
        RegCloseKey(hFaxExtensionKey);
        RegDeleteKey(hFaxRoutingExtensionsKey, ROUTEAPI_EXTENSION);
        RegCloseKey(hFaxRoutingExtensionsKey);
        return;
    }

//    RegDeleteKey(hFaxRoutingMethodsKey, ROUTEAPI_METHOD1);
//    RegDeleteKey(hFaxRoutingMethodsKey, ROUTEAPI_METHOD2);
      RegCloseKey(hFaxRoutingMethodsKey);
//    RegDeleteKey(hFaxExtensionKey, FAX_ROUTINGMETHODS_REGKEY);
	  RegCloseKey(hFaxExtensionKey);
//    RegDeleteKey(hFaxRoutingExtensionsKey, ROUTEAPI_EXTENSION);
      RegCloseKey(hFaxRoutingExtensionsKey);
	  return;
}

BOOL
fnStopFaxSvc(
)
/*++

Routine Description:

  Stops the fax service

Return Value:

  TRUE on success

--*/
{
    HANDLE          hManager = NULL;
    HANDLE          hService = NULL;
    SERVICE_STATUS  ServiceStatus;

	fnWriteLogFile(TEXT("<function name=\"_utils(StopFaxSvc)\">"));

    // Open the service control manager
    hManager = OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_ALL_ACCESS);
    // Open the service
    hService = OpenService(hManager, FAX_SERVICE, SERVICE_ALL_ACCESS);

    // Query the service status
    ZeroMemory(&ServiceStatus, sizeof(SERVICE_STATUS));
    if (!QueryServiceStatus(hService, &ServiceStatus)) {
        CloseServiceHandle(hService);
        CloseServiceHandle(hManager);
        fnWriteLogFile(TEXT("QueryServiceStatus() failed, ec = 0x%08x.\r\n"), GetLastError());
		fnWriteLogFile(TEXT("\n\t<summary attempt=\"-1\" pass=\"-1\" fail=\"-1\"></summary>\n"));
		fnWriteLogFile(TEXT("\n\t</function>"));
        return FALSE;
    }

    if (ServiceStatus.dwCurrentState == SERVICE_STOPPED) {
        // Service is stopped
        // Return TRUE
		fnWriteLogFile(TEXT("\n\t<summary attempt=\"0\" pass=\"0\" fail=\"0\"></summary>\n"));
		fnWriteLogFile(TEXT("\n\t</function>"));
        return TRUE;
    }

    // Stop the service
    if (!ControlService(hService, SERVICE_CONTROL_STOP, &ServiceStatus)) {
        CloseServiceHandle(hService);
        CloseServiceHandle(hManager);
        fnWriteLogFile(TEXT("ControlService() failed, ec = 0x%08x.\r\n"), GetLastError());
		fnWriteLogFile(TEXT("\n\t<summary attempt=\"-1\" pass=\"-1\" fail=\"-1\"></summary>\n"));
		fnWriteLogFile(TEXT("\n\t</function>"));
        return FALSE;
    }

    // Wait until the service is stopped
    ZeroMemory(&ServiceStatus, sizeof(SERVICE_STATUS));
    while (ServiceStatus.dwCurrentState != SERVICE_STOPPED) {
        Sleep(1000);

        // Query the service status
        if (!QueryServiceStatus(hService, &ServiceStatus)) {
            CloseServiceHandle(hService);
            CloseServiceHandle(hManager);
            fnWriteLogFile(TEXT("QueryServiceStatus() failed, ec = 0x%08x.\r\n"), GetLastError());
			fnWriteLogFile(TEXT("\n\t<summary attempt=\"-1\" pass=\"-1\" fail=\"-1\"></summary>\n"));
			fnWriteLogFile(TEXT("\n\t</function>"));
            return FALSE;
        }

        // Verify the service is stopped or stopping
        if (!((ServiceStatus.dwCurrentState == SERVICE_STOPPED) || (ServiceStatus.dwCurrentState == SERVICE_STOP_PENDING))) {
            CloseServiceHandle(hService);
            CloseServiceHandle(hManager);
            fnWriteLogFile(TEXT("The Fax Service is in an unexpected state.  dwCurrentState: 0x%08x.\r\n"), ServiceStatus.dwCurrentState);
			fnWriteLogFile(TEXT("\n\t<summary attempt=\"-1\" pass=\"-1\" fail=\"-1\"></summary>\n"));
			fnWriteLogFile(TEXT("\n\t</function>"));
            return FALSE;
        }
    }

    Sleep(1000);

    CloseServiceHandle(hService);
    CloseServiceHandle(hManager);
	fnWriteLogFile(TEXT("\n\t<summary attempt=\"0\" pass=\"0\" fail=\"0\"></summary>\n"));
	fnWriteLogFile(TEXT("\n\t</function>"));
    return TRUE;
}

VOID
fnAddRouteApiExtension(
)
/*++

Routine Description:

  Adds the Microsoft Routing Extension

Return Value:

  None

--*/
{
    // szRouteApiDll is the route api dll
    TCHAR   szRouteApiDll[MAX_PATH];

    // hFaxSvcHandle is the handle to the fax server
    HANDLE  hFaxSvcHandle;
    DWORD   dwIndex = 0;

	fnWriteLogFile(TEXT("<function name=\"_utils(AddRouteApiExtension)\">"));

    ExpandEnvironmentStrings(ROUTEAPI_EXTENSION_IMAGENAME, szRouteApiDll, sizeof(szRouteApiDll) / sizeof(TCHAR));
    if (!lstrcmpi(ROUTEAPI_EXTENSION_IMAGENAME, szRouteApiDll)) {
		fnWriteLogFile(TEXT("WHIS> Test Error: ROUTEAPI_EXTENSION_IMAGENAME and szRouteApiDll are not the same, The error code is 0x%08x\r\n"),GetLastError());
		fnWriteLogFile(TEXT("\n\t<summary attempt=\"-1\" pass=\"-1\" fail=\"-1\"></summary>\n"));
		fnWriteLogFile(TEXT("\n\t</function>"));
		return;
    }

    // Copy the FaxRcv dll
    if (!CopyFile(ROUTEAPI_EXTENSION_DLLNAME, szRouteApiDll, FALSE)) {
		fnWriteLogFile(TEXT("WHIS> Test Error: Could not copy routing extension file to system directory, The error code is 0x%08x\r\n"),GetLastError());
		fnWriteLogFile(TEXT("\n\t<summary attempt=\"-1\" pass=\"-1\" fail=\"-1\"></summary>\n"));
		fnWriteLogFile(TEXT("\n\t</function>"));
		return;
    }

    // Connect to the fax server
    g_ApiInterface.FaxConnectFaxServer(NULL, &hFaxSvcHandle);

    g_ApiInterface.FaxRegisterRoutingExtension(hFaxSvcHandle, ROUTEAPI_EXTENSION_W, ROUTEAPI_EXTENSION_FRIENDLYNAME_W, ROUTEAPI_EXTENSION_IMAGENAME_W, fnRouteApiExtensionCallback, &dwIndex);

    // Disconnect from the fax server
    g_ApiInterface.FaxClose(hFaxSvcHandle);
	fnWriteLogFile(TEXT("\n\t<summary attempt=\"0\" pass=\"0\" fail=\"0\"></summary>\n"));
	fnWriteLogFile(TEXT("\n\t</function>"));
}

VOID
fnRemoveRouteApiExtension(
)
/*++

Routine Description:

  Removes the RouteApi Routing Extension

Return Value:

  None

--*/
{
    // hFaxRoutingExtensionsKey is the handle to the fax routing extensions registry key
    HKEY  hFaxRoutingExtensionsKey;
    // hFaxExtensionKey is the handle to the fax extension registry key
    HKEY  hFaxExtensionKey;
    // hFaxRoutingMethodsKey is the handle to the fax routing methods registry key
    HKEY  hFaxRoutingMethodsKey;

	// internat Attempt/Pass counters (to display EVAL)
	DWORD			dwFuncCasesAtt=0;
	DWORD			dwFuncCasesPass=0;

	fnWriteLogFile(TEXT("<function name=\"_utils(RemoveRouteApiExtension)\">"));

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, FAX_ROUTINGEXTENSIONS_REGKEY, 0, KEY_ALL_ACCESS, &hFaxRoutingExtensionsKey)) {
		fnWriteLogFile(TEXT("\n\t<summary attempt=\"-1\" pass=\"-1\" fail=\"-1\"></summary>\n"));
		fnWriteLogFile(TEXT("\n\t</function>"));
        return;
    }

    if (RegOpenKeyEx(hFaxRoutingExtensionsKey, ROUTEAPI_EXTENSION, 0, KEY_ALL_ACCESS, &hFaxExtensionKey)) {
        RegCloseKey(hFaxRoutingExtensionsKey);
		fnWriteLogFile(TEXT("\n\t<summary attempt=\"-1\" pass=\"-1\" fail=\"-1\"></summary>\n"));
		fnWriteLogFile(TEXT("\n\t</function>"));
        return;
    }

    if (RegOpenKeyEx(hFaxExtensionKey, FAX_ROUTINGMETHODS_REGKEY, 0, KEY_ALL_ACCESS, &hFaxRoutingMethodsKey)) {
        RegCloseKey(hFaxExtensionKey);
        RegDeleteKey(hFaxRoutingExtensionsKey, ROUTEAPI_EXTENSION);
        RegCloseKey(hFaxRoutingExtensionsKey);
		fnWriteLogFile(TEXT("\n\t<summary attempt=\"-1\" pass=\"-1\" fail=\"-1\"></summary>\n"));
		fnWriteLogFile(TEXT("\n\t</function>"));
        return;
    }

    RegDeleteKey(hFaxRoutingMethodsKey, ROUTEAPI_METHOD1);
    RegDeleteKey(hFaxRoutingMethodsKey, ROUTEAPI_METHOD2);
    RegCloseKey(hFaxRoutingMethodsKey);
    RegDeleteKey(hFaxExtensionKey, FAX_ROUTINGMETHODS_REGKEY);
    RegCloseKey(hFaxExtensionKey);
    RegDeleteKey(hFaxRoutingExtensionsKey, ROUTEAPI_EXTENSION);
    RegCloseKey(hFaxRoutingExtensionsKey);
	fnWriteLogFile(TEXT("\n\t<summary attempt=\"0\" pass=\"0\" fail=\"0\"></summary>\n"));
	fnWriteLogFile(TEXT("\n\t</function>"));
}

VOID
fnFaxEnumGlobalRoutingInfo(
    LPCTSTR  szServerName,
    PUINT    pnNumCasesAttempted,
    PUINT    pnNumCasesPassed
)
/*++

Routine Description:

  FaxEnumGlobalRoutingInfo()

Return Value:

  None

--*/
{
    // hFaxSvcHandle is the handle to the fax server
    HANDLE                    hFaxSvcHandle;
    // pRoutingInfo is the pointer to the global routing structures
    PFAX_GLOBAL_ROUTING_INFO  pRoutingInfo;
    // dwNumMethods is the number of routing methods
    DWORD                     dwNumMethods;

    // szRouteApiDll is the route api dll
    TCHAR                     szRouteApiDll[MAX_PATH];

    DWORD                     dwIndex;

	TCHAR					szPreDefinedValue[MAX_PATH];

	// internat Attempt/Pass counters (to display EVAL)
	DWORD			dwFuncCasesAtt=0;
	DWORD			dwFuncCasesPass=0;



	fnWriteLogFile(TEXT(  "\n--------------------------"));
    fnWriteLogFile(TEXT("### FaxEnumGlobalRoutingInfo().\r\n"));
	fnWriteLogFile(TEXT("\n\t<function name=\"FaxEnumGlobalRoutingInfo\">"));

   // Connect to the fax server
    if (!g_ApiInterface.FaxConnectFaxServer(szServerName, &hFaxSvcHandle)) {
		fnWriteLogFile(TEXT("WHIS> ERROR: Can not connect to fax server %s, The error code is 0x%08x.\r\n"),szServerName, GetLastError());
		fnWriteLogFile(TEXT("\n\t<summary attempt=\"-1\" pass=\"-1\" fail=\"-1\"></summary>\n"));
		fnWriteLogFile(TEXT("\n\t</function>"));
        return;
    }
	else
	{
		fnWriteLogFile(TEXT("WHIS> Connected to fax server %s. \r\n"),szServerName);
	}

    for (dwIndex = 0; dwIndex < 2; dwIndex++) {
        // Enumerate the routing extension global info
        (*pnNumCasesAttempted)++;
		dwFuncCasesAtt++;

        fnWriteLogFile(TEXT("Valid Case.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
		fnWriteLogFile(TEXT("\n\t<case name=\"Valid Case\" id=\"%d\">"), *pnNumCasesAttempted);

        if (!g_ApiInterface.FaxEnumGlobalRoutingInfo(hFaxSvcHandle, &pRoutingInfo, &dwNumMethods)) {
            fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxEnumGlobalRoutingInfo() failed.  The error code is 0x%08x.  This is an error.  FaxEnumGlobalRoutingInfo() should succeed.</result>\r\n"), GetLastError());
        }
        else {
            if (pRoutingInfo == NULL) {
                fnWriteLogFile(TEXT("\n\t<result value=\"0\">pRoutingInfo is NULL.  This is an error.  pRoutingInfo should not be NULL.</result>\r\n"));
            }
			if (dwNumMethods != g_dwNumMethods) {
                fnWriteLogFile(TEXT("\n\t<result value=\"0\">dwNumMethods is not g_dwNumMethods.  This is an error.  dwNumMethods should be g_dwNumMethods.</result>\r\n"));
            }

			if ((pRoutingInfo != NULL) && (dwNumMethods == g_dwNumMethods)) {

				if (pRoutingInfo[g_dwIndexAPIMethod1].SizeOfStruct != sizeof(FAX_GLOBAL_ROUTING_INFO)) {
                    fnWriteLogFile(TEXT("\n\t<result value=\"0\">SizeOfStruct: Received: %d, Expected: %d.</result>\r\n"), pRoutingInfo[g_dwIndexAPIMethod1].SizeOfStruct, sizeof(FAX_GLOBAL_ROUTING_INFO));
                    goto FuncFailed;
                }

                if (pRoutingInfo[g_dwIndexAPIMethod1].Priority != g_dwNumMethods-1) {
                    fnWriteLogFile(TEXT("\n\t<result value=\"0\">Priority: Received: %d, Expected: g_dwNumMethods-1.</result>\r\n"), pRoutingInfo[g_dwIndexAPIMethod1].Priority);
                    goto FuncFailed;
                }
				
				if (lstrcmp(pRoutingInfo[g_dwIndexAPIMethod1].Guid,ROUTEAPI_METHOD_GUID1)!=0) {
                    fnWriteLogFile(TEXT("\n\t<result value=\"0\">Guid: Received: %s, Expected: %s.</result>\r\n"), pRoutingInfo[g_dwIndexAPIMethod1].Guid, ROUTEAPI_METHOD_GUID1);
                    goto FuncFailed;
                }

                if (lstrcmp(pRoutingInfo[g_dwIndexAPIMethod1].FriendlyName, ROUTEAPI_METHOD_FRIENDLYNAME1)!=0) {
                    fnWriteLogFile(TEXT("\n\t<result value=\"0\">FriendlyName: Received: %s, Expected: %s.</result>\r\n"), pRoutingInfo[g_dwIndexAPIMethod1].FriendlyName, ROUTEAPI_METHOD_FRIENDLYNAME1);
                    goto FuncFailed;
                }

                if (lstrcmp(pRoutingInfo[g_dwIndexAPIMethod1].FunctionName, ROUTEAPI_METHOD_FUNCTIONNAME1)!=0) {
                    fnWriteLogFile(TEXT("\n\t<result value=\"0\">FunctionName: Received: %s, Expected: %s.</result>\r\n"), pRoutingInfo[g_dwIndexAPIMethod1].FunctionName, ROUTEAPI_METHOD_FUNCTIONNAME1);
                    goto FuncFailed;
                }

                ExpandEnvironmentStrings(ROUTEAPI_EXTENSION_IMAGENAME, szRouteApiDll, sizeof(szRouteApiDll) / sizeof(TCHAR));
                if (lstrcmp(pRoutingInfo[g_dwIndexAPIMethod1].ExtensionImageName, szRouteApiDll)!=0) {
                    fnWriteLogFile(TEXT("\n\t<result value=\"0\">ExtensionImageName: Received: %s, Expected: %s.</result>\r\n"), pRoutingInfo[g_dwIndexAPIMethod1].ExtensionImageName, szRouteApiDll);
                    goto FuncFailed;
                }

                if (lstrcmp(pRoutingInfo[g_dwIndexAPIMethod1].ExtensionFriendlyName, ROUTEAPI_EXTENSION_FRIENDLYNAME)!=0) {
                    fnWriteLogFile(TEXT("\n\t<result value=\"0\">ExtensionFriendlyName: Received: %s, Expected: %s.</result>\r\n"), pRoutingInfo[g_dwIndexAPIMethod1].ExtensionFriendlyName, ROUTEAPI_EXTENSION_FRIENDLYNAME);
                    goto FuncFailed;
                }

                if (pRoutingInfo[g_dwIndexAPIMethod2].SizeOfStruct != sizeof(FAX_GLOBAL_ROUTING_INFO)!=0) {
                    fnWriteLogFile(TEXT("\n\t<result value=\"0\">SizeOfStruct: Received: %d, Expected: %d.</result>\r\n"), pRoutingInfo[g_dwIndexAPIMethod2].SizeOfStruct, sizeof(FAX_GLOBAL_ROUTING_INFO));
                    goto FuncFailed;
                }

                if (pRoutingInfo[g_dwIndexAPIMethod2].Priority != g_dwNumMethods) {
                    fnWriteLogFile(TEXT("\n\t<result value=\"0\">Priority: Received: %d, Expected: g_dwNumMethods.</result>\r\n"), pRoutingInfo[g_dwIndexAPIMethod2].Priority);
                    goto FuncFailed;
                }

                if (lstrcmp(pRoutingInfo[g_dwIndexAPIMethod2].Guid, ROUTEAPI_METHOD_GUID2)!=0) {
                    fnWriteLogFile(TEXT("\n\t<result value=\"0\">Guid: Received: %s, Expected: %s.</result>\r\n"), pRoutingInfo[g_dwIndexAPIMethod2].Guid, ROUTEAPI_METHOD_GUID2);
                    goto FuncFailed;
                }

                if (lstrcmp(pRoutingInfo[g_dwIndexAPIMethod2].FriendlyName, ROUTEAPI_METHOD_FRIENDLYNAME2)!=0) {
                    fnWriteLogFile(TEXT("\n\t<result value=\"0\">FriendlyName: Received: %s, Expected: %s.</result>\r\n"), pRoutingInfo[g_dwIndexAPIMethod2].FriendlyName, ROUTEAPI_METHOD_FRIENDLYNAME2);
                    goto FuncFailed;
                }

                if (lstrcmp(pRoutingInfo[g_dwIndexAPIMethod2].FunctionName, ROUTEAPI_METHOD_FUNCTIONNAME2)!=0) {
                    fnWriteLogFile(TEXT("\n\t<result value=\"0\">FunctionName: Received: %s, Expected: %s.</result>\r\n"), pRoutingInfo[g_dwIndexAPIMethod2].FunctionName, ROUTEAPI_METHOD_FUNCTIONNAME2);
                    goto FuncFailed;
                }

                ExpandEnvironmentStrings(ROUTEAPI_EXTENSION_IMAGENAME, szRouteApiDll, sizeof(szRouteApiDll) / sizeof(TCHAR));
                if (lstrcmp(pRoutingInfo[g_dwIndexAPIMethod2].ExtensionImageName, szRouteApiDll)!=0) {
                    fnWriteLogFile(TEXT("\n\t<result value=\"0\">ExtensionImageName: Received: %s, Expected: %s.</result>\r\n"), pRoutingInfo[g_dwIndexAPIMethod2].ExtensionImageName, szRouteApiDll);
                    goto FuncFailed;
                }

                if (lstrcmp(pRoutingInfo[g_dwIndexAPIMethod2].ExtensionFriendlyName, ROUTEAPI_EXTENSION_FRIENDLYNAME)!=0) {
                    fnWriteLogFile(TEXT("\n\t<result value=\"0\">ExtensionFriendlyName: Received: %s, Expected: %s.</result>\r\n"), pRoutingInfo[g_dwIndexAPIMethod2].ExtensionFriendlyName, ROUTEAPI_EXTENSION_FRIENDLYNAME);
                    goto FuncFailed;
                }

                (*pnNumCasesPassed)++;
				dwFuncCasesPass++;
				fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
            }

FuncFailed:
            g_ApiInterface.FaxFreeBuffer(pRoutingInfo);
        }
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));
    }
	

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("hFaxSvcHandle = NULL.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"hFaxSvcHandle = NULL\" id=\"%d\">"), *pnNumCasesAttempted);

    if (g_ApiInterface.FaxEnumGlobalRoutingInfo(NULL, &pRoutingInfo, &dwNumMethods)) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxEnumGlobalRoutingInfo() returned TRUE.  This is an error.  FaxEnumGlobalRoutingInfo() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).</result>\r\n"), ERROR_INVALID_HANDLE);
        g_ApiInterface.FaxFreeBuffer(pRoutingInfo);
    }
    else if (GetLastError() != ERROR_INVALID_HANDLE) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">GetLastError() returned 0x%08x.  This is an error.  FaxEnumGlobalRoutingInfo() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_HANDLE);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
		fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
    }
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("pRoutingInfo = NULL.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"pRoutingInfo = NULL\" id=\"%d\">"), *pnNumCasesAttempted);

    if (g_ApiInterface.FaxEnumGlobalRoutingInfo(hFaxSvcHandle, NULL, &dwNumMethods)) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxEnumGlobalRoutingInfo() returned TRUE.  This is an error.  FaxEnumGlobalRoutingInfo() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).</result>\r\n"), ERROR_INVALID_PARAMETER);
        g_ApiInterface.FaxFreeBuffer(pRoutingInfo);
    }
    else if (GetLastError() != ERROR_INVALID_PARAMETER) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">GetLastError() returned 0x%08x.  This is an error.  FaxEnumGlobalRoutingInfo() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
		fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
    }
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("dwNumMethods = NULL.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"dwNumMethods = NULL\" id=\"%d\">"), *pnNumCasesAttempted);

    if (g_ApiInterface.FaxEnumGlobalRoutingInfo(hFaxSvcHandle, &pRoutingInfo, NULL)) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxEnumGlobalRoutingInfo() returned TRUE.  This is an error.  FaxEnumGlobalRoutingInfo() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).</result>\r\n"), ERROR_INVALID_PARAMETER);
        g_ApiInterface.FaxFreeBuffer(pRoutingInfo);
    }
    else if (GetLastError() != ERROR_INVALID_PARAMETER) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">GetLastError() returned 0x%08x.  This is an error.  FaxEnumGlobalRoutingInfo() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
		fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
    }
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

    // Disconnect from the fax server
    g_ApiInterface.FaxClose(hFaxSvcHandle);

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("Invalid hFaxSvcHandle.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"Invalid hFaxSvcHandle\" id=\"%d\">"), *pnNumCasesAttempted);

    if (g_ApiInterface.FaxEnumGlobalRoutingInfo(hFaxSvcHandle, &pRoutingInfo, NULL)) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxEnumGlobalRoutingInfo() returned TRUE.  This is an error.  FaxEnumGlobalRoutingInfo() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).</result>\r\n"), ERROR_INVALID_HANDLE);
        g_ApiInterface.FaxFreeBuffer(pRoutingInfo);
    }
    else if (GetLastError() != ERROR_INVALID_HANDLE) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">GetLastError() returned 0x%08x.  This is an error.  FaxEnumGlobalRoutingInfo() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_HANDLE);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
		fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
    }
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

//    if (szServerName) {
//		fnWriteLogFile(TEXT("WHIS> SERVER CASE(s):\r\n"));
        // Connect to the fax server
//        if (!g_ApiInterface.FaxConnectFaxServer(szServerName, &hFaxSvcHandle)) {
//            return;
        //}

        //(*pnNumCasesAttempted)++;

        //fnWriteLogFile(TEXT("Remote hFaxSvcHandle.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
        //if (!g_ApiInterface.FaxEnumGlobalRoutingInfo(hFaxSvcHandle, &pRoutingInfo, &dwNumMethods)) {
          //  fnWriteLogFile(TEXT("FaxEnumGlobalRoutingInfo() failed.  The error code is 0x%08x.  This is an error.  FaxEnumGlobalRoutingInfo() should succeed.\r\n"), GetLastError());
        //}
        //else {
          //  g_ApiInterface.FaxFreeBuffer(pRoutingInfo);
//            (*pnNumCasesPassed)++;


  //      }

        // Disconnect from the fax server
    //    g_ApiInterface.FaxClose(hFaxSvcHandle);
    //}
fnWriteLogFile(TEXT("$$$ Summery for FaxEnumGlobalRoutingMethods, Attempt %d, Pass %d, Fail %d\n"),dwFuncCasesAtt,dwFuncCasesPass,dwFuncCasesAtt-dwFuncCasesPass);
fnWriteLogFile(TEXT("\n\t<summary attempt=\"%d\" pass=\"%d\" fail=\"%d\"></summary>\n"),dwFuncCasesAtt,dwFuncCasesPass,dwFuncCasesAtt-dwFuncCasesPass);
fnWriteLogFile(TEXT("\n\t</function>"));
}

VOID
fnFaxSetGlobalRoutingInfo(
    LPCTSTR  szServerName,
    PUINT    pnNumCasesAttempted,
    PUINT    pnNumCasesPassed,
	BOOL	 bTestLimits
)
/*++

Routine Description:

  FaxSetGlobalRoutingInfo()

Return Value:

  None

--*/
{
    // hFaxSvcHandle is the handle to the fax server
    HANDLE                    hFaxSvcHandle;
    // pRoutingInfo is the pointer to the global routing structures
    PFAX_GLOBAL_ROUTING_INFO  pRoutingInfo;
    // dwNumMethods is the number of routing methods
    DWORD                     dwNumMethods;
    // szGUID is the copy of a routing method GUID
    LPTSTR                    szGUID;

    DWORD                     dwIndex;
    DWORD                     cb;
    DWORD                     dwOffset;
	DWORD					  dwWhisRoutingCounter;

	// internat Attempt/Pass counters (to display EVAL)
	DWORD			dwFuncCasesAtt=0;
	DWORD			dwFuncCasesPass=0;

	fnWriteLogFile(TEXT(  "\n--------------------------"));
    fnWriteLogFile(TEXT("### FaxSetGlobalRoutingInfo().\r\n"));
	fnWriteLogFile(TEXT("\n\t<function name=\"FaxSetGlobalRoutingInfo\">"));

    // Connect to the fax server
    if (!g_ApiInterface.FaxConnectFaxServer(szServerName, &hFaxSvcHandle)) {
		fnWriteLogFile(TEXT("WHIS> ERROR: Can not connect to fax server %s, The error code is 0x%08x.\r\n"),szServerName, GetLastError());
		fnWriteLogFile(TEXT("\n\t<summary attempt=\"-1\" pass=\"-1\" fail=\"-1\"></summary>\n"));
		fnWriteLogFile(TEXT("\n\t</function>"));
        return;
    }
	else
	{
		fnWriteLogFile(TEXT("WHIS> Connected to fax server %s. \r\n"),szServerName);
	}
    
	// Enumerate the routing extension global info
    if (!g_ApiInterface.FaxEnumGlobalRoutingInfo(hFaxSvcHandle, &pRoutingInfo, &dwNumMethods)) {
        fnWriteLogFile(TEXT("WHIS> (org test error) FaxEnumGlobalRoutingInfo() failed.  The error code is 0x%08x.  This is an error.  FaxEnumGlobalRoutingInfo() should succeed.\r\n"), GetLastError());
        // Disconnect from the fax server
        g_ApiInterface.FaxClose(hFaxSvcHandle);
		fnWriteLogFile(TEXT("\n\t<summary attempt=\"-1\" pass=\"-1\" fail=\"-1\"></summary>\n"));
		fnWriteLogFile(TEXT("\n\t</function>"));
        return;
    }

	
	pRoutingInfo[g_dwIndexAPIMethod1].Priority = g_dwNumMethods;
    pRoutingInfo[g_dwIndexAPIMethod2].Priority = g_dwNumMethods-1;

    // Set the routing extension global info
    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("Valid Case.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"Valid Case\" id=\"%d\">"), *pnNumCasesAttempted);

    if (!g_ApiInterface.FaxSetGlobalRoutingInfo(hFaxSvcHandle, &pRoutingInfo[g_dwIndexAPIMethod1])) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxSetGlobalRoutingInfo() failed.  The error code is 0x%08x.  This is an error.  FaxSetGlobalRoutingInfo() should succeed.</result>\r\n"), GetLastError());
    }
    else {
        if (!g_ApiInterface.FaxSetGlobalRoutingInfo(hFaxSvcHandle, &pRoutingInfo[g_dwIndexAPIMethod2])) {
            fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxSetGlobalRoutingInfo() failed.  The error code is 0x%08x.  This is an error.  FaxSetGlobalRoutingInfo() should succeed.</result>\r\n"), GetLastError());
        }
        else {
            g_ApiInterface.FaxFreeBuffer(pRoutingInfo);

            // Enumerate the routing extension global info
            g_ApiInterface.FaxEnumGlobalRoutingInfo(hFaxSvcHandle, &pRoutingInfo, &dwNumMethods);
            if (lstrcmp(pRoutingInfo[g_dwIndexAPIMethod1].Guid, ROUTEAPI_METHOD_GUID2)!=0) {
                fnWriteLogFile(TEXT("\n\t<result value=\"0\">Guid: Received: %s, Expected: %s.</result>\r\n"), pRoutingInfo[g_dwIndexAPIMethod1].Guid, ROUTEAPI_METHOD_GUID2);
                goto FuncFailed;
            }

            if (pRoutingInfo[g_dwIndexAPIMethod1].Priority != g_dwNumMethods-1) {
                fnWriteLogFile(TEXT("\n\t<result value=\"0\">Priority: Received: %d, Expected: g_dwNumMethods-1.</result>\r\n"), pRoutingInfo[g_dwIndexAPIMethod1].Priority);
                goto FuncFailed;
            }

            if (lstrcmp(pRoutingInfo[g_dwIndexAPIMethod2].Guid, ROUTEAPI_METHOD_GUID1)!=0) {
                fnWriteLogFile(TEXT("Guid: Received: %s, Expected: %s.\r\n"), pRoutingInfo[g_dwIndexAPIMethod2].Guid, ROUTEAPI_METHOD_GUID1);
                goto FuncFailed;
            }

            if (pRoutingInfo[g_dwIndexAPIMethod2].Priority != g_dwNumMethods) {
                fnWriteLogFile(TEXT("Priority: Received: %d, Expected: g_dwNumMethods.\r\n"), pRoutingInfo[g_dwIndexAPIMethod2].Priority);
                goto FuncFailed;
            }

            (*pnNumCasesPassed)++;
			dwFuncCasesPass++;
			fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));

FuncFailed:
            pRoutingInfo[g_dwIndexAPIMethod1].Priority = g_dwNumMethods-1;
            pRoutingInfo[g_dwIndexAPIMethod2].Priority = g_dwNumMethods;

            g_ApiInterface.FaxSetGlobalRoutingInfo(hFaxSvcHandle, &pRoutingInfo[g_dwIndexAPIMethod1]);
            g_ApiInterface.FaxSetGlobalRoutingInfo(hFaxSvcHandle, &pRoutingInfo[g_dwIndexAPIMethod2]);
            g_ApiInterface.FaxFreeBuffer(pRoutingInfo);
            g_ApiInterface.FaxEnumGlobalRoutingInfo(hFaxSvcHandle, &pRoutingInfo, &dwNumMethods);
        }
    }
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

    pRoutingInfo[g_dwIndexAPIMethod1].SizeOfStruct = 0;
    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("pRoutingInfo->SizeOfStruct = 0.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"pRoutingInfo->SizeOfStruct = 0\" id=\"%d\">"), *pnNumCasesAttempted);

    if (g_ApiInterface.FaxSetGlobalRoutingInfo(hFaxSvcHandle, &pRoutingInfo[g_dwIndexAPIMethod1])) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxSetGlobalRoutingInfo() returned TRUE.  This is an error.  FaxSetGlobalRoutingInfo() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).</result>\r\n"), ERROR_INVALID_PARAMETER);
    }
    else if (GetLastError() != ERROR_INVALID_PARAMETER) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">GetLastError() returned 0x%08x.  This is an error.  FaxSetGlobalRoutingInfo() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
		fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
    }
    pRoutingInfo[g_dwIndexAPIMethod1].SizeOfStruct = sizeof(FAX_GLOBAL_ROUTING_INFO);
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("hFaxSvcHandle = NULL.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"hFaxSvcHandle = NULL\" id=\"%d\">"), *pnNumCasesAttempted);

    if (g_ApiInterface.FaxSetGlobalRoutingInfo(NULL, &pRoutingInfo[g_dwIndexAPIMethod1])) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxSetGlobalRoutingInfo() returned TRUE.  This is an error.  FaxSetGlobalRoutingInfo() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).</result>\r\n"), ERROR_INVALID_HANDLE);
    }
    else if (GetLastError() != ERROR_INVALID_HANDLE) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">GetLastError() returned 0x%08x.  This is an error.  FaxSetGlobalRoutingInfo() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_HANDLE);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
		fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
    }
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("pRoutingInfo = NULL.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"pRoutingInfo = NULL\" id=\"%d\">"), *pnNumCasesAttempted);

    if (g_ApiInterface.FaxSetGlobalRoutingInfo(hFaxSvcHandle, NULL)) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxSetGlobalRoutingInfo() returned TRUE.  This is an error.  FaxSetGlobalRoutingInfo() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).</result>\r\n"), ERROR_INVALID_PARAMETER);
    }
    else if (GetLastError() != ERROR_INVALID_PARAMETER) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">GetLastError() returned 0x%08x.  This is an error.  FaxSetGlobalRoutingInfo() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
		fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
    }
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

    szGUID = HeapAlloc(g_hHeap, HEAP_GENERATE_EXCEPTIONS | HEAP_ZERO_MEMORY, (lstrlen(pRoutingInfo[g_dwIndexAPIMethod1].Guid) + 1) * sizeof(TCHAR));
    lstrcpy(szGUID, pRoutingInfo[g_dwIndexAPIMethod1].Guid);
    lstrcpy((LPTSTR) pRoutingInfo[g_dwIndexAPIMethod1].Guid, ROUTEAPI_INVALID_GUID);

	(*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

	fnWriteLogFile(TEXT("Invalid GUID.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"Invalid GUID\" id=\"%d\">"), *pnNumCasesAttempted);

	if (g_ApiInterface.FaxSetGlobalRoutingInfo(hFaxSvcHandle, &pRoutingInfo[g_dwIndexAPIMethod1])) {
		fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxSetGlobalRoutingInfo() returned TRUE.  This is an error.  FaxSetGlobalRoutingInfo() should return FALSE and GetLastError() should return ERROR_INVALID_DATA (0x%08x).</result>\r\n"), ERROR_INVALID_DATA);
	}
	else if (GetLastError() != ERROR_INVALID_DATA) {
		fnWriteLogFile(TEXT("\n\t<result value=\"0\">GetLastError() returned 0x%08x.  This is an error.  FaxSetGlobalRoutingInfo() should return FALSE and GetLastError() should return ERROR_INVALID_DATA (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_DATA);
	}
	else {
		(*pnNumCasesPassed)++;
		dwFuncCasesPass++;
		fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
	}
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

	if (bTestLimits)	{
		
		// limit values tested

		// priority=MAX_DWORD
		(*pnNumCasesAttempted)++;
		dwFuncCasesAtt++;

		fnWriteLogFile(TEXT("WHIS> LIMITS: Priotiry = MAX_DWORD.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
		fnWriteLogFile(TEXT("\n\t<case name=\"LIMITS: Priotiry = MAX_DWORD\" id=\"%d\">"), *pnNumCasesAttempted);

		pRoutingInfo[g_dwIndexAPIMethod1].Priority = MAX_DWORD;
		if (g_ApiInterface.FaxSetGlobalRoutingInfo(hFaxSvcHandle, &pRoutingInfo[g_dwIndexAPIMethod1])) {
			fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxSetGlobalRoutingInfo() returned TRUE.  This is an error.  FaxSetGlobalRoutingInfo() should return FALSE and GetLastError() should return ERROR_INVALID_DATA (0x%08x).</result>\r\n"), ERROR_INVALID_DATA);
		}
		else if (GetLastError() != ERROR_INVALID_DATA) {
			fnWriteLogFile(TEXT("\n\t<result value=\"0\">GetLastError() returned 0x%08x.  This is an error.  FaxSetGlobalRoutingInfo() should return FALSE and GetLastError() should return ERROR_INVALID_DATA (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_DATA);
		}
		else {
	        (*pnNumCasesPassed)++;
			dwFuncCasesPass++;
			fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
		}
		fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

	
		(*pnNumCasesAttempted)++;
		dwFuncCasesAtt++;

		fnWriteLogFile(TEXT("WHIS> LIMITS: FriendlyName=LONG_STRING  Test Case: %d.\r\n"), *pnNumCasesAttempted);
		fnWriteLogFile(TEXT("\n\t<case name=\"LIMITS: FriendlyName=LONG_STRING\" id=\"%d\">"), *pnNumCasesAttempted);

		pRoutingInfo[g_dwIndexAPIMethod1].FriendlyName = TEXT(LONG_STRING);
		if (g_ApiInterface.FaxSetGlobalRoutingInfo(hFaxSvcHandle, &pRoutingInfo[g_dwIndexAPIMethod1])) {
			fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxSetGlobalRoutingInfo() returned TRUE.  This is an error.  FaxSetGlobalRoutingInfo() should return FALSE and GetLastError() should return ERROR_INVALID_DATA (0x%08x).</result>\r\n"), ERROR_INVALID_DATA);
		}
	    else if (GetLastError() != ERROR_INVALID_DATA) {
	        fnWriteLogFile(TEXT("\n\t<result value=\"0\">GetLastError() returned 0x%08x.  This is an error.  FaxSetGlobalRoutingInfo() should return FALSE and GetLastError() should return ERROR_INVALID_DATA (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_DATA);
		}
		else {
			(*pnNumCasesPassed)++;
			dwFuncCasesPass++;
			fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
		}
		fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

		(*pnNumCasesAttempted)++;
		dwFuncCasesAtt++;

		fnWriteLogFile(TEXT("WHIS> LIMITS: FunctionName=LONG_STRING  Test Case: %d.\r\n"), *pnNumCasesAttempted);
		fnWriteLogFile(TEXT("\n\t<case name=\"LIMITS: FunctionName=LONG_STRING\" id=\"%d\">"), *pnNumCasesAttempted);

		pRoutingInfo[g_dwIndexAPIMethod1].FunctionName = TEXT(LONG_STRING);
		if (g_ApiInterface.FaxSetGlobalRoutingInfo(hFaxSvcHandle, &pRoutingInfo[g_dwIndexAPIMethod1])) {
			fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxSetGlobalRoutingInfo() returned TRUE.  This is an error.  FaxSetGlobalRoutingInfo() should return FALSE and GetLastError() should return ERROR_INVALID_DATA (0x%08x).</result>\r\n"), ERROR_INVALID_DATA);
		}
	    else if (GetLastError() != ERROR_INVALID_DATA) {
	        fnWriteLogFile(TEXT("\n\t<result value=\"0\">GetLastError() returned 0x%08x.  This is an error.  FaxSetGlobalRoutingInfo() should return FALSE and GetLastError() should return ERROR_INVALID_DATA (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_DATA);
		}
		else {
			(*pnNumCasesPassed)++;
			dwFuncCasesPass++;
			fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
		}
		fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

		(*pnNumCasesAttempted)++;
		dwFuncCasesAtt++;

	    fnWriteLogFile(TEXT("WHIS> LIMITS: ExtensionImageName=LONG_STRING  Test Case: %d.\r\n"), *pnNumCasesAttempted);
		fnWriteLogFile(TEXT("\n\t<case name=\"LIMITS: ExtensionImageName=LONG_STRING\" id=\"%d\">"), *pnNumCasesAttempted);

		pRoutingInfo[g_dwIndexAPIMethod1].ExtensionImageName = TEXT(LONG_STRING);
	    if (g_ApiInterface.FaxSetGlobalRoutingInfo(hFaxSvcHandle, &pRoutingInfo[g_dwIndexAPIMethod1])) {
	        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxSetGlobalRoutingInfo() returned TRUE.  This is an error.  FaxSetGlobalRoutingInfo() should return FALSE and GetLastError() should return ERROR_INVALID_DATA (0x%08x).</result>\r\n"), ERROR_INVALID_DATA);
		}
		else if (GetLastError() != ERROR_INVALID_DATA) {
		    fnWriteLogFile(TEXT("\n\t<result value=\"0\">GetLastError() returned 0x%08x.  This is an error.  FaxSetGlobalRoutingInfo() should return FALSE and GetLastError() should return ERROR_INVALID_DATA (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_DATA);
	    }
	    else {
	        (*pnNumCasesPassed)++;
			dwFuncCasesPass++;
			fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
		}
		fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

		(*pnNumCasesAttempted)++;
		dwFuncCasesAtt++;

		fnWriteLogFile(TEXT("WHIS> LIMITS: ExtensionFriendlyName=LONG_STRING  Test Case: %d.\r\n"), *pnNumCasesAttempted);
		fnWriteLogFile(TEXT("\n\t<case name=\"LIMITS: ExtensionFriendlyName=LONG_STRING\" id=\"%d\">"), *pnNumCasesAttempted);

		pRoutingInfo[g_dwIndexAPIMethod1].ExtensionFriendlyName = TEXT(LONG_STRING);
		if (g_ApiInterface.FaxSetGlobalRoutingInfo(hFaxSvcHandle, &pRoutingInfo[g_dwIndexAPIMethod1])) {
	        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxSetGlobalRoutingInfo() returned TRUE.  This is an error.  FaxSetGlobalRoutingInfo() should return FALSE and GetLastError() should return ERROR_INVALID_DATA (0x%08x).</result>\r\n"), ERROR_INVALID_DATA);
		}
		else if (GetLastError() != ERROR_INVALID_DATA) {
			fnWriteLogFile(TEXT("\n\t<result value=\"0\">GetLastError() returned 0x%08x.  This is an error.  FaxSetGlobalRoutingInfo() should return FALSE and GetLastError() should return ERROR_INVALID_DATA (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_DATA);
		}
		else {
			(*pnNumCasesPassed)++;
			dwFuncCasesPass++;
			fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
		}
		fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));
	}

    lstrcpy((LPTSTR) pRoutingInfo[g_dwIndexAPIMethod1].Guid, szGUID);
    HeapFree(g_hHeap, 0, szGUID);

    // Disconnect from the fax server
    g_ApiInterface.FaxClose(hFaxSvcHandle);

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("Invalid hFaxSvcHandle.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"Invalid hFaxSvcHandle\" id=\"%d\">"), *pnNumCasesAttempted);

    if (g_ApiInterface.FaxSetGlobalRoutingInfo(hFaxSvcHandle, &pRoutingInfo[g_dwIndexAPIMethod1])) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxSetGlobalRoutingInfo() returned TRUE.  This is an error.  FaxSetGlobalRoutingInfo() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).</result>\r\n"), ERROR_INVALID_HANDLE);
    }
    else if (GetLastError() != ERROR_INVALID_HANDLE) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">GetLastError() returned 0x%08x.  This is an error.  FaxSetGlobalRoutingInfo() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_HANDLE);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
		fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
    }
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

    g_ApiInterface.FaxFreeBuffer(pRoutingInfo);

    //if (szServerName) {
	//	fnWriteLogFile(TEXT("WHIS> SERVER CASE(s):\r\n"));
        // Connect to the fax server
      //  if (!g_ApiInterface.FaxConnectFaxServer(szServerName, &hFaxSvcHandle)) {
        //    return;
        //}

        // Enumerate the routing extension global info
        //if (!g_ApiInterface.FaxEnumGlobalRoutingInfo(hFaxSvcHandle, &pRoutingInfo, &dwNumMethods)) {
          //  fnWriteLogFile(TEXT("FaxEnumGlobalRoutingInfo() failed.  The error code is 0x%08x.  This is an error.  FaxEnumGlobalRoutingInfo() should succeed.\r\n"), GetLastError());
            // Disconnect from the fax server
            //g_ApiInterface.FaxClose(hFaxSvcHandle);
            //return;
        //}

        // Set the routing extension global info
        //(*pnNumCasesAttempted)++;

        //fnWriteLogFile(TEXT("Remote hFaxSvcHandle.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
        //for (dwIndex = 0; dwIndex < dwNumMethods; dwIndex++) {
            //if (!g_ApiInterface.FaxSetGlobalRoutingInfo(hFaxSvcHandle, &pRoutingInfo[dwIndex])) {
              //  fnWriteLogFile(TEXT("FaxSetGlobalRoutingInfo() failed.  The error code is 0x%08x.  This is an error.  FaxSetGlobalRoutingInfo() should succeed.\r\n"), GetLastError());
//                break;
  //          }
    //    }

      //  if (dwIndex == dwNumMethods) {
        //    (*pnNumCasesPassed)++;

        //}

        //g_ApiInterface.FaxFreeBuffer(pRoutingInfo);

        // Disconnect from the fax server
//        g_ApiInterface.FaxClose(hFaxSvcHandle);
  //  }
fnWriteLogFile(TEXT("$$$ Summery for FaxSetGlobalRoutingInfo, Attempt %d, Pass %d, Fail %d\n"),dwFuncCasesAtt,dwFuncCasesPass,dwFuncCasesAtt-dwFuncCasesPass);
fnWriteLogFile(TEXT("\n\t<summary attempt=\"%d\" pass=\"%d\" fail=\"%d\"></summary>\n"),dwFuncCasesAtt,dwFuncCasesPass,dwFuncCasesAtt-dwFuncCasesPass);
fnWriteLogFile(TEXT("\n\t</function>"));
}




VOID
fnFaxEnumRoutingMethods(
    LPCTSTR  szServerName,
    PUINT    pnNumCasesAttempted,
    PUINT    pnNumCasesPassed
)
/*++

Routine Description:

  FaxEnumGlobalRoutingInfo()

Return Value:

  None

--*/
{
    // hFaxSvcHandle is the handle to the fax server
    HANDLE               hFaxSvcHandle;
    // hFaxPortHandle is the handle to a fax port
    HANDLE               hFaxPortHandle;
    // pFaxPortInfo is the pointer to the fax port info
    PFAX_PORT_INFO       pFaxPortInfo;
    // dwNumPorts is the number of fax ports
    DWORD                dwNumPorts;
    // dwDeviceId is the device id of the fax port
    DWORD                dwDeviceId;
    // szDeviceName is the device name of the fax port
    LPTSTR               szDeviceName;
    // pRoutingMethod is the pointer to the routing method data structures
    PFAX_ROUTING_METHOD  pRoutingMethods;
    // dwNumMethods is the number of routing methods
    DWORD                dwNumMethods;

    DWORD                dwIndex;
						
	TCHAR				 szRouteApiDll[MAX_PATH];

	// internat Attempt/Pass counters (to display EVAL)
	DWORD			dwFuncCasesAtt=0;
	DWORD			dwFuncCasesPass=0;

	fnWriteLogFile(TEXT(  "\n--------------------------"));
    fnWriteLogFile(TEXT("### FaxEnumRoutingMethods().\r\n"));
	fnWriteLogFile(TEXT("\n\t<function name=\"FaxEnumRoutingMethods\">"));

    // Connect to the fax server
    if (!g_ApiInterface.FaxConnectFaxServer(szServerName, &hFaxSvcHandle)) {
		fnWriteLogFile(TEXT("WHIS> ERROR: Can not connect to fax server %s, The error code is 0x%08x.\r\n"),szServerName, GetLastError());
		fnWriteLogFile(TEXT("\n\t<summary attempt=\"-1\" pass=\"-1\" fail=\"-1\"></summary>\n"));
		fnWriteLogFile(TEXT("\n\t</function>"));
        return;
    }
	else
	{
		fnWriteLogFile(TEXT("WHIS> Connected to fax server %s. \r\n"),szServerName);
	}

    // Enumerate the fax ports
    if (!g_ApiInterface.FaxEnumPorts(hFaxSvcHandle, &pFaxPortInfo, &dwNumPorts)) {
		fnWriteLogFile(TEXT("WHIS> ERROR: Can not enum ports on server %s, The error code is 0x%08x.\r\n"),szServerName, GetLastError());
        // Disconnect from the fax server
        g_ApiInterface.FaxClose(hFaxSvcHandle);
		fnWriteLogFile(TEXT("\n\t<summary attempt=\"-1\" pass=\"-1\" fail=\"-1\"></summary>\n"));
		fnWriteLogFile(TEXT("\n\t</function>"));
        return;
    }

    dwDeviceId = pFaxPortInfo[0].DeviceId;
    szDeviceName = HeapAlloc(g_hHeap, HEAP_GENERATE_EXCEPTIONS | HEAP_ZERO_MEMORY, (lstrlen(pFaxPortInfo[0].DeviceName) + 1) * sizeof(TCHAR));
    lstrcpy(szDeviceName, pFaxPortInfo[0].DeviceName);

    // Free the fax port info
    g_ApiInterface.FaxFreeBuffer(pFaxPortInfo);

    if (!g_ApiInterface.FaxOpenPort(hFaxSvcHandle, dwDeviceId, PORT_OPEN_QUERY, &hFaxPortHandle)) {
		fnWriteLogFile(TEXT("WHIS> ERROR: Can not open port %d, The error code is 0x%08x.\r\n"),dwDeviceId, GetLastError());
        HeapFree(g_hHeap, 0, szDeviceName);
        // Disconnect from the fax server
        g_ApiInterface.FaxClose(hFaxSvcHandle);
		fnWriteLogFile(TEXT("\n\t<summary attempt=\"-1\" pass=\"-1\" fail=\"-1\"></summary>\n"));
		fnWriteLogFile(TEXT("\n\t</function>"));
        return;
    }

    for (dwIndex = 0; dwIndex < 2; dwIndex++) {
        // Enumerate the routing methods
        (*pnNumCasesAttempted)++;
		dwFuncCasesAtt++;

        fnWriteLogFile(TEXT("Valid Case.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
		fnWriteLogFile(TEXT("\n\t<case name=\"Valid Case\" id=\"%d\">"), *pnNumCasesAttempted);

        if (!g_ApiInterface.FaxEnumRoutingMethods(hFaxPortHandle, &pRoutingMethods, &dwNumMethods)) {
            fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxEnumRoutingMethods() failed.  The error code is 0x%08x.  This is an error.  FaxEnumRoutingMethods() should succeed.</result>\r\n"), GetLastError());
        }
        else {
            if (pRoutingMethods == NULL) {
                fnWriteLogFile(TEXT("\n\t<result value=\"0\">pRoutingMethods is NULL.  This is an error.  pRoutingMethods should not be NULL.</result>\r\n"));
            }

            if (dwNumMethods != g_dwNumMethods) {
                fnWriteLogFile(TEXT("\n\t<result value=\"0\">dwNumMethods is not g_dwNumMethods.  This is an error.  dwNumMethods should be g_dwNumMethods.</result>\r\n"));
            }

            if ((pRoutingMethods != NULL) && (dwNumMethods == g_dwNumMethods)) {
                if (pRoutingMethods[g_dwIndexAPIMethod2].SizeOfStruct != sizeof(FAX_ROUTING_METHOD)) {
                    fnWriteLogFile(TEXT("\n\t<result value=\"0\">SizeOfStruct: Received: %d, Expected: %d.</result>\r\n"), pRoutingMethods[g_dwIndexAPIMethod2].SizeOfStruct, sizeof(FAX_ROUTING_METHOD));
                    goto FuncFailed;
                }

                if (pRoutingMethods[g_dwIndexAPIMethod2].DeviceId != dwDeviceId) {
                    fnWriteLogFile(TEXT("\n\t<result value=\"0\">DeviceId: Received: 0x%08x, Expected: 0x%08x.</result>\r\n"), pRoutingMethods[g_dwIndexAPIMethod2].DeviceId, dwDeviceId);
                    goto FuncFailed;
                }

                if ((dwIndex == 0) && (pRoutingMethods[g_dwIndexAPIMethod2].Enabled)) {
                    fnWriteLogFile(TEXT("\n\t<result value=\"0\">Enabled: Received: FALSE, Expected: TRUE.</result>\r\n"));
                    goto FuncFailed;
                }
                else if ((dwIndex == 1) && (!pRoutingMethods[g_dwIndexAPIMethod2].Enabled)) {
                    fnWriteLogFile(TEXT("\n\t<result value=\"0\">Enabled: Received: TRUE, Expected: FALSE.</result>\r\n"));
                    goto FuncFailed;
                }

                if (lstrcmp(pRoutingMethods[g_dwIndexAPIMethod2].DeviceName, szDeviceName)!=0) {
                    fnWriteLogFile(TEXT("\n\t<result value=\"0\">DeviceName: Received: %s, Expected: %s.</result>\r\n"), pRoutingMethods[g_dwIndexAPIMethod2].DeviceName, szDeviceName);
                    goto FuncFailed;
                }

                if (lstrcmp(pRoutingMethods[g_dwIndexAPIMethod2].Guid, ROUTEAPI_METHOD_GUID1)!=0) {
                    fnWriteLogFile(TEXT("\n\t<result value=\"0\">Guid: Received: %s, Expected: %s.</result>\r\n"), pRoutingMethods[g_dwIndexAPIMethod2].Guid, ROUTEAPI_METHOD_GUID1);
                    goto FuncFailed;
                }
				
                if (lstrcmp(pRoutingMethods[g_dwIndexAPIMethod2].FriendlyName, ROUTEAPI_METHOD_FRIENDLYNAME1)!=0) {
                    fnWriteLogFile(TEXT("\n\t<result value=\"0\">FriendlyName: Received: %s, Expected: %s.</result>\r\n"), pRoutingMethods[g_dwIndexAPIMethod2].FriendlyName, ROUTEAPI_METHOD_FRIENDLYNAME1);
                    goto FuncFailed;
                }

                ExpandEnvironmentStrings(ROUTEAPI_EXTENSION_IMAGENAME, szRouteApiDll, sizeof(szRouteApiDll) / sizeof(TCHAR));
                if (lstrcmp(pRoutingMethods[g_dwIndexAPIMethod2].ExtensionImageName, szRouteApiDll)!=0) {
                    fnWriteLogFile(TEXT("\n\t<result value=\"0\">ExtensionImageName: Received: %s, Expected: %s.</result>\r\n"), pRoutingMethods[g_dwIndexAPIMethod2].ExtensionImageName, szRouteApiDll);
                    goto FuncFailed;
                }

                if (lstrcmp(pRoutingMethods[g_dwIndexAPIMethod2].ExtensionFriendlyName, ROUTEAPI_EXTENSION_FRIENDLYNAME)!=0) {
                    fnWriteLogFile(TEXT("\n\t<result value=\"0\">ExtensionFriendlyName: Received: %s, Expected: %s.</result>\r\n"), pRoutingMethods[g_dwIndexAPIMethod2].ExtensionFriendlyName, ROUTEAPI_EXTENSION_FRIENDLYNAME);
                    goto FuncFailed;
                }

                if (pRoutingMethods[g_dwIndexAPIMethod1].SizeOfStruct != sizeof(FAX_ROUTING_METHOD)) {
                    fnWriteLogFile(TEXT("\n\t<result value=\"0\">SizeOfStruct: Received: %d, Expected: %d.</result>\r\n"), pRoutingMethods[g_dwIndexAPIMethod1].SizeOfStruct, sizeof(FAX_ROUTING_METHOD));
                    goto FuncFailed;
                }

                if (pRoutingMethods[g_dwIndexAPIMethod1].DeviceId != dwDeviceId) {
                    fnWriteLogFile(TEXT("\n\t<result value=\"0\">DeviceId: Received: 0x%08x, Expected: 0x%08x.</result>\r\n"), pRoutingMethods[g_dwIndexAPIMethod1].DeviceId, dwDeviceId);
                    goto FuncFailed;
                }

                if ((dwIndex == 0) && (pRoutingMethods[g_dwIndexAPIMethod1].Enabled)) {
                    fnWriteLogFile(TEXT("\n\t<result value=\"0\">Enabled: Received: FALSE, Expected: TRUE.</result>\r\n"));
                    goto FuncFailed;
                }
                else if ((dwIndex == 1) && (!pRoutingMethods[g_dwIndexAPIMethod1].Enabled)) {
                    fnWriteLogFile(TEXT("\n\t<result value=\"0\">Enabled: Received: TRUE, Expected: FALSE.</result>\r\n"));
                    goto FuncFailed;
                }

                if (lstrcmp(pRoutingMethods[g_dwIndexAPIMethod1].DeviceName, szDeviceName)!=0) {
                    fnWriteLogFile(TEXT("\n\t<result value=\"0\">DeviceName: Received: %s, Expected: %s.</result>\r\n"), pRoutingMethods[g_dwIndexAPIMethod1].DeviceName, szDeviceName);
                    goto FuncFailed;
                }

                if (lstrcmp(pRoutingMethods[g_dwIndexAPIMethod1].Guid, ROUTEAPI_METHOD_GUID2)!=0) {
                    fnWriteLogFile(TEXT("\n\t<result value=\"0\">Guid: Received: %s, Expected: %s.</result>\r\n"), pRoutingMethods[g_dwIndexAPIMethod1].Guid, ROUTEAPI_METHOD_GUID2);
                    goto FuncFailed;
                }

                if (lstrcmp(pRoutingMethods[g_dwIndexAPIMethod1].FriendlyName, ROUTEAPI_METHOD_FRIENDLYNAME2)!=0) {
                    fnWriteLogFile(TEXT("\n\t<result value=\"0\">FriendlyName: Received: %s, Expected: %s.</result>\r\n"), pRoutingMethods[g_dwIndexAPIMethod1].FriendlyName, ROUTEAPI_METHOD_FRIENDLYNAME2);
                    goto FuncFailed;
                }

                ExpandEnvironmentStrings(ROUTEAPI_EXTENSION_IMAGENAME, szRouteApiDll, sizeof(szRouteApiDll) / sizeof(TCHAR));
                if (lstrcmp(pRoutingMethods[g_dwIndexAPIMethod1].ExtensionImageName, szRouteApiDll)!=0) {
                    fnWriteLogFile(TEXT("\n\t<result value=\"0\">ExtensionImageName: Received: %s, Expected: %s.</result>\r\n"), pRoutingMethods[g_dwIndexAPIMethod1].ExtensionImageName, szRouteApiDll);
                    goto FuncFailed;
                }

                if (lstrcmp(pRoutingMethods[g_dwIndexAPIMethod1].ExtensionFriendlyName, ROUTEAPI_EXTENSION_FRIENDLYNAME)!=0) {
                    fnWriteLogFile(TEXT("\n\t<result value=\"0\">ExtensionFriendlyName: Received: %s, Expected: %s.</result>\r\n"), pRoutingMethods[g_dwIndexAPIMethod1].ExtensionFriendlyName, ROUTEAPI_EXTENSION_FRIENDLYNAME);
                    goto FuncFailed;
                }

                (*pnNumCasesPassed)++;
				dwFuncCasesPass++;
				fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
            }

FuncFailed:
            g_ApiInterface.FaxFreeBuffer(pRoutingMethods);
        }

        g_ApiInterface.FaxEnableRoutingMethod(hFaxPortHandle, ROUTEAPI_METHOD_GUID1, dwIndex ? FALSE : TRUE);
        g_ApiInterface.FaxEnableRoutingMethod(hFaxPortHandle, ROUTEAPI_METHOD_GUID2, dwIndex ? FALSE : TRUE);
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));
    }
	

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("hFaxPortHandle = NULL.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"hFaxPortHandle = NULL\" id=\"%d\">"), *pnNumCasesAttempted);

    if (g_ApiInterface.FaxEnumRoutingMethods(NULL, &pRoutingMethods, &dwNumMethods)) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxEnumRoutingMethods() returned TRUE.  This is an error.  FaxEnumRoutingMethods() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_HANDLE);
        g_ApiInterface.FaxFreeBuffer(pRoutingMethods);
    }
    else if (GetLastError() != ERROR_INVALID_HANDLE) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">GetLastError() returned 0x%08x.  This is an error.  FaxEnumRoutingMethods() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_HANDLE);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
		fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
    }
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("pRoutingMethods = NULL.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"pRoutingMethods = NULL\" id=\"%d\">"), *pnNumCasesAttempted);

    if (g_ApiInterface.FaxEnumRoutingMethods(hFaxPortHandle, NULL, &dwNumMethods)) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxEnumRoutingMethods() returned TRUE.  This is an error.  FaxEnumRoutingMethods() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
        g_ApiInterface.FaxFreeBuffer(pRoutingMethods);
    }
    else if (GetLastError() != ERROR_INVALID_PARAMETER) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">GetLastError() returned 0x%08x.  This is an error.  FaxEnumRoutingMethods() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
		fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
    }
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("dwNumMethods = NULL.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"dwNumMethods = NULL\" id=\"%d\">"), *pnNumCasesAttempted);

    if (g_ApiInterface.FaxEnumRoutingMethods(hFaxPortHandle, &pRoutingMethods, NULL)) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxEnumRoutingMethods() returned TRUE.  This is an error.  FaxEnumRoutingMethods() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
        g_ApiInterface.FaxFreeBuffer(pRoutingMethods);
    }
    else if (GetLastError() != ERROR_INVALID_PARAMETER) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">GetLastError() returned 0x%08x.  This is an error.  FaxEnumRoutingMethods() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
		fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
    }
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

    // Disconnect from the fax port
    g_ApiInterface.FaxClose(hFaxPortHandle);

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("Invalid hFaxPortHandle.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"Invalid hFaxPortHandle\" id=\"%d\">"), *pnNumCasesAttempted);

    if (g_ApiInterface.FaxEnumRoutingMethods(hFaxPortHandle, &pRoutingMethods, &dwNumMethods)) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxEnumRoutingMethods() returned TRUE.  This is an error.  FaxEnumRoutingMethods() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_HANDLE);
        g_ApiInterface.FaxFreeBuffer(pRoutingMethods);
    }
    else if (GetLastError() != ERROR_INVALID_HANDLE) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">GetLastError() returned 0x%08x.  This is an error.  FaxEnumRoutingMethods() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_HANDLE);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
		fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
    }
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

    // Disconnect from the fax server
    g_ApiInterface.FaxClose(hFaxSvcHandle);

    HeapFree(g_hHeap, 0, szDeviceName);

//    if (szServerName) {
//		fnWriteLogFile(TEXT("WHIS> SERVER CASE(s):\r\n"));
        // Connect to the fax server
  //      if (!g_ApiInterface.FaxConnectFaxServer(szServerName, &hFaxSvcHandle)) {
    //        return;
      //  }

        // Enumerate the fax ports
//        if (!g_ApiInterface.FaxEnumPorts(hFaxSvcHandle, &pFaxPortInfo, &dwNumPorts)) {
            // Disconnect from the fax server
  //          g_ApiInterface.FaxClose(hFaxSvcHandle);
    //        return;
      //  }

        //dwDeviceId = pFaxPortInfo[0].DeviceId;

        // Free the fax port info
        //g_ApiInterface.FaxFreeBuffer(pFaxPortInfo);





        //if (!g_ApiInterface.FaxOpenPort(hFaxSvcHandle, dwDeviceId, PORT_OPEN_QUERY, &hFaxPortHandle)) {
		//	fnWriteLogFile(TEXT("WHIS> ERROR: Can not open port %d, The error code is 0x%08x.\r\n"),dwDeviceId, GetLastError());
            // Disconnect from the fax server
          //  g_ApiInterface.FaxClose(hFaxSvcHandle);
//            return;
  //      }
//
  //      (*pnNumCasesAttempted)++;

    //    fnWriteLogFile(TEXT("Remote hFaxPortHandle.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
      //  if (!g_ApiInterface.FaxEnumRoutingMethods(hFaxPortHandle, &pRoutingMethods, &dwNumMethods)) {
        //    fnWriteLogFile(TEXT("FaxEnumRoutingMethods() failed.  The error code is 0x%08x.  This is an error.  FaxEnumRoutingMethods() should succeed.\r\n"), GetLastError());
        //}
        //else {
          //  g_ApiInterface.FaxFreeBuffer(pRoutingMethods);
//            (*pnNumCasesPassed)++;
  //      }


        // Disconnect from the fax port
    //    g_ApiInterface.FaxClose(hFaxPortHandle);

        // Disconnect from the fax server
//        g_ApiInterface.FaxClose(hFaxSvcHandle);
  //  }
fnWriteLogFile(TEXT("$$$ Summery for FaxEnumRoutingMethods, Attempt %d, Pass %d, Fail %d\n"),dwFuncCasesAtt,dwFuncCasesPass,dwFuncCasesAtt-dwFuncCasesPass);
fnWriteLogFile(TEXT("\n\t<summary attempt=\"%d\" pass=\"%d\" fail=\"%d\"></summary>\n"),dwFuncCasesAtt,dwFuncCasesPass,dwFuncCasesAtt-dwFuncCasesPass);
fnWriteLogFile(TEXT("\n\t</function>"));
}

VOID
fnFaxEnableRoutingMethod(
    LPCTSTR  szServerName,
    PUINT    pnNumCasesAttempted,
    PUINT    pnNumCasesPassed
)
/*++

Routine Description:

  FaxEnableRoutingMethod()

Return Value:

  None

--*/
{
    // hFaxSvcHandle is the handle to the fax server
    HANDLE               hFaxSvcHandle;
    // hFaxPortHandle is the handle to a fax port
    HANDLE               hFaxPortHandle;
    // pFaxPortInfo is the pointer to the fax port info
    PFAX_PORT_INFO       pFaxPortInfo;
    // dwNumPorts is the number of fax ports
    DWORD                dwNumPorts;
    // dwDeviceId is the device id of the fax port
    DWORD                dwDeviceId;
    // pRoutingMethod is the pointer to the routing method data structures
    PFAX_ROUTING_METHOD  pRoutingMethods;
    // dwNumMethods is the number of routing methods
    DWORD                dwNumMethods;

    // szRouteApiDll is the route api dll
    TCHAR                szRouteApiDll[MAX_PATH];
    // hInstance is the handle to the instance of the route api dll
    HINSTANCE            hInstance;
    // FaxRouteDeviceEnable is the pointer to the FaxRouteDeviceEnable() function
    FARPROC              FaxRouteDeviceEnable;

	// internat Attempt/Pass counters (to display EVAL)
	DWORD			dwFuncCasesAtt=0;
	DWORD			dwFuncCasesPass=0;

	fnWriteLogFile(TEXT(  "\n--------------------------"));
    fnWriteLogFile(TEXT("### FaxEnableRoutingMethod().\r\n"));
	fnWriteLogFile(TEXT("\n\t<function name=\"FaxEnableRoutingMethod\">"));

    ExpandEnvironmentStrings(ROUTEAPI_EXTENSION_IMAGENAME, szRouteApiDll, sizeof(szRouteApiDll) / sizeof(TCHAR));
    if (!lstrcmpi(ROUTEAPI_EXTENSION_IMAGENAME, szRouteApiDll)) {
        return;
    }

    hInstance = LoadLibrary((LPCTSTR) szRouteApiDll);
    if (!hInstance) {
        return;
    }

    FaxRouteDeviceEnable = (FARPROC) GetProcAddress(hInstance, "FaxRouteDeviceEnable");
    if (!FaxRouteDeviceEnable) {
        FreeLibrary(hInstance);
        return;
    }

	// Connect to the fax server
    if (!g_ApiInterface.FaxConnectFaxServer(szServerName, &hFaxSvcHandle)) {
		fnWriteLogFile(TEXT("WHIS> ERROR: Can not connect to fax server %s, The error code is 0x%08x.\r\n"),szServerName, GetLastError());
		fnWriteLogFile(TEXT("\n\t<summary attempt=\"-1\" pass=\"-1\" fail=\"-1\"></summary>\n"));
		fnWriteLogFile(TEXT("\n\t</function>"));
        return;
    }
	else
	{
		fnWriteLogFile(TEXT("WHIS> Connected to fax server %s. \r\n"),szServerName);
	}

    // Enumerate the fax ports
    if (!g_ApiInterface.FaxEnumPorts(hFaxSvcHandle, &pFaxPortInfo, &dwNumPorts)) {
		fnWriteLogFile(TEXT("WHIS> ERROR: Can not enum ports on server %s, The error code is 0x%08x.\r\n"),szServerName, GetLastError());
        // Disconnect from the fax server
        g_ApiInterface.FaxClose(hFaxSvcHandle);
		fnWriteLogFile(TEXT("\n\t<summary attempt=\"-1\" pass=\"-1\" fail=\"-1\"></summary>\n"));
		fnWriteLogFile(TEXT("\n\t</function>"));
        return;
    }

    dwDeviceId = pFaxPortInfo[0].DeviceId;

    // Free the fax port info
    g_ApiInterface.FaxFreeBuffer(pFaxPortInfo);

    if (!g_ApiInterface.FaxOpenPort(hFaxSvcHandle, dwDeviceId, PORT_OPEN_QUERY, &hFaxPortHandle)) {
		fnWriteLogFile(TEXT("WHIS> ERROR: Can not open port %d, The error code is 0x%08x.\r\n"),dwDeviceId, GetLastError());
        // Disconnect from the fax server
        g_ApiInterface.FaxClose(hFaxSvcHandle);
        FreeLibrary(hInstance);
		fnWriteLogFile(TEXT("\n\t<summary attempt=\"-1\" pass=\"-1\" fail=\"-1\"></summary>\n"));
		fnWriteLogFile(TEXT("\n\t</function>"));
        return;
    }

    // Enable the routing method
    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("Valid Case.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"Valid Case\" id=\"%d\">"), *pnNumCasesAttempted);

    if (!g_ApiInterface.FaxEnableRoutingMethod(hFaxPortHandle, ROUTEAPI_METHOD_GUID1, TRUE)) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxEnableRoutingMethod() failed.  The error code is 0x%08x.  This is an error.  FaxEnableRoutingMethod() should succeed.</result>\r\n"), GetLastError());
    }
    else {
        if (!FaxRouteDeviceEnable(ROUTEAPI_METHOD_GUID1_W, dwDeviceId, -1)) {
            fnWriteLogFile(TEXT("\n\t<result value=\"0\">Enabled: Received: FALSE, Expected: TRUE.</result>\r\n"));
        }
        else {
            (*pnNumCasesPassed)++;
			dwFuncCasesPass++;
			fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
        }
    }
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

    // Disable the routing method
    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("Valid Case.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"Valid Case\" id=\"%d\">"), *pnNumCasesAttempted);

    if (!g_ApiInterface.FaxEnableRoutingMethod(hFaxPortHandle, ROUTEAPI_METHOD_GUID1, FALSE)) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxEnableRoutingMethod() failed.  The error code is 0x%08x.  This is an error.  FaxEnableRoutingMethod() should succeed.</result>\r\n"), GetLastError());
    }
    else {
        if (FaxRouteDeviceEnable(ROUTEAPI_METHOD_GUID1_W, dwDeviceId, -1)) {
            fnWriteLogFile(TEXT("\n\t<result value=\"0\">Enabled: Received: TRUE, Expected: FALSE.</result>\r\n"));
        }
        else {
            (*pnNumCasesPassed)++;
			dwFuncCasesPass++;
			fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
        }
    }
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

    FreeLibrary(hInstance);

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("hFaxPortHandle = NULL.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"hFaxPortHandle = NULL\" id=\"%d\">"), *pnNumCasesAttempted);

    if (g_ApiInterface.FaxEnableRoutingMethod(NULL, ROUTEAPI_METHOD_GUID1, FALSE)) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxEnableRoutingMethod() returned TRUE.  This is an error.  FaxEnableRoutingMethod() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).</result>\r\n"), ERROR_INVALID_HANDLE);
    }
    else if (GetLastError() != ERROR_INVALID_HANDLE) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">GetLastError() returned 0x%08x.  This is an error.  FaxEnableRoutingMethod() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_HANDLE);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
		fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
    }
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("ROUTEAPI_METHOD_GUID1 = NULL.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"ROUTEAPI_METHOD_GUID1 = NULL\" id=\"%d\">"), *pnNumCasesAttempted);

    if (g_ApiInterface.FaxEnableRoutingMethod(hFaxPortHandle, NULL, FALSE)) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxEnableRoutingMethod() returned TRUE.  This is an error.  FaxEnableRoutingMethod() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).</result>\r\n"), ERROR_INVALID_PARAMETER);
    }
    else if (GetLastError() != ERROR_INVALID_PARAMETER) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">GetLastError() returned 0x%08x.  This is an error.  FaxEnableRoutingMethod() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
		fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
    }
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("Invalid ROUTEAPI_METHOD_GUID1.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"Invalid ROUTEAPI_METHOD_GUID1\" id=\"%d\">"), *pnNumCasesAttempted);

    if (g_ApiInterface.FaxEnableRoutingMethod(hFaxPortHandle, ROUTEAPI_INVALID_GUID, FALSE)) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxEnableRoutingMethod() returned TRUE.  This is an error.  FaxEnableRoutingMethod() should return FALSE and GetLastError() should return ERROR_INVALID_DATA (0x%08x).</result>\r\n"), ERROR_INVALID_DATA);
    }
    else if (GetLastError() != ERROR_INVALID_DATA) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">GetLastError() returned 0x%08x.  This is an error.  FaxEnableRoutingMethod() should return FALSE and GetLastError() should return ERROR_INVALID_DATA (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_DATA);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
		fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
    }
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

    // Disconnect from the fax port
    g_ApiInterface.FaxClose(hFaxPortHandle);

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("Invalid hFaxPortHandle.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"Invalid hFaxPortHandle\" id=\"%d\">"), *pnNumCasesAttempted);

    if (g_ApiInterface.FaxEnableRoutingMethod(hFaxPortHandle, ROUTEAPI_METHOD_GUID1, FALSE)) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxEnableRoutingMethod() returned TRUE.  This is an error.  FaxEnableRoutingMethod() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).</result>\r\n"), ERROR_INVALID_HANDLE);
    }
    else if (GetLastError() != ERROR_INVALID_HANDLE) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">GetLastError() returned 0x%08x.  This is an error.  FaxEnableRoutingMethod() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_HANDLE);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
		fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
    }
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

    // Disconnect from the fax server
    g_ApiInterface.FaxClose(hFaxSvcHandle);

//    if (szServerName) {
//		fnWriteLogFile(TEXT("WHIS> SERVER CASE(s):\r\n"));
        // Connect to the fax server
  //      if (!g_ApiInterface.FaxConnectFaxServer(szServerName, &hFaxSvcHandle)) {
    //        return;
      //  }

        // Enumerate the fax ports
        //if (!g_ApiInterface.FaxEnumPorts(hFaxSvcHandle, &pFaxPortInfo, &dwNumPorts)) {
            // Disconnect from the fax server
          //  g_ApiInterface.FaxClose(hFaxSvcHandle);
            //return;
        //}

        //dwDeviceId = pFaxPortInfo[0].DeviceId;

        // Free the fax port info
        //g_ApiInterface.FaxFreeBuffer(pFaxPortInfo);

        //if (!g_ApiInterface.FaxOpenPort(hFaxSvcHandle, dwDeviceId, PORT_OPEN_QUERY, &hFaxPortHandle)) {
            // Disconnect from the fax server
          //  g_ApiInterface.FaxClose(hFaxSvcHandle);
//            return;
  //      }

    //    if (!g_ApiInterface.FaxEnumRoutingMethods(hFaxPortHandle, &pRoutingMethods, &dwNumMethods)) {
            // Disconnect from the fax port
      //      g_ApiInterface.FaxClose(hFaxPortHandle);
            // Disconnect from the fax server
        //    g_ApiInterface.FaxClose(hFaxSvcHandle);
            //return;
        //}

        //(*pnNumCasesAttempted)++;

        //fnWriteLogFile(TEXT("Remote hFaxPortHandle.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
        //if (!g_ApiInterface.FaxEnableRoutingMethod(hFaxPortHandle, pRoutingMethods[g_dwIndexAPIMethod1].Guid, pRoutingMethods[g_dwIndexAPIMethod1].Enabled)) {
            //fnWriteLogFile(TEXT("FaxEnableRoutingMethod() failed.  The error code is 0x%08x.  This is an error.  FaxEnableRoutingMethod() should succeed.\r\n"), GetLastError());
        //}
        //else {
            //(*pnNumCasesPassed)++;
        //}

        //g_ApiInterface.FaxFreeBuffer(pRoutingMethods);

        // Disconnect from the fax port
        //g_ApiInterface.FaxClose(hFaxPortHandle);

        // Disconnect from the fax server
        //g_ApiInterface.FaxClose(hFaxSvcHandle);
    //}
fnWriteLogFile(TEXT("$$$ Summery for FaxEnableRoutingMethod, Attempt %d, Pass %d, Fail %d\n"),dwFuncCasesAtt,dwFuncCasesPass,dwFuncCasesAtt-dwFuncCasesPass);
fnWriteLogFile(TEXT("\n\t<summary attempt=\"%d\" pass=\"%d\" fail=\"%d\"></summary>\n"),dwFuncCasesAtt,dwFuncCasesPass,dwFuncCasesAtt-dwFuncCasesPass);
fnWriteLogFile(TEXT("\n\t</function>"));
}

VOID
fnFaxGetRoutingInfo(
    LPCTSTR  szServerName,
    PUINT    pnNumCasesAttempted,
    PUINT    pnNumCasesPassed
)
/*++

Routine Description:

  FaxGetRoutingInfo()

Return Value:

  None

--*/
{
    // hFaxSvcHandle is the handle to the fax server
    HANDLE               hFaxSvcHandle;
    // hFaxPortHandle is the handle to a fax port
    HANDLE               hFaxPortHandle;
    // pFaxPortInfo is the pointer to the fax port info
    PFAX_PORT_INFO       pFaxPortInfo;
    // dwNumPorts is the number of fax ports
    DWORD                dwNumPorts;
    // dwDeviceId is the device id of the fax port
    DWORD                dwDeviceId;
    // pRoutingMethod is the pointer to the routing method data structures
    PFAX_ROUTING_METHOD  pRoutingMethods;
    // dwNumMethods is the number of routing methods
    DWORD                dwNumMethods;
    BOOL                 bEnabled;

    // szRouteApiDll is the route api dll
    TCHAR                szRouteApiDll[MAX_PATH];
    // hInstance is the handle to the instance of the route api dll
    HINSTANCE            hInstance;
    // FaxRouteSetRoutingInfo is the pointer to the FaxRouteSetRoutingInfo() function
    FARPROC              FaxRouteSetRoutingInfo;

	// internat Attempt/Pass counters (to display EVAL)
	DWORD			dwFuncCasesAtt=0;
	DWORD			dwFuncCasesPass=0;

    DWORD                dwGetRoutingInfo;
    DWORD                dwSetRoutingInfo;
    LPBYTE               RoutingInfo;
    DWORD                dwRoutingInfoSize;

	fnWriteLogFile(TEXT(  "\n--------------------------"));
    fnWriteLogFile(TEXT("### FaxGetRoutingInfo().\r\n"));
	fnWriteLogFile(TEXT("\n\t<function name=\"FaxGetRoutingInfo\">"));

    ExpandEnvironmentStrings(ROUTEAPI_EXTENSION_IMAGENAME, szRouteApiDll, sizeof(szRouteApiDll) / sizeof(TCHAR));
    if (!lstrcmpi(ROUTEAPI_EXTENSION_IMAGENAME, szRouteApiDll)) {
        return;
    }

    hInstance = LoadLibrary((LPCTSTR) szRouteApiDll);
    if (!hInstance) {
        return;
    }

    FaxRouteSetRoutingInfo = (FARPROC) GetProcAddress(hInstance, "FaxRouteSetRoutingInfo");
    if (!FaxRouteSetRoutingInfo) {
        FreeLibrary(hInstance);
        return;
    } 


    // Connect to the fax server
    if (!g_ApiInterface.FaxConnectFaxServer(szServerName, &hFaxSvcHandle)) {
		fnWriteLogFile(TEXT("WHIS> ERROR: Can not connect to fax server %s, The error code is 0x%08x.\r\n"),szServerName, GetLastError());
        FreeLibrary(hInstance);
		fnWriteLogFile(TEXT("\n\t<summary attempt=\"-1\" pass=\"-1\" fail=\"-1\"></summary>\n"));
		fnWriteLogFile(TEXT("\n\t</function>"));
        return;
    }
	else	{
		fnWriteLogFile(TEXT("WHIS> Connected to fax server %s. \r\n"),szServerName);
	}

    
	
	// Enumerate the fax ports
    if (!g_ApiInterface.FaxEnumPorts(hFaxSvcHandle, &pFaxPortInfo, &dwNumPorts)) {
		fnWriteLogFile(TEXT("WHIS> ERROR: Can not enum ports on server %s, The error code is 0x%08x.\r\n"),szServerName, GetLastError());
        // Disconnect from the fax server
        g_ApiInterface.FaxClose(hFaxSvcHandle);
        FreeLibrary(hInstance);
		fnWriteLogFile(TEXT("\n\t<summary attempt=\"-1\" pass=\"-1\" fail=\"-1\"></summary>\n"));
		fnWriteLogFile(TEXT("\n\t</function>"));
        return;
    }

    dwDeviceId = pFaxPortInfo[0].DeviceId;

    // Free the fax port info
    g_ApiInterface.FaxFreeBuffer(pFaxPortInfo);

    if (!g_ApiInterface.FaxOpenPort(hFaxSvcHandle, dwDeviceId, PORT_OPEN_QUERY, &hFaxPortHandle)) {
		fnWriteLogFile(TEXT("WHIS> ERROR: Can not open port %d, The error code is 0x%08x.\r\n"),dwDeviceId, GetLastError());
        // Disconnect from the fax server
        g_ApiInterface.FaxClose(hFaxSvcHandle);
        FreeLibrary(hInstance);
		fnWriteLogFile(TEXT("\n\t<summary attempt=\"-1\" pass=\"-1\" fail=\"-1\"></summary>\n"));
		fnWriteLogFile(TEXT("\n\t</function>"));
        return;
    }

    // Set the routing info
    dwSetRoutingInfo = ERROR_INVALID_PARAMETER;
    FaxRouteSetRoutingInfo(ROUTEAPI_METHOD_GUID1_W, dwDeviceId, (LPBYTE) &dwSetRoutingInfo, sizeof(DWORD));

    // Get the routing info
    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("Valid Case.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"Valid Case\" id=\"%d\">"), *pnNumCasesAttempted);

    if (!g_ApiInterface.FaxGetRoutingInfo(hFaxPortHandle, ROUTEAPI_METHOD_GUID1, &RoutingInfo, &dwRoutingInfoSize)) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxGetRoutingInfo() failed.  The error code is 0x%08x.  This is an error.  FaxGetRoutingInfo() should succeed.</result>\r\n"), GetLastError());
    }
    else {
        dwGetRoutingInfo = (DWORD) *(LPDWORD *) RoutingInfo;
        if (dwGetRoutingInfo != dwSetRoutingInfo) {
            fnWriteLogFile(TEXT("\n\t<result value=\"0\">RoutingInfo: Received: 0x%08x, Expected: 0x%08x.</result>\r\n"), dwGetRoutingInfo, dwSetRoutingInfo);
        }
        else {
            (*pnNumCasesPassed)++;
			dwFuncCasesPass++;
			fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
        }

        g_ApiInterface.FaxFreeBuffer(RoutingInfo);
    }
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

    // Set the routing info
    FaxRouteSetRoutingInfo(ROUTEAPI_METHOD_GUID1_W, dwDeviceId, NULL, 0);

    // Get the routing info
    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;
    fnWriteLogFile(TEXT("Valid Case.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"Valid Case\" id=\"%d\">"), *pnNumCasesAttempted);

    if (!g_ApiInterface.FaxGetRoutingInfo(hFaxPortHandle, ROUTEAPI_METHOD_GUID1, &RoutingInfo, &dwRoutingInfoSize)) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxGetRoutingInfo() failed.  The error code is 0x%08x.  This is an error.  FaxGetRoutingInfo() should succeed.</result>\r\n"), GetLastError());
    }
    else {
        dwGetRoutingInfo = (DWORD) *(LPDWORD *) RoutingInfo;
        if (dwGetRoutingInfo != 0) {
            fnWriteLogFile(TEXT("\n\t<result value=\"0\">RoutingInfo: Received: 0x%08x, Expected: 0.</result>\r\n"), dwGetRoutingInfo);
        }
        else {
            (*pnNumCasesPassed)++;
			dwFuncCasesPass++;
			fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
        }

        g_ApiInterface.FaxFreeBuffer(RoutingInfo);
    }
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

    FreeLibrary(hInstance);

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("hFaxPortHandle = NULL.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"hFaxPortHandle = NULL\" id=\"%d\">"), *pnNumCasesAttempted);

    if (g_ApiInterface.FaxGetRoutingInfo(NULL, ROUTEAPI_METHOD_GUID1, &RoutingInfo, &dwRoutingInfoSize)) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxGetRoutingInfo() returned TRUE.  This is an error.  FaxGetRoutingInfo() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).</result>\r\n"), ERROR_INVALID_HANDLE);
        g_ApiInterface.FaxFreeBuffer(RoutingInfo);
    }
    else if (GetLastError() != ERROR_INVALID_HANDLE) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">GetLastError() returned 0x%08x.  This is an error.  FaxGetRoutingInfo() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_HANDLE);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
		fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
    }
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("ROUTEAPI_METHOD_GUID1 = NULL.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"ROUTEAPI_METHOD_GUID1 = NULL\" id=\"%d\">"), *pnNumCasesAttempted);

    if (g_ApiInterface.FaxGetRoutingInfo(hFaxPortHandle, NULL, &RoutingInfo, &dwRoutingInfoSize)) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxGetRoutingInfo() returned TRUE.  This is an error.  FaxGetRoutingInfo() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).</result>\r\n"), ERROR_INVALID_PARAMETER);
        g_ApiInterface.FaxFreeBuffer(RoutingInfo);
    }
    else if (GetLastError() != ERROR_INVALID_PARAMETER) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">GetLastError() returned 0x%08x.  This is an error.  FaxGetRoutingInfo() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
		fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
    }
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("Invalid ROUTEAPI_METHOD_GUID1.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"Invalid ROUTEAPI_METHOD_GUID1\" id=\"%d\">"), *pnNumCasesAttempted);

    if (g_ApiInterface.FaxGetRoutingInfo(hFaxPortHandle, ROUTEAPI_INVALID_GUID, &RoutingInfo, &dwRoutingInfoSize)) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxGetRoutingInfo() returned TRUE.  This is an error.  FaxGetRoutingInfo() should return FALSE and GetLastError() should return ERROR_INVALID_DATA (0x%08x).</result>\r\n"), ERROR_INVALID_DATA);
        g_ApiInterface.FaxFreeBuffer(RoutingInfo);
    }
    else if (GetLastError() != ERROR_INVALID_DATA) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">GetLastError() returned 0x%08x.  This is an error.  FaxGetRoutingInfo() should return FALSE and GetLastError() should return ERROR_INVALID_DATA (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_DATA);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
		fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
    }
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("RoutingInfo = NULL.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"RoutingInfo = NULL\" id=\"%d\">"), *pnNumCasesAttempted);

    if (g_ApiInterface.FaxGetRoutingInfo(hFaxPortHandle, ROUTEAPI_METHOD_GUID1, NULL, &dwRoutingInfoSize)) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxGetRoutingInfo() returned TRUE.  This is an error.  FaxGetRoutingInfo() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).</result>\r\n"), ERROR_INVALID_PARAMETER);
        g_ApiInterface.FaxFreeBuffer(RoutingInfo);
    }
    else if (GetLastError() != ERROR_INVALID_PARAMETER) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">GetLastError() returned 0x%08x.  This is an error.  FaxGetRoutingInfo() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
		fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
    }
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("RoutingInfoSize = NULL.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"RoutingInfoSize = NULL\" id=\"%d\">"), *pnNumCasesAttempted);

    if (g_ApiInterface.FaxGetRoutingInfo(hFaxPortHandle, ROUTEAPI_METHOD_GUID1, &RoutingInfo, NULL)) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxGetRoutingInfo() returned TRUE.  This is an error.  FaxGetRoutingInfo() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).</result>\r\n"), ERROR_INVALID_PARAMETER);
        g_ApiInterface.FaxFreeBuffer(RoutingInfo);
    }
    else if (GetLastError() != ERROR_INVALID_PARAMETER) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">GetLastError() returned 0x%08x.  This is an error.  FaxGetRoutingInfo() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
		fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
    }
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

    // Disconnect from the fax port
    g_ApiInterface.FaxClose(hFaxPortHandle);

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("Invalid hFaxPortHandle.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"Invalid hFaxPortHandle\" id=\"%d\">"), *pnNumCasesAttempted);

    if (g_ApiInterface.FaxGetRoutingInfo(hFaxPortHandle, ROUTEAPI_METHOD_GUID1, &RoutingInfo, &dwRoutingInfoSize)) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxGetRoutingInfo() returned TRUE.  This is an error.  FaxGetRoutingInfo() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).</result>\r\n"), ERROR_INVALID_HANDLE);
        g_ApiInterface.FaxFreeBuffer(RoutingInfo);
    }
    else if (GetLastError() != ERROR_INVALID_HANDLE) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">GetLastError() returned 0x%08x.  This is an error.  FaxGetRoutingInfo() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_HANDLE);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
		fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
    }
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

    // Disconnect from the fax server
    g_ApiInterface.FaxClose(hFaxSvcHandle);

    //if (szServerName) {
	//	fnWriteLogFile(TEXT("WHIS> SERVER CASE(s):\r\n"));
        // Connect to the fax server
      //  if (!g_ApiInterface.FaxConnectFaxServer(szServerName, &hFaxSvcHandle)) {
        //    return;
//        }

        // Enumerate the fax ports
  //      if (!g_ApiInterface.FaxEnumPorts(hFaxSvcHandle, &pFaxPortInfo, &dwNumPorts)) {
            // Disconnect from the fax server
    //        g_ApiInterface.FaxClose(hFaxSvcHandle);
      //      return;
//        }

  //      dwDeviceId = pFaxPortInfo[0].DeviceId;

        // Free the fax port info
    //    g_ApiInterface.FaxFreeBuffer(pFaxPortInfo);

      //  if (!g_ApiInterface.FaxOpenPort(hFaxSvcHandle, dwDeviceId, PORT_OPEN_QUERY, &hFaxPortHandle)) {
            // Disconnect from the fax server
        //    g_ApiInterface.FaxClose(hFaxSvcHandle);
            //return;
        //}

        //if (!g_ApiInterface.FaxEnumRoutingMethods(hFaxPortHandle, &pRoutingMethods, &dwNumMethods)) {
            // Disconnect from the fax port
          //  g_ApiInterface.FaxClose(hFaxPortHandle);
            // Disconnect from the fax server
//            g_ApiInterface.FaxClose(hFaxSvcHandle);
  //          return;
    //    }

      //  (*pnNumCasesAttempted)++;

//        fnWriteLogFile(TEXT("Remote hFaxPortHandle.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
  //      if (!g_ApiInterface.FaxGetRoutingInfo(hFaxPortHandle, pRoutingMethods[g_dwIndexAPIMethod1].Guid, &RoutingInfo, &dwRoutingInfoSize)) {
    //        fnWriteLogFile(TEXT("FaxGetRoutingInfo() failed.  The error code is 0x%08x.  This is an error.  FaxGetRoutingInfo() should succeed.\r\n"), GetLastError());
      //  }
//        else {
  //          g_ApiInterface.FaxFreeBuffer(RoutingInfo);
    //        (*pnNumCasesPassed)++;

      //  }

        //g_ApiInterface.FaxFreeBuffer(pRoutingMethods);

        // Disconnect from the fax port
        //g_ApiInterface.FaxClose(hFaxPortHandle);

        // Disconnect from the fax server
        //g_ApiInterface.FaxClose(hFaxSvcHandle);
    //}
fnWriteLogFile(TEXT("$$$ Summery for FaxGetRoutingInfo, Attempt %d, Pass %d, Fail %d\n"),dwFuncCasesAtt,dwFuncCasesPass,dwFuncCasesAtt-dwFuncCasesPass);
fnWriteLogFile(TEXT("\n\t<summary attempt=\"%d\" pass=\"%d\" fail=\"%d\"></summary>\n"),dwFuncCasesAtt,dwFuncCasesPass,dwFuncCasesAtt-dwFuncCasesPass);
fnWriteLogFile(TEXT("\n\t</function>"));
}

VOID
fnFaxSetRoutingInfo(
    LPCTSTR  szServerName,
    PUINT    pnNumCasesAttempted,
    PUINT    pnNumCasesPassed
)
/*++

Routine Description:

  FaxSetRoutingInfo()

Return Value:

  None

--*/
{
    // hFaxSvcHandle is the handle to the fax server
    HANDLE               hFaxSvcHandle;
    // hFaxPortHandle is the handle to a fax port
    HANDLE               hFaxPortHandle;
    // pFaxPortInfo is the pointer to the fax port info
    PFAX_PORT_INFO       pFaxPortInfo;
    // dwNumPorts is the number of fax ports
    DWORD                dwNumPorts;
    // dwDeviceId is the device id of the fax port
    DWORD                dwDeviceId;
    // pRoutingMethod is the pointer to the routing method data structures
    PFAX_ROUTING_METHOD  pRoutingMethods;
    // dwNumMethods is the number of routing methods
    DWORD                dwNumMethods;
    BOOL                 bEnabled;

    // szRouteApiDll is the route api dll
    TCHAR                szRouteApiDll[MAX_PATH];
    // hInstance is the handle to the instance of the route api dll
    HINSTANCE            hInstance;
    // FaxRouteGetRoutingInfo is the pointer to the FaxRouteGetRoutingInfo() function
    FARPROC              FaxRouteGetRoutingInfo;

	// internat Attempt/Pass counters (to display EVAL)
	DWORD			dwFuncCasesAtt=0;
	DWORD			dwFuncCasesPass=0;

    DWORD                dwGetRoutingInfo;
    DWORD                dwSetRoutingInfo;
    LPBYTE               RoutingInfo;
    DWORD                dwRoutingInfoSize;

	fnWriteLogFile(TEXT(  "\n--------------------------"));
    fnWriteLogFile(TEXT("### FaxSetRoutingInfo().\r\n"));
	fnWriteLogFile(TEXT("\n\t<function name=\"FaxSetRoutingInfo\">"));

    ExpandEnvironmentStrings(ROUTEAPI_EXTENSION_IMAGENAME, szRouteApiDll, sizeof(szRouteApiDll) / sizeof(TCHAR));
    if (!lstrcmpi(ROUTEAPI_EXTENSION_IMAGENAME, szRouteApiDll)) {
        return;
    }

    hInstance = LoadLibrary((LPCTSTR) szRouteApiDll);
    if (!hInstance) {
        return;
    }

    FaxRouteGetRoutingInfo = (FARPROC) GetProcAddress(hInstance, "FaxRouteGetRoutingInfo");
    if (!FaxRouteGetRoutingInfo) {
        FreeLibrary(hInstance);
        return;
    }

	// Connect to the fax server
    if (!g_ApiInterface.FaxConnectFaxServer(szServerName, &hFaxSvcHandle)) {
		fnWriteLogFile(TEXT("WHIS> ERROR: Can not connect to fax server %s, The error code is 0x%08x.\r\n"),szServerName, GetLastError());
		fnWriteLogFile(TEXT("\n\t<summary attempt=\"-1\" pass=\"-1\" fail=\"-1\"></summary>\n"));
		fnWriteLogFile(TEXT("\n\t</function>"));
        return;
    }
	else
	{
		fnWriteLogFile(TEXT("WHIS> Connected to fax server %s. \r\n"),szServerName);
	}

    // Enumerate the fax ports
    if (!g_ApiInterface.FaxEnumPorts(hFaxSvcHandle, &pFaxPortInfo, &dwNumPorts)) {
		fnWriteLogFile(TEXT("WHIS> ERROR: Can not enum ports on server %s, The error code is 0x%08x.\r\n"),szServerName, GetLastError());
        // Disconnect from the fax server
        g_ApiInterface.FaxClose(hFaxSvcHandle);
		fnWriteLogFile(TEXT("\n\t<summary attempt=\"-1\" pass=\"-1\" fail=\"-1\"></summary>\n"));
		fnWriteLogFile(TEXT("\n\t</function>"));
        return;
    }


    dwDeviceId = pFaxPortInfo[0].DeviceId;

    // Free the fax port info
    g_ApiInterface.FaxFreeBuffer(pFaxPortInfo);

    if (!g_ApiInterface.FaxOpenPort(hFaxSvcHandle, dwDeviceId, PORT_OPEN_QUERY, &hFaxPortHandle)) {
		fnWriteLogFile(TEXT("WHIS> ERROR: Can not open port %d, The error code is 0x%08x.\r\n"),dwDeviceId, GetLastError());
        // Disconnect from the fax server
        g_ApiInterface.FaxClose(hFaxSvcHandle);
        FreeLibrary(hInstance);
		fnWriteLogFile(TEXT("\n\t<summary attempt=\"-1\" pass=\"-1\" fail=\"-1\"></summary>\n"));
		fnWriteLogFile(TEXT("\n\t</function>"));
        return;
    }

    // Set the routing info
    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("Valid Case.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"Valid Case\" id=\"%d\">"), *pnNumCasesAttempted);

    dwSetRoutingInfo = ERROR_INVALID_PARAMETER;
    if (!g_ApiInterface.FaxSetRoutingInfo(hFaxPortHandle, ROUTEAPI_METHOD_GUID1, (LPBYTE) &dwSetRoutingInfo, sizeof(DWORD))) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxSetRoutingInfo() failed.  The error code is 0x%08x.  This is an error.  FaxSetRoutingInfo() should succeed.</result>\r\n"), GetLastError());
    }
    else {
        FaxRouteGetRoutingInfo(ROUTEAPI_METHOD_GUID1_W, dwDeviceId, &dwGetRoutingInfo, NULL);

        if (dwGetRoutingInfo != dwSetRoutingInfo) {
            fnWriteLogFile(TEXT("\n\t<result value=\"0\">RoutingInfo: Received: 0x%08x, Expected: 0x%08x.</result>\r\n"), dwGetRoutingInfo, dwSetRoutingInfo);
        }
        else {
            (*pnNumCasesPassed)++;
			dwFuncCasesPass++;
			fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
        }
    }
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

    FreeLibrary(hInstance);

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;
    fnWriteLogFile(TEXT("hFaxPortHandle = NULL.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"hFaxPortHandle = NULL\" id=\"%d\">"), *pnNumCasesAttempted);

    if (g_ApiInterface.FaxSetRoutingInfo(NULL, ROUTEAPI_METHOD_GUID1, (LPBYTE) &dwSetRoutingInfo, sizeof(DWORD))) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxSetRoutingInfo() returned TRUE.  This is an error.  FaxSetRoutingInfo() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).</result>\r\n"), ERROR_INVALID_HANDLE);
    }
    else if (GetLastError() != ERROR_INVALID_HANDLE) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">GetLastError() returned 0x%08x.  This is an error.  FaxSetRoutingInfo() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_HANDLE);
    }
    else {
		fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
		fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
    }
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("ROUTEAPI_METHOD_GUID1 = NULL.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"ROUTEAPI_METHOD_GUID1 = NULL\" id=\"%d\">"), *pnNumCasesAttempted);

    if (g_ApiInterface.FaxSetRoutingInfo(hFaxPortHandle, NULL, (LPBYTE) &dwSetRoutingInfo, sizeof(DWORD))) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxSetRoutingInfo() returned TRUE.  This is an error.  FaxSetRoutingInfo() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).</result>\r\n"), ERROR_INVALID_PARAMETER);
    }
    else if (GetLastError() != ERROR_INVALID_PARAMETER) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">GetLastError() returned 0x%08x.  This is an error.  FaxSetRoutingInfo() should return FALSE and GetLastError() should return ERROR_INVALID_PARAMETER (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_PARAMETER);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
		fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
    }
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("Invalid ROUTEAPI_METHOD_GUID1.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"Invalid ROUTEAPI_METHOD_GUID1\" id=\"%d\">"), *pnNumCasesAttempted);

    if (g_ApiInterface.FaxSetRoutingInfo(hFaxPortHandle, ROUTEAPI_INVALID_GUID, (LPBYTE) &dwSetRoutingInfo, sizeof(DWORD))) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxSetRoutingInfo() returned TRUE.  This is an error.  FaxSetRoutingInfo() should return FALSE and GetLastError() should return ERROR_INVALID_DATA (0x%08x).</result>\r\n"), ERROR_INVALID_DATA);
    }
    else if (GetLastError() != ERROR_INVALID_DATA) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">GetLastError() returned 0x%08x.  This is an error.  FaxSetRoutingInfo() should return FALSE and GetLastError() should return ERROR_INVALID_DATA (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_DATA);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
		fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
    }
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

    // Disconnect from the fax port
    g_ApiInterface.FaxClose(hFaxPortHandle);

    (*pnNumCasesAttempted)++;
	dwFuncCasesAtt++;

    fnWriteLogFile(TEXT("Invalid hFaxPortHandle.  Test Case: %d.\r\n"), *pnNumCasesAttempted);
	fnWriteLogFile(TEXT("\n\t<case name=\"Invalid hFaxPortHandle\" id=\"%d\">"), *pnNumCasesAttempted);

    if (g_ApiInterface.FaxSetRoutingInfo(hFaxPortHandle, ROUTEAPI_METHOD_GUID1, (LPBYTE) &dwSetRoutingInfo, sizeof(DWORD))) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">FaxSetRoutingInfo() returned TRUE.  This is an error.  FaxSetRoutingInfo() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).</result>\r\n"), ERROR_INVALID_HANDLE);
    }
    else if (GetLastError() != ERROR_INVALID_HANDLE) {
        fnWriteLogFile(TEXT("\n\t<result value=\"0\">GetLastError() returned 0x%08x.  This is an error.  FaxSetRoutingInfo() should return FALSE and GetLastError() should return ERROR_INVALID_HANDLE (0x%08x).</result>\r\n"), GetLastError(), ERROR_INVALID_HANDLE);
    }
    else {
        (*pnNumCasesPassed)++;
		dwFuncCasesPass++;
		fnWriteLogFile(TEXT("\n\t<result value=\"1\"></result>"));
    }
	fnWriteLogFile(TEXT("\n\t</case>"));fnWriteLogFile(TEXT("\n\n"));

    // Disconnect from the fax server
    g_ApiInterface.FaxClose(hFaxSvcHandle);

//    if (szServerName) {
//		fnWriteLogFile(TEXT("WHIS> SERVER CASE(s):\r\n"));
        // Connect to the fax server
  //      if (!g_ApiInterface.FaxConnectFaxServer(szServerName, &hFaxSvcHandle)) {
    //        return;
      //  }

        // Enumerate the fax ports
//        if (!g_ApiInterface.FaxEnumPorts(hFaxSvcHandle, &pFaxPortInfo, &dwNumPorts)) {
            // Disconnect from the fax server
  //          g_ApiInterface.FaxClose(hFaxSvcHandle);
    //        return;
        //}

        //dwDeviceId = pFaxPortInfo[0].DeviceId;

        // Free the fax port info
        //g_ApiInterface.FaxFreeBuffer(pFaxPortInfo);

        //if (!g_ApiInterface.FaxOpenPort(hFaxSvcHandle, dwDeviceId, PORT_OPEN_QUERY, &hFaxPortHandle)) {
            // Disconnect from the fax server
          //  g_ApiInterface.FaxClose(hFaxSvcHandle);
//            return;
  //      }

    //    if (!g_ApiInterface.FaxEnumRoutingMethods(hFaxPortHandle, &pRoutingMethods, &dwNumMethods)) {
      //      // Disconnect from the fax port
        //    g_ApiInterface.FaxClose(hFaxPortHandle);
            // Disconnect from the fax server
          //  g_ApiInterface.FaxClose(hFaxSvcHandle);
            //return;
        //}

//        if (!g_ApiInterface.FaxGetRoutingInfo(hFaxPortHandle, pRoutingMethods[g_dwIndexAPIMethod1].Guid, &RoutingInfo, &dwRoutingInfoSize)) {
  //          g_ApiInterface.FaxFreeBuffer(pRoutingMethods);
            // Disconnect from the fax port
    //        g_ApiInterface.FaxClose(hFaxPortHandle);
            // Disconnect from the fax server
      //      g_ApiInterface.FaxClose(hFaxSvcHandle);
        //}

        //(*pnNumCasesAttempted)++;
        //fnWriteLogFile(TEXT("Remote hFaxPortHandle.  Test Case: %d.\r\n"), *pnNumCasesAttempted);

        //if (!g_ApiInterface.FaxSetRoutingInfo(hFaxPortHandle, pRoutingMethods[g_dwIndexAPIMethod1].Guid, RoutingInfo, dwRoutingInfoSize)) {
            //fnWriteLogFile(TEXT("FaxSetRoutingInfo() failed.  The error code is 0x%08x.  This is an error.  FaxSetRoutingInfo() should succeed.\r\n"), GetLastError());
        //}
        //else {
          //  (*pnNumCasesPassed)++;

        //}

        //g_ApiInterface.FaxFreeBuffer(RoutingInfo);

        //g_ApiInterface.FaxFreeBuffer(pRoutingMethods);

        // Disconnect from the fax port
        //g_ApiInterface.FaxClose(hFaxPortHandle);

        // Disconnect from the fax server
        //g_ApiInterface.FaxClose(hFaxSvcHandle);
    //}
fnWriteLogFile(TEXT("$$$ Summery for FaxSetRoutingInfo, Attempt %d, Pass %d, Fail %d\n"),dwFuncCasesAtt,dwFuncCasesPass,dwFuncCasesAtt-dwFuncCasesPass);
fnWriteLogFile(TEXT("\n\t<summary attempt=\"%d\" pass=\"%d\" fail=\"%d\"></summary>\n"),dwFuncCasesAtt,dwFuncCasesPass,dwFuncCasesAtt-dwFuncCasesPass);
fnWriteLogFile(TEXT("\n\t</function>"));
}


// count number of methods, return by referance: number of methods, index of API method 1/2 (if not found, their index will be 0)
BOOL
fnWhisFaxCountRoutingMethods(
    LPCTSTR  szServerName,
	PDWORD pdwMethodsCount,			// number of methods
	PDWORD pdwIndexAPIMethod1,		// index of API-Method 1
	PDWORD pdwIndexAPIMethod2		// index of API-Method 2

)
/*++

Routine Description:

   Count global methods 

Return Value:

Succeed/Fail


--*/
{
	
    // hFaxSvcHandle is the handle to the fax server
    HANDLE               hFaxSvcHandle;
    // hFaxPortHandle is the handle to a fax port
    HANDLE               hFaxPortHandle;
    // pFaxPortInfo is the pointer to the fax port info
    PFAX_PORT_INFO       pFaxPortInfo;

	// pRoutingInfo is the pointer to the global routing structures
    PFAX_GLOBAL_ROUTING_INFO  pRoutingInfo;

		// dwNumPorts is the number of fax ports
    DWORD                dwNumPorts;
    // dwDeviceId is the device id of the fax port
    DWORD                dwDeviceId;
    // szDeviceName is the device name of the fax port
    LPTSTR               szDeviceName;
    // pRoutingMethod is the pointer to the routing method data structures
    PFAX_ROUTING_METHOD  pRoutingMethods;
    // dwNumMethods is the number of routing methods
    DWORD                dwNumMethods;
	
	// szRouteApiDll is the route api dll
    TCHAR                szRouteApiDll[MAX_PATH];
	// index
    DWORD                dwIndex;
	// index for enumerating methods
	DWORD				 dwIndexAPI;

	fnWriteLogFile(TEXT("<function name=\"_utils(CountRoutingMethods)\">"));

	
    fnWriteLogFile(TEXT("WHIS> UTIL SERVICE: Counting global methods...\r\n"));



	



    // Connect to the fax server
    if (!g_ApiInterface.FaxConnectFaxServer(szServerName, &hFaxSvcHandle)) {
		fnWriteLogFile(TEXT("WHIS> UTIL FUNCTION ERROR: Can not connect to fax server %s, The error code is 0x%08x.\r\n"),szServerName, GetLastError());
		(*pdwMethodsCount)=0;
		fnWriteLogFile(TEXT("\n\t<summary attempt=\"-1\" pass=\"-1\" fail=\"-1\"></summary>\n"));
		fnWriteLogFile(TEXT("\n\t</function>"));
        return FALSE;
    }
	else	{
		fnWriteLogFile(TEXT("WHIS> Connected to fax server %s. \r\n"),szServerName);
	}

    // Enumerate the fax ports
    if (!g_ApiInterface.FaxEnumPorts(hFaxSvcHandle, &pFaxPortInfo, &dwNumPorts)) {
        // Disconnect from the fax server
		fnWriteLogFile(TEXT("WHIS> UTIL FUNCTION ERROR: Can not enum ports on server %s, The error code is 0x%08x.\r\n"),szServerName, GetLastError());
        g_ApiInterface.FaxClose(hFaxSvcHandle);
		(*pdwMethodsCount)=0;
		fnWriteLogFile(TEXT("\n\t<summary attempt=\"-1\" pass=\"-1\" fail=\"-1\"></summary>\n"));
		fnWriteLogFile(TEXT("\n\t</function>"));
        return FALSE;
    }

    // allocate heap for device name
	dwDeviceId = pFaxPortInfo[0].DeviceId;
    szDeviceName = HeapAlloc(g_hHeap, HEAP_GENERATE_EXCEPTIONS | HEAP_ZERO_MEMORY, (lstrlen(pFaxPortInfo[0].DeviceName) + 1) * sizeof(TCHAR));
    lstrcpy(szDeviceName, pFaxPortInfo[0].DeviceName);

    // Free the fax port info
    g_ApiInterface.FaxFreeBuffer(pFaxPortInfo);

    // open port
	if (!g_ApiInterface.FaxOpenPort(hFaxSvcHandle, dwDeviceId, PORT_OPEN_QUERY, &hFaxPortHandle)) {
		fnWriteLogFile(TEXT("WHIS> UTIL FUNCTION ERROR: Can not open port %d, The error code is 0x%08x.\r\n"),dwDeviceId, GetLastError());
		HeapFree(g_hHeap, 0, szDeviceName);
		g_ApiInterface.FaxClose(hFaxSvcHandle);
		(*pdwMethodsCount)=0;
		fnWriteLogFile(TEXT("\n\t<summary attempt=\"-1\" pass=\"-1\" fail=\"-1\"></summary>\n"));
		fnWriteLogFile(TEXT("\n\t</function>"));
		return FALSE;
    }

   	// enumarate global methods
	if (!g_ApiInterface.FaxEnumGlobalRoutingInfo(hFaxSvcHandle, &pRoutingInfo, &dwNumMethods)) {
        fnWriteLogFile(TEXT("WHIS> UTIL FUNCTION ERROR: Could not enum global routing extensions, The error code is 0x%08x.  This is an error.  FaxEnumGlobalRoutingInfo() should succeed.\r\n"), GetLastError());
		HeapFree(g_hHeap, 0, szDeviceName);
		g_ApiInterface.FaxClose(hFaxSvcHandle);
		(*pdwMethodsCount)=0;
		fnWriteLogFile(TEXT("\n\t<summary attempt=\"-1\" pass=\"-1\" fail=\"-1\"></summary>\n"));
		fnWriteLogFile(TEXT("\n\t</function>"));
		return FALSE;
    }

	// get the index number of the 1st API extension and the 2nd API extension
	for (dwIndexAPI=0;dwIndexAPI<g_dwNumMethods;dwIndexAPI++)	{
		if (lstrcmp(pRoutingInfo[dwIndexAPI].Guid, ROUTEAPI_METHOD_GUID1)==0) {
		(*pdwIndexAPIMethod1)=dwIndexAPI;
		}
		
		if (lstrcmp(pRoutingInfo[dwIndexAPI].Guid, ROUTEAPI_METHOD_GUID2)==0) {
		(*pdwIndexAPIMethod2)=dwIndexAPI;
		}
	}
	
	HeapFree(g_hHeap, 0, szDeviceName);
	g_ApiInterface.FaxClose(hFaxSvcHandle);
	(*pdwMethodsCount)=dwNumMethods;
	fnWriteLogFile(TEXT("\n\t<summary attempt=\"0\" pass=\"0\" fail=\"0\"></summary>\n"));
	fnWriteLogFile(TEXT("\n\t</function>"));
	return TRUE;
}










BOOL WINAPI
FaxAPIDllTest(
	LPCWSTR  szWhisPhoneNumberW,
	LPCSTR   szWhisPhoneNumberA,
    LPCWSTR  szServerNameW,
    LPCSTR   szServerNameA,
    UINT     nNumCasesLocal,
    UINT     nNumCasesServer,
    PUINT    pnNumCasesAttempted,
    PUINT    pnNumCasesPassed,
	DWORD	 dwTestMode
)
{
    LPCTSTR  szServerName;
    UINT     nNumCases;
	DWORD	 dwNumMethods;
	DWORD	dwIndexAPIMethod1=0;
	DWORD	dwIndexAPIMethod2=0;

#ifdef UNICODE
    szServerName = szServerNameW;
#else
    szServerName = szServerNameA;
#endif

    if (szServerName) {
        nNumCases = nNumCasesServer;
		fnWriteLogFile(TEXT("WHIS> REMOTE SERVER MODE:\r\n"));
    }
    else {
        nNumCases = nNumCasesLocal;
    }

	
	
	// routing extension
	// -----------------

	// count number of global methods before adding API methods
	
	if (!fnWhisFaxCountRoutingMethods(szServerName,&dwNumMethods,&dwIndexAPIMethod1,&dwIndexAPIMethod2))	{
		fnWriteLogFile(TEXT("Could not count routing extensions, error code is The error code is 0x%08x\r\n"),GetLastError());
	}
	
	fnWriteLogFile(TEXT("WHIS> number of global methods: %d.\r\n"),dwNumMethods);
	fnWriteLogFile(TEXT("WHIS> 1st API Method index: %d.\r\n"),dwIndexAPIMethod1);
	fnWriteLogFile(TEXT("WHIS> 2nd API Method index: %d.\r\n"),dwIndexAPIMethod2);


									// this program assumes that
	g_dwNumMethods=dwNumMethods+2;  // global number of methods should be 2 more then current found 
									// (2 more extension will be added in the next 2 lines of this section)
							
	// FaxRegisterRoutingExtension()

    fnFaxRegisterRoutingExtension(szServerName, pnNumCasesAttempted, pnNumCasesPassed);
	
	// add route api extension DLL
	fnAddRouteApiExtension();
    
	// stop the service
	if (!fnStopFaxSvc()) {
        fnWriteLogFile(TEXT("Could not stop the Fax Service.\r\n"));
	    return FALSE;
    }

	// re-count number of global methods (new value should be 2 more then previous count)
	if (!fnWhisFaxCountRoutingMethods(szServerName,&dwNumMethods,&dwIndexAPIMethod1,&dwIndexAPIMethod2))	{
		fnWriteLogFile(TEXT("Could not count routing extensions, error code is The error code is 0x%08x\r\n"),GetLastError());
	}

	fnWriteLogFile(TEXT("WHIS> number of global methods: %d.\r\n"),dwNumMethods);
	fnWriteLogFile(TEXT("WHIS> 1st API Method index: %d.\r\n"),dwIndexAPIMethod1);
	fnWriteLogFile(TEXT("WHIS> 2nd API Method index: %d.\r\n"),dwIndexAPIMethod2);

	
	// test if there are 2 new methods to do the test on
	if (g_dwNumMethods==dwNumMethods && dwIndexAPIMethod1 > 0 && dwIndexAPIMethod2 > 0)	{

		


		g_dwIndexAPIMethod1=dwIndexAPIMethod1;
		g_dwIndexAPIMethod2=dwIndexAPIMethod2;
	
		 
		// FaxEnumGlobalRoutingInfo()
		fnFaxEnumGlobalRoutingInfo(szServerName, pnNumCasesAttempted, pnNumCasesPassed);

		// FaxSetGlobalRoutingInfo()
		if (dwTestMode == WHIS_TEST_MODE_LIMITS)	{
			fnFaxSetGlobalRoutingInfo(szServerName, pnNumCasesAttempted, pnNumCasesPassed,TRUE);
		}
		else	{
			fnFaxSetGlobalRoutingInfo(szServerName, pnNumCasesAttempted, pnNumCasesPassed,FALSE);
		}


		// FaxEnumRoutingMethods()
		fnFaxEnumRoutingMethods(szServerName, pnNumCasesAttempted, pnNumCasesPassed);

		// FaxEnableRoutingMethod()
		fnFaxEnableRoutingMethod(szServerName, pnNumCasesAttempted, pnNumCasesPassed);

		// FaxGetRoutingInfo()
		fnFaxGetRoutingInfo(szServerName, pnNumCasesAttempted, pnNumCasesPassed);

		// FaxSetRoutingInfo()
		fnFaxSetRoutingInfo(szServerName, pnNumCasesAttempted, pnNumCasesPassed);

		if (!fnStopFaxSvc()) {
			fnWriteLogFile(TEXT("Could not stop the Fax Service.\r\n"));
			return FALSE;
		}
	} // of do actual routeext testing
	else	{
		// incorrect number of methods, or 0 indexes for the API methods
		fnWriteLogFile(TEXT("WHIS> ERROR: Incorrect Methods Configuration, WILL NOT TEST\r\n"));
	}


	// remove API extension
	fnRemoveRouteApiExtension();
	

	// service provider
	// ----------------

	// FaxRegisterServiceProvider()
    fnFaxRegisterServiceProvider(szServerName, pnNumCasesAttempted, pnNumCasesPassed);
	


    if ((*pnNumCasesAttempted == nNumCases) && (*pnNumCasesPassed == *pnNumCasesAttempted)) {
        return TRUE;
    }
    else {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\faxcomapi\extendedcom\msdn code snippets samples\createrule.cpp ===
// This sample demonstrates how to create an outbound routing rule.
// It creates a rule so that whenever a fax is sent to Israel, area code 4,
// it is always sent using the first fax device.
// NOTICE: this code will fail if it runs on Windows XP home edition or
//         professional edition. The Fax Outbound Routing Rules only exist
//         in server editions and beyond.

#include <conio.h>
#include <iostream>

//
// We're going to add a rule for country code 972 (Israel)
// and area code 4 (Haifa region)
//
#define COUNTRY_CODE    long(972)
#define AREA_CODE       long(4)

// Import the fax service fxscomex.dll file so that fax service COM objects can be used.
// The typical path to fxscomex.dll is shown. 
// If this path is not correct, search for fxscomex.dll and replace with the right path.
#import "c:\Windows\System32\fxscomex.dll" no_namespace

using namespace std;

int main ()
{
    try
    {
        HRESULT hr;
        //    
        // Define variables.
        //
        IFaxServerPtr sipFaxServer;
        IFaxDevicePtr sipFaxDevice;
        IFaxDevicesPtr sipFaxDevices;
        IFaxOutboundRoutingRulePtr sipFaxOutboundRoutingRule;
        long lID;
        //
        // Initialize the COM library on the current thread.
        //
        hr = CoInitialize(NULL); 
        if (FAILED(hr))
        {
            _com_issue_error(hr);
        }
        //
        // Create the root object.
        //
        hr = sipFaxServer.CreateInstance("FaxComEx.FaxServer");
        if (FAILED(hr))
        {
            _com_issue_error(hr);
        }
		//
		// Connect to the fax server. 
		// "" defaults to the machine on which the program is running.
		//
        sipFaxServer->Connect("");
        //        
        // Initialize the collection of devices.
        //
        sipFaxDevices = sipFaxServer->GetDevices();
        //
        // Get the first device.
        //
        sipFaxDevice = sipFaxDevices->GetItem(_variant_t(long(1)));
        //
        // Get the device ID.
        //
        lID = sipFaxDevice -> Id;
        //
        // Add a rule.
        //
        sipFaxOutboundRoutingRule = 
            sipFaxServer->OutboundRouting->GetRules()->Add(COUNTRY_CODE,   // Country code
                                                           AREA_CODE,      // Area code
                                                           VARIANT_TRUE,   // Use device
                                                           "",             // Don't care about group name
                                                           lID);           // Device id
        //
        // Now, if we wanted, we could go and use the newly created
        // rule through the returned sipFaxOutboundRoutingRule pointer.
        //
    }
    catch (_com_error& e)
    {
        cout                                << 
			"Error. HRESULT message is: \"" << 
			e.ErrorMessage()                << 
            "\" ("                          << 
            e.Error()                       << 
            ")"                             << 
            endl;
        if (e.ErrorInfo())
        {
		    cout << (char *)e.Description() << endl;
        }
    }
    
    CoUninitialize();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\faxcomapi\extendedcom\msdn code snippets samples\configdevices.cpp ===
// The following C++ code configures the first fax device to send faxes and
// automatically receive faxes after 4 rings.

#include <conio.h>
#include <iostream>

// Import the fax service fxscomex.dll file so that fax service COM objects can be used.
// The typical path to fxscomex.dll is shown. 
// If this path is not correct, search for fxscomex.dll and replace with the right path.

#import "c:\Windows\System32\fxscomex.dll" no_namespace

using namespace std;

int main ()
{
    try
    {
        HRESULT hr;
        IFaxServerPtr sipFaxServer;
        IFaxDevicesPtr sipFaxDevices;
        IFaxDevicePtr sipFaxDevice;
        //
        //Initialize the COM library on the current thread.
        //
        hr = CoInitialize(NULL); 
        if (FAILED(hr))
        {
            _com_issue_error(hr);
        }
        //
        // Connect to the fax server.
        //
        hr = sipFaxServer.CreateInstance("FaxComEx.FaxServer");
        if (FAILED(hr))
        {
            _com_issue_error(hr);
        }
        //
		// "" defaults to the machine on which the program is running.
        //
        sipFaxServer -> Connect ("");
        //
        // Get the collection of devices
        //
        sipFaxDevices = sipFaxServer -> GetDevices();
        //
        // Get the 1st device
        //
        sipFaxDevice = sipFaxDevices -> GetItem(_variant_t(long(0)));
        //
        // Set device to answer automatically
        //
        sipFaxDevice -> ReceiveMode = fdrmAUTO_ANSWER;
        //
        // Set the number of rings before the device answers
        //
        sipFaxDevice -> RingsBeforeAnswer = 4;
        //
        // Enable Send
        //
        sipFaxDevice -> SendEnabled = VARIANT_TRUE;
        //
        // Save the device configuration
        //
        sipFaxDevice -> Save();
    }
    catch (_com_error& e)
    {
        cout                                << 
			"Error. HRESULT message is: \"" << 
			e.ErrorMessage()                << 
            "\" ("                          << 
            e.Error()                       << 
            ")"                             << 
            endl;
        if (e.ErrorInfo())
        {
		    cout << (char *)e.Description() << endl;
        }
    }
    CoUninitialize();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\faxcomapi\extendedcom\msdn code snippets samples\setqueue.cpp ===
// This sample demonstrates how to set the outgoing queue properties

#include <conio.h>
#include <iostream>

// Import the fax service fxscomex.dll file so that fax service COM objects can be used.
// The typical path to fxscomex.dll is shown. 
// If this path is not correct, search for fxscomex.dll and replace with the right path.

#import "c:\Windows\System32\fxscomex.dll" no_namespace

using namespace std;

int main()
{
    try
    {
        HRESULT hr;
        //
        // Define variables
        //
        IFaxServerPtr sipFaxServer;
        IFaxFoldersPtr sipFaxFolders;
        IFaxOutgoingQueuePtr sipFaxOutgoingQueue;
        bool bBrand;
        long lAge;
        bool bAllow;
        DATE dDiscountStart;
        DATE dDiscountEnd;       
        long lRetries;
        //
        // Initialize the COM library on the current thread.
        //
        hr = CoInitialize(NULL); 
        if (FAILED(hr))
        {
            _com_issue_error(hr);
        }
        //        
        // Create the root object
        //
        hr = sipFaxServer.CreateInstance("FaxComEx.FaxServer");
        if (FAILED(hr))
        {
            _com_issue_error(hr);
        }
		//
		// Connect to the fax server. 
		// "" defaults to the machine on which the program is running.
		//
        sipFaxServer->Connect("");
        //
        // Initialize the FaxFolders object from the FaxServer object
        //
        sipFaxFolders = sipFaxServer->Folders;
        //
        // Initialize FaxOutgoingQueue object from the FaxFolders object
        //
        sipFaxOutgoingQueue = sipFaxFolders->OutgoingQueue;
        //
        // Set the outgoing queue properties
        // Disable page branding
        //
        sipFaxOutgoingQueue->Branding = VARIANT_FALSE;
        //
        // Set age limit to 2 days
        //
        sipFaxOutgoingQueue->AgeLimit = 2;
        //
        // Allow personal cover pages
        //
        sipFaxOutgoingQueue->AllowPersonalCoverPages = VARIANT_TRUE;
        //
        // Discount rate starts at 8:00AM and ends at 4:30PM
        //
        sipFaxOutgoingQueue->DiscountRateStart = 8.0/24.0;
        sipFaxOutgoingQueue->DiscountRateEnd = 16.5/24.0;
        //
        // We retry 5 times for each faild fax
        //
        sipFaxOutgoingQueue->Retries = 5;
        //
        // Save it all
        //
        sipFaxOutgoingQueue->Save();   
        //
        // Display the settings
        //
        bBrand = VARIANT_TRUE == sipFaxOutgoingQueue->Branding ? true : false;
        lAge = sipFaxOutgoingQueue->AgeLimit;
        bAllow = VARIANT_TRUE == sipFaxOutgoingQueue->AllowPersonalCoverPages ? true : false;
        dDiscountStart = sipFaxOutgoingQueue->DiscountRateStart;
        dDiscountEnd = sipFaxOutgoingQueue->DiscountRateEnd;
        lRetries = sipFaxOutgoingQueue->Retries;
        cout << "The Branding property has been set to " << bBrand << endl;
        cout << "The AgeLimit property has been set to " << lAge << endl;
        cout << "The AllowPersonalCoverPages property has been set to " << bAllow << endl;
        cout << "The DiscountRateStart property has been set to " << dDiscountStart << endl;
        cout << "The DiscountRateEnd property has been set to " << dDiscountEnd << endl;
        cout << "The Retries property has been set to " << lRetries << endl;
    }
    catch (_com_error& e)
    {
        cout                                << 
			"Error. HRESULT message is: \"" << 
			e.ErrorMessage()                << 
            "\" ("                          << 
            e.Error()                       << 
            ")"                             << 
            endl;
        if (e.ErrorInfo())
        {
		    cout << (char *)e.Description() << endl;
        }
    }
    CoUninitialize();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\faxcomapi\extendedcom\msdn code snippets samples\monitoractivity.cpp ===
// This sample demonstrates how to monitor fax activity

#include <conio.h>
#include <iostream>

// Import the fax service fxscomex.dll file so that fax service COM objects can be used.
// The typical path to fxscomex.dll is shown. 
// If this path is not correct, search for fxscomex.dll and replace with the right path.

#import "c:\windows\system32\fxscomex.dll" no_namespace

using namespace std;

int main()
{
    try
    {
        HRESULT hr;
		long lQueuedMessages;
		long lIncomingMessages;
		long lOutgoingMessages;
		long lRoutingMessages;
        IFaxServerPtr sipFaxServer;
        IFaxActivityPtr sipFaxActivity;
		//
        // Initialize the COM library on the current thread.
		//
        hr = CoInitialize(NULL); 
        if (FAILED(hr))
        {
            _com_issue_error(hr);
        }

        hr = sipFaxServer.CreateInstance("FaxComEx.FaxServer");
        if (FAILED(hr))
        {
            _com_issue_error(hr);
        }
		//
		// Connect to the fax server. 
		// "" defaults to the machine on which the program is running.
		//
        sipFaxServer->Connect("");
		//
		// Initialize the FaxActivity object
		//
        sipFaxActivity=sipFaxServer->Activity;
		//
		// Get the fax activity properties
		//
        lIncomingMessages=sipFaxActivity->IncomingMessages;
        lOutgoingMessages=sipFaxActivity->OutgoingMessages;
        lRoutingMessages=sipFaxActivity->RoutingMessages;
        lQueuedMessages=sipFaxActivity->QueuedMessages;
        //
        // Create the output
		//		 
        cout << "Number of incoming messages is " << lIncomingMessages << endl;
        cout << "Number of outgoing messages is " << lOutgoingMessages << endl;
        cout << "Number of routing messages is " << lRoutingMessages << endl;
        cout << "Number of queued messages is " << lQueuedMessages <<endl;
    }
    catch (_com_error& e)
    {
        cout                                << 
			"Error. HRESULT message is: \"" << 
			e.ErrorMessage()                << 
            "\" ("                          << 
            e.Error()                       << 
            ")"                             << 
            endl;
        if (e.ErrorInfo())
        {
		    cout << (char *)e.Description() << endl;
        }
    }
    CoUninitialize();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\faxcomapi\extendedcom\msdn code snippets samples\sendsinglefax.cpp ===
// This sample demonstrates how to send a fax

#include <conio.h>
#include <iostream>

// Import the fax service fxscomex.dll file so that fax service COM objects can be used.
// The typical path to fxscomex.dll is shown. 
// If this path is not correct, search for fxscomex.dll and replace with the right path.

#import "c:\windows\system32\fxscomex.dll" no_namespace

using namespace std;

// You can change properties easily using the following defines
#define FAX_BODY                L"c:\\Body.txt"
#define MY_DOCUMENT             L"My First Fax"
#define RECIPIENT_PHONE_NUMBER  L"+1 (425) 123-4567"
#define RECIPIENT_NAME          L"Bill"
#define SENDER_NAME             L"Bob"
#define SENDER_CODE             L"23A54"
#define SENDER_DEPT             L"Accts Payable"
#define SENDER_PHONE_NUMBER     L"+972 (4) 833-9070" 

int main()
{
    try
    {
        HRESULT hr;
        //
        // Define variables
        //
        IFaxServerPtr sipFaxServer;
        IFaxActivityPtr sipFaxActivity;
        IFaxDocumentPtr sipFaxDocument;
        _variant_t varJobID;
        //
        // Initialize the COM library on the current thread.
        //
        hr = CoInitialize(NULL); 
        if (FAILED(hr))
        {
            _com_issue_error(hr);
        }
        //                
        // Create the root objects
        //
        hr = sipFaxServer.CreateInstance("FaxComEx.FaxServer");
        if (FAILED(hr))
        {
            _com_issue_error(hr);
        }

        hr = sipFaxDocument.CreateInstance("FaxComEx.FaxDocument");
        if (FAILED(hr))
        {
            _com_issue_error(hr);
        }
		//
		// Connect to the fax server. 
		// "" defaults to the machine on which the program is running.
		//
        sipFaxServer->Connect("");
        //
        // Set the fax body (aka attachment)
        //
        sipFaxDocument->Body = FAX_BODY;
        //
        // Name the document
        //
        sipFaxDocument->DocumentName = MY_DOCUMENT;
        //
        // Add the recipient
        // 
        sipFaxDocument->Recipients->Add (RECIPIENT_PHONE_NUMBER, RECIPIENT_NAME);
        //
        // If we want to send a fax to more than one recipient, we just repeat
        // the line above for each recipient.
        //
        
        //
        // Set the sender properties
        //
        sipFaxDocument->Sender->Name = SENDER_NAME;
        sipFaxDocument->Sender->BillingCode = SENDER_CODE;
        sipFaxDocument->Sender->Department = SENDER_DEPT;
        sipFaxDocument->Sender->FaxNumber = SENDER_PHONE_NUMBER;
        //
        // Submit the document to the connected fax server
        // and get back the job ID.
        //
        // Notice we could skip the IFaxServer interface altogether
        // and just use the Submit("") method instead in this case.
        //
        varJobID = sipFaxDocument->ConnectedSubmit(sipFaxServer);

        long lIndex = 0;
        long lUBound;
        //
        // Get the upper bound of the array or job ids
        //
        SafeArrayGetUBound(varJobID.parray, 1, &lUBound);
        for (lIndex = 0; lIndex <= lUBound; lIndex++)
        {
            BSTR bstrJobID;
            SafeArrayGetElement(varJobID.parray , &lIndex, LPVOID(&bstrJobID));
            wprintf (L"Job ID is %s\n", bstrJobID);
        }
    }
    catch (_com_error& e)
    {
        cout                                << 
			"Error. HRESULT message is: \"" << 
			e.ErrorMessage()                << 
            "\" ("                          << 
            e.Error()                       << 
            ")"                             << 
            endl;
        if (e.ErrorInfo())
        {
		    cout << (char *)e.Description() << endl;
        }
    }
    CoUninitialize();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\faxcomapi\extendedcom\msdn code snippets samples\setbranding.cpp ===
// This sample demonstrates how to set the Branding property

#include <conio.h>
#include <iostream>

// Import the fax service fxscomex.dll file so that fax service COM objects can be used.
// The typical path to fxscomex.dll is shown. 
// If this path is not correct, search for fxscomex.dll and replace with the right path.

#import "c:\Windows\System32\fxscomex.dll" no_namespace

using namespace std;

int main()
{
    try
    {
        HRESULT hr;
        //
        // Define variables
        //
        IFaxServerPtr sipFaxServer;
        IFaxFoldersPtr sipFaxFolders;
        IFaxOutgoingQueuePtr sipFaxOutgoingQueue;
        //
        // Initialize the COM library on the current thread.
        //
        hr = CoInitialize(NULL); 
        if (FAILED(hr))
        {
            _com_issue_error(hr);
        }
        //                
        // Create the root object
        //
        hr = sipFaxServer.CreateInstance("FaxComEx.FaxServer");
        if (FAILED(hr))
        {
            _com_issue_error(hr);
        }
        //
		// "" defaults to the machine on which the program is running.
        //
        sipFaxServer -> Connect ("");
        //
        // Initialize the FaxFolders object from the FaxServer object
        //
        sipFaxFolders = sipFaxServer->Folders;
        //
        // Initialize FaxOutgoingQueue object from the FaxFolders object
        //
        sipFaxOutgoingQueue = sipFaxFolders->OutgoingQueue;
        //
        // Set the Branding property
        //
        sipFaxOutgoingQueue->Branding = VARIANT_TRUE;
        sipFaxOutgoingQueue->Save();   
        cout << 
            "The branding property has been set to " << 
            ((VARIANT_TRUE == sipFaxOutgoingQueue->Branding) ?
                "TRUE" : "FALSE") << 
            endl;
    }
    catch (_com_error& e)
    {
        cout                                << 
			"Error. HRESULT message is: \"" << 
			e.ErrorMessage()                << 
            "\" ("                          << 
            e.Error()                       << 
            ")"                             << 
            endl;
        if (e.ErrorInfo())
        {
		    cout << (char *)e.Description() << endl;
        }
    }
    CoUninitialize();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\fsp\3rdpartyfsp_verifier\cthreaditem.h ===
//CThreadItem.h
#ifndef CThreadItem_h
#define CThreadItem_h

//
//Thread stuff
//
class CThreadItem
{
public:
	DWORD               m_dwThreadId;		//
    HANDLE				m_hThread;		//
	CThreadItem():
		m_dwThreadId(0),
		m_hThread(NULL)
	{
		;
	}

	~CThreadItem()
	{
		m_dwThreadId = 0;
		if (NULL != m_hThread)
		{
			CloseHandleResetThreadId();
		}
	}

	bool StartThread(
		const LPTHREAD_START_ROUTINE lpStartAddress,
		const LPVOID lpParameter
		)
	{
		m_hThread = ::CreateThread(
			NULL,
			0,
			(LPTHREAD_START_ROUTINE) lpStartAddress,
			lpParameter,
			0,
			&m_dwThreadId
			);

		if (!m_hThread)
		{
			::lgLogError(
				LOG_SEV_2,
				TEXT("Could not start the Thread (ec: %ld)"),
				::GetLastError()
				);
			return false;
		}
		return true;
	}

	void CloseHandleResetThreadId()
	{
		::CloseHandle(m_hThread);
		m_hThread = NULL;
		m_dwThreadId = 0;
	}

};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\fsp\3rdpartyfsp_verifier\cfspwrapper.cpp ===
#include "CFspWrapper.h"
#include "assert.h"

extern DWORD g_dwCaseNumber;

CCriticalSection* CFspWrapper::sm_pCsProvider=NULL;
CFspWrapper::CFspWrapper():
	m_hInstModuleHandle(NULL),
	m_fnFaxDevReceive(NULL),
	m_fnFaxDevEndJob(NULL),
	m_fnFaxDevAbortOperation(NULL),
	m_fnFaxDevStartJob(NULL),
	m_fnFaxDevInitialize(NULL),
	m_fnFaxDevVirtualDeviceCreation(NULL),
	m_fnFaxDevReportStatus(NULL),
	m_fnFaxDevSend(NULL)
{
	lstrcpy(m_szImageName,TEXT(""));
}

bool CFspWrapper::LoadModule(LPCTSTR szEfspModuleName,const bool bLog)
{
	assert(NULL != szEfspModuleName);
	lstrcpy(m_szImageName,szEfspModuleName);

	m_hInstModuleHandle = LoadLibrary(m_szImageName);
	if (NULL == m_hInstModuleHandle)
	{
		::lgLogError(
			LOG_SEV_2, 
			TEXT("LoadLibrary failed with %ld"),
			::GetLastError()
			);
		return false;
	}
	else
	{
		if (true == bLog)
		{
			::lgLogDetail(
				LOG_PASS,
				2,
				TEXT("Module:%s loaded"),
				m_szImageName
				);
		}
		else
		{
			::lgLogDetail(
				LOG_X,
				5,
				TEXT("Module:%s loaded"),
				m_szImageName
				);
		}
	}
	return true;
}

void CFspWrapper::UnLoadModule(const bool bLog)
{
	if (NULL != m_hInstModuleHandle)
	{
		if (true == bLog)
		{
			::lgLogDetail(
				LOG_PASS,
				2,
				TEXT("Unloading Module: %s"),
				m_szImageName
				);
		}
		else
		{
			::lgLogDetail(
				LOG_X,
				5,
				TEXT("Unloading Module: %s"),
				m_szImageName
				);
		}

		if (!FreeLibrary(m_hInstModuleHandle))
		{
			::lgLogError(
				LOG_SEV_2, 
				TEXT("FreeLibrary failed with %ld"),
				::GetLastError()
				);
		}
		m_hInstModuleHandle = NULL;
		lstrcpy(m_szImageName,TEXT(""));
	}
}


bool CFspWrapper::Init(LPCTSTR szEfspModuleName,const bool bLog)
{
	//
	//Init the static member
	//
	if (NULL == sm_pCsProvider)
	{
		if (false == CreateCriticalSection())
		{
			return false;
		}
	}
	if (false == LoadModule(szEfspModuleName,bLog))
	{
		UnLoadModule(false);
		return false;
	}
	return true;
}

bool CFspWrapper::CreateCriticalSection()
{
	assert(NULL == sm_pCsProvider);
	sm_pCsProvider = new CCriticalSection;
	if (NULL == sm_pCsProvider)
	{
		::lgLogError(
			LOG_SEV_2,
			TEXT("new CCriticalSection failed")
			);
		return false;
	}
	return true;
}


CFspWrapper::~CFspWrapper()
{
	LockProvider();
	UnLoadModule(false);
	UnlockProvider();
}


void CFspWrapper::LockProvider()
{
	sm_pCsProvider->Enter();
}
void CFspWrapper::UnlockProvider()
{
	sm_pCsProvider->Leave();
}

bool CFspWrapper::GetProcAddressesFromModule(const bool bLog)
{

	//
	//FSP API: mandatory functions
	//
	m_fnFaxDevInitialize = (PFAXDEVINITIALIZE) GetProcAddress(m_hInstModuleHandle,"FaxDevInitialize");
	if (NULL == m_fnFaxDevInitialize)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FaxDevInitialize is a mandatory function, and %s doesn't export it"),
			m_szImageName
			);
		return false;
	}
	else
	{
		if (bLog)
		{
			::lgLogDetail(
				LOG_PASS, 
				2,
				TEXT("FaxDevInitialize() exported")
				);
		}
	}

	m_fnFaxDevSend = (PFAXDEVSEND) GetProcAddress(m_hInstModuleHandle,"FaxDevSend");
	if (NULL == m_fnFaxDevSend)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FaxDevSend is a mandatory function, and %s doesn't export it"),
			m_szImageName
			);
		return false;

	}
	else
	{
		if (bLog)
		{
			::lgLogDetail(
				LOG_PASS, 
				2,
				TEXT("FaxDevSend() exported")
				);
		}
	}
	
	m_fnFaxDevReportStatus = (PFAXDEVREPORTSTATUS) GetProcAddress(m_hInstModuleHandle,"FaxDevReportStatus");
	if (NULL == m_fnFaxDevReportStatus)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FaxDevReportStatus is a mandatory function, and %s doesn't export it"),
			m_szImageName
			);
		return false;
	}
	else
	{
		if (bLog)
		{
			::lgLogDetail(
				LOG_PASS, 
				2,
				TEXT("FaxDevReportStatus() exported")
				);
		}
	}

	m_fnFaxDevStartJob = (PFAXDEVSTARTJOB) GetProcAddress(m_hInstModuleHandle,"FaxDevStartJob");
	if (NULL == m_fnFaxDevStartJob)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FaxDevStartJob is a mandatory function, and %s doesn't export it"),
			m_szImageName
			);
		return false;
	}
	else
	{
		if (bLog)
		{
			::lgLogDetail(
				LOG_PASS, 
				2,
				TEXT("FaxDevStartJob() exported")
				);
		}
	}

	m_fnFaxDevEndJob = (PFAXDEVENDJOB) GetProcAddress(m_hInstModuleHandle,"FaxDevEndJob");
	if (NULL == m_fnFaxDevEndJob)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FaxDevEndJob is a mandatory function, and %s doesn't export it"),
			m_szImageName
			);
		return false;
	}
	else
	{
		if (bLog)
		{
			::lgLogDetail(
				LOG_PASS, 
				2,
				TEXT("FaxDevEndJob() exported")
				);
		}
	}

	m_fnFaxDevReceive = (PFAXDEVRECEIVE) GetProcAddress(m_hInstModuleHandle,"FaxDevReceive");
	if (NULL == m_fnFaxDevReceive)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FaxDevReceive is a mandatory function, and %s doesn't export it"),
			m_szImageName
			);
		return false;
	}
	else
	{
		if (bLog)
		{
			::lgLogDetail(
				LOG_PASS, 
				2,
				TEXT("FaxDevReceive() exported")
				);
		}
	}
	
	m_fnFaxDevAbortOperation = (PFAXDEVABORTOPERATION) GetProcAddress(m_hInstModuleHandle,"FaxDevAbortOperation");
	if (NULL == m_fnFaxDevAbortOperation)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FaxDevAbortOperation is a mandatory function, and %s doesn't export it"),
			m_szImageName
			);
		return false;
	}
	else
	{
		if (bLog)
		{
			::lgLogDetail(
				LOG_PASS, 
				2,
				TEXT("FaxDevAbortOperations() exported")
				);
		}
	}
	return true;
}


TCHAR*	CFspWrapper::GetImageName()
{
	return m_szImageName;
}
void CFspWrapper::SetCallbackFunction(const PFAX_LINECALLBACK pCallbackFunction)
{
	m_fnFaxDevCallback = pCallbackFunction;
}
HINSTANCE CFspWrapper::GetModuleHandle() const
{
	return m_hInstModuleHandle;
}

//
//FSP API
//
bool CFspWrapper::FaxDevReceive(
	IN			HANDLE			FaxHandle,
	IN			HCALL			CallHandle,
	IN OUT		PFAX_RECEIVE	FaxReceive
	) const
{
	BOOL bStatus = FALSE;
	__try
	{
		::lgLogDetail(
			LOG_X,
			7,
			TEXT("Calling FaxDevReceive(0x%08x,0x%08x,0x%08x)"),
			FaxHandle,
			CallHandle,
			FaxReceive
			);
		bStatus = m_fnFaxDevReceive(
			FaxHandle,
			CallHandle,
			FaxReceive
			);
		if (FALSE == bStatus)
		{
			::lgLogDetail(
				LOG_X,
				7,
				TEXT("FaxDevReceive returned FALSE")
				);
		}
		else
		{
			::lgLogDetail(
				LOG_X,
				7,
				TEXT("FaxDevReceive returned TRUE")
				);
		}
	}
	__except(EXCEPTION_EXECUTE_HANDLER )
	{
		lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevReceive() raised an exception of type: 0x%08x"),
			GetExceptionCode()
			);
	}
	return (TRUE == bStatus);
}

void CFspWrapper::FaxDevCallback(
	IN HANDLE		hFaxHandle,
	IN DWORD		hDevice,
	IN DWORD		dwMessage,
	IN DWORD_PTR	dwInstance,
	IN DWORD_PTR	dwParam1,
	IN DWORD_PTR	dwParam2,
	IN DWORD_PTR	dwParam3
	) const
{
	__try
	{
		::lgLogDetail(
			LOG_X,
			7,
			TEXT("Calling FaxDevCallback(0x%08x,0x%08x,0x%08x,0x%08x,0x%08x,0x%08x,0x%08x)"),
			hFaxHandle,
			hDevice,
			dwMessage,
			dwInstance,
			dwParam1,
			dwParam2,
			dwParam3
			);
		m_fnFaxDevCallback(
			hFaxHandle,
			hDevice,
			dwMessage,
			dwInstance,
			dwParam1,
			dwParam2,
			dwParam3
			);
	}
	__except(EXCEPTION_EXECUTE_HANDLER )
	{
		lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevCallback() raised an exception of type: 0x%08x"),
			GetExceptionCode()
			);
	}
	return;
}

bool CFspWrapper::FaxDevEndJob(
	IN  HANDLE FaxHandle
	) const
{
	BOOL bStatus = FALSE;
	__try
	{
		::lgLogDetail(
			LOG_X,
			7,
			TEXT("Calling FaxDevEndJob(0x%08x)"),
			FaxHandle
			);
		bStatus = m_fnFaxDevEndJob(FaxHandle);
		if (FALSE == bStatus)
		{
			::lgLogDetail(
				LOG_X,
				7,
				TEXT("FaxDevEndJob returned FALSE")
				);
		}
		else
		{
			::lgLogDetail(
				LOG_X,
				7,
				TEXT("FaxDevEndJob returned TRUE")
				);
		}
	}
	__except(EXCEPTION_EXECUTE_HANDLER )
	{
		lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevEndJob() raised an exception of type: 0x%08x"),
			GetExceptionCode()
			);
	}
	return (TRUE == bStatus);
}

bool CFspWrapper::FaxDevAbortOperation(
		IN  HANDLE FaxHandle
	) const
{
	BOOL bStatus = FALSE;
	__try
	{
		::lgLogDetail(
			LOG_X,
			7,
			TEXT("Calling FaxDevAbortOperation(0x%08x)"),
			FaxHandle
			);
		bStatus = m_fnFaxDevAbortOperation(FaxHandle);
		if (FALSE == bStatus)
		{
			::lgLogDetail(
				LOG_X,
				7,
				TEXT("FaxDevAbortOperation returned FALSE")
				);
		}
		else
		{
			::lgLogDetail(
				LOG_X,
				7,
				TEXT("FaxDevAbortOperation returned TRUE")
				);
		}
	}
	__except(EXCEPTION_EXECUTE_HANDLER )
	{
		lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevAbortOperation() raised an exception of type: 0x%08x"),
			GetExceptionCode()
			);
	}
	return (TRUE == bStatus);
}

bool CFspWrapper::FaxDevStartJob(
	IN  HLINE		LineHandle,
	IN  DWORD		DeviceId,
	OUT PHANDLE		FaxHandle,
	IN  HANDLE		CompletionPortHandle,
	IN  ULONG_PTR	CompletionKey
	) const
{
	BOOL bStatus = FALSE;
	__try
	{
		::lgLogDetail(
			LOG_X,
			7,
			TEXT("Calling FaxDevStartJob(0x%08x,0x%08x,0x%08x,0x%08x,0x%08x)"),
			LineHandle,
			DeviceId,
			FaxHandle,
			CompletionPortHandle,
			CompletionKey
			);
		bStatus = m_fnFaxDevStartJob(
			LineHandle,
			DeviceId,
			FaxHandle,
			CompletionPortHandle,
			CompletionKey
			);
		if (FALSE == bStatus)
		{
			::lgLogDetail(
				LOG_X,
				7,
				TEXT("FaxDevStartJob returned FALSE")
				);
		}
		else
		{
			::lgLogDetail(
				LOG_X,
				7,
				TEXT("FaxDevStartJob returned TRUE")
				);
		}
	}
	__except(EXCEPTION_EXECUTE_HANDLER )
	{
		lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevStartJob() raised an exception of type: 0x%08x"),
			GetExceptionCode()
			);
	}
	return (TRUE == bStatus);
}

bool CFspWrapper::FaxDevInitialize(
	IN  HLINEAPP				LineAppHandle,
	IN  HANDLE					HeapHandle,
	OUT PFAX_LINECALLBACK*		LineCallbackFunction,
	IN  PFAX_SERVICE_CALLBACK	FaxServiceCallback
	) const
{
	BOOL bStatus = FALSE;
	__try
	{
		::lgLogDetail(
			LOG_X,
			7,
			TEXT("Calling FaxDevInitialize(0x%08x,0x%08x,0x%08x,0x%08x))"),
			LineAppHandle,
			HeapHandle,
			LineCallbackFunction,
			FaxServiceCallback
			);
		bStatus = m_fnFaxDevInitialize(
			LineAppHandle,
			HeapHandle,
			LineCallbackFunction,
			FaxServiceCallback
			);
		if (FALSE == bStatus)
		{
			::lgLogDetail(
				LOG_X,
				7,
				TEXT("FaxDevInitialize returned FALSE")
				);
		}
		else
		{
			::lgLogDetail(
				LOG_X,
				7,
				TEXT("FaxDevInitialize returned TRUE")
				);
		}
	}
	__except(EXCEPTION_EXECUTE_HANDLER )
	{
		lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevInitialize() raised an exception of type: 0x%08x"),
			GetExceptionCode()
			);
	}
	return (TRUE == bStatus);
}

bool CFspWrapper::FaxDevVirtualDeviceCreation(
	OUT LPDWORD		DeviceCount,
	OUT LPWSTR		DeviceNamePrefix,
	OUT LPDWORD		DeviceIdPrefix,
	IN  HANDLE		CompletionPort,
	IN  ULONG_PTR	CompletionKey
	) const
{
	BOOL bStatus = FALSE;
	__try
	{
		::lgLogDetail(
			LOG_X,
			7,
			TEXT("Calling FaxDevVirtualDeviceCreation(0x%08x,%s,0x%08x,0x%08x,0x%08x)"),
			DeviceCount,
			DeviceNamePrefix,
			DeviceIdPrefix,
			CompletionPort,
			CompletionKey
			);
		bStatus = m_fnFaxDevVirtualDeviceCreation(
			DeviceCount,
			DeviceNamePrefix,
			DeviceIdPrefix,
			CompletionPort,
			CompletionKey
			);
		if (FALSE == bStatus)
		{
			::lgLogDetail(
				LOG_X,
				7,
				TEXT("FaxDevVirtualDeviceCreation returned FALSE")
				);
		}
		else
		{
			::lgLogDetail(
				LOG_X,
				7,
				TEXT("FaxDevVirtualDeviceCreation returned TRUE")
				);
		}
	}
	__except(EXCEPTION_EXECUTE_HANDLER )
	{
		lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevVirtualDeviceCreation() raised an exception of type: 0x%08x"),
			GetExceptionCode()
			);
	}
	return (TRUE == bStatus);
}


bool CFspWrapper::FaxDevReportStatus(
	IN  HANDLE				FaxHandle OPTIONAL,
	OUT PFAX_DEV_STATUS		FaxStatus,
	IN  DWORD				FaxStatusSize,
	OUT LPDWORD				FaxStatusSizeRequired
	) const
{
	BOOL bStatus = FALSE;
	__try
	{
		::lgLogDetail(
			LOG_X,
			7,
			TEXT("Calling FaxDevReportStatus(0x%08x,0x%08x,0x%08x,0x%08x)"),
			FaxHandle,
			FaxStatus,
			FaxStatusSize,
			FaxStatusSizeRequired
			);
		bStatus = m_fnFaxDevReportStatus(
			FaxHandle OPTIONAL,			
			FaxStatus,
			FaxStatusSize,
			FaxStatusSizeRequired
			);
		if (FALSE == bStatus)
		{
			::lgLogDetail(
				LOG_X,
				7,
				TEXT("FaxDevReportStatus returned FALSE")
				);
		}
		else
		{
			::lgLogDetail(
				LOG_X,
				7,
				TEXT("FaxDevReportStatus returned TRUE")
				);
		}
	}
	__except(EXCEPTION_EXECUTE_HANDLER )
	{
		lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevReportStatus() raised an exception of type: 0x%08x"),
			GetExceptionCode()
			);
	}
	return (TRUE == bStatus);
}

bool CFspWrapper::FaxDevSend(
	IN  HANDLE				FaxHandle,
	IN  PFAX_SEND			FaxSend,
	IN  PFAX_SEND_CALLBACK	FaxSendCallback
	) const
{
	BOOL bStatus = FALSE;
	__try
	{
		::lgLogDetail(
			LOG_X,
			7,
			TEXT("Calling FaxDevSend(0x%08x,0x%08x,0x%08x)"),
			FaxHandle,
			FaxSend,
			FaxSendCallback
			);
		bStatus = m_fnFaxDevSend(
			FaxHandle,
			FaxSend,
			FaxSendCallback
			);
		if (FALSE == bStatus)
		{
			::lgLogDetail(
				LOG_X,
				7,
				TEXT("FaxDevSend returned FALSE")
				);
		}
		else
		{
			::lgLogDetail(
				LOG_X,
				7,
				TEXT("FaxDevSend returned TRUE")
				);
		}
	}
	__except(EXCEPTION_EXECUTE_HANDLER )
	{
		lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevSend() raised an exception of type: 0x%08x"),
			GetExceptionCode()
			);
	}
	return (TRUE == bStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\fsp\3rdpartyfsp_verifier\cfspwrapper.h ===
#ifndef CfspWrapper_h
#define CfspWrapper_h

#include <WINFAX.H>
#include <faxDev.h>
#include <log.h>
#include <windows.h>
#include "CS.h"

class CFspWrapper
{
protected:
	static CCriticalSection*		sm_pCsProvider;
public:
	TCHAR                           m_szImageName[MAX_PATH];
	HINSTANCE						m_hInstModuleHandle;		//Dll handle
	
	//FSP API
	PFAXDEVRECEIVE					m_fnFaxDevReceive;
	PFAXDEVENDJOB					m_fnFaxDevEndJob;
	PFAXDEVABORTOPERATION			m_fnFaxDevAbortOperation;
	PFAXDEVSTARTJOB					m_fnFaxDevStartJob;
	PFAXDEVINITIALIZE				m_fnFaxDevInitialize;
	PFAXDEVVIRTUALDEVICECREATION	m_fnFaxDevVirtualDeviceCreation;
	PFAXDEVREPORTSTATUS				m_fnFaxDevReportStatus;
	PFAXDEVSEND						m_fnFaxDevSend;
	//call back function
	PFAX_LINECALLBACK               m_fnFaxDevCallback;

private:
	static bool CreateCriticalSection();
	void UnLoadModule(const bool bLog);
public:
	CFspWrapper();
	~CFspWrapper();
	
	bool GetProcAddressesFromModule(const bool bLog);
	bool Init(LPCTSTR EfspModuleName,const bool bLog=false);
	TCHAR* GetImageName();
	void SetCallbackFunction(const PFAX_LINECALLBACK pCallbackFunction);
	HINSTANCE GetModuleHandle() const;
	bool LoadModule(LPCTSTR szEfspModuleName,const bool bLog);
	static void LockProvider();
	static void UnlockProvider();


	//
	//FSP API
	//
	bool FaxDevReceive(
		IN			HANDLE			FaxHandle,
		IN			HCALL			CallHandle,
		IN OUT		PFAX_RECEIVE	FaxReceive
		) const;
	void FaxDevCallback(
		IN HANDLE		hFaxHandle,
		IN DWORD		hDevice,
		IN DWORD		dwMessage,
		IN DWORD_PTR	dwInstance,
		IN DWORD_PTR	dwParam1,
		IN DWORD_PTR	dwParam2,
		IN DWORD_PTR	dwParam3
		) const;
	bool FaxDevEndJob(IN  HANDLE FaxHandle) const;
	bool FaxDevAbortOperation(IN  HANDLE FaxHandle) const;
	bool FaxDevStartJob(
		IN  HLINE		LineHandle,
		IN  DWORD		DeviceId,
		OUT PHANDLE		FaxHandle,
		IN  HANDLE		CompletionPortHandle,
		IN  ULONG_PTR	CompletionKey
		) const;
	bool FaxDevInitialize(
		IN  HLINEAPP				LineAppHandle,
		IN  HANDLE					HeapHandle,
		OUT PFAX_LINECALLBACK*		LineCallbackFunction,
		IN  PFAX_SERVICE_CALLBACK	FaxServiceCallback
		) const;
	bool FaxDevVirtualDeviceCreation(
		OUT LPDWORD		DeviceCount,
		OUT LPWSTR		DeviceNamePrefix,
		OUT LPDWORD		DeviceIdPrefix,
		IN  HANDLE		CompletionPort,
		IN  ULONG_PTR	CompletionKey
		) const;
	bool FaxDevReportStatus(
		IN  HANDLE				FaxHandle OPTIONAL,
		OUT PFAX_DEV_STATUS		FaxStatus,
		IN  DWORD				FaxStatusSize,
		OUT LPDWORD				FaxStatusSizeRequired
		) const;
	bool FaxDevSend(
		IN  HANDLE				FaxHandle,
		IN  PFAX_SEND			FaxSend,
		IN  PFAX_SEND_CALLBACK	FaxSendCallback
		) const;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\fsp\3rdpartyfsp_verifier\clineinfo.cpp ===
#include <WINFAX.H>
#include <faxDev.h>
#include <log.h>
#include <TCHAR.h>
#ifdef USE_EXTENDED_FSPI
#include "Efsp\Service.h"
#else
#include "Fsp\Service.h"
#endif
#include "CLineInfo.h"

extern TCHAR*	g_szValidRecipientFaxNumber;
extern DWORD	g_dwReceiveTimeOut;

CLineInfo::CLineInfo(const DWORD dwDeviceId):
	m_dwDeviceId(dwDeviceId),
	m_szDeviceName(NULL),
	m_szCsid(NULL),
	m_dwFlags(0),
	m_hFaxHandle(NULL),
	m_dwState(-1),
	m_pFaxReceive(NULL),
	m_pFaxSend(NULL),
	m_bCanFaxDevReceiveFail(false),
	m_bIsJobCompleted(false),
	m_pCsLineInfo(NULL),
	m_hJobFinalState(NULL)
{
	;
}

CLineInfo::~CLineInfo()
{
	free (m_pFaxSend);
	free (m_pFaxReceive);
	free (m_szCsid);
	free (m_szDeviceName);
	SafeMakeDeviceStateUnAvailable();
	m_hFaxHandle			=	NULL;		// FSP job handle (provided by FaxDevStartJob)
	m_dwFlags				=	0;			// Device use flags (Send / Receive)
	m_szDeviceName			=	NULL;		// Device Tapi name
	m_szCsid				=	NULL;		// Calling stations identifier
	m_pFaxSend				=	NULL;
	m_pFaxReceive			=	NULL;
	m_bCanFaxDevReceiveFail	=	false;		//set to false in case of aborting receive jobs
	delete m_pCsLineInfo;
	m_pCsLineInfo = NULL;
	
}

bool CLineInfo::CreateReceiveThread()
{
	if (false == m_receiveThreadItem.StartThread(
		(LPTHREAD_START_ROUTINE) ReceiveThread,
		this
		))
	{
		return false;
	}
	return true;
}

void CLineInfo::SafeCloseReceiveThread()
{
	CS cs(*m_pCsLineInfo);
	m_receiveThreadItem.CloseHandleResetThreadId();
	m_receiveThreadItem.m_dwThreadId = 0;
	m_receiveThreadItem.m_hThread = NULL;
}

bool CLineInfo::IsReceiveThreadActive() const
{
	return (NULL != m_receiveThreadItem.m_hThread);
}

bool CLineInfo::WaitForReceiveThreadTerminate()
{
	if (false == IsReceiveThreadActive())
	{
		//
		//Thread has already terminated
		//
		return true;
	}

	DWORD dwStatus = WaitForSingleObject(m_receiveThreadItem.m_hThread,g_dwReceiveTimeOut);
	if (WAIT_TIMEOUT == dwStatus)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("WaitForSingleObject(pReceivingLineInfo->hReceiveThread) got a timeout after %d milliseconds"),
			g_dwReceiveTimeOut
			);
		return false;
	}
	if (WAIT_FAILED == dwStatus)
	{
		::lgLogError(
			LOG_SEV_2,
			TEXT("WaitForSingleObject(pReceivingLineInfo->GetReceiveThreadHandle()) returned WAIT_FAILED with last error %d"),
			::GetLastError()
			);
		return false;
	}
	assert(WAIT_OBJECT_0 == dwStatus);
	SafeCloseReceiveThread();
	
	return true;
}



bool CLineInfo::GetDefaultParamsForFaxSend(PFAX_SEND pfsFaxSend,LPCTSTR szSendFileName)
{
	pfsFaxSend->SizeOfStruct = sizeof(FAX_SEND);
	pfsFaxSend->FileName = _tcsdup(szSendFileName);
	pfsFaxSend->CallerName = _tcsdup(DEFAULT_SENDER_INFO__NAME);
	pfsFaxSend->CallerNumber = _tcsdup(DEFAULT_SENDER_INFO__FAX_NUMBER);
	pfsFaxSend->ReceiverName = _tcsdup(DEFAULT_RECIPIENT_INFO__NAME);
	pfsFaxSend->ReceiverNumber = _tcsdup(g_szValidRecipientFaxNumber);
	pfsFaxSend->Branding = DEFAULT_BRANDING;
	pfsFaxSend->CallHandle = NULL;
	pfsFaxSend->Reserved[0]     = 0;
	pfsFaxSend->Reserved[1]     = 0;
	pfsFaxSend->Reserved[2]     = 0;

	if (
		(NULL == pfsFaxSend->FileName)
		|| (NULL == pfsFaxSend->CallerName)
		|| (NULL == pfsFaxSend->CallerNumber)
		|| (NULL == pfsFaxSend->ReceiverName)
		|| (NULL == pfsFaxSend->ReceiverNumber)
	)
	{
		::lgLogError(
			LOG_SEV_2,
			TEXT("_tcsdup() failed")
			);
		goto error;
	}
	return true;

error:
	FreeDefaultParamsForFaxSend(pfsFaxSend);
	return false;
}


bool CLineInfo::GetDefaultParamsForFaxReceive(PFAX_RECEIVE pFaxReceive,LPCTSTR szReceiveFileName,LPCTSTR szReceiverName,LPCTSTR szReceiverNumber)
{
	pFaxReceive->SizeOfStruct	=	sizeof(FAX_RECEIVE);
	pFaxReceive->FileName		=	_tcsdup(szReceiveFileName);
	pFaxReceive->ReceiverName	=	_tcsdup(szReceiverName);
	pFaxReceive->ReceiverNumber	=	_tcsdup(szReceiverNumber);
	pFaxReceive->Reserved[0]	=	0;
	pFaxReceive->Reserved[1]	=	0;
	pFaxReceive->Reserved[2]	=	0;
	pFaxReceive->Reserved[3]	=	0;

		if (
			(NULL == pFaxReceive->FileName)
			|| (NULL == pFaxReceive->ReceiverName)
			|| (NULL == pFaxReceive->ReceiverNumber)
		)
	{
		::lgLogError(
			LOG_SEV_2,
			TEXT("_tcsdup() failed")
			);
		goto error;
	}
	return true;
error:
	FreeDefaultParamsForFaxReceive(pFaxReceive);
	return false;
}

void CLineInfo::FreeDefaultParamsForFaxSend(PFAX_SEND pfsFaxSend)
{
	//
	//Free / Reset all PFAX_SEND members
	//
	free(pfsFaxSend->FileName);
	free(pfsFaxSend->CallerName);
	free(pfsFaxSend->CallerNumber);
	free(pfsFaxSend->ReceiverName);
	free(pfsFaxSend->ReceiverNumber);
	pfsFaxSend->Branding		= false;
    pfsFaxSend->CallHandle		= NULL;
	pfsFaxSend->FileName		= NULL;
	pfsFaxSend->CallerName		= NULL;
	pfsFaxSend->CallerNumber	= NULL;
	pfsFaxSend->ReceiverName	= NULL;
	pfsFaxSend->ReceiverNumber	= NULL;
	pfsFaxSend->SizeOfStruct = 0;
}

void CLineInfo::FreeDefaultParamsForFaxReceive(PFAX_RECEIVE pfrFaxReceive)
{
	//
	//Free / Reset all PFAX_RECEIVE members
	//
	free(pfrFaxReceive->FileName);
	free(pfrFaxReceive->ReceiverName);
	free(pfrFaxReceive->ReceiverNumber);
	
	pfrFaxReceive->FileName			= NULL;
	pfrFaxReceive->ReceiverName		= NULL;
	pfrFaxReceive->ReceiverNumber	= NULL;
	pfrFaxReceive->SizeOfStruct		= 0;
}


//
//m_szDeviceName
//
LPTSTR CLineInfo::GetDeviceName() const
{
	return m_szDeviceName;
}


//
//m_szCsid
//
LPTSTR CLineInfo::GetCsid() const
{
	return m_szCsid;
}

//
//Critical section
//
void CLineInfo::Lock()
{
	assert(NULL != m_pCsLineInfo);
	m_pCsLineInfo->Enter();
}
void CLineInfo::UnLock()
{
	assert(NULL != m_pCsLineInfo);
	m_pCsLineInfo->Leave();
}

//
//m_hFaxHandle
//
HANDLE CLineInfo::GetJobHandle() const
{
	return m_hFaxHandle;
}
void CLineInfo::SafeSetJobHandle(HANDLE hJob)
{
	CS cs(*m_pCsLineInfo);
	m_bIsJobCompleted = false;
	m_hFaxHandle = hJob;
}

//
//m_bIsJobCompleted
//
bool CLineInfo::IsJobAtFinalState() const
{
	return m_bIsJobCompleted;
}
void CLineInfo::SafeSetJobAtFinalState()
{
	CS cs(*m_pCsLineInfo);
	m_bIsJobCompleted = true;
}
void CLineInfo::SafeSetJobNotAtFinalState()
{
	CS cs(*m_pCsLineInfo);
	m_bIsJobCompleted = false;
}



//
//m_dwFlags
//
bool CLineInfo::IsReceivingEnabled() const
{
	return (m_dwFlags & FPF_RECEIVE);
}
bool CLineInfo::SafeIsReceivingEnabled()
{
	CS cs(*m_pCsLineInfo);
	bool bRet = (m_dwFlags & FPF_RECEIVE);
	return bRet;
}
void CLineInfo::SafeEnableReceive()
{
	CS cs(*m_pCsLineInfo);
	m_dwFlags |= FPF_RECEIVE;
}
void CLineInfo::SafeDisableReceive()
{
	CS cs(*m_pCsLineInfo);
	m_dwFlags &= ~FPF_RECEIVE;
}
	

//
//m_dwState
//
void CLineInfo::SafeMakeDeviceStateUnAvailable()
{
	CS cs(*m_pCsLineInfo);
	m_dwState = FPS_UNAVAILABLE;
}
void CLineInfo::SafeMakeDeviceStateAvailable()
{
	CS cs(*m_pCsLineInfo);
	m_dwState = FPS_AVAILABLE;
}

DWORD CLineInfo::GetDeviceState() const
{
	return m_dwState;
}
	
bool CLineInfo::IsDeviceAvailable() const
{
	return (FPS_AVAILABLE == m_dwState);
}

//
//Can receive fail flag
//
bool CLineInfo::CanReceiveFail() const
{
	return m_bCanFaxDevReceiveFail;
}
void CLineInfo::EnableReceiveCanFail()
{
	m_bCanFaxDevReceiveFail = true;
}
void CLineInfo::DisableReceiveCanFail()
{
	m_bCanFaxDevReceiveFail = false;
}
//
//m_dwDeviceId
//
DWORD CLineInfo::GetDeviceId() const
{
	return m_dwDeviceId;
}


bool CLineInfo::CommonPrepareLineInfoParams(LPCTSTR szFilename,bool bIsReceiveLineinfo)
{
	bool bRet= false;
	
	m_hFaxHandle					= NULL;			// will contain job handles
	SafeMakeDeviceStateAvailable();				// device state
	m_dwFlags						= FPF_SEND;		// device use flags
	m_receiveThreadItem.m_hThread	= NULL;			// Handle to the receiving thread
	m_receiveThreadItem.m_dwThreadId= 0;			// Receiving thread ID
	m_szCsid						= ::_tcsdup(DEFAULT_DEVICE_CSID);
	if (NULL == m_szCsid)
	{
		goto out;
	}
	m_bCanFaxDevReceiveFail		= false;
	m_bIsJobCompleted			= false;
	m_pFaxSend					= NULL;
	m_pFaxReceive				= NULL;

	

	if (true == bIsReceiveLineinfo)
	{
		SafeEnableReceive();
		//
		//Receiving device
		//
		PFAX_RECEIVE pFaxReceive	=	NULL;
		DWORD dwReceiveSize			=	sizeof(FAX_RECEIVE) + FAXDEVRECEIVE_SIZE;
		
		//
		//Prepare the Receive structure
		//
		pFaxReceive = (PFAX_RECEIVE) malloc( dwReceiveSize );
		if (!pFaxReceive)
		{
			::lgLogError(
				LOG_SEV_1,
				TEXT("malloc() failed with error:%d"),
				::GetLastError()
				);
			goto out;
		}
		GetDefaultParamsForFaxReceive(pFaxReceive,szFilename,m_szDeviceName,m_szCsid);
		m_pFaxReceive = pFaxReceive;
	}
	else
	{
		//
		//Sending Device
		//
		PFAX_SEND pFaxSend			=	NULL;
		pFaxSend = (PFAX_SEND) malloc( sizeof(FAX_SEND));
		if (!pFaxSend)
		{
			::lgLogError(
				LOG_SEV_1,
				TEXT("malloc() failed with error:%d"),
				::GetLastError()
				);
			goto out;
		}
		GetDefaultParamsForFaxSend(pFaxSend,szFilename);
		m_pFaxSend = pFaxSend;
	}
	bRet = true;
out:
	return bRet;
}

//
//m_hJobFinalState
//
void CLineInfo::SafeSetFinalStateHandle(HANDLE hJobFinalState)
{
	m_hJobFinalState = hJobFinalState;
}
HANDLE CLineInfo::GetFinalStateHandle() const
{
	return m_hJobFinalState;
}
void CLineInfo::SafeCloseFinalStateHandle()
{
	if (NULL != m_hJobFinalState)
	{
		::CloseHandle(m_hJobFinalState);
		m_hJobFinalState = NULL;
	}
}

bool CLineInfo::CreateCriticalSection()
{
	assert(NULL == m_pCsLineInfo);
	m_pCsLineInfo = new CCriticalSection;
	if (NULL == m_pCsLineInfo)
	{
		::lgLogError(
			LOG_SEV_2,
			TEXT("new CCriticalSection failed")
			);
		return false;
	}
	return true;
}

bool CLineInfo::SetDeviceName(LPTSTR szDeviceName)
{
	m_szDeviceName = ::_tcsdup(szDeviceName);
	if (NULL == m_szDeviceName)
	{
		::lgLogError(
			LOG_SEV_2,
			TEXT("_tcsdup failed")
			);
		return false;
	}
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\fsp\3rdpartyfsp_verifier\efsp\aborts.cpp ===
//Aborts.cpp
#include <assert.h>
#include <TCHAR.h>
#include <WINFAX.H>
#include <faxDev.h>
#include <log\log.h>

#include "Service.h"
#include "CEfspWrapper.h"
#include "FaxDevSendExWrappers.h"

#ifdef __cplusplus
extern "C"
{
#endif

#include "..\tiff\test\tifftools\TiffTools.h"

#ifdef __cplusplus
}
#endif

extern HANDLE		g_hCompletionPortHandle;
extern DWORD		g_dwCaseNumber;
//
//device IDs
//
extern DWORD		g_dwInvalidDeviceId;
extern DWORD		g_dwSendingValidDeviceId;
extern DWORD		g_dwReceiveValidDeviceId;

extern CEfspWrapper *g_pEFSP;
extern CEfspLineInfo *g_pSendingLineInfo;
extern CEfspLineInfo *g_pReceivingLineInfo;

extern DWORD	g_dwTimeTillRingingStarts;
extern DWORD	g_dwTimeTillTransferingBitsStarts;

//
//Tiff files
//
extern TCHAR* g_szValid__TiffFileName;




void AbortReceiverBeforeReceive()
{
	//
	//Disable the receiving device from answering
	//
	g_pReceivingLineInfo->SafeDisableReceive();

	//
	//Start the send job
	//
	HANDLE hJob;
	if (false == g_pEFSP->FaxDevStartJob(
	    NULL,        //Non Tapi EFSP
		g_pReceivingLineInfo->GetDeviceId(),
		&hJob,
		g_hCompletionPortHandle,
		(ULONG_PTR) g_pReceivingLineInfo	// The completion key provided to the FSP is the LineInfo
		))								// pointer. When the FSP reports status it uses this key thus allowing
                                        // us to know to which line the status belongs.
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevStartJob() failed with error:%d"),
			::GetLastError()
			);
		goto out;
	}
	g_pReceivingLineInfo->SafeSetJobHandle(hJob);

	FAX_ABORT_ITEM faiAbortItem;
	faiAbortItem.pLineInfo		= g_pReceivingLineInfo;
	faiAbortItem.dwMilliSecondsBeforeCallingAbort =	0;
	faiAbortItem.bLogging = true;
	AbortOperationAndWaitForAbortState(&faiAbortItem);
	
out:
	//
	//End the send job
	//
	g_pReceivingLineInfo->SafeEndFaxJob();
	
	//
	//enable back the receiving device
	//
	g_pReceivingLineInfo->SafeEnableReceive();
}



void AbortSenderWhileRinging(DWORD dwMilliSecond)
{
	CThreadItem tiAbortThread;
	
	//
	//Disable the receiving device from answering
	//
	g_pReceivingLineInfo->SafeDisableReceive();

	//
	//Prepare the item to abort through the AbortThread
	//
	DWORD dwThreadStatus;
	FAX_ABORT_ITEM faiAbortItem;
	faiAbortItem.pLineInfo	= g_pSendingLineInfo;
	faiAbortItem.dwMilliSecondsBeforeCallingAbort =	dwMilliSecond;
	faiAbortItem.bLogging = true;

	if (false == tiAbortThread.StartThread(
		(LPTHREAD_START_ROUTINE) AbortOperationAndWaitForAbortState,
		&faiAbortItem
		))
	{
		goto out;
	}
	
	if (S_OK != SafeCreateValidSendingJob(g_pSendingLineInfo,g_pSendingLineInfo->m_pFaxSend->ReceiverNumber))
	{
		goto out;
	}
	
	assert(NULL != g_pSendingLineInfo->GetJobHandle());
	::lgLogDetail(
		LOG_X,
		5,
		TEXT("FaxDevSendEx() succeeded")
		);
	
	//
	//Before we end the job, we need to be sure the AbortOperation completed
	//We set the max time to dwMilliSecond + max time for abort operation + 2 seconds (just to be safe)
	//
	dwThreadStatus = WaitForSingleObject(tiAbortThread.m_hThread,dwMilliSecond+ 2000 + MAX_TIME_FOR_ABORT + MAX_TIME_FOR_REPORT_STATUS);
	if (WAIT_OBJECT_0 != dwThreadStatus)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("WaitForSingleObject(CallFaxAbortThread) returned %d"),
			dwThreadStatus
			);
		goto out;
	}

	
	
out:
	//
	//End the send job
	//
	g_pSendingLineInfo->SafeEndFaxJob();
	if (NULL != tiAbortThread.m_hThread)
	{
		::CloseHandle(tiAbortThread.m_hThread);
		tiAbortThread.m_hThread = NULL;
		tiAbortThread.m_dwThreadId = 0;
	}
	//
	//enable back the receiving device
	//
	g_pReceivingLineInfo->SafeEnableReceive();
}


void SimulatniousAbortSenderWhileRinging(DWORD dwSleepBeforeFirstAbort, DWORD dwSleepBeforeSecondAbort)
{
	CThreadItem tiFirstAbortThread;
	CThreadItem tiSecondAbortThread;
	
	//
	//Disable the receiving device from answering
	//
	g_pReceivingLineInfo->SafeDisableReceive();

	//
	//First abort thread
	//
	DWORD dwThreadStatus;
	FAX_ABORT_ITEM faiAbortFirstItem;
	faiAbortFirstItem.pLineInfo	= g_pSendingLineInfo;
	faiAbortFirstItem.dwMilliSecondsBeforeCallingAbort = dwSleepBeforeFirstAbort;
	faiAbortFirstItem.bLogging = true;
	
	//
	//create the abort thread
	//
	if (false == tiFirstAbortThread.StartThread(
		(LPTHREAD_START_ROUTINE) AbortOperationAndWaitForAbortState,
		&faiAbortFirstItem
		))
	{
		goto out;
	}
	
	//
	//Second abort thread
	//
	FAX_ABORT_ITEM faiAbortSecondItem;
	faiAbortSecondItem.pLineInfo	= g_pSendingLineInfo;
	faiAbortSecondItem.dwMilliSecondsBeforeCallingAbort = dwSleepBeforeSecondAbort;
	faiAbortSecondItem.bLogging = true;
	
	//
	//create the abort thread
	//
	if (false == tiSecondAbortThread.StartThread(
		(LPTHREAD_START_ROUTINE) AbortOperationAndWaitForAbortState,
		&faiAbortSecondItem
		))
	{
		goto out;
	}
	
	if (S_OK != SafeCreateValidSendingJob(g_pSendingLineInfo,g_pSendingLineInfo->m_pFaxSend->ReceiverNumber))
	{
		goto out;
	}
	
	assert(NULL != g_pSendingLineInfo->GetJobHandle());
	::lgLogDetail(
		LOG_X,
		5,
		TEXT("FaxDevSendEx() succeeded")
		);

	//
	//Before we end the job, we need to be sure the Abort Operations completed
	//We set the max time to dwMilliSecond + max time for abort operation + 2 seconds (just to be safe)
	//

	//
	//First abort thread
	//
	dwThreadStatus = WaitForSingleObject(tiFirstAbortThread.m_hThread,dwSleepBeforeFirstAbort+ 2000 + MAX_TIME_FOR_ABORT + MAX_TIME_FOR_REPORT_STATUS);
	if (WAIT_OBJECT_0 != dwThreadStatus)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("WaitForSingleObject(1'st abort thread) returned %d"),
			dwThreadStatus
			);
		goto out;
	}

	//
	//Second abort thread
	//
	dwThreadStatus = WaitForSingleObject(tiSecondAbortThread.m_hThread,dwSleepBeforeSecondAbort+ 2000 + MAX_TIME_FOR_ABORT + MAX_TIME_FOR_REPORT_STATUS);
	if (WAIT_OBJECT_0 != dwThreadStatus)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("WaitForSingleObject(2'nd abort thread) returned %d"),
			dwThreadStatus
			);
		goto out;
	}

	
	
out:
	//
	//End the send job
	//
	g_pSendingLineInfo->SafeEndFaxJob();

	if (NULL != tiFirstAbortThread.m_hThread)
	{
		::CloseHandle(tiFirstAbortThread.m_hThread);
		tiFirstAbortThread.m_hThread = NULL;
		tiFirstAbortThread.m_dwThreadId = 0;
	}
	if (NULL != tiSecondAbortThread.m_hThread)
	{
		::CloseHandle(tiSecondAbortThread.m_hThread);
		tiSecondAbortThread.m_hThread = NULL;
		tiSecondAbortThread.m_dwThreadId = 0;
	}
	
	//
	//enable back the receiving device
	//
	g_pReceivingLineInfo->SafeEnableReceive();;
}


void AbortSenderWhileTransferingBits(DWORD dwMilliSecond)
{
	CThreadItem tiAbortThread;
	LPFSPI_JOB_STATUS pReceivingDevStatus = NULL;
	
	g_pReceivingLineInfo->EnableReceiveCanFail();

	//
	//Prepare the item to abort through the AbortThread
	//
	DWORD dwStatus;
	FAX_ABORT_ITEM faiAbortItem;
	faiAbortItem.pLineInfo	= g_pSendingLineInfo;
	faiAbortItem.dwMilliSecondsBeforeCallingAbort =	dwMilliSecond;
	faiAbortItem.bLogging = true;

	//
	//create the abort thread
	//
	if (false == tiAbortThread.StartThread(
		(LPTHREAD_START_ROUTINE) AbortOperationAndWaitForAbortState,
		&faiAbortItem
		))
	{
		goto out;
	}

	if (S_OK != SafeCreateValidSendingJob(g_pSendingLineInfo,g_pSendingLineInfo->m_pFaxSend->ReceiverNumber))
	{
		goto out;
	}
	else
	{
		::lgLogDetail(
			LOG_X,
			5,
			TEXT("While aborting the send job: FaxDevSend() succeeded")
			);
	}

	//
	//Wait till the abort thread signals us for finishing
	//
	dwStatus = WaitForSingleObject(tiAbortThread.m_hThread,dwMilliSecond+ 2000 + MAX_TIME_FOR_ABORT + MAX_TIME_FOR_REPORT_STATUS);
	if (WAIT_TIMEOUT == dwStatus)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("got a timeout for Aborting")
			);
		goto out;
	}

	if (WAIT_OBJECT_0 != dwStatus)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("WaitForSingleObject(Abort send thread) returned %d"),
			dwStatus
			);
		goto out;
	}

	//
	//Send operation was aborted, now let's check what's happening with the receive job
	//

	//
	//Now we need to wait till the receive thread finishes (FaxDevReceive() returns)
	//Since we can't close handles and end jobs when FaxDevReceive didn't return
	//
	if (false == g_pReceivingLineInfo->WaitForReceiveThreadTerminate())
	{
		goto out;
	}

	//
	//OK, receive thread has terminated, now let's check the status of the receive job
	//
	if (false == g_pReceivingLineInfo->GetDevStatus(
		&pReceivingDevStatus,
		true				
		))
	{
		//
		//GetDevStatus() failed, logging is in GetDevStatus()
		//
		goto out;
	}
	else
	{
		//
		//We aborted the receive job, so it can either be in the following status:
		//FSPI_JS_ABORTED, FSPI_JS_FAILED, FSPI_JS_UNKNOWN
		//
		if ( (FSPI_JS_ABORTED	== pReceivingDevStatus->dwJobStatus ) ||
			 (FSPI_JS_FAILED	== pReceivingDevStatus->dwJobStatus ) ||
			 (FSPI_JS_UNKNOWN	== pReceivingDevStatus->dwJobStatus )
			 )
		{
			::lgLogDetail(
				LOG_PASS,
				2,
				TEXT("Receive Job: GetDevStatus() reported JobStatus: 0x%08x"),
				pReceivingDevStatus->dwJobStatus 
				);
		}
		else
		{
			::lgLogError(
				LOG_SEV_1,
				TEXT("Receive Job: GetDevStatus() should report JobStatus: FSPI_JS_ABORTED or FSPI_JS_FAILED or FSPI_JS_UNKNOWN for the receiving job and not, 0x%08x"),
				pReceivingDevStatus->dwJobStatus 
				);
		}
	}
	
out:
	//
	//End the jobs
	//
	g_pSendingLineInfo->SafeEndFaxJob();
	g_pReceivingLineInfo->SafeEndFaxJob();
	if (NULL != tiAbortThread.m_hThread)
	{
		::CloseHandle(tiAbortThread.m_hThread);
		tiAbortThread.m_hThread = NULL;
		tiAbortThread.m_dwThreadId = 0;
	}
}

void AbortReceivierWhileTransferingBits(DWORD dwMilliSecond)
{
	CThreadItem tiAbortThread;
	LPFSPI_JOB_STATUS pSendingDevStatus = NULL;
		
	g_pReceivingLineInfo->EnableReceiveCanFail();

	//
	//Prepare the item to abort through the AbortThread(we want to abort the receive job
	//
	DWORD dwThreadStatus;
	FAX_ABORT_ITEM faiAbortItem;
	faiAbortItem.pLineInfo	= g_pReceivingLineInfo;
	faiAbortItem.dwMilliSecondsBeforeCallingAbort =	dwMilliSecond;
	faiAbortItem.bLogging = true;

	//
	//create the abort thread
	//
	if (false == tiAbortThread.StartThread(
		(LPTHREAD_START_ROUTINE) AbortOperationAndWaitForAbortState,
		&faiAbortItem
		))
	{
		goto out;
	}
	
	if (S_OK != SafeCreateValidSendingJob(g_pSendingLineInfo,g_pSendingLineInfo->m_pFaxSend->ReceiverNumber))
	{
		goto out;
	}
	else
	{
		::lgLogDetail(
			LOG_X,
			5,
			TEXT("While aborting the receive job: FaxDevSend() succeeded")
			);
	}

	//
	//Before we end the job, we need to be sure the AbortOperation completed
	//We set the max time to dwMilliSecond + max time for abort operation + 2 seconds (just to be safe)
	//
	dwThreadStatus = WaitForSingleObject(tiAbortThread.m_hThread,dwMilliSecond+ 2000 + MAX_TIME_FOR_ABORT + MAX_TIME_FOR_REPORT_STATUS);
	if (WAIT_TIMEOUT == dwThreadStatus)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("got a timeout for Aborting")
			);
		goto out;
	}

	if (WAIT_OBJECT_0 != dwThreadStatus)
	{
		::lgLogError(
			LOG_SEV_2,
			TEXT("WaitForSingleObject(Abort receive thread) returned %d"),
			dwThreadStatus
			);
		goto out;
	}

	//
	//Now we need to wait till the receive thread finishes (FaxDevReceive() returns)
	//Since we can't close handles and end jobs when FaxDevReceive didn't return
	//
	if (false == g_pReceivingLineInfo->WaitForReceiveThreadTerminate())
	{
		goto out;
	}

	//
	//receive operation was finshed and aborted, now let's check what's happening with the send job
	//
	//
	//Get the status through FaxDevReportStatus
	//
	if (false == g_pSendingLineInfo->GetDevStatus(
		&pSendingDevStatus,
		true				
		))
	{
		//
		//GetDevStatus() failed, logging is in GetDevStatus()
		//
		goto out;
	}
	else
	{
		//
		//We aborted the receive job, so it can either be in the following status:
		//FSPI_JS_ABORTED, FSPI_JS_FAILED, FSPI_JS_UNKNOWN
		//
		if ( (FSPI_JS_ABORTED	== pSendingDevStatus->dwJobStatus) ||
			 (FSPI_JS_FAILED	== pSendingDevStatus->dwJobStatus) ||
			 (FSPI_JS_UNKNOWN	== pSendingDevStatus->dwJobStatus)
			 )
		{
			::lgLogDetail(
				LOG_PASS,
				2,
				TEXT("Send Job: GetDevStatus() reported JobStatus:0x%08x as expected"),
				pSendingDevStatus->dwJobStatus
				);
		}
		else
		{
			::lgLogError(
				LOG_SEV_1,
				TEXT("Send Job: GetDevStatus() should report JobStatus: FSPI_JS_ABORTED or FSPI_JS_FAILED or FSPI_JS_UNKNOWN for the receiving job and not, 0x%08x"),
				pSendingDevStatus->dwJobStatus
				);
		}
	}
	
out:
	//
	//End the jobs
	//
	g_pSendingLineInfo->SafeEndFaxJob();
	g_pReceivingLineInfo->SafeEndFaxJob();
	if (NULL != tiAbortThread.m_hThread)
	{
		::CloseHandle(tiAbortThread.m_hThread);
		tiAbortThread.m_hThread = NULL;
		tiAbortThread.m_dwThreadId = 0;
	}
}


void Suite_Abort()
{
	::lgBeginSuite(TEXT("Abort tests"));

	
	//
	//Abort The receive job before call FaxDevReceive()
	//
	if (true == RunThisTest(++g_dwCaseNumber))
	{														
		::lgBeginCase(g_dwCaseNumber,TEXT("Abort The Receive job before call FaxDevReceive()"));
		AbortReceiverBeforeReceive();
		::lgEndCase();
	}

	//
	//Abort the sender while ringing
	//
	DWORD dwSleepBeforeAbort;

	dwSleepBeforeAbort = g_dwTimeTillRingingStarts;
	TCHAR szLogMessage[1000];
	_stprintf(szLogMessage,TEXT("Abort The send job %d milliSeconds after calling FaxDevSend()"),dwSleepBeforeAbort );
	if (true == RunThisTest(++g_dwCaseNumber))
	{														
		::lgBeginCase(g_dwCaseNumber,szLogMessage);
		AbortSenderWhileRinging(dwSleepBeforeAbort);
		::lgEndCase();
	}

	//
	//abort from 2 threads simulatanisly
	//
	DWORD dwSleepBeforeFirstAbort = g_dwTimeTillRingingStarts;
	DWORD dwSleepBeforeSecondAbort= g_dwTimeTillRingingStarts;
	_stprintf(szLogMessage,TEXT("Aborting the send job from 2 threads simulatinously (first abort after %d milliSeconds, second abort after %d milliSeconds)"),dwSleepBeforeFirstAbort,dwSleepBeforeSecondAbort);
	if (true == RunThisTest(++g_dwCaseNumber))
	{														
		::lgBeginCase(g_dwCaseNumber,szLogMessage);
		SimulatniousAbortSenderWhileRinging(dwSleepBeforeFirstAbort,dwSleepBeforeSecondAbort);
		::lgEndCase();
	}


	//
	//Abort The send job after a random time after calling FaxDevSend()
	//
	
	dwSleepBeforeAbort = g_dwTimeTillTransferingBitsStarts;	
	_stprintf(szLogMessage,TEXT("Abort the sender job while transfering Bits (%d milliSeconds after calling FaxDevSend())"),dwSleepBeforeAbort );
	if (true == RunThisTest(++g_dwCaseNumber))
	{														
		::lgBeginCase(g_dwCaseNumber,szLogMessage);
		AbortSenderWhileTransferingBits(dwSleepBeforeAbort);
		::lgEndCase();
	}

	//
	//Abort The receive job after a random time after calling FaxDevSend()
	//
	dwSleepBeforeAbort = g_dwTimeTillTransferingBitsStarts;
	_stprintf(szLogMessage,TEXT("Abort the receive job while transfering Bits (%d milliSeconds after calling FaxDevSend())"),dwSleepBeforeAbort );
	if (true == RunThisTest(++g_dwCaseNumber))
	{														
		::lgBeginCase(g_dwCaseNumber,szLogMessage);
		AbortReceivierWhileTransferingBits(dwSleepBeforeAbort);
		::lgEndCase();
	}

	::lgEndSuite();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\fsp\3rdpartyfsp_verifier\clineinfo.h ===
#ifndef CLineInfo_h
#define CLineInfo_h

#include "CS.h"
#include <assert.h>
#include "CThreadItem.h"

class CLineInfo
{
private:
	CCriticalSection*	m_pCsLineInfo;
	HANDLE				m_hFaxHandle;					// EFSP job handle (provided by FaxDevStartJob)
    const DWORD         m_dwDeviceId;					// provider device id(Virtual or Tapi)
    DWORD               m_dwState;						// Device state
    DWORD               m_dwFlags;						// Device use flags (Send / Receive)
	bool				m_bCanFaxDevReceiveFail;		// set to false in case of aborting receive jobs
	LPTSTR              m_szDeviceName;					// Device friendly name (Virtual or Tapi)
    LPTSTR              m_szCsid;						// Calling station's identifier
	CThreadItem			m_receiveThreadItem;			// Receiving thread
	bool				m_bIsJobCompleted;
	HANDLE				m_hJobFinalState;				// signaled when the job reaches a final state
	
public:
	PFAX_RECEIVE		m_pFaxReceive;
	PFAX_SEND			m_pFaxSend;
	
protected:
	bool CommonPrepareLineInfoParams(LPCTSTR szFilename,bool bIsReceiveLineinfo);

public:
	CLineInfo(const DWORD dwDeviceId);
	~CLineInfo();
	virtual void ResetParams()=0;
	virtual void SafeEndFaxJob()=0;
	virtual bool PrepareLineInfoParams(LPCTSTR szFilename,bool bIsReceiveLineinfo)=0;
	
	bool CreateCriticalSection();
	
	void SafeSetFinalStateHandle(HANDLE hJobFinalState);
	HANDLE GetFinalStateHandle() const;
	void SafeCloseFinalStateHandle();
	
	bool CreateReceiveThread();
	void SafeCloseReceiveThread();
	bool IsReceiveThreadActive() const;
	bool WaitForReceiveThreadTerminate();

	
	void Lock();
	void UnLock();
	
	DWORD GetDeviceId() const;
	LPTSTR GetDeviceName() const;
	LPTSTR GetCsid() const;
	bool SetDeviceName(LPTSTR szDeviceName);
	
	HANDLE GetJobHandle() const;
	void SafeSetJobHandle(HANDLE hJob);

	bool IsJobAtFinalState() const;
	void SafeSetJobAtFinalState();
	void SafeSetJobNotAtFinalState();
	
	bool IsReceivingEnabled() const;
	bool SafeIsReceivingEnabled();
	void SafeEnableReceive();
	void SafeDisableReceive();
	
	bool IsDeviceAvailable() const;
	void SafeMakeDeviceStateUnAvailable();
	void SafeMakeDeviceStateAvailable();
	
	DWORD GetDeviceState() const;
	
	bool CanReceiveFail() const;
	void EnableReceiveCanFail();
	void DisableReceiveCanFail();
	
	
	static bool GetDefaultParamsForFaxSend(PFAX_SEND pfsFaxSend,LPCTSTR szSendFileName);
	static void FreeDefaultParamsForFaxSend(PFAX_SEND pfsFaxSend);
	static bool GetDefaultParamsForFaxReceive(PFAX_RECEIVE pFaxReceive,LPCTSTR szReceiveFileName,LPCTSTR szReceiverName,LPCTSTR szReceiverNumber);
	static void FreeDefaultParamsForFaxReceive(PFAX_RECEIVE pfsFaxReceive);
	
		
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\fsp\3rdpartyfsp_verifier\tiffs.cpp ===
//Tiffs.cpp

///////////////////////////////////////////////////
//THIS FILE IS COMMON BOTH TO EFSP AND FSP TESTER//
///////////////////////////////////////////////////

#include <assert.h>
#include <TCHAR.h>
#include <WINFAX.H>
#include <faxDev.h>
#include <log.h>

#ifdef USE_EXTENDED_FSPI
	
	//
	//EFSP headers
	//
	#include "EfspTester\CEfspWrapper.h"
	#include "EfspTester\Service.h"
	#include "EfspTester\FaxDevSendExWrappers.h"
	
	extern TCHAR* g_szValid__CoverpageFileName;
	bool g_reloadFspEachTest = false;				//In the EFSP tester we don't use this mechanism
	
	extern CEfspWrapper	*g_pEFSP;					//declared in the main module
	extern CEfspLineInfo *g_pSendingLineInfo;
	extern CEfspLineInfo *g_pReceivingLineInfo;
#else
	
	//
	//FSP headers
	//
	#include "Fsp\Service.h"
	#include "CFspWrapper.h"
	#include "Fsp\TapiDbg.h"

	extern HANDLE		g_hTapiCompletionPort;		//declared in the main module
	extern HANDLE		g_hCompletionPortHandle;
	extern HLINEAPP		g_hLineAppHandle;			//Tapi app handle
	extern bool			g_bIgnoreErrorCodeBug;	//RAID: T30 bug, raid # 8038(EdgeBugs)
	extern bool			g_bT30_OneLineDiffBUG;	//RAID: T30 bug, raid # 8040(EdgeBugs)
	extern bool			g_reloadFspEachTest;

	extern CFspWrapper	*g_pFSP;					//declared in the main module
	extern CFspLineInfo *g_pSendingLineInfo;
	extern CFspLineInfo *g_pReceivingLineInfo;
#endif
	


//
//device IDs
//
extern DWORD		g_dwInvalidDeviceId;
extern DWORD		g_dwSendingValidDeviceId;
extern DWORD		g_dwReceiveValidDeviceId;

//
//Phone numbers
//
extern TCHAR*		g_szInvalidRecipientFaxNumber;
extern DWORD		g_dwCaseNumber;


//
//Tiff files
//
extern TCHAR* g_szValid__TiffFileName;
extern TCHAR* g_szValid_ReadOnly_TiffFileName;
extern TCHAR* g_szValid_UNC_TiffFileName;
extern TCHAR* g_szValid_NTFS_TiffFileName;
extern TCHAR* g_szValid_FAT_TiffFileName;
extern TCHAR* g_szValid_Link_TiffFileName;
extern TCHAR* g_szValid_ReceiveFileName;	//filename to receive  tiff to


#ifdef __cplusplus
extern "C"
{
#endif

#include "..\tiff\test\tifftools\TiffTools.h"

#ifdef __cplusplus
}
#endif


#ifdef USE_EXTENDED_FSPI

//
//EFSP Send Receive
//
bool SendReceive(CEfspLineInfo *pSendingLineInfo,CEfspLineInfo *pReceivingLineInfo)
{
	HRESULT hr = S_OK;
	bool bAreTiffTheSame = false;
	DWORD dwStatus = -1;
	LPFSPI_JOB_STATUS pSendingDevStatus = NULL;
	LPFSPI_JOB_STATUS pReceivingDevStatus = NULL;

	DWORD dwMaxMessageIdSize = g_pEFSP->m_dwMaxMessageIdSize;
	LPFSPI_MESSAGE_ID	lpRecipientMessageIds	= NULL;    // This array holds the message id structures array used as output parameter to FaxDevSendEx()
	PHANDLE				lpRecipientJobHandles	= NULL;				// This array holds the recipient job handles array used as output parameter to FaxDevSendEx()
	FSPI_MESSAGE_ID		ParentMessageId;                    // The parent message id returned by FaxDevSendEx()
    LPFSPI_MESSAGE_ID	lpParentMessageId		= NULL;         // Points to the parent message id if it is used.
                                                        // NULL in case of an EFSP that does not support job reestablishment.
	HANDLE				hParent					= NULL;								// The parent job handle returned by FaxDevSendEx()
	
	::lgLogDetail(
		LOG_X,
		5,
		TEXT("Send the file: \"%s\" with device \"%s\" to recipient device \"%s\" number(%s) on file: \"%s\" "),
		pSendingLineInfo->m_pFaxSend->FileName,
		pSendingLineInfo->GetDeviceName(),
		pReceivingLineInfo->GetDeviceName(),
		pSendingLineInfo->m_pFaxSend->ReceiverNumber,
		pReceivingLineInfo->m_pFaxReceive->FileName
		);

	pSendingLineInfo->ResetParams();
	pReceivingLineInfo->ResetParams();

	//
	//Create events to signal the finish of the send job and the receive job
	//
	HANDLE hTmp = CreateEvent(NULL,false,false,NULL);
	if (NULL == hTmp)
	{
		::lgLogError(
			LOG_SEV_2, 
            TEXT("Failed to CreateEvent, error:%ld)"),
            GetLastError()
			);
		hr = FSPI_E_NOMEM;
		goto out;
	}
	pSendingLineInfo->SafeSetFinalStateHandle(hTmp);
	
	hTmp = CreateEvent(NULL,false,false,NULL);
	if (NULL == hTmp)
	{
		::lgLogError(
			LOG_SEV_2, 
            TEXT("Failed to CreateEvent, error:%ld)"),
            GetLastError()
			);
		hr = FSPI_E_NOMEM;
		goto out;
	}
	pReceivingLineInfo->SafeSetFinalStateHandle(hTmp);
		
	
	
	//
	//Prepare the Send job
	//
	
	//
    //Coverpage for send fax
    //
	FSPI_COVERPAGE_INFO covEFSPICoverPage;
	PrepareFSPICoverPage(
			&covEFSPICoverPage,
		    FSPI_COVER_PAGE_FMT_COV,
			1,
			g_szValid__CoverpageFileName,
			DEFAULT_COVERPAGE_NOTE,
			DEFAULT_COVERPAGE_SUBJECT
			);

	//
	//schedule of send fax
	//
	SYSTEMTIME tmSchedule;
	tmSchedule.wYear = 0;
	tmSchedule.wMonth = 0;
	tmSchedule.wDayOfWeek = 0;
	tmSchedule.wDay = 0;
	tmSchedule.wHour = 0;
	tmSchedule.wMinute = 0;
	tmSchedule.wSecond = 0;
	tmSchedule.wMilliseconds = 0;
	
	//
	//Sender and recipient profiles
	//
	FSPI_PERSONAL_PROFILE FSPISenderInfo;				// The Sender information sent to FaxDevSendEx()
	FSPI_PERSONAL_PROFILE FSPIRecipientInfo;			// The recipient information sent to FaxDevSendEx()
	
	PreparePersonalProfile(
		&FSPISenderInfo,
		pSendingLineInfo->m_pFaxSend->CallerName,
		pSendingLineInfo->m_pFaxSend->CallerNumber,
		DEFAULT_SENDER_INFO__COMPANY,
		DEFAULT_SENDER_INFO__STREET,
		DEFAULT_SENDER_INFO__CITY,
		DEFAULT_SENDER_INFO__STATE,
		DEFAULT_SENDER_INFO__ZIP,
		DEFAULT_SENDER_INFO__COUNTRY,
		DEFAULT_SENDER_INFO__TITLE,
		DEFAULT_SENDER_INFO__DEPT,
		DEFAULT_SENDER_INFO__OFFICE_LOCATION,
		DEFAULT_SENDER_INFO__HOME_PHONE,
		DEFAULT_SENDER_INFO__OFFICE_PHONE,
		DEFAULT_SENDER_INFO__ORG_MAIL,
		DEFAULT_SENDER_INFO__INTERNET_MAIL,
		DEFAULT_SENDER_INFO__BILLING_CODE
		);

	PreparePersonalProfile(
		&FSPIRecipientInfo,
		pSendingLineInfo->m_pFaxSend->ReceiverName,
		pSendingLineInfo->m_pFaxSend->ReceiverNumber,
		DEFAULT_RECIPIENT_INFO__COMPANY,
		DEFAULT_RECIPIENT_INFO__STREET,
		DEFAULT_RECIPIENT_INFO__CITY,
		DEFAULT_RECIPIENT_INFO__STATE,
		DEFAULT_RECIPIENT_INFO__ZIP,
		DEFAULT_RECIPIENT_INFO__COUNTRY,
		DEFAULT_RECIPIENT_INFO__TITLE,
		DEFAULT_RECIPIENT_INFO__DEPT,
		DEFAULT_RECIPIENT_INFO__OFFICE_LOCATION,
		DEFAULT_RECIPIENT_INFO__HOME_PHONE,
		DEFAULT_RECIPIENT_INFO__OFFICE_PHONE,
		DEFAULT_RECIPIENT_INFO__ORG_MAIL,
		DEFAULT_RECIPIENT_INFO__INTERNET_MAIL,
		DEFAULT_RECIPIENT_INFO__BILLING_CODE
		);
	

	//
    // Allocate the FSP recipient job handles array
    //
    lpRecipientJobHandles = (PHANDLE)malloc(sizeof (HANDLE));
    if (!lpRecipientJobHandles)
    {
        ::lgLogError(
			LOG_SEV_2, 
            TEXT("Failed to allocate recipient job handles array, error:%ld)"),
            GetLastError()
			);
		hr = FSPI_E_NOMEM;
		goto out;
    }


	//
	//Allocate and init lpRecipientMessageIds and lpParentMessageId
	//
	if (0 < dwMaxMessageIdSize)
	{
		//
        // The EFSP supports job reestablishment
        //


		//
		// Allocate and initialize the recipients permanent message ids array
		//
		hr = CreateFSPIRecipientMessageIdsArray(
			&lpRecipientMessageIds,
			1,
			dwMaxMessageIdSize
			);
		if (S_OK != hr)
		{
			lpRecipientMessageIds = NULL;
			::lgLogError(
				LOG_SEV_2, 
				TEXT("CreateFSPIRecipientMessageIdsArray() failed with error:0x%08x"),
				hr
				);
			goto out;
		}
		
		//
		// Allocate the parent permanent message id
		//
		memset(&ParentMessageId,0,sizeof(FSPI_MESSAGE_ID));
		ParentMessageId.dwSizeOfStruct = sizeof(FSPI_MESSAGE_ID);
		ParentMessageId.dwIdSize = dwMaxMessageIdSize;
		ParentMessageId.lpbId = (LPBYTE)malloc(ParentMessageId.dwIdSize);
		if (!ParentMessageId.lpbId)
		{
			::lgLogError(
				LOG_SEV_2, 
				TEXT("Failed to allocate permanent message id buffer for parent job. MaxMessageIdSize: %ld. (ec: %ld)"),
				dwMaxMessageIdSize,
				GetLastError()
				);
			hr = FSPI_E_NOMEM;
			goto out;
		}
		lpParentMessageId = &ParentMessageId;
	}
	else
	{
		lpRecipientMessageIds = NULL;
        lpParentMessageId = NULL;
	}
	
	
	
	//
	//OK, all the params are ready, do the FaxDevSendEx
	//
	hr = g_pEFSP->FaxDevSendEx(
        NULL,							//NON TAPI EFSP
        pSendingLineInfo->GetDeviceId(),	//Sending device ID
        pSendingLineInfo->m_pFaxSend->FileName,
        &covEFSPICoverPage,
		tmSchedule,
        &FSPISenderInfo,
        1,
        &FSPIRecipientInfo,
        lpRecipientMessageIds,
        lpRecipientJobHandles,
        lpParentMessageId,
		&hParent
		);
	if (FSPI_S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FaxDevSendEx failed with error 0x%08x"),
			hr
			);
		goto out;
	}
	
	//
	//Save the job handle for future use
	//
	pSendingLineInfo->SafeSetJobHandle(lpRecipientJobHandles[0]);
	

	//
	//receiving is done through the FaxServiceCallback handler and not here
	//

	//
	//Wait for the send to finish and signal us
	//
	assert (NULL != pSendingLineInfo->GetFinalStateHandle());
	dwStatus = WaitForSingleObject(pSendingLineInfo->GetFinalStateHandle(),WAIT_FOR_JOB_FINAL_STATE_TIMEOUT);
	if (WAIT_TIMEOUT == dwStatus)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("Send job didn't reach a final state, got a timeout for WaitForSingleObject(pSendingLineInfo->m_hJobFinalState)")
			);
		goto out;
	}
	if (WAIT_OBJECT_0 != dwStatus)
	{
		::lgLogError(
			LOG_SEV_2,
			TEXT("WaitForSingleObject(pSendingLineInfo->m_hJobFinalState) returned %d"),
			dwStatus
			);
		goto out;
	}

	//
	//Wait for the receive to finish and signal us
	//
	assert (NULL != pReceivingLineInfo->GetFinalStateHandle());
	dwStatus = WaitForSingleObject(pReceivingLineInfo->GetFinalStateHandle(),WAIT_FOR_JOB_FINAL_STATE_TIMEOUT);
	if (WAIT_TIMEOUT == dwStatus)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("Receive job didn't reach a final state, got a timeout for WaitForSingleObject(pReceivingLineInfo->m_hJobFinalState)")
			);
		goto out;
	}
	if (WAIT_OBJECT_0 != dwStatus)
	{
		::lgLogError(
			LOG_SEV_2,
			TEXT("WaitForSingleObject(pReceivingLineInfo->m_hJobFinalState) returned %d"),
			dwStatus
			);
		goto out;
	}
	
	//
	//Just to be sure, let's wait till the receive thread terminates
	//
	if (false == pReceivingLineInfo->WaitForReceiveThreadTerminate())
	{
		goto out;
	}
	
	
	//
	//The received thread signaled us, we should have received a fax
	//
	assert(NULL != pReceivingLineInfo->m_pFaxReceive->FileName);
	assert(NULL != pReceivingLineInfo->GetJobHandle());

	//
	//Get the status through FaxDevReportStatus
	//
	pSendingLineInfo->GetDevStatus(
		&pSendingDevStatus
		,true				//log the report
		);
	pReceivingLineInfo->GetDevStatus(
		&pReceivingDevStatus
		,true				//log the report
		);

	//
	//Verify the send / receive jobs are at a completed state (FSPI_JS_COMPLETED)
	//
	if (FSPI_JS_COMPLETED == pSendingDevStatus->dwJobStatus)
	{
		::lgLogDetail(
			LOG_PASS,
			3,
			TEXT("Sending job: GetDevStatus() reported FSPI_JS_COMPLETED")
			);
	}
	else
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("Sending job: GetDevStatus() reported 0x%08x status instead of FSPI_JS_COMPLETED as expected"),
			pSendingDevStatus->dwJobStatus
			);
		goto out;
	}
	
	if (FSPI_JS_COMPLETED == pReceivingDevStatus->dwJobStatus)
	{
		::lgLogDetail(
			LOG_PASS,
			3,
			TEXT("Receiving job: GetDevStatus() reported FSPI_JS_COMPLETED")
			);
	}
	else
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("Receiving job: GetDevStatus() reported 0x%08x status instead of FSPI_JS_COMPLETED as expected"),
			pReceivingDevStatus->dwJobStatus
			);
		goto out;
	}
	
	//
	//Sending and receiving are finished, now we need to compare the Tiffs
	//
	if (0 == TiffCompare(pSendingLineInfo->m_pFaxSend->FileName,pReceivingLineInfo->m_pFaxReceive->FileName,TRUE))
	{
		bAreTiffTheSame = true;
	}
	else
	{
		bAreTiffTheSame = false;
		::lgLogError(
			LOG_SEV_1,
			TEXT("Tiff Compare failed")
			);
	}
	
out:
	::free(pSendingDevStatus);
	::free(pReceivingDevStatus);
	
	//
	//End the send and the receive job
	//
	g_pSendingLineInfo->SafeEndFaxJob();
	g_pReceivingLineInfo->SafeEndFaxJob();
		
	//
	//Free the handles
	//
	pSendingLineInfo->SafeCloseFinalStateHandle();
	pReceivingLineInfo->SafeCloseFinalStateHandle();

	//
	//Clear all the parameters
	//
	pSendingLineInfo->ResetParams();
	pReceivingLineInfo->ResetParams();

	return bAreTiffTheSame;
}

#else

//
// FSP Send Receive
// TODO: describe what function does.
//
bool SendReceive(CFspLineInfo * pSendingLineInfo,CFspLineInfo * pReceivingLineInfo)
{

	::lgLogDetail(
		LOG_X,
		5,
		TEXT("Send the file: \"%s\" with device \"%s\" to recipient device \"%s\" number(%s) on file: \"%s\" "),
		pSendingLineInfo->m_pFaxSend->FileName,
		pSendingLineInfo->GetDeviceName(),
		pReceivingLineInfo->GetDeviceName(),
		pSendingLineInfo->m_pFaxSend->ReceiverNumber,
		pReceivingLineInfo->m_pFaxReceive->FileName
		);
	
	bool bAreTiffTheSame = false;
	DWORD dwStatus = -1;
	PFAX_DEV_STATUS pSendingDevStatus = NULL;
	PFAX_DEV_STATUS pReceivingDevStatus = NULL;


	//
	//FaxDevSend params
	//
	PFAX_SEND_CALLBACK pFaxSendCallback = (PFAX_SEND_CALLBACK) FaxDevSend__SendCallBack;

	//
	//Start the send job
	//
	HANDLE hJob;
	if (false == g_pFSP->FaxDevStartJob(
	    pSendingLineInfo->GetLineHandle(),
		pSendingLineInfo->GetDeviceId(),
		&hJob,
		g_hCompletionPortHandle,
		(ULONG_PTR) pSendingLineInfo	// The completion key provided to the FSP is the LineInfo
		))								// pointer. When the FSP reports status it uses this key thus allowing
                                        // us to know to which line the status belongs.
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevStartJob() failed with error:%d"),
			::GetLastError()
			);
		goto out;
	}
	pSendingLineInfo->SafeSetJobHandle(hJob);

	if (false == g_pFSP->FaxDevSend(
	 	pSendingLineInfo->GetJobHandle(),
		pSendingLineInfo->m_pFaxSend,
		pFaxSendCallback
		))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevSend() failed with error:%d"),
			::GetLastError()
			);
		goto out;
	}
	
	//
	// receiving is done through the Tapi handler and not here
	//

	//
	// sending job is finished, wait for the signal from the receiving job
	//
	if (false == g_pReceivingLineInfo->WaitForReceiveThreadTerminate())
	{
		goto out;
	}

	//
	//The received thread signaled us, we should have received a fax
	//
	assert(NULL != pReceivingLineInfo->m_pFaxReceive->FileName);

	//
	//Get the status through FaxDevReportStatus
	//
	pSendingLineInfo->GetDevStatus(
		&pSendingDevStatus
		,true				//log the report
		);
	pReceivingLineInfo->GetDevStatus(
		&pReceivingDevStatus
		,true				//log the report
		);

	//
	//Let's verify that reportStatus reported correct values
	//Should have a no_error
	//
	VerifySendingStatus(pSendingDevStatus,false);
	
	//
	//Verify the send / receive jobs are at a completed state (FS_COMPLETED)
	//
	
	//
	//send job
	//
	if (FS_COMPLETED == pSendingDevStatus->StatusId)
	{
		::lgLogDetail(
			LOG_PASS,
			3,
			TEXT("Sending job: GetDevStatus() reported FS_COMPLETED")
			);
	}
	else
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("Sending job: GetDevStatus() reported 0x%08x status instead of FS_COMPLETED as expected"),
			pSendingDevStatus->StatusId
			);
	}
	if (false == g_bIgnoreErrorCodeBug)
	{
		if (NO_ERROR != pSendingDevStatus->ErrorCode)
		{
			::lgLogError(
				LOG_SEV_1,
				TEXT("Sending job: GetDevStatus() reported %d ErrorCode instead of NO_ERROR"),
				pSendingDevStatus->ErrorCode
				);
		}
	}

	//
	//receive job
	//
	if (FS_COMPLETED == pReceivingDevStatus->StatusId)
	{
		::lgLogDetail(
			LOG_PASS,
			3,
			TEXT("Receiving job: GetDevStatus() reported FS_COMPLETED")
			);
	}
	else
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("Receiving job: GetDevStatus() reported 0x%08x status instead of FS_COMPLETED as expected"),
			pReceivingDevStatus->StatusId
			);
	}
	if (false  == g_bIgnoreErrorCodeBug)
	{
		if (NO_ERROR != pReceivingDevStatus->ErrorCode)
		{
			::lgLogError(
				LOG_SEV_1,
				TEXT("Receiving job: GetDevStatus() reported %d ErrorCode instead of NO_ERROR"),
				pReceivingDevStatus->ErrorCode
				);
		}
	}
	
	//
	//Sending and receiving are finished, now we need to compare the Tiffs
	//
	if (true == g_bT30_OneLineDiffBUG)
	{
		//
		//T30 has a bug of one line diff (Edgebug #8040), so we call TiffCompare() with TRUE (ignore first line)
		//
		if (0 == TiffCompare(pSendingLineInfo->m_pFaxSend->FileName,pReceivingLineInfo->m_pFaxReceive->FileName,TRUE))
		{
			bAreTiffTheSame = true;
		}
		else
		{
			bAreTiffTheSame = false;
			::lgLogError(
				LOG_SEV_1,
				TEXT("Tiff Compare failed")
				);
		}
	}
	else
	{
		//
		//All the other FSPs, do a one by one line compare
		//
		if (0 == TiffCompare(pSendingLineInfo->m_pFaxSend->FileName,pReceivingLineInfo->m_pFaxReceive->FileName,FALSE))
		{
			bAreTiffTheSame = true;
		}
		else
		{
			bAreTiffTheSame = false;
			::lgLogError(
				LOG_SEV_1,
				TEXT("Tiff Compare failed")
				);
		}
	}
	
out:
	::free(pSendingDevStatus);
	::free(pReceivingDevStatus);

	//
	//End the send and the receive job
	//
	g_pSendingLineInfo->SafeEndFaxJob();
	g_pReceivingLineInfo->SafeEndFaxJob();
	
	return bAreTiffTheSame;
}
#endif




void testSend(LPCTSTR szSendFileName,LPCTSTR szReceiveFileName)
{
	if (true == g_reloadFspEachTest)
	{
		if (false == InitProviders())
		{
			//
			//login in InitTapi_LoadFsp_CallFaxDevInit
			//
			goto out;
		}
		
		//
		//Prepare a send and a receive line
		//
		assert (NULL == g_pSendingLineInfo);
#ifdef USE_EXTENDED_FSPI
		g_pSendingLineInfo = new CEfspLineInfo(g_dwSendingValidDeviceId);
#else
		g_pSendingLineInfo = new CFspLineInfo(g_dwSendingValidDeviceId);
#endif
		if (NULL == g_pSendingLineInfo)
		{
			::lgLogError(
				LOG_SEV_2,
				TEXT("new failed")
				);
			goto out;
		}
		if (false == g_pSendingLineInfo->PrepareLineInfoParams(g_szValid__TiffFileName,false))
		{
			goto out;
		}
		
		assert (NULL == g_pReceivingLineInfo);
#ifdef USE_EXTENDED_FSPI
		g_pReceivingLineInfo = new CEfspLineInfo(g_dwReceiveValidDeviceId);
#else
		g_pReceivingLineInfo = new CFspLineInfo(g_dwReceiveValidDeviceId);
#endif		
		if (NULL == g_pReceivingLineInfo)
		{
			::lgLogError(
				LOG_SEV_2,
				TEXT("new failed")
				);
			goto out;
		}
		if (false == g_pReceivingLineInfo->PrepareLineInfoParams(g_szValid_ReceiveFileName,true))
		{
			goto out;
		}
	}
	
	if (false == SendReceive(g_pSendingLineInfo,g_pReceivingLineInfo))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("Sent and received Tiffs are different")
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Sent and received Tiffs are equal")
			);
	}

out:
	if (true == g_reloadFspEachTest)
	{
		ShutdownProviders();
	}
	return;
}


void Suite_TiffSending()
{
	::lgBeginSuite(TEXT("Tiff Send/Receive tests"));
	
	//
	//Valid Tiff
	//
	if (true == RunThisTest(++g_dwCaseNumber))
	{														
		::lgBeginCase(g_dwCaseNumber,TEXT("Valid Tiff"));
		testSend(g_szValid__TiffFileName,g_szValid_ReceiveFileName);
		::lgEndCase();
	}
	
	//
	//ReadOnly Tiff
	//
	if (true == RunThisTest(++g_dwCaseNumber))
	{														
		::lgBeginCase(g_dwCaseNumber,TEXT("Readonly valid Tiff"));
		testSend(g_szValid_ReadOnly_TiffFileName,g_szValid_ReceiveFileName);
		::lgEndCase();
	}

	//
	//UNC Tiff
	//
	if (true == RunThisTest(++g_dwCaseNumber))
	{														
		::lgBeginCase(g_dwCaseNumber,TEXT("Valid Tiff which has a UNC Path"));
		testSend(g_szValid_UNC_TiffFileName,g_szValid_ReceiveFileName);
		::lgEndCase();
	}

	//
	//NTFS Tiff
	//
	if (true == RunThisTest(++g_dwCaseNumber))
	{														
		::lgBeginCase(g_dwCaseNumber,TEXT("Valid Tiff on a NTFS drive"));
		testSend(g_szValid_NTFS_TiffFileName,g_szValid_ReceiveFileName);
		::lgEndCase();
	}

	//
	//FAT Tiff
	//
	if (true == RunThisTest(++g_dwCaseNumber))
	{														
		::lgBeginCase(g_dwCaseNumber,TEXT("Valid Tiff on a FAT drive"));
		testSend(g_szValid_FAT_TiffFileName,g_szValid_ReceiveFileName);
		::lgEndCase();
	}

	::lgEndSuite();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\fsp\3rdpartyfsp_verifier\efsp\cefsplineinfo.h ===
//CEfspLineInfo.h
#ifndef CEfspLineInfo_h
#define CEfspLineInfo_h

#include "CEfspWrapper.h"
#include "..\CLineInfo.h"

class CEfspLineInfo: public CLineInfo
{
private:
	DWORD				m_dwLastJobStatus;
	DWORD				m_dwLastExtendedJobStatus;
public:
	CEfspLineInfo(const DWORD dwDeviceId);

	bool PrepareLineInfoParams(LPCTSTR szFilename,bool bIsReceiveLineinfo);
	void SafeEndFaxJob();
	void ResetParams();
	bool GetDevStatus(LPFSPI_JOB_STATUS *ppFaxStatus,const bool bLogTheStatus) const;
		
	DWORD GetLastJobStatus() const;
	DWORD GetLastExtendedJobStatus() const;
	void SafeSetLastJobStatusAndExtendedJobStatus(DWORD dwLastJobStatus,DWORD dwLastExtendedJobStatus);

};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\fsp\3rdpartyfsp_verifier\efsp\cefspwrapper.cpp ===
#include "CEfspWrapper.h"
#include "assert.h"

extern DWORD g_dwCaseNumber;
extern bool g_bReestablishEfsp;
extern bool g_bVirtualEfsp;

CEfspWrapper::CEfspWrapper(DWORD dwEfspCapability,DWORD dwDeviceBaseId):
	CFspWrapper(),
	m_fnFaxDevInitializeEx(NULL),
	m_fnFaxDevSendEx(NULL),
	m_fnFaxDevReestablishJobContext(NULL),
	m_fnFaxDevReportStatusEx(NULL),
	m_fnFaxDevShutdown(NULL),
	m_fnFaxDevEnumerateDevices(NULL),
	m_fnFaxDevGetLogData(NULL),
	m_dwEfspCapability(dwEfspCapability),
	m_dwDeviceBaseId(dwDeviceBaseId),
	m_dwMaxMessageIdSize(0)
{
	;
}

CEfspWrapper::~CEfspWrapper()
{
	;
}



void CEfspWrapper::SetMaxMessageIdSize(DWORD dwMaxMessageIdSize)
{
	m_dwMaxMessageIdSize = dwMaxMessageIdSize;
}
	


bool CEfspWrapper::GetProcAddressesFromModule(bool bLog)
{

	//
	//EFSP API
	//

	//
	//Mandatory functions
	//
	m_fnFaxDevInitializeEx = (PFAXDEVINITIALIZEEX) GetProcAddress(m_hInstModuleHandle,"FaxDevInitializeEx");
	if (NULL == m_fnFaxDevInitializeEx)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FaxDevInitializeEx is a mandatory function, and %s doesn't export it"),
			m_szImageName
			);
		return false;
	}
	else
	{
		if (bLog)
		{
			::lgLogDetail(
				LOG_PASS,
				2,
				TEXT("FaxDevInitializeEx() exported")
				);
		}
	}

	m_fnFaxDevSendEx = (PFAXDEVSENDEX) GetProcAddress(m_hInstModuleHandle,"FaxDevSendEx");
	if (NULL == m_fnFaxDevSendEx)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FaxDevSendEx is a mandatory function, and %s doesn't export it"),
			m_szImageName
			);
		return false;
	}
	else
	{
		if (bLog)
		{
			::lgLogDetail(
				LOG_PASS, 
				2,
				TEXT("FaxDevSendEx() exported")
				);
		}
	}



	m_fnFaxDevShutdown = (PFAXDEVSHUTDOWN) GetProcAddress(m_hInstModuleHandle,"FaxDevShutdown");
	if (NULL == m_fnFaxDevShutdown)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FaxDevShutdown is a mandatory function, and %s doesn't export it"),
			m_szImageName
			);
		return false;
	}
	else
	{
		if (bLog)
		{
			::lgLogDetail(
				LOG_PASS, 
				2,
				TEXT("FaxDevShutdown() exported")
				);
		}
	}
	
	
	m_fnFaxDevReportStatusEx = (PFAXDEVREPORTSTATUSEX) GetProcAddress(m_hInstModuleHandle,"FaxDevReportStatusEx");
	if (NULL == m_fnFaxDevReportStatusEx)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FaxDevReportStatusEx is a mandatory function, and %s doesn't export it"),
			m_szImageName
			);
		return false;
	}
	else
	{
		if (bLog)
		{
			::lgLogDetail(
				LOG_PASS, 
				2,
				TEXT("FaxDevReportStatusEx() exported")
				);
		}
	}
	
	
	//
	//Optional functions
	//
	m_fnFaxDevReestablishJobContext = (PFAXDEVREESTABLISHJOBCONTEXT) GetProcAddress(m_hInstModuleHandle,"FaxDevReestablishJobContext");
	if (true == IsReestablishEFSP())
	{
		if (NULL == m_fnFaxDevReestablishJobContext)
		{
			::lgLogError(
				LOG_SEV_1,
				TEXT("%s supports job re-establishment and it should support FaxDevReestablishJobContext()"),
				m_szImageName
				);
			return false;
		}
		else
		{
			if (bLog)
			{
				::lgLogDetail(
					LOG_PASS,
					2,
					TEXT("%s supports job re-establishment and exports FaxDevReestablishJobContext()"),
					m_szImageName
					);
			}
		}
	}
	else
	{
		if (bLog)
		{
			if (NULL == m_fnFaxDevReestablishJobContext)
			{
				::lgLogDetail(
					LOG_X,
					2,
					TEXT("FaxDevReestablishJobContext() optional function not exported")
					);
			}
			else
			{
				::lgLogDetail(
					LOG_X,
					2,
					TEXT("FaxDevReestablishJobContext() optional function exported")
					);
			}
		}
	}

	m_fnFaxDevEnumerateDevices = (PFAXDEVENUMERATEDEVICES) GetProcAddress(m_hInstModuleHandle,"FaxDevEnumerateDevices");
	if (IsVirtualEfsp())
	{
		//
		//this is a Virtual EFSP, it needs to support Device Enum
		//
		if (NULL == m_fnFaxDevEnumerateDevices)
		{
			::lgLogError(
				LOG_SEV_1,
				TEXT("%s is a Virtual EFSP and it should support FaxDevEnumerateDevices()"),
				m_szImageName
				);
			return false;
		}
		else
		{
			if (bLog)
			{
				::lgLogDetail(
					LOG_PASS,
					2,
					TEXT("%s is a Virtual EFSP and exports FaxDevEnumerateDevices()"),
					m_szImageName
					);
			}
		}
	}
	else
	{
		if (bLog)
		{
			if (NULL == m_fnFaxDevEnumerateDevices)
			{
				::lgLogDetail(
					LOG_X,
					2,
					TEXT("FaxDevEnumerateDevices() optional function not exported")
					);
			}
			else
			{
				::lgLogDetail(
					LOG_X,
					2,
					TEXT("FaxDevEnumerateDevices() optional function exported")
					);
			}
		}
	}

	//
	//FSP API: mandatory functions
	//
	m_fnFaxDevStartJob = (PFAXDEVSTARTJOB) GetProcAddress(m_hInstModuleHandle,"FaxDevStartJob");
	if (NULL == m_fnFaxDevStartJob)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FaxDevStartJob is a mandatory function, and %s doesn't export it"),
			m_szImageName
			);
		return false;
	}
	else
	{
		if (bLog)
		{
			::lgLogDetail(
				LOG_PASS, 
				2,
				TEXT("FaxDevStartJob() exported")
				);
		}
	}

	m_fnFaxDevEndJob = (PFAXDEVENDJOB) GetProcAddress(m_hInstModuleHandle,"FaxDevEndJob");
	if (NULL == m_fnFaxDevEndJob)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FaxDevEndJob is a mandatory function, and %s doesn't export it"),
			m_szImageName
			);
		return false;
	}
	else
	{
		if (bLog)
		{
			::lgLogDetail(
				LOG_PASS, 
				2,
				TEXT("FaxDevEndJob() exported")
				);
		}
	}

	m_fnFaxDevReceive = (PFAXDEVRECEIVE) GetProcAddress(m_hInstModuleHandle,"FaxDevReceive");
	if (NULL == m_fnFaxDevReceive)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FaxDevReceive is a mandatory function, and %s doesn't export it"),
			m_szImageName
			);
		return false;
	}
	else
	{
		if (bLog)
		{
			::lgLogDetail(
				LOG_PASS, 
				2,
				TEXT("FaxDevReceive() exported")
				);
		}
	}

	m_fnFaxDevAbortOperation = (PFAXDEVABORTOPERATION) GetProcAddress(m_hInstModuleHandle,"FaxDevAbortOperation");
	if (NULL == m_fnFaxDevAbortOperation)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FaxDevAbortOperation is a mandatory function, and %s doesn't export it"),
			m_szImageName
			);
		return false;
	}
	else
	{
		if (bLog)
		{
			::lgLogDetail(
				LOG_PASS, 
				2,
				TEXT("FaxDevAbortOperation() exported")
				);
		}
	}
	return true;
}

bool CEfspWrapper::IsReestablishEFSP() const
{
	return g_bReestablishEfsp;
}



bool CEfspWrapper::IsSchedulingEFSP() const
{
	if (FSPI_CAP_SCHEDULING & m_dwEfspCapability)
	{
		return true;
	}
	else
	{
		return false;
	}
}

bool CEfspWrapper::IsVirtualEfsp() const
{
	return g_bVirtualEfsp;
}

//
//EFSP API
//
HRESULT	 CEfspWrapper::FaxDevInitializeEx(
	IN  HANDLE                      hFSP,
	IN  HLINEAPP                    LineAppHandle,
	OUT PFAX_LINECALLBACK *         LineCallbackFunction,
	IN  PFAX_SERVICE_CALLBACK_EX    FaxServiceCallbackEx,
	OUT LPDWORD                     lpdwMaxMessageIdSize
	) const
{
	HRESULT hr = FSPI_E_FAILED;
	__try
	{
		::lgLogDetail(
			LOG_X,
			7,
			TEXT("Calling FaxDevInitializeEx(0x%08x,0x%08x,0x%08x,0x%08x,0x%08x)"),
			hFSP,
			LineAppHandle,
			LineCallbackFunction,
			FaxServiceCallbackEx,
			lpdwMaxMessageIdSize
			);
		hr = m_fnFaxDevInitializeEx(
			hFSP,
			LineAppHandle,
			LineCallbackFunction,
			FaxServiceCallbackEx,
			lpdwMaxMessageIdSize
			);
		::lgLogDetail(
			LOG_X,
			7,
			TEXT("FaxDevInitializeEx returned 0x%08x"),
			hr
			);
	}
	__except(EXCEPTION_EXECUTE_HANDLER )
	{
		lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevInitializeEx() raised an exception of type: 0x%08x"),
			GetExceptionCode()
			);
	}
	return hr;
}

HRESULT	 CEfspWrapper::FaxDevSendEx(
	IN  HLINE                       hTapiLine,
	IN  DWORD                       dwDeviceId,
	IN  LPCWSTR                     lpcwstrBodyFileName,
	IN  LPCFSPI_COVERPAGE_INFO      lpcCoverPageInfo,
	IN  SYSTEMTIME                  tmSchedule,
	IN  LPCFSPI_PERSONAL_PROFILE    lpcSenderProfile,
	IN  DWORD                       dwNumRecipients,
	IN  LPCFSPI_PERSONAL_PROFILE    lpcRecipientProfiles,
	OUT LPFSPI_MESSAGE_ID           lpRecipientMessageIds,
	OUT PHANDLE                     lphRecipientJobs,
	OUT LPFSPI_MESSAGE_ID           lpParentMessageId,
	OUT LPHANDLE                    lphParentJob
	) const
{
	HRESULT hr = FSPI_E_FAILED;
	__try
	{
		::lgLogDetail(
			LOG_X,
			7,
			TEXT("Calling FaxDevSendEx(TapiLine=0x%08x, DeviceId=%d, Body FileName=%s, CoverPage FileName=%s, CoverPage Format=0x%08x,CoverPage NumberOfPages=%d, CoverPage Note=%s, CoverPage Subject=%s,Branding=false)"),
			hTapiLine,
			dwDeviceId,
			lpcwstrBodyFileName,
			lpcCoverPageInfo->lpwstrCoverPageFileName,
			lpcCoverPageInfo->dwCoverPageFormat,
			lpcCoverPageInfo->dwNumberOfPages,
			lpcCoverPageInfo->lpwstrNote,
			lpcCoverPageInfo->lpwstrSubject
			);
		hr = m_fnFaxDevSendEx(
			hTapiLine,
			dwDeviceId,
			lpcwstrBodyFileName,
			lpcCoverPageInfo,
			false,						//no branding
			tmSchedule,
			lpcSenderProfile,
			dwNumRecipients,
			lpcRecipientProfiles,
			lpRecipientMessageIds,
			lphRecipientJobs,
			lpParentMessageId,
			lphParentJob
			);
		::lgLogDetail(
			LOG_X,
			7,
			TEXT("FaxDevSendEx returned 0x%08x"),
			hr
			);
	}
	__except(EXCEPTION_EXECUTE_HANDLER )
	{
		lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevSendEx() raised an exception of type: 0x%08x"),
			GetExceptionCode()
			);
	}
	return hr;
}

HRESULT CEfspWrapper::FaxDevReestablishJobContext(
	IN  HLINE               hTapiLine,
	IN  DWORD               dwDeviceId,
	IN  LPCFSPI_MESSAGE_ID  lpcParentMessageId,
	OUT PHANDLE             lphParentJob,
	IN  DWORD               dwRecipientCount,
	IN  LPCFSPI_MESSAGE_ID  lpcRecipientMessageIds,
	OUT PHANDLE             lpRecipientJobs
	) const
{
	HRESULT hr = FSPI_E_FAILED;
	__try
	{
		::lgLogDetail(
			LOG_X,
			7,
			TEXT("Calling FaxDevReestablishJobContext(0x%08x,%d,0x%08x,0x%08x,0x%08x,0x%08x,0x%08x)"),
			hTapiLine,
			dwDeviceId,
			lpcParentMessageId,
			lphParentJob,
			dwRecipientCount,
			lpcRecipientMessageIds,
			lpRecipientJobs
			);
		hr = m_fnFaxDevReestablishJobContext(
			hTapiLine,
			dwDeviceId,
			lpcParentMessageId,
			lphParentJob,
			dwRecipientCount,
			lpcRecipientMessageIds,
			lpRecipientJobs
			);
		::lgLogDetail(
			LOG_X,
			7,
			TEXT("FaxDevReestablishJobContext returned 0x%08x"),
			hr
			);
	}
	__except(EXCEPTION_EXECUTE_HANDLER )
	{
		lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevReestablishJobContext() raised an exception of type: 0x%08x"),
			GetExceptionCode()
			);
	}
	return hr;
}

HRESULT CEfspWrapper::FaxDevReportStatusEx(
	IN         HANDLE				hJob,
	IN OUT     LPFSPI_JOB_STATUS	lpStatus,
	IN         DWORD				dwStatusSize,
	OUT        LPDWORD				lpdwRequiredStatusSize
	) const
{
	HRESULT hr = FSPI_E_FAILED;
	__try
	{
		::lgLogDetail(
			LOG_X,
			7,
			TEXT("Calling FaxDevReportStatusEx(0x%08x,0x%08x,0x%08x,0x%08x)"),
			hJob,
			lpStatus,
			dwStatusSize,
			lpdwRequiredStatusSize
			);
		hr = m_fnFaxDevReportStatusEx(
			hJob,			
			lpStatus,
			dwStatusSize,
			lpdwRequiredStatusSize
			);
		::lgLogDetail(
			LOG_X,
			7,
			TEXT("FaxDevReportStatusEx returned 0x%08x"),
			hr
			);
	}
	__except(EXCEPTION_EXECUTE_HANDLER )
	{
		lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevReportStatusEx() raised an exception of type: 0x%08x"),
			GetExceptionCode()
			);
	}
	return hr;
}

HRESULT CEfspWrapper::FaxDevShutdown() const
{
	HRESULT hr = FSPI_E_FAILED;
	__try
	{
		::lgLogDetail(
			LOG_X,
			7,
			TEXT("Calling FaxDevShutdown()")
			);
		hr = m_fnFaxDevShutdown();
		::lgLogDetail(
			LOG_X,
			7,
			TEXT("FaxDevShutdown returned 0x%08x"),
			hr
			);
	}
	__except(EXCEPTION_EXECUTE_HANDLER )
	{
		lgLogError(
			LOG_SEV_1,
			TEXT("m_fnFaxDevShutdown() raised an exception of type: 0x%08x"),
			GetExceptionCode()
			);
	}
	return hr;
}

HRESULT CEfspWrapper::FaxDevEnumerateDevices(
	IN      DWORD dwDeviceIdBase,
	IN OUT  LPDWORD lpdwDeviceCount,
	OUT     LPFSPI_DEVICE_INFO lpDevices
	) const
{
	HRESULT hr = FSPI_E_FAILED;
	__try
	{
		::lgLogDetail(
			LOG_X,
			7,
			TEXT("Calling FaxDevEnumerateDevices(0x%08x,0x%08x,0x%08x)"),
			dwDeviceIdBase,
			lpdwDeviceCount,
			lpDevices
			);
		hr = m_fnFaxDevEnumerateDevices(
			dwDeviceIdBase,
			lpdwDeviceCount,
			lpDevices
			);
		::lgLogDetail(
			LOG_X,
			7,
			TEXT("FaxDevEnumerateDevices returned 0x%08x"),
			hr
			);
	}
	__except(EXCEPTION_EXECUTE_HANDLER )
	{
		lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevEnumerateDevices() raised an exception of type: 0x%08x"),
			GetExceptionCode()
			);
	}
	return hr;
}

HRESULT CEfspWrapper::FaxDevGetLogData(
	IN  HANDLE		hFaxHandle,
	OUT VARIANT*	lppLogData
	) const
{
	HRESULT hr = FSPI_E_FAILED;
	__try
	{
		::lgLogDetail(
			LOG_X,
			7,
			TEXT("Calling FaxDevGetLogData(0x%08x,0x%08x)"),
			hFaxHandle,
			lppLogData
			);
		hr = m_fnFaxDevGetLogData(
			hFaxHandle,
			lppLogData
			);
		::lgLogDetail(
			LOG_X,
			7,
			TEXT("FaxDevGetLogData returned 0x%08x"),
			hr
			);
	}
	__except(EXCEPTION_EXECUTE_HANDLER )
	{
		lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevGetLogData() raised an exception of type: 0x%08x"),
			GetExceptionCode()
			);
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\fsp\3rdpartyfsp_verifier\efsp\cefspwrapper.h ===
#ifndef CefspWrapper_h
#define CefspWrapper_h

#include <WINFAX.H>
#include <faxDev.h>
#include <log\log.h>
#include <windows.h>
#include "..\CFspWrapper.h"

class CEfspWrapper: public CFspWrapper
{
private:
	//EFSP API
	PFAXDEVINITIALIZEEX             m_fnFaxDevInitializeEx;
    PFAXDEVSENDEX                   m_fnFaxDevSendEx;
    PFAXDEVREESTABLISHJOBCONTEXT    m_fnFaxDevReestablishJobContext;
    PFAXDEVREPORTSTATUSEX           m_fnFaxDevReportStatusEx;
    PFAXDEVSHUTDOWN                 m_fnFaxDevShutdown;
    PFAXDEVENUMERATEDEVICES         m_fnFaxDevEnumerateDevices;
    PFAXDEVGETLOGDATA               m_fnFaxDevGetLogData;
	
public:
	DWORD	m_dwEfspCapability;
	DWORD	m_dwDeviceBaseId;
	DWORD	m_dwMaxMessageIdSize;

public:
	CEfspWrapper(DWORD dwEfspCapability,DWORD dwDeviceBaseId);
	~CEfspWrapper();
	bool GetProcAddressesFromModule(bool bLog=false);
	bool IsReestablishEFSP() const;
	bool IsSchedulingEFSP() const;
	bool IsVirtualEfsp() const;
	void SetMaxMessageIdSize(DWORD dwMaxMessageIdSize);
	
	//
	//EFSP API
	//
	HRESULT	FaxDevInitializeEx(
		IN  HANDLE                      hFSP,
		IN  HLINEAPP                    LineAppHandle,
		OUT PFAX_LINECALLBACK *         LineCallbackFunction,
		IN  PFAX_SERVICE_CALLBACK_EX    FaxServiceCallbackEx,
		OUT LPDWORD                     lpdwMaxMessageIdSize
		) const;
	HRESULT	FaxDevSendEx(
		IN  HLINE                       hTapiLine,
		IN  DWORD                       dwDeviceId,
		IN  LPCWSTR                     lpcwstrBodyFileName,
		IN  LPCFSPI_COVERPAGE_INFO      lpcCoverPageInfo,
		IN  SYSTEMTIME                  tmSchedule,
		IN  LPCFSPI_PERSONAL_PROFILE    lpcSenderProfile,
		IN  DWORD                       dwNumRecipients,
		IN  LPCFSPI_PERSONAL_PROFILE    lpcRecipientProfiles,
		OUT LPFSPI_MESSAGE_ID           lpRecipientMessageIds,
		OUT PHANDLE                     lphRecipientJobs,
		OUT LPFSPI_MESSAGE_ID           lpParentMessageId,
		OUT LPHANDLE                    lphParentJob
		) const;
	HRESULT	FaxDevReestablishJobContext(
		IN  HLINE               hTapiLine,
		IN  DWORD               dwDeviceId,
		IN  LPCFSPI_MESSAGE_ID  lpcParentMessageId,
		OUT PHANDLE             lphParentJob,
		IN  DWORD               dwRecipientCount,
		IN  LPCFSPI_MESSAGE_ID  lpcRecipientMessageIds,
		OUT PHANDLE             lpRecipientJobs
		) const;
	HRESULT	FaxDevReportStatusEx(
		IN         HANDLE				hJob,
		IN OUT     LPFSPI_JOB_STATUS	lpStatus,
		IN         DWORD				dwStatusSize,
		OUT        LPDWORD				lpdwRequiredStatusSize
		) const;
	HRESULT	FaxDevShutdown() const;
	HRESULT	FaxDevEnumerateDevices(
		IN      DWORD dwDeviceIdBase,
		IN OUT  LPDWORD lpdwDeviceCount,
		OUT     LPFSPI_DEVICE_INFO lpDevices
		) const;
	HRESULT	FaxDevGetLogData(
		IN  HANDLE		hFaxHandle,
		OUT VARIANT*	lppLogData
		) const;
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\fsp\3rdpartyfsp_verifier\efsp\cefsplineinfo.cpp ===
//CEfspLineInfo.cpp
#include "Service.h"
#include "CEfspLineInfo.h"
extern CEfspWrapper *g_pEFSP; 

CEfspLineInfo::CEfspLineInfo(const DWORD dwDeviceId):
	CLineInfo(dwDeviceId),
	m_dwLastJobStatus(0),
	m_dwLastExtendedJobStatus(0)
{
	;
}




void CEfspLineInfo::SafeEndFaxJob()
{
	if (NULL == GetJobHandle())
	{
		//
		//the job is already ended
		//
		return;
	}
	if (false == g_pEFSP->FaxDevEndJob(GetJobHandle()))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevEndJob failed with %d"),
			::GetLastError()
			);
	}

	//
	//Reset the handle
	//
	SafeSetJobHandle(NULL);
	ResetParams();
}

void CEfspLineInfo::ResetParams()
{
	SafeSetJobNotAtFinalState();
	m_dwLastJobStatus = DUMMY_JOB_STATUS_INDEX;
	m_dwLastExtendedJobStatus = 0;
	if (IsReceiveThreadActive())
	{
		SafeCloseReceiveThread();
	}
	if (NULL != GetFinalStateHandle())
	{
		SafeCloseFinalStateHandle();
	}
}



//
//m_dwLastJobStatus, m_dwLastExtendedJobStatus
//
void CEfspLineInfo::SafeSetLastJobStatusAndExtendedJobStatus(DWORD dwLastJobStatus,DWORD dwLastExtendedJobStatus)
{
	m_dwLastJobStatus = dwLastJobStatus;
	m_dwLastExtendedJobStatus = dwLastExtendedJobStatus;
}

DWORD CEfspLineInfo::GetLastJobStatus() const
{
	return m_dwLastJobStatus;
}
DWORD CEfspLineInfo::GetLastExtendedJobStatus() const
{
	return m_dwLastExtendedJobStatus;
}


bool CEfspLineInfo::GetDevStatus(
    LPFSPI_JOB_STATUS *ppFaxStatus,
	const bool bLogTheStatus
	) const
{
	assert(NULL != GetJobHandle());
	HRESULT hr = E_FAIL;
	DWORD dwStatusSize = sizeof(FSPI_JOB_STATUS) + FAXDEVREPORTSTATUS_SIZE;
	DWORD dwRequiredStatusSize = 0;
 	LPFSPI_JOB_STATUS pFaxStatus = (LPFSPI_JOB_STATUS) malloc(dwStatusSize);
	if (!pFaxStatus)
	{
		lgLogError(
			LOG_SEV_1,
			TEXT("Case_ReportStatus_Incorrect_hJob(): malloc failed")
			);
		goto Exit;
	}

	pFaxStatus->dwSizeOfStruct = sizeof(FSPI_JOB_STATUS);
	
	hr = g_pEFSP->FaxDevReportStatusEx(
		GetJobHandle(),
		pFaxStatus,
		dwStatusSize,
		&dwRequiredStatusSize
		);

	if (FSPI_S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FaxDevReportStatusEx() failed FSPI_S_OK and should fail with FSPI_E_INVALID_JOB_HANDLE")
			);
		goto Exit;
	}
	if (true == bLogTheStatus)
	{
		//
		//we should log all the data
		//
		::lgLogDetail(
			LOG_X,
			5,
			TEXT("FaxDevReportEx() has reported the following details: ")
			TEXT("AvailableStatusInfo=0x%08x, JobStatus=%d, ExtendedStatus=%d, ExtendedStatusStringId=%d, ")
			TEXT("RemoteStationId=\"%s\", CallerId=\"%s\", ")
			TEXT("RoutingInfo=\"%s\", PageCount=%d"),
			pFaxStatus->fAvailableStatusInfo,
			pFaxStatus->dwJobStatus,
			pFaxStatus->dwExtendedStatus,
			pFaxStatus->dwExtendedStatusStringId,
			pFaxStatus->lpwstrRemoteStationId,
			pFaxStatus->lpwstrCallerId,
			pFaxStatus->lpwstrRoutingInfo,
			pFaxStatus->dwPageCount
			);
	}
    

Exit:
    if (S_OK == hr)
	{
        *ppFaxStatus = pFaxStatus;
		return true;
    }
	else
	{
        free(pFaxStatus);
    }
    return false;
}

bool CEfspLineInfo::PrepareLineInfoParams(LPCTSTR szFilename,bool bIsReceiveLineinfo)
{
	bool bRet= false;
	TCHAR *szDeviceFriendlyName = NULL;

	//
	//Prepare a critical section
	//
	if (false == CreateCriticalSection())
	{
		goto out;
	}
	
	//
	//We're assigning values, lock the LineInfo (we can't use CS auto-pointer, since we have a goto and can't declare after the goto)
	//
	Lock();

	GetDeviceFriendlyName(&szDeviceFriendlyName,GetDeviceId());
	
	//
	//record the DeviceName
	//
	if (NULL == szDeviceFriendlyName)
	{
		//
		//EFSP Didn't supply a device friendly name, supply a default one
		//
		if (false == SetDeviceName(DEFAULT_DEVICE_NAME))
		{
			goto out;
		}
	}
	else
	{
		if (false == SetDeviceName(szDeviceFriendlyName))
		{
			goto out;
		}
	}
	
	//
	//Get the general stuff from the base object
	//
	bRet = CommonPrepareLineInfoParams(szFilename,bIsReceiveLineinfo);
out:
	UnLock();
	::free(szDeviceFriendlyName);
	return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\fsp\3rdpartyfsp_verifier\efsp\efsploading.cpp ===
//EfspLoading.cpp
#include "service.h"
extern DWORD		g_dwCaseNumber;

bool Suite_EfspLoading()
{
	
	
	if (true == RunThisTest(++g_dwCaseNumber))
	{											
		::lgBeginSuite(TEXT("EFSP loading"));

		::lgBeginCase(g_dwCaseNumber,TEXT("EFSP Loading"));
		if (false == InitEfsp(true))
		{
			::lgEndCase();
			::lgEndSuite();
			return false;
		}
		UnloadEfsp(true);
		::lgEndCase();

		::lgEndSuite();
	}
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\fsp\3rdpartyfsp_verifier\efsp\faxdevsendexwrappers.h ===
#ifndef FaxDevSendExWrapper_h
#define FaxDevSendExWrapper_h





HRESULT SafeCreateValidSendingJob(CEfspLineInfo *pSendingLineInfo,TCHAR *szRecipentNumber);
HRESULT SendDefaultFaxWithSenderProfile(FSPI_PERSONAL_PROFILE *pFSPISenderInfo);
HRESULT SendDefaultFaxWithRecipientProfile(FSPI_PERSONAL_PROFILE *pFSPIRecipientInfo);
HRESULT SendDefaultFaxUsingDeviceID(DWORD dwDeviceID);
HRESULT SendDefaultFaxWithBodyFile(LPCWSTR pSzBodyFileName);
HRESULT SendDefaultFaxWithCoverpage(LPWSTR pSzCoverpageFileName);
HRESULT SendDefaultFaxWithCoverpageInfo(FSPI_COVERPAGE_INFO *pCovEFSPICoverPage);
HRESULT SendDefaultFaxWithSystemTime(SYSTEMTIME tmSchedule);
HRESULT SendDefaultFaxWithMessageIdArray(LPFSPI_MESSAGE_ID lpRecipientMessageIds);
HRESULT SendDefaultFaxWithRecipientJobHandleArray(PHANDLE lpRecipientJobHandles);
HRESULT SendDefaultFaxWithParentJobHandle(PHANDLE phParentHandle);






HRESULT CreateFSPIRecipientMessageIdsArray(
        LPFSPI_MESSAGE_ID * lppRecipientMessageIds,
        DWORD dwRecipientCount,
        DWORD dwMessageIdSize
		);

void PreparePersonalProfile(
    LPFSPI_PERSONAL_PROFILE lpDst,
    LPWSTR     lptstrName,
    LPWSTR     lptstrFaxNumber,
    LPWSTR     lptstrCompany,
    LPWSTR     lptstrStreetAddress,
    LPWSTR     lptstrCity,
    LPWSTR     lptstrState,
    LPWSTR     lptstrZip,
    LPWSTR     lptstrCountry,
    LPWSTR     lptstrTitle,
    LPWSTR     lptstrDepartment,
    LPWSTR     lptstrOfficeLocation,
    LPWSTR     lptstrHomePhone,
    LPWSTR     lptstrOfficePhone,
    LPWSTR     lptstrEmail,
    LPWSTR     lptstrBillingCode
	);

void PrepareFSPICoverPage(
    LPFSPI_COVERPAGE_INFO lpDst,
    DWORD	dwCoverPageFormat,
	DWORD   dwNumberOfPages,
	LPTSTR  lptstrCoverPageFileName,
	LPTSTR  lptstrNote,
	LPTSTR  lptstrSubject
	);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\fsp\3rdpartyfsp_verifier\efsp\faxdevsendexwrappers.cpp ===
#include "ParamTest.h"
#include "CEfspWrapper.h"
#include "Service.h"
#include "FaxDevSendExWrappers.h"

extern CEfspWrapper *g_pEFSP;
extern CEfspLineInfo	*g_pSendingLineInfo;
extern TCHAR		*g_szValidRecipientFaxNumber;
extern TCHAR		*g_szValid__TiffFileName;
extern TCHAR		*g_szValid__CoverpageFileName;

extern DWORD g_dwSendingValidDeviceId;



HRESULT SafeCreateValidSendingJob(CEfspLineInfo *pSendingLineInfo,TCHAR *szRecipientNumber)
{
	HRESULT hr = S_OK;
	DWORD dwDeviceID = g_dwSendingValidDeviceId;
	DWORD dwMaxMessageIdSize = g_pEFSP->m_dwMaxMessageIdSize;

	//
    // Prepare the coverPage structure.
    //
	FSPI_COVERPAGE_INFO covEFSPICoverPage;
	PrepareFSPICoverPage(
			&covEFSPICoverPage,
		    FSPI_COVER_PAGE_FMT_COV,
			1,
			g_szValid__CoverpageFileName,
			DEFAULT_COVERPAGE_NOTE,
			DEFAULT_COVERPAGE_SUBJECT
			);

	//
	//Set the time to send to now (0 in all the fields)
	//
	SYSTEMTIME tmSchedule;
	tmSchedule.wYear = 0;
	tmSchedule.wMonth = 0;
	tmSchedule.wDayOfWeek = 0;
	tmSchedule.wDay = 0;
	tmSchedule.wHour = 0;
	tmSchedule.wMinute = 0;
	tmSchedule.wSecond = 0;
	tmSchedule.wMilliseconds = 0;
	
	FSPI_PERSONAL_PROFILE FSPISenderInfo;				// The Sender information sent to FaxDevSendEx()
	FSPI_PERSONAL_PROFILE FSPIRecipientInfo;			// The recipient information sent to FaxDevSendEx()
	//
	//prepare the sender profile
	//
	PreparePersonalProfile(
		&FSPISenderInfo,
		DEFAULT_SENDER_INFO__NAME,
		DEFAULT_SENDER_INFO__FAX_NUMBER,
		DEFAULT_SENDER_INFO__COMPANY,
		DEFAULT_SENDER_INFO__STREET,
		DEFAULT_SENDER_INFO__CITY,
		DEFAULT_SENDER_INFO__STATE,
		DEFAULT_SENDER_INFO__ZIP,
		DEFAULT_SENDER_INFO__COUNTRY,
		DEFAULT_SENDER_INFO__TITLE,
		DEFAULT_SENDER_INFO__DEPT,
		DEFAULT_SENDER_INFO__OFFICE_LOCATION,
		DEFAULT_SENDER_INFO__HOME_PHONE,
		DEFAULT_SENDER_INFO__OFFICE_PHONE,
		DEFAULT_SENDER_INFO__ORG_MAIL,
		DEFAULT_SENDER_INFO__INTERNET_MAIL,
		DEFAULT_SENDER_INFO__BILLING_CODE
		);

	//
	//prepare the recipient profile
	//
	PreparePersonalProfile(
		&FSPIRecipientInfo,
		DEFAULT_RECIPIENT_INFO__NAME,
		szRecipientNumber,
		DEFAULT_RECIPIENT_INFO__COMPANY,
		DEFAULT_RECIPIENT_INFO__STREET,
		DEFAULT_RECIPIENT_INFO__CITY,
		DEFAULT_RECIPIENT_INFO__STATE,
		DEFAULT_RECIPIENT_INFO__ZIP,
		DEFAULT_RECIPIENT_INFO__COUNTRY,
		DEFAULT_RECIPIENT_INFO__TITLE,
		DEFAULT_RECIPIENT_INFO__DEPT,
		DEFAULT_RECIPIENT_INFO__OFFICE_LOCATION,
		DEFAULT_RECIPIENT_INFO__HOME_PHONE,
		DEFAULT_RECIPIENT_INFO__OFFICE_PHONE,
		DEFAULT_RECIPIENT_INFO__ORG_MAIL,
		DEFAULT_RECIPIENT_INFO__INTERNET_MAIL,
		DEFAULT_RECIPIENT_INFO__BILLING_CODE
		);
	

	LPFSPI_MESSAGE_ID lpRecipientMessageIds  = NULL;    // This array holds the message id structures array used as output parameter to FaxDevSendEx()
	PHANDLE lpRecipientJobHandles = NULL;				// This array holds the recipient job handles array used as output parameter to FaxDevSendEx()
	FSPI_MESSAGE_ID ParentMessageId;                    // The parent message id returned by FaxDevSendEx()
    LPFSPI_MESSAGE_ID lpParentMessageId = NULL;         // Points to the parent message id if it is used.
                                                        // NULL in case of an EFSP that does not support job reestablishment.
	HANDLE hParent;                                     // The parent job handle returned by FaxDevSendEx()

	//
    // Allocate the FSP recipient job handles array
    //

    lpRecipientJobHandles = (PHANDLE)malloc(sizeof (HANDLE));
    if (!lpRecipientJobHandles)
    {
        ::lgLogError(
			LOG_SEV_1, 
            TEXT("Failed to allocate recipient job handles array, error:%ld)"),
            GetLastError()
			);
		return FSPI_E_NOMEM;
    }


	//
	//Allocate and init lpRecipientMessageIds and lpParentMessageId
	//
	if (0 < dwMaxMessageIdSize)
	{
		//
        // The EFSP supports job reestablishment
        //


		//
		// Allocate and initialize the recipients permanent message ids array
		//
		hr = CreateFSPIRecipientMessageIdsArray(
			&lpRecipientMessageIds,
			1,
			dwMaxMessageIdSize
			);
		if (S_OK != hr)
		{
			lpRecipientMessageIds = NULL;
			::lgLogError(
				LOG_SEV_1, 
				TEXT("CreateFSPIRecipientMessageIdsArray() failed with error:0x%08x"),
				hr
				);
			return hr;
		}
		
		//
		// Allocate the parent permanent message id
		//
		memset(&ParentMessageId,0,sizeof(FSPI_MESSAGE_ID));
		ParentMessageId.dwSizeOfStruct = sizeof(FSPI_MESSAGE_ID);
		ParentMessageId.dwIdSize = dwMaxMessageIdSize;
		ParentMessageId.lpbId = (LPBYTE)malloc(ParentMessageId.dwIdSize);
		if (!ParentMessageId.lpbId)
		{
			::lgLogError(
				LOG_SEV_1, 
				TEXT("Failed to allocate permanent message id buffer for parent job. MaxMessageIdSize: %ld. (ec: %ld)"),
			dwMaxMessageIdSize,
				GetLastError()
				);
			return FSPI_E_NOMEM;
		}
		lpParentMessageId = &ParentMessageId;
	}
	else
	{
		lpRecipientMessageIds = NULL;
        lpParentMessageId = NULL;
	}
	
	
	
	hr = g_pEFSP->FaxDevSendEx(
        NULL,
        dwDeviceID,
        pSendingLineInfo->m_pFaxSend->FileName,
        &covEFSPICoverPage,
		tmSchedule,
        &FSPISenderInfo,
        1,
        &FSPIRecipientInfo,
        lpRecipientMessageIds,
        lpRecipientJobHandles,
        lpParentMessageId,
		&hParent
		);
	if (FSPI_S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FaxDevSendEx failed with error 0x%08x"),
			hr
			);
		return hr;

	}
	pSendingLineInfo->Lock();
	pSendingLineInfo->SafeSetJobHandle(lpRecipientJobHandles[0]);
	pSendingLineInfo->UnLock();
	return FSPI_S_OK;
}


HRESULT SendDefaultFaxWithSenderProfile(FSPI_PERSONAL_PROFILE *pFSPISenderInfo)
{
	DWORD dwDeviceID = g_dwSendingValidDeviceId;
	DWORD dwMaxMessageIdSize = g_pEFSP->m_dwMaxMessageIdSize;

	//
    // Prepare the coverPage structure.
    //
	FSPI_COVERPAGE_INFO covEFSPICoverPage;
	PrepareFSPICoverPage(
			&covEFSPICoverPage,
		    FSPI_COVER_PAGE_FMT_COV,
			1,
			g_szValid__CoverpageFileName,
			DEFAULT_COVERPAGE_NOTE,
			DEFAULT_COVERPAGE_SUBJECT
			);

	//
	//Set the time to send to now (0 in all the fields)
	//
	SYSTEMTIME tmSchedule;
	tmSchedule.wYear = 0;
	tmSchedule.wMonth = 0;
	tmSchedule.wDayOfWeek = 0;
	tmSchedule.wDay = 0;
	tmSchedule.wHour = 0;
	tmSchedule.wMinute = 0;
	tmSchedule.wSecond = 0;
	tmSchedule.wMilliseconds = 0;
	
	//
	//sender info is in pFSPISenderInfo, prepare the recipient info
	//
	FSPI_PERSONAL_PROFILE FSPIRecipientInfo;			// The recipient information sent to FaxDevSendEx()
	
	//
	//prepare the recipient profile
	//
	PreparePersonalProfile(
		&FSPIRecipientInfo,
		DEFAULT_RECIPIENT_INFO__NAME,
		g_szValidRecipientFaxNumber,
		DEFAULT_RECIPIENT_INFO__COMPANY,
		DEFAULT_RECIPIENT_INFO__STREET,
		DEFAULT_RECIPIENT_INFO__CITY,
		DEFAULT_RECIPIENT_INFO__STATE,
		DEFAULT_RECIPIENT_INFO__ZIP,
		DEFAULT_RECIPIENT_INFO__COUNTRY,
		DEFAULT_RECIPIENT_INFO__TITLE,
		DEFAULT_RECIPIENT_INFO__DEPT,
		DEFAULT_RECIPIENT_INFO__OFFICE_LOCATION,
		DEFAULT_RECIPIENT_INFO__HOME_PHONE,
		DEFAULT_RECIPIENT_INFO__OFFICE_PHONE,
		DEFAULT_RECIPIENT_INFO__ORG_MAIL,
		DEFAULT_RECIPIENT_INFO__INTERNET_MAIL,
		DEFAULT_RECIPIENT_INFO__BILLING_CODE
		);
	

	LPFSPI_MESSAGE_ID lpRecipientMessageIds  = NULL;    // This array holds the message id structures array used as output parameter to FaxDevSendEx()
	PHANDLE lpRecipientJobHandles = NULL;				// This array holds the recipient job handles array used as output parameter to FaxDevSendEx()
	FSPI_MESSAGE_ID ParentMessageId;                    // The parent message id returned by FaxDevSendEx()
    LPFSPI_MESSAGE_ID lpParentMessageId = NULL;         // Points to the parent message id if it is used.
                                                        // NULL in case of an EFSP that does not support job reestablishment.
	HANDLE hParent;                                     // The parent job handle returned by FaxDevSendEx()

	//
    // Allocate the FSP recipient job handles array
    //

    lpRecipientJobHandles = (PHANDLE)malloc(sizeof (HANDLE));
    if (!lpRecipientJobHandles)
    {
        ::lgLogError(
			LOG_SEV_1, 
            TEXT("Failed to allocate recipient job handles array, error:%ld)"),
            GetLastError()
			);
		return FSPI_E_NOMEM;
    }


	//
	//Allocate and init lpRecipientMessageIds and lpParentMessageId
	//
	if (0 < dwMaxMessageIdSize)
	{
		//
        // The EFSP supports job reestablishment
        //


		//
		// Allocate and initialize the recipients permanent message ids array
		//
		HRESULT hr = CreateFSPIRecipientMessageIdsArray(
			&lpRecipientMessageIds,
			1,
			dwMaxMessageIdSize
			);
		if (S_OK != hr)
		{
			lpRecipientMessageIds = NULL;
			::lgLogError(
				LOG_SEV_1, 
				TEXT("CreateFSPIRecipientMessageIdsArray() failed. (ec: %ld)"),
				GetLastError()
				);
			return FSPI_E_NOMEM;
		}
		
		//
		// Allocate the parent permanent message id
		//
		memset(&ParentMessageId,0,sizeof(FSPI_MESSAGE_ID));
		ParentMessageId.dwSizeOfStruct = sizeof(FSPI_MESSAGE_ID);
		ParentMessageId.dwIdSize = dwMaxMessageIdSize;
		ParentMessageId.lpbId = (LPBYTE)malloc(ParentMessageId.dwIdSize);
		if (!ParentMessageId.lpbId)
		{
			::lgLogError(
				LOG_SEV_1, 
				TEXT("Failed to allocate permanent message id buffer for parent job. MaxMessageIdSize: %ld. (ec: %ld)"),
				dwMaxMessageIdSize,
				GetLastError()
				);
			return FSPI_E_NOMEM;
		}
		lpParentMessageId = &ParentMessageId;
	}
	else
	{
		lpRecipientMessageIds = NULL;
        lpParentMessageId = NULL;
	}

	HRESULT hr = g_pEFSP->FaxDevSendEx(
        NULL,
        dwDeviceID,
        g_szValid__TiffFileName,
        &covEFSPICoverPage,
		tmSchedule,
        pFSPISenderInfo,
        1,
        &FSPIRecipientInfo,
        lpRecipientMessageIds,
        lpRecipientJobHandles,
        lpParentMessageId,
		&hParent
		);

	if (S_OK == hr)
	{
		g_pSendingLineInfo->SafeSetJobHandle(lpRecipientJobHandles[0]);
		HANDLE hJob = g_pSendingLineInfo->GetJobHandle();

		//
		//we need to close the send handle
		//
		if (false == g_pEFSP->FaxDevAbortOperation(hJob))
		{
			::lgLogError(
				LOG_SEV_3,
				TEXT("FaxDevAbortOperation() on sending job failed with last error: 0x%08x"),
				::GetLastError()
				);
		}
		g_pSendingLineInfo->SafeEndFaxJob();
	}
	return hr;
}

HRESULT SendDefaultFaxWithRecipientProfile(FSPI_PERSONAL_PROFILE *pFSPIRecipientInfo)
{
	DWORD dwDeviceID = g_dwSendingValidDeviceId;
	DWORD dwMaxMessageIdSize = g_pEFSP->m_dwMaxMessageIdSize;

	//
    // Prepare the coverPage structure.
    //
	FSPI_COVERPAGE_INFO covEFSPICoverPage;
	PrepareFSPICoverPage(
			&covEFSPICoverPage,
		    FSPI_COVER_PAGE_FMT_COV,
			1,
			g_szValid__CoverpageFileName,
			DEFAULT_COVERPAGE_NOTE,
			DEFAULT_COVERPAGE_SUBJECT
			);

	//
	//Set the time to send to now (0 in all the fields)
	//
	SYSTEMTIME tmSchedule;
	tmSchedule.wYear = 0;
	tmSchedule.wMonth = 0;
	tmSchedule.wDayOfWeek = 0;
	tmSchedule.wDay = 0;
	tmSchedule.wHour = 0;
	tmSchedule.wMinute = 0;
	tmSchedule.wSecond = 0;
	tmSchedule.wMilliseconds = 0;
	
	//
	//Recipient info is in pFSPIRecipientInfo, prepare the sender info
	//
	FSPI_PERSONAL_PROFILE FSPISenderInfo;			// The sender information sent to FaxDevSendEx()
	
	//
	//prepare the recipient profile
	//
	PreparePersonalProfile(
		&FSPISenderInfo,
		DEFAULT_RECIPIENT_INFO__NAME,
		g_szValidRecipientFaxNumber,
		DEFAULT_RECIPIENT_INFO__COMPANY,
		DEFAULT_RECIPIENT_INFO__STREET,
		DEFAULT_RECIPIENT_INFO__CITY,
		DEFAULT_RECIPIENT_INFO__STATE,
		DEFAULT_RECIPIENT_INFO__ZIP,
		DEFAULT_RECIPIENT_INFO__COUNTRY,
		DEFAULT_RECIPIENT_INFO__TITLE,
		DEFAULT_RECIPIENT_INFO__DEPT,
		DEFAULT_RECIPIENT_INFO__OFFICE_LOCATION,
		DEFAULT_RECIPIENT_INFO__HOME_PHONE,
		DEFAULT_RECIPIENT_INFO__OFFICE_PHONE,
		DEFAULT_RECIPIENT_INFO__ORG_MAIL,
		DEFAULT_RECIPIENT_INFO__INTERNET_MAIL,
		DEFAULT_RECIPIENT_INFO__BILLING_CODE
		);
	

	LPFSPI_MESSAGE_ID lpRecipientMessageIds  = NULL;    // This array holds the message id structures array used as output parameter to FaxDevSendEx()
	PHANDLE lpRecipientJobHandles = NULL;				// This array holds the recipient job handles array used as output parameter to FaxDevSendEx()
	FSPI_MESSAGE_ID ParentMessageId;                    // The parent message id returned by FaxDevSendEx()
    LPFSPI_MESSAGE_ID lpParentMessageId = NULL;         // Points to the parent message id if it is used.
                                                        // NULL in case of an EFSP that does not support job reestablishment.
	HANDLE hParent;                                     // The parent job handle returned by FaxDevSendEx()

	//
    // Allocate the FSP recipient job handles array
    //

    lpRecipientJobHandles = (PHANDLE)malloc(sizeof (HANDLE));
    if (!lpRecipientJobHandles)
    {
        ::lgLogError(
			LOG_SEV_1, 
            TEXT("Failed to allocate recipient job handles array, error:%ld)"),
            GetLastError()
			);
		return FSPI_E_NOMEM;
    }


	//
	//Allocate and init lpRecipientMessageIds and lpParentMessageId
	//
	if (0 < dwMaxMessageIdSize)
	{
		//
        // The EFSP supports job reestablishment
        //


		//
		// Allocate and initialize the recipients permanent message ids array
		//
		HRESULT hr = CreateFSPIRecipientMessageIdsArray(
			&lpRecipientMessageIds,
			1,
			dwMaxMessageIdSize
			);
		if (S_OK != hr)
		{
			lpRecipientMessageIds = NULL;
			::lgLogError(
				LOG_SEV_1, 
				TEXT("CreateFSPIRecipientMessageIdsArray() failed. (ec: %ld)"),
				GetLastError()
				);
			return FSPI_E_NOMEM;
		}
		
		//
		// Allocate the parent permanent message id
		//
		memset(&ParentMessageId,0,sizeof(FSPI_MESSAGE_ID));
		ParentMessageId.dwSizeOfStruct = sizeof(FSPI_MESSAGE_ID);
		ParentMessageId.dwIdSize = dwMaxMessageIdSize;
		ParentMessageId.lpbId = (LPBYTE)malloc(ParentMessageId.dwIdSize);
		if (!ParentMessageId.lpbId)
		{
			::lgLogError(
				LOG_SEV_1, 
				TEXT("Failed to allocate permanent message id buffer for parent job. MaxMessageIdSize: %ld. (ec: %ld)"),
				dwMaxMessageIdSize,
				GetLastError()
				);
			return FSPI_E_NOMEM;
		}
		lpParentMessageId = &ParentMessageId;
	}
	else
	{
		lpRecipientMessageIds = NULL;
        lpParentMessageId = NULL;
	}
	
	
	
	HRESULT hr = g_pEFSP->FaxDevSendEx(
        NULL,
        dwDeviceID,
        g_szValid__TiffFileName,
        &covEFSPICoverPage,
		tmSchedule,
        &FSPISenderInfo,
        1,
        pFSPIRecipientInfo,
        lpRecipientMessageIds,
        lpRecipientJobHandles,
        lpParentMessageId,
		&hParent
		);
	if (S_OK == hr)
	{
		g_pSendingLineInfo->SafeSetJobHandle(lpRecipientJobHandles[0]);
		HANDLE hJob = g_pSendingLineInfo->GetJobHandle();
		//
		//we need to close the send handle
		//
		if (false == g_pEFSP->FaxDevAbortOperation(hJob))
		{
			::lgLogError(
				LOG_SEV_3,
				TEXT("FaxDevAbortOperation() on sending job failed with last error: 0x%08x"),
				::GetLastError()
				);
		}
		g_pSendingLineInfo->SafeEndFaxJob();
	}
	return hr;
}

HRESULT SendDefaultFaxUsingDeviceID(DWORD dwDeviceID)
{
	DWORD dwMaxMessageIdSize = g_pEFSP->m_dwMaxMessageIdSize;

	//
    // Prepare the coverPage structure.
    //
	FSPI_COVERPAGE_INFO covEFSPICoverPage;
	PrepareFSPICoverPage(
			&covEFSPICoverPage,
		    FSPI_COVER_PAGE_FMT_COV,
			1,
			g_szValid__CoverpageFileName,
			DEFAULT_COVERPAGE_NOTE,
			DEFAULT_COVERPAGE_SUBJECT
			);

	//
	//Set the time to send to now (0 in all the fields)
	//
	SYSTEMTIME tmSchedule;
	tmSchedule.wYear = 0;
	tmSchedule.wMonth = 0;
	tmSchedule.wDayOfWeek = 0;
	tmSchedule.wDay = 0;
	tmSchedule.wHour = 0;
	tmSchedule.wMinute = 0;
	tmSchedule.wSecond = 0;
	tmSchedule.wMilliseconds = 0;
	
	FSPI_PERSONAL_PROFILE FSPISenderInfo;				// The sender information sent to FaxDevSendEx()
	FSPI_PERSONAL_PROFILE FSPIRecipientInfo;			// The recipient information sent to FaxDevSendEx()
	
	//
	//prepare the sender profile
	//
	PreparePersonalProfile(
		&FSPISenderInfo,
		DEFAULT_SENDER_INFO__NAME,
		DEFAULT_SENDER_INFO__FAX_NUMBER,
		DEFAULT_SENDER_INFO__COMPANY,
		DEFAULT_SENDER_INFO__STREET,
		DEFAULT_SENDER_INFO__CITY,
		DEFAULT_SENDER_INFO__STATE,
		DEFAULT_SENDER_INFO__ZIP,
		DEFAULT_SENDER_INFO__COUNTRY,
		DEFAULT_SENDER_INFO__TITLE,
		DEFAULT_SENDER_INFO__DEPT,
		DEFAULT_SENDER_INFO__OFFICE_LOCATION,
		DEFAULT_SENDER_INFO__HOME_PHONE,
		DEFAULT_SENDER_INFO__OFFICE_PHONE,
		DEFAULT_SENDER_INFO__ORG_MAIL,
		DEFAULT_SENDER_INFO__INTERNET_MAIL,
		DEFAULT_SENDER_INFO__BILLING_CODE
		);
	
	//
	//prepare the recipient profile
	//
	PreparePersonalProfile(
		&FSPIRecipientInfo,
		DEFAULT_RECIPIENT_INFO__NAME,
		g_szValidRecipientFaxNumber,
		DEFAULT_RECIPIENT_INFO__COMPANY,
		DEFAULT_RECIPIENT_INFO__STREET,
		DEFAULT_RECIPIENT_INFO__CITY,
		DEFAULT_RECIPIENT_INFO__STATE,
		DEFAULT_RECIPIENT_INFO__ZIP,
		DEFAULT_RECIPIENT_INFO__COUNTRY,
		DEFAULT_RECIPIENT_INFO__TITLE,
		DEFAULT_RECIPIENT_INFO__DEPT,
		DEFAULT_RECIPIENT_INFO__OFFICE_LOCATION,
		DEFAULT_RECIPIENT_INFO__HOME_PHONE,
		DEFAULT_RECIPIENT_INFO__OFFICE_PHONE,
		DEFAULT_RECIPIENT_INFO__ORG_MAIL,
		DEFAULT_RECIPIENT_INFO__INTERNET_MAIL,
		DEFAULT_RECIPIENT_INFO__BILLING_CODE
		);
	

	LPFSPI_MESSAGE_ID lpRecipientMessageIds  = NULL;    // This array holds the message id structures array used as output parameter to FaxDevSendEx()
	PHANDLE lpRecipientJobHandles = NULL;				// This array holds the recipient job handles array used as output parameter to FaxDevSendEx()
	FSPI_MESSAGE_ID ParentMessageId;                    // The parent message id returned by FaxDevSendEx()
    LPFSPI_MESSAGE_ID lpParentMessageId = NULL;         // Points to the parent message id if it is used.
                                                        // NULL in case of an EFSP that does not support job reestablishment.
	HANDLE hParent;                                     // The parent job handle returned by FaxDevSendEx()

	//
    // Allocate the FSP recipient job handles array
    //

    lpRecipientJobHandles = (PHANDLE)malloc(sizeof (HANDLE));
    if (!lpRecipientJobHandles)
    {
        ::lgLogError(
			LOG_SEV_1, 
            TEXT("Failed to allocate recipient job handles array, error:%ld)"),
            GetLastError()
			);
		return FSPI_E_NOMEM;
    }


	//
	//Allocate and init lpRecipientMessageIds and lpParentMessageId
	//
	if (0 < dwMaxMessageIdSize)
	{
		//
        // The EFSP supports job reestablishment
        //


		//
		// Allocate and initialize the recipients permanent message ids array
		//
		HRESULT hr = CreateFSPIRecipientMessageIdsArray(
			&lpRecipientMessageIds,
			1,
			dwMaxMessageIdSize
			);
		if (S_OK != hr)
		{
			lpRecipientMessageIds = NULL;
			::lgLogError(
				LOG_SEV_1, 
				TEXT("CreateFSPIRecipientMessageIdsArray() failed. (ec: %ld)"),
				GetLastError()
				);
			return FSPI_E_NOMEM;
		}
		
		//
		// Allocate the parent permanent message id
		//
		memset(&ParentMessageId,0,sizeof(FSPI_MESSAGE_ID));
		ParentMessageId.dwSizeOfStruct = sizeof(FSPI_MESSAGE_ID);
		ParentMessageId.dwIdSize = dwMaxMessageIdSize;
		ParentMessageId.lpbId = (LPBYTE)malloc(ParentMessageId.dwIdSize);
		if (!ParentMessageId.lpbId)
		{
			::lgLogError(
				LOG_SEV_1, 
				TEXT("Failed to allocate permanent message id buffer for parent job. MaxMessageIdSize: %ld. (ec: %ld)"),
				dwMaxMessageIdSize,
				GetLastError()
				);
			return FSPI_E_NOMEM;
		}
		lpParentMessageId = &ParentMessageId;
	}
	else
	{
		lpRecipientMessageIds = NULL;
        lpParentMessageId = NULL;
	}
	
	
	
	HRESULT hr = g_pEFSP->FaxDevSendEx(
        NULL,
        dwDeviceID,
        g_szValid__TiffFileName,
        &covEFSPICoverPage,
		tmSchedule,
        &FSPISenderInfo,
        1,
        &FSPIRecipientInfo,
        lpRecipientMessageIds,
        lpRecipientJobHandles,
        lpParentMessageId,
		&hParent
		);
	if (S_OK == hr)
	{
		g_pSendingLineInfo->SafeSetJobHandle(lpRecipientJobHandles[0]);
		HANDLE hJob = g_pSendingLineInfo->GetJobHandle();

		//
		//we need to close the send handle
		//
		if (false == g_pEFSP->FaxDevAbortOperation(hJob))
		{
			::lgLogError(
				LOG_SEV_3,
				TEXT("FaxDevAbortOperation() on sending job failed with last error: 0x%08x"),
				::GetLastError()
				);
		}
		g_pSendingLineInfo->SafeEndFaxJob();
	}
	return hr;
}


HRESULT SendDefaultFaxWithBodyFile(LPCWSTR pSzBodyFileName)
{
	DWORD dwDeviceID = g_dwSendingValidDeviceId;
	DWORD dwMaxMessageIdSize = g_pEFSP->m_dwMaxMessageIdSize;

	//
    // Prepare the coverPage structure.
    //
	FSPI_COVERPAGE_INFO covEFSPICoverPage;
	PrepareFSPICoverPage(
			&covEFSPICoverPage,
		    FSPI_COVER_PAGE_FMT_COV,
			1,
			g_szValid__CoverpageFileName,
			DEFAULT_COVERPAGE_NOTE,
			DEFAULT_COVERPAGE_SUBJECT
			);

	//
	//Set the time to send to now (0 in all the fields)
	//
	SYSTEMTIME tmSchedule;
	tmSchedule.wYear = 0;
	tmSchedule.wMonth = 0;
	tmSchedule.wDayOfWeek = 0;
	tmSchedule.wDay = 0;
	tmSchedule.wHour = 0;
	tmSchedule.wMinute = 0;
	tmSchedule.wSecond = 0;
	tmSchedule.wMilliseconds = 0;
	
	FSPI_PERSONAL_PROFILE FSPISenderInfo;				// The sender information sent to FaxDevSendEx()
	FSPI_PERSONAL_PROFILE FSPIRecipientInfo;			// The recipient information sent to FaxDevSendEx()
	
	//
	//prepare the sender profile
	//
	PreparePersonalProfile(
		&FSPISenderInfo,
		DEFAULT_SENDER_INFO__NAME,
		DEFAULT_SENDER_INFO__FAX_NUMBER,
		DEFAULT_SENDER_INFO__COMPANY,
		DEFAULT_SENDER_INFO__STREET,
		DEFAULT_SENDER_INFO__CITY,
		DEFAULT_SENDER_INFO__STATE,
		DEFAULT_SENDER_INFO__ZIP,
		DEFAULT_SENDER_INFO__COUNTRY,
		DEFAULT_SENDER_INFO__TITLE,
		DEFAULT_SENDER_INFO__DEPT,
		DEFAULT_SENDER_INFO__OFFICE_LOCATION,
		DEFAULT_SENDER_INFO__HOME_PHONE,
		DEFAULT_SENDER_INFO__OFFICE_PHONE,
		DEFAULT_SENDER_INFO__ORG_MAIL,
		DEFAULT_SENDER_INFO__INTERNET_MAIL,
		DEFAULT_SENDER_INFO__BILLING_CODE
		);
	
	//
	//prepare the recipient profile
	//
	PreparePersonalProfile(
		&FSPIRecipientInfo,
		DEFAULT_RECIPIENT_INFO__NAME,
		g_szValidRecipientFaxNumber,
		DEFAULT_RECIPIENT_INFO__COMPANY,
		DEFAULT_RECIPIENT_INFO__STREET,
		DEFAULT_RECIPIENT_INFO__CITY,
		DEFAULT_RECIPIENT_INFO__STATE,
		DEFAULT_RECIPIENT_INFO__ZIP,
		DEFAULT_RECIPIENT_INFO__COUNTRY,
		DEFAULT_RECIPIENT_INFO__TITLE,
		DEFAULT_RECIPIENT_INFO__DEPT,
		DEFAULT_RECIPIENT_INFO__OFFICE_LOCATION,
		DEFAULT_RECIPIENT_INFO__HOME_PHONE,
		DEFAULT_RECIPIENT_INFO__OFFICE_PHONE,
		DEFAULT_RECIPIENT_INFO__ORG_MAIL,
		DEFAULT_RECIPIENT_INFO__INTERNET_MAIL,
		DEFAULT_RECIPIENT_INFO__BILLING_CODE
		);
	

	LPFSPI_MESSAGE_ID lpRecipientMessageIds  = NULL;    // This array holds the message id structures array used as output parameter to FaxDevSendEx()
	PHANDLE lpRecipientJobHandles = NULL;				// This array holds the recipient job handles array used as output parameter to FaxDevSendEx()
	FSPI_MESSAGE_ID ParentMessageId;                    // The parent message id returned by FaxDevSendEx()
    LPFSPI_MESSAGE_ID lpParentMessageId = NULL;         // Points to the parent message id if it is used.
                                                        // NULL in case of an EFSP that does not support job reestablishment.
	HANDLE hParent;                                     // The parent job handle returned by FaxDevSendEx()

	//
    // Allocate the FSP recipient job handles array
    //

    lpRecipientJobHandles = (PHANDLE)malloc(sizeof (HANDLE));
    if (!lpRecipientJobHandles)
    {
        ::lgLogError(
			LOG_SEV_1, 
            TEXT("Failed to allocate recipient job handles array, error:%ld)"),
            GetLastError()
			);
		return FSPI_E_NOMEM;
    }


	//
	//Allocate and init lpRecipientMessageIds and lpParentMessageId
	//
	if (0 < dwMaxMessageIdSize)
	{
		//
        // The EFSP supports job reestablishment
        //


		//
		// Allocate and initialize the recipients permanent message ids array
		//
		HRESULT hr = CreateFSPIRecipientMessageIdsArray(
			&lpRecipientMessageIds,
			1,
			dwMaxMessageIdSize
			);
		if (S_OK != hr)
		{
			lpRecipientMessageIds = NULL;
			::lgLogError(
				LOG_SEV_1, 
				TEXT("CreateFSPIRecipientMessageIdsArray() failed. (ec: %ld)"),
				GetLastError()
				);
			return FSPI_E_NOMEM;
		}
		
		//
		// Allocate the parent permanent message id
		//
		memset(&ParentMessageId,0,sizeof(FSPI_MESSAGE_ID));
		ParentMessageId.dwSizeOfStruct = sizeof(FSPI_MESSAGE_ID);
		ParentMessageId.dwIdSize = dwMaxMessageIdSize;
		ParentMessageId.lpbId = (LPBYTE)malloc(ParentMessageId.dwIdSize);
		if (!ParentMessageId.lpbId)
		{
			::lgLogError(
				LOG_SEV_1, 
				TEXT("Failed to allocate permanent message id buffer for parent job. MaxMessageIdSize: %ld. (ec: %ld)"),
				dwMaxMessageIdSize,
				GetLastError()
				);
			return FSPI_E_NOMEM;
		}
		lpParentMessageId = &ParentMessageId;
	}
	else
	{
		lpRecipientMessageIds = NULL;
        lpParentMessageId = NULL;
	}
	
	
	
	HRESULT hr = g_pEFSP->FaxDevSendEx(
        NULL,
        dwDeviceID,
        pSzBodyFileName,
        &covEFSPICoverPage,
		tmSchedule,
        &FSPISenderInfo,
        1,
        &FSPIRecipientInfo,
        lpRecipientMessageIds,
        lpRecipientJobHandles,
        lpParentMessageId,
		&hParent
		);
	if (S_OK == hr)
	{
		g_pSendingLineInfo->SafeSetJobHandle(lpRecipientJobHandles[0]);
		HANDLE hJob = g_pSendingLineInfo->GetJobHandle();

		//
		//we need to close the send handle
		//
		if (false == g_pEFSP->FaxDevAbortOperation(hJob))
		{
			::lgLogError(
				LOG_SEV_3,
				TEXT("FaxDevAbortOperation() on sending job failed with last error: 0x%08x"),
				::GetLastError()
				);
		}
		g_pSendingLineInfo->SafeEndFaxJob();
	}
	return hr;
}





HRESULT SendDefaultFaxWithCoverpage(LPWSTR pSzCoverpageFileName)
{
	DWORD dwDeviceID = g_dwSendingValidDeviceId;
	DWORD dwMaxMessageIdSize = g_pEFSP->m_dwMaxMessageIdSize;

	//
    // Prepare the coverPage structure.
    //
	FSPI_COVERPAGE_INFO covEFSPICoverPage;
	PrepareFSPICoverPage(
			&covEFSPICoverPage,
		    FSPI_COVER_PAGE_FMT_COV,
			1,
			pSzCoverpageFileName,
			DEFAULT_COVERPAGE_NOTE,
			DEFAULT_COVERPAGE_SUBJECT
			);
	
	return (SendDefaultFaxWithCoverpageInfo(&covEFSPICoverPage));
}

HRESULT SendDefaultFaxWithCoverpageInfo(FSPI_COVERPAGE_INFO *pCovEFSPICoverPage)
{

	DWORD dwDeviceID = g_dwSendingValidDeviceId;
	DWORD dwMaxMessageIdSize = g_pEFSP->m_dwMaxMessageIdSize;
	
	//
	//Set the time to send to now (0 in all the fields)
	//
	SYSTEMTIME tmSchedule;
	tmSchedule.wYear = 0;
	tmSchedule.wMonth = 0;
	tmSchedule.wDayOfWeek = 0;
	tmSchedule.wDay = 0;
	tmSchedule.wHour = 0;
	tmSchedule.wMinute = 0;
	tmSchedule.wSecond = 0;
	tmSchedule.wMilliseconds = 0;
	
	FSPI_PERSONAL_PROFILE FSPISenderInfo;				// The sender information sent to FaxDevSendEx()
	FSPI_PERSONAL_PROFILE FSPIRecipientInfo;			// The recipient information sent to FaxDevSendEx()
	
	//
	//prepare the sender profile
	//
	PreparePersonalProfile(
		&FSPISenderInfo,
		DEFAULT_SENDER_INFO__NAME,
		DEFAULT_SENDER_INFO__FAX_NUMBER,
		DEFAULT_SENDER_INFO__COMPANY,
		DEFAULT_SENDER_INFO__STREET,
		DEFAULT_SENDER_INFO__CITY,
		DEFAULT_SENDER_INFO__STATE,
		DEFAULT_SENDER_INFO__ZIP,
		DEFAULT_SENDER_INFO__COUNTRY,
		DEFAULT_SENDER_INFO__TITLE,
		DEFAULT_SENDER_INFO__DEPT,
		DEFAULT_SENDER_INFO__OFFICE_LOCATION,
		DEFAULT_SENDER_INFO__HOME_PHONE,
		DEFAULT_SENDER_INFO__OFFICE_PHONE,
		DEFAULT_SENDER_INFO__ORG_MAIL,
		DEFAULT_SENDER_INFO__INTERNET_MAIL,
		DEFAULT_SENDER_INFO__BILLING_CODE
		);
	
	//
	//prepare the recipient profile
	//
	PreparePersonalProfile(
		&FSPIRecipientInfo,
		DEFAULT_RECIPIENT_INFO__NAME,
		g_szValidRecipientFaxNumber,
		DEFAULT_RECIPIENT_INFO__COMPANY,
		DEFAULT_RECIPIENT_INFO__STREET,
		DEFAULT_RECIPIENT_INFO__CITY,
		DEFAULT_RECIPIENT_INFO__STATE,
		DEFAULT_RECIPIENT_INFO__ZIP,
		DEFAULT_RECIPIENT_INFO__COUNTRY,
		DEFAULT_RECIPIENT_INFO__TITLE,
		DEFAULT_RECIPIENT_INFO__DEPT,
		DEFAULT_RECIPIENT_INFO__OFFICE_LOCATION,
		DEFAULT_RECIPIENT_INFO__HOME_PHONE,
		DEFAULT_RECIPIENT_INFO__OFFICE_PHONE,
		DEFAULT_RECIPIENT_INFO__ORG_MAIL,
		DEFAULT_RECIPIENT_INFO__INTERNET_MAIL,
		DEFAULT_RECIPIENT_INFO__BILLING_CODE
		);
	

	LPFSPI_MESSAGE_ID lpRecipientMessageIds  = NULL;    // This array holds the message id structures array used as output parameter to FaxDevSendEx()
	PHANDLE lpRecipientJobHandles = NULL;				// This array holds the recipient job handles array used as output parameter to FaxDevSendEx()
	FSPI_MESSAGE_ID ParentMessageId;                    // The parent message id returned by FaxDevSendEx()
    LPFSPI_MESSAGE_ID lpParentMessageId = NULL;         // Points to the parent message id if it is used.
                                                        // NULL in case of an EFSP that does not support job reestablishment.
	HANDLE hParent;                                     // The parent job handle returned by FaxDevSendEx()

	//
    // Allocate the FSP recipient job handles array
    //

    lpRecipientJobHandles = (PHANDLE)malloc(sizeof (HANDLE));
    if (!lpRecipientJobHandles)
    {
        ::lgLogError(
			LOG_SEV_1, 
            TEXT("Failed to allocate recipient job handles array, error:%ld)"),
            GetLastError()
			);
		return FSPI_E_NOMEM;
    }


	//
	//Allocate and init lpRecipientMessageIds and lpParentMessageId
	//
	if (0 < dwMaxMessageIdSize)
	{
		//
        // The EFSP supports job reestablishment
        //


		//
		// Allocate and initialize the recipients permanent message ids array
		//
		HRESULT hr = CreateFSPIRecipientMessageIdsArray(
			&lpRecipientMessageIds,
			1,
			dwMaxMessageIdSize
			);
		if (S_OK != hr)
		{
			lpRecipientMessageIds = NULL;
			::lgLogError(
				LOG_SEV_1, 
				TEXT("CreateFSPIRecipientMessageIdsArray() failed. (ec: %ld)"),
				GetLastError()
				);
			return FSPI_E_NOMEM;
		}
		
		//
		// Allocate the parent permanent message id
		//
		memset(&ParentMessageId,0,sizeof(FSPI_MESSAGE_ID));
		ParentMessageId.dwSizeOfStruct = sizeof(FSPI_MESSAGE_ID);
		ParentMessageId.dwIdSize = dwMaxMessageIdSize;
		ParentMessageId.lpbId = (LPBYTE)malloc(ParentMessageId.dwIdSize);
		if (!ParentMessageId.lpbId)
		{
			::lgLogError(
				LOG_SEV_1, 
				TEXT("Failed to allocate permanent message id buffer for parent job. MaxMessageIdSize: %ld. (ec: %ld)"),
				dwMaxMessageIdSize,
				GetLastError()
				);
			return FSPI_E_NOMEM;
		}
		lpParentMessageId = &ParentMessageId;
	}
	else
	{
		lpRecipientMessageIds = NULL;
        lpParentMessageId = NULL;
	}
	
	
	
	HRESULT hr = g_pEFSP->FaxDevSendEx(
        NULL,
        dwDeviceID,
        g_szValid__TiffFileName,
        pCovEFSPICoverPage,
		tmSchedule,
        &FSPISenderInfo,
        1,
        &FSPIRecipientInfo,
        lpRecipientMessageIds,
        lpRecipientJobHandles,
        lpParentMessageId,
		&hParent
		);
	if (S_OK == hr)
	{
		g_pSendingLineInfo->SafeSetJobHandle(lpRecipientJobHandles[0]);
		HANDLE hJob = g_pSendingLineInfo->GetJobHandle();
		
		//
		//we need to close the send handle
		//
		if (false == g_pEFSP->FaxDevAbortOperation(hJob))
		{
			::lgLogError(
				LOG_SEV_3,
				TEXT("FaxDevAbortOperation() on sending job failed with last error: 0x%08x"),
				::GetLastError()
				);
		}
		g_pSendingLineInfo->SafeEndFaxJob();
	}
	return hr;
}

HRESULT SendDefaultFaxWithSystemTime(SYSTEMTIME tmSchedule)
{

	DWORD dwDeviceID = g_dwSendingValidDeviceId;
	DWORD dwMaxMessageIdSize = g_pEFSP->m_dwMaxMessageIdSize;

	//
    // Prepare the coverPage structure.
    //
	FSPI_COVERPAGE_INFO covEFSPICoverPage;
	PrepareFSPICoverPage(
			&covEFSPICoverPage,
		    FSPI_COVER_PAGE_FMT_COV,
			1,
			g_szValid__CoverpageFileName,
			DEFAULT_COVERPAGE_NOTE,
			DEFAULT_COVERPAGE_SUBJECT
			);

	FSPI_PERSONAL_PROFILE FSPISenderInfo;				// The sender information sent to FaxDevSendEx()
	FSPI_PERSONAL_PROFILE FSPIRecipientInfo;			// The recipient information sent to FaxDevSendEx()
	
	//
	//prepare the sender profile
	//
	PreparePersonalProfile(
		&FSPISenderInfo,
		DEFAULT_SENDER_INFO__NAME,
		DEFAULT_SENDER_INFO__FAX_NUMBER,
		DEFAULT_SENDER_INFO__COMPANY,
		DEFAULT_SENDER_INFO__STREET,
		DEFAULT_SENDER_INFO__CITY,
		DEFAULT_SENDER_INFO__STATE,
		DEFAULT_SENDER_INFO__ZIP,
		DEFAULT_SENDER_INFO__COUNTRY,
		DEFAULT_SENDER_INFO__TITLE,
		DEFAULT_SENDER_INFO__DEPT,
		DEFAULT_SENDER_INFO__OFFICE_LOCATION,
		DEFAULT_SENDER_INFO__HOME_PHONE,
		DEFAULT_SENDER_INFO__OFFICE_PHONE,
		DEFAULT_SENDER_INFO__ORG_MAIL,
		DEFAULT_SENDER_INFO__INTERNET_MAIL,
		DEFAULT_SENDER_INFO__BILLING_CODE
		);
	
	//
	//prepare the recipient profile
	//
	PreparePersonalProfile(
		&FSPIRecipientInfo,
		DEFAULT_RECIPIENT_INFO__NAME,
		g_szValidRecipientFaxNumber,
		DEFAULT_RECIPIENT_INFO__COMPANY,
		DEFAULT_RECIPIENT_INFO__STREET,
		DEFAULT_RECIPIENT_INFO__CITY,
		DEFAULT_RECIPIENT_INFO__STATE,
		DEFAULT_RECIPIENT_INFO__ZIP,
		DEFAULT_RECIPIENT_INFO__COUNTRY,
		DEFAULT_RECIPIENT_INFO__TITLE,
		DEFAULT_RECIPIENT_INFO__DEPT,
		DEFAULT_RECIPIENT_INFO__OFFICE_LOCATION,
		DEFAULT_RECIPIENT_INFO__HOME_PHONE,
		DEFAULT_RECIPIENT_INFO__OFFICE_PHONE,
		DEFAULT_RECIPIENT_INFO__ORG_MAIL,
		DEFAULT_RECIPIENT_INFO__INTERNET_MAIL,
		DEFAULT_RECIPIENT_INFO__BILLING_CODE
		);
	

	LPFSPI_MESSAGE_ID lpRecipientMessageIds  = NULL;    // This array holds the message id structures array used as output parameter to FaxDevSendEx()
	PHANDLE lpRecipientJobHandles = NULL;				// This array holds the recipient job handles array used as output parameter to FaxDevSendEx()
	FSPI_MESSAGE_ID ParentMessageId;                    // The parent message id returned by FaxDevSendEx()
    LPFSPI_MESSAGE_ID lpParentMessageId = NULL;         // Points to the parent message id if it is used.
                                                        // NULL in case of an EFSP that does not support job reestablishment.
	HANDLE hParent;                                     // The parent job handle returned by FaxDevSendEx()

	//
    // Allocate the FSP recipient job handles array
    //

    lpRecipientJobHandles = (PHANDLE)malloc(sizeof (HANDLE));
    if (!lpRecipientJobHandles)
    {
        ::lgLogError(
			LOG_SEV_1, 
            TEXT("Failed to allocate recipient job handles array, error:%ld)"),
            GetLastError()
			);
		return FSPI_E_NOMEM;
    }


	//
	//Allocate and init lpRecipientMessageIds and lpParentMessageId
	//
	if (0 < dwMaxMessageIdSize)
	{
		//
        // The EFSP supports job reestablishment
        //


		//
		// Allocate and initialize the recipients permanent message ids array
		//
		HRESULT hr = CreateFSPIRecipientMessageIdsArray(
			&lpRecipientMessageIds,
			1,
			dwMaxMessageIdSize
			);
		if (S_OK != hr)
		{
			lpRecipientMessageIds = NULL;
			::lgLogError(
				LOG_SEV_1, 
				TEXT("CreateFSPIRecipientMessageIdsArray() failed. (ec: %ld)"),
				GetLastError()
				);
			return FSPI_E_NOMEM;
		}
		
		//
		// Allocate the parent permanent message id
		//
		memset(&ParentMessageId,0,sizeof(FSPI_MESSAGE_ID));
		ParentMessageId.dwSizeOfStruct = sizeof(FSPI_MESSAGE_ID);
		ParentMessageId.dwIdSize = dwMaxMessageIdSize;
		ParentMessageId.lpbId = (LPBYTE)malloc(ParentMessageId.dwIdSize);
		if (!ParentMessageId.lpbId)
		{
			::lgLogError(
				LOG_SEV_1, 
				TEXT("Failed to allocate permanent message id buffer for parent job. MaxMessageIdSize: %ld. (ec: %ld)"),
				dwMaxMessageIdSize,
				GetLastError()
				);
			return FSPI_E_NOMEM;
		}
		lpParentMessageId = &ParentMessageId;
	}
	else
	{
		lpRecipientMessageIds = NULL;
        lpParentMessageId = NULL;
	}
	
	
	
	HRESULT hr = g_pEFSP->FaxDevSendEx(
        NULL,
        dwDeviceID,
        g_szValid__TiffFileName,
        &covEFSPICoverPage,
		tmSchedule,
        &FSPISenderInfo,
        1,
        &FSPIRecipientInfo,
        lpRecipientMessageIds,
        lpRecipientJobHandles,
        lpParentMessageId,
		&hParent
		);
	if (S_OK == hr)
	{
		g_pSendingLineInfo->SafeSetJobHandle(lpRecipientJobHandles[0]);
		HANDLE hJob = g_pSendingLineInfo->GetJobHandle();
		
		//
		//we need to close the send handle
		//
		if (false == g_pEFSP->FaxDevAbortOperation(hJob))
		{
			::lgLogError(
				LOG_SEV_3,
				TEXT("FaxDevAbortOperation() on sending job failed with last error: 0x%08x"),
				::GetLastError()
				);
		}
		g_pSendingLineInfo->SafeEndFaxJob();
	}
	return hr;

}




HRESULT SendDefaultFaxWithMessageIdArray(LPFSPI_MESSAGE_ID lpRecipientMessageIds)
{
	DWORD dwDeviceID = g_dwSendingValidDeviceId;
	DWORD dwMaxMessageIdSize = g_pEFSP->m_dwMaxMessageIdSize;

	//
	//Set the time to send to now (0 in all the fields)
	//
	SYSTEMTIME tmSchedule;
	tmSchedule.wYear = 0;
	tmSchedule.wMonth = 0;
	tmSchedule.wDayOfWeek = 0;
	tmSchedule.wDay = 0;
	tmSchedule.wHour = 0;
	tmSchedule.wMinute = 0;
	tmSchedule.wSecond = 0;
	tmSchedule.wMilliseconds = 0;
	
	
	//
    // Prepare the coverPage structure.
    //
	FSPI_COVERPAGE_INFO covEFSPICoverPage;
	PrepareFSPICoverPage(
			&covEFSPICoverPage,
		    FSPI_COVER_PAGE_FMT_COV,
			1,
			g_szValid__CoverpageFileName,
			DEFAULT_COVERPAGE_NOTE,
			DEFAULT_COVERPAGE_SUBJECT
			);

	FSPI_PERSONAL_PROFILE FSPISenderInfo;				// The sender information sent to FaxDevSendEx()
	FSPI_PERSONAL_PROFILE FSPIRecipientInfo;			// The recipient information sent to FaxDevSendEx()
	
	//
	//prepare the sender profile
	//
	PreparePersonalProfile(
		&FSPISenderInfo,
		DEFAULT_SENDER_INFO__NAME,
		DEFAULT_SENDER_INFO__FAX_NUMBER,
		DEFAULT_SENDER_INFO__COMPANY,
		DEFAULT_SENDER_INFO__STREET,
		DEFAULT_SENDER_INFO__CITY,
		DEFAULT_SENDER_INFO__STATE,
		DEFAULT_SENDER_INFO__ZIP,
		DEFAULT_SENDER_INFO__COUNTRY,
		DEFAULT_SENDER_INFO__TITLE,
		DEFAULT_SENDER_INFO__DEPT,
		DEFAULT_SENDER_INFO__OFFICE_LOCATION,
		DEFAULT_SENDER_INFO__HOME_PHONE,
		DEFAULT_SENDER_INFO__OFFICE_PHONE,
		DEFAULT_SENDER_INFO__ORG_MAIL,
		DEFAULT_SENDER_INFO__INTERNET_MAIL,
		DEFAULT_SENDER_INFO__BILLING_CODE
		);
	
	//
	//prepare the recipient profile
	//
	PreparePersonalProfile(
		&FSPIRecipientInfo,
		DEFAULT_RECIPIENT_INFO__NAME,
		g_szValidRecipientFaxNumber,
		DEFAULT_RECIPIENT_INFO__COMPANY,
		DEFAULT_RECIPIENT_INFO__STREET,
		DEFAULT_RECIPIENT_INFO__CITY,
		DEFAULT_RECIPIENT_INFO__STATE,
		DEFAULT_RECIPIENT_INFO__ZIP,
		DEFAULT_RECIPIENT_INFO__COUNTRY,
		DEFAULT_RECIPIENT_INFO__TITLE,
		DEFAULT_RECIPIENT_INFO__DEPT,
		DEFAULT_RECIPIENT_INFO__OFFICE_LOCATION,
		DEFAULT_RECIPIENT_INFO__HOME_PHONE,
		DEFAULT_RECIPIENT_INFO__OFFICE_PHONE,
		DEFAULT_RECIPIENT_INFO__ORG_MAIL,
		DEFAULT_RECIPIENT_INFO__INTERNET_MAIL,
		DEFAULT_RECIPIENT_INFO__BILLING_CODE
		);
	

	PHANDLE lpRecipientJobHandles = NULL;				// This array holds the recipient job handles array used as output parameter to FaxDevSendEx()
	FSPI_MESSAGE_ID ParentMessageId;                    // The parent message id returned by FaxDevSendEx()
    LPFSPI_MESSAGE_ID lpParentMessageId = NULL;         // Points to the parent message id if it is used.
                                                        // NULL in case of an EFSP that does not support job reestablishment.
	HANDLE hParent;                                     // The parent job handle returned by FaxDevSendEx()

	//
    // Allocate the FSP recipient job handles array
    //

    lpRecipientJobHandles = (PHANDLE)malloc(sizeof (HANDLE));
    if (!lpRecipientJobHandles)
    {
        ::lgLogError(
			LOG_SEV_1, 
            TEXT("Failed to allocate recipient job handles array, error:%ld)"),
            GetLastError()
			);
		return FSPI_E_NOMEM;
    }


	//
	//Allocate and init lpRecipientMessageIds and lpParentMessageId
	//
	if (0 < dwMaxMessageIdSize)
	{
		//
        // The EFSP supports job reestablishment
        //


		//
		// Allocate the parent permanent message id
		//
		memset(&ParentMessageId,0,sizeof(FSPI_MESSAGE_ID));
		ParentMessageId.dwSizeOfStruct = sizeof(FSPI_MESSAGE_ID);
		ParentMessageId.dwIdSize = dwMaxMessageIdSize;
		ParentMessageId.lpbId = (LPBYTE)malloc(ParentMessageId.dwIdSize);
		if (!ParentMessageId.lpbId)
		{
			::lgLogError(
				LOG_SEV_1, 
				TEXT("Failed to allocate permanent message id buffer for parent job. MaxMessageIdSize: %ld. (ec: %ld)"),
				dwMaxMessageIdSize,
				GetLastError()
				);
			return FSPI_E_NOMEM;
		}
		lpParentMessageId = &ParentMessageId;
	}
	else
	{
        lpParentMessageId = NULL;
	}
	
	
	
	HRESULT hr = g_pEFSP->FaxDevSendEx(
        NULL,
        dwDeviceID,
        g_szValid__TiffFileName,
        &covEFSPICoverPage,
		tmSchedule,
        &FSPISenderInfo,
        1,
        &FSPIRecipientInfo,
        lpRecipientMessageIds,
        lpRecipientJobHandles,
        lpParentMessageId,
		&hParent
		);
	if (S_OK == hr)
	{
		g_pSendingLineInfo->SafeSetJobHandle(lpRecipientJobHandles[0]);
		HANDLE hJob = g_pSendingLineInfo->GetJobHandle();
		
		//
		//we need to close the send handle
		//
		if (false == g_pEFSP->FaxDevAbortOperation(hJob))
		{
			::lgLogError(
				LOG_SEV_3,
				TEXT("FaxDevAbortOperation() on sending job failed with last error: 0x%08x"),
				::GetLastError()
				);
		}
		g_pSendingLineInfo->SafeEndFaxJob();
	}
	return hr;
}

HRESULT SendDefaultFaxWithRecipientJobHandleArray(PHANDLE lpRecipientJobHandles)
{

	DWORD dwDeviceID = g_dwSendingValidDeviceId;
	DWORD dwMaxMessageIdSize = g_pEFSP->m_dwMaxMessageIdSize;

	//
	//Set the time to send to now (0 in all the fields)
	//
	SYSTEMTIME tmSchedule;
	tmSchedule.wYear = 0;
	tmSchedule.wMonth = 0;
	tmSchedule.wDayOfWeek = 0;
	tmSchedule.wDay = 0;
	tmSchedule.wHour = 0;
	tmSchedule.wMinute = 0;
	tmSchedule.wSecond = 0;
	tmSchedule.wMilliseconds = 0;

	
	//
    // Prepare the coverPage structure.
    //
	FSPI_COVERPAGE_INFO covEFSPICoverPage;
	PrepareFSPICoverPage(
			&covEFSPICoverPage,
		    FSPI_COVER_PAGE_FMT_COV,
			1,
			g_szValid__CoverpageFileName,
			DEFAULT_COVERPAGE_NOTE,
			DEFAULT_COVERPAGE_SUBJECT
			);

	FSPI_PERSONAL_PROFILE FSPISenderInfo;				// The sender information sent to FaxDevSendEx()
	FSPI_PERSONAL_PROFILE FSPIRecipientInfo;			// The recipient information sent to FaxDevSendEx()
	
	//
	//prepare the sender profile
	//
	PreparePersonalProfile(
		&FSPISenderInfo,
		DEFAULT_SENDER_INFO__NAME,
		DEFAULT_SENDER_INFO__FAX_NUMBER,
		DEFAULT_SENDER_INFO__COMPANY,
		DEFAULT_SENDER_INFO__STREET,
		DEFAULT_SENDER_INFO__CITY,
		DEFAULT_SENDER_INFO__STATE,
		DEFAULT_SENDER_INFO__ZIP,
		DEFAULT_SENDER_INFO__COUNTRY,
		DEFAULT_SENDER_INFO__TITLE,
		DEFAULT_SENDER_INFO__DEPT,
		DEFAULT_SENDER_INFO__OFFICE_LOCATION,
		DEFAULT_SENDER_INFO__HOME_PHONE,
		DEFAULT_SENDER_INFO__OFFICE_PHONE,
		DEFAULT_SENDER_INFO__ORG_MAIL,
		DEFAULT_SENDER_INFO__INTERNET_MAIL,
		DEFAULT_SENDER_INFO__BILLING_CODE
		);
	
	//
	//prepare the recipient profile
	//
	PreparePersonalProfile(
		&FSPIRecipientInfo,
		DEFAULT_RECIPIENT_INFO__NAME,
		g_szValidRecipientFaxNumber,
		DEFAULT_RECIPIENT_INFO__COMPANY,
		DEFAULT_RECIPIENT_INFO__STREET,
		DEFAULT_RECIPIENT_INFO__CITY,
		DEFAULT_RECIPIENT_INFO__STATE,
		DEFAULT_RECIPIENT_INFO__ZIP,
		DEFAULT_RECIPIENT_INFO__COUNTRY,
		DEFAULT_RECIPIENT_INFO__TITLE,
		DEFAULT_RECIPIENT_INFO__DEPT,
		DEFAULT_RECIPIENT_INFO__OFFICE_LOCATION,
		DEFAULT_RECIPIENT_INFO__HOME_PHONE,
		DEFAULT_RECIPIENT_INFO__OFFICE_PHONE,
		DEFAULT_RECIPIENT_INFO__ORG_MAIL,
		DEFAULT_RECIPIENT_INFO__INTERNET_MAIL,
		DEFAULT_RECIPIENT_INFO__BILLING_CODE
		);
	

	LPFSPI_MESSAGE_ID lpRecipientMessageIds  = NULL;    // This array holds the message id structures array used as output parameter to FaxDevSendEx()
	FSPI_MESSAGE_ID ParentMessageId;                    // The parent message id returned by FaxDevSendEx()
    LPFSPI_MESSAGE_ID lpParentMessageId = NULL;         // Points to the parent message id if it is used.
                                                        // NULL in case of an EFSP that does not support job reestablishment.
	HANDLE hParent;                                     // The parent job handle returned by FaxDevSendEx()

	//
	//Allocate and init lpRecipientMessageIds and lpParentMessageId
	//
	if (0 < dwMaxMessageIdSize)
	{
		//
        // The EFSP supports job reestablishment
        //


		//
		// Allocate and initialize the recipients permanent message ids array
		//
		HRESULT hr = CreateFSPIRecipientMessageIdsArray(
			&lpRecipientMessageIds,
			1,
			dwMaxMessageIdSize
			);
		if (S_OK != hr)
		{
			lpRecipientMessageIds = NULL;
			::lgLogError(
				LOG_SEV_1, 
				TEXT("CreateFSPIRecipientMessageIdsArray() failed. (ec: %ld)"),
				GetLastError()
				);
			return FSPI_E_NOMEM;
		}
		
		//
		// Allocate the parent permanent message id
		//
		memset(&ParentMessageId,0,sizeof(FSPI_MESSAGE_ID));
		ParentMessageId.dwSizeOfStruct = sizeof(FSPI_MESSAGE_ID);
		ParentMessageId.dwIdSize = dwMaxMessageIdSize;
		ParentMessageId.lpbId = (LPBYTE)malloc(ParentMessageId.dwIdSize);
		if (!ParentMessageId.lpbId)
		{
			::lgLogError(
				LOG_SEV_1, 
				TEXT("Failed to allocate permanent message id buffer for parent job. MaxMessageIdSize: %ld. (ec: %ld)"),
				dwMaxMessageIdSize,
				GetLastError()
				);
			return FSPI_E_NOMEM;
		}
		lpParentMessageId = &ParentMessageId;
	}
	else
	{
		lpRecipientMessageIds = NULL;
        lpParentMessageId = NULL;
	}
	
	
	
	HRESULT hr = g_pEFSP->FaxDevSendEx(
        NULL,
        dwDeviceID,
        g_szValid__TiffFileName,
        &covEFSPICoverPage,
		tmSchedule,
        &FSPISenderInfo,
        1,
        &FSPIRecipientInfo,
        lpRecipientMessageIds,
        lpRecipientJobHandles,
        lpParentMessageId,
		&hParent
		);
	if (S_OK == hr)
	{
		if (NULL != lpRecipientJobHandles)
		{
			g_pSendingLineInfo->SafeSetJobHandle(lpRecipientJobHandles[0]);
			HANDLE hJob = g_pSendingLineInfo->GetJobHandle();
			
			//
			//we need to close the send handle
			//
			if (false == g_pEFSP->FaxDevAbortOperation(hJob))
			{
				::lgLogError(
					LOG_SEV_3,
					TEXT("FaxDevAbortOperation() on sending job failed with last error: 0x%08x"),
					::GetLastError()
					);
			}
			g_pSendingLineInfo->SafeEndFaxJob();
		}
	}
	return hr;
}


HRESULT SendDefaultFaxWithParentJobHandle(PHANDLE phParentHandle)
{
	DWORD dwDeviceID = g_dwSendingValidDeviceId;
	DWORD dwMaxMessageIdSize = g_pEFSP->m_dwMaxMessageIdSize;

	//
	//Set the time to send to now (0 in all the fields)
	//
	SYSTEMTIME tmSchedule;
	tmSchedule.wYear = 0;
	tmSchedule.wMonth = 0;
	tmSchedule.wDayOfWeek = 0;
	tmSchedule.wDay = 0;
	tmSchedule.wHour = 0;
	tmSchedule.wMinute = 0;
	tmSchedule.wSecond = 0;
	tmSchedule.wMilliseconds = 0;

	
	//
    // Prepare the coverPage structure.
    //
	FSPI_COVERPAGE_INFO covEFSPICoverPage;
	PrepareFSPICoverPage(
			&covEFSPICoverPage,
		    FSPI_COVER_PAGE_FMT_COV,
			1,
			g_szValid__CoverpageFileName,
			DEFAULT_COVERPAGE_NOTE,
			DEFAULT_COVERPAGE_SUBJECT
			);

	FSPI_PERSONAL_PROFILE FSPISenderInfo;				// The sender information sent to FaxDevSendEx()
	FSPI_PERSONAL_PROFILE FSPIRecipientInfo;			// The recipient information sent to FaxDevSendEx()
	
	//
	//prepare the sender profile
	//
	PreparePersonalProfile(
		&FSPISenderInfo,
		DEFAULT_SENDER_INFO__NAME,
		DEFAULT_SENDER_INFO__FAX_NUMBER,
		DEFAULT_SENDER_INFO__COMPANY,
		DEFAULT_SENDER_INFO__STREET,
		DEFAULT_SENDER_INFO__CITY,
		DEFAULT_SENDER_INFO__STATE,
		DEFAULT_SENDER_INFO__ZIP,
		DEFAULT_SENDER_INFO__COUNTRY,
		DEFAULT_SENDER_INFO__TITLE,
		DEFAULT_SENDER_INFO__DEPT,
		DEFAULT_SENDER_INFO__OFFICE_LOCATION,
		DEFAULT_SENDER_INFO__HOME_PHONE,
		DEFAULT_SENDER_INFO__OFFICE_PHONE,
		DEFAULT_SENDER_INFO__ORG_MAIL,
		DEFAULT_SENDER_INFO__INTERNET_MAIL,
		DEFAULT_SENDER_INFO__BILLING_CODE
		);
	
	//
	//prepare the recipient profile
	//
	PreparePersonalProfile(
		&FSPIRecipientInfo,
		DEFAULT_RECIPIENT_INFO__NAME,
		g_szValidRecipientFaxNumber,
		DEFAULT_RECIPIENT_INFO__COMPANY,
		DEFAULT_RECIPIENT_INFO__STREET,
		DEFAULT_RECIPIENT_INFO__CITY,
		DEFAULT_RECIPIENT_INFO__STATE,
		DEFAULT_RECIPIENT_INFO__ZIP,
		DEFAULT_RECIPIENT_INFO__COUNTRY,
		DEFAULT_RECIPIENT_INFO__TITLE,
		DEFAULT_RECIPIENT_INFO__DEPT,
		DEFAULT_RECIPIENT_INFO__OFFICE_LOCATION,
		DEFAULT_RECIPIENT_INFO__HOME_PHONE,
		DEFAULT_RECIPIENT_INFO__OFFICE_PHONE,
		DEFAULT_RECIPIENT_INFO__ORG_MAIL,
		DEFAULT_RECIPIENT_INFO__INTERNET_MAIL,
		DEFAULT_RECIPIENT_INFO__BILLING_CODE
		);
	

	PHANDLE lpRecipientJobHandles = NULL;				// This array holds the recipient job handles array used as output parameter to FaxDevSendEx()
	LPFSPI_MESSAGE_ID lpRecipientMessageIds  = NULL;    // This array holds the message id structures array used as output parameter to FaxDevSendEx()
	FSPI_MESSAGE_ID ParentMessageId;                    // The parent message id returned by FaxDevSendEx()
    LPFSPI_MESSAGE_ID lpParentMessageId = NULL;         // Points to the parent message id if it is used.
                                                        // NULL in case of an EFSP that does not support job reestablishment.
	
	//
    // Allocate the FSP recipient job handles array
    //
    lpRecipientJobHandles = (PHANDLE)malloc(sizeof (HANDLE));
    if (!lpRecipientJobHandles)
    {
        ::lgLogError(
			LOG_SEV_1, 
            TEXT("Failed to allocate recipient job handles array, error:%ld)"),
            GetLastError()
			);
		return FSPI_E_NOMEM;
    }
	
	//
	//Allocate and init lpRecipientMessageIds and lpParentMessageId
	//
	if (0 < dwMaxMessageIdSize)
	{
		//
        // The EFSP supports job reestablishment
        //


		//
		// Allocate and initialize the recipients permanent message ids array
		//
		HRESULT hr = CreateFSPIRecipientMessageIdsArray(
			&lpRecipientMessageIds,
			1,
			dwMaxMessageIdSize
			);
		if (S_OK != hr)
		{
			lpRecipientMessageIds = NULL;
			::lgLogError(
				LOG_SEV_1, 
				TEXT("CreateFSPIRecipientMessageIdsArray() failed. (ec: %ld)"),
				GetLastError()
				);
			return FSPI_E_NOMEM;
		}
		
		//
		// Allocate the parent permanent message id
		//
		memset(&ParentMessageId,0,sizeof(FSPI_MESSAGE_ID));
		ParentMessageId.dwSizeOfStruct = sizeof(FSPI_MESSAGE_ID);
		ParentMessageId.dwIdSize = dwMaxMessageIdSize;
		ParentMessageId.lpbId = (LPBYTE)malloc(ParentMessageId.dwIdSize);
		if (!ParentMessageId.lpbId)
		{
			::lgLogError(
				LOG_SEV_1, 
				TEXT("Failed to allocate permanent message id buffer for parent job. MaxMessageIdSize: %ld. (ec: %ld)"),
				dwMaxMessageIdSize,
				GetLastError()
				);
			return FSPI_E_NOMEM;
		}
		lpParentMessageId = &ParentMessageId;
	}
	else
	{
		lpRecipientMessageIds = NULL;
        lpParentMessageId = NULL;
	}
	
	
	
	HRESULT hr = g_pEFSP->FaxDevSendEx(
        NULL,
        dwDeviceID,
        g_szValid__TiffFileName,
        &covEFSPICoverPage,
		tmSchedule,
        &FSPISenderInfo,
        1,
        &FSPIRecipientInfo,
        lpRecipientMessageIds,
        lpRecipientJobHandles,
        lpParentMessageId,
		phParentHandle
		);
	if (S_OK == hr)
	{
		g_pSendingLineInfo->SafeSetJobHandle(lpRecipientJobHandles[0]);
		HANDLE hJob = g_pSendingLineInfo->GetJobHandle();

		//
		//we need to close the send handle
		//
		if (false == g_pEFSP->FaxDevAbortOperation(hJob))
		{
			::lgLogError(
				LOG_SEV_3,
				TEXT("FaxDevAbortOperation() on sending job failed with last error: 0x%08x"),
				::GetLastError()
				);
		}
		g_pSendingLineInfo->SafeEndFaxJob();
	}
	return hr;
}




HRESULT CreateFSPIRecipientMessageIdsArray(
        LPFSPI_MESSAGE_ID * lppRecipientMessageIds,
        DWORD dwRecipientCount,
        DWORD dwMessageIdSize)
{

	DWORD dwRecipient;
	DWORD ec = 0;
	LPFSPI_MESSAGE_ID lpRecipientMessageIds;

	if (0 < dwMessageIdSize)
    {
        //
        // The EFSP supports job reestablishment
        //
		assert(lppRecipientMessageIds);
		assert(dwRecipientCount >= 1);

		//
		// Allocate the permanent message id structures array.
		//
		lpRecipientMessageIds = (LPFSPI_MESSAGE_ID) malloc( dwRecipientCount * sizeof (FSPI_MESSAGE_ID));
		if (!lpRecipientMessageIds)
		{
			ec = GetLastError();
			::lgLogError(
				LOG_SEV_1, 
				TEXT("Failed to allocate permanent message id structures array. RecipientCount: %ld (ec: %ld)"),
				dwRecipientCount,
				GetLastError()
				);
			return ERROR_OUTOFMEMORY;
		}
		//
		// We must nullify the array (specifically FSPI_MESSAGE_ID.lpbId) so we will know
		// which id as allocated and which was not (for cleanup).
		//
		memset(lpRecipientMessageIds, 0, dwRecipientCount * sizeof (FSPI_MESSAGE_ID));

		for (dwRecipient = 0; dwRecipient < dwRecipientCount; dwRecipient++)
		{
			lpRecipientMessageIds[dwRecipient].dwSizeOfStruct = sizeof(FSPI_MESSAGE_ID);
			lpRecipientMessageIds[dwRecipient].dwIdSize = dwMessageIdSize;
			if (dwMessageIdSize)
			{
				assert(lpRecipientMessageIds[dwRecipient].dwIdSize > 0);
				lpRecipientMessageIds[dwRecipient].lpbId = (LPBYTE)malloc(lpRecipientMessageIds[dwRecipient].dwIdSize);
				if (!lpRecipientMessageIds[dwRecipient].lpbId)
				{
					ec = GetLastError();
					::lgLogError(
						LOG_SEV_1, 
						TEXT("Failed to allocate permanent message id buffer for recipient #%ld. MaxMessageIdSize: %ld. (ec: %ld)"),
						dwRecipient,
						dwMessageIdSize,
						ec
						);
					return ERROR_OUTOFMEMORY;
				}
			}
			else
			{
				lpRecipientMessageIds[dwRecipient].lpbId = NULL;
			}
		}
	}
	else
    {
        lpRecipientMessageIds = NULL;
    }

    *lppRecipientMessageIds = lpRecipientMessageIds;

    return S_OK;
   
}


void PrepareFSPICoverPage(
    LPFSPI_COVERPAGE_INFO lpDst,
    DWORD	dwCoverPageFormat,
	DWORD   dwNumberOfPages,
	LPTSTR  lptstrCoverPageFileName,
	LPTSTR  lptstrNote,
	LPTSTR  lptstrSubject
	)
{
    assert(lpDst);

    lpDst->dwSizeOfStruct = sizeof(FSPI_COVERPAGE_INFO);
    lpDst->dwCoverPageFormat = dwCoverPageFormat;
    lpDst->lpwstrCoverPageFileName = lptstrCoverPageFileName;
    lpDst->lpwstrNote = lptstrNote;
    lpDst->lpwstrSubject = lptstrSubject;
    lpDst->dwNumberOfPages = dwNumberOfPages;
}

void PreparePersonalProfile(
    LPFSPI_PERSONAL_PROFILE lpDst,
    LPWSTR     lptstrName,
    LPWSTR     lptstrFaxNumber,
    LPWSTR     lptstrCompany,
    LPWSTR     lptstrStreetAddress,
    LPWSTR     lptstrCity,
    LPWSTR     lptstrState,
    LPWSTR     lptstrZip,
    LPWSTR     lptstrCountry,
    LPWSTR     lptstrTitle,
    LPWSTR     lptstrDepartment,
    LPWSTR     lptstrOfficeLocation,
    LPWSTR     lptstrHomePhone,
    LPWSTR     lptstrOfficePhone,
    LPWSTR     lptstrEmail,
    LPWSTR     lptstrBillingCode
	)
{
    assert(lpDst);

    lpDst->dwSizeOfStruct = sizeof(FSPI_PERSONAL_PROFILE);
    lpDst->lpwstrName = lptstrName;
	lpDst->lpwstrFaxNumber = lptstrFaxNumber;
    lpDst->lpwstrCompany = lptstrCompany;
    lpDst->lpwstrStreetAddress = lptstrStreetAddress;
	lpDst->lpwstrCity = lptstrCity;
    lpDst->lpwstrState = lptstrState;
    lpDst->lpwstrZip = lptstrZip;
    lpDst->lpwstrCountry = lptstrCountry;
    lpDst->lpwstrTitle = lptstrTitle;
    lpDst->lpwstrDepartment = lptstrDepartment;
    lpDst->lpwstrOfficeLocation = lptstrOfficeLocation;
    lpDst->lpwstrHomePhone = lptstrHomePhone;
	lpDst->lpwstrOfficePhone = lptstrOfficePhone;
    lpDst->lptstrEmail = lptstrEmail;
    lpDst->lpwstrBillingCode = lptstrBillingCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\fsp\3rdpartyfsp_verifier\efsp\paramtest.h ===
#ifndef ParamTest_h
#define ParamTest_h

#include "CEfspWrapper.h"
#include <assert.h>
#include <stdio.h>
#include <TCHAR.h>
#include <WINFAX.H>
#include <faxDev.h>
#include <log\log.h>




void Suite_FaxDevInitializeEx();
void Suite_FaxDevEnumerateDevices();
void Suite_FaxDevReportStatusEx();
void Suite_FaxDevSendEx();
void Suite_FaxDevReestablishJobContext();
void Suite_FaxDevReceive();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\fsp\3rdpartyfsp_verifier\efsp\paramtest.cpp ===
#include "ParamTest.h"
#include "Service.h"
#include "FaxDevSendExWrappers.h"

extern CEfspWrapper *g_pEFSP;
extern DWORD g_dwCaseNumber;

extern CEfspLineInfo * g_pSendingLineInfo;
extern CEfspLineInfo * g_pReceivingLineInfo;


//
//EFSP info
//
extern bool g_bHasLineCallbackFunction;

//
//DeviceIDs
//
extern DWORD g_dwInvalidDeviceId;
extern DWORD g_dwSendingValidDeviceId;
extern DWORD g_dwReceiveValidDeviceId;

//
//Phone numbers
//
extern TCHAR* g_szInvalidRecipientFaxNumber;
extern TCHAR* g_szValidRecipientFaxNumber;

//
//TIFF files
//
extern TCHAR* g_szValid__TiffFileName;
extern TCHAR* g_szValid_ReadOnly_TiffFileName;
extern TCHAR* g_szValid_FileNotFound_TiffFileName;
extern TCHAR* g_szValid_UNC_TiffFileName;
extern TCHAR* g_szValid_NTFS_TiffFileName;
extern TCHAR* g_szValid_FAT_TiffFileName;
extern TCHAR* g_szValid_Link_TiffFileName;
extern TCHAR* g_szValid_NotTiffExt_TiffFileName;
extern TCHAR* g_szValid_InvalidTiffFormat_TiffFileName;
extern TCHAR* g_szValid_ReceiveFileName;


//
//Coverpage files
//
extern TCHAR* g_szValid__CoverpageFileName;
extern TCHAR* g_szValid_ReadOnly_CoverpageFileName;
extern TCHAR* g_szValid_FileNotFound_CoverpageFileName;
extern TCHAR* g_szValid_UNC_CoverpageFileName;
extern TCHAR* g_szValid_NTFS_CoverpageFileName;
extern TCHAR* g_szValid_FAT_CoverpageFileName;
extern TCHAR* g_szValid_Link_CoverpageFileName;
extern TCHAR* g_szValid_NotCoverpageFormat_CoverpageFileName;
extern TCHAR* g_szValid_InvalidCoverpageFormat_CoverpageFileName;






/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
//FaxDevInitializeEx cases
void Case_EfspInit_hFSP(const CFaxDevInitParams faxDevInitParams);
void Case_EfspInit_hLineApp(const CFaxDevInitParams faxDevInitParams);
void Case_EfspInit_LineCallBackFunction(const CFaxDevInitParams faxDevInitParams);
void Case_EfspInit_ServiceCallbackFunction(const CFaxDevInitParams faxDevInitParams);
void Case_EfspInit_MessageIdSize(const CFaxDevInitParams faxDevInitParams);


void Suite_FaxDevInitializeEx()
{
	::lgBeginSuite(TEXT("FaxDevInitializeEx Init"));
	
	HANDLE						hFSP				=	(HANDLE) 100;
	PFAX_LINECALLBACK			LineCallbackFunction=	NULL;
    PFAX_SERVICE_CALLBACK_EX	FaxServiceCallbackEx=	FaxDeviceProviderCallbackEx_NoReceiveNoSignal;
    DWORD						dwMaxMessageIdSize	=	0;
	

	const CFaxDevInitParams originalFaxDevInitParams(
		hFSP,
		NULL,
		&LineCallbackFunction,
		FaxServiceCallbackEx,
		&dwMaxMessageIdSize
		);


	Case_EfspInit_hFSP(originalFaxDevInitParams);
	Case_EfspInit_hLineApp(originalFaxDevInitParams);
	Case_EfspInit_LineCallBackFunction(originalFaxDevInitParams);
	Case_EfspInit_ServiceCallbackFunction(originalFaxDevInitParams);
	Case_EfspInit_MessageIdSize(originalFaxDevInitParams);

	::lgEndSuite();
	return;
}



///////////////////////////////////////////////////////////////////////////////
//
//FSP handle
//
void Case_EfspInit__NULL_hFSP(const CFaxDevInitParams originalEfspParms)
{
	BEGIN_CASE(TEXT("NULL hFSP"))

	CFaxDevInitParams faxDevInitParams = originalEfspParms;
	faxDevInitParams.m_hFSP = NULL;
	
	FaxDevInitializeExWrapper(faxDevInitParams,true);		//should fail
	ShutdownEfsp_UnloadEfsp();

	::lgEndCase();
}

void Case_EfspInit_hFSP(const CFaxDevInitParams originalEfspParms)
{
	lgLogDetail(
		LOG_X,
		2,
		TEXT("\n\n\n*************************************************************************\n***************************** hFSP param ********************************")
		);

	Case_EfspInit__NULL_hFSP(originalEfspParms);
}


///////////////////////////////////////////////////////////////////////////////
//
//hLineAppHandle handle
//
void Case_EfspInit__NULL_hLineApp(const CFaxDevInitParams originalEfspParms)
{
	BEGIN_CASE(TEXT("NULL hLineApp"))

	CFaxDevInitParams faxDevInitParams= originalEfspParms;
	faxDevInitParams.m_LineAppHandle = NULL;

	FaxDevInitializeExWrapper(faxDevInitParams,false);		//Non Tapi EFSP, shouldn't fail
	ShutdownEfsp_UnloadEfsp();

	::lgEndCase();
}

void Case_EfspInit_hLineApp(const CFaxDevInitParams originalEfspParms)
{
	lgLogDetail(
		LOG_X,
		2,
		TEXT("\n\n\n*************************************************************************\n***************************** hLineApp param ********************************")
		);

	Case_EfspInit__NULL_hLineApp(originalEfspParms);
}


///////////////////////////////////////////////////////////////////////////////
//
//LineCallbackFunction handle
//
void Case_EfspInit__NULL_LineCallBackFunction(const CFaxDevInitParams originalEfspParms)
{
	BEGIN_CASE(TEXT("NULL LineCallBackFunction"))

	CFaxDevInitParams faxDevInitParams = originalEfspParms;
	faxDevInitParams.m_LineCallbackFunction = NULL;

	if (true == g_bHasLineCallbackFunction)
	{
		FaxDevInitializeExWrapper(faxDevInitParams,false);		//should not fail
	}
	else
	{
		FaxDevInitializeExWrapper(faxDevInitParams,true);		//should fail
	}
	ShutdownEfsp_UnloadEfsp();
	::lgEndCase();
}

void Case_EfspInit__VerifyOutParam_LineCallBackFunction(const CFaxDevInitParams originalEfspParms)
{
	BEGIN_CASE(TEXT("Verify EFSP sets LineCallBackFunction out param properly"))

	CFaxDevInitParams faxDevInitParams = originalEfspParms;

	if (false == FaxDevInitializeExWrapper(faxDevInitParams,false))		//should succeed(also call ShutDown)
	{
		goto out;
	}
	FaxDevShutdownWrapper();
	
	//
	//Non Tapi EFSP
	//
	if (true == g_bHasLineCallbackFunction)
	{
		if (NULL == *faxDevInitParams.m_LineCallbackFunction)
		{
			::lgLogError(
				LOG_SEV_1,
				TEXT("\"%s\" EFSP doesn't export a LineCallback function as needed"),
				g_pEFSP->GetImageName()
				);
		}
		else
		{
			::lgLogDetail(
				LOG_PASS,
				5,
				TEXT("LineCallback function found")
				);
		}
	}
	else
	{
		//
		//EFSP doesn't have a LineCallback Function
		//
		if (NULL == *faxDevInitParams.m_LineCallbackFunction)
		{
			::lgLogDetail(
				LOG_PASS,
				5,
				TEXT("LineCallback not found")
				);
		}
		else
		{
			::lgLogError(
				LOG_SEV_1,
				TEXT("\"%s\" EFSP shouldn't export a LineCallback function"),
				g_pEFSP->GetImageName()
				);
		}
	}
out:
	ShutdownEfsp_UnloadEfsp();
	::lgEndCase();
}

void Case_EfspInit_LineCallBackFunction(const CFaxDevInitParams originalEfspParms)
{
	lgLogDetail(
		LOG_X,
		2,
		TEXT("\n\n\n*************************************************************************\n***************************** LineCallBackFunction param ********************************")
		);

	Case_EfspInit__NULL_LineCallBackFunction(originalEfspParms);
	Case_EfspInit__VerifyOutParam_LineCallBackFunction(originalEfspParms);
}

///////////////////////////////////////////////////////////////////////////////
//
//FaxServiceCallbackFunction param
//
void Case_EfspInit__NULL_ServiceCallbackFunction(const CFaxDevInitParams originalEfspParms)
{
	BEGIN_CASE(TEXT("NULL ServiceCallbackFunction"))

	CFaxDevInitParams faxDevInitParams = originalEfspParms;
	faxDevInitParams.m_FaxServiceCallbackEx = NULL;
	
	FaxDevInitializeExWrapper(faxDevInitParams,true);		//should fail
	ShutdownEfsp_UnloadEfsp();

	::lgEndCase();
}

void Case_EfspInit_ServiceCallbackFunction(const CFaxDevInitParams originalEfspParms)
{
	lgLogDetail(
		LOG_X,
		2,
		TEXT("\n\n\n*************************************************************************\n***************************** ServiceCallbackFunction param ********************************")
		);

	Case_EfspInit__NULL_ServiceCallbackFunction(originalEfspParms);
}


///////////////////////////////////////////////////////////////////////////////
//
//MessageIdSize param
//
void Case_EfspInit__NULL_MessageIdSize(const CFaxDevInitParams originalEfspParms)
{
	BEGIN_CASE(TEXT("NULL MessageIdSize"))
	
	CFaxDevInitParams faxDevInitParams= originalEfspParms;
	faxDevInitParams.m_lpdwMaxMessageIdSize = NULL;
	
	FaxDevInitializeExWrapper(faxDevInitParams,true);		//should fail
	ShutdownEfsp_UnloadEfsp();

	::lgEndCase();
}

void Case_EfspInit__VerifyOutParam_MessageIdSize(const CFaxDevInitParams originalEfspParms)
{
	BEGIN_CASE(TEXT("Verify EFSP sets MessageIdSize out param properly"))
	
	CFaxDevInitParams faxDevInitParams= originalEfspParms;
	
	if (false == FaxDevInitializeExWrapper(faxDevInitParams,false))		//should succeed (also call Shutdown)
	{
		goto out;
	}
	if (NULL != g_pEFSP->FaxDevReestablishJobContext)
	{
		//
		//EFSP exports FaxDevReestablishJobContext(), verify m_lpdwMaxMessageIdSize is non Zero
		//
		if (0 == *faxDevInitParams.m_lpdwMaxMessageIdSize)
		{
			::lgLogError(
				LOG_SEV_1,
				TEXT("EFSP(%s) exports FaxDevReestablishJobContext() but reports a zero m_lpdwMaxMessageIdSize"),
				g_pEFSP->GetImageName()
				);
		}
		else
		{
			::lgLogDetail(
				LOG_PASS,
				2,
				TEXT("EFSP(%s) exports FaxDevReestablishJobContext() and reports m_lpdwMaxMessageIdSize=%d"),
				g_pEFSP->GetImageName(),
				*faxDevInitParams.m_lpdwMaxMessageIdSize
				);
		}
	}
	else
	{
		//
		//EFSP doesn't export FaxDevReestablishJobContext()
		//This means that the EFSP should set m_lpdwMaxMessageIdSize to Zero
		//
		if (0 == *faxDevInitParams.m_lpdwMaxMessageIdSize)
		{
			::lgLogDetail(
				LOG_PASS,
				2,
				TEXT("EFSP(%s) doesn't export FaxDevReestablishJobContext() and reports m_lpdwMaxMessageIdSize=0"),
				g_pEFSP->GetImageName()
				);
		}
		else
		{
			::lgLogError(
				LOG_SEV_1,
				TEXT("EFSP(%s) exports FaxDevReestablishJobContext() but reports m_lpdwMaxMessageIdSize=%d"),
				g_pEFSP->GetImageName(),
				*faxDevInitParams.m_lpdwMaxMessageIdSize
				);
		}
	}
out:
	ShutdownEfsp_UnloadEfsp();
	::lgEndCase();
}

void Case_EfspInit_MessageIdSize(const CFaxDevInitParams originalEfspParms)
{
	lgLogDetail(
		LOG_X,
		2,
		TEXT("\n\n\n*************************************************************************\n***************************** MessageIdSize param ********************************")
		);

	Case_EfspInit__NULL_MessageIdSize(originalEfspParms);
	Case_EfspInit__VerifyOutParam_MessageIdSize(originalEfspParms);
}

/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
//FaxDevEnumerateDevices cases
void Case_EfspEnum_DeviceInfo();
void Case_EfspEnum_DeviceCount();
void Case_EfspEnum_InvokeBeforeInit();
void Case_EfspEnum_InvokeAfterShutdown();

void Suite_FaxDevEnumerateDevices()
{
	lgBeginSuite(TEXT("FaxDevEnumerateDevices Init"));
	
	Case_EfspEnum_DeviceCount();
	Case_EfspEnum_DeviceInfo();
	
	::lgEndSuite();
}

void Case_EfspEnum_InvokeBeforeInit()
{
	BEGIN_CASE(TEXT("Invoke FaxDevEnumerateDevices() before invoking FaxDevInitEx()"))
	
	DWORD dwDeviceCount = 0;
	HRESULT hr = g_pEFSP->FaxDevEnumerateDevices(g_pEFSP->m_dwDeviceBaseId,&dwDeviceCount,NULL);
	if (FSPI_E_FAILED == hr)
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("FaxDevEnumerateDevices() failed with FSPI_E_FAILED as expected")
			);
	}
	else
	{
		if (FSPI_S_OK == hr)
		{
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FaxDevEnumerateDevices() succeeded and it should fail")
				);
		}
		else
		{
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FaxDevEnumerateDevices() didn't fail with FSPI_E_FAILED, but with an unexpected error 0x%08x"),
				hr
				);
		}
	}
	::lgEndCase();
}

void Case_EfspEnum_InvokeAfterShutdown()
{
	BEGIN_CASE(TEXT("Invoke FaxDevEnumerateDevices() after invoking FaxDevShutdown()"))
		
	DWORD dwDeviceCount = 0;
	HRESULT hr = g_pEFSP->FaxDevEnumerateDevices(g_pEFSP->m_dwDeviceBaseId,&dwDeviceCount,NULL);
	if (FSPI_E_FAILED == hr)
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("FaxDevEnumerateDevices() failed with FSPI_E_FAILED as expected")
			);
	}
	else
	{
		if (FSPI_S_OK == hr)
		{
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FaxDevEnumerateDevices() succeeded and it should fail")
				);
		}
		else
		{
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FaxDevEnumerateDevices() didn't fail with FSPI_E_FAILED, but with an unexpected error 0x%08x"),
				hr
				);
		}
	}
	::lgEndCase();
}

///////////////////////////////////////////////////////////////////////////////
//
//DeviceCount param
//
void Case_EfspEnum_NULL_DeviceCount()
{
	BEGIN_CASE(TEXT("NULL DeviceCount"))
	
	HRESULT hr=S_OK;
			
	hr = g_pEFSP->FaxDevEnumerateDevices(g_pEFSP->m_dwDeviceBaseId,NULL,NULL);
	if (FSPI_S_OK == hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FaxDevEnumerateDevices() should fail if DeviceCount is NULL")
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("FaxDevEnumerateDevices() failed as expected with error:0x%08x"),
			hr
			);
	}
	::lgEndCase();
}

void Case_EfspEnum_Zero_DeviceCount()
{
	BEGIN_CASE(TEXT("Verify number of devices is > 0"))
	
	HRESULT hr = S_OK;
	DWORD dwDeviceCount = 0;
	
	hr = g_pEFSP->FaxDevEnumerateDevices(g_pEFSP->m_dwDeviceBaseId,&dwDeviceCount,NULL);
	if (FSPI_S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FaxDevEnumerateDevices failed with error 0x%08x"),
			hr
			);
		goto out;
	}

	//
	//Enumeration succeeded, Buffer is NULL, so EFSP should return in dwDeviceCount the number of supported devices
	//
	if (0 == dwDeviceCount)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FaxDevEnumerateDevices() should return the number of devices")
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("FaxDevEnumerateDevices() returned %d devices"),
			dwDeviceCount
			);
	}
out:
	::lgEndCase();
}

void Case_EfspEnum_DeviceCount()
{
	lgLogDetail(
		LOG_X,
		2,
		TEXT("\n\n\n*************************************************************************\n***************************** DeviceCount param ********************************")
		);

	Case_EfspEnum_NULL_DeviceCount();
	Case_EfspEnum_Zero_DeviceCount();
}

///////////////////////////////////////////////////////////////////////////////
//
//DeviceInfo param
//

void Case_EfspEnum__NULL_DeviceInfo()
{
	BEGIN_CASE(TEXT("NULL DeviceInfo structure"))
	
	DWORD dwDeviceCount = 0;
	LPFSPI_DEVICE_INFO  lpVirtualDevices = NULL;		// The array of virtual device information that the EFSP will fill.
	HRESULT hr = S_OK;

	
	//
	//First enumerate the number of devices
	//
	hr = g_pEFSP->FaxDevEnumerateDevices(g_pEFSP->m_dwDeviceBaseId,&dwDeviceCount,NULL);
	if (FSPI_S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FaxDevEnumerateDevices failed with error 0x%08x"),
			hr
			);
	}
	else
	{
		if (0 == dwDeviceCount)
		{
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FaxDevEnumerateDevices() didn't return the number of supported devices")
				);
		}
		else
		{
			::lgLogDetail(
				LOG_PASS, 
				2,
				TEXT("%s EFSP has %d devices"),
				g_pEFSP->GetImageName(),
				dwDeviceCount
				);
		}
	}
	::lgEndCase();
}

void Case_EfspEnum__VerifyOutParam_DeviceInfo()
{
	BEGIN_CASE(TEXT("Verify EFSP sets DeviceInfo out param properly"))

	DWORD dwDeviceCount = 0;
	LPFSPI_DEVICE_INFO  lpVirtualDevices = NULL;		// The array of virtual device information that the EFSP will fill.
	DWORD i=0;
	HRESULT hr = S_OK;
	
	//
	//First enumerate the number of devices
	//
	hr = g_pEFSP->FaxDevEnumerateDevices(g_pEFSP->m_dwDeviceBaseId,&dwDeviceCount,NULL);
	if (FSPI_S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FaxDevEnumerateDevices failed with error 0x%08x"),
			hr
			);
		goto out;
	}

	//
    // Allocate the device array according to the number of devices
    //
    lpVirtualDevices = (LPFSPI_DEVICE_INFO) malloc(dwDeviceCount * sizeof(FSPI_DEVICE_INFO));
    if (!lpVirtualDevices)
    {
        ::lgLogError(
			LOG_SEV_1, 
			TEXT("Failed to allocate virtual device info array for %ld devices. (ec: %ld)"),
			dwDeviceCount,
            GetLastError()
			);
	}

	//
	//Get the device specific info
	//
	hr = g_pEFSP->FaxDevEnumerateDevices(g_pEFSP->m_dwDeviceBaseId,&dwDeviceCount, lpVirtualDevices);
	if (FSPI_S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FaxDevEnumerateDevices failed with error 0x%08x"),
			hr
			);
	}

	for (i=0; i < dwDeviceCount;i++)
	{
		
		//
		//EFSP must provide Device Friendly name
		//
		if (NULL == lpVirtualDevices[i].szFriendlyName)
		{
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FaxDevEnumerateDevices() didn't supply a friendly name")
				);
		}
		else
		{
			lgLogDetail(
				LOG_PASS,
				2,
				TEXT("FaxDevEnumerateDevices() DeviceID(%d) has a proper friendly name \"%s\""),
				lpVirtualDevices[i].dwId,
				lpVirtualDevices[i].szFriendlyName
				);
		}


		//
		//verify dwSizeOfStruct == sizeof(FSPI_DEVICE_INFO)
		//
		if (sizeof(FSPI_DEVICE_INFO) != lpVirtualDevices[i].dwSizeOfStruct)
		{
			::lgLogError(
				LOG_SEV_1, 
				TEXT("dwSizeOfStruct must be sizeof(FSPI_DEVICE_INFO)")
				);
		}
		else
		{
			lgLogDetail(
				LOG_PASS,
				2,
				TEXT("FaxDevEnumerateDevices() deviceID(%d) has a proper dwSizeOfStruct (==FSPI_DEVICE_INFO)"),
				lpVirtualDevices[i].dwId
				);
		}
	}
out:
	free(lpVirtualDevices);
	::lgEndCase();
}


void Case_EfspEnum_DeviceInfo()
{
	::lgLogDetail(
		LOG_X,
		2,
		TEXT("\n\n\n*************************************************************************\n***************************** DeviceInfo param ********************************")
		);
	
	Case_EfspEnum__NULL_DeviceInfo();
	Case_EfspEnum__VerifyOutParam_DeviceInfo();
}






/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
//FaxDevReportStatusEx cases

void Case_ReportStatus_hJob();
void Case_ReportStatus_JobStatusStructure();
void Case_ReportStatus_StatusSize();
void Case_ReportStatus_RequiredStatusSize();


void Suite_FaxDevReportStatusEx()
{
	lgBeginSuite(TEXT("FaxDevReportStatusEx() Function"));
	
	g_pReceivingLineInfo->SafeDisableReceive();
	
	//
	//FaxDevReportStatusEx() requires a job handle, so create a valid job handle for the tests
	//we don't enable the receiving device, so we'll get a no answer on the sending side
	//
	HRESULT hr = SafeCreateValidSendingJob(g_pSendingLineInfo,g_szValidRecipientFaxNumber);
	if (FSPI_S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("CreateValidSendingJob() failed with error:0x%08x"),
			hr
			);
		goto out;
	}
	assert(g_pSendingLineInfo->GetJobHandle());
		
	Case_ReportStatus_hJob();
	Case_ReportStatus_JobStatusStructure();
	Case_ReportStatus_StatusSize();
	Case_ReportStatus_RequiredStatusSize();

	//
	//Terminate the sending job and enable the receive
	//
	g_pSendingLineInfo->SafeEndFaxJob();
	g_pReceivingLineInfo->SafeEnableReceive();
	
out:
	::lgEndSuite();
}

//////////////////////////////////////////////////////////////////
//
//hJob parameter
//
void Case_ReportStatus_NULL_hJob()
{
	BEGIN_CASE(TEXT("NULL hJob handle"))
	
	HRESULT hr = S_OK;
	HANDLE hJob	=	NULL;
	DWORD dwRequiredStatusSize = 0;
	DWORD dwStatusSize = sizeof(FSPI_JOB_STATUS) + FAXDEVREPORTSTATUS_SIZE;
 	LPFSPI_JOB_STATUS pFaxStatus = (LPFSPI_JOB_STATUS) malloc(dwStatusSize);
	if (!pFaxStatus)
	{
		lgLogError(
			LOG_SEV_1,
			TEXT("Case_ReportStatus_NULL_hJob(): malloc failed")
			);
		goto out;
	}

	pFaxStatus->dwSizeOfStruct = sizeof(FSPI_JOB_STATUS);
	

	hr = g_pEFSP->FaxDevReportStatusEx(
		hJob,
		pFaxStatus,
		dwStatusSize,
		&dwRequiredStatusSize
		);


	if (FSPI_S_OK == hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FaxDevReportStatusEx() returned FSPI_S_OK and should fail with FSPI_E_INVALID_JOB_HANDLE")
			);
	}
	else
	{
		if (FSPI_E_INVALID_JOB_HANDLE != hr)
		{
			if (FSPI_S_OK == hr)
			{
				::lgLogError(
					LOG_SEV_1, 
					TEXT("FaxDevReportStatusEx() succeeded and it should fail with FSPI_E_INVALID_JOB_HANDLE")
					);
			}
			else
			{
				::lgLogError(
					LOG_SEV_1, 
					TEXT("FaxDevReportStatusEx() should return FSPI_E_INVALID_JOB_HANDLE, and not 0x%08x"),
					hr
					);
			}
		}
		else
		{
			::lgLogDetail(
				LOG_PASS,
				2,
				TEXT("FaxDevReportStatusEx() failed as expected with error:FSPI_E_INVALID_JOB_HANDLE")
				);
		}
	}
out:
	free(pFaxStatus);
	::lgEndCase();
}

void Case_ReportStatus_Incorrect_hJob()
{
	BEGIN_CASE(TEXT("Incorrect hJob handle"))
	
	HANDLE hJob	= NULL;
	HRESULT hr = S_OK;
	DWORD dwStatusSize = sizeof(FSPI_JOB_STATUS) + FAXDEVREPORTSTATUS_SIZE;
 	LPFSPI_JOB_STATUS pFaxStatus = NULL;
	DWORD dwRequiredStatusSize = 0;

	hJob = g_pSendingLineInfo->GetJobHandle();
		
	//
	//hJob is now a valid Job handle, let's change it a bit
	//We take a guess and go for 7
	//
	if ((HANDLE)0x7 != hJob)
	{
		hJob = (HANDLE) 0x7;
	}
	else
	{
		hJob = (HANDLE) 0x8;
	}

	//
	//Notice that hJob now holds an invalid hJob handle
	//
	pFaxStatus = (LPFSPI_JOB_STATUS) malloc(dwStatusSize);
	if (!pFaxStatus)
	{
		lgLogError(
			LOG_SEV_1,
			TEXT("Case_ReportStatus_Incorrect_hJob(): malloc failed")
			);
		goto out;
	}

	pFaxStatus->dwSizeOfStruct = sizeof(FSPI_JOB_STATUS);
	

	hr = g_pEFSP->FaxDevReportStatusEx(
		hJob,
		pFaxStatus,
		dwStatusSize,
		&dwRequiredStatusSize
		);


	if (FSPI_S_OK == hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FaxDevReportStatusEx() returned FSPI_S_OK and should fail with FSPI_E_INVALID_JOB_HANDLE")
			);
	}
	else
	{
		if (FSPI_E_INVALID_JOB_HANDLE != hr)
		{
			if (FSPI_S_OK == hr)
			{
				::lgLogError(
					LOG_SEV_1, 
					TEXT("FaxDevReportStatusEx() succeeded and it should fail")
					);
			}
			else
			{
				::lgLogError(
					LOG_SEV_1, 
					TEXT("FaxDevReportStatusEx() should return FSPI_E_INVALID_JOB_HANDLE, and not 0x%08x"),
					hr
					);
			}
		}
		else
		{
			::lgLogDetail(
				LOG_PASS,
				2,
				TEXT("FaxDevReportStatusEx() failed as expected with error:FSPI_E_INVALID_JOB_HANDLE")
				);
		}
	}
out:
	free(pFaxStatus);
	::lgEndCase();
}

void Case_ReportStatus_hJob()
{
	lgLogDetail(
		LOG_X,
		2,
		TEXT("\n\n\n*************************************************************************\n***************************** hJob param ********************************")
		);

	Case_ReportStatus_NULL_hJob();
	Case_ReportStatus_Incorrect_hJob();
}




//////////////////////////////////////////////////////////////////
//
//JobStatusStructure parameter
//
void Case_ReportStatus_NULL_JobStatusStructure()
{
	BEGIN_CASE(TEXT("NULL JobStatusStructure"))

	HANDLE hJob	= NULL;
	DWORD dwStatusSize = 0;
 	LPFSPI_JOB_STATUS pFaxStatus = (LPFSPI_JOB_STATUS) NULL;
	
	DWORD dwRequiredStatusSize = 0;
	HRESULT hr = S_OK;

	
	hJob = g_pSendingLineInfo->GetJobHandle();



	hr = g_pEFSP->FaxDevReportStatusEx(
		hJob,
		pFaxStatus,
		dwStatusSize,
		&dwRequiredStatusSize
		);


	if (FSPI_S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FaxDevReportStatusEx() failed with error:0x%08x"),
			hr
			);
	}
	else
	{
		//
		//FaxDevReportStatusEx() should fill in the required size
		//
		if (0 == dwRequiredStatusSize)
		{
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FaxDevReportStatusEx() should report the Required StatusSize")
				);
		}
		else
		{
			::lgLogDetail(
				LOG_PASS,
				5,
				TEXT("FaxDevReportStatusEx() reported a needed size of: %d"),
				dwRequiredStatusSize
				);
		}
	}
	::lgEndCase();
}



void Case_ReportStatus_JobStatusStructure()
{
	lgLogDetail(
		LOG_X,
		2,
		TEXT("\n\n\n*************************************************************************\n***************************** JobStatusStructure param ********************************")
		);

	Case_ReportStatus_NULL_JobStatusStructure();
}



//////////////////////////////////////////////////////////////////
//
//StatusSize parameter
//

void Case_ReportStatus_Zero_dwStatusSize()
{
	BEGIN_CASE(TEXT("size of dwStatusSize is Zero"));

	HANDLE hJob	= NULL;
	HRESULT hr = S_OK;
	DWORD dwStatusSize = sizeof(FSPI_JOB_STATUS) + FAXDEVREPORTSTATUS_SIZE;
 	LPFSPI_JOB_STATUS pFaxStatus = NULL;
	DWORD dwRequiredStatusSize = 0;

	hJob = g_pSendingLineInfo->GetJobHandle();
	
	pFaxStatus = (LPFSPI_JOB_STATUS) malloc(dwStatusSize);
	if (!pFaxStatus)
	{
		lgLogError(
			LOG_SEV_1,
			TEXT("Case_ReportStatus_NULL_hJob(): malloc failed")
			);
		goto out;
	}

	pFaxStatus->dwSizeOfStruct = sizeof(FSPI_JOB_STATUS);

	hr = g_pEFSP->FaxDevReportStatusEx(
		hJob,
		pFaxStatus,
		dwStatusSize,
		&dwRequiredStatusSize
		);


	if (FSPI_E_BUFFER_OVERFLOW != hr)
	{
		if (FSPI_S_OK == hr)
		{
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FaxDevReportStatusEx() succeeded and it should fail")
				);
		}
		else
		{
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FaxDevReportStatusEx() should return FSPI_E_BUFFER_OVERFLOW, and not 0x%08x"),
				hr
				);
		}
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("FaxDevReportStatusEx() failed as expected with error:FSPI_E_BUFFER_OVERFLOW")
			);
	}
out:
	free(pFaxStatus);
	::lgEndCase();
}

void Case_ReportStatus_ToSmall_dwStatusSize()
{
	BEGIN_CASE(TEXT("size of dwStatusSize is small"));

	HANDLE hJob	= NULL;
	HRESULT hr = S_OK;
	DWORD dwStatusSize = sizeof(FSPI_JOB_STATUS) + FAXDEVREPORTSTATUS_SIZE;
 	LPFSPI_JOB_STATUS pFaxStatus = NULL;
	DWORD dwRequiredStatusSize = 0;


	
	hJob = g_pSendingLineInfo->GetJobHandle();

	//
	//This is a smaller buffer then the EFSP needs (missing FAXDEVREPORTSTATUS_SIZE)
	//
	dwStatusSize = sizeof(FSPI_JOB_STATUS) + FAXDEVREPORTSTATUS_SIZE;
 	pFaxStatus = (LPFSPI_JOB_STATUS) malloc(dwStatusSize);
	if (!pFaxStatus)
	{
		lgLogError(
			LOG_SEV_1,
			TEXT("Case_ReportStatus_NULL_hJob(): malloc failed")
			);
		goto out;
	}

	pFaxStatus->dwSizeOfStruct = sizeof(FSPI_JOB_STATUS);
	dwRequiredStatusSize = 0;

	hr = g_pEFSP->FaxDevReportStatusEx(
		hJob,
		pFaxStatus,
		dwStatusSize,
		&dwRequiredStatusSize
		);


	if (FSPI_E_BUFFER_OVERFLOW != hr)
	{
		if (FSPI_S_OK == hr)
		{
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FaxDevReportStatusEx() succeeded and it should fail")
				);
		}
		else
		{
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FaxDevReportStatusEx() should return FSPI_E_BUFFER_OVERFLOW, and not 0x%08x"),
				hr
				);
		}
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("FaxDevReportStatusEx() failed as expected with error:FSPI_E_BUFFER_OVERFLOW")
			);
	}
out:
	free(pFaxStatus);
	::lgEndCase();
}


void Case_ReportStatus_StatusSize()
{
	lgLogDetail(
		LOG_X,
		2,
		TEXT("\n\n\n*************************************************************************\n***************************** StatusSize param ********************************")
		);

	Case_ReportStatus_Zero_dwStatusSize();
	Case_ReportStatus_ToSmall_dwStatusSize();
}

//////////////////////////////////////////////////////////////////
//
//RequiredStatusSize parameter
//


void Case_ReportStatus_NULL_RequiredStatusSize()
{
	BEGIN_CASE(TEXT("dwRequiredSize is a NULL Param"));

	HANDLE hJob	= NULL;
	HRESULT hr = S_OK;
	DWORD dwStatusSize = sizeof(FSPI_JOB_STATUS) + FAXDEVREPORTSTATUS_SIZE;
 	LPFSPI_JOB_STATUS pFaxStatus = NULL;
	DWORD dwRequiredStatusSize = 0;

	hJob = g_pSendingLineInfo->GetJobHandle();


	//
	//We have 2 cases here:
	//1. We provide a smaller buffer than the EFSP needs
	//2. We don't provide a buffer at all (we query for the needed buffer size)
	//
	
	
	//
	//This buffer is missing FAXDEVREPORTSTATUS_SIZE
	//
	dwStatusSize = sizeof(FSPI_JOB_STATUS) + FAXDEVREPORTSTATUS_SIZE;
 	pFaxStatus = (LPFSPI_JOB_STATUS) malloc(dwStatusSize);
	if (!pFaxStatus)
	{
		lgLogError(
			LOG_SEV_1,
			TEXT("Case_ReportStatus_NULL_hJob(): malloc failed")
			);
		goto out;;
	}

	pFaxStatus->dwSizeOfStruct = sizeof(FSPI_JOB_STATUS);

	hr = g_pEFSP->FaxDevReportStatusEx(
		hJob,
		pFaxStatus,
		dwStatusSize,
		NULL
		);


	if ( (FSPI_E_BUFFER_OVERFLOW != hr) && (FSPI_E_FAILED != hr) ) 
	{
		if (FSPI_S_OK == hr)
		{
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FaxDevReportStatusEx() succeeded and it should fail with FSPI_E_BUFFER_OVERFLOW or FSPI_E_FAILED")
				);
		}
		else
		{
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FaxDevReportStatusEx() should return FSPI_E_BUFFER_OVERFLOW or FSPI_E_FAILED, and not 0x%08x"),
				hr
				);
		}
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("FaxDevReportStatusEx() failed as expected")
			);
	}

	//
	//test case 2
	//
	hr = g_pEFSP->FaxDevReportStatusEx(
		hJob,
		NULL,
		0,
		NULL
		);


	if ( (FSPI_E_BUFFER_OVERFLOW != hr) && (FSPI_E_FAILED != hr) )
	{
		if (FSPI_S_OK == hr)
		{
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FaxDevReportStatusEx() succeeded and it should fail with FSPI_E_BUFFER_OVERFLOW or FSPI_E_FAILED")
				);
		}
		else
		{
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FaxDevReportStatusEx() should return FSPI_E_BUFFER_OVERFLOW or FSPI_E_FAILED, and not 0x%08x"),
				hr
				);
		}
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("FaxDevReportStatusEx() failed as expected")
			);
	}

out:
	free(pFaxStatus);
	::lgEndCase();
}

void Case_ReportStatus_RequiredStatusSize()
{
	lgLogDetail(
		LOG_X,
		2,
		TEXT("\n\n\n*************************************************************************\n***************************** RequiredStatusSize param ********************************")
		);

	Case_ReportStatus_NULL_RequiredStatusSize();
}



/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
//FaxDevSendEx cases

void Case_SendEx_hLine();
void Case_SendEx_dwDeviceID();
void Case_SendEx_BodyFileName();
void Case_SendEx_CoverpageInfo();
void Case_SendEx_TimeToSend(bool bIsSchedulingEFSP);
void Case_SendEx_SenderProfile();
void Case_SendEx_dwNumberOfRecipients();
void Case_SendEx_RecipientProfileArray();
void Case_SendEx_RecipientMessageIdArray(bool bIsReestablishEFSP);
void Case_SendEx_RecipientJobHandleArray();
void Case_SendEx_ParentMessageId(bool bIsReestablishEFSP);
void Case_SendEx_ParentJobHandle();


void Suite_FaxDevSendEx()
{
	lgBeginSuite(TEXT("FaxDevSendEx() Function"));
	
	
	//
	//Does  this device support job reestablishment?
	//
	bool bIsReestablishEFSP = g_pEFSP->IsReestablishEFSP();

	//
	//Does this EFSP support scheduling?
	//
	bool bIsSchedulingEFSP = g_pEFSP->IsSchedulingEFSP();
	
	//
	//we don't enable the receiving device, so we'll get a no answer on the sending side
	//
	g_pReceivingLineInfo->SafeDisableReceive();
	
	//
	//All the following test cases, create a sending job abort it and end the job
	//
	Case_SendEx_hLine();
	Case_SendEx_dwDeviceID();
	Case_SendEx_BodyFileName();
	Case_SendEx_CoverpageInfo();
	Case_SendEx_TimeToSend(bIsSchedulingEFSP);
	Case_SendEx_SenderProfile();
	Case_SendEx_dwNumberOfRecipients();
	Case_SendEx_RecipientProfileArray();
	Case_SendEx_RecipientMessageIdArray(bIsReestablishEFSP);
	Case_SendEx_RecipientJobHandleArray();
	Case_SendEx_ParentMessageId(bIsReestablishEFSP);
	Case_SendEx_ParentJobHandle();

	g_pReceivingLineInfo->SafeEnableReceive();	
	::lgEndSuite();
}

//////////////////////////////////////////////////////////////////
//
//hLine parameter
//

void Case_SendEx_hLine()
{
	lgLogDetail(
		LOG_X,
		2,
		TEXT("\n\n\n*************************************************************************\n***************************** hLine param ********************************")
		);
	::lgLogDetail(
		LOG_X, 
		3,
		TEXT("Non Tapi EFSP, no test cases")
		);


}

//////////////////////////////////////////////////////////////////
//
//dwDeviceID parameter
//

void Case_SendEx_Invalid_dwDeviceID()
{
	BEGIN_CASE(TEXT("dwDeviceID is an invalid device ID"));
	
	HRESULT hr = SendDefaultFaxUsingDeviceID(g_dwInvalidDeviceId);
	if (FSPI_S_OK == hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FaxDevSendEx() didn't fail to send with an invalid device ID")
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("FaxDevSendEx failed as expected with error:0x%08x"),
			hr
			);
	}
	::lgEndCase();
}

void Case_SendEx_dwDeviceID()
{
	lgLogDetail(
		LOG_X,
		2,
		TEXT("\n\n\n*************************************************************************\n***************************** dwDeviceID param ********************************")
		);

	Case_SendEx_Invalid_dwDeviceID();
}

//////////////////////////////////////////////////////////////////
//
//BodyFileName parameter
//

void Case_SendEx_Readonly_BodyFileName()
{
	BEGIN_CASE(TEXT("Body Tiff file is a readonly file"));
	
	HRESULT hr = SendDefaultFaxWithBodyFile(g_szValid_ReadOnly_TiffFileName);
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevSendEx() failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("FaxDevSendEx succeeded")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_FileNotFound_BodyFileName()
{
	BEGIN_CASE(TEXT("Body Tiff file is not found"));
	
	HRESULT hr = SendDefaultFaxWithBodyFile(g_szValid_FileNotFound_TiffFileName);
	if (FSPI_S_OK == hr)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevSendEx() didn't fail in sending an invalid tiff file(file not found)")
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("FaxDevSendEx failed as expected with error code:0x%08x"),
			hr
			);
	}
	
	::lgEndCase();
}


void Case_SendEx_UNC_PATH_BodyFileName()
{
	BEGIN_CASE(TEXT("Body Tiff file has a UNC path"));
	
	HRESULT hr = SendDefaultFaxWithBodyFile(g_szValid_UNC_TiffFileName);
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevSendEx() failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("FaxDevSendEx succeeded")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_NTFS_BodyFileName()
{
	BEGIN_CASE(TEXT("Body Tiff file is on a NTFS system"));
	
	HRESULT hr = SendDefaultFaxWithBodyFile(g_szValid_NTFS_TiffFileName);
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevSendEx() failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("FaxDevSendEx succeeded")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_FAT_BodyFileName()
{
	BEGIN_CASE(TEXT("Body Tiff file is on a FAT system"));
	
	HRESULT hr = SendDefaultFaxWithBodyFile(g_szValid_FAT_TiffFileName);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevSendEx() failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("FaxDevSendEx succeeded")
			);
	}

	::lgEndCase();
}
void Case_SendEx_LINK_BodyFileName()
{
	BEGIN_CASE(TEXT("Body Tiff file is a link to the file and not the file itself"));
	
	HRESULT hr = SendDefaultFaxWithBodyFile(g_szValid_Link_TiffFileName);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevSendEx() failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("FaxDevSendEx succeeded")
			);
	}
	::lgEndCase();
}

void Case_SendEx_NonTiff_BodyFileName()
{
	BEGIN_CASE(TEXT("Body Tiff file is a not a tiff format"));
	
	HRESULT hr = SendDefaultFaxWithBodyFile(g_szValid_Link_TiffFileName);     //This will also Abort and End the send job
	if (FSPI_S_OK == hr)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevSendEx() succeeded with a non tiff format")
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("FaxDevSendEx failed as expected with error: 0x%08x"),
			hr
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_InvalidTiffFormat_BodyFileName()
{
	BEGIN_CASE(TEXT("Body Tiff file has an invalid tiff format"));
	
	HRESULT hr = SendDefaultFaxWithBodyFile(g_szValid_InvalidTiffFormat_TiffFileName);     //This will also Abort and End the send job
	if (FSPI_S_OK == hr)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevSendEx() succeeded with an invalid tiff format")
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("FaxDevSendEx failed as expected with error: 0x%08x"),
			hr
			);
	}

	::lgEndCase();
}

void Case_SendEx_BodyFileName()
{
	lgLogDetail(
		LOG_X,
		2,
		TEXT("\n\n\n*************************************************************************\n***************************** BodyFileName param ********************************")
		);

	Case_SendEx_Readonly_BodyFileName();
	Case_SendEx_FileNotFound_BodyFileName();
	Case_SendEx_UNC_PATH_BodyFileName();
	Case_SendEx_NTFS_BodyFileName();
	Case_SendEx_FAT_BodyFileName();
	Case_SendEx_LINK_BodyFileName();
	Case_SendEx_NonTiff_BodyFileName();
	Case_SendEx_InvalidTiffFormat_BodyFileName();

	


}


//////////////////////////////////////////////////////////////////
//
//CoverpageInfo parameter
//


void Case_SendEx_Readonly_CoverpageFileName()
{
	BEGIN_CASE(TEXT("Coverpage file is a readonly file"));
	
	HRESULT hr = SendDefaultFaxWithCoverpage(g_szValid_ReadOnly_CoverpageFileName);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevSendEx() failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("FaxDevSendEx succeeded")
			);
	}
	::lgEndCase();
}

void Case_SendEx_FileNotFound_CoverpageFileName()
{
	BEGIN_CASE(TEXT("Coverpage file is not found"));
	
	HRESULT hr = SendDefaultFaxWithCoverpage(g_szValid_FileNotFound_CoverpageFileName);     //This will also Abort and End the send job
	if (FSPI_S_OK == hr)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevSendEx() didn't fail in sending an invalid coverpage file(file not found)")
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("FaxDevSendEx failed as expected with error code:0x%08x"),
			hr
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_UNC_PATH_CoverpageFileName()
{
	BEGIN_CASE(TEXT("Coverpage file has a UNC path"));
	
	HRESULT hr = SendDefaultFaxWithCoverpage(g_szValid_UNC_CoverpageFileName);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevSendEx() failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("FaxDevSendEx succeeded")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_NTFS_CoverpageFileName()
{
	BEGIN_CASE(TEXT("Coverpage file is on a NTFS system"));
	
	HRESULT hr = SendDefaultFaxWithCoverpage(g_szValid_NTFS_CoverpageFileName);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevSendEx() failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("FaxDevSendEx succeeded")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_FAT_CoverpageFileName()
{
	BEGIN_CASE(TEXT("Coverpage file is on a FAT system"));
	
	HRESULT hr = SendDefaultFaxWithCoverpage(g_szValid_FAT_CoverpageFileName);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevSendEx() failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("FaxDevSendEx succeeded")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_LINK_CoverpageFileName()
{
	BEGIN_CASE(TEXT("Coverpage file is a link to the file and not the file itself"));
	
	HRESULT hr = SendDefaultFaxWithCoverpage(g_szValid_Link_CoverpageFileName);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevSendEx() failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("FaxDevSendEx succeeded")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_NonCoverPage_CoverpageFileName()
{
	BEGIN_CASE(TEXT("Coverpage file is a not a coverpage format"));
	
	HRESULT hr = SendDefaultFaxWithCoverpage(g_szValid_NotCoverpageFormat_CoverpageFileName);     //This will also Abort and End the send job
	if (FSPI_S_OK == hr)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevSendEx() succeeded with a non coverpage file")
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("FaxDevSendEx failed as expected with error: 0x%08x"),
			hr
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_InvalidCoverpageFormat_CoverpageFileName()
{
	BEGIN_CASE(TEXT("Coverpage file has an invalid coverpage format"));

	HRESULT hr = SendDefaultFaxWithCoverpage(g_szValid_InvalidCoverpageFormat_CoverpageFileName);     //This will also Abort and End the send job
	if (FSPI_S_OK == hr)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevSendEx() succeeded with an invalid coverpage file format")
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("FaxDevSendEx failed as expected with error: 0x%08x"),
			hr
			);
	}

	::lgEndCase();
}

void Case_SendEx_NULL_CoverpageFileName()
{
	BEGIN_CASE(TEXT("Coverpage file name is a NULL pointer"));

	HRESULT hr = SendDefaultFaxWithCoverpage(NULL);     //This will also Abort and End the send job
	if (FSPI_S_OK == hr)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevSendEx() succeeded to send an NULL pointer file name")
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("FaxDevSendEx failed as expected with error: 0x%08x"),
			hr
			);
	}

	::lgEndCase();
}








void Case_SendEx_Zero_CoverpageFormat()
{
	BEGIN_CASE(TEXT("Coverpage file structure has 0 as the coverpage format"));

	FSPI_COVERPAGE_INFO covEFSPICoverPage;
	PrepareFSPICoverPage(
		&covEFSPICoverPage,
		0,					//coverpage format
		1,					//number of pages
		g_szValidRecipientFaxNumber,
		DEFAULT_COVERPAGE_NOTE,
		DEFAULT_COVERPAGE_SUBJECT
		);
	HRESULT hr = SendDefaultFaxWithCoverpageInfo(&covEFSPICoverPage);     //This will also Abort and End the send job
	if (FSPI_S_OK == hr)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevSendEx() succeeded with 0 as the coverpage format")
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("FaxDevSendEx failed as expected with error: 0x%08x"),
			hr
			);
	}

	::lgEndCase();
}



void Case_SendEx_Invalid_CoverpageFormat()
{
	BEGIN_CASE(TEXT("Coverpage file structure has an invalid coverpage format"));

	FSPI_COVERPAGE_INFO covEFSPICoverPage;
	PrepareFSPICoverPage(
		&covEFSPICoverPage,
		INVALID_COVERPAGE_FORMAT,					//coverpage format
		1,					//number of pages
		g_szValid__CoverpageFileName,
		DEFAULT_COVERPAGE_NOTE,
		DEFAULT_COVERPAGE_SUBJECT
		);
	HRESULT hr = SendDefaultFaxWithCoverpageInfo(&covEFSPICoverPage);     //This will also Abort and End the send job
	if (FSPI_S_OK == hr)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevSendEx() succeeded with 0 as the coverpage format")
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("FaxDevSendEx failed as expected with error: 0x%08x"),
			hr
			);
	}

	::lgEndCase();
}




void Case_SendEx_hasOnePageButIndicatesTwoPage_CoverpageFileName()
{
	BEGIN_CASE(TEXT("Coverpage file has 1 page but indicates 2 in the coverPageInfo structure"));
	//BUGBUG: NIY
	::lgLogDetail(
		LOG_X, 
		3,
		TEXT("Test case NIY")
		);
	::lgEndCase();
}

void Case_SendEx_hasTwoPageButIndicatesOnePage_CoverpageFileName()
{
	BEGIN_CASE(TEXT("Coverpage file has 2 pages but indicates 1 in the coverPageInfo structure"));
	//BUGBUG: NIY
	::lgLogDetail(
		LOG_X, 
		3,
		TEXT("Test case NIY")
		);
	::lgEndCase();
}

void Case_SendEx_NULL_Note_CoverpageFileName()
{
	BEGIN_CASE(TEXT("Coverpage has an NULL note"));
	
	FSPI_COVERPAGE_INFO covEFSPICoverPage;
	PrepareFSPICoverPage(
		&covEFSPICoverPage,
		FSPI_COVER_PAGE_FMT_COV,
		1,
		g_szValid__CoverpageFileName,
		NULL,
		DEFAULT_COVERPAGE_SUBJECT
		);
	HRESULT hr = SendDefaultFaxWithCoverpageInfo(&covEFSPICoverPage);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevSendEx() failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("FaxDevSendEx succeeded")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_EmptyString_Note_CoverpageFileName()
{
	BEGIN_CASE(TEXT("Coverpage has an empty string note"));
	
	FSPI_COVERPAGE_INFO covEFSPICoverPage;
	PrepareFSPICoverPage(
		&covEFSPICoverPage,
		FSPI_COVER_PAGE_FMT_COV,
		1,
		g_szValid__CoverpageFileName,
		TEXT(""),
		DEFAULT_COVERPAGE_SUBJECT
		);
	HRESULT hr = SendDefaultFaxWithCoverpageInfo(&covEFSPICoverPage);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevSendEx() failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("FaxDevSendEx succeeded")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_VeryLongString_Note_CoverpageFileName()
{
	BEGIN_CASE(TEXT("Coverpage has a very long string note"));
	
	FSPI_COVERPAGE_INFO covEFSPICoverPage;
	PrepareFSPICoverPage(
		&covEFSPICoverPage,
		FSPI_COVER_PAGE_FMT_COV,
		1,
		g_szValid__CoverpageFileName,
		DEFAULT_VERYLONG_COVERPAGE_NOTE,
		DEFAULT_COVERPAGE_SUBJECT
		);
	HRESULT hr = SendDefaultFaxWithCoverpageInfo(&covEFSPICoverPage);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevSendEx() failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("FaxDevSendEx succeeded")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_NULL_Subject_CoverpageFileName()
{
	BEGIN_CASE(TEXT("Coverpage has an NULL subject"));
	
	FSPI_COVERPAGE_INFO covEFSPICoverPage;
	PrepareFSPICoverPage(
		&covEFSPICoverPage,
		FSPI_COVER_PAGE_FMT_COV,
		1,
		g_szValid__CoverpageFileName,
		DEFAULT_COVERPAGE_NOTE,
		NULL
		);
	HRESULT hr = SendDefaultFaxWithCoverpageInfo(&covEFSPICoverPage);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevSendEx() failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("FaxDevSendEx succeeded")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_EmptyString_Subject_CoverpageFileName()
{
	BEGIN_CASE(TEXT("Coverpage has an empty string subject"));
	
	FSPI_COVERPAGE_INFO covEFSPICoverPage;
	PrepareFSPICoverPage(
		&covEFSPICoverPage,
		FSPI_COVER_PAGE_FMT_COV,
		1,
		g_szValid__CoverpageFileName,
		DEFAULT_COVERPAGE_NOTE,
		TEXT("")
		);
	HRESULT hr = SendDefaultFaxWithCoverpageInfo(&covEFSPICoverPage);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevSendEx() failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("FaxDevSendEx succeeded")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_VeryLongString_Subject_CoverpageFileName()
{
	BEGIN_CASE(TEXT("Coverpage has a very long string subject"));
	
	FSPI_COVERPAGE_INFO covEFSPICoverPage;
	PrepareFSPICoverPage(
		&covEFSPICoverPage,
		FSPI_COVER_PAGE_FMT_COV,
		1,
		g_szValid__CoverpageFileName,
		DEFAULT_COVERPAGE_NOTE,
		DEFAULT_VERYLONG_COVERPAGE_SUBJECT
		);
	HRESULT hr = SendDefaultFaxWithCoverpageInfo(&covEFSPICoverPage);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevSendEx() failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("FaxDevSendEx succeeded")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_CoverpageInfo()
{
	lgLogDetail(
		LOG_X,
		2,
		TEXT("\n\n\n*************************************************************************\n***************************** CoverpageInfo param ********************************")
		);

	//
	//File manipulations
	//
	Case_SendEx_Readonly_CoverpageFileName();
	Case_SendEx_FileNotFound_CoverpageFileName();
	Case_SendEx_UNC_PATH_CoverpageFileName();
	Case_SendEx_NTFS_CoverpageFileName();
	Case_SendEx_FAT_CoverpageFileName();
	Case_SendEx_LINK_CoverpageFileName();
	Case_SendEx_NonCoverPage_CoverpageFileName();
	Case_SendEx_InvalidCoverpageFormat_CoverpageFileName();
	Case_SendEx_NULL_CoverpageFileName();

	
	//
	//CoverPage format cases
	//
	Case_SendEx_Zero_CoverpageFormat();
	Case_SendEx_Invalid_CoverpageFormat();

	//
	//Number of pages in cover page info
	//
	Case_SendEx_hasOnePageButIndicatesTwoPage_CoverpageFileName();
	Case_SendEx_hasTwoPageButIndicatesOnePage_CoverpageFileName();
	
	//
	//Note
	//
	Case_SendEx_NULL_Note_CoverpageFileName();
	Case_SendEx_EmptyString_Note_CoverpageFileName();
	Case_SendEx_VeryLongString_Note_CoverpageFileName();
	
	//
	//Subject
	//
	Case_SendEx_NULL_Subject_CoverpageFileName();
	Case_SendEx_EmptyString_Subject_CoverpageFileName();
	Case_SendEx_VeryLongString_Subject_CoverpageFileName();
}

//////////////////////////////////////////////////////////////////
//
//TimeToSend parameter
//


void Case_SendEx_ZeroInAllFields_TimeToSend(bool bIsSchedulingEFSP)
{
	BEGIN_CASE(TEXT("Time to send contains 0 in all fields(Now)"))
	
	//
	//prepare the time variable which we want to test
	//
	SYSTEMTIME tmSchedule;
	tmSchedule.wYear=0;
	tmSchedule.wMonth=0;
	tmSchedule.wDayOfWeek=0;
	tmSchedule.wDay=0;
	tmSchedule.wHour=0;
	tmSchedule.wMinute=0;
	tmSchedule.wSecond=0;

	HRESULT hr = SendDefaultFaxWithSystemTime(tmSchedule);     //This will also Abort and End the send job
	if (bIsSchedulingEFSP)
	{
		//
		//This is a queuing EFSP and the fax should be sent at a specific time
		//
		if (S_OK != hr)
		{
			::lgLogError(
				LOG_SEV_1,
				TEXT("FaxDevSendEx() failed with error: 0x%08x"),
				hr
				);
		}
		else
		{
			::lgLogDetail(
				LOG_PASS,
				2,
				TEXT("FaxDevSendEx succeeded")
				);
			//BUGBUG: Verify fax is sent now.
		}
	}
	else
	{
		//
		//Non queuing EFSP, fax should be sent now (ASAP)
		//
		if (S_OK != hr)
		{
			::lgLogError(
				LOG_SEV_1,
				TEXT("FaxDevSendEx() failed with error: 0x%08x"),
				hr
				);
		}
		else
		{
			::lgLogDetail(
				LOG_PASS,
				2,
				TEXT("FaxDevSendEx succeeded")
				);
			//BUGBUG: Verify fax is sent now.


		}
	}
	
	::lgEndCase();
}

void Case_SendEx_Now_TimeToSend(bool bIsSchedulingEFSP)
{
	BEGIN_CASE(TEXT("Time to send is now(After 10 seconds)"));
	
	//
	//prepare the time variable which we want to test
	//
	SYSTEMTIME tmSchedule;
	GetSystemTime(&tmSchedule);
	
	HRESULT hr = SendDefaultFaxWithSystemTime(tmSchedule);     //This will also Abort and End the send job
	if (bIsSchedulingEFSP)
	{
		//
		//This is a queuing EFSP and the fax should be sent at a specific time
		//
		if (S_OK != hr)
		{
			::lgLogError(
				LOG_SEV_1,
				TEXT("FaxDevSendEx() failed with error: 0x%08x"),
				hr
				);
		}
		else
		{
			::lgLogDetail(
				LOG_PASS,
				2,
				TEXT("FaxDevSendEx succeeded")
				);
			//BUGBUG: Verify fax is sent now.

		}
	}
	else
	{
		//
		//Non queuing EFSP, fax should be sent now (ASAP)
		//
		if (S_OK != hr)
		{
			::lgLogError(
				LOG_SEV_1,
				TEXT("FaxDevSendEx() failed with error: 0x%08x"),
				hr
				);
		}
		else
		{
			::lgLogDetail(
				LOG_PASS,
				2,
				TEXT("FaxDevSendEx succeeded")
				);
			//BUGBUG: Verify fax is sent now.

		}
	}
	
	::lgEndCase();
}

void Case_SendEx_NearFuture_TimeToSend(bool bIsSchedulingEFSP)
{
	BEGIN_CASE(TEXT("Time to send is in the near future(after 5 minutes)"));
	//BUGBUG: NIY
	::lgLogDetail(
		LOG_X, 
		3,
		TEXT("Test case NIY")
		);
	::lgEndCase();
}

void Case_SendEx_FarAwayFuture_TimeToSend(bool bIsSchedulingEFSP)
{
	BEGIN_CASE(TEXT("Time to send is in a far away time(after 5 days)"));
	//BUGBUG: NIY
	::lgLogDetail(
		LOG_X, 
		3,
		TEXT("Test case NIY")
		);
	::lgEndCase();
}

void Case_SendEx_Past_TimeToSend(bool bIsSchedulingEFSP)
{
	BEGIN_CASE(TEXT("Time to send occurred in the past"));
		//BUGBUG: NIY
	::lgLogDetail(
		LOG_X, 
		3,
		TEXT("Test case NIY")
		);

	::lgEndCase();
}

void Case_SendEx_Invalid_TimeToSend(bool bIsSchedulingEFSP)
{
	BEGIN_CASE(TEXT("Time to send is an invalid date"));
	
	//
	//prepare an invalid date(30/2/1999)
	//
	SYSTEMTIME tmInvalidSchedule;
	tmInvalidSchedule.wYear=1999;
	tmInvalidSchedule.wMonth=2;
	tmInvalidSchedule.wDayOfWeek=1;
	tmInvalidSchedule.wDay=30;
	tmInvalidSchedule.wHour=10;
	tmInvalidSchedule.wMinute=4;
	tmInvalidSchedule.wSecond=5;

	HRESULT hr = SendDefaultFaxWithSystemTime(tmInvalidSchedule);     //This will also Abort and End the send job
	if (bIsSchedulingEFSP)
	{
		//
		//This is a queuing EFSP, FaxDevSendEx should fail since this is an invalid date
		//
		if (FSPI_S_OK == hr)
		{
			::lgLogError(
				LOG_SEV_1,
				TEXT("FaxDevSendEx() succeeded to send with an invalid date")
				);
		}
		else
		{
			::lgLogDetail(
				LOG_PASS,
				2,
				TEXT("FaxDevSendEx() failed as expected with ec:0x%08x"),
				hr
				);
		}
	}
	else
	{
		//
		//Non queuing EFSP, fax should be sent now (ASAP)
		//
		if (S_OK != hr)
		{
			::lgLogError(
				LOG_SEV_1,
				TEXT("FaxDevSendEx() failed with error: 0x%08x"),
				hr
				);
		}
		else
		{
			::lgLogDetail(
				LOG_PASS,
				2,
				TEXT("FaxDevSendEx succeeded")
				);
			//BUGBUG: Verify fax is sent now.

		}
	}

	::lgEndCase();
}

void Case_SendEx_TimeToSend(bool bIsSchedulingEFSP)
{
	lgLogDetail(
		LOG_X,
		2,
		TEXT("\n\n\n*************************************************************************\n***************************** TimeToSend param ********************************")
		);
	
	if (true == bIsSchedulingEFSP)
	{
		::lgLogDetail(
			LOG_X,
			5,
			TEXT("This is a non scheduling EFSP")
			);
	}
	else
	{
		::lgLogDetail(
			LOG_X,
			5,
			TEXT("This is a scheduling EFSP")
			);
	
	}

	Case_SendEx_ZeroInAllFields_TimeToSend(bIsSchedulingEFSP);
	Case_SendEx_Now_TimeToSend(bIsSchedulingEFSP);
	Case_SendEx_NearFuture_TimeToSend(bIsSchedulingEFSP);
	Case_SendEx_FarAwayFuture_TimeToSend(bIsSchedulingEFSP);
	Case_SendEx_Past_TimeToSend(bIsSchedulingEFSP);
	Case_SendEx_Invalid_TimeToSend(bIsSchedulingEFSP);

}


//////////////////////////////////////////////////////////////////
//
//SenderProfile parameter
//





void Case_SendEx_NULL_Name_SenderProfile()
{
	BEGIN_CASE(TEXT("Sender profile contains a NULL string as the sender name"));
	
	FSPI_PERSONAL_PROFILE FSPISenderInfo;				// The Sender information sent to FaxDevSendEx()
	//
	//prepare the sender profile
	//
	PreparePersonalProfile(
		&FSPISenderInfo,
		NULL,
		DEFAULT_SENDER_INFO__FAX_NUMBER,
		DEFAULT_SENDER_INFO__COMPANY,
		DEFAULT_SENDER_INFO__STREET,
		DEFAULT_SENDER_INFO__CITY,
		DEFAULT_SENDER_INFO__STATE,
		DEFAULT_SENDER_INFO__ZIP,
		DEFAULT_SENDER_INFO__COUNTRY,
		DEFAULT_SENDER_INFO__TITLE,
		DEFAULT_SENDER_INFO__DEPT,
		DEFAULT_SENDER_INFO__OFFICE_LOCATION,
		DEFAULT_SENDER_INFO__HOME_PHONE,
		DEFAULT_SENDER_INFO__OFFICE_PHONE,
		DEFAULT_SENDER_INFO__ORG_MAIL,
		DEFAULT_SENDER_INFO__INTERNET_MAIL,
		DEFAULT_SENDER_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithSenderProfile(&FSPISenderInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}


void Case_SendEx_EmptyString_Name_SenderProfile()
{
	BEGIN_CASE(TEXT("Sender profile contains an empty string as the sender name"))
	
	FSPI_PERSONAL_PROFILE FSPISenderInfo;				// The Sender information sent to FaxDevSendEx()
	//
	//prepare the sender profile
	//
	PreparePersonalProfile(
		&FSPISenderInfo,
		TEXT(""),
		DEFAULT_SENDER_INFO__FAX_NUMBER,
		DEFAULT_SENDER_INFO__COMPANY,
		DEFAULT_SENDER_INFO__STREET,
		DEFAULT_SENDER_INFO__CITY,
		DEFAULT_SENDER_INFO__STATE,
		DEFAULT_SENDER_INFO__ZIP,
		DEFAULT_SENDER_INFO__COUNTRY,
		DEFAULT_SENDER_INFO__TITLE,
		DEFAULT_SENDER_INFO__DEPT,
		DEFAULT_SENDER_INFO__OFFICE_LOCATION,
		DEFAULT_SENDER_INFO__HOME_PHONE,
		DEFAULT_SENDER_INFO__OFFICE_PHONE,
		DEFAULT_SENDER_INFO__ORG_MAIL,
		DEFAULT_SENDER_INFO__INTERNET_MAIL,
		DEFAULT_SENDER_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithSenderProfile(&FSPISenderInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}


void Case_SendEx_NULL_FaxNumber_SenderProfile()
{
	BEGIN_CASE(TEXT("Sender profile contains a NULL string as the sender fax number"));
	
	FSPI_PERSONAL_PROFILE FSPISenderInfo;				// The Sender information sent to FaxDevSendEx()
	//
	//prepare the sender profile
	//
	PreparePersonalProfile(
		&FSPISenderInfo,
		DEFAULT_SENDER_INFO__NAME,
		NULL,
		DEFAULT_SENDER_INFO__COMPANY,
		DEFAULT_SENDER_INFO__STREET,
		DEFAULT_SENDER_INFO__CITY,
		DEFAULT_SENDER_INFO__STATE,
		DEFAULT_SENDER_INFO__ZIP,
		DEFAULT_SENDER_INFO__COUNTRY,
		DEFAULT_SENDER_INFO__TITLE,
		DEFAULT_SENDER_INFO__DEPT,
		DEFAULT_SENDER_INFO__OFFICE_LOCATION,
		DEFAULT_SENDER_INFO__HOME_PHONE,
		DEFAULT_SENDER_INFO__OFFICE_PHONE,
		DEFAULT_SENDER_INFO__ORG_MAIL,
		DEFAULT_SENDER_INFO__INTERNET_MAIL,
		DEFAULT_SENDER_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithSenderProfile(&FSPISenderInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_EmptyString_FaxNumber_SenderProfile()
{
	BEGIN_CASE(TEXT("Sender profile contains an empty string as the sender Fax Number"))
	
	FSPI_PERSONAL_PROFILE FSPISenderInfo;				// The Sender information sent to FaxDevSendEx()
	//
	//prepare the sender profile
	//
	PreparePersonalProfile(
		&FSPISenderInfo,
		DEFAULT_SENDER_INFO__NAME,
		TEXT(""),
		DEFAULT_SENDER_INFO__COMPANY,
		DEFAULT_SENDER_INFO__STREET,
		DEFAULT_SENDER_INFO__CITY,
		DEFAULT_SENDER_INFO__STATE,
		DEFAULT_SENDER_INFO__ZIP,
		DEFAULT_SENDER_INFO__COUNTRY,
		DEFAULT_SENDER_INFO__TITLE,
		DEFAULT_SENDER_INFO__DEPT,
		DEFAULT_SENDER_INFO__OFFICE_LOCATION,
		DEFAULT_SENDER_INFO__HOME_PHONE,
		DEFAULT_SENDER_INFO__OFFICE_PHONE,
		DEFAULT_SENDER_INFO__ORG_MAIL,
		DEFAULT_SENDER_INFO__INTERNET_MAIL,
		DEFAULT_SENDER_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithSenderProfile(&FSPISenderInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_NULL_Company_SenderProfile()
{
	BEGIN_CASE(TEXT("Sender profile contains a NULL string as the sender Company"));
	
	FSPI_PERSONAL_PROFILE FSPISenderInfo;				// The Sender information sent to FaxDevSendEx()
	//
	//prepare the sender profile
	//
	PreparePersonalProfile(
		&FSPISenderInfo,
		DEFAULT_SENDER_INFO__NAME,
		DEFAULT_SENDER_INFO__FAX_NUMBER,
		NULL,
		DEFAULT_SENDER_INFO__STREET,
		DEFAULT_SENDER_INFO__CITY,
		DEFAULT_SENDER_INFO__STATE,
		DEFAULT_SENDER_INFO__ZIP,
		DEFAULT_SENDER_INFO__COUNTRY,
		DEFAULT_SENDER_INFO__TITLE,
		DEFAULT_SENDER_INFO__DEPT,
		DEFAULT_SENDER_INFO__OFFICE_LOCATION,
		DEFAULT_SENDER_INFO__HOME_PHONE,
		DEFAULT_SENDER_INFO__OFFICE_PHONE,
		DEFAULT_SENDER_INFO__ORG_MAIL,
		DEFAULT_SENDER_INFO__INTERNET_MAIL,
		DEFAULT_SENDER_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithSenderProfile(&FSPISenderInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_EmptyString_Company_SenderProfile()
{
	BEGIN_CASE(TEXT("Sender profile contains an empty string as the sender Company"));
	
	FSPI_PERSONAL_PROFILE FSPISenderInfo;				// The Sender information sent to FaxDevSendEx()
	//
	//prepare the sender profile
	//
	PreparePersonalProfile(
		&FSPISenderInfo,
		DEFAULT_SENDER_INFO__NAME,
		DEFAULT_SENDER_INFO__FAX_NUMBER,
		TEXT(""),
		DEFAULT_SENDER_INFO__STREET,
		DEFAULT_SENDER_INFO__CITY,
		DEFAULT_SENDER_INFO__STATE,
		DEFAULT_SENDER_INFO__ZIP,
		DEFAULT_SENDER_INFO__COUNTRY,
		DEFAULT_SENDER_INFO__TITLE,
		DEFAULT_SENDER_INFO__DEPT,
		DEFAULT_SENDER_INFO__OFFICE_LOCATION,
		DEFAULT_SENDER_INFO__HOME_PHONE,
		DEFAULT_SENDER_INFO__OFFICE_PHONE,
		DEFAULT_SENDER_INFO__ORG_MAIL,
		DEFAULT_SENDER_INFO__INTERNET_MAIL,
		DEFAULT_SENDER_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithSenderProfile(&FSPISenderInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_NULL_StreetAddress_SenderProfile()
{
	BEGIN_CASE(TEXT("Sender profile contains a NULL string as the sender StreetAddress"));
		
	FSPI_PERSONAL_PROFILE FSPISenderInfo;				// The Sender information sent to FaxDevSendEx()
	//
	//prepare the sender profile
	//
	PreparePersonalProfile(
		&FSPISenderInfo,
		DEFAULT_SENDER_INFO__NAME,
		DEFAULT_SENDER_INFO__FAX_NUMBER,
		DEFAULT_SENDER_INFO__COMPANY,
		NULL,
		DEFAULT_SENDER_INFO__CITY,
		DEFAULT_SENDER_INFO__STATE,
		DEFAULT_SENDER_INFO__ZIP,
		DEFAULT_SENDER_INFO__COUNTRY,
		DEFAULT_SENDER_INFO__TITLE,
		DEFAULT_SENDER_INFO__DEPT,
		DEFAULT_SENDER_INFO__OFFICE_LOCATION,
		DEFAULT_SENDER_INFO__HOME_PHONE,
		DEFAULT_SENDER_INFO__OFFICE_PHONE,
		DEFAULT_SENDER_INFO__ORG_MAIL,
		DEFAULT_SENDER_INFO__INTERNET_MAIL,
		DEFAULT_SENDER_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithSenderProfile(&FSPISenderInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_EmptyString_StreetAddress_SenderProfile()
{
	BEGIN_CASE(TEXT("Sender profile contains an empty string as the sender StreetAddress"));
	
	FSPI_PERSONAL_PROFILE FSPISenderInfo;				// The Sender information sent to FaxDevSendEx()
	//
	//prepare the sender profile
	//
	PreparePersonalProfile(
		&FSPISenderInfo,
		DEFAULT_SENDER_INFO__NAME,
		DEFAULT_SENDER_INFO__FAX_NUMBER,
		DEFAULT_SENDER_INFO__COMPANY,
		TEXT(""),
		DEFAULT_SENDER_INFO__CITY,
		DEFAULT_SENDER_INFO__STATE,
		DEFAULT_SENDER_INFO__ZIP,
		DEFAULT_SENDER_INFO__COUNTRY,
		DEFAULT_SENDER_INFO__TITLE,
		DEFAULT_SENDER_INFO__DEPT,
		DEFAULT_SENDER_INFO__OFFICE_LOCATION,
		DEFAULT_SENDER_INFO__HOME_PHONE,
		DEFAULT_SENDER_INFO__OFFICE_PHONE,
		DEFAULT_SENDER_INFO__ORG_MAIL,
		DEFAULT_SENDER_INFO__INTERNET_MAIL,
		DEFAULT_SENDER_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithSenderProfile(&FSPISenderInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}



void Case_SendEx_NULL_City_SenderProfile()
{
	BEGIN_CASE(TEXT("Sender profile contains a NULL string as the sender City"));
		
	FSPI_PERSONAL_PROFILE FSPISenderInfo;				// The Sender information sent to FaxDevSendEx()
	//
	//prepare the sender profile
	//
	PreparePersonalProfile(
		&FSPISenderInfo,
		DEFAULT_SENDER_INFO__NAME,
		DEFAULT_SENDER_INFO__FAX_NUMBER,
		DEFAULT_SENDER_INFO__COMPANY,
		DEFAULT_SENDER_INFO__STREET,
		NULL,
		DEFAULT_SENDER_INFO__STATE,
		DEFAULT_SENDER_INFO__ZIP,
		DEFAULT_SENDER_INFO__COUNTRY,
		DEFAULT_SENDER_INFO__TITLE,
		DEFAULT_SENDER_INFO__DEPT,
		DEFAULT_SENDER_INFO__OFFICE_LOCATION,
		DEFAULT_SENDER_INFO__HOME_PHONE,
		DEFAULT_SENDER_INFO__OFFICE_PHONE,
		DEFAULT_SENDER_INFO__ORG_MAIL,
		DEFAULT_SENDER_INFO__INTERNET_MAIL,
		DEFAULT_SENDER_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithSenderProfile(&FSPISenderInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_EmptyString_City_SenderProfile()
{
	BEGIN_CASE(TEXT("Sender profile contains an empty string as the sender City"));
	
	FSPI_PERSONAL_PROFILE FSPISenderInfo;				// The Sender information sent to FaxDevSendEx()
	//
	//prepare the sender profile
	//
	PreparePersonalProfile(
		&FSPISenderInfo,
		DEFAULT_SENDER_INFO__NAME,
		DEFAULT_SENDER_INFO__FAX_NUMBER,
		DEFAULT_SENDER_INFO__COMPANY,
		DEFAULT_SENDER_INFO__STREET,
		TEXT(""),
		DEFAULT_SENDER_INFO__STATE,
		DEFAULT_SENDER_INFO__ZIP,
		DEFAULT_SENDER_INFO__COUNTRY,
		DEFAULT_SENDER_INFO__TITLE,
		DEFAULT_SENDER_INFO__DEPT,
		DEFAULT_SENDER_INFO__OFFICE_LOCATION,
		DEFAULT_SENDER_INFO__HOME_PHONE,
		DEFAULT_SENDER_INFO__OFFICE_PHONE,
		DEFAULT_SENDER_INFO__ORG_MAIL,
		DEFAULT_SENDER_INFO__INTERNET_MAIL,
		DEFAULT_SENDER_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithSenderProfile(&FSPISenderInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}


void Case_SendEx_NULL_State_SenderProfile()
{
	BEGIN_CASE(TEXT("Sender profile contains a NULL string as the sender State"));
		
	FSPI_PERSONAL_PROFILE FSPISenderInfo;				// The Sender information sent to FaxDevSendEx()
	//
	//prepare the sender profile
	//
	PreparePersonalProfile(
		&FSPISenderInfo,
		DEFAULT_SENDER_INFO__NAME,
		DEFAULT_SENDER_INFO__FAX_NUMBER,
		DEFAULT_SENDER_INFO__COMPANY,
		DEFAULT_SENDER_INFO__STREET,
		DEFAULT_SENDER_INFO__CITY,
		NULL,
		DEFAULT_SENDER_INFO__ZIP,
		DEFAULT_SENDER_INFO__COUNTRY,
		DEFAULT_SENDER_INFO__TITLE,
		DEFAULT_SENDER_INFO__DEPT,
		DEFAULT_SENDER_INFO__OFFICE_LOCATION,
		DEFAULT_SENDER_INFO__HOME_PHONE,
		DEFAULT_SENDER_INFO__OFFICE_PHONE,
		DEFAULT_SENDER_INFO__ORG_MAIL,
		DEFAULT_SENDER_INFO__INTERNET_MAIL,
		DEFAULT_SENDER_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithSenderProfile(&FSPISenderInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_EmptyString_State_SenderProfile()
{
	BEGIN_CASE(TEXT("Sender profile contains an empty string as the sender State"));
	
	
	FSPI_PERSONAL_PROFILE FSPISenderInfo;				// The Sender information sent to FaxDevSendEx()
	//
	//prepare the sender profile
	//
	PreparePersonalProfile(
		&FSPISenderInfo,
		DEFAULT_SENDER_INFO__NAME,
		DEFAULT_SENDER_INFO__FAX_NUMBER,
		DEFAULT_SENDER_INFO__COMPANY,
		DEFAULT_SENDER_INFO__STREET,
		DEFAULT_SENDER_INFO__CITY,
		TEXT(""),
		DEFAULT_SENDER_INFO__ZIP,
		DEFAULT_SENDER_INFO__COUNTRY,
		DEFAULT_SENDER_INFO__TITLE,
		DEFAULT_SENDER_INFO__DEPT,
		DEFAULT_SENDER_INFO__OFFICE_LOCATION,
		DEFAULT_SENDER_INFO__HOME_PHONE,
		DEFAULT_SENDER_INFO__OFFICE_PHONE,
		DEFAULT_SENDER_INFO__ORG_MAIL,
		DEFAULT_SENDER_INFO__INTERNET_MAIL,
		DEFAULT_SENDER_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithSenderProfile(&FSPISenderInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_NULL_Zip_SenderProfile()
{
	BEGIN_CASE(TEXT("Sender profile contains a NULL string as the sender Zip"));
	
	FSPI_PERSONAL_PROFILE FSPISenderInfo;				// The Sender information sent to FaxDevSendEx()
	//
	//prepare the sender profile
	//
	PreparePersonalProfile(
		&FSPISenderInfo,
		DEFAULT_SENDER_INFO__NAME,
		DEFAULT_SENDER_INFO__FAX_NUMBER,
		DEFAULT_SENDER_INFO__COMPANY,
		DEFAULT_SENDER_INFO__STREET,
		DEFAULT_SENDER_INFO__CITY,
		DEFAULT_SENDER_INFO__STATE,
		NULL,
		DEFAULT_SENDER_INFO__COUNTRY,
		DEFAULT_SENDER_INFO__TITLE,
		DEFAULT_SENDER_INFO__DEPT,
		DEFAULT_SENDER_INFO__OFFICE_LOCATION,
		DEFAULT_SENDER_INFO__HOME_PHONE,
		DEFAULT_SENDER_INFO__OFFICE_PHONE,
		DEFAULT_SENDER_INFO__ORG_MAIL,
		DEFAULT_SENDER_INFO__INTERNET_MAIL,
		DEFAULT_SENDER_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithSenderProfile(&FSPISenderInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_EmptyString_Zip_SenderProfile()
{
	BEGIN_CASE(TEXT("Sender profile contains an empty string as the sender Zip"));
	
	FSPI_PERSONAL_PROFILE FSPISenderInfo;				// The Sender information sent to FaxDevSendEx()
	//
	//prepare the sender profile
	//
	PreparePersonalProfile(
		&FSPISenderInfo,
		DEFAULT_SENDER_INFO__NAME,
		DEFAULT_SENDER_INFO__FAX_NUMBER,
		DEFAULT_SENDER_INFO__COMPANY,
		DEFAULT_SENDER_INFO__STREET,
		DEFAULT_SENDER_INFO__CITY,
		DEFAULT_SENDER_INFO__STATE,
		TEXT(""),
		DEFAULT_SENDER_INFO__COUNTRY,
		DEFAULT_SENDER_INFO__TITLE,
		DEFAULT_SENDER_INFO__DEPT,
		DEFAULT_SENDER_INFO__OFFICE_LOCATION,
		DEFAULT_SENDER_INFO__HOME_PHONE,
		DEFAULT_SENDER_INFO__OFFICE_PHONE,
		DEFAULT_SENDER_INFO__ORG_MAIL,
		DEFAULT_SENDER_INFO__INTERNET_MAIL,
		DEFAULT_SENDER_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithSenderProfile(&FSPISenderInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_NULL_Country_SenderProfile()
{
	BEGIN_CASE(TEXT("Sender profile contains a NULL string as the sender Country"));
	
	FSPI_PERSONAL_PROFILE FSPISenderInfo;				// The Sender information sent to FaxDevSendEx()
	//
	//prepare the sender profile
	//
	PreparePersonalProfile(
		&FSPISenderInfo,
		DEFAULT_SENDER_INFO__NAME,
		DEFAULT_SENDER_INFO__FAX_NUMBER,
		DEFAULT_SENDER_INFO__COMPANY,
		DEFAULT_SENDER_INFO__STREET,
		DEFAULT_SENDER_INFO__CITY,
		DEFAULT_SENDER_INFO__STATE,
		DEFAULT_SENDER_INFO__ZIP,
		NULL,
		DEFAULT_SENDER_INFO__TITLE,
		DEFAULT_SENDER_INFO__DEPT,
		DEFAULT_SENDER_INFO__OFFICE_LOCATION,
		DEFAULT_SENDER_INFO__HOME_PHONE,
		DEFAULT_SENDER_INFO__OFFICE_PHONE,
		DEFAULT_SENDER_INFO__ORG_MAIL,
		DEFAULT_SENDER_INFO__INTERNET_MAIL,
		DEFAULT_SENDER_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithSenderProfile(&FSPISenderInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_EmptyString_Country_SenderProfile()
{
	BEGIN_CASE(TEXT("Sender profile contains an empty string as the sender Country"))
	
	FSPI_PERSONAL_PROFILE FSPISenderInfo;				// The Sender information sent to FaxDevSendEx()
	//
	//prepare the sender profile
	//
	PreparePersonalProfile(
		&FSPISenderInfo,
		DEFAULT_SENDER_INFO__NAME,
		DEFAULT_SENDER_INFO__FAX_NUMBER,
		DEFAULT_SENDER_INFO__COMPANY,
		DEFAULT_SENDER_INFO__STREET,
		DEFAULT_SENDER_INFO__CITY,
		DEFAULT_SENDER_INFO__STATE,
		DEFAULT_SENDER_INFO__ZIP,
		TEXT(""),
		DEFAULT_SENDER_INFO__TITLE,
		DEFAULT_SENDER_INFO__DEPT,
		DEFAULT_SENDER_INFO__OFFICE_LOCATION,
		DEFAULT_SENDER_INFO__HOME_PHONE,
		DEFAULT_SENDER_INFO__OFFICE_PHONE,
		DEFAULT_SENDER_INFO__ORG_MAIL,
		DEFAULT_SENDER_INFO__INTERNET_MAIL,
		DEFAULT_SENDER_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithSenderProfile(&FSPISenderInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_NULL_Title_SenderProfile()
{
	BEGIN_CASE(TEXT("Sender profile contains a NULL string as the sender Title"));
	
	FSPI_PERSONAL_PROFILE FSPISenderInfo;				// The Sender information sent to FaxDevSendEx()
	//
	//prepare the sender profile
	//
	PreparePersonalProfile(
		&FSPISenderInfo,
		DEFAULT_SENDER_INFO__NAME,
		DEFAULT_SENDER_INFO__FAX_NUMBER,
		DEFAULT_SENDER_INFO__COMPANY,
		DEFAULT_SENDER_INFO__STREET,
		DEFAULT_SENDER_INFO__CITY,
		DEFAULT_SENDER_INFO__STATE,
		DEFAULT_SENDER_INFO__ZIP,
		DEFAULT_SENDER_INFO__COUNTRY,
		NULL,
		DEFAULT_SENDER_INFO__DEPT,
		DEFAULT_SENDER_INFO__OFFICE_LOCATION,
		DEFAULT_SENDER_INFO__HOME_PHONE,
		DEFAULT_SENDER_INFO__OFFICE_PHONE,
		DEFAULT_SENDER_INFO__ORG_MAIL,
		DEFAULT_SENDER_INFO__INTERNET_MAIL,
		DEFAULT_SENDER_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithSenderProfile(&FSPISenderInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_EmptyString_Title_SenderProfile()
{
	BEGIN_CASE(TEXT("Sender profile contains an empty string as the sender Title"))
	
	FSPI_PERSONAL_PROFILE FSPISenderInfo;				// The Sender information sent to FaxDevSendEx()
	//
	//prepare the sender profile
	//
	PreparePersonalProfile(
		&FSPISenderInfo,
		DEFAULT_SENDER_INFO__NAME,
		DEFAULT_SENDER_INFO__FAX_NUMBER,
		DEFAULT_SENDER_INFO__COMPANY,
		DEFAULT_SENDER_INFO__STREET,
		DEFAULT_SENDER_INFO__CITY,
		DEFAULT_SENDER_INFO__STATE,
		DEFAULT_SENDER_INFO__ZIP,
		DEFAULT_SENDER_INFO__COUNTRY,
		TEXT(""),
		DEFAULT_SENDER_INFO__DEPT,
		DEFAULT_SENDER_INFO__OFFICE_LOCATION,
		DEFAULT_SENDER_INFO__HOME_PHONE,
		DEFAULT_SENDER_INFO__OFFICE_PHONE,
		DEFAULT_SENDER_INFO__ORG_MAIL,
		DEFAULT_SENDER_INFO__INTERNET_MAIL,
		DEFAULT_SENDER_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithSenderProfile(&FSPISenderInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_NULL_Department_SenderProfile()
{
	BEGIN_CASE(TEXT("Sender profile contains a NULL string as the sender Department"));
	
	FSPI_PERSONAL_PROFILE FSPISenderInfo;				// The Sender information sent to FaxDevSendEx()
	//
	//prepare the sender profile
	//
	PreparePersonalProfile(
		&FSPISenderInfo,
		DEFAULT_SENDER_INFO__NAME,
		DEFAULT_SENDER_INFO__FAX_NUMBER,
		DEFAULT_SENDER_INFO__COMPANY,
		DEFAULT_SENDER_INFO__STREET,
		DEFAULT_SENDER_INFO__CITY,
		DEFAULT_SENDER_INFO__STATE,
		DEFAULT_SENDER_INFO__ZIP,
		DEFAULT_SENDER_INFO__COUNTRY,
		DEFAULT_SENDER_INFO__TITLE,
		NULL,
		DEFAULT_SENDER_INFO__OFFICE_LOCATION,
		DEFAULT_SENDER_INFO__HOME_PHONE,
		DEFAULT_SENDER_INFO__OFFICE_PHONE,
		DEFAULT_SENDER_INFO__ORG_MAIL,
		DEFAULT_SENDER_INFO__INTERNET_MAIL,
		DEFAULT_SENDER_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithSenderProfile(&FSPISenderInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_EmptyString_Department_SenderProfile()
{
	BEGIN_CASE(TEXT("Sender profile contains an empty string as the sender Department"))
	
	FSPI_PERSONAL_PROFILE FSPISenderInfo;				// The Sender information sent to FaxDevSendEx()
	//
	//prepare the sender profile
	//
	PreparePersonalProfile(
		&FSPISenderInfo,
		DEFAULT_SENDER_INFO__NAME,
		DEFAULT_SENDER_INFO__FAX_NUMBER,
		DEFAULT_SENDER_INFO__COMPANY,
		DEFAULT_SENDER_INFO__STREET,
		DEFAULT_SENDER_INFO__CITY,
		DEFAULT_SENDER_INFO__STATE,
		DEFAULT_SENDER_INFO__ZIP,
		DEFAULT_SENDER_INFO__COUNTRY,
		DEFAULT_SENDER_INFO__TITLE,
		TEXT(""),
		DEFAULT_SENDER_INFO__OFFICE_LOCATION,
		DEFAULT_SENDER_INFO__HOME_PHONE,
		DEFAULT_SENDER_INFO__OFFICE_PHONE,
		DEFAULT_SENDER_INFO__ORG_MAIL,
		DEFAULT_SENDER_INFO__INTERNET_MAIL,
		DEFAULT_SENDER_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithSenderProfile(&FSPISenderInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}
void Case_SendEx_NULL_OfficeLocation_SenderProfile()
{
	BEGIN_CASE(TEXT("Sender profile contains a NULL string as the sender OfficeLocation"));
	
	FSPI_PERSONAL_PROFILE FSPISenderInfo;				// The Sender information sent to FaxDevSendEx()
	//
	//prepare the sender profile
	//
	PreparePersonalProfile(
		&FSPISenderInfo,
		DEFAULT_SENDER_INFO__NAME,
		DEFAULT_SENDER_INFO__FAX_NUMBER,
		DEFAULT_SENDER_INFO__COMPANY,
		DEFAULT_SENDER_INFO__STREET,
		DEFAULT_SENDER_INFO__CITY,
		DEFAULT_SENDER_INFO__STATE,
		DEFAULT_SENDER_INFO__ZIP,
		DEFAULT_SENDER_INFO__COUNTRY,
		DEFAULT_SENDER_INFO__TITLE,
		DEFAULT_SENDER_INFO__DEPT,
		NULL,
		DEFAULT_SENDER_INFO__HOME_PHONE,
		DEFAULT_SENDER_INFO__OFFICE_PHONE,
		DEFAULT_SENDER_INFO__ORG_MAIL,
		DEFAULT_SENDER_INFO__INTERNET_MAIL,
		DEFAULT_SENDER_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithSenderProfile(&FSPISenderInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_EmptyString_OfficeLocation_SenderProfile()
{
	BEGIN_CASE(TEXT("Sender profile contains an empty string as the sender OfficeLocation"))
	
	FSPI_PERSONAL_PROFILE FSPISenderInfo;				// The Sender information sent to FaxDevSendEx()
	//
	//prepare the sender profile
	//
	PreparePersonalProfile(
		&FSPISenderInfo,
		DEFAULT_SENDER_INFO__NAME,
		DEFAULT_SENDER_INFO__FAX_NUMBER,
		DEFAULT_SENDER_INFO__COMPANY,
		DEFAULT_SENDER_INFO__STREET,
		DEFAULT_SENDER_INFO__CITY,
		DEFAULT_SENDER_INFO__STATE,
		DEFAULT_SENDER_INFO__ZIP,
		DEFAULT_SENDER_INFO__COUNTRY,
		DEFAULT_SENDER_INFO__TITLE,
		DEFAULT_SENDER_INFO__DEPT,
		TEXT(""),
		DEFAULT_SENDER_INFO__HOME_PHONE,
		DEFAULT_SENDER_INFO__OFFICE_PHONE,
		DEFAULT_SENDER_INFO__ORG_MAIL,
		DEFAULT_SENDER_INFO__INTERNET_MAIL,
		DEFAULT_SENDER_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithSenderProfile(&FSPISenderInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_NULL_HomePhone_SenderProfile()
{
	BEGIN_CASE(TEXT("Sender profile contains a NULL string as the sender HomePhone"));
	
	FSPI_PERSONAL_PROFILE FSPISenderInfo;				// The Sender information sent to FaxDevSendEx()
	//
	//prepare the sender profile
	//
	PreparePersonalProfile(
		&FSPISenderInfo,
		DEFAULT_SENDER_INFO__NAME,
		DEFAULT_SENDER_INFO__FAX_NUMBER,
		DEFAULT_SENDER_INFO__COMPANY,
		DEFAULT_SENDER_INFO__STREET,
		DEFAULT_SENDER_INFO__CITY,
		DEFAULT_SENDER_INFO__STATE,
		DEFAULT_SENDER_INFO__ZIP,
		DEFAULT_SENDER_INFO__COUNTRY,
		DEFAULT_SENDER_INFO__TITLE,
		DEFAULT_SENDER_INFO__DEPT,
		NULL,
		DEFAULT_SENDER_INFO__HOME_PHONE,
		DEFAULT_SENDER_INFO__OFFICE_PHONE,
		DEFAULT_SENDER_INFO__ORG_MAIL,
		DEFAULT_SENDER_INFO__INTERNET_MAIL,
		DEFAULT_SENDER_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithSenderProfile(&FSPISenderInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_EmptyString_HomePhone_SenderProfile()
{
	BEGIN_CASE(TEXT("Sender profile contains an empty string as the sender HomePhone"))
	
	FSPI_PERSONAL_PROFILE FSPISenderInfo;				// The Sender information sent to FaxDevSendEx()
	//
	//prepare the sender profile
	//
	PreparePersonalProfile(
		&FSPISenderInfo,
		DEFAULT_SENDER_INFO__NAME,
		DEFAULT_SENDER_INFO__FAX_NUMBER,
		DEFAULT_SENDER_INFO__COMPANY,
		DEFAULT_SENDER_INFO__STREET,
		DEFAULT_SENDER_INFO__CITY,
		DEFAULT_SENDER_INFO__STATE,
		DEFAULT_SENDER_INFO__ZIP,
		DEFAULT_SENDER_INFO__COUNTRY,
		DEFAULT_SENDER_INFO__TITLE,
		DEFAULT_SENDER_INFO__DEPT,
		TEXT(""),
		DEFAULT_SENDER_INFO__HOME_PHONE,
		DEFAULT_SENDER_INFO__OFFICE_PHONE,
		DEFAULT_SENDER_INFO__ORG_MAIL,
		DEFAULT_SENDER_INFO__INTERNET_MAIL,
		DEFAULT_SENDER_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithSenderProfile(&FSPISenderInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_NULL_OfficePhone_SenderProfile()
{
	BEGIN_CASE(TEXT("Sender profile contains a NULL string as the sender OfficePhone"));
	
	FSPI_PERSONAL_PROFILE FSPISenderInfo;				// The Sender information sent to FaxDevSendEx()
	//
	//prepare the sender profile
	//
	PreparePersonalProfile(
		&FSPISenderInfo,
		DEFAULT_SENDER_INFO__NAME,
		DEFAULT_SENDER_INFO__FAX_NUMBER,
		DEFAULT_SENDER_INFO__COMPANY,
		DEFAULT_SENDER_INFO__STREET,
		DEFAULT_SENDER_INFO__CITY,
		DEFAULT_SENDER_INFO__STATE,
		DEFAULT_SENDER_INFO__ZIP,
		DEFAULT_SENDER_INFO__COUNTRY,
		DEFAULT_SENDER_INFO__TITLE,
		DEFAULT_SENDER_INFO__DEPT,
		DEFAULT_SENDER_INFO__OFFICE_LOCATION,
		DEFAULT_SENDER_INFO__HOME_PHONE,
		NULL,
		DEFAULT_SENDER_INFO__ORG_MAIL,
		DEFAULT_SENDER_INFO__INTERNET_MAIL,
		DEFAULT_SENDER_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithSenderProfile(&FSPISenderInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_EmptyString_OfficePhone_SenderProfile()
{
	BEGIN_CASE(TEXT("Sender profile contains an empty string as the sender OfficePhone"))
	
	FSPI_PERSONAL_PROFILE FSPISenderInfo;				// The Sender information sent to FaxDevSendEx()
	//
	//prepare the sender profile
	//
	PreparePersonalProfile(
		&FSPISenderInfo,
		DEFAULT_SENDER_INFO__NAME,
		DEFAULT_SENDER_INFO__FAX_NUMBER,
		DEFAULT_SENDER_INFO__COMPANY,
		DEFAULT_SENDER_INFO__STREET,
		DEFAULT_SENDER_INFO__CITY,
		DEFAULT_SENDER_INFO__STATE,
		DEFAULT_SENDER_INFO__ZIP,
		DEFAULT_SENDER_INFO__COUNTRY,
		DEFAULT_SENDER_INFO__TITLE,
		DEFAULT_SENDER_INFO__DEPT,
		DEFAULT_SENDER_INFO__OFFICE_LOCATION,
		DEFAULT_SENDER_INFO__HOME_PHONE,
		TEXT(""),
		DEFAULT_SENDER_INFO__ORG_MAIL,
		DEFAULT_SENDER_INFO__INTERNET_MAIL,
		DEFAULT_SENDER_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithSenderProfile(&FSPISenderInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_NULL_OrganizationalMail_SenderProfile()
{
	BEGIN_CASE(TEXT("Sender profile contains a NULL string as the sender OrganizationalMail"));
	
	FSPI_PERSONAL_PROFILE FSPISenderInfo;				// The Sender information sent to FaxDevSendEx()
	//
	//prepare the sender profile
	//
	PreparePersonalProfile(
		&FSPISenderInfo,
		DEFAULT_SENDER_INFO__NAME,
		DEFAULT_SENDER_INFO__FAX_NUMBER,
		DEFAULT_SENDER_INFO__COMPANY,
		DEFAULT_SENDER_INFO__STREET,
		DEFAULT_SENDER_INFO__CITY,
		DEFAULT_SENDER_INFO__STATE,
		DEFAULT_SENDER_INFO__ZIP,
		DEFAULT_SENDER_INFO__COUNTRY,
		DEFAULT_SENDER_INFO__TITLE,
		DEFAULT_SENDER_INFO__DEPT,
		DEFAULT_SENDER_INFO__OFFICE_LOCATION,
		DEFAULT_SENDER_INFO__HOME_PHONE,
		DEFAULT_SENDER_INFO__OFFICE_PHONE,
		NULL,
		DEFAULT_SENDER_INFO__INTERNET_MAIL,
		DEFAULT_SENDER_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithSenderProfile(&FSPISenderInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_EmptyString_OrganizationalMail_SenderProfile()
{
	BEGIN_CASE(TEXT("Sender profile contains an empty string as the sender OrganizationalMail"))
	
	FSPI_PERSONAL_PROFILE FSPISenderInfo;				// The Sender information sent to FaxDevSendEx()
	//
	//prepare the sender profile
	//
	PreparePersonalProfile(
		&FSPISenderInfo,
		DEFAULT_SENDER_INFO__NAME,
		DEFAULT_SENDER_INFO__FAX_NUMBER,
		DEFAULT_SENDER_INFO__COMPANY,
		DEFAULT_SENDER_INFO__STREET,
		DEFAULT_SENDER_INFO__CITY,
		DEFAULT_SENDER_INFO__STATE,
		DEFAULT_SENDER_INFO__ZIP,
		DEFAULT_SENDER_INFO__COUNTRY,
		DEFAULT_SENDER_INFO__TITLE,
		DEFAULT_SENDER_INFO__DEPT,
		DEFAULT_SENDER_INFO__OFFICE_LOCATION,
		DEFAULT_SENDER_INFO__HOME_PHONE,
		DEFAULT_SENDER_INFO__OFFICE_PHONE,
		TEXT(""),
		DEFAULT_SENDER_INFO__INTERNET_MAIL,
		DEFAULT_SENDER_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithSenderProfile(&FSPISenderInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_NULL_InternetMail_SenderProfile()
{
	BEGIN_CASE(TEXT("Sender profile contains a NULL string as the sender InternetMail"));
	
	FSPI_PERSONAL_PROFILE FSPISenderInfo;				// The Sender information sent to FaxDevSendEx()
	//
	//prepare the sender profile
	//
	PreparePersonalProfile(
		&FSPISenderInfo,
		DEFAULT_SENDER_INFO__NAME,
		DEFAULT_SENDER_INFO__FAX_NUMBER,
		DEFAULT_SENDER_INFO__COMPANY,
		DEFAULT_SENDER_INFO__STREET,
		DEFAULT_SENDER_INFO__CITY,
		DEFAULT_SENDER_INFO__STATE,
		DEFAULT_SENDER_INFO__ZIP,
		DEFAULT_SENDER_INFO__COUNTRY,
		DEFAULT_SENDER_INFO__TITLE,
		DEFAULT_SENDER_INFO__DEPT,
		DEFAULT_SENDER_INFO__OFFICE_LOCATION,
		DEFAULT_SENDER_INFO__HOME_PHONE,
		DEFAULT_SENDER_INFO__OFFICE_PHONE,
		DEFAULT_SENDER_INFO__ORG_MAIL,
		NULL,
		DEFAULT_SENDER_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithSenderProfile(&FSPISenderInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_EmptyString_InternetMail_SenderProfile()
{
	BEGIN_CASE(TEXT("Sender profile contains an empty string as the sender InternetMail"))
	
	FSPI_PERSONAL_PROFILE FSPISenderInfo;				// The Sender information sent to FaxDevSendEx()
	//
	//prepare the sender profile
	//
	PreparePersonalProfile(
		&FSPISenderInfo,
		DEFAULT_SENDER_INFO__NAME,
		DEFAULT_SENDER_INFO__FAX_NUMBER,
		DEFAULT_SENDER_INFO__COMPANY,
		DEFAULT_SENDER_INFO__STREET,
		DEFAULT_SENDER_INFO__CITY,
		DEFAULT_SENDER_INFO__STATE,
		DEFAULT_SENDER_INFO__ZIP,
		DEFAULT_SENDER_INFO__COUNTRY,
		DEFAULT_SENDER_INFO__TITLE,
		DEFAULT_SENDER_INFO__DEPT,
		DEFAULT_SENDER_INFO__OFFICE_LOCATION,
		DEFAULT_SENDER_INFO__HOME_PHONE,
		DEFAULT_SENDER_INFO__OFFICE_PHONE,
		DEFAULT_SENDER_INFO__ORG_MAIL,
		TEXT(""),
		DEFAULT_SENDER_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithSenderProfile(&FSPISenderInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_NULL_BillingCode_SenderProfile()
{
	BEGIN_CASE(TEXT("Sender profile contains a NULL string as the sender BillingCode"));
	
	FSPI_PERSONAL_PROFILE FSPISenderInfo;				// The Sender information sent to FaxDevSendEx()
	//
	//prepare the sender profile
	//
	PreparePersonalProfile(
		&FSPISenderInfo,
		DEFAULT_SENDER_INFO__NAME,
		DEFAULT_SENDER_INFO__FAX_NUMBER,
		DEFAULT_SENDER_INFO__COMPANY,
		DEFAULT_SENDER_INFO__STREET,
		DEFAULT_SENDER_INFO__CITY,
		DEFAULT_SENDER_INFO__STATE,
		DEFAULT_SENDER_INFO__ZIP,
		DEFAULT_SENDER_INFO__COUNTRY,
		DEFAULT_SENDER_INFO__TITLE,
		DEFAULT_SENDER_INFO__DEPT,
		DEFAULT_SENDER_INFO__OFFICE_LOCATION,
		DEFAULT_SENDER_INFO__HOME_PHONE,
		DEFAULT_SENDER_INFO__OFFICE_PHONE,
		DEFAULT_SENDER_INFO__ORG_MAIL,
		DEFAULT_SENDER_INFO__INTERNET_MAIL,
		NULL
		);


	HRESULT hr = SendDefaultFaxWithSenderProfile(&FSPISenderInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_EmptyString_BillingCode_SenderProfile()
{
	BEGIN_CASE(TEXT("Sender profile contains an empty string as the sender BillingCode"));
	
	FSPI_PERSONAL_PROFILE FSPISenderInfo;				// The Sender information sent to FaxDevSendEx()
	//
	//prepare the sender profile
	//
	PreparePersonalProfile(
		&FSPISenderInfo,
		DEFAULT_SENDER_INFO__NAME,
		DEFAULT_SENDER_INFO__FAX_NUMBER,
		DEFAULT_SENDER_INFO__COMPANY,
		DEFAULT_SENDER_INFO__STREET,
		DEFAULT_SENDER_INFO__CITY,
		DEFAULT_SENDER_INFO__STATE,
		DEFAULT_SENDER_INFO__ZIP,
		DEFAULT_SENDER_INFO__COUNTRY,
		DEFAULT_SENDER_INFO__TITLE,
		DEFAULT_SENDER_INFO__DEPT,
		DEFAULT_SENDER_INFO__OFFICE_LOCATION,
		DEFAULT_SENDER_INFO__HOME_PHONE,
		DEFAULT_SENDER_INFO__OFFICE_PHONE,
		DEFAULT_SENDER_INFO__OFFICE_PHONE,
		DEFAULT_SENDER_INFO__INTERNET_MAIL,
		TEXT("")
		);


	HRESULT hr = SendDefaultFaxWithSenderProfile(&FSPISenderInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}


void Case_SendEx_NULL_SenderProfile()
{
	BEGIN_CASE(TEXT("Sender profile is a NULL structure"));
	
	HRESULT hr = SendDefaultFaxWithSenderProfile(NULL);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}


void Case_SendEx_SenderProfile()
{
	lgLogDetail(
		LOG_X,
		2,
		TEXT("\n\n\n*************************************************************************\n***************************** SenderProfile param ********************************")
		);

	Case_SendEx_NULL_SenderProfile();

	Case_SendEx_NULL_Name_SenderProfile();
	Case_SendEx_EmptyString_Name_SenderProfile();
	
	Case_SendEx_NULL_FaxNumber_SenderProfile();
	Case_SendEx_EmptyString_FaxNumber_SenderProfile();
	
	Case_SendEx_NULL_Company_SenderProfile();
	Case_SendEx_EmptyString_Company_SenderProfile();
	
	Case_SendEx_NULL_StreetAddress_SenderProfile();
	Case_SendEx_EmptyString_StreetAddress_SenderProfile();
	
	Case_SendEx_NULL_City_SenderProfile();
	Case_SendEx_EmptyString_City_SenderProfile();

	Case_SendEx_NULL_State_SenderProfile();
	Case_SendEx_EmptyString_State_SenderProfile();

	Case_SendEx_NULL_Zip_SenderProfile();
	Case_SendEx_EmptyString_Zip_SenderProfile();

	Case_SendEx_NULL_Country_SenderProfile();
	Case_SendEx_EmptyString_Country_SenderProfile();

	Case_SendEx_NULL_Title_SenderProfile();
	Case_SendEx_EmptyString_Title_SenderProfile();

	Case_SendEx_NULL_Department_SenderProfile();
	Case_SendEx_EmptyString_Department_SenderProfile();

	Case_SendEx_NULL_OfficeLocation_SenderProfile();
	Case_SendEx_EmptyString_OfficeLocation_SenderProfile();

	Case_SendEx_NULL_HomePhone_SenderProfile();
	Case_SendEx_EmptyString_HomePhone_SenderProfile();

	Case_SendEx_NULL_OfficePhone_SenderProfile();
	Case_SendEx_EmptyString_OfficePhone_SenderProfile();

	Case_SendEx_NULL_OrganizationalMail_SenderProfile();
	Case_SendEx_EmptyString_OrganizationalMail_SenderProfile();

	Case_SendEx_NULL_InternetMail_SenderProfile();
	Case_SendEx_EmptyString_InternetMail_SenderProfile();

	Case_SendEx_NULL_BillingCode_SenderProfile();
	Case_SendEx_EmptyString_BillingCode_SenderProfile();

}

//////////////////////////////////////////////////////////////////
//
//dwNumberOfRecipients parameter
//
void Case_SendEx_Zero_dwNumberOfRecipients()
{
	BEGIN_CASE(TEXT("0 Number of recipients to send to"));
	//BUGBUG: NIY
	::lgLogDetail(
		LOG_X, 
		3,
		TEXT("Test case NIY")
		);
	::lgEndCase();
}

void Case_SendEx_MoreThenSupplied_dwNumberOfRecipients()
{
	BEGIN_CASE(TEXT("Supply more recipients then declared in dwNumberOfRecipients"));
	//BUGBUG: NIY
	::lgLogDetail(
		LOG_X, 
		3,
		TEXT("Test case NIY")
		);
	::lgEndCase();
}

void Case_SendEx_LessThenSupplied_dwNumberOfRecipients()
{
	BEGIN_CASE(TEXT("Supply less recipients then declared in dwNumberOfRecipients"));
	//BUGBUG: NIY
	::lgLogDetail(
		LOG_X, 
		3,
		TEXT("Warning: Test case NIY")
		);
	::lgEndCase();
}

void Case_SendEx_dwNumberOfRecipients()
{
	lgLogDetail(
		LOG_X,
		2,
		TEXT("\n\n\n*************************************************************************\n***************************** dwNumberOfRecipients param ********************************")
		);

	Case_SendEx_Zero_dwNumberOfRecipients();
	Case_SendEx_MoreThenSupplied_dwNumberOfRecipients();
	Case_SendEx_LessThenSupplied_dwNumberOfRecipients();
}

//////////////////////////////////////////////////////////////////
//
//RecipientProfileArray parameter
//




void Case_SendEx_NULL_Name_RecipientProfile()
{
	BEGIN_CASE(TEXT("Recipient profile contains a NULL string as the recipient name"));
	
	FSPI_PERSONAL_PROFILE FSPIRecipientInfo;				// The Recipient information sent to FaxDevSendEx()
	//
	//prepare the recipient profile
	//
	PreparePersonalProfile(
		&FSPIRecipientInfo,
		NULL,
		g_szValidRecipientFaxNumber,
		DEFAULT_RECIPIENT_INFO__COMPANY,
		DEFAULT_RECIPIENT_INFO__STREET,
		DEFAULT_RECIPIENT_INFO__CITY,
		DEFAULT_RECIPIENT_INFO__STATE,
		DEFAULT_RECIPIENT_INFO__ZIP,
		DEFAULT_RECIPIENT_INFO__COUNTRY,
		DEFAULT_RECIPIENT_INFO__TITLE,
		DEFAULT_RECIPIENT_INFO__DEPT,
		DEFAULT_RECIPIENT_INFO__OFFICE_LOCATION,
		DEFAULT_RECIPIENT_INFO__HOME_PHONE,
		DEFAULT_RECIPIENT_INFO__OFFICE_PHONE,
		DEFAULT_RECIPIENT_INFO__ORG_MAIL,
		DEFAULT_RECIPIENT_INFO__INTERNET_MAIL,
		DEFAULT_RECIPIENT_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithRecipientProfile(&FSPIRecipientInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}


void Case_SendEx_EmptyString_Name_RecipientProfile()
{
	BEGIN_CASE(TEXT("Recipient profile contains an empty string as the recipient name"))
	
	FSPI_PERSONAL_PROFILE FSPIRecipientInfo;				// The Recipient information sent to FaxDevSendEx()
	//
	//prepare the recipient profile
	//
	PreparePersonalProfile(
		&FSPIRecipientInfo,
		TEXT(""),
		g_szValidRecipientFaxNumber,
		DEFAULT_RECIPIENT_INFO__COMPANY,
		DEFAULT_RECIPIENT_INFO__STREET,
		DEFAULT_RECIPIENT_INFO__CITY,
		DEFAULT_RECIPIENT_INFO__STATE,
		DEFAULT_RECIPIENT_INFO__ZIP,
		DEFAULT_RECIPIENT_INFO__COUNTRY,
		DEFAULT_RECIPIENT_INFO__TITLE,
		DEFAULT_RECIPIENT_INFO__DEPT,
		DEFAULT_RECIPIENT_INFO__OFFICE_LOCATION,
		DEFAULT_RECIPIENT_INFO__HOME_PHONE,
		DEFAULT_RECIPIENT_INFO__OFFICE_PHONE,
		DEFAULT_RECIPIENT_INFO__ORG_MAIL,
		DEFAULT_RECIPIENT_INFO__INTERNET_MAIL,
		DEFAULT_RECIPIENT_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithRecipientProfile(&FSPIRecipientInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}


void Case_SendEx_NULL_FaxNumber_RecipientProfile()
{
	BEGIN_CASE(TEXT("Recipient profile contains a NULL string as the recipient fax number"));
	
	FSPI_PERSONAL_PROFILE FSPIRecipientInfo;				// The Recipient information sent to FaxDevSendEx()
	//
	//prepare the recipient profile
	//
	PreparePersonalProfile(
		&FSPIRecipientInfo,
		DEFAULT_RECIPIENT_INFO__NAME,
		NULL,
		DEFAULT_RECIPIENT_INFO__COMPANY,
		DEFAULT_RECIPIENT_INFO__STREET,
		DEFAULT_RECIPIENT_INFO__CITY,
		DEFAULT_RECIPIENT_INFO__STATE,
		DEFAULT_RECIPIENT_INFO__ZIP,
		DEFAULT_RECIPIENT_INFO__COUNTRY,
		DEFAULT_RECIPIENT_INFO__TITLE,
		DEFAULT_RECIPIENT_INFO__DEPT,
		DEFAULT_RECIPIENT_INFO__OFFICE_LOCATION,
		DEFAULT_RECIPIENT_INFO__HOME_PHONE,
		DEFAULT_RECIPIENT_INFO__OFFICE_PHONE,
		DEFAULT_RECIPIENT_INFO__ORG_MAIL,
		DEFAULT_RECIPIENT_INFO__INTERNET_MAIL,
		DEFAULT_RECIPIENT_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithRecipientProfile(&FSPIRecipientInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sending failed as expected with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending didn't fail")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_EmptyString_FaxNumber_RecipientProfile()
{
	BEGIN_CASE(TEXT("Recipient profile contains an empty string as the recipient Fax Number"))
	
	FSPI_PERSONAL_PROFILE FSPIRecipientInfo;				// The Recipient information sent to FaxDevSendEx()
	//
	//prepare the recipient profile
	//
	PreparePersonalProfile(
		&FSPIRecipientInfo,
		DEFAULT_RECIPIENT_INFO__NAME,
		TEXT(""),
		DEFAULT_RECIPIENT_INFO__COMPANY,
		DEFAULT_RECIPIENT_INFO__STREET,
		DEFAULT_RECIPIENT_INFO__CITY,
		DEFAULT_RECIPIENT_INFO__STATE,
		DEFAULT_RECIPIENT_INFO__ZIP,
		DEFAULT_RECIPIENT_INFO__COUNTRY,
		DEFAULT_RECIPIENT_INFO__TITLE,
		DEFAULT_RECIPIENT_INFO__DEPT,
		DEFAULT_RECIPIENT_INFO__OFFICE_LOCATION,
		DEFAULT_RECIPIENT_INFO__HOME_PHONE,
		DEFAULT_RECIPIENT_INFO__OFFICE_PHONE,
		DEFAULT_RECIPIENT_INFO__ORG_MAIL,
		DEFAULT_RECIPIENT_INFO__INTERNET_MAIL,
		DEFAULT_RECIPIENT_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithRecipientProfile(&FSPIRecipientInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sending failed as expected with error: 0x%08x")
			);
	}
	else
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending didn't fail")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_NULL_Company_RecipientProfile()
{
	BEGIN_CASE(TEXT("Recipient profile contains a NULL string as the recipient Company"));
	
	FSPI_PERSONAL_PROFILE FSPIRecipientInfo;				// The Recipient information sent to FaxDevSendEx()
	//
	//prepare the recipient profile
	//
	PreparePersonalProfile(
		&FSPIRecipientInfo,
		DEFAULT_RECIPIENT_INFO__NAME,
		g_szValidRecipientFaxNumber,
		NULL,
		DEFAULT_RECIPIENT_INFO__STREET,
		DEFAULT_RECIPIENT_INFO__CITY,
		DEFAULT_RECIPIENT_INFO__STATE,
		DEFAULT_RECIPIENT_INFO__ZIP,
		DEFAULT_RECIPIENT_INFO__COUNTRY,
		DEFAULT_RECIPIENT_INFO__TITLE,
		DEFAULT_RECIPIENT_INFO__DEPT,
		DEFAULT_RECIPIENT_INFO__OFFICE_LOCATION,
		DEFAULT_RECIPIENT_INFO__HOME_PHONE,
		DEFAULT_RECIPIENT_INFO__OFFICE_PHONE,
		DEFAULT_RECIPIENT_INFO__ORG_MAIL,
		DEFAULT_RECIPIENT_INFO__INTERNET_MAIL,
		DEFAULT_RECIPIENT_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithRecipientProfile(&FSPIRecipientInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_EmptyString_Company_RecipientProfile()
{
	BEGIN_CASE(TEXT("Recipient profile contains an empty string as the recipient Company"))
	
	FSPI_PERSONAL_PROFILE FSPIRecipientInfo;				// The Recipient information sent to FaxDevSendEx()
	//
	//prepare the recipient profile
	//
	PreparePersonalProfile(
		&FSPIRecipientInfo,
		DEFAULT_RECIPIENT_INFO__NAME,
		g_szValidRecipientFaxNumber,
		TEXT(""),
		DEFAULT_RECIPIENT_INFO__STREET,
		DEFAULT_RECIPIENT_INFO__CITY,
		DEFAULT_RECIPIENT_INFO__STATE,
		DEFAULT_RECIPIENT_INFO__ZIP,
		DEFAULT_RECIPIENT_INFO__COUNTRY,
		DEFAULT_RECIPIENT_INFO__TITLE,
		DEFAULT_RECIPIENT_INFO__DEPT,
		DEFAULT_RECIPIENT_INFO__OFFICE_LOCATION,
		DEFAULT_RECIPIENT_INFO__HOME_PHONE,
		DEFAULT_RECIPIENT_INFO__OFFICE_PHONE,
		DEFAULT_RECIPIENT_INFO__ORG_MAIL,
		DEFAULT_RECIPIENT_INFO__INTERNET_MAIL,
		DEFAULT_RECIPIENT_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithRecipientProfile(&FSPIRecipientInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_NULL_StreetAddress_RecipientProfile()
{
	BEGIN_CASE(TEXT("Recipient profile contains a NULL string as the recipient StreetAddress"));
	
	FSPI_PERSONAL_PROFILE FSPIRecipientInfo;				// The Recipient information sent to FaxDevSendEx()
	//
	//prepare the recipient profile
	//
	PreparePersonalProfile(
		&FSPIRecipientInfo,
		DEFAULT_RECIPIENT_INFO__NAME,
		g_szValidRecipientFaxNumber,
		DEFAULT_RECIPIENT_INFO__COMPANY,
		NULL,
		DEFAULT_RECIPIENT_INFO__CITY,
		DEFAULT_RECIPIENT_INFO__STATE,
		DEFAULT_RECIPIENT_INFO__ZIP,
		DEFAULT_RECIPIENT_INFO__COUNTRY,
		DEFAULT_RECIPIENT_INFO__TITLE,
		DEFAULT_RECIPIENT_INFO__DEPT,
		DEFAULT_RECIPIENT_INFO__OFFICE_LOCATION,
		DEFAULT_RECIPIENT_INFO__HOME_PHONE,
		DEFAULT_RECIPIENT_INFO__OFFICE_PHONE,
		DEFAULT_RECIPIENT_INFO__ORG_MAIL,
		DEFAULT_RECIPIENT_INFO__INTERNET_MAIL,
		DEFAULT_RECIPIENT_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithRecipientProfile(&FSPIRecipientInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_EmptyString_StreetAddress_RecipientProfile()
{
	BEGIN_CASE(TEXT("Recipient profile contains an empty string as the recipient StreetAddress"))
	
	FSPI_PERSONAL_PROFILE FSPIRecipientInfo;				// The Recipient information sent to FaxDevSendEx()
	//
	//prepare the recipient profile
	//
	PreparePersonalProfile(
		&FSPIRecipientInfo,
		DEFAULT_RECIPIENT_INFO__NAME,
		g_szValidRecipientFaxNumber,
		DEFAULT_RECIPIENT_INFO__COMPANY,
		TEXT(""),
		DEFAULT_RECIPIENT_INFO__CITY,
		DEFAULT_RECIPIENT_INFO__STATE,
		DEFAULT_RECIPIENT_INFO__ZIP,
		DEFAULT_RECIPIENT_INFO__COUNTRY,
		DEFAULT_RECIPIENT_INFO__TITLE,
		DEFAULT_RECIPIENT_INFO__DEPT,
		DEFAULT_RECIPIENT_INFO__OFFICE_LOCATION,
		DEFAULT_RECIPIENT_INFO__HOME_PHONE,
		DEFAULT_RECIPIENT_INFO__OFFICE_PHONE,
		DEFAULT_RECIPIENT_INFO__ORG_MAIL,
		DEFAULT_RECIPIENT_INFO__INTERNET_MAIL,
		DEFAULT_RECIPIENT_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithRecipientProfile(&FSPIRecipientInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}



void Case_SendEx_NULL_City_RecipientProfile()
{
	BEGIN_CASE(TEXT("Recipient profile contains a NULL string as the recipient City"));
	
	FSPI_PERSONAL_PROFILE FSPIRecipientInfo;				// The Recipient information sent to FaxDevSendEx()
	//
	//prepare the recipient profile
	//
	PreparePersonalProfile(
		&FSPIRecipientInfo,
		DEFAULT_RECIPIENT_INFO__NAME,
		g_szValidRecipientFaxNumber,
		DEFAULT_RECIPIENT_INFO__COMPANY,
		DEFAULT_RECIPIENT_INFO__STREET,
		NULL,
		DEFAULT_RECIPIENT_INFO__STATE,
		DEFAULT_RECIPIENT_INFO__ZIP,
		DEFAULT_RECIPIENT_INFO__COUNTRY,
		DEFAULT_RECIPIENT_INFO__TITLE,
		DEFAULT_RECIPIENT_INFO__DEPT,
		DEFAULT_RECIPIENT_INFO__OFFICE_LOCATION,
		DEFAULT_RECIPIENT_INFO__HOME_PHONE,
		DEFAULT_RECIPIENT_INFO__OFFICE_PHONE,
		DEFAULT_RECIPIENT_INFO__ORG_MAIL,
		DEFAULT_RECIPIENT_INFO__INTERNET_MAIL,
		DEFAULT_RECIPIENT_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithRecipientProfile(&FSPIRecipientInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_EmptyString_City_RecipientProfile()
{
	BEGIN_CASE(TEXT("Recipient profile contains an empty string as the recipient City"));
	
	FSPI_PERSONAL_PROFILE FSPIRecipientInfo;				// The Recipient information sent to FaxDevSendEx()
	//
	//prepare the recipient profile
	//
	PreparePersonalProfile(
		&FSPIRecipientInfo,
		DEFAULT_RECIPIENT_INFO__NAME,
		g_szValidRecipientFaxNumber,
		DEFAULT_RECIPIENT_INFO__COMPANY,
		DEFAULT_RECIPIENT_INFO__STREET,
		TEXT(""),
		DEFAULT_RECIPIENT_INFO__STATE,
		DEFAULT_RECIPIENT_INFO__ZIP,
		DEFAULT_RECIPIENT_INFO__COUNTRY,
		DEFAULT_RECIPIENT_INFO__TITLE,
		DEFAULT_RECIPIENT_INFO__DEPT,
		DEFAULT_RECIPIENT_INFO__OFFICE_LOCATION,
		DEFAULT_RECIPIENT_INFO__HOME_PHONE,
		DEFAULT_RECIPIENT_INFO__OFFICE_PHONE,
		DEFAULT_RECIPIENT_INFO__ORG_MAIL,
		DEFAULT_RECIPIENT_INFO__INTERNET_MAIL,
		DEFAULT_RECIPIENT_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithRecipientProfile(&FSPIRecipientInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}


void Case_SendEx_NULL_State_RecipientProfile()
{
	BEGIN_CASE(TEXT("Recipient profile contains a NULL string as the recipient State"));
	
	FSPI_PERSONAL_PROFILE FSPIRecipientInfo;				// The Recipient information sent to FaxDevSendEx()
	//
	//prepare the recipient profile
	//
	PreparePersonalProfile(
		&FSPIRecipientInfo,
		DEFAULT_RECIPIENT_INFO__NAME,
		g_szValidRecipientFaxNumber,
		DEFAULT_RECIPIENT_INFO__COMPANY,
		DEFAULT_RECIPIENT_INFO__STREET,
		DEFAULT_RECIPIENT_INFO__CITY,
		NULL,
		DEFAULT_RECIPIENT_INFO__ZIP,
		DEFAULT_RECIPIENT_INFO__COUNTRY,
		DEFAULT_RECIPIENT_INFO__TITLE,
		DEFAULT_RECIPIENT_INFO__DEPT,
		DEFAULT_RECIPIENT_INFO__OFFICE_LOCATION,
		DEFAULT_RECIPIENT_INFO__HOME_PHONE,
		DEFAULT_RECIPIENT_INFO__OFFICE_PHONE,
		DEFAULT_RECIPIENT_INFO__ORG_MAIL,
		DEFAULT_RECIPIENT_INFO__INTERNET_MAIL,
		DEFAULT_RECIPIENT_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithRecipientProfile(&FSPIRecipientInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_EmptyString_State_RecipientProfile()
{
	BEGIN_CASE(TEXT("Recipient profile contains an empty string as the recipient State"));
	
	FSPI_PERSONAL_PROFILE FSPIRecipientInfo;				// The Recipient information sent to FaxDevSendEx()
	//
	//prepare the recipient profile
	//
	PreparePersonalProfile(
		&FSPIRecipientInfo,
		DEFAULT_RECIPIENT_INFO__NAME,
		g_szValidRecipientFaxNumber,
		DEFAULT_RECIPIENT_INFO__COMPANY,
		DEFAULT_RECIPIENT_INFO__STREET,
		DEFAULT_RECIPIENT_INFO__CITY,
		TEXT(""),
		DEFAULT_RECIPIENT_INFO__ZIP,
		DEFAULT_RECIPIENT_INFO__COUNTRY,
		DEFAULT_RECIPIENT_INFO__TITLE,
		DEFAULT_RECIPIENT_INFO__DEPT,
		DEFAULT_RECIPIENT_INFO__OFFICE_LOCATION,
		DEFAULT_RECIPIENT_INFO__HOME_PHONE,
		DEFAULT_RECIPIENT_INFO__OFFICE_PHONE,
		DEFAULT_RECIPIENT_INFO__ORG_MAIL,
		DEFAULT_RECIPIENT_INFO__INTERNET_MAIL,
		DEFAULT_RECIPIENT_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithRecipientProfile(&FSPIRecipientInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_NULL_Zip_RecipientProfile()
{
	BEGIN_CASE(TEXT("Recipient profile contains a NULL string as the recipient Zip"));
	
	FSPI_PERSONAL_PROFILE FSPIRecipientInfo;				// The Recipient information sent to FaxDevSendEx()
	//
	//prepare the recipient profile
	//
	PreparePersonalProfile(
		&FSPIRecipientInfo,
		DEFAULT_RECIPIENT_INFO__NAME,
		g_szValidRecipientFaxNumber,
		DEFAULT_RECIPIENT_INFO__COMPANY,
		DEFAULT_RECIPIENT_INFO__STREET,
		DEFAULT_RECIPIENT_INFO__CITY,
		DEFAULT_RECIPIENT_INFO__STATE,
		NULL,
		DEFAULT_RECIPIENT_INFO__COUNTRY,
		DEFAULT_RECIPIENT_INFO__TITLE,
		DEFAULT_RECIPIENT_INFO__DEPT,
		DEFAULT_RECIPIENT_INFO__OFFICE_LOCATION,
		DEFAULT_RECIPIENT_INFO__HOME_PHONE,
		DEFAULT_RECIPIENT_INFO__OFFICE_PHONE,
		DEFAULT_RECIPIENT_INFO__ORG_MAIL,
		DEFAULT_RECIPIENT_INFO__INTERNET_MAIL,
		DEFAULT_RECIPIENT_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithRecipientProfile(&FSPIRecipientInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_EmptyString_Zip_RecipientProfile()
{
	BEGIN_CASE(TEXT("Recipient profile contains an empty string as the recipient Zip"));
	
	FSPI_PERSONAL_PROFILE FSPIRecipientInfo;				// The Recipient information sent to FaxDevSendEx()
	//
	//prepare the recipient profile
	//
	PreparePersonalProfile(
		&FSPIRecipientInfo,
		DEFAULT_RECIPIENT_INFO__NAME,
		g_szValidRecipientFaxNumber,
		DEFAULT_RECIPIENT_INFO__COMPANY,
		DEFAULT_RECIPIENT_INFO__STREET,
		DEFAULT_RECIPIENT_INFO__CITY,
		DEFAULT_RECIPIENT_INFO__STATE,
		TEXT(""),
		DEFAULT_RECIPIENT_INFO__COUNTRY,
		DEFAULT_RECIPIENT_INFO__TITLE,
		DEFAULT_RECIPIENT_INFO__DEPT,
		DEFAULT_RECIPIENT_INFO__OFFICE_LOCATION,
		DEFAULT_RECIPIENT_INFO__HOME_PHONE,
		DEFAULT_RECIPIENT_INFO__OFFICE_PHONE,
		DEFAULT_RECIPIENT_INFO__ORG_MAIL,
		DEFAULT_RECIPIENT_INFO__INTERNET_MAIL,
		DEFAULT_RECIPIENT_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithRecipientProfile(&FSPIRecipientInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_NULL_Country_RecipientProfile()
{
	BEGIN_CASE(TEXT("Recipient profile contains a NULL string as the recipient Country"));
	
	FSPI_PERSONAL_PROFILE FSPIRecipientInfo;				// The Recipient information sent to FaxDevSendEx()
	//
	//prepare the recipient profile
	//
	PreparePersonalProfile(
		&FSPIRecipientInfo,
		DEFAULT_RECIPIENT_INFO__NAME,
		g_szValidRecipientFaxNumber,
		DEFAULT_RECIPIENT_INFO__COMPANY,
		DEFAULT_RECIPIENT_INFO__STREET,
		DEFAULT_RECIPIENT_INFO__CITY,
		DEFAULT_RECIPIENT_INFO__STATE,
		DEFAULT_RECIPIENT_INFO__ZIP,
		NULL,
		DEFAULT_RECIPIENT_INFO__TITLE,
		DEFAULT_RECIPIENT_INFO__DEPT,
		DEFAULT_RECIPIENT_INFO__OFFICE_LOCATION,
		DEFAULT_RECIPIENT_INFO__HOME_PHONE,
		DEFAULT_RECIPIENT_INFO__OFFICE_PHONE,
		DEFAULT_RECIPIENT_INFO__ORG_MAIL,
		DEFAULT_RECIPIENT_INFO__INTERNET_MAIL,
		DEFAULT_RECIPIENT_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithRecipientProfile(&FSPIRecipientInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_EmptyString_Country_RecipientProfile()
{
	BEGIN_CASE(TEXT("Recipient profile contains an empty string as the recipient Country"));
	
	FSPI_PERSONAL_PROFILE FSPIRecipientInfo;				// The Recipient information sent to FaxDevSendEx()
	//
	//prepare the recipient profile
	//
	PreparePersonalProfile(
		&FSPIRecipientInfo,
		DEFAULT_RECIPIENT_INFO__NAME,
		g_szValidRecipientFaxNumber,
		DEFAULT_RECIPIENT_INFO__COMPANY,
		DEFAULT_RECIPIENT_INFO__STREET,
		DEFAULT_RECIPIENT_INFO__CITY,
		DEFAULT_RECIPIENT_INFO__STATE,
		DEFAULT_RECIPIENT_INFO__ZIP,
		TEXT(""),
		DEFAULT_RECIPIENT_INFO__TITLE,
		DEFAULT_RECIPIENT_INFO__DEPT,
		DEFAULT_RECIPIENT_INFO__OFFICE_LOCATION,
		DEFAULT_RECIPIENT_INFO__HOME_PHONE,
		DEFAULT_RECIPIENT_INFO__OFFICE_PHONE,
		DEFAULT_RECIPIENT_INFO__ORG_MAIL,
		DEFAULT_RECIPIENT_INFO__INTERNET_MAIL,
		DEFAULT_RECIPIENT_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithRecipientProfile(&FSPIRecipientInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_NULL_Title_RecipientProfile()
{
	BEGIN_CASE(TEXT("Recipient profile contains a NULL string as the recipient Title"));
	
	FSPI_PERSONAL_PROFILE FSPIRecipientInfo;				// The Recipient information sent to FaxDevSendEx()
	//
	//prepare the recipient profile
	//
	PreparePersonalProfile(
		&FSPIRecipientInfo,
		DEFAULT_RECIPIENT_INFO__NAME,
		g_szValidRecipientFaxNumber,
		DEFAULT_RECIPIENT_INFO__COMPANY,
		DEFAULT_RECIPIENT_INFO__STREET,
		DEFAULT_RECIPIENT_INFO__CITY,
		DEFAULT_RECIPIENT_INFO__STATE,
		DEFAULT_RECIPIENT_INFO__ZIP,
		DEFAULT_RECIPIENT_INFO__COUNTRY,
		NULL,
		DEFAULT_RECIPIENT_INFO__DEPT,
		DEFAULT_RECIPIENT_INFO__OFFICE_LOCATION,
		DEFAULT_RECIPIENT_INFO__HOME_PHONE,
		DEFAULT_RECIPIENT_INFO__OFFICE_PHONE,
		DEFAULT_RECIPIENT_INFO__ORG_MAIL,
		DEFAULT_RECIPIENT_INFO__INTERNET_MAIL,
		DEFAULT_RECIPIENT_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithRecipientProfile(&FSPIRecipientInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_EmptyString_Title_RecipientProfile()
{
	BEGIN_CASE(TEXT("Recipient profile contains an empty string as the recipient Title"));
	
	FSPI_PERSONAL_PROFILE FSPIRecipientInfo;				// The Recipient information sent to FaxDevSendEx()
	//
	//prepare the recipient profile
	//
	PreparePersonalProfile(
		&FSPIRecipientInfo,
		DEFAULT_RECIPIENT_INFO__NAME,
		g_szValidRecipientFaxNumber,
		DEFAULT_RECIPIENT_INFO__COMPANY,
		DEFAULT_RECIPIENT_INFO__STREET,
		DEFAULT_RECIPIENT_INFO__CITY,
		DEFAULT_RECIPIENT_INFO__STATE,
		DEFAULT_RECIPIENT_INFO__ZIP,
		DEFAULT_RECIPIENT_INFO__COUNTRY,
		TEXT(""),
		DEFAULT_RECIPIENT_INFO__DEPT,
		DEFAULT_RECIPIENT_INFO__OFFICE_LOCATION,
		DEFAULT_RECIPIENT_INFO__HOME_PHONE,
		DEFAULT_RECIPIENT_INFO__OFFICE_PHONE,
		DEFAULT_RECIPIENT_INFO__ORG_MAIL,
		DEFAULT_RECIPIENT_INFO__INTERNET_MAIL,
		DEFAULT_RECIPIENT_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithRecipientProfile(&FSPIRecipientInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_NULL_Department_RecipientProfile()
{
	BEGIN_CASE(TEXT("Recipient profile contains a NULL string as the recipient Department"));
	
	FSPI_PERSONAL_PROFILE FSPIRecipientInfo;				// The Recipient information sent to FaxDevSendEx()
	//
	//prepare the recipient profile
	//
	PreparePersonalProfile(
		&FSPIRecipientInfo,
		DEFAULT_RECIPIENT_INFO__NAME,
		g_szValidRecipientFaxNumber,
		DEFAULT_RECIPIENT_INFO__COMPANY,
		DEFAULT_RECIPIENT_INFO__STREET,
		DEFAULT_RECIPIENT_INFO__CITY,
		DEFAULT_RECIPIENT_INFO__STATE,
		DEFAULT_RECIPIENT_INFO__ZIP,
		DEFAULT_RECIPIENT_INFO__COUNTRY,
		DEFAULT_RECIPIENT_INFO__TITLE,
		NULL,
		DEFAULT_RECIPIENT_INFO__OFFICE_LOCATION,
		DEFAULT_RECIPIENT_INFO__HOME_PHONE,
		DEFAULT_RECIPIENT_INFO__OFFICE_PHONE,
		DEFAULT_RECIPIENT_INFO__ORG_MAIL,
		DEFAULT_RECIPIENT_INFO__INTERNET_MAIL,
		DEFAULT_RECIPIENT_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithRecipientProfile(&FSPIRecipientInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_EmptyString_Department_RecipientProfile()
{
	BEGIN_CASE(TEXT("Recipient profile contains an empty string as the recipient Department"))
	
	FSPI_PERSONAL_PROFILE FSPIRecipientInfo;				// The Recipient information sent to FaxDevSendEx()
	//
	//prepare the recipient profile
	//
	PreparePersonalProfile(
		&FSPIRecipientInfo,
		DEFAULT_RECIPIENT_INFO__NAME,
		g_szValidRecipientFaxNumber,
		DEFAULT_RECIPIENT_INFO__COMPANY,
		DEFAULT_RECIPIENT_INFO__STREET,
		DEFAULT_RECIPIENT_INFO__CITY,
		DEFAULT_RECIPIENT_INFO__STATE,
		DEFAULT_RECIPIENT_INFO__ZIP,
		DEFAULT_RECIPIENT_INFO__COUNTRY,
		DEFAULT_RECIPIENT_INFO__TITLE,
		TEXT(""),
		DEFAULT_RECIPIENT_INFO__OFFICE_LOCATION,
		DEFAULT_RECIPIENT_INFO__HOME_PHONE,
		DEFAULT_RECIPIENT_INFO__OFFICE_PHONE,
		DEFAULT_RECIPIENT_INFO__ORG_MAIL,
		DEFAULT_RECIPIENT_INFO__INTERNET_MAIL,
		DEFAULT_RECIPIENT_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithRecipientProfile(&FSPIRecipientInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}
void Case_SendEx_NULL_OfficeLocation_RecipientProfile()
{
	BEGIN_CASE(TEXT("Recipient profile contains a NULL string as the recipient OfficeLocation"));
	
	FSPI_PERSONAL_PROFILE FSPIRecipientInfo;				// The Recipient information sent to FaxDevSendEx()
	//
	//prepare the recipient profile
	//
	PreparePersonalProfile(
		&FSPIRecipientInfo,
		DEFAULT_RECIPIENT_INFO__NAME,
		g_szValidRecipientFaxNumber,
		DEFAULT_RECIPIENT_INFO__COMPANY,
		DEFAULT_RECIPIENT_INFO__STREET,
		DEFAULT_RECIPIENT_INFO__CITY,
		DEFAULT_RECIPIENT_INFO__STATE,
		DEFAULT_RECIPIENT_INFO__ZIP,
		DEFAULT_RECIPIENT_INFO__COUNTRY,
		DEFAULT_RECIPIENT_INFO__TITLE,
		DEFAULT_RECIPIENT_INFO__DEPT,
		NULL,
		DEFAULT_RECIPIENT_INFO__HOME_PHONE,
		DEFAULT_RECIPIENT_INFO__OFFICE_PHONE,
		DEFAULT_RECIPIENT_INFO__ORG_MAIL,
		DEFAULT_RECIPIENT_INFO__INTERNET_MAIL,
		DEFAULT_RECIPIENT_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithRecipientProfile(&FSPIRecipientInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_EmptyString_OfficeLocation_RecipientProfile()
{
	BEGIN_CASE(TEXT("Recipient profile contains an empty string as the recipient OfficeLocation"));
	
	FSPI_PERSONAL_PROFILE FSPIRecipientInfo;				// The Recipient information sent to FaxDevSendEx()
	//
	//prepare the recipient profile
	//
	PreparePersonalProfile(
		&FSPIRecipientInfo,
		DEFAULT_RECIPIENT_INFO__NAME,
		g_szValidRecipientFaxNumber,
		DEFAULT_RECIPIENT_INFO__COMPANY,
		DEFAULT_RECIPIENT_INFO__STREET,
		DEFAULT_RECIPIENT_INFO__CITY,
		DEFAULT_RECIPIENT_INFO__STATE,
		DEFAULT_RECIPIENT_INFO__ZIP,
		DEFAULT_RECIPIENT_INFO__COUNTRY,
		DEFAULT_RECIPIENT_INFO__TITLE,
		DEFAULT_RECIPIENT_INFO__DEPT,
		TEXT(""),
		DEFAULT_RECIPIENT_INFO__HOME_PHONE,
		DEFAULT_RECIPIENT_INFO__OFFICE_PHONE,
		DEFAULT_RECIPIENT_INFO__ORG_MAIL,
		DEFAULT_RECIPIENT_INFO__INTERNET_MAIL,
		DEFAULT_RECIPIENT_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithRecipientProfile(&FSPIRecipientInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_NULL_HomePhone_RecipientProfile()
{
	BEGIN_CASE(TEXT("Recipient profile contains a NULL string as the recipient HomePhone"));
	
	FSPI_PERSONAL_PROFILE FSPIRecipientInfo;				// The Recipient information sent to FaxDevSendEx()
	//
	//prepare the recipient profile
	//
	PreparePersonalProfile(
		&FSPIRecipientInfo,
		DEFAULT_RECIPIENT_INFO__NAME,
		g_szValidRecipientFaxNumber,
		DEFAULT_RECIPIENT_INFO__COMPANY,
		DEFAULT_RECIPIENT_INFO__STREET,
		DEFAULT_RECIPIENT_INFO__CITY,
		DEFAULT_RECIPIENT_INFO__STATE,
		DEFAULT_RECIPIENT_INFO__ZIP,
		DEFAULT_RECIPIENT_INFO__COUNTRY,
		DEFAULT_RECIPIENT_INFO__TITLE,
		DEFAULT_RECIPIENT_INFO__DEPT,
		NULL,
		DEFAULT_RECIPIENT_INFO__HOME_PHONE,
		DEFAULT_RECIPIENT_INFO__OFFICE_PHONE,
		DEFAULT_RECIPIENT_INFO__ORG_MAIL,
		DEFAULT_RECIPIENT_INFO__INTERNET_MAIL,
		DEFAULT_RECIPIENT_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithRecipientProfile(&FSPIRecipientInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_EmptyString_HomePhone_RecipientProfile()
{
	BEGIN_CASE(TEXT("Recipient profile contains an empty string as the recipient HomePhone"));
	
	FSPI_PERSONAL_PROFILE FSPIRecipientInfo;				// The Recipient information sent to FaxDevSendEx()
	//
	//prepare the recipient profile
	//
	PreparePersonalProfile(
		&FSPIRecipientInfo,
		DEFAULT_RECIPIENT_INFO__NAME,
		g_szValidRecipientFaxNumber,
		DEFAULT_RECIPIENT_INFO__COMPANY,
		DEFAULT_RECIPIENT_INFO__STREET,
		DEFAULT_RECIPIENT_INFO__CITY,
		DEFAULT_RECIPIENT_INFO__STATE,
		DEFAULT_RECIPIENT_INFO__ZIP,
		DEFAULT_RECIPIENT_INFO__COUNTRY,
		DEFAULT_RECIPIENT_INFO__TITLE,
		DEFAULT_RECIPIENT_INFO__DEPT,
		TEXT(""),
		DEFAULT_RECIPIENT_INFO__HOME_PHONE,
		DEFAULT_RECIPIENT_INFO__OFFICE_PHONE,
		DEFAULT_RECIPIENT_INFO__ORG_MAIL,
		DEFAULT_RECIPIENT_INFO__INTERNET_MAIL,
		DEFAULT_RECIPIENT_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithRecipientProfile(&FSPIRecipientInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_NULL_OfficePhone_RecipientProfile()
{
	BEGIN_CASE(TEXT("Recipient profile contains a NULL string as the recipient OfficePhone"));
	
	FSPI_PERSONAL_PROFILE FSPIRecipientInfo;				// The Recipient information sent to FaxDevSendEx()
	//
	//prepare the recipient profile
	//
	PreparePersonalProfile(
		&FSPIRecipientInfo,
		DEFAULT_RECIPIENT_INFO__NAME,
		g_szValidRecipientFaxNumber,
		DEFAULT_RECIPIENT_INFO__COMPANY,
		DEFAULT_RECIPIENT_INFO__STREET,
		DEFAULT_RECIPIENT_INFO__CITY,
		DEFAULT_RECIPIENT_INFO__STATE,
		DEFAULT_RECIPIENT_INFO__ZIP,
		DEFAULT_RECIPIENT_INFO__COUNTRY,
		DEFAULT_RECIPIENT_INFO__TITLE,
		DEFAULT_RECIPIENT_INFO__DEPT,
		DEFAULT_RECIPIENT_INFO__OFFICE_LOCATION,
		DEFAULT_RECIPIENT_INFO__HOME_PHONE,
		NULL,
		DEFAULT_RECIPIENT_INFO__ORG_MAIL,
		DEFAULT_RECIPIENT_INFO__INTERNET_MAIL,
		DEFAULT_RECIPIENT_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithRecipientProfile(&FSPIRecipientInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_EmptyString_OfficePhone_RecipientProfile()
{
	BEGIN_CASE(TEXT("Recipient profile contains an empty string as the recipient OfficePhone"))
	
	FSPI_PERSONAL_PROFILE FSPIRecipientInfo;				// The Recipient information sent to FaxDevSendEx()
	//
	//prepare the recipient profile
	//
	PreparePersonalProfile(
		&FSPIRecipientInfo,
		DEFAULT_RECIPIENT_INFO__NAME,
		g_szValidRecipientFaxNumber,
		DEFAULT_RECIPIENT_INFO__COMPANY,
		DEFAULT_RECIPIENT_INFO__STREET,
		DEFAULT_RECIPIENT_INFO__CITY,
		DEFAULT_RECIPIENT_INFO__STATE,
		DEFAULT_RECIPIENT_INFO__ZIP,
		DEFAULT_RECIPIENT_INFO__COUNTRY,
		DEFAULT_RECIPIENT_INFO__TITLE,
		DEFAULT_RECIPIENT_INFO__DEPT,
		DEFAULT_RECIPIENT_INFO__OFFICE_LOCATION,
		DEFAULT_RECIPIENT_INFO__HOME_PHONE,
		TEXT(""),
		DEFAULT_RECIPIENT_INFO__ORG_MAIL,
		DEFAULT_RECIPIENT_INFO__INTERNET_MAIL,
		DEFAULT_RECIPIENT_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithRecipientProfile(&FSPIRecipientInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_NULL_OrganizationalMail_RecipientProfile()
{
	BEGIN_CASE(TEXT("Recipient profile contains a NULL string as the recipient OrganizationalMail"));
	
	FSPI_PERSONAL_PROFILE FSPIRecipientInfo;				// The Recipient information sent to FaxDevSendEx()
	//
	//prepare the recipient profile
	//
	PreparePersonalProfile(
		&FSPIRecipientInfo,
		DEFAULT_RECIPIENT_INFO__NAME,
		g_szValidRecipientFaxNumber,
		DEFAULT_RECIPIENT_INFO__COMPANY,
		DEFAULT_RECIPIENT_INFO__STREET,
		DEFAULT_RECIPIENT_INFO__CITY,
		DEFAULT_RECIPIENT_INFO__STATE,
		DEFAULT_RECIPIENT_INFO__ZIP,
		DEFAULT_RECIPIENT_INFO__COUNTRY,
		DEFAULT_RECIPIENT_INFO__TITLE,
		DEFAULT_RECIPIENT_INFO__DEPT,
		DEFAULT_RECIPIENT_INFO__OFFICE_LOCATION,
		DEFAULT_RECIPIENT_INFO__HOME_PHONE,
		DEFAULT_RECIPIENT_INFO__OFFICE_PHONE,
		NULL,
		DEFAULT_RECIPIENT_INFO__INTERNET_MAIL,
		DEFAULT_RECIPIENT_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithRecipientProfile(&FSPIRecipientInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_EmptyString_OrganizationalMail_RecipientProfile()
{
	BEGIN_CASE(TEXT("Recipient profile contains an empty string as the recipient OrganizationalMail"))
	
	FSPI_PERSONAL_PROFILE FSPIRecipientInfo;				// The Recipient information sent to FaxDevSendEx()
	//
	//prepare the recipient profile
	//
	PreparePersonalProfile(
		&FSPIRecipientInfo,
		DEFAULT_RECIPIENT_INFO__NAME,
		g_szValidRecipientFaxNumber,
		DEFAULT_RECIPIENT_INFO__COMPANY,
		DEFAULT_RECIPIENT_INFO__STREET,
		DEFAULT_RECIPIENT_INFO__CITY,
		DEFAULT_RECIPIENT_INFO__STATE,
		DEFAULT_RECIPIENT_INFO__ZIP,
		DEFAULT_RECIPIENT_INFO__COUNTRY,
		DEFAULT_RECIPIENT_INFO__TITLE,
		DEFAULT_RECIPIENT_INFO__DEPT,
		DEFAULT_RECIPIENT_INFO__OFFICE_LOCATION,
		DEFAULT_RECIPIENT_INFO__HOME_PHONE,
		DEFAULT_RECIPIENT_INFO__OFFICE_PHONE,
		TEXT(""),
		DEFAULT_RECIPIENT_INFO__INTERNET_MAIL,
		DEFAULT_RECIPIENT_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithRecipientProfile(&FSPIRecipientInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_NULL_InternetMail_RecipientProfile()
{
	BEGIN_CASE(TEXT("Recipient profile contains a NULL string as the recipient InternetMail"));
	
	FSPI_PERSONAL_PROFILE FSPIRecipientInfo;				// The Recipient information sent to FaxDevSendEx()
	//
	//prepare the recipient profile
	//
	PreparePersonalProfile(
		&FSPIRecipientInfo,
		DEFAULT_RECIPIENT_INFO__NAME,
		g_szValidRecipientFaxNumber,
		DEFAULT_RECIPIENT_INFO__COMPANY,
		DEFAULT_RECIPIENT_INFO__STREET,
		DEFAULT_RECIPIENT_INFO__CITY,
		DEFAULT_RECIPIENT_INFO__STATE,
		DEFAULT_RECIPIENT_INFO__ZIP,
		DEFAULT_RECIPIENT_INFO__COUNTRY,
		DEFAULT_RECIPIENT_INFO__TITLE,
		DEFAULT_RECIPIENT_INFO__DEPT,
		DEFAULT_RECIPIENT_INFO__OFFICE_LOCATION,
		DEFAULT_RECIPIENT_INFO__HOME_PHONE,
		DEFAULT_RECIPIENT_INFO__OFFICE_PHONE,
		DEFAULT_RECIPIENT_INFO__ORG_MAIL,
		NULL,
		DEFAULT_RECIPIENT_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithRecipientProfile(&FSPIRecipientInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_EmptyString_InternetMail_RecipientProfile()
{
	BEGIN_CASE(TEXT("Recipient profile contains an empty string as the recipient InternetMail"));
	
	FSPI_PERSONAL_PROFILE FSPIRecipientInfo;				// The Recipient information sent to FaxDevSendEx()
	//
	//prepare the recipient profile
	//
	PreparePersonalProfile(
		&FSPIRecipientInfo,
		DEFAULT_RECIPIENT_INFO__NAME,
		g_szValidRecipientFaxNumber,
		DEFAULT_RECIPIENT_INFO__COMPANY,
		DEFAULT_RECIPIENT_INFO__STREET,
		DEFAULT_RECIPIENT_INFO__CITY,
		DEFAULT_RECIPIENT_INFO__STATE,
		DEFAULT_RECIPIENT_INFO__ZIP,
		DEFAULT_RECIPIENT_INFO__COUNTRY,
		DEFAULT_RECIPIENT_INFO__TITLE,
		DEFAULT_RECIPIENT_INFO__DEPT,
		DEFAULT_RECIPIENT_INFO__OFFICE_LOCATION,
		DEFAULT_RECIPIENT_INFO__HOME_PHONE,
		DEFAULT_RECIPIENT_INFO__OFFICE_PHONE,
		DEFAULT_RECIPIENT_INFO__ORG_MAIL,
		TEXT(""),
		DEFAULT_RECIPIENT_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithRecipientProfile(&FSPIRecipientInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_NULL_BillingCode_RecipientProfile()
{
	BEGIN_CASE(TEXT("Recipient profile contains a NULL string as the recipient BillingCode"));
	
	FSPI_PERSONAL_PROFILE FSPIRecipientInfo;				// The Recipient information sent to FaxDevSendEx()
	//
	//prepare the recipient profile
	//
	PreparePersonalProfile(
		&FSPIRecipientInfo,
		DEFAULT_RECIPIENT_INFO__NAME,
		g_szValidRecipientFaxNumber,
		DEFAULT_RECIPIENT_INFO__COMPANY,
		DEFAULT_RECIPIENT_INFO__STREET,
		DEFAULT_RECIPIENT_INFO__CITY,
		DEFAULT_RECIPIENT_INFO__STATE,
		DEFAULT_RECIPIENT_INFO__ZIP,
		DEFAULT_RECIPIENT_INFO__COUNTRY,
		DEFAULT_RECIPIENT_INFO__TITLE,
		DEFAULT_RECIPIENT_INFO__DEPT,
		DEFAULT_RECIPIENT_INFO__OFFICE_LOCATION,
		DEFAULT_RECIPIENT_INFO__HOME_PHONE,
		DEFAULT_RECIPIENT_INFO__OFFICE_PHONE,
		DEFAULT_RECIPIENT_INFO__ORG_MAIL,
		DEFAULT_RECIPIENT_INFO__INTERNET_MAIL,
		NULL
		);


	HRESULT hr = SendDefaultFaxWithRecipientProfile(&FSPIRecipientInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_EmptyString_BillingCode_RecipientProfile()
{
	BEGIN_CASE(TEXT("Recipient profile contains an empty string as the recipient BillingCode"));
	
	FSPI_PERSONAL_PROFILE FSPIRecipientInfo;				// The Recipient information sent to FaxDevSendEx()
	//
	//prepare the recipient profile
	//
	PreparePersonalProfile(
		&FSPIRecipientInfo,
		DEFAULT_RECIPIENT_INFO__NAME,
		g_szValidRecipientFaxNumber,
		DEFAULT_RECIPIENT_INFO__COMPANY,
		DEFAULT_RECIPIENT_INFO__STREET,
		DEFAULT_RECIPIENT_INFO__CITY,
		DEFAULT_RECIPIENT_INFO__STATE,
		DEFAULT_RECIPIENT_INFO__ZIP,
		DEFAULT_RECIPIENT_INFO__COUNTRY,
		DEFAULT_RECIPIENT_INFO__TITLE,
		DEFAULT_RECIPIENT_INFO__DEPT,
		DEFAULT_RECIPIENT_INFO__OFFICE_LOCATION,
		DEFAULT_RECIPIENT_INFO__HOME_PHONE,
		DEFAULT_RECIPIENT_INFO__OFFICE_PHONE,
		DEFAULT_RECIPIENT_INFO__OFFICE_PHONE,
		DEFAULT_RECIPIENT_INFO__INTERNET_MAIL,
		TEXT("")
		);


	HRESULT hr = SendDefaultFaxWithRecipientProfile(&FSPIRecipientInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_NULL_RecipientProfile()
{
	BEGIN_CASE(TEXT("Recipient profile is a NULL pointer"));
	
	HRESULT hr = SendDefaultFaxWithRecipientProfile(NULL);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sending failed as expected with error code:0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("Fax Sent Successfully, without a recipient profile")
			);
	}
	::lgEndCase();
}

void Case_SendEx_InvalidPhoneNumber_RecipientProfile()
{
	BEGIN_CASE(TEXT("Recipient has an invalid phone number"));
	
	FSPI_PERSONAL_PROFILE FSPIRecipientInfo;				// The Recipient information sent to FaxDevSendEx()
	//
	//prepare the recipient profile
	//
	PreparePersonalProfile(
		&FSPIRecipientInfo,
		DEFAULT_RECIPIENT_INFO__NAME,
		g_szInvalidRecipientFaxNumber,
		DEFAULT_RECIPIENT_INFO__COMPANY,
		DEFAULT_RECIPIENT_INFO__STREET,
		DEFAULT_RECIPIENT_INFO__CITY,
		DEFAULT_RECIPIENT_INFO__STATE,
		DEFAULT_RECIPIENT_INFO__ZIP,
		DEFAULT_RECIPIENT_INFO__COUNTRY,
		DEFAULT_RECIPIENT_INFO__TITLE,
		DEFAULT_RECIPIENT_INFO__DEPT,
		DEFAULT_RECIPIENT_INFO__OFFICE_LOCATION,
		DEFAULT_RECIPIENT_INFO__HOME_PHONE,
		DEFAULT_RECIPIENT_INFO__OFFICE_PHONE,
		DEFAULT_RECIPIENT_INFO__OFFICE_PHONE,
		DEFAULT_RECIPIENT_INFO__INTERNET_MAIL,
		DEFAULT_RECIPIENT_INFO__BILLING_CODE
		);


	HRESULT hr = SendDefaultFaxWithRecipientProfile(&FSPIRecipientInfo);     //This will also Abort and End the send job
	if (S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("Fax Sending failed with error: 0x%08x"),
			hr
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sent Successfully")
			);
	}
	
	::lgEndCase();
}



void Case_SendEx_RecipientProfileArray()
{
	lgLogDetail(
		LOG_X,
		2,
		TEXT("\n\n\n*************************************************************************\n***************************** RecipientProfileArray param ********************************")
		);

	
	Case_SendEx_InvalidPhoneNumber_RecipientProfile();

	Case_SendEx_NULL_RecipientProfile();
	
	Case_SendEx_NULL_Name_RecipientProfile();
	Case_SendEx_EmptyString_Name_RecipientProfile();
	
	Case_SendEx_NULL_FaxNumber_RecipientProfile();
	Case_SendEx_EmptyString_FaxNumber_RecipientProfile();
	
	Case_SendEx_NULL_Company_RecipientProfile();
	Case_SendEx_EmptyString_Company_RecipientProfile();
	
	Case_SendEx_NULL_StreetAddress_RecipientProfile();
	Case_SendEx_EmptyString_StreetAddress_RecipientProfile();
	
	Case_SendEx_NULL_City_RecipientProfile();
	Case_SendEx_EmptyString_City_RecipientProfile();

	Case_SendEx_NULL_State_RecipientProfile();
	Case_SendEx_EmptyString_State_RecipientProfile();

	Case_SendEx_NULL_Zip_RecipientProfile();
	Case_SendEx_EmptyString_Zip_RecipientProfile();

	Case_SendEx_NULL_Country_RecipientProfile();
	Case_SendEx_EmptyString_Country_RecipientProfile();

	Case_SendEx_NULL_Title_RecipientProfile();
	Case_SendEx_EmptyString_Title_RecipientProfile();

	Case_SendEx_NULL_Department_RecipientProfile();
	Case_SendEx_EmptyString_Department_RecipientProfile();

	Case_SendEx_NULL_OfficeLocation_RecipientProfile();
	Case_SendEx_EmptyString_OfficeLocation_RecipientProfile();

	Case_SendEx_NULL_HomePhone_RecipientProfile();
	Case_SendEx_EmptyString_HomePhone_RecipientProfile();

	Case_SendEx_NULL_OfficePhone_RecipientProfile();
	Case_SendEx_EmptyString_OfficePhone_RecipientProfile();

	Case_SendEx_NULL_OrganizationalMail_RecipientProfile();
	Case_SendEx_EmptyString_OrganizationalMail_RecipientProfile();

	Case_SendEx_NULL_InternetMail_RecipientProfile();
	Case_SendEx_EmptyString_InternetMail_RecipientProfile();

	Case_SendEx_NULL_BillingCode_RecipientProfile();
	Case_SendEx_EmptyString_BillingCode_RecipientProfile();

}

//////////////////////////////////////////////////////////////////
//
//RecipientMessageIdArray parameter
//

void Case_SendEx_NULL_RecipientMessageIdArray(bool bIsReestablishEFSP)
{
	BEGIN_CASE(TEXT("Message ID array is a NULL pointer"));

	LPFSPI_MESSAGE_ID lpRecipientMessageIds = NULL;

	//
	// Allocate and initialize the recipients permanent message ids array
	//
	HRESULT hr = CreateFSPIRecipientMessageIdsArray(
		&lpRecipientMessageIds,
		1,
		g_pEFSP->m_dwMaxMessageIdSize
		);
	if (S_OK != hr)
	{
		lpRecipientMessageIds = NULL;
		::lgLogError(
			LOG_SEV_1, 
			TEXT("CreateFSPIRecipientMessageIdsArray() failed. (ec: %ld)"),
			GetLastError()
			);
		goto out;
	}
	
	hr = SendDefaultFaxWithMessageIdArray(NULL);     //This will also Abort and End the send job
	if (true == bIsReestablishEFSP)
	{
		//
		//EFSP Supports job reestablishment, so this should fail
		//
		if (FSPI_E_FAILED == hr)
		{
			//
			//good, this is what we want
			//
			::lgLogDetail(
				LOG_PASS,
				2,
				TEXT("Fax Sending failed as expected with error code:FSPI_E_FAILED")
				);
		}
		else
		{
			//
			//No good, what happen? did it succeeded or fail with another error?
			//
			if (FSPI_S_OK == hr)
			{
				//
				//Success is bad in this case
				//
				::lgLogError(
					LOG_SEV_1,
					TEXT("Fax Sent Successfully, without a proper RecipientMessageIdArray")
					);
				//
				//The sending operation is aborted in the call to SendDefaultFaxWithMessageIdArray()
				//
			}
			else
			{
				//
				//other error
				//
				::lgLogError(
					LOG_SEV_1,
					TEXT("failed with an unexpected error:0x%08x"),
					hr
					);
			}
		}
	}
	else
	{
		//
		//Non reestablishing EFSP
		//
		if (FSPI_S_OK == hr)
		{
			::lgLogDetail(
				LOG_PASS,
				2,
				TEXT("Fax Sending succeeded on a non reestablishing EFSP")
				);
		}
		else
		{
			::lgLogError(
				LOG_SEV_1,
				TEXT("Fax Send Failure, error code:0x%08x"),
				hr
				);
		}
	}
out:
	::lgEndCase();
}




void Case_SendEx_Item_wrongSizeOfStruct_RecipientMessageIdArray(bool bIsReestablishEFSP)
{
	BEGIN_CASE(TEXT("Message ID dwSizeOfStruct is 0"));

	LPFSPI_MESSAGE_ID lpRecipientMessageIds = NULL;
	HRESULT hr = S_OK;

	if (false == bIsReestablishEFSP)
	{
		::lgLogDetail(
			LOG_X,
			5,
			TEXT("Efsp is a non re-establishing EFSP, quitting this test")
			);
		goto out;
	}

	//
	// Allocate and initialize the recipients permanent message ids array
	//
	hr = CreateFSPIRecipientMessageIdsArray(
		&lpRecipientMessageIds,
		1,
		g_pEFSP->m_dwMaxMessageIdSize
		);
	if (S_OK != hr)
	{
		lpRecipientMessageIds = NULL;
		::lgLogError(
			LOG_SEV_1, 
			TEXT("CreateFSPIRecipientMessageIdsArray() failed. (ec: %ld)"),
			GetLastError()
			);
		goto out;
	}
	lpRecipientMessageIds[0].dwSizeOfStruct=0;
	
	hr = SendDefaultFaxWithMessageIdArray(lpRecipientMessageIds);     //This will also Abort and End the send job
	//
	//EFSP Supports job reestablishment, so this should fail
	//
	if (FSPI_E_FAILED == hr)
	{
		//
		//good, this is what we want
		//
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sending failed as expected with error code:FSPI_E_FAILED")
			);
	}
	else
	{
		//
		//No good, what happen? did it succeeded or fail with another error?
		//
		if (FSPI_S_OK == hr)
		{
			//
			//Success is bad in this case
			//
			::lgLogError(
				LOG_SEV_1,
				TEXT("Fax Sent Successfully, without a proper RecipientMessageIdArray")
				);
		}
		else
		{
			//
			//other error
			//
			::lgLogError(
				LOG_SEV_1,
				TEXT("failed with an unexpected error:0x%08x"),
				hr
				);
		}
	}
	
out:
	::lgEndCase();
}




void Case_SendEx_Item_ZeroSizeOfMessageId_RecipientMessageIdArray(bool bIsReestablishEFSP)
{
	BEGIN_CASE(TEXT("Message ID dwIdSize is 0 and not the same as given in FaxDevInitEx()"));

	LPFSPI_MESSAGE_ID lpRecipientMessageIds = NULL;
	HRESULT hr = S_OK;
	
	if (false == bIsReestablishEFSP)
	{
		::lgLogDetail(
			LOG_X,
			5,
			TEXT("Efsp is a non re-establishing EFSP, quitting this test")
			);
		goto out;
	}

	//
	// Allocate and initialize the recipients permanent message ids array
	//
	hr = CreateFSPIRecipientMessageIdsArray(
		&lpRecipientMessageIds,
		1,
		g_pEFSP->m_dwMaxMessageIdSize
		);
	if (S_OK != hr)
	{
		lpRecipientMessageIds = NULL;
		::lgLogError(
			LOG_SEV_1, 
			TEXT("CreateFSPIRecipientMessageIdsArray() failed. (ec: %ld)"),
			GetLastError()
			);
		goto out;
	}
	lpRecipientMessageIds[0].dwIdSize = 0;
	
	hr = SendDefaultFaxWithMessageIdArray(lpRecipientMessageIds);     //This will also Abort and End the send job
	
	//
	//EFSP Supports job reestablishment, so this should fail
	//
	if (FSPI_E_FAILED == hr)
	{
		//
		//good, this is what we want
		//
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sending failed as expected with error code:FSPI_E_FAILED")
			);
	}
	else
	{
		//
		//No good, what happen? did it succeeded or fail with another error?
		//
		if (FSPI_S_OK == hr)
		{
			//
			//Success is bad in this case
			//
			::lgLogError(
				LOG_SEV_1,
				TEXT("Fax Sent Successfully, without a proper RecipientMessageIdArray")
				);
		}
		else
		{
			//
			//other error
			//
			::lgLogError(
				LOG_SEV_1,
				TEXT("failed with an unexpected error:0x%08x"),
				hr
				);
		}
	}
	
out:
	::lgEndCase();
}


void Case_SendEx_Item_wrongSizeOfMessageId_RecipientMessageIdArray(bool bIsReestablishEFSP)
{
	BEGIN_CASE(TEXT("Message ID dwIdSize is not the same as given in FaxDevInitEx()"));
	
	LPFSPI_MESSAGE_ID lpRecipientMessageIds = NULL;
	HRESULT hr = S_OK;
	
	if (false == bIsReestablishEFSP)
	{
		::lgLogDetail(
			LOG_X,
			5,
			TEXT("Efsp is a non re-establishing EFSP, quitting this test")
			);
		goto out;
	}

	//
	// Allocate and initialize the recipients permanent message ids array
	//
	hr = CreateFSPIRecipientMessageIdsArray(
		&lpRecipientMessageIds,
		1,
		g_pEFSP->m_dwMaxMessageIdSize
		);
	if (S_OK != hr)
	{
		lpRecipientMessageIds = NULL;
		::lgLogError(
			LOG_SEV_1, 
			TEXT("CreateFSPIRecipientMessageIdsArray() failed. (ec: %ld)"),
			GetLastError()
			);
		goto out;
	}
	//
	//We want to change dwIdSize to be an invalid size, let's bet on 4
	//
	if (4 != lpRecipientMessageIds[0].dwIdSize)
	{
		//
		//The original size isn't 4, so let's set it to 4
		//
		lpRecipientMessageIds[0].dwIdSize = 4;
	}
	else
	{
		//
		//The original size is 4, let's set it to 8
		//
		lpRecipientMessageIds[0].dwIdSize = 8;
	}

	hr = SendDefaultFaxWithMessageIdArray(lpRecipientMessageIds);     //This will also Abort and End the send job
	
	//
	//EFSP Supports job reestablishment, so this should fail
	//
	if (FSPI_E_FAILED == hr)
	{
		//
		//good, this is what we want
		//
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sending failed as expected with error code:FSPI_E_FAILED")
			);
	}
	else
	{
		//
		//No good, what happen? did it succeeded or fail with another error?
		//
		if (FSPI_S_OK == hr)
		{
			//
			//Success is bad in this case
			//
			::lgLogError(
				LOG_SEV_1,
				TEXT("Fax Sent Successfully, without a proper RecipientMessageIdArray")
				);
		}
		else
		{
			//
			//other error
			//
			::lgLogError(
				LOG_SEV_1,
				TEXT("failed with an unexpected error:0x%08x"),
				hr
				);
		}
	}
out:
	::lgEndCase();
}



void Case_SendEx_Item_NULL_MessageIdStruct_RecipientMessageIdArray(bool bIsReestablishEFSP)
{
	BEGIN_CASE(TEXT("Message ID lpbId buffer is a NULL pointer buffer"));

	LPFSPI_MESSAGE_ID lpRecipientMessageIds = NULL;
	HRESULT hr = S_OK;
	
	if (false == bIsReestablishEFSP)
	{
		::lgLogDetail(
			LOG_X,
			5,
			TEXT("Efsp is a non re-establishing EFSP, quitting this test")
			);
		goto out;
	}

	//
	// Allocate and initialize the recipients permanent message ids array
	//
	hr = CreateFSPIRecipientMessageIdsArray(
		&lpRecipientMessageIds,
		1,
		g_pEFSP->m_dwMaxMessageIdSize
		);
	if (S_OK != hr)
	{
		lpRecipientMessageIds = NULL;
		::lgLogError(
			LOG_SEV_1, 
			TEXT("CreateFSPIRecipientMessageIdsArray() failed. (ec: %ld)"),
			GetLastError()
			);
		goto out;
	}
	//
	//Set the lpbId to NULL(this is the case we are testing)
	//
	lpRecipientMessageIds[0].lpbId = NULL;
	
	hr = SendDefaultFaxWithMessageIdArray(lpRecipientMessageIds);     //This will also Abort and End the send job
	//
	//EFSP Supports job reestablishment, so this should fail
	//
	if (FSPI_E_FAILED == hr)
	{
		//
		//good, this is what we want
		//
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("Fax Sending failed as expected with error code:FSPI_E_FAILED")
			);
	}
	else
	{
		//
		//No good, what happen? did it succeeded or fail with another error?
		//
		if (FSPI_S_OK == hr)
		{
			//
			//Success is bad in this case
			//
			::lgLogError(
				LOG_SEV_1,
				TEXT("Fax Sent Successfully, without a proper RecipientMessageIdArray")
				);
		}
		else
		{
			//
			//other error
			//
			::lgLogError(
				LOG_SEV_1,
				TEXT("failed with an unexpected error:0x%08x"),
				hr
				);
		}
	}
out:
	::lgEndCase();
}


void Case_SendEx_RecipientMessageIdArray(bool bIsReestablishEFSP)
{
	lgLogDetail(
		LOG_X,
		2,
		TEXT("\n\n\n*************************************************************************\n***************************** RecipientMessageIdArray param ********************************")
		);
	
	Case_SendEx_NULL_RecipientMessageIdArray(bIsReestablishEFSP);
	//BUGBUG:NIY: Case_SendEx_ZeroItems_RecipientMessageIdArray(efspParms,bIsReestablishEFSP);
	
	//
	//Single Item
	//
	Case_SendEx_Item_wrongSizeOfStruct_RecipientMessageIdArray(bIsReestablishEFSP);
	Case_SendEx_Item_ZeroSizeOfMessageId_RecipientMessageIdArray(bIsReestablishEFSP);
	Case_SendEx_Item_wrongSizeOfMessageId_RecipientMessageIdArray(bIsReestablishEFSP);
	Case_SendEx_Item_NULL_MessageIdStruct_RecipientMessageIdArray(bIsReestablishEFSP);
	
	
}


//////////////////////////////////////////////////////////////////
//
//RecipientJobHandleArray parameter
//

void Case_SendEx_NULL_RecipientJobHandleArray()
{
	BEGIN_CASE(TEXT("Recipient Job Handle array is a NULL pointer"));
	
	HRESULT hr = SendDefaultFaxWithRecipientJobHandleArray(NULL);     //This will also Abort and End the send job
	if (S_OK == hr)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevSendEx() succeeded to send without a Recipient Job Handle array")
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("FaxDevSendEx() failed as expected with:0x%08x"),
			hr
			);
	}
	
	::lgEndCase();
}


void Case_SendEx_RecipientJobHandleArray()
{
	lgLogDetail(
		LOG_X,
		2,
		TEXT("\n\n\n*************************************************************************\n***************************** RecipientJobHandleArray param ********************************")
		);
	Case_SendEx_NULL_RecipientJobHandleArray();
}

//////////////////////////////////////////////////////////////////
//
//ParentMessageId parameter
//
void Case_SendEx_ParentMessageId(bool bIsReestablishEFSP)
{
	lgLogDetail(
		LOG_X,
		2,
		TEXT("\n\n\n*************************************************************************\n***************************** ParentMessageId param ********************************")
		);
	//BUGBUG: NIY
	::lgLogDetail(
		LOG_X, 
		3,
		TEXT("Test case NIY")
		);

}

//////////////////////////////////////////////////////////////////
//
//ParentJobHandle parameter
//
void Case_SendEx_NULL_ParentJobHandle()
{
	BEGIN_CASE(TEXT("Parent Job Handle is a NULL pointer"));
	
	HRESULT hr = SendDefaultFaxWithParentJobHandle(NULL);     //This will also Abort and End the send job
	if (S_OK == hr)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevSendEx() succeeded to send without a parent Job Handle")
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("FaxDevSendEx() failed as expected with:0x%08x"),
			hr
			);
	}
	
	::lgEndCase();
}

void Case_SendEx_ParentJobHandle()
{
	lgLogDetail(
		LOG_X,
		2,
		TEXT("\n\n\n*************************************************************************\n***************************** ParentJobHandle param ********************************")
		);
	Case_SendEx_NULL_ParentJobHandle();

}














/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
//FaxDevReestablishJobContext cases

void Suite_FaxDevReestablishJobContext()
{
	lgBeginSuite(TEXT("FaxDevReestablishJobContext Cases"));
	
	//BUGBUG:TBD
	::lgLogDetail(
		LOG_X, 
		3,
		TEXT("Test Suite NIY")
		);

	::lgEndSuite();
}


/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
//FaxDevReceive cases

void Suite_FaxDevReceive()
{
	lgBeginSuite(TEXT("FaxDevReceive Cases"));
	
	//BUGBUG:TBD
	::lgLogDetail(
		LOG_X, 
		3,
		TEXT("Test Suite NIY")
		);

	::lgEndSuite();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\fsp\3rdpartyfsp_verifier\fsp\aborts.cpp ===
//Aborts.cpp
#include <assert.h>
#include <TCHAR.h>
#include <WINFAX.H>
#include <faxDev.h>
#include <log.h>

#include "Service.h"
#include "..\CFspWrapper.h"
#include "TapiDbg.h"

#ifdef __cplusplus
extern "C"
{
#endif

#include "..\..\..\TiffTools\TiffCompare\TiffTools.h"

#ifdef __cplusplus
}
#endif


extern HANDLE		g_hTapiCompletionPort;	//declared in the main module
extern HANDLE		g_hCompletionPortHandle;
extern CFspWrapper *g_pFSP;
extern DWORD		g_dwCaseNumber;
extern bool			g_reloadFspEachTest;
//
//device IDs
//
extern DWORD		g_dwInvalidDeviceId;
extern DWORD		g_dwSendingValidDeviceId;
extern DWORD		g_dwReceiveValidDeviceId;


//
//Tapi
//
extern HLINEAPP	g_hLineAppHandle;			//Tapi app handle
extern TCHAR*	g_szInvalidRecipientFaxNumber;

extern CFspLineInfo *g_pSendingLineInfo;
extern CFspLineInfo *g_pReceivingLineInfo;

//
//Tiff files
//
extern TCHAR* g_szValid__TiffFileName;

//
//Other
//
extern DWORD g_dwTimeTillRingingStarts;
extern DWORD g_dwTimeTillTransferingBitsStarts;



void AbortSenderBeforeSend()
{
	if (true == g_reloadFspEachTest)
	{
		if (false == LoadTapiLoadFspAndPrepareSendReceiveDevice())
		{
			goto out;
		}
	}
	//
	//Disable the receiving device from answering
	//
	g_pReceivingLineInfo->SafeDisableReceive();

	//
	//Start the send job
	//
	HANDLE hJob;
	if (false == g_pFSP->FaxDevStartJob(
	    g_pSendingLineInfo->GetLineHandle(),
		g_pSendingLineInfo->GetDeviceId(),
		&hJob,
		g_hCompletionPortHandle,
		(ULONG_PTR) g_pSendingLineInfo	// The completion key provided to the FSP is the LineInfo
		))								// pointer. When the FSP reports status it uses this key thus allowing
                                        // us to know to which line the status belongs.
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevStartJob() failed with error:%d"),
			::GetLastError()
			);
		goto out;
	}
	g_pSendingLineInfo->SafeSetJobHandle(hJob);

	FAX_ABORT_ITEM faiAbortItem;
	faiAbortItem.pLineInfo		= g_pSendingLineInfo;
	faiAbortItem.dwMilliSecondsBeforeCallingAbort =	0;
	faiAbortItem.bLogging = true;
	AbortOperationAndWaitForAbortState(&faiAbortItem);
	
out:
	//
	//End the send job
	//
	g_pSendingLineInfo->SafeEndFaxJob();
	
	//
	//enable back the receiving device
	//
	g_pReceivingLineInfo->SafeEnableReceive();
	if (true == g_reloadFspEachTest)
	{
		UnloadFsp();
	}
}



void AbortSenderWhileRinging(DWORD dwMilliSecond)
{
	CThreadItem tiAbortThread;
	
	if (true == g_reloadFspEachTest)
	{
		if (false == LoadTapiLoadFspAndPrepareSendReceiveDevice())
		{
			goto out;
		}
	}
	//
	//Disable the receiving device from answering
	//
	g_pReceivingLineInfo->SafeDisableReceive();


	//
	//Start the send job
	//
	HANDLE hJob;
	if (false == g_pFSP->FaxDevStartJob(
	    g_pSendingLineInfo->GetLineHandle(),
		g_pSendingLineInfo->GetDeviceId(),
		&hJob,
		g_hCompletionPortHandle,
		(ULONG_PTR) g_pSendingLineInfo	// The completion key provided to the FSP is the LineInfo
		))								// pointer. When the FSP reports status it uses this key thus allowing
                                        // us to know to which line the status belongs.
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevStartJob() failed with error:%d"),
			::GetLastError()
			);
		goto out;
	}
	g_pSendingLineInfo->SafeSetJobHandle(hJob);

	//
	//Prepare the item to abort through the AbortThread
	//
	DWORD dwThreadStatus;
	FAX_ABORT_ITEM faiAbortItem;
	faiAbortItem.pLineInfo	= g_pSendingLineInfo;
	faiAbortItem.dwMilliSecondsBeforeCallingAbort =	dwMilliSecond;
	faiAbortItem.bLogging = true;

	if (false == tiAbortThread.StartThread(
		(LPTHREAD_START_ROUTINE) AbortOperationAndWaitForAbortState,
		&faiAbortItem
		))
	{
		goto out;
	}
	
	if (false == g_pFSP->FaxDevSend(
	 	g_pSendingLineInfo->GetJobHandle(),
		g_pSendingLineInfo->m_pFaxSend,
		FaxDevSend__SendCallBack
		))
	{
		//
		//FaxDevSend() has failed, but this is OK, since we aborted it from another thread and it can fail
		//
		::lgLogDetail(
			LOG_X,
			5,
			TEXT("FaxDevSend() has failed (ec: %ld)"),
			::GetLastError()
			);
	}
	else
	{
		::lgLogDetail(
			LOG_X,
			5,
			TEXT("FaxDevSend() succeeded")
			);
	}

	//
	//Before we end the job, we need to be sure the AbortOperation completed
	//We set the max time to + 10 seconds
	//
	dwThreadStatus = WaitForSingleObject(tiAbortThread.m_hThread,dwMilliSecond+10000);
	if (WAIT_OBJECT_0 != dwThreadStatus)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("WaitForSingleObject(CallFaxAbortThread) returned %d"),
			dwThreadStatus
			);
		goto out;
	}

	
	
out:
	//
	//End the send job
	//
	g_pSendingLineInfo->SafeEndFaxJob();
	tiAbortThread.CloseHandleResetThreadId();
	
	//
	//enable back the receiving device
	//
	g_pReceivingLineInfo->SafeEnableReceive();
	if (true == g_reloadFspEachTest)
	{
		UnloadFsp();
	}
}


void SimulatniousAbortSenderWhileRinging(DWORD dwSleepBeforeFirstAbort, DWORD dwSleepBeforeSecondAbort)
{
	CThreadItem tiFirstAbortThread;
	CThreadItem tiSecondAbortThread;
	if (true == g_reloadFspEachTest)
	{
		if (false == LoadTapiLoadFspAndPrepareSendReceiveDevice())
		{
			goto out;
		}
	}
	//
	//Disable the receiving device from answering
	//
	g_pReceivingLineInfo->SafeDisableReceive();

	//
	//Start the send job
	//
	HANDLE hJob;
	if (false == g_pFSP->FaxDevStartJob(
	    g_pSendingLineInfo->GetLineHandle(),
		g_pSendingLineInfo->GetDeviceId(),
		&hJob,
		g_hCompletionPortHandle,
		(ULONG_PTR) g_pSendingLineInfo	// The completion key provided to the FSP is the LineInfo
		))								// pointer. When the FSP reports status it uses this key thus allowing
                                        // us to know to which line the status belongs.
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevStartJob() failed with error:%d"),
			::GetLastError()
			);
		goto out;
	}
	g_pSendingLineInfo->SafeSetJobHandle(hJob);
	
	//
	//First abort thread
	//
	DWORD dwThreadStatus;
	FAX_ABORT_ITEM faiAbortFirstItem;
	faiAbortFirstItem.pLineInfo	= g_pSendingLineInfo;
	faiAbortFirstItem.dwMilliSecondsBeforeCallingAbort = dwSleepBeforeFirstAbort;
	faiAbortFirstItem.bLogging = true;

	if (false == tiFirstAbortThread.StartThread(
		(LPTHREAD_START_ROUTINE) AbortOperationAndWaitForAbortState,
		&faiAbortFirstItem
		))
	{
		goto out;
	}
	
	//
	//Second abort thread
	//
	FAX_ABORT_ITEM faiAbortSecondItem;
	faiAbortSecondItem.pLineInfo	= g_pSendingLineInfo;
	faiAbortSecondItem.dwMilliSecondsBeforeCallingAbort = dwSleepBeforeSecondAbort;
	faiAbortSecondItem.bLogging = true;

	if (false == tiSecondAbortThread.StartThread(
		(LPTHREAD_START_ROUTINE) AbortOperationAndWaitForAbortState,
		&faiAbortSecondItem
		))
	{
		goto out;
	}
	
	if (false == g_pFSP->FaxDevSend(
	 	g_pSendingLineInfo->GetJobHandle(),
		g_pSendingLineInfo->m_pFaxSend,
		FaxDevSend__SendCallBack
		))
	{
		//
		//FaxDevSend() has failed, but this is OK, since we aborted it from another thread and it can fail
		//
		::lgLogDetail(
			LOG_X,
			5,
			TEXT("FaxDevSend() has failed (ec: %ld)"),
			::GetLastError()
			);
	}
	else
	{
		::lgLogDetail(
			LOG_X,
			5,
			TEXT("FaxDevSend() succeeded")
			);
	}

	//
	//Before we end the job, we need to be sure the Abort Operations completed
	//We set the max time to + 10 seconds
	//

	//
	//First abort thread
	//
	dwThreadStatus = WaitForSingleObject(tiFirstAbortThread.m_hThread,dwSleepBeforeFirstAbort+10000);
	if (WAIT_OBJECT_0 != dwThreadStatus)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("WaitForSingleObject(1'st abort thread) returned %d"),
			dwThreadStatus
			);
		goto out;
	}

	//
	//Second abort thread
	//
	dwThreadStatus = WaitForSingleObject(tiSecondAbortThread.m_hThread,dwSleepBeforeSecondAbort+10000);
	if (WAIT_OBJECT_0 != dwThreadStatus)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("WaitForSingleObject(2'nd abort thread) returned %d"),
			dwThreadStatus
			);
		goto out;
	}

	
	
out:
	//
	//End the send job
	//
	g_pSendingLineInfo->SafeEndFaxJob();

	if (NULL != tiFirstAbortThread.m_hThread)
	{
		::CloseHandle(tiFirstAbortThread.m_hThread);
		tiFirstAbortThread.m_hThread = NULL;
		tiFirstAbortThread.m_dwThreadId = 0;
	}
	if (NULL != tiSecondAbortThread.m_hThread)
	{
		::CloseHandle(tiSecondAbortThread.m_hThread);
		tiSecondAbortThread.m_hThread = NULL;
		tiSecondAbortThread.m_dwThreadId = 0;
	}
	
	//
	//enable back the receiving device
	//
	g_pReceivingLineInfo->SafeEnableReceive();;
	if (true == g_reloadFspEachTest)
	{
		UnloadFsp();
	}
}


void AbortSenderWhileTransferingBits(DWORD dwMilliSecond)
{
	CThreadItem tiAbortThread;
	PFAX_DEV_STATUS pReceivingDevStatus = NULL;
	
	if (true == g_reloadFspEachTest)
	{
		if (false == LoadTapiLoadFspAndPrepareSendReceiveDevice())
		{
			goto out;
		}
	}
		
	g_pReceivingLineInfo->EnableReceiveCanFail();


	//
	//Start the send job
	//
	HANDLE hJob;
	if (false == g_pFSP->FaxDevStartJob(
	    g_pSendingLineInfo->GetLineHandle(),
		g_pSendingLineInfo->GetDeviceId(),
		&hJob,
		g_hCompletionPortHandle,
		(ULONG_PTR) g_pSendingLineInfo	// The completion key provided to the FSP is the LineInfo
		))								// pointer. When the FSP reports status it uses this key thus allowing
                                        // us to know to which line the status belongs.
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevStartJob() failed with error:%d"),
			::GetLastError()
			);
		goto out;
	}
	g_pSendingLineInfo->SafeSetJobHandle(hJob);
	

	//
	//Prepare the item to abort through the AbortThread
	//
	DWORD dwStatus;
	FAX_ABORT_ITEM faiAbortItem;
	faiAbortItem.pLineInfo	= g_pSendingLineInfo;
	faiAbortItem.dwMilliSecondsBeforeCallingAbort =	dwMilliSecond;
	faiAbortItem.bLogging = true;

	if (false == tiAbortThread.StartThread(
		(LPTHREAD_START_ROUTINE) AbortOperationAndWaitForAbortState,
		&faiAbortItem
		))
	{
		goto out;
	}
	
	if (false == g_pFSP->FaxDevSend(
	 	g_pSendingLineInfo->GetJobHandle(),
		g_pSendingLineInfo->m_pFaxSend,
		FaxDevSend__SendCallBack
		))
	{
		//
		//FaxDevSend() has failed, but this is OK, since we aborted it from another thread and it can fail
		//
		::lgLogDetail(
			LOG_X,
			5,
			TEXT("While aborting the send job: FaxDevSend() has failed (ec: %ld)"),
			::GetLastError()
			);
	}
	else
	{
		::lgLogDetail(
			LOG_X,
			5,
			TEXT("While aborting the send job: FaxDevSend() succeeded")
			);
	}

	//
	//Wait till the abort thread signals us for finishing
	//
	dwStatus = WaitForSingleObject(tiAbortThread.m_hThread,dwMilliSecond+10000);
	if (WAIT_TIMEOUT == dwStatus)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("got a timeout for Aborting")
			);
		goto out;
	}

	if (WAIT_OBJECT_0 != dwStatus)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("WaitForSingleObject(Abort send thread) returned %d"),
			dwStatus
			);
		goto out;
	}

	//
	//Send operation was aborted, now let's check what's happening with the receive job
	//

	//
	//Now we need to wait till the receive thread finishes (FaxDevReceive() returns)
	//Since we can't close handles and end jobs when FaxDevReceive didn't return
	//
	if (false == g_pReceivingLineInfo->WaitForReceiveThreadTerminate())
	{
		goto out;
	}

	//
	//OK, receive thread has terminated, now let's check the status of the receive job
	//
	if (ERROR_SUCCESS != g_pReceivingLineInfo->GetDevStatus(
		&pReceivingDevStatus,
		true				
		))
	{
		//
		//GetDevStatus() failed, logging is in GetDevStatus()
		//
		goto out;
	}
	else
	{
		
		//
		//We aborted the receive job, so it can either be in the following status:
		//FS_FATAL_ERROR, FS_DISCONNECTED, FS_USER_ABORT
		//

		
		if ( (FS_USER_ABORT		== pReceivingDevStatus->StatusId) ||
			 (FS_FATAL_ERROR	== pReceivingDevStatus->StatusId) ||
			 (FS_DISCONNECTED	== pReceivingDevStatus->StatusId)   )
		{
			::lgLogDetail(
				LOG_PASS,
				2,
				TEXT("Receive Job: GetDevStatus() reported 0x%08x"),
				pReceivingDevStatus->StatusId
				);
		}
		else
		{
			::lgLogError(
				LOG_SEV_1,
				TEXT("Receive Job: GetDevStatus() should report FS_USER_ABORT or FS_FATAL_ERROR or FS_DISCONNECTED for the receiving job and not, 0x%08x"),
				pReceivingDevStatus->StatusId
				);
		}
	}
	
out:
	//
	//End the jobs
	//
	g_pSendingLineInfo->SafeEndFaxJob();
	g_pReceivingLineInfo->SafeEndFaxJob();
	tiAbortThread.CloseHandleResetThreadId();
	if (true == g_reloadFspEachTest)
	{
		UnloadFsp();
	}
}

void AbortReceivierWhileTransferingBits(DWORD dwMilliSecond)
{
	CThreadItem tiAbortThread;
	PFAX_DEV_STATUS pSendingDevStatus = NULL;
		
	if (true == g_reloadFspEachTest)
	{
		if (false == LoadTapiLoadFspAndPrepareSendReceiveDevice())
		{
			goto out;
		}
	}
	g_pReceivingLineInfo->EnableReceiveCanFail();

	//
	//Start the send job
	//
	HANDLE hJob;
	if (false == g_pFSP->FaxDevStartJob(
	    g_pSendingLineInfo->GetLineHandle(),
		g_pSendingLineInfo->GetDeviceId(),
		&hJob,
		g_hCompletionPortHandle,
		(ULONG_PTR) g_pSendingLineInfo	// The completion key provided to the FSP is the LineInfo
		))								// pointer. When the FSP reports status it uses this key thus allowing
                                        // us to know to which line the status belongs.
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevStartJob() failed with error:%d"),
			::GetLastError()
			);
		goto out;
	}
	g_pSendingLineInfo->SafeSetJobHandle(hJob);

	//
	//Prepare the item to abort through the AbortThread(we want to abort the receive job
	//
	DWORD dwThreadStatus;
	FAX_ABORT_ITEM faiAbortItem;
	faiAbortItem.pLineInfo	= g_pReceivingLineInfo;
	faiAbortItem.dwMilliSecondsBeforeCallingAbort =	dwMilliSecond;
	faiAbortItem.bLogging = true;

	if (false == tiAbortThread.StartThread(
		(LPTHREAD_START_ROUTINE) AbortOperationAndWaitForAbortState,
		&faiAbortItem
		))
	{
		goto out;
	}
	
	if (false == g_pFSP->FaxDevSend(
	 	g_pSendingLineInfo->GetJobHandle(),
		g_pSendingLineInfo->m_pFaxSend,
		FaxDevSend__SendCallBack
		))
	{
		//
		//FaxDevSend() has failed, but this is OK, since we aborted it from another thread and it can fail
		//
		::lgLogDetail(
			LOG_X,
			5,
			TEXT("While aborting the receive job: FaxDevSend() has failed (ec: %ld)"),
			::GetLastError()
			);
	}
	else
	{
		::lgLogDetail(
			LOG_X,
			5,
			TEXT("While aborting the receive job: FaxDevSend() succeeded")
			);
	}

	//
	//Before we end the job, we need to be sure the AbortOperation completed
	//We set the max time to + 10 seconds
	//
	dwThreadStatus = WaitForSingleObject(tiAbortThread.m_hThread,dwMilliSecond+10000);
	if (WAIT_TIMEOUT == dwThreadStatus)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("got a timeout for Aborting")
			);
		goto out;
	}

	if (WAIT_OBJECT_0 != dwThreadStatus)
	{
		::lgLogError(
			LOG_SEV_2,
			TEXT("WaitForSingleObject(Abort receive thread) returned %d"),
			dwThreadStatus
			);
		goto out;
	}

	//
	//Now we need to wait till the receive thread finishes (FaxDevReceive() returns)
	//Since we can't close handles and end jobs when FaxDevReceive didn't return
	//
	if (false == g_pReceivingLineInfo->WaitForReceiveThreadTerminate())
	{
		goto out;
	}


	//
	//receive operation was finished and aborted, now let's check what's happening with the send job
	//
	//
	//Get the status through FaxDevReportStatus
	//
	if (ERROR_SUCCESS != g_pSendingLineInfo->GetDevStatus(
		&pSendingDevStatus,
		true				
		))
	{
		//
		//GetDevStatus() failed, logging is in GetDevStatus()
		//
		goto out;
	}
	else
	{
		//
		//We aborted the receive job, so it can either be in the following status:
		//FS_FATAL_ERROR, FS_DISCONNECTED, FS_USER_ABORT
		//
		if ( (FS_USER_ABORT		== pSendingDevStatus->StatusId) ||
			 (FS_FATAL_ERROR	== pSendingDevStatus->StatusId) ||
			 (FS_DISCONNECTED	== pSendingDevStatus->StatusId)   )
		{
			::lgLogDetail(
				LOG_PASS,
				2,
				TEXT("Send Job: GetDevStatus() reported 0x%08x as expected"),
				pSendingDevStatus->StatusId
				);
		}
		else
		{
			::lgLogError(
				LOG_SEV_1,
				TEXT("Send Job: GetDevStatus() should report FS_USER_ABORT or FS_FATAL_ERROR or FS_DISCONNECTED for the receiving job and not, 0x%08x"),
				pSendingDevStatus->StatusId
				);
		}
	}
	
out:
	//
	//End the jobs
	//
	g_pSendingLineInfo->SafeEndFaxJob();
	g_pReceivingLineInfo->SafeEndFaxJob();
	tiAbortThread.CloseHandleResetThreadId();
	if (true == g_reloadFspEachTest)
	{
		UnloadFsp();
	}
}

void Suite_Abort()
{
	::lgBeginSuite(TEXT("Abort tests"));

	
	//
	//Abort The send job before call FaxDevSend()
	//
	if (true == RunThisTest(++g_dwCaseNumber))
	{														
		::lgBeginCase(g_dwCaseNumber,TEXT("Abort The send job before call FaxDevSend()"));
		AbortSenderBeforeSend();
		::lgEndCase();
	}

	//
	//Abort The send abortion while ringing
	//
	DWORD dwSleepBeforeAbort = g_dwTimeTillRingingStarts;
	TCHAR szLogMessage[1000];
	_stprintf(szLogMessage,TEXT("Abort The send job %d milliSeconds after calling FaxDevSend()"),dwSleepBeforeAbort );
	if (true == RunThisTest(++g_dwCaseNumber))
	{														
		::lgBeginCase(g_dwCaseNumber,szLogMessage);
		AbortSenderWhileRinging(dwSleepBeforeAbort);
		::lgEndCase();
	}

	//
	//abort from 2 threads simulatinously
	//
	DWORD dwSleepBeforeFirstAbort = g_dwTimeTillRingingStarts;
	DWORD dwSleepBeforeSecondAbort= g_dwTimeTillRingingStarts;
	_stprintf(szLogMessage,TEXT("Aborting the send job from 2 threads simulatinously (first abort after %d milliSeconds, second abort after %d milliSeconds)"),dwSleepBeforeFirstAbort,dwSleepBeforeSecondAbort);
	if (true == RunThisTest(++g_dwCaseNumber))
	{														
		::lgBeginCase(g_dwCaseNumber,szLogMessage);
		SimulatniousAbortSenderWhileRinging(dwSleepBeforeFirstAbort,dwSleepBeforeSecondAbort);
		::lgEndCase();
	}


	//
	//Abort The send job after a random time after calling FaxDevSend()
	//
	
	dwSleepBeforeAbort = g_dwTimeTillTransferingBitsStarts;
	_stprintf(szLogMessage,TEXT("Abort the sender job while transfering Bits (%d milliSeconds after calling FaxDevSend())"),dwSleepBeforeAbort );
	if (true == RunThisTest(++g_dwCaseNumber))
	{														
		::lgBeginCase(g_dwCaseNumber,szLogMessage);
		AbortSenderWhileTransferingBits(dwSleepBeforeAbort);
		::lgEndCase();
	}

	//
	//Abort The receive job after a random time after calling FaxDevSend()
	//
	dwSleepBeforeAbort = g_dwTimeTillTransferingBitsStarts;
	_stprintf(szLogMessage,TEXT("Abort the receive job while transfering Bits (%d milliSeconds after calling FaxDevSend())"),dwSleepBeforeAbort );
	if (true == RunThisTest(++g_dwCaseNumber))
	{														
		::lgBeginCase(g_dwCaseNumber,szLogMessage);
		AbortReceivierWhileTransferingBits(dwSleepBeforeAbort);
		::lgEndCase();
	}

	//
	//Abort the send job after random time
	//

	::lgEndSuite();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\fsp\3rdpartyfsp_verifier\fsp\cfsplineinfo.cpp ===
//CFspLineInfo.cpp
#include "Service.h"
#include "CFspLineInfo.h"
extern CFspWrapper *g_pFSP; 
extern HLINEAPP		g_hLineAppHandle;

CFspLineInfo::CFspLineInfo(const DWORD dwDeviceId):
	CLineInfo(dwDeviceId),
	m_hReceiveCallHandle(NULL),
	m_hLine(NULL)
{
	;
}

CFspLineInfo::~CFspLineInfo()
{
	if(NULL != m_hLine)
	{
		long lStatus = ::lineClose(m_hLine);
		if (0 != lStatus)
		{
			::lgLogError(
				LOG_SEV_2,
				TEXT("::lineClose() failed with error:%d"),
				lStatus
				);
		}
		m_hLine = NULL;
	}
}

void CFspLineInfo::SafeEndFaxJob()
{
	if (NULL == GetJobHandle())
	{
		//
		//the job is already ended
		//
		return;
	}
	if (false == g_pFSP->FaxDevEndJob(GetJobHandle()))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevEndJob failed with %d"),
			::GetLastError()
			);
	}

	//
	//Reset the handle
	//
	SafeSetJobHandle(NULL);
	ResetParams();

}

void CFspLineInfo::ResetParams()
{
	if (IsReceiveThreadActive())
	{
		SafeCloseReceiveThread();
	}
	if (NULL != m_hReceiveCallHandle)
	{
		CloseHCall();
	}
}



DWORD CFspLineInfo::GetDevStatus(
	PFAX_DEV_STATUS *ppFaxStatus,
	const bool bLogTheStatus
	) const
{
    DWORD dwRet = ERROR_SUCCESS;
    LPWSTR szStatusStr = NULL;
    DWORD dwSize = 0;

    assert(NULL != GetJobHandle());
    assert(ppFaxStatus);


    //
    // We're have a legacy FSP to deal with.
    //
    PFAX_DEV_STATUS pFaxStatus = NULL;

    //
    // Allocate memory for the status packet this is a variable size packet
    // based on the size of the strings contained within the packet.
    //
    DWORD StatusSize = sizeof(FAX_DEV_STATUS) + FAXDEVREPORTSTATUS_SIZE;
	pFaxStatus = (PFAX_DEV_STATUS) malloc( StatusSize );
    if (!pFaxStatus)
	{
        ::lgLogError(
			LOG_SEV_2,
			TEXT("Failed to allocate memory for FAX_DEV_STATUS")
			);
        dwRet = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    //
    // Setup the status packet(supply invalid values so we can verify that the FSP changed them)
    //
    pFaxStatus->SizeOfStruct=	0;
	pFaxStatus->CallerId	=	NULL;
	pFaxStatus->CSI			=	NULL;
	pFaxStatus->ErrorCode	=	NO_ERROR;
	pFaxStatus->PageCount	=	-1;
	pFaxStatus->Reserved[0]	=	0;
	pFaxStatus->Reserved[1]	=	0;
	pFaxStatus->Reserved[2]	=	0;
	pFaxStatus->RoutingInfo =	NULL;
	pFaxStatus->StatusId	=	-1;
	pFaxStatus->StringId	=	-1;

    //
    // Call the FSP
    //
    DWORD dwBytesNeeded;

    if (false == g_pFSP->FaxDevReportStatus(
                 GetJobHandle(),
                 pFaxStatus,
                 StatusSize,
                 &dwBytesNeeded
                ))
	{
       	dwRet = ::GetLastError();
		::lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevReportStatus() failed - %d"),
			dwRet
			);
        goto Exit;
	}

	if (true == bLogTheStatus)
	{
		//
		//we should log all the data
		//
		::lgLogDetail(
			LOG_X,
			6,
			TEXT("FaxDevReport() has reported the following details: ")
			TEXT("StatusID=0x%08x, StringId=%d, PageCount=%d, ")
			TEXT("CSI=\"%s\", CallerId=\"%s\", ")
			TEXT("RoutingInfo=\"%s\", ErrorCode=%d"),
			pFaxStatus->StatusId,
			pFaxStatus->StringId,
			pFaxStatus->PageCount,
			pFaxStatus->CSI,
			pFaxStatus->CallerId,
			pFaxStatus->RoutingInfo,
			pFaxStatus->ErrorCode
			);
	}
    

Exit:
    if (dwRet == ERROR_SUCCESS)
	{
        *ppFaxStatus = pFaxStatus;
    }
	else
	{
        free(pFaxStatus);
    }
    return(dwRet);
}

bool CFspLineInfo::OpenTapiLine(HLINEAPP hLineApp,bool bIsOwner)
{
	//
	//This function doesn't use critical sections, the caller should take care of syncs.
	//
	HLINE hLine;
	DWORD dwAPIVersion = API_VERSION;
	DWORD dwExtVersion = 0;
	DWORD dwPrivileges  = (bIsOwner ? LINECALLPRIVILEGE_OWNER:LINECALLPRIVILEGE_NONE);
	DWORD dwMediaModes =  LINEMEDIAMODE_DATAMODEM;
	LINECALLPARAMS callParams;
	::ZeroMemory(&callParams, sizeof(callParams));
	callParams.dwTotalSize = sizeof(callParams);
	InitLineCallParams(&callParams,dwMediaModes);
	
	//
	//call lineGetDevCaps() for retrieving some lineDevice information
	//such as supported media modes
	//
	LINEDEVCAPS ldLineDevCaps;
	::ZeroMemory(&ldLineDevCaps,sizeof(ldLineDevCaps));
	ldLineDevCaps.dwTotalSize = sizeof(ldLineDevCaps);
	
	long lineGetDevCapsStatus = ::lineGetDevCaps(
		hLineApp,           
		GetDeviceId(),
		dwAPIVersion,
		dwExtVersion,
		&ldLineDevCaps
		);
	if (0 != lineGetDevCapsStatus)
	{
		::lgLogError(
			LOG_SEV_2,
			TEXT("lineGetDevCaps() failed, error code:0x%08x"), 
			lineGetDevCapsStatus
			);
		return false;
	}

	if ( !(dwMediaModes & ldLineDevCaps.dwMediaModes) )
	{
		//
		//the desired media mode is not supported by this device
		//
		::lgLogError(
			LOG_SEV_2,
			TEXT("The desired media mode(%x) isn't supported by this device(%d), the supported modes are: 0x%x"),
			dwMediaModes,
			GetDeviceId(),
			ldLineDevCaps.dwMediaModes
			);
		return false;
	}

	long lineOpenStatus = ::lineOpen(
	        hLineApp,
            GetDeviceId(),
            &hLine,
            dwAPIVersion,
            dwExtVersion,
            (DWORD_PTR) this,	// Note that the pLineInfo pointer is used as CallbackInstance data. This means we will
                                // get the pLineInfo pointer each time we get a TAPI message.
            dwPrivileges,
            dwMediaModes,
            &callParams
            );

	if (0 != lineOpenStatus)
	{
		::lgLogError(
			LOG_SEV_2,
			TEXT("lineOpen() failed, error code:0x%08x"), 
			lineOpenStatus
			);
		return false;
	}
	
	//
	//Everything is ok, and the line is open, return the line handle in the LineInfo structure
	//
	m_hLine = hLine;
	return true;
}

void CFspLineInfo::CloseHCall()
{
	assert(NULL != m_hReceiveCallHandle);
	LONG lStatus = ::lineDeallocateCall(m_hReceiveCallHandle);
	if (0 > lStatus)
	{
		::lgLogError(
			LOG_SEV_2,
			TEXT("lineDeallocateCall failed with error: 0x%08x"),
			lStatus
			);
	}
	m_hReceiveCallHandle = NULL;
}

HCALL CFspLineInfo::GetReceiveCallHandle() const
{
	return m_hReceiveCallHandle;
}
void CFspLineInfo::SetReceiveCallHandle(const HCALL hReceive)
{
	m_hReceiveCallHandle = hReceive;
}

//
//m_hLine
//
HLINE CFspLineInfo::GetLineHandle() const
{
	return m_hLine;
}
void CFspLineInfo::SetLineHandle(const HLINE hLine)
{
	m_hLine = hLine;
}

bool CFspLineInfo::PrepareLineInfoParams(LPCTSTR szFilename,const bool bIsReceiveLineinfo)
{
	bool bRet = false;
	HLINEAPP	hLineAppHandle = g_hLineAppHandle;
	DWORD dwAPIVersion = API_VERSION;
	DWORD dwExtVersion = 0;
	DWORD dwSizeOfLineDevsCaps = (10*MAX_PATH*sizeof(TCHAR))+sizeof(LINEDEVCAPS);
	LINEDEVCAPS *pLineDevCaps = NULL;
	
	pLineDevCaps = (LINEDEVCAPS*) malloc (dwSizeOfLineDevsCaps);
	if (NULL != pLineDevCaps)
	{
		::ZeroMemory(pLineDevCaps,dwSizeOfLineDevsCaps);
		pLineDevCaps->dwTotalSize = dwSizeOfLineDevsCaps;
		long lineGetDevCapsStatus = ::lineGetDevCaps(
			hLineAppHandle,           
			GetDeviceId(),
			dwAPIVersion,
			dwExtVersion,
			pLineDevCaps
			);
		if (0 != lineGetDevCapsStatus)
		{
			::lgLogError(
				LOG_SEV_2,
				TEXT("lineGetDevCaps() failed, error code:0x%08x"), 
				lineGetDevCapsStatus
				);
			//
			//don't return here, continue and assign default values
			//
		}
	}

	//
	//Prepare a critical section
	//
	if (false == CreateCriticalSection())
	{
		goto out;
	}
	
	//
	//We're assigning values, lock the LineInfo (we can't use CS auto-pointer, since we have a goto and can't declare after the goto)
	//
	Lock();

	

	//
	//recorded the DeviceName
	//
	if (0 == pLineDevCaps->dwLineNameSize)
	{
		//
		//LineGetDevsCaps doesn't contains a Line Name, record a default one
		//
		if (false == SetDeviceName(DEFAULT_DEVICE_NAME))
		{
			goto out;
		}
	}
	else
	{
		//
		//LineGetDevsCaps contains Line Name, so record it
		//
		if (false == SetDeviceName( (LPTSTR) ((LPBYTE) pLineDevCaps + pLineDevCaps->dwLineNameOffset)))
		{
			goto out;
		}
	}
	
	m_hLine=NULL;					// tapi line handle
	
	//
	//We need to Open the tapi lines
	//
	if (true == bIsReceiveLineinfo)
	{
		//
		////we should open the line as owner (for receiving)
		//
		if (false == OpenTapiLine(g_hLineAppHandle,true))
		{
			//
			//Logging is in OpenTapiLine()
			//
			goto out;
		}
	}
	else
	{
		//
		//we should open the line as owner (for sending)
		//
		if (false == OpenTapiLine(g_hLineAppHandle,false))
		{
			//
			//Logging is in OpenTapiLine()
			//
			goto out;
		}
	}
	
	//
	//Get the general stuff from the base object
	//
	bRet = CommonPrepareLineInfoParams(szFilename,bIsReceiveLineinfo);
out:
	UnLock();
	free(pLineDevCaps);
	return bRet;
}

void CFspLineInfo::InitLineCallParams(LINECALLPARAMS *callParams,const DWORD dwMediaModes)
{

	//
	//CallParams structure init
	//
	callParams->dwBearerMode		=	LINEBEARERMODE_VOICE;
	callParams->dwMinRate		=	0;
	callParams->dwMaxRate		=	0;	//0 = highest rate.
	callParams->dwMediaMode		=	dwMediaModes;
	callParams->dwAddressMode	=	1;
	callParams->dwAddressID		=	0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\fsp\3rdpartyfsp_verifier\efsp\main.cpp ===
//main.cpp

#include <assert.h>
#include <stdio.h>
#include <TCHAR.h>
#include <WINFAX.H>
#include <faxDev.h>
#include <log\log.h>


#include "ParamTest.h"
#include "Service.h"

//
//Globals
//
bool g_bHasLineCallbackFunction = true;

DWORD		g_dwCaseNumber			=	0;				//will be used for counting the case number

CEfspLineInfo	*g_pSendingLineInfo	=	NULL;
CEfspLineInfo	*g_pReceivingLineInfo=	NULL;

extern DWORD g_dwSendingValidDeviceId;
extern DWORD g_dwReceiveValidDeviceId;
extern TCHAR* g_szValid__TiffFileName;
extern TCHAR* g_szValid_ReceiveFileName;
extern TCHAR * g_szFspIniFileName;


bool Suite_EfspLoading();
void Suite_TiffSending();
void Suite_Abort();



void Usage()
{
	::lgLogDetail(
		LOG_X,
		1,
		TEXT("Usage:\n%s%s%s%s"),
		TEXT("\tEfspTester.exe <Filename.INI>    : INI file to run the test on"),
		TEXT("\t\nExample:\nEfspTester.exe .\\Vendor.Ini    : Run the EFSP tester on Vendor.INI which is on the current directory"),
		TEXT("\t\nExample:\nFspTester.exe c:\\Vendor\\T30.Ini    : Run the EFSP tester on Vendor.INI which is on the current c:\\Test directory")
		);
}


//
//Logging levels:
//1 
//2	Whole test case PASS
//3 Test case step PASS
//4
//5	Ini settings / Don't care if FAIL/PASS messages
//6	Tapi Messages
//7 Enter / Leave FSP APIs
//8
//9
void main(int argc, char ** argvA)
{
	//
	//Init the logger for the test cases
	//
	::lgInitializeLogger();
	g_dwCaseNumber=0;
		
	if (2 != argc)
	{
		Usage();
		goto out;

	}
	
	TCHAR **argv;
#ifdef UNICODE
	argv = ::CommandLineToArgvW( GetCommandLine(), &argc );
#else
	argv = argvA;
#endif

	g_szFspIniFileName = argv[1];
	
	//
	//Because of a VC6 bug, we need to declare all globals as pointers and malloc/free them
	//
	if (false == AllocGlobalVariables())
	{
		goto out;
	}
	if (false == InitGlobalVariables())
	{
		goto out;
	}
	if (false == GetIniSettings())		//fetch the user INI setting.
	{
		goto out;
	}
	
	//
	//EFSP loading + function exporting tests
	//
	if (false == Suite_EfspLoading())
	{
		//
		//if init tests fail, there's no point to continue with the rest of the test cases/suites
		//
		::lgLogError(
			LOG_SEV_1,
			TEXT("Init test cases failed, no point to continue with rest of test cases")
			);
		goto out;
	}
	

	//
	//Loads and call FaxDevInitEx by itself
	//
	Suite_FaxDevInitializeEx();

	//
	//Prepare the devices for the rest of the test cases
	//
		
	//
	//Init Tapi, load the FSP and call FaxDevInit() for all the rest of the test cases
	//
	if (false == LoadAndInitFsp_InitSendAndReceiveDevices())
	{
		goto out;
	}

	Suite_FaxDevEnumerateDevices();
	Suite_FaxDevReportStatusEx();
	Suite_FaxDevSendEx();
	Suite_FaxDevReestablishJobContext();
	Suite_FaxDevReceive();

	Suite_TiffSending();
	Suite_Abort();


out:	
	FreeGlobalVariables();

#ifdef UNICODE
	//
	//we need to free the buffer from CommandLineToArgvW()
	//
	::GlobalFree(argv);
#endif

	::lgLogDetail(
		LOG_X,
		1,
		TEXT("Test Finished")
		);
	lgCloseLogger();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\fsp\3rdpartyfsp_verifier\efsp\service.cpp ===
//Service.cpp
#include <assert.h>
#include <stdio.h>
#include <TCHAR.h>
#include <WINFAX.H>
#include <faxDev.h>
#include <log\log.h>

#include "CEfspWrapper.h"
#include "CEfspLineInfo.h"
#include "Service.h"

#define	EFSP_DEVICE_BASE_ID				0


#define INI_SECTION__EFSP_SETTINGS		TEXT("EfspSettings")
#define INI_SECTION__PHONE_NUMBERS		TEXT("PhoneNumbers")
#define INI_SECTION__TIFF_FILES			TEXT("TiffFiles")
#define INI_SECTION__COVERPAGE_FILES	TEXT("CoverpageFiles")
#define INI_SECTION__CASES				TEXT("Cases")
#define	INI_SECTION__GENERAL			TEXT("General")

CEfspWrapper *g_pEFSP;
#define MAX_DEVICE_FRIENDLY_NAME	MAX_PATH

extern CEfspLineInfo *	g_pReceivingLineInfo;
extern CEfspLineInfo *	g_pSendingLineInfo;
HANDLE		g_hCompletionPortHandle;

//
//INI stuff
//
#define MAX_INI_VALUE 200
#define LAST_CASE_NUMBER				200
bool baRunThisTest[LAST_CASE_NUMBER];

#define INI_SECTION__EFSP_SETTINGS		TEXT("EfspSettings")
#define INI_SECTION__PHONE_NUMBERS		TEXT("PhoneNumbers")
#define INI_SECTION__TIFF_FILES			TEXT("TiffFiles")
#define INI_SECTION__COVERPAGE_FILES	TEXT("CoverpageFiles")
TCHAR * g_szFspIniFileName			=		NULL;

//
//EFSP info
//
TCHAR*  g_szModuleName					=			NULL;
#define EFSP_MODULE_NAME__INI_KEY					TEXT("EFSP DLL")

DWORD	g_dwEfspCaps					=			0;
#define EFSP_CAP__INI_KEY							TEXT("EFSP CAP")

bool	g_bReestablishEfsp				=			false;
#define	REESTABLISH_EFSP__INI_KEY					TEXT("REESTABLISH_EFSP")

bool	g_bVirtualEfsp					=			false;
#define VIRTUAL_EFSP__INI_KEY						TEXT("VIRTUAL_EFSP")

DWORD	g_dwInvalidDeviceId				=			0;
#define INVALID_DEVICE_ID__INI_KEY					TEXT("INVALID_DEVICE_ID")

DWORD	g_dwSendingValidDeviceId			=			0;
#define SENDING_VALID_DEVICE_ID__INI_KEY			TEXT("SENDING_VALID_DEVICE_ID")

DWORD	g_dwReceiveValidDeviceId			=			0;
#define RECEIVE_VALID_DEVICE_ID__INI_KEY			TEXT("RECEIVE_VALID_DEVICE_ID")

DWORD	g_dwReceiveTimeOut	=	0;
#define	MAX_TIME_FOR_RECEIVING_FAX__INI_KEY							TEXT("MAX_TIME_FOR_RECEIVING_FAX")
DWORD	g_dwTimeTillRingingStarts = 0;
#define TIME_FROM_SEND_START_TILL_RINGING_STARTS__INI_KEY			TEXT("TIME_FROM_SEND_START_TILL_RINGING_STARTS")
DWORD	g_dwTimeTillTransferingBitsStarts = 0;
#define TIME_FROM_SEND_START_TILL_TRANSFERING_BITS_STARTS__INI_KEY	TEXT("TIME_FROM_SEND_START_TILL_TRANSFERING_BITS_STARTS")

//
//Phone numbers
//
TCHAR* g_szInvalidRecipientFaxNumber	=				NULL;
#define	INVALID_RECIPIENT_FAX_NUMBER__INI_KEY			TEXT("INVALID_RECIPIENT_FAX_NUMBER")
TCHAR* g_szValidRecipientFaxNumber		=				NULL;
#define	VALID_RECIPIENT_FAX_NUMBER__INI_KEY				TEXT("VALID_RECIPIENT_FAX_NUMBER")

//
//TIFF files
//
TCHAR* g_szValid__TiffFileName = NULL;
#define	VALID_TIFF_FILE__INI_KEY								TEXT("VALID_TIFF_FILE")
TCHAR* g_szValid_ReadOnly_TiffFileName = NULL;
#define VALID_TIFF_FILE__READONLY__INI_KEY						TEXT("VALID_TIFF_FILE__READONLY")
TCHAR* g_szValid_FileNotFound_TiffFileName = NULL;
#define INVALID_TIFF_FILE__FILENOTFOUND__INI_KEY				TEXT("INVALID_TIFF_FILE__FILENOTFOUND")
TCHAR* g_szValid_UNC_TiffFileName = NULL;
#define VALID_TIFF_FILE__UNC__INI_KEY							TEXT("VALID_TIFF_FILE__UNC")
TCHAR* g_szValid_NTFS_TiffFileName = NULL;
#define VALID_TIFF_FILE__NTFS__INI_KEY							TEXT("VALID_TIFF_FILE__NTFS")
TCHAR* g_szValid_FAT_TiffFileName = NULL;
#define VALID_TIFF_FILE__FAT__INI_KEY							TEXT("VALID_TIFF_FILE__FAT")
TCHAR* g_szValid_Link_TiffFileName = NULL;
#define VALID_TIFF_FILE__LINK__INI_KEY							TEXT("VALID_TIFF_FILE__LINK")
TCHAR* g_szValid_NotTiffExt_TiffFileName = NULL;
#define INVALID_TIFF_FILE__NOT_TIFF_EXT__INI_KEY				TEXT("INVALID_TIFF_FILE__NOT_TIFF_EXT")
TCHAR* g_szValid_InvalidTiffFormat_TiffFileName = NULL;
#define INVALID_TIFF_FILE__INVALID_TIFF_FORMAT__INI_KEY			TEXT("INVALID_TIFF_FILE__INVALID_TIFF_FORMAT")
//Valid receive file name
TCHAR* g_szValid_ReceiveFileName = NULL;
#define VALID_TIFF_FILE__RECEIVE_FILE_NAME__INI_KEY				TEXT("VALID_TIFF_FILE__RECEIVE_FILE_NAME")


//
//Coverpage files
//
TCHAR* g_szValid__CoverpageFileName = NULL;
#define	VALID_COVERPAGE_FILE__INI_KEY										TEXT("VALID_COVERPAGE_FILE")	
TCHAR* g_szValid_ReadOnly_CoverpageFileName = NULL;
#define VALID_COVERPAGE_FILE__READONLY__INI_KEY								TEXT("VALID_COVERPAGE_FILE__READONLY")
TCHAR* g_szValid_FileNotFound_CoverpageFileName = NULL;
#define INVALID_COVERPAGE_FILE__FILENOTFOUND__INI_KEY						TEXT("INVALID_COVERPAGE_FILE__FILENOTFOUND")
TCHAR* g_szValid_UNC_CoverpageFileName = NULL;
#define VALID_COVERPAGE_FILE__UNC__INI_KEY									TEXT("VALID_COVERPAGE_FILE__UNC")
TCHAR* g_szValid_NTFS_CoverpageFileName = NULL;
#define VALID_COVERPAGE_FILE__NTFS__INI_KEY									TEXT("VALID_COVERPAGE_FILE__NTFS")
TCHAR* g_szValid_FAT_CoverpageFileName = NULL;
#define VALID_COVERPAGE_FILE__FAT__INI_KEY									TEXT("VALID_COVERPAGE_FILE__FAT")
TCHAR* g_szValid_Link_CoverpageFileName = NULL;
#define VALID_COVERPAGE_FILE__LINK__INI_KEY									TEXT("VALID_COVERPAGE_FILE__LINK")
TCHAR* g_szValid_NotCoverpageFormat_CoverpageFileName = NULL;
#define INVALID_COVERPAGE_FILE__NOT_COVERPAGE_FORMAT__INI_KEY				TEXT("INVALID_COVERPAGE_FILE__NOT_COVERPAGE_FORMAT")
TCHAR* g_szValid_InvalidCoverpageFormat_CoverpageFileName = NULL;
#define INVALID_COVERPAGE_FILE__INVALID_COVERPAGE_FORMAT__INI_KEY			TEXT("INVALID_COVERPAGE_FILE__INVALID_COVERPAGE_FORMAT")




//
//JOB status stuff
//
#define LAST_JOB_STATUS_INDEX			FSPI_JS_DELETED
#define LAST_JOB_EXTENDEND_STATUS_INDEX	FSPI_ES_NOT_FAX_CALL

bool g_bStatusFlowArray[LAST_JOB_STATUS_INDEX+1][LAST_JOB_STATUS_INDEX+1] = {
/*
/*														TO STATE
/*FROM State**************DUMMY	,UNKNOWN	,PENDING	,INPROGRESS	,SUSPENDING	,SUSPENDED	,RESUMING	,ABORTING	,ABORTED	,COMPLETED	,RETRY	,FAILED	,FAILED_NO_RETRY	,DELETED	*/
/********************************************************************************************************************************************************************************************/
/*DUMMY				****/{false	,true		,true		,true		,true		,true		,true		,true		,true		,true		,true	,true	,true				,true		},
/*JS_UNKNOWN		****/{false	,true		,true		,true	    ,true		,true       ,true       ,true		,true		,true		,true	,true	,true				,true		},
/*JS_PENDING		****/{false	,true		,true		,true	    ,true       ,false      ,false      ,true		,false		,false		,false	,false	,false				,true		},
/*JS_INPROGRESS		****/{false	,true		,false		,true	    ,true       ,false      ,true       ,true		,false		,true		,true	,true	,true				,true		},
/*JS_SUSPENDING		****/{false	,true		,false		,false	    ,true       ,true       ,false      ,false		,false		,false		,false	,false	,false				,true		},
/*JS_SUSPENDED		****/{false	,true		,false		,false	    ,false      ,true	    ,true       ,true		,false		,false		,false	,false	,false				,true		},
/*JS_RESUMING		****/{false	,true		,false		,true	    ,false		,false      ,true       ,true		,false		,false		,false	,false	,false				,true		},
/*JS_ABORTING		****/{false	,true		,false		,false		,false		,false      ,false	    ,true		,true		,false		,false	,false	,false				,true		},
/*JS_ABORTED		****/{false	,true		,false		,false		,false		,false      ,false	    ,false		,true		,false		,false	,false	,false				,true		},
/*JS_COMPLETED		****/{false	,true		,false		,false		,false		,false      ,false	    ,false		,false		,true		,false	,false	,false				,true		},
/*JS_RETRY			****/{false	,true		,false		,true	    ,true       ,false      ,false	    ,true		,false		,false		,true	,false	,false				,true		},
/*JS_FAILED			****/{false	,true		,false		,false		,false		,false      ,false	    ,false		,false		,false		,false	,true	,false				,true		},
/*JS_FAILED_NO_RETRY****/{false	,true		,false		,false		,false		,false      ,false	    ,false		,false		,false		,false	,false	,true				,true		},
/*JS_DELETED		****/{false	,true		,false		,false		,false		,false      ,false	    ,false		,false		,false		,false	,false	,false				,true		},
};

bool g_bExtendedStatusFlowArray[LAST_JOB_EXTENDEND_STATUS_INDEX+1][LAST_JOB_EXTENDEND_STATUS_INDEX+1] = {

/*
/*														TO Extended state
/*FROM Extended state******NONE	,DISCONNECTED	,INITIALIZING	,DIALING,TRANSMITTING	,ANSWERED	,RECEIVING	,LINE_UNAVAILABLE	,BUSY	,NO_ANSWER	,BAD_ADDRESS,NO_DIAL_TONE	,FATAL_ERROR,CALL_DELAYED	,CALL_BLACKLISTED	,NOT_FAX_CALL	*/
/****************************************************************************************************************************************************************************************************************************************************/
/*NONE(No given ES)	 ****/{true	,true			,true			,true	,true			,true		,true		,true				,true	,true		,true		,true			,true		,true			,true				,true			},
/*ES_DISCONNECTED	 ****/{true	,true			,false			,false	,false			,false		,false		,false				,false	,false		,false		,false			,false		,false			,false				,false			},
/*ES_INITIALIZING	 ****/{true	,false			,true			,true	,false			,true		,false		,false				,false	,false		,false		,false			,false		,false			,false				,false			},
/*ES_DIALING		 ****/{true	,false			,false			,true	,true			,false		,false		,false				,false	,false		,false		,false			,false		,false			,false				,false			},
/*ES_TRANSMITTING	 ****/{true	,false			,false			,false	,true			,false		,false		,false				,false	,false		,false		,false			,false		,false			,false				,false			},
/*ES_ANSWERED		 ****/{true	,false			,false			,false	,false			,true		,true		,false				,false	,false		,false		,false			,false		,false			,false				,false			},
/*ES_RECEIVING		 ****/{true	,false			,false			,false	,false			,false		,true		,false				,false	,false		,false		,false			,false		,false			,false				,false			},
/*ES_LINE_UNAVAILABLE****/{true	,false			,false			,false	,false			,false		,false		,false				,false	,false		,false		,false			,false		,false			,false				,false			},
/*ES_BUSY			 ****/{true	,false			,false			,false	,false			,false		,false		,false				,false	,false		,false		,false			,false		,false			,false				,false			},
/*ES_NO_ANSWER		 ****/{true	,false			,false			,false	,false			,false		,false		,false				,false	,false		,false		,false			,false		,false			,false				,false			},
/*ES_BAD_ADDRESS	 ****/{true	,false			,false			,false	,false			,false		,false		,false				,false	,false		,false		,false			,false		,false			,false				,false			},
/*ES_NO_DIAL_TONE	 ****/{true	,false			,false			,false	,false			,false		,false		,false				,false	,false		,false		,false			,false		,false			,false				,false			},
/*ES_FATAL_ERROR	 ****/{true	,false			,false			,false	,false			,false		,false		,false				,false	,false		,false		,false			,false		,false			,false				,false			},
/*ES_CALL_DELAYED	 ****/{true	,false			,false			,false	,false			,false		,false		,false				,false	,false		,false		,false			,false		,false			,false				,false			},
/*ES_CALL_BLACKLISTED****/{true	,false			,false			,false	,false			,false		,false		,false				,false	,false		,false		,false			,false		,false			,false				,false			},
/*ES_NOT_FAX_CALL	 ****/{true	,false			,false			,false	,false			,false		,false		,false				,false	,false		,false		,false			,false		,false			,false				,false			}
};




bool InitGlobalVariables()
{
	bool bRet = true;
	
	//
	//global completion port for use by all tests (for FaxDevStartJob)
	//
	g_hCompletionPortHandle = CreateCompletionPort();
	if (NULL == g_hCompletionPortHandle)
	{
		//
		//Logging in CreateCompletionPort()
		//
		bRet=false;
	}
	
	return bRet;
}






bool VerifyJobStatus(LPCFSPI_JOB_STATUS lpcFSPJobStatus)
{
	TCHAR szStatus[MAXSIZE_JOB_STATUS];
	TCHAR szExtendedStatus[MAXSIZE_JOB_STATUS];
	GetJobStatusString(lpcFSPJobStatus->dwJobStatus,szStatus);
	GetExtendedJobStatusString(lpcFSPJobStatus->dwExtendedStatus,szExtendedStatus);
	switch (lpcFSPJobStatus->dwJobStatus)
	{
	case FSPI_JS_UNKNOWN:
		switch (lpcFSPJobStatus->dwExtendedStatus)
		{
		case 0:
		case FSPI_ES_DISCONNECTED:
			return true;
		default:
			if (FSPI_ES_PROPRIETARY <= lpcFSPJobStatus->dwExtendedStatus)

			{
				//
				//EFSP private extended status
				//
				return true;
			}
			else
			{
				::lgLogError(
					LOG_SEV_1,
					TEXT("Job Status:%s doesn't support the extended Job Status:%s"),
					szStatus,
					szExtendedStatus
					);
				return false;
			}
		}
	
	case FSPI_JS_INPROGRESS:
		switch (lpcFSPJobStatus->dwExtendedStatus)
		{
		case 0:
		case FSPI_ES_INITIALIZING:
		case FSPI_ES_DIALING:
		case FSPI_ES_TRANSMITTING:
		case FSPI_ES_ANSWERED:
		case FSPI_ES_RECEIVING:
			return true;
		default:
			if (FSPI_ES_PROPRIETARY <= lpcFSPJobStatus->dwExtendedStatus)
			{
				//
				//EFSP private extended status
				//
				return true;
			}
			else
			{
				::lgLogError(
					LOG_SEV_1,
					TEXT("Job Status:%s doesn't support the extended Job Status:%s"),
					szStatus,
					szExtendedStatus
					);
				return false;
			}
		}

	case FSPI_JS_FAILED:
	case FSPI_JS_RETRY:
		switch (lpcFSPJobStatus->dwExtendedStatus)
		{
		case 0:
		case FSPI_ES_BUSY:
		case FSPI_ES_NO_ANSWER:
		case FSPI_ES_BAD_ADDRESS:
		case FSPI_ES_NO_DIAL_TONE:
		case FSPI_ES_DISCONNECTED:
		case FSPI_ES_FATAL_ERROR:
		case FSPI_ES_CALL_DELAYED:
		case FSPI_ES_CALL_BLACKLISTED:
		case FSPI_ES_NOT_FAX_CALL:
		case FSPI_ES_LINE_UNAVAILABLE:
			return true;
		default:
			if (FSPI_ES_PROPRIETARY <= lpcFSPJobStatus->dwExtendedStatus)
			{
				//
				//EFSP private extended status
				//
				return true;
			}
			else
			{
				::lgLogError(
					LOG_SEV_1,
					TEXT("Job Status:%s doesn't support the extended Job Status:%s"),
					szStatus,
					szExtendedStatus
					);
				return false;
			}
		}
		break;

	case FSPI_JS_PENDING:
	case FSPI_JS_SUSPENDING:
	case FSPI_JS_SUSPENDED:
	case FSPI_JS_RESUMING:
	case FSPI_JS_ABORTING:
	case FSPI_JS_ABORTED:
	case FSPI_JS_COMPLETED:
	case FSPI_JS_FAILED_NO_RETRY:
	case FSPI_JS_DELETED:
		if	( (0 == lpcFSPJobStatus->dwExtendedStatus) ||
			(FSPI_ES_PROPRIETARY <= lpcFSPJobStatus->dwExtendedStatus) )
		{
			return true;
		}
		else
		{
			::lgLogError(
					LOG_SEV_1,
					TEXT("Job Status:%s doesn't support the extended Job Status:%s"),
					szStatus,
					szExtendedStatus
					);
			return false;
		}
		
	default:
		lgLogError(
			LOG_SEV_1,
			TEXT("Job Status:0x%08x isn't supported"),
			lpcFSPJobStatus->dwJobStatus
			);
		return false;
	}

}

void GetJobStatusString(DWORD dwJobStatus,TCHAR *szJobStatus)
{
	switch (dwJobStatus)
	{
	case FSPI_JS_UNKNOWN: 
		lstrcpy(szJobStatus,TEXT("FSPI_JS_UNKNOWN"));
		break;
	case FSPI_JS_PENDING:
		lstrcpy(szJobStatus,TEXT("FSPI_JS_PENDING"));
		break;
	case FSPI_JS_INPROGRESS: 
		lstrcpy(szJobStatus,TEXT("FSPI_JS_INPROGRESS"));
		break;
	case FSPI_JS_SUSPENDING:
		lstrcpy(szJobStatus,TEXT("FSPI_JS_SUSPENDING"));
		break;
	case FSPI_JS_SUSPENDED: 
		lstrcpy(szJobStatus,TEXT("FSPI_JS_SUSPENDED"));
		break;
	case FSPI_JS_RESUMING:
		lstrcpy(szJobStatus,TEXT("FSPI_JS_RESUMING"));
		break;
	case FSPI_JS_ABORTING: 
		lstrcpy(szJobStatus,TEXT("FSPI_JS_ABORTING"));
		break;
	case FSPI_JS_ABORTED:
		lstrcpy(szJobStatus,TEXT("FSPI_JS_ABORTED"));
		break;
	case FSPI_JS_COMPLETED: 
		lstrcpy(szJobStatus,TEXT("FSPI_JS_COMPLETED"));
		break;
	case FSPI_JS_RETRY:
		lstrcpy(szJobStatus,TEXT("FSPI_JS_RETRY"));
		break;
	case FSPI_JS_FAILED: 
		lstrcpy(szJobStatus,TEXT("FSPI_JS_FAILED"));
		break;
	case FSPI_JS_FAILED_NO_RETRY:
		lstrcpy(szJobStatus,TEXT("FSPI_JS_FAILED_NO_RETRY"));
		break;
	case FSPI_JS_DELETED: 
		lstrcpy(szJobStatus,TEXT("FSPI_JS_DELETED"));
		break;
	default:
		_stprintf(szJobStatus,TEXT("Unsupported Job Status(0x%08x)"),dwJobStatus);
		break;
	}

}

void GetExtendedJobStatusString(DWORD dwExtendedStatus,TCHAR *szJobExtendedStatus)
{
	switch (dwExtendedStatus)
	{
	case 0:
		lstrcpy(szJobExtendedStatus,TEXT("No Extended Job Status given"));	
		break;

	case FSPI_ES_DISCONNECTED: 
		lstrcpy(szJobExtendedStatus,TEXT("FSPI_ES_DISCONNECTED"));
		break;
	case FSPI_ES_INITIALIZING: 
		lstrcpy(szJobExtendedStatus,TEXT("FSPI_ES_INITIALIZING"));
		break;
	case FSPI_ES_DIALING: 
		lstrcpy(szJobExtendedStatus,TEXT("FSPI_ES_DIALING"));
		break;
	case FSPI_ES_TRANSMITTING: 
		lstrcpy(szJobExtendedStatus,TEXT("FSPI_ES_TRANSMITTING"));
		break;
	case FSPI_ES_ANSWERED: 
		lstrcpy(szJobExtendedStatus,TEXT("FSPI_ES_ANSWERED"));
		break;
	case FSPI_ES_RECEIVING: 
		lstrcpy(szJobExtendedStatus,TEXT("FSPI_ES_RECEIVING"));
		break;
	case FSPI_ES_LINE_UNAVAILABLE: 
		lstrcpy(szJobExtendedStatus,TEXT("FSPI_ES_LINE_UNAVAILABLE"));
		break;
	case FSPI_ES_BUSY: 
		lstrcpy(szJobExtendedStatus,TEXT("FSPI_ES_BUSY"));
		break;
	case FSPI_ES_NO_ANSWER: 
		lstrcpy(szJobExtendedStatus,TEXT("FSPI_ES_NO_ANSWER"));
		break;
	case FSPI_ES_BAD_ADDRESS: 
		lstrcpy(szJobExtendedStatus,TEXT("FSPI_ES_BAD_ADDRESS"));
		break;
	case FSPI_ES_NO_DIAL_TONE: 
		lstrcpy(szJobExtendedStatus,TEXT("FSPI_ES_NO_DIAL_TONE"));
		break;
	case FSPI_ES_FATAL_ERROR: 
		lstrcpy(szJobExtendedStatus,TEXT("FSPI_ES_FATAL_ERROR"));
		break;
	case FSPI_ES_CALL_DELAYED: 
		lstrcpy(szJobExtendedStatus,TEXT("FSPI_ES_CALL_DELAYED"));
		break;
	case FSPI_ES_CALL_BLACKLISTED: 
		lstrcpy(szJobExtendedStatus,TEXT("FSPI_ES_CALL_BLACKLISTED"));
		break;
	case FSPI_ES_NOT_FAX_CALL: 
		lstrcpy(szJobExtendedStatus,TEXT("FSPI_ES_NOT_FAX_CALL"));
		break;
	case FSPI_ES_HANDLED: 
		lstrcpy(szJobExtendedStatus,TEXT("FSPI_ES_HANDLED"));
		break;
	default:
		if (FSPI_ES_PROPRIETARY <= dwExtendedStatus)
		{
			_stprintf(szJobExtendedStatus,TEXT("EFSP Private Extended Job State(0x%08x)"),dwExtendedStatus);
		}
		else
		{
			_stprintf(szJobExtendedStatus,TEXT("Unsupported Extended Job Status(0x%08x)"),dwExtendedStatus);
		}
		break;
	}
}

void LogJobStatus(
	HANDLE hFSP,
	HANDLE hFSPJob,
	LPCFSPI_JOB_STATUS lpcFSPJobStatus
	)
{
	TCHAR szJobStatus[MAXSIZE_JOB_STATUS];
	TCHAR szJobExtendedStatus[MAXSIZE_JOB_STATUS];
	
	GetJobStatusString(lpcFSPJobStatus->dwJobStatus,szJobStatus);
	GetExtendedJobStatusString(lpcFSPJobStatus->dwExtendedStatus,szJobExtendedStatus);

	::lgLogDetail(
		LOG_X,
		2,
		TEXT("\n**\n***\nEFSP Handle=0x%08x , Job Handle=0x%08x \nJobStatus=%s, JobExtendedStatus=%s\n***\n**\n"),
		hFSP,
		hFSPJob,
		szJobStatus,
		szJobExtendedStatus
		);
}


void FaxDevShutdownWrapper()
{
	HRESULT hr = S_OK;
	hr = g_pEFSP->FaxDevShutdown();
	if (FSPI_S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FaxDevShutdown() failed with error 0x%08x"),
			hr
			);
	}
	//
	//Clear the Max message ID size member
	//
	g_pEFSP->SetMaxMessageIdSize(0);

}

bool FaxDevInitializeExWrapperWithReceive()
{
	assert (NULL != g_pEFSP);

	//
	//For this tests we need to call FaxDevInit
	//
	HANDLE						hFSP				=	(HANDLE) 100;
	PFAX_LINECALLBACK			LineCallbackFunction=	NULL;
    PFAX_SERVICE_CALLBACK_EX	FaxServiceCallbackEx=	FaxDeviceProviderCallbackExWithReceiveCaps;
    DWORD						dwMaxMessageIdSize	=	0;
	

	const CFaxDevInitParams faxDevInitParams(
		hFSP,
		NULL,
		&LineCallbackFunction,
		FaxServiceCallbackEx,
		&dwMaxMessageIdSize
		);


	//
	//This call to FaxDevInitEx() is for all the test suite
	//
	return (FaxDevInitializeExWrapper(faxDevInitParams,false));
}

bool FaxDevInitializeExWrapper(const CFaxDevInitParams faxDevInitParamsToTest, bool bShouldFail)
{
	HRESULT hr = S_OK;
	bool bRet = false;
	if (g_pEFSP == NULL)
	{
		//
		//First load the EFSP
		//
		if (false == InitEfsp())
		{
			goto out;
		}
	}

	hr = g_pEFSP->FaxDevInitializeEx(
		faxDevInitParamsToTest.m_hFSP,
		faxDevInitParamsToTest.m_LineAppHandle,
		faxDevInitParamsToTest.m_LineCallbackFunction,
		faxDevInitParamsToTest.m_FaxServiceCallbackEx,
		faxDevInitParamsToTest.m_lpdwMaxMessageIdSize
		);
	if (FSPI_S_OK != hr)
	{
		if (true == bShouldFail)
		{
			::lgLogDetail(
				LOG_PASS,
				5,
				TEXT("FaxDevInitializeEx() failed with error 0x%08x, as expected"),
				hr
				);
		}
		else
		{
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FaxDevInitializeEx() failed with error 0x%08x"),
				hr
				);
		}
		bRet = false;
	}
	else
	{
		//
		//FaxDevInitEx() succeeded
		//
		if (true == g_pEFSP->IsReestablishEFSP())
		{
			if (0 == *(faxDevInitParamsToTest.m_lpdwMaxMessageIdSize))
			{
				::lgLogError(
					LOG_SEV_1,
					TEXT("INI file states that the EFSP supports job re-establishment, but in the call to FaxDevInitializeEx() the EFSP reported dwMaxMessageIdSize==0")
					);
				//
				//We return true, since FaxDevInitializeEx succeded
				//
				return true;
			}
		}
		
		//
		//Save the Max message ID size
		//
		g_pEFSP->SetMaxMessageIdSize(*(faxDevInitParamsToTest.m_lpdwMaxMessageIdSize));
		
		//
		//Should it succeed?
		//
		if (true == bShouldFail)
		{
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FaxDevInitializeEx() returned S_OK and should fail")
				);
		}
		else
		{
			::lgLogDetail(
				LOG_PASS,
				5,
				TEXT("FaxDevInitializeEx() succeeded")
				);
		}
		
		bRet = true;
	}
out:
	return bRet;
}

void GetErrorString(DWORD dwErrorCode,TCHAR *szErrorString)
{

	LPVOID lpMsgBuf;
	if (0 < FormatMessage( 
		FORMAT_MESSAGE_ALLOCATE_BUFFER | 
		FORMAT_MESSAGE_FROM_SYSTEM | 
		FORMAT_MESSAGE_IGNORE_INSERTS,
		NULL,
		dwErrorCode,
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
		(LPTSTR) &lpMsgBuf,
		0,
		NULL 
	))
	{
		_tcscpy(szErrorString,(LPTSTR) lpMsgBuf);
		LocalFree( lpMsgBuf );
	}
	else 
	{
		_tcscpy(szErrorString,TEXT("Unknown ERROR"));
	}


}

HRESULT GetValueFromINI(
	TCHAR *szINISectionName,
	TCHAR *szINIKeyName,
	TCHAR *szResponseString,
	DWORD dwSize
	)
{
	HRESULT hr = S_OK;
	DWORD dwGetPrivateProfileStringStatus;
	
	//
	//Allocate a buffer to work with
	//
	TCHAR * szIniString = (TCHAR *) malloc(dwSize);
	if (!szIniString)
	{
		hr = E_OUTOFMEMORY;
		goto out;
	}
	::ZeroMemory(szIniString,dwSize);

	dwGetPrivateProfileStringStatus = ::GetPrivateProfileString(
		szINISectionName,		// points to section name
		szINIKeyName,			// points to key name
		TEXT(""),				// points to default string
		szIniString,			// points to destination buffer
		dwSize,					// size of destination buffer
		g_szFspIniFileName		// points to initialization filename
		);
	if (0 > dwGetPrivateProfileStringStatus)
	{
		hr = HRESULT_FROM_WIN32(ERROR_READ_FAULT);
		goto out;
	}
	
	if(dwGetPrivateProfileStringStatus == dwSize - 1)
	{
		hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
		goto out;
	}

	::_tcscpy(szResponseString,szIniString);

out:
	free(szIniString);
	return hr;
}



TCHAR *GetEfspToLoad()
{
	if (NULL != g_szModuleName)
	{
		//
		//g_szModuleName already contains the module name, just return it
		//
		return g_szModuleName;
	}

	//
	//Get the module name from the registry and set it in the global variable
	//
	TCHAR szBufferToConvert[MAX_INI_VALUE];
	if (S_OK != GetValueFromINI(
		INI_SECTION__EFSP_SETTINGS,
		EFSP_MODULE_NAME__INI_KEY,
		szBufferToConvert,
		MAX_INI_VALUE
		))
	{
		return NULL;
	}
	
	//
	//Duplicate the string, CALLER MUST FREE THIS BUFFER
	//
	g_szModuleName = ::_tcsdup(szBufferToConvert);
	return g_szModuleName;
}

void GetCasesToRun()
{
	TCHAR szIniValue[MAX_INI_VALUE];
	TCHAR szKeyName[MAX_INI_VALUE];
	INT i = 0;

	::lgLogDetail(
		LOG_X,
		5,
		TEXT("I will run the following test case numbers")
		);

	for (i=0; i < LAST_CASE_NUMBER ;i++)
	{
		//
		//Prepare the key name to read
		//
		_stprintf( szKeyName, TEXT("Case%d"),i);
		if (S_OK != GetValueFromINI(
			INI_SECTION__CASES,
			szKeyName,
			szIniValue,
			MAX_INI_VALUE
			))
		{
			//
			//Reading from INI has failed for some reason
			//no point in quilting all the test cases,
			//we'll use the default value: don't run this test case
			//
			baRunThisTest[i] = false;
			continue;
		}
		if (0 == _tcscmp(szIniValue,TEXT("True")))
		{
			//
			//the default is: don't run this test case
			//
			baRunThisTest[i] = true;
			::lgLogDetail(
				LOG_X,
				5,
				TEXT("Run Test case: %d"),
				i
				);
		}
		else
		{
			//
			//default is don't run
			//
			baRunThisTest[i] = false;
		}
	}
}

bool GetIniSettings()
{
	//
	//EFSP Settings
	//
	g_szModuleName = GetEfspToLoad();
	if (NULL == g_szModuleName)
	{
		return false;
	}

	//
	//DeviceIDs
	//
	TCHAR szBufferToConvert[MAX_INI_VALUE];
	if (S_OK != GetValueFromINI(
		INI_SECTION__EFSP_SETTINGS,
		INVALID_DEVICE_ID__INI_KEY,
		szBufferToConvert,
		MAX_INI_VALUE
		))
	{
		return false;
	}
	g_dwInvalidDeviceId = _ttol(szBufferToConvert);

	if (S_OK != GetValueFromINI(
		INI_SECTION__EFSP_SETTINGS,
		SENDING_VALID_DEVICE_ID__INI_KEY,
		szBufferToConvert,
		MAX_INI_VALUE
		))
	{
		return false;
	}
	g_dwSendingValidDeviceId = ::_ttol(szBufferToConvert);

	if (S_OK != GetValueFromINI(
		INI_SECTION__EFSP_SETTINGS,
		RECEIVE_VALID_DEVICE_ID__INI_KEY,
		szBufferToConvert,
		MAX_INI_VALUE
		))
	{
		return false;
	}
	g_dwReceiveValidDeviceId = ::_ttol(szBufferToConvert);

	if (S_OK != GetValueFromINI(
		INI_SECTION__EFSP_SETTINGS,
		EFSP_CAP__INI_KEY,
		szBufferToConvert,
		MAX_INI_VALUE
		))
	{
		return false;
	}
	g_dwEfspCaps = ::_ttol(szBufferToConvert);
		
	if (S_OK != GetValueFromINI(
		INI_SECTION__EFSP_SETTINGS,
		REESTABLISH_EFSP__INI_KEY,
		szBufferToConvert,
		MAX_INI_VALUE
		))
	{
		return false;
	}
	if (0 == ::_tcscmp(szBufferToConvert,TEXT("true")))
	{
		g_bReestablishEfsp = true;
	}
	else
	{
		g_bReestablishEfsp = false;
	}

	if (S_OK != GetValueFromINI(
		INI_SECTION__EFSP_SETTINGS,
		VIRTUAL_EFSP__INI_KEY,
		szBufferToConvert,
		MAX_INI_VALUE
		))
	{
		return false;
	}
	if (0 == ::_tcscmp(szBufferToConvert,TEXT("true")))
	{
		g_bVirtualEfsp = true;
	}
	else
	{
		g_bVirtualEfsp = false;
	}

	//
	//General
	//
	if (S_OK != GetValueFromINI(
		INI_SECTION__GENERAL,
		MAX_TIME_FOR_RECEIVING_FAX__INI_KEY,
		szBufferToConvert,
		MAX_INI_VALUE
		))
	{
		::lgLogError(
			LOG_SEV_2,
			TEXT("Can't find the MaxReceiveTimeOut settings")
			);
		return false;
	}
	g_dwReceiveTimeOut = _ttol(szBufferToConvert);

	//
	//EFSP time till ringing and transfering bits
	//
	if (S_OK != GetValueFromINI(
		INI_SECTION__GENERAL,
		TIME_FROM_SEND_START_TILL_RINGING_STARTS__INI_KEY,
		szBufferToConvert,
		MAX_INI_VALUE
		))
	{
		::lgLogError(
			LOG_SEV_2,
			TEXT("Can't find the Time till ringing starts settings")
			);
		return false;
	}
	g_dwTimeTillRingingStarts = _ttol(szBufferToConvert);
	if (S_OK != GetValueFromINI(
		INI_SECTION__GENERAL,
		TIME_FROM_SEND_START_TILL_TRANSFERING_BITS_STARTS__INI_KEY,
		szBufferToConvert,
		MAX_INI_VALUE
		))
	{
		::lgLogError(
			LOG_SEV_2,
			TEXT("Can't find the Time till ringing starts settings")
			);
		return false;
	}
	g_dwTimeTillTransferingBitsStarts = _ttol(szBufferToConvert);

	
	//
	//Phone Numbers
	//
	if (S_OK != GetValueFromINI(
		INI_SECTION__PHONE_NUMBERS,
		VALID_RECIPIENT_FAX_NUMBER__INI_KEY,
		g_szValidRecipientFaxNumber,
		MAX_INI_VALUE
		))
	{
		return false;
	}
	if (S_OK != GetValueFromINI(
		INI_SECTION__PHONE_NUMBERS,
		INVALID_RECIPIENT_FAX_NUMBER__INI_KEY,
		g_szInvalidRecipientFaxNumber,
		MAX_INI_VALUE
		))
	{
		return false;
	}
	
	//
	//TIFF files
	//
	if (S_OK != GetValueFromINI(
		INI_SECTION__TIFF_FILES,
		VALID_TIFF_FILE__INI_KEY,
		g_szValid__TiffFileName,
		MAX_INI_VALUE
		))
	{
		return false;
	}
	if (S_OK != GetValueFromINI(
		INI_SECTION__TIFF_FILES,
		VALID_TIFF_FILE__READONLY__INI_KEY,
		g_szValid_ReadOnly_TiffFileName,
		MAX_INI_VALUE
		))
	{
		return false;
	}
	if (S_OK != GetValueFromINI(
		INI_SECTION__TIFF_FILES,
		INVALID_TIFF_FILE__FILENOTFOUND__INI_KEY,
		g_szValid_FileNotFound_TiffFileName,
		MAX_INI_VALUE
		))
	{
		return false;
	}
	if (S_OK != GetValueFromINI(
		INI_SECTION__TIFF_FILES,
		VALID_TIFF_FILE__UNC__INI_KEY,
		g_szValid_UNC_TiffFileName,
		MAX_INI_VALUE
		))
	{
		return false;
	}
	if (S_OK != GetValueFromINI(
		INI_SECTION__TIFF_FILES,
		VALID_TIFF_FILE__NTFS__INI_KEY,
		g_szValid_NTFS_TiffFileName,
		MAX_INI_VALUE
		))
	{
		return false;
	}
	if (S_OK != GetValueFromINI(
		INI_SECTION__TIFF_FILES,
		VALID_TIFF_FILE__FAT__INI_KEY,
		g_szValid_FAT_TiffFileName,
		MAX_INI_VALUE
		))
	{
		return false;
	}
	if (S_OK != GetValueFromINI(
		INI_SECTION__TIFF_FILES,
		VALID_TIFF_FILE__LINK__INI_KEY,
		g_szValid_Link_TiffFileName,
		MAX_INI_VALUE
		))
	{
		return false;
	}
	if (S_OK != GetValueFromINI(
		INI_SECTION__TIFF_FILES,
		INVALID_TIFF_FILE__NOT_TIFF_EXT__INI_KEY,
		g_szValid_NotTiffExt_TiffFileName,
		MAX_INI_VALUE
		))
	{
		return false;
	}
	if (S_OK != GetValueFromINI(
		INI_SECTION__TIFF_FILES,
		INVALID_TIFF_FILE__INVALID_TIFF_FORMAT__INI_KEY,
		g_szValid_InvalidTiffFormat_TiffFileName,
		MAX_INI_VALUE
		))
	{
		return false;
	}
	if (S_OK != GetValueFromINI(
		INI_SECTION__TIFF_FILES,
		VALID_TIFF_FILE__RECEIVE_FILE_NAME__INI_KEY,
		g_szValid_ReceiveFileName,
		MAX_INI_VALUE
		))
	{
		return false;
	}

	//
	//Coverpage files
	//
	if (S_OK != GetValueFromINI(
		INI_SECTION__COVERPAGE_FILES,
		VALID_COVERPAGE_FILE__INI_KEY,
		g_szValid__CoverpageFileName,
		MAX_INI_VALUE
		))
	{
		return false;
	}
	if (S_OK != GetValueFromINI(
		INI_SECTION__COVERPAGE_FILES,
		VALID_COVERPAGE_FILE__READONLY__INI_KEY,
		g_szValid_ReadOnly_CoverpageFileName,
		MAX_INI_VALUE
		))
	{
		return false;
	}
	if (S_OK != GetValueFromINI(
		INI_SECTION__COVERPAGE_FILES,
		INVALID_COVERPAGE_FILE__FILENOTFOUND__INI_KEY,
		g_szValid_FileNotFound_CoverpageFileName,
		MAX_INI_VALUE
		))
	{
		return false;
	}
	if (S_OK != GetValueFromINI(
		INI_SECTION__COVERPAGE_FILES,
		VALID_COVERPAGE_FILE__UNC__INI_KEY,
		g_szValid_UNC_CoverpageFileName,
		MAX_INI_VALUE
		))
	{
		return false;
	}
	if (S_OK != GetValueFromINI(
		INI_SECTION__COVERPAGE_FILES,
		VALID_COVERPAGE_FILE__NTFS__INI_KEY,
		g_szValid_NTFS_CoverpageFileName,
		MAX_INI_VALUE
		))
	{
		return false;
	}
	if (S_OK != GetValueFromINI(
		INI_SECTION__COVERPAGE_FILES,
		VALID_COVERPAGE_FILE__FAT__INI_KEY,
		g_szValid_FAT_CoverpageFileName,
		MAX_INI_VALUE
		))
	{
		return false;
	}
	if (S_OK != GetValueFromINI(
		INI_SECTION__COVERPAGE_FILES,
		VALID_COVERPAGE_FILE__LINK__INI_KEY,
		g_szValid_Link_CoverpageFileName,
		MAX_INI_VALUE
		))
	{
		return false;
	}
	if (S_OK != GetValueFromINI(
		INI_SECTION__COVERPAGE_FILES,
		INVALID_COVERPAGE_FILE__NOT_COVERPAGE_FORMAT__INI_KEY,
		g_szValid_NotCoverpageFormat_CoverpageFileName,
		MAX_INI_VALUE
		))
	{
		return false;
	}
		if (S_OK != GetValueFromINI(
		INI_SECTION__COVERPAGE_FILES,
		INVALID_COVERPAGE_FILE__INVALID_COVERPAGE_FORMAT__INI_KEY,
		g_szValid_InvalidCoverpageFormat_CoverpageFileName,
		MAX_INI_VALUE
		))
	{
		return false;
	}

	//
	//Log the INI settings
	//
	
	//
	//Tiffs
	//
	::lgLogDetail(
		LOG_X,
		5,
		TEXT("\n\n***INI Settings***\nFSP=%s%s%s"),
		g_szModuleName,
		TEXT("\n******************"),
		TEXT("\n***Tiff Files***")
		);
	::lgLogDetail(
		LOG_X,
		5,
		TEXT("Valid tiff file is: \"%s\""),
		g_szValid__TiffFileName
		);
	::lgLogDetail(
		LOG_X,
		5,
		TEXT("Valid readonly tiff file is: \"%s\""),
		g_szValid_ReadOnly_TiffFileName
		);
	::lgLogDetail(
		LOG_X,
		5,
		TEXT("File not found tiff file is: \"%s\""),
		g_szValid_FileNotFound_TiffFileName
		);
	::lgLogDetail(
		LOG_X,
		5,
		TEXT("Valid UNC path tiff file is: \"%s\""),
		g_szValid_UNC_TiffFileName
		);
	::lgLogDetail(
		LOG_X,
		5,
		TEXT("Valid tiff file on NTFS File System is: \"%s\""),
		g_szValid_NTFS_TiffFileName
		);
	::lgLogDetail(
		LOG_X,
		5,
		TEXT("Valid tiff file on FAT File System is: \"%s\""),
		g_szValid_FAT_TiffFileName
		);
	::lgLogDetail(
		LOG_X,
		5,
		TEXT("Valid link to to a tiff file is: \"%s\""),
		g_szValid_Link_TiffFileName
		);
	::lgLogDetail(
		LOG_X,
		5,
		TEXT("tiff file with out a tiff extension is: \"%s\""),
		g_szValid_NotTiffExt_TiffFileName
		);
	::lgLogDetail(
		LOG_X,
		5,
		TEXT("tiff file with an incorrect tiff version is: \"%s\""),
		g_szValid_InvalidTiffFormat_TiffFileName
		);
	::lgLogDetail(
		LOG_X,
		5,
		TEXT("Receive tiff file to: \"%s\""),
		g_szValid_ReceiveFileName
		);


	//
	//Coverpages
	//
	::lgLogDetail(
		LOG_X,
		5,
		TEXT("\n***Coverpage Files***")
		);
	::lgLogDetail(
		LOG_X,
		5,
		TEXT("Valid coverpage file is: \"%s\""),
		g_szValid__CoverpageFileName
		);
	::lgLogDetail(
		LOG_X,
		5,
		TEXT("Valid readonly coverpage file is: \"%s\""),
		g_szValid_ReadOnly_CoverpageFileName
		);
	::lgLogDetail(
		LOG_X,
		5,
		TEXT("File not found coverpage file is: \"%s\""),
		g_szValid_FileNotFound_CoverpageFileName
		);
	::lgLogDetail(
		LOG_X,
		5,
		TEXT("Valid UNC path coverpage file is: \"%s\""),
		g_szValid_UNC_CoverpageFileName
		);
	::lgLogDetail(
		LOG_X,
		5,
		TEXT("Valid coverpage file on NTFS File System is: \"%s\""),
		g_szValid_NTFS_CoverpageFileName
		);
	::lgLogDetail(
		LOG_X,
		5,
		TEXT("Valid coverpage file on FAT File System is: \"%s\""),
		g_szValid_FAT_CoverpageFileName
		);
	::lgLogDetail(
		LOG_X,
		5,
		TEXT("Valid link to to a coverpage file is: \"%s\""),
		g_szValid_Link_CoverpageFileName
		);
	::lgLogDetail(
		LOG_X,
		5,
		TEXT("coverpage file with out a coverpage extension is: \"%s\""),
		g_szValid_NotCoverpageFormat_CoverpageFileName
		);
	::lgLogDetail(
		LOG_X,
		5,
		TEXT("coverpage file with an incorrect coverpage version is: \"%s\""),
		g_szValid_InvalidCoverpageFormat_CoverpageFileName
		);

	//
	//Phone number settings
	//
	::lgLogDetail(
		LOG_X,
		5,
		TEXT("\n***Phone number settings***")
		);
	::lgLogDetail(
		LOG_X,
		5,
		TEXT("Invalid recipient number is: %s"),
		g_szInvalidRecipientFaxNumber
		);
	::lgLogDetail(
		LOG_X,
		5,
		TEXT("Valid recipient number is: %s"),
		g_szValidRecipientFaxNumber
		);
	
	//
	//Other settings
	//
	::lgLogDetail(
		LOG_X,
		5,
		TEXT("\n***Other settings***")
		);
	::lgLogDetail(
		LOG_X,
		5,
		TEXT("EFSP Caps are: 0x%x"),
		g_dwEfspCaps
		);
	if (true == g_bReestablishEfsp)
	{
		::lgLogDetail(
			LOG_X,
			5,
			TEXT("EFSP supports Job re-establishment")
			);
	}
	else
	{
		::lgLogDetail(
			LOG_X,
			5,
			TEXT("EFSP does not support Job re-establishment")
			);
	}
	if (true == g_bVirtualEfsp)
	{
		::lgLogDetail(
			LOG_X,
			5,
			TEXT("EFSP is a virtual EFSP")
			);
	}
	else
	{
		::lgLogDetail(
			LOG_X,
			5,
			TEXT("EFSP is not a virtual EFSP")
			);
	}
	::lgLogDetail(
		LOG_X,
		5,
		TEXT("Valid Sending device ID: %d"),
		g_dwSendingValidDeviceId
		);
	::lgLogDetail(
		LOG_X,
		5,
		TEXT("Valid Receiving device ID: %d"),
		g_dwReceiveValidDeviceId
		);

	::lgLogDetail(
		LOG_X,
		5,
		TEXT("Invalid device ID: %d"),
		g_dwInvalidDeviceId
		);

	::lgLogDetail(
		LOG_X,
		5,
		TEXT("Max TimeOut for receive the default (valid tiff) fax is: %d"),
		g_dwReceiveTimeOut
		);

	::lgLogDetail(
		LOG_X,
		5,
		TEXT("Time in milliseconds from the start of the send operation until the receiving device starts to ring: %d"),
		g_dwTimeTillRingingStarts
		);
	
	::lgLogDetail(
		LOG_X,
		5,
		TEXT("Time in milliseconds from the start of the send operation until the receiving device answers and bits are transferred: %d"),
		g_dwTimeTillTransferingBitsStarts
		);

	GetCasesToRun();
	return true;
}



bool AllocGlobalVariables()
{


	//
	//TIFF files
	//
	g_szValid__TiffFileName								= (TCHAR*) malloc(sizeof(TCHAR)*MAX_INI_VALUE);
	if (NULL == g_szValid__TiffFileName								)
	{
		goto error;
	}
	g_szValid_ReadOnly_TiffFileName						= (TCHAR*) malloc(sizeof(TCHAR)*MAX_INI_VALUE);
	if (NULL == g_szValid_ReadOnly_TiffFileName						)
	{
		goto error;
	}
	g_szValid_FileNotFound_TiffFileName					= (TCHAR*) malloc(sizeof(TCHAR)*MAX_INI_VALUE);
	if (NULL == g_szValid_FileNotFound_TiffFileName					)
	{
		goto error;
	}
	g_szValid_UNC_TiffFileName							= (TCHAR*) malloc(sizeof(TCHAR)*MAX_INI_VALUE);
	if (NULL == g_szValid_UNC_TiffFileName							)
	{
		goto error;
	}
	g_szValid_NTFS_TiffFileName							= (TCHAR*) malloc(sizeof(TCHAR)*MAX_INI_VALUE);
	if (NULL == g_szValid_NTFS_TiffFileName							)
	{
		goto error;
	}
	g_szValid_FAT_TiffFileName							= (TCHAR*) malloc(sizeof(TCHAR)*MAX_INI_VALUE);
	if (NULL == g_szValid_FAT_TiffFileName							)
	{
		goto error;
	}
	g_szValid_Link_TiffFileName							= (TCHAR*) malloc(sizeof(TCHAR)*MAX_INI_VALUE);
	if (NULL == g_szValid_Link_TiffFileName							)
	{
		goto error;
	}
	g_szValid_NotTiffExt_TiffFileName					= (TCHAR*) malloc(sizeof(TCHAR)*MAX_INI_VALUE);
	if (NULL == g_szValid_NotTiffExt_TiffFileName					)
	{
		goto error;
	}
	g_szValid_InvalidTiffFormat_TiffFileName			= (TCHAR*) malloc(sizeof(TCHAR)*MAX_INI_VALUE);
	if (NULL == g_szValid_InvalidTiffFormat_TiffFileName			)
	{
		goto error;
	}
	g_szValid_ReceiveFileName							= (TCHAR*) malloc(sizeof(TCHAR)*MAX_INI_VALUE);
	if (NULL == g_szValid_ReceiveFileName							)
	{
		goto error;
	}


	//
	//Coverpage files
	//
	g_szValid__CoverpageFileName						= (TCHAR*) malloc(sizeof(TCHAR)*MAX_INI_VALUE);
	if (NULL == g_szValid__CoverpageFileName						)
	{
		goto error;
	}
	g_szValid_ReadOnly_CoverpageFileName				= (TCHAR*) malloc(sizeof(TCHAR)*MAX_INI_VALUE);
	if (NULL == g_szValid_ReadOnly_CoverpageFileName				)
	{
		goto error;
	}
	g_szValid_FileNotFound_CoverpageFileName			= (TCHAR*) malloc(sizeof(TCHAR)*MAX_INI_VALUE);
	if (NULL == g_szValid_FileNotFound_CoverpageFileName			)
	{
		goto error;
	}
	g_szValid_UNC_CoverpageFileName						= (TCHAR*) malloc(sizeof(TCHAR)*MAX_INI_VALUE);
	if (NULL == g_szValid_UNC_CoverpageFileName						)
	{
		goto error;
	}
	g_szValid_NTFS_CoverpageFileName					= (TCHAR*) malloc(sizeof(TCHAR)*MAX_INI_VALUE);
	if (NULL == g_szValid_NTFS_CoverpageFileName					)
	{
		goto error;
	}
	g_szValid_FAT_CoverpageFileName						= (TCHAR*) malloc(sizeof(TCHAR)*MAX_INI_VALUE);
	if (NULL == g_szValid_FAT_CoverpageFileName						)
	{
		goto error;
	}
	g_szValid_Link_CoverpageFileName					= (TCHAR*) malloc(sizeof(TCHAR)*MAX_INI_VALUE);
	if (NULL == g_szValid_Link_CoverpageFileName					)
	{
		goto error;
	}
	g_szValid_NotCoverpageFormat_CoverpageFileName		= (TCHAR*) malloc(sizeof(TCHAR)*MAX_INI_VALUE);
	if (NULL == g_szValid_NotCoverpageFormat_CoverpageFileName		)
	{
		goto error;
	}
	g_szValid_InvalidCoverpageFormat_CoverpageFileName	= (TCHAR*) malloc(sizeof(TCHAR)*MAX_INI_VALUE);
	if (NULL == g_szValid_InvalidCoverpageFormat_CoverpageFileName	)
	{
		goto error;
	}

	//
	//other variables
	//
	g_szInvalidRecipientFaxNumber						= (TCHAR*) malloc(sizeof(TCHAR)*MAX_INI_VALUE);
	if (NULL == g_szInvalidRecipientFaxNumber						)
	{
		goto error;
	}
	g_szValidRecipientFaxNumber							= (TCHAR*) malloc(sizeof(TCHAR)*MAX_INI_VALUE);
	if (NULL == g_szValidRecipientFaxNumber							)
	{
		goto error;
	}

	return true;

error:
	FreeGlobalVariables();
	return false;
}

void FreeGlobalVariables()
{
	//
	//TIFF files
	//
	free(g_szValid__TiffFileName);
	free(g_szValid_ReadOnly_TiffFileName);
	free(g_szValid_FileNotFound_TiffFileName);
	free(g_szValid_UNC_TiffFileName);
	free(g_szValid_NTFS_TiffFileName);
	free(g_szValid_FAT_TiffFileName);
	free(g_szValid_Link_TiffFileName);
	free(g_szValid_NotTiffExt_TiffFileName);
	free(g_szValid_InvalidTiffFormat_TiffFileName);


	//
	//Coverpage files
	//
	free(g_szValid__CoverpageFileName);
	free(g_szValid_ReadOnly_CoverpageFileName);
	free(g_szValid_FileNotFound_CoverpageFileName);
	free(g_szValid_UNC_CoverpageFileName);
	free(g_szValid_NTFS_CoverpageFileName);
	free(g_szValid_FAT_CoverpageFileName);
	free(g_szValid_Link_CoverpageFileName);
	free(g_szValid_NotCoverpageFormat_CoverpageFileName);
	free(g_szValid_InvalidCoverpageFormat_CoverpageFileName);

	//
	//other variables
	//
	free(g_szInvalidRecipientFaxNumber);
	free(g_szValidRecipientFaxNumber);
}




HRESULT CALLBACK FaxDeviceProviderCallbackExWithReceiveCaps(
    IN HANDLE hFSP,
    IN DWORD  dwMsgType,
    IN DWORD  dwParam1,
    IN DWORD  dwParam2,
    IN DWORD  dwParam3
	)
{
	
	//
	//Job status message
	//
	if (FSPI_MSG_JOB_STATUS == dwMsgType)
	{
		HANDLE hFSPJob = (HANDLE) dwParam1;
		LPCFSPI_JOB_STATUS lpcFSPJobStatus = (LPCFSPI_JOB_STATUS) dwParam2;
		CEfspLineInfo * pLineInfo = NULL;

		//
		//Verify if the job handle belongs to Send or Receive globals
		//
		if (hFSPJob == g_pSendingLineInfo->GetJobHandle())
		{
			//
			//Sending job
			//
			pLineInfo = g_pSendingLineInfo;
		}
		else if (hFSPJob == g_pReceivingLineInfo->GetJobHandle())
		{
			//
			//Receive job
			//
			pLineInfo = g_pReceivingLineInfo;
		}
		else
		{
			if ( (NULL == g_pSendingLineInfo) && (NULL == g_pReceivingLineInfo) )
			{
				//
				//Both jobs have ended
				//
				::lgLogError(
					LOG_SEV_1,
					TEXT("FaxServiceCallback: got an MSG_JOB_STATUS message for job that already ended")
					);
			}
			else
			{
				::lgLogError(
					LOG_SEV_1,
					TEXT("FaxServiceCallback: got an MSG_JOB_STATUS message for an unknown hFaxHandle")
					);
			}
			return FSPI_E_INVALID_PARAM1;
		}

		pLineInfo->Lock();

		VerifyJobStatus(lpcFSPJobStatus);
		LogJobStatus(hFSP,hFSPJob,lpcFSPJobStatus);

		//
		//Should we verify the job state flow control
		//
		if (true)
		{
			if (false == pLineInfo->IsJobAtFinalState())
			{
				//
				//Verify the job status flow
				//
				VerifyLegalJobStatusFlow(
					hFSPJob,
					pLineInfo->GetLastJobStatus(),
					pLineInfo->GetLastExtendedJobStatus(),
					lpcFSPJobStatus->dwJobStatus,
					lpcFSPJobStatus->dwExtendedStatus
					);
				pLineInfo->SafeSetLastJobStatusAndExtendedJobStatus(lpcFSPJobStatus->dwJobStatus,lpcFSPJobStatus->dwExtendedStatus);
				
				//
				//Is job in a final state
				//
				if (
					(FSPI_JS_COMPLETED			== lpcFSPJobStatus->dwJobStatus)||
					(FSPI_JS_FAILED				== lpcFSPJobStatus->dwJobStatus)||
					(FSPI_JS_FAILED_NO_RETRY	== lpcFSPJobStatus->dwJobStatus)||
					(FSPI_JS_ABORTED			== lpcFSPJobStatus->dwJobStatus)
					)
				{
					pLineInfo->SafeSetJobAtFinalState();
					if (NULL != pLineInfo->GetFinalStateHandle())
					{
						//
						//Signal the job is finished
						//
						::SetEvent(pLineInfo->GetFinalStateHandle());
					}
				}
			}
			else
			{
				//
				//EFSP send notification of a job that has already reached a final state
				//
				
				TCHAR szJobStatus[MAXSIZE_JOB_STATUS];
				TCHAR szJobExtendedStatus[MAXSIZE_JOB_STATUS];
				
				GetJobStatusString(lpcFSPJobStatus->dwJobStatus,szJobStatus);
				GetExtendedJobStatusString(lpcFSPJobStatus->dwExtendedStatus,szJobExtendedStatus);

				::lgLogError(
					LOG_SEV_1,
					TEXT("**\n***\nEFSP Sent the following status on a job that has reached a final status:\nEFSP Handle=0x%08x , Job Handle=0x%08x \nJobStatus=%s, JobExtendedStatus=%s\n***\n**\n"),
					hFSP,
					hFSPJob,
					szJobStatus,
					szJobExtendedStatus
					);
				pLineInfo->UnLock();
				return FSPI_E_FAILED;
			}
		}
		pLineInfo->UnLock();
	}

	//
	//Device status message
	//
	if (FSPI_MSG_VIRTUAL_DEVICE_STATUS == dwMsgType)
	{
		if (dwParam1 == FSPI_DEVSTATUS_NEW_INBOUND_MESSAGE)
		{
			//
			//We have a new offering call
			//Create a receive thread
			//
				
			//
			//The new call is on Device ID dwParam2
			//
			DWORD dwOfferingCallDeviceID = dwParam2;

			//
			//Verify this is indeed our receiving device and verify it's enabled for receiving
			//
			if ((dwOfferingCallDeviceID == g_pReceivingLineInfo->GetDeviceId()) && (g_pReceivingLineInfo->IsReceivingEnabled()) && (g_pReceivingLineInfo->IsDeviceAvailable())) 
			{
				g_pReceivingLineInfo->Lock();
        		if (false == g_pReceivingLineInfo->CreateReceiveThread())
				{
					g_pReceivingLineInfo->UnLock();
					return FSPI_E_NOMEM;
				}
				g_pReceivingLineInfo->UnLock();
			}
			else
			{
				::lgLogDetail(
					LOG_X,
					5,
					TEXT("We have an offering call, but the device is not configured for receiving or is not available")
					);
			}
		}
	}
	return FSPI_S_OK;
}


HRESULT CALLBACK FaxDeviceProviderCallbackEx_NoReceiveNoSignal(
    IN HANDLE hFSP,
    IN DWORD  dwMsgType,
    IN DWORD  dwParam1,
    IN DWORD  dwParam2,
    IN DWORD  dwParam3
	)
{
	
	//
	//Job status message
	//
	if (FSPI_MSG_JOB_STATUS == dwMsgType)
	{
		HANDLE hFSPJob = (HANDLE) dwParam1;
		LPCFSPI_JOB_STATUS lpcFSPJobStatus = (LPCFSPI_JOB_STATUS) dwParam2;
		LogJobStatus(hFSP,hFSPJob,lpcFSPJobStatus);
	}

	//
	//Device status message
	//
	if (FSPI_MSG_VIRTUAL_DEVICE_STATUS == dwMsgType)
	{
		if (dwParam1 == FSPI_DEVSTATUS_NEW_INBOUND_MESSAGE)
		{
			//
			//We have a new offering call on DEVICE ID (dwParam2)
			//
			DWORD dwOfferingCallDeviceID = dwParam2;

			//
			//Verify this is indeed our receiving device and verify it's enabled for receiving
			//
			if ((dwOfferingCallDeviceID == g_pReceivingLineInfo->GetDeviceId()) && (g_pReceivingLineInfo->IsReceivingEnabled()) && (g_pReceivingLineInfo->IsDeviceAvailable())) 
			{
				assert(false);
			}
		}
	}
	return FSPI_S_OK;
}

void ReceiveThread(LPVOID pThreadParam)
{
	CEfspLineInfo * pLineInfo	=   (CEfspLineInfo *) pThreadParam;
	PFAX_RECEIVE pFaxReceive	=	pLineInfo->m_pFaxReceive;
	DWORD dwReceiveSize			=	0;

	assert(NULL == pLineInfo->GetJobHandle());

	//
    // start a fax job
    //
	HANDLE hJob = NULL;
	if (false == g_pEFSP->FaxDevStartJob(
	    NULL,							//Non Tapi EFSP
		pLineInfo->GetDeviceId(),
		&hJob,
		g_hCompletionPortHandle,
		(ULONG_PTR) pLineInfo			// The completion key provided to the FSP is the LineInfo
        ))								// pointer. When the FSP reports status it uses this key thus allowing
                                        // us to know to which line the status belongs.
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevStartJob() failed with error:%d"),
			::GetLastError()
			);
		goto exit;
	}
	pLineInfo->SafeSetJobHandle(hJob);

	//
	//Receive the job itself
	//
	if (false == g_pEFSP->FaxDevReceive(
        hJob,
        NULL,					//This is a non Tapi EFSP, so HCALL is NULL
        pFaxReceive
		))
	{

		if (true == pLineInfo->CanReceiveFail())
		{
			//
			//it's ok for FaxDevReceive() to fail, don't log an error
			//
			::lgLogDetail(
				LOG_X,
				5,
				TEXT("FaxDevReceive() has failed (ec: %ld)"),
				::GetLastError()
				);
		}
		else
		{
			//
			//FaxDevReceive() has failed, log an error
			//
			::lgLogError(
				LOG_SEV_1,
				TEXT("FaxDevReceive() failed with error:%d"),
				::GetLastError()
				);
		}
	}


exit:
	return;
}



HANDLE CreateCompletionPort()
{
	HANDLE StatusCompletionPortHandle = CreateIoCompletionPort(
        INVALID_HANDLE_VALUE,
        NULL,
        0,
        1		//taken from the fax service code...
        );
    if (!StatusCompletionPortHandle)
	{
        ::lgLogError(
			LOG_SEV_2,
			TEXT("Failed to create an IoCompletionPort (ec: %ld)"),
			::GetLastError()
			);
        return NULL;
    }
	return StatusCompletionPortHandle;
}



void GetDeviceFriendlyName(LPTSTR *pszDeviceFriendlyName,DWORD dwDeviceID)
{
	DWORD dwDeviceCount = 0;
	LPFSPI_DEVICE_INFO  lpVirtualDevices = NULL;		// The array of virtual device information that the EFSP will fill.

	//
	//First enumerate the number of devices
	//
	HRESULT hr = g_pEFSP->FaxDevEnumerateDevices(g_pEFSP->m_dwDeviceBaseId,&dwDeviceCount,NULL);
	if (FSPI_S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FaxDevEnumerateDevices failed with error 0x%08x"),
			hr
			);
		goto out;
	}

	//
    // Allocate the device array according to the number of devices
    //
    lpVirtualDevices = (LPFSPI_DEVICE_INFO) malloc(dwDeviceCount * sizeof(FSPI_DEVICE_INFO));
    if (!lpVirtualDevices)
    {
        ::lgLogError(
			LOG_SEV_1, 
			TEXT("Failed to allocate virtual device info array for %ld devices. (ec: %ld)"),
			dwDeviceCount,
            GetLastError()
			);
		goto out;
	}

	//
	//Get the device specific info
	//
	hr = g_pEFSP->FaxDevEnumerateDevices(g_pEFSP->m_dwDeviceBaseId,&dwDeviceCount, lpVirtualDevices);
	if (FSPI_S_OK != hr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FaxDevEnumerateDevices failed with error 0x%08x"),
			hr
			);
		goto out;
	}

		
	//
	//fetch the Device Friendly name
	//
	if (NULL == lpVirtualDevices[dwDeviceID].szFriendlyName)
	{
		::lgLogDetail(
			LOG_X,
			5,
			TEXT("FaxDevEnumerateDevices() didn't supply a friendly name")
			);
	}
	else
	{
		*pszDeviceFriendlyName = ::_tcsdup(lpVirtualDevices[dwDeviceID].szFriendlyName);
	}

out:
	free(lpVirtualDevices);
	::lgEndCase();
}


bool WaitForCompletedReceiveJob(CEfspLineInfo * pReceivingLineInfo,bool bEndReceiveJob)
{
	assert(NULL != pReceivingLineInfo);
		
	//
	//wait for receive to finish
	//
	if (false == pReceivingLineInfo->WaitForReceiveThreadTerminate())
	{
		return false;
	}

	//
	//Verify the status of the jobs
	//
	LPFSPI_JOB_STATUS pReceivingDevStatus;
	pReceivingLineInfo->GetDevStatus(
		&pReceivingDevStatus
		,true				//log the report
		);
	if (FSPI_JS_COMPLETED != pReceivingDevStatus->dwJobStatus)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("Receiving job: GetDevStatus() reported 0x%08x FSPI_JS_COMPLETED instead of FS_COMPLETED as expected"),
			pReceivingDevStatus->dwJobStatus
			);
	}

	//
	//End the receive job
	//
	if (true == bEndReceiveJob)
	{
		pReceivingLineInfo->SafeEndFaxJob();
	}
	
	//
	//Close the thread handle
	//
	pReceivingLineInfo->SafeEndFaxJob();

	return true;

}

void VerifyLegalJobStatusFlow(HANDLE hJob,DWORD dwLastJobStatus,DWORD dwLastExtendedJobStatus,DWORD dwNextJobStatus,DWORD dwNextExtendedJobStatus)
{
	if (DUMMY_JOB_STATUS_INDEX == dwLastJobStatus)
	{
		//
		//This is the first time we enter this function and the last status is still a dummy
		//
		return;
	}

	//
	//First let's convert the job status and expended status to friendly strings
	//
	TCHAR szLastJobStatus[200];
	TCHAR szLastJobExtendedStatus[200];
	TCHAR szNextJobStatus[200];
	TCHAR szNextJobExtendedStatus[200];
	
	GetJobStatusString(dwLastJobStatus,szLastJobStatus);
	GetExtendedJobStatusString(dwLastExtendedJobStatus,szLastJobExtendedStatus);
	GetJobStatusString(dwNextJobStatus,szNextJobStatus);
	GetExtendedJobStatusString(dwNextExtendedJobStatus,szNextJobExtendedStatus);
	//
	//Check if the new job status(dwNextJobStatus) is valid after the last job status(dwLastJobStatus)
	//
	if (false == g_bStatusFlowArray[dwLastJobStatus][dwNextJobStatus])
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("Job Handle:0x%08x has and invalid JobStatus flow: %s--------->>>>>%s"),
			hJob,
			szLastJobStatus,
			szNextJobStatus
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			4,
			TEXT("Job Handle:0x%08x has a valid JobStatus flow: %s--------->>>>>%s"),
			hJob,
			szLastJobStatus,
			szNextJobStatus
			);
	}
	
	
	//
	//Check if the new extended job status(dwNextExtendedJobStatus) is valid after the last extended job status(dwLastExtendedJobStatus),
	//moving between extended job statuses is valid within the same job status
	//
	if ((dwLastJobStatus == dwNextJobStatus) && 
		((LAST_JOB_EXTENDEND_STATUS_INDEX > dwLastExtendedJobStatus) && (LAST_JOB_EXTENDEND_STATUS_INDEX > dwNextExtendedJobStatus))
		)
	{
		if (false == g_bExtendedStatusFlowArray[dwLastExtendedJobStatus][dwNextExtendedJobStatus])
		{
			::lgLogError(
				LOG_SEV_1,
				TEXT("EXTENDED JOB STATUS: For job status:%s, the Extended status flow:%s-------->>>>%s is not valid"),
				szLastJobStatus,
				szLastJobExtendedStatus,
				szNextJobExtendedStatus
				);
		}
	}
}





bool InitEfsp(bool bLog)
{
	assert (NULL == g_pEFSP);
	g_pEFSP = new CEfspWrapper(g_dwEfspCaps,EFSP_DEVICE_BASE_ID);
	if (NULL == g_pEFSP)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("new failed")
			);
		return false;
	}

	//
	//Load the EFSP and get the the exported functions
	//
	if (false == g_pEFSP->Init(GetEfspToLoad(),bLog))
	{
		return false;
	}
	return (g_pEFSP->GetProcAddressesFromModule(bLog));
}

void ShutdownEfsp_UnloadEfsp()
{
	if (NULL != g_pEFSP)
	{
		//
		//first shutdown the Efsp
		//
		g_pEFSP->FaxDevShutdown();
	}
	delete g_pEFSP;
	g_pEFSP = NULL;
	
	delete g_pSendingLineInfo;
	g_pSendingLineInfo = NULL;
	
	delete g_pReceivingLineInfo;
	g_pReceivingLineInfo = NULL;
}

void UnloadEfsp(const bool bLog)
{
	assert(NULL != g_pEFSP);
	delete g_pEFSP;
	g_pEFSP = NULL;
	
	delete g_pSendingLineInfo;
	g_pSendingLineInfo = NULL;
	
	delete g_pReceivingLineInfo;
	g_pReceivingLineInfo = NULL;
}

bool LoadEfsp_CallFaxDevInitEx()
{
	if (false == InitEfsp(false))
	{
		return false;
	}
	if (false == FaxDevInitializeExWrapperWithReceive())
	{
		return false;
	}
	return true;
}

bool InitProviders()
{
	return LoadEfsp_CallFaxDevInitEx();
}

void ShutdownProviders()
{
	ShutdownEfsp_UnloadEfsp();
}


bool RunThisTest(DWORD dwCaseNumber)
{
	return baRunThisTest[dwCaseNumber];
}

bool LoadAndInitFsp_InitSendAndReceiveDevices()
{
	if (false == LoadEfsp_CallFaxDevInitEx())
	{
		goto error;
	}
	//
	//prepare a Sending device and a receiving device
	//
	assert (NULL == g_pSendingLineInfo);
	g_pSendingLineInfo = new CEfspLineInfo(g_dwSendingValidDeviceId);
	if (NULL == g_pSendingLineInfo)
	{
		::lgLogError(
			LOG_SEV_2,
			TEXT("new failed")
			);
		goto error;
	}
	if (false == g_pSendingLineInfo->PrepareLineInfoParams(g_szValid__TiffFileName,false))
	{
		goto error;
	}
	assert (NULL == g_pReceivingLineInfo);
	g_pReceivingLineInfo = new CEfspLineInfo(g_dwReceiveValidDeviceId);
	if (NULL == g_pReceivingLineInfo)
	{
		::lgLogError(
			LOG_SEV_2,
			TEXT("new failed")
			);
		goto error;
	}
	if (false == g_pReceivingLineInfo->PrepareLineInfoParams(g_szValid_ReceiveFileName,true))
	{
		goto error;
	}
	return true;

error:

	ShutdownEfsp_UnloadEfsp();
	delete g_pSendingLineInfo;
	g_pSendingLineInfo = NULL;
	delete g_pReceivingLineInfo;
	g_pReceivingLineInfo = NULL;
	return false;
}

bool AbortOperationAndWaitForAbortState(PFAX_ABORT_ITEM pAbortItem)
{
	bool bRet = false;
	LPFSPI_JOB_STATUS pAbortingDevStatus = NULL;
	
	//
	//Sleep the desired time
	//
	::Sleep(pAbortItem->dwMilliSecondsBeforeCallingAbort);


	//
	//Verify the job to abort is OK
	//
	HANDLE hJob = pAbortItem->pLineInfo->GetJobHandle();
	if (NULL == hJob)
	{
		::lgLogError(
			LOG_SEV_2,
			TEXT("Abort item has a NULL hFaxHandle")
			);
		goto out;
	}
	
	//
	//Now we can abort the operation
	//
	if (false == g_pEFSP->FaxDevAbortOperation(hJob))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevAbortOperation() failed - %d"),
			::GetLastError()
			);
		goto out;
	}

	
	//
	//FaxDevAbortOperation is async, let's sleep and give the EFSP a change to abort the job
	//
	::Sleep(MAX_TIME_FOR_ABORT);


	//
	//The job state should be USER_ABORTED now
	//
	
	//
	//Get the status through FaxDevReportStatus
	//
	if (false == pAbortItem->pLineInfo->GetDevStatus(
		&pAbortingDevStatus,
		pAbortItem->bLogging				
		))
	{
		//
		//GetDevStatus() failed, logging is in GetDevStatus()
		//
		goto out;
	}
	else
	{
		//
		//Now let's verify the status is FSPI_JS_ABORTED
		//
		if (FSPI_JS_ABORTED == pAbortingDevStatus->dwJobStatus)
		{
			bRet = true;
			if (true == pAbortItem->bLogging)
			{
				::lgLogDetail(
					LOG_PASS,
					2,
					TEXT("Aborting Job: GetDevStatus() reported FSPI_JS_ABORTED")
					);
			}
		}
		else
		{
			bRet = false;
			if (true == pAbortItem->bLogging)
			{
				::lgLogError(
					LOG_SEV_1,
					TEXT("Aborting Job: GetDevStatus() reported %d JobStatus instead of FSPI_JS_ABORTED"),
					pAbortingDevStatus->dwJobStatus
					);
			}
		}
	}

out:
	if (NULL != pAbortingDevStatus)
	{
		free (pAbortingDevStatus);
	}
	return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\fsp\3rdpartyfsp_verifier\fsp\cfsplineinfo.h ===
//CFspLineInfo.h
#ifndef CEfspLineInfo_h
#define CEfspLineInfo_h

#include "..\CLineInfo.h"
#include "..\CFspWrapper.h"

class CFspLineInfo: public CLineInfo
{
private:
	HCALL               m_hReceiveCallHandle;
    HLINE               m_hLine;                      // Tapi line handle (provided by TapiOpenLine)
public:
	CFspLineInfo(const DWORD dwDeviceId);
	~CFspLineInfo();

	bool PrepareLineInfoParams(LPCTSTR szFilename,bool bIsReceiveLineinfo);
	void SafeEndFaxJob();
	void ResetParams();
	DWORD GetDevStatus(PFAX_DEV_STATUS *ppFaxStatus,const bool bLogTheStatus) const;
	
	bool OpenTapiLine(HLINEAPP hLineApp,bool bIsOwner);
	void CloseHCall();

	HCALL GetReceiveCallHandle() const;
	void SetReceiveCallHandle(const HCALL hReceive);
	
	HLINE GetLineHandle() const;
	void SetLineHandle(const HLINE hLine);
	
	static void InitLineCallParams(LINECALLPARAMS *callParams,const DWORD dwMediaModes);

};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\fsp\3rdpartyfsp_verifier\efsp\service.h ===
#ifndef Service_h
#define Service_h

#include "CEfspLineInfo.h"


//Max sizes
#define MAXSIZE_JOB_STATUS			200
#define MAX_CSID_SIZE							1000
#define MAX_DEVICE_NAME_SIZE					1000 

//default stuff
#define DEFAULT_COVERPAGE_SUBJECT				TEXT("Fax Subject")
#define DEFAULT_VERYLONG_COVERPAGE_SUBJECT		TEXT("SubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubjectSubject")
#define DEFAULT_COVERPAGE_NOTE					TEXT("Fax Note")
#define DEFAULT_VERYLONG_COVERPAGE_NOTE			TEXT("NoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNoteNote")
#define DEFAULT_BRANDING						true

#define DEFAULT_DEVICE_NAME		TEXT("EFSP Device")
#define DEFAULT_DEVICE_CSID		TEXT("EFSP Device CSID")



//Timeouts
#define WAIT_FOR_JOB_FINAL_STATE_TIMEOUT		100000
#define	WAIT_FOR_THREAD_TO_TERMINATE_TIMEOUT	30000
#define MAX_TIME_FOR_ABORT						10000
#define MAX_TIME_FOR_REPORT_STATUS				10000

//other
#define VALID_hFSP_ID							(HANDLE) 0x100
#define INVALID_COVERPAGE_FORMAT				100
#define DUMMY_JOB_STATUS_INDEX					0


//
//Sender
//
#define DEFAULT_SENDER_INFO__NAME				TEXT("Sender Name")
#define DEFAULT_SENDER_INFO__VERYLONG_NAME		TEXT("Very Long Sender Name__Very Long Sender Name__Very Long Sender Name__Very Long Sender Name__Very Long Sender Name__Very Long Sender Name__Very Long Sender Name__Very Long Sender Name")

#define DEFAULT_SENDER_INFO__FAX_NUMBER			TEXT("Sender Fax Number")
#define DEFAULT_SENDER_INFO__VERYLONG_FAX_NUMBER TEXT("12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012")

#define DEFAULT_SENDER_INFO__COMPANY			TEXT("Sender Company")
#define DEFAULT_SENDER_INFO__STREET				TEXT("Sender Street address")
#define DEFAULT_SENDER_INFO__CITY				TEXT("Sender City")
#define DEFAULT_SENDER_INFO__STATE				TEXT("Sender State")
#define DEFAULT_SENDER_INFO__ZIP				TEXT("Sender Zip")
#define DEFAULT_SENDER_INFO__COUNTRY			TEXT("Sender Country")
#define DEFAULT_SENDER_INFO__TITLE				TEXT("Sender Title")
#define DEFAULT_SENDER_INFO__DEPT				TEXT("Sender Dept")
#define DEFAULT_SENDER_INFO__OFFICE_LOCATION	TEXT("Sender Office loc")
#define DEFAULT_SENDER_INFO__HOME_PHONE			TEXT("Sender Home Phone")
#define DEFAULT_SENDER_INFO__OFFICE_PHONE		TEXT("Sender Office Phone")
#define DEFAULT_SENDER_INFO__ORG_MAIL			TEXT("Sender Org mail")
#define DEFAULT_SENDER_INFO__INTERNET_MAIL		TEXT("Sender Internet mail")
#define DEFAULT_SENDER_INFO__BILLING_CODE		TEXT("Sender Billing code")



//
//Receiver
//
#define DEFAULT_RECIPIENT_INFO__NAME			TEXT("Recipient Name")
#define DEFAULT_RECIPIENT_INFO__VERYLONG_NAME	TEXT("Very Long Recipient Name__Very Long Recipient Name__Very Long Recipient Name__Very Long Recipient Name__Very Long Recipient Name__Very Long Recipient Name__Very Long Recipient Name")
#define DEFAULT_RECIPIENT_INFO__COMPANY			TEXT("Recipient Company")
#define DEFAULT_RECIPIENT_INFO__STREET			TEXT("Recipient Street address")
#define DEFAULT_RECIPIENT_INFO__CITY			TEXT("Recipient City")
#define DEFAULT_RECIPIENT_INFO__STATE			TEXT("Recipient State")
#define DEFAULT_RECIPIENT_INFO__ZIP				TEXT("Recipient Zip")
#define DEFAULT_RECIPIENT_INFO__COUNTRY			TEXT("Recipient Country")
#define DEFAULT_RECIPIENT_INFO__TITLE			TEXT("Recipient Title")
#define DEFAULT_RECIPIENT_INFO__DEPT			TEXT("Recipient Dept")
#define DEFAULT_RECIPIENT_INFO__OFFICE_LOCATION	TEXT("Recipient Office loc")
#define DEFAULT_RECIPIENT_INFO__HOME_PHONE		TEXT("Recipient Home Phone")
#define DEFAULT_RECIPIENT_INFO__OFFICE_PHONE	TEXT("Recipient Office Phone")
#define DEFAULT_RECIPIENT_INFO__ORG_MAIL		TEXT("Recipient Org mail")
#define DEFAULT_RECIPIENT_INFO__INTERNET_MAIL	TEXT("Recipient Internet mail")
#define DEFAULT_RECIPIENT_INFO__BILLING_CODE	TEXT("Recipient Billing code")


//
//Aborting Stuff
//
typedef struct _FAX_ABORT_ITEM {
    DWORD               dwMilliSecondsBeforeCallingAbort;	//how many milliseconds to wait before calling FaxDevAbortOperation()
	CEfspLineInfo		*pLineInfo;							//LineInfo structure
	bool				bLogging;							//Should we log the Status
} FAX_ABORT_ITEM, *PFAX_ABORT_ITEM;

bool AbortOperationAndWaitForAbortState(PFAX_ABORT_ITEM pAbortItem);


class CFaxDevInitParams
{
public:
	IN  HANDLE                      m_hFSP;
    IN  HLINEAPP                    m_LineAppHandle;
    OUT PFAX_LINECALLBACK *         m_LineCallbackFunction;
    IN  PFAX_SERVICE_CALLBACK_EX    m_FaxServiceCallbackEx;
    OUT LPDWORD                     m_lpdwMaxMessageIdSize;
	HANDLE m_hJob;
public:
	CFaxDevInitParams(
		HANDLE                      hFSP				=NULL,
		HLINEAPP                    LineAppHandle		=NULL,
		PFAX_LINECALLBACK *         LineCallbackFunction=NULL,
		PFAX_SERVICE_CALLBACK_EX    FaxServiceCallbackEx=NULL,
		LPDWORD                     lpdwMaxMessageIdSize=NULL
		):m_hFSP(hFSP),
		m_LineAppHandle(LineAppHandle),
		m_LineCallbackFunction(LineCallbackFunction),
		m_FaxServiceCallbackEx(FaxServiceCallbackEx),
		m_lpdwMaxMessageIdSize(lpdwMaxMessageIdSize)
	{
		//empty constructor
	}
};


bool FaxDevInitializeExWrapper(const CFaxDevInitParams faxDevInitParamsToTest, bool bShouldFail);
void FaxDevShutdownWrapper();

//
//Job status
//
void VerifyLegalJobStatusFlow(HANDLE hJob,DWORD dwLastJobStatus,DWORD dwLastExtendedJobStatus,DWORD dwNextJobStatus,DWORD dwNextExtendedJobStatus);
void GetExtendedJobStatusString(DWORD dwExtendedStatus,TCHAR *szJobExtendedStatus);
void GetJobStatusString(DWORD dwJobStatus,TCHAR *szJobStatus);
void LogJobStatus(
	HANDLE hFSP,
	HANDLE hFSPJob,
	LPCFSPI_JOB_STATUS lpcFSPJobStatus
	);
bool VerifyJobStatus(LPCFSPI_JOB_STATUS lpcFSPJobStatus);




//
//Other
//
void GetErrorString(DWORD dwErrorCode,TCHAR *szErrorString);
bool GetIniSettings();
TCHAR *GetEfspToLoad();

bool AllocGlobalVariables();
bool InitGlobalVariables();
void FreeGlobalVariables();

HANDLE CreateCompletionPort();
void ReceiveThread(LPVOID pThreadParam);


void GetDeviceFriendlyName(LPTSTR *szDeviceFriendlyName,DWORD dwDeviceID);
bool WaitForCompletedReceiveJob(CEfspLineInfo * pReceivingLineInfo,bool bEndReceiveJob);


bool InitProviders();
void ShutdownProviders();

bool LoadAndInitFsp_InitSendAndReceiveDevices();
bool LoadEfsp_CallFaxDevInitEx();

bool InitEfsp(bool bLog=false);
void ShutdownEfsp_UnloadEfsp();
void UnloadEfsp(const bool bLog=false);

bool RunThisTest(DWORD g_dwCaseNumber);
#define BEGIN_CASE(CASE_NAME)								\
	g_dwCaseNumber++;										\
	if (true == RunThisTest(g_dwCaseNumber))				\
	{														\
		::lgBeginCase(g_dwCaseNumber,CASE_NAME);			\
	}														\
	else													\
	{														\
		return;												\
	}


//
//FaxService callback function
//
HRESULT CALLBACK FaxDeviceProviderCallbackExWithReceiveCaps(
    IN HANDLE hFSP,
    IN DWORD  dwMsgType,
    IN DWORD  dwParam1,
    IN DWORD  dwParam2,
    IN DWORD  dwParam3
	);

HRESULT CALLBACK FaxDeviceProviderCallbackEx_NoReceiveNoSignal(
    IN HANDLE hFSP,
    IN DWORD  dwMsgType,
    IN DWORD  dwParam1,
    IN DWORD  dwParam2,
    IN DWORD  dwParam3
	);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\fsp\3rdpartyfsp_verifier\fsp\fsploading.cpp ===
//FspLoading.cpp
#include "service.h"
extern DWORD		g_dwCaseNumber;

bool Suite_FspLoading()
{
	//
	//This suite returns a value, if it fails there's no point to continue with the rest of the test cases / suites
	//
	
	if (true == RunThisTest(++g_dwCaseNumber))
	{											
		::lgBeginSuite(TEXT("FSP loading"));
		
		::lgBeginCase(g_dwCaseNumber,TEXT("FSP Loading"));
		if (false == InitFsp(true))
		{
			::lgEndCase();
			::lgEndSuite();
			return false;
		}
		UnloadFsp(true);
		::lgEndCase();

		::lgEndSuite();
	}
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\fsp\3rdpartyfsp_verifier\fsp\paramtest.h ===
//ParamTest.h

#ifndef ParamTest_h
#define ParamTest_h

#ifdef __cplusplus
extern "C"
{
#endif

void Suite_FaxDevInitialize();
void Suite_FaxDevStartJob();
void Suite_FaxDevSend();
void Suite_FaxDevReceive();

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\fsp\3rdpartyfsp_verifier\fsp\service.h ===
//Service.h
#ifndef Service_h
#define Service_h

#include "..\CFspWrapper.h"
#include "CFspLineInfo.h"
#include "..\CThreadItem.h"

#ifdef __cplusplus
extern "C"
{
#endif


//
//Default stuff
//
#define DEFAULT_SENDER_INFO__NAME				TEXT("Sender Name")
#define DEFAULT_RECEIVER_INFO__NAME				TEXT("Receiver Name")
#define DEFAULT_RECEIVER_INFO__NUMBER			TEXT("Receiver Number")

#define SENDER_INFO__VERYLONG_NAME				TEXT("Very Long Sender Name__Very Long Sender Name__Very Long Sender Name__Very Long Sender Name__Very Long Sender Name__Very Long Sender Name__Very Long Sender Name__Very Long Sender Name")
#define DEFAULT_SENDER_INFO__FAX_NUMBER			TEXT("Sender Fax Number")
#define SENDER_INFO__VERYLONG_FAX_NUMBER		TEXT("12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012")
#define DEFAULT_SENDER_INFO__FAX_NUMBER			TEXT("Sender Fax Number")
#define DEFAULT_RECIPIENT_INFO__NAME			TEXT("Recipient Name")
#define RECIPIENT_INFO__VERYLONG_NAME			TEXT("Very Long Recipient Name__Very Long Recipient Name__Very Long Recipient Name__Very Long Recipient Name__Very Long Recipient Name__Very Long Recipient Name__Very Long Recipient Name")
#define DEFAULT_BRANDING						true

#define MAX_CSID_SIZE							1000
#define MAX_DEVICE_NAME_SIZE					1000 

#define DEFAULT_DEVICE_NAME						TEXT("FSP Device")
#define DEFAULT_DEVICE_CSID						TEXT("FSP Device CSID")

//
//Tapi stuff
//
#define API_VERSION						0x00020000
#define TAPI_COMPLETION_KEY				0x80000001

#define		WAIT_FOR_THREAD_TO_TERMINATE_TIMEOUT	(WAIT_FOR_COMPLETION_PORT_TIMEOUT+30000)
#define		WAIT_FOR_COMPLETION_PORT_TIMEOUT		(1000)



typedef struct _FAX_RECEIVE_ITEM {
    HCALL               hCall;
    CFspLineInfo		*LineInfo;
    LPTSTR              FileName;
} FAX_RECEIVE_ITEM, *PFAX_RECEIVE_ITEM;



//
//Aborting Stuff
//
typedef struct _FAX_ABORT_ITEM {
    DWORD               dwMilliSecondsBeforeCallingAbort;	//how many milliseconds to wait before calling FaxDevAbortOperation()
	CFspLineInfo		*pLineInfo;							//LineInfo structure
	bool				bLogging;							//Should we log the Status
} FAX_ABORT_ITEM, *PFAX_ABORT_ITEM;

bool AbortOperationAndWaitForAbortState(PFAX_ABORT_ITEM pAbortItem);



bool AllocGlobalVariables();
void FreeGlobalVariables();
bool GetIniSettings();
TCHAR *GetFspToLoad();

BOOL WINAPI FaxDevSend__SendCallBack(
    IN HANDLE hFaxHandle,
    IN HCALL hCallHandle,
    IN DWORD Reserved1,
    IN DWORD Reserved2
    );

BOOL CALLBACK FaxServiceCallbackWithAssert(
    IN HANDLE FaxHandle,
    IN DWORD  DeviceId,
    IN DWORD_PTR  Param1,
    IN DWORD_PTR  Param2,
    IN DWORD_PTR  Param3
    );

	
bool InitThreadsAndCompletionPorts();
bool InitFsp(bool bLog=false);
void ShutDownTapiAndTapiThread();
void UnloadFsp(const bool bLog=false);
bool FspFaxDevInit();
bool InitTapi_LoadFsp_CallFaxDevInit();
HLINEAPP InitTapiWithCompletionPort();
bool InitProviders();
void ShutdownProviders();

void DumpDeviceId();
bool RunThisTest(DWORD g_dwCaseNumber);

void VerifySendingStatus(PFAX_DEV_STATUS pFaxStatus,bool bShouldFail);
void VerifyReceivingStatus(PFAX_DEV_STATUS pFaxStatus,bool bShouldFail);

bool LoadTapiLoadFspAndPrepareSendReceiveDevice();
bool LoadTapiLoadFspAndPrepareSendDevice();
DWORD WINAPI ReceiveThread(LPVOID pThreadParam);

#define BEGIN_CASE(CASE_NAME)								\
	g_dwCaseNumber++;										\
	if (true == RunThisTest(g_dwCaseNumber))				\
	{														\
		::lgBeginCase(g_dwCaseNumber,CASE_NAME);			\
	}														\
	else													\
	{														\
		return;												\
	}

//
//Additional libs
//
bool LoadLibraries();
void UnloadLibraries();

BOOL FileToFileTiffCompare(
	LPTSTR				/* IN */	szFile1,
	LPTSTR				/* IN */	szFile2,
    BOOL                /* IN */    fSkipFirstLine
	);

//
//Implemented in FxsTiff.DLL
//
typedef BOOL (WINAPI *PTIFFPOSTPROCESSFAST)			(LPTSTR,LPTSTR);
BOOL
TiffPostProcessFast(
    LPTSTR SrcFileName,
    LPTSTR DstFileName          // can be null for generated name
    );


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\fsp\3rdpartyfsp_verifier\fsp\service.cpp ===
//Service.cpp
#include <assert.h>
#include <TCHAR.h>
#include <WINFAX.H>
#include <faxDev.h>
#include <log.h>

#include "Service.h"
#include "..\CFspWrapper.h"
#include "TapiDbg.h"

HLINEAPP	g_hLineAppHandle		=	NULL;	//Tapi app handle
HANDLE		g_hTapiCompletionPort	=	NULL;
bool		g_bTerminateTapiThread	=	false;
HANDLE		g_hCompletionPortHandle	=	NULL;
CThreadItem	g_TapiThread;

CFspWrapper *g_pFSP					=	NULL;

extern	CFspLineInfo *g_pSendingLineInfo;
extern	CFspLineInfo *g_pReceivingLineInfo;

//
//T30 specific stuff
//
extern	bool	g_bIgnoreErrorCodeBug;					
extern	bool	g_bT30_OneLineDiffBUG;					
extern  bool	g_bT30_sizeOfStructBug;					


//
//fxsTiff.dll parameters
//
#define FXSTIFF_DLL		TEXT("FXSTIFF.dll")
HINSTANCE				g_hFaxTiffLibrary		=	NULL;
PTIFFPOSTPROCESSFAST	g_fnTiffPostProcessFast	=	NULL;


//
//INI stuff
//
TCHAR * g_szFspIniFileName				=				NULL;				
#define MAX_INI_VALUE					200
#define LAST_CASE_NUMBER				100
bool baRunThisTest[LAST_CASE_NUMBER];

#define INI_SECTION__FSP_SETTINGS		TEXT("FspSettings")
#define INI_SECTION__PHONE_NUMBERS		TEXT("PhoneNumbers")
#define	INI_SECTION__GENERAL			TEXT("General")
#define INI_SECTION__TIFF_FILES			TEXT("TiffFiles")
#define INI_SECTION__CASES				TEXT("Cases")

//
//Phone numbers
//
TCHAR* g_szInvalidRecipientFaxNumber	=				NULL;
#define	INVALID_RECIPIENT_FAX_NUMBER__INI_KEY			TEXT("INVALID_RECIPIENT_FAX_NUMBER")
TCHAR* g_szValidRecipientFaxNumber		=				NULL;
#define	VALID_RECIPIENT_FAX_NUMBER__INI_KEY				TEXT("VALID_RECIPIENT_FAX_NUMBER")

//
//FSP info
//
TCHAR*  g_szModuleName					=			NULL;
#define FSP_MODULE_NAME__INI_KEY					TEXT("FSP DLL")

DWORD g_dwInvalidDeviceId				=			0;
#define INVALID_DEVICE_ID__INI_KEY					TEXT("INVALID_DEVICE_ID")

DWORD g_dwSendingValidDeviceId			=			0;
#define SENDING_VALID_DEVICE_ID__INI_KEY			TEXT("SENDING_VALID_DEVICE_ID")

DWORD g_dwReceiveValidDeviceId			=			0;
#define RECEIVE_VALID_DEVICE_ID__INI_KEY			TEXT("RECEIVE_VALID_DEVICE_ID")

//
//General
//
bool	g_reloadFspEachTest = false;
#define INIT_PARAMETERS_EACH_TEST__INI_KEY							TEXT("INIT_PARAMETERS_EACH_TEST")
DWORD	g_dwReceiveTimeOut	=	0;
#define	MAX_TIME_FOR_RECEIVING_FAX__INI_KEY							TEXT("MAX_TIME_FOR_RECEIVING_FAX")
DWORD	g_dwTimeTillRingingStarts = 0;
#define TIME_FROM_SEND_START_TILL_RINGING_STARTS__INI_KEY			TEXT("TIME_FROM_SEND_START_TILL_RINGING_STARTS")
DWORD	g_dwTimeTillTransferingBitsStarts = 0;
#define TIME_FROM_SEND_START_TILL_TRANSFERING_BITS_STARTS__INI_KEY	TEXT("TIME_FROM_SEND_START_TILL_TRANSFERING_BITS_STARTS")
//
//TIFF files
//
TCHAR* g_szValid__TiffFileName = NULL;
#define	VALID_TIFF_FILE__INI_KEY								TEXT("VALID_TIFF_FILE")
TCHAR* g_szValid_ReadOnly_TiffFileName = NULL;
#define VALID_TIFF_FILE__READONLY__INI_KEY						TEXT("VALID_TIFF_FILE__READONLY")
TCHAR* g_szValid_FileNotFound_TiffFileName = NULL;
#define INVALID_TIFF_FILE__FILENOTFOUND__INI_KEY				TEXT("INVALID_TIFF_FILE__FILENOTFOUND")
TCHAR* g_szValid_UNC_TiffFileName = NULL;
#define VALID_TIFF_FILE__UNC__INI_KEY							TEXT("VALID_TIFF_FILE__UNC")
TCHAR* g_szValid_NTFS_TiffFileName = NULL;
#define VALID_TIFF_FILE__NTFS__INI_KEY							TEXT("VALID_TIFF_FILE__NTFS")
TCHAR* g_szValid_FAT_TiffFileName = NULL;
#define VALID_TIFF_FILE__FAT__INI_KEY							TEXT("VALID_TIFF_FILE__FAT")
TCHAR* g_szValid_Link_TiffFileName = NULL;
#define VALID_TIFF_FILE__LINK__INI_KEY							TEXT("VALID_TIFF_FILE__LINK")
TCHAR* g_szValid_NotTiffExtButTiffFormat_TiffFileName = NULL;
#define VALID_TIFF_FILE__NOT_TIFF_EXT_BUT_TIFF_FORMAT__INI_KEY	TEXT("VALID_TIFF_FILE__NOT_TIFF_EXT_BUT_VALID_TIFF_FORMAT")
TCHAR* g_szValid_InvalidTiffFormat_TiffFileName = NULL;
#define INVALID_TIFF_FILE__INVALID_TIFF_FORMAT__INI_KEY			TEXT("INVALID_TIFF_FILE__INVALID_TIFF_FORMAT")
//Valid receive file name
TCHAR* g_szValid_ReceiveFileName = NULL;
#define VALID_TIFF_FILE__RECEIVE_FILE_NAME__INI_KEY				TEXT("VALID_TIFF_FILE__RECEIVE_FILE_NAME")

void ShutdownTapi(HLINEAPP hLineApp)
{
	if (NULL != hLineApp)
	{
		LONG lLineShutdownStatus =  ::lineShutdown(hLineApp);
		if (0 != lLineShutdownStatus)
		{
			::lgLogError(
				LOG_SEV_2, 
				TEXT("lineShutdown() failed, error code:0x%08x"),
				lLineShutdownStatus
				);
		}
	}
}


HLINEAPP InitTapi()
{
	HLINEAPP hLineApp;
	//
	//lineInitializeExParams structure init
	//
	DWORD					dwNumDevs				=	0 ;
	DWORD					dwTapiAPIVersion		=	API_VERSION;
	LINEINITIALIZEEXPARAMS	lineInitializeExParams;
	
	::ZeroMemory(&lineInitializeExParams,sizeof (lineInitializeExParams));
	lineInitializeExParams.dwTotalSize = sizeof (lineInitializeExParams);
	lineInitializeExParams.dwOptions = LINEINITIALIZEEXOPTION_USEEVENT;
	
	long lineInitializeStatus = ::lineInitializeEx(
		&hLineApp,
		GetModuleHandle(NULL),		//client application HINSTANCE.
		NULL,						//TAPI messages through Events, no callback function.
		NULL,						//Application module name will be used
		&dwNumDevs,					//Number of devices.
		&dwTapiAPIVersion,			//TAPI API highest supported version.
		&lineInitializeExParams
		);
	if (0 != lineInitializeStatus)
	{
		::lgLogError(
			LOG_SEV_2, 
			TEXT("lineInitializeEx() failed, error code:0x%08x"),
			lineInitializeStatus
			);
		return NULL;
	}
	assert(API_VERSION <= dwTapiAPIVersion);

	return hLineApp;
}

HLINEAPP InitTapiWithCompletionPort()
{
	assert(NULL != g_hTapiCompletionPort);
	HLINEAPP hLineApp;
	
	//
	//lineInitializeExParams structure init
	//
	DWORD					dwNumDevs				=	0 ;
	DWORD					dwTapiAPIVersion		=	API_VERSION;
	LINEINITIALIZEEXPARAMS	lineInitializeExParams;
	
	::ZeroMemory(&lineInitializeExParams,sizeof (lineInitializeExParams));
    lineInitializeExParams.dwNeededSize             = 0;
    lineInitializeExParams.dwUsedSize               = 0;
	lineInitializeExParams.dwTotalSize = sizeof (lineInitializeExParams);
	lineInitializeExParams.dwOptions = LINEINITIALIZEEXOPTION_USECOMPLETIONPORT;
    lineInitializeExParams.Handles.hCompletionPort  = g_hTapiCompletionPort;
    lineInitializeExParams.dwCompletionKey          = TAPI_COMPLETION_KEY;

	long lineInitializeStatus = ::lineInitializeEx(
		&hLineApp,
		GetModuleHandle(NULL),		//client application HINSTANCE.
		NULL,						//TAPI messages through Events, no callback function.
		NULL,						//Application module name will be used
		&dwNumDevs,					//Number of devices.
		&dwTapiAPIVersion,			//TAPI API highest supported version.
		&lineInitializeExParams
		);
	if (0 != lineInitializeStatus)
	{
		::lgLogError(
			LOG_SEV_2, 
			TEXT("lineInitializeEx() failed, error code:0x%08x"),
			lineInitializeStatus
			);
		return NULL;
	}
	assert(API_VERSION <= dwTapiAPIVersion);

	return hLineApp;
}

DWORD WINAPI ReceiveThread(LPVOID pThreadParam)
{
	CFspLineInfo *pLineInfo		=	(CFspLineInfo *) pThreadParam;
	DWORD dwReceiveSize			=	0;

	pLineInfo->Lock();
	PFAX_RECEIVE pFaxReceive=	pLineInfo->m_pFaxReceive;
	DWORD	dwDeviceId		=	pLineInfo->GetDeviceId();
	HLINE	hLine			=	pLineInfo->GetLineHandle();
	HCALL	hReceiveCall	=	pLineInfo->GetReceiveCallHandle();
	assert(NULL == pLineInfo->GetJobHandle());
	pLineInfo->UnLock();
	
	//
    // start a fax job
    //
	HANDLE hJob;
	if (false == g_pFSP->FaxDevStartJob(
	    hLine,
		dwDeviceId,
		&hJob,
		g_hCompletionPortHandle,
		(ULONG_PTR) pLineInfo			// The completion key provided to the FSP is the LineInfo
        ))								// pointer. When the FSP reports status it uses this key thus allowing
                                        // us to know to which line the status belongs.
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevStartJob() failed with error:%d"),
			::GetLastError()
			);
		goto exit;
	}
	pLineInfo->SafeSetJobHandle(hJob);


	//
	//Receive the job itself
	//
	if (false == g_pFSP->FaxDevReceive(
        hJob,
        hReceiveCall,
        pFaxReceive
		))
	{
		if (true == pLineInfo->CanReceiveFail())
		{
			//
			//it's ok for FaxDevReceive() to fail, don't log an error
			//
			::lgLogDetail(
				LOG_X,
				5,
				TEXT("FaxDevReceive() has failed (ec: %ld)"),
				::GetLastError()
				);
		}
		else
		{
			//
			//FaxDevReceive() has failed, log an error
			//
			::lgLogError(
				LOG_SEV_1,
				TEXT("FaxDevReceive() failed with error:%d"),
				::GetLastError()
				);
		}
	}
	else
	{
		//
		//Job receiving is finished OK
		//
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("FaxDevReceive() succeeded")
			);

		//
		//Close the HCall handle
		//
		pLineInfo->CloseHCall();
		
		if (NULL == g_hFaxTiffLibrary)
		{
			//
			//We need to load FxsTiff.dll
			//
			g_hFaxTiffLibrary = LoadLibrary(FXSTIFF_DLL);
			if (NULL == g_hFaxTiffLibrary)
			{
				::lgLogError(
					LOG_SEV_2,
					TEXT("LoadLibrary(FxsTiff.DLL) failed with error:%d"),
					::GetLastError()
					);
				goto exit;
			}
		}
		if (NULL == g_fnTiffPostProcessFast)
		{
			//
			//We need to get the address of TiffPostProcessFast()
			//
			g_fnTiffPostProcessFast= (PTIFFPOSTPROCESSFAST) (GetProcAddress(g_hFaxTiffLibrary, "TiffPostProcessFast"));
			if (NULL == g_fnTiffPostProcessFast)
			{
				::lgLogError(
					LOG_SEV_2,
					TEXT("GetProcAddress(TiffPostProcessFast) failed with error:%d"),
					::GetLastError()
					);
				goto exit;
			}
		}
		
		//
		//OK, now we can actually call TiffPostProcessFast()
		//
		if (!g_fnTiffPostProcessFast( pFaxReceive->FileName, NULL ))
		{
			::lgLogError(
				LOG_SEV_2,
				TEXT("TiffPostProcessFast() failed with error:%d"),
				::GetLastError()
				);
		}
	}


exit:
	return 0;
}



ULONG TapiWorkerThread(LPVOID unUsed)
{
    CFspLineInfo *pLineInfo;
    BOOL Rval;
    DWORD Bytes;
    ULONG_PTR CompletionKey;
    LPLINEMESSAGE LineMsg = NULL;
	
	while(false == g_bTerminateTapiThread)
	{
        if (LineMsg)
		{
            ::LocalFree( LineMsg );
			LineMsg = NULL;
        }

        Rval = ::GetQueuedCompletionStatus(
            g_hTapiCompletionPort,
            &Bytes,
            &CompletionKey,
            (LPOVERLAPPED*) &LineMsg,
            WAIT_FOR_COMPLETION_PORT_TIMEOUT
            );
        if (!Rval)
		{
			if (WAIT_TIMEOUT == ::GetLastError())
			{
				//
				//Timeout, continue to the next iteration
				//
				;
			}
			else
			{
				LineMsg = NULL;
				::lgLogError(
					LOG_SEV_2,
					TEXT("GetQueuedCompletionStatus() failed, ec=0x%08x"),
					GetLastError()
					);
			}
            continue;
        }
		
        pLineInfo = (CFspLineInfo*) LineMsg->dwCallbackInstance;
		pLineInfo->Lock();

        ShowLineEvent(
            (HLINE) LineMsg->hDevice,
            (HCALL) LineMsg->hDevice,
			NULL,
            LineMsg->dwCallbackInstance,
            LineMsg->dwMessageID,
            LineMsg->dwParam1,
            LineMsg->dwParam2,
            LineMsg->dwParam3
            );

		

        switch( LineMsg->dwMessageID )
		{
        case LINE_ADDRESSSTATE:
            if (LineMsg->dwParam2 == LINEADDRESSSTATE_INUSEONE ||
                LineMsg->dwParam2 == LINEADDRESSSTATE_INUSEMANY)
			{
                //
                // the port is now unavailable
                //
                ::lgLogDetail(
					LOG_X,
					6,
					TEXT("pLineInfo->m_State=0x%x, change it now to FPS_AVAILABLE"),
                    pLineInfo->GetDeviceState()
					);
                pLineInfo->SafeMakeDeviceStateAvailable();
            }
            if (LineMsg->dwParam2 == LINEADDRESSSTATE_INUSEZERO)
			{

                //
                // the port is now available
                //
                ::lgLogDetail(
					LOG_X,
					6,
					TEXT("pLineInfo->m_State=0x%x, change it now to FPS_UNAVAILABLE"),
                    pLineInfo->GetDeviceState()
					);
                pLineInfo->SafeMakeDeviceStateUnAvailable();
            }
            break;

        case LINE_CALLINFO:
            break;

        case LINE_CALLSTATE:
            //BUGBUG:TBD:
			/*
			if (LineMsg->dwParam3 == LINECALLPRIVILEGE_OWNER && pLineInfo->m_JobEntry && pLineInfo->m_JobEntry->HandoffJob) {
                //
                // call was just handed off to us
                //
                if (pLineInfo->m_JobEntry  && pLineInfo->m_JobEntry->HandoffJob) {
                    pLineInfo->m_HandoffCallHandle = (HCALL) LineMsg->hDevice;
                    SetEvent( pLineInfo->m_JobEntry->hCallHandleEvent );
                }
                else {
                    DebugPrint(( TEXT("We have LINE_CALLSTATE msg, doing lineDeallocateCall\r\n")));
                    lineDeallocateCall( (HCALL) LineMsg->hDevice );
                }

            }


            if (LineMsg->dwParam1 == LINECALLSTATE_IDLE)  {
                DebugPrint(( TEXT("We have LINE_CALLSTATE (IDLE) msg, doing 'ReleaseTapiLine'\r\n")));
                ReleaseTapiLine( pLineInfo, (HCALL) LineMsg->hDevice );
                pLineInfo->m_NewCall = FALSE;
                CreateFaxEvent( pLineInfo->m_PermanentLineID, FEI_IDLE, 0xffffffff );
            }

            if (pLineInfo->m_NewCall && LineMsg->dwParam1 != LINECALLSTATE_OFFERING && pLineInfo->m_State == FPS_AVAILABLE) {
                pLineInfo->m_State = FPS_NOT_FAX_CALL;
                pLineInfo->m_NewCall = FALSE;
            }
			*/
            break;

        case LINE_CLOSE:
			// BUGBUG:TBD, close the line or something
			/*
            pLineInfo->m_State = FPS_OFFLINE;
            pLineInfo->m_hLine = 0;
			*/
            break;

        case LINE_DEVSPECIFIC:
            break;

        case LINE_DEVSPECIFICFEATURE:
            break;

        case LINE_GATHERDIGITS:
            break;

        case LINE_GENERATE:
            break;

        case LINE_LINEDEVSTATE:
			break;

        case LINE_MONITORDIGITS:
            break;

        case LINE_MONITORMEDIA:
            break;

        case LINE_MONITORTONE:
            break;

        case LINE_REPLY:
            break;

        case LINE_REQUEST:
            break;

        case PHONE_BUTTON:
            break;

        case PHONE_CLOSE:
            break;

        case PHONE_DEVSPECIFIC:
            break;

        case PHONE_REPLY:
            break;

        case PHONE_STATE:
            break;

        case LINE_CREATE:
            break;

        case PHONE_CREATE:
            break;

        case LINE_AGENTSPECIFIC:
            break;

        case LINE_AGENTSTATUS:
            break;

        case LINE_APPNEWCALL:
            break;

        case LINE_PROXYREQUEST:
            break;

        case LINE_REMOVE:
            break;

        case PHONE_REMOVE:
            break;
        }

        //
        // Check if the provider module is still up
		//
		CFspWrapper::LockProvider();
		if ((NULL == g_pFSP) || (NULL == g_pFSP->m_hInstModuleHandle) )
		{
			::lgLogDetail(
				LOG_X,
				5,
				TEXT("Provider is not loaded, not calling the callback function")
				);
			CFspWrapper::UnlockProvider();
            pLineInfo->UnLock();
			continue;
		}
		//
		// call the device providers line callback function
        //
		(void)g_pFSP->FaxDevCallback(
			pLineInfo->GetJobHandle(),
			LineMsg->hDevice,
			LineMsg->dwMessageID,
			LineMsg->dwCallbackInstance,
			LineMsg->dwParam1,
			LineMsg->dwParam2,
			LineMsg->dwParam3
			);

		//
		//do we have an offering call?
		//
		if (LineMsg->dwMessageID == LINE_CALLSTATE && LineMsg->dwParam1 == LINECALLSTATE_OFFERING)
		{
			//
			//Verify if device is enabled for receiving
			//
			if ((pLineInfo->IsReceivingEnabled()) && (pLineInfo->IsDeviceAvailable())) 
			{
        
				//
				//Receive the job in a separate thread
				//
				if (!pLineInfo->m_pFaxReceive)
				{
					::lgLogError(
						LOG_SEV_2,
						TEXT("FATAL ERROR: pLineInfo does not have FAX_RECEIVE item"),
						::GetLastError()
						);
					CFspWrapper::UnlockProvider();
					pLineInfo->UnLock();
					return -1;
				}
				//
				//The destination to receive the file is supplied in pLineInfo struct(pLineInfo->m_szReceiveFileName)
				//
				pLineInfo->SetReceiveCallHandle(LineMsg->hDevice);
				

				if (false == pLineInfo->CreateReceiveThread())
				{
					CFspWrapper::UnlockProvider();
					pLineInfo->UnLock();
					return -1;
				}
			}
			else
			{
				::lgLogDetail(
					LOG_X,
					6,
					TEXT("We have an offering call, but the device is not configured for receiving or is un available")
					);
			}
		}//offering call
		CFspWrapper::UnlockProvider();
		pLineInfo->UnLock();
    }
	//
	//Exit the thread
	//
	return 0;
}

void TerminateTapiThread(CThreadItem *pTapiThread)
{
	if (NULL == pTapiThread->m_hThread)
	{
		return;
	}

	//
	//Signal the Tapi thread to terminate
	//
	g_bTerminateTapiThread = true;

	//
	//Now let's wait for the thread to finish
	//
	DWORD dwStatus = ::WaitForSingleObject(pTapiThread->m_hThread,WAIT_FOR_THREAD_TO_TERMINATE_TIMEOUT);
	if (WAIT_TIMEOUT == dwStatus)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("Signaling Tapi thread to terminate got a timeout after %d milliseconds"),
			WAIT_FOR_THREAD_TO_TERMINATE_TIMEOUT
			);
		goto out;
	}

	if (WAIT_OBJECT_0 != dwStatus)
	{
		::lgLogError(
			LOG_SEV_2,
			TEXT("WaitForSingleObject(tapiThread.m_hThread) returned %d"),
			dwStatus
			);
		goto out;
	}

	pTapiThread->CloseHandleResetThreadId();
	pTapiThread = NULL;

out:
	//
	//BUGBUG: Should we call TerminateThread
	//
	return;
}

bool  CreateTapiThread()
{
	assert(NULL == g_TapiThread.m_hThread);
	
	g_bTerminateTapiThread = false;
	if (false == g_TapiThread.StartThread(
		(LPTHREAD_START_ROUTINE) TapiWorkerThread,
		NULL
		))
	{
		g_TapiThread.m_dwThreadId		= 0;
		g_TapiThread.m_hThread		= NULL;
		return false;
	}
	return true;
}




void GetErrorString(DWORD dwErrorCode,TCHAR *szErrorString)
{

	LPVOID lpMsgBuf;
	if (0 < ::FormatMessage( 
		FORMAT_MESSAGE_ALLOCATE_BUFFER | 
		FORMAT_MESSAGE_FROM_SYSTEM | 
		FORMAT_MESSAGE_IGNORE_INSERTS,
		NULL,
		dwErrorCode,
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
		(LPTSTR) &lpMsgBuf,
		0,
		NULL 
	))
	{
		::_tcscpy(szErrorString,(LPTSTR) lpMsgBuf);
		::LocalFree( lpMsgBuf );
	}
	else 
	{
		::_tcscpy(szErrorString,TEXT("Unknown ERROR"));
	}


}

HRESULT GetValueFromINI(
	TCHAR *szINISectionName,
	TCHAR *szINIKeyName,
	TCHAR *szResponseString,
	DWORD dwSize
	)
{
	HRESULT hr = S_OK;
	DWORD dwGetPrivateProfileStringStatus;
	
	//
	//Allocate a buffer to work with
	//
	TCHAR * szIniString = (TCHAR *) ::malloc(dwSize);
	if (!szIniString)
	{
		hr = E_OUTOFMEMORY;
		goto out;
	}
	::ZeroMemory(szIniString,dwSize);

	dwGetPrivateProfileStringStatus = ::GetPrivateProfileString(
		szINISectionName,		// points to section name
		szINIKeyName,			// points to key name
		TEXT(""),				// points to default string
		szIniString,			// points to destination buffer
		dwSize,					// size of destination buffer
		g_szFspIniFileName		// points to initialization filename
		);
	if (0 > dwGetPrivateProfileStringStatus)
	{
		hr = HRESULT_FROM_WIN32(ERROR_READ_FAULT);
		goto out;
	}
	
	if(dwGetPrivateProfileStringStatus == dwSize - 1)
	{
		hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
		goto out;
	}
	if (0 == _tcscmp(szIniString,TEXT("")))
	{
		hr = S_FALSE;
		goto out;
	}

	::_tcscpy(szResponseString,szIniString);

out:
	::free(szIniString);
	return hr;
}

TCHAR *GetFspToLoad()
{
	if (NULL != g_szModuleName)
	{
		//
		//g_szModuleName already contains the module name, just return it
		//
		return g_szModuleName;
	}

	//
	//Get the module name from the registry and set it in the global variable
	//
	TCHAR szBufferToConvert[MAX_INI_VALUE];
	if (S_OK != GetValueFromINI(
		INI_SECTION__FSP_SETTINGS,
		FSP_MODULE_NAME__INI_KEY,
		szBufferToConvert,
		MAX_INI_VALUE
		))
	{
		return NULL;
	}
	
	//
	//Duplicate the string, CALLER MUST FREE THIS BUFFER
	//
	g_szModuleName = ::_tcsdup(szBufferToConvert);
	return g_szModuleName;
}

void GetCasesToRun()
{
	TCHAR szIniValue[MAX_INI_VALUE];
	TCHAR szKeyName[MAX_INI_VALUE];
	INT i = 0;

	::lgLogDetail(
		LOG_X,
		5,
		TEXT("I will run the following test case numbers")
		);

	for (i=0; i < LAST_CASE_NUMBER ;i++)
	{
		//
		//Prepare the key name to read
		//
		_stprintf( szKeyName, TEXT("Case%d"),i);
		if (S_OK != GetValueFromINI(
			INI_SECTION__CASES,
			szKeyName,
			szIniValue,
			MAX_INI_VALUE
			))
		{
			//
			//Reading from INI has failed for some reason
			//no point in quilting all the test cases,
			//we'll use the default value: don't run this test case
			//
			baRunThisTest[i] = false;
			continue;
		}
		if (0 == _tcscmp(szIniValue,TEXT("True")))
		{
			//
			//the default is: don't run this test case
			//
			baRunThisTest[i] = true;
			::lgLogDetail(
				LOG_X,
				5,
				TEXT("Run Test case: %d"),
				i
				);
		}
		else
		{
			//
			//default is don't run
			//
			baRunThisTest[i] = false;
		}
	}
}

bool GetIniSettings()
{
	//
	//FSP Settings
	//
	g_szModuleName = GetFspToLoad();
	if (NULL == g_szModuleName)
	{
		return false;
	}

	//
	//Device IDs
	//
	TCHAR szBufferToConvert[MAX_INI_VALUE];
	if (S_OK != GetValueFromINI(
		INI_SECTION__FSP_SETTINGS,
		INVALID_DEVICE_ID__INI_KEY,
		szBufferToConvert,
		MAX_INI_VALUE
		))
	{
		::lgLogError(
			LOG_SEV_2,
			TEXT("Can't find the Invalid DeviceID settings")
			);
		return false;
	}
	g_dwInvalidDeviceId	= _ttol(szBufferToConvert);

	if (S_OK != GetValueFromINI(
		INI_SECTION__FSP_SETTINGS,
		SENDING_VALID_DEVICE_ID__INI_KEY,
		szBufferToConvert,
		MAX_INI_VALUE
		))
	{
		::lgLogError(
			LOG_SEV_2,
			TEXT("Can't find the Valid DeviceID settings")
			);return false;
	}
	g_dwSendingValidDeviceId = ::_ttol(szBufferToConvert);

	if (S_OK != GetValueFromINI(
		INI_SECTION__FSP_SETTINGS,
		RECEIVE_VALID_DEVICE_ID__INI_KEY,
		szBufferToConvert,
		MAX_INI_VALUE
		))
	{
		::lgLogError(
			LOG_SEV_2,
			TEXT("Can't find the Receive DeviceID settings")
			);
		return false;
	}
	g_dwReceiveValidDeviceId = ::_ttol(szBufferToConvert);
	
	
	//
	//General settings
	//
	if (S_OK != GetValueFromINI(
		INI_SECTION__GENERAL,
		INIT_PARAMETERS_EACH_TEST__INI_KEY,
		szBufferToConvert,
		MAX_INI_VALUE
		))
	{
		//not a mandetory key, default is don't load the FSP each test
		g_reloadFspEachTest = false;
	}
	else
	{
		if (0 == _tcsicmp(TEXT("True"),szBufferToConvert))
		{
			g_reloadFspEachTest = true;
		}
		else
		{
			g_reloadFspEachTest = false;
		}
	}
	if (S_OK != GetValueFromINI(
		INI_SECTION__GENERAL,
		MAX_TIME_FOR_RECEIVING_FAX__INI_KEY,
		szBufferToConvert,
		MAX_INI_VALUE
		))
	{
		::lgLogError(
			LOG_SEV_2,
			TEXT("Can't find the MaxReceiveTimeOut settings")
			);
		return false;
	}
	g_dwReceiveTimeOut = _ttol(szBufferToConvert);

	//
	//FSP time till ringing and transfering bits
	//
	if (S_OK != GetValueFromINI(
		INI_SECTION__GENERAL,
		TIME_FROM_SEND_START_TILL_RINGING_STARTS__INI_KEY,
		szBufferToConvert,
		MAX_INI_VALUE
		))
	{
		::lgLogError(
			LOG_SEV_2,
			TEXT("Can't find the Time till ringing starts settings")
			);
		return false;
	}
	g_dwTimeTillRingingStarts = _ttol(szBufferToConvert);
	if (S_OK != GetValueFromINI(
		INI_SECTION__GENERAL,
		TIME_FROM_SEND_START_TILL_TRANSFERING_BITS_STARTS__INI_KEY,
		szBufferToConvert,
		MAX_INI_VALUE
		))
	{
		::lgLogError(
			LOG_SEV_2,
			TEXT("Can't find the Time till ringing starts settings")
			);
		return false;
	}
	g_dwTimeTillTransferingBitsStarts = _ttol(szBufferToConvert);

		
	//
	//Phone Numbers
	//
	if (S_OK != GetValueFromINI(
		INI_SECTION__PHONE_NUMBERS,
		VALID_RECIPIENT_FAX_NUMBER__INI_KEY,
		g_szValidRecipientFaxNumber,
		MAX_INI_VALUE
		))
	{
		::lgLogError(
			LOG_SEV_2,
			TEXT("Can't find the Receive Number settings")
			);
		return false;
	}
	if (S_OK != GetValueFromINI(
		INI_SECTION__PHONE_NUMBERS,
		INVALID_RECIPIENT_FAX_NUMBER__INI_KEY,
		g_szInvalidRecipientFaxNumber,
		MAX_INI_VALUE
		))
	{
		::lgLogError(
			LOG_SEV_2,
			TEXT("Can't find the Invalid receive number settings")
			);
		return false;
	}
	
	//
	//TIFF files
	//
	if (S_OK != GetValueFromINI(
		INI_SECTION__TIFF_FILES,
		VALID_TIFF_FILE__INI_KEY,
		g_szValid__TiffFileName,
		MAX_INI_VALUE
		))
	{
		::lgLogError(
			LOG_SEV_2,
			TEXT("Can't find the Valid Tiff Filename settings")
			);
		return false;
	}
	if (S_OK != GetValueFromINI(
		INI_SECTION__TIFF_FILES,
		VALID_TIFF_FILE__READONLY__INI_KEY,
		g_szValid_ReadOnly_TiffFileName,
		MAX_INI_VALUE
		))
	{
		::lgLogError(
			LOG_SEV_2,
			TEXT("Can't find the readonly Tiff Filename settings")
			);
		return false;
	}
	if (S_OK != GetValueFromINI(
		INI_SECTION__TIFF_FILES,
		INVALID_TIFF_FILE__FILENOTFOUND__INI_KEY,
		g_szValid_FileNotFound_TiffFileName,
		MAX_INI_VALUE
		))
	{
		::lgLogError(
			LOG_SEV_2,
			TEXT("Can't find the file not found Tiff Filename settings")
			);
		return false;
	}
	if (S_OK != GetValueFromINI(
		INI_SECTION__TIFF_FILES,
		VALID_TIFF_FILE__UNC__INI_KEY,
		g_szValid_UNC_TiffFileName,
		MAX_INI_VALUE
		))
	{
		::lgLogError(
			LOG_SEV_2,
			TEXT("Can't find the UNC Path Tiff Filename settings")
			);
		return false;
	}
	if (S_OK != GetValueFromINI(
		INI_SECTION__TIFF_FILES,
		VALID_TIFF_FILE__NTFS__INI_KEY,
		g_szValid_NTFS_TiffFileName,
		MAX_INI_VALUE
		))
	{
		::lgLogError(
			LOG_SEV_2,
			TEXT("Can't find the NTFS path Tiff Filename settings")
			);
		return false;
	}
	if (S_OK != GetValueFromINI(
		INI_SECTION__TIFF_FILES,
		VALID_TIFF_FILE__FAT__INI_KEY,
		g_szValid_FAT_TiffFileName,
		MAX_INI_VALUE
		))
	{
		::lgLogError(
			LOG_SEV_2,
			TEXT("Can't find the FAT path Tiff Filename settings")
			);
		return false;
	}
	if (S_OK != GetValueFromINI(
		INI_SECTION__TIFF_FILES,
		VALID_TIFF_FILE__LINK__INI_KEY,
		g_szValid_Link_TiffFileName,
		MAX_INI_VALUE
		))
	{
		::lgLogError(
			LOG_SEV_2,
			TEXT("Can't find the LINK path Tiff Filename settings")
			);
		return false;
	}
	if (S_OK != GetValueFromINI(
		INI_SECTION__TIFF_FILES,
		VALID_TIFF_FILE__NOT_TIFF_EXT_BUT_TIFF_FORMAT__INI_KEY,
		g_szValid_NotTiffExtButTiffFormat_TiffFileName,
		MAX_INI_VALUE
		))
	{
		::lgLogError(
			LOG_SEV_2,
			TEXT("Can't find the non tiff extension Tiff Filename settings")
			);
		return false;
	}
	if (S_OK != GetValueFromINI(
		INI_SECTION__TIFF_FILES,
		INVALID_TIFF_FILE__INVALID_TIFF_FORMAT__INI_KEY,
		g_szValid_InvalidTiffFormat_TiffFileName,
		MAX_INI_VALUE
		))
	{
		::lgLogError(
			LOG_SEV_2,
			TEXT("Can't find the invalid tiff format Tiff Filename settings")
			);
		return false;
	}
	if (S_OK != GetValueFromINI(
		INI_SECTION__TIFF_FILES,
		VALID_TIFF_FILE__RECEIVE_FILE_NAME__INI_KEY,
		g_szValid_ReceiveFileName,
		MAX_INI_VALUE
		))
	{
		::lgLogError(
			LOG_SEV_2,
			TEXT("Can't find the Valid receive Tiff Filename settings")
			);
		return false;
	}

	//
	//Log the INI settings
	//
	
	//
	//Tiff
	//
	::lgLogDetail(
		LOG_X,
		5,
		TEXT("\n\n***INI Settings***\nFSP=%s%s%s"),
		g_szModuleName,
		TEXT("\n******************"),
		TEXT("\n***Tiff Files***")
		);
	::lgLogDetail(
		LOG_X,
		5,
		TEXT("Valid tiff file is: \"%s\""),
		g_szValid__TiffFileName
		);
	::lgLogDetail(
		LOG_X,
		5,
		TEXT("Valid readonly tiff file is: \"%s\""),
		g_szValid_ReadOnly_TiffFileName
		);
	::lgLogDetail(
		LOG_X,
		5,
		TEXT("File not found tiff file is: \"%s\""),
		g_szValid_FileNotFound_TiffFileName
		);
	::lgLogDetail(
		LOG_X,
		5,
		TEXT("Valid UNC path tiff file is: \"%s\""),
		g_szValid_UNC_TiffFileName
		);
	::lgLogDetail(
		LOG_X,
		5,
		TEXT("Valid tiff file on NTFS File System is: \"%s\""),
		g_szValid_NTFS_TiffFileName
		);
	::lgLogDetail(
		LOG_X,
		5,
		TEXT("Valid tiff file on FAT File System is: \"%s\""),
		g_szValid_FAT_TiffFileName
		);
	::lgLogDetail(
		LOG_X,
		5,
		TEXT("Valid link to to a tiff file is: \"%s\""),
		g_szValid_Link_TiffFileName
		);
	::lgLogDetail(
		LOG_X,
		5,
		TEXT("tiff file with out a tiff extension is: \"%s\""),
		g_szValid_NotTiffExtButTiffFormat_TiffFileName
		);
	::lgLogDetail(
		LOG_X,
		5,
		TEXT("tiff file with an incorrect tiff version is: \"%s\""),
		g_szValid_InvalidTiffFormat_TiffFileName
		);
	::lgLogDetail(
		LOG_X,
		5,
		TEXT("Receive tiff file to: \"%s\""),
		g_szValid_ReceiveFileName
		);


	//
	//Phone number settings
	//
	::lgLogDetail(
		LOG_X,
		5,
		TEXT("\n***Phone number settings***")
		);
	::lgLogDetail(
		LOG_X,
		5,
		TEXT("Invalid recipient number is: %s"),
		g_szInvalidRecipientFaxNumber
		);
	::lgLogDetail(
		LOG_X,
		5,
		TEXT("Valid recipient number is: %s"),
		g_szValidRecipientFaxNumber
		);
	
	//
	//Other settings
	//
	::lgLogDetail(
		LOG_X,
		5,
		TEXT("\n***Other settings***")
		);
	::lgLogDetail(
		LOG_X,
		5,
		TEXT("Valid Sending device ID: %d"),
		g_dwSendingValidDeviceId
		);
	::lgLogDetail(
		LOG_X,
		5,
		TEXT("Valid Receiving device ID: %d"),
		g_dwReceiveValidDeviceId
		);

	::lgLogDetail(
		LOG_X,
		5,
		TEXT("Invalid device ID: %d"),
		g_dwInvalidDeviceId
		);
	
	::lgLogDetail(
		LOG_X,
		5,
		TEXT("Max TimeOut for receive the default (valid tiff) fax is: %d"),
		g_dwReceiveTimeOut
		);

	::lgLogDetail(
		LOG_X,
		5,
		TEXT("Time in milliseconds from the start of the send operation until the receiving device starts to ring: %d"),
		g_dwTimeTillRingingStarts
		);
	
	::lgLogDetail(
		LOG_X,
		5,
		TEXT("Time in milliseconds from the start of the send operation until the receiving device answers and bits are transferred: %d"),
		g_dwTimeTillTransferingBitsStarts
		);
		
	if (true == g_reloadFspEachTest)
	{
		::lgLogDetail(
			LOG_X,
			5,
			TEXT("The FSP will be initialized Separately for each test")
			);
	}
	
	GetCasesToRun();
	return true;
}



bool AllocGlobalVariables()
{

	//
	//TIFF files
	//
	g_szValid__TiffFileName = (TCHAR*) malloc(sizeof(TCHAR)*MAX_INI_VALUE);
	if (NULL == g_szValid__TiffFileName )
	{
		goto error;
	}
	g_szValid_ReadOnly_TiffFileName = (TCHAR*) malloc(sizeof(TCHAR)*MAX_INI_VALUE);
	if (NULL == g_szValid_ReadOnly_TiffFileName )
	{
		goto error;
	}
	g_szValid_FileNotFound_TiffFileName = (TCHAR*) malloc(sizeof(TCHAR)*MAX_INI_VALUE);
	if (NULL == g_szValid_FileNotFound_TiffFileName )
	{
		goto error;
	}
	g_szValid_UNC_TiffFileName = (TCHAR*) malloc(sizeof(TCHAR)*MAX_INI_VALUE);
	if (NULL == g_szValid_UNC_TiffFileName )
	{
		goto error;
	}
	g_szValid_NTFS_TiffFileName = (TCHAR*) malloc(sizeof(TCHAR)*MAX_INI_VALUE);
	if (NULL == g_szValid_NTFS_TiffFileName )
	{
		goto error;
	}
	g_szValid_FAT_TiffFileName = (TCHAR*) malloc(sizeof(TCHAR)*MAX_INI_VALUE);
	if (NULL == g_szValid_FAT_TiffFileName )
	{
		goto error;
	}
	g_szValid_Link_TiffFileName = (TCHAR*) malloc(sizeof(TCHAR)*MAX_INI_VALUE);
	if (NULL == g_szValid_Link_TiffFileName )
	{
		goto error;
	}
	g_szValid_NotTiffExtButTiffFormat_TiffFileName = (TCHAR*) malloc(sizeof(TCHAR)*MAX_INI_VALUE);
	if (NULL == g_szValid_NotTiffExtButTiffFormat_TiffFileName )
	{
		goto error;
	}
	g_szValid_InvalidTiffFormat_TiffFileName = (TCHAR*) malloc(sizeof(TCHAR)*MAX_INI_VALUE);
	if (NULL == g_szValid_InvalidTiffFormat_TiffFileName )
	{
		goto error;
	}
	g_szValid_ReceiveFileName = (TCHAR*) malloc(sizeof(TCHAR)*MAX_INI_VALUE);
	if (NULL == g_szValid_ReceiveFileName )
	{
		goto error;
	}

	//
	//other variables
	//
	g_szInvalidRecipientFaxNumber = (TCHAR*) malloc(sizeof(TCHAR)*MAX_INI_VALUE);
	if (NULL == g_szInvalidRecipientFaxNumber )
	{
		goto error;
	}
	g_szValidRecipientFaxNumber = (TCHAR*) malloc(sizeof(TCHAR)*MAX_INI_VALUE);
	if (NULL == g_szValidRecipientFaxNumber )
	{
		goto error;
	}
	
	return true;


error:

	//
	//Free all the globals that we set before
	//
	FreeGlobalVariables();
	return false;
}

HANDLE CreateCompletionPort()
{
	HANDLE StatusCompletionPortHandle = CreateIoCompletionPort(
        INVALID_HANDLE_VALUE,
        NULL,
        0,
        1		//taken from the fax service code...
        );
    if (NULL == StatusCompletionPortHandle)
	{
        ::lgLogError(
			LOG_SEV_2,
			TEXT("Failed to create CreateIoCompletionPort (ec: %ld)"),
			::GetLastError()
			);
    }
	return StatusCompletionPortHandle;
}


bool InitThreadsAndCompletionPorts()
{
	//
	//global completion port for use by all tests (for FaxDevStartJob)
	//
	g_hCompletionPortHandle = CreateCompletionPort();
	if (NULL == g_hCompletionPortHandle)
	{
		goto error;
	}
	
	//
	//Tapi needs a completion port to signal us stuff
	//
	g_hTapiCompletionPort = CreateCompletionPort();
	if (NULL == g_hTapiCompletionPort)
	{
		goto error;
	}
	
	//
	//Create a tapi thread which will wait on the completion port
	//
	if (false == CreateTapiThread())
	{
		//
		//Logging is in CreateTapiThread()
		//
		goto error;
	}
	return true;
error:
	::CloseHandle(g_hCompletionPortHandle);
	g_hCompletionPortHandle = NULL;
	::CloseHandle(g_hTapiCompletionPort);
	g_hTapiCompletionPort = NULL;
	TerminateTapiThread(&g_TapiThread);
	return false;
}


void FreeGlobalVariables()
{
	//
	//Phone numbers
	//
	::free (g_szInvalidRecipientFaxNumber);
	g_szInvalidRecipientFaxNumber				= NULL;
	::free(g_szValidRecipientFaxNumber );
	g_szValidRecipientFaxNumber					= NULL;

	//
	//FSP info
	//
	g_dwInvalidDeviceId							=	0;
	g_dwSendingValidDeviceId					=	0;
	g_dwReceiveValidDeviceId					=	0;

	//
	//TIFF files
	//
	::free(g_szValid__TiffFileName);
	g_szValid__TiffFileName						=	NULL;
	::free(g_szValid_ReadOnly_TiffFileName	);
	g_szValid_ReadOnly_TiffFileName				=	NULL;
	::free(g_szValid_FileNotFound_TiffFileName	);
	g_szValid_FileNotFound_TiffFileName			=	NULL;
	::free(g_szValid_UNC_TiffFileName	);
	g_szValid_UNC_TiffFileName					=	NULL;
	::free(g_szValid_NTFS_TiffFileName	);
	g_szValid_NTFS_TiffFileName					=	NULL;
	::free(g_szValid_FAT_TiffFileName	);
	g_szValid_FAT_TiffFileName					=	NULL;
	::free(g_szValid_Link_TiffFileName	);
	g_szValid_Link_TiffFileName					=	NULL;
	::free(g_szValid_NotTiffExtButTiffFormat_TiffFileName	);
	g_szValid_NotTiffExtButTiffFormat_TiffFileName			=	NULL;
	::free(g_szValid_InvalidTiffFormat_TiffFileName	);
	g_szValid_InvalidTiffFormat_TiffFileName	=	NULL;
	::free(g_szValid_ReceiveFileName	);
	g_szValid_ReceiveFileName					=	NULL;
}

void ShutDownTapiAndTapiThread()
{
	if (NULL != g_TapiThread.m_hThread)
	{
		TerminateTapiThread(&g_TapiThread);
	}
	ShutdownTapi(g_hLineAppHandle);
	g_hLineAppHandle							= NULL;
}

bool LoadLibraries()
{
	if (NULL == g_hFaxTiffLibrary)
	{
		//
		//We need to load FxsTiff.dll
		//
		g_hFaxTiffLibrary = ::LoadLibrary(FXSTIFF_DLL);
		if (NULL == g_hFaxTiffLibrary)
		{
			::lgLogError(
				LOG_SEV_2,
				TEXT("LoadLibrary(FxsTiff.DLL) failed with error:%d"),
				::GetLastError()
				);
			goto error;
		}
	}
	if (NULL == g_fnTiffPostProcessFast)
	{
		//
		//We need to get the address of TiffPostProcessFast()
		//
		g_fnTiffPostProcessFast = (PTIFFPOSTPROCESSFAST) (::GetProcAddress(g_hFaxTiffLibrary, "TiffPostProcessFast"));
		if (NULL == g_fnTiffPostProcessFast)
		{
			::lgLogError(
				LOG_SEV_2,
				TEXT("GetProcAddress(TiffPostProcessFast) failed with error:%d"),
				::GetLastError()
				);
			goto error;
		}
	}
	return true;

error:
	UnloadLibraries();
	return false;
}

void UnloadLibraries()
{
	if (NULL != g_hFaxTiffLibrary)
	{
		//
		//Unload FxsTiff.dll
		//
		FreeLibrary(g_hFaxTiffLibrary);
		g_hFaxTiffLibrary = NULL;
	}
	if (NULL != g_fnTiffPostProcessFast)
	{
		g_fnTiffPostProcessFast = NULL;
	}

}





bool AbortOperationAndWaitForAbortState(PFAX_ABORT_ITEM pAbortItem)
{
	bool bRet = false;
	PFAX_DEV_STATUS pAbortingDevStatus = NULL;
	
	//
	//Sleep the desired time
	//
	::Sleep(pAbortItem->dwMilliSecondsBeforeCallingAbort);


	//
	//Verify the job to abort is OK
	//
	HANDLE hJob = pAbortItem->pLineInfo->GetJobHandle();
	if (NULL == hJob)
	{
		::lgLogError(
			LOG_SEV_2,
			TEXT("Abort item has a NULL hFaxHandle")
			);
		goto out;
	}
	
	//
	//Now we can abort the operation
	//
	if (false == g_pFSP->FaxDevAbortOperation(hJob))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevAbortOperation() failed - %d"),
			::GetLastError()
			);
		goto out;
	}

	//
	//The job state should be USER_ABORTED now
	//
	
	//
	//Get the status through FaxDevReportStatus
	//
	if (ERROR_SUCCESS != pAbortItem->pLineInfo->GetDevStatus(
		&pAbortingDevStatus,
		pAbortItem->bLogging				
		))
	{
		//
		//GetDevStatus() failed, logging is in GetDevStatus()
		//
		goto out;
	}
	else
	{
		//
		//Now let's verify the status is USER_ABORTED
		//
		if (FS_USER_ABORT == pAbortingDevStatus->StatusId)
		{
			bRet = true;
			if (true == pAbortItem->bLogging)
			{
				::lgLogDetail(
					LOG_PASS,
					2,
					TEXT("Aborting Job: GetDevStatus() reported FS_USER_ABORT")
					);
			}
		}
		else
		{
			bRet = false;
			if (true == pAbortItem->bLogging)
			{
				::lgLogError(
					LOG_SEV_1,
					TEXT("Aborting Job: GetDevStatus() reported %d StatusId instead of FS_USER_ABORT"),
					pAbortingDevStatus->StatusId
					);
			}
		}
	}

out:
	if (NULL != pAbortingDevStatus)
	{
		free (pAbortingDevStatus);
	}
	return bRet;
}


BOOL CALLBACK FaxServiceCallbackWithAssert(
    IN HANDLE FaxHandle,
    IN DWORD  DeviceId,
    IN DWORD_PTR  Param1,
    IN DWORD_PTR  Param2,
    IN DWORD_PTR  Param3
    )
{
	assert(false);
	::lgLogError(
		LOG_SEV_1,
		TEXT("FaxServiceCallback function should not be called by FSP, this is a future option")
		);
	return false;
}

void DumpDeviceId()
{
	
	//
	//First Init Tapi
	//
	LINEDEVCAPS *pLineDevCaps = NULL;
	HLINEAPP	hLineApp = NULL;
	DWORD i=0;
	DWORD dwSizeOfLineDevsCaps=0;
	
		
	TCHAR szDeviceName[MAX_PATH];
	TCHAR szProviderName[MAX_PATH];
	//
	//lineInitializeExParams structure init
	//
	DWORD					dwNumDevs	 =	0 ;
	DWORD					dwAPIVersion = API_VERSION;
	DWORD					dwExtVersion = 0;
	LINEINITIALIZEEXPARAMS	lineInitializeExParams;
	
	
	::ZeroMemory(&lineInitializeExParams,sizeof (lineInitializeExParams));
    lineInitializeExParams.dwNeededSize		=	0;
    lineInitializeExParams.dwUsedSize		=	0;
	lineInitializeExParams.dwTotalSize		=	sizeof (lineInitializeExParams);
	lineInitializeExParams.dwOptions		=	LINEINITIALIZEEXOPTION_USEEVENT ;
    lineInitializeExParams.Handles.hEvent	=	NULL;
    lineInitializeExParams.dwCompletionKey	=	0;

	long lineInitializeStatus = ::lineInitializeEx(
		&hLineApp,
		GetModuleHandle(NULL),		//client application HINSTANCE.
		NULL,						//TAPI messages through Events, no callback function.
		NULL,						//Application module name will be used
		&dwNumDevs,					//Number of devices.
		&dwAPIVersion,				//TAPI API highest supported version.
		&lineInitializeExParams
		);
	if (0 != lineInitializeStatus)
	{
		::lgLogError(
			LOG_SEV_2, 
			TEXT("lineInitializeEx() failed, error code:0x%08x"),
			lineInitializeStatus
			);
		goto out;
	}
	assert(API_VERSION <= dwAPIVersion);
	
	dwSizeOfLineDevsCaps = (10*MAX_PATH*sizeof(TCHAR))+sizeof(LINEDEVCAPS);
	pLineDevCaps = (LINEDEVCAPS*) malloc (dwSizeOfLineDevsCaps);
	if (NULL == pLineDevCaps)
	{
		::lgLogError(
			LOG_SEV_2, 
			TEXT("malloc() failed")
			);
		goto out;
	}

	::lgLogDetail(
		LOG_X,
		1,
		TEXT("The following is a list of all Tapi supported Lines as reported by Tapi's GetDevCaps()\n%s"),
		TEXT("\t\t***************************************************************************************")
		);

	for (i=0;i<dwNumDevs;i++)
	{
		::ZeroMemory(pLineDevCaps,dwSizeOfLineDevsCaps);
		pLineDevCaps->dwTotalSize = dwSizeOfLineDevsCaps;
		
		long lineGetDevCapsStatus = ::lineGetDevCaps(
			hLineApp,           
			i,
			dwAPIVersion,
			dwExtVersion,
			pLineDevCaps
			);
		if (0 != lineGetDevCapsStatus)
		{
			::lgLogDetail(
				LOG_X,
				1,
				TEXT("Can't get device info for deviceId:%d"), 
				i
				);
			continue;
		}
		
		//
		//recorded the DeviceName
		//
		if (0 == pLineDevCaps->dwLineNameSize)
		{
			//
			//LineGetDevsCaps doesn't contains a Line Name, record a default one
			//
			_tcscpy(szDeviceName, TEXT(""));
		}
		else
		{
			//
			//LineGetDevsCaps contains Line Name, so record it
			//
			_tcscpy(szDeviceName, ( (LPTSTR)((LPBYTE) pLineDevCaps + pLineDevCaps->dwLineNameOffset) ));
		}
		//
		//recorded the Provider name
		//
		if (0 == pLineDevCaps->dwProviderInfoSize)
		{
			//
			//LineGetDevsCaps doesn't contains a Line Name, record a default one
			//
			_tcscpy(szProviderName, TEXT(""));
		}
		else
		{
			//
			//LineGetDevsCaps contains Line Name, so record it
			//
			_tcscpy(szProviderName, ( (LPTSTR)((LPBYTE) pLineDevCaps + pLineDevCaps->dwProviderInfoOffset) ));
		}
		
		::lgLogDetail(
			LOG_X,
			1,
			TEXT("DeviceName:\"%s\", DeviceID:%d  Device Provider:\"%s\""),
			szDeviceName,
			i,
			szProviderName
			);
	}
out:
	::lineShutdown(hLineApp);
}

bool InitFsp(bool bLog)
{
	assert (NULL == g_pFSP);
	g_pFSP = new CFspWrapper();
	if (NULL == g_pFSP)
	{
		::lgLogError(
			LOG_SEV_2,
			TEXT("new failed")
			);
		return false;
	}

	//
	//Load the FSP and get the the exported functions
	//
		//
	//Load the EFSP and get the the exported functions
	//
	if (false == g_pFSP->Init(GetFspToLoad(),bLog))
	{
		return false;
	}
	return (g_pFSP->GetProcAddressesFromModule(bLog));
}

void UnloadFsp(const bool bLog)
{
	assert(NULL != g_pFSP);
	delete g_pFSP;
	g_pFSP = NULL;
	
	delete g_pSendingLineInfo;
	g_pSendingLineInfo = NULL;
	
	delete g_pReceivingLineInfo;
	g_pReceivingLineInfo = NULL;
	
	ShutdownTapi(g_hLineAppHandle);
	g_hLineAppHandle = NULL;
}


bool FspFaxDevInit()
{
	assert (NULL != g_pFSP);

	HANDLE					hHeap				=	HeapCreate( 0, 1024*100, 1024*1024*2 );
	PFAX_LINECALLBACK		LineCallbackFunction=	NULL;		//would be filled by the service provider in the call to FaxDevInit()
    PFAX_SERVICE_CALLBACK	FaxServiceCallback	=	FaxServiceCallbackWithAssert;		//shouldn't be called
	if (NULL == hHeap)
	{
		::lgLogError(
			LOG_SEV_2,
			TEXT("HeapCreate failed with %d"),
			::GetLastError()
			);
		return false;
	}
	
	//
	//Init the FSP
	//
	if (false == g_pFSP->FaxDevInitialize(
		g_hLineAppHandle,
		hHeap,
		&LineCallbackFunction,
		FaxServiceCallback
		))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevInitialize() failed with error:%d"),
			::GetLastError()
			);
		return false;
	}
	g_pFSP->SetCallbackFunction(LineCallbackFunction);
	return true;
}





	
bool InitTapi_LoadFsp_CallFaxDevInit()
{
	assert(NULL == g_hLineAppHandle);
	g_hLineAppHandle = InitTapiWithCompletionPort();
	if (NULL == g_hLineAppHandle)
	{
		return false;
	}
	if (false == InitFsp(false))
	{
		return false;
	}
	if (false == FspFaxDevInit())
	{
		return false;
	}
	return true;
}


bool InitProviders()
{
	return InitTapi_LoadFsp_CallFaxDevInit();
}

void ShutdownProviders()
{
	UnloadFsp();
}
	

BOOL WINAPI FaxDevSend__SendCallBack(
    IN HANDLE hFaxHandle,
    IN HCALL hCallHandle,
    IN DWORD Reserved1,
    IN DWORD Reserved2
    )
{
	//
	//Let's verify the parameters are as expected
	//
	if (hFaxHandle != g_pSendingLineInfo->GetJobHandle())
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FAX_SEND_CALLBACK should report 0x%08x as the call handle and not 0x%08x"),
			g_pSendingLineInfo->GetJobHandle(),
			hFaxHandle
			);
		return false;
	}

	if (NULL == hCallHandle)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FAX_SEND_CALLBACK reported a NULL Call handle")
			);
		return false;
	}
	if ( (0 != Reserved1) || (0 != Reserved2) )
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FAX_SEND_CALLBACK should report Reserved1 and Reserved2 with value of 0")
			);
		return false;
	}
	return true;
}


bool RunThisTest(DWORD dwCaseNumber)
{
	return baRunThisTest[dwCaseNumber];
}

bool PrepareSendingDevice()
{
	assert (NULL == g_pSendingLineInfo);
	g_pSendingLineInfo = new CFspLineInfo(g_dwSendingValidDeviceId);
	if (NULL == g_pSendingLineInfo)
	{
		::lgLogError(
			LOG_SEV_2,
			TEXT("new failed")
			);
		return false;
	}
	return (g_pSendingLineInfo->PrepareLineInfoParams(g_szValid__TiffFileName,false));
}

bool PrepareReceivingDevice()
{
	assert (NULL == g_pReceivingLineInfo);
	g_pReceivingLineInfo = new CFspLineInfo(g_dwReceiveValidDeviceId);
	if (NULL == g_pReceivingLineInfo)
	{
		::lgLogError(
			LOG_SEV_2,
			TEXT("new failed")
			);
		return false;
	}
	return (g_pReceivingLineInfo->PrepareLineInfoParams(g_szValid_ReceiveFileName,true));
}

bool LoadTapiLoadFspAndPrepareSendReceiveDevice()
{
	if (false == InitTapi_LoadFsp_CallFaxDevInit())
	{
		//
		//login in InitTapi_LoadFsp_CallFaxDevInit
		//
		return false;
	}
	
	//
	//Prepare a send and a receive line
	//
	if (false == PrepareSendingDevice())
	{
		return false;
	}
	if (false == PrepareReceivingDevice())
	{
		return false;
	}
	
	return true;
}

bool LoadTapiLoadFspAndPrepareSendDevice()
{
	if (false == InitTapi_LoadFsp_CallFaxDevInit())
	{
		//
		//login in InitTapi_LoadFsp_CallFaxDevInit
		//
		return false;
	}
	
	//
	//Prepare a send and a receive line
	//
	if (false == PrepareSendingDevice())
	{
		return false;
	}
	
	return true;
}


	


void VerifySendingStatus(PFAX_DEV_STATUS pFaxStatus,bool bShouldFail)
{
		//
	//Let's verify the returned status has valid values
	//
	if(
		(FS_INITIALIZING    == pFaxStatus->StatusId) ||
		(FS_DIALING         == pFaxStatus->StatusId) ||
		(FS_TRANSMITTING    == pFaxStatus->StatusId) ||
		(FS_RECEIVING       == pFaxStatus->StatusId) ||
		(FS_COMPLETED       == pFaxStatus->StatusId) ||
		(FS_HANDLED         == pFaxStatus->StatusId) ||
		(FS_LINE_UNAVAILABLE== pFaxStatus->StatusId) ||
		(FS_BUSY            == pFaxStatus->StatusId) ||
		(FS_NO_ANSWER       == pFaxStatus->StatusId) ||
		(FS_BAD_ADDRESS     == pFaxStatus->StatusId) ||
		(FS_NO_DIAL_TONE    == pFaxStatus->StatusId) ||
		(FS_DISCONNECTED    == pFaxStatus->StatusId) ||
		(FS_FATAL_ERROR     == pFaxStatus->StatusId) ||
		(FS_NOT_FAX_CALL    == pFaxStatus->StatusId) ||
		(FS_CALL_DELAYED    == pFaxStatus->StatusId) ||
		(FS_CALL_BLACKLISTED== pFaxStatus->StatusId) ||
		(FS_USER_ABORT      == pFaxStatus->StatusId) ||
		(FS_ANSWERED        == pFaxStatus->StatusId)
		)
	{
		//
		//OK, this is a known statusID, continue as usual
		//
		;
	}
	else
	{
		//
		//provider-defined status
		//verify FSP provided a StringId
		//
		if (0 == pFaxStatus->StringId)
		{
			::lgLogError(
				LOG_SEV_2,
				TEXT("Sending Job: FSP has reported a provider-defined status(%d) but report a StringId=0"),
				pFaxStatus->StatusId
				);
		}
		else
		{
			//
			//Try to load the provider string
			//
			TCHAR szFspStatusId[1000];
			DWORD Size = LoadString (
					g_pFSP->GetModuleHandle(),
					pFaxStatus->StringId,
					szFspStatusId,
					sizeof(szFspStatusId)/sizeof(TCHAR)
					);
                if (Size == 0)
                {
                    ::lgLogError(
						LOG_SEV_2,
						TEXT("Sending Job: Failed to load extended status string (ec: %ld) stringid : %ld"),
                        GetLastError(),
                        pFaxStatus->StringId
                        );
				}
		}
	}

	//
	//verify other reported status
	//
	if (true == g_bT30_sizeOfStructBug)
	{
		//
		//t30 has a bug (raid bug #8873), so we don't run this test for t30
		//
		;
	}
	else
	{
		if (pFaxStatus->SizeOfStruct != sizeof(PFAX_DEV_STATUS))
		{
			::lgLogError(
				LOG_SEV_2,
				TEXT("Sending Job: In the call to FaxDevReportStatus() the FSP must set FAX_DEV_STATUS::SizeOfStruct to sizeof(PFAX_DEV_STATUS)")
				);
		}
	}
	if (NULL == pFaxStatus->CSI)
	{
		::lgLogError(
			LOG_SEV_2,
			TEXT("Sending Job: In the call to FaxDevReportStatus() the FSP must supply FAX_DEV_STATUS::CSID")
			);
	}
	if (false == bShouldFail)
	{
		if (NO_ERROR != pFaxStatus->ErrorCode)
		{
			::lgLogError(
				LOG_SEV_2,
				TEXT("Sending Job: In the call to FaxDevReportStatus() the FSP must supply FAX_DEV_STATUS::ErrorCode equal to NO_ERROR")
				);
		}
	}
	else
	{
		if (NO_ERROR == pFaxStatus->ErrorCode)
		{
			::lgLogError(
				LOG_SEV_2,
				TEXT("Sending Job: In the call to FaxDevReportStatus() the FSP must supply FAX_DEV_STATUS::ErrorCode NOT equal to NO_ERROR")
				);
		}
	}

	if (0 != pFaxStatus->Reserved[0])
	{
		::lgLogError(
			LOG_SEV_2,
			TEXT("Sending Job: In the call to FaxDevReportStatus() the FSP must set the FAX_DEV_STATUS::Reserved bits to 0")
			);
	}
	if (0 != pFaxStatus->Reserved[1])
	{
		::lgLogError(
			LOG_SEV_2,
			TEXT("Sending Job: In the call to FaxDevReportStatus() the FSP must set the FAX_DEV_STATUS::Reserved bits to 0")
			);
	}
	if (0 != pFaxStatus->Reserved[2])
	{
		::lgLogError(
			LOG_SEV_2,
			TEXT("Sending Job: In the call to FaxDevReportStatus() the FSP must set the FAX_DEV_STATUS::Reserved bits to 0")
			);
	}
}

void VerifyReceivingStatus(PFAX_DEV_STATUS pFaxStatus,bool bShouldFail)
{
	//
	//Let's verify the returned status has valid values
	//
	if(
		(FS_INITIALIZING    == pFaxStatus->StatusId) ||
		(FS_DIALING         == pFaxStatus->StatusId) ||
		(FS_TRANSMITTING    == pFaxStatus->StatusId) ||
		(FS_RECEIVING       == pFaxStatus->StatusId) ||
		(FS_COMPLETED       == pFaxStatus->StatusId) ||
		(FS_HANDLED         == pFaxStatus->StatusId) ||
		(FS_LINE_UNAVAILABLE== pFaxStatus->StatusId) ||
		(FS_BUSY            == pFaxStatus->StatusId) ||
		(FS_NO_ANSWER       == pFaxStatus->StatusId) ||
		(FS_BAD_ADDRESS     == pFaxStatus->StatusId) ||
		(FS_NO_DIAL_TONE    == pFaxStatus->StatusId) ||
		(FS_DISCONNECTED    == pFaxStatus->StatusId) ||
		(FS_FATAL_ERROR     == pFaxStatus->StatusId) ||
		(FS_NOT_FAX_CALL    == pFaxStatus->StatusId) ||
		(FS_CALL_DELAYED    == pFaxStatus->StatusId) ||
		(FS_CALL_BLACKLISTED== pFaxStatus->StatusId) ||
		(FS_USER_ABORT      == pFaxStatus->StatusId) ||
		(FS_ANSWERED        == pFaxStatus->StatusId)
		)
	{
		//
		//OK, this is a known statusID, continue as usual
		//
		;
	}
	else
	{
		//
		//provider-defined status
		//verify FSP provided a StringId
		//
		if (0 == pFaxStatus->StringId)
		{
			::lgLogError(
				LOG_SEV_2,
				TEXT("Receive Job: FSP has reported a provider-defined status(%d) but report a StringId=0"),
				pFaxStatus->StatusId
				);
		}
		else
		{
			//
			//Try to load the provider string
			//
			TCHAR szFspStatusId[1000];
			DWORD Size = LoadString (
					g_pFSP->GetModuleHandle(),
					pFaxStatus->StringId,
					szFspStatusId,
					sizeof(szFspStatusId)/sizeof(TCHAR)
					);
                if (Size == 0)
                {
                    ::lgLogError(
						LOG_SEV_2,
						TEXT("Receive Job: Failed to load extended status string (ec: %ld) stringid : %ld"),
                        GetLastError(),
                        pFaxStatus->StringId
                        );
				}
		}
	}

	//
	//verify other reported status
	//
	if (true == g_bT30_sizeOfStructBug)
	{
		//
		//t30 has a bug (raid bug #8873), so we don't run this test for t30
		//
		;
	}
	else
	{
		if (pFaxStatus->SizeOfStruct != sizeof(PFAX_DEV_STATUS))
		{
			::lgLogError(
				LOG_SEV_2,
				TEXT("Receive Job: In the call to FaxDevReportStatus() the FSP must set FAX_DEV_STATUS::SizeOfStruct to sizeof(PFAX_DEV_STATUS)")
				);
		}
	}
	if (NULL == pFaxStatus->CSI)
	{
		::lgLogError(
			LOG_SEV_2,
			TEXT("Receive Job: In the call to FaxDevReportStatus() the FSP must supply FAX_DEV_STATUS::CSID")
			);
	}
	if (false == bShouldFail)
	{
		if (NO_ERROR != pFaxStatus->ErrorCode)
		{
			::lgLogError(
				LOG_SEV_2,
				TEXT("Receive Job: In the call to FaxDevReportStatus() the FSP must supply FAX_DEV_STATUS::ErrorCode equal to NO_ERROR")
				);
		}
	}
	else
	{
		if (NO_ERROR == pFaxStatus->ErrorCode)
		{
			::lgLogError(
				LOG_SEV_2,
				TEXT("Receive Job: In the call to FaxDevReportStatus() the FSP must supply FAX_DEV_STATUS::ErrorCode NOT equal to NO_ERROR")
				);
		}
	}

	if (0 != pFaxStatus->Reserved[0])
	{
		::lgLogError(
			LOG_SEV_2,
			TEXT("Receive Job: In the call to FaxDevReportStatus() the FSP must set the FAX_DEV_STATUS::Reserved bits to 0")
			);
	}
	if (0 != pFaxStatus->Reserved[1])
	{
		::lgLogError(
			LOG_SEV_2,
			TEXT("Receive Job: In the call to FaxDevReportStatus() the FSP must set the FAX_DEV_STATUS::Reserved bits to 0")
			);
	}
	if (0 != pFaxStatus->Reserved[2])
	{
		::lgLogError(
			LOG_SEV_2,
			TEXT("Receive Job: In the call to FaxDevReportStatus() the FSP must set the FAX_DEV_STATUS::Reserved bits to 0")
			);
	}
	
	//
	//Receiving stuff only
	//
	if (NULL == pFaxStatus->CallerId )
	{
		::lgLogDetail(
			LOG_X,
			5,
			TEXT("Receive Job: In the call to FaxDevReportStatus() the FSP reported FAX_DEV_STATUS::CallerId = NULL")
			);
	}
	if (NULL == pFaxStatus->RoutingInfo )
	{
		::lgLogDetail(
			LOG_X,
			5,
			TEXT("Receive Job: In the call to FaxDevReportStatus() the FSP reported FAX_DEV_STATUS::RoutingInfo = NULL")
			);
	}
	if (0 == pFaxStatus->PageCount)
	{
		::lgLogError(
			LOG_SEV_2,
			TEXT("Receive Job: In the call to FaxDevReportStatus() the FSP must supply FAX_DEV_STATUS::PageCount")
			);
	}
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\fsp\3rdpartyfsp_verifier\fsp\paramtest.cpp ===
//ParamTest.cpp
#include <assert.h>
#include <stdio.h>
#include <TCHAR.h>
#include <WINFAX.H>
#include <faxDev.h>
#include <log.h>
#include "Service.h"
#include "..\CFspWrapper.h"
#include "ParamTest.h"

extern bool g_reloadFspEachTest;

extern CFspLineInfo *g_pSendingLineInfo;
extern CFspLineInfo *g_pReceivingLineInfo;

extern CFspWrapper *g_pFSP;
extern HLINEAPP		g_hLineAppHandle;
extern HANDLE		g_hCompletionPortHandle;
extern DWORD		g_dwCaseNumber;

extern DWORD g_dwInvalidDeviceId;
extern DWORD g_dwSendingValidDeviceId;
extern DWORD g_dwReceiveValidDeviceId;
extern TCHAR* g_szInvalidRecipientFaxNumber;

extern TCHAR* g_szValid__TiffFileName;
extern TCHAR* g_szValid_ReadOnly_TiffFileName;
extern TCHAR* g_szValid_FileNotFound_TiffFileName;
extern TCHAR* g_szValid_UNC_TiffFileName;
extern TCHAR* g_szValid_NTFS_TiffFileName;
extern TCHAR* g_szValid_FAT_TiffFileName;
extern TCHAR* g_szValid_Link_TiffFileName;
extern TCHAR* g_szValid_NotTiffExtButTiffFormat_TiffFileName;
extern TCHAR* g_szValid_InvalidTiffFormat_TiffFileName;
extern TCHAR* g_szValid_ReceiveFileName;

void Case_FaxDevInit_AllParamsOK(
	HANDLE						hHeap,
	PFAX_LINECALLBACK			LineCallbackFunction,
    PFAX_SERVICE_CALLBACK		FaxServiceCallback
	);

void Case_FaxDevInit_hLineApp(
	HANDLE						hHeap,
	PFAX_LINECALLBACK			LineCallbackFunction,
    PFAX_SERVICE_CALLBACK		FaxServiceCallback
	);

void Case_FaxDevInit_hHeap(
	HANDLE						hHeap,
	PFAX_LINECALLBACK			LineCallbackFunction,
    PFAX_SERVICE_CALLBACK		FaxServiceCallback
	);

void Case_FaxDevInit_hLineCallbackFunction(
	HANDLE						hHeap,
	PFAX_LINECALLBACK			LineCallbackFunction,
    PFAX_SERVICE_CALLBACK		FaxServiceCallback
	);

void Case_FaxDevInit_hServiceCallbackFunction(
	HANDLE						hHeap,
	PFAX_LINECALLBACK			LineCallbackFunction,
    PFAX_SERVICE_CALLBACK		FaxServiceCallback
	);







///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//FaxDevInitialize cases
void Suite_FaxDevInitialize()
{
	lgBeginSuite(TEXT("FaxDevInitialize Init"));
	bool bIsTapiDevice = true;
	
	
	HANDLE						hHeap				=	HeapCreate( 0, 1024*100, 1024*1024*2 );
	PFAX_LINECALLBACK			LineCallbackFunction=	NULL;
    PFAX_SERVICE_CALLBACK		FaxServiceCallback	=	NULL;

	if (NULL == hHeap)
	{
		::lgLogError(
			LOG_SEV_2,
			TEXT("HeapCreate failed with %d"),
			::GetLastError()
			);
		goto out;
	}


	
	Case_FaxDevInit_AllParamsOK(
		hHeap,
		LineCallbackFunction,
		FaxServiceCallback
		);
		
	Case_FaxDevInit_hLineApp(
		hHeap,
		LineCallbackFunction,
		FaxServiceCallback
		);
	
	Case_FaxDevInit_hHeap(
		hHeap,
		LineCallbackFunction,
		FaxServiceCallback
		);
	
	Case_FaxDevInit_hLineCallbackFunction(
		hHeap,
		LineCallbackFunction,
		FaxServiceCallback
		);

	Case_FaxDevInit_hServiceCallbackFunction(
		hHeap,
		LineCallbackFunction,
		FaxServiceCallback
		);

out:
	::lgEndSuite();
	return;
}

void Case_FaxDevInit_AllParamsOK(
	HANDLE						hHeap,
	PFAX_LINECALLBACK			LineCallbackFunction,
    PFAX_SERVICE_CALLBACK		FaxServiceCallback
	)
{
	BEGIN_CASE(TEXT("All parameters are OK"))

	if (false == InitFsp(false))
	{
		goto out;
	}
	g_hLineAppHandle = InitTapiWithCompletionPort();
	if (NULL == g_hLineAppHandle)
	{
		goto out;
	}
	
	if (false == g_pFSP->FaxDevInitialize(
		g_hLineAppHandle,
		hHeap,
		&LineCallbackFunction,
		FaxServiceCallback
		))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevInitialize() failed with error:%d"),
			::GetLastError()
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("FaxDevInitialize()")
			);
	}
out:
	UnloadFsp();
	::lgEndCase();
}
////////////////////////////////////////////////////////////////////////////////
//hLineApp


void Case_FaxDevInit__NULL_hLineApp(
	HANDLE						hHeap,
	PFAX_LINECALLBACK			LineCallbackFunction,
    PFAX_SERVICE_CALLBACK		FaxServiceCallback
	)
{
	BEGIN_CASE(TEXT("NULL hLineApp"))

	if (false == InitFsp(false))
	{
		goto out;
	}
	//
	//No need for a Tapi HLineAppHandle here
	//
	if (true == g_pFSP->FaxDevInitialize(
		NULL,
		hHeap,
		&LineCallbackFunction,
		FaxServiceCallback
		))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevInitialize() should fail")
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("FaxDevInitialize() failed as expected with error: %d"),
			::GetLastError()
			);
	}
out:
	UnloadFsp();
	::lgEndCase();
}

void Case_FaxDevInit_hLineApp(
	HANDLE						hHeap,
	PFAX_LINECALLBACK			LineCallbackFunction,
    PFAX_SERVICE_CALLBACK		FaxServiceCallback
	)
{
	lgLogDetail(
		LOG_X,
		2,
		TEXT("\n\n\n*************************************************************************\n***************************** hLineApp param ********************************")
		);

	Case_FaxDevInit__NULL_hLineApp(
		hHeap,
		LineCallbackFunction,
		FaxServiceCallback
		);
}

////////////////////////////////////////////////////////////////////////////////
//hHeap
void Case_FaxDevInit__NULL_hHeap(
	HANDLE						hHeap,
	PFAX_LINECALLBACK			LineCallbackFunction,
    PFAX_SERVICE_CALLBACK		FaxServiceCallback
	)
{
	BEGIN_CASE(TEXT("NULL hHeap"))

	if (false == InitFsp(false))
	{
		goto out;
	}
	g_hLineAppHandle = InitTapiWithCompletionPort();
	if (NULL == g_hLineAppHandle)
	{
		goto out;
	}
	
	if (true == g_pFSP->FaxDevInitialize(
		g_hLineAppHandle,
		NULL,
		&LineCallbackFunction,
		FaxServiceCallback
		))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevInitialize() succeeded")
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("FaxDevInitialize() failed as expected with error: %d"),
			::GetLastError()
			);
	}
out:
	UnloadFsp();
	::lgEndCase();
}

void Case_FaxDevInit_hHeap(
	HANDLE						hHeap,
	PFAX_LINECALLBACK			LineCallbackFunction,
    PFAX_SERVICE_CALLBACK		FaxServiceCallback
	)
{
	lgLogDetail(
		LOG_X,
		2,
		TEXT("\n\n\n*************************************************************************\n***************************** hHeap param ********************************")
		);

	Case_FaxDevInit__NULL_hHeap(
		hHeap,
		LineCallbackFunction,
		FaxServiceCallback
		);
}

////////////////////////////////////////////////////////////////////////////////
//hLineCallbackFunction
void Case_FaxDevInit__NULL_hLineCallbackFunction(
	HANDLE						hHeap,
	PFAX_LINECALLBACK			LineCallbackFunction,
    PFAX_SERVICE_CALLBACK		FaxServiceCallback
	)
{
	BEGIN_CASE(TEXT("NULL hLineCallbackFunction"))

	if (false == InitFsp(false))
	{
		goto out;
	}
	g_hLineAppHandle = InitTapiWithCompletionPort();
	if (NULL == g_hLineAppHandle)
	{
		goto out;
	}
	
	if (true == g_pFSP->FaxDevInitialize(
		g_hLineAppHandle,
		hHeap,
		NULL,
		FaxServiceCallback
		))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevInitialize() should fail")
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("FaxDevInitialize() failed as expected with error: %d"),
			::GetLastError()
			);
	}
out:
	UnloadFsp();
	::lgEndCase();
}

void Case_FaxDevInit_hLineCallbackFunction(
	HANDLE						hHeap,
	PFAX_LINECALLBACK			LineCallbackFunction,
    PFAX_SERVICE_CALLBACK	FaxServiceCallback
	)
{
	lgLogDetail(
		LOG_X,
		2,
		TEXT("\n\n\n*************************************************************************\n***************************** hLineCallbackFunction param ********************************")
		);

	Case_FaxDevInit__NULL_hLineCallbackFunction(
		hHeap,
		LineCallbackFunction,
		FaxServiceCallback
		);
}
////////////////////////////////////////////////////////////////////////////////
//hServiceCallbackFunction
void Case_FaxDevInit__NULL_hServiceCallbackFunction(
	HANDLE						hHeap,
	PFAX_LINECALLBACK			LineCallbackFunction,
    PFAX_SERVICE_CALLBACK		FaxServiceCallback
	)
{
	BEGIN_CASE(TEXT("NULL hServiceCallbackFunction"))

	if (false == InitFsp(false))
	{
		goto out;
	}
	g_hLineAppHandle = InitTapiWithCompletionPort();
	if (NULL == g_hLineAppHandle)
	{
		goto out;
	}

	if (false == g_pFSP->FaxDevInitialize(
		g_hLineAppHandle,
		hHeap,
		&LineCallbackFunction,
		NULL
		))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("hServiceCallbackFunction is ignored and FaxDevInitialize() failed with error:%d"),
			::GetLastError()
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("FaxDevInitialize() succeeded as expected")
			);
	}
out:
	UnloadFsp();
	::lgEndCase();
}

void Case_FaxDevInit_hServiceCallbackFunction(
	HANDLE						hHeap,
	PFAX_LINECALLBACK			LineCallbackFunction,
    PFAX_SERVICE_CALLBACK		FaxServiceCallback
	)
{
	lgLogDetail(
		LOG_X,
		2,
		TEXT("\n\n\n*************************************************************************\n***************************** hServiceCallbackFunction param ********************************")
		);

	Case_FaxDevInit__NULL_hServiceCallbackFunction(
		hHeap,
		LineCallbackFunction,
		FaxServiceCallback
		);
}



///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//FaxDevStartJob cases

void Case_FaxDevStartJob_AllParamsOK(
	ULONG ulCompletionKey
	);
	
void Case_FaxDevStartJob_hLineHandle(
	ULONG ulCompletionKey
	);

void Case_FaxDevStartJob_dwDeviceId(
	ULONG ulCompletionKey
	);

void Case_FaxDevStartJob_hFaxHandle(
	ULONG ulCompletionKey
	);

void Case_FaxDevStartJob_CompletionPort(
	ULONG ulCompletionKey
	);


void Suite_FaxDevStartJob()
{
	lgBeginSuite(TEXT("FaxDevStartJob Init"));
	
	//
	//FaxDevStartJob params
	//
	ULONG ulCompletionKey			=	0;


	//
	//Proceed to the test cases
	//
	Case_FaxDevStartJob_AllParamsOK(ulCompletionKey);
	Case_FaxDevStartJob_hLineHandle(ulCompletionKey);
	Case_FaxDevStartJob_dwDeviceId(ulCompletionKey);
	Case_FaxDevStartJob_hFaxHandle(ulCompletionKey);
	Case_FaxDevStartJob_CompletionPort(ulCompletionKey);

	::lgEndSuite();
	return;
}




void Case_FaxDevStartJob_AllParamsOK(ULONG ulCompletionKey)
{
	BEGIN_CASE(TEXT("All parameters are valid"))

	if (true == g_reloadFspEachTest)
	{
		//
		//We need a Sending device only
		//
		if (false == LoadTapiLoadFspAndPrepareSendDevice())
		{
			goto out;
		}
	}

	HANDLE hJob;
	if (false == g_pFSP->FaxDevStartJob(
	    g_pSendingLineInfo->GetLineHandle(),
		g_pSendingLineInfo->GetDeviceId(),
		&hJob,
		g_hCompletionPortHandle,
		ulCompletionKey
		))

	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevStartJob() failed with error:%d"),
			::GetLastError()
			);
	}
	else
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("FaxDevStartJob() succeeded")
			);
		g_pFSP->FaxDevEndJob(hJob);
	}
out:
	if (true == g_reloadFspEachTest)
	{
		UnloadFsp();
	}
	::lgEndCase();
}

////////////////////////////////////////////////////////////////////////////////
//hLineHandle
void Case_FaxDevStartJob__NULL_hLineHandle(
	ULONG ulCompletionKey
	)
{
	BEGIN_CASE(TEXT("NULL hLineHandle"))
	if (true == g_reloadFspEachTest)
	{
		//
		//We need a Sending device only
		//
		if (false == LoadTapiLoadFspAndPrepareSendDevice())
		{
			goto out;
		}
	}
	
	HANDLE hJob;
	if (false == g_pFSP->FaxDevStartJob(
	    NULL,
		g_pSendingLineInfo->GetDeviceId(),
		&hJob,
		g_hCompletionPortHandle,
		ulCompletionKey
		))
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("FaxDevStartJob() failed as expected with error:%d"),
			::GetLastError()
			);
	}
	else
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevStartJob() should fail")
			);
		g_pFSP->FaxDevEndJob(hJob);
	}
out:
	if (true == g_reloadFspEachTest)
	{
		UnloadFsp();
	}
	::lgEndCase();
}

void Case_FaxDevStartJob_hLineHandle(ULONG ulCompletionKey)
{
	lgLogDetail(
		LOG_X,
		2,
		TEXT("\n\n\n*************************************************************************\n***************************** hLineHandle param ********************************")
		);

	Case_FaxDevStartJob__NULL_hLineHandle(ulCompletionKey);
}

////////////////////////////////////////////////////////////////////////////////
//dwDeviceId
void Case_FaxDevStartJob__Invalid_dwDeviceId(ULONG ulCompletionKey)
{
	BEGIN_CASE(TEXT("Invalid dwDeviceId"))

	if (true == g_reloadFspEachTest)
	{
		//
		//We need a Sending device only
		//
		if (false == LoadTapiLoadFspAndPrepareSendDevice())
		{
			goto out;
		}
	}
	
	HANDLE hJob;
	if (false == g_pFSP->FaxDevStartJob(
	    g_pSendingLineInfo->GetLineHandle(),
		g_pSendingLineInfo->GetDeviceId(),
		&hJob,
		g_hCompletionPortHandle,
		ulCompletionKey
		))
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("FaxDevStartJob() failed as expected with error:%d"),
			::GetLastError()
			);
	}
	else
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevStartJob() should fail")
			);
		g_pFSP->FaxDevEndJob(hJob);
	}
out:
	if (true == g_reloadFspEachTest)
	{
		UnloadFsp();
	}
	::lgEndCase();
}

void Case_FaxDevStartJob_dwDeviceId(ULONG ulCompletionKey)
{
	lgLogDetail(
		LOG_X,
		2,
		TEXT("\n\n\n*************************************************************************\n***************************** dwDeviceId param ********************************")
		);

	Case_FaxDevStartJob__Invalid_dwDeviceId(ulCompletionKey);
}


////////////////////////////////////////////////////////////////////////////////
//hFaxHandle
void Case_FaxDevStartJob__NULL_hFaxHandle(ULONG ulCompletionKey)
{
	BEGIN_CASE(TEXT("NULL hFaxHandle"))
	if (true == g_reloadFspEachTest)
	{
		//
		//We need a Sending device only
		//
		if (false == LoadTapiLoadFspAndPrepareSendDevice())
		{
			goto out;
		}
	}
	
	if (false == g_pFSP->FaxDevStartJob(
	    g_pSendingLineInfo->GetLineHandle(),
		g_pSendingLineInfo->GetDeviceId(),
		NULL,
		g_hCompletionPortHandle,
		ulCompletionKey
		))
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("FaxDevStartJob() failed as expected with error:%d"),
			::GetLastError()
			);
	}
	else
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevStartJob() should fail")
			);
		//
		//End the NULL hJob
		//
		if (false == g_pFSP->FaxDevEndJob(NULL))
		{
			::lgLogDetail(
				LOG_X,
				5,
				TEXT("FaxDevEndJob(NULL) failed with %d"),
				::GetLastError()
				);
		}
	}
out:
	if (true == g_reloadFspEachTest)
	{
		UnloadFsp();
	}
	::lgEndCase();
}

void Case_FaxDevStartJob_hFaxHandle(ULONG ulCompletionKey)
{
	lgLogDetail(
		LOG_X,
		2,
		TEXT("\n\n\n*************************************************************************\n***************************** hFaxHandle param ********************************")
		);

	Case_FaxDevStartJob__NULL_hFaxHandle(ulCompletionKey);
}




////////////////////////////////////////////////////////////////////////////////
//CompletionPort
void Case_FaxDevStartJob__NULL_CompletionPort(ULONG ulCompletionKey)
{
	BEGIN_CASE(TEXT("completionPort is a NULL pointer"))

	if (true == g_reloadFspEachTest)
	{
		//
		//We need a Sending device only
		//
		if (false == LoadTapiLoadFspAndPrepareSendDevice())
		{
			goto out;
		}
	}
	HANDLE hJob;
	if (false == g_pFSP->FaxDevStartJob(
	    g_pSendingLineInfo->GetLineHandle(),
		g_pSendingLineInfo->GetDeviceId(),
		&hJob,
		NULL,
		ulCompletionKey
		))
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("FaxDevStartJob() failed as expected with error:%d"),
			::GetLastError()
			);
	}
	else
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevStartJob() should fail")
			);
		g_pFSP->FaxDevEndJob(hJob);
	}
out:
	if (true == g_reloadFspEachTest)
	{
		UnloadFsp();
	}
	::lgEndCase();
}

void Case_FaxDevStartJob_CompletionPort(ULONG ulCompletionKey)
{
	lgLogDetail(
		LOG_X,
		2,
		TEXT("\n\n\n*************************************************************************\n***************************** CompletionPort param ********************************")
		);

	Case_FaxDevStartJob__NULL_CompletionPort(ulCompletionKey);
}


void Case_FaxDevSend_AllParamsOK();
void Case_FaxDevSend_FaxHandle();
void Case_FaxDevSend_FaxSend();
void Case_FaxDevSend_FaxSendCallback();





void Suite_FaxDevSend()
{
	lgBeginSuite(TEXT("FaxDevSend Init"));
	
	
	//FaxDevSend__SendCallBack;
	
	//
	//Proceed with cases
	//
	Case_FaxDevSend_AllParamsOK();
	Case_FaxDevSend_FaxHandle();
	Case_FaxDevSend_FaxSend();
	Case_FaxDevSend_FaxSendCallback();

	::lgEndSuite();
	return;
}


void FaxDevSendWrapper(
	CFspLineInfo *pSendingLineInfo,
	IN	PFAX_SEND_CALLBACK pFaxSendCallback,
	bool bShouldFail
	)
{
	DWORD dwStatus = -1;
	//
	//Start the send job
	//
	HANDLE hJob;
	if (false == g_pFSP->FaxDevStartJob(
	    pSendingLineInfo->GetLineHandle(),
		pSendingLineInfo->GetDeviceId(),
		&hJob,
		g_hCompletionPortHandle,
		(ULONG_PTR) pSendingLineInfo	// The completion key provided to the FSP is the LineInfo
        ))								// pointer. When the FSP reports status it uses this key thus allowing
                                        // us to know to which line the status belongs.
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevStartJob() failed with error:%d"),
			::GetLastError()
			);
		goto out;
	}
	pSendingLineInfo->SafeSetJobHandle(hJob);

	//
	//do the actual sending
	//
	if (false == g_pFSP->FaxDevSend(
		pSendingLineInfo->GetJobHandle(),
		pSendingLineInfo->m_pFaxSend,
		pFaxSendCallback
		))
	{
		//
		//send operation has failed, should it?
		//
		if (true == bShouldFail)
		{
			::lgLogDetail(
				LOG_PASS,
				2,
				TEXT("FaxDevSend() failed with as expected with error:%d"),
				::GetLastError()
				);
		}
		else
		{
			::lgLogError(
				LOG_SEV_1,
				TEXT("FaxDevSend() failed with error:%d"),
				::GetLastError()
				);
			goto out;
		}
	}
	else
	{
		//
		//Send operation succeed.should it?
		//
		if (true == bShouldFail)
		{
			::lgLogError(
				LOG_SEV_1,
				TEXT("FaxDevSend() succeeded when it should fail")
				);
			goto out;
		}
		else
		{
			::lgLogDetail(
				LOG_PASS,
				2,
				TEXT("FaxDevSend() succeeded")
				);
		}
		
		//
		//Wait for the receive to finish as well
		//
		if (true == g_pReceivingLineInfo->IsReceiveThreadActive())
		{
			if (false == g_pReceivingLineInfo->WaitForReceiveThreadTerminate())
			{
				goto out;
			}
			g_pReceivingLineInfo->SafeCloseReceiveThread();
			
			//
			//Verify the status of the jobs
			//
			PFAX_DEV_STATUS pSendingDevStatus;
			PFAX_DEV_STATUS pReceivingDevStatus;
			pSendingLineInfo->GetDevStatus(
				&pSendingDevStatus
				,true				//log the report
				);
			g_pReceivingLineInfo->GetDevStatus(
				&pReceivingDevStatus
				,true				//log the report
				);

			//
			//Let's verify that reportStatus reported correct values
			//
			VerifySendingStatus(pSendingDevStatus,false);

			//
			//Both jobs should be in COMPLETED state
			//
			if (FS_COMPLETED != pSendingDevStatus->StatusId)
			{
				::lgLogError(
					LOG_SEV_1,
					TEXT("Sending job: GetDevStatus() reported 0x%08x status instead of FS_COMPLETED as expected"),
					pSendingDevStatus->StatusId
					);
				goto out;
			}
			if (FS_COMPLETED != pReceivingDevStatus->StatusId)
			{
				::lgLogError(
					LOG_SEV_1,
					TEXT("Receiving job: GetDevStatus() reported 0x%08x status instead of FS_COMPLETED as expected"),
					pReceivingDevStatus->StatusId
					);
				goto out;
			}
		}
	}
out:
	g_pSendingLineInfo->SafeEndFaxJob();
	g_pReceivingLineInfo->SafeEndFaxJob();
	if (true == g_pReceivingLineInfo->IsReceiveThreadActive())
	{
		//
		//Let's try to give a chance to the receive thread to end normally
		//
		g_pReceivingLineInfo->WaitForReceiveThreadTerminate();
		g_pReceivingLineInfo->SafeCloseReceiveThread();
	}
}





void Case_FaxDevSend_AllParamsOK()
{
	BEGIN_CASE(TEXT("All parameters are valid"))
	
	if (true == g_reloadFspEachTest)
	{
		//
		//We need a Sending device only
		//
		if (false == LoadTapiLoadFspAndPrepareSendReceiveDevice())
		{
			goto out;
		}
	}

	FaxDevSendWrapper(g_pSendingLineInfo,FaxDevSend__SendCallBack,false);		//operation should succeed

out:
	if (true == g_reloadFspEachTest)
	{
		UnloadFsp();
	}
	::lgEndCase();
}

////////////////////////////////////////////////////////////////////////////////
//hFaxHandle
void Case_FaxDevSend__NULL_FaxHandle()
{
	BEGIN_CASE(TEXT("NULL hFaxHandle"))

	if (true == g_reloadFspEachTest)
	{
		//
		//We need a Sending device only
		//
		if (false == LoadTapiLoadFspAndPrepareSendReceiveDevice())
		{
			goto out;
		}
	}
	
	if (false == g_pFSP->FaxDevSend(
		NULL,
		g_pSendingLineInfo->m_pFaxSend,
		FaxDevSend__SendCallBack
		))
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("FaxDevSend() failed as expected with error:%d"),
			::GetLastError()
			);
	}
	else
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevSend() should fail")
			);
		//
		//wait for receive
		//
		if (false == g_pReceivingLineInfo->WaitForReceiveThreadTerminate())
		{
			goto out;
		}
		g_pSendingLineInfo->SafeEndFaxJob();
		g_pReceivingLineInfo->SafeEndFaxJob();
	}

out:
	if (true == g_reloadFspEachTest)
	{
		UnloadFsp();
	}

	::lgEndCase();
}

void Case_FaxDevSend__Invalid_FaxHandle()
{
	BEGIN_CASE(TEXT("Invalid hFaxHandle"))

	HANDLE hFaxHandle = NULL;
	
	if (true == g_reloadFspEachTest)
	{
		//
		//We need a Sending device only
		//
		if (false == LoadTapiLoadFspAndPrepareSendReceiveDevice())
		{
			goto out;
		}
	}
	
	//
	//We want an invalid handle, let's try a random number 1008
	//
	hFaxHandle = (HANDLE) 1008;
	
	if (false == g_pFSP->FaxDevSend(
	    hFaxHandle,
		g_pSendingLineInfo->m_pFaxSend,
		FaxDevSend__SendCallBack
		))
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("FaxDevSend() failed as expected with error:%d"),
			::GetLastError()
			);
	}
	else
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevSend() should fail")
			);
			//
			//wait for receive
			//
			if (false == g_pReceivingLineInfo->WaitForReceiveThreadTerminate())
			{
				goto out;
			}
			g_pSendingLineInfo->SafeEndFaxJob();
			g_pReceivingLineInfo->SafeEndFaxJob();
	
	}
out:
	if (true == g_reloadFspEachTest)
	{
		UnloadFsp();
	}
	::lgEndCase();
}

void Case_FaxDevSend_FaxHandle()
{
	lgLogDetail(
		LOG_X,
		2,
		TEXT("\n\n\n*************************************************************************\n***************************** hFaxHandle param ********************************")
		);

	Case_FaxDevSend__NULL_FaxHandle();
	Case_FaxDevSend__Invalid_FaxHandle();
}

////////////////////////////////////////////////////////////////////////////////
//FaxSend structure
void Case_FaxDevSend__Zero_SizeOfStruct_FaxSend()
{
	BEGIN_CASE(TEXT("Zero SizeOfStruct"))
	
	DWORD dwOriginalSizeOfStruct;
	
	if (true == g_reloadFspEachTest)
	{
		//
		//We need a Sending device only
		//
		if (false == LoadTapiLoadFspAndPrepareSendReceiveDevice())
		{
			goto out;
		}
	}
	dwOriginalSizeOfStruct = g_pSendingLineInfo->m_pFaxSend->SizeOfStruct;
	g_pSendingLineInfo->m_pFaxSend->SizeOfStruct = 0;
	FaxDevSendWrapper(g_pSendingLineInfo,FaxDevSend__SendCallBack,false);		//operation should succeed
	g_pSendingLineInfo->m_pFaxSend->SizeOfStruct = dwOriginalSizeOfStruct;
out:
	if (true == g_reloadFspEachTest)
	{
		UnloadFsp();
	}
	::lgEndCase();
}

void Case_FaxDevSend__Incorrect_SizeOfStruct_FaxSend()
{
	BEGIN_CASE(TEXT("Incorrect SizeOfStruct"))
	DWORD dwOriginalSizeOfStruct;
	if (true == g_reloadFspEachTest)
	{
		//
		//We need a Sending device only
		//
		if (false == LoadTapiLoadFspAndPrepareSendReceiveDevice())
		{
			goto out;
		}
	}
	dwOriginalSizeOfStruct = g_pSendingLineInfo->m_pFaxSend->SizeOfStruct;
	g_pSendingLineInfo->m_pFaxSend->SizeOfStruct =  g_pSendingLineInfo->m_pFaxSend->SizeOfStruct - 3; //change the correct value to an incorrect value
	FaxDevSendWrapper(g_pSendingLineInfo,FaxDevSend__SendCallBack,false);		//operation should succeed
	g_pSendingLineInfo->m_pFaxSend->SizeOfStruct = dwOriginalSizeOfStruct;

out:
	if (true == g_reloadFspEachTest)
	{
		UnloadFsp();
	}
	::lgEndCase();
}

void Case_FaxDevSend__SizeOfStruct_FaxSend()
{
	Case_FaxDevSend__Zero_SizeOfStruct_FaxSend();
	Case_FaxDevSend__Incorrect_SizeOfStruct_FaxSend();
}

//FileName
void Case_FaxDevSend__NULL_FileName_FaxSend()
{
	BEGIN_CASE(TEXT("Filename is a NULL pointer"))

	TCHAR *szOrgFileName = NULL;
	if (true == g_reloadFspEachTest)
	{
		//
		//We need a Sending device only
		//
		if (false == LoadTapiLoadFspAndPrepareSendReceiveDevice())
		{
			goto out;
		}
	}
	
	szOrgFileName = g_pSendingLineInfo->m_pFaxSend->FileName;
	g_pSendingLineInfo->m_pFaxSend->FileName =  NULL;
	FaxDevSendWrapper(g_pSendingLineInfo,FaxDevSend__SendCallBack,true);		//operation should fail
	g_pSendingLineInfo->m_pFaxSend->FileName = szOrgFileName;
out:
	if (true == g_reloadFspEachTest)
	{
		UnloadFsp();
	}
	::lgEndCase();
}



void Case_FaxDevSend__Empty_FileName_FaxSend()
{
	BEGIN_CASE(TEXT("Filename is an empty string"))
	TCHAR *szOrgFileName = NULL;
	if (true == g_reloadFspEachTest)
	{
		//
		//We need a Sending device only
		//
		if (false == LoadTapiLoadFspAndPrepareSendReceiveDevice())
		{
			goto out;
		}
	}
	szOrgFileName = g_pSendingLineInfo->m_pFaxSend->FileName;
	g_pSendingLineInfo->m_pFaxSend->FileName =  TEXT("");
	FaxDevSendWrapper(g_pSendingLineInfo,FaxDevSend__SendCallBack,true);		//operation should fail
	g_pSendingLineInfo->m_pFaxSend->FileName = szOrgFileName;
out:
	if (true == g_reloadFspEachTest)
	{
		UnloadFsp();
	}
	::lgEndCase();
}

void Case_FaxDevSend__Readonly_FileName_FaxSend()
{
	BEGIN_CASE(TEXT("Filename point to a file which is a readonly file"))
	TCHAR *szOrgFileName = NULL;
	if (true == g_reloadFspEachTest)
	{
		//
		//We need a Sending device only
		//
		if (false == LoadTapiLoadFspAndPrepareSendReceiveDevice())
		{
			goto out;
		}
	}
	szOrgFileName = g_pSendingLineInfo->m_pFaxSend->FileName;
	g_pSendingLineInfo->m_pFaxSend->FileName =  g_szValid_ReadOnly_TiffFileName;
	FaxDevSendWrapper(g_pSendingLineInfo,FaxDevSend__SendCallBack,false);		//operation should succeed
	g_pSendingLineInfo->m_pFaxSend->FileName = szOrgFileName;

out:
	if (true == g_reloadFspEachTest)
	{
		UnloadFsp();
	}
	::lgEndCase();
}

void Case_FaxDevSend__FileNotFound_FileName_FaxSend()
{
	BEGIN_CASE(TEXT("Filename point to a file which isn't found"))
	TCHAR *szOrgFileName = NULL;
	if (true == g_reloadFspEachTest)
	{
		//
		//We need a Sending device only
		//
		if (false == LoadTapiLoadFspAndPrepareSendReceiveDevice())
		{
			goto out;
		}
	}
	szOrgFileName = g_pSendingLineInfo->m_pFaxSend->FileName;
	g_pSendingLineInfo->m_pFaxSend->FileName =  g_szValid_FileNotFound_TiffFileName;
	FaxDevSendWrapper(g_pSendingLineInfo,FaxDevSend__SendCallBack,true);		//operation should fail
	g_pSendingLineInfo->m_pFaxSend->FileName = szOrgFileName;

out:
	if (true == g_reloadFspEachTest)
	{
		UnloadFsp();
	}
	::lgEndCase();
}

void Case_FaxDevSend__UNC_FileName_FaxSend()
{
	BEGIN_CASE(TEXT("Filename point to a file which has a UNC path"))
	TCHAR *szOrgFileName = NULL;
	if (true == g_reloadFspEachTest)
	{
		//
		//We need a Sending device only
		//
		if (false == LoadTapiLoadFspAndPrepareSendReceiveDevice())
		{
			goto out;
		}
	}
	szOrgFileName = g_pSendingLineInfo->m_pFaxSend->FileName;
	g_pSendingLineInfo->m_pFaxSend->FileName =  g_szValid_UNC_TiffFileName;
	FaxDevSendWrapper(g_pSendingLineInfo,FaxDevSend__SendCallBack,false);		//operation should succeed
	g_pSendingLineInfo->m_pFaxSend->FileName = szOrgFileName;
out:
	if (true == g_reloadFspEachTest)
	{
		UnloadFsp();
	}
	::lgEndCase();
}
void Case_FaxDevSend__NTFS_FileName_FaxSend()
{
	BEGIN_CASE(TEXT("Filename point to a file which has a NTFS path"))
	TCHAR *szOrgFileName = NULL;
	if (true == g_reloadFspEachTest)
	{
		//
		//We need a Sending device only
		//
		if (false == LoadTapiLoadFspAndPrepareSendReceiveDevice())
		{
			goto out;
		}
	}
	szOrgFileName = g_pSendingLineInfo->m_pFaxSend->FileName;
	g_pSendingLineInfo->m_pFaxSend->FileName =  g_szValid_NTFS_TiffFileName;
	FaxDevSendWrapper(g_pSendingLineInfo,FaxDevSend__SendCallBack,false);		//operation should succeed
	g_pSendingLineInfo->m_pFaxSend->FileName = szOrgFileName;
out:
	if (true == g_reloadFspEachTest)
	{
		UnloadFsp();
	}
	::lgEndCase();
}

void Case_FaxDevSend__FAT_FileName_FaxSend()
{
	BEGIN_CASE(TEXT("Filename point to a file which has a FAT path"))
	TCHAR *szOrgFileName = NULL;
	if (true == g_reloadFspEachTest)
	{
		//
		//We need a Sending device only
		//
		if (false == LoadTapiLoadFspAndPrepareSendReceiveDevice())
		{
			goto out;
		}
	}
	szOrgFileName = g_pSendingLineInfo->m_pFaxSend->FileName;
	g_pSendingLineInfo->m_pFaxSend->FileName =  g_szValid_FAT_TiffFileName;
	FaxDevSendWrapper(g_pSendingLineInfo,FaxDevSend__SendCallBack,false);		//operation should succeed
	g_pSendingLineInfo->m_pFaxSend->FileName = szOrgFileName;
out:
	if (true == g_reloadFspEachTest)
	{
		UnloadFsp();
	}
	::lgEndCase();
}
void Case_FaxDevSend__LINK_FileName_FaxSend()
{
	BEGIN_CASE(TEXT("Filename point to a file which is a link to a tiff file"))
	TCHAR *szOrgFileName = NULL;
	if (true == g_reloadFspEachTest)
	{
		//
		//We need a Sending device only
		//
		if (false == LoadTapiLoadFspAndPrepareSendReceiveDevice())
		{
			goto out;
		}
	}
	szOrgFileName = g_pSendingLineInfo->m_pFaxSend->FileName;
	g_pSendingLineInfo->m_pFaxSend->FileName =  g_szValid_Link_TiffFileName;
	FaxDevSendWrapper(g_pSendingLineInfo,FaxDevSend__SendCallBack,false);		//operation should succeed
	g_pSendingLineInfo->m_pFaxSend->FileName = szOrgFileName;

out:
	if (true == g_reloadFspEachTest)
	{
		UnloadFsp();
	}
	::lgEndCase();
}
void Case_FaxDevSend__NotTiffExtButTiffFormat_FileName_FaxSend()
{
	BEGIN_CASE(TEXT("Filename point to a file which doesn't have a tif extension but has a valid tiff format"))
	TCHAR *szOrgFileName = NULL;
	if (true == g_reloadFspEachTest)
	{
		//
		//We need a Sending device only
		//
		if (false == LoadTapiLoadFspAndPrepareSendReceiveDevice())
		{
			goto out;
		}
	}
	szOrgFileName = g_pSendingLineInfo->m_pFaxSend->FileName;
	g_pSendingLineInfo->m_pFaxSend->FileName =  g_szValid_NotTiffExtButTiffFormat_TiffFileName;
	FaxDevSendWrapper(g_pSendingLineInfo,FaxDevSend__SendCallBack,false);		//operation should succeeded
	g_pSendingLineInfo->m_pFaxSend->FileName = szOrgFileName;

out:
	if (true == g_reloadFspEachTest)
	{
		UnloadFsp();
	}
	::lgEndCase();
}
void Case_FaxDevSend__InvalidTiffFormat_FileName_FaxSend()
{
	BEGIN_CASE(TEXT("Filename point to a file which doesn't have a valid tif format"))
	TCHAR *szOrgFileName = NULL;
	if (true == g_reloadFspEachTest)
	{
		//
		//We need a Sending device only
		//
		if (false == LoadTapiLoadFspAndPrepareSendReceiveDevice())
		{
			goto out;
		}
	}
	szOrgFileName = g_pSendingLineInfo->m_pFaxSend->FileName;
	g_pSendingLineInfo->m_pFaxSend->FileName =  g_szValid_InvalidTiffFormat_TiffFileName;
	FaxDevSendWrapper(g_pSendingLineInfo,FaxDevSend__SendCallBack,true);		//operation should fail
	g_pSendingLineInfo->m_pFaxSend->FileName = szOrgFileName;

out:
	if (true == g_reloadFspEachTest)
	{
		UnloadFsp();
	}
	::lgEndCase();
}
void Case_FaxDevSend__FileName_FaxSend()
{
	//
	//Invalid cases
	//
	Case_FaxDevSend__NULL_FileName_FaxSend();				//BUG8437
	Case_FaxDevSend__Empty_FileName_FaxSend();				//BUG8437
	Case_FaxDevSend__FileNotFound_FileName_FaxSend();		//BUG8437
	Case_FaxDevSend__NotTiffExtButTiffFormat_FileName_FaxSend();			//BUG8437
	Case_FaxDevSend__InvalidTiffFormat_FileName_FaxSend();	//BUG8437
	Case_FaxDevSend__LINK_FileName_FaxSend();

	//
	//Valid cases
	//
	Case_FaxDevSend__Readonly_FileName_FaxSend();
	Case_FaxDevSend__UNC_FileName_FaxSend();
	Case_FaxDevSend__NTFS_FileName_FaxSend();
	Case_FaxDevSend__FAT_FileName_FaxSend();
}

//Caller
void Case_FaxDevSend__NULL_CallerName_FaxSend()
{
	BEGIN_CASE(TEXT("Caller name is a NULL pointer"))
	TCHAR *szOrgCallerName = NULL;
	if (true == g_reloadFspEachTest)
	{
		//
		//We need a Sending device only
		//
		if (false == LoadTapiLoadFspAndPrepareSendReceiveDevice())
		{
			goto out;
		}
	}
	szOrgCallerName = g_pSendingLineInfo->m_pFaxSend->CallerName;
	g_pSendingLineInfo->m_pFaxSend->CallerName =  NULL;
	FaxDevSendWrapper(g_pSendingLineInfo,FaxDevSend__SendCallBack,false);		//operation should succeed
	g_pSendingLineInfo->m_pFaxSend->CallerName = szOrgCallerName;
out:
	if (true == g_reloadFspEachTest)
	{
		UnloadFsp();
	}
	::lgEndCase();
}

void Case_FaxDevSend__Empty_CallerName_FaxSend()
{
	BEGIN_CASE(TEXT("Caller name is an empty string"))
	TCHAR *szOrgCallerName = NULL;
	if (true == g_reloadFspEachTest)
	{
		//
		//We need a Sending device only
		//
		if (false == LoadTapiLoadFspAndPrepareSendReceiveDevice())
		{
			goto out;
		}
	}
	szOrgCallerName = g_pSendingLineInfo->m_pFaxSend->CallerName;
	g_pSendingLineInfo->m_pFaxSend->CallerName =  TEXT("");
	FaxDevSendWrapper(g_pSendingLineInfo,FaxDevSend__SendCallBack,false);		//operation should succeed
	g_pSendingLineInfo->m_pFaxSend->CallerName = szOrgCallerName;
	
out:
	if (true == g_reloadFspEachTest)
	{
		UnloadFsp();
	}
	::lgEndCase();
}
void Case_FaxDevSend__VeryLong_CallerName_FaxSend()
{
	BEGIN_CASE(TEXT("Caller name is a very long string"))
	TCHAR *szOrgCallerName = NULL;
	if (true == g_reloadFspEachTest)
	{
		//
		//We need a Sending device only
		//
		if (false == LoadTapiLoadFspAndPrepareSendReceiveDevice())
		{
			goto out;
		}
	}
	szOrgCallerName = g_pSendingLineInfo->m_pFaxSend->CallerName;
	g_pSendingLineInfo->m_pFaxSend->CallerName =  SENDER_INFO__VERYLONG_NAME;
	FaxDevSendWrapper(g_pSendingLineInfo,FaxDevSend__SendCallBack,false);		//operation should succeed
	g_pSendingLineInfo->m_pFaxSend->CallerName = szOrgCallerName;

out:
	if (true == g_reloadFspEachTest)
	{
		UnloadFsp();
	}
	::lgEndCase();
}
void Case_FaxDevSend__NULL_CallerNumber_FaxSend()
{
	BEGIN_CASE(TEXT("Caller number is a NULL pointer"))
	TCHAR *szOrgCallerNumber = NULL;
	if (true == g_reloadFspEachTest)
	{
		//
		//We need a Sending device only
		//
		if (false == LoadTapiLoadFspAndPrepareSendReceiveDevice())
		{
			goto out;
		}
	}
	szOrgCallerNumber = g_pSendingLineInfo->m_pFaxSend->CallerNumber;
	g_pSendingLineInfo->m_pFaxSend->CallerNumber =  NULL;
	FaxDevSendWrapper(g_pSendingLineInfo,FaxDevSend__SendCallBack,false);		//operation should succeed
	g_pSendingLineInfo->m_pFaxSend->CallerNumber = szOrgCallerNumber;
	
out:
	if (true == g_reloadFspEachTest)
	{
		UnloadFsp();
	}
	::lgEndCase();
}
void Case_FaxDevSend__Empty_CallerNumber_FaxSend()
{
	BEGIN_CASE(TEXT("Caller number is an empty string"))
	TCHAR *szOrgCallerNumber = NULL;
	if (true == g_reloadFspEachTest)
	{
		//
		//We need a Sending device only
		//
		if (false == LoadTapiLoadFspAndPrepareSendReceiveDevice())
		{
			goto out;
		}
	}
	szOrgCallerNumber = g_pSendingLineInfo->m_pFaxSend->CallerNumber;
	g_pSendingLineInfo->m_pFaxSend->CallerNumber =  TEXT("");
	FaxDevSendWrapper(g_pSendingLineInfo,FaxDevSend__SendCallBack,false);		//operation should succeed
	g_pSendingLineInfo->m_pFaxSend->CallerNumber = szOrgCallerNumber;

out:
	if (true == g_reloadFspEachTest)
	{
		UnloadFsp();
	}
	::lgEndCase();
}
void Case_FaxDevSend__VeryLong_CallerNumber_FaxSend()
{
	BEGIN_CASE(TEXT("Caller number is a very long string"))
	TCHAR *szOrgCallerNumber = NULL;
	if (true == g_reloadFspEachTest)
	{
		//
		//We need a Sending device only
		//
		if (false == LoadTapiLoadFspAndPrepareSendReceiveDevice())
		{
			goto out;
		}
	}
	szOrgCallerNumber = g_pSendingLineInfo->m_pFaxSend->CallerNumber;
	g_pSendingLineInfo->m_pFaxSend->CallerNumber =  SENDER_INFO__VERYLONG_FAX_NUMBER;
	FaxDevSendWrapper(g_pSendingLineInfo,FaxDevSend__SendCallBack,false);		//operation should succeed
	g_pSendingLineInfo->m_pFaxSend->CallerNumber = szOrgCallerNumber;
	
out:
	if (true == g_reloadFspEachTest)
	{
		UnloadFsp();
	}
	::lgEndCase();
}
void Case_FaxDevSend__Caller_FaxSend()
{
	Case_FaxDevSend__NULL_CallerName_FaxSend();
	Case_FaxDevSend__Empty_CallerName_FaxSend();
	Case_FaxDevSend__VeryLong_CallerName_FaxSend();
	Case_FaxDevSend__NULL_CallerNumber_FaxSend();
	Case_FaxDevSend__Empty_CallerNumber_FaxSend();
	Case_FaxDevSend__VeryLong_CallerNumber_FaxSend();
}

//Receiver
void Case_FaxDevSend__NULL_ReceiverName_FaxSend()
{
	BEGIN_CASE(TEXT("Receiver name is a NULL pointer"))
	TCHAR *szOrgReceiverName = NULL;
	if (true == g_reloadFspEachTest)
	{
		//
		//We need a Sending device only
		//
		if (false == LoadTapiLoadFspAndPrepareSendReceiveDevice())
		{
			goto out;
		}
	}
	szOrgReceiverName = g_pSendingLineInfo->m_pFaxSend->ReceiverName;
	g_pSendingLineInfo->m_pFaxSend->ReceiverName =  NULL;
	FaxDevSendWrapper(g_pSendingLineInfo,FaxDevSend__SendCallBack,false);		//operation should succeed
	g_pSendingLineInfo->m_pFaxSend->ReceiverName = szOrgReceiverName;
	
out:
	if (true == g_reloadFspEachTest)
	{
		UnloadFsp();
	}
	::lgEndCase();
}
void Case_FaxDevSend__Empty_ReceiverName_FaxSend()
{
	BEGIN_CASE(TEXT("Receiver name is an empty string"))
	TCHAR *szOrgReceiverName = NULL;
	if (true == g_reloadFspEachTest)
	{
		//
		//We need a Sending device only
		//
		if (false == LoadTapiLoadFspAndPrepareSendReceiveDevice())
		{
			goto out;
		}
	}
	szOrgReceiverName = g_pSendingLineInfo->m_pFaxSend->ReceiverName;
	g_pSendingLineInfo->m_pFaxSend->ReceiverName =  TEXT("");
	FaxDevSendWrapper(g_pSendingLineInfo,FaxDevSend__SendCallBack,false);		//operation should succeed
	g_pSendingLineInfo->m_pFaxSend->ReceiverName = szOrgReceiverName;

	
out:
	if (true == g_reloadFspEachTest)
	{
		UnloadFsp();
	}
	::lgEndCase();
}
void Case_FaxDevSend__VeryLong_ReceiverName_FaxSend()
{
	BEGIN_CASE(TEXT("Receiver name is a very long string"))
	TCHAR *szOrgReceiverName = NULL;
	if (true == g_reloadFspEachTest)
	{
		//
		//We need a Sending device only
		//
		if (false == LoadTapiLoadFspAndPrepareSendReceiveDevice())
		{
			goto out;
		}
	}
	szOrgReceiverName = g_pSendingLineInfo->m_pFaxSend->ReceiverName;
	g_pSendingLineInfo->m_pFaxSend->ReceiverName =  RECIPIENT_INFO__VERYLONG_NAME;
	FaxDevSendWrapper(g_pSendingLineInfo,FaxDevSend__SendCallBack,false);		//operation should succeed
	g_pSendingLineInfo->m_pFaxSend->ReceiverName = szOrgReceiverName;
	
out:
	if (true == g_reloadFspEachTest)
	{
		UnloadFsp();
	}
	::lgEndCase();
}
void Case_FaxDevSend__NULL_ReceiverNumber_FaxSend()
{
	BEGIN_CASE(TEXT("Receiver number is a NULL pointer"))
	TCHAR *szOrgReceiverNumber = NULL;
	if (true == g_reloadFspEachTest)
	{
		//
		//We need a Sending device only
		//
		if (false == LoadTapiLoadFspAndPrepareSendReceiveDevice())
		{
			goto out;
		}
	}
	szOrgReceiverNumber = g_pSendingLineInfo->m_pFaxSend->ReceiverNumber;
	g_pSendingLineInfo->m_pFaxSend->ReceiverNumber =  NULL;
	FaxDevSendWrapper(g_pSendingLineInfo,FaxDevSend__SendCallBack,true);		//operation should fail
	g_pSendingLineInfo->m_pFaxSend->ReceiverNumber = szOrgReceiverNumber;
	
out:
	if (true == g_reloadFspEachTest)
	{
		UnloadFsp();
	}
	::lgEndCase();
}
void Case_FaxDevSend__Empty_ReceiverNumber_FaxSend()
{
	BEGIN_CASE(TEXT("Receiver number is an empty string"))
	TCHAR *szOrgReceiverNumber = NULL;
	if (true == g_reloadFspEachTest)
	{
		//
		//We need a Sending device only
		//
		if (false == LoadTapiLoadFspAndPrepareSendReceiveDevice())
		{
			goto out;
		}
	}
	szOrgReceiverNumber = g_pSendingLineInfo->m_pFaxSend->ReceiverNumber;
	g_pSendingLineInfo->m_pFaxSend->ReceiverNumber =  TEXT("");
	FaxDevSendWrapper(g_pSendingLineInfo,FaxDevSend__SendCallBack,true);		//operation should fail
	g_pSendingLineInfo->m_pFaxSend->ReceiverNumber = szOrgReceiverNumber;
	
out:
	if (true == g_reloadFspEachTest)
	{
		UnloadFsp();
	}
	::lgEndCase();
}
void Case_FaxDevSend__Invalid_ReceiverNumber_FaxSend()
{
	BEGIN_CASE(TEXT("Receiver number is an invalid number"))
	TCHAR *szOrgReceiverNumber = NULL;
	if (true == g_reloadFspEachTest)
	{
		//
		//We need a Sending device only
		//
		if (false == LoadTapiLoadFspAndPrepareSendReceiveDevice())
		{
			goto out;
		}
	}
	szOrgReceiverNumber = g_pSendingLineInfo->m_pFaxSend->ReceiverNumber;
	g_pSendingLineInfo->m_pFaxSend->ReceiverNumber =  g_szInvalidRecipientFaxNumber;
	FaxDevSendWrapper(g_pSendingLineInfo,FaxDevSend__SendCallBack,true);		//operation should fail
	g_pSendingLineInfo->m_pFaxSend->ReceiverNumber = szOrgReceiverNumber;
	
out:
	if (true == g_reloadFspEachTest)
	{
		UnloadFsp();
	}
	::lgEndCase();
}

void Case_FaxDevSend__Receiver_FaxSend()
{
	//
	//Receiver name cases
	//
	Case_FaxDevSend__NULL_ReceiverName_FaxSend();
	Case_FaxDevSend__Empty_ReceiverName_FaxSend();
	Case_FaxDevSend__VeryLong_ReceiverName_FaxSend();

	//
	//Receiver number cases
	//
	Case_FaxDevSend__Invalid_ReceiverNumber_FaxSend();
	Case_FaxDevSend__NULL_ReceiverNumber_FaxSend();			//Invalid cases
	Case_FaxDevSend__Empty_ReceiverNumber_FaxSend();		//Invalid cases
	
}

void Case_FaxDevSend__Branding_FaxSend()
{
	lgLogDetail(
		LOG_X,
		2,
		TEXT("Branding param cases NIY")
		);
}

void Case_FaxDevSend__CallHandle_FaxSend()
{
	::lgLogDetail(
		LOG_X,
		2,
		TEXT("\n\n\n*************************************************************************\n***************************** FaxSend structure********************************")
		);
	::lgLogDetail(
		LOG_X,
		2,
		TEXT("hCallHandle param cases NIY")
		);
}

void Case_FaxDevSend_FaxSend()
{
	lgLogDetail(
		LOG_X,
		2,
		TEXT("\n\n\n*************************************************************************\n***************************** FaxSend structure********************************")
		);

	Case_FaxDevSend__SizeOfStruct_FaxSend();
	Case_FaxDevSend__FileName_FaxSend();
	Case_FaxDevSend__Caller_FaxSend();
	Case_FaxDevSend__Receiver_FaxSend();
	Case_FaxDevSend__Branding_FaxSend();
	Case_FaxDevSend__CallHandle_FaxSend();
}

void Case_FaxDevSend_FaxSendCallback()
{
	lgLogDetail(
		LOG_X,
		2,
		TEXT("\n\n\n*************************************************************************\n***************************** FaxSendCallback param ********************************")
		);
	::lgLogDetail(
		LOG_X,
		2,
		TEXT("FaxSendCallback param cases NIY")
		);
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//FaxDevReceive cases
void Case_FaxDevReceive_AllParamsOK();
void Case_FaxDevReceive_FaxHandle();
void Case_FaxDevReceive_CallHandle();
void Case_FaxDevReceive_FaxReceive();

void Suite_FaxDevReceive()
{
	lgBeginSuite(TEXT("FaxDevReceive"));
	
	//
	//Proceed with cases
	//
	Case_FaxDevReceive_AllParamsOK();
	Case_FaxDevReceive_FaxHandle();
	Case_FaxDevReceive_CallHandle();
	Case_FaxDevReceive_FaxReceive();
	
	::lgEndSuite();
	return;
}



void Case_FaxDevReceive_AllParamsOK()
{
	::lgLogDetail(
		LOG_X,
		2,
		TEXT("\n\n\n*************************************************************************\n***************************** AllParamsOK ********************************")
		);
	lgLogDetail(
		LOG_X,
		2,
		TEXT("NIY")
		);
}

void Case_FaxDevReceive_FaxHandle()
{
	::lgLogDetail(
		LOG_X,
		2,
		TEXT("\n\n\n*************************************************************************\n***************************** hFaxHandle parameter********************************")
		);
	lgLogDetail(
		LOG_X,
		2,
		TEXT("NIY")
		);
}

//call handle
void Case_FaxDevReceive__NULL_CallHandle()
{
	BEGIN_CASE(TEXT("hCallHandle parameter is a NULL pointer"))
	
	if (true == g_reloadFspEachTest)
	{
		//
		//We need a Sending device only
		//
		if (false == LoadTapiLoadFspAndPrepareSendReceiveDevice())
		{
			goto out;
		}
	}
	
	//
	//Start the receive job
	//
	HANDLE hJob;
	if (false == g_pFSP->FaxDevStartJob(
	    g_pReceivingLineInfo->GetLineHandle(),
		g_pReceivingLineInfo->GetDeviceId(),
		&hJob,
		g_hCompletionPortHandle,
		(ULONG_PTR) g_pReceivingLineInfo	// The completion key provided to the FSP is the LineInfo
        ))								// pointer. When the FSP reports status it uses this key thus allowing
                                        // us to know to which line the status belongs.
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevStartJob() failed with error:%d"),
			::GetLastError()
			);
		goto out;
	}
	g_pReceivingLineInfo->SafeSetJobHandle(hJob);
	
	if (false == g_pFSP->FaxDevReceive(
		g_pReceivingLineInfo->GetJobHandle(),
		NULL,
		g_pReceivingLineInfo->m_pFaxReceive
		))
	{
		::lgLogDetail(
			LOG_PASS,
			2,
			TEXT("FaxDevReceive() failed with:%d, as expected"),
			::GetLastError()
			);
	}
	else
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FaxDevReceive() succeeded and it should fail")
			);
	}
out:
	if (true == g_reloadFspEachTest)
	{
		UnloadFsp();
	}
	::lgEndCase();
}

void Case_FaxDevReceive_CallHandle()
{
	::lgLogDetail(
		LOG_X,
		2,
		TEXT("\n\n\n*************************************************************************\n***************************** hCallHandle parameter********************************")
		);
	Case_FaxDevReceive__NULL_CallHandle();
}


void Case_FaxDevReceive_FaxReceive()
{
	::lgLogDetail(
		LOG_X,
		2,
		TEXT("\n\n\n*************************************************************************\n***************************** FaxReceive parameter********************************")
		);
	lgLogDetail(
		LOG_X,
		2,
		TEXT("NIY")
		);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\fsp\3rdpartyfsp_verifier\fsp\main.cpp ===
//main.cpp
#include <assert.h>
#include <TCHAR.h>
#include <WINFAX.H>
#include <faxDev.h>
#include <log.h>

#include "..\CFspWrapper.h"
#include "ParamTest.h"
#include "Service.h"

DWORD		g_dwCaseNumber			=	0;				//will be used for counting the case number

CFspLineInfo	*g_pSendingLineInfo	=	NULL;
CFspLineInfo	*g_pReceivingLineInfo=	NULL;

extern DWORD g_dwSendingValidDeviceId;
extern DWORD g_dwReceiveValidDeviceId;
extern TCHAR* g_szValid__TiffFileName;
extern TCHAR* g_szValid_ReceiveFileName;

extern TCHAR * g_szFspIniFileName;
extern bool g_reloadFspEachTest;

bool	g_bIgnoreErrorCodeBug;					//RAID: T30 bug, raid # 8038(EdgeBugs)
bool	g_bT30_OneLineDiffBUG;					//RAID: T30 bug, raid # 8040(EdgeBugs)
bool	g_bT30_sizeOfStructBug;					//RAID: T30 bug, raid # 8873(EdgeBugs)


bool Suite_FspLoading();
void Suite_TiffSending();
void Suite_Abort();



void Usage()
{
	
	
	//
	//outbound call
	//
	::lgLogDetail(
		LOG_X,
		1,
		TEXT("Usage:\n%s%s%s%s"),
		TEXT("\tFspTester.exe DumpID            : list of all the devices and their IDs\n"),
		TEXT("\tFspTester.exe <Filename.INI>    : INI file to run the test on"),
		TEXT("\t\nExample:\nFspTester.exe .\\T30.Ini    : Run the FSP tester on T30.INI which is on the current directory"),
		TEXT("\t\nExample:\nFspTester.exe c:\\Test\\T30.Ini    : Run the FSP tester on T30.INI which is on the current c:\\Test directory")
		);
}


//
//Logging levels:
//1 
//2	Whole test case PASS
//3 Test case step PASS
//4
//5	Ini settings / Don't care if FAIL/PASS messages
//6	Tapi Messages
//7 Enter / Leave FSP APIs
//8
//9
void main(int argc, char ** argvA)
{
	::lgInitializeLogger();
	if (2 != argc)
	{
		Usage();
		goto out;

	}
	
	TCHAR **argv;
#ifdef UNICODE
	argv = ::CommandLineToArgvW( GetCommandLine(), &argc );
#else
	argv = argvA;
#endif

	//
	//Init the logger for the test cases
	//
	g_dwCaseNumber=0;
	
	
	//
	//Because of a VC6 bug, we need to declare all globals as pointers and malloc/free them
	//
	if (false == AllocGlobalVariables())
	{
		goto out;
	}
	if (0 == ::lstrcmpi(argv[1],TEXT("DumpID")))
	{
		DumpDeviceId();
		goto out;
	}
	else
	{
		//
		//User param is an INI file
		//
		g_szFspIniFileName = argv[1];
	}

	if (false == InitThreadsAndCompletionPorts())
	{
		goto out;
	}
	if (false == LoadLibraries())		//helper function in other DLLs.
	{
		goto out;
	}
	if (false == GetIniSettings())		//fetch the user INI setting.
	{
		goto out;
	}


	//
	//Check if test is ran on T30
	//
	if (NULL != ::_tcsstr(GetFspToLoad(),TEXT("FXST30.dll")))
	{
		//
		//This is T30 FSP
		//
		::lgLogDetail(
			LOG_X,
			5,
			TEXT("Running T30 Specific tests")
			);
		g_bIgnoreErrorCodeBug = true;				
		g_bT30_OneLineDiffBUG = true;				
		g_bT30_sizeOfStructBug= true;				
	}
	else
	{
		//
		//Not a T30 FSP, run test as usual
		//
		g_bIgnoreErrorCodeBug = false;
		g_bT30_OneLineDiffBUG = false;
		g_bT30_sizeOfStructBug= false;
	}
	
	//
	// next 2 suites do not need g_reloadFspEachTest
	//

	//
	//FSP loading + function exporting tests
	//
	if (false == Suite_FspLoading())
	{
		//
		//if init tests fail, there's no point to continue with the rest of the test cases/suites
		//
		::lgLogError(
			LOG_SEV_1,
			TEXT("Init test cases failed, no point to continue with rest of test cases")
			);
		goto out;
	}
	
	//
	//Suite_FaxDevInitialize loads the FSP and calls FaxDevInit() by itself
	//
	Suite_FaxDevInitialize();
	
	
	//
	//Prepare the devices for the rest of the test cases
	//
	if (false == g_reloadFspEachTest)
	{
		
		//
		//Init Tapi, load the FSP and call FaxDevInit() for all the rest of the test cases
		//
		if (false == InitTapi_LoadFsp_CallFaxDevInit())
		{
			//
			//login in FspFaxDevInit
			//
			goto out;
		}
		
		//
		//prepare a Sending device and a receiving device
		//
		assert (NULL == g_pSendingLineInfo);
		g_pSendingLineInfo = new CFspLineInfo(g_dwSendingValidDeviceId);
		if (NULL == g_pSendingLineInfo)
		{
			::lgLogError(
				LOG_SEV_2,
				TEXT("new failed")
				);
			goto out;
		}
		if (false == g_pSendingLineInfo->PrepareLineInfoParams(g_szValid__TiffFileName,false))
		{
			goto out;
		}
		assert (NULL == g_pReceivingLineInfo);
		g_pReceivingLineInfo = new CFspLineInfo(g_dwReceiveValidDeviceId);
		if (NULL == g_pReceivingLineInfo)
		{
			::lgLogError(
				LOG_SEV_2,
				TEXT("new failed")
				);
			goto out;
		}
		if (false == g_pReceivingLineInfo->PrepareLineInfoParams(g_szValid_ReceiveFileName,true))
		{
			goto out;
		}
	}

	//
	//Parameter testing
	//
	Suite_FaxDevStartJob();
	Suite_FaxDevSend();
	Suite_FaxDevReceive();
	
	//
	//Scenario testing
	//
	Suite_TiffSending();
	Suite_Abort();


out:
	if (false == g_reloadFspEachTest)
	{
		UnloadFsp();
	}
	UnloadLibraries();
	FreeGlobalVariables();
	ShutDownTapiAndTapiThread();

#ifdef UNICODE
	//
	//we need to free the buffer from CommandLineToArgvW()
	//
	::GlobalFree(argv);
#endif
	
	::lgLogDetail(
		LOG_X,
		1,
		TEXT("Test Finished")
		);
	lgCloseLogger();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\fsp\3rdpartyfsp_verifier\fsp\tapidbg.h ===
#ifndef TAPIDBG_H
#define TAPIDBG_H

#ifdef __cplusplus
extern "C"
{
#endif

void ShowLineEvent(
    HLINE       htLine,
    HCALL       htCall,
    LPTSTR      MsgStr,
    DWORD_PTR   dwCallbackInstance,
    DWORD       dwMsg,
    DWORD_PTR   dwParam1,
    DWORD_PTR   dwParam2,
    DWORD_PTR   dwParam3
    );


#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\fsp\3rdpartyfsp_verifier\fsp\tapidbg.cpp ===
#include <assert.h>
#include <TCHAR.h>
#include <WINFAX.H>
#include <faxDev.h>
#include <log.h>

#include "TapiDbg.h"


typedef struct _LOOKUP {
    DWORD   dwVal;
    LPTSTR   lpszVal;
} LOOKUP, *PLOOKUP;

typedef struct _MSGTYPE {
    DWORD   MsgId;
    BOOL    LineMsg;
    LPTSTR  Text;
} MSGTYPE, *PMSGTYPE;


MSGTYPE  aMsgs[] =
{
    { LINE_ADDRESSSTATE,             TRUE,     TEXT("LINE_ADDRESSSTATE")         },
    { LINE_AGENTSPECIFIC,            TRUE,     TEXT("LINE_AGENTSPECIFIC")        },
    { LINE_AGENTSTATUS,              TRUE,     TEXT("LINE_AGENTSTATUS")          },
    { LINE_APPNEWCALL,               TRUE,     TEXT("LINE_APPNEWCALL")           },
    { LINE_CALLINFO,                 TRUE,     TEXT("LINE_CALLINFO")             },
    { LINE_CALLSTATE,                TRUE,     TEXT("LINE_CALLSTATE")            },
    { LINE_CLOSE,                    TRUE,     TEXT("LINE_CLOSE")                },
    { LINE_CREATE,                   TRUE,     TEXT("LINE_CREATE")               },
    { LINE_CREATE,                   TRUE,     TEXT("LINE_CREATE")               },
    { LINE_DEVSPECIFIC,              TRUE,     TEXT("LINE_DEVSPECIFIC")          },
    { LINE_DEVSPECIFICFEATURE,       TRUE,     TEXT("LINE_DEVSPECIFICFEATURE")   },
    { LINE_GATHERDIGITS,             TRUE,     TEXT("LINE_GATHERDIGITS")         },
    { LINE_GENERATE,                 TRUE,     TEXT("LINE_GENERATE")             },
    { LINE_LINEDEVSTATE,             TRUE,     TEXT("LINE_LINEDEVSTATE")         },
    { LINE_MONITORDIGITS,            TRUE,     TEXT("LINE_MONITORDIGITS")        },
    { LINE_MONITORMEDIA,             TRUE,     TEXT("LINE_MONITORMEDIA")         },
    { LINE_MONITORTONE,              TRUE,     TEXT("LINE_MONITORTONE")          },
    { LINE_PROXYREQUEST,             TRUE,     TEXT("LINE_PROXYREQUEST")         },
    { LINE_REMOVE,                   TRUE,     TEXT("LINE_REMOVE")               },
    { LINE_REPLY,                    TRUE,     TEXT("LINE_REPLY")                },
    { LINE_REQUEST,                  TRUE,     TEXT("LINE_REQUEST")              },
    { PHONE_BUTTON,                  FALSE,    TEXT("PHONE_BUTTON")              },
    { PHONE_CLOSE,                   FALSE,    TEXT("PHONE_CLOSE")               },
    { PHONE_CREATE,                  FALSE,    TEXT("PHONE_CREATE")              },
    { PHONE_DEVSPECIFIC,             FALSE,    TEXT("PHONE_DEVSPECIFIC")         },
    { PHONE_REMOVE,                  FALSE,    TEXT("PHONE_REMOVE")              },
    { PHONE_REPLY,                   FALSE,    TEXT("PHONE_REPLY")               },
    { PHONE_STATE,                   FALSE,    TEXT("PHONE_STATE")               },
    { 0xffffffff,                    FALSE,    NULL                              }
};

LOOKUP  aAddressStates[] =
{
    { LINEADDRESSSTATE_OTHER           ,TEXT("OTHER")              },
    { LINEADDRESSSTATE_DEVSPECIFIC     ,TEXT("DEVSPECIFIC")        },
    { LINEADDRESSSTATE_INUSEZERO       ,TEXT("INUSEZERO")          },
    { LINEADDRESSSTATE_INUSEONE        ,TEXT("INUSEONE")           },
    { LINEADDRESSSTATE_INUSEMANY       ,TEXT("INUSEMANY")          },
    { LINEADDRESSSTATE_NUMCALLS        ,TEXT("NUMCALLS")           },
    { LINEADDRESSSTATE_FORWARD         ,TEXT("FORWARD")            },
    { LINEADDRESSSTATE_TERMINALS       ,TEXT("TERMINALS")          },
    { LINEADDRESSSTATE_CAPSCHANGE      ,TEXT("CAPSCHANGE")         },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aBearerModes[] =
{
    { LINEBEARERMODE_VOICE             ,TEXT("VOICE")              },
    { LINEBEARERMODE_SPEECH            ,TEXT("SPEECH")             },
    { LINEBEARERMODE_MULTIUSE          ,TEXT("MULTIUSE")           },
    { LINEBEARERMODE_DATA              ,TEXT("DATA")               },
    { LINEBEARERMODE_ALTSPEECHDATA     ,TEXT("ALTSPEECHDATA")      },
    { LINEBEARERMODE_NONCALLSIGNALING  ,TEXT("NONCALLSIGNALING")   },
    { LINEBEARERMODE_PASSTHROUGH       ,TEXT("PASSTHROUGH")        },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aButtonModes[] =
{
    { PHONEBUTTONMODE_DUMMY            ,TEXT("DUMMY")              },
    { PHONEBUTTONMODE_CALL             ,TEXT("CALL")               },
    { PHONEBUTTONMODE_FEATURE          ,TEXT("FEATURE")            },
    { PHONEBUTTONMODE_KEYPAD           ,TEXT("KEYPAD")             },
    { PHONEBUTTONMODE_LOCAL            ,TEXT("LOCAL")              },
    { PHONEBUTTONMODE_DISPLAY          ,TEXT("DISPLAY")            },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aButtonStates[] =
{
    { PHONEBUTTONSTATE_UP              ,TEXT("UP")                 },
    { PHONEBUTTONSTATE_DOWN            ,TEXT("DOWN")               },
    { PHONEBUTTONSTATE_UNKNOWN         ,TEXT("UNKNOWN")            },
    { PHONEBUTTONSTATE_UNAVAIL         ,TEXT("UNAVAIL")            },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aCallInfoStates[] =
{
    { LINECALLINFOSTATE_OTHER          ,TEXT("OTHER")              },
    { LINECALLINFOSTATE_DEVSPECIFIC    ,TEXT("DEVSPECIFIC")        },
    { LINECALLINFOSTATE_BEARERMODE     ,TEXT("BEARERMODE")         },
    { LINECALLINFOSTATE_RATE           ,TEXT("RATE")               },
    { LINECALLINFOSTATE_MEDIAMODE      ,TEXT("MEDIAMODE")          },
    { LINECALLINFOSTATE_APPSPECIFIC    ,TEXT("APPSPECIFIC")        },
    { LINECALLINFOSTATE_CALLID         ,TEXT("CALLID")             },
    { LINECALLINFOSTATE_RELATEDCALLID  ,TEXT("RELATEDCALLID")      },
    { LINECALLINFOSTATE_ORIGIN         ,TEXT("ORIGIN")             },
    { LINECALLINFOSTATE_REASON         ,TEXT("REASON")             },
    { LINECALLINFOSTATE_COMPLETIONID   ,TEXT("COMPLETIONID")       },
    { LINECALLINFOSTATE_NUMOWNERINCR   ,TEXT("NUMOWNERINCR")       },
    { LINECALLINFOSTATE_NUMOWNERDECR   ,TEXT("NUMOWNERDECR")       },
    { LINECALLINFOSTATE_NUMMONITORS    ,TEXT("NUMMONITORS")        },
    { LINECALLINFOSTATE_TRUNK          ,TEXT("TRUNK")              },
    { LINECALLINFOSTATE_CALLERID       ,TEXT("CALLERID")           },
    { LINECALLINFOSTATE_CALLEDID       ,TEXT("CALLEDID")           },
    { LINECALLINFOSTATE_CONNECTEDID    ,TEXT("CONNECTEDID")        },
    { LINECALLINFOSTATE_REDIRECTIONID  ,TEXT("REDIRECTIONID")      },
    { LINECALLINFOSTATE_REDIRECTINGID  ,TEXT("REDIRECTINGID")      },
    { LINECALLINFOSTATE_DISPLAY        ,TEXT("DISPLAY")            },
    { LINECALLINFOSTATE_USERUSERINFO   ,TEXT("USERUSERINFO")       },
    { LINECALLINFOSTATE_HIGHLEVELCOMP  ,TEXT("HIGHLEVELCOMP")      },
    { LINECALLINFOSTATE_LOWLEVELCOMP   ,TEXT("LOWLEVELCOMP")       },
    { LINECALLINFOSTATE_CHARGINGINFO   ,TEXT("CHARGINGINFO")       },
    { LINECALLINFOSTATE_TERMINAL       ,TEXT("TERMINAL")           },
    { LINECALLINFOSTATE_DIALPARAMS     ,TEXT("DIALPARAMS")         },
    { LINECALLINFOSTATE_MONITORMODES   ,TEXT("MONITORMODES")       },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aCallSelects[] =
{
    { LINECALLSELECT_LINE              ,TEXT("LINE")               },
    { LINECALLSELECT_ADDRESS           ,TEXT("ADDRESS")            },
    { LINECALLSELECT_CALL              ,TEXT("CALL")               },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aCallStates[] =
{
    { LINECALLSTATE_IDLE               ,TEXT("IDLE")               },
    { LINECALLSTATE_OFFERING           ,TEXT("OFFERING")           },
    { LINECALLSTATE_ACCEPTED           ,TEXT("ACCEPTED")           },
    { LINECALLSTATE_DIALTONE           ,TEXT("DIALTONE")           },
    { LINECALLSTATE_DIALING            ,TEXT("DIALING")            },
    { LINECALLSTATE_RINGBACK           ,TEXT("RINGBACK")           },
    { LINECALLSTATE_BUSY               ,TEXT("BUSY")               },
    { LINECALLSTATE_SPECIALINFO        ,TEXT("SPECIALINFO")        },
    { LINECALLSTATE_CONNECTED          ,TEXT("CONNECTED")          },
    { LINECALLSTATE_PROCEEDING         ,TEXT("PROCEEDING")         },
    { LINECALLSTATE_ONHOLD             ,TEXT("ONHOLD")             },
    { LINECALLSTATE_CONFERENCED        ,TEXT("CONFERENCED")        },
    { LINECALLSTATE_ONHOLDPENDCONF     ,TEXT("ONHOLDPENDCONF")     },
    { LINECALLSTATE_ONHOLDPENDTRANSFER ,TEXT("ONHOLDPENDTRANSFER") },
    { LINECALLSTATE_DISCONNECTED       ,TEXT("DISCONNECTED")       },
    { LINECALLSTATE_UNKNOWN            ,TEXT("UNKNOWN")            },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aDigitModes[] =
{
    { LINEDIGITMODE_PULSE              ,TEXT("PULSE")              },
    { LINEDIGITMODE_DTMF               ,TEXT("DTMF")               },
    { LINEDIGITMODE_DTMFEND            ,TEXT("DTMFEND")            },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aHookSwitchDevs[] =
{
    { PHONEHOOKSWITCHDEV_HANDSET       ,TEXT("HANDSET")            },
    { PHONEHOOKSWITCHDEV_SPEAKER       ,TEXT("SPEAKER")            },
    { PHONEHOOKSWITCHDEV_HEADSET       ,TEXT("HEADSET")            },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aHookSwitchModes[] =
{
    { PHONEHOOKSWITCHMODE_ONHOOK       ,TEXT("ONHOOK")             },
    { PHONEHOOKSWITCHMODE_MIC          ,TEXT("MIC")                },
    { PHONEHOOKSWITCHMODE_SPEAKER      ,TEXT("SPEAKER")            },
    { PHONEHOOKSWITCHMODE_MICSPEAKER   ,TEXT("MICSPEAKER")         },
    { PHONEHOOKSWITCHMODE_UNKNOWN      ,TEXT("UNKNOWN")            },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aLampModes[] =
{
    { PHONELAMPMODE_DUMMY              ,TEXT("DUMMY")              },
    { PHONELAMPMODE_OFF                ,TEXT("OFF")                },
    { PHONELAMPMODE_STEADY             ,TEXT("STEADY")             },
    { PHONELAMPMODE_WINK               ,TEXT("WINK")               },
    { PHONELAMPMODE_FLASH              ,TEXT("FLASH")              },
    { PHONELAMPMODE_FLUTTER            ,TEXT("FLUTTER")            },
    { PHONELAMPMODE_BROKENFLUTTER      ,TEXT("BROKENFLUTTER")      },
    { PHONELAMPMODE_UNKNOWN            ,TEXT("UNKNOWN")            },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aLineStates[] =
{
    { LINEDEVSTATE_OTHER               ,TEXT("OTHER")              },
    { LINEDEVSTATE_RINGING             ,TEXT("RINGING")            },
    { LINEDEVSTATE_CONNECTED           ,TEXT("CONNECTED")          },
    { LINEDEVSTATE_DISCONNECTED        ,TEXT("DISCONNECTED")       },
    { LINEDEVSTATE_MSGWAITON           ,TEXT("MSGWAITON")          },
    { LINEDEVSTATE_MSGWAITOFF          ,TEXT("MSGWAITOFF")         },
    { LINEDEVSTATE_INSERVICE           ,TEXT("INSERVICE")          },
    { LINEDEVSTATE_OUTOFSERVICE        ,TEXT("OUTOFSERVICE")       },
    { LINEDEVSTATE_MAINTENANCE         ,TEXT("MAINTENANCE")        },
    { LINEDEVSTATE_OPEN                ,TEXT("OPEN")               },
    { LINEDEVSTATE_CLOSE               ,TEXT("CLOSE")              },
    { LINEDEVSTATE_NUMCALLS            ,TEXT("NUMCALLS")           },
    { LINEDEVSTATE_NUMCOMPLETIONS      ,TEXT("NUMCOMPLETIONS")     },
    { LINEDEVSTATE_TERMINALS           ,TEXT("TERMINALS")          },
    { LINEDEVSTATE_ROAMMODE            ,TEXT("ROAMMODE")           },
    { LINEDEVSTATE_BATTERY             ,TEXT("BATTERY")            },
    { LINEDEVSTATE_SIGNAL              ,TEXT("SIGNAL")             },
    { LINEDEVSTATE_DEVSPECIFIC         ,TEXT("DEVSPECIFIC")        },
    { LINEDEVSTATE_REINIT              ,TEXT("REINIT")             },
    { LINEDEVSTATE_LOCK                ,TEXT("LOCK")               },
    { LINEDEVSTATE_CAPSCHANGE          ,TEXT("CAPSCHANGE")         },
    { LINEDEVSTATE_CONFIGCHANGE        ,TEXT("CONFIGCHANGE")       },
    { LINEDEVSTATE_TRANSLATECHANGE     ,TEXT("TRANSLATECHANGE")    },
    { LINEDEVSTATE_COMPLCANCEL         ,TEXT("COMPLCANCEL")        },
    { LINEDEVSTATE_REMOVED             ,TEXT("REMOVED")            },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aMediaModes[] =
{
    { LINEMEDIAMODE_UNKNOWN            ,TEXT("UNKNOWN")            },
    { LINEMEDIAMODE_INTERACTIVEVOICE   ,TEXT("INTERACTIVEVOICE")   },
    { LINEMEDIAMODE_AUTOMATEDVOICE     ,TEXT("AUTOMATEDVOICE")     },
    { LINEMEDIAMODE_DATAMODEM          ,TEXT("DATAMODEM")          },
    { LINEMEDIAMODE_G3FAX              ,TEXT("G3FAX")              },
    { LINEMEDIAMODE_TDD                ,TEXT("TDD")                },
    { LINEMEDIAMODE_G4FAX              ,TEXT("G4FAX")              },
    { LINEMEDIAMODE_DIGITALDATA        ,TEXT("DIGITALDATA")        },
    { LINEMEDIAMODE_TELETEX            ,TEXT("TELETEX")            },
    { LINEMEDIAMODE_VIDEOTEX           ,TEXT("VIDEOTEX")           },
    { LINEMEDIAMODE_TELEX              ,TEXT("TELEX")              },
    { LINEMEDIAMODE_MIXED              ,TEXT("MIXED")              },
    { LINEMEDIAMODE_ADSI               ,TEXT("ADSI")               },
    { LINEMEDIAMODE_VOICEVIEW          ,TEXT("VOICEVIEW")          },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aPhoneStates[] =
{
    { PHONESTATE_OTHER                 ,TEXT("OTHER")              },
    { PHONESTATE_CONNECTED             ,TEXT("CONNECTED")          },
    { PHONESTATE_DISCONNECTED          ,TEXT("DISCONNECTED")       },
    { PHONESTATE_OWNER                 ,TEXT("OWNER")              },
    { PHONESTATE_MONITORS              ,TEXT("MONITORS")           },
    { PHONESTATE_DISPLAY               ,TEXT("DISPLAY")            },
    { PHONESTATE_LAMP                  ,TEXT("LAMP")               },
    { PHONESTATE_RINGMODE              ,TEXT("RINGMODE")           },
    { PHONESTATE_RINGVOLUME            ,TEXT("RINGVOLUME")         },
    { PHONESTATE_HANDSETHOOKSWITCH     ,TEXT("HANDSETHOOKSWITCH")  },
    { PHONESTATE_HANDSETVOLUME         ,TEXT("HANDSETVOLUME")      },
    { PHONESTATE_HANDSETGAIN           ,TEXT("HANDSETGAIN")        },
    { PHONESTATE_SPEAKERHOOKSWITCH     ,TEXT("SPEAKERHOOKSWITCH")  },
    { PHONESTATE_SPEAKERVOLUME         ,TEXT("SPEAKERVOLUME")      },
    { PHONESTATE_SPEAKERGAIN           ,TEXT("SPEAKERGAIN")        },
    { PHONESTATE_HEADSETHOOKSWITCH     ,TEXT("HEADSETHOOKSWITCH")  },
    { PHONESTATE_HEADSETVOLUME         ,TEXT("HEADSETVOLUME")      },
    { PHONESTATE_HEADSETGAIN           ,TEXT("HEADSETGAIN")        },
    { PHONESTATE_SUSPEND               ,TEXT("SUSPEND")            },
    { PHONESTATE_RESUME                ,TEXT("RESUME")             },
    { PHONESTATE_DEVSPECIFIC           ,TEXT("DEVSPECIFIC")        },
    { PHONESTATE_REINIT                ,TEXT("REINIT")             },
    { PHONESTATE_CAPSCHANGE            ,TEXT("CAPSCHANGE")         },
    { PHONESTATE_REMOVED               ,TEXT("REMOVED")            },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aTerminalModes[] =
{
    { LINETERMMODE_BUTTONS             ,TEXT("BUTTONS")            },
    { LINETERMMODE_LAMPS               ,TEXT("LAMPS")              },
    { LINETERMMODE_DISPLAY             ,TEXT("DISPLAY")            },
    { LINETERMMODE_RINGER              ,TEXT("RINGER")             },
    { LINETERMMODE_HOOKSWITCH          ,TEXT("HOOKSWITCH")         },
    { LINETERMMODE_MEDIATOLINE         ,TEXT("MEDIATOLINE")        },
    { LINETERMMODE_MEDIAFROMLINE       ,TEXT("MEDIAFROMLINE")      },
    { LINETERMMODE_MEDIABIDIRECT       ,TEXT("MEDIABIDIRECT")      },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aToneModes[] =
{
    { LINETONEMODE_CUSTOM              ,TEXT("CUSTOM")             },
    { LINETONEMODE_RINGBACK            ,TEXT("RINGBACK")           },
    { LINETONEMODE_BUSY                ,TEXT("BUSY")               },
    { LINETONEMODE_BEEP                ,TEXT("BEEP")               },
    { LINETONEMODE_BILLING             ,TEXT("BILLING")            },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aTransferModes[] =
{
    { LINETRANSFERMODE_TRANSFER        ,TEXT("TRANSFER")           },
    { LINETRANSFERMODE_CONFERENCE      ,TEXT("CONFERENCE")         },
    { 0xffffffff                       ,TEXT("")                   }
};


LPTSTR
GetFlags(
    DWORD_PTR dwFlags,
    PLOOKUP   pLookup
    )
{
    int i;
    TCHAR buf[256];
    LPTSTR p = NULL;


    buf[0] = 0;

    for (i = 0; (dwFlags && (pLookup[i].dwVal != 0xffffffff)); i++) {
        if (dwFlags & pLookup[i].dwVal) {
            _tcscat( buf, pLookup[i].lpszVal );
            dwFlags = dwFlags & (~(DWORD_PTR)pLookup[i].dwVal);
        }
    }

    if (buf[0]) {
        p = (LPTSTR) ::malloc( (_tcslen(buf) + 1) * sizeof(buf[1]) );
        if (p) {
            _tcscpy( p, buf );
        }
    }

    return p;
}


void
ShowLineEvent(
    HLINE       htLine,
    HCALL       htCall,
    LPTSTR      MsgStr,
    DWORD_PTR   dwCallbackInstance,
    DWORD       dwMsg,
    DWORD_PTR   dwParam1,
    DWORD_PTR   dwParam2,
    DWORD_PTR   dwParam3
    )
{
    int       i;
    LPTSTR    lpszParam1 = NULL;
    LPTSTR    lpszParam2 = NULL;
    LPTSTR    lpszParam3 = NULL;
    TCHAR     MsgBuf[1024];



    MsgBuf[0] = 0;

    if (MsgStr)
	{
        _stprintf( &MsgBuf[_tcslen(MsgBuf)], TEXT("%s "), MsgStr );
    }

    _stprintf( &MsgBuf[_tcslen(MsgBuf)], TEXT("dwCallbackInstance=0x%08x "), dwCallbackInstance );

    for (i = 0; aMsgs[i].MsgId != 0xffffffff; i++)
	{
        if (dwMsg == aMsgs[i].MsgId)
		{
            break;
        }
    }

    if (aMsgs[i].MsgId == 0xffffffff)
	{
        _stprintf(
            &MsgBuf[_tcslen(MsgBuf)],
            TEXT("<unknown msg id = %d> : hLine=0x%08x, hCall=0x%08x "),
            dwMsg,
            htLine,
            htCall
            );
    }
	else
	{
        _stprintf(
            &MsgBuf[_tcslen(MsgBuf)],
            TEXT("%s : hLine=0x%08x, hCall=0x%08x "),
            aMsgs[i].Text,
            htLine,
            htCall
            );
    }

    if (aMsgs[i].LineMsg)
	{
        switch (dwMsg)
		{
            case LINE_ADDRESSSTATE:
                lpszParam2 = GetFlags( dwParam2, aAddressStates );
                break;

            case LINE_CALLINFO:
                lpszParam1 = GetFlags( dwParam1, aCallInfoStates );
                break;

            case LINE_CALLSTATE:
                lpszParam1 = GetFlags( dwParam1, aCallStates );
                break;

            case LINE_LINEDEVSTATE:
                lpszParam1 = GetFlags( dwParam1, aLineStates );
                break;
        }

    }
	else
	{
        switch (dwMsg)
		{
            case PHONE_BUTTON:
                lpszParam2 = GetFlags( dwParam2, aButtonModes );
                lpszParam3 = GetFlags( dwParam3, aButtonStates );
                break;

            case PHONE_STATE:
                lpszParam1 = GetFlags( dwParam1, aPhoneStates);
                break;
        }

    }

    _stprintf( &MsgBuf[_tcslen(MsgBuf)], TEXT("dwParam1=0x%08x"), dwParam1 );
    if (lpszParam1)
	{
        _stprintf( &MsgBuf[_tcslen(MsgBuf)], TEXT("(%s) "), lpszParam1 );
    }
	else
	{
        _stprintf( &MsgBuf[_tcslen(MsgBuf)], TEXT(" ") );
    }

    _stprintf( &MsgBuf[_tcslen(MsgBuf)], TEXT("dwParam2=0x%08x"), dwParam2 );
    if (lpszParam2)
	{
        _stprintf( &MsgBuf[_tcslen(MsgBuf)], TEXT("(%s) "), lpszParam2 );
    }
	else
	{
        _stprintf( &MsgBuf[_tcslen(MsgBuf)], TEXT(" ") );
    }

    _stprintf( &MsgBuf[_tcslen(MsgBuf)], TEXT("dwParam3=0x%08x"), dwParam3 );
    if (lpszParam3)
	{
        _stprintf( &MsgBuf[_tcslen(MsgBuf)], TEXT("(%s)"), lpszParam3 );
    }

    ::lgLogDetail(
		LOG_X,
		6,
		TEXT("Got a Tapi Message: %s"),
		MsgBuf
		);

    ::free(lpszParam1);
    ::free(lpszParam2);
	::free(lpszParam3);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\fsp\manyrecvfsp\macros.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  macros.h

Abstract:

  This module contains the global macros

--*/

#ifndef _MACROS_H
#define _MACROS_H

extern HANDLE  g_HeapHandle;  // g_HeapHandle is the global handle to the heap

// MemInitializeMacro is a macro to get the handle to the heap
#define MemInitializeMacro(hHeap) (g_HeapHandle = hHeap)

// MemAllocMacro is a macro to allocate dwBytes bytes of memory from the heap
#define MemAllocMacro(dwBytes) (HeapAlloc(g_HeapHandle, HEAP_GENERATE_EXCEPTIONS | HEAP_ZERO_MEMORY, dwBytes))

// MemReAllocMacro is a macro to reallocate dwBytes bytes of memory from the heap
#define MemReAllocMacro(lpMem, dwBytes) (HeapReAlloc(g_HeapHandle, HEAP_GENERATE_EXCEPTIONS | HEAP_ZERO_MEMORY, lpMem, dwBytes))

// MemFreeMacro is a macro to free a memory block allocated from the heap
#define MemFreeMacro(lpMem) (HeapFree(g_HeapHandle, 0, lpMem))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\fsp\manyrecvfsp\device.h ===
//
//
// Filename:	device.h
// Author:		Sigalit Bar (sigalitb)
// Date:		6-Jan-99
//
//

#ifndef __DEVICE_H_
#define __DEVICE_H_


#include <stdlib.h>
#include <stdio.h>
#include <TCHAR.H>
#include <vector>

#include <windows.h>
#include <crtdbg.h>

#include <tapi.h>
#include <faxdev.h>

#include "..\..\log\log.h"
#include "util.h"

using namespace std ;

// DEVICE_NAME_PREFIX is the name prefix for the virtual fax devices
#define NEWFSP_DEVICE_NAME_PREFIX  TEXT("Many Rec VFSP Device ")
// DEVICE_ID_PREFIX is the value that identifies the virtual fax devices
#define NEWFSP_DEVICE_ID_PREFIX    0x60000

// DEVICE_IDLE indicates the virtual fax device is idle
#define DEVICE_IDLE                1
// DEVICE_START indicates the virtual fax device is pending a fax job
#define DEVICE_START               2
// DEVICE_SEND indicates the virtual fax device is sending
#define DEVICE_SEND                3
// DEVICE_RECEIVE indicates the virtual fax device is receiving
#define DEVICE_RECEIVE             4
// DEVICE_ABORTING indicates the virtual fax device is aborting
#define DEVICE_ABORTING            5

// JOB_UNKNOWN indicates the fax job is pending
#define JOB_UNKNOWN                1
// JOB_SEND indicates the fax job is a send
#define JOB_SEND                   2
// JOB_RECEIVE indicates the fax job is a receive
#define JOB_RECEIVE                3

#define JOB_SLEEP_TIME	3000
#define MAX_RAND_SLEEP	4000
#define MIN_RAND_SLEEP	1000


#define RING_THREAD_TIMEOUT 500000	

#define RECVFSP_FILENAME	TEXT("d:\\EFSP\\ManyRecVFSP\\RecVFSP.tif")

class CDeviceJob;

//////////////////////////// CDevice ////////////////////////////

class CDevice{

public:
	CDevice(
		DWORD	dwDeviceId = 0, 
		HANDLE	hDeviceCompletionPort = NULL,
		DWORD	dwDeviceCompletionKey = 0,
		DWORD	dwDeviceStatus = DEVICE_IDLE,
		long	lReceivedFaxes = 0,
		long	lRing = 1,
		HANDLE	hRingThread = NULL
		);
	~CDevice(void);

	BOOL GetAllData(
		DWORD				dwDeviceId,
		HANDLE             hDeviceCompletionPort,
		DWORD              dwDeviceCompletionKey,
		DWORD              dwDeviceStatus,
		long               lReceivedFaxes,
		long               lRing,
		HANDLE             hRingThread
		);
	BOOL GetDeviceId(LPDWORD pdwDeviceId) const;
	BOOL GetDeviceStatus(LPDWORD pdwDeviceStatus) const;
	long GetRing(void) const;

	BOOL CreateRingThread(LPTHREAD_START_ROUTINE fnThread, LPVOID pVoid);
	BOOL StartJob(PHANDLE phFaxHandle, HANDLE hCompletionPortHandle, DWORD dwCompletionKey);
	BOOL EndJob(CDeviceJob* pDeviceJob);
	BOOL Send(
		IN OUT	CDeviceJob*			pDeviceJob,
		IN		PFAX_SEND			pFaxSend,
		IN		PFAX_SEND_CALLBACK	fnFaxSendCallback
		);
	BOOL Receive(
		IN OUT	CDeviceJob*		pDeviceJob,
		IN		HCALL			CallHandle,
		IN OUT	PFAX_RECEIVE	pFaxReceive
		);
	BOOL AbortOperation(IN OUT	CDeviceJob*	pDeviceJob);

	BOOL PostRingEvent(void);

private:
    CRITICAL_SECTION	m_cs;						// object to serialize access to the virtual fax device
    DWORD               m_dwDeviceId;				// specifies the identifier of the virtual fax device
    HANDLE              m_hDeviceCompletionPort;	// specifies a handle to an I/O completion port
    DWORD               m_dwDeviceCompletionKey;	// specifies a completion port key value
    DWORD               m_dwDeviceStatus;			// specifies the current status of the virtual fax device
    long                m_lReceivedFaxes;			// specifies the number of received faxes o n the device
    long                m_lRing;					// specifies if the device's ring thread is enabled
    HANDLE              m_hRingThread;				// the device's ring thread handle
};


//////////////////////////// CFaxDeviceVector ////////////////////////////

// CFaxDeviceVector
// an STL list of CDevices
#ifdef _C_FAX_DEVICE_VECTOR_
#error "redefinition of _C_FAX_DEVICE_VECTOR_"
#else
#define _C_FAX_DEVICE_VECTOR_
typedef vector< CDevice* > CFaxDeviceVector;
#endif

BOOL
FreeDeviceArray( CFaxDeviceVector& aFaxDeviceArray );

BOOL 
InitDeviceArray(
	IN OUT	CFaxDeviceVector&	aFaxDeviceArray,
	IN		DWORD				dwNumOfDevices,
    IN		HANDLE				hCompletionPort,
    IN		DWORD				dwCompletionKey
	);


//////////////////////////// CDeviceJob ////////////////////////////

class CDeviceJob{

public:
	CDeviceJob(
		CDevice*	pDevicePtr = NULL,
		HANDLE		hJobCompletionPort = NULL,
		DWORD		dwJobCompletionKey = 0,
		DWORD		dwJobType = JOB_UNKNOWN,
		DWORD		dwJobStatus = FS_INITIALIZING
		);
	~CDeviceJob(void);
	
	BOOL GetDevicePtr(OUT CDevice** ppDevicePtr) const;
	BOOL GetDeviceId(OUT LPDWORD pdwDeviceId) const;
	BOOL GetJobCompletionPort(OUT PHANDLE phJobCompletionPort) const;
	BOOL GetJobCompletionKey(OUT LPDWORD pdwJobCompletionKey) const;

	//NOTE: Always surround a call to this func with the job's device m_cs
	//      EnterCriticalSection(&m_cs) and LeaveCriticalSection(&m_cs)
	BOOL SetJobStatus(DWORD dwJobStatus);

private:
    CDevice*	         m_pDevicePtr;				// the virtual fax device id associated with the fax job
    HANDLE               m_hJobCompletionPort;	// specifies a handle to an I/O completion port
    DWORD                m_dwJobCompletionKey;	// specifies a completion port key value
    DWORD                m_dwJobType;			// specifies the fax job type
    DWORD                m_dwJobStatus;			// specifies the current status of the fax job

};

#ifdef __cplusplus
extern "C" {
#endif

extern CFaxDeviceVector g_myFaxDeviceVector;		

#ifdef __cplusplus
}
#endif 



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\fsp\manyrecvfsp\main.cpp ===
// Module name:		main.cpp
// Module author:	Sigalit Bar (sigalitb)
// Date:			13-Dec-98

// Description:
//
// Specifics:
//		  
// To Use:
//

//VFSP DLL header file

#include "VFSP.h"

#ifdef __cplusplus
extern "C" {
#endif

HANDLE			g_HeapHandle = NULL;		// g_HeapHandle is the global handle to the heap
HANDLE			g_hInstance = NULL;			// g_hInstance is the global handle to the module
HLINEAPP		g_LineAppHandle = NULL;		// g_LineAppHandle is the global handle to the fax service's registration with TAPI


// Vector containing the information for the virtual devices of the FSP
CFaxDeviceVector g_myFaxDeviceVector;		

// indicates whether devices were initiated
BOOL g_fDevicesInitiated = FALSE;			


long					g_lReceivedFaxes = 0;

DWORD					g_dwSleepTime = 1000;


BOOL WINAPI DllMain (HINSTANCE hInstance, DWORD fdwReason, LPVOID lpvReserved)
{
	switch (fdwReason)
	{
	case DLL_PROCESS_ATTACH:
		::lgInitializeLogger();
		::lgEnableLogging();
		::lgSetLogLevel(9);
		::lgBeginSuite(TEXT("Many Rec VFSP"));
		::lgBeginCase(1, TEXT("Many Rec VFSP"));
		g_hInstance = hInstance;
		::DisableThreadLibraryCalls( hInstance );
		break;

	case DLL_PROCESS_DETACH:
		::lgLogDetail(LOG_X,1,TEXT("g_lReceivedFaxes=%d"),g_lReceivedFaxes);
		if (TRUE == g_fDevicesInitiated) FreeDeviceArray(g_myFaxDeviceVector);
		::lgEndCase();
		::lgEndSuite();
		::lgCloseLogger();
		break;
	}
	return(TRUE);
}


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\fsp\manyrecvfsp\device.cpp ===
//
//
// Filename:	device.cpp
// Author:		Sigalit Bar (sigalitb)
// Date:		6-Jan-99
//
//


#include "device.h"


/////////////////////////////////// CFaxDeviceVector ///////////////////////////////////////////////
DWORD WINAPI RingThread(LPVOID pVoid);

BOOL 
InitDeviceArray(
	IN OUT	CFaxDeviceVector&	aFaxDeviceArray,
	IN		DWORD				dwNumOfDevices,
    IN		HANDLE				hCompletionPort,
    IN		DWORD				dwCompletionKey
	)
{
    ::lgLogDetail(LOG_X,7,TEXT("[ManyRecVFSP]Entry of InitDeviceArray"));
    ::lgLogDetail(LOG_X,7,TEXT("[ManyRecVFSP] dwNumOfDevices = %d"),dwNumOfDevices);

	DWORD i;
	for (i=0; i<dwNumOfDevices; i++)
	{
		CDevice* pDevice = new CDevice(i,hCompletionPort,dwCompletionKey);
		if (NULL == pDevice)
		{
			//TO DO: log fail
			::lgLogError(
				LOG_SEV_1,
				TEXT("%s[%d]: new failed"),
				TEXT(__FILE__),
				__LINE__
				);
			goto ExitFail;
		}
		if (FALSE == pDevice->CreateRingThread(RingThread, (LPVOID)i))
		{
			//TO DO: change assert to something better.
			_ASSERTE(FALSE);
		}
		aFaxDeviceArray.push_back(pDevice);
	}
    ::lgLogDetail(LOG_X,7,TEXT("[ManyRecVFSP]Exit from InitDeviceArray"));
	return(TRUE);

ExitFail:
	//cleanup array
	if (FALSE == FreeDeviceArray(aFaxDeviceArray))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: FreeDeviceArray failed"),
			TEXT(__FILE__),
			__LINE__
			);
	}
	else
	{
		::lgLogDetail(
			LOG_X,
			1,
			TEXT("%s[%d]: FreeDeviceArray succeeded"),
			TEXT(__FILE__),
			__LINE__
			);
	}
	return(FALSE);
}


BOOL 
FreeDeviceArray(IN OUT CFaxDeviceVector& aFaxDeviceArray)
{
    ::lgLogDetail(LOG_X,7,TEXT("[ManyRecVFSP]Entry of FreeDeviceArray"));

	DWORD i;
	DWORD dwNumOfDevices = aFaxDeviceArray.size();
    ::lgLogDetail(LOG_X,7,TEXT("[ManyRecVFSP]FreeDeviceArray freeing %d devices"),dwNumOfDevices);
	for (i=0; i<dwNumOfDevices; i++)
	{
		delete (aFaxDeviceArray.at(i));
	}
	aFaxDeviceArray.clear();
    ::lgLogDetail(LOG_X,7,TEXT("[ManyRecVFSP]Exit from FreeDeviceArray"));
	return(TRUE);

	//Q: What about any "left over" jobs?
	//   We want to make sure they are all freed, so we will have to add a 
	//   ptr (array of ptrs for multi-send) from device to its job(s).
	//	 and free them here.
}

/////////////////////////////////////// CDevice ////////////////////////////////////////////////////

CDevice::CDevice(
	DWORD	dwDeviceId, 
	HANDLE	hDeviceCompletionPort,
	DWORD	dwDeviceCompletionKey,
	DWORD	dwDeviceStatus,
	long	lReceivedFaxes,
	long	lRing,
	HANDLE	hRingThread
	)
{
	::InitializeCriticalSection(&m_cs); 
	m_dwDeviceId = dwDeviceId;
	m_hDeviceCompletionPort = hDeviceCompletionPort;
	m_dwDeviceCompletionKey = dwDeviceCompletionKey;
	m_dwDeviceStatus = dwDeviceStatus;
	m_lReceivedFaxes = lReceivedFaxes;
	m_lRing = lRing;
	m_hRingThread = hRingThread;
}


CDevice::~CDevice(void)
{
	::InterlockedExchange(&m_lRing,0);
	DWORD dwWait;
	dwWait = ::WaitForSingleObject(m_hRingThread,RING_THREAD_TIMEOUT);
	//TO DO: check return value of WaitForSingleObject, for now ...
	if (WAIT_OBJECT_0 != dwWait)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: WaitForSingleObject != WAIT_OBJECT_0"),
			TEXT(__FILE__),
			__LINE__
			);
	}

	if (FALSE == ::CloseHandle(m_hRingThread))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: CloseHandle(m_hRingThread) failed for devId=%d"),
			TEXT(__FILE__),
			__LINE__,
			m_dwDeviceId
			);
	}

	//TO DO: check return value of CloseHandle
	//Q: need to close port handle? m_hDeviceCompletionPort

    ::DeleteCriticalSection(&m_cs);

	::lgLogDetail(
		LOG_X,
		1,
		TEXT("Device[%d].lReceivedFaxes=%d"),
		m_dwDeviceId,
		m_lReceivedFaxes
		);

}

BOOL CDevice::GetAllData(
	DWORD				dwDeviceId,
	HANDLE             hDeviceCompletionPort,
	DWORD              dwDeviceCompletionKey,
	DWORD              dwDeviceStatus,
	long               lReceivedFaxes,
	long               lRing,
	HANDLE             hRingThread)
{
	EnterCriticalSection(&m_cs);
		dwDeviceId = m_dwDeviceId;
		hDeviceCompletionPort = m_hDeviceCompletionPort;
		dwDeviceCompletionKey = m_dwDeviceCompletionKey;
		dwDeviceStatus = m_dwDeviceStatus;
		lReceivedFaxes = m_lReceivedFaxes;
		lRing = m_lRing;
		hRingThread = m_hRingThread;
	LeaveCriticalSection(&m_cs);
	return(TRUE);
}

BOOL CDevice::GetDeviceId(LPDWORD pdwDeviceId) const
{
	if (NULL == pdwDeviceId)
	{
		return(FALSE);
	}
	*pdwDeviceId = m_dwDeviceId;
	return(TRUE);
}

BOOL CDevice::GetDeviceStatus(LPDWORD pdwDeviceStatus) const
{
	if (NULL == pdwDeviceStatus)
	{
		return(FALSE);
	}
	*pdwDeviceStatus = m_dwDeviceStatus;
	return(TRUE);
}

long CDevice::GetRing(void) const
{
	return(m_lRing);
}

BOOL CDevice::CreateRingThread(LPTHREAD_START_ROUTINE fnThread, LPVOID pVoid)
{
	BOOL fRetVal = FALSE;

	EnterCriticalSection(&m_cs);
		if (NULL == m_hRingThread)
		{
			::lgLogDetail(LOG_X,4,TEXT("[ManyRecVFSP]CREATE THREAD for dwDeviceId=%d"),m_dwDeviceId);
			m_hRingThread = CreateThread(
				NULL, 
				0, 
				fnThread, 
				pVoid, 
				0, 
				NULL
				);
			if (NULL == m_hRingThread)
			{
				//this means we can't start the RingThread, so for now
				::lgLogDetail(
					LOG_X,
					1,
					TEXT("[ManyRecVFSP]CreateThread for a_Devices[%d].hRingThread failed"),
					m_dwDeviceId
					);
				goto ExitFunc;
			}
		}

		fRetVal = TRUE;

ExitFunc:
	LeaveCriticalSection(&m_cs);
	return(fRetVal);
}

//
// StartJob:
//	Starts a job (outbound or inbound) on the device.
//	This function is invoked from the VFSP's FaxDevStartJob() function.
//	Where FaxDevStartJob HANDLE hCompletionPortHandle (4th param) is passed on,
//	so is dwCompletionKey (5th param) and PHANDLE pFaxHandle (3rd OUT param) is
//	passed on to be created here (it is set to point at a CDeviceJob that represents
//	the started job on the device).
//
BOOL CDevice::StartJob(
	OUT PHANDLE	phFaxHandle, 
	IN	HANDLE	hCompletionPortHandle, 
	IN	DWORD	dwCompletionKey
	)
{

	BOOL fRetVal = FALSE;
	if (NULL == phFaxHandle)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: phFaxHandle == NULL"),
			TEXT(__FILE__),
			__LINE__
			);
		return(FALSE);
	}

    EnterCriticalSection(&m_cs);
		CDeviceJob* pDeviceJob = new CDeviceJob(
			this,
			hCompletionPortHandle,
			dwCompletionKey
			);
		if (NULL == pDeviceJob)
		{
			::lgLogError(
				LOG_SEV_1,
				TEXT("%s[%d]: new CDeviceJob() failed"),
				TEXT(__FILE__),
				__LINE__
				);
			goto ExitFunc;
		}

		m_dwDeviceStatus = DEVICE_START;
		//m_pDeviceJob = pDeviceJob;

		*phFaxHandle = (PHANDLE)pDeviceJob;
		fRetVal = TRUE;

ExitFunc:
    LeaveCriticalSection(&m_cs);
	return(fRetVal);
}

//
// EndJob:
//	Ends job pDeviceJob on the device.
//	This function is invoked from the VFSP's FaxDevEndJob() function,
//	where pDeviceJob is extracted from FaxDevEndJob() HANDLE FaxHandle param.
//
BOOL CDevice::EndJob(CDeviceJob* pDeviceJob)
{
    EnterCriticalSection(&m_cs);
		m_dwDeviceStatus = DEVICE_IDLE;
		delete (pDeviceJob);
		//on a multi-send device we
		//may want to do more here
    LeaveCriticalSection(&m_cs);
	return(TRUE);
}

//
// Send:
//	Sends the outbound job pDeviceJob on the device.
//	This function is invoked from the VFSP's FaxDevSend() function.
//	Where pDeviceJob is extracted from the FaxDevSend() HANDLE FaxHandle (1st param),
//	pFaxSend (2nd param) is passed on, and so is fnFaxSendCallback (3rd param).
//
BOOL CDevice::Send(
	IN OUT	CDeviceJob*			pDeviceJob,
    IN		PFAX_SEND			pFaxSend,
    IN		PFAX_SEND_CALLBACK	fnFaxSendCallback
	)
{
	BOOL fRetVal = FALSE;
	BOOL fTempRetVal = FALSE;
	HANDLE hJobCompletionPort = NULL;
	DWORD  dwJobCompletionKey = 0;
	DWORD dwJobStatus = FS_FATAL_ERROR;

	if (NULL == pDeviceJob)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: NULL == pDeviceJob"),
			TEXT(__FILE__),
			__LINE__
			);
		return(FALSE);
	}

	//
	// get the job's port and key
	//
	if(FALSE == pDeviceJob->GetJobCompletionPort(&hJobCompletionPort))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: pDeviceJob->GetJobCompletionPort() failed"),
			TEXT(__FILE__),
			__LINE__
			);
		return(FALSE);
	}
	if(FALSE == pDeviceJob->GetJobCompletionKey(&dwJobCompletionKey))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: pDeviceJob->GetJobCompletionKey() failed"),
			TEXT(__FILE__),
			__LINE__
			);
		return(FALSE);
	}

	//
	// initialization
	//
    EnterCriticalSection(&m_cs);
	if (DEVICE_ABORTING == m_dwDeviceStatus) 
	{
		dwJobStatus = FS_USER_ABORT;
		LeaveCriticalSection(&m_cs);
		goto ExitFalse;
	}
		m_dwDeviceStatus = DEVICE_SEND;
		fTempRetVal = pDeviceJob->SetJobStatus(FS_INITIALIZING);
    LeaveCriticalSection(&m_cs);
	if(FALSE == fTempRetVal)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: pDeviceJob->SetJobStatus(FS_INITIALIZING) failed"),
			TEXT(__FILE__),
			__LINE__
			);
		dwJobStatus = FS_FATAL_ERROR;
		goto ExitFalse;
	}

	// post status
    if (!PostJobStatus(
			hJobCompletionPort, 
			dwJobCompletionKey, 
			FS_INITIALIZING, 
			ERROR_SUCCESS
			)
		)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: PostJobStatus failed"),
			TEXT(__FILE__),
			__LINE__
			);
		dwJobStatus = FS_FATAL_ERROR;
		goto ExitFalse;
	}
	Sleep(500);

	//
	// transmission
	//
	EnterCriticalSection(&m_cs);
	if (DEVICE_ABORTING == m_dwDeviceStatus) 
	{
		dwJobStatus = FS_USER_ABORT;
	    LeaveCriticalSection(&m_cs);
		goto ExitFalse;
	}
		m_dwDeviceStatus = DEVICE_SEND;
		fTempRetVal = pDeviceJob->SetJobStatus(FS_TRANSMITTING);
    LeaveCriticalSection(&m_cs);
	if(FALSE == fTempRetVal)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: pDeviceJob->SetJobStatus(FS_TRANSMITTING) failed"),
			TEXT(__FILE__),
			__LINE__
			);
		dwJobStatus = FS_FATAL_ERROR;
		goto ExitFalse;
	}

	// post status
    if (!PostJobStatus(
			hJobCompletionPort, 
			dwJobCompletionKey, 
			FS_TRANSMITTING, 
			ERROR_SUCCESS
			)
		)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: PostJobStatus failed"),
			TEXT(__FILE__),
			__LINE__
			);
		dwJobStatus = FS_FATAL_ERROR;
		goto ExitFalse;
	}
	Sleep(1000);

	//
	// completion
	//
	EnterCriticalSection(&m_cs);
	if (DEVICE_ABORTING == m_dwDeviceStatus) 
	{
		dwJobStatus = FS_USER_ABORT;
	    LeaveCriticalSection(&m_cs);
		goto ExitFalse;
	}
		m_dwDeviceStatus = DEVICE_SEND;
		fTempRetVal = pDeviceJob->SetJobStatus(FS_COMPLETED);
    LeaveCriticalSection(&m_cs);
	if(FALSE == fTempRetVal)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: pDeviceJob->SetJobStatus(FS_COMPLETED) failed"),
			TEXT(__FILE__),
			__LINE__
			);
		dwJobStatus = FS_FATAL_ERROR;
		goto ExitFalse;
	}

	// post status
    if (!PostJobStatus(
			hJobCompletionPort, 
			dwJobCompletionKey, 
			FS_COMPLETED, 
			ERROR_SUCCESS
			)
		)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: PostJobStatus failed"),
			TEXT(__FILE__),
			__LINE__
			);
		dwJobStatus = FS_FATAL_ERROR;
		goto ExitFalse;
	}
	Sleep(500);

    ::lgLogDetail(
		LOG_X,
		1,
		TEXT("[ManyRecVFSP]Exit of FaxDevSend with TRUE")
		);

    return(TRUE);


ExitFalse:
	EnterCriticalSection(&m_cs);
		if(FALSE == pDeviceJob->SetJobStatus(dwJobStatus))
		{
			::lgLogError(
				LOG_SEV_1,
				TEXT("%s[%d]: pDeviceJob->SetJobStatus(%d) failed"),
				TEXT(__FILE__),
				__LINE__,
				dwJobStatus
				);
		}
	LeaveCriticalSection(&m_cs);

	//post status
    if (!PostJobStatus(
			hJobCompletionPort, 
			dwJobCompletionKey, 
			dwJobStatus, 
			ERROR_SUCCESS
			)
		)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: PostJobStatus failed"),
			TEXT(__FILE__),
			__LINE__
			);
	}
	Sleep(3000);

    ::lgLogDetail(
		LOG_X,
		1,
		TEXT("[ManyRecVFSP]Exit of FaxDevSend with FALSE")
		);
	return(FALSE);
}

//
// Receive:
//	Receive an inbound job (pDeviceJob) on the device
//	This method is invoked from the VFSP's FaxDevReceive() function.
//	Where pDeviceJob is extracted from FaxDevReceive() HANDLE FaxHandle (1st param),
//	CallHandle (2nd param) is passed on and so is pFaxReceive (3rd param).
// 
BOOL CDevice::Receive(
	IN OUT	CDeviceJob*		pDeviceJob,
    IN		HCALL			CallHandle,
    IN OUT	PFAX_RECEIVE	pFaxReceive
	)
{
	BOOL fRetVal = FALSE;
	BOOL fTempRetVal = FALSE;
	HANDLE hJobCompletionPort = NULL;
	DWORD  dwJobCompletionKey = 0;
	DWORD dwJobStatus = FS_FATAL_ERROR;

	if (NULL == pDeviceJob)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: NULL == pDeviceJob"),
			TEXT(__FILE__),
			__LINE__
			);
		return(FALSE);
	}

	//
	// get the job's port and key
	//
	if(FALSE == pDeviceJob->GetJobCompletionPort(&hJobCompletionPort))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: pDeviceJob->GetJobCompletionPort() failed"),
			TEXT(__FILE__),
			__LINE__
			);
		return(FALSE);
	}
	if(FALSE == pDeviceJob->GetJobCompletionKey(&dwJobCompletionKey))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: pDeviceJob->GetJobCompletionKey() failed"),
			TEXT(__FILE__),
			__LINE__
			);
		return(FALSE);
	}

	//
	// initialization
	//
    EnterCriticalSection(&m_cs);
	if (DEVICE_ABORTING == m_dwDeviceStatus) 
	{
		dwJobStatus = FS_USER_ABORT;
		LeaveCriticalSection(&m_cs);
		goto ExitFalse;
	}
		m_dwDeviceStatus = DEVICE_RECEIVE;
		fTempRetVal = pDeviceJob->SetJobStatus(FS_ANSWERED);
    LeaveCriticalSection(&m_cs);
	if(FALSE == fTempRetVal)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: pDeviceJob->SetJobStatus(FS_ANSWERED) failed"),
			TEXT(__FILE__),
			__LINE__
			);
		dwJobStatus = FS_FATAL_ERROR;
		goto ExitFalse;
	}

	// post status
    if (!PostJobStatus(
			hJobCompletionPort, 
			dwJobCompletionKey, 
			FS_ANSWERED, 
			ERROR_SUCCESS
			)
		)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: PostJobStatus failed"),
			TEXT(__FILE__),
			__LINE__
			);
		dwJobStatus = FS_FATAL_ERROR;
		goto ExitFalse;
	}
	Sleep(500);

	//
	// receive
	//
	EnterCriticalSection(&m_cs);
	if (DEVICE_ABORTING == m_dwDeviceStatus) 
	{
		dwJobStatus = FS_USER_ABORT;
		LeaveCriticalSection(&m_cs);
		goto ExitFalse;
	}
		m_dwDeviceStatus = DEVICE_RECEIVE;
		fTempRetVal = pDeviceJob->SetJobStatus(FS_RECEIVING);
    LeaveCriticalSection(&m_cs);
	if(FALSE == fTempRetVal)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: pDeviceJob->SetJobStatus(FS_RECEIVING) failed"),
			TEXT(__FILE__),
			__LINE__
			);
		dwJobStatus = FS_FATAL_ERROR;
		goto ExitFalse;
	}

	// post status
    if (!PostJobStatus(
			hJobCompletionPort, 
			dwJobCompletionKey, 
			FS_RECEIVING, 
			ERROR_SUCCESS
			)
		)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: PostJobStatus failed"),
			TEXT(__FILE__),
			__LINE__
			);
		dwJobStatus = FS_FATAL_ERROR;
		goto ExitFalse;
	}
	Sleep(1000);

	// actual receive
	_ASSERTE(NULL != pFaxReceive);
	if (NULL == pFaxReceive->FileName)
	{
		::lgLogError(LOG_SEV_1,TEXT("BUG: FaxSvc gave NULL == pFaxReceive->FileName"));
		_ASSERTE(FALSE);
	}
	//also check strlen > 0
	if (!CopyFile(RECVFSP_FILENAME, pFaxReceive->FileName, FALSE)) //overwrite the 0K file 
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("[ManyRecVFSP]CopyFile failed with err=%d"),
			::GetLastError());
		_ASSERTE(FALSE);
	}


	//
	// completion
	//
	EnterCriticalSection(&m_cs);
	if (DEVICE_ABORTING == m_dwDeviceStatus) 
	{
		dwJobStatus = FS_USER_ABORT;
		LeaveCriticalSection(&m_cs);
		goto ExitFalse;
	}
		m_dwDeviceStatus = DEVICE_RECEIVE;
		fTempRetVal = pDeviceJob->SetJobStatus(FS_COMPLETED);
		m_lReceivedFaxes++;
    LeaveCriticalSection(&m_cs);
	if(FALSE == fTempRetVal)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: pDeviceJob->SetJobStatus(FS_COMPLETED) failed"),
			TEXT(__FILE__),
			__LINE__
			);
		dwJobStatus = FS_FATAL_ERROR;
		goto ExitFalse;
	}

	// post status
    if (!PostJobStatus(
			hJobCompletionPort, 
			dwJobCompletionKey, 
			FS_COMPLETED, 
			ERROR_SUCCESS
			)
		)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: PostJobStatus failed"),
			TEXT(__FILE__),
			__LINE__
			);
		dwJobStatus = FS_FATAL_ERROR;
		goto ExitFalse;
	}
	Sleep(500);

    ::lgLogDetail(
		LOG_X,
		1,
		TEXT("[ManyRecVFSP]Exit of FaxDevReceive with TRUE")
		);

	//m_dwDeviceStatus = DEVICE_IDLE;
    return(TRUE);


ExitFalse:
	EnterCriticalSection(&m_cs);
		if(FALSE == pDeviceJob->SetJobStatus(dwJobStatus))
		{
			::lgLogError(
				LOG_SEV_1,
				TEXT("%s[%d]: pDeviceJob->SetJobStatus(%d) failed"),
				TEXT(__FILE__),
				__LINE__,
				dwJobStatus
				);
		}
	LeaveCriticalSection(&m_cs);

	//post status
    if (!PostJobStatus(
			hJobCompletionPort, 
			dwJobCompletionKey, 
			dwJobStatus, 
			ERROR_SUCCESS
			)
		)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: PostJobStatus failed"),
			TEXT(__FILE__),
			__LINE__
			);
	}
	//m_dwDeviceStatus = DEVICE_IDLE;
	Sleep(3000);

    ::lgLogDetail(
		LOG_X,
		1,
		TEXT("[ManyRecVFSP]Exit of FaxDevReceive with FALSE")
		);
	return(FALSE);
}

//
// AbortOperation:
//	Aborts job pDeviceJob on the device.
//	This function is invoked from the VFSP's FaxDevAbortOperation() function.
//	Where pDeviceJob is extracted from FaxDevAbortOperation() HANDLE FaxHandle param.
//	
BOOL CDevice::AbortOperation(IN OUT	CDeviceJob*	pDeviceJob)
{

	if (NULL == pDeviceJob)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: NULL == pDeviceJob"),
			TEXT(__FILE__),
			__LINE__
			);
		return(FALSE);
	}

    EnterCriticalSection(&m_cs);
		m_dwDeviceStatus = DEVICE_ABORTING;
		//for a multi-send device we may want to do more here
    LeaveCriticalSection(&m_cs);

    return(TRUE);
}

//
// PostRingEvent:
//	Posts a LINEDEVSTATE_RINGING massege on the device's completion port.
//	=> tells the Fax Service that the device is ringing.
//
BOOL CDevice::PostRingEvent(void)
{
	BOOL fReturnValue = FALSE;

	::lgLogDetail(LOG_X,1,TEXT("CDevice::PostRingEvent entry for device=%d"), m_dwDeviceId);

    // pLineMessage is a pointer to LINEMESSAGE structure 
	// to signal an incoming fax transmission to the fax service
    LPLINEMESSAGE  pLineMessage = NULL;


	// check if device is idle
	if (DEVICE_IDLE != m_dwDeviceStatus) 
	{
		::lgLogDetail(
			LOG_X,
			1,
			TEXT("DEVICE_IDLE != m_dwDeviceStatus (device=%d)"),
			m_dwDeviceId
			);
		goto ExitFunc;
	}

	//
	// post the ring event
	//

	// Allocate a block of memory for the completion packet
	pLineMessage = (LPLINEMESSAGE)LocalAlloc(LPTR, sizeof(LINEMESSAGE));
	if( NULL == pLineMessage )
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: LocalAlloc failed (device=%d)"),
			TEXT(__FILE__),
			__LINE__,
			m_dwDeviceId
			);
		goto ExitFunc;
	}
	// Initialize the completion packet
	// Set the completion packet's handle to the virtual fax device
	pLineMessage->hDevice = m_dwDeviceId + NEWFSP_DEVICE_ID_PREFIX;
	// Set the completion packet's virtual fax device message
	pLineMessage->dwMessageID = 0;
	// Set the completion packet's instance data
	pLineMessage->dwCallbackInstance = 0;
	// Set the completion packet's first parameter
	pLineMessage->dwParam1 = LINEDEVSTATE_RINGING;
	// Set the completion packet's second parameter
	pLineMessage->dwParam2 = 0;
	// Set the completion packet's third parameter
	pLineMessage->dwParam3 = 0;

	// Post the completion packet
	if (! PostQueuedCompletionStatus(
			m_hDeviceCompletionPort, 
			sizeof(LINEMESSAGE), 
			m_dwDeviceCompletionKey, 
			(LPOVERLAPPED) pLineMessage
			)
		)
	{
		::lgLogDetail(
			LOG_X,
			1,
			TEXT("PostQueuedCompletionStatus(LINEDEVSTATE_RINGING) failed for device %d"),
			m_dwDeviceId
			);
		if (NULL != LocalFree(pLineMessage)) //LocalFree returns NULL if successfull
		{
			::lgLogError(
				LOG_SEV_1,
				TEXT("%s[%d]: LocalFree failed (device=%d)"),
				TEXT(__FILE__),
				__LINE__,
				m_dwDeviceId
				);
		}
		goto ExitFunc;
	}

	fReturnValue = TRUE;

ExitFunc:

	::lgLogDetail(
		LOG_X,
		1,
		TEXT("PostRingEvent (for device %d) exits with %d"),
		m_dwDeviceId,
		fReturnValue
		);

    return(fReturnValue);
}

///////////////////////////////////// CDeviceJob //////////////////////////////////////////////////

CDeviceJob::CDeviceJob(
	CDevice*	pDevicePtr,
	HANDLE		hJobCompletionPort,
	DWORD		dwJobCompletionKey,
	DWORD		dwJobType,
	DWORD		dwJobStatus)
{
	_ASSERTE(NULL != pDevicePtr);
	m_pDevicePtr = pDevicePtr;
	m_hJobCompletionPort = hJobCompletionPort;
	m_dwJobCompletionKey = dwJobCompletionKey;
	m_dwJobType = dwJobType;
	m_dwJobStatus = dwJobStatus;
}

CDeviceJob::~CDeviceJob(void)
{
}

BOOL CDeviceJob::GetDevicePtr(CDevice** ppDevicePtr) const
{
	BOOL fRetVal = FALSE;

	if (NULL == ppDevicePtr)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: NULL == ppDevicePtr"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
	}
	*ppDevicePtr = m_pDevicePtr;
	fRetVal = TRUE;

ExitFunc:
	return(fRetVal);
}

BOOL CDeviceJob::GetDeviceId(LPDWORD pdwDeviceId) const
{
	BOOL fRetVal = FALSE;

	if (NULL == m_pDevicePtr)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: NULL == m_pDevicePtr"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
	}
	if (NULL == pdwDeviceId)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: NULL == pdwDeviceId"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
	}
	fRetVal = m_pDevicePtr->GetDeviceId(pdwDeviceId);

ExitFunc:
	return(fRetVal);
}

BOOL CDeviceJob::GetJobCompletionPort(OUT PHANDLE phJobCompletionPort) const
{
	if (NULL == phJobCompletionPort)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: NULL == phJobCompletionPort"),
			TEXT(__FILE__),
			__LINE__
			);
		return(FALSE);
	}

	(*phJobCompletionPort) = m_hJobCompletionPort;
	return(TRUE);
}

BOOL CDeviceJob::GetJobCompletionKey(OUT LPDWORD pdwJobCompletionKey) const
{
	if (NULL == pdwJobCompletionKey)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: NULL == pdwJobCompletionKey"),
			TEXT(__FILE__),
			__LINE__
			);
		return(FALSE);
	}

	(*pdwJobCompletionKey) = m_dwJobCompletionKey;
	return(TRUE);
}


BOOL CDeviceJob::SetJobStatus(DWORD dwJobStatus)
{
	//Always surround a call to this func with the job's device m_cs
	// EnterCriticalSection(&m_cs) and LeaveCriticalSection(&m_cs)
	m_dwJobStatus = dwJobStatus;
	return(TRUE);
}

/////////////////////// Device Ring Thread //////////////////////////

DWORD WINAPI RingThread(LPVOID pVoid)
{

	::lgLogDetail(LOG_X,1,TEXT("RingThread entry"));

    // Copy the virtual fax device identifier
    DWORD dwDeviceId = (DWORD) pVoid;

	::lgLogDetail(LOG_X,1,TEXT("RingThread (for device %d)"),dwDeviceId);

	// get pDevice
	CDevice* pDevice = NULL;
	pDevice = g_myFaxDeviceVector.at(dwDeviceId);
	_ASSERTE(NULL != pDevice);


	//::lgLogDetail(LOG_X,1,TEXT("RingThread (for device %d) sleeping for 10 sec"),dwDeviceId);
	//Sleep(10000); //wait a little before you start

	srand( (unsigned)dwDeviceId*200 );

	DWORD dwRandSleep = (rand())%MAX_RAND_SLEEP; //random sleep time (up to MAX_RAND_SLEEP ms)
	::lgLogDetail(LOG_X,1,TEXT("RingThread (for device %d) sleeping for %d sec"),dwDeviceId, dwRandSleep);
	Sleep(dwRandSleep); //wait a little before you start

	while(pDevice->GetRing())
	{

		if (FALSE == pDevice->PostRingEvent())
		{
			::lgLogDetail(
				LOG_X,
				1,
				TEXT("pDevice->PostRingEvent failed (for device %d)"),
				dwDeviceId
				);
		}
		else
		{
			::lgLogDetail(
				LOG_X,
				1,
				TEXT("pDevice->PostRingEvent succeeded (for device %d)"),
				dwDeviceId
				);
		}
		dwRandSleep = (rand() % MAX_RAND_SLEEP) + MIN_RAND_SLEEP;
		::lgLogDetail(
			LOG_X,
			1,
			TEXT("Device(%d) sleeping for %d ms"),
			dwDeviceId,
			dwRandSleep
			);
		Sleep(dwRandSleep);
	}

	::lgLogDetail(LOG_X,1,TEXT("RingThread (for device %d) exit"),dwDeviceId);
	return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\fsp\manyrecvfsp\reg.h ===
// Module name:		reg.h
// Module author:	Sigalit Bar (sigalitb)
// Date:			13-Dec-98

#ifndef _REG_H
#define _REG_H

// FAX_PROVIDERS_REGKEY is the providers registry key under the fax registry key
#define FAX_PROVIDERS_REGKEY           L"Software\\Microsoft\\Fax\\Device Providers"

#ifndef NT5_FAX
// CometFax

// NEWFSP_PROVIDER is the newfsp registry key under the providers registry key
#define NEWFSP_PROVIDER                L"Many Rec VFsp"
// NEWFSP_PROVIDER_FRIENDLYNAME is the friendly name of the newfsp service provider
#define NEWFSP_PROVIDER_FRIENDLYNAME   L"Many Rec VFsp"
// NEWFSP_PROVIDER_IMAGENAME is the image name of the newfsp service provider
#define NEWFSP_PROVIDER_IMAGENAME      L"d:\\EFSP\\ManyRecVfsp\\ManyRecVFSP.dll"
// NEWFSP_PROVIDER_PROVIDERNAME is the provider name of the newfsp service provider
#define NEWFSP_PROVIDER_PROVIDERNAME   L"Many Rec VFsp"

#else // NT5_FAX
// NT5 Fax

// NEWFSP_PROVIDER is the newfsp registry key under the providers registry key
#define NEWFSP_PROVIDER                L"NT5 Many Rec VFsp"
// NEWFSP_PROVIDER_FRIENDLYNAME is the friendly name of the newfsp service provider
#define NEWFSP_PROVIDER_FRIENDLYNAME   L"NT5 Many Rec VFsp"
// NEWFSP_PROVIDER_IMAGENAME is the image name of the newfsp service provider
#define NEWFSP_PROVIDER_IMAGENAME      L"d:\\EFSP\\ManyRecVfsp\\NT5ManyRecVFSP.dll"
// NEWFSP_PROVIDER_PROVIDERNAME is the provider name of the newfsp service provider
#define NEWFSP_PROVIDER_PROVIDERNAME   L"NT5 Many Rec VFsp"

#endif //NT5_FAX

// NEWFSP_DEVICES is the virtual fax devices registry key under the newfsp registry key
#define NEWFSP_DEVICES                 L"Devices"

BOOL SetNewFspRegistryData( void );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\fsp\vfsp\macros.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  macros.h

Abstract:

  This module contains the global macros

--*/

#ifndef _MACROS_H
#define _MACROS_H

extern HANDLE  g_HeapHandle;  // g_HeapHandle is the global handle to the heap

// MemInitializeMacro is a macro to get the handle to the heap
#define MemInitializeMacro(hHeap) (g_HeapHandle = hHeap)

// MemAllocMacro is a macro to allocate dwBytes bytes of memory from the heap
#define MemAllocMacro(dwBytes) (HeapAlloc(g_HeapHandle, HEAP_GENERATE_EXCEPTIONS | HEAP_ZERO_MEMORY, dwBytes))

// MemReAllocMacro is a macro to reallocate dwBytes bytes of memory from the heap
#define MemReAllocMacro(lpMem, dwBytes) (HeapReAlloc(g_HeapHandle, HEAP_GENERATE_EXCEPTIONS | HEAP_ZERO_MEMORY, lpMem, dwBytes))

// MemFreeMacro is a macro to free a memory block allocated from the heap
#define MemFreeMacro(lpMem) (HeapFree(g_HeapHandle, 0, lpMem))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\fsp\manyrecvfsp\manyrecvfsp.cpp ===
//
// Module name:		ManyRecVFSP.cpp
// Module author:	Sigalit Bar (sigalitb)
// Date:			21-Dec-98
//



#include "vfsp.h"


void CALLBACK
MyLineCallback(
    IN HANDLE FaxHandle,
    IN DWORD hDevice,
    IN DWORD dwMessage,
    IN DWORD dwInstance,
    IN DWORD dwParam1,
    IN DWORD dwParam2,
    IN DWORD dwParam3
    )
{
	::lgLogDetail(
			LOG_X,
			1,
			TEXT("[ManyRecVFSP]MyLineCallback called with -\n\tFaxHandle=%d\n\thDevice=%d\n\tdwMessage=%d\n\tdwInstance=%d"),
			(DWORD)FaxHandle,
			hDevice,
			dwMessage,
			dwInstance
			);
    return;
}

 
BOOL WINAPI
FaxDevInitialize(
    IN  HLINEAPP LineAppHandle,
    IN  HANDLE HeapHandle,
    OUT PFAX_LINECALLBACK *LineCallbackFunction,
    IN  PFAX_SERVICE_CALLBACK FaxServiceCallback
    )
{

    ::lgLogDetail(LOG_X,1,TEXT("[ManyRecVFSP]Entry of FaxDevInitialize"));
	g_LineAppHandle = LineAppHandle;
    MemInitializeMacro(HeapHandle);
	_ASSERTE(NULL != LineCallbackFunction);
    *LineCallbackFunction = MyLineCallback;

    ::lgLogDetail(LOG_X,1,TEXT("[ManyRecVFSP]Exit of FaxDevInitialize"));
    return(TRUE);
}



BOOL WINAPI
FaxDevVirtualDeviceCreation(
    OUT LPDWORD	pdwDeviceCount,
    OUT LPWSTR  szDeviceNamePrefix,
    OUT LPDWORD pdwDeviceIdPrefix,
    IN  HANDLE	hCompletionPort,
    IN  DWORD	dwCompletionKey
    )
{
    ::lgLogDetail(LOG_X,1,TEXT("[ManyRecVFSP]Entry of FaxDevVirtualDeviceCreation"));
	_ASSERTE(NULL != pdwDeviceCount);
	_ASSERTE(NULL != szDeviceNamePrefix);
	_ASSERTE(NULL != pdwDeviceIdPrefix);

	//
	// internal data initializations
	//

	if (!::InitDeviceArray(g_myFaxDeviceVector, FSP_VDEV_LIMIT, hCompletionPort, dwCompletionKey))
	{
		::lgLogError(LOG_SEV_1,TEXT("[ManyRecVFSP] InitDeviceArray failed"));
		return(FALSE);
	}
	else
	{
		::lgLogDetail(LOG_X,1,TEXT("[ManyRecVFSP] InitDeviceArray success"));
		g_fDevicesInitiated = TRUE;
	}

	//
	// Set OUT parameters
	//

	//FAX BUG: remove the line bellow and svc will attempt to create
	//         "endless" device registry keys
	*pdwDeviceCount = FSP_VDEV_LIMIT;

    lstrcpyn(szDeviceNamePrefix, NEWFSP_DEVICE_NAME_PREFIX, 128);
    *pdwDeviceIdPrefix = NEWFSP_DEVICE_ID_PREFIX;

    ::lgLogDetail(LOG_X,1,TEXT("[ManyRecVFSP]Exit of FaxDevVirtualDeviceCreation"));
    return TRUE;
}



BOOL WINAPI
FaxDevStartJob(
    IN  HLINE	hLineHandle,
    IN  DWORD	dwDeviceId,
    OUT PHANDLE phFaxHandle,
    IN  HANDLE	hCompletionPortHandle,
    IN  DWORD	dwCompletionKey
    )
{

    ::lgLogDetail(LOG_X,1,TEXT("[ManyRecVFSP]Entry of FaxDevStartJob for device=%d"),dwDeviceId);
	_ASSERTE(NULL != phFaxHandle);

	CDevice* pDevice = g_myFaxDeviceVector.at(dwDeviceId);
	if (NULL == pDevice)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: g_myFaxDeviceVector.at(%d) returned NULL"),
			TEXT(__FILE__),
			__LINE__,
			dwDeviceId
			);
		*phFaxHandle = NULL;
		return(FALSE);
	}
	if (FALSE == pDevice->StartJob(phFaxHandle, hCompletionPortHandle, dwCompletionKey))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: theDevice->StartJob() failed"),
			TEXT(__FILE__),
			__LINE__
			);
		*phFaxHandle = NULL;
		return(FALSE);
	}

    ::lgLogDetail(LOG_X,1,TEXT("[ManyRecVFSP]Exit of FaxDevStartJob for device=%d"),dwDeviceId);
    return(TRUE);
}

BOOL GetJobAndDeviceFromHandle(
	IN HANDLE hFaxHandle, 
	OUT CDeviceJob** ppDeviceJob,
	OUT CDevice**		ppDevice
	)
{
    ::lgLogDetail(LOG_X,1,TEXT("[ManyRecVFSP]Entry of GetJobAndDeviceFromHandle"));

	BOOL fRetVal = FALSE;

	if (NULL == hFaxHandle)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: hFaxHandle is NULL"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
	}

	if (NULL == ppDeviceJob)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: ppDeviceJob is NULL"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
	}

	if (NULL == ppDevice)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: ppDevice is NULL"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
	}

	(*ppDeviceJob) = (CDeviceJob*)hFaxHandle;
	
	if (FALSE == (*ppDeviceJob)->GetDevicePtr(ppDevice))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: (*ppDeviceJob)->GetDevicePtr() failed"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
	}

	fRetVal = TRUE;

ExitFunc:
	return(fRetVal);
}

BOOL WINAPI
FaxDevEndJob(
    IN  HANDLE hFaxHandle
    )
{


    ::lgLogDetail(LOG_X,1,TEXT("[ManyRecVFSP]Entry of FaxDevEndJob"));

	if (NULL == hFaxHandle)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: hFaxHandle is NULL"),
			TEXT(__FILE__),
			__LINE__
			);
		return(FALSE);
	}

	CDeviceJob* pDeviceJob = NULL;
	CDevice* pDevice = NULL;

	if (FALSE == GetJobAndDeviceFromHandle(hFaxHandle,&pDeviceJob,&pDevice))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: pDeviceJob->GetDevicePtr() failed"),
			TEXT(__FILE__),
			__LINE__
			);
		return(FALSE);
	}
	
	_ASSERTE(NULL != pDeviceJob);
	_ASSERTE(NULL != pDevice);

	DWORD dwDeviceId = 0;
	if (FALSE == pDeviceJob->GetDeviceId(&dwDeviceId))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: pDeviceJob->GetDeviceId() failed"),
			TEXT(__FILE__),
			__LINE__
			);
		return(FALSE);

	}
    ::lgLogDetail(LOG_X,1,TEXT("[ManyRecVFSP]FaxDevEndJob for device=%d"),dwDeviceId);

	if (FALSE == pDevice->EndJob(pDeviceJob))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: pDevice->EndJob() failed"),
			TEXT(__FILE__),
			__LINE__
			);
		return(FALSE);
	}

    ::lgLogDetail(LOG_X,1,TEXT("[ManyRecVFSP]Exit of FaxDevEndJob for device=%d"),dwDeviceId);
    return(TRUE);
}



BOOL WINAPI
FaxDevSend(
    IN  HANDLE hFaxHandle,
    IN  PFAX_SEND pFaxSend,
    IN  PFAX_SEND_CALLBACK fnFaxSendCallback
    )
{
	BOOL fRetVal = FALSE;
	CDeviceJob* pDeviceJob = NULL;
	CDevice* pDevice = NULL;
	DWORD dwDeviceId = 0;

    ::lgLogDetail(LOG_X,1,TEXT("[ManyRecVFSP]Entry of FaxDevSend"));

	if (NULL == hFaxHandle)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: NULL == hFaxHandle"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
	}

	if (FALSE == GetJobAndDeviceFromHandle(hFaxHandle,&pDeviceJob,&pDevice))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: GetJobAndDeviceFromHandle failed"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
	}
	
	_ASSERTE(NULL != pDeviceJob);
	_ASSERTE(NULL != pDevice);

	if (FALSE == pDeviceJob->GetDeviceId(&dwDeviceId))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: pDeviceJob->GetDeviceId() failed"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
	}

    ::lgLogDetail(LOG_X,1,TEXT("[ManyRecVFSP]FaxDevSend for device=%d"),dwDeviceId);

	if (FALSE == pDevice->Send(pDeviceJob, pFaxSend, fnFaxSendCallback))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: pDevice->Send() failed"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
	}

	fRetVal= TRUE;

ExitFunc:
    ::lgLogDetail(
		LOG_X,
		1,
		TEXT("[ManyRecVFSP]Exit of FaxDevSend for device=%d. fRetVal=%d"),
		dwDeviceId,
		fRetVal
		);
    return(fRetVal);
}



BOOL WINAPI
FaxDevReceive(
    IN  HANDLE hFaxHandle,
    IN  HCALL CallHandle,
    IN OUT PFAX_RECEIVE pFaxReceive
    )
{
	BOOL fRetVal = FALSE;
	CDeviceJob* pDeviceJob = NULL;
	CDevice* pDevice = NULL;
	DWORD dwDeviceId = 0;

    ::lgLogDetail(LOG_X,1,TEXT("[ManyRecVFSP]Entry of FaxDevReceive"));

	if (NULL == hFaxHandle)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: NULL == hFaxHandle"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
	}

	if (FALSE == GetJobAndDeviceFromHandle(hFaxHandle,&pDeviceJob,&pDevice))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: GetJobAndDeviceFromHandle failed"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
	}
	
	_ASSERTE(NULL != pDeviceJob);
	_ASSERTE(NULL != pDevice);

	if (FALSE == pDeviceJob->GetDeviceId(&dwDeviceId))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: pDeviceJob->GetDeviceId() failed"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
	}

    ::lgLogDetail(LOG_X,1,TEXT("[ManyRecVFSP]FaxDevReceive for device=%d"),dwDeviceId);

	if (FALSE == pDevice->Receive(pDeviceJob, CallHandle, pFaxReceive))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: pDevice->Receive() failed"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
	}

	fRetVal= TRUE;

ExitFunc:
    ::lgLogDetail(
		LOG_X,
		1,
		TEXT("[ManyRecVFSP]Exit of FaxDevReceive for device=%d. fRetVal=%d"),
		dwDeviceId,
		fRetVal
		);
    return(fRetVal);
}


BOOL WINAPI
FaxDevAbortOperation(
    IN  HANDLE hFaxHandle
    )
{
	BOOL fRetVal = FALSE;
	CDeviceJob* pDeviceJob = NULL;
	CDevice* pDevice = NULL;
	DWORD dwDeviceId = 0;

    ::lgLogDetail(LOG_X,1,TEXT("[ManyRecVFSP]Entry of FaxDevAbortOperation"));

	if (NULL == hFaxHandle)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: NULL == hFaxHandle"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
	}

	if (FALSE == GetJobAndDeviceFromHandle(hFaxHandle,&pDeviceJob,&pDevice))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: GetJobAndDeviceFromHandle failed"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
	}
	
	_ASSERTE(NULL != pDeviceJob);
	_ASSERTE(NULL != pDevice);

	if (FALSE == pDeviceJob->GetDeviceId(&dwDeviceId))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: pDeviceJob->GetDeviceId() failed"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
	}

    ::lgLogDetail(LOG_X,1,TEXT("[ManyRecVFSP]FaxDevAbortOperation for device=%d"),dwDeviceId);

	if (FALSE == pDevice->AbortOperation(pDeviceJob))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: pDevice->AbortOperation() failed"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
	}

	fRetVal= TRUE;

ExitFunc:
    ::lgLogDetail(
		LOG_X,
		1,
		TEXT("[ManyRecVFSP]Exit of FaxDevAbortOperation for device=%d. fRetVal=%d"),
		dwDeviceId,
		fRetVal
		);
    return(fRetVal);
}


BOOL WINAPI
FaxDevReportStatus(
    IN  HANDLE			hFaxHandle OPTIONAL,
    OUT PFAX_DEV_STATUS pFaxStatus,
    IN  DWORD			dwFaxStatusSize,
    OUT LPDWORD			pdwFaxStatusSizeRequired
    )
{

	::lgLogDetail(LOG_X,1,TEXT("[ManyRecVFSP]Entry of FaxDevReportStatus"));

    // dwSize is the size of the completion packet
    DWORD         dwSize;
    // upString is the offset of the strings within the completion packet
    UINT_PTR      upStringOffset;

    if (hFaxHandle == NULL) 
	{
        // Set the error code
        SetLastError(ERROR_INVALID_HANDLE);
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: FaxHandle == NULL"),
			TEXT(__FILE__),
			__LINE__
			);
        return(FALSE);
    }

    if (pdwFaxStatusSizeRequired == NULL) 
	{
        // Set the error code
        SetLastError(ERROR_INVALID_PARAMETER);
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: pdwFaxStatusSizeRequired == NULL"),
			TEXT(__FILE__),
			__LINE__
			);
        return FALSE;
    }

    if ((pFaxStatus == NULL) && (dwFaxStatusSize != 0)) 
	{
        // Set the error code
        SetLastError(ERROR_INVALID_PARAMETER);
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: (FaxStatus == NULL) && (FaxStatusSize != 0)"),
			TEXT(__FILE__),
			__LINE__
			);
        return FALSE;
    }


    // Initialize the size of the completion packet
    dwSize = sizeof(FAX_DEV_STATUS);
    dwSize += (lstrlen(TEXT("CSI")) + 1) * sizeof(TCHAR);
    dwSize += (lstrlen(TEXT("CallerId")) + 1) * sizeof(TCHAR);
	dwSize += (lstrlen(TEXT("RoutingInfo")) + 1) * sizeof(TCHAR);

    // Set the calculated size of the buffer required to hold the completion packet
    *pdwFaxStatusSizeRequired = dwSize;

    if ((pFaxStatus == NULL) && (dwFaxStatusSize == 0)) 
	{
		::lgLogDetail(LOG_X,1,TEXT("[ManyRecVFSP]Exit of FaxDevReportStatus - TRUE"));
        return(TRUE);
    }

    if (dwFaxStatusSize < dwSize) 
	{
        // Set the error code
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: FaxStatusSize < dwSize"),
			TEXT(__FILE__),
			__LINE__
			);
        return(FALSE);
    }

    upStringOffset = sizeof(FAX_DEV_STATUS);

	_ASSERTE(NULL != pFaxStatus);
    pFaxStatus->SizeOfStruct = sizeof(FAX_DEV_STATUS);

	CDeviceJob* pDeviceJob = NULL;
	CDevice* pDevice = NULL;

	if (FALSE == GetJobAndDeviceFromHandle(hFaxHandle,&pDeviceJob,&pDevice))
	{
        SetLastError(E_INVALIDARG);
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: GetJobAndDeviceFromHandle() failed"),
			TEXT(__FILE__),
			__LINE__
			);
		return(FALSE);
	}
	
	_ASSERTE(NULL != pDeviceJob);
	_ASSERTE(NULL != pDevice);

	DWORD dwDeviceStatus = 0;
	if (FALSE == pDevice->GetDeviceStatus(&dwDeviceStatus))
	{
        SetLastError(E_INVALIDARG);
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: pDevice->GetDeviceStatus() failed"),
			TEXT(__FILE__),
			__LINE__
			);
		return(FALSE);
	}

    pFaxStatus->StatusId = dwDeviceStatus;
	::lgLogDetail(LOG_X,1,TEXT("[ManyRecVFSP]Entry of FaxDevReportStatus(): dwDeviceStatus=0x%08X"), dwDeviceStatus);
    pFaxStatus->StringId = 0;
    pFaxStatus->PageCount = 1;
	pFaxStatus->CSI = NULL;
    pFaxStatus->CSI = (LPTSTR) ((UINT_PTR) pFaxStatus + upStringOffset);
    if (NULL == lstrcpy(pFaxStatus->CSI, TEXT("CSI")))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: lstrcpy failed"),
			TEXT(__FILE__),
			__LINE__
			);
		return(FALSE);
	}
    upStringOffset += (lstrlen(TEXT("CSI")) + 1) * sizeof(TCHAR);
    pFaxStatus->CallerId = NULL;
    pFaxStatus->CallerId = (LPTSTR) ((UINT_PTR) pFaxStatus + upStringOffset);
    if (NULL == lstrcpy(pFaxStatus->CallerId, TEXT("CallerId")))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: lstrcpy failed"),
			TEXT(__FILE__),
			__LINE__
			);
		return(FALSE);
	}
    upStringOffset += (lstrlen(TEXT("CallerId")) + 1) * sizeof(TCHAR);
    pFaxStatus->RoutingInfo = NULL;
    pFaxStatus->RoutingInfo = (LPWSTR) ((UINT_PTR) pFaxStatus + upStringOffset);
    if (NULL == lstrcpy(pFaxStatus->RoutingInfo, TEXT("RoutingInfo")))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: lstrcpy failed"),
			TEXT(__FILE__),
			__LINE__
			);
		return(FALSE);
	}
    upStringOffset += (lstrlen(TEXT("RoutingInfo")) + 1) * sizeof(TCHAR);
    pFaxStatus->ErrorCode = ERROR_SUCCESS;

	::lgLogDetail(LOG_X,1,TEXT("[ManyRecVFSP]Exit of FaxDevReportStatus"));

	return(TRUE);
}



MODULEAPI
STDAPI DllRegisterServer()
/*++

Routine Description:

  Function for the in-process server to create its registry entries

Return Value:

  S_OK on success

--*/
{
    // hFaxSvcHandle is the handle to the fax server
    HANDLE                       hFaxSvcHandle;

	::lgLogDetail(LOG_X,1,TEXT("[ManyRecVFSP]Entry of DllRegisterServer"));


    // Connect to the fax server
    if (!FaxConnectFaxServer(NULL, &hFaxSvcHandle)) 
	{
		::lgLogError(LOG_SEV_1,TEXT("FaxConnectFaxServer failed"));
		::lgLogDetail(LOG_X,1,TEXT("DllRegisterServer exiting with E_UNEXPECTED"));
        return E_UNEXPECTED;
    }

    // Register the fax service provider
    if (!FaxRegisterServiceProvider(
			NEWFSP_PROVIDER, 
			NEWFSP_PROVIDER_FRIENDLYNAME, 
			NEWFSP_PROVIDER_IMAGENAME, 
			NEWFSP_PROVIDER_PROVIDERNAME
			)
		) 
	{
        // Close the connection to the fax server
        FaxClose(hFaxSvcHandle);

		::lgLogError(LOG_SEV_1,TEXT("FaxRegisterServiceProvider failed"));
		::lgLogDetail(LOG_X,1,TEXT("DllRegisterServer exiting with E_UNEXPECTED"));
        return E_UNEXPECTED;
    }

    // Close the connection to the fax server
    FaxClose(hFaxSvcHandle);

    // Set g_hHeap
    MemInitializeMacro(GetProcessHeap());

	::lgLogDetail(LOG_X,1,TEXT("[ManyRecVFSP]DllRegisterServer exiting with S_OK"));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\fsp\manyrecvfsp\vfsp.h ===
// Module name:		VFSP.h
// Module author:	Sigalit Bar (sigalitb)
// Date:			13-Dec-98


#ifndef _VFSP_H_
#define _VFSP_H_

#include <windows.h>
#include <stdio.h>
#include <tapi.h>
#include <faxdev.h>
#include <winfax.h>

#include "crtdbg.h"

#include "macros.h"
#include "reg.h"
#include "..\..\log\log.h"
#include "device.h"

#ifndef MODULEAPI
#define MODULEAPI __declspec(dllexport) 
#endif

#ifndef WINAPIV
#define WINAPIV __cdecl
#endif


#ifdef __cplusplus
extern "C" {
#endif


// MAX_PATH_LEN is the maximum length of a fully-qualified path without the filename
#define MAX_PATH_LEN               (MAX_PATH - 16)




extern HANDLE        g_hInstance;       // g_hInstance is the global handle to the module
extern HLINEAPP      g_LineAppHandle;   // g_LineAppHandle is the global handle to the fax service's registration with TAPI

extern CFaxDeviceVector g_myFaxDeviceVector;
extern BOOL g_fDevicesInitiated;
extern DWORD				g_dwSleepTime;

#define FSP_VDEV_LIMIT	10




#ifdef __cplusplus
}
#endif 

#endif //_VFSP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\fsp\vfsp\main.cpp ===
// Module name:		main.cpp
// Module author:	Sigalit Bar (sigalitb)
// Date:			13-Dec-98

// Description:
//
// Specifics:
//		  
// To Use:
//

//VFSP DLL header file

#include "VFSP.h"

#ifdef __cplusplus
extern "C" {
#endif

HANDLE			g_HeapHandle = NULL;		// g_HeapHandle is the global handle to the heap
HANDLE			g_hInstance = NULL;			// g_hInstance is the global handle to the module
HLINEAPP		g_LineAppHandle = NULL;		// g_LineAppHandle is the global handle to the fax service's registration with TAPI


// Vector containing the information for the virtual devices of the FSP
CFaxDeviceVector g_myFaxDeviceVector;		

// indicates whether devices were initiated
BOOL g_fDevicesInitiated = FALSE;			


long					g_lReceivedFaxes = 0;

DWORD					g_dwSleepTime = 1000;


BOOL WINAPI DllMain (HINSTANCE hInstance, DWORD fdwReason, LPVOID lpvReserved)
{
	switch (fdwReason)
	{
	case DLL_PROCESS_ATTACH:
		::lgInitializeLogger();
		::lgEnableLogging();
		::lgSetLogLevel(9);
		::lgBeginSuite(TEXT("Many Rec VFSP"));
		::lgBeginCase(1, TEXT("Many Rec VFSP"));
		g_hInstance = hInstance;
		::DisableThreadLibraryCalls( hInstance );
		break;

	case DLL_PROCESS_DETACH:
		::lgLogDetail(LOG_X,1,TEXT("g_lReceivedFaxes=%d"),g_lReceivedFaxes);
		if (TRUE == g_fDevicesInitiated) FreeDeviceArray(g_myFaxDeviceVector);
		::lgEndCase();
		::lgEndSuite();
		::lgCloseLogger();
		break;
	}
	return(TRUE);
}


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\fsp\manyrecvfsp\util.h ===
//
//
// Module name:		util.h
// Module author:	Sigalit Bar (sigalitb)
// Date:			13-Dec-98
//
//


#ifndef __UTIL_H_
#define __UTIL_H_

#include <stdlib.h>
#include <stdio.h>
#include <TCHAR.H>

#include <windows.h>
#include <crtdbg.h>

#include <tapi.h>
#include "faxdev.h"
#include "..\..\log\log.h"
#include "macros.h"

// Function definitions:

BOOL
PostJobStatus(
    HANDLE     CompletionPort,
    ULONG_PTR  CompletionKey,
    DWORD      StatusId,
    DWORD      ErrorCode
);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\fsp\manyrecvfsp\util.cpp ===
//
// Module name:		util.cpp
// Module author:	Sigalit Bar (sigalitb)
// Date:			13-Dec-98
//

#include "util.h"


BOOL
PostJobStatus(
    HANDLE     CompletionPort,
    ULONG_PTR  CompletionKey,
    DWORD      StatusId,
    DWORD      ErrorCode
)
/*++

Routine Description:

  Post a completion packet for a fax service provider fax job status change

Arguments:

  CompletionPort - specifies a handle to an I/O completion port
  CompletionKey - specifies a completion port key value
  StatusId - specifies a fax status code
  ErrorCode - specifies one of the Win32 error codes that the fax service provider should use to report an error that occurs

Return Value:

  TRUE on success

--*/
{
    // pFaxDevStatus is a pointer to the completion packet
    PFAX_DEV_STATUS  pFaxDevStatus;

    // Allocate a block of memory for the completion packet
    pFaxDevStatus = (FAX_DEV_STATUS *)MemAllocMacro(sizeof(FAX_DEV_STATUS));
    if (NULL == pFaxDevStatus) 
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: MemAllocMacro failed"),
			TEXT(__FILE__),
			__LINE__
			);
		return(FALSE);
	}

    pFaxDevStatus->SizeOfStruct = sizeof(FAX_DEV_STATUS);
    pFaxDevStatus->StatusId = StatusId;
    pFaxDevStatus->StringId = 0;
    pFaxDevStatus->PageCount = 0;
    pFaxDevStatus->CSI = NULL;
    pFaxDevStatus->CallerId = NULL;
    pFaxDevStatus->RoutingInfo = NULL;
    pFaxDevStatus->ErrorCode = ErrorCode;

    // Post the completion packet
    if (!PostQueuedCompletionStatus(
			CompletionPort, 
			sizeof(FAX_DEV_STATUS), 
			CompletionKey, (
			LPOVERLAPPED) pFaxDevStatus
			)
		)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: MemAllocMacro failed"),
			TEXT(__FILE__),
			__LINE__
			);
		return(FALSE);
	}

	return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\fsp\vfsp\device.cpp ===
//
//
// Filename:	device.cpp
// Author:		Sigalit Bar (sigalitb)
// Date:		6-Jan-99
//
//

#include "device.h"
#include "IniFileEntries.h"

// default seconds to sleep before posting message
const DWORD dwSleepDefaultValue = 0;
// default page number to simulte sending/receiving
const DWORD dwPageCountDefaultValue = 1;

/////////////////////////////////// CFaxDeviceVector ///////////////////////////////////////////////
DWORD WINAPI RingThread(LPVOID pVoid);

BOOL 
InitDeviceArray(
	IN OUT	CFaxDeviceVector&	aFaxDeviceArray,
	IN		DWORD				dwNumOfDevices,
    IN		HANDLE				hCompletionPort,
    IN		DWORD				dwCompletionKey
	)
{
    ::lgLogDetail(LOG_X,7,TEXT("{VFSP}[InitDeviceArray] Entry"));
    ::lgLogDetail(LOG_X,7,TEXT("{VFSP}[InitDeviceArray] dwNumOfDevices = %d"),dwNumOfDevices);

	DWORD i;
	for (i=0; i<dwNumOfDevices; i++)
	{
		CDevice* pDevice = new CDevice(i,hCompletionPort,dwCompletionKey);
		if (NULL == pDevice)
		{
			//TO DO: log fail
			::lgLogError(
				LOG_SEV_1,
				TEXT("%s[%d]: new failed"),
				TEXT(__FILE__),
				__LINE__
				);
			goto ExitFail;
		}
		if (FALSE == pDevice->CreateRingThread(RingThread, (LPVOID)i))
		{
			//TO DO: change assert to something better.
			_ASSERTE(FALSE);
		}
		aFaxDeviceArray.push_back(pDevice);
	}
    ::lgLogDetail(LOG_X,7,TEXT("{VFSP}[RingThread] Exit"));
	return(TRUE);

ExitFail:
	//cleanup array
	if (FALSE == FreeDeviceArray(aFaxDeviceArray))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: FreeDeviceArray failed"),
			TEXT(__FILE__),
			__LINE__
			);
	}
	else
	{
		::lgLogDetail(
			LOG_X,
			1,
			TEXT("%s[%d]: FreeDeviceArray succeeded"),
			TEXT(__FILE__),
			__LINE__
			);
	}
	return(FALSE);
}


BOOL 
FreeDeviceArray(IN OUT CFaxDeviceVector& aFaxDeviceArray)
{
    ::lgLogDetail(LOG_X,7,TEXT("{VFSP}[FreeDeviceArray] Entry"));

	DWORD i;
	DWORD dwNumOfDevices = aFaxDeviceArray.size();
    ::lgLogDetail(LOG_X,7,TEXT("{VFSP}[FreeDeviceArray] freeing %d devices"),dwNumOfDevices);
	for (i=0; i<dwNumOfDevices; i++)
	{
		delete (aFaxDeviceArray.at(i));
	}
	aFaxDeviceArray.clear();
    ::lgLogDetail(LOG_X,7,TEXT("{VFSP}[FreeDeviceArray] Exit"));
	return(TRUE);

	//Q: What about any "left over" jobs?
	//   We want to make sure they are all freed, so we will have to add a 
	//   ptr (array of ptrs for multi-send) from device to its job(s).
	//	 and free them here.
}

/////////////////////////////////////// CDevice ////////////////////////////////////////////////////

CDevice::CDevice(
	DWORD	dwDeviceId, 
	HANDLE	hDeviceCompletionPort,
	DWORD	dwDeviceCompletionKey,
	DWORD	dwDeviceStatus,
	long	lReceivedFaxes,
	long	lRing,
	HANDLE	hRingThread
	)
{
	::InitializeCriticalSection(&m_cs); 
	m_dwDeviceId = dwDeviceId;
	m_hDeviceCompletionPort = hDeviceCompletionPort;
	m_dwDeviceCompletionKey = dwDeviceCompletionKey;
	m_dwDeviceStatus = dwDeviceStatus;
	m_lReceivedFaxes = lReceivedFaxes;
	m_lRing = lRing;
	m_hRingThread = hRingThread;
}


CDevice::~CDevice(void)
{
	::InterlockedExchange(&m_lRing,0);
	DWORD dwWait;
	dwWait = ::WaitForSingleObject(m_hRingThread,RING_THREAD_TIMEOUT);
	//TO DO: check return value of WaitForSingleObject, for now ...
	if (WAIT_OBJECT_0 != dwWait)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: WaitForSingleObject != WAIT_OBJECT_0"),
			TEXT(__FILE__),
			__LINE__
			);
	}

	if (FALSE == ::CloseHandle(m_hRingThread))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: CloseHandle(m_hRingThread) failed for devId=%d"),
			TEXT(__FILE__),
			__LINE__,
			m_dwDeviceId
			);
	}

	//TO DO: check return value of CloseHandle
	//Q: need to close port handle? m_hDeviceCompletionPort

    ::DeleteCriticalSection(&m_cs);

	::lgLogDetail(
		LOG_X,
		1,
		TEXT("Device[%d].lReceivedFaxes=%d"),
		m_dwDeviceId,
		m_lReceivedFaxes
		);

}

BOOL CDevice::GetAllData(
	DWORD				dwDeviceId,
	HANDLE             hDeviceCompletionPort,
	DWORD              dwDeviceCompletionKey,
	DWORD              dwDeviceStatus,
	long               lReceivedFaxes,
	long               lRing,
	HANDLE             hRingThread)
{
	EnterCriticalSection(&m_cs);
		dwDeviceId = m_dwDeviceId;
		hDeviceCompletionPort = m_hDeviceCompletionPort;
		dwDeviceCompletionKey = m_dwDeviceCompletionKey;
		dwDeviceStatus = m_dwDeviceStatus;
		lReceivedFaxes = m_lReceivedFaxes;
		lRing = m_lRing;
		hRingThread = m_hRingThread;
	LeaveCriticalSection(&m_cs);
	return(TRUE);
}

BOOL CDevice::GetDeviceId(LPDWORD pdwDeviceId) const
{
	if (NULL == pdwDeviceId)
	{
		return(FALSE);
	}
	*pdwDeviceId = m_dwDeviceId;
	return(TRUE);
}

BOOL CDevice::GetDeviceStatus(LPDWORD pdwDeviceStatus) const
{
	if (NULL == pdwDeviceStatus)
	{
		return(FALSE);
	}
	*pdwDeviceStatus = m_dwDeviceStatus;
	return(TRUE);
}

long CDevice::GetRing(void) const
{
	return(m_lRing);
}

BOOL CDevice::CreateRingThread(LPTHREAD_START_ROUTINE fnThread, LPVOID pVoid)
{
	BOOL fRetVal = FALSE;

	EnterCriticalSection(&m_cs);
		if (NULL == m_hRingThread)
		{
			::lgLogDetail(LOG_X,4,TEXT("{VFSP}[CreateRingThread] CREATE THREAD for dwDeviceId=%d"),m_dwDeviceId);
			m_hRingThread = CreateThread(
				NULL, 
				0, 
				fnThread, 
				pVoid, 
				0, 
				NULL
				);
			if (NULL == m_hRingThread)
			{
				//this means we can't start the RingThread, so for now
				::lgLogDetail(
					LOG_X,
					1,
					TEXT("{VFSP}[CreateRingThread] CreateThread for a_Devices[%d].hRingThread failed"),
					m_dwDeviceId
					);
				goto ExitFunc;
			}
		}

		fRetVal = TRUE;

ExitFunc:
	LeaveCriticalSection(&m_cs);
	return(fRetVal);
}

//
// StartJob:
//	Starts a job (outbound or inbound) on the device.
//	This function is invoked from the VFSP's FaxDevStartJob() function.
//	Where FaxDevStartJob HANDLE hCompletionPortHandle (4th param) is passed on,
//	so is dwCompletionKey (5th param) and PHANDLE pFaxHandle (3rd OUT param) is
//	passed on to be created here (it is set to point at a CDeviceJob that represents
//	the started job on the device).
//
BOOL CDevice::StartJob(
	OUT PHANDLE	phFaxHandle, 
	IN	HANDLE	hCompletionPortHandle, 
	IN	DWORD	dwCompletionKey
	)
{

	BOOL fRetVal = FALSE;
	if (NULL == phFaxHandle)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: phFaxHandle == NULL"),
			TEXT(__FILE__),
			__LINE__
			);
		return(FALSE);
	}

    EnterCriticalSection(&m_cs);
		CDeviceJob* pDeviceJob = new CDeviceJob(
			this,
			hCompletionPortHandle,
			dwCompletionKey
			);
		if (NULL == pDeviceJob)
		{
			::lgLogError(
				LOG_SEV_1,
				TEXT("%s[%d]: new CDeviceJob() failed"),
				TEXT(__FILE__),
				__LINE__
				);
			goto ExitFunc;
		}

		m_dwDeviceStatus = DEVICE_START;
		//m_pDeviceJob = pDeviceJob;

		*phFaxHandle = (PHANDLE)pDeviceJob;
		fRetVal = TRUE;

ExitFunc:
    LeaveCriticalSection(&m_cs);
	return(fRetVal);
}

//
// EndJob:
//	Ends job pDeviceJob on the device.
//	This function is invoked from the VFSP's FaxDevEndJob() function,
//	where pDeviceJob is extracted from FaxDevEndJob() HANDLE FaxHandle param.
//
BOOL CDevice::EndJob(CDeviceJob* pDeviceJob)
{
    EnterCriticalSection(&m_cs);
		m_dwDeviceStatus = DEVICE_IDLE;
		delete (pDeviceJob);
		//on a multi-send device we
		//may want to do more here
    LeaveCriticalSection(&m_cs);
	return(TRUE);
}

//
// Send:
//	Sends the outbound job pDeviceJob on the device.
//	This function is invoked from the VFSP's FaxDevSend() function.
//	Where pDeviceJob is extracted from the FaxDevSend() HANDLE FaxHandle (1st param),
//	pFaxSend (2nd param) is passed on, and so is fnFaxSendCallback (3rd param).
//
BOOL CDevice::Send(
	IN OUT	CDeviceJob*			pDeviceJob,
    IN		PFAX_SEND			pFaxSend,
    IN		PFAX_SEND_CALLBACK	fnFaxSendCallback
	)
{
	BOOL fRetVal = FALSE;
	BOOL fTempRetVal = FALSE;
	HANDLE hJobCompletionPort = NULL;
	DWORD  dwJobCompletionKey = 0;
	DWORD dwJobStatus = FS_FATAL_ERROR;
	DWORD dwPageCount = 1;
	DWORD dwBeforeInitializeSleep = 0;
	DWORD dwBetweenPagesSleep =0;
	DWORD dwBeforeCompletedSleep = 0;
	DWORD dwAfterCompletedSleep = 0;
	DWORD dwBeforeAbortSleep = 0;
	DWORD dwIntRetValue = 0;

	if (NULL == pDeviceJob)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: NULL == pDeviceJob"),
			TEXT(__FILE__),
			__LINE__
			);
		return(FALSE);
	}

	//
	// get the job's port and key
	//
	if(FALSE == pDeviceJob->GetJobCompletionPort(&hJobCompletionPort))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: pDeviceJob->GetJobCompletionPort() failed"),
			TEXT(__FILE__),
			__LINE__
			);
		return(FALSE);
	}
	if(FALSE == pDeviceJob->GetJobCompletionKey(&dwJobCompletionKey))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: pDeviceJob->GetJobCompletionKey() failed"),
			TEXT(__FILE__),
			__LINE__
			);
		return(FALSE);
	}

	// If the device has its own parameters entry in the ini file use it
	// otherwise use the default device entry
	TCHAR DeviceSendSectionName[MAX_PATH];
	TCHAR dummybuff[4];
	_stprintf(DeviceSendSectionName,TEXT("%s%d"),DEVICE_SEND_SEC_PREFIX,m_dwDeviceId);
	DWORD dwIniQueryRet = GetPrivateProfileSection(DeviceSendSectionName,
												   dummybuff,
												   4,
												   VFSPIniFile);
	// device private section wasn't found
	if(!dwIniQueryRet)
	{
		_tcscpy(DeviceSendSectionName, DEFAULT_SEND_SECTION);
	}

	// get number of pages to simulate sending, from ini file   
	dwIntRetValue =  GetPrivateProfileInt( DeviceSendSectionName,
										   TEXT("PageCount"),
										   -1,
										   VFSPIniFile);
	dwPageCount =  (dwIntRetValue != -1) ? dwIntRetValue : dwPageCountDefaultValue;

	// get seconds to sleep before abort, from ini file   
	dwIntRetValue =  GetPrivateProfileInt( DeviceSendSectionName,
										   TEXT("BeforeAbortSleep"),
										   -1,
										   VFSPIniFile);
	dwBeforeAbortSleep =  (dwIntRetValue != -1) ? dwIntRetValue : dwSleepDefaultValue;

	//
	// initialization
	//

	// get seconds to sleep before posting initializing message,from ini file
    dwIntRetValue =  GetPrivateProfileInt( DeviceSendSectionName,
										   TEXT("BeforeInitializeSleep"),
										   -1,
										   VFSPIniFile);
	dwBeforeInitializeSleep =  (dwIntRetValue != -1) ? dwIntRetValue : dwSleepDefaultValue;
	
	Sleep(1000 * dwBeforeInitializeSleep);

    EnterCriticalSection(&m_cs);
	if (DEVICE_ABORTING == m_dwDeviceStatus) 
	{
		Sleep(1000* dwBeforeAbortSleep);
		dwJobStatus = FS_USER_ABORT;
		LeaveCriticalSection(&m_cs);
		goto ExitFalse;
	}
	
	m_dwDeviceStatus = DEVICE_SEND;
	fTempRetVal = pDeviceJob->SetJobStatus(FS_INITIALIZING);
    LeaveCriticalSection(&m_cs);
	if(FALSE == fTempRetVal)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: pDeviceJob->SetJobStatus(FS_INITIALIZING) failed"),
			TEXT(__FILE__),
			__LINE__
			);
		dwJobStatus = FS_FATAL_ERROR;
		goto ExitFalse;
	}

	// post status
    if (!PostJobStatus(
			hJobCompletionPort, 
			dwJobCompletionKey, 
			FS_INITIALIZING, 
			ERROR_SUCCESS
			)
		)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: PostJobStatus failed"),
			TEXT(__FILE__),
			__LINE__
			);
		dwJobStatus = FS_FATAL_ERROR;
		goto ExitFalse;
	}


	// get seconds to sleep between pages sending, from ini file
	dwIntRetValue =  GetPrivateProfileInt( DeviceSendSectionName,
										   TEXT("BetweenPagesSleep"),
										   -1,
										   VFSPIniFile);
	dwBetweenPagesSleep =  (dwIntRetValue != -1) ? dwIntRetValue : dwSleepDefaultValue;

	DWORD dwLoopIndex;
	for (dwLoopIndex = 0; dwLoopIndex < dwPageCount; dwLoopIndex++)
	{

		//
		// transmission
		//
		Sleep(1000 * dwBetweenPagesSleep);
		
		EnterCriticalSection(&m_cs);
		if (DEVICE_ABORTING == m_dwDeviceStatus) 
		{
			Sleep(1000 * dwBeforeAbortSleep);

			dwJobStatus = FS_USER_ABORT;
			LeaveCriticalSection(&m_cs);
			goto ExitFalse;
		}
		
		m_dwDeviceStatus = DEVICE_SEND;
		fTempRetVal = pDeviceJob->SetJobStatus(FS_TRANSMITTING);
		LeaveCriticalSection(&m_cs);
		if(FALSE == fTempRetVal)
		{
			::lgLogError(
				LOG_SEV_1,
				TEXT("%s[%d]: pDeviceJob->SetJobStatus(FS_TRANSMITTING) failed"),
				TEXT(__FILE__),
				__LINE__
				);
			dwJobStatus = FS_FATAL_ERROR;
			goto ExitFalse;
		}
		
		// post status
		if (!PostJobStatus(
				hJobCompletionPort, 
				dwJobCompletionKey, 
				FS_TRANSMITTING, 
				ERROR_SUCCESS
				)
			)
		{
			::lgLogError(
				LOG_SEV_1,
				TEXT("%s[%d]: PostJobStatus failed"),
				TEXT(__FILE__),
				__LINE__
				);
			dwJobStatus = FS_FATAL_ERROR;
			goto ExitFalse;
		}

	} // for (dwLoopIndex = 0; dwLoopIndex < dwPageCount; dwLoopIndex++)

	//
	// completion
	//

	// get seconds to sleep before posting completed message, from ini file
	dwIntRetValue =  GetPrivateProfileInt( DeviceSendSectionName,
										   TEXT("BeforeCompletedSleep"),
										   -1,
										   VFSPIniFile);
	dwBeforeCompletedSleep =  (dwIntRetValue != -1) ? dwIntRetValue : dwSleepDefaultValue;
	
	Sleep(1000 * dwBeforeCompletedSleep);

	EnterCriticalSection(&m_cs);
	if (DEVICE_ABORTING == m_dwDeviceStatus) 
	{
		Sleep(1000 * dwBeforeAbortSleep);

		dwJobStatus = FS_USER_ABORT;
	    LeaveCriticalSection(&m_cs);
		goto ExitFalse;
	}

	m_dwDeviceStatus = DEVICE_SEND;
	fTempRetVal = pDeviceJob->SetJobStatus(FS_COMPLETED);
    LeaveCriticalSection(&m_cs);
	if(FALSE == fTempRetVal)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: pDeviceJob->SetJobStatus(FS_COMPLETED) failed"),
			TEXT(__FILE__),
			__LINE__
			);
		dwJobStatus = FS_FATAL_ERROR;
		goto ExitFalse;
	}

	// post status
    if (!PostJobStatus(
			hJobCompletionPort, 
			dwJobCompletionKey, 
			FS_COMPLETED, 
			ERROR_SUCCESS
			)
		)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: PostJobStatus failed"),
			TEXT(__FILE__),
			__LINE__
			);
		dwJobStatus = FS_FATAL_ERROR;
		goto ExitFalse;
	}

	// get seconds to sleep after posting completed message, from ini file
	dwIntRetValue =  GetPrivateProfileInt( DeviceSendSectionName,
										   TEXT("AfterCompletedSleep"),
										   -1,
										   VFSPIniFile);
	dwAfterCompletedSleep =  (dwIntRetValue != -1) ? dwIntRetValue : dwSleepDefaultValue;
	
	Sleep(1000* dwAfterCompletedSleep);


    ::lgLogDetail(
		LOG_X,
		1,
		TEXT("{VFSP}[CDevice:Send] Exit with TRUE")
		);

    return(TRUE);


ExitFalse:
	EnterCriticalSection(&m_cs);
	if(FALSE == pDeviceJob->SetJobStatus(dwJobStatus))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: pDeviceJob->SetJobStatus(%d) failed"),
			TEXT(__FILE__),
			__LINE__,
			dwJobStatus
			);
	}
	LeaveCriticalSection(&m_cs);

	//post status
    if (!PostJobStatus(
			hJobCompletionPort, 
			dwJobCompletionKey, 
			dwJobStatus, 
			ERROR_SUCCESS
			)
		)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: PostJobStatus failed"),
			TEXT(__FILE__),
			__LINE__
			);
	}
//	Sleep(3000);

    ::lgLogDetail(
		LOG_X,
		1,
		TEXT("{VFSP}[CDevice:Send] Exit with FALSE")
		);
	return(FALSE);
}

//
// Receive:
//	Receive an inbound job (pDeviceJob) on the device
//	This method is invoked from the VFSP's FaxDevReceive() function.
//	Where pDeviceJob is extracted from FaxDevReceive() HANDLE FaxHandle (1st param),
//	CallHandle (2nd param) is passed on and so is pFaxReceive (3rd param).
// 
BOOL CDevice::Receive(
	IN OUT	CDeviceJob*		pDeviceJob,
    IN		HCALL			CallHandle,
    IN OUT	PFAX_RECEIVE	pFaxReceive
	)
{
	BOOL fRetVal = FALSE;
	BOOL fTempRetVal = FALSE;
	HANDLE hJobCompletionPort = NULL;
	DWORD  dwJobCompletionKey = 0;
	DWORD dwJobStatus = FS_FATAL_ERROR;
	DWORD dwBeforeInitializeSleep = 0;
	DWORD dwBeforeCompletedSleep = 0;
	DWORD dwAfterCompletedSleep = 0;
	DWORD dwBeforeAbortSleep = 0;
	DWORD dwIntRetValue = 0;

	if (NULL == pDeviceJob)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: NULL == pDeviceJob"),
			TEXT(__FILE__),
			__LINE__
			);
		return(FALSE);
	}

	//
	// get the job's port and key
	//
	if(FALSE == pDeviceJob->GetJobCompletionPort(&hJobCompletionPort))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: pDeviceJob->GetJobCompletionPort() failed"),
			TEXT(__FILE__),
			__LINE__
			);
		return(FALSE);
	}
	if(FALSE == pDeviceJob->GetJobCompletionKey(&dwJobCompletionKey))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: pDeviceJob->GetJobCompletionKey() failed"),
			TEXT(__FILE__),
			__LINE__
			);
		return(FALSE);
	}

	// If the device has its own parameters entry in the ini file use it
	// otherwise use the default device entry
	TCHAR DeviceReceiveSectionName[MAX_PATH];
	TCHAR dummybuff[4];
	_stprintf(DeviceReceiveSectionName,TEXT("%s%d"),DEVICE_RECEIVE_SEC_PREFIX,m_dwDeviceId);
	DWORD dwIniQueryRet = GetPrivateProfileSection(DeviceReceiveSectionName,
												   dummybuff,
												   4,
												   VFSPIniFile);
	// device private section wasn't found
	if(!dwIniQueryRet)
	{
		_tcscpy(DeviceReceiveSectionName, DEFAULT_RECEIVE_SECTION);
	}

	// get seconds to sleep before abort, from ini file   
	dwIntRetValue =  GetPrivateProfileInt( DeviceReceiveSectionName,
										   TEXT("BeforeAbortSleep"),
										   -1,
										   VFSPIniFile);
	dwBeforeAbortSleep =  (dwIntRetValue != -1) ? dwIntRetValue : dwSleepDefaultValue;

		
	//
	// initialization
	//

	// get seconds to sleep before posting initializing message,from ini file
    dwIntRetValue =  GetPrivateProfileInt( DeviceReceiveSectionName,
										   TEXT("BeforeInitializeSleep"),
										   -1,
										   VFSPIniFile);
	dwBeforeInitializeSleep =  (dwIntRetValue != -1) ? dwIntRetValue : dwSleepDefaultValue;

	Sleep(1000 * dwBeforeInitializeSleep);
    EnterCriticalSection(&m_cs);

	if (DEVICE_ABORTING == m_dwDeviceStatus) 
	{
		Sleep(1000 * dwBeforeAbortSleep);

		dwJobStatus = FS_USER_ABORT;
		LeaveCriticalSection(&m_cs);
		goto ExitFalse;
	}

	m_dwDeviceStatus = DEVICE_RECEIVE;
	fTempRetVal = pDeviceJob->SetJobStatus(FS_ANSWERED);
    LeaveCriticalSection(&m_cs);
	
	if(FALSE == fTempRetVal)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: pDeviceJob->SetJobStatus(FS_ANSWERED) failed"),
			TEXT(__FILE__),
			__LINE__
			);
		dwJobStatus = FS_FATAL_ERROR;
		goto ExitFalse;
	}


	// post status
    if (!PostJobStatus(
			hJobCompletionPort, 
			dwJobCompletionKey, 
			FS_ANSWERED, 
			ERROR_SUCCESS
			)
		)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: PostJobStatus failed"),
			TEXT(__FILE__),
			__LINE__
			);
		dwJobStatus = FS_FATAL_ERROR;
		goto ExitFalse;
	}

	//Sleep(500);

	
	//
	// receive
	//
	EnterCriticalSection(&m_cs);
	
	m_dwDeviceStatus = DEVICE_RECEIVE;
	fTempRetVal = pDeviceJob->SetJobStatus(FS_RECEIVING);
	LeaveCriticalSection(&m_cs);
	if(FALSE == fTempRetVal)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: pDeviceJob->SetJobStatus(FS_RECEIVING) failed"),
			TEXT(__FILE__),
			__LINE__
			);
		dwJobStatus = FS_FATAL_ERROR;
		goto ExitFalse;
	}


	// post status
	if (!PostJobStatus(
			hJobCompletionPort, 
			dwJobCompletionKey, 
			FS_RECEIVING, 
			ERROR_SUCCESS
			)
		)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: PostJobStatus failed"),
			TEXT(__FILE__),
			__LINE__
			);
		dwJobStatus = FS_FATAL_ERROR;
		goto ExitFalse;
	}

	// actual receive
	_ASSERTE(NULL != pFaxReceive);
	if (NULL == pFaxReceive->FileName)
	{
		::lgLogError(LOG_SEV_1,TEXT("BUG: FaxSvc gave NULL == pFaxReceive->FileName"));
		_ASSERTE(FALSE);
	}

	// Search the ini file for the file path that will be copied
	TCHAR tstrReceiveFilePath[MAX_PATH];
	dwIniQueryRet = GetPrivateProfileString( GENERAL_PARAMS,
											 TEXT("RECVFSP_FILENAME "), 
											 TEXT("NOT FOUND"),
											 tstrReceiveFilePath, 
											 MAX_PATH,
											 VFSPIniFile);

	if( !dwIniQueryRet || !_tcscmp(tstrReceiveFilePath, TEXT("NOT FOUND")))
	{
		_tcscpy(tstrReceiveFilePath, RECVFSP_FILENAME);
	}

	//also check strlen > 0
	if (!CopyFile(tstrReceiveFilePath, pFaxReceive->FileName, FALSE)) //overwrite the 0K file 
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("{VFSP}[CDevice:Receive]CopyFile failed with err=%d"),
			::GetLastError());
		_ASSERTE(FALSE);
	}


	//
	// completion
	//

	// get seconds to sleep before posting completed message, from ini file
	dwIntRetValue =  GetPrivateProfileInt( DeviceReceiveSectionName,
										   TEXT("BeforeCompletedSleep"),
										   -1,
										   VFSPIniFile);
	dwBeforeCompletedSleep =  (dwIntRetValue != -1) ? dwIntRetValue : dwSleepDefaultValue;
	Sleep(1000 * dwBeforeCompletedSleep);

	EnterCriticalSection(&m_cs);

	if (DEVICE_ABORTING == m_dwDeviceStatus) 
	{
		
		Sleep(1000 * dwBeforeAbortSleep);

		dwJobStatus = FS_USER_ABORT;
		LeaveCriticalSection(&m_cs);
		goto ExitFalse;
	}

	m_dwDeviceStatus = DEVICE_RECEIVE;
	fTempRetVal = pDeviceJob->SetJobStatus(FS_COMPLETED);
	m_lReceivedFaxes++;
    LeaveCriticalSection(&m_cs);
	if(FALSE == fTempRetVal)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: pDeviceJob->SetJobStatus(FS_COMPLETED) failed"),
			TEXT(__FILE__),
			__LINE__
			);
		dwJobStatus = FS_FATAL_ERROR;
		goto ExitFalse;
	}

	// post status
    if (!PostJobStatus(
			hJobCompletionPort, 
			dwJobCompletionKey, 
			FS_COMPLETED, 
			ERROR_SUCCESS
			)
		)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: PostJobStatus failed"),
			TEXT(__FILE__),
			__LINE__
			);
		dwJobStatus = FS_FATAL_ERROR;
		goto ExitFalse;
	}

	// get seconds to sleep after posting completed message, from ini file
	dwIntRetValue =  GetPrivateProfileInt( DeviceReceiveSectionName,
										   TEXT("AfterCompletedSleep"),
										   -1,
										   VFSPIniFile);
	dwAfterCompletedSleep =  (dwIntRetValue != -1) ? dwIntRetValue : dwSleepDefaultValue;
	Sleep(1000 * dwAfterCompletedSleep);

    ::lgLogDetail(
		LOG_X,
		1,
		TEXT("{VFSP}[CDevice:Receive] Exit with TRUE")
		);

	//m_dwDeviceStatus = DEVICE_IDLE;
    return(TRUE);


ExitFalse:
	EnterCriticalSection(&m_cs);
	if(FALSE == pDeviceJob->SetJobStatus(dwJobStatus))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: pDeviceJob->SetJobStatus(%d) failed"),
			TEXT(__FILE__),
			__LINE__,
			dwJobStatus
			);
	}
	LeaveCriticalSection(&m_cs);

	//post status
    if (!PostJobStatus(
			hJobCompletionPort, 
			dwJobCompletionKey, 
			dwJobStatus, 
			ERROR_SUCCESS
			)
		)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: PostJobStatus failed"),
			TEXT(__FILE__),
			__LINE__
			);
	}
	//m_dwDeviceStatus = DEVICE_IDLE;
	// Sleep(3000);

    ::lgLogDetail(
		LOG_X,
		1,
		TEXT("{VFSP}[CDevice:Receive] Exit with FALSE")
		);
	return(FALSE);
}

//
// AbortOperation:
//	Aborts job pDeviceJob on the device.
//	This function is invoked from the VFSP's FaxDevAbortOperation() function.
//	Where pDeviceJob is extracted from FaxDevAbortOperation() HANDLE FaxHandle param.
//	
BOOL CDevice::AbortOperation(IN OUT	CDeviceJob*	pDeviceJob)
{

	if (NULL == pDeviceJob)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: NULL == pDeviceJob"),
			TEXT(__FILE__),
			__LINE__
			);
		return(FALSE);
	}

    EnterCriticalSection(&m_cs);
		m_dwDeviceStatus = DEVICE_ABORTING;
		//for a multi-send device we may want to do more here
    LeaveCriticalSection(&m_cs);

    return(TRUE);
}

//
// PostRingEvent:
//	Posts a LINEDEVSTATE_RINGING massege on the device's completion port.
//	=> tells the Fax Service that the device is ringing.
//
BOOL CDevice::PostRingEvent(void)
{
	BOOL fReturnValue = FALSE;

	::lgLogDetail(LOG_X,1,TEXT("CDevice::PostRingEvent entry for device=%d"), m_dwDeviceId);

    // pLineMessage is a pointer to LINEMESSAGE structure 
	// to signal an incoming fax transmission to the fax service
    LPLINEMESSAGE  pLineMessage = NULL;


	// check if device is idle
	if (DEVICE_IDLE != m_dwDeviceStatus) 
	{
		::lgLogDetail(
			LOG_X,
			1,
			TEXT("DEVICE_IDLE != m_dwDeviceStatus (device=%d)"),
			m_dwDeviceId
			);
		goto ExitFunc;
	}

	//
	// post the ring event
	//

	// Allocate a block of memory for the completion packet
	pLineMessage = (LPLINEMESSAGE)LocalAlloc(LPTR, sizeof(LINEMESSAGE));
	if( NULL == pLineMessage )
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: LocalAlloc failed (device=%d)"),
			TEXT(__FILE__),
			__LINE__,
			m_dwDeviceId
			);
		goto ExitFunc;
	}
	// Initialize the completion packet
	// Set the completion packet's handle to the virtual fax device
	pLineMessage->hDevice = m_dwDeviceId + VFSP_DEVICE_ID_PREFIX;
	// Set the completion packet's virtual fax device message
	pLineMessage->dwMessageID = 0;
	// Set the completion packet's instance data
	pLineMessage->dwCallbackInstance = 0;
	// Set the completion packet's first parameter
	pLineMessage->dwParam1 = LINEDEVSTATE_RINGING;
	// Set the completion packet's second parameter
	pLineMessage->dwParam2 = 0;
	// Set the completion packet's third parameter
	pLineMessage->dwParam3 = 0;

	// Post the completion packet
	if (! PostQueuedCompletionStatus(
			m_hDeviceCompletionPort, 
			sizeof(LINEMESSAGE), 
			m_dwDeviceCompletionKey, 
			(LPOVERLAPPED) pLineMessage
			)
		)
	{
		::lgLogDetail(
			LOG_X,
			1,
			TEXT("PostQueuedCompletionStatus(LINEDEVSTATE_RINGING) failed for device %d"),
			m_dwDeviceId
			);
		if (NULL != LocalFree(pLineMessage)) //LocalFree returns NULL if successfull
		{
			::lgLogError(
				LOG_SEV_1,
				TEXT("%s[%d]: LocalFree failed (device=%d)"),
				TEXT(__FILE__),
				__LINE__,
				m_dwDeviceId
				);
		}
		goto ExitFunc;
	}

	fReturnValue = TRUE;

ExitFunc:

	::lgLogDetail(
		LOG_X,
		1,
		TEXT("PostRingEvent (for device %d) exits with %d"),
		m_dwDeviceId,
		fReturnValue
		);

    return(fReturnValue);
}

///////////////////////////////////// CDeviceJob //////////////////////////////////////////////////

CDeviceJob::CDeviceJob(
	CDevice*	pDevicePtr,
	HANDLE		hJobCompletionPort,
	DWORD		dwJobCompletionKey,
	DWORD		dwJobType,
	DWORD		dwJobStatus)
{
	_ASSERTE(NULL != pDevicePtr);
	m_pDevicePtr = pDevicePtr;
	m_hJobCompletionPort = hJobCompletionPort;
	m_dwJobCompletionKey = dwJobCompletionKey;
	m_dwJobType = dwJobType;
	m_dwJobStatus = dwJobStatus;
}

CDeviceJob::~CDeviceJob(void)
{
}

BOOL CDeviceJob::GetDevicePtr(CDevice** ppDevicePtr) const
{
	BOOL fRetVal = FALSE;

	if (NULL == ppDevicePtr)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: NULL == ppDevicePtr"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
	}
	*ppDevicePtr = m_pDevicePtr;
	fRetVal = TRUE;

ExitFunc:
	return(fRetVal);
}

BOOL CDeviceJob::GetDeviceId(LPDWORD pdwDeviceId) const
{
	BOOL fRetVal = FALSE;

	if (NULL == m_pDevicePtr)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: NULL == m_pDevicePtr"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
	}
	if (NULL == pdwDeviceId)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: NULL == pdwDeviceId"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
	}
	fRetVal = m_pDevicePtr->GetDeviceId(pdwDeviceId);

ExitFunc:
	return(fRetVal);
}

BOOL CDeviceJob::GetJobCompletionPort(OUT PHANDLE phJobCompletionPort) const
{
	if (NULL == phJobCompletionPort)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: NULL == phJobCompletionPort"),
			TEXT(__FILE__),
			__LINE__
			);
		return(FALSE);
	}

	(*phJobCompletionPort) = m_hJobCompletionPort;
	return(TRUE);
}

BOOL CDeviceJob::GetJobCompletionKey(OUT LPDWORD pdwJobCompletionKey) const
{
	if (NULL == pdwJobCompletionKey)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: NULL == pdwJobCompletionKey"),
			TEXT(__FILE__),
			__LINE__
			);
		return(FALSE);
	}

	(*pdwJobCompletionKey) = m_dwJobCompletionKey;
	return(TRUE);
}


BOOL CDeviceJob::SetJobStatus(DWORD dwJobStatus)
{
	//Always surround a call to this func with the job's device m_cs
	// EnterCriticalSection(&m_cs) and LeaveCriticalSection(&m_cs)
	m_dwJobStatus = dwJobStatus;
	return(TRUE);
}

BOOL CDeviceJob::GetJobStatus(LPDWORD pdwJobStatus)
{
	if (NULL == pdwJobStatus)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: NULL == pdwJobStatus"),
			TEXT(__FILE__),
			__LINE__
			);
		return(FALSE);
	}
	(*pdwJobStatus) = m_dwJobStatus;
	return(TRUE);
}

/////////////////////// Device Ring Thread //////////////////////////

DWORD WINAPI RingThread(LPVOID pVoid)
{

	::lgLogDetail(LOG_X,1,TEXT("RingThread entry"));

    // Copy the virtual fax device identifier
    DWORD dwDeviceId = (DWORD) pVoid;

	::lgLogDetail(LOG_X,1,TEXT("RingThread (for device %d)"),dwDeviceId);

	// get pDevice
	CDevice* pDevice = NULL;
	pDevice = g_myFaxDeviceVector.at(dwDeviceId);
	_ASSERTE(NULL != pDevice);


	//::lgLogDetail(LOG_X,1,TEXT("RingThread (for device %d) sleeping for 10 sec"),dwDeviceId);
	//Sleep(10000); //wait a little before you start

	srand( (unsigned)dwDeviceId*200 );

	DWORD dwRandSleep = (rand())%MAX_RAND_SLEEP + MIN_INITIALIZE_SLEEP; //random sleep time (up to MAX_RAND_SLEEP ms)
	::lgLogDetail(LOG_X,1,TEXT("RingThread (for device %d) sleeping for %d sec"),dwDeviceId, dwRandSleep);
	Sleep(dwRandSleep); //wait a little before you start

	while(pDevice->GetRing())
	{
		// TO DO: get bool enableRing from ini file
		// if enabled 
		//{
			if (FALSE == pDevice->PostRingEvent())
			{
				::lgLogDetail(
					LOG_X,
					1,
					TEXT("pDevice->PostRingEvent failed (for device %d)"),
					dwDeviceId
					);
			}
			else
			{
				::lgLogDetail(
					LOG_X,
					1,
					TEXT("pDevice->PostRingEvent succeeded (for device %d)"),
					dwDeviceId
					);
			}
		//} // TO DO
		dwRandSleep = (rand() % MAX_RAND_SLEEP) + MIN_RAND_SLEEP;
		::lgLogDetail(
			LOG_X,
			1,
			TEXT("Device(%d) sleeping for %d ms"),
			dwDeviceId,
			dwRandSleep
			);
		Sleep(dwRandSleep);
	}

	::lgLogDetail(LOG_X,1,TEXT("RingThread (for device %d) exit"),dwDeviceId);
	return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\fsp\vfsp\util.h ===
//
//
// Module name:		util.h
// Module author:	Sigalit Bar (sigalitb)
// Date:			13-Dec-98
//
//


#ifndef __UTIL_H_
#define __UTIL_H_

#include <stdlib.h>
#include <stdio.h>
#include <TCHAR.H>

#include <windows.h>
#include <crtdbg.h>

#include <tapi.h>
#include "faxdev.h"
#include "..\..\log\log.h"
#include "macros.h"

// Function definitions:

BOOL
PostJobStatus(
    HANDLE     CompletionPort,
    ULONG_PTR  CompletionKey,
    DWORD      StatusId,
    DWORD      ErrorCode
);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\fsp\vfsp\device.h ===
//
//
// Filename:	device.h
// Author:		Sigalit Bar (sigalitb)
// Date:		6-Jan-99
//
//

#ifndef __DEVICE_H_
#define __DEVICE_H_


#include <stdlib.h>
#include <stdio.h>
#include <TCHAR.H>
#include <vector>

#include <windows.h>
#include <crtdbg.h>

#include <tapi.h>
#include <faxdev.h>

#include "..\..\log\log.h"
#include "util.h"

using namespace std ;

// DEVICE_NAME_PREFIX is the name prefix for the virtual fax devices
#define VFSP_DEVICE_NAME_PREFIX  TEXT("VFSP Device ")
// DEVICE_ID_PREFIX is the value that identifies the virtual fax devices
#define VFSP_DEVICE_ID_PREFIX    0x60000

// DEVICE_IDLE indicates the virtual fax device is idle
#define DEVICE_IDLE                1
// DEVICE_START indicates the virtual fax device is pending a fax job
#define DEVICE_START               2
// DEVICE_SEND indicates the virtual fax device is sending
#define DEVICE_SEND                3
// DEVICE_RECEIVE indicates the virtual fax device is receiving
#define DEVICE_RECEIVE             4
// DEVICE_ABORTING indicates the virtual fax device is aborting
#define DEVICE_ABORTING            5

// JOB_UNKNOWN indicates the fax job is pending
#define JOB_UNKNOWN                1
// JOB_SEND indicates the fax job is a send
#define JOB_SEND                   2
// JOB_RECEIVE indicates the fax job is a receive
#define JOB_RECEIVE                3

#define JOB_SLEEP_TIME	3000
#define MAX_RAND_SLEEP	(6*60*1000)
#define MIN_RAND_SLEEP	(3*60*1000)
#define MIN_INITIALIZE_SLEEP (60*1000)


#define RING_THREAD_TIMEOUT 500000	

#define RECVFSP_FILENAME	TEXT("d:\\VFSP\\RECEIVE\\RecVFSP.tif")

class CDeviceJob;

//////////////////////////// CDevice ////////////////////////////

class CDevice{

public:
	CDevice(
		DWORD	dwDeviceId = 0, 
		HANDLE	hDeviceCompletionPort = NULL,
		DWORD	dwDeviceCompletionKey = 0,
		DWORD	dwDeviceStatus = DEVICE_IDLE,
		long	lReceivedFaxes = 0,
		long	lRing = 1,
		HANDLE	hRingThread = NULL
		);
	~CDevice(void);

	BOOL GetAllData(
		DWORD				dwDeviceId,
		HANDLE             hDeviceCompletionPort,
		DWORD              dwDeviceCompletionKey,
		DWORD              dwDeviceStatus,
		long               lReceivedFaxes,
		long               lRing,
		HANDLE             hRingThread
		);
	BOOL GetDeviceId(LPDWORD pdwDeviceId) const;
	BOOL GetDeviceStatus(LPDWORD pdwDeviceStatus) const;
	long GetRing(void) const;

	BOOL CreateRingThread(LPTHREAD_START_ROUTINE fnThread, LPVOID pVoid);
	BOOL StartJob(PHANDLE phFaxHandle, HANDLE hCompletionPortHandle, DWORD dwCompletionKey);
	BOOL EndJob(CDeviceJob* pDeviceJob);
	BOOL Send(
		IN OUT	CDeviceJob*			pDeviceJob,
		IN		PFAX_SEND			pFaxSend,
		IN		PFAX_SEND_CALLBACK	fnFaxSendCallback
		);
	BOOL Receive(
		IN OUT	CDeviceJob*		pDeviceJob,
		IN		HCALL			CallHandle,
		IN OUT	PFAX_RECEIVE	pFaxReceive
		);
	BOOL AbortOperation(IN OUT	CDeviceJob*	pDeviceJob);

	BOOL PostRingEvent(void);

private:
    CRITICAL_SECTION	m_cs;						// object to serialize access to the virtual fax device
    DWORD               m_dwDeviceId;				// specifies the identifier of the virtual fax device
    HANDLE              m_hDeviceCompletionPort;	// specifies a handle to an I/O completion port
    DWORD               m_dwDeviceCompletionKey;	// specifies a completion port key value
    DWORD               m_dwDeviceStatus;			// specifies the current status of the virtual fax device
    long                m_lReceivedFaxes;			// specifies the number of received faxes o n the device
    long                m_lRing;					// specifies if the device's ring thread is enabled
    HANDLE              m_hRingThread;				// the device's ring thread handle
};


//////////////////////////// CFaxDeviceVector ////////////////////////////

// CFaxDeviceVector
// an STL list of CDevices
#ifdef _C_FAX_DEVICE_VECTOR_
#error "redefinition of _C_FAX_DEVICE_VECTOR_"
#else
#define _C_FAX_DEVICE_VECTOR_
typedef vector< CDevice* > CFaxDeviceVector;
#endif

BOOL
FreeDeviceArray( CFaxDeviceVector& aFaxDeviceArray );

BOOL 
InitDeviceArray(
	IN OUT	CFaxDeviceVector&	aFaxDeviceArray,
	IN		DWORD				dwNumOfDevices,
    IN		HANDLE				hCompletionPort,
    IN		DWORD				dwCompletionKey
	);


//////////////////////////// CDeviceJob ////////////////////////////

class CDeviceJob{

public:
	CDeviceJob(
		CDevice*	pDevicePtr = NULL,
		HANDLE		hJobCompletionPort = NULL,
		DWORD		dwJobCompletionKey = 0,
		DWORD		dwJobType = JOB_UNKNOWN,
		DWORD		dwJobStatus = FS_INITIALIZING
		);
	~CDeviceJob(void);
	
	BOOL GetDevicePtr(OUT CDevice** ppDevicePtr) const;
	BOOL GetDeviceId(OUT LPDWORD pdwDeviceId) const;
	BOOL GetJobCompletionPort(OUT PHANDLE phJobCompletionPort) const;
	BOOL GetJobCompletionKey(OUT LPDWORD pdwJobCompletionKey) const;

	//NOTE: Always surround a call to this func with the job's device m_cs
	//      EnterCriticalSection(&m_cs) and LeaveCriticalSection(&m_cs)
	BOOL SetJobStatus(DWORD dwJobStatus);

	BOOL GetJobStatus(LPDWORD pdwJobStatus);

private:
    CDevice*	         m_pDevicePtr;				// the virtual fax device id associated with the fax job
    HANDLE               m_hJobCompletionPort;	// specifies a handle to an I/O completion port
    DWORD                m_dwJobCompletionKey;	// specifies a completion port key value
    DWORD                m_dwJobType;			// specifies the fax job type
    DWORD                m_dwJobStatus;			// specifies the current status of the fax job

};

#ifdef __cplusplus
extern "C" {
#endif

extern CFaxDeviceVector g_myFaxDeviceVector;		

#ifdef __cplusplus
}
#endif 



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\fsp\vfsp\vfsp.h ===
// Module name:		VFSP.h
// Module author:	Sigalit Bar (sigalitb)
// Date:			13-Dec-98


#ifndef _VFSP_H_
#define _VFSP_H_

#include <windows.h>
#include <stdio.h>
#include <tapi.h>
#include <faxdev.h>
#include <winfax.h>

#include "crtdbg.h"

#include "macros.h"
#include "reg.h"
#include "..\..\log\log.h"
#include "device.h"

#ifndef MODULEAPI
#define MODULEAPI __declspec(dllexport) 
#endif

#ifndef WINAPIV
#define WINAPIV __cdecl
#endif


#ifdef __cplusplus
extern "C" {
#endif


// MAX_PATH_LEN is the maximum length of a fully-qualified path without the filename
#define MAX_PATH_LEN               (MAX_PATH - 16)




extern HANDLE        g_hInstance;       // g_hInstance is the global handle to the module
extern HLINEAPP      g_LineAppHandle;   // g_LineAppHandle is the global handle to the fax service's registration with TAPI

extern CFaxDeviceVector g_myFaxDeviceVector;
extern BOOL g_fDevicesInitiated;
extern DWORD				g_dwSleepTime;

#define FSP_VDEV_LIMIT	10




#ifdef __cplusplus
}
#endif 

#endif //_VFSP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\fsp\vfsp\inifileentries.h ===
#ifndef __INI_FILE_ENTRIES_H
#define __INI_FILE_ENTRIES_H

// ini file which contains setting parameters
// the file must reside in the VFSP.dll directory.
#define VFSPIniFile TEXT("d:\\vfsp\\VFSP.ini")
// section names
#define REGISTRY_PARAMS		       TEXT("Registry Parameters")
#define GENERAL_PARAMS		       TEXT("General Parameters")
#define DEFAULT_SEND_SECTION       TEXT("Default Receive Parameters")
#define DEFAULT_RECEIVE_SECTION    TEXT("Default Receive Parameters")
#define DEVICE_SEND_SEC_PREFIX     TEXT("Send Parameters DEVICE")
#define	DEVICE_RECEIVE_SEC_PREFIX  TEXT("Receive Parameters DEVICE")

#endif //INI_FILE_ENTRIES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\fsp\vfsp\util.cpp ===
//
// Module name:		util.cpp
// Module author:	Sigalit Bar (sigalitb)
// Date:			13-Dec-98
//

#include "util.h"


BOOL
PostJobStatus(
    HANDLE     CompletionPort,
    ULONG_PTR  CompletionKey,
    DWORD      StatusId,
    DWORD      ErrorCode
)
/*++

Routine Description:

  Post a completion packet for a fax service provider fax job status change

Arguments:

  CompletionPort - specifies a handle to an I/O completion port
  CompletionKey - specifies a completion port key value
  StatusId - specifies a fax status code
  ErrorCode - specifies one of the Win32 error codes that the fax service provider should use to report an error that occurs

Return Value:

  TRUE on success

--*/
{
    // pFaxDevStatus is a pointer to the completion packet
    PFAX_DEV_STATUS  pFaxDevStatus;

    // Allocate a block of memory for the completion packet
    pFaxDevStatus = (FAX_DEV_STATUS *)MemAllocMacro(sizeof(FAX_DEV_STATUS));
    if (NULL == pFaxDevStatus) 
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: MemAllocMacro failed"),
			TEXT(__FILE__),
			__LINE__
			);
		return(FALSE);
	}

    pFaxDevStatus->SizeOfStruct = sizeof(FAX_DEV_STATUS);
    pFaxDevStatus->StatusId = StatusId;
    pFaxDevStatus->StringId = 0;
    pFaxDevStatus->PageCount = 0;
    pFaxDevStatus->CSI = NULL;
    pFaxDevStatus->CallerId = NULL;
    pFaxDevStatus->RoutingInfo = NULL;
    pFaxDevStatus->ErrorCode = ErrorCode;

    // Post the completion packet
    if (!PostQueuedCompletionStatus(
			CompletionPort, 
			sizeof(FAX_DEV_STATUS), 
			CompletionKey, (
			LPOVERLAPPED) pFaxDevStatus
			)
		)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: MemAllocMacro failed"),
			TEXT(__FILE__),
			__LINE__
			);
		return(FALSE);
	}

	return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\fsp\vfsp\manyrecvfsp.cpp ===
//
// Module name:		ManyRecVFSP.cpp
// Module author:	Sigalit Bar (sigalitb)
// Date:			21-Dec-98
//



#include "vfsp.h"
#include <assert.h>
#include "IniFileEntries.h"

HRESULT FindServerArrayEntry(HKEY& hServerArrayKey);

void CALLBACK
MyLineCallback(
    IN HANDLE FaxHandle,
    IN DWORD hDevice,
    IN DWORD dwMessage,
    IN DWORD dwInstance,
    IN DWORD dwParam1,
    IN DWORD dwParam2,
    IN DWORD dwParam3
    )
{
	::lgLogDetail(
			LOG_X,
			1,
			TEXT("[VFSP]MyLineCallback called with -\n\tFaxHandle=%d\n\thDevice=%d\n\tdwMessage=%d\n\tdwInstance=%d"),
			(DWORD)FaxHandle,
			hDevice,
			dwMessage,
			dwInstance
			);
    return;
}

 
BOOL WINAPI
FaxDevInitialize(
    IN  HLINEAPP LineAppHandle,
    IN  HANDLE HeapHandle,
    OUT PFAX_LINECALLBACK *LineCallbackFunction,
    IN  PFAX_SERVICE_CALLBACK FaxServiceCallback
    )
{

    ::lgLogDetail(LOG_X,1,TEXT("{VFSP}[FaxDevInitialize] Entry"));
	g_LineAppHandle = LineAppHandle;
    MemInitializeMacro(HeapHandle);
	_ASSERTE(NULL != LineCallbackFunction);
    *LineCallbackFunction = MyLineCallback;

    ::lgLogDetail(LOG_X,1,TEXT("{VFSP}[FaxDevInitialize] Exit"));
    return(TRUE);
}



BOOL WINAPI
FaxDevVirtualDeviceCreation(
    OUT LPDWORD	pdwDeviceCount,
    OUT LPWSTR  szDeviceNamePrefix,
    OUT LPDWORD pdwDeviceIdPrefix,
    IN  HANDLE	hCompletionPort,
    IN  DWORD	dwCompletionKey

    )
{
    ::lgLogDetail(LOG_X,1,TEXT("{VFSP}[FaxDevVirtualDeviceCreation] Entry"));
	_ASSERTE(NULL != pdwDeviceCount);
	_ASSERTE(NULL != szDeviceNamePrefix);
	_ASSERTE(NULL != pdwDeviceIdPrefix);

	//
	// internal data initializations
	//

	if (!::InitDeviceArray(g_myFaxDeviceVector, FSP_VDEV_LIMIT, hCompletionPort, dwCompletionKey))
	{
		::lgLogError(LOG_SEV_1,TEXT("{VFSP}[FaxDevVirtualDeviceCreation] InitDeviceArray failed"));
		return(FALSE);
	}
	else
	{
		::lgLogDetail(LOG_X,1,TEXT("{VFSP}[FaxDevVirtualDeviceCreation] InitDeviceArray success"));
		g_fDevicesInitiated = TRUE;
	}

	//
	// Set OUT parameters
	//

	DWORD dwIntRetValue =  GetPrivateProfileInt( GENERAL_PARAMS,
												 TEXT("DEVICES_NUMBER"),
												 -1,
												 VFSPIniFile);
	//FAX BUG: remove the line bellow and svc will attempt to create
	//         "endless" device registry keys
	*pdwDeviceCount = (dwIntRetValue != -1) ? dwIntRetValue : FSP_VDEV_LIMIT;

    lstrcpyn(szDeviceNamePrefix, VFSP_DEVICE_NAME_PREFIX, 128);
    *pdwDeviceIdPrefix = VFSP_DEVICE_ID_PREFIX;

    ::lgLogDetail(LOG_X,1,TEXT("{VFSP}[FaxDevVirtualDeviceCreation] Exit"));
    return TRUE;
}



BOOL WINAPI
FaxDevStartJob(
    IN  HLINE	hLineHandle,
    IN  DWORD	dwDeviceId,
    OUT PHANDLE phFaxHandle,
    IN  HANDLE	hCompletionPortHandle,
    IN  DWORD	dwCompletionKey
    )
{

    ::lgLogDetail(LOG_X,1,TEXT("{VFSP}[FaxDevStartJob] Entry for device=%d"),dwDeviceId);
	_ASSERTE(NULL != phFaxHandle);

	CDevice* pDevice = g_myFaxDeviceVector.at(dwDeviceId);
	if (NULL == pDevice)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("{VFSP}[FaxDevStartJob]\n%s[%d]: g_myFaxDeviceVector.at(%d) returned NULL"),
			TEXT(__FILE__),
			__LINE__,
			dwDeviceId
			);
		*phFaxHandle = NULL;
		return(FALSE);
	}
	if (FALSE == pDevice->StartJob(phFaxHandle, hCompletionPortHandle, dwCompletionKey))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("{VFSP}[FaxDevStartJob]\n%s[%d]: theDevice->StartJob() failed"),
			TEXT(__FILE__),
			__LINE__
			);
		*phFaxHandle = NULL;
		return(FALSE);
	}

    ::lgLogDetail(LOG_X,1,TEXT("{VFSP}[FaxDevStartJob] Exit for device=%d"),dwDeviceId);
    return(TRUE);
}

BOOL GetJobAndDeviceFromHandle(
	IN HANDLE hFaxHandle, 
	OUT CDeviceJob** ppDeviceJob,
	OUT CDevice**		ppDevice
	)
{
    ::lgLogDetail(LOG_X,1,TEXT("{VFSP}[GetJobAndDeviceFromHandle] Entry"));

	BOOL fRetVal = FALSE;

	if (NULL == hFaxHandle)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("{VFSP}[GetJobAndDeviceFromHandle]\n%s[%d]: hFaxHandle is NULL"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
	}

	if (NULL == ppDeviceJob)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("{VFSP}[GetJobAndDeviceFromHandle]\n%s[%d]: ppDeviceJob is NULL"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
	}

	if (NULL == ppDevice)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("{VFSP}[GetJobAndDeviceFromHandle]\n%s[%d]: ppDevice is NULL"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
	}

	(*ppDeviceJob) = (CDeviceJob*)hFaxHandle;
	
	if (FALSE == (*ppDeviceJob)->GetDevicePtr(ppDevice))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("{VFSP}[GetJobAndDeviceFromHandle]\n%s[%d]: (*ppDeviceJob)->GetDevicePtr() failed"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
	}

	fRetVal = TRUE;

ExitFunc:
    ::lgLogDetail(LOG_X,1,TEXT("{VFSP}[GetJobAndDeviceFromHandle] Exit"));
	return(fRetVal);
}

BOOL WINAPI
FaxDevEndJob(
    IN  HANDLE hFaxHandle
    )
{


    ::lgLogDetail(LOG_X,1,TEXT("{VFSP}[FaxDevEndJob] Entry"));

	if (NULL == hFaxHandle)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("{VFSP}[FaxDevEndJob]\n%s[%d]: hFaxHandle is NULL"),
			TEXT(__FILE__),
			__LINE__
			);
		return(FALSE);
	}

	CDeviceJob* pDeviceJob = NULL;
	CDevice* pDevice = NULL;

	if (FALSE == GetJobAndDeviceFromHandle(hFaxHandle,&pDeviceJob,&pDevice))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("{VFSP}[FaxDevEndJob]\n%s[%d]: pDeviceJob->GetDevicePtr() failed"),
			TEXT(__FILE__),
			__LINE__
			);
		return(FALSE);
	}
	
	_ASSERTE(NULL != pDeviceJob);
	_ASSERTE(NULL != pDevice);

	DWORD dwDeviceId = 0;
	if (FALSE == pDeviceJob->GetDeviceId(&dwDeviceId))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("{VFSP}[FaxDevEndJob]\n%s[%d]: pDeviceJob->GetDeviceId() failed"),
			TEXT(__FILE__),
			__LINE__
			);
		return(FALSE);

	}
    ::lgLogDetail(LOG_X,1,TEXT("{VFSP}[FaxDevEndJob] for device=%d"),dwDeviceId);

	if (FALSE == pDevice->EndJob(pDeviceJob))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("{VFSP}[FaxDevEndJob]\n%s[%d]: pDevice->EndJob() failed"),
			TEXT(__FILE__),
			__LINE__
			);
		return(FALSE);
	}

    ::lgLogDetail(LOG_X,1,TEXT("{VFSP}[FaxDevEndJob] Exit for device=%d"),dwDeviceId);
    return(TRUE);
}



BOOL WINAPI
FaxDevSend(
    IN  HANDLE hFaxHandle,
    IN  PFAX_SEND pFaxSend,
    IN  PFAX_SEND_CALLBACK fnFaxSendCallback
    )
{
	BOOL fRetVal = FALSE;
	CDeviceJob* pDeviceJob = NULL;
	CDevice* pDevice = NULL;
	DWORD dwDeviceId = 0;

    ::lgLogDetail(LOG_X,1,TEXT("{VFSP}[FaxDevSend] Entry"));

	if (NULL == hFaxHandle)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("{VFSP}[FaxDevSend]\n%s[%d]: NULL == hFaxHandle"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
	}

	if (FALSE == GetJobAndDeviceFromHandle(hFaxHandle,&pDeviceJob,&pDevice))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("{VFSP}[FaxDevSend]\n%s[%d]: GetJobAndDeviceFromHandle failed"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
	}
	
	_ASSERTE(NULL != pDeviceJob);
	_ASSERTE(NULL != pDevice);

	if (FALSE == pDeviceJob->GetDeviceId(&dwDeviceId))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("{VFSP}[FaxDevSend]\n%s[%d]: pDeviceJob->GetDeviceId() failed"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
	}

    ::lgLogDetail(LOG_X,1,TEXT("{VFSP}[FaxDevSend] for device=%d"),dwDeviceId);

	if (FALSE == pDevice->Send(pDeviceJob, pFaxSend, fnFaxSendCallback))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("{VFSP}[FaxDevSend]\n%s[%d]: pDevice->Send() failed"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
	}

	fRetVal= TRUE;

ExitFunc:
    ::lgLogDetail(
		LOG_X,
		1,
		TEXT("{VFSP}[FaxDevSend] Exit for device=%d. fRetVal=%d"),
		dwDeviceId,
		fRetVal
		);
    return(fRetVal);
}



BOOL WINAPI
FaxDevReceive(
    IN  HANDLE hFaxHandle,
    IN  HCALL CallHandle,
    IN OUT PFAX_RECEIVE pFaxReceive
    )
{
	BOOL fRetVal = FALSE;
	CDeviceJob* pDeviceJob = NULL;
	CDevice* pDevice = NULL;
	DWORD dwDeviceId = 0;

    ::lgLogDetail(LOG_X,1,TEXT("{VFSP}[FaxDevReceive] Entry"));

	if (NULL == hFaxHandle)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("{VFSP}[FaxDevReceive]\n%s[%d]: NULL == hFaxHandle"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
	}

	if (FALSE == GetJobAndDeviceFromHandle(hFaxHandle,&pDeviceJob,&pDevice))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("{VFSP}[FaxDevReceive]\n%s[%d]: GetJobAndDeviceFromHandle failed"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
	}
	
	_ASSERTE(NULL != pDeviceJob);
	_ASSERTE(NULL != pDevice);

	if (FALSE == pDeviceJob->GetDeviceId(&dwDeviceId))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("{VFSP}[FaxDevReceive]\n%s[%d]: pDeviceJob->GetDeviceId() failed"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
	}

    ::lgLogDetail(LOG_X,1,TEXT("{VFSP}[FaxDevReceive] device=%d"),dwDeviceId);

	if (FALSE == pDevice->Receive(pDeviceJob, CallHandle, pFaxReceive))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("{VFSP}[FaxDevReceive]\n%s[%d]: pDevice->Receive() failed"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
	}

	fRetVal= TRUE;

ExitFunc:
    ::lgLogDetail(
		LOG_X,
		1,
		TEXT("{VFSP}[FaxDevReceive] Exit for device=%d. fRetVal=%d"),
		dwDeviceId,
		fRetVal
		);
    return(fRetVal);
}


BOOL WINAPI
FaxDevAbortOperation(
    IN  HANDLE hFaxHandle
    )
{
	BOOL fRetVal = FALSE;
	CDeviceJob* pDeviceJob = NULL;
	CDevice* pDevice = NULL;
	DWORD dwDeviceId = 0;

    ::lgLogDetail(LOG_X,1,TEXT("{VFSP}[FaxDevAbortOperation] Entry"));

	if (NULL == hFaxHandle)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("{VFSP}[FaxDevAbortOperation]\n%s[%d]: NULL == hFaxHandle"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
	}

	if (FALSE == GetJobAndDeviceFromHandle(hFaxHandle,&pDeviceJob,&pDevice))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("{VFSP}[FaxDevAbortOperation]\n%s[%d]: GetJobAndDeviceFromHandle failed"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
	}
	
	_ASSERTE(NULL != pDeviceJob);
	_ASSERTE(NULL != pDevice);

	if (FALSE == pDeviceJob->GetDeviceId(&dwDeviceId))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("{VFSP}[FaxDevAbortOperation]\n%s[%d]: pDeviceJob->GetDeviceId() failed"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
	}

    ::lgLogDetail(LOG_X,1,TEXT("{VFSP}[FaxDevAbortOperation] for device=%d"),dwDeviceId);

	if (FALSE == pDevice->AbortOperation(pDeviceJob))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("{VFSP}[FaxDevAbortOperation]\n%s[%d]: pDevice->AbortOperation() failed"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
	}

	fRetVal= TRUE;

ExitFunc:
    ::lgLogDetail(
		LOG_X,
		1,
		TEXT("{VFSP}[FaxDevAbortOperation] Exit for device=%d. fRetVal=%d"),
		dwDeviceId,
		fRetVal
		);
    return(fRetVal);
}


BOOL WINAPI
FaxDevReportStatus(
    IN  HANDLE			hFaxHandle OPTIONAL,
    OUT PFAX_DEV_STATUS pFaxStatus,
    IN  DWORD			dwFaxStatusSize,
    OUT LPDWORD			pdwFaxStatusSizeRequired
    )
{

	::lgLogDetail(LOG_X,1,TEXT("{VFSP}[FaxDevReportStatus] Entry "));

    // dwSize is the size of the completion packet
    DWORD         dwSize;
    // upString is the offset of the strings within the completion packet
    UINT_PTR      upStringOffset;

    if (hFaxHandle == NULL) 
	{
        // Set the error code
        SetLastError(ERROR_INVALID_HANDLE);
		::lgLogError(
			LOG_SEV_1,
			TEXT("{VFSP}[FaxDevReportStatus]\n%s[%d]: FaxHandle == NULL"),
			TEXT(__FILE__),
			__LINE__
			);
        return(FALSE);
    }

    if (pdwFaxStatusSizeRequired == NULL) 
	{
        // Set the error code
        SetLastError(ERROR_INVALID_PARAMETER);
		::lgLogError(
			LOG_SEV_1,
			TEXT("{VFSP}[FaxDevReportStatus]\n%s[%d]: pdwFaxStatusSizeRequired == NULL"),
			TEXT(__FILE__),
			__LINE__
			);
        return FALSE;
    }

    if ((pFaxStatus == NULL) && (dwFaxStatusSize != 0)) 
	{
        // Set the error code
        SetLastError(ERROR_INVALID_PARAMETER);
		::lgLogError(
			LOG_SEV_1,
			TEXT("{VFSP}[FaxDevReportStatus]\n%s[%d]: (FaxStatus == NULL) && (FaxStatusSize != 0)"),
			TEXT(__FILE__),
			__LINE__
			);
        return FALSE;
    }


    // Initialize the size of the completion packet
    dwSize = sizeof(FAX_DEV_STATUS);
    dwSize += (lstrlen(TEXT("CSI")) + 1) * sizeof(TCHAR);
    dwSize += (lstrlen(TEXT("CallerId")) + 1) * sizeof(TCHAR);
	dwSize += (lstrlen(TEXT("RoutingInfo")) + 1) * sizeof(TCHAR);

    // Set the calculated size of the buffer required to hold the completion packet
    *pdwFaxStatusSizeRequired = dwSize;

    if ((pFaxStatus == NULL) && (dwFaxStatusSize == 0)) 
	{
		::lgLogDetail(LOG_X,1,TEXT("{VFSP}[FaxDevReportStatus] Exit - TRUE"));
        return(TRUE);
    }

    if (dwFaxStatusSize < dwSize) 
	{
        // Set the error code
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
		::lgLogError(
			LOG_SEV_1,
			TEXT("{VFSP}[FaxDevReportStatus]\n%s[%d]: FaxStatusSize < dwSize"),
			TEXT(__FILE__),
			__LINE__
			);
        return(FALSE);
    }

    upStringOffset = sizeof(FAX_DEV_STATUS);

	_ASSERTE(NULL != pFaxStatus);
    pFaxStatus->SizeOfStruct = sizeof(FAX_DEV_STATUS);

	CDeviceJob* pDeviceJob = NULL;
	CDevice* pDevice = NULL;

	if (FALSE == GetJobAndDeviceFromHandle(hFaxHandle,&pDeviceJob,&pDevice))
	{
        SetLastError(E_INVALIDARG);
		::lgLogError(
			LOG_SEV_1,
			TEXT("{VFSP}[FaxDevReportStatus]\n%s[%d]: GetJobAndDeviceFromHandle() failed"),
			TEXT(__FILE__),
			__LINE__
			);
		return(FALSE);
	}
	
	_ASSERTE(NULL != pDeviceJob);
	_ASSERTE(NULL != pDevice);

	DWORD dwDeviceStatus = 0;
	if (FALSE == pDevice->GetDeviceStatus(&dwDeviceStatus))
	{
        SetLastError(E_INVALIDARG);
		::lgLogError(
			LOG_SEV_1,
			TEXT("{VFSP}[FaxDevReportStatus]\n%s[%d]: pDevice->GetDeviceStatus() failed"),
			TEXT(__FILE__),
			__LINE__
			);
		return(FALSE);
	}

    pFaxStatus->StatusId = dwDeviceStatus;
	::lgLogDetail(LOG_X,1,TEXT("{VFSP}[FaxDevReportStatus] dwDeviceStatus=0x%08X"), dwDeviceStatus);
    pFaxStatus->StringId = 0;
    pFaxStatus->PageCount = 1;
	pFaxStatus->CSI = NULL;
    pFaxStatus->CSI = (LPTSTR) ((UINT_PTR) pFaxStatus + upStringOffset);
    if (NULL == lstrcpy(pFaxStatus->CSI, TEXT("CSI")))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("%s[%d]: lstrcpy failed"),
			TEXT(__FILE__),
			__LINE__
			);
		return(FALSE);
	}
    upStringOffset += (lstrlen(TEXT("CSI")) + 1) * sizeof(TCHAR);
    pFaxStatus->CallerId = NULL;
    pFaxStatus->CallerId = (LPTSTR) ((UINT_PTR) pFaxStatus + upStringOffset);
    if (NULL == lstrcpy(pFaxStatus->CallerId, TEXT("CallerId")))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("{VFSP}[FaxDevReportStatus]\n%s[%d]: lstrcpy failed"),
			TEXT(__FILE__),
			__LINE__
			);
		return(FALSE);
	}
    upStringOffset += (lstrlen(TEXT("CallerId")) + 1) * sizeof(TCHAR);
    pFaxStatus->RoutingInfo = NULL;
    pFaxStatus->RoutingInfo = (LPWSTR) ((UINT_PTR) pFaxStatus + upStringOffset);
    if (NULL == lstrcpy(pFaxStatus->RoutingInfo, TEXT("RoutingInfo")))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("{VFSP}[FaxDevReportStatus]\n%s[%d]: lstrcpy failed"),
			TEXT(__FILE__),
			__LINE__
			);
		return(FALSE);
	}
    upStringOffset += (lstrlen(TEXT("RoutingInfo")) + 1) * sizeof(TCHAR);
    pFaxStatus->ErrorCode = ERROR_SUCCESS;

	::lgLogDetail(LOG_X,1,TEXT("{VFSP}[FaxDevReportStatus] Exit"));

	return(TRUE);
}



MODULEAPI
STDAPI DllRegisterServer()
/*++

Routine Description:

  Function for the in-process server to create its registry entries

Return Value:

  S_OK on success

--*/
{
    HRESULT hRetVal = E_UNEXPECTED;
	LONG lRet = E_UNEXPECTED;
    // registry keys
	HKEY hServiceProvidersKey = NULL;
	HKEY hServerArrayKey = NULL;
    HKEY hVfspKey = NULL;
       	
	DWORD dwRegDwordValue = 0;
	DWORD dwValueSize = 0;
	DWORD dwIniQueryRet = 0;

	::lgLogDetail(LOG_X,1,TEXT("[DllRegisterServer] Entry"));

    // Register the fax service provider
    /*if (FALSE == FaxRegisterServiceProvider(
			VFSP_PROVIDER, 
			VFSP_PROVIDER_FRIENDLYNAME, 
			VFSP_PROVIDER_IMAGENAME, 
			VFSP_PROVIDER_PROVIDERNAME
			)
		) 
	{
		::lgLogError(LOG_SEV_1,TEXT("[DllRegisterServer] FaxRegisterServiceProvider failed"));
		::lgLogDetail(LOG_X,1,TEXT("[DllRegisterServer] exiting with E_UNEXPECTED"));
        goto ExitFunc;
    }
	*/

    // add providers GUID directly to registry 
    // we do this for now since the new FaxRegisterServiceProvider 
    // that takes a GUID is not implemented yet, but service assumes providers 
    // register with a GUID.
    // => TO DO: change above FaxRegisterServiceProvider() call to a FaxRegisterServiceProviderEx()
    //           call using the provider's GUID

    
	// Open the fax server array registry key
    if(FindServerArrayEntry(hServerArrayKey) != S_OK)
	{
		assert(!hServerArrayKey);
		::lgLogDetail(LOG_X,1,TEXT("[DllRegisterServer] exiting with E_UNEXPECTED"));
        goto ExitFunc;
	}

   // Open the service provider registry key
	lRet = RegOpenKeyEx(
                hServerArrayKey, 
                FAX_PROVIDERS_REGKEY, 
                0, 
                KEY_ALL_ACCESS, 
                &hServiceProvidersKey
                );
    if (ERROR_SUCCESS != lRet)
    {
		::lgLogError(LOG_SEV_1,TEXT("[DllRegisterServer] RegOpenKeyEx(FAX_PROVIDERS_REGKEY) failed with %d"), lRet);
		::lgLogDetail(LOG_X,1,TEXT("[DllRegisterServer] exiting with E_UNEXPECTED"));
        goto ExitFunc;
    }

	// create newfsp service ptovider registry key with quid as key name 
	lRet = RegCreateKeyEx(
			hServiceProvidersKey,         
			VFSP_GUID, 
			0,  
			NULL,
			REG_OPTION_NON_VOLATILE, 
			KEY_ALL_ACCESS,  
			NULL,
			&hVfspKey, 
			NULL);
 
	if (ERROR_SUCCESS != lRet)
    {
		::lgLogError(LOG_SEV_1,TEXT("[DllRegisterServer] RegCreateKeyEx(VFSP_GUID) failed with %d"), lRet);
		::lgLogDetail(LOG_X,1,TEXT("[DllRegisterServer] exiting with E_UNEXPECTED"));
        goto ExitFunc;
    }

	//Create class name
	dwValueSize = (1 + _tcslen(PROVIDER_CLASS_NAME))*sizeof(TCHAR); // length includes terminating NULL
    lRet = RegSetValueEx(
                hVfspKey, 
                CLASS_NAME_STR, 
                0, 
                REG_SZ , 
                (LPBYTE)PROVIDER_CLASS_NAME, 
                dwValueSize
                );
    if (ERROR_SUCCESS != lRet)
    {
		::lgLogError(LOG_SEV_1,TEXT("[DllRegisterServer] RegSetValueEx(CLASS_NAME_STR) failed with %d"), lRet);
		::lgLogDetail(LOG_X,1,TEXT("[DllRegisterServer] exiting with E_UNEXPECTED"));
        goto ExitFunc;
    }

	// Create version number
	dwValueSize = sizeof(DWORD); 
	dwRegDwordValue = (DWORD)VFSP_API_VERSION_VALUE;
    lRet = RegSetValueEx(
                hVfspKey, 
                COMET_API_VERSION_STR, 
                0, 
                REG_DWORD , 
                (LPBYTE)&dwRegDwordValue, 
                dwValueSize
                );
    if (ERROR_SUCCESS != lRet)
    {
		::lgLogError(LOG_SEV_1,TEXT("[DllRegisterServer] RegSetValueEx(COMET_API_VERSION_STR) failed with %d"), lRet);
		::lgLogDetail(LOG_X,1,TEXT("[DllRegisterServer] exiting with E_UNEXPECTED"));
        goto ExitFunc;
    }


	// Create capabilities identifier
	dwValueSize = sizeof(DWORD); 
	dwRegDwordValue = (DWORD)VFSP_CAPABILITIES_VALUE;
    lRet = RegSetValueEx(
                hVfspKey, 
                PROVIDER_CAPABILITIES_STR, 
                0, 
                REG_DWORD , 
                (LPBYTE)&dwRegDwordValue, 
                dwValueSize
                );
    if (ERROR_SUCCESS != lRet)
    {
		::lgLogError(LOG_SEV_1,TEXT("[DllRegisterServer] RegSetValueEx(PROVIDER_CAPABILITIES_STR) failed with %d"), lRet);
		::lgLogDetail(LOG_X,1,TEXT("[DllRegisterServer] exiting with E_UNEXPECTED"));
        goto ExitFunc;
    }
	
	// Create description string
	dwValueSize = (1 + _tcslen(VFSP_DESCRIPTION))*sizeof(TCHAR); // length includes terminating NULL
    lRet = RegSetValueEx(
                hVfspKey, 
                PROVIDER_DESCRIPTION_STR, 
                0, 
                REG_SZ , 
                (LPBYTE)VFSP_DESCRIPTION, 
                dwValueSize
                );
    if (ERROR_SUCCESS != lRet)
    {
		::lgLogError(LOG_SEV_1,TEXT("[DllRegisterServer] RegSetValueEx(PROVIDER_DESCRIPTION_STR) failed with %d"), lRet);
		::lgLogDetail(LOG_X,1,TEXT("[DllRegisterServer] exiting with E_UNEXPECTED"));
        goto ExitFunc;
    }


	// Create fiendly name string
	dwValueSize = (1 + _tcslen(VFSP_FRIENDLY_NAME))*sizeof(TCHAR); // length includes terminating NULL
    lRet = RegSetValueEx(
                hVfspKey, 
                PROVIDER_FRIENDLY_NAME_STR, 
                0, 
                REG_SZ , 
                (LPBYTE)VFSP_FRIENDLY_NAME, 
                dwValueSize
                );
    if (ERROR_SUCCESS != lRet)
    {
		::lgLogError(LOG_SEV_1,TEXT("[DllRegisterServer] RegSetValueEx(PROVIDER_FRIENDLY_NAME_STR) failed with %d"), lRet);
		::lgLogDetail(LOG_X,1,TEXT("[DllRegisterServer] exiting with E_UNEXPECTED"));
        goto ExitFunc;
    }

	// Create image name path

	// Search for the image file path in the ini file
	TCHAR tstrImageFilePath[MAX_PATH];
	dwIniQueryRet = GetPrivateProfileString( REGISTRY_PARAMS,
											 TEXT("VFSP_IMAGE_NAME"), 
											 TEXT("NOT FOUND"),
											 tstrImageFilePath, 
											 MAX_PATH,
											 VFSPIniFile);

	if( !dwIniQueryRet || !_tcscmp(tstrImageFilePath, TEXT("NOT FOUND")))
	{
		_tcscpy(tstrImageFilePath, VFSP_IMAGE_NAME);
	}
	dwValueSize = (1 + _tcslen(tstrImageFilePath))*sizeof(TCHAR); // length includes terminating NULL
    lRet = RegSetValueEx(
                hVfspKey, 
                PROVIDER_IMAGE_NAME_STR, 
                0, 
                REG_SZ , 
                (LPBYTE)tstrImageFilePath, 
                dwValueSize
                );
    if (ERROR_SUCCESS != lRet)
    {
		::lgLogError(LOG_SEV_1,TEXT("[DllRegisterServer] RegSetValueEx(PROVIDER_IMAGE_NAME_STR) failed with %d"), lRet);
		::lgLogDetail(LOG_X,1,TEXT("[DllRegisterServer] exiting with E_UNEXPECTED"));
        goto ExitFunc;
    }

    // Create the providers GUID value
    dwValueSize = (1 + _tcslen(VFSP_GUID))*sizeof(TCHAR); // length includes terminating NULL
    lRet = RegSetValueEx(
                hVfspKey, 
                PROVIDER_GUID_STR, 
                0, 
                REG_SZ , 
                (LPBYTE)VFSP_GUID, 
                dwValueSize
                );
    if (ERROR_SUCCESS != lRet)
    {
		::lgLogError(LOG_SEV_1,TEXT("[DllRegisterServer] RegSetValueEx(PROVIDER_GUID_STR) failed with %d"), lRet);
		::lgLogDetail(LOG_X,1,TEXT("[DllRegisterServer] exiting with E_UNEXPECTED"));
        goto ExitFunc;
    }

	// Create the tsp name
    dwValueSize = (1 + _tcslen(VFSP_TSP_NAME))*sizeof(TCHAR); // length includes terminating NULL
    lRet = RegSetValueEx(
                hVfspKey, 
                PROVIDER_TSP_NAME_STR, 
                0, 
                REG_SZ , 
                (LPBYTE)VFSP_TSP_NAME, 
                dwValueSize
                );
    if (ERROR_SUCCESS != lRet)
    {
		::lgLogError(LOG_SEV_1,TEXT("[DllRegisterServer] RegSetValueEx(PROVIDER_TSP_NAME_STR) failed with %d"), lRet);
		::lgLogDetail(LOG_X,1,TEXT("[DllRegisterServer] exiting with E_UNEXPECTED"));
        goto ExitFunc;
    }

    // Set g_hHeap
    MemInitializeMacro(GetProcessHeap());

	::lgLogDetail(LOG_X,1,TEXT("[DllRegisterServer] exiting with S_OK"));

    hRetVal = S_OK;

ExitFunc:
    // TO DO: close all opened keys
    lRet = RegCloseKey(hServiceProvidersKey);
    if (ERROR_SUCCESS != lRet)
    {
		::lgLogError(LOG_SEV_1,TEXT("[DllRegisterServer] RegCloseKey(hServiceProvidersKey) failed with %d"), lRet);
		::lgLogDetail(LOG_X,1,TEXT("[DllRegisterServer] exiting with E_UNEXPECTED"));
        hRetVal = E_UNEXPECTED;
    }
    lRet = RegCloseKey(hVfspKey);
    if (ERROR_SUCCESS != lRet)
    {
		::lgLogError(LOG_SEV_1,TEXT("[DllRegisterServer] RegCloseKey(hPipeEfspKey) failed with %d"), lRet);
		::lgLogDetail(LOG_X,1,TEXT("[DllRegisterServer] exiting with E_UNEXPECTED"));
        hRetVal = E_UNEXPECTED;
    }
	// This one was opened by FindServerArrayEntry()
	lRet = RegCloseKey(hServerArrayKey);
    if (ERROR_SUCCESS != lRet)
    {
		::lgLogError(LOG_SEV_1,TEXT("[DllRegisterServer] RegCloseKey(hServiceProvidersKey) failed with %d"), lRet);
		::lgLogDetail(LOG_X,1,TEXT("[DllRegisterServer] exiting with E_UNEXPECTED"));
        hRetVal = E_UNEXPECTED;
    }
    return(hRetVal);
}


// FindServerArrayEntry()
//
// search in the comet storage registry and returns
// the array key with server name identical to local machine name.
//
// [out] hServerArrayKey - is NULL if no such key was found, 
//						   and a valid registry key if found.
// returned value - 0 for success.
//
HRESULT FindServerArrayEntry(HKEY& hServerArrayKey)
{
	HRESULT hRetVal = E_UNEXPECTED;
 	LONG lRet = E_UNEXPECTED;
    
	HKEY hArraysKey = NULL;
	TCHAR* tstrSubKeyName = NULL;
	BYTE* tstrCometServerName = NULL;
	DWORD dwMaxSubKeyLen = 0;
	DWORD dwSubKeysNum = 0;
	int index;
	DWORD dwComputerNameLenth = 0;
	
	// initialize 
	hServerArrayKey = NULL;

	// open comet storage arrays key
	lRet = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE, 
                FAX_ARRAYS_REGKEY, 
                0, 
                KEY_ALL_ACCESS, 
                &hArraysKey
                );
    if (ERROR_SUCCESS != lRet)
    {
		::lgLogError(LOG_SEV_1,TEXT("[FindServerArrayEntry] RegOpenKeyEx(FAX_ARRAYS_REGKEY) failed with %d"), lRet);
		::lgLogDetail(LOG_X,1,TEXT("[FindServerArrayEntry] exiting with E_UNEXPECTED"));
        goto ExitFunc;
    }
	
	// find arrays number and the maximum lenth of array name
	lRet = RegQueryInfoKey(
				 hArraysKey, 
				 NULL, 
				 NULL, 
				 NULL,
				 &dwSubKeysNum,     
				 &dwMaxSubKeyLen, 
				 NULL,
				 NULL, 
				 NULL, 
				 NULL,  
				 NULL,
				 NULL );
 
	if (ERROR_SUCCESS != lRet)
    {
		::lgLogError(LOG_SEV_1,TEXT("[FindServerArrayEntry] RegQueryInfoKey(FAX_ARRAYS_REGKEY) failed with %d"), lRet);
		::lgLogDetail(LOG_X,1,TEXT("[FindServerArrayEntry] exiting with E_UNEXPECTED"));
        goto ExitFunc;
    }

	// allocate buffer for array key name
	tstrSubKeyName = new TCHAR[dwMaxSubKeyLen + 1];
	if(!tstrSubKeyName)
	{
		::lgLogError(LOG_SEV_1,TEXT("[FindServerArrayEntry] memory allocation failed"));
		::lgLogDetail(LOG_X,1,TEXT("[FindServerArrayEntry] exiting with E_UNEXPECTED"));
        goto ExitFunc;
	}

	// get local server name
	TCHAR strLocalServerName[MAX_COMPUTERNAME_LENGTH + 1 ];
	dwComputerNameLenth = MAX_COMPUTERNAME_LENGTH;
	if(!GetComputerName(strLocalServerName, &dwComputerNameLenth))
	{
		::lgLogError(LOG_SEV_1,TEXT("[FindServerArrayEntry] GetComputerName() failed with %d"), GetLastError());
		::lgLogDetail(LOG_X,1,TEXT("[FindServerArrayEntry] exiting with E_UNEXPECTED"));
        goto ExitFunc;
	}

	// walk on arrays key entries
	for( index = 0; index < dwSubKeysNum; index++)
	{
		// get array name
		lRet = RegEnumKey(
					hArraysKey, 
					index,  
					tstrSubKeyName,    
					dwMaxSubKeyLen + 1);
	
		if (ERROR_SUCCESS != lRet)
		{
			::lgLogError(LOG_SEV_1,TEXT("[FindServerArrayEntry] RegEnumKey(FAX_ARRAYS_REGKEY) failed with %d"), lRet);
			::lgLogDetail(LOG_X,1,TEXT("[FindServerArrayEntry] exiting with E_UNEXPECTED"));
			goto ExitFunc;
		}

		// open array key
		lRet = RegOpenKeyEx(
					hArraysKey, 
					tstrSubKeyName, 
					0, 
					KEY_ALL_ACCESS, 
					&hServerArrayKey
					);
		if (ERROR_SUCCESS != lRet)
		{
			::lgLogError(LOG_SEV_1,TEXT("[FindServerArrayEntry] RegOpenKeyEx(ARRAY REGKEY) failed with %d"), lRet);
			::lgLogDetail(LOG_X,1,TEXT("[FindServerArrayEntry] exiting with E_UNEXPECTED"));
			goto ExitFunc;
		}

		// query server name value
		DWORD dwBufferSize = 0;
		DWORD dwType;
		lRet =  RegQueryValueEx(
					 hServerArrayKey,
					 COMET_SERVER_STR,
					 NULL,
					 &dwType,
					 NULL,  
					 &dwBufferSize);
 
		if(ERROR_SUCCESS != lRet)
		{
			// Value name may not exist(?) so go over the rest of the keys 
			lRet = RegCloseKey(hServerArrayKey);
			hServerArrayKey = NULL;
			if (ERROR_SUCCESS != lRet)
			{
				::lgLogError(LOG_SEV_1,TEXT("[FindServerArrayEntry] RegCloseKey(hServerArrayKey) failed with %d"), lRet);
				::lgLogDetail(LOG_X,1,TEXT("[FindServerArrayEntry] exiting with E_UNEXPECTED"));
				goto ExitFunc;
			}
			continue;
		}

		// alocate server name buffer
		tstrCometServerName = new BYTE[dwBufferSize + 1];
		if(!tstrCometServerName)
		{
			::lgLogError(LOG_SEV_1,TEXT("[FindServerArrayEntry] memory allocation failed"));
			::lgLogDetail(LOG_X,1,TEXT("[FindServerArrayEntry] exiting with E_UNEXPECTED"));
		
			lRet = RegCloseKey(hServerArrayKey);
			hServerArrayKey = NULL;
			if (ERROR_SUCCESS != lRet)
			{
				::lgLogError(LOG_SEV_1,TEXT("[FindServerArrayEntry] RegCloseKey(hServerArrayKey) failed with %d"), lRet);
				::lgLogDetail(LOG_X,1,TEXT("[FindServerArrayEntry] exiting with E_UNEXPECTED"));
			}
			goto ExitFunc;
		}

		// query server name value
		lRet =  RegQueryValueEx(
					 hServerArrayKey,
					 COMET_SERVER_STR,
					 NULL,
					 &dwType,
					 tstrCometServerName,  
					 &dwBufferSize);
		if (ERROR_SUCCESS != lRet)
		{
			::lgLogError(LOG_SEV_1,TEXT("[FindServerArrayEntry] RegQueryValueEx(hServerArrayKey) failed with %d"), lRet);
			::lgLogDetail(LOG_X,1,TEXT("[FindServerArrayEntry] exiting with E_UNEXPECTED"));
			
			lRet = RegCloseKey(hServerArrayKey);
			hServerArrayKey = NULL;
			if (ERROR_SUCCESS != lRet)
			{
				::lgLogError(LOG_SEV_1,TEXT("[FindServerArrayEntry] RegCloseKey(hServerArrayKey) failed with %d"), lRet);
				::lgLogDetail(LOG_X,1,TEXT("[FindServerArrayEntry] exiting with E_UNEXPECTED"));
			}
			goto ExitFunc;
		}

		// found it
		if(!_tcscmp((TCHAR*)tstrCometServerName, strLocalServerName))
		{
			break;
		}

		// cleanup
		lRet = RegCloseKey(hServerArrayKey);
		hServerArrayKey = NULL;
		if (ERROR_SUCCESS != lRet)
		{
			::lgLogError(LOG_SEV_1,TEXT("[FindServerArrayEntry] RegCloseKey(hServerArrayKey) failed with %d"), lRet);
			::lgLogDetail(LOG_X,1,TEXT("[FindServerArrayEntry] exiting with E_UNEXPECTED"));
		}
		delete tstrCometServerName;
		tstrCometServerName = NULL;
	}
	hRetVal = S_OK;

ExitFunc:
	delete tstrCometServerName;
	delete tstrSubKeyName;
	lRet = RegCloseKey(hArraysKey);
    if (ERROR_SUCCESS != lRet)
    {
		RegCloseKey(hServerArrayKey);
		hServerArrayKey = NULL;
		::lgLogError(LOG_SEV_1,TEXT("[FindServerArrayEntry] RegCloseKey(hArraysKey) failed with %d"), lRet);
		::lgLogDetail(LOG_X,1,TEXT("[FindServerArrayEntry] exiting with E_UNEXPECTED"));
        hRetVal = E_UNEXPECTED;
    }
   
    return hRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\cpuhog.h ===
#ifndef __CPU_HOG_H
#define __CPU_HOG_H

//
// this class is used for hogging a resource.
// it differs from simple hogging by dynamically
// hogging all resources and then releasing some.
// the level of free resources can be controlled.
//


#include "hogger.h"

class CCpuHog : public CHogger
{
public:
	//
	// does not hog Resources yet.
	//
	CCpuHog(
		const DWORD dwComplementOfHogCycleIterations, 
		const DWORD dwSleepTimeAfterHog = 0
		);

	~CCpuHog(void);

protected:
	virtual void FreeAll(void);

	virtual bool HogAll(void);
	virtual bool FreeSome(void);
};

#endif //__CPU_HOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\cpuhog.cpp ===
//
// this class is used for hogging Resources.
// it differs from simple hogging by dynamically
// hogging all Resources and then releasing some.
// the level of free Resources can be controlled.
//

//#define HOGGER_LOGGING

#include "CpuHog.h"



CCpuHog::CCpuHog(
		const DWORD dwComplementOfHogCycleIterations, 
		const DWORD dwSleepTimeAfterHog
	)
	:
	CHogger(dwComplementOfHogCycleIterations, dwSleepTimeAfterHog, dwSleepTimeAfterHog)
{
}


CCpuHog::~CCpuHog(void)
{
	HaltHoggingAndFreeAll();
}

void CCpuHog::FreeAll(void)
{
	;
}


bool CCpuHog::HogAll(void)
{
    //
    // I consider free resources as the reciprocal of taken-resources,
    // and in this case each loop is a taken-resource.
    //
	DWORD dwHogCycleIterations = 
		(RANDOM_AMOUNT_OF_FREE_RESOURCES == m_dwMaxFreeResources) ?
		rand() && (rand()<<16) :
		0xFFFFFFFF - m_dwMaxFreeResources;

    while(dwHogCycleIterations--)
	{
		if (m_fAbort)
		{
			return false;
		}
		if (m_fHaltHogging)
		{
			return true;
		}
	}

	HOGGERDPF(("Hogged %d loops.\n", m_dwMaxFreeResources));

	return true;
}


bool CCpuHog::FreeSome(void)
{
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\fsp\vfsp\reg.h ===
// Module name:		reg.h
// Module author:	Sigalit Bar (sigalitb)
// Date:			13-Dec-98

#ifndef _REG_H
#define _REG_H

// FAX_PROVIDERS_REGKEY is the providers registry key under the fax registry key
//#define FAX_PROVIDERS_REGKEY           L"Software\\Microsoft\\Comet\\CometFax\\Device Providers"

// strings used with FaxRegisterServiceProvider()

// VFSP_PROVIDER is the newfsp registry key under the providers registry key
#define VFSP_PROVIDER                L"VFsp"
// VFSP_PROVIDER_FRIENDLYNAME is the friendly name of the newfsp service provider
#define VFSP_PROVIDER_FRIENDLYNAME   L"VFsp"
// VFSP_PROVIDER_IMAGENAME is the image name of the newfsp service provider
#define VFSP_PROVIDER_IMAGENAME      L"d:\\Vfsp\\VFSP.dll"
// VFSP_PROVIDER_PROVIDERNAME is the provider name of the newfsp service provider
#define VFSP_PROVIDER_PROVIDERNAME   L"VFsp"

// updated from build 693
#define FAX_ARRAYS_REGKEY         L"Software\\Microsoft\\Comet\\Arrays"
#define FAX_PROVIDERS_REGKEY      L"Software\\Microsoft\\BOSFax\\Device Providers"


// strings for manual registration
#define	API_VERSION_STR         TEXT("ApiVersion")
//VFSP_API_VERSION_VALUE is the provider's api version number
#define VFSP_API_VERSION_VALUE        0x10000
//
#define PROVIDER_CAPABILITIES_STR     TEXT("Capabilities")
//VFSP_CAPABILITIES_VALUE is the provider's capabilities identifier
#define VFSP_CAPABILITIES_VALUE       0x00000
//
#define PROVIDER_DESCRIPTION_STR      TEXT("Description")
//VFSP_DESCRIPTION_VALUE is the provider's text description
#define VFSP_DESCRIPTION              TEXT("Virtual FSP, simulates sending and receiving")
//
#define PROVIDER_FRIENDLY_NAME_STR    TEXT("FriendlyName")
//// VFSP_FRIENDLY_NAME is the friendly name of the newfsp service provider
#define VFSP_FRIENDLY_NAME            TEXT("Vfsp")
//
#define PROVIDER_IMAGE_NAME_STR       TEXT("ImageName")
//VFSP_IMAGE_NAME is the image name of the newfsp service provider
#define VFSP_IMAGE_NAME               TEXT("d:\\Vfsp\\VFSP.dll")
//
#define PROVIDER_GUID_STR             TEXT("Guid")
// the GUID value name that exists under every Provider
#define VFSP_GUID                     TEXT("{7729C6B3-1D72-11d3-B02C-0004AC2E7326}")
//


BOOL SetNewFspRegistryData( void );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\critsechog.cpp ===
//
// this class is used for hogging Resources.
// it differs from simple hogging by dynamically
// hogging all Resources and then releasing some.
// the level of free Resources can be controlled.
//

#define HOGGER_LOGGING

#include "CritSecHog.h"



CCritSecHog::CCritSecHog(
	const DWORD dwMaxFreeResources, 
	const DWORD dwSleepTimeAfterFullHog,
	const DWORD dwSleepTimeAfterReleasing
	)
	:
	CHogger(dwMaxFreeResources, dwSleepTimeAfterFullHog, dwSleepTimeAfterReleasing),
	m_dwNextFreeIndex(0)
{
    return;
}

CCritSecHog::~CCritSecHog(void)
{
	HaltHoggingAndFreeAll();
}


void CCritSecHog::FreeAll(void)
{
	HOGGERDPF(("before freeing all.\n"));

	for (; m_dwNextFreeIndex > 0; m_dwNextFreeIndex--)
	{
        ::DeleteCriticalSection(&m_acsHogger[m_dwNextFreeIndex-1]);
	}

	HOGGERDPF(("out of FreeAll().\n"));
}

bool CCritSecHog::HogAll(void)
{
	HOGGERDPF(("CCritSecHog::HogAll().\n"));

    __try
    {
	    for (; m_dwNextFreeIndex < 10*HANDLE_ARRAY_SIZE; m_dwNextFreeIndex++)
	    {
            if (m_fAbort)
		    {
			    return false;
		    }
		    if (m_fHaltHogging)
		    {
			    return true;
		    }

            ::InitializeCriticalSection(&m_acsHogger[m_dwNextFreeIndex]);
            ::EnterCriticalSection(&m_acsHogger[m_dwNextFreeIndex]);
	    }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // expecting STATUS_NO_MEMORY 
        //
        DWORD dwExceptionCode = ::GetExceptionCode();
        if (STATUS_NO_MEMORY != dwExceptionCode)
        {
            HOGGERDPF(("CCritSecHog::HogAll(): UN-EXPECTED exception 0x%08X after initializing %d Critical Sections.\n", dwExceptionCode, m_dwNextFreeIndex));
        }
        else
        {
            HOGGERDPF(("CCritSecHog::HogAll(): caught expected exception STATUS_NO_MEMORY after initializing %d Critical Sections.\n", m_dwNextFreeIndex));
        }

        return true;
    }

	HOGGERDPF(("Initialized %d Critical Sections.\n", m_dwNextFreeIndex));

	return true;
}


bool CCritSecHog::FreeSome(void)
{
	DWORD dwOriginalNextFreeIndex = m_dwNextFreeIndex;
	//
	// take care of RANDOM_AMOUNT_OF_FREE_RESOURCES case
	//
	DWORD dwToFree = 
		(RANDOM_AMOUNT_OF_FREE_RESOURCES == m_dwMaxFreeResources) ?
		rand() && (rand()<<16) :
		m_dwMaxFreeResources;
	dwToFree = min(dwToFree, m_dwNextFreeIndex);

	for (; m_dwNextFreeIndex > dwOriginalNextFreeIndex - dwToFree; m_dwNextFreeIndex--)
	{
        ::DeleteCriticalSection(&m_acsHogger[m_dwNextFreeIndex-1]);
	}//for (; m_ahHogger > dwOriginalNextFreeIndex - dwToFree; m_ahHogger--)

	HOGGERDPF(("CCritSecHog::FreeSome(): deleted %d critical sections.\n", dwToFree));
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\critsechog.h ===
#ifndef __CRIT_SEC_HOG_H
#define __CRIT_SEC_HOG_H

//
// this class is used for hogging a resource.
// it differs from simple hogging by dynamically
// hogging all resources and then releasing some.
// the level of free resources can be controlled.
//


#include "hogger.h"

class CCritSecHog : public CHogger
{
public:
	//
	// does not hog Resources yet.
	//
	CCritSecHog(
		const DWORD dwMaxFreeResources, 
		const DWORD dwSleepTimeAfterFullHog = 1000, 
		const DWORD dwSleepTimeAfterReleasing = 1000
		);

	~CCritSecHog(void);

protected:
	virtual void FreeAll(void);

	virtual bool HogAll(void);
	virtual bool FreeSome(void);

    //
    // the hogger array
    //
    CRITICAL_SECTION m_acsHogger[10*HANDLE_ARRAY_SIZE];

    //
    // index to next free entry in hogger array
    //
	DWORD m_dwNextFreeIndex;

};

#endif //__CRIT_SEC_HOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\diskhog.h ===
#ifndef __DISK_HOG_H
#define __DISK_HOG_H

//
// this class is used for hogging a resource.
// it differs from simple hogging by dynamically
// hogging all resources and then releasing some.
// the level of free resources can be controlled.
//


#include "hogger.h"

class CDiskHog : public CHogger
{
public:
	//
	// does not hog Resources yet.
	//
	CDiskHog(
		LPCTSTR szTempPath,
		const DWORD dwMaxFreeResources, 
		const DWORD dwSleepTimeAfterFullHog = 1000, 
		const DWORD dwSleepTimeAfterReleasing = 1000
		);

	~CDiskHog(void);

protected:
	virtual void FreeAll(void);

	virtual bool HogAll(void);
	virtual bool FreeSome(void);

	//
	// the path of the temp file
	//
	TCHAR m_szTempPath[MAX_PATH+1];

	//
	// the temp file name - a la hogger.
	//
	TCHAR m_szTempFile[MAX_PATH+1];

	HANDLE m_hTempFile;

	//
	// low order DWORD of file size to try.
	//
	long m_lLastLowTry;

	//
	// high order DWORD of file size to try.
	//
	long m_lLastHighTry;
};

#endif //__DISK_HOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\diskhog.cpp ===
//
// this class is used for hogging Resources.
// it differs from simple hogging by dynamically
// hogging all Resources and then releasing some.
// the level of free Resources can be controlled.
//

//#define HOGGER_LOGGING

#include "DiskHog.h"



CDiskHog::CDiskHog(
	LPCTSTR szTempPath,
	const DWORD dwMaxFreeResources, 
	const DWORD dwSleepTimeAfterFullHog,
	const DWORD dwSleepTimeAfterReleasing
	)
	:
	CHogger(dwMaxFreeResources, dwSleepTimeAfterFullHog, dwSleepTimeAfterReleasing),
	m_lLastLowTry(0),
	m_lLastHighTry(0x40000000)
{
	//
	// copy temp path
	//
	::lstrcpyn(m_szTempPath, szTempPath, MAX_PATH);
	m_szTempPath[MAX_PATH] = TEXT('\0');

	//
	// create tem file for hogging
	//
	UINT ui = ::GetTempFileName(
		m_szTempPath,  // pointer to directory name for temporary file
		TEXT("Hog"),  // pointer to filename prefix
		0,        // number used to create temporary filename
		m_szTempFile // pointer to buffer that receives the new filename
		);
    if (0 == ui)
    {
		throw CException(
			TEXT("CDiskHog::CDiskHog(): GetTempFileName(%s) failed with %d"), 
			m_szTempPath,
			::GetLastError()
			);
    }
 
	m_hTempFile = ::CreateFile(  
		m_szTempFile,          // pointer to name of the file
		GENERIC_WRITE | GENERIC_READ,       // access (read-write) mode
		0,           // share mode
		0, // pointer to security attributes
		CREATE_ALWAYS,  // how to create
		FILE_FLAG_DELETE_ON_CLOSE,  // file attributes
		NULL         // handle to file with attributes to copy
		);
	if (INVALID_HANDLE_VALUE == m_hTempFile)
	{
		throw CException(
			TEXT("CDiskHog::CDiskHog(): CreateFile(%s) failed with %d"), 
			m_szTempFile,
			::GetLastError()
			);
	}
	HOGGERDPF(("Created temp file: %s.\n", m_szTempFile));
}

//
// set temp file size to 0, and delete the file
//
CDiskHog::~CDiskHog(void)
{
	HaltHoggingAndFreeAll();

	if (!::CloseHandle(m_hTempFile))
	{
		HOGGERDPF(("CDiskHog::~CDiskHog(void): CloseHandle() failed with %d.\n", ::GetLastError()));
	}
	if (!::DeleteFile(m_szTempFile))
	{
        //
        // we may fail, because the file is FILE_FLAG_DELETE_ON_CLOSE
        //
	}
}


//
// algorithm: set temp file size to 0.
//
void CDiskHog::FreeAll(void)
{
	HOGGERDPF(("before freeing all.\n"));

	long zero = 0;
	DWORD dwPtrLow = ::SetFilePointer(
		m_hTempFile,          // handle of file
		0,  // number of bytes to move file pointer
		&zero,// pointer to high-order DWORD of distance to move
		FILE_BEGIN     // how to move
		);
	// Test for failure
	DWORD dwError;
	if (dwPtrLow == 0xFFFFFFFF && (dwError = ::GetLastError()) != NO_ERROR )
	{ 
		HOGGERDPF(("CDiskHog::FreeAll(void): SetFilePointer() failed with %d.\n", dwError));
	}

	if (! ::SetEndOfFile(m_hTempFile))
	{ 
		HOGGERDPF(("CDiskHog::FreeAll(void): SetEndOfFile() failed with %d.\n", ::GetLastError()));
	}

	HOGGERDPF(("out of FreeAll().\n"));
}

//
// hog all diskspace
// algorithm:
//   Try to set the filesize as 2^62. 
//   if succeeds, try to add 2^61 to filesize. 
//   Else, try to set filesize as 2^61.
//   Try to set the filesize as 2^62+2^61 (or 2^61, depending on previous step).
//   if succeeds, try to add 2^60 to filesize. 
//   Else, try to set filesize as 2^62+2^60 (or 2^60, depending on previous step).
//   I think you got the idea.
//
//   The implementation, has 2 steps: 1 for high long, and 1 for low long.
//   Each step is implemented using bittology (bit arithmetic).
//
bool CDiskHog::HogAll(void)
{
	//
	// this bit will shift right as we progress.
	// it marks the next bit that we try to set in the size bitmask.
	//
	DWORD dwCurrentLeastSignificatBit = 0x40000000;

	//
	// this is the size bitmask
	//
	m_lLastHighTry = m_lLastHighTry | dwCurrentLeastSignificatBit;

	//
	// try to set the filesize, with current m_lLastLowTry, but maximal m_lLastHighTry.
	// note that this loop may (and usually will) leave the loop with value of 0.
	//
#pragma warning (disable:4127)
	while(true)
#pragma warning (default:4127)
	{
		if (m_fAbort)
		{
			return false;
		}

		if (m_fHaltHogging)
		{
			return true;
		}

		//
		// try to hog this amount
		//
		HOGGERDPF(("CDiskHog::HogAll(void): trying SetFilePointer(0x%08X, 0x%08X).\n", m_lLastHighTry, m_lLastLowTry));
		DWORD dwPtrLow = ::SetFilePointer(
			m_hTempFile,          // handle of file
			m_lLastLowTry,  // number of bytes to move file pointer
			&m_lLastHighTry,// pointer to high-order DWORD of distance to move
			FILE_BEGIN     // how to move
			);
		// Test for (not failure)
		DWORD dwError;
		if (!(dwPtrLow == 0xFFFFFFFF && (dwError = ::GetLastError()) != NO_ERROR ))
		{
			//
			// not hogged yet, still need to set end of file
			//
			HOGGERDPF(("CDiskHog::HogAll(void): SetFilePointer() succeeded.\n"));

			//
			// try to acually seek to there. this is the real test for success
			//
			if (::SetEndOfFile(m_hTempFile))
			{
				//
				// we succeeded to hog this amount, so add another bit
				//
				dwCurrentLeastSignificatBit = dwCurrentLeastSignificatBit >> 1;
				m_lLastHighTry = m_lLastHighTry | dwCurrentLeastSignificatBit;
				continue;
			}

			if (ERROR_DISK_FULL != ::GetLastError())
			{
				//
				// this is NOT expected, but i do not care, since i do not test the file system,
				// i just want to hog!
				// so i failed, i do not care why!
				HOGGERDPF(("CDiskHog::HogAll(void): SetEndOfFile() failed with %d.\n", ::GetLastError()));
				//MessageBox(NULL, szMessage, "DiskHogger", MB_OK);
			}
			else
			{
				//
				// this is expected
				//
				HOGGERDPF(("CDiskHog::HogAll(void): SetEndOfFile() failed with ERROR_DISK_FULL.\n"));
			}

		}

		//
		// we failed. we now need to move the lsb one bit to the right.
		// if lsb was 0, we've finished with high dword, else we try again.
		//
		HOGGERDPF(("CDiskHog::HogAll(void): SetFilePointer() failed with %d, or SetEndOfFile() failed with ERROR_DISK_FULL.\n", dwError));

		m_lLastHighTry = (m_lLastHighTry & (~dwCurrentLeastSignificatBit));
		dwCurrentLeastSignificatBit = dwCurrentLeastSignificatBit >> 1;
		if (0 == dwCurrentLeastSignificatBit)
		{
			break;
		}
		m_lLastHighTry = m_lLastHighTry | dwCurrentLeastSignificatBit;
	}
	//
	// we have found a high dword that succeeds to allocate.
	// now try with low part.
	//
	dwCurrentLeastSignificatBit = 0x80000000;
	m_lLastLowTry = m_lLastLowTry | dwCurrentLeastSignificatBit;

	HOGGERDPF(("CDiskHog::HogAll(void): finished with high part.\n"));
#pragma warning (disable:4127)
	while(true)
#pragma warning (default:4127)
	{
		if (m_fAbort)
		{
			return false;
		}

		if (m_fHaltHogging)
		{
			return true;
		}

		HOGGERDPF(("CDiskHog::HogAll(void): trying SetFilePointer(0x%08X, 0x%08X).\n", m_lLastHighTry, m_lLastLowTry));
		DWORD dwPtrLow = ::SetFilePointer(
			m_hTempFile,          // handle of file
			m_lLastLowTry,  // number of bytes to move file pointer
			&m_lLastHighTry,// pointer to high-order DWORD of distance to move
			FILE_BEGIN     // how to move
			);
		// Test for (not failure)
		DWORD dwError;
		if (!(dwPtrLow == 0xFFFFFFFF && (dwError = ::GetLastError()) != NO_ERROR ))
		{
			//
			// not hogged yet, still need to set end of file
			//

			if (::SetEndOfFile(m_hTempFile))
			{ 
				//
				// we succeeded to hog this amount, so add another bit
				//
				dwCurrentLeastSignificatBit = dwCurrentLeastSignificatBit >> 1;
				m_lLastLowTry = m_lLastLowTry | dwCurrentLeastSignificatBit;
				HOGGERDPF(("CDiskHog::HogAll(void): SetEndOfFile() succeeded. dwCurrentLeastSignificatBit=0x%08X, m_lLastLowTry=0x%08X.\n", dwCurrentLeastSignificatBit, m_lLastLowTry));
				if (0 == dwCurrentLeastSignificatBit)
				{
					break;
				}
				continue;
			}

			if (ERROR_DISK_FULL != ::GetLastError())
			{
				//
				// this is NOT expected, but i do not care, since i do not test the file system,
				// i just want to hog!
				// so i failed, i do not care why!
				HOGGERDPF(("CDiskHog::HogAll(void): SetEndOfFile() failed with %d.\n", ::GetLastError()));
			}
			else
			{
				//
				// this is expected
				//
				HOGGERDPF(("CDiskHog::HogAll(void): SetEndOfFile() failed with ERROR_DISK_FULL.\n"));
			}
		}

		//
		// we failed. we now need to move the lsb one bit to the left.
		// if lsb was 0, we've finished with high dword, else we try again.
		//
		HOGGERDPF(("CDiskHog::HogAll(void): SetFilePointer() failed with %d, or SetEndOfFile() failed with ERROR_DISK_FULL.\n", dwError));

		m_lLastLowTry = (m_lLastLowTry & (~dwCurrentLeastSignificatBit));
		dwCurrentLeastSignificatBit = dwCurrentLeastSignificatBit >> 1;
		if (0 == dwCurrentLeastSignificatBit)
		{
			break;
		}
		m_lLastLowTry = m_lLastLowTry | dwCurrentLeastSignificatBit;
	}

	HOGGERDPF(("Hogged 0x%08x %08x bytes.\n", m_lLastHighTry, m_lLastLowTry));

	return true;
}


bool CDiskHog::FreeSome(void)
{
	//
	// take care of RANDOM_AMOUNT_OF_FREE_RESOURCES case
	// no point in freeing more than 2^31 bytes, so we subtract only low part.
	//
	DWORD dwMaxFreeDiskSpace = 
		(RANDOM_AMOUNT_OF_FREE_RESOURCES == m_dwMaxFreeResources) ?
		rand() && (rand()<<16) :
		m_dwMaxFreeResources;

	if (m_lLastLowTry <= (long)dwMaxFreeDiskSpace)
	{
		m_lLastLowTry = 0;
	}
	else
	{
		m_lLastLowTry = m_lLastLowTry - dwMaxFreeDiskSpace;
	}

	HOGGERDPF(("CDiskHog::FreeSome(void): trying to release % bytes, SetFilePointer(0x%08X, 0x%08X).\n", m_dwMaxFreeResources, m_lLastHighTry, m_lLastLowTry));
	DWORD dwPtrLow = ::SetFilePointer(
		m_hTempFile,          // handle of file
		m_lLastLowTry,  // number of bytes to move file pointer
		&m_lLastHighTry,// pointer to high-order DWORD of distance to move
		FILE_BEGIN     // how to move
		);
	// Test for (not failure)
	DWORD dwError;
	if (!(dwPtrLow == 0xFFFFFFFF && (dwError = ::GetLastError()) != NO_ERROR ))
	{
		//
		// we succeeded
		//
		if (::SetEndOfFile(m_hTempFile))
		{ 
			return true;
		}

		//
		// oops!
		// could it be that we failed to free diskspace?
		//
		HOGGERDPF(("Strange: SetEndOfFile() failed with %d when reducing file size!", ::GetLastError()));
		//MessageBox(NULL, szMessage, "DiskHogger", MB_OK);
		// return true anyway, since we are not interested in API failures.
	}

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\hogger.h ===
#ifndef __HOGGER_H
#define __HOGGER_H


//#define HOGGER_LOGGING

//
// this class is used as a base class for resource hogging classes.
// it differs from simple hogging by dynamically
// hogging all resources and then releasing some.
// the level of free resources can be controlled.
//


#define HANDLE_ARRAY_SIZE (1024*1024)

#pragma warning(disable:4201) // nonstandard extension used : nameless struct/union

#include <windows.h>
#include <stdio.h>

#include <crtdbg.h>

#pragma warning(default:4201) // nonstandard extension used : nameless struct/union


#define _ASSERTE_(expr) CHogger::__assert__((expr), TEXT(__FILE__), __LINE__, TEXT(#expr)) 

#include "..\exception\exception.h"

//
// a simple debug print macro
//
#ifdef HOGGER_LOGGING
	#define HOGGERDPF(x) printf x; fflush(stdout);
#else
	#define HOGGERDPF(x) 
#endif

//
// this value is used, if you want the amount of free resources (delta),
// to be random.
//
#define RANDOM_AMOUNT_OF_FREE_RESOURCES (-1)

class CHogger
{
public:
	//
	// does not hog Resources yet.
	//
	CHogger(
		const DWORD dwMaxFreeResources, 
		const DWORD dwSleepTimeAfterFullHog = 1000, 
		const DWORD dwSleepTimeAfterFreeingSome = 1000
		);
	virtual ~CHogger(void);

	//
	// start hogging Resources, leaving amount set by ctor or by SetMaxFreeResources()
	//
	void StartHogging(void);

	//
	// halts hogging, i.e. Resources is not freed, but the cycle of free-hog is halted
	//
	void HaltHogging(void);

	//
	// stop the cycle of free-hog, and free all Resources
	//
	virtual void HaltHoggingAndFreeAll(void);

	//
	// this method should hog all the resources.
	// called by the hogger thread.
	//
	virtual bool HogAll(void) = 0;

	//
	// this method should free the amount of resources, according to m_dwMaxFreeResources.
	// do not forget that m_dwMaxFreeResources can be RANDOM_AMOUNT_OF_FREE_RESOURCES.
	// called by the hogger thread.
	//
	virtual bool FreeSome(void) = 0;

	//
	// stop the cycle of free-hog, and free all Resources
	//
	virtual void FreeAll(void) = 0;

	//
	// set the amout of Resources to leave un-allocated.
	// this method can be called while hogging.
	//
	void SetMaxFreeResources(const DWORD dwMaxFreeResources)
	{
		HaltHogging();
		m_dwMaxFreeResources = dwMaxFreeResources;
		StartHogging();
	}

	void SetSleepTimeAfterFullHog(const DWORD dwSleepTimeAfterFullHog)
	{
		m_dwSleepTimeAfterFullHog = dwSleepTimeAfterFullHog;
	}

	void SetSleepTimeAfterFreeingSome(const DWORD dwSleepTimeAfterFreeingSome)
	{
		m_dwSleepTimeAfterFreeingSome = dwSleepTimeAfterFreeingSome;
	}

    static void __assert__(BOOL expr, TCHAR *szFile, int line, TCHAR *szExpr)
    {
#ifdef DEBUG
        if (!(expr) && (1 == _CrtDbgReport(_CRT_ASSERT, szFile, line, NULL, szExpr)))
        {
             _CrtDbgBreak(); 
        }
#else
        UNREFERENCED_PARAMETER(expr);
        UNREFERENCED_PARAMETER(szFile);
        UNREFERENCED_PARAMETER(line);
        UNREFERENCED_PARAMETER(szExpr);
#endif
    }

    static TCHAR* GetUniqueName(
        TCHAR *szUnique, 
        DWORD dwSize
        );


protected:
	//
	// req to the hooging thread to halt hogging (i.e. STAY!)
	// implementation of HogAll() and/or FreeSome() may need to sample this value,
	// so that a response to a halt request is quicker.
	//
	long m_fHaltHogging;

	//
	// signal to the hooging thread to abort.
	// implementation of HogAll() and/or FreeSome() may need to sample this value,
	// so that a response to an abort request is quicker.
	// hogger thread resets it to signal an ack, before exiting.
	//
	long m_fAbort;

	//
	// the number of resources to hog.
	// each sub-class has a different meaning.
	// a memory hogger will count memory bytes, an GDI hogger will count GDI objects
	//
	DWORD m_dwMaxFreeResources;

	//
	// handle to the hogger thread
	//
	HANDLE m_hthHogger;

private:
	//
	// the thread that acually hogs Resources
	//
	static friend DWORD WINAPI HoggerThread(void *pVoid);

	//
	// stop the hogging thread, and wait for the thread to finish
	//
	void AbortHoggingThread(void);

	//
	// used by the thread, to handle halt requests
	//
	bool IsHaltHogging();

	//
	// signals the hogger thread to abort, wait for it
	// to abort, and close the thread's handle
	//
	void CloseHoggerThread(void);

	//
	// req to the hoging thread to start hogging.
	// should be acked with m_fStartedHogging
	//
	long m_fStartHogging;

	//
	// ack from the hogging thread to m_fStartHogging req.
	//
	long m_fStartedHogging;

	//
	// ack from the hooging thread, to the m_fHaltHogging req.
	//
	long m_fHaltedHogging;

	DWORD m_dwSleepTimeAfterFullHog;

	DWORD m_dwSleepTimeAfterFreeingSome;

};

#endif //__HOGGER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\hogger.cpp ===
//
// this class is used for hogging Resources.
// it differs from simple hogging by dynamically
// hogging all Resources and then releasing some.
// the level of free Resources can be controlled.
//

//#define HOGGER_LOGGING


#include "Hogger.h"
#include <time.h>


//
// HoggerThread()
// algorithm:
//   always do the cycle of hog & release, untill aborted, or halted.
//   Abort means that the threads exits.
//   Halt means that the threads starts polling for start or abort.
//
//   cycle is: hog all resources, sleep m_dwSleepTimeAfterFullHog, free some resources.
//    sleep m_dwSleepTimeAfterFreeingSome.
//
//   the thread can be aborted, halted, and started.
//   abort - exit from the thread.
//   halt - wait for start or abort.
//   start - start the hog-release cycle.
//
//   return value - not used, always TRUE.
//
static DWORD WINAPI HoggerThread(void *pVoid)
{
	_ASSERTE_(NULL != pVoid);

	//
	// get the this pointer of this object
	//
	CHogger *pThis = (CHogger*)pVoid;

	//
	// continuously loop untill aborted
	//
	while(!pThis->m_fAbort)
	{
		//
		// wait for signal to start.
		// I use polling because I do not want to rely on any
		// thing fancy in low resources state.
		// note that we should be ready for a m_fHaltHogging signal too.
		//
		while (!pThis->m_fStartHogging)
		{
			#ifdef HOGGER_LOGGING
				::Sleep(1000);
			#endif
			HOGGERDPF(("wait for (!pThis->m_fStartHogging).\n"));
			//
			// always be ready to abort
			//
			if (pThis->m_fAbort)
			{
				goto out;
			}
			
			//
			// we may get a halt request, so we need to ack it.
			//
			pThis->IsHaltHogging();

			//
			// in order not to hog cpu while polling
			//
			::Sleep(10);
		}
		HOGGERDPF(("received m_fStartHogging).\n"));
		if (!pThis->m_fStartedHogging) Sleep(1000);//let main show menu
		//
		// started, mark as started
		//
		::InterlockedExchange(&pThis->m_fStartedHogging, TRUE);
		::InterlockedExchange(&pThis->m_fHaltedHogging, FALSE);// is that really needed?

		HOGGERDPF(("Before hog cycle.\n"));
		if (!pThis->HogAll())
        {
    		HOGGERDPF(("HoggerThread(): got abort during HogAll().\n"));
            goto out;//aborted
        }

		if (pThis->IsHaltHogging()) continue;

		::Sleep(pThis->m_dwSleepTimeAfterFullHog);

		if (!pThis->FreeSome())
        {
    		HOGGERDPF(("HoggerThread(): got abort during FreeSome().\n"));
            goto out;//aborted
        }

		//
		// i had the feeling that freeing was not enough.
		// so lets trim this process down, and let others breathe some air
		//
		if (!SetProcessWorkingSetSize(GetCurrentProcess(), (SIZE_T)-1, (SIZE_T)-1))
		{
			HOGGERDPF(("HoggerThread(): SetProcessWorkingSetSize(-1, -1) failed with %d. Out of memory?\n", ::GetLastError()));
		}

		HOGGERDPF(("finished free cycle.\n"));
		::Sleep(pThis->m_dwSleepTimeAfterFreeingSome);

	}//while(!pThis->m_fAbort)

out:
	//
	// i was aborted so mark this thread as aborted
	//
	::InterlockedExchange(&pThis->m_fAbort, FALSE);

	return TRUE;
}//static DWORD WINAPI HoggerThread(void *pVoid)


//
// init members, and create the hogger thread
//
CHogger::CHogger(
	const DWORD dwMaxFreeResources, 
	const DWORD dwSleepTimeAfterFullHog, 
	const DWORD dwSleepTimeAfterFreeingSome
	):
	m_dwMaxFreeResources(dwMaxFreeResources),
	m_fAbort(false),
	m_fStartHogging(false),
	m_fHaltHogging(false),
	m_dwSleepTimeAfterFullHog(dwSleepTimeAfterFullHog),
	m_dwSleepTimeAfterFreeingSome(dwSleepTimeAfterFreeingSome)
{
    //
    // seeding random for any deriving class
    //
	srand( (unsigned)time( NULL ) );	
	
	//
	// create the hogging thread
	//
	DWORD dwThreadId;
	m_hthHogger = CreateThread(
		NULL,// pointer to thread security attributes 
		0,// initial thread stack size, in bytes 
		HoggerThread,// pointer to thread function 
		this,// argument for new thread 
		0,// creation flags 
		&dwThreadId// pointer to returned thread identifier 
		);
	if (NULL == m_hthHogger)
	{
		throw CException(
			TEXT("CHogger(): CreateThread(HoggerThread) failed with %d"), 
			::GetLastError()
			);
	}

}

//
// close the hogger thread
//
CHogger::~CHogger(void)
{
	HOGGERDPF(("CHogger::~CHogger() in.\n"));

	if (NULL != m_hthHogger)
	{
		CloseHoggerThread();
	}
	HOGGERDPF(("CHogger::~CHogger() out.\n"));
}

//
// abort hogger thread, and close its handle
//
void CHogger::CloseHoggerThread(void)
{
	HOGGERDPF(("CHogger::CloseHoggerThread() in.\n"));

	AbortHoggingThread();

    if (!::CloseHandle(m_hthHogger))
	{
		throw CException(
			TEXT("CloseHoggerThread(): CloseHandle(m_hthHogger) failed with %d"), 
			::GetLastError()
			);
	}
	HOGGERDPF(("CHogger::CloseHoggerThread() out.\n"));
}


//
// polling is used because we are probably out of resources
//
void CHogger::StartHogging(void)
{
	::InterlockedExchange(&m_fStartedHogging, FALSE);
	::InterlockedExchange(&m_fHaltHogging, FALSE);
	::InterlockedExchange(&m_fStartHogging, TRUE);

	//
	// m_fStartedHogging will become false as soon as the thread acks
	//
	HOGGERDPF(("waiting for !m_fStartedHogging.\n"));
	while(!m_fStartedHogging)
	{
		Sleep(10);
	}
	::InterlockedExchange(&m_fStartedHogging, FALSE);
}

//
// polling is used because we are probably out of resources
//
void CHogger::HaltHogging(void)
{
	::InterlockedExchange(&m_fHaltedHogging, FALSE);
	::InterlockedExchange(&m_fStartHogging, FALSE);
	::InterlockedExchange(&m_fHaltHogging, TRUE);

	//
	// m_fHaltedHogging will become false as soon as the thread halts
	//
	HOGGERDPF(("HaltHogging(): before while(!m_fHaltedHogging).\n"));
	while(!m_fHaltedHogging)
	{
		Sleep(10);
	}
	::InterlockedExchange(&m_fHaltedHogging, FALSE);
	::InterlockedExchange(&m_fHaltHogging, FALSE);

	HOGGERDPF(("out of HaltHogging().\n"));
}


//
// polling is used because we are probably out of resources
//
void CHogger::AbortHoggingThread(void)
{
	HOGGERDPF(("CHogger::AbortHoggingThread() in.\n"));
	//
	// sognal thread to abort
	//
	::InterlockedExchange(&m_fAbort, TRUE);

	//
	// wait for thread to confirm
	//
	HOGGERDPF(("CHogger::AbortHoggingThread(): waiting for m_fAbort.\n"));
	while(m_fAbort)
	{
		Sleep(10);
	}
	HOGGERDPF(("CHogger::AbortHoggingThread() out.\n"));
}


//
// used by hogger thread, to handle halt request.
// if requested to abort, acks, and waits for ack to reset.
// returns true if was aborted, false if not.
//
bool CHogger::IsHaltHogging(void)
{
	if (m_fHaltHogging)
	{
		HOGGERDPF(("IsHaltHogging(): m_fHaltHogging.\n"));
		//
		// mark that i halted hogging
		//
		::InterlockedExchange(&m_fHaltedHogging, TRUE);
		HOGGERDPF(("IsHaltHogging(): before while(m_fHaltedHogging).\n"));
		//
		// wait for signaller to confirm
		//
		while(m_fHaltedHogging)
		{
			Sleep(10);
		}
		HOGGERDPF(("IsHaltHogging(): after while(m_fHaltedHogging).\n"));

		return true;
	}

	return false;
}


void CHogger::HaltHoggingAndFreeAll(void)
{
	HOGGERDPF(("CHogger::HaltHoggingAndFreeAll() in.\n"));
	HaltHogging();

	//
	// this method must be implemented by derived methods!
	//
	FreeAll();
	HOGGERDPF(("CHogger::HaltHoggingAndFreeAll() out.\n"));
}


TCHAR* CHogger::GetUniqueName(
    TCHAR *szUnique, 
    DWORD dwSize
    )
{
	::_sntprintf(
        szUnique, 
        dwSize-1, 
        TEXT("%X.tmp"), 
        ::GetTickCount() + (rand()<<16 | rand())
        );
	szUnique[dwSize-1] = TEXT('\0');

    return szUnique;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\main.cpp ===
#include "MemHog.h"
#include "RemoteMemHog.h"
#include "DiskHog.h"
#include "CpuHog.h"
#include "RegistryHog.h"
#include "PHDesktopHog.h"
#include "PHMutexHog.h"
#include "PHEventHog.h"
#include "PHFileMapHog.h"
#include "PHBrushHog.h"
#include "PHPenHog.h"
#include "PHBitMapHog.h"
#include "PHPenHog.h"
#include "PHBrushHog.h"
#include "PHJobObjectHog.h"
#include "PHSemaphoreHog.h"
#include "PHThreadHog.h"
#include "PHProcessHog.h"
#include "PHWSASocketHog.h"
#include "PHFileHog.h"
#include "PHTimerHog.h"
#include "PHTimerQueueHog.h"
#include "PHRegisterWaitHog.h"
#include "PHKeyHog.h"
#include "PHMailSlotHog.h"
#include "PHRemoteThreadHog.h"
#include "PHCompPortHog.h"
#include "PHWindowHog.h"
#include "PHWinStationHog.h"
#include "PHPipeHog.h"
#include "PHDCHog.h"
#include "PHPrinterHog.h"
#include "PHConScrnBuffHog.h"
#include "PHServiceHog.h"
#include "PHSC_HHog.h"
#include "PHHeapHog.h"
#include "PostMessageHog.h"
#include "PostThreadMessageHog.h"
#include "PostCompPackHog.h"
#include "CritSecHog.h"
#include "PHFiberHog.h"
#include "QueueAPCHog.h"
#include "PHRgstrEvntSrcHog.h"

//#include "terminator.h"

int GetDelta()
{
	int nDelta;
	_tprintf(TEXT("enter -1:to exit\n"));
    _tprintf(TEXT("-2:to halt hogging\n"));
    _tprintf(TEXT("-3:to stop hogging\n"));
    _tprintf(TEXT("<resources-free> to hog MaxResources-<resources-free> to MaxResources: "));
	scanf("%d", &nDelta);

    return nDelta;
}

bool g_fDeleting_g_pHogger = false;
CHogger *g_pHogger[5] = {NULL, NULL, NULL, NULL, NULL};
//CTerminator *g_pTerminator = NULL;

void DeleteHoggers()
{
    for (int i = 0; i < (sizeof(g_pHogger) / sizeof(*g_pHogger)); i++)
    {
        if (g_pHogger[i]) g_pHogger[i]->HaltHogging();
    }
    for (i = 0; i < (sizeof(g_pHogger) / sizeof(*g_pHogger)); i++)
    {
        delete g_pHogger[i];
        g_pHogger[i] = NULL;
    }
}

BOOL WINAPI Handler_Routine(DWORD dwCtrlType)
{
	switch(dwCtrlType)
    {
    case CTRL_C_EVENT:
    case CTRL_BREAK_EVENT:
    case CTRL_LOGOFF_EVENT:
    case CTRL_SHUTDOWN_EVENT:
        if (g_pHogger[0]) 
        {
            //
            // BUGBUG: g_fDeleting_g_pHogger should be interlock set to true
            //
            if (!g_fDeleting_g_pHogger)
            {
                g_fDeleting_g_pHogger = true;
			    _tprintf(TEXT("Aborting... Please wait while freeing resources....\n"));
                DeleteHoggers();
                exit(-1);
            }
            else
            {
                TCHAR szResponse[1024];
    			_tprintf(TEXT("Already aborting. abort now with risk of leaving persistent hog residues?[Y/N]:"));
                _tscanf(TEXT("%s"), szResponse);
                if ( (TEXT('y') == szResponse[0]) || (TEXT('Y') == szResponse[0]) )
                {
    			    _tprintf(TEXT("Crashing... ;-)\n"));
                    _exit(-1);
                }
            }
        }

        break;

    case CTRL_CLOSE_EVENT:
        ExitProcess(2);


    }

	return true;

}

void Usage(TCHAR *szThisExe)
{
	::system("ReadMe.doc");
    exit(-1);
}



int main(int argc, char *argvA[])
{
    bool fNamedObject = false;
    TCHAR *pszObjType = NULL;
    TCHAR *pszOptionalString = NULL;
    DWORD dwFreeResources = 0xFFFFFFFF; // means auto start

	LPTSTR *szArgv;
#ifdef UNICODE
    UNREFERENCED_PARAMETER(argvA);
	szArgv = CommandLineToArgvW( GetCommandLine(), &argc );
#else
	szArgv = argvA;
#endif

	try
	{
		if (argc < 6)
		{
            Usage(szArgv[0]);
		}

        DWORD dwSleepBeforeStarting = _ttoi(szArgv[1]);

        pszObjType = szArgv[2];

        DWORD dwSleepAfterHog = _ttoi(szArgv[3]);
        DWORD dwSleepAfterFree = _ttoi(szArgv[4]);
        DWORD dwFreeResources = _ttoi(szArgv[5]);

		if (argc > 6)
		{
            pszOptionalString = szArgv[6];
		}

        if (! ::SetConsoleCtrlHandler(
			      Handler_Routine,  // address of handler function
			      true                          // handler to add or remove
			      ))
	    {
		    _tprintf(TEXT("SetConsoleCtrlHandler() failed with %d.\n"),GetLastError());
		    exit(1);
	    }

		int nDelta;

retry_allocating_hogger:
        if (0 == lstrcmpi(pszObjType, TEXT("memory")))
        {
			g_pHogger[0] = new CMemHog(1024, dwSleepAfterHog, dwSleepAfterFree);
        }
		else if (0 == lstrcmpi(pszObjType, TEXT("RemoteMemory")))
        {
			g_pHogger[0] = new CRemoteMemHog(1024, dwSleepAfterHog, dwSleepAfterFree, true);
        }
		else if (0 == lstrcmpi(pszObjType, TEXT("VirtualAlloc")))
        {
			g_pHogger[0] = new CRemoteMemHog(1024, dwSleepAfterHog, dwSleepAfterFree, false);
        }
		else if (0 == lstrcmpi(pszObjType, TEXT("bitmap")))
        {
			g_pHogger[0] = new CPHBitMapHog<1024>(1024, dwSleepAfterHog, dwSleepAfterFree);
        }
		else if (0 == lstrcmpi(pszObjType, TEXT("pen")))
        {
			g_pHogger[0] = new CPHPenHog(1024, dwSleepAfterHog, dwSleepAfterFree);
        }
		else if (0 == lstrcmpi(pszObjType, TEXT("brush")))
        {
			g_pHogger[0] = new CPHBrushHog(1024, dwSleepAfterHog, dwSleepAfterFree);
        }
		else if (0 == lstrcmpi(pszObjType, TEXT("cpu")))
        {
            _tprintf(TEXT("CPU hogging was removed from the hogger.\n"));
            exit(-1);
			g_pHogger[0] = new CCpuHog(1024, dwSleepAfterHog);
        }
		else if (0 == lstrcmpi(pszObjType, TEXT("thread")))
        {
			g_pHogger[0] = new CPHThreadHog(1024, dwSleepAfterHog, dwSleepAfterFree, true);
        }
		else if (0 == lstrcmpi(pszObjType, TEXT("threadNS")))
        {
			g_pHogger[0] = new CPHThreadHog(1024, dwSleepAfterHog, dwSleepAfterFree, false);
        }
		else if (0 == lstrcmpi(pszObjType, TEXT("remotethread")))
        {
			g_pHogger[0] = new CPHRemoteThreadHog(1024, dwSleepAfterHog, dwSleepAfterFree, true);
        }
		else if (0 == lstrcmpi(pszObjType, TEXT("remotethreadNS")))
        {
			g_pHogger[0] = new CPHRemoteThreadHog(1024, dwSleepAfterHog, dwSleepAfterFree, false);
        }
		else if (0 == lstrcmpi(pszObjType, TEXT("CompPort")))
        {
			g_pHogger[0] = new CPHCompPortHog(1024, dwSleepAfterHog, dwSleepAfterFree, false);
        }
		else if (0 == lstrcmpi(pszObjType, TEXT("CompPortW")))
        {
			g_pHogger[0] = new CPHCompPortHog(1024, dwSleepAfterHog, dwSleepAfterFree, true);
        }
		else if (0 == lstrcmpi(pszObjType, TEXT("Window")))
        {
			g_pHogger[0] = new CPHWindowHog(1024, dwSleepAfterHog, dwSleepAfterFree, fNamedObject/*visible*/);
        }
		else if (0 == lstrcmpi(pszObjType, TEXT("WinStation")))
        {
			g_pHogger[0] = new CPHWinStationHog(1024, dwSleepAfterHog, dwSleepAfterFree);
        }
		else if (0 == lstrcmpi(pszObjType, TEXT("pipe")))
        {
			g_pHogger[0] = new CPHPipeHog(1024, dwSleepAfterHog, dwSleepAfterFree, false);
        }
		else if (0 == lstrcmpi(pszObjType, TEXT("pipew")))
        {
			g_pHogger[0] = new CPHPipeHog(1024, dwSleepAfterHog, dwSleepAfterFree, true);
        }
		else if (0 == lstrcmpi(pszObjType, TEXT("dc")))
        {
			g_pHogger[0] = new CPHDCHog(1024, dwSleepAfterHog, dwSleepAfterFree);
        }
		else if (0 == lstrcmpi(pszObjType, TEXT("Printer")))
        {
			g_pHogger[0] = new CPHPrinterHog(1024, dwSleepAfterHog, dwSleepAfterFree);
        }
		else if (0 == lstrcmpi(pszObjType, TEXT("ConScrnBuff")))
        {
			g_pHogger[0] = new CPHConScrnBuffHog(1024, dwSleepAfterHog, dwSleepAfterFree, false);
        }
		else if (0 == lstrcmpi(pszObjType, TEXT("ConScrnBuffW")))
        {
			g_pHogger[0] = new CPHConScrnBuffHog(1024, dwSleepAfterHog, dwSleepAfterFree, true);
        }
		else if (0 == lstrcmpi(pszObjType, TEXT("Service")))
        {
            TCHAR *pszService = TEXT("c:\\stam.exe");
            if (((argc == 5) && !fNamedObject) || ((argc == 6) && fNamedObject))
            {
                pszService = szArgv[argc-1];
            }

			g_pHogger[0] = new CPHServiceHog(1024, dwSleepAfterHog, dwSleepAfterFree, pszService);
        }
		else if (0 == lstrcmpi(pszObjType, TEXT("SC_H")))
        {
			g_pHogger[0] = new CPHSC_HHog(1024, dwSleepAfterHog, dwSleepAfterFree);
        }
		else if (0 == lstrcmpi(pszObjType, TEXT("heap")))
        {
			g_pHogger[0] = new CPHHeapHog(1024, dwSleepAfterHog, dwSleepAfterFree);
        }
		else if (0 == lstrcmpi(pszObjType, TEXT("PostMessage")))
        {
			g_pHogger[0] = new CPostMessageHog(1024, dwSleepAfterHog, dwSleepAfterFree);
        }
		else if (0 == lstrcmpi(pszObjType, TEXT("PostThreadMessage")))
        {
			g_pHogger[0] = new CPostThreadMessageHog(1024, dwSleepAfterHog, dwSleepAfterFree);
        }
		else if (0 == lstrcmpi(pszObjType, TEXT("CompPack")))
        {
			g_pHogger[0] = new CPostCompletionPacketHog(1024, dwSleepAfterHog, dwSleepAfterFree);
        }
		else if (0 == lstrcmpi(pszObjType, TEXT("CritSec")))
        {
			g_pHogger[0] = new CCritSecHog(1024, dwSleepAfterHog, dwSleepAfterFree);
        }
		else if (0 == lstrcmpi(pszObjType, TEXT("Fiber")))
        {
			g_pHogger[0] = new CPHFiberHog(1024, dwSleepAfterHog, dwSleepAfterFree);
        }
		else if (0 == lstrcmpi(pszObjType, TEXT("QueueAPC")))
        {
			g_pHogger[0] = new CQueueAPCHog(1024, dwSleepAfterHog, dwSleepAfterFree);
        }
		else if (0 == lstrcmpi(pszObjType, TEXT("process")))
        {
            TCHAR *pszExe = pszOptionalString ? pszOptionalString : TEXT("nothing.exe");
            if (((argc == 5) && !fNamedObject) || ((argc == 6) && fNamedObject))
            {
                pszExe = szArgv[argc-1];
            }
            
            g_pHogger[0] = new CPHProcessHog(1024, pszExe, dwSleepAfterHog, dwSleepAfterFree, true);
        }
		else if (0 == lstrcmpi(pszObjType, TEXT("processns")))
        {
            TCHAR *pszExe = pszOptionalString ? pszOptionalString : TEXT("nothing.exe");
            if (((argc == 5) && !fNamedObject) || ((argc == 6) && fNamedObject))
            {
                pszExe = szArgv[argc-1];
            }
            
            g_pHogger[0] = new CPHProcessHog(1024, pszExe, dwSleepAfterHog, dwSleepAfterFree, false);
        }
		else if (0 == lstrcmpi(pszObjType, TEXT("mutex")))
        {
			g_pHogger[0] = new CPHMutexHog(1024, dwSleepAfterHog, dwSleepAfterFree, fNamedObject);
        }
		else if (0 == lstrcmpi(pszObjType, TEXT("semaphore")))
        {
			g_pHogger[0] = new CPHSemaphoreHog(1024, dwSleepAfterHog, dwSleepAfterFree, fNamedObject);
        }
		else if (0 == lstrcmpi(pszObjType, TEXT("timer")))
        {
			g_pHogger[0] = new CPHTimerHog(1024, dwSleepAfterHog, dwSleepAfterFree, fNamedObject);
        }
		else if (0 == lstrcmpi(pszObjType, TEXT("TimerQueue")))
        {
			g_pHogger[0] = new CPHTimerQueueHog(1024, dwSleepAfterHog, dwSleepAfterFree, fNamedObject);
			g_pHogger[1] = new CPHTimerQueueHog(1024, dwSleepAfterHog, dwSleepAfterFree, fNamedObject);
			g_pHogger[2] = new CPHTimerQueueHog(1024, dwSleepAfterHog, dwSleepAfterFree, fNamedObject);
			g_pHogger[3] = new CPHTimerQueueHog(1024, dwSleepAfterHog, dwSleepAfterFree, fNamedObject);
			g_pHogger[4] = new CPHTimerQueueHog(1024, dwSleepAfterHog, dwSleepAfterFree, fNamedObject);
        }
		else if (0 == lstrcmpi(pszObjType, TEXT("RegisterWait")))
        {
			g_pHogger[0] = new CPHRegisterWaitHog(1024, dwSleepAfterHog, dwSleepAfterFree, fNamedObject);
        }
		else if (0 == lstrcmpi(pszObjType, TEXT("registry")))
        {
			g_pHogger[0] = new CRegistryHog(1024, dwSleepAfterHog, dwSleepAfterFree);
        }
		else if (0 == lstrcmpi(pszObjType, TEXT("hkey")))
        {
			//g_pHogger[0] = new CRegHkeyHog(1024, dwSleepAfterHog, dwSleepAfterFree);
			g_pHogger[0] = new CPHKeyHog(1024, dwSleepAfterHog, dwSleepAfterFree);
        }
		else if (0 == lstrcmpi(pszObjType, TEXT("WSASocketTCP")))
        {
			g_pHogger[0] = new CPHWSASocketHog(1024, true, false, false, dwSleepAfterHog, dwSleepAfterFree);
        }
		else if (0 == lstrcmpi(pszObjType, TEXT("WSASocketTCPb")))
        {
			g_pHogger[0] = new CPHWSASocketHog(1024, true, true, false, dwSleepAfterHog, dwSleepAfterFree);
        }
		else if (0 == lstrcmpi(pszObjType, TEXT("WSASocketTCPbl")))
        {
			g_pHogger[0] = new CPHWSASocketHog(1024, true, true, true, dwSleepAfterHog, dwSleepAfterFree);
        }
		else if (0 == lstrcmpi(pszObjType, TEXT("WSASocketUDP")))
        {
			g_pHogger[0] = new CPHWSASocketHog(1024, false, false, false,  dwSleepAfterHog, dwSleepAfterFree);
        }
		else if (0 == lstrcmpi(pszObjType, TEXT("WSASocketUDPb")))
        {
			g_pHogger[0] = new CPHWSASocketHog(1024, false, true, false,  dwSleepAfterHog, dwSleepAfterFree);
        }
		else if (0 == lstrcmpi(pszObjType, TEXT("WSASocketUDPbl")))
        {
			g_pHogger[0] = new CPHWSASocketHog(1024, false, true, true,  dwSleepAfterHog, dwSleepAfterFree);
        }
		else if (0 == lstrcmpi(pszObjType, TEXT("disk")))
        {
            TCHAR *pszPath = pszOptionalString;
			if (NULL == pszPath)
			{
				_tprintf(TEXT("Usage: %s disk <msecs sleep after full hog> <msecs sleep after releasing some> <path to temp folder>\n"), szArgv[0]);
				return -1;
			}

			g_pHogger[0] = new CDiskHog(pszPath, 1024, dwSleepAfterHog, dwSleepAfterFree);
        }
		else if (0 == lstrcmpi(pszObjType, TEXT("file")))
        {
            TCHAR *pszPath = pszOptionalString;
			if (NULL == pszPath)
			{
				_tprintf(TEXT("Usage: %s file <msecs sleep after full hog> <msecs sleep after releasing some> <path to temp folder>\n"), szArgv[0]);
				return -1;
			}

			g_pHogger[0] = new CPHFileHog(pszPath, 1024, dwSleepAfterHog, dwSleepAfterFree);
        }
		else if (0 == lstrcmpi(pszObjType, TEXT("FileMap")))
        {
			g_pHogger[0] = new CPHFileMapHog(1024, dwSleepAfterHog, dwSleepAfterFree, fNamedObject);
        }
		else if (0 == lstrcmpi(pszObjType, TEXT("DeskTop")))
        {
			g_pHogger[0] = new CPHDesktopHog(1024, dwSleepAfterHog, dwSleepAfterFree);
        }
		else if (0 == lstrcmpi(pszObjType, TEXT("event")))
        {
			g_pHogger[0] = new CPHEventHog(1024, dwSleepAfterHog, dwSleepAfterFree, fNamedObject);
        }
		else if (0 == lstrcmpi(pszObjType, TEXT("job")))
        {
			g_pHogger[0] = new CPHJobObjectHog(1024, dwSleepAfterHog, dwSleepAfterFree, fNamedObject);
        }
		else if (0 == lstrcmpi(pszObjType, TEXT("MailSlot")))
        {
			g_pHogger[0] = new CPHMailSlotHog(1024, dwSleepAfterHog, dwSleepAfterFree, false);
        }
		else if (0 == lstrcmpi(pszObjType, TEXT("MailSlotW")))
        {
			g_pHogger[0] = new CPHMailSlotHog(1024, dwSleepAfterHog, dwSleepAfterFree, true);
        }
		else if (0 == lstrcmpi(pszObjType, TEXT("RegisterEventSource")))
        {
			g_pHogger[0] = new CPHRegisterEventSourceHog(1024, dwSleepAfterHog, dwSleepAfterFree);
        }
        else
        {
            Usage(szArgv[0]);
        }


		if (NULL == g_pHogger[0])
		{
			_tprintf(TEXT("Out of memory, retrying\n"));
			::Sleep(rand()%1000);
			goto retry_allocating_hogger;
			return -1;
		}
		
		_tprintf(TEXT("Before sleeping %d milliseconds\n"), dwSleepBeforeStarting);
		::Sleep(dwSleepBeforeStarting);
		_tprintf(TEXT("After sleeping %d milliseconds\n"), dwSleepBeforeStarting);

		nDelta = dwFreeResources;
		for(;;)
		{
			int i;

			switch(nDelta)
			{
			case -1:
				_tprintf(TEXT("Please wait while freeing resources....\n"));
				if (!g_fDeleting_g_pHogger)
				{
					g_fDeleting_g_pHogger = true;
					DeleteHoggers();
					return(-1);
				}

			case -2:
				_tprintf(TEXT("Please wait....\n"));
				for (i = 0; i < (sizeof(g_pHogger) / sizeof(*g_pHogger)); i++)
				{
					if (g_pHogger[i]) g_pHogger[i]->HaltHogging();
				}
				
				_tprintf(TEXT("Hogging halted.\n"));
				break;

			case -3:
				_tprintf(TEXT("Please wait....\n"));
				for (i = 0; i < (sizeof(g_pHogger) / sizeof(*g_pHogger)); i++)
				{
					if (g_pHogger[i]) g_pHogger[i]->HaltHoggingAndFreeAll();
				}
				
				_tprintf(TEXT("Resources freed.\n"));
				break;

			default:
				_tprintf(TEXT("starting to hog.... free resources (delta)=%d.\n"), nDelta);
				for (i = 0; i < (sizeof(g_pHogger) / sizeof(*g_pHogger)); i++)
				{
					if (g_pHogger[i]) g_pHogger[i]->SetMaxFreeResources(nDelta);
				}

				_tprintf(TEXT("hogging... free resources (delta)=%d.\n"), nDelta);
			}
			
			nDelta = GetDelta();
		}//for(;;)
	}catch(CException e)
	{
		_tprintf(TEXT("Exception: %s\n"), (const TCHAR*)e);
        if (!g_fDeleting_g_pHogger)
        {
            g_fDeleting_g_pHogger = true;
		    DeleteHoggers();
        }
		return -1;
	}catch(...)
	{
		_tprintf(TEXT("Unknown Exception.\n"));
        if (!g_fDeleting_g_pHogger)
        {
            g_fDeleting_g_pHogger = true;
		    DeleteHoggers();
        }
		return -1;
	}

  if (!g_fDeleting_g_pHogger)
    {
        g_fDeleting_g_pHogger = true;
		DeleteHoggers();
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\memhog.cpp ===
//
// this class is used for hogging Resources.
// it differs from simple hogging by dynamically
// hogging all Resources and then releasing some.
// the level of free Resources can be controlled.
//

//#define HOGGER_LOGGING

#include "MemHog.h"


//
// lookup table for calculating powers of 10
//
const long CMemHog::m_lPowerOfTen[10] =
{
	1,
	10,
	1000,
	10000,
	100000,
	1000000,
	10000000,
	100000000,
	1000000000,
	1000000000 //intentional missing zero: too big for a long type.
};

CMemHog::CMemHog(
	const DWORD dwMaxFreeResources, 
	const DWORD dwSleepTimeAfterFullHog,
	const DWORD dwSleepTimeAfterReleasing
	)
	:
	CHogger(dwMaxFreeResources, dwSleepTimeAfterFullHog, dwSleepTimeAfterReleasing)
{
	//
	// initialize hogger array
	//
	for (int iPowerOfTen = 0 ; iPowerOfTen < 10; iPowerOfTen++)
	{
		for (int j = 0 ; j < 10; j++)
		{
			m_apcHogger[iPowerOfTen][j] = NULL;
		}
	}
}

CMemHog::~CMemHog(void)
{
    HaltHoggingAndFreeAll();
}

void CMemHog::FreeAll(void)
{
	HOGGERDPF(("CMemHog::FreeAll(): before freeing all.\n"));
	
	for (int i = 0 ; i < 10; i++)
	{
		for (int j = 0 ; j < 10; j++)
		{
			free(m_apcHogger[i][j]);	
			m_apcHogger[i][j] = NULL;
		}	
	}
	HOGGERDPF(("CMemHog::FreeAll(): out of FreeAll().\n"));
}

//
// algorithm:
//  try allocate 10^9 bytes, up to 10 allocations.
//  then try to allocate 10^8 bytes, up to 10 allocations.
//  then try to allocate 10^7 bytes, up to 10 allocations.
//  ...
//  then try to allocate 10^0 bytes, up to 10 allocations.
//  now all memory is hogged (up to 20*10^9 =~ 20GBytes...)
//
bool CMemHog::HogAll(void)
{
	static DWORD s_dwHogged = 0;

	for (	int iPowerOfTen = 9 ; 
			iPowerOfTen >= 0; 
			iPowerOfTen--
		)
	{
		//HOGGERDPF(("iPowerOfTen=%d.\n", iPowerOfTen));
		for (	int j = 0 ; 
				j < 10; 
				j++
			)
		{
			//
			// always be ready to abort
			//
			if (m_fAbort)
			{
	            HOGGERDPF(("CMemHog::HogAll(): got m_fAbort.\n"));
				return false;
			}

			if (m_fHaltHogging)
			{
	            HOGGERDPF(("CMemHog::HogAll(): got m_fHaltHogging.\n"));
				return true;
			}

			//
			// skip already allocated pointers
			//
			if (NULL != m_apcHogger[iPowerOfTen][j])
			{
				continue;
			}
			
			//
			// break if fail to allocate, so lesser amounts will be allocated
			//
			if (NULL == (m_apcHogger[iPowerOfTen][j] = (char*)malloc(m_lPowerOfTen[iPowerOfTen])))
			{
				break;
			}

			//
			// actually use the memory!
			//
#ifndef _DEBUG
			memset(m_apcHogger[iPowerOfTen][j], rand(), m_lPowerOfTen[iPowerOfTen]);
#endif
			//HOGGERDPF(("allocated %d bytes.\n", m_lPowerOfTen[iPowerOfTen]));
			s_dwHogged += m_lPowerOfTen[iPowerOfTen];
		}//for (j = 0 ; j < 10; j++)
	}//for (int iPowerOfTen = 9 ; iPowerOfTen >= 0; iPowerOfTen--)

	HOGGERDPF(("CMemHog::HogAll(): Hogged %d bytes.\n", s_dwHogged));

	return true;
}


bool CMemHog::FreeSome(void)
{
		//
		// free blocks, from small(10^0) to large(10^9), until freeing at least m_dwMaxFreeMem bytes
		//
		DWORD dwFreed = 0;

		//
		// take care of RANDOM_AMOUNT_OF_FREE_RESOURCES case
		// will free all memory if m_dwMaxFreeResources > actually allocated
		//
		DWORD dwMaxFreeMem = 
			(RANDOM_AMOUNT_OF_FREE_RESOURCES == m_dwMaxFreeResources) ?
			rand() && (rand()<<16) :
			m_dwMaxFreeResources;

		HOGGERDPF(("CMemHog::FreeSome(): before free cycle.\n"));
		for (int i = 0; i < 10; i++)
		{
			for (int j = 0; j < 10; j++)
			{
				if (m_apcHogger[i][j])
				{
					free(m_apcHogger[i][j]);
					m_apcHogger[i][j] = NULL;
					dwFreed += m_lPowerOfTen[i];
					//HOGGERDPF(("freed %d bytes.\n", m_lPowerOfTen[i]));
				}

				if (dwFreed >= dwMaxFreeMem)
				{
					break;
				}
			}
			if (dwFreed >= dwMaxFreeMem)
			{
				break;
			}
		}//for (int i = 0; i < 10; i++)
		HOGGERDPF(("CMemHog::FreeSome(): Freed %d bytes.\n", dwFreed));

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\memhog.h ===
#ifndef __MEM_HOG_H
#define __MEM_HOG_H

//
// this class is used for hogging a resource.
// it differs from simple hogging by dynamically
// hogging all resources and then releasing some.
// the level of free resources can be controlled.
//


#include "hogger.h"

class CMemHog : public CHogger
{
public:
	//
	// does not hog Resources yet.
	//
	CMemHog(
		const DWORD dwMaxFreeResources, 
		const DWORD dwSleepTimeAfterFullHog = 1000, 
		const DWORD dwSleepTimeAfterReleasing = 1000
		);

	~CMemHog(void);

protected:
	virtual void FreeAll(void);

	virtual bool HogAll(void);
	virtual bool FreeSome(void);

	//
	// 1st index is power of 10. each 1st index may holds 10 place holder for the 
	// amount of 10^1st bytes.
	// 
	char *m_apcHogger[10][10];

	//
	// holds the powers of 10, to calculate amounts of memory
	//
	static const long m_lPowerOfTen[10];


};

#endif //__MEM_HOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phbitmaphog.cpp ===
//
// this class is used for hogging Resources.
// it differs from simple hogging by dynamically
// hogging all Resources and then releasing some.
// the level of free Resources can be controlled.
//


//#define HOGGER_LOGGING

#include "PHBitMapHog.h"



CPHBitMapHog::CPHBitMapHog(
	const DWORD dwMaxFreeResources, 
	const DWORD dwSleepTimeAfterFullHog, 
	const DWORD dwSleepTimeAfterFreeingSome
	)
	:
	CPseudoHandleHog<HBITMAP, NULL>(
        dwMaxFreeResources, 
        dwSleepTimeAfterFullHog, 
        dwSleepTimeAfterFreeingSome,
        false //named object
        )
{
	return;
}

CPHBitMapHog::~CPHBitMapHog(void)
{
	HaltHoggingAndFreeAll();
}


template <DWORD DW_BITMAP_SIZE>
inline
HBITMAP CPHBitMapHog::CreatePseudoHandle(DWORD /*index*/, TCHAR * /*szTempName*/)
{
    //
    // dummy bitmap
    //
	static const BYTE ab[DW_BITMAP_SIZE][DW_BITMAP_SIZE];

    return ::CreateBitmap(
				DW_BITMAP_SIZE, // bitmap width, in pixels 
				DW_BITMAP_SIZE, // bitmap height, in pixels 
				1, // number of color planes used by device 
				1, // number of bits required to identify a color 
				ab  // pointer to array containing color data 
				); 
}



bool CPHBitMapHog::ReleasePseudoHandle(DWORD /*index*/)
{
	return true;
}


bool CPHBitMapHog::ClosePseudoHandle(DWORD index)
{
    return (0 != ::DeleteObject(m_ahHogger[index]));
}


bool CPHBitMapHog::PostClosePseudoHandle(DWORD /*index*/)
{
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phbitmaphog.h ===
#ifndef __PHBITMAP_HOG_H
#define __PHBITMAP_HOG_H

//
// this class is used for hogging a resource.
// it differs from simple hogging by dynamically
// hogging all resources and then releasing some.
// the level of free resources can be controlled.
//



#include "PseudoHandleHog.h"

template <DWORD DW_BITMAP_SIZE>
class CPHBitMapHog : public CPseudoHandleHog<HBITMAP, NULL>
{
public:
	//
	// does not hog Resources yet.
	//
	CPHBitMapHog(
		const DWORD dwMaxFreeResources, 
		const DWORD dwSleepTimeAfterFullHog = 1000, 
		const DWORD dwSleepTimeAfterFreeingSome = 1000
		);
    ~CPHBitMapHog(void);

protected:
	HBITMAP CreatePseudoHandle(DWORD index, TCHAR *szTempName = 0);
	bool ReleasePseudoHandle(DWORD index);
	bool ClosePseudoHandle(DWORD index);
	bool PostClosePseudoHandle(DWORD index);
};



template <DWORD DW_BITMAP_SIZE>
CPHBitMapHog<DW_BITMAP_SIZE>::CPHBitMapHog(
	const DWORD dwMaxFreeResources, 
	const DWORD dwSleepTimeAfterFullHog, 
	const DWORD dwSleepTimeAfterFreeingSome
	)
	:
	CPseudoHandleHog<HBITMAP, NULL>(
        dwMaxFreeResources, 
        dwSleepTimeAfterFullHog, 
        dwSleepTimeAfterFreeingSome,
        false //named object
        )
{
	return;
}

template <DWORD DW_BITMAP_SIZE>
CPHBitMapHog<DW_BITMAP_SIZE>::~CPHBitMapHog(void)
{
	HaltHoggingAndFreeAll();
}


template <DWORD DW_BITMAP_SIZE>
inline
HBITMAP CPHBitMapHog<DW_BITMAP_SIZE>::CreatePseudoHandle(DWORD /*index*/, TCHAR * /*szTempName*/)
{
    //
    // dummy bitmap
    //
	static const BYTE ab[DW_BITMAP_SIZE][DW_BITMAP_SIZE];

    return ::CreateBitmap(
				DW_BITMAP_SIZE, // bitmap width, in pixels 
				DW_BITMAP_SIZE, // bitmap height, in pixels 
				1, // number of color planes used by device 
				1, // number of bits required to identify a color 
				ab  // pointer to array containing color data 
				); 
}



template <DWORD DW_BITMAP_SIZE>
inline
bool CPHBitMapHog<DW_BITMAP_SIZE>::ReleasePseudoHandle(DWORD /*index*/)
{
	return true;
}


template <DWORD DW_BITMAP_SIZE>
inline
bool CPHBitMapHog<DW_BITMAP_SIZE>::ClosePseudoHandle(DWORD index)
{
    return (0 != ::DeleteObject(m_ahHogger[index]));
}


template <DWORD DW_BITMAP_SIZE>
inline
bool CPHBitMapHog<DW_BITMAP_SIZE>::PostClosePseudoHandle(DWORD /*index*/)
{
	return true;
}


#endif //__PHBITMAP_HOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phcompporthog.h ===
#ifndef __PHCOMP_PORT_HOG_H
#define __PHCOMP_PORT_HOG_H

//
// this class is used for hogging a resource.
// it differs from simple hogging by dynamically
// hogging all resources and then releasing some.
// the level of free resources can be controlled.
//



#include "PseudoHandleHog.h"


class CPHCompPortHog : public CPseudoHandleHog<HANDLE, NULL>
{
public:
	//
	// does not hog Resources yet.
	//
	CPHCompPortHog(
		const DWORD dwMaxFreeResources, 
		const DWORD dwSleepTimeAfterFullHog = 1000, 
		const DWORD dwSleepTimeAfterFreeingSome = 1000,
        const bool fWrite = false
		);
    ~CPHCompPortHog(void);

protected:
	HANDLE CreatePseudoHandle(DWORD index, TCHAR *szTempName = 0);
	bool ReleasePseudoHandle(DWORD index);
	bool ClosePseudoHandle(DWORD index);
	bool PostClosePseudoHandle(DWORD index);

private:
    bool m_fWrite;
};

#endif //__PHCOMP_PORT_HOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phbrushhog.h ===
#ifndef __PHBRUSH_HOG_H
#define __PHBRUSH_HOG_H

//
// this class is used for hogging a resource.
// it differs from simple hogging by dynamically
// hogging all resources and then releasing some.
// the level of free resources can be controlled.
//



#include "PseudoHandleHog.h"


class CPHBrushHog : public CPseudoHandleHog<HBRUSH, NULL>
{
public:
	//
	// does not hog Resources yet.
	//
	CPHBrushHog(
		const DWORD dwMaxFreeResources, 
		const DWORD dwSleepTimeAfterFullHog = 1000, 
		const DWORD dwSleepTimeAfterFreeingSome = 1000
		);
    ~CPHBrushHog(void);

protected:
	HBRUSH CreatePseudoHandle(DWORD index, TCHAR *szTempName = 0);
	bool ReleasePseudoHandle(DWORD index);
	bool ClosePseudoHandle(DWORD index);
	bool PostClosePseudoHandle(DWORD index);
};

#endif //__PHBRUSH_HOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phbrushhog.cpp ===
//
// this class is used for hogging Resources.
// it differs from simple hogging by dynamically
// hogging all Resources and then releasing some.
// the level of free Resources can be controlled.
//


//#define HOGGER_LOGGING

#include "PHBrushHog.h"



CPHBrushHog::CPHBrushHog(
	const DWORD dwMaxFreeResources, 
	const DWORD dwSleepTimeAfterFullHog, 
	const DWORD dwSleepTimeAfterFreeingSome
	)
	:
	CPseudoHandleHog<HBRUSH, NULL>(
        dwMaxFreeResources, 
        dwSleepTimeAfterFullHog, 
        dwSleepTimeAfterFreeingSome,
        false //named object
        )
{
	return;
}

CPHBrushHog::~CPHBrushHog(void)
{
	HaltHoggingAndFreeAll();
}


HBRUSH CPHBrushHog::CreatePseudoHandle(DWORD /*index*/, TCHAR * /*szTempName*/)
{
    return ::CreateSolidBrush(0x00AA1108);
}



bool CPHBrushHog::ReleasePseudoHandle(DWORD /*index*/)
{
	return true;
}


bool CPHBrushHog::ClosePseudoHandle(DWORD index)
{
    return (0 != ::DeleteObject(m_ahHogger[index]));
}


bool CPHBrushHog::PostClosePseudoHandle(DWORD /*index*/)
{
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phconscrnbuffhog.h ===
#ifndef __PHCONSOLE_SCREEN_BUFFER_HOG_H
#define __PHCONSOLE_SCREEN_BUFFER_HOG_H

//
// this class is used for hogging a resource.
// it differs from simple hogging by dynamically
// hogging all resources and then releasing some.
// the level of free resources can be controlled.
//



#include "PseudoHandleHog.h"


class CPHConScrnBuffHog : public CPseudoHandleHog<HANDLE, (DWORD)INVALID_HANDLE_VALUE>
{
public:
	//
	// does not hog Resources yet.
	//
	CPHConScrnBuffHog(
		const DWORD dwMaxFreeResources, 
		const DWORD dwSleepTimeAfterFullHog = 1000, 
		const DWORD dwSleepTimeAfterFreeingSome = 1000,
        const bool fWrite = false
		);
    ~CPHConScrnBuffHog(void);

protected:
	HANDLE CreatePseudoHandle(DWORD index, TCHAR *szTempName = 0);
	bool ReleasePseudoHandle(DWORD index);
	bool ClosePseudoHandle(DWORD index);
	bool PostClosePseudoHandle(DWORD index);

private:
    bool m_fWrite;
};

#endif //__PHCONSOLE_SCREEN_BUFFER_HOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phcompporthog.cpp ===
//
// this class is used for hogging Resources.
// it differs from simple hogging by dynamically
// hogging all Resources and then releasing some.
// the level of free Resources can be controlled.
//


//#define HOGGER_LOGGING

#include "PHCompPortHog.h"



CPHCompPortHog::CPHCompPortHog(
	const DWORD dwMaxFreeResources, 
	const DWORD dwSleepTimeAfterFullHog, 
	const DWORD dwSleepTimeAfterFreeingSome,
    const bool fWrite
	)
	:
	CPseudoHandleHog<HANDLE, NULL>(
        dwMaxFreeResources, 
        dwSleepTimeAfterFullHog, 
        dwSleepTimeAfterFreeingSome,
        false //fNamedObject
        ),
    m_fWrite(fWrite)
{
	return;
}

CPHCompPortHog::~CPHCompPortHog(void)
{
	HaltHoggingAndFreeAll();
}


HANDLE CPHCompPortHog::CreatePseudoHandle(DWORD /*index*/, TCHAR * /*szTempName*/)
{
    return ::CreateIoCompletionPort( 
        INVALID_HANDLE_VALUE,              // file handle to associate with the I/O completion port
        NULL,  // handle to the I/O completion port
        0,            // per-file completion key for I/O  completion packets
        0 // number of threads allowed to execute concurrently
        );
}



bool CPHCompPortHog::ReleasePseudoHandle(DWORD /*index*/)
{
	return true;
}


bool CPHCompPortHog::ClosePseudoHandle(DWORD index)
{
    return (0 != ::CloseHandle(m_ahHogger[index]));
}




bool CPHCompPortHog::PostClosePseudoHandle(DWORD /*index*/)
{
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phdchog.h ===
#ifndef __PHDC_HOG_H
#define __PHDC_HOG_H

//
// this class is used for hogging a resource.
// it differs from simple hogging by dynamically
// hogging all resources and then releasing some.
// the level of free resources can be controlled.
//



#include "PseudoHandleHog.h"


class CPHDCHog : public CPseudoHandleHog<HDC, NULL>
{
public:
	//
	// does not hog Resources yet.
	//
	CPHDCHog(
		const DWORD dwMaxFreeResources, 
		const DWORD dwSleepTimeAfterFullHog = 1000, 
		const DWORD dwSleepTimeAfterFreeingSome = 1000
		);
    ~CPHDCHog(void);

protected:
	HDC CreatePseudoHandle(DWORD index, TCHAR *szTempName = 0);
	bool ReleasePseudoHandle(DWORD index);
	bool ClosePseudoHandle(DWORD index);
	bool PostClosePseudoHandle(DWORD index);

private:
    TCHAR m_PrinterName[MAX_PATH];
    LPTSTR m_pDriver ;                   // used in parsing a profile string
    LPTSTR m_pDevice ;                   //    ditto
    LPTSTR m_pOutput ;                   //    ditto
    HANDLE m_hPrinter;
    PDEVMODE m_pDevMode;

};

#endif //__PHDC_HOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phconscrnbuffhog.cpp ===
//
// this class is used for hogging Resources.
// it differs from simple hogging by dynamically
// hogging all Resources and then releasing some.
// the level of free Resources can be controlled.
//


//#define HOGGER_LOGGING

#include "PHConScrnBuffHog.h"

static const TCHAR s_szBuff[] = TEXT("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX");
static bool s_fHugeBuffFilled = false;
static TCHAR s_szHugeBuff[1024*1024];


CPHConScrnBuffHog::CPHConScrnBuffHog(
	const DWORD dwMaxFreeResources, 
	const DWORD dwSleepTimeAfterFullHog, 
	const DWORD dwSleepTimeAfterFreeingSome,
    const bool fWrite
	)
	:
	CPseudoHandleHog<HANDLE, (DWORD)INVALID_HANDLE_VALUE>(
        dwMaxFreeResources, 
        dwSleepTimeAfterFullHog, 
        dwSleepTimeAfterFreeingSome,
        false//fNamedObject
        ),
    m_fWrite(fWrite)
{
    if (!s_fHugeBuffFilled)
    {
        ::memset(s_szHugeBuff, TEXT('X'), sizeof(s_szHugeBuff)/sizeof(*s_szHugeBuff));
        s_szHugeBuff[sizeof(s_szHugeBuff)/sizeof(*s_szHugeBuff)-1] = TEXT('\0');
        s_fHugeBuffFilled = true;
    }

	return;
}

CPHConScrnBuffHog::~CPHConScrnBuffHog(void)
{
	HaltHoggingAndFreeAll();
}


HANDLE CPHConScrnBuffHog::CreatePseudoHandle(DWORD /*index*/, TCHAR * /*szTempName*/)
{
    DWORD dwDesiredAccess = 0;
    if (rand()%2) dwDesiredAccess |= GENERIC_READ;
    if (rand()%2) dwDesiredAccess |= GENERIC_WRITE;
    if (0 == dwDesiredAccess)
    {
        if (rand()%2) dwDesiredAccess = GENERIC_READ;
        else dwDesiredAccess = GENERIC_WRITE;
    }
    if (m_fWrite)
    {
        dwDesiredAccess |= GENERIC_WRITE;
    }

    DWORD dwShareMode = 0;
    if (rand()%2) dwShareMode |= FILE_SHARE_READ;
    if (rand()%2) dwShareMode |= FILE_SHARE_WRITE;
    if (0 == dwShareMode)
    {
        if (rand()%2) dwShareMode = FILE_SHARE_READ;
        else dwShareMode = FILE_SHARE_WRITE;
    }

    HANDLE h;
    /*return*/ h = ::CreateConsoleScreenBuffer(
            dwDesiredAccess,  // access flag
            dwShareMode,      // buffer share mode
            NULL, // pointer to security attributes
            CONSOLE_TEXTMODE_BUFFER,          // type of buffer to create
            NULL   // reserved
            );
    if (INVALID_HANDLE_VALUE == h) return INVALID_HANDLE_VALUE;

    if (m_fWrite)
    {
        const TCHAR *pBuff;
        DWORD dwBuffSize;
        if (rand()%2)
        {
            pBuff = s_szHugeBuff;
            dwBuffSize = sizeof(s_szHugeBuff)/sizeof(*s_szHugeBuff);
        }
        else
        {
            pBuff = s_szBuff;
            dwBuffSize = sizeof(s_szBuff)/sizeof(*s_szBuff);
        }

        COORD coord;
        coord.X = (short)rand();
        coord.Y = (short)rand();
        DWORD dwNumberOfCharsWritten;
        if (! ::WriteConsoleOutputCharacter(
                h,  // handle to a console screen buffer
                pBuff,    // pointer to buffer to write characters from
                dwBuffSize,          // number of character cells to write to
                coord,     // coordinates of first cell to write to
                &dwNumberOfCharsWritten // pointer to number of cells written to
                )
           )
        {
            HOGGERDPF(("CPHConScrnBuffHog::CreatePseudoHandle(): WriteConsoleOutputCharacter() failed with %d\n", ::GetLastError()));
        }
    }

    return h;
}



bool CPHConScrnBuffHog::ReleasePseudoHandle(DWORD /*index*/)
{
	return true;
}


bool CPHConScrnBuffHog::ClosePseudoHandle(DWORD index)
{
    return (0 != ::CloseHandle(m_ahHogger[index]));
}




bool CPHConScrnBuffHog::PostClosePseudoHandle(DWORD /*index*/)
{
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phdesktophog.h ===
#ifndef __PHDESKTOP_HOG_H
#define __PHDESKTOP_HOG_H

//
// this class is used for hogging a resource.
// it differs from simple hogging by dynamically
// hogging all resources and then releasing some.
// the level of free resources can be controlled.
//



#include "PseudoHandleHog.h"

class CPHDesktopHog : public CPseudoHandleHog<HDESK, NULL>
{
public:
	//
	// does not hog Resources yet.
	//
	CPHDesktopHog(
		const DWORD dwMaxFreeResources, 
		const DWORD dwSleepTimeAfterFullHog = 1000, 
		const DWORD dwSleepTimeAfterFreeingSome = 1000
		);
    ~CPHDesktopHog(void);

protected:
	HDESK CreatePseudoHandle(DWORD index, TCHAR *szTempName = 0);
	bool ReleasePseudoHandle(DWORD index);
	bool ClosePseudoHandle(DWORD index);
	bool PostClosePseudoHandle(DWORD index);
};

#endif //__PHDESKTOP_HOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phdesktophog.cpp ===
//
// this class is used for hogging Resources.
// it differs from simple hogging by dynamically
// hogging all Resources and then releasing some.
// the level of free Resources can be controlled.
//


//#define HOGGER_LOGGING

#include "PHDesktopHog.h"



CPHDesktopHog::CPHDesktopHog(
	const DWORD dwMaxFreeResources, 
	const DWORD dwSleepTimeAfterFullHog, 
	const DWORD dwSleepTimeAfterFreeingSome
	)
	:
	CPseudoHandleHog<HDESK, NULL>(
        dwMaxFreeResources, 
        dwSleepTimeAfterFullHog, 
        dwSleepTimeAfterFreeingSome, 
        true //named
        )
{
	return;
}

CPHDesktopHog::~CPHDesktopHog(void)
{
	HaltHoggingAndFreeAll();
}


HDESK CPHDesktopHog::CreatePseudoHandle(DWORD /*index*/, TCHAR *szTempName)
{
	return ::CreateDesktop( 
        szTempName,    // name of the new desktop
        NULL,     // reserved; must be NULL.
        NULL,     // reserved; must be NULL
        0,          // flags to control interaction with other applications
        DESKTOP_CREATEWINDOW ,  // specifies access of returned handle
        NULL  // specifies security attributes of the desktop
        );

}



bool CPHDesktopHog::ReleasePseudoHandle(DWORD /*index*/)
{
	return true;
}


bool CPHDesktopHog::ClosePseudoHandle(DWORD index)
{
    return (0 != ::CloseDesktop(m_ahHogger[index]));
}


bool CPHDesktopHog::PostClosePseudoHandle(DWORD /*index*/)
{
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phdchog.cpp ===
//
// this class is used for hogging Resources.
// it differs from simple hogging by dynamically
// hogging all Resources and then releasing some.
// the level of free Resources can be controlled.
//


//#define HOGGER_LOGGING

#include "PHDCHog.h"



CPHDCHog::CPHDCHog(
	const DWORD dwMaxFreeResources, 
	const DWORD dwSleepTimeAfterFullHog, 
	const DWORD dwSleepTimeAfterFreeingSome
	)
	:
	CPseudoHandleHog<HDC, NULL>(
        dwMaxFreeResources, 
        dwSleepTimeAfterFullHog, 
        dwSleepTimeAfterFreeingSome,
        false //named object
        ),
    m_hPrinter(NULL),
    m_pDevice(NULL),
    m_pDriver(NULL),
    m_pOutput(NULL),
    m_pDevMode(NULL)
{
    DWORD dwBytesRead = ::GetProfileString( TEXT("Windows"), TEXT("device"), TEXT(",,,"), m_PrinterName, MAX_PATH ) ;
    if(( m_pDevice = _tcstok( m_PrinterName, TEXT(","))) &&
       ( m_pDriver = _tcstok( NULL, TEXT(", "))) &&
       ( m_pOutput = _tcstok( NULL, TEXT(", ")))) 
    {
        //ok
    }
    else
    {
	    throw CException(TEXT("CPHDCHog::CPHDCHog(): could not find default printer settings. GetProfileString(Windows, device)\n"));
    }
    if ( (MAX_PATH - 1 == dwBytesRead) || (MAX_PATH - 2 == dwBytesRead) )
    {
	    throw CException(TEXT("Internal error - CPHDCHog::CPHDCHog(): GetProfileString(Windows, device) - buffer too small. MAX_PATH=%d, dwBytesRead=%d\n"), MAX_PATH, dwBytesRead);
    }
    if (6 > dwBytesRead)
    {
	    throw CException(TEXT("Internal error - CPHDCHog::CPHDCHog(): GetProfileString(Windows, device) - (6 > dwBytesRead(%d)).\n"), dwBytesRead);
    }
	HOGGERDPF((
		"CPHDCHog::CPHDCHog(): m_PrinterName=%s, m_pDevice=%s, m_pDriver=%s, m_pOutput=%s\n", 
		m_PrinterName,
        m_pDevice,
        m_pDriver,
        m_pOutput
		));

    if( !::OpenPrinter( m_PrinterName, &m_hPrinter, NULL ))
    {
        throw CException(TEXT("CPHDCHog::CPHDCHog(): OpenPrinter(%s) failed with %d.\n"), m_PrinterName, ::GetLastError());
    }
    _ASSERTE_(NULL != m_hPrinter);

    long lStructSize;
    if( 0 > ( lStructSize = ::DocumentProperties( NULL, m_hPrinter, NULL, NULL, NULL, 0 )))
    {
        ::ClosePrinter(m_hPrinter);
        throw CException(TEXT("CPHDCHog::CPHDCHog(): 1st DocumentProperties() failed with %d.\n"), ::GetLastError());
    }

    if( NULL == ( m_pDevMode = (PDEVMODE) malloc(lStructSize )))
    {
        ::ClosePrinter(m_hPrinter);
        throw CException(TEXT("CPHDCHog::CPHDCHog(): malloc(%d) failed.\n"), lStructSize);
    }

    if (0 > DocumentProperties(
            NULL,
            m_hPrinter,
            NULL,
            m_pDevMode,
            NULL,
            DM_OUT_BUFFER ))
    {
        ::ClosePrinter(m_hPrinter);
        throw CException(TEXT("CPHDCHog::CPHDCHog(): 2nd DocumentProperties() failed with .\n"), ::GetLastError());
    }

    m_pDevMode->dmOrientation = DMORIENT_PORTRAIT;
    m_pDevMode->dmPaperSize = DMPAPER_A4;
    m_pDevMode->dmFields = DM_ORIENTATION | DM_PAPERSIZE ;
    if( 0 > DocumentProperties( 
            NULL,
            m_hPrinter,
            NULL,
            m_pDevMode,
            m_pDevMode,
            DM_IN_BUFFER | DM_OUT_BUFFER
            )
      )
    {
        ::ClosePrinter(m_hPrinter);
        throw CException(TEXT("CPHDCHog::CPHDCHog(): 3rd DocumentProperties() failed with .\n"), ::GetLastError());
    }
}

CPHDCHog::~CPHDCHog(void)
{
	HaltHoggingAndFreeAll();
    ::ClosePrinter(m_hPrinter);
    free(m_pDevMode);
}


HDC CPHDCHog::CreatePseudoHandle(DWORD /*index*/, TCHAR * /*szTempName*/)
{
    return ::CreateDC( m_pDriver, m_pDevice, m_pOutput, m_pDevMode ) ;
}



bool CPHDCHog::ReleasePseudoHandle(DWORD /*index*/)
{
	return true;
}


bool CPHDCHog::ClosePseudoHandle(DWORD index)
{
    return (0 != ::DeleteDC(m_ahHogger[index]));
}


bool CPHDCHog::PostClosePseudoHandle(DWORD /*index*/)
{
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\pheventhog.h ===
#ifndef __PHEVENT_HOG_H
#define __PHEVENT_HOG_H

//
// this class is used for hogging a resource.
// it differs from simple hogging by dynamically
// hogging all resources and then releasing some.
// the level of free resources can be controlled.
//



#include "PseudoHandleHog.h"


class CPHEventHog : public CPseudoHandleHog<HANDLE, NULL>
{
public:
	//
	// does not hog Resources yet.
	//
	CPHEventHog(
		const DWORD dwMaxFreeResources, 
		const DWORD dwSleepTimeAfterFullHog = 1000, 
		const DWORD dwSleepTimeAfterFreeingSome = 1000,
        const bool fNamedObject = false
		);
    ~CPHEventHog(void);

protected:
	HANDLE CreatePseudoHandle(DWORD index, TCHAR *szTempName = 0);
	bool ReleasePseudoHandle(DWORD index);
	bool ClosePseudoHandle(DWORD index);
	bool PostClosePseudoHandle(DWORD index);
};

#endif //__PHEVENT_HOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phfiberhog.cpp ===
//
// this class is used for hogging Resources.
// it differs from simple hogging by dynamically
// hogging all Resources and then releasing some.
// the level of free Resources can be controlled.
//


//#define HOGGER_LOGGING

#include "PHFiberHog.h"

static VOID CALLBACK FiberStartRoutine(
    PVOID lpParameter   // fiber data
    )
{
    CPHFiberHog *pThis = (CPHFiberHog*)lpParameter;
    if (pThis->m_fAbort)
	{
		::SwitchToFiber(pThis->m_pvMainFiber);;
	}
	if (pThis->m_fHaltHogging)
	{
		::SwitchToFiber(pThis->m_pvMainFiber);;
	}

    pThis->m_dwNextFreeIndex++;
    //HOGGERDPF(("FiberStartRoutine(%d): .\n", pThis->m_dwNextFreeIndex));
    pThis->m_ahHogger[pThis->m_dwNextFreeIndex] = ::CreateFiber(
        0,  // initial thread stack size, in bytes
        FiberStartRoutine, // pointer to fiber function
        lpParameter  // this is "this" actually. argument for new fiber
        );
    if (pThis->m_ahHogger[pThis->m_dwNextFreeIndex])
    {
        //HOGGERDPF(("CreateFiber(%d): returned 0x%08X.\n", pThis->m_dwNextFreeIndex, pThis->m_ahHogger[pThis->m_dwNextFreeIndex]));
        ::SwitchToFiber(pThis->m_ahHogger[pThis->m_dwNextFreeIndex]);
    }
    else
    {
        HOGGERDPF(("CreateFiber(%d): failed with %d.\n", pThis->m_dwNextFreeIndex, ::GetLastError()));
        ::SwitchToFiber(pThis->m_pvMainFiber);
    }
}

CPHFiberHog::CPHFiberHog(
	const DWORD dwMaxFreeResources, 
	const DWORD dwSleepTimeAfterFullHog, 
	const DWORD dwSleepTimeAfterFreeingSome
	)
	:
	CHogger(dwMaxFreeResources, dwSleepTimeAfterFullHog, dwSleepTimeAfterFreeingSome),
    m_dwNextFreeIndex(0),
    m_pvMainFiber(NULL)
{
    return;
}

CPHFiberHog::~CPHFiberHog(void)
{
	HaltHoggingAndFreeAll();
}


bool CPHFiberHog::HogAll(void)
{
    if (NULL == m_pvMainFiber)
    {
        m_pvMainFiber = ::ConvertThreadToFiber(0);
    }
    if (NULL == m_pvMainFiber)
    {
        _ASSERTE_(false);
        return true;
    }

    m_ahHogger[m_dwNextFreeIndex] = ::CreateFiber(
        1024,  // initial thread stack size, in bytes
        FiberStartRoutine, // pointer to fiber function
        (void*)this  // argument for new fiber
        );
    if (m_ahHogger[m_dwNextFreeIndex])
    {
        HOGGERDPF(("CreateFiber(%d): returned 0x%08X.\n", m_dwNextFreeIndex, m_ahHogger[m_dwNextFreeIndex]));
        ::SwitchToFiber(m_ahHogger[m_dwNextFreeIndex]);
    }
    else
    {
        HOGGERDPF(("CreateFiber(%d): failed with %d.\n", m_dwNextFreeIndex, ::GetLastError()));
    }

    if (m_fAbort)
	{
		return false;
	}
	if (m_fHaltHogging)
	{
        //redundant, but more clear
		return true;
	}
    return true;
}




void CPHFiberHog::FreeAll(void)
{
    for (; m_dwNextFreeIndex > 0; m_dwNextFreeIndex--)
    {
        ::DeleteFiber(m_ahHogger[m_dwNextFreeIndex-1]);
    }
}


bool CPHFiberHog::FreeSome(void)
{
	DWORD dwOriginalNextFreeIndex = m_dwNextFreeIndex;
	DWORD dwToFree = 
		(RANDOM_AMOUNT_OF_FREE_RESOURCES == m_dwMaxFreeResources) ?
		rand() && (rand()<<16) :
		m_dwMaxFreeResources;
	dwToFree = min(dwToFree, m_dwNextFreeIndex);

    for (; m_dwNextFreeIndex > dwOriginalNextFreeIndex - dwToFree; m_dwNextFreeIndex--)
    {
        ::DeleteFiber(m_ahHogger[m_dwNextFreeIndex-1]);
    }
    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\pheventhog.cpp ===
//
// this class is used for hogging Resources.
// it differs from simple hogging by dynamically
// hogging all Resources and then releasing some.
// the level of free Resources can be controlled.
//


//#define HOGGER_LOGGING

#include "PHEventHog.h"



CPHEventHog::CPHEventHog(
	const DWORD dwMaxFreeResources, 
	const DWORD dwSleepTimeAfterFullHog, 
	const DWORD dwSleepTimeAfterFreeingSome,
    const bool fNamedObject
	)
	:
	CPseudoHandleHog<HANDLE, NULL>(
        dwMaxFreeResources, 
        dwSleepTimeAfterFullHog, 
        dwSleepTimeAfterFreeingSome,
        fNamedObject
        )
{
	return;
}

CPHEventHog::~CPHEventHog(void)
{
	HaltHoggingAndFreeAll();
}


HANDLE CPHEventHog::CreatePseudoHandle(DWORD /*index*/, TCHAR *szTempName)
{
	return ::CreateEvent(
		NULL, // pointer to security attributes 
		false, // flag for manual-reset event 
		true, // flag for initial state 
		szTempName
		);
}



bool CPHEventHog::ReleasePseudoHandle(DWORD /*index*/)
{
	return true;
}


bool CPHEventHog::ClosePseudoHandle(DWORD index)
{
    return (0 != ::CloseHandle(m_ahHogger[index]));
}




bool CPHEventHog::PostClosePseudoHandle(DWORD /*index*/)
{
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phfiberhog.h ===
#ifndef __PHFIBER_HOG_H
#define __PHFIBER_HOG_H

//
// this class is used for hogging a resource.
// it differs from simple hogging by dynamically
// hogging all resources and then releasing some.
// the level of free resources can be controlled.
//



#include "Hogger.h"


class CPHFiberHog : public CHogger
{
public:
	//
	// does not hog Resources yet.
	//
	CPHFiberHog(
		const DWORD dwMaxFreeResources, 
		const DWORD dwSleepTimeAfterFullHog = 1000, 
		const DWORD dwSleepTimeAfterFreeingSome = 1000
		);
    ~CPHFiberHog(void);

protected:
	virtual void FreeAll(void);

	virtual bool HogAll(void);
	virtual bool FreeSome(void);

private:
	static friend VOID CALLBACK FiberStartRoutine(PVOID lpParameter);

    //
    // the hogger array
    //
	void* m_ahHogger[HANDLE_ARRAY_SIZE];

    //
    // index to next free entry in hogger array
    //
	DWORD m_dwNextFreeIndex;

    void* m_pvMainFiber;

};

#endif //__PHFIBER_HOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phfilehog.h ===
#ifndef __PHFILE_HOG_H
#define __PHFILE_HOG_H

//
// this class is used for hogging a resource.
// it differs from simple hogging by dynamically
// hogging all resources and then releasing some.
// the level of free resources can be controlled.
//



#include "PseudoHandleHog.h"


class CPHFileHog : public CPseudoHandleHog<HANDLE, (DWORD)INVALID_HANDLE_VALUE>
{
public:
	//
	// does not hog Resources yet.
	//
	CPHFileHog(
		LPCTSTR szTempPath,
		const DWORD dwMaxFreeResources, 
		const DWORD dwSleepTimeAfterFullHog = 1000, 
		const DWORD dwSleepTimeAfterFreeingSome = 1000
		);
    ~CPHFileHog(void);

protected:
	HANDLE CreatePseudoHandle(DWORD index, TCHAR *szTempName = 0);
	bool ReleasePseudoHandle(DWORD index);
	bool ClosePseudoHandle(DWORD index);
	bool PostClosePseudoHandle(DWORD index);

private:
	TCHAR *m_aszFileName[HANDLE_ARRAY_SIZE];
	int m_nMaxTempFileLen;
	
	//
	// the path of the temp file
	//
	TCHAR m_szTempPath[MAX_PATH+1];
};

#endif //__PHFILE_HOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phfilemaphog.cpp ===
//
// this class is used for hogging Resources.
// it differs from simple hogging by dynamically
// hogging all Resources and then releasing some.
// the level of free Resources can be controlled.
//


//#define HOGGER_LOGGING

#include "PHFileMapHog.h"



CPHFileMapHog::CPHFileMapHog(
	const DWORD dwMaxFreeResources, 
	const DWORD dwSleepTimeAfterFullHog, 
	const DWORD dwSleepTimeAfterFreeingSome,
    const bool fNamedObject
	)
	:
	CPseudoHandleHog<HANDLE, NULL>(
        dwMaxFreeResources, 
        dwSleepTimeAfterFullHog, 
        dwSleepTimeAfterFreeingSome,
        fNamedObject
        )
{
	return;
}

CPHFileMapHog::~CPHFileMapHog(void)
{
	HaltHoggingAndFreeAll();
}


HANDLE CPHFileMapHog::CreatePseudoHandle(DWORD /*index*/, TCHAR *szTempName)
{
    return ::CreateFileMapping( 
        INVALID_HANDLE_VALUE, // create in paging file     
        NULL, // no security 
        PAGE_READWRITE, // read/write access     
        0, // size (high) 
        4*1024, // size(low) 
        szTempName // mapping object name
        );  
}



bool CPHFileMapHog::ReleasePseudoHandle(DWORD /*index*/)
{
	return true;
}


bool CPHFileMapHog::ClosePseudoHandle(DWORD index)
{
    return (0 != ::CloseHandle(m_ahHogger[index]));
}




bool CPHFileMapHog::PostClosePseudoHandle(DWORD /*index*/)
{
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phfilemaphog.h ===
#ifndef __PHFILEMAP_HOG_H
#define __PHFILEMAP_HOG_H

//
// this class is used for hogging a resource.
// it differs from simple hogging by dynamically
// hogging all resources and then releasing some.
// the level of free resources can be controlled.
//



#include "PseudoHandleHog.h"


class CPHFileMapHog : public CPseudoHandleHog<HANDLE, NULL>
{
public:
	//
	// does not hog Resources yet.
	//
	CPHFileMapHog(
		const DWORD dwMaxFreeResources, 
		const DWORD dwSleepTimeAfterFullHog = 1000, 
		const DWORD dwSleepTimeAfterFreeingSome = 1000,
        const bool fNamedObject = false
		);
    ~CPHFileMapHog(void);

protected:
	HANDLE CreatePseudoHandle(DWORD index, TCHAR *szTempName = 0);
	bool ReleasePseudoHandle(DWORD index);
	bool ClosePseudoHandle(DWORD index);
	bool PostClosePseudoHandle(DWORD index);
};

#endif //__PHFILEMAP_HOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phfilehog.cpp ===
//
// this class is used for hogging Resources.
// it differs from simple hogging by dynamically
// hogging all Resources and then releasing some.
// the level of free Resources can be controlled.
//


//#define HOGGER_LOGGING

#include "PHFileHog.h"



CPHFileHog::CPHFileHog(
	LPCTSTR szTempPath,
	const DWORD dwMaxFreeResources, 
	const DWORD dwSleepTimeAfterFullHog, 
	const DWORD dwSleepTimeAfterFreeingSome
	)
	:
	CPseudoHandleHog<HANDLE, (DWORD)INVALID_HANDLE_VALUE>(
        dwMaxFreeResources, 
        dwSleepTimeAfterFullHog, 
        dwSleepTimeAfterFreeingSome,
        true //named object
        )
{
	//
	// copy temp path
	//
	::lstrcpyn(m_szTempPath, szTempPath, MAX_PATH);
	m_szTempPath[MAX_PATH] = TEXT('\0');

	//
	// length is path + \ + file-length(8.3) + NULL
	//
    m_nMaxTempFileLen = ::lstrlen(m_szTempPath) + 1 + (8+1+3) + 1;

	for (int i = 0; i < HANDLE_ARRAY_SIZE; i++)
	{
		m_aszFileName[i] = NULL;
	}
}

CPHFileHog::~CPHFileHog(void)
{
	HaltHoggingAndFreeAll();
}


HANDLE CPHFileHog::CreatePseudoHandle(DWORD /*index*/, TCHAR *szTempName)
{
/* FILE_FLAG_DELETE_ON_CLOSE used
	m_aszFileName[index] = new TCHAR[m_nMaxTempFileLen];
	if (NULL == m_aszFileName[index])
	{
		HOGGERDPF(("CPHFileHog::CreatePseudoHandle(%d): new TCHAR[MAX_PATH] failed.\n", index));
		return INVALID_HANDLE_VALUE;
	}

    _sntprintf(m_aszFileName[index], m_nMaxTempFileLen, "%s\\%s", m_szTempPath, szTempName);
    m_aszFileName[index][m_nMaxTempFileLen-1] = TEXT('\0');
*/
    TCHAR szName[1024];
    _sntprintf(szName, sizeof(szName)/sizeof(*szName)-1, TEXT("%s\\%s"), m_szTempPath, szTempName);
    szName[sizeof(szName)/sizeof(*szName)-1] = TEXT('\0');
	return ::CreateFile(  
		szName, //m_aszFileName[index],          // pointer to name of the file
		GENERIC_WRITE | GENERIC_READ,       // access (read-write) mode
		0,           // share mode
		0, // pointer to security attributes
		CREATE_ALWAYS,  // how to create
		FILE_FLAG_DELETE_ON_CLOSE,  // file attributes
		NULL         // handle to file with attributes to copy
		);
}



bool CPHFileHog::ReleasePseudoHandle(DWORD /*index*/)
{
	return true;
}


bool CPHFileHog::ClosePseudoHandle(DWORD index)
{
    return (0 != ::CloseHandle(m_ahHogger[index]));
}


bool CPHFileHog::PostClosePseudoHandle(DWORD /*index*/)
{
/* FILE_FLAG_DELETE_ON_CLOSE used
	if (!::DeleteFile(m_aszFileName[index]))
	{
		HOGGERDPF(("CPHFileHog::PostClosePseudoHandle(%d): DeleteFile(%s) failed with %d.\n", index, m_aszFileName[index], ::GetLastError()));
	}
	_ASSERTE_(NULL != m_aszFileName[index]);
	delete[] m_aszFileName[index];
	m_aszFileName[index] = NULL;
*/

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phheaphog.cpp ===
//
// this class is used for hogging Resources.
// it differs from simple hogging by dynamically
// hogging all Resources and then releasing some.
// the level of free Resources can be controlled.
//


//#define HOGGER_LOGGING

#include "PHHeapHog.h"



CPHHeapHog::CPHHeapHog(
	const DWORD dwMaxFreeResources, 
	const DWORD dwSleepTimeAfterFullHog, 
	const DWORD dwSleepTimeAfterFreeingSome
	)
	:
	CPseudoHandleHog<HANDLE, NULL>(
        dwMaxFreeResources, 
        dwSleepTimeAfterFullHog, 
        dwSleepTimeAfterFreeingSome,
        false //fNamedObject
        )
{
	return;
}

CPHHeapHog::~CPHHeapHog(void)
{
	HaltHoggingAndFreeAll();
}


HANDLE CPHHeapHog::CreatePseudoHandle(DWORD /*index*/, TCHAR * /*szTempName*/)
{
    DWORD flOptions = 0;
    DWORD dwMaximumSize;

    if (rand()%2) flOptions = HEAP_GENERATE_EXCEPTIONS;
    if (rand()%2) flOptions |= HEAP_NO_SERIALIZE;

    if (rand()%2) dwMaximumSize = 0;
    else dwMaximumSize = rand();

    return ::HeapCreate( 
        flOptions,      // heap allocation flag
        1,  // will round up to 1 page. initial heap size
        dwMaximumSize   // maximum heap size
        );
}



bool CPHHeapHog::ReleasePseudoHandle(DWORD /*index*/)
{
	return true;
}


bool CPHHeapHog::ClosePseudoHandle(DWORD index)
{
    return (0 != ::HeapDestroy(m_ahHogger[index]));
}




bool CPHHeapHog::PostClosePseudoHandle(DWORD /*index*/)
{
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phjobobjecthog.cpp ===
//
// this class is used for hogging Resources.
// it differs from simple hogging by dynamically
// hogging all Resources and then releasing some.
// the level of free Resources can be controlled.
//


//#define HOGGER_LOGGING

#include "PHJobObjectHog.h"



CPHJobObjectHog::CPHJobObjectHog(
	const DWORD dwMaxFreeResources, 
	const DWORD dwSleepTimeAfterFullHog, 
	const DWORD dwSleepTimeAfterFreeingSome,
    const bool fNamedObject
	)
	:
	CPseudoHandleHog<HANDLE, NULL>(
        dwMaxFreeResources, 
        dwSleepTimeAfterFullHog, 
        dwSleepTimeAfterFreeingSome,
        fNamedObject
        )
{
	return;
}

CPHJobObjectHog::~CPHJobObjectHog(void)
{
	HaltHoggingAndFreeAll();
}


HANDLE CPHJobObjectHog::CreatePseudoHandle(DWORD /*index*/, TCHAR *szTempName)
{
#if _WIN32_WINNT > 0x400
    return 	(::CreateJobObject(NULL, szTempName));
#else
    MessageBox(::GetFocus(), TEXT("Job Objects require _WIN32_WINNT > 0x400"), TEXT("Hogger"), MB_OK);
    szTempName; // to prevent compiler warning
    ::SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return NULL;
#endif
}



bool CPHJobObjectHog::ReleasePseudoHandle(DWORD /*index*/)
{
	return true;
}


bool CPHJobObjectHog::ClosePseudoHandle(DWORD index)
{
    return (0 != ::CloseHandle(m_ahHogger[index]));
}




bool CPHJobObjectHog::PostClosePseudoHandle(DWORD /*index*/)
{
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phheaphog.h ===
#ifndef __PHHEAPHOG_H
#define __PHHEAPHOG_H

//
// this class is used for hogging a resource.
// it differs from simple hogging by dynamically
// hogging all resources and then releasing some.
// the level of free resources can be controlled.
//



#include "PseudoHandleHog.h"


class CPHHeapHog : public CPseudoHandleHog<HANDLE, NULL>
{
public:
	//
	// does not hog Resources yet.
	//
	CPHHeapHog(
		const DWORD dwMaxFreeResources, 
		const DWORD dwSleepTimeAfterFullHog = 1000, 
		const DWORD dwSleepTimeAfterFreeingSome = 1000
		);
    ~CPHHeapHog(void);

protected:
	HANDLE CreatePseudoHandle(DWORD index, TCHAR *szTempName = 0);
	bool ReleasePseudoHandle(DWORD index);
	bool ClosePseudoHandle(DWORD index);
	bool PostClosePseudoHandle(DWORD index);
};

#endif //__PHHEAPHOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phjobobjecthog.h ===
#ifndef __PHJOB_OBJECT_HOG_H
#define __PHJOB_OBJECT_HOG_H

//
// this class is used for hogging a resource.
// it differs from simple hogging by dynamically
// hogging all resources and then releasing some.
// the level of free resources can be controlled.
//



#include "PseudoHandleHog.h"


class CPHJobObjectHog : public CPseudoHandleHog<HANDLE, NULL>
{
public:
	//
	// does not hog Resources yet.
	//
	CPHJobObjectHog(
		const DWORD dwMaxFreeResources, 
		const DWORD dwSleepTimeAfterFullHog = 1000, 
		const DWORD dwSleepTimeAfterFreeingSome = 1000,
        const bool fNamedObject = false
		);
    ~CPHJobObjectHog(void);

protected:
	HANDLE CreatePseudoHandle(DWORD index, TCHAR *szTempName = 0);
	bool ReleasePseudoHandle(DWORD index);
	bool ClosePseudoHandle(DWORD index);
	bool PostClosePseudoHandle(DWORD index);
};

#endif //__PHJOB_OBJECT_HOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phmailslothog.h ===
#ifndef __PHMAILSLOT_HOG_H
#define __PHMAILSLOT_HOG_H

//
// this class is used for hogging a resource.
// it differs from simple hogging by dynamically
// hogging all resources and then releasing some.
// the level of free resources can be controlled.
//



#include "PseudoHandleHog.h"


class CPHMailSlotHog : public CPseudoHandleHog<HANDLE, (DWORD)INVALID_HANDLE_VALUE>
{
public:
	//
	// does not hog Resources yet.
	//
	CPHMailSlotHog(
		const DWORD dwMaxFreeResources, 
		const DWORD dwSleepTimeAfterFullHog = 1000, 
		const DWORD dwSleepTimeAfterFreeingSome = 1000,
        const bool fWrite = false
		);
    ~CPHMailSlotHog(void);

protected:
	HANDLE CreatePseudoHandle(DWORD index, TCHAR *szTempName = 0);
	bool ReleasePseudoHandle(DWORD index);
	bool ClosePseudoHandle(DWORD index);
	bool PostClosePseudoHandle(DWORD index);

private:
    bool m_fWrite;
    HANDLE *m_aphWrite[2000];
};

#endif //__PHMAILSLOT_HOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phkeyhog.cpp ===
//
// this class is used for hogging Resources.
// it differs from simple hogging by dynamically
// hogging all Resources and then releasing some.
// the level of free Resources can be controlled.
//


//#define HOGGER_LOGGING

#include "PHKeyHog.h"



CPHKeyHog::CPHKeyHog(
	const DWORD dwMaxFreeResources, 
	const DWORD dwSleepTimeAfterFullHog, 
	const DWORD dwSleepTimeAfterFreeingSome,
	const TCHAR* szHKCUSubKey, 
    const bool fNamedObject
	)
	:
	CPseudoHandleHog<HKEY, NULL>(
        dwMaxFreeResources, 
        dwSleepTimeAfterFullHog, 
        dwSleepTimeAfterFreeingSome,
        fNamedObject
        )
{
    //
    // need to find a key to hog, this means that i can open it.
    //
    m_hKey = HKEY_CURRENT_USER;
    ::lstrcpyn(m_szName, szHKCUSubKey, sizeof(m_szName)/sizeof(*m_szName)-1);
    m_szName[sizeof(m_szName)/sizeof(*m_szName)-1] = TEXT('\0');

    if (NULL == CreatePseudoHandle(0))
    {
		throw CException(
			TEXT("CPHKeyHog(): CreatePseudoHandle(HKEY_CURRENT_USER, Environment) failed with %d"), 
			::GetLastError()
			);
    }

    m_dwNextFreeIndex++;

	return;
}

CPHKeyHog::~CPHKeyHog(void)
{
	HaltHoggingAndFreeAll();
}


HKEY CPHKeyHog::CreatePseudoHandle(DWORD /*index*/, TCHAR * /*szTempName*/)
{
    //
    // note that if we fail we must return NULL, and set last error
    //

    HKEY hKey = NULL;

    long lRegOpenKeyRetval = ::RegOpenKey(
		m_hKey,         // handle to open key
		m_szName,   // address of name of subkey to open
		&hKey
		);
    if (ERROR_SUCCESS != lRegOpenKeyRetval)
	{
        ::SetLastError(lRegOpenKeyRetval);
		HOGGERDPF((
			"CPHKeyHog::CreatePseudoHandle(): RegOpenKey() failed with %d\n", 
			lRegOpenKeyRetval
			));
		return NULL;
	}
	else
	{
        _ASSERTE_(NULL != hKey);
		return hKey;
	}
}



bool CPHKeyHog::ReleasePseudoHandle(DWORD /*index*/)
{
	return true;
}


bool CPHKeyHog::ClosePseudoHandle(DWORD index)
{
    long lRegCloseKeyRetval = ::RegCloseKey(m_ahHogger[index]);
    if (0 != lRegCloseKeyRetval)
    {
        ::SetLastError(lRegCloseKeyRetval);
        return false;
    }

    return true;
}




bool CPHKeyHog::PostClosePseudoHandle(DWORD /*index*/)
{
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phkeyhog.h ===
#ifndef __PHKEY_HOG_H
#define __PHKEY_HOG_H

//
// this class is used for hogging a resource.
// it differs from simple hogging by dynamically
// hogging all resources and then releasing some.
// the level of free resources can be controlled.
//



#include "PseudoHandleHog.h"


class CPHKeyHog : public CPseudoHandleHog<HKEY, NULL>
{
public:
	//
	// does not hog Resources yet.
	//
	CPHKeyHog(
		const DWORD dwMaxFreeResources, 
		const DWORD dwSleepTimeAfterFullHog = 1000, 
		const DWORD dwSleepTimeAfterFreeingSome = 1000,
	    const TCHAR* szHKCUSubKey = TEXT("Environment"), 
        const bool fNamedObject = false
		);
    ~CPHKeyHog(void);

protected:
	HKEY CreatePseudoHandle(DWORD index, TCHAR *szTempName = 0);
	bool ReleasePseudoHandle(DWORD index);
	bool ClosePseudoHandle(DWORD index);
	bool PostClosePseudoHandle(DWORD index);

private:
    HKEY m_hKey;
    TCHAR m_szName[1024];

};

#endif //__PHKEY_HOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phmutexhog.h ===
#ifndef __PHMUTEX_HOG_H
#define __PHMUTEX_HOG_H

//
// this class is used for hogging a resource.
// it differs from simple hogging by dynamically
// hogging all resources and then releasing some.
// the level of free resources can be controlled.
//



#include "PseudoHandleHog.h"


class CPHMutexHog : public CPseudoHandleHog<HANDLE, NULL>
{
public:
	//
	// does not hog Resources yet.
	//
	CPHMutexHog(
		const DWORD dwMaxFreeResources, 
		const DWORD dwSleepTimeAfterFullHog = 1000, 
		const DWORD dwSleepTimeAfterFreeingSome = 1000,
        const bool fNamedObject = false
		);
    ~CPHMutexHog(void);

protected:
	HANDLE CreatePseudoHandle(DWORD index, TCHAR *szTempName = 0);
	bool ReleasePseudoHandle(DWORD index);
	bool ClosePseudoHandle(DWORD index);
	bool PostClosePseudoHandle(DWORD index);
};

#endif //__PHMUTEX_HOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phpenhog.cpp ===
//
// this class is used for hogging Resources.
// it differs from simple hogging by dynamically
// hogging all Resources and then releasing some.
// the level of free Resources can be controlled.
//


//#define HOGGER_LOGGING

#include "PHPenHog.h"



CPHPenHog::CPHPenHog(
	const DWORD dwMaxFreeResources, 
	const DWORD dwSleepTimeAfterFullHog, 
	const DWORD dwSleepTimeAfterFreeingSome
	)
	:
	CPseudoHandleHog<HPEN, NULL>(
        dwMaxFreeResources, 
        dwSleepTimeAfterFullHog, 
        dwSleepTimeAfterFreeingSome,
        false //named object
        )
{
	return;
}

CPHPenHog::~CPHPenHog(void)
{
	HaltHoggingAndFreeAll();
}


HPEN CPHPenHog::CreatePseudoHandle(DWORD /*index*/, TCHAR * /*szTempName*/)
{
    return ::CreatePen(PS_SOLID, 100, 0x00AA1108);
}



bool CPHPenHog::ReleasePseudoHandle(DWORD /*index*/)
{
	return true;
}


bool CPHPenHog::ClosePseudoHandle(DWORD index)
{
    return (0 != ::DeleteObject(m_ahHogger[index]));
}


bool CPHPenHog::PostClosePseudoHandle(DWORD /*index*/)
{
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phmutexhog.cpp ===
//
// this class is used for hogging Resources.
// it differs from simple hogging by dynamically
// hogging all Resources and then releasing some.
// the level of free Resources can be controlled.
//


//#define HOGGER_LOGGING

#include "PHMutexHog.h"



CPHMutexHog::CPHMutexHog(
	const DWORD dwMaxFreeResources, 
	const DWORD dwSleepTimeAfterFullHog, 
	const DWORD dwSleepTimeAfterFreeingSome,
    const bool fNamedObject
	)
	:
	CPseudoHandleHog<HANDLE, NULL>(
        dwMaxFreeResources, 
        dwSleepTimeAfterFullHog, 
        dwSleepTimeAfterFreeingSome,
        fNamedObject
        )
{
	return;
}

CPHMutexHog::~CPHMutexHog(void)
{
	HaltHoggingAndFreeAll();
}


HANDLE CPHMutexHog::CreatePseudoHandle(DWORD /*index*/, TCHAR *szTempName)
{
	return ::CreateMutex(
		NULL, // pointer to security attributes 
		true, // flag for initial owner 
		szTempName
		);
}



bool CPHMutexHog::ReleasePseudoHandle(DWORD /*index*/)
{
	return true;
}


bool CPHMutexHog::ClosePseudoHandle(DWORD index)
{
    return (0 != ::CloseHandle(m_ahHogger[index]));
}


bool CPHMutexHog::PostClosePseudoHandle(DWORD /*index*/)
{
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phmailslothog.cpp ===
//
// this class is used for hogging Resources.
// it differs from simple hogging by dynamically
// hogging all Resources and then releasing some.
// the level of free Resources can be controlled.
//


//#define HOGGER_LOGGING

#include "PHMailSlotHog.h"



CPHMailSlotHog::CPHMailSlotHog(
	const DWORD dwMaxFreeResources, 
	const DWORD dwSleepTimeAfterFullHog, 
	const DWORD dwSleepTimeAfterFreeingSome,
    const bool fWrite
	)
	:
	CPseudoHandleHog<HANDLE, (DWORD)INVALID_HANDLE_VALUE>(
        dwMaxFreeResources, 
        dwSleepTimeAfterFullHog, 
        dwSleepTimeAfterFreeingSome,
        true //fNamedObject
        ),
    m_fWrite(fWrite)
{
    for (int i = 0; i < sizeof(m_aphWrite)/sizeof(*m_aphWrite); i++)
    {
        m_aphWrite[i] = new HANDLE[i+1];
        if (NULL == m_aphWrite[i])
        {
            HOGGERDPF(("CPHMailSlotHog::CPHMailSlotHog(): new HANDLE[%d] failed.\n", i+1));
        }
    }
	return;
}

CPHMailSlotHog::~CPHMailSlotHog(void)
{
	HaltHoggingAndFreeAll();
}


HANDLE CPHMailSlotHog::CreatePseudoHandle(DWORD index, TCHAR *szTempName)
{
    TCHAR szName[64];
    _sntprintf(szName, sizeof(szName)/sizeof(*szName)-1, TEXT("\\\\.\\mailslot\\hogger\\%s"), szTempName);
    szName[sizeof(szName)/sizeof(*szName)-1] = TEXT('\0');

    if (m_fWrite && (index < sizeof(m_aphWrite)/sizeof(*m_aphWrite)))
    {
        for (DWORD i = 0; i < index; i++)
        {
            if (m_apszName[i])
            {
                if (INVALID_HANDLE_VALUE == (m_aphWrite[index][i] = ::CreateFile(
                        m_apszName[i],
                        GENERIC_WRITE, 
                        FILE_SHARE_READ,  // required to write to a mailslot 
                        (LPSECURITY_ATTRIBUTES) NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL, 
                        (HANDLE) NULL
                        ))
                   )
                {
                    //HOGGERDPF(("CPHMailSlotHog::CreatePseudoHandle(): CreateFile(%s) failed with %d.\n", m_apszName[i], ::GetLastError()));
                    //break;
                    continue;
                }
            }

            // almost 400 bytes.
            static const char cszBuff[] = "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX";
            DWORD dwNumberOfBytesWritten = 0;
            if (!::WriteFile(
                    m_aphWrite[index][i],                    // handle to file to write to
                    cszBuff,                // pointer to data to write to file
                    sizeof(cszBuff),     // number of bytes to write
                    &dwNumberOfBytesWritten,  // pointer to number of bytes written
                    NULL        // pointer to structure for overlapped I/O
                    )
               )
            {
                HOGGERDPF(("CPHMailSlotHog::CreatePseudoHandle(): WriteFile(%s) failed with %d.\n", m_apszName[i], ::GetLastError()));
                continue;
            }

            if (!::CloseHandle(m_aphWrite[index][i]))
            {
                HOGGERDPF(("CPHMailSlotHog::CreatePseudoHandle(): CloseHandle(m_aphWrite[index=%d][i=%d]:%s) failed with %d.\n", index, i, m_apszName[i], ::GetLastError()));
            }
        }

    }

    //
    // keep the name, because we want it for openning the pipe.
    //
    m_apszName[index] = new TCHAR[::lstrlen(szName)+1];
    if (m_apszName[index])
    {
        ::lstrcpy(m_apszName[index], szName);
    }
    else
    {
        HOGGERDPF(("CPHMailSlotHog::CreatePseudoHandle(): m_apszName[index] = new char[%d] failed, trying to create a pipe anyway.\n", ::lstrlen(szName)+1));
    }

    return ::CreateMailslot(
        szName,         // pointer to string for mailslot name
        0,  // maximum message size (0 is any size)
        0,     // milliseconds before read time-out
        NULL // pointer to security structure
        );
}



bool CPHMailSlotHog::ReleasePseudoHandle(DWORD /*index*/)
{
	return true;
}


bool CPHMailSlotHog::ClosePseudoHandle(DWORD index)
{
    delete[]m_apszName[index];
    m_apszName[index] = NULL;
    return (0 != ::CloseHandle(m_ahHogger[index]));
}


bool CPHMailSlotHog::PostClosePseudoHandle(DWORD /*index*/)
{
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phpenhog.h ===
#ifndef __PHPEN_HOG_H
#define __PHPEN_HOG_H

//
// this class is used for hogging a resource.
// it differs from simple hogging by dynamically
// hogging all resources and then releasing some.
// the level of free resources can be controlled.
//



#include "PseudoHandleHog.h"


class CPHPenHog : public CPseudoHandleHog<HPEN, NULL>
{
public:
	//
	// does not hog Resources yet.
	//
	CPHPenHog(
		const DWORD dwMaxFreeResources, 
		const DWORD dwSleepTimeAfterFullHog = 1000, 
		const DWORD dwSleepTimeAfterFreeingSome = 1000
		);
    ~CPHPenHog(void);

protected:
	HPEN CreatePseudoHandle(DWORD index, TCHAR *szTempName = 0);
	bool ReleasePseudoHandle(DWORD index);
	bool ClosePseudoHandle(DWORD index);
	bool PostClosePseudoHandle(DWORD index);
};

#endif //__PHPEN_HOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phprinterhog.h ===
#ifndef __PHPRINTER_HOG_H
#define __PHPRINTER_HOG_H

//
// this class is used for hogging a resource.
// it differs from simple hogging by dynamically
// hogging all resources and then releasing some.
// the level of free resources can be controlled.
//



#include "PseudoHandleHog.h"


class CPHPrinterHog : public CPseudoHandleHog<HANDLE, NULL>
{
public:
	//
	// does not hog Resources yet.
	//
	CPHPrinterHog(
		const DWORD dwMaxFreeResources, 
		const DWORD dwSleepTimeAfterFullHog = 1000, 
		const DWORD dwSleepTimeAfterFreeingSome = 1000
		);
    ~CPHPrinterHog(void);

protected:
	HANDLE CreatePseudoHandle(DWORD index, TCHAR *szTempName = 0);
	bool ReleasePseudoHandle(DWORD index);
	bool ClosePseudoHandle(DWORD index);
	bool PostClosePseudoHandle(DWORD index);

private:
    TCHAR m_PrinterName[MAX_PATH];
    LPTSTR m_pDriver ;                   // used in parsing a profile string
    LPTSTR m_pDevice ;                   //    ditto
    LPTSTR m_pOutput ;                   //    ditto
};

#endif //__PHPRINTER_HOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phpipehog.cpp ===
//
// this class is used for hogging Resources.
// it differs from simple hogging by dynamically
// hogging all Resources and then releasing some.
// the level of free Resources can be controlled.
//


//#define HOGGER_LOGGING

#include "PHPipeHog.h"



CPHPipeHog::CPHPipeHog(
	const DWORD dwMaxFreeResources, 
	const DWORD dwSleepTimeAfterFullHog, 
	const DWORD dwSleepTimeAfterFreeingSome,
    const bool fWrite1K
	)
	:
	CPseudoHandleHog<HANDLE, NULL>(
        dwMaxFreeResources, 
        dwSleepTimeAfterFullHog, 
        dwSleepTimeAfterFreeingSome,
        false//fNamedObject
        ),
    m_fWrite1K(fWrite1K)
{
	return;
}

CPHPipeHog::~CPHPipeHog(void)
{
	HaltHoggingAndFreeAll();
}


HANDLE CPHPipeHog::CreatePseudoHandle(DWORD index, TCHAR * /*szTempName*/)
{
    HANDLE hReadSide;

    if (! ::CreatePipe( 
            &hReadSide,
            &m_hWriteSide[index],
            NULL, //security
            0 // size
            )
       )
    {
        return NULL;
    }

    _ASSERTE_(NULL != hReadSide);
    _ASSERTE_(NULL != m_hWriteSide[index]);

    if (m_fWrite1K)
    {
        static BYTE buffer[1024];
        DWORD dwNumberOfBytesWritten;
        if (!::WriteFile(
                m_hWriteSide[index],                    // handle to file to write to
                buffer,                // pointer to data to write to file
                sizeof(buffer),     // number of bytes to write
                &dwNumberOfBytesWritten,  // pointer to number of bytes written
                NULL        // pointer to structure for overlapped I/O
                )
           )
        {
            HOGGERDPF(("CPHPipeHog::CreatePseudoHandle(): WriteFile(m_hWriteSide[%d]) failed with %d.\n", index, ::GetLastError()));
        }
    }

    return hReadSide;
}



bool CPHPipeHog::ReleasePseudoHandle(DWORD /*index*/)
{
	return true;
}


bool CPHPipeHog::ClosePseudoHandle(DWORD index)
{
    return ( (0 != ::CloseHandle(m_ahHogger[index]) && (0 != ::CloseHandle(m_hWriteSide[index]))) );
}




bool CPHPipeHog::PostClosePseudoHandle(DWORD /*index*/)
{
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phpipehog.h ===
#ifndef __PHPIPE_HOG_H
#define __PHPIPE_HOG_H

//
// this class is used for hogging a resource.
// it differs from simple hogging by dynamically
// hogging all resources and then releasing some.
// the level of free resources can be controlled.
//



#include "PseudoHandleHog.h"


class CPHPipeHog : public CPseudoHandleHog<HANDLE, NULL>
{
public:
	//
	// does not hog Resources yet.
	//
	CPHPipeHog(
		const DWORD dwMaxFreeResources, 
		const DWORD dwSleepTimeAfterFullHog = 1000, 
	    const DWORD dwSleepTimeAfterFreeingSome = 1000,
        const bool fWrite1K = false
		);
    ~CPHPipeHog(void);

protected:
	HANDLE CreatePseudoHandle(DWORD index, TCHAR *szTempName = 0);
	bool ReleasePseudoHandle(DWORD index);
	bool ClosePseudoHandle(DWORD index);
	bool PostClosePseudoHandle(DWORD index);

private:
    //regular hogger array (m_ahHogger) is used as read handle
    HANDLE m_hWriteSide[HANDLE_ARRAY_SIZE];
    bool m_fWrite1K;
};

#endif //__PHPIPE_HOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phregisterwaithog.cpp ===
//
// this class is used for hogging Resources.
// it differs from simple hogging by dynamically
// hogging all Resources and then releasing some.
// the level of free Resources can be controlled.
//


//#define HOGGER_LOGGING

#include "PHRegisterWaitHog.h"


static void NTAPI CallBack(void* pVoid, BOOLEAN bTimeout)
{
    CPHRegisterWaitHog *pThis = (CPHRegisterWaitHog*)pVoid;
    ::InterlockedDecrement((long*)(&pThis->m_dwCallCount));
/*
	HOGGERDPF((
		"CallBack(bTimeout=%d): pThis->m_dwCallCount=%d, pThis->m_dwNextFreeIndex=%d.\n", 
        bTimeout,
        pThis->m_dwCallCount,
        pThis->m_dwNextFreeIndex
		));
*/
    return;   
}

CPHRegisterWaitHog::CPHRegisterWaitHog(
	const DWORD dwMaxFreeResources, 
	const DWORD dwSleepTimeAfterFullHog, 
	const DWORD dwSleepTimeAfterFreeingSome,
    const bool fNamedObject
	)
	:
	CPseudoHandleHog<HANDLE, NULL>(
        dwMaxFreeResources, 
        dwSleepTimeAfterFullHog, 
        dwSleepTimeAfterFreeingSome,
        fNamedObject
        ),
    m_dwCallCount(0)
{
	return;
}

CPHRegisterWaitHog::~CPHRegisterWaitHog(void)
{
	HaltHoggingAndFreeAll();
}


HANDLE CPHRegisterWaitHog::CreatePseudoHandle(DWORD index, TCHAR * /*szTempName*/)
{
#if _WIN32_WINNT > 0x400
    //
    // create an event, that this registration will wait upon
    //
    m_ahEvents[index] = ::CreateEvent(
		NULL, // pointer to security attributes 
		false, // flag for manual-reset event 
		false, // flag for initial state 
		NULL
		);
    if (NULL == m_ahEvents[index])
    {
		HOGGERDPF((
			"CPHRegisterWaitHog::CreatePseudoHandle(): CreateEvent(m_ahEvents[%d]) failed with %d\n", 
			index,
            ::GetLastError()
			));
        return NULL;
    }
/*
#define WT_EXECUTEDEFAULT       0x00000000                           
#define WT_EXECUTEINIOTHREAD    0x00000001                           
#define WT_EXECUTEINUITHREAD    0x00000002                           
#define WT_EXECUTEINWAITTHREAD  0x00000004                           
#define WT_EXECUTEONLYONCE      0x00000008                           
#define WT_EXECUTEINTIMERTHREAD 0x00000020                           
#define WT_EXECUTELONGFUNCTION  0x00000010                           
*/
	if ( ::RegisterWaitForSingleObject(
        &m_ahHogger[index],
        m_ahEvents[index], //m_hEvent,//::GetCurrentThread(),
        CallBack,
        (void*)this,
        (DWORD)-1,
        WT_EXECUTEINWAITTHREAD
        ))
    {
        return m_ahHogger[index];
    }
    else
    {
		HOGGERDPF((
			"ERROR: CPHRegisterWaitHog::CreatePseudoHandle(): RegisterWaitForSingleObject(m_ahHogger[%d]) failed with %d\n", 
            index,
            ::GetLastError()
			));
        if (!::CloseHandle(m_ahEvents[index]))
        {
		    HOGGERDPF((
			    "ERROR: CPHRegisterWaitHog::CreatePseudoHandle(): CloseHandle(m_ahEvents[%d]) failed with %d\n", 
                index,
                ::GetLastError()
			    ));
        }
        m_ahEvents[index] = NULL;
        return NULL;
    }
#else
    MessageBox(::GetFocus(), TEXT("CreateTimerQueue() requires _WIN32_WINNT > 0x400"), TEXT("Hogger"), MB_OK);
    ::SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return NULL;
#endif
}



bool CPHRegisterWaitHog::ReleasePseudoHandle(DWORD /*index*/)
{
	return true;
}


bool CPHRegisterWaitHog::ClosePseudoHandle(DWORD index)
{
#if _WIN32_WINNT > 0x400
    //
    // callback decrements
    //
    ::InterlockedIncrement((long*)(&m_dwCallCount));

    //
    // sometimes set the event, and sometimes just close the handle
    //
    _ASSERTE_(NULL != m_ahEvents[index]);
    if (!::SetEvent(m_ahEvents[index]))
    {
		HOGGERDPF((
			"CPHRegisterWaitHog::ClosePseudoHandle(): SetEvent(m_ahEvents[%d]) failed with %d\n", 
			index,
            ::GetLastError()
			));
    }
    else
    {
        DWORD dwTimeout = 0;
        while ((0 < m_dwCallCount) && (dwTimeout < 10000))
        {
            ::Sleep(0);
            dwTimeout++;
        }
        if (0 != m_dwCallCount)
        {
		    HOGGERDPF((
			    "CPHRegisterWaitHog::ClosePseudoHandle(): It seems that callback was not called for %d. m_dwCallCount=%d\n", 
			    index,
                m_dwCallCount
			    ));
            m_dwCallCount = 0;
        }
    }

    if (!::CloseHandle(m_ahEvents[index]))
    {
		HOGGERDPF((
			"CPHRegisterWaitHog::ClosePseudoHandle(): CloseHandle(m_ahEvents[%d]) failed with %d\n", 
			index,
            ::GetLastError()
			));
    }
    m_ahEvents[index] = NULL;
    //
    // we do not wait for the callback to be called.
    //
    return (0 != ::UnregisterWait(m_ahHogger[index]));
#else
    MessageBox(::GetFocus(), TEXT("DeleteTimerQueue() requires _WIN32_WINNT > 0x400"), TEXT("Hogger"), MB_OK);
    ::SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return false;
#endif
}


bool CPHRegisterWaitHog::PostClosePseudoHandle(DWORD /*index*/)
{
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phprinterhog.cpp ===
//
// this class is used for hogging Resources.
// it differs from simple hogging by dynamically
// hogging all Resources and then releasing some.
// the level of free Resources can be controlled.
//


//#define HOGGER_LOGGING

#include "PHPrinterHog.h"



CPHPrinterHog::CPHPrinterHog(
	const DWORD dwMaxFreeResources, 
	const DWORD dwSleepTimeAfterFullHog, 
	const DWORD dwSleepTimeAfterFreeingSome
	)
	:
	CPseudoHandleHog<HANDLE, NULL>(
        dwMaxFreeResources, 
        dwSleepTimeAfterFullHog, 
        dwSleepTimeAfterFreeingSome,
        false //named object
        )
{
    DWORD dwBytesRead = ::GetProfileString( TEXT("Windows"), TEXT("device"), TEXT(",,,"), m_PrinterName, MAX_PATH ) ;
    if(( m_pDevice = _tcstok( m_PrinterName, TEXT(","))) &&
       ( m_pDriver = _tcstok( NULL, TEXT(", "))) &&
       ( m_pOutput = _tcstok( NULL, TEXT(", ")))) 
    {
        //ok
    }
    else
    {
	    throw CException(TEXT("CPHPrinterHog::CPHPrinterHog(): could not find default printer settings. GetProfileString(Windows, device)\n"));
    }
    if ( (MAX_PATH - 1 == dwBytesRead) || (MAX_PATH - 2 == dwBytesRead) )
    {
	    throw CException(TEXT("Internal error - CPHPrinterHog::CPHPrinterHog(): GetProfileString(Windows, device) - buffer too small. MAX_PATH=%d, dwBytesRead=%d\n"), MAX_PATH, dwBytesRead);
    }
    if (6 > dwBytesRead)
    {
	    throw CException(TEXT("Internal error - CPHPrinterHog::CPHPrinterHog(): GetProfileString(Windows, device) - (6 > dwBytesRead(%d)).\n"), dwBytesRead);
    }
	HOGGERDPF((
		"CPHPrinterHog::CPHPrinterHog(): m_PrinterName=%s, m_pDevice=%s, m_pDriver=%s, m_pOutput=%s\n", 
		m_PrinterName,
        m_pDevice,
        m_pDriver,
        m_pOutput
		));

}

CPHPrinterHog::~CPHPrinterHog(void)
{
	HaltHoggingAndFreeAll();
}


HANDLE CPHPrinterHog::CreatePseudoHandle(DWORD /*index*/, TCHAR * /*szTempName*/)
{
    HANDLE hPrinter = NULL;

    if( !::OpenPrinter( m_PrinterName, &hPrinter, NULL ))
    {
        return NULL;
    }

    _ASSERTE_(NULL != hPrinter);

    return hPrinter;
}



bool CPHPrinterHog::ReleasePseudoHandle(DWORD /*index*/)
{
	return true;
}


bool CPHPrinterHog::ClosePseudoHandle(DWORD index)
{
    return (0 != ::ClosePrinter(m_ahHogger[index]));
}


bool CPHPrinterHog::PostClosePseudoHandle(DWORD /*index*/)
{
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phprocesshog.cpp ===
//
// this class is used for hogging Resources.
// it differs from simple hogging by dynamically
// hogging all Resources and then releasing some.
// the level of free Resources can be controlled.
//


//#define HOGGER_LOGGING

#include "PHProcessHog.h"




CPHProcessHog::CPHProcessHog(
	const DWORD dwMaxFreeResources, 
	const TCHAR * const szProcess, 
	const DWORD dwSleepTimeAfterFullHog, 
	const DWORD dwSleepTimeAfterFreeingSome,
    const bool fCreateSuspended
	)
	:
	CPseudoHandleHog<HANDLE, NULL>(
        dwMaxFreeResources, 
        dwSleepTimeAfterFullHog, 
        dwSleepTimeAfterFreeingSome,
        false //named object
        ),
    m_fCreateSuspended(fCreateSuspended)
{
	::lstrcpyn(m_szProcess, szProcess, sizeof(m_szProcess)/sizeof(*m_szProcess)-1);
	m_szProcess[sizeof(m_szProcess)/sizeof(*m_szProcess)-1] = TEXT('\0');

	for (int i = 0; i < HANDLE_ARRAY_SIZE; i++)
	{
		m_hMainThread[i] = NULL;
	}
}

CPHProcessHog::~CPHProcessHog(void)
{
	HaltHoggingAndFreeAll();
}


HANDLE CPHProcessHog::CreatePseudoHandle(DWORD index, TCHAR * /*szTempName*/)
{
	STARTUPINFO si;
    ::memset(&si, 0, sizeof(si));
	si.cb = sizeof(si);
	si.lpReserved = NULL; 
    si.lpDesktop = NULL;     
	si.lpTitle = NULL;     
	//DWORD   dwX;     
	//DWORD   dwY; 
    //DWORD   dwXSize;     
	//DWORD   dwYSize;     
	//DWORD   dwXCountChars; 
    //DWORD   dwYCountChars;     
	//DWORD   dwFillAttribute;     
	si.dwFlags = 0; 
    //WORD    wShowWindow;     
	si.cbReserved2 = 0;     
	si.lpReserved2 = NULL; 
    //HANDLE  hStdInput;     
	//HANDLE  hStdOutput;     
	//HANDLE  hStdError; 

	PROCESS_INFORMATION pi;
    //HANDLE hProcess;
    //HANDLE hThread;
    //DWORD dwProcessId;
    //DWORD dwThreadId;

	if (!::CreateProcess(  
			m_szProcess,// pointer to name of executable module
			NULL,  // pointer to command line string
			NULL,// pointer to process security attributes
			NULL,// pointer to thread security attributes
			false,  // handle inheritance flag
            m_fCreateSuspended ? CREATE_SUSPENDED : 0, // creation flags
			NULL,  // pointer to new environment block
			NULL, // pointer to current directory name
			&si,// pointer to STARTUPINFO
			&pi  // pointer to PROCESS_INFORMATION
			)
		)
	{
		HOGGERDPF(("CPHProcessHog::CreateProcess(%s): failed with %d.\n", m_szProcess, ::GetLastError()));
		//
		// check if there's a user error of not having the process image in the current directory
		//
		if (ERROR_FILE_NOT_FOUND == ::GetLastError())
		{
			TCHAR msg[1024];
			_stprintf(msg, TEXT("CreateProcess(%s) failed because it is not found. Make sure it is placed in the current directory"), m_szProcess);
			MessageBox(NULL, msg, TEXT("Hogger.exe"), MB_OK);
		}

		return NULL;
	}

	_ASSERTE_(NULL != pi.hProcess);
	_ASSERTE_(NULL != pi.hThread);
	m_hMainThread[index] = pi.hThread;
	return pi.hProcess;
}



bool CPHProcessHog::ReleasePseudoHandle(DWORD index)
{
    DWORD dwLastError = ERROR_SUCCESS;

    if (!m_fCreateSuspended)
    {
        //
        // no need to resume the process, just close the main thread handle
        //
	    if (!::CloseHandle(m_hMainThread[index]))
	    {
            HOGGERDPF(("CHandleHog::ReleasePseudoHandle(): CloseHandle(m_hMainThread[%d]) failed with %d.\n", index, ::GetLastError()));
	    }
	    m_hMainThread[index] = NULL;
        return true;
    }

    //
    // this should cause the exe to continue executing, or to finish in the case
    // of "nothing.exe"
    //
    if (!::ResumeThread(m_ahHogger[index]))
	{
		HOGGERDPF(("CPHProcessHog::ReleasePseudoHandle(): TerminateProcess(%d) failed with %d.\n", index, ::GetLastError()));
	}

	_ASSERTE_(NULL != m_hMainThread[index]);
	if (!::CloseHandle(m_hMainThread[index]))
	{
        //
        // we only care if this call fails, and not if later calls fail
        //
        dwLastError = ::GetLastError();
		HOGGERDPF(("CHandleHog::ReleasePseudoHandle(): CloseHandle(m_hMainThread[%d]) failed with %d.\n", index, dwLastError));
	}
	m_hMainThread[index] = NULL;

	//
	// wait for thread to exit, but only 1 milli, since we don't really care if it finishes,
    // because we will terminate the process later.
    // yet, i feel like giving the process a chance to finish on its own
	//
	DWORD dwWait = ::WaitForSingleObject(m_ahHogger[index], 1);
	if (WAIT_OBJECT_0 == dwWait) return true;

	if (WAIT_FAILED == dwWait)
	{
		HOGGERDPF(("CThreadHog::ReleasePseudoHandle(%d): WaitForSingleObject() failed with %d..\n", index, ::GetLastError()));
	}
	else if (WAIT_TIMEOUT == dwWait)
	{
        //
        // kind of expected, since system is under stress
        //
		//HOGGERDPF(("CThreadHog::ReleasePseudoHandle(%d): WaitForSingleObject() failed with WAIT_TIMEOUT.\n", index));
	}
	else
	{
        //
        // what other error?
        //
        dwLastError = ::GetLastError();
        HOGGERDPF(("CThreadHog::ReleasePseudoHandle(%d): WaitForSingleObject() returned 0x%08X, last error=%d.\n", index, dwWait, dwLastError));
		_ASSERTE_(FALSE);
	}

    if (ERROR_SUCCESS != dwLastError)
    {
        ::SetLastError(dwLastError);
        return false;
    }
    else
    {
	    return true;
    }
}


bool CPHProcessHog::ClosePseudoHandle(DWORD index)
{
    if (m_fCreateSuspended)
    {
        //
        // the process may be done, because we released the main thread in ReleasePseudoHandle()
        // but we want to be sure that we don't have orphaned processes, in case
        // the process is not "nothing.exe"
        //
	    if (!TerminateProcess(
			    m_ahHogger[index], // handle to the process
			    0   // exit code for the process
			    )
		    )
	    {
		    HOGGERDPF(("CProcessHog::ClosePseudoHandle(): TerminateProcess(%d) failed with %d.\n", index, ::GetLastError()));
	    }
    }

    return (0 != ::CloseHandle(m_ahHogger[index]));
}


bool CPHProcessHog::PostClosePseudoHandle(DWORD /*index*/)
{
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phprocesshog.h ===
#ifndef __PHPROCESS_HOG_H
#define __PHPROCESS_HOG_H

//
// this class is used for hogging a resource.
// it differs from simple hogging by dynamically
// hogging all resources and then releasing some.
// the level of free resources can be controlled.
//



#include "PseudoHandleHog.h"


class CPHProcessHog : public CPseudoHandleHog<HANDLE, NULL>
{
public:
	//
	// does not hog Resources yet.
	//
	CPHProcessHog(
		const DWORD dwMaxFreeResources, 
		const TCHAR * const szProcess = TEXT("nothing.exe"), 
		const DWORD dwSleepTimeAfterFullHog = 1000, 
		const DWORD dwSleepTimeAfterFreeingSome = 1000,
        const bool fCreateSuspended = true
		);
    ~CPHProcessHog(void);

protected:
	HANDLE CreatePseudoHandle(DWORD index, TCHAR *szTempName = 0);
	bool ReleasePseudoHandle(DWORD index);
	bool ClosePseudoHandle(DWORD index);
	bool PostClosePseudoHandle(DWORD index);
   	HANDLE m_hMainThread[HANDLE_ARRAY_SIZE];
	TCHAR m_szProcess[1024];
    bool m_fCreateSuspended;

};

#endif //__PHPROCESS_HOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phregisterwaithog.h ===
#ifndef __PHREGISTER_WAIT_HOG_H
#define __PHREGISTER_WAIT_HOG_H

//
// this class is used for hogging a resource.
// it differs from simple hogging by dynamically
// hogging all resources and then releasing some.
// the level of free resources can be controlled.
//



#include "PseudoHandleHog.h"



class CPHRegisterWaitHog : public CPseudoHandleHog<HANDLE, NULL>
{
public:
	//
	// does not hog Resources yet.
	//
	CPHRegisterWaitHog(
		const DWORD dwMaxFreeResources, 
		const DWORD dwSleepTimeAfterFullHog = 1000, 
		const DWORD dwSleepTimeAfterFreeingSome = 1000,
        const bool fNamedObject = false
		);
    ~CPHRegisterWaitHog(void);

    friend static void NTAPI CallBack(void* pVoid, BOOLEAN bTimeout);

protected:
	HANDLE CreatePseudoHandle(DWORD index, TCHAR *szTempName = 0);
	bool ReleasePseudoHandle(DWORD index);
	bool ClosePseudoHandle(DWORD index);
	bool PostClosePseudoHandle(DWORD index);

private:
//    HANDLE m_hEvent;
    HANDLE m_ahEvents[HANDLE_ARRAY_SIZE];
    DWORD m_dwCallCount;
};

#endif //__PHREGISTER_WAIT_HOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phsc_hhog.h ===
#ifndef __PHSC_H_HOG_H
#define __PHSC_H_HOG_H

//
// this class is used for hogging a resource.
// it differs from simple hogging by dynamically
// hogging all resources and then releasing some.
// the level of free resources can be controlled.
//



#include "PseudoHandleHog.h"

class CPHSC_HHog : public CPseudoHandleHog<SC_HANDLE, NULL>
{
public:
	//
	// does not hog Resources yet.
	//
	CPHSC_HHog(
		const DWORD dwMaxFreeResources, 
		const DWORD dwSleepTimeAfterFullHog = 1000, 
		const DWORD dwSleepTimeAfterFreeingSome = 1000
        );
    ~CPHSC_HHog(void);

protected:
	SC_HANDLE CreatePseudoHandle(DWORD index, TCHAR *szTempName = 0);
	bool ReleasePseudoHandle(DWORD index);
	bool ClosePseudoHandle(DWORD index);
	bool PostClosePseudoHandle(DWORD index);

};

#endif //__PHSC_H_HOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phremotethreadhog.cpp ===
//
// this class is used for hogging Resources.
// it differs from simple hogging by dynamically
// hogging all Resources and then releasing some.
// the level of free Resources can be controlled.
//


//#define HOGGER_LOGGING

#include "PHRemoteThreadHog.h"

/*
  code copied from Gil Shafriri
*/
const LPSECURITY_ATTRIBUTES PSA_DEFAULT_SECURITY_ATTRIBUTES     = 0;
const LPCTSTR               PSZ_NO_NAME                         = 0;
const BOOL                  F_OR_MULTIPLE_WAIT                  = FALSE;
const BOOL                  F_AND_MULTIPLE_WAIT                 = TRUE;
const BOOL                  F_PROCESS_DOES_NOT_INHERIT_HANDLES  = FALSE;
const BOOL                  F_PROCESS_INHERITS_HANDLES          = TRUE;
const LPVOID                P_USE_MY_ENVIRONMENT                = NULL;
const LPCTSTR               P_USE_MY_CURRENT_DIRECTORY          = NULL;
const DWORD     DW_IGNORED = 0;

static
bool
ReplaceByNonInheritableHandle (HANDLE *phSource)
{
    HANDLE  hCurrentProcess = OpenProcess (PROCESS_DUP_HANDLE,
                                           F_PROCESS_DOES_NOT_INHERIT_HANDLES,
                                         GetCurrentProcessId());
   
    HANDLE  hNonInheritable;
    if (
    
             (! DuplicateHandle (hCurrentProcess,
                                 *phSource,
                                 hCurrentProcess,
                                 &hNonInheritable,
                                 DW_IGNORED,
                                 F_PROCESS_INHERITS_HANDLES,
                                 DUPLICATE_SAME_ACCESS))
             ||
             (! CloseHandle (*phSource))
           )
     {

       HOGGERDPF(("ReplaceByNonInheritableHandle(): DuplicateHandle() failed with", GetLastError()));
     }
     *phSource = hNonInheritable;
     CloseHandle (hCurrentProcess);
   
     return true;
}
/*
  end of code copied from Gil Shafriri
*/

//
// the process that we will open threads in.
//
const TCHAR* CPHRemoteThreadHog::sm_szProcess = TEXT("RemoteThreadProcess.exe");


CPHRemoteThreadHog::CPHRemoteThreadHog(
	const DWORD dwMaxFreeResources, 
	const DWORD dwSleepTimeAfterFullHog, 
	const DWORD dwSleepTimeAfterFreeingSome,
    const bool fCreateSuspended
	)
	:
	CPseudoHandleHog<HANDLE, NULL>(
        dwMaxFreeResources, 
        dwSleepTimeAfterFullHog, 
        dwSleepTimeAfterFreeingSome,
        false //named object
        ),
    m_fCreateSuspended(fCreateSuspended)
{
    //
    // create the pipe, that will get the remote process stdout
    //
    HANDLE hReadPipe = NULL;
    HANDLE hWritePipe = NULL;

    SECURITY_ATTRIBUTES saPipe;
    saPipe.nLength              = sizeof( SECURITY_ATTRIBUTES ); 
    saPipe.lpSecurityDescriptor = NULL;     
    saPipe.bInheritHandle       = TRUE; 
    if (!CreatePipe(
            &hReadPipe,                       // pointer to read handle
            &hWritePipe,                      // pointer to write handle
            NULL,  // pointer to security attributes
            0                              // pipe size
            )
       )
    {
		throw CException(
			TEXT("CPHRemoteThreadHog(): CreatePipe() failed with %d"), 
			::GetLastError()
			);
    }

    if (!ReplaceByNonInheritableHandle(&hWritePipe))
    {
		throw CException(
			TEXT("CPHRemoteThreadHog(): ReplaceByNonInheritableHandle() failed with %d"), 
			::GetLastError()
			);
    }

    _ASSERTE_(NULL != hReadPipe);
    _ASSERTE_(NULL != hWritePipe);

    //
    // create the remote process
    //
    ::memset(&m_si, 0, sizeof(m_si));
	m_si.cb = sizeof(m_si);
	m_si.lpReserved = NULL; 
    m_si.lpDesktop = NULL;     
	m_si.lpTitle = NULL;     
	//DWORD   dwX;     
	//DWORD   dwY; 
    //DWORD   dwXSize;     
	//DWORD   dwYSize;     
	//DWORD   dwXCountChars; 
    //DWORD   dwYCountChars;     
	//DWORD   dwFillAttribute;     
	m_si.dwFlags = STARTF_USESTDHANDLES; 
    //WORD    wShowWindow;     
	m_si.cbReserved2 = 0;     
	m_si.lpReserved2 = NULL; 
    m_si.hStdInput = NULL;     
	m_si.hStdOutput = hWritePipe;     
	m_si.hStdError = hWritePipe; 

	//PROCESS_INFORMATION pi;
    //HANDLE hProcess;
    //HANDLE hThread;
    //DWORD dwProcessId;
    //DWORD dwThreadId;

	if (!::CreateProcess(  
			NULL,// pointer to name of executable module
			(TCHAR*)sm_szProcess,  // pointer to command line string
			NULL,// pointer to process security attributes
			NULL,// pointer to thread security attributes
			true,  // handle inheritance flag
			0, // creation flags
			NULL,  // pointer to new environment block
			NULL, // pointer to current directory name
			&m_si,// pointer to STARTUPINFO
			&m_pi  // pointer to PROCESS_INFORMATION
			)
		)
	{
        ::CloseHandle(hReadPipe);
        ::CloseHandle(hWritePipe);
		HOGGERDPF(("CPHemoteThreadHog, CreateProcess(%s): failed with %d.\n", sm_szProcess, ::GetLastError()));

		throw CException(
			TEXT("CPHRemoteThreadHog(): CreateProcess(%s) failed with %d"), 
			sm_szProcess,
            ::GetLastError()
			);
	}
	_ASSERTE_(NULL != m_pi.hProcess);
	_ASSERTE_(NULL != m_pi.hThread);

    //
    // get from the remote process, the address of the thread
    //
    char szRemoteThreadAddress[1024];
    memset(szRemoteThreadAddress, 0, sizeof(szRemoteThreadAddress));
    DWORD dwNumberOfBytesRead;
    if (!::ReadFile(
            hReadPipe,
            szRemoteThreadAddress,             // pointer to buffer that receives data
            8,  // number of bytes to read
            &dwNumberOfBytesRead, // pointer to number of bytes read
            NULL    // pointer to structure for data
            )
       )
    {
        if (!TerminateProcess(m_pi.hProcess, 0))
        {
		    HOGGERDPF(("CPHRemoteThreadHog::CPHRemoteThreadHog(): TerminateProcess(): failed with %d.\n", ::GetLastError()));
        }
        ::CloseHandle(hReadPipe);
        ::CloseHandle(hWritePipe);
		HOGGERDPF(("CPHemoteThreadHog, ReadFile(): failed with %d.\n", sm_szProcess, ::GetLastError()));

		throw CException(
			TEXT("CPHRemoteThreadHog(): ReadFile() failed with %d"), 
            ::GetLastError()
			);
    }

    m_pfnRemoteSuspendedThread = (REMOTE_THREAD_FUNCTION)atoi(szRemoteThreadAddress);

    ::CloseHandle(hReadPipe);
    ::CloseHandle(hWritePipe);
}

CPHRemoteThreadHog::~CPHRemoteThreadHog(void)
{
	HaltHoggingAndFreeAll();

    if (!TerminateProcess(m_pi.hProcess, 0))
    {
		HOGGERDPF(("CPHRemoteThreadHog::~CPHRemoteThreadHog(): TerminateProcess(): failed with %d.\n", ::GetLastError()));
    }

    ::CloseHandle(m_pi.hProcess);
    ::CloseHandle(m_pi.hThread);
}


HANDLE CPHRemoteThreadHog::CreatePseudoHandle(DWORD /*index*/, TCHAR * /*szTempName*/)
{
	DWORD dwThreadId;
	return 	::CreateRemoteThread(
        m_pi.hProcess, // handle to process to create thread in
		NULL, // pointer to thread security attributes
		64,      // initial thread stack size, in bytes
		m_pfnRemoteSuspendedThread,// pointer to thread function
		0,     // argument for new thread
        m_fCreateSuspended ? CREATE_SUSPENDED : 0,  // creation flags
		&dwThreadId      // pointer to returned thread identifier		
	);
}



bool CPHRemoteThreadHog::ReleasePseudoHandle(DWORD index)
{
    if (!m_fCreateSuspended)
    {
        return true;
    }

	//
	// try to make the thread exit by releasing it from suspend mode.
	// if fail, just try to terminate the thread
	//
	DWORD dwSuspendCount = 1;
	while (dwSuspendCount > 0)
	{
		dwSuspendCount = ::ResumeThread(m_ahHogger[index]);

		if (0xffffffff == dwSuspendCount)
		{
			HOGGERDPF(("CPHRemoteThreadHog::ReleaseHandle(): ResumeThread(%d) failed with %d. Terminating thread.\n", index, ::GetLastError()));
			if (!::TerminateThread(m_ahHogger[index], 0))
			{
				HOGGERDPF(("CPHRemoteThreadHog::ReleaseHandle(): TerminateThread(%d) failed with %d.\n", index, ::GetLastError()));
			}
			break;
		}

		if (dwSuspendCount > 1)
		{
			HOGGERDPF(("CPHRemoteThreadHog::ReleaseHandle(): ResumeThread(%d) returned %d instead 1.\n", index, dwSuspendCount));
		}
	}

	//
	// wait for thread to exit.
	// if does not exit, try to terminate it
	//
	DWORD dwWait = ::WaitForSingleObject(m_ahHogger[index], 60*1000);
	if (WAIT_OBJECT_0 == dwWait) return true;

	if (WAIT_FAILED == dwWait)
	{
		HOGGERDPF(("CPHRemoteThreadHog::ReleaseHandle(): WaitForSingleObject() failed with %d. Terminating thread %d.\n", ::GetLastError(), index));
	}
	else if (WAIT_TIMEOUT == dwWait)
	{
		HOGGERDPF(("CPHRemoteThreadHog::ReleaseHandle(): WaitForSingleObject() failed with WAIT_TIMEOUT. Terminating thread %d.\n", index));
	}
	else
	{
		_ASSERTE_(FALSE);
	}

	if (!::TerminateThread(m_ahHogger[index], 0))
	{
		HOGGERDPF(("CPHRemoteThreadHog::ReleaseHandle(): TerminateThread(%d) failed with %d.\n", index, ::GetLastError()));
    	return false;
	}

	return true;
}


bool CPHRemoteThreadHog::ClosePseudoHandle(DWORD index)
{
    return (0 != ::CloseHandle(m_ahHogger[index]));
}


bool CPHRemoteThreadHog::PostClosePseudoHandle(DWORD /*index*/)
{
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phrgstrevntsrchog.cpp ===
//
// this class is used for hogging Resources.
// it differs from simple hogging by dynamically
// hogging all Resources and then releasing some.
// the level of free Resources can be controlled.
//


//#define HOGGER_LOGGING

#include "PHRgstrEvntSrcHog.h"



CPHRegisterEventSourceHog::CPHRegisterEventSourceHog(
	const DWORD dwMaxFreeResources, 
	const DWORD dwSleepTimeAfterFullHog, 
	const DWORD dwSleepTimeAfterFreeingSome
	)
	:
	CPseudoHandleHog<HANDLE, NULL>(
        dwMaxFreeResources, 
        dwSleepTimeAfterFullHog, 
        dwSleepTimeAfterFreeingSome,
        false //fNamedObject
        )
{
	return;
}

CPHRegisterEventSourceHog::~CPHRegisterEventSourceHog(void)
{
	HaltHoggingAndFreeAll();
}


HANDLE CPHRegisterEventSourceHog::CreatePseudoHandle(DWORD index, TCHAR * /*szTempName*/)
{
	HOGGERDPF(("CPHRegisterEventSourceHog::CreatePseudoHandle(%d).\n", index));
	return 	::RegisterEventSource(
        NULL,  // server name for source
        TEXT("PHRgstrEvntSrcHog")   // source name for registered handle
        );
}



bool CPHRegisterEventSourceHog::ReleasePseudoHandle(DWORD /*index*/)
{
	return true;
}


bool CPHRegisterEventSourceHog::ClosePseudoHandle(DWORD index)
{
    return (0 != ::DeregisterEventSource(m_ahHogger[index]));
}


bool CPHRegisterEventSourceHog::PostClosePseudoHandle(DWORD /*index*/)
{
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phremotethreadhog.h ===
#ifndef __PHREMOTE_THREAD_HOG_H
#define __PHREMOTE_THREAD_HOG_H

//
// this class is used for hogging a resource.
// it differs from simple hogging by dynamically
// hogging all resources and then releasing some.
// the level of free resources can be controlled.
//



#include "PseudoHandleHog.h"

typedef DWORD (WINAPI *REMOTE_THREAD_FUNCTION)(void *pVoid);

class CPHRemoteThreadHog : public CPseudoHandleHog<HANDLE, NULL>
{
public:
	//
	// does not hog Resources yet.
	//
	CPHRemoteThreadHog(
		const DWORD dwMaxFreeResources, 
		const DWORD dwSleepTimeAfterFullHog = 1000, 
		const DWORD dwSleepTimeAfterFreeingSome = 1000,
        const bool fCreateSuspended = true
		);
    ~CPHRemoteThreadHog(void);

protected:
	HANDLE CreatePseudoHandle(DWORD index, TCHAR *szTempName = 0);
	bool ReleasePseudoHandle(DWORD index);
	bool ClosePseudoHandle(DWORD index);
	bool PostClosePseudoHandle(DWORD index);

private:
    static const TCHAR *sm_szProcess;
    REMOTE_THREAD_FUNCTION m_pfnRemoteSuspendedThread;
    STARTUPINFO m_si;
    PROCESS_INFORMATION m_pi;
    bool m_fCreateSuspended;
};

#endif //__PHREMOTE_THREAD_HOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phrgstrevntsrchog.h ===
#ifndef __PHREGISTEREVENTSOURCE_HOG_H
#define __PHREGISTEREVENTSOURCE_HOG_H

//
// this class is used for hogging a resource.
// it differs from simple hogging by dynamically
// hogging all resources and then releasing some.
// the level of free resources can be controlled.
//



#include "PseudoHandleHog.h"


class CPHRegisterEventSourceHog : public CPseudoHandleHog<HANDLE, NULL>
{
public:
	//
	// does not hog Resources yet.
	//
	CPHRegisterEventSourceHog(
		const DWORD dwMaxFreeResources, 
		const DWORD dwSleepTimeAfterFullHog = 1000, 
		const DWORD dwSleepTimeAfterFreeingSome = 1000
		);
    ~CPHRegisterEventSourceHog(void);

protected:
	HANDLE CreatePseudoHandle(DWORD index, TCHAR *szTempName = 0);
	bool ReleasePseudoHandle(DWORD index);
	bool ClosePseudoHandle(DWORD index);
	bool PostClosePseudoHandle(DWORD index);
};

#endif //__PHREGISTEREVENTSOURCE_HOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phsc_hhog.cpp ===
//
// this class is used for hogging Resources.
// it differs from simple hogging by dynamically
// hogging all Resources and then releasing some.
// the level of free Resources can be controlled.
//


//#define HOGGER_LOGGING

#include "PHSC_HHog.h"



CPHSC_HHog::CPHSC_HHog(
	const DWORD dwMaxFreeResources, 
	const DWORD dwSleepTimeAfterFullHog, 
	const DWORD dwSleepTimeAfterFreeingSome
	)
	:
	CPseudoHandleHog<SC_HANDLE, NULL>(
        dwMaxFreeResources, 
        dwSleepTimeAfterFullHog, 
        dwSleepTimeAfterFreeingSome, 
        true //named
        )
{
    return;
}

CPHSC_HHog::~CPHSC_HHog(void)
{
	HaltHoggingAndFreeAll();
}


SC_HANDLE CPHSC_HHog::CreatePseudoHandle(DWORD /*index*/, TCHAR * /*szTempName*/)
{
    return ::OpenSCManager(  
        NULL,  // pointer to machine name string
        SERVICES_ACTIVE_DATABASE,  // pointer to database name string
        SC_MANAGER_CONNECT   // type of access
        );
}



bool CPHSC_HHog::ReleasePseudoHandle(DWORD /*index*/)
{
	return true;
}


bool CPHSC_HHog::ClosePseudoHandle(DWORD index)
{
    return (0 != ::CloseServiceHandle(m_ahHogger[index]));
}


bool CPHSC_HHog::PostClosePseudoHandle(DWORD /*index*/)
{
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phsemaphorehog.cpp ===
//
// this class is used for hogging Resources.
// it differs from simple hogging by dynamically
// hogging all Resources and then releasing some.
// the level of free Resources can be controlled.
//


//#define HOGGER_LOGGING

#include "PHSemaphoreHog.h"



CPHSemaphoreHog::CPHSemaphoreHog(
	const DWORD dwMaxFreeResources, 
	const DWORD dwSleepTimeAfterFullHog, 
	const DWORD dwSleepTimeAfterFreeingSome,
    const bool fNamedObject
	)
	:
	CPseudoHandleHog<HANDLE, NULL>(
        dwMaxFreeResources, 
        dwSleepTimeAfterFullHog, 
        dwSleepTimeAfterFreeingSome,
        fNamedObject
        )
{
	return;
}

CPHSemaphoreHog::~CPHSemaphoreHog(void)
{
	HaltHoggingAndFreeAll();
}


HANDLE CPHSemaphoreHog::CreatePseudoHandle(DWORD /*index*/, TCHAR *szTempName)
{
	return 	::CreateSemaphore(
		NULL,// pointer to security attributes
		100,  // initial count  
		200,  // maximum count
		szTempName       // pointer to semaphore-object name
		);
}



bool CPHSemaphoreHog::ReleasePseudoHandle(DWORD /*index*/)
{
	return true;
}


bool CPHSemaphoreHog::ClosePseudoHandle(DWORD index)
{
    return (0 != ::CloseHandle(m_ahHogger[index]));
}


bool CPHSemaphoreHog::PostClosePseudoHandle(DWORD /*index*/)
{
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phsemaphorehog.h ===
#ifndef __PHSEMAPHORE_HOG_H
#define __PHSEMAPHORE_HOG_H

//
// this class is used for hogging a resource.
// it differs from simple hogging by dynamically
// hogging all resources and then releasing some.
// the level of free resources can be controlled.
//



#include "PseudoHandleHog.h"


class CPHSemaphoreHog : public CPseudoHandleHog<HANDLE, NULL>
{
public:
	//
	// does not hog Resources yet.
	//
	CPHSemaphoreHog(
		const DWORD dwMaxFreeResources, 
		const DWORD dwSleepTimeAfterFullHog = 1000, 
		const DWORD dwSleepTimeAfterFreeingSome = 1000,
        const bool fNamedObject = false
		);
    ~CPHSemaphoreHog(void);

protected:
	HANDLE CreatePseudoHandle(DWORD index, TCHAR *szTempName = 0);
	bool ReleasePseudoHandle(DWORD index);
	bool ClosePseudoHandle(DWORD index);
	bool PostClosePseudoHandle(DWORD index);
};

#endif //__PHSEMAPHORE_HOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phtimerhog.h ===
#ifndef __PHTIMER_HOG_H
#define __PHTIMER_HOG_H

//
// this class is used for hogging a resource.
// it differs from simple hogging by dynamically
// hogging all resources and then releasing some.
// the level of free resources can be controlled.
//



#include "PseudoHandleHog.h"


class CPHTimerHog : public CPseudoHandleHog<HANDLE, NULL>
{
public:
	//
	// does not hog Resources yet.
	//
	CPHTimerHog(
		const DWORD dwMaxFreeResources, 
		const DWORD dwSleepTimeAfterFullHog = 1000, 
		const DWORD dwSleepTimeAfterFreeingSome = 1000,
        const bool fNamedObject = false
		);
    ~CPHTimerHog(void);

protected:
	HANDLE CreatePseudoHandle(DWORD index, TCHAR *szTempName = 0);
	bool ReleasePseudoHandle(DWORD index);
	bool ClosePseudoHandle(DWORD index);
	bool PostClosePseudoHandle(DWORD index);
};

#endif //__PHTIMER_HOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phthreadhog.h ===
#ifndef __PHTHREAD_HOG_H
#define __PHTHREAD_HOG_H

//
// this class is used for hogging a resource.
// it differs from simple hogging by dynamically
// hogging all resources and then releasing some.
// the level of free resources can be controlled.
//



#include "PseudoHandleHog.h"


class CPHThreadHog : public CPseudoHandleHog<HANDLE, NULL>
{
public:
	//
	// does not hog Resources yet.
	//
	CPHThreadHog(
		const DWORD dwMaxFreeResources, 
		const DWORD dwSleepTimeAfterFullHog = 1000, 
		const DWORD dwSleepTimeAfterFreeingSome = 1000,
        const bool fCreateSuspended = true
		);
    ~CPHThreadHog(void);

protected:
	HANDLE CreatePseudoHandle(DWORD index, TCHAR *szTempName = 0);
	bool ReleasePseudoHandle(DWORD index);
	bool ClosePseudoHandle(DWORD index);
	bool PostClosePseudoHandle(DWORD index);

private:
    bool m_fCreateSuspended;
};

#endif //__PHTHREAD_HOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phtimerhog.cpp ===
//
// this class is used for hogging Resources.
// it differs from simple hogging by dynamically
// hogging all Resources and then releasing some.
// the level of free Resources can be controlled.
//


//#define HOGGER_LOGGING

#include "PHTimerHog.h"



CPHTimerHog::CPHTimerHog(
	const DWORD dwMaxFreeResources, 
	const DWORD dwSleepTimeAfterFullHog, 
	const DWORD dwSleepTimeAfterFreeingSome,
    const bool fNamedObject
	)
	:
	CPseudoHandleHog<HANDLE, NULL>(
        dwMaxFreeResources, 
        dwSleepTimeAfterFullHog, 
        dwSleepTimeAfterFreeingSome,
        fNamedObject
        )
{
	return;
}

CPHTimerHog::~CPHTimerHog(void)
{
	HaltHoggingAndFreeAll();
}


HANDLE CPHTimerHog::CreatePseudoHandle(DWORD /*index*/, TCHAR *szTempName)
{
	return 	::CreateWaitableTimer(
		NULL,  // pointer to security attributes
		false,  // flag for manual reset state
		szTempName // pointer to timer-object name 
		);
}



bool CPHTimerHog::ReleasePseudoHandle(DWORD /*index*/)
{
	return true;
}


bool CPHTimerHog::ClosePseudoHandle(DWORD index)
{
    return (0 != ::CloseHandle(m_ahHogger[index]));
}


bool CPHTimerHog::PostClosePseudoHandle(DWORD /*index*/)
{
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phthreadhog.cpp ===
//
// this class is used for hogging Resources.
// it differs from simple hogging by dynamically
// hogging all Resources and then releasing some.
// the level of free Resources can be controlled.
//


//#define HOGGER_LOGGING

#include "PHThreadHog.h"


//
// dummy thread to hog.
// it should be created as suspended, so resuming it should make it end.
//
static DWORD WINAPI SuspendedThread(LPVOID pVoid)
{
    DWORD dwToSleep = (DWORD)pVoid;
    if (0 != dwToSleep) ::Sleep(dwToSleep);
	return 0;
}



CPHThreadHog::CPHThreadHog(
	const DWORD dwMaxFreeResources, 
	const DWORD dwSleepTimeAfterFullHog, 
	const DWORD dwSleepTimeAfterFreeingSome,
    const bool fCreateSuspended
	)
	:
	CPseudoHandleHog<HANDLE, NULL>(
        dwMaxFreeResources, 
        dwSleepTimeAfterFullHog, 
        dwSleepTimeAfterFreeingSome,
        false //named object
        ),
    m_fCreateSuspended(fCreateSuspended)
{
	return;
}

CPHThreadHog::~CPHThreadHog(void)
{
	HaltHoggingAndFreeAll();
}


HANDLE CPHThreadHog::CreatePseudoHandle(DWORD /*index*/, TCHAR * /*szTempName*/)
{
	DWORD dwThreadId;

	return 	::CreateThread(
		NULL, // pointer to thread security attributes
		64,      // initial thread stack size, in bytes
		SuspendedThread,// pointer to thread function
        m_fCreateSuspended ? 0 : (void*)(rand()%3000),     // argument for new thread
        m_fCreateSuspended ? CREATE_SUSPENDED : 0,  // creation flags
		&dwThreadId      // pointer to returned thread identifier		
	);
}



bool CPHThreadHog::ReleasePseudoHandle(DWORD index)
{
    if (!m_fCreateSuspended)
    {
        return true;
    }

	//
	// try to make the thread exit by releasing it from suspend mode.
	// if fail, just try to terminate the thread
	//
	DWORD dwSuspendCount = 1;
	while (dwSuspendCount > 0)
	{
		dwSuspendCount = ::ResumeThread(m_ahHogger[index]);

		if (0xffffffff == dwSuspendCount)
		{
			HOGGERDPF(("CPHThreadHog::ReleaseHandle(): ResumeThread(%d) failed with %d. Terminating thread.\n", index, ::GetLastError()));
			if (!::TerminateThread(m_ahHogger[index], 0))
			{
				HOGGERDPF(("CPHThreadHog::ReleaseHandle(): TerminateThread(%d) failed with %d.\n", index, ::GetLastError()));
			}
			break;
		}

		if (dwSuspendCount > 1)
		{
			HOGGERDPF(("CPHThreadHog::ReleaseHandle(): ResumeThread(%d) returned %d instead 1.\n", index, dwSuspendCount));
		}
	}

	//
	// wait for thread to exit.
	// if does not exit, try to terminate it
	//
	DWORD dwWait = ::WaitForSingleObject(m_ahHogger[index], 60*1000);
	if (WAIT_OBJECT_0 == dwWait) return true;

	if (WAIT_FAILED == dwWait)
	{
		HOGGERDPF(("CPHThreadHog::ReleaseHandle(): WaitForSingleObject() failed with %d. Terminating thread %d.\n", ::GetLastError(), index));
	}
	else if (WAIT_TIMEOUT == dwWait)
	{
		HOGGERDPF(("CPHThreadHog::ReleaseHandle(): WaitForSingleObject() failed with WAIT_TIMEOUT. Terminating thread %d.\n", index));
	}
	else
	{
		_ASSERTE_(FALSE);
	}

	if (!::TerminateThread(m_ahHogger[index], 0))
	{
		HOGGERDPF(("CPHThreadHog::ReleaseHandle(): TerminateThread(%d) failed with %d.\n", index, ::GetLastError()));
	}

	return false;
}


bool CPHThreadHog::ClosePseudoHandle(DWORD index)
{
    return (0 != ::CloseHandle(m_ahHogger[index]));
}


bool CPHThreadHog::PostClosePseudoHandle(DWORD /*index*/)
{
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phservicehog.h ===
#ifndef __PHSERVICE_HOG_H
#define __PHSERVICE_HOG_H

//
// this class is used for hogging a resource.
// it differs from simple hogging by dynamically
// hogging all resources and then releasing some.
// the level of free resources can be controlled.
//



#include "PseudoHandleHog.h"

class CPHServiceHog : public CPseudoHandleHog<SC_HANDLE, NULL>
{
public:
	//
	// does not hog Resources yet.
	//
	CPHServiceHog(
		const DWORD dwMaxFreeResources, 
		const DWORD dwSleepTimeAfterFullHog = 1000, 
		const DWORD dwSleepTimeAfterFreeingSome = 1000,
        const TCHAR * const szBinaryFullName = TEXT("D:\\comet\\src\\fax\\faxtest\\src\\common\\hogger\\RemoteThreadProcess\\Debug\\RemoteThreadProcess.exe")
		);
    ~CPHServiceHog(void);

protected:
	SC_HANDLE CreatePseudoHandle(DWORD index, TCHAR *szTempName = 0);
	bool ReleasePseudoHandle(DWORD index);
	bool ClosePseudoHandle(DWORD index);
	bool PostClosePseudoHandle(DWORD index);

private:
    SC_HANDLE m_hSCManager;
    TCHAR m_szBinaryFullName[1024];
};

#endif //__PHSERVICE_HOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phtimerqueuehog.cpp ===
//
// this class is used for hogging Resources.
// it differs from simple hogging by dynamically
// hogging all Resources and then releasing some.
// the level of free Resources can be controlled.
//


//#define HOGGER_LOGGING

#include "PHTimerQueueHog.h"



CPHTimerQueueHog::CPHTimerQueueHog(
	const DWORD dwMaxFreeResources, 
	const DWORD dwSleepTimeAfterFullHog, 
	const DWORD dwSleepTimeAfterFreeingSome,
    const bool fNamedObject
	)
	:
	CPseudoHandleHog<HANDLE, NULL>(
        dwMaxFreeResources, 
        dwSleepTimeAfterFullHog, 
        dwSleepTimeAfterFreeingSome,
        fNamedObject
        )
{
	return;
}

CPHTimerQueueHog::~CPHTimerQueueHog(void)
{
	HaltHoggingAndFreeAll();
}


HANDLE CPHTimerQueueHog::CreatePseudoHandle(DWORD /*index*/, TCHAR * /*szTempName*/)
{
#if _WIN32_WINNT > 0x400
	return ::CreateTimerQueue();
#else
    MessageBox(::GetFocus(), TEXT("CreateTimerQueue() requires _WIN32_WINNT > 0x400"), TEXT("Hogger"), MB_OK);
    ::SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return NULL;
#endif
}



bool CPHTimerQueueHog::ReleasePseudoHandle(DWORD /*index*/)
{
	return true;
}


bool CPHTimerQueueHog::ClosePseudoHandle(DWORD index)
{
#if _WIN32_WINNT > 0x400
    return (0 != ::DeleteTimerQueue(m_ahHogger[index]));
#else
    MessageBox(::GetFocus(), TEXT("DeleteTimerQueue() requires _WIN32_WINNT > 0x400"), TEXT("Hogger"), MB_OK);
    index;
    ::SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return false;
#endif
}


bool CPHTimerQueueHog::PostClosePseudoHandle(DWORD /*index*/)
{
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phservicehog.cpp ===
//
// this class is used for hogging Resources.
// it differs from simple hogging by dynamically
// hogging all Resources and then releasing some.
// the level of free Resources can be controlled.
//


//#define HOGGER_LOGGING

#include "PHServiceHog.h"



CPHServiceHog::CPHServiceHog(
	const DWORD dwMaxFreeResources, 
	const DWORD dwSleepTimeAfterFullHog, 
	const DWORD dwSleepTimeAfterFreeingSome,
    const TCHAR * const szBinaryFullName
	)
	:
	CPseudoHandleHog<SC_HANDLE, NULL>(
        dwMaxFreeResources, 
        dwSleepTimeAfterFullHog, 
        dwSleepTimeAfterFreeingSome, 
        true //named
        ),
    m_hSCManager(NULL)
{
    m_hSCManager = ::OpenSCManager(  
        NULL,  // pointer to machine name string
        SERVICES_ACTIVE_DATABASE,  // pointer to database name string
        SC_MANAGER_CREATE_SERVICE | GENERIC_EXECUTE   // type of access
        );
    if (NULL == m_hSCManager)
    {
		throw CException(
			TEXT("CPHServiceHog::CPHServiceHog(): OpenSCManager(SERVICES_ACTIVE_DATABASE) failed with %d"), 
			::GetLastError()
			);
    }

    ::lstrcpyn(m_szBinaryFullName, szBinaryFullName, sizeof(m_szBinaryFullName)/sizeof(*m_szBinaryFullName)-1);
    m_szBinaryFullName[sizeof(m_szBinaryFullName)/sizeof(*m_szBinaryFullName)-1] = TEXT('\0');
}

CPHServiceHog::~CPHServiceHog(void)
{
	HaltHoggingAndFreeAll();
    if (!CloseServiceHandle(m_hSCManager))
    {
        HOGGERDPF(("CPHServiceHog::~CPHServiceHog() CloseServiceHandle() failed with %d.\n", ::GetLastError()));
    }
}


SC_HANDLE CPHServiceHog::CreatePseudoHandle(DWORD /*index*/, TCHAR *szTempName)
{
    TCHAR szServiceName[256];
    TCHAR szDisplayName[256];
    ::_sntprintf(szServiceName, sizeof(szServiceName)/sizeof(*szServiceName)-1, TEXT("HoggerServiceName%s"), szTempName);
    szServiceName[sizeof(szServiceName)/sizeof(*szServiceName)-1] = TEXT('\0');
    ::_sntprintf(szDisplayName, sizeof(szDisplayName)/sizeof(*szDisplayName)-1, TEXT("HoggerDisplayName%s"), szTempName);
    szDisplayName[sizeof(szDisplayName)/sizeof(*szDisplayName)-1] = TEXT('\0');

    return ::CreateService(
        m_hSCManager,  // handle to service control manager database
        szServiceName, // pointer to name of service to start
        szDisplayName, // pointer to display name
        SERVICE_ALL_ACCESS, // type of access to service
        SERVICE_WIN32_OWN_PROCESS | SERVICE_INTERACTIVE_PROCESS ,   // type of service
        SERVICE_DEMAND_START,     // when to start service
        SERVICE_ERROR_IGNORE,  // severity if service fails to start
        TEXT("D:\\comet\\src\\fax\\faxtest\\src\\common\\hogger\\RemoteThreadProcess\\Debug\\RemoteThreadProcess.exe"),  // pointer to name of binary file
        NULL,  // pointer to name of load ordering group
        NULL,     // pointer to variable to get tag identifier
        NULL,  // pointer to array of dependency names
        NULL, // runs as a local system account
        NULL       // pointer to password for service account
        );

}



bool CPHServiceHog::ReleasePseudoHandle(DWORD /*index*/)
{
	return true;
}


bool CPHServiceHog::ClosePseudoHandle(DWORD index)
{
    return (0 != ::DeleteService(m_ahHogger[index]));
}


bool CPHServiceHog::PostClosePseudoHandle(DWORD /*index*/)
{
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phtimerqueuehog.h ===
#ifndef __PHTIMER_QUEUE_HOG_H
#define __PHTIMER_QUEUE_HOG_H

//
// this class is used for hogging a resource.
// it differs from simple hogging by dynamically
// hogging all resources and then releasing some.
// the level of free resources can be controlled.
//



#include "PseudoHandleHog.h"



class CPHTimerQueueHog : public CPseudoHandleHog<HANDLE, NULL>
{
public:
	//
	// does not hog Resources yet.
	//
	CPHTimerQueueHog(
		const DWORD dwMaxFreeResources, 
		const DWORD dwSleepTimeAfterFullHog = 1000, 
		const DWORD dwSleepTimeAfterFreeingSome = 1000,
        const bool fNamedObject = false
		);
    ~CPHTimerQueueHog(void);

protected:
	HANDLE CreatePseudoHandle(DWORD index, TCHAR *szTempName = 0);
	bool ReleasePseudoHandle(DWORD index);
	bool ClosePseudoHandle(DWORD index);
	bool PostClosePseudoHandle(DWORD index);
};

#endif //__PHTIMER_QUEUE_HOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phwindowhog.h ===
#ifndef __PHWINDOW_HOG_H
#define __PHWINDOW_HOG_H

//
// this class is used for hogging a resource.
// it differs from simple hogging by dynamically
// hogging all resources and then releasing some.
// the level of free resources can be controlled.
//



#include "PseudoHandleHog.h"

class CPHWindowHog : public CPseudoHandleHog<HWND, NULL>
{
public:
	//
	// does not hog Resources yet.
	//
	CPHWindowHog(
		const DWORD dwMaxFreeResources, 
		const DWORD dwSleepTimeAfterFullHog = 1000, 
		const DWORD dwSleepTimeAfterFreeingSome = 1000,
        const bool fShowWindows = true
		);
    ~CPHWindowHog(void);

protected:
	HWND CreatePseudoHandle(DWORD index, TCHAR *szTempName = 0);
	bool ReleasePseudoHandle(DWORD index);
	bool ClosePseudoHandle(DWORD index);
	bool PostClosePseudoHandle(DWORD index);

private:
    bool m_fShowWindows;
};

#endif //__PHWINDOW_HOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phwinstationhog.h ===
#ifndef __PHWIN_STATION_HOG_H
#define __PHWIN_STATION_HOG_H

//
// this class is used for hogging a resource.
// it differs from simple hogging by dynamically
// hogging all resources and then releasing some.
// the level of free resources can be controlled.
//



#include "PseudoHandleHog.h"

class CPHWinStationHog : public CPseudoHandleHog<HWINSTA, NULL>
{
public:
	//
	// does not hog Resources yet.
	//
	CPHWinStationHog(
		const DWORD dwMaxFreeResources, 
		const DWORD dwSleepTimeAfterFullHog = 1000, 
		const DWORD dwSleepTimeAfterFreeingSome = 1000
		);
    ~CPHWinStationHog(void);

    static DWORD GetRandomDesiredAccess(void);

protected:
	HWINSTA CreatePseudoHandle(DWORD index, TCHAR *szTempName = 0);
	bool ReleasePseudoHandle(DWORD index);
	bool ClosePseudoHandle(DWORD index);
	bool PostClosePseudoHandle(DWORD index);

};

#endif //__PHWIN_STATION_HOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phwsasockethog.h ===
#ifndef __PHWSASOCKET_HOG_H
#define __PHWSASOCKET_HOG_H

//
// this class is used for hogging a resource.
// it differs from simple hogging by dynamically
// hogging all resources and then releasing some.
// the level of free resources can be controlled.
//



#include "PseudoHandleHog.h"


class CPHWSASocketHog : public CPseudoHandleHog<SOCKET, INVALID_SOCKET>
{
public:
	//
	// does not hog Resources yet.
	//
	CPHWSASocketHog(
		const DWORD dwMaxFreeResources, 
        const bool fTCP,
        const bool fBind,
        const bool fListen,
		const DWORD dwSleepTimeAfterFullHog = 1000, 
		const DWORD dwSleepTimeAfterFreeingSome = 1000
		);
    ~CPHWSASocketHog(void);

protected:
	SOCKET CreatePseudoHandle(DWORD index, TCHAR *szTempName = 0);
	bool ReleasePseudoHandle(DWORD index);
	bool ClosePseudoHandle(DWORD index);
	bool PostClosePseudoHandle(DWORD index);

private:
    bool m_fTCP;
    bool m_fBind;
    bool m_fListen;
    static int sm_nWSAStartedCount;
    DWORD m_dwOccupiedAddresses;
    DWORD m_adwOccupiedAddressIndex[HANDLE_ARRAY_SIZE];
    bool m_fOccupiedAddress[0xFFFF];
    bool m_fNoMoreBuffs;
};

#endif //__PHWSASOCKET_HOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phwindowhog.cpp ===
//
// this class is used for hogging Resources.
// it differs from simple hogging by dynamically
// hogging all Resources and then releasing some.
// the level of free Resources can be controlled.
//


//#define HOGGER_LOGGING

#include "PHWindowHog.h"


#define CLASS_NAME TEXT("{5CFD4FE0-9684-11d2-B8B6-mickys-hogger}")


static LRESULT CALLBACK MainWndProc(
    HWND hWnd,
    UINT msg, 
    WPARAM wParam,
    LPARAM lParam 
    )
{
	return( DefWindowProc( hWnd, msg, wParam, lParam ));
}


CPHWindowHog::CPHWindowHog(
	const DWORD dwMaxFreeResources, 
	const DWORD dwSleepTimeAfterFullHog, 
	const DWORD dwSleepTimeAfterFreeingSome,
    const bool fShowWindows
	)
	:
	CPseudoHandleHog<HWND, NULL>(
        dwMaxFreeResources, 
        dwSleepTimeAfterFullHog, 
        dwSleepTimeAfterFreeingSome, 
        false //named
        ),
    m_fShowWindows(fShowWindows)
{
	//
	// register class
	//
	WNDCLASS wc;
	wc.lpszClassName = CLASS_NAME;
	wc.lpfnWndProc = MainWndProc;
	wc.style = CS_OWNDC | CS_VREDRAW | CS_HREDRAW;
	wc.hInstance = NULL;
	wc.hIcon = NULL,//::LoadIcon( NULL, IDI_APPLICATION );
	wc.hCursor = NULL,//::LoadCursor( NULL, IDC_ARROW );
	wc.hbrBackground = (HBRUSH)( COLOR_WINDOW+1 );
	wc.lpszMenuName = TEXT("hoggerAppMenu");
	wc.cbClsExtra = 0;
	wc.cbWndExtra = 0;
	if (!RegisterClass( &wc ))
	{
		throw CException(
			TEXT("CPHWindowHog::CPHWindowHog(): RegisterClass(%s) failed with %d"), 
			CLASS_NAME,
			::GetLastError()
			);
	}

}

CPHWindowHog::~CPHWindowHog(void)
{
	HaltHoggingAndFreeAll();
}


HWND CPHWindowHog::CreatePseudoHandle(DWORD /*index*/, TCHAR * /*szTempName*/)
{
	HWND hWnd;

    hWnd = ::CreateWindow( 
		CLASS_NAME,
		TEXT("window hogger"),
		WS_CAPTION | WS_SYSMENU, //WS_OVERLAPPEDWINDOW|WS_HSCROLL|WS_VSCROLL,
		0,
		0,
		150,//CW_USEDEFAULT,
		0,//CW_USEDEFAULT,
		NULL,
		NULL,
		NULL, //hInstance,
		NULL
		);
	if (NULL == hWnd)
	{
		HOGGERDPF(("CPHWindowHog::CreatePseudoHandle(): CreateWindow() failed with %d.\n", ::GetLastError()));
		return NULL;
	}

    if (m_fShowWindows) ::ShowWindow( hWnd, SW_SHOW );

	return hWnd;
}



bool CPHWindowHog::ReleasePseudoHandle(DWORD /*index*/)
{
	return true;
}


bool CPHWindowHog::ClosePseudoHandle(DWORD index)
{
    return (0 != ::DestroyWindow(m_ahHogger[index]));
}


bool CPHWindowHog::PostClosePseudoHandle(DWORD /*index*/)
{
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\postcomppackhog.h ===
#ifndef __POST_COMPLETION_PACKET_HOG_H
#define __POST_COMPLETION_PACKET_HOG_H

//
// this class is used for hogging a resource.
// it differs from simple hogging by dynamically
// hogging all resources and then releasing some.
// the level of free resources can be controlled.
//


#include "hogger.h"

class CPostCompletionPacketHog : public CHogger
{
public:
	//
	// does not hog Resources yet.
	//
	CPostCompletionPacketHog(
		const DWORD dwComplementOfHogCycleIterations, 
		const DWORD dwSleepTimeAfterFullHog = 1000, 
		const DWORD dwSleepTimeAfterReleasing = 1000
		);

	~CPostCompletionPacketHog(void);

protected:
	virtual void FreeAll(void);

	virtual bool HogAll(void);
	virtual bool FreeSome(void);

private:
    DWORD m_dwPostedMessages;
    HANDLE m_hCompletionPort;
};

#endif //__POST_COMPLETION_PACKET_HOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phwsasockethog.cpp ===
//
// this class is used for hogging Resources.
// it differs from simple hogging by dynamically
// hogging all Resources and then releasing some.
// the level of free Resources can be controlled.
//

//#define HOGGER_LOGGING

#define MAX_PORT_NUM (0xFFFF)
//
// must be defined 1st to override winsock1
//
#include <winsock2.h>


//
// defines for WSASocet() params
//
#define PROTO_TYPE_UNICAST          0 
#define PROTO_TYPE_MCAST            1 
#define PROTOCOL_ID(Type, VendorMajor, VendorMinor, Id) (((Type)<<28)|((VendorMajor)<<24)|((VendorMinor)<<16)|(Id)) 

#include "PHWSASocketHog.h"

//
// LPWSAOVERLAPPED_COMPLETION_ROUTINE 
// we do not use it, but we need it defined for the overlapped UDP ::WSARecvFrom()
//
static void __stdcall fn(
    DWORD dwError,
    DWORD cbTransferred,
    LPWSAOVERLAPPED lpOverlapped,
    DWORD dwFlags
    )                                             
{
    UNREFERENCED_PARAMETER(dwError);
    UNREFERENCED_PARAMETER(cbTransferred);
    UNREFERENCED_PARAMETER(lpOverlapped);
    UNREFERENCED_PARAMETER(dwFlags);
    return;
}

//
// actually an object counter, used to initialize / uninitialize WSA only as needed
//
int CPHWSASocketHog::sm_nWSAStartedCount = 0;


CPHWSASocketHog::CPHWSASocketHog(
	const DWORD dwMaxFreeResources, 
    const bool fTCP,
    const bool fBind,
    const bool fListen,
	const DWORD dwSleepTimeAfterFullHog, 
	const DWORD dwSleepTimeAfterFreeingSome
	)
	:
	CPseudoHandleHog<SOCKET, INVALID_SOCKET>(
        dwMaxFreeResources, 
        dwSleepTimeAfterFullHog, 
        dwSleepTimeAfterFreeingSome,
        false //named object
        ),
    m_fTCP(fTCP),
    m_fBind(fBind),
    m_fListen(fListen),
    m_dwOccupiedAddresses(0),
    m_fNoMoreBuffs(false)
{
    //
    // force m_fListen not to conflict with m_fBind
    //
    _ASSERTE_(!(!m_fBind && m_fListen));
    if (!m_fBind) m_fListen = false;

    //
    // call ::WSAStartup() only for 1st object
    //
    if (0 == sm_nWSAStartedCount)
    {
        WSADATA wsaData;
        if (0 != ::WSAStartup (MAKEWORD( 2, 2 ), &wsaData))
        {
	        throw CException(TEXT("CPHWSASocketHog::CPHWSASocketHog(): WSAStartup() failed with %d.\n"), ::WSAGetLastError());
        }
    }
    sm_nWSAStartedCount++;

    //
    // initialize cache of occupied addresses
    //
    for (DWORD i = 0; i < sizeof(m_fOccupiedAddress)/sizeof(m_fOccupiedAddress[0]);  i++)
    {
        m_fOccupiedAddress[i] = false;
    }
    for (i = 0; i < sizeof(m_adwOccupiedAddressIndex)/sizeof(m_adwOccupiedAddressIndex[0]);  i++)
    {
        m_adwOccupiedAddressIndex[i] = sizeof(m_fOccupiedAddress)/sizeof(m_fOccupiedAddress[0]) - 1;
    }
}

CPHWSASocketHog::~CPHWSASocketHog(void)
{
	HaltHoggingAndFreeAll();

    //
    // call ::WSACleanup() only for last object
    //
    sm_nWSAStartedCount--;
    if (0 == sm_nWSAStartedCount)
    {
        if (0 != ::WSACleanup())
        {
	        HOGGERDPF(("CWSASocketHog::CWSASocketHog(): WSACleanup() failed with %d.\n", ::WSAGetLastError()));
        }
    }
}


SOCKET CPHWSASocketHog::CreatePseudoHandle(DWORD index, TCHAR * /*szTempName*/)
{
    //
    // create the socket
    //
    SOCKET s = ::WSASocket(
        AF_INET,    
        m_fTCP ? SOCK_STREAM : SOCK_DGRAM,    
        m_fTCP ? IPPROTO_TCP: IPPROTO_UDP,   
        NULL, 
        0,
        WSA_FLAG_OVERLAPPED
        );
    if (INVALID_SOCKET == s)
    {
        ::SetLastError(::WSAGetLastError());
        return INVALID_SOCKET;
    }

    //
    // created the socket.
    // if no need to bind, return with the socket
    //
    if (!m_fBind) return s;

    //
    // optimization: if we know that last ::bind() failed failed with WSAENOBUFS, there's no need to retry
    //
    if (m_fNoMoreBuffs) return s;

    //
    // optimization: if we know that there are no free addresses, no need to bind
    //
    if (MAX_PORT_NUM <= m_dwOccupiedAddresses)
    {
        //
        // no chance to bind
        //
        //HOGGERDPF(("CWSASocketHog::CreatePseudoHandle(%d): 0xFFFF == m_dwOccupiedAddresses.\n", index));
        return s;
    }

    //
    // try to bind, do not care if I fail
    //
    SOCKADDR_IN     sinSockAddr;     
    sinSockAddr.sin_family      = AF_INET; 
    //sinSockAddr.sin_addr.s_addr = 0; 
    sinSockAddr.sin_port        = 0;
    
    bool fBound = false;
    for (WORD wAddress = 0; wAddress < MAX_PORT_NUM; wAddress++)
    {
        if (m_fOccupiedAddress[wAddress]) continue;

        sinSockAddr.sin_addr.s_addr = wAddress; 

        if (::bind(
                s, 
                (const struct sockaddr FAR*)&sinSockAddr, 
                sizeof(SOCKADDR_IN)
                ) == SOCKET_ERROR
           )
        { 
            if (WSAENOBUFS == ::WSAGetLastError())
            {
                //
                // this is expected when hogging.
                // this means that there's no need to keep trying to bind
                //
                m_fNoMoreBuffs = true;
                return s;
            }

            //
            // the address was already occupied
            //
            m_dwOccupiedAddresses++;
            m_fOccupiedAddress[wAddress] = true;
            HOGGERDPF(("CWSASocketHog::CreatePseudoHandle(%d): bind(%d) failed with %d, m_dwOccupiedAddresses=%d.\n", index, wAddress, ::WSAGetLastError(), m_dwOccupiedAddresses));
        }
        else
        {
            //
            // the address is now occupied
            //
            m_dwOccupiedAddresses++;
            m_fOccupiedAddress[wAddress] = true;
            m_adwOccupiedAddressIndex[index] = wAddress;
            fBound = true;
            break;
        }
    }

    if (!fBound)
    {
        //
        // we are not bound, so no need to listen
        //
        return s;
    }

    //
    // if no need to listen, return
    //
    if (!m_fListen) return s;

    //
    // listen (on TCP) or WSARecvFrom (on UDP).
    // do not care if I fail.
    //
    if (m_fTCP)
    {
        if (SOCKET_ERROR == ::listen(s, 2 /*SOMAXCONN*/))
        {
            HOGGERDPF(("CWSASocketHog::CreatePseudoHandle(%d): listen(%d) failed with %d, m_dwOccupiedAddresses=%d.\n", index, wAddress, ::WSAGetLastError(), m_dwOccupiedAddresses));
        }
        else
        {
            //HOGGERDPF(("CWSASocketHog::CreatePseudoHandle(%d): listen(%d) SUCCEEDED, m_dwOccupiedAddresses=%d.\n", index, wAddress, ::WSAGetLastError(), m_dwOccupiedAddresses));
        }
    }
    else
    {
        //
        // these must be static, because when we close the socket, the overlapped is aborted
        //
        static char buff[1024];
        static WSABUF wsabuff;
        wsabuff.buf = buff;
        wsabuff.len = sizeof(buff);
        static DWORD dwNumberOfBytesRecvd;
        static WSAOVERLAPPED wsaOverlapped;
        DWORD dwFlags = MSG_PEEK;

        if (SOCKET_ERROR == 
            ::WSARecvFrom (
                s,                                               
                &wsabuff,                                     
                1,                                    
                &dwNumberOfBytesRecvd,                           
                &dwFlags,                                        
                NULL,//struct sockaddr FAR * lpFrom,                           
                NULL,//LPINT lpFromlen,                                        
                &wsaOverlapped,                           
                fn  
                )
           )
        {
            if (::WSAGetLastError() != ERROR_IO_PENDING)
            {
                HOGGERDPF(("CWSASocketHog::CreatePseudoHandle(%d): WSARecvFrom(%d) failed with %d, m_dwOccupiedAddresses=%d.\n", index, wAddress, ::WSAGetLastError(), m_dwOccupiedAddresses));
            }
        }
        else
        {
            HOGGERDPF(("CWSASocketHog::CreatePseudoHandle(%d): listen(%d) SUCCEEDED instead failing with ERROR_IO_PENDING, m_dwOccupiedAddresses=%d.\n", index, wAddress, ::WSAGetLastError(), m_dwOccupiedAddresses));
        }
    }

    return s;
}


bool CPHWSASocketHog::ReleasePseudoHandle(DWORD /*index*/)
{
    return true;
}


bool CPHWSASocketHog::ClosePseudoHandle(DWORD index)
{
    //
    // maybe we released an address.
    // I could have cached this info, but I was lazy.
    //
    if (0 < m_dwOccupiedAddresses) m_dwOccupiedAddresses--;

    //
    // if address was occupied, mark it as free.
    //
    _ASSERTE_(0xFFFF >= m_adwOccupiedAddressIndex[index]);
    m_fOccupiedAddress[m_adwOccupiedAddressIndex[index]] = false;
    m_adwOccupiedAddressIndex[index] = sizeof(m_fOccupiedAddress)/sizeof(m_fOccupiedAddress[0]) - 1;

    //
    // if we free a resource, we may get the buff next time
    //
    m_fNoMoreBuffs = false;

    if (0 != ::closesocket(m_ahHogger[index]))
    {
        ::SetLastError(::WSAGetLastError());
        return false;
    }

    return true;
}


bool CPHWSASocketHog::PostClosePseudoHandle(DWORD /*index*/)
{
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\phwinstationhog.cpp ===
//
// this class is used for hogging Resources.
// it differs from simple hogging by dynamically
// hogging all Resources and then releasing some.
// the level of free Resources can be controlled.
//


//#define HOGGER_LOGGING

#include "PHWinStationHog.h"



CPHWinStationHog::CPHWinStationHog(
	const DWORD dwMaxFreeResources, 
	const DWORD dwSleepTimeAfterFullHog, 
	const DWORD dwSleepTimeAfterFreeingSome
	)
	:
	CPseudoHandleHog<HWINSTA, NULL>(
        dwMaxFreeResources, 
        dwSleepTimeAfterFullHog, 
        dwSleepTimeAfterFreeingSome, 
        true //named
        )
{
	return;
}

CPHWinStationHog::~CPHWinStationHog(void)
{
	HaltHoggingAndFreeAll();
}


HWINSTA CPHWinStationHog::CreatePseudoHandle(DWORD /*index*/, TCHAR *szTempName)
{
    return ::CreateWindowStation(
        szTempName,        // name of the new window station
        NULL,       // reserved; must be NULL
        GetRandomDesiredAccess(),  // specifies access of returned handle
        NULL  // specifies security attributes of the window station
        );
}

bool CPHWinStationHog::ReleasePseudoHandle(DWORD /*index*/)
{
	return true;
}


bool CPHWinStationHog::ClosePseudoHandle(DWORD index)
{
    return (0 != ::CloseWindowStation(m_ahHogger[index]));
}


bool CPHWinStationHog::PostClosePseudoHandle(DWORD /*index*/)
{
	return true;
}

DWORD CPHWinStationHog::GetRandomDesiredAccess(void)
{
    DWORD dwAccumulatedDesiredAccess = 0;
    if (rand() % 9 == 0) dwAccumulatedDesiredAccess |= WINSTA_ENUMDESKTOPS;
    if (rand() % 9 == 0) dwAccumulatedDesiredAccess |= WINSTA_READATTRIBUTES;
    if (rand() % 9 == 0) dwAccumulatedDesiredAccess |= WINSTA_ACCESSCLIPBOARD;
    if (rand() % 9 == 0) dwAccumulatedDesiredAccess |= WINSTA_CREATEDESKTOP;
    if (rand() % 9 == 0) dwAccumulatedDesiredAccess |= WINSTA_WRITEATTRIBUTES;
    if (rand() % 9 == 0) dwAccumulatedDesiredAccess |= WINSTA_ACCESSGLOBALATOMS;
    if (rand() % 9 == 0) dwAccumulatedDesiredAccess |= WINSTA_EXITWINDOWS;
    if (rand() % 9 == 0) dwAccumulatedDesiredAccess |= WINSTA_ENUMERATE;
    if (rand() % 9 == 0) dwAccumulatedDesiredAccess |= WINSTA_READSCREEN;

    if (0 == dwAccumulatedDesiredAccess)
    {
        //
        // choose 1 random access type
        //
        if (rand() % 9 == 0) return WINSTA_ENUMDESKTOPS;
        if (rand() % 8 == 0) return WINSTA_READATTRIBUTES;
        if (rand() % 7 == 0) return WINSTA_ACCESSCLIPBOARD;
        if (rand() % 6 == 0) return WINSTA_CREATEDESKTOP;
        if (rand() % 5 == 0) return WINSTA_WRITEATTRIBUTES;
        if (rand() % 4 == 0) return WINSTA_ACCESSGLOBALATOMS;
        if (rand() % 3 == 0) return WINSTA_EXITWINDOWS;
        if (rand() % 2 == 0) return WINSTA_ENUMERATE;
        return WINSTA_READSCREEN;
    }
    else
    {
        return dwAccumulatedDesiredAccess;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\postcomppackhog.cpp ===
//
// this class is used for hogging Resources.
// it differs from simple hogging by dynamically
// hogging all Resources and then releasing some.
// the level of free Resources can be controlled.
//

//#define HOGGER_LOGGING

#include "PostCompPackHog.h"



CPostCompletionPacketHog::CPostCompletionPacketHog(
	const DWORD dwComplementOfHogCycleIterations, 
	const DWORD dwSleepTimeAfterFullHog,
	const DWORD dwSleepTimeAfterReleasing
	)
	:
	CHogger(dwComplementOfHogCycleIterations, dwSleepTimeAfterFullHog, dwSleepTimeAfterReleasing),
    m_dwPostedMessages(0)
{
    m_hCompletionPort = ::CreateIoCompletionPort( 
        INVALID_HANDLE_VALUE,              // file handle to associate with the I/O completion port
        NULL,  // handle to the I/O completion port
        0,            // per-file completion key for I/O  completion packets
        0 // number of threads allowed to execute concurrently
        );
    if (NULL == m_hCompletionPort)
    {
		throw CException(
			TEXT("CPostCompletionPacketHog::CPostCompletionPacketHog(): CreateIoCompletionPort() failed with %d"), 
			::GetLastError()
			);
    }
}


CPostCompletionPacketHog::~CPostCompletionPacketHog(void)
{
	HaltHoggingAndFreeAll();
}

void CPostCompletionPacketHog::FreeAll(void)
{
	return;
}


bool CPostCompletionPacketHog::HogAll(void)
{
    while(!m_fHaltHogging)
	{
		if (m_fAbort)
		{
			return false;
		}
        
        //
        // post any message, it doesn't matter, since this thread ignores these messages
        //
        static OVERLAPPED ol;
        if (! ::PostQueuedCompletionStatus(
                m_hCompletionPort,  // handle to an I/O completion port
                0x1000,  // value to return via GetQueuedCompletionStatus'  lpNumberOfBytesTranferred
                0xbcbcbcbc,  // value to return via GetQueuedCompletionStatus' lpCompletionKey
                &ol  // value to return via GetQueuedCompletionStatus' lpOverlapped
                )
           )
        {
            HOGGERDPF(("CPostCompletionPacketHog::HogAll(): PostQueuedCompletionStatus() failed with %d\n", ::GetLastError()));
            break;
        }

        m_dwPostedMessages++;
	}

	HOGGERDPF(("Sent total of %d messages.\n", m_dwPostedMessages));

	return true;
}


bool CPostCompletionPacketHog::FreeSome(void)
{
	DWORD dwMessagesToFree = 
		(RANDOM_AMOUNT_OF_FREE_RESOURCES == m_dwMaxFreeResources) ?
		rand() && (rand()<<16) :
		m_dwMaxFreeResources;
    dwMessagesToFree = min(dwMessagesToFree, m_dwPostedMessages);

    for (DWORD i = 0; i < dwMessagesToFree; i++)
    {
		if (m_fAbort)
		{
			return false;
		}
		if (m_fHaltHogging)
		{
			return true;
		}

        LPOVERLAPPED *lpOverlapped; //we post a static one
        DWORD dwNumberOfBytesTransferred;
        DWORD dwCompletionKey;
        if (! ::GetQueuedCompletionStatus(
                m_hCompletionPort,       // the I/O completion port of interest
                &dwNumberOfBytesTransferred,// to receive number of bytes transferred during I/O
                &dwCompletionKey,     // to receive file's completion key
                lpOverlapped,  // to receive pointer to OVERLAPPED structure
                60*1000         // optional timeout value
                )
           )
        {
                HOGGERDPF(("CPostCompletionPacketHog::FreeSome(), GetMessage() failed with %d.\n", ::GetLastError()));
        }
        else
        {
            m_dwPostedMessages++;
            _ASSERTE_(0x1000 == dwNumberOfBytesTransferred);
            _ASSERTE_(0xbcbcbcbc == dwCompletionKey);
        }
    }

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\postmessagehog.h ===
#ifndef __POST_MESSAGE_HOG_H
#define __POST_MESSAGE_HOG_H

//
// this class is used for hogging a resource.
// it differs from simple hogging by dynamically
// hogging all resources and then releasing some.
// the level of free resources can be controlled.
//


#include "hogger.h"

class CPostMessageHog : public CHogger
{
public:
	//
	// does not hog Resources yet.
	//
	CPostMessageHog(
		const DWORD dwComplementOfHogCycleIterations, 
		const DWORD dwSleepTimeAfterFullHog = 1000, 
		const DWORD dwSleepTimeAfterReleasing = 1000
		);

	~CPostMessageHog(void);

protected:
	virtual void FreeAll(void);

	virtual bool HogAll(void);
	virtual bool FreeSome(void);

private:
    DWORD m_dwPostedMessages;
    HWND m_hWnd;
    bool m_fFirstTime;
    DWORD m_dwWindowQueueThreadID;
};

#endif //__POST_MESSAGE_HOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\postthreadmessagehog.h ===
#ifndef __POST_THREAD_MESSAGE_HOG_H
#define __POST_THREAD_MESSAGE_HOG_H

//
// this class is used for hogging a resource.
// it differs from simple hogging by dynamically
// hogging all resources and then releasing some.
// the level of free resources can be controlled.
//


#include "hogger.h"

class CPostThreadMessageHog : public CHogger
{
public:
	//
	// does not hog Resources yet.
	//
	CPostThreadMessageHog(
		const DWORD dwComplementOfHogCycleIterations, 
		const DWORD dwSleepTimeAfterFullHog = 1000, 
		const DWORD dwSleepTimeAfterReleasing = 1000
		);

	~CPostThreadMessageHog(void);

protected:
	virtual void FreeAll(void);

	virtual bool HogAll(void);
	virtual bool FreeSome(void);

private:
    DWORD m_dwPostedMessages;
};

#endif //__POST_THREAD_MESSAGE_HOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\postmessagehog.cpp ===
//
// this class is used for hogging Resources.
// it differs from simple hogging by dynamically
// hogging all Resources and then releasing some.
// the level of free Resources can be controlled.
//

//#define HOGGER_LOGGING

#include "PostMessageHog.h"

#define CLASS_NAME TEXT("{5CFD4FE0-9684-11d2-B8B6-mickys-PostMessageHogger}")

static LRESULT CALLBACK MainWndProc(
    HWND hWnd,
    UINT msg, 
    WPARAM wParam,
    LPARAM lParam 
    )
{
	return( DefWindowProc( hWnd, msg, wParam, lParam ));
}

CPostMessageHog::CPostMessageHog(
	const DWORD dwComplementOfHogCycleIterations, 
	const DWORD dwSleepTimeAfterFullHog,
	const DWORD dwSleepTimeAfterReleasing
	)
	:
	CHogger(dwComplementOfHogCycleIterations, dwSleepTimeAfterFullHog, dwSleepTimeAfterReleasing),
    m_dwPostedMessages(0),
    m_hWnd(NULL),
    m_fFirstTime(true),
    m_dwWindowQueueThreadID(0)
{
	//
	// register class
	//
	WNDCLASS wc;
	wc.lpszClassName = CLASS_NAME;
	wc.lpfnWndProc = MainWndProc;
	wc.style = CS_OWNDC | CS_VREDRAW | CS_HREDRAW;
	wc.hInstance = NULL;
	wc.hIcon = NULL,//::LoadIcon( NULL, IDI_APPLICATION );
	wc.hCursor = NULL,//::LoadCursor( NULL, IDC_ARROW );
	wc.hbrBackground = (HBRUSH)( COLOR_WINDOW+1 );
	wc.lpszMenuName = TEXT("hoggerAppMenu");
	wc.cbClsExtra = 0;
	wc.cbWndExtra = 0;
	if (!RegisterClass( &wc ))
	{
		throw CException(
			TEXT("CPHWindowHog::CPHWindowHog(): RegisterClass(%s) failed with %d"), 
			CLASS_NAME,
			::GetLastError()
			);
	}

    //
    // the window must be created in the same thread as the GetMessage() thread.
    //
}


CPostMessageHog::~CPostMessageHog(void)
{
    //
    // BUGBUG: the window must be destroyed in the same thread as the CreateWindow() thread.
    //

    if (!::DestroyWindow(m_hWnd))
    {
        HOGGERDPF(("CPostMessageHog::~CPostMessageHog() DestroyWindow() failed with %d.\n", ::GetLastError()));
    }

	HaltHoggingAndFreeAll();
}

void CPostMessageHog::FreeAll(void)
{
	return;
}


bool CPostMessageHog::HogAll(void)
{
    if (m_fFirstTime)
    {
        //
        // in order to get messages, we must be on same thread that created the window
        //
        m_fFirstTime = false;

        m_hWnd = ::CreateWindow( 
		    CLASS_NAME,
		    TEXT("Post Message hogger"),
		    WS_CAPTION | WS_SYSMENU, //WS_OVERLAPPEDWINDOW|WS_HSCROLL|WS_VSCROLL,
		    0,
		    0,
		    150,//CW_USEDEFAULT,
		    0,//CW_USEDEFAULT,
		    NULL,
		    NULL,
		    NULL, //hInstance,
		    NULL
		    );
	    if (NULL == m_hWnd)
	    {
            HOGGERDPF((
			    "CPHWindowHog::HogAll(): CreateWindow(%s) failed with %d", 
			    CLASS_NAME,
			    ::GetLastError()
                ));
		    throw CException(
			    TEXT("CPHWindowHog::HogAll(): CreateWindow(%s) failed with %d"), 
			    CLASS_NAME,
			    ::GetLastError()
			    );
	    }

        m_dwWindowQueueThreadID = ::GetCurrentThreadId();
    }
    else
    {
        if (::GetCurrentThreadId() != m_dwWindowQueueThreadID)
        {
            HOGGERDPF((
                "CPHWindowHog::HogAll(): This method was called from a different thread than previous call to this method!"
                ));
		    throw CException(
                TEXT("CPHWindowHog::HogAll(): This method was called from a different thread than previous call to this method!")
                );
        }
    }

    HOGGERDPF(("+++into CPostMessageHog::HogAll().\n"));
    while(!m_fHaltHogging)
	{
		if (m_fAbort)
		{
			return false;
		}
        
        //
        // post any message, it doesn't matter, since this thread ignores these messages
        //
        if (!::PostMessage(
                m_hWnd,      // handle of destination window
                WM_USER, //WM_SETFOCUS,       // message to post
                3,  // first message parameter
                4   // second message parameter WM_QUIT
                )
           )
        {
            HOGGERDPF(("CPostMessageHog::HogAll(), PostMessage() failed with %d.\n", ::GetLastError()));
            break;
        }

        m_dwPostedMessages++;
	}

	HOGGERDPF(("---Sent total of %d messages.\n", m_dwPostedMessages));

	return true;
}


bool CPostMessageHog::FreeSome(void)
{
	HOGGERDPF(("+++into CPostMessageHog::FreeSome().\n"));
	DWORD dwMessagesToFree = 
		(RANDOM_AMOUNT_OF_FREE_RESOURCES == m_dwMaxFreeResources) ?
		rand() && (rand()<<16) :
		m_dwMaxFreeResources;
    dwMessagesToFree = min(dwMessagesToFree, m_dwPostedMessages);

    for (DWORD i = 0; i < dwMessagesToFree; i++)
    {
		if (m_fAbort)
		{
			return false;
		}
		if (m_fHaltHogging)
		{
			return true;
		}

        MSG msg;
        BOOL bGetMessage = ::GetMessage(  
            &msg,         // address of structure with message
            m_hWnd,           // handle of window: NULL is current thread
            0,  // first message  
            0xFFFF   // last message
            );
        switch(bGetMessage)
        {
        case 0:
            HOGGERDPF(("CPostMessageHog::FreeSome(), GetMessage() returned 0 with msg.message=0x%04X, msg.wParam=0x%04X, msg.lParam=0x%04X.\n", msg.message, msg.wParam, msg.lParam));
            break;

        case -1:
            HOGGERDPF(("CPostMessageHog::FreeSome(), GetMessage() returned -1 with %d.\n", ::GetLastError()));
            break;
        default:
            m_dwPostedMessages--;
            _ASSERTE_(WM_USER == msg.message);
            _ASSERTE_(3 == msg.wParam);
            _ASSERTE_(4 == msg.lParam);
        }
    }

	HOGGERDPF(("---out of CPostMessageHog::FreeSome().\n"));
    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\postthreadmessagehog.cpp ===
//
// this class is used for hogging Resources.
// it differs from simple hogging by dynamically
// hogging all Resources and then releasing some.
// the level of free Resources can be controlled.
//

//#define HOGGER_LOGGING

#include "PostThreadMessageHog.h"



CPostThreadMessageHog::CPostThreadMessageHog(
	const DWORD dwComplementOfHogCycleIterations, 
	const DWORD dwSleepTimeAfterFullHog,
	const DWORD dwSleepTimeAfterReleasing
	)
	:
	CHogger(dwComplementOfHogCycleIterations, dwSleepTimeAfterFullHog, dwSleepTimeAfterReleasing),
    m_dwPostedMessages(0)
{
        return;
}


CPostThreadMessageHog::~CPostThreadMessageHog(void)
{
	HaltHoggingAndFreeAll();
}

void CPostThreadMessageHog::FreeAll(void)
{
	return;
}


bool CPostThreadMessageHog::HogAll(void)
{
    while(!m_fHaltHogging)
	{
		if (m_fAbort)
		{
			return false;
		}
        
        //
        // post any message, it doesn't matter, since this thread ignores these messages
        //
        if (!::PostThreadMessage(
            ::GetCurrentThreadId(), // thread identifier  
                WM_USER,       // message to post
                3,  // first message parameter
                4   // second message parameter WM_QUIT
                )
           )
        {
            HOGGERDPF(("CPostThreadMessageHog::HogAll(), PostThreadMessage() failed with %d.\n", ::GetLastError()));
            break;
        }

        m_dwPostedMessages++;
	}

	HOGGERDPF(("Sent total of %d messages.\n", m_dwPostedMessages));

	return true;
}


bool CPostThreadMessageHog::FreeSome(void)
{
	DWORD dwMessagesToFree = 
		(RANDOM_AMOUNT_OF_FREE_RESOURCES == m_dwMaxFreeResources) ?
		rand() && (rand()<<16) :
		m_dwMaxFreeResources;
    dwMessagesToFree = min(dwMessagesToFree, m_dwPostedMessages);

    for (DWORD i = 0; i < dwMessagesToFree; i++)
    {
		if (m_fAbort)
		{
			return false;
		}
		if (m_fHaltHogging)
		{
			return true;
		}

        MSG msg;
        BOOL bGetMessage = ::GetMessage(  
            &msg,         // address of structure with message
            NULL,           // handle of window: NULL is current thread
            0,  // first message  
            0xFFFF   // last message
            );
        switch(bGetMessage)
        {
        case 0:
            HOGGERDPF(("CPostThreadMessageHog::FreeSome(), GetMessage() returned 0 with msg.message=0x%04X, msg.wParam=0x%04X, msg.lParam=0x%04X.\n", msg.message, msg.wParam, msg.lParam));
            break;

        case -1:
            HOGGERDPF(("CPostThreadMessageHog::FreeSome(), GetMessage() returned -1 with %d.\n", ::GetLastError()));
            break;
        default:
            m_dwPostedMessages--;
            _ASSERTE_(WM_USER == msg.message);
            _ASSERTE_(3 == msg.wParam);
            _ASSERTE_(4 == msg.lParam);
        }
    }

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\pseudohandlehog.h ===
#ifndef __PSEUDO_HANDLE_HOG_H
#define __PSEUDO_HANDLE_HOG_H

//
// this class is used for hogging a resource.
// it differs from simple hogging by dynamically
// hogging all resources and then releasing some.
// the level of free resources can be controlled.
//

//
// this template should be used for hogging objects that are handle-like.
// this means that there's an array of these objects, and we create these objects
// as items in this array.
// a resource-unit is an entry in the array.
//

#include "hogger.h"

template <class T, DWORD INVALID_PSEUDO_HANDLE_VALUE> class CPseudoHandleHog : public CHogger
{
public:
	//
	// does not hog Resources yet.
	//
	CPseudoHandleHog(
		const DWORD dwMaxFreeResources, 
		const DWORD dwSleepTimeAfterFullHog = 1000, 
		const DWORD dwSleepTimeAfterFreeingSome = 1000,
        const bool fNamedObject = false
		);

	virtual ~CPseudoHandleHog(void) = 0;

protected:
    //
    // these are implemented, and should not be overridden
    //
	virtual void FreeAll(void);
	virtual bool HogAll(void);
	virtual bool FreeSome(void);

    //
    // you should implement the following 4, per an Object class
    //

    //
    // e.g: CreateFile()
    //
	virtual T CreatePseudoHandle(DWORD index, TCHAR *szTempName = 0) = 0;

    //
    // usually an empty imp.
    // with threads, can be used to terminate the thread.
    //
	virtual bool ReleasePseudoHandle(DWORD index) = 0;

    //
    // e.g: CloseHandle()
    //
	virtual bool ClosePseudoHandle(DWORD index) = 0;

    //
    // usually an empty imp.
    // with files, can be used to delete the file.
    //
	virtual bool PostClosePseudoHandle(DWORD index) = 0;

    //
    // the hogger array
    //
	T m_ahHogger[HANDLE_ARRAY_SIZE];

    //
    // place holder for names of objects
    //
	TCHAR* m_apszName[HANDLE_ARRAY_SIZE];

    //
    // index to next free entry in hogger array
    //
	DWORD m_dwNextFreeIndex;

    //
    // is it a named object?
    //
    bool m_fNamedObject;

};

//
// implementation
//

template <class T, DWORD INVALID_PSEUDO_HANDLE_VALUE>
CPseudoHandleHog<T, INVALID_PSEUDO_HANDLE_VALUE>::CPseudoHandleHog(
	const DWORD dwMaxFreeResources, 
	const DWORD dwSleepTimeAfterFullHog, 
	const DWORD dwSleepTimeAfterFreeingSome,
    const bool fNamedObject
	)
	:
	CHogger(dwMaxFreeResources, dwSleepTimeAfterFullHog, dwSleepTimeAfterFreeingSome),
	m_dwNextFreeIndex(0),
    m_fNamedObject(fNamedObject)
{
	for (int i = 0; i < HANDLE_ARRAY_SIZE; i++)
	{
		m_ahHogger[i] = (T)INVALID_PSEUDO_HANDLE_VALUE;
        m_apszName[i] = NULL;
	}
}



template <class T, DWORD INVALID_PSEUDO_HANDLE_VALUE>
CPseudoHandleHog<T, INVALID_PSEUDO_HANDLE_VALUE>::~CPseudoHandleHog(void)
{
	for (int i = 0; i < HANDLE_ARRAY_SIZE; i++)
	{
        delete m_apszName[i];
	}

    //derived classes should call: HaltHoggingAndFreeAll();
}



template <class T, DWORD INVALID_PSEUDO_HANDLE_VALUE>
inline
void CPseudoHandleHog<T, INVALID_PSEUDO_HANDLE_VALUE>::FreeAll(void)
{
	HOGGERDPF(("+++CPseudoHandleHog::FreeAll().\n"));
	for (int i = m_dwNextFreeIndex; i < HANDLE_ARRAY_SIZE; i++)
	{
		_ASSERTE_((T)INVALID_PSEUDO_HANDLE_VALUE == m_ahHogger[i]);
	}

	for (; m_dwNextFreeIndex > 0; m_dwNextFreeIndex--)
	{
		if (!ReleasePseudoHandle(m_dwNextFreeIndex-1))
		{
			HOGGERDPF(("CPseudoHandleHog::FreeAll(): ReleasePseudoHandle(%d) failed with %d.\n", m_dwNextFreeIndex-1, ::GetLastError()));
		}

//HOGGERDPF(("BEFORE ReleasePseudoHandle(%d).\n", m_dwNextFreeIndex-1));
		if (!ClosePseudoHandle(m_dwNextFreeIndex-1))
		{
			HOGGERDPF(("CPseudoHandleHog::FreeAll(): ClosePseudoHandle(%d) failed with %d.\n", m_dwNextFreeIndex-1, ::GetLastError()));
		}
//HOGGERDPF(("AFTER ReleasePseudoHandle(%d).\n", m_dwNextFreeIndex-1));
		m_ahHogger[m_dwNextFreeIndex-1] = (T)INVALID_PSEUDO_HANDLE_VALUE;

		if (!PostClosePseudoHandle(m_dwNextFreeIndex-1))
		{
			HOGGERDPF(("CPseudoHandleHog::FreeAll(): PostClosePseudoHandle(%d) failed with %d.\n", m_dwNextFreeIndex-1, ::GetLastError()));
		}
	}
	HOGGERDPF(("---CPseudoHandleHog::FreeAll().\n"));
}

template <class T, DWORD INVALID_PSEUDO_HANDLE_VALUE>
bool CPseudoHandleHog<T, INVALID_PSEUDO_HANDLE_VALUE>::HogAll(void)
{
	for (; m_dwNextFreeIndex < HANDLE_ARRAY_SIZE; m_dwNextFreeIndex++)
	{
        TCHAR szTempBuffForName[16];
        TCHAR *pszTempName;

        if (m_fAbort)
		{
			return false;
		}
		if (m_fHaltHogging)
		{
			return true;
		}

        //
        // get a unique name or NULL, according to m_fNamedObject
        //
        if (m_fNamedObject)
        {
            pszTempName = GetUniqueName(szTempBuffForName, sizeof(szTempBuffForName)/sizeof(*szTempBuffForName));
        }
        else
        {
            pszTempName = NULL;
        }

        m_ahHogger[m_dwNextFreeIndex] = CreatePseudoHandle(m_dwNextFreeIndex, pszTempName);
        if((T)INVALID_PSEUDO_HANDLE_VALUE == m_ahHogger[m_dwNextFreeIndex])
		{
			HOGGERDPF(("CPseudoHandleHog::HogAll(): CreatePseudoHandle(%d, %s) failed with %d.\n", m_dwNextFreeIndex, pszTempName, ::GetLastError()));
			break;
		}
	}

	if (m_dwNextFreeIndex == HANDLE_ARRAY_SIZE)
	{
		HOGGERDPF(("Hogged %d handles, but that's not enough!", HANDLE_ARRAY_SIZE));
	}

	HOGGERDPF(("CPseudoHandleHog::HogAll(): Hogged %d handles.\n", m_dwNextFreeIndex));

	return true;
}



template <class T, DWORD INVALID_PSEUDO_HANDLE_VALUE>
inline
bool CPseudoHandleHog<T, INVALID_PSEUDO_HANDLE_VALUE>::FreeSome(void)
{
	DWORD dwOriginalNextFreeIndex = m_dwNextFreeIndex;
	//
	// take care of RANDOM_AMOUNT_OF_FREE_RESOURCES case
	//
	DWORD dwToFree = 
		(RANDOM_AMOUNT_OF_FREE_RESOURCES == m_dwMaxFreeResources) ?
		rand() && (rand()<<16) :
		m_dwMaxFreeResources;
	dwToFree = min(dwToFree, m_dwNextFreeIndex);

    HOGGERDPF(("CPseudoHandleHog::FreeSome(): m_dwNextFreeIndex=%d, m_dwMaxFreeResources=%d, dwToFree=%d.\n", m_dwNextFreeIndex, m_dwMaxFreeResources, dwToFree));

	HOGGERDPF(("CPseudoHandleHog::FreeSome(): before free cycle.\n"));
	for (; m_dwNextFreeIndex > dwOriginalNextFreeIndex - dwToFree; m_dwNextFreeIndex--)
	{
		if (!ReleasePseudoHandle(m_dwNextFreeIndex-1))
		{
			HOGGERDPF(("CPseudoHandleHog::FreeSome(): ReleasePseudoHandle(%d) failed with %d.\n", m_dwNextFreeIndex-1, ::GetLastError()));
		}

		if (!ClosePseudoHandle(m_dwNextFreeIndex-1))
		{
			HOGGERDPF(("CPseudoHandleHog::FreeSome(): ClosePseudoHandle(%d) failed with %d.\n", m_dwNextFreeIndex-1, ::GetLastError()));
		}
		m_ahHogger[m_dwNextFreeIndex-1] = (T)INVALID_PSEUDO_HANDLE_VALUE;

		if (!PostClosePseudoHandle(m_dwNextFreeIndex-1))
		{
			HOGGERDPF(("CPseudoHandleHog::FreeSome(): PostClosePseudoHandle(%d) failed with %d.\n", m_dwNextFreeIndex-1, ::GetLastError()));
		}
	}//for (; m_ahHogger > dwOriginalNextFreeIndex - dwToFree; m_ahHogger--)

	HOGGERDPF(("CPseudoHandleHog::FreeSome(): Freed %d handles.\n", dwToFree));

	return true;
}



#endif //__PSEUDO_HANDLE_HOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\queueapchog.h ===
#ifndef __QUEUE_APC_HOG_H
#define __QUEUE_APC_HOG_H

//
// this class is used for hogging a resource.
// it differs from simple hogging by dynamically
// hogging all resources and then releasing some.
// the level of free resources can be controlled.
//



#include "hogger.h"

class CQueueAPCHog : public CHogger
{
public:
    friend static void WINAPI APCFunc(DWORD dwParam);

	//
	// does not hog Resources yet.
	//
	CQueueAPCHog(
		const DWORD dwMaxFreeResources, 
		const DWORD dwSleepTimeAfterFullHog = 1000, 
		const DWORD dwSleepTimeAfterReleasing = 1000
		);

	~CQueueAPCHog(void);

protected:
	virtual void FreeAll(void);

	virtual bool HogAll(void);
	virtual bool FreeSome(void);

private:
    DWORD m_dwQueuedAPCs;
};

#endif //__QUEUE_APC_HOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\registryhog.cpp ===
//
// this class is used for hogging Resources.
// it differs from simple hogging by dynamically
// hogging all Resources and then releasing some.
// the level of free Resources can be controlled.
//

//#define HOGGER_LOGGING

#include "RegistryHog.h"

//
// the value we put as an "empty" value
//
static const TCHAR s_szEmpty[] = TEXT("e");

//
// the key we create under HKEY_CURRENT_USER, under which we create the hogging keys
//
static const TCHAR s_szSubKey[] = TEXT("MickysHogger");

//
// format of the keys under s_szSubKey
//
static const TCHAR s_szKeyFormat[] = TEXT("%X_Power_Of_F_times_%X");

static const TCHAR s_cData = TEXT('x');

//
// actually, if power of 2 > 10^6, we take the result as 10^6, 
// since a registry value cannot be larger than that.
//
#define MAX_POWER_OF_2 (100)

CRegistryHog::CRegistryHog(
	const DWORD dwMaxFreeResources, 
	const DWORD dwSleepTimeAfterFullHog, 
	const DWORD dwSleepTimeAfterFreeingSome
	)
	:
	CHogger(dwMaxFreeResources, dwSleepTimeAfterFullHog, dwSleepTimeAfterFreeingSome),
	m_hkeyParams(NULL),
	m_dwTotalAllocatedRegistry(0)
{
	//
	// create the key that will hold the hogging keys
	//
        LONG lRegCreateKeyRetval = ::RegCreateKey(
		HKEY_CURRENT_USER,        // handle to an open key
		s_szSubKey, // address of name of subkey to open
		&m_hkeyParams   // address of handle to open key
		);
	if (ERROR_SUCCESS != lRegCreateKeyRetval)
	{
		throw CException(
			TEXT("CRegistryHog::CRegistryHog(): RegCreateKey(HKEY_CURRENT_USER, %s) failed with %d"), 
			s_szSubKey,
			lRegCreateKeyRetval
			);
	}

	_ASSERTE_(NULL != m_hkeyParams);

	//
	// create the keys that are place holders for hogging values
	//
	Initialize();
}


CRegistryHog::~CRegistryHog(void)
{
	HaltHoggingAndFreeAll();

	//
	// delete all the keys that i created
	//
	DWORD cbName;
	TCHAR szNextName[MAX_PATH+1];
	bool fBreakWhile = false;
	//
	// it seems that RegEnumKey() misses many keys, so i loop untill it catches all.
	//
	while(!fBreakWhile)
	{
		for (DWORD dwIndex = 0; ; dwIndex++)
		{
			cbName = sizeof(szNextName);

			LONG lRegEnumKeyRetval = ::RegEnumKey(  
				m_hkeyParams,     // handle to key to query
				dwIndex, // index of subkey to query
				szNextName, // address of buffer for subkey name
				cbName   // size of subkey buffer
				);
			if (ERROR_NO_MORE_ITEMS == lRegEnumKeyRetval)
			{
				if (0 == dwIndex)
				{
					//
					// this means that there are REALLY no more keys
					//
					fBreakWhile = true;
				}
				break;
			}
			if (ERROR_SUCCESS != lRegEnumKeyRetval)
			{
				HOGGERDPF((
					"CRegistryHog::~CRegistryHog(): RegEnumKey(HKEY_CURRENT_USER, %s) failed with %d\n", 
					szNextName,
					lRegEnumKeyRetval
					));
			}

			long lRegDeleteKeyRetval = ::RegDeleteKey(
				m_hkeyParams,         // handle to open key
				szNextName   // address of name of subkey to delete
				);
			if (ERROR_SUCCESS != lRegDeleteKeyRetval)
			{
				HOGGERDPF((
					"CRegistryHog::~CRegistryHog(): RegDeleteKey(HKEY_CURRENT_USER, %s) failed with %d\n", 
					szNextName,
					lRegDeleteKeyRetval
					));
			}
		}//for (DWORD dwIndex = 0; ; dwIndex++)
	}//while(!fBreakWhile)

	//
	// close the parent key
	//
	LONG lRegCloseKeyRetval = ::RegCloseKey(m_hkeyParams);
	if (ERROR_SUCCESS != lRegCloseKeyRetval)
	{
		HOGGERDPF((
			"CRegistryHog::~CRegistryHog(): RegDeleteKey(HKEY_CURRENT_USER, %s) failed with %d\n", 
			s_szSubKey,
			lRegCloseKeyRetval
			));
	}
	m_hkeyParams = NULL;

	//
	// and delete it
	//
	long lRegDeleteKeyRetval = ::RegDeleteKey(
		HKEY_CURRENT_USER,         // handle to open key
		s_szSubKey   // address of name of subkey to delete
		);
	if (ERROR_SUCCESS != lRegDeleteKeyRetval)
	{
		HOGGERDPF((
			"CRegistryHog::~CRegistryHog(): RegDeleteKey(HKEY_CURRENT_USER, %s) failed with %d\n", 
			s_szSubKey,
			lRegDeleteKeyRetval
			));
	}

}

void CRegistryHog::Initialize()
{
	//
	// create keys according to the s_szKeyFormat format.
	// they will have values of the empty string s_szEmpty.
	//
	for (int iPowerOf2 = 0; iPowerOf2 <= MAX_POWER_OF_2; iPowerOf2++)
	{
		for (int i = 0x0; i < 0x10; i++)
		{
			//
			// will be formatted to hold the key name
			//
			TCHAR szSubKey[1024];
			_stprintf(szSubKey, s_szKeyFormat, iPowerOf2, i);

			//
			// set a value of the3 empty string
			//
			long lRegSetValueRetval = ::RegSetValue(
				m_hkeyParams,
				szSubKey,
				REG_SZ,
				s_szEmpty,
				1
				);
			if (ERROR_SUCCESS != lRegSetValueRetval)
			{
				throw CException(
					TEXT("CRegistryHog::Initialize(): RegSetValue(HKEY_CURRENT_USER, %s, %s) failed with %d\n"), 
					szSubKey,
					s_szEmpty,
					lRegSetValueRetval
					);
			}
		}
	}

	m_dwTotalAllocatedRegistry = 0;

	memset(m_szRegistryDataToWrite, s_cData, MAX_REG_SET_SIZE);
	m_szRegistryDataToWrite[MAX_REG_SET_SIZE] = TEXT('\0');
}

void CRegistryHog::FreeAll(void)
{
    try
    {
	    Initialize();
    }catch(CException e)
    {
		HOGGERDPF(((const char*)e));
    }
}


bool CRegistryHog::HogAll(void)
{
	//
	// start with the largest keys, that will hold 10^6-byte strings.
	// note that if power of 2 > 10^6, we take the value of 10^6 instead,
	// since it's the max value len.
	//
	for (int iPowerOf2 = MAX_POWER_OF_2; iPowerOf2 > 0; iPowerOf2--)
	{
		for (int i = 0x0; i < 0x10; i++)
		{
			if (m_fAbort)
			{
				return false;
			}
			if (m_fHaltHogging)
			{
				return true;
			}

            //
            // i could have made a table of key names, and save re-formatting all the time.
            // i did not.
            //
			TCHAR szSubKey[1024];
            ::_sntprintf(szSubKey, sizeof(szSubKey)/sizeof(*szSubKey)-1, s_szKeyFormat, iPowerOf2, i);
            szSubKey[sizeof(szSubKey)/sizeof(*szSubKey)-1] = TEXT('\0');

			if (!IsEmptyKey(szSubKey)) continue;

			//
			// choose the amount to into this key
			//
			int iRealPowerOf2 = min(iPowerOf2, 20);
			DWORD dwThisKeySize = (1 << iRealPowerOf2);
			dwThisKeySize = min(dwThisKeySize, MAX_REG_SET_SIZE);
            //
            // put a terminating null to temporarily mark the string.
            // this null will be replaced later with s_cData
            //
			m_szRegistryDataToWrite[dwThisKeySize] = TEXT('\0');

			long lRegSetValueRetval = ::RegSetValue(
				m_hkeyParams,
				szSubKey,
				REG_SZ,
				m_szRegistryDataToWrite,
				dwThisKeySize
				);

            //
            // restore the terminating null
            //
			m_szRegistryDataToWrite[dwThisKeySize] = s_cData;

			if (ERROR_SUCCESS != lRegSetValueRetval)
			{
				HOGGERDPF((
					"CRegistryHog::HogAll(): RegSetValue(HKEY_CURRENT_USER, %s, <Size=%d>) failed with %d\n", 
					szSubKey,
					dwThisKeySize,
					lRegSetValueRetval
					));
				break;
			}

			//
			// we cannot be sure that we succeeded.
			// we must read the value, and verify!
			//

			long lCount = dwThisKeySize+1;
			long lRegRegQueryValueRetval = ::RegQueryValue(
				m_hkeyParams,       // handle to key to query
				szSubKey,                   // name of subkey to query
				m_szReadRegistryData,  // buffer for returned string
				&lCount  // receives size of returned string
				);
			if (ERROR_SUCCESS != lRegRegQueryValueRetval)
			{
				HOGGERDPF((
					"CRegistryHog::HogAll(): RegQueryValue(HKEY_CURRENT_USER, %s, <Size=%d>) failed with %d\n", 
					szSubKey,
					dwThisKeySize,
					lRegRegQueryValueRetval
					));
				//
				// we failed, so break
				//
				break;
			}

			//
			// retval is not enough, make sure we wrote all the bytes.
			//
			if (lCount != (long)dwThisKeySize+1)
			{
				if (IsEmptyKey(szSubKey))
				{
					//HOGGERDPF(("CRegistryHog::HogAll(): iPowerOf2=%d, IsEmptyKey(%s) . Assuming failure.\n", iPowerOf2, szSubKey));
				}
				else
				{
					HOGGERDPF(("CRegistryHog::HogAll(): iPowerOf2=%d, lCount(%d) != dwThisKeySize+1(%d). Assuming failure.\n", iPowerOf2, lCount, dwThisKeySize+1));
				}

				//
				// we failed, so break
				//
				break;
			}

			//
			// count hogges bytes
			//
			m_dwTotalAllocatedRegistry += lCount;
			//HOGGERDPF(("CRegistryHog::HogAll(): m_dwTotalAllocatedRegistry=%d, lCount=%d.\n", m_dwTotalAllocatedRegistry, lCount));
		}//for (int i = 0x0; i < 0x10; i++)
	}//for (int iPowerOf2 = MAX_POWER_OF_2; iPowerOf2 > 0; iPowerOf2--)

	//HOGGERDPF(("CRegistryHog::HogAll(): Hogged %d registry bytes.\n", m_dwTotalAllocatedRegistry));
	return true;
}


bool CRegistryHog::FreeSome(void)
{
	DWORD dwFreed = 0;
	for (int iPowerOf2 = 0; iPowerOf2 <= MAX_POWER_OF_2; iPowerOf2++)
	{
		for (int i = 0x0; i < 0x10; i++)
		{
			if (m_fAbort)
			{
				return false;
			}
			if (m_fHaltHogging)
			{
				return true;
			}

            //
            // i could have made a table of key names, and save re-formatting all the time.
            // i did not.
            //
			TCHAR szSubKey[1024];
            ::_sntprintf(szSubKey, sizeof(szSubKey)/sizeof(*szSubKey)-1, s_szKeyFormat, iPowerOf2, i);
            szSubKey[sizeof(szSubKey)/sizeof(*szSubKey)-1] = TEXT('\0');

			if (!IsEmptyKey(szSubKey)) break;

			int iRealPowerOf2 = min(iPowerOf2, 20);
			DWORD dwThisKeySize = (1 << iRealPowerOf2);
			dwThisKeySize = min(dwThisKeySize, MAX_REG_SET_SIZE);

            long lRegSetValueRetval = ::RegSetValue(
				m_hkeyParams,
				szSubKey,
				REG_SZ,
				s_szEmpty,
				1
				);

			if (ERROR_NO_SYSTEM_RESOURCES == lRegSetValueRetval)
			{
				HOGGERDPF((
					"CRegistryHog::FreeSome(): RegSetValue(HKEY_CURRENT_USER, %s, %s) failed with ERROR_NO_SYSTEM_RESOURCES\n", 
					szSubKey,
					s_szEmpty
					));
				continue;
			}
			if (ERROR_SUCCESS != lRegSetValueRetval)
			{
				HOGGERDPF((
					"CRegistryHog::FreeSome(): RegSetValue(HKEY_CURRENT_USER, %s, %s) failed with %d\n", 
					szSubKey,
					s_szEmpty,
					lRegSetValueRetval
					));
				_ASSERTE_(FALSE);
				break;
			}

			if (!IsEmptyKey(szSubKey))
			{
				HOGGERDPF(("CRegistryHog::FreeSome(): key %s is not empty after emptying it!.\n", szSubKey));
			}

			//
			// count freed bytes
			//
			m_dwTotalAllocatedRegistry -= (dwThisKeySize-1);
			dwFreed += dwThisKeySize-1;
			if (dwFreed >= m_dwMaxFreeResources)
			{
				//HOGGERDPF(("CRegistryHog::FreeSome(): freed %d bytes.\n", dwFreed));
				return true;
			}

		}//for (int i = 0x0; i < 0x10; i++)
	}//for (int iPowerOf2 = MAX_POWER_OF_2; iPowerOf2 > 0; iPowerOf2--)

	HOGGERDPF(("CRegistryHog::FreeSome(): freed %d bytes.\n", dwFreed));
	_ASSERTE_(false);

	return true;
}


bool CRegistryHog::IsEmptyKey(const TCHAR * const szSubKey)
{
	long lCount = 3;
	TCHAR szRegistryData[4];

    long lRegRegQueryValueRetval = ::RegQueryValue(
		m_hkeyParams,       // handle to key to query
		szSubKey,                   // name of subkey to query
		szRegistryData,  // buffer for returned string
		&lCount  // receives size of returned string
		);

	if (ERROR_MORE_DATA == lRegRegQueryValueRetval)
	{
		return false;
	}

	if (ERROR_SUCCESS != lRegRegQueryValueRetval)
	{
		HOGGERDPF((
			"CRegistryHog::IsEmptyKey(): RegQueryValue(HKEY_CURRENT_USER, %s) failed with %d\n", 
			szSubKey,
			lRegRegQueryValueRetval
			));
		return true;
	}

    if (0 == ::lstrcmp(szRegistryData, s_szEmpty))
	{
		return true;
	}

	if (0 == lCount)
	{
		return true;
	}

	return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\queueapchog.cpp ===
//
// this class is used for hogging Resources.
// it differs from simple hogging by dynamically
// hogging all Resources and then releasing some.
// the level of free Resources can be controlled.
//

//#define HOGGER_LOGGING

#include "QueueAPCHog.h"

static void WINAPI APCFunc(DWORD dwParam)
{
    CQueueAPCHog* pThis = (CQueueAPCHog*) dwParam;

    //if (0 == pThis->m_dwQueuedAPCs%10000) HOGGERDPF(("APCFunc(): pThis->m_dwQueuedAPCs=%d\n", pThis->m_dwQueuedAPCs));
    pThis->m_dwQueuedAPCs--;
    return;
}

CQueueAPCHog::CQueueAPCHog(
	const DWORD dwMaxFreeResources, 
	const DWORD dwSleepTimeAfterFullHog,
	const DWORD dwSleepTimeAfterReleasing
	)
	:
	CHogger(dwMaxFreeResources, dwSleepTimeAfterFullHog, dwSleepTimeAfterReleasing),
    m_dwQueuedAPCs(0)
{
    return;
}


CQueueAPCHog::~CQueueAPCHog(void)
{
	HaltHoggingAndFreeAll();
}

void CQueueAPCHog::FreeAll(void)
{
    //
    // warning: this method will work only if called from the same thread as the queueing thread!
    //

    //
    // get into alertable state - all APCs should run
    //
    ::SleepEx(0, true);

    if (0 < m_dwQueuedAPCs)
    {
    	HOGGERDPF(("ERROR! 0 < m_dwQueuedAPCs(%d).\n", m_dwQueuedAPCs));
    }
    else
    {
	    HOGGERDPF(("All Is Freed.\n"));
    }
    return;
}


bool CQueueAPCHog::HogAll(void)
{
    while(!m_fHaltHogging)
	{
		if (m_fAbort)
		{
            //
            // we must free all, because we must free all APCs from this thread\
            //
            FreeAll();
			return false;
		}
        
        if (! ::QueueUserAPC(  
                    APCFunc, // pointer to APC function
                    m_hthHogger,  // handle to the thread
                    (DWORD)this     // argument for the APC function
                    )
           )
        {
            //
            // according to the docs, GetLastError() will NOT return an error.
            //
            //HOGGERDPF(("CQueueAPCHog::HogAll(): QueueUserAPC() failed with %d\n", ::GetLastError()));
            break;
        }

        m_dwQueuedAPCs++;
	}
    if (m_fHaltHogging)
    {
        //
        // we must free all, because we must free all APCs from this thread\
        //
        FreeAll();
    }

	HOGGERDPF(("Sent total of %d messages.\n", m_dwQueuedAPCs));

	return true;
}


bool CQueueAPCHog::FreeSome(void)
{
    //
    // i cannot free some, only all, because when i become alerted, all APC's is Q
    // will be called.
    //
    FreeAll();

	if (m_fAbort)
	{
		return false;
	}
	if (m_fHaltHogging)
	{
		return true;
	}

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\remotememhog.h ===
#ifndef __REMOTE_MEM_HOG_H
#define __REMOTE_MEM_HOG_H

//
// this class is used for hogging a resource.
// it differs from simple hogging by dynamically
// hogging all resources and then releasing some.
// the level of free resources can be controlled.
//


#include "hogger.h"

class CRemoteMemHog : public CHogger
{
public:
	//
	// does not hog Resources yet.
	//
	CRemoteMemHog(
		const DWORD dwMaxFreeResources, 
		const DWORD dwSleepTimeAfterFullHog = 1000, 
		const DWORD dwSleepTimeAfterReleasing = 1000,
        const bool fRemote = true
		);

	~CRemoteMemHog(void);

protected:
	virtual void FreeAll(void);

	virtual bool HogAll(void);
	virtual bool FreeSome(void);

	//
	// 1st index is power of 10. each 1st index may holds 10 place holder for the 
	// amount of 10^1st bytes.
	// 
	char *m_apcHogger[10][10];

	//
	// holds the powers of 10, to calculate amounts of memory
	//
	static const long m_lPowerOfTen[10];

    STARTUPINFO m_si;
    PROCESS_INFORMATION m_pi;
    static const TCHAR *sm_szProcess;
    bool m_fRemote;

};

#endif //__REMOTE_MEM_HOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\memhog\main.cpp ===
#include "memhog.h"


int GetFreeMem()
{
	int nFreeMem;
	printf("enter 0:to exit\n     -1:to halt hogging\n     -2:to stop hogging\n     <bytes-free> to hog MaxMem-<bytes-free> to MaxMem: ");
	scanf("%d", &nFreeMem);
	if (0 > nFreeMem)
	{
		//printf("exiting\n");
		//exit(-1);
	}

	return nFreeMem;
}

int main()
{
	int nFreeMem;

	CMemHog hogger(1024*1024);
	while(true)
	{
		nFreeMem = GetFreeMem();
		switch(nFreeMem)
		{
		case 0:
			printf("Please wait....\n");
			hogger.FreeMem();
			printf("Exiting.\n");
			exit(-1);

		case -1:
			printf("Please wait....\n");
			hogger.HaltHogging();
			printf("Hogging halted.\n");
			break;

		case -2:
			printf("Please wait....\n");
			hogger.FreeMem();
			printf("Memory freed.\n");
			break;

		default:
			if (0 > nFreeMem)
			{
				printf("Illegal Input.\nExiting.\n");
				exit(-1);
			}

			printf("hogging restarting.\n");
			hogger.SetMaxFreeMem(nFreeMem);
			hogger.StartHogging();
			printf("hogging resumed, free mem=%d.\n", nFreeMem);
		}
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\registryhog.h ===
#ifndef __REGISTRY_HOG_H
#define __REGISTRY_HOG_H

//
// this class is used for hogging a resource.
// it differs from simple hogging by dynamically
// hogging all resources and then releasing some.
// the level of free resources can be controlled.
//


#include "hogger.h"

#define MAX_REG_SET_SIZE (1000000)

class CRegistryHog : public CHogger
{
public:
	//
	// does not hog Resources yet.
	//
	CRegistryHog(
		const DWORD dwMaxFreeResources, 
		const DWORD dwSleepTimeAfterFullHog = 1000, 
		const DWORD dwSleepTimeAfterFreeingSome = 1000
		);

	~CRegistryHog(void);

protected:
	virtual void FreeAll(void);

	virtual bool HogAll(void);
	virtual bool FreeSome(void);

private:
	bool IsEmptyKey(const TCHAR * const szSubKey);
	void Initialize();

	HKEY m_hkeyParams;
	TCHAR *m_szRegistryData;
	TCHAR m_szRegistryDataToWrite[MAX_REG_SET_SIZE+1];
	TCHAR m_szReadRegistryData[MAX_REG_SET_SIZE+1];
	DWORD m_dwTotalAllocatedRegistry;


};

#endif //__REGISTRY_HOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\remotememhog.cpp ===
//
// this class is used for hogging Resources.
// it differs from simple hogging by dynamically
// hogging all Resources and then releasing some.
// the level of free Resources can be controlled.
//

//#define HOGGER_LOGGING

#include "RemoteMemHog.h"


//
// lookup table for calculating powers of 10
//
const long CRemoteMemHog::m_lPowerOfTen[10] =
{
	1,
	10,
	1000,
	10000,
	100000,
	1000000,
	10000000,
	100000000,
	1000000000,
	1000000000 //intentional missing zero: too big for a long type.
};

//
// the process that we will allocate in.
//
const TCHAR* CRemoteMemHog::sm_szProcess = TEXT("RemoteThreadProcess.exe");

CRemoteMemHog::CRemoteMemHog(
	const DWORD dwMaxFreeResources, 
	const DWORD dwSleepTimeAfterFullHog,
	const DWORD dwSleepTimeAfterReleasing,
    const bool fRemote
	)
	:
	CHogger(dwMaxFreeResources, dwSleepTimeAfterFullHog, dwSleepTimeAfterReleasing),
    m_fRemote(fRemote)
{
    if (m_fRemote)
    {
        //
        // create the remote process
        //
        ::memset(&m_si, 0, sizeof(m_si));
	    m_si.cb = sizeof(m_si);
	    m_si.lpReserved = NULL; 
        m_si.lpDesktop = NULL;     
	    m_si.lpTitle = NULL;     
	    //DWORD   dwX;     
	    //DWORD   dwY; 
        //DWORD   dwXSize;     
	    //DWORD   dwYSize;     
	    //DWORD   dwXCountChars; 
        //DWORD   dwYCountChars;     
	    //DWORD   dwFillAttribute;     
	    m_si.dwFlags = 0; 
        //WORD    wShowWindow;     
	    m_si.cbReserved2 = 0;     
	    m_si.lpReserved2 = NULL; 
        m_si.hStdInput = NULL;     
	    //m_si.hStdOutput = hWritePipe;     
	    //m_si.hStdError = hWritePipe; 

	    //PROCESS_INFORMATION pi;
        //HANDLE hProcess;
        //HANDLE hThread;
        //DWORD dwProcessId;
        //DWORD dwThreadId;

	    if (!::CreateProcess(  
			    NULL,// pointer to name of executable module
			    (TCHAR*)sm_szProcess,  // pointer to command line string
			    NULL,// pointer to process security attributes
			    NULL,// pointer to thread security attributes
			    true,  // handle inheritance flag
			    0, // creation flags
			    NULL,  // pointer to new environment block
			    NULL, // pointer to current directory name
			    &m_si,// pointer to STARTUPINFO
			    &m_pi  // pointer to PROCESS_INFORMATION
			    )
		    )
	    {
		    HOGGERDPF(("CRemoteMemHog, CreateProcess(%s): failed with %d.\n", sm_szProcess, ::GetLastError()));

		    throw CException(
			    TEXT("CRemoteMemHog(): CreateProcess(%s) failed with %d"), 
			    sm_szProcess,
                ::GetLastError()
			    );
	    }
	    _ASSERTE_(NULL != m_pi.hProcess);
	    _ASSERTE_(NULL != m_pi.hThread);
    }
    else //if (m_fRemote)
    {
        m_pi.hProcess = ::GetCurrentProcess();
    }

    //
	// initialize hogger array
	//
	for (int iPowerOfTen = 0 ; iPowerOfTen < 10; iPowerOfTen++)
	{
		for (int j = 0 ; j < 10; j++)
		{
			m_apcHogger[iPowerOfTen][j] = NULL;
		}
	}
}

CRemoteMemHog::~CRemoteMemHog(void)
{
    HaltHoggingAndFreeAll();

    if (m_fRemote)
    {
        if (!TerminateProcess(m_pi.hProcess, 0))
        {
		    HOGGERDPF(("CRemoteMemHog::~CRemoteMemHog(): TerminateProcess(): failed with %d.\n", ::GetLastError()));
        }

        ::CloseHandle(m_pi.hProcess);
        ::CloseHandle(m_pi.hThread);
    }
}

void CRemoteMemHog::FreeAll(void)
{
	HOGGERDPF(("CRemoteMemHog::FreeAll(): before freeing all.\n"));
	
	for (int i = 0 ; i < 10; i++)
	{
		for (int j = 0 ; j < 10; j++)
		{
            if ((NULL != m_apcHogger[i][j]) && !::VirtualFreeEx(
                        m_pi.hProcess,  // process within which to free memory
                        m_apcHogger[i][j], // starting address of memory region to free
                        0,     // size, in bytes, of memory region to free
                        MEM_RELEASE // type of free operation
                    )
               )
            {
                HOGGERDPF(("CRemoteMemHog::FreeAll(): VirtualFreeEx() failed with %d. m_apcHogger[i][j]=0x%08X\n", ::GetLastError(), m_apcHogger[i][j]));
            }
			m_apcHogger[i][j] = NULL;
		}	
	}
	HOGGERDPF(("CRemoteMemHog::FreeAll(): out of FreeAll().\n"));
}

//
// algorithm:
//  try allocate 10^9 bytes, up to 10 allocations.
//  then try to allocate 10^8 bytes, up to 10 allocations.
//  then try to allocate 10^7 bytes, up to 10 allocations.
//  ...
//  then try to allocate 10^0 bytes, up to 10 allocations.
//  now all memory is hogged (up to 20*10^9 =~ 20GBytes...)
//
bool CRemoteMemHog::HogAll(void)
{
	static DWORD s_dwHogged = 0;

	for (	int iPowerOfTen = 9 ; 
			iPowerOfTen >= 0; 
			iPowerOfTen--
		)
	{
		//HOGGERDPF(("iPowerOfTen=%d.\n", iPowerOfTen));
		for (	int j = 0 ; 
				j < 10; 
				j++
			)
		{
			//
			// always be ready to abort
			//
			if (m_fAbort)
			{
	            HOGGERDPF(("CRemoteMemHog::HogAll(): got m_fAbort.\n"));
				return false;
			}

			if (m_fHaltHogging)
			{
	            HOGGERDPF(("CRemoteMemHog::HogAll(): got m_fHaltHogging.\n"));
				return true;
			}

			//
			// skip already allocated pointers
			//
			if (NULL != m_apcHogger[iPowerOfTen][j])
			{
				continue;
			}
			
			//
			// break if fail to allocate, so lesser amounts will be allocated
			//
            DWORD dwProtect =   (0 == rand()%6) ? PAGE_NOACCESS :
                                (0 == rand()%5) ? PAGE_READONLY :
                                (0 == rand()%4) ? PAGE_READWRITE :
                                (0 == rand()%3) ? PAGE_EXECUTE :
                                (0 == rand()%2) ? PAGE_EXECUTE_READ :
                                PAGE_EXECUTE_READWRITE;
			if (NULL == (m_apcHogger[iPowerOfTen][j] = 
                    (char*)::VirtualAllocEx(
                        m_pi.hProcess, // process within which to allocate memory
                        NULL,// desired starting address of allocation
                        m_lPowerOfTen[iPowerOfTen], // size, in bytes, of region to allocate
                        MEM_COMMIT, // type of allocation
                        dwProtect // type of access protection PAGE_READONLY
                        )
                        )
               )
			{
                HOGGERDPF(("CRemoteMemHog::HogAll(): VirtualAllocEx(dwProtect=0x%08X) failed with %d.\n", dwProtect, ::GetLastError()));
				break;
			}

			HOGGERDPF(("allocated %d bytes.\n", m_lPowerOfTen[iPowerOfTen]));
			s_dwHogged += m_lPowerOfTen[iPowerOfTen];
		}//for (j = 0 ; j < 10; j++)
	}//for (int iPowerOfTen = 9 ; iPowerOfTen >= 0; iPowerOfTen--)

	HOGGERDPF(("CRemoteMemHog::HogAll(): Hogged %d bytes.\n", s_dwHogged));

	return true;
}


bool CRemoteMemHog::FreeSome(void)
{
		//
		// free blocks, from small(10^0) to large(10^9), until freeing at least m_dwMaxFreeMem bytes
		//
		DWORD dwFreed = 0;

		//
		// take care of RANDOM_AMOUNT_OF_FREE_RESOURCES case
		// will free all memory if m_dwMaxFreeResources > actually allocated
		//
		DWORD dwMaxFreeMem = 
			(RANDOM_AMOUNT_OF_FREE_RESOURCES == m_dwMaxFreeResources) ?
			rand() && (rand()<<16) :
			m_dwMaxFreeResources;

		HOGGERDPF(("CRemoteMemHog::FreeSome(): before free cycle.\n"));
		for (int i = 0; i < 10; i++)
		{
			for (int j = 0; j < 10; j++)
			{
				if (m_apcHogger[i][j])
				{
                    if (!::VirtualFreeEx(
                                m_pi.hProcess,  // process within which to free memory
                                m_apcHogger[i][j], // starting address of memory region to free
                                0,     // size, in bytes, of memory region to free
                                MEM_RELEASE // type of free operation
                            )
                       )
                    {
                        HOGGERDPF(("CRemoteMemHog::FreeSome(): VirtualFreeEx() failed with %d.\n", ::GetLastError()));
                    }
					m_apcHogger[i][j] = NULL;
					dwFreed += m_lPowerOfTen[i];
					//HOGGERDPF(("freed %d bytes.\n", m_lPowerOfTen[i]));
				}

				if (dwFreed >= dwMaxFreeMem)
				{
					break;
				}
			}
			if (dwFreed >= dwMaxFreeMem)
			{
				break;
			}
		}//for (int i = 0; i < 10; i++)
		HOGGERDPF(("CRemoteMemHog::FreeSome(): Freed %d bytes.\n", dwFreed));

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\nothing\main.c ===
#include <windows.h>

void MyMain()
{
#ifdef __HANDLE_AV
	try
	{
#endif
#ifdef __CAUSE_AV
	char *p = NULL;
	*p = 3;//AV!
#endif //__CAUSE_AV
#ifdef __HANDLE_AV
	}
	catch(...)
	{
		;
	}
#endif
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\memhog\memhog.cpp ===
//
// this class is used for hogging memory.
// it differs from simple hogging by dynamically
// hogging all memory and then releasing some.
// the level of free memory can be controlled.
//

#include "MemHog.h"


static bool s_fLogging = true;
#define MEMHOGDPF(x) if (s_fLogging) printf x
//
// lookup table for calculating powers of 10
//
const long CMemHog::m_lPowerOfTen[10] =
{
	1,
	10,
	1000,
	10000,
	100000,
	1000000,
	10000000,
	100000000,
	1000000000,
	1000000000 //intentional missing zero
};


//
// HoggerThread()
// algorithm:
//   allocate 10^9 bytes until i fail.
//   allocate 10^8 bytes until i fail.
//   ...
//   allocate 10^1 bytes until i fail.
//   allocate 10^0 bytes until i fail.
//
//   move to fre cycle - free m_dwMaxFreeMem amount of bytes, and repeat the process
//
//   the thread can be aborted, halted, and started.
//   abort - exit from the thread.
//   halt - after releasing m_dwMaxFreeMem bytes, do not resume to allocating new handles.
//          but wait for the start.
//   start - start the hog-release cycle.
//
//   return value - not used, always TRUE.
//
static DWORD WINAPI HoggerThread(void *pVoid)
{
	_ASSERTE(pVoid);

	//
	// get the this pointer of this object
	//
	CMemHog *pThis = (CMemHog*)pVoid;

	DWORD dwHogged = 0;

	//
	// continuously loop untill aborted
	//
	while(!pThis->m_fAbort)
	{
		//
		// wait for signal to start.
		// I use polling because I do not want to rely on any
		// thing fancy in low resources state.
		// note that we should be ready for a m_fHaltHogging signal too.
		//
		while (!pThis->m_fStartHogging)
		{
			if (s_fLogging) Sleep(1000);
			MEMHOGDPF(("wait for (!pThis->m_fStartHogging).\n"));
			//
			// always be ready to abort
			//
			if (pThis->m_fAbort)
			{
				goto out;
			}
			
			//
			// if halted mark as halted
			//
			pThis->HandleHaltHogging();

			Sleep(1);
		}
		MEMHOGDPF(("received m_fStartHogging).\n"));
		//
		// started, mark as started
		//
		::InterlockedExchange(&pThis->m_fStartedHogging, TRUE);
		::InterlockedExchange(&pThis->m_fHaltedHogging, FALSE);


		//
		// hog until halted, or out of memory
		//

		//
		// allocate from the maximum amount to the minimum amount
		// in short: hog all memory!
		//
		MEMHOGDPF(("Before hog cycle.\n"));

		for (	int iPowerOfTen = 9 ; 
				iPowerOfTen >= 0 && !pThis->m_fHaltHogging; 
				iPowerOfTen--
			)
		{
			//MEMHOGDPF(("iPowerOfTen=%d.\n", iPowerOfTen));
			for (	int j = 0 ; 
					j < 10 && !pThis->m_fHaltHogging; 
					j++
				)
			{
				//
				// always be ready to abort
				//
				if (pThis->m_fAbort)
				{
					goto out;
				}

				//
				// skip already allocated pointers
				//
				if (NULL != pThis->m_apcHogger[iPowerOfTen][j])
				{
					continue;
				}
				
				//
				// break if fail to allocate, so lesser amounts will be allocated
				//
				if (pThis->m_apcHogger[iPowerOfTen][j] = (char*)malloc(pThis->m_lPowerOfTen[iPowerOfTen]))
				{
					//
					// once in a while actually use the memory!
					//
					if (false /*0 == rand() % 100*/)
					{
						memset(pThis->m_apcHogger[iPowerOfTen][j], rand(), pThis->m_lPowerOfTen[iPowerOfTen]);
					}

					//
					// let other processes a chance to do something
					//
					for (int nGiveUpCpuQuantum = 0; nGiveUpCpuQuantum < rand()%100; nGiveUpCpuQuantum++)
					{
						Sleep(0);
					}
					//MEMHOGDPF(("allocated %d bytes.\n", pThis->m_lPowerOfTen[iPowerOfTen]));
					dwHogged += pThis->m_lPowerOfTen[iPowerOfTen];
				}//if (pThis->m_apcHogger[iPowerOfTen][j] = (char*)malloc(pThis->m_lPowerOfTen[iPowerOfTen]))
			}//for (j = 0 ; j < 10; j++)
		}//for (int iPowerOfTen = 9 ; iPowerOfTen >= 0; iPowerOfTen--)

		MEMHOGDPF(("Hogged %d bytes.\n", dwHogged));

		//
		// if halted mark as halted
		//
		pThis->HandleHaltHogging();

		Sleep(pThis->m_dwSleepTimeAfterFullHog);

		//
		// free blocks, from small to large, until freeing at least pThis->m_dwMaxFreeMem bytes
		//
		DWORD dwFreed = 0;

		//
		// take care of RANDOM_AMOUNT_OF_FREE_MEM case
		//
		DWORD dwMaxFreeMem = 
			(RANDOM_AMOUNT_OF_FREE_MEM == pThis->m_dwMaxFreeMem) ?
			rand() && (rand()<<16) :
			pThis->m_dwMaxFreeMem;

		MEMHOGDPF(("before free cycle.\n"));
		for (int i = 0; i < 10; i++)
		{
			for (int j = 0; j < 10; j++)
			{
				if (pThis->m_apcHogger[i][j])
				{
					free(pThis->m_apcHogger[i][j]);
					pThis->m_apcHogger[i][j] = NULL;
					dwFreed += pThis->m_lPowerOfTen[i];
					//MEMHOGDPF(("freed %d bytes.\n", pThis->m_lPowerOfTen[i]));
				}

				if (dwFreed >= dwMaxFreeMem)
				{
					break;
				}
			}
			if (dwFreed >= dwMaxFreeMem)
			{
				break;
			}
		}//for (int i = 0; i < 10; i++)
		MEMHOGDPF(("Freed %d bytes.\n", dwFreed));

		if (!SetProcessWorkingSetSize(GetCurrentProcess(), -1, -1))
		{
			MEMHOGDPF(("SetProcessWorkingSetSize(-1, -1) failed with %d. Out of memory?\n", GetLastError()));
		}

		Sleep(pThis->m_dwSleepTimeAfterReleasing);

	}//while(!pThis->m_fAbort)

out:
	//
	// i was aborted so mark this thread as aborted
	//
	::InterlockedExchange(&pThis->m_fAbort, FALSE);

	return TRUE;
}//static DWORD WINAPI HoggerThread(void *pVoid)


CMemHog::CMemHog(
	const DWORD dwMaxFreeMem, 
	const DWORD dwSleepTimeAfterFullHog, 
	const DWORD dwSleepTimeAfterReleasing
	):
	m_dwMaxFreeMem(dwMaxFreeMem),
	m_fAbort(false),
	m_fStartHogging(false),
	m_fHaltHogging(false),
	m_dwSleepTimeAfterFullHog(dwSleepTimeAfterFullHog),
	m_dwSleepTimeAfterReleasing(dwSleepTimeAfterReleasing)
{
	//m_pEscapeOxigen = (char*)malloc(1000*1000);

	//if (! m_pEscapeOxigen)
	//{
	//	throw CException(
	//		"CMemHog(): malloc(m_pEscapeOxigen) failed with %d",
	//		GetLastError()
	//		);
	//}

	//
	// initialize hogger array
	//
	for (int iPowerOfTen = 0 ; iPowerOfTen < 10; iPowerOfTen++)
	{
		for (int j = 0 ; j < 10; j++)
		{
			m_apcHogger[iPowerOfTen][j] = NULL;
		}
	}

	//
	// create the hogging thread
	//
	DWORD dwThreadId;
	m_hthHogger = CreateThread(
		NULL,// pointer to thread security attributes 
		0,// initial thread stack size, in bytes 
		HoggerThread,// pointer to thread function 
		this,// argument for new thread 
		0,// creation flags 
		&dwThreadId// pointer to returned thread identifier 
		);
	if (NULL == m_hthHogger)
	{
		//
		//BUGBUG: memory leak - must free what was allocated!
		//
		throw CException(
			"CMemHog(): CreateThread(HoggerThread) failed with %d", 
			GetLastError()
			);
	}

}

CMemHog::~CMemHog(void)
{
	FreeMem();

	//free(m_pEscapeOxigen);

	if (NULL != m_hthHogger)
	{
		CloseHoggerThread();
	}

}

void CMemHog::FreeMem(void)
{
	HaltHogging();

	//
	// close all open handles
	//
	MEMHOGDPF(("before freeing all.\n"));
	for (int i = 0 ; i < 10; i++)
	{
		for (int j = 0 ; j < 10; j++)
		{
			free(m_apcHogger[i][j]);	
			m_apcHogger[i][j] = NULL;
		}	
	}
	MEMHOGDPF(("out of FreeMem().\n"));
}

void CMemHog::CloseHoggerThread(void)
{

	AbortHoggingThread();

	if (!CloseHandle(m_hthHogger))
	{
		throw CException(
			"CloseHoggerThread(): CloseHandle(m_hthHogger) failed with %d", 
			GetLastError()
			);
	}
}


//
// polling is used because we are probably out of resources
//
void CMemHog::StartHogging(void)
{
	::InterlockedExchange(&m_fStartedHogging, FALSE);
	::InterlockedExchange(&m_fHaltHogging, FALSE);
	::InterlockedExchange(&m_fStartHogging, TRUE);

	//
	// m_fStartedHogging will become false as soon as the thread acks
	//
	MEMHOGDPF(("waiting for !m_fStartedHogging.\n"));
	while(!m_fStartedHogging)
	{
		Sleep(1);
	}
	::InterlockedExchange(&m_fStartedHogging, FALSE);
}

//
// polling is used because we are probably out of resources
//
void CMemHog::HaltHogging(void)
{
	::InterlockedExchange(&m_fHaltedHogging, FALSE);
	::InterlockedExchange(&m_fStartHogging, FALSE);
	::InterlockedExchange(&m_fHaltHogging, TRUE);

	//
	// m_fHaltedHogging will become false as soon as the thread halts
	//
	MEMHOGDPF(("HaltHogging(): before while(!m_fHaltedHogging).\n"));
	while(!m_fHaltedHogging)
	{
		Sleep(1);
	}
	::InterlockedExchange(&m_fHaltedHogging, FALSE);
	::InterlockedExchange(&m_fHaltHogging, FALSE);

	MEMHOGDPF(("out of HaltHogging().\n"));
}


//
// polling is used because we are probably out of resources
//
void CMemHog::AbortHoggingThread(void)
{
	//
	// sognal thread to abort
	//
	::InterlockedExchange(&m_fAbort, TRUE);

	//
	// wait for thread to confirm
	//
	MEMHOGDPF(("waiting for m_fAbort.\n"));
	while(m_fAbort)
	{
		Sleep(1);
	}
}


void CMemHog::SetMaxFreeMem(const DWORD dwMaxFreeMem)
{
	m_dwMaxFreeMem = dwMaxFreeMem;
}


void CMemHog::HandleHaltHogging()
{
	if (m_fHaltHogging)
	{
		MEMHOGDPF(("HandleHaltHogging(): m_fHaltHogging.\n"));
		//
		// mark that i halted hogging
		//
		::InterlockedExchange(&m_fHaltedHogging, TRUE);
		MEMHOGDPF(("HandleHaltHogging(): before while(m_fHaltedHogging).\n"));
		//
		// wait for signaller to confirm
		//
		while(m_fHaltedHogging)
		{
			Sleep(1);
		}
		MEMHOGDPF(("HandleHaltHogging(): after while(m_fHaltedHogging).\n"));
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\memhog\memhog.h ===
#ifndef __MEMHOG_H
#define __MEMHOG_H

//
// this class is used for hogging memory.
// it differs from simple hogging by dynamically
// hogging all handles and then releasing some.
// the level of free memory can be controlled.
//


#include <windows.h>
#include <stdio.h>
#include <crtdbg.h>

#include "..\exception\exception.h"

#define RANDOM_AMOUNT_OF_FREE_MEM (-1)

class CMemHog
{
public:
	//
	// does not hog mem yet.
	//
	CMemHog(
		const DWORD dwMaxFreeMem, 
		const DWORD dwSleepTimeAfterFullHog = 1000, 
		const DWORD dwSleepTimeAfterReleasing = 10000
		);
	~CMemHog(void);

	//
	// start hogging mem, leaving amount set by ctor or by SetFreeMem()
	//
	void StartHogging(void);

	//
	// halts hogging, i.e. memory is not freed, but the cycle of free-hog is halted
	//
	void HaltHogging(void);

	//
	// free mem, and stop the cycle of free-hog
	//
	void FreeMem(void);

	//
	// set the amout of memory to leave un-allocated.
	// this methid can be called while hogging.
	//
	void SetMaxFreeMem(const DWORD dwMaxFreeMem);

	void SetSleepTimeAfterFullHog(const DWORD dwSleepTimeAfterFullHog)
	{
		m_dwSleepTimeAfterFullHog = dwSleepTimeAfterFullHog;
	}

	void SetSleepTimeAfterReleasing(const DWORD dwSleepTimeAfterReleasing)
	{
		m_dwSleepTimeAfterReleasing = dwSleepTimeAfterReleasing;
	}


private:
	//
	// the thread that acually hogs memory
	//
	static friend DWORD WINAPI HoggerThread(void *pVoid);

	//
	// stop the hogging thread, and wait for the thread to finish
	//
	void AbortHoggingThread(void);

	void HandleHaltHogging();

	//
	// signal the hogger thread to abort, wait for it
	// to abort, and close the thread's handle
	//
	void CloseHoggerThread(void);

	//
	// bi-dir signal to the hooging thread
	//
	long m_fStartHogging;

	//
	// bi-dir signal to the hooging thread
	//
	long m_fStartedHogging;

	//
	// bi-dir signal to the hooging thread
	//
	long m_fHaltHogging;

	//
	// bi-dir signal to the hooging thread
	//
	long m_fHaltedHogging;

	//
	// bi-dir signal to the hooging thread
	//
	long m_fAbort;

	DWORD m_dwSleepTimeAfterFullHog;

	DWORD m_dwSleepTimeAfterReleasing;

	//
	// for each handle type we have NUM_OF_HANDLES_IN_ARRAY place-holders
	// this is a huge array. it may cause stack overflow!
	//
	char *m_apcHogger[10][10];
	//char *m_pEscapeOxigen;
	static const long m_lPowerOfTen[10];

	//
	// handle to the hogger thread
	//
	HANDLE m_hthHogger;

	//
	// the number of handles we should close after
	// hogging all handles.
	//
	DWORD m_dwMaxFreeMem;

};

#endif //__MEMHOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\remotethreadprocess\main.cpp ===
#include <windows.h>
#include <stdio.h>

DWORD WINAPI SuspendedThread(void *pVoid)
{
    //MessageBox(GetFocus(), "I am a suspended thread!", "remote process", MB_OK);
    return 0;
}
int main()
{
    char szBuff[64];
    sprintf(szBuff, "%08d", SuspendedThread);
    ::fprintf(stdout, szBuff, SuspendedThread);
    ::fflush(stdout);
    //MessageBox(GetFocus(), szBuff, "remote", MB_OK);
    ::Sleep(INFINITE);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\hoggers\usenetwork\main.cpp ===
/*
    This is a simple single threaded command line utility that was initially
    developed to simply stress the network a bit.
    Today, it was somewhat expanded, still, network operations are performed.
    See usage in main().
    The program does each of the following randomly, and it does not care if
    any of them fail:
    - copy a local file to a remote share (only if file was not already created there)
    - delete the same file from the share (only if file was not already created there)
    - create a file on the remote share (only if file was not already created there)
    - write a buff to the remote file (only if file was already created)
    - read a buff from the remote file (only if file was already created)
    - cancel IO (effective only if above are pending) (only if file was already created)
    - close the remote file handle, thus deleting it (only if file was already created)

    Important Note: due to a possible bug (in NT?), file may remain inaccessible in the share,
        thus we cannot re create it, so we generate a new filename to work with.
        This will leave files on the remote share that cannot be deleted!
        Use "net file <id> /close" to close those files, and then delete them.



*/
#include <windows.h>
#include <time.h>
#include <TCHAR.h>
#include <stdio.h>
#include <crtdbg.h>

//
// read&write buffs
#define BUFF_SIZE (10*1024*1024)

//
// Handler_Routine flag to mark shutdown
// remember that we need to close the file handels in order to delete them.
//
bool g_fExit = false;

BOOL WINAPI Handler_Routine(DWORD dwCtrlType)
{
    g_fExit = true;
	return true;
}

//
// set random local and remote filenames
//
void SetRandomFileNames(TCHAR *szShare, TCHAR *szFileName, TCHAR *szRemoteFileName)
{
    _stprintf(szFileName, TEXT("deleteme.0x%08X.tmp"), ::GetTickCount());

    _stprintf(
        szRemoteFileName, 
        TEXT("%s\\%s"), 
        szShare, 
        szFileName
        );
}

DWORD GetRandomAmountToReadWrite()
{
    WORD wLowPart = rand();
    WORD wHighPart = rand();

    //
    // we want less probability of huge buffs
    //
    if (rand()%10 != 0)
    {
        wHighPart >> (rand()%16);
    }

    DWORD dwRet = ((wHighPart << 16) | wLowPart) % BUFF_SIZE;

    return dwRet;
}

int main(int argc, char *ArgvA[])
{
    int nSeed;
	LPTSTR *szArgv;
#ifdef UNICODE
	szArgv = CommandLineToArgvW( GetCommandLine(), &argc );
#else
	szArgv = argvA;
#endif

    if (argc != 2)
    {
        _tprintf(TEXT("Usage: %s <netpath>\n"), szArgv[0]);
        _tprintf(TEXT("Example: %s \\\\mickys001\\public\n"), szArgv[0]);
        _tprintf(TEXT("The generated file(s) are of type deleteme.*.tmp\n"));
        return -1;
    }

    if (argc == 3)
    {
        nSeed = _ttoi(szArgv[2]);
        _tprintf(TEXT("seed is %d (from command line)\n"), nSeed);
    }
    else
    {
        nSeed = (unsigned)time( NULL );
        _tprintf(TEXT("seed is %d (time)\n"), nSeed);
    }
    srand(nSeed);



    if (! ::SetConsoleCtrlHandler(
			  Handler_Routine,  // address of handler function
			  true                          // handler to add or remove
			  ))
	{
		_tprintf(TEXT("SetConsoleCtrlHandler() failed with %d.\n"),GetLastError());
		exit(1);
	}

    //////////////////////////////////////////////////////////
    // prepare all that's needed for read & write operations.
    //////////////////////////////////////////////////////////
    BYTE *pReadBuff = new BYTE[BUFF_SIZE];
    if (NULL == pReadBuff)
    {
		_tprintf(TEXT("new BYTE[BUFF_SIZE] failed with %d.\n"),GetLastError());
		exit(1);
    }

    BYTE *pWriteBuff = new BYTE[BUFF_SIZE];
    if (NULL == pWriteBuff)
    {
		_tprintf(TEXT("new BYTE[BUFF_SIZE] failed with %d.\n"),GetLastError());
		exit(1);
    }

    //
    // fill random write buffer
    //
    for (int i = 0; i < sizeof(pWriteBuff); i++)
    {
        pWriteBuff[i] = 0xFF & rand();
    }

    OVERLAPPED olWrite;
    OVERLAPPED olRead;
    olWrite.OffsetHigh = olWrite.Offset = 0;
    olRead.OffsetHigh = olRead.Offset = 0;
    olWrite.hEvent = CreateEvent(
        NULL, // address of security attributes
        TRUE, // flag for manual-reset event
        FALSE,// flag for initial state
        NULL  // address of event-object name
        );
    if (NULL == olWrite.hEvent)
    {
        _tprintf(TEXT("CreateEvent(olWrite.hEvent) failed with %d\n"), GetLastError());
		exit(1);
    }
    olRead.hEvent = CreateEvent(
        NULL, // address of security attributes
        TRUE, // flag for manual-reset event
        FALSE,// flag for initial state
        NULL  // address of event-object name
        );
    if (NULL == olRead.hEvent)
    {
        _tprintf(TEXT("CreateEvent(olRead.hEvent) failed with %d\n"), GetLastError());
		exit(1);
    }

    //
    // prepare filenames, and create the local file
    //
    TCHAR szFileName[1024];
    TCHAR szRemoteFileName[1024];
    SetRandomFileNames(szArgv[1], szFileName, szRemoteFileName);

    HANDLE hDeleteOnCloseTempFileToCopy;
    hDeleteOnCloseTempFileToCopy = CreateFile(
        szFileName,
        GENERIC_READ | GENERIC_WRITE,       // access (read-write) mode
        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,           // share mode
        NULL,                        // pointer to security attributes
        OPEN_ALWAYS,  // how to create
        FILE_FLAG_DELETE_ON_CLOSE,  // file attributes
        NULL         // handle to file with attributes to copy
        );
    if(INVALID_HANDLE_VALUE == hDeleteOnCloseTempFileToCopy)
    {
        _tprintf(TEXT("CreateFile(%s) failed with %d\n"), szFileName, ::GetLastError());
        return -1;
    }

    //////////////////////////////////////////////////////////
    // here we go to a loop until the program is aborted
    //////////////////////////////////////////////////////////

    HANDLE hDeleteOnCloseRemoteFile = INVALID_HANDLE_VALUE;
    DWORD dwAmoutToReadWrite;
    while(!g_fExit)
    {
        switch(rand()%30)
        {
        case 0://copy file to share
            if (INVALID_HANDLE_VALUE == hDeleteOnCloseRemoteFile)
            {
                if (!CopyFile(
                        szFileName,
                        szRemoteFileName,
                        false
                    ))
                {
                    _tprintf(TEXT("CopyFile(%s, %s) failed with %d\n"), szFileName, szRemoteFileName, ::GetLastError());
                }
                else
                {
                    _tprintf(TEXT("CopyFile(%s, %s) succeeded\n"), szFileName, szRemoteFileName);
                }
            }

            break;

        case 1://delete file from share
            if (INVALID_HANDLE_VALUE == hDeleteOnCloseRemoteFile)
            {
                if (!DeleteFile(
                        szRemoteFileName
                    ))
                {
                    _tprintf(TEXT("DeleteFile(%s) failed with %d\n"), szRemoteFileName, ::GetLastError());
                }
                else
                {
                    _tprintf(TEXT("DeleteFile(%s) succeeded\n"), szRemoteFileName);
                }
            }

            break;

        case 2://create file on share
            if (INVALID_HANDLE_VALUE == hDeleteOnCloseRemoteFile)
            {
                hDeleteOnCloseRemoteFile = CreateFile(
                    szRemoteFileName,
                    GENERIC_READ | GENERIC_WRITE,       // access (read-write) mode
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,           // share mode
                    NULL,                        // pointer to security attributes
                    OPEN_ALWAYS,  // how to create
                    FILE_FLAG_OVERLAPPED | FILE_FLAG_DELETE_ON_CLOSE,  // file attributes
                    NULL         // handle to file with attributes to copy
                    );
                if(INVALID_HANDLE_VALUE == hDeleteOnCloseRemoteFile)
                {
                    DWORD dwLastError = ::GetLastError();
                    if (ERROR_ACCESS_DENIED == dwLastError)
                    {
                        //
                        // BUGBUG, probably in NT, that the file on the share bocomes a zombie.
                        // so lets try another filname.
                        //
                        _tprintf(TEXT("CreateFile(%s) failed with ERROR_ACCESS_DENIED, will try a new filename\n"), szRemoteFileName);
                        SetRandomFileNames(szArgv[1], szFileName, szRemoteFileName);
                    }
                    else
                    {
                        _tprintf(TEXT("CreateFile(%s) failed with %d\n"), szRemoteFileName, dwLastError);
                    }
                }
                else
                {
                    _tprintf(TEXT("CreateFile(%s) succeeded\n"), szRemoteFileName);
                }
            }

            break;

        case 3://close file on share
            if (INVALID_HANDLE_VALUE != hDeleteOnCloseRemoteFile)
            {
                if (!CloseHandle(hDeleteOnCloseRemoteFile))
                {
                    _tprintf(TEXT("CloseHandle(%s) failed with %d\n"), szRemoteFileName, ::GetLastError());
                }
                else
                {
                    _tprintf(TEXT("CloseHandle(%s) succeeded\n"), szRemoteFileName);
                }
                hDeleteOnCloseRemoteFile = INVALID_HANDLE_VALUE;
            }

        //
        // my silly way of having more probability of this case
        //
        case 4://write to file on share
        case 5://write to file on share
        case 6://write to file on share
        case 7://write to file on share
        case 8://write to file on share
        case 9://write to file on share
        case 10://write to file on share
        case 11://write to file on share
        case 12://write to file on share
        case 13://write to file on share
            if (INVALID_HANDLE_VALUE != hDeleteOnCloseRemoteFile)
            {
                dwAmoutToReadWrite = GetRandomAmountToReadWrite();
                DWORD dwWritten;
                if (!WriteFile(
                        hDeleteOnCloseRemoteFile,
                        pWriteBuff,
                        dwAmoutToReadWrite,
                        &dwWritten,
                        &olWrite
                    ))
                {
                    _tprintf(TEXT("WriteFile(%s) failed to write %d bytes with %d\n"), szRemoteFileName, dwAmoutToReadWrite, ::GetLastError());
                }
                else
                {
                    _tprintf(TEXT("WriteFile(%s) succeeded to write %d bytes\n"), szRemoteFileName, dwAmoutToReadWrite);
                }
            }

            break;

        //
        // my silly way of having more probability of this case
        //
        case 14://read from file on share
        case 15://read from file on share
        case 16://read from file on share
        case 17://read from file on share
        case 18://read from file on share
        case 19://read from file on share
        case 20://read from file on share
        case 21://read from file on share
        case 22://read from file on share
        case 23://read from file on share
        case 24://read from file on share
        case 25://read from file on share
            if (INVALID_HANDLE_VALUE != hDeleteOnCloseRemoteFile)
            {
                dwAmoutToReadWrite = GetRandomAmountToReadWrite();
                DWORD dwRead;
                if (!ReadFile(
                        hDeleteOnCloseRemoteFile,
                        pReadBuff,
                        dwAmoutToReadWrite,
                        &dwRead,
                        &olRead
                    ))
                {
                    _tprintf(TEXT("ReadFile(%s) failed to write %d bytes with %d\n"), szRemoteFileName, dwAmoutToReadWrite, ::GetLastError());
                }
                else
                {
                    _tprintf(TEXT("ReadFile(%s) succeeded to write %d bytes\n"), szRemoteFileName, dwAmoutToReadWrite);
                }
            }

            break;

        case 26://cancel IO of file on share
        case 27://cancel IO of file on share
        case 28://cancel IO of file on share
        case 29://cancel IO of file on share
            if (INVALID_HANDLE_VALUE != hDeleteOnCloseRemoteFile)
            {
                if (!CancelIo(hDeleteOnCloseRemoteFile))
                {
                    _tprintf(TEXT("CancelIo(hDeleteOnCloseRemoteFile) failed with %d\n"), ::GetLastError());
                }
                else
                {
                    _tprintf(TEXT("CancelIo(hDeleteOnCloseRemoteFile) succeeded\n"));
                }
            }

            break;

        default:
            _ASSERTE(FALSE);
        }//switch(rand()%30)

    }//while(!g_fExit)

    //
    // cleanup of files (no real need to free memory, since the process exits).
    // well, actually the same with file handles, but lets do it anyway.
    //
    if (INVALID_HANDLE_VALUE != hDeleteOnCloseRemoteFile)
    {
        if (!CloseHandle(hDeleteOnCloseRemoteFile))
        {
            _tprintf(TEXT("CloseHandle(hDeleteOnCloseRemoteFile) failed with %d\n"), ::GetLastError());
        }
    }

    if (!CloseHandle(hDeleteOnCloseTempFileToCopy))
    {
        _tprintf(TEXT("CloseHandle(hDeleteOnCloseTempFileToCopy) failed with %d\n"), ::GetLastError());
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\aborttest\dummyfaxcompport.cpp ===
#include "..\..\..\..\FaxBVT\FaxSender\FaxCompPort.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\aborttest\dummyfaxbroadcast.cpp ===
#include "..\..\..\..\FaxBVT\FaxSender\FaxBroadCast.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\aborttest\dummycometfax.cpp ===
#include "..\..\..\..\FaxBVT\FaxSender\CometFax.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\aborttest\dummyfaxeventex.cpp ===
#include "..\..\..\..\FaxBVT\FaxSender\FaxEventEx.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\aborttest\dummyfaxsender.cpp ===
#include "..\..\..\..\FaxBVT\FaxSender\FaxSender.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\aborttest\dummywcsutil.cpp ===
#include "..\..\..\..\FaxBVT\FaxSender\Wcsutil.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\aborttest\dummylogelle.cpp ===
#include "..\..\UTIL\General\log\LogElle.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\aborttest\dummysendinfo.cpp ===
#include "..\..\..\..\FaxBVT\FaxSender\SendInfo.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\aborttest\dummystreamex.cpp ===
#include "..\..\..\..\FaxBVT\FaxSender\StreamEx.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\aborttest\util.h ===
//
//
// Filename:	util.h
// Author:		Sigalit Bar (sigalitb)
// Date:		7-Oct-00
//
//

#ifndef _UTIL_H_
#define _UTIL_H_


#include <windows.h>
#include <crtdbg.h>
#include <TCHAR.H>
//#include <shlwapi.h> //for SHDeleteKey() + prj linked with shlwapi.lib

#include "log.h"

#ifdef __cplusplus
extern "C" {
#endif


#define SHARED_FAX_SERVICE_NAME      TEXT("Fax")
/*
#define DLL_REGISTER_SERVER         "DllRegisterServer"

#define REGSVR32_EXE                TEXT("regsvr32.exe /s")
#define REGSVR32_UNREG_SWITCH                TEXT(" /u ")
*/
#define MAX_HINTS                   10

HRESULT StartFaxService(void);

HRESULT StopFaxService(void);

#ifdef __cplusplus
}
#endif 

#endif //_UTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\aborttest\main.cpp ===
//
//
// Filename:	main.cpp
// Author:		Sigalit Bar
// Date:		30-dec-98
//
//


#include "test.h"

#define HELP_SWITCH_1        TEXT("/?")
#define HELP_SWITCH_2        TEXT("/H")
#define HELP_SWITCH_3        TEXT("-?")
#define HELP_SWITCH_4        TEXT("-H")

#define MAX_ARGS	10 //including exe name

#define ARGUMENT_IS_SERVER_NAME						1
#define ARGUMENT_IS_FAX_NUMBER						2
#define ARGUMENT_IS_DOC								3
#define ARGUMENT_IS_CP								4
//#define ARGUMENT_IS_ABORT_RECEIVE_JOB				5
#define ARGUMENT_IS_DO_WHAT							5
#define ARGUMENT_IS_START_TIME						6
#define ARGUMENT_IS_STOP_TIME						7
#define ARGUMENT_IS_DELTA_TIME						8
#define ARGUMENT_IS_SANITY_SEND_EVERY_X_ABORTS		9

#define DEFAULT_SANITY_SEND_EVERY_X_ABORTS	20

#define NULL_COVERPAGE TEXT("NULL")


//
// global pointer to process heap
//
HANDLE g_hMainHeap = NULL;

//
// GetBoolFromStr:
//  if szVal is 'true', sets *pfVal to TRUE and returns TRUE
//  if szVal is 'false', sets *pfVal to FALSE and returns TRUE
//  otherwise returns FALSE.
//
#define FALSE_TSTR TEXT("false")
#define TRUE_TSTR  TEXT("true")
static BOOL GetBoolFromStr(LPCTSTR /* IN */ szVal, BOOL* /* OUT */ pfVal)
{
    BOOL fRetVal = FALSE;
    BOOL fTmpVal = FALSE;

    _ASSERTE(NULL != szVal);
    _ASSERTE(NULL != pfVal);

    if ( 0 == _tcscmp(szVal, FALSE_TSTR) )
    {
        fTmpVal = FALSE;
    }
    else
    {
        if ( 0 == _tcscmp(szVal, TRUE_TSTR) )
        {
            fTmpVal = TRUE;
        }
        else
        {
		    ::lgLogError(
                LOG_SEV_1,
                TEXT("\nparam is invalid (%s)\nShould be '%s' or '%s'\n"),
                szVal,
                TRUE_TSTR,
                FALSE_TSTR
                );
            goto ExitFunc;
        }
    }

    (*pfVal) = fTmpVal;
    fRetVal = TRUE;

ExitFunc:
    return(fRetVal);
}


//
// GetDoParamFromStr:
//  if szVal is 'true', sets *pfVal to TRUE and returns TRUE
//  if szVal is 'false', sets *pfVal to FALSE and returns TRUE
//  otherwise returns FALSE.
//
#define ABORT_SEND_TSTR		TEXT("abort_send")
#define ABORT_RECEIVE_TSTR  TEXT("abort_receive")
#define STOP_SVC_TSTR		TEXT("stop_svc")
static BOOL GetDoWhatFromStr(LPCTSTR /* IN */ szVal, DWORD* /* OUT */ pdwVal)
{
    BOOL fRetVal = FALSE;
    DWORD dwTmpVal = DO_ABORT_SEND_JOB;

    _ASSERTE(NULL != szVal);
    _ASSERTE(NULL != pdwVal);

    if ( 0 == _tcscmp(szVal, ABORT_SEND_TSTR) )
    {
        dwTmpVal = DO_ABORT_SEND_JOB;
    }
    else
    {
        if ( 0 == _tcscmp(szVal, ABORT_RECEIVE_TSTR) )
        {
            dwTmpVal = DO_ABORT_RECEIVE_JOB;
        }
        else
        {
			if ( 0 == _tcscmp(szVal, STOP_SVC_TSTR) )
			{
				dwTmpVal = DO_STOP_SERVICE;
			}
			else
			{
				::lgLogError(
					LOG_SEV_1,
					TEXT("\nparam is invalid (%s)\nShould be '%s' or '%s' or '%s'\n"),
					szVal,
					ABORT_SEND_TSTR,
					ABORT_RECEIVE_TSTR,
					STOP_SVC_TSTR
					);
				goto ExitFunc;
			}
        }
    }

    (*pdwVal) = dwTmpVal;
    fRetVal = TRUE;

ExitFunc:
    return(fRetVal);
}

//
// UsageInfo:
//	Outputs application's proper usage and exits process.
//
void
UsageInfo(void)
{
	::_tprintf(TEXT("AbortTest\n\n"));
	::_tprintf(TEXT("AbortTest server_name fax_number document cover_page start_time stop_time delta sanity\n"));
	::_tprintf(TEXT("    server_name        the name of the fax server (without the \\\\)\n"));
	::_tprintf(TEXT("    fax_number         the fax number to send the fax to\n"));
	::_tprintf(TEXT("    document           the full path of the document to send\n"));
	::_tprintf(TEXT("    cover_page         the full path to the cover page to send\n"));
	::_tprintf(TEXT("    do_what			if 'abort_send' then send job will be aborted\n"));
	::_tprintf(TEXT("                       if 'abort_receive' then receive job will be aborted\n"));
	::_tprintf(TEXT("                       if 'stop_svc' then service will be restarted\n"));
	::_tprintf(TEXT("    start_time         the minimum time to wait before aborting in ms\n"));
	::_tprintf(TEXT("    stop_time          the maximum time to wait before aborting in ms\n"));
	::_tprintf(TEXT("    delta              the delta at which to move from start_time to stop_time in ms\n"));
	::_tprintf(TEXT("    sanity             every <sanity> aborts a sanity check will be performed (a complete fax send)\n"));
	::_tprintf(TEXT(" Note: (stop_time - start_time)/delta faxes will be queued and then aborted\n"));
	::_tprintf(TEXT("       1st fax will be queued and aborted after start_time ms,\n"));
	::_tprintf(TEXT("       2nd fax will be queued and aborted after (start_time + delta) ms, etc\n"));
	::_tprintf(TEXT("\n"));
	exit(0);
}


//
// ParseCmdLineParams:
//	Parses the command line parameters, saves a copy of them,
//	and converts from MBCS to UNICODE if necessary.
//
// Parameters:
//	argc				IN parameter.
//						command line number of arguments.
//	argvA[]				IN parameter.
//						command line args (in MBCS).
//	pszServerName		OUT parameter.
//						Pointer to string to copy 1st argument to.
//						Represents the name of fax server to use.
//	pszFaxNumber		OUT parameter.
//						Pointer to string to copy 2nd argument to.
//						Represents the fax number of 1st device on the
//						above fax server.
//	pszDocument			OUT parameter.
//						Pointer to string to copy 3rd argument to.
//						Represents the name of document to use with tests.
//	pszCoverPage		OUT parameter.
//						Pointer to string to copy 4th argument to.
//						Represents the name of the cover page to use
//						with tests.
//
//	pfAbortReceiveJob	OUT parameter.
//						Pointer to BOOL to copy 5th argument to.
//						Represents whether to abort the send or the receive job.
//                      If TRUE then abort the receive job.
//
//	pdwStartTime		OUT parameter
//						Pointer to DWORD to copy 6th argument to.
//					    Represents the Minimum time (in ms) to wait before aborting in tests.
//
//	pdwStopTime		    OUT parameter
//						Pointer to DWORD to copy 7th argument to.
//					    Represents the Maximum time (in ms) to wait before aborting in tests.
//
//	pdwDelta			OUT parameter
//						Pointer to DWORD to copy 8th argument to.
//					    Represents the Delta time (in ms) to increase the wait time before aborting in tests.
//
//	pdwSanitySendEveryXAborts   OUT parameter
//						        Pointer to DWORD to copy 9th argument to.
//					            Perform a sanity check after every X aborts.
//
// Return Value:
//	TRUE on success and FALSE on failure.
//
//
BOOL 
ParseCmdLineParams(
	const INT	/* IN */	argc,
	CHAR *		/* IN */	argvA[],
	LPTSTR*		/* OUT */	pszServerName,
	LPTSTR*		/* OUT */	pszFaxNumber,
	LPTSTR*		/* OUT */	pszDocument,
	LPTSTR*		/* OUT */	pszCoverPage,
    LPDWORD     /* OUT */   pdwDoWhat,
	LPDWORD		/* OUT */	pdwStartTime,
	LPDWORD		/* OUT */	pdwStopTime,
	LPDWORD		/* OUT */	pdwDelta,
	LPDWORD		/* OUT */	pdwSanitySendEveryXAborts
	)
{
	_ASSERTE(pszServerName);
	_ASSERTE(pszDocument);
	_ASSERTE(pszFaxNumber);
	_ASSERTE(pszCoverPage);
    _ASSERTE(pdwDoWhat);
	_ASSERTE(pdwStartTime);
	_ASSERTE(pdwStopTime);
	_ASSERTE(pdwDelta);
	_ASSERTE(pdwSanitySendEveryXAborts);

	DWORD	dwArgLoopIndex;
	DWORD	dwArgSize;
	LPTSTR	aszParam[MAX_ARGS];
	DWORD	dwTmpStartTime	= DEFAULT_START_TIME;
	DWORD	dwTmpStopTime	= DEFAULT_STOP_TIME;
	DWORD	dwTmpDelta		= DEFAULT_DELTA;
	LPTSTR  szStopTstr		= NULL;
	DWORD	dwTmpSanitySendEveryXAborts = DEFAULT_SANITY_SEND_EVERY_X_ABORTS;
	LPTSTR  szSanityTstr	= NULL;

	//
	// Check number of parameters
	//
	if ( ( argc != MAX_ARGS ) && ( argc != 2 ) )   //=2 is for exe and help switch
	{
		::_tprintf(TEXT("\nInvalid invokation of AbortTest.exe\n\n"));
		::_tprintf(TEXT("AbortTest.exe Help:\n"));
		::UsageInfo(); //UsageInfo() exits process.
	}

	//
	// Initialize awcsParam[]
	//
	for (dwArgLoopIndex = 0; dwArgLoopIndex < MAX_ARGS; dwArgLoopIndex++)
	{
		aszParam[dwArgLoopIndex] = NULL;
	}

	//
	// Loop on arguments in argvA[]
	//
    for (dwArgLoopIndex = 1; dwArgLoopIndex < (DWORD) argc; dwArgLoopIndex++) 
	{
		//
        // Determine the memory required for the parameter
		//
        dwArgSize = (::lstrlenA(argvA[dwArgLoopIndex]) + 1) * sizeof(TCHAR);

		//
        // Allocate the memory for the parameter
		//
		_ASSERTE(g_hMainHeap);
        aszParam[dwArgLoopIndex] = (TCHAR*)::HeapAlloc(
			g_hMainHeap, 
			HEAP_ZERO_MEMORY, 
			dwArgSize
			);
		if(NULL == aszParam[dwArgLoopIndex])
		{
			::_tprintf(TEXT("FILE:%s LINE:%d\n HeapAlloc returned NULL\n"),
				TEXT(__FILE__),
				__LINE__
				);
			goto ExitFuncFail;
		}

		//
		// Copy content of argument from argvA[index] to new allocation
		//
#ifdef _UNICODE
		// argvA[] is a CHAR*, so it needs to be converted to a WCHAR* ifdef UNICODE
        // Convert awcsParam
		if (!::MultiByteToWideChar(
			CP_ACP, 
			0, 
			argvA[dwArgLoopIndex], 
			-1, 
			aszParam[dwArgLoopIndex], 
			(::lstrlenA(argvA[dwArgLoopIndex]) + 1) * sizeof(WCHAR))
			)
		{
			::_tprintf(
				TEXT("FILE:%s LINE:%d\n MultiByteToWideChar failed With GetLastError()=%d\n"),
				TEXT(__FILE__),
				__LINE__,
				::GetLastError()
				);
			goto ExitFuncFail;
		}
#else //_MBCS
		::strcpy(aszParam[dwArgLoopIndex],argvA[dwArgLoopIndex]);
		if (strcmp(aszParam[dwArgLoopIndex],argvA[dwArgLoopIndex]))
		{
			::_tprintf(
				TEXT("FILE:%s LINE:%d\n string copy or compare failed\n"),
				TEXT(__FILE__),
				__LINE__,
				::GetLastError()
				);
			goto ExitFuncFail;
		}
#endif
		//
		// Check for help switch
		//
		// If this is the second argument, it may be one of several help switches defined.
		// A help switch can appear only as the second argument.
        if (2 == argc)
		{
			if (! (!::lstrcmpi(HELP_SWITCH_1, aszParam[dwArgLoopIndex])) || 
				  (!::lstrcmpi(HELP_SWITCH_2, aszParam[dwArgLoopIndex])) || 
				  (!::lstrcmpi(HELP_SWITCH_3, aszParam[dwArgLoopIndex])) || 
				  (!::lstrcmpi(HELP_SWITCH_4, aszParam[dwArgLoopIndex]))
				) 
			{
				::_tprintf(TEXT("Invalid invokation of CometFaxSender.exe\n\n"));
			}
			::UsageInfo(); //UsageInfo() exits the process.
		}

		//
		// Treat each argument accordingly
		//
		switch (dwArgLoopIndex)
		{
		case ARGUMENT_IS_SERVER_NAME:
			//server_name param
			(*pszServerName) = aszParam[dwArgLoopIndex];
			break;

		case ARGUMENT_IS_FAX_NUMBER:
			//fax_number1 param
			(*pszFaxNumber) = aszParam[dwArgLoopIndex];
			break;

		case ARGUMENT_IS_DOC:
			//document param
			(*pszDocument) = aszParam[dwArgLoopIndex];
			break;

		case ARGUMENT_IS_CP:
			//cover_page param
			(*pszCoverPage) = aszParam[dwArgLoopIndex];
			break;

/*
        case ARGUMENT_IS_ABORT_RECEIVE_JOB:
            if (FALSE == GetBoolFromStr(aszParam[dwArgLoopIndex], pfAbortReceiveJob))
            {
                goto ExitFuncFail;
            }
            break;
*/
        case ARGUMENT_IS_DO_WHAT:
            if (FALSE == GetDoWhatFromStr(aszParam[dwArgLoopIndex], pdwDoWhat))
            {
                goto ExitFuncFail;
            }
            break;

		case ARGUMENT_IS_START_TIME:
			//start_time param
			dwTmpStartTime = ::_tcstol(aszParam[dwArgLoopIndex], &szStopTstr, 10);
			//TO DO: check that szStopTstr is NULL ?
			(*pdwStartTime) = dwTmpStartTime;
			//we don't need the alloc so free and NULL it
			if (FALSE == ::HeapFree(g_hMainHeap, 0, aszParam[dwArgLoopIndex]))
			{
				::_tprintf(TEXT("FILE:%s LINE:%d ARGUMENT_IS_START_TIME\nHeapFree returned FALSE with GetLastError()=%d\n"),
					TEXT(__FILE__),
					__LINE__,
					::GetLastError()
					);
				goto ExitFuncFail; // BUGBUG we will try to HeapFree all params (and probably fail again)
			}
			aszParam[dwArgLoopIndex] = NULL;
			break;

		case ARGUMENT_IS_STOP_TIME:
			//stop_time param
			dwTmpStopTime = ::_tcstol(aszParam[dwArgLoopIndex], &szStopTstr, 10);
			//TO DO: check that szStopTstr is NULL ?
			(*pdwStopTime) = dwTmpStopTime;
			//we don't need the alloc so free and NULL it
			if (FALSE == ::HeapFree(g_hMainHeap, 0, aszParam[dwArgLoopIndex]))
			{
				::_tprintf(TEXT("FILE:%s LINE:%d ARGUMENT_IS_STOP_TIME\nHeapFree returned FALSE with GetLastError()=%d\n"),
					TEXT(__FILE__),
					__LINE__,
					::GetLastError()
					);
				goto ExitFuncFail; // BUGBUG we will try to HeapFree all params (and probably fail again)
			}
			aszParam[dwArgLoopIndex] = NULL;
			break;

		case ARGUMENT_IS_DELTA_TIME:
			//delta param
			dwTmpDelta = ::_tcstol(aszParam[dwArgLoopIndex], &szStopTstr, 10);
			//TO DO: check that szStopTstr is NULL ?
			//we don't need the alloc so free and NULL it
			if (FALSE == ::HeapFree(g_hMainHeap, 0, aszParam[dwArgLoopIndex]))
			{
				::_tprintf(TEXT("FILE:%s LINE:%d ARGUMENT_IS_STOP_TIME\nHeapFree returned FALSE with GetLastError()=%d\n"),
					TEXT(__FILE__),
					__LINE__,
					::GetLastError()
					);
				goto ExitFuncFail; // BUGBUG we will try to HeapFree all params (and probably fail again)
			}
			aszParam[dwArgLoopIndex] = NULL;
			// check that params make sense, if not set to default
			if (dwTmpStopTime < (dwTmpStartTime + dwTmpDelta))
			{
				::_tprintf(TEXT("FILE:%s LINE:%d\n set params to default since - StartTime=%d StopTime=%d and Delta=%d"),
					TEXT(__FILE__),
					__LINE__,
					dwTmpStartTime,
					dwTmpStopTime,
					dwTmpDelta
					);
				dwTmpStartTime = DEFAULT_START_TIME;
				dwTmpStopTime = DEFAULT_STOP_TIME;
				dwTmpDelta = DEFAULT_DELTA;
			}
			(*pdwStartTime) = dwTmpStartTime;
			(*pdwStopTime) = dwTmpStopTime;
			(*pdwDelta) = dwTmpDelta;
			break;

		case ARGUMENT_IS_SANITY_SEND_EVERY_X_ABORTS:
			//sanity param
			dwTmpSanitySendEveryXAborts = 
				::_tcstol(aszParam[dwArgLoopIndex], &szSanityTstr, 10);
			//TO DO: check that szSanityTstr is NULL ?
			//check that param makes sense
			if (0 >= dwTmpSanitySendEveryXAborts)
			{
				dwTmpSanitySendEveryXAborts = DEFAULT_SANITY_SEND_EVERY_X_ABORTS;
			}
			(*pdwSanitySendEveryXAborts) = dwTmpSanitySendEveryXAborts;
			//we don't need the alloc so free and NULL it
			if (FALSE == ::HeapFree(g_hMainHeap, 0, aszParam[dwArgLoopIndex]))
			{
				::_tprintf(TEXT("FILE:%s LINE:%d ARGUMENT_IS_STOP_TIME\nHeapFree returned FALSE with GetLastError()=%d\n"),
					TEXT(__FILE__),
					__LINE__,
					::GetLastError()
					);
				goto ExitFuncFail; // BUGBUG we will try to HeapFree all params (and probably fail again)
			}
			aszParam[dwArgLoopIndex] = NULL;
			break;

		default:
			::_tprintf(TEXT("FILE:%s LINE:%d\n default reached dwArgLoopIndex=%d\n"),
				TEXT(__FILE__),
				__LINE__,
				dwArgLoopIndex
				);
			_ASSERTE(FALSE);
			return FALSE;
		}// switch (dwIndex)

	}//for (dwIndex = 1; dwIndex < (DWORD) argc; dwIndex++)


	//If all is well then we do NOT free 
	//pszServerName, pszFaxNumber1, pszFaxNumber, pszDocument and pszCoverPage,
	//since these allocations were the purpose of the function.
	return(TRUE);

ExitFuncFail:

	//
	// Free allocations
	//
	DWORD i;
	//0 to MAX_ARGS is ok, since that is aszParam array size and we NULLed all of it first
	for (i=0; i<MAX_ARGS; i++) 
	{
		if (NULL == aszParam[i]) continue;
		if (FALSE == ::HeapFree(g_hMainHeap, 0, aszParam[i]))
		{
			::_tprintf(TEXT("FILE:%s LINE:%d loop#%d\nHeapFree returned FALSE with GetLastError()=%d\n"),
				TEXT(__FILE__),
				__LINE__,
				i,
				::GetLastError()
				);
			return(FALSE);
		}
	}

	//
	//reset OUT parameters
	//
	(*pszServerName) = NULL;
	(*pszFaxNumber) = NULL;
	(*pszDocument) = NULL;
	(*pszCoverPage) = NULL;
    (*pdwDoWhat) = -1;
	(*pdwStartTime) = -1;
	(*pdwStopTime) = -1;
	(*pdwDelta) = -1;
	(*pdwSanitySendEveryXAborts) = -1;

	return(FALSE);
}




//
// main body of application.
//
int __cdecl
main(
	INT   argc,
    CHAR  *argvA[]
)
{
	int nReturnValue = 1; //"default" return value is to indicate error

	LPTSTR szServerName = NULL;
	LPTSTR szFaxNumber = NULL;
	LPTSTR szDocument = NULL;
	LPTSTR szCoverPage = NULL;
    DWORD  dwDoWhat = -1;
	DWORD  dwStartTime = -1;
	DWORD  dwStopTime = -1;
	DWORD  dwDelta = -1;
	DWORD  dwSanitySendEveryXAborts = -1;
	DWORD  dwCurrentAbortTime = 0;
	DWORD  lLoopIndex = 1;

	HINSTANCE hModWinfax = NULL;
	LPVOID pVoidTempFunc = NULL;

	//
	// Set g_hMainHeap to process heap
	//
	g_hMainHeap = NULL;
	g_hMainHeap = ::GetProcessHeap();
	if(NULL == g_hMainHeap)
	{
		::_tprintf(TEXT("FILE:%s LINE:%d\nGetProcessHeap returned NULL with GetLastError()=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
		goto ExitFunc;
	}

	//
	// Parse the command line
	//
	if (!::ParseCmdLineParams(
			argc,
			argvA,
			&szServerName,
			&szFaxNumber,
			&szDocument,
			&szCoverPage,
            &dwDoWhat,
			&dwStartTime,
			&dwStopTime,
			&dwDelta,
			&dwSanitySendEveryXAborts
			)
		)
	{
		goto ExitFunc;
	}


	//
	// "Debug" printing of the command line parameters after parsing
	//
#ifdef _DEBUG
	::_tprintf(
		TEXT("DEBUG DEBUG DEBUG\nServer=%s\nFaxNumber=%s\nDocument=%s\nCoverPage=%s\ndwDoWhat=%d\nStartTime=%d\nStopTime=%d\nDelta=%d\ndwSanitySendEveryXAborts=%d\n"),
		szServerName,
		szFaxNumber,
		szDocument,
		szCoverPage,
        dwDoWhat,
		dwStartTime,
		dwStopTime,
		dwDelta,
		dwSanitySendEveryXAborts
		);
#endif

	if (!TestSuiteSetup(
			szServerName,
			szFaxNumber,
			szDocument,
			szCoverPage,
            dwDoWhat,
			dwStartTime,
			dwStopTime,
			dwDelta,
			dwSanitySendEveryXAborts
			)
		)
	{
		goto ExitFunc;
	}


    //
    // if user gave szCoverPage=="NULL" then set szCoverPage=NULL (and not "NULL")
    //
    if ( 0 == ::_tcscmp(NULL_COVERPAGE, szCoverPage))
    {
        ::free(szCoverPage);
        szCoverPage = NULL;
    }

	dwCurrentAbortTime = dwStartTime;
	lLoopIndex = 1;
	while (dwCurrentAbortTime <= dwStopTime)
	{
		//Send a fax + CP and abort after dwCurrentAbortTime
		if (FALSE == SendAndAbort(			
						szServerName,
						szFaxNumber,
						szDocument,
						szCoverPage,
						dwCurrentAbortTime,
                        dwDoWhat
						)
			)
		{
			goto ExitFunc;
		}

        // if user gave dwDelta=0 then we 
        // SendAndAbort() once with dwCurrentAbortTime=dwStartTime
        if (0 == dwDelta) break; 

		dwCurrentAbortTime = dwCurrentAbortTime + dwDelta;
		// TO DO: force the dwStopTime value for dwCurrentAbortTime

		if ((DO_ABORT_SEND_JOB == dwDoWhat)||(DO_ABORT_RECEIVE_JOB == dwDoWhat))
		{
			// sleep only if aborting send / receive
			// (no need to sleep after svc restart)
			Sleep(SLEEP_TIME_BETWEEN);
		}


		if (TRUE == PerformSanityCheck(lLoopIndex,dwSanitySendEveryXAborts))
		{
			Sleep(3*SLEEP_TIME_BETWEEN);

			//Send a fax + CP (no abort), returns true iff completed successfully
			if (FALSE == SendRegularFax(			
							szServerName,
							szFaxNumber,
							szDocument,
							szCoverPage
							)
				)
			{
				goto ExitFunc;
			}
		}

		lLoopIndex++;
	}

    //
    // if we didn't perform a sanity check after the last SendAndAbort, do one
    //
    lLoopIndex--; //the last lLoopIndex (inside loop)
	if (FALSE == PerformSanityCheck(lLoopIndex,dwSanitySendEveryXAborts))
	{
		//Since PerformSanityCheck() also returned FALSE last time in the loop
        //this means that we didn't perform a sanity check after the last SendAndAbort()
        //so we will now.
		if (FALSE == SendRegularFax(			
						szServerName,
						szFaxNumber,
						szDocument,
						szCoverPage
						)
			)
		{
			goto ExitFunc;
		}
	}


ExitFunc:
	TestSuiteShutdown();
	return(nReturnValue);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\aborttest\test.h ===
//
//
// Filename:	test.h
// Author:		Sigalit Bar (sigalitb)
// Date:		30-Dec-98
//
//

#ifndef _TEST_H_
#define _TEST_H_

#include <windows.h>
#include <TCHAR.H>
#include "crtdbg.h"

#include "log.h"
#include "FaxSender.h"


#ifdef __cplusplus
extern "C" {
#endif

#define DEFAULT_START_TIME	0
#define DEFAULT_STOP_TIME	60000
#define DEFAULT_DELTA		1000
#define SLEEP_TIME_BETWEEN	10000


#define DO_ABORT_SEND_JOB		1
#define DO_ABORT_RECEIVE_JOB	2
#define DO_STOP_SERVICE			3

//
// TestSuiteSetup:
//	Initializes logger and changes the Fax server configuration
//	for the tests.
//
// Parameters:
//	szServerName	    IN parameter.
//					    Name of Fax server to setup.
//  
//	szFaxNumber		    IN parameter
//					    Phone number of first device installed on server.
//					    Will be set up as sending device.
//
//	szDocument		    IN parameter
//					    Filename of document to be used in tests.
//					    The function only prints this string to logger (for debugging).
//
//	szCoverPage		    IN parameter
//					    Filename of cover page to be used in tests.
//					    The function only prints this string to logger (for debugging).
//
//	fAbortReceiveJob	IN parameter.
//						Represents whether to abort the send or the receive job.
//                      If TRUE then abort the receive job.
//
//	dwStartTime		    IN parameter
//					    Minimum time (in ms) to wait before aborting in tests.
//
//	dwStopTime		    IN parameter
//					    Maximum time (in ms) to wait before aborting in tests.
//
//	dwDelta			    IN parameter
//					    Delta time (in ms) to increase the wait time before aborting in tests.
//
//	dwSanitySendEveryXAborts    IN parameter
//					            Perform a sanity check after every X aborts.
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL WINAPIV TestSuiteSetup(
	LPCTSTR		szServerName,
	LPCTSTR		szFaxNumber,
	LPCTSTR		szDocument,
	LPCTSTR		szCoverPage,
    DWORD       dwDoWhat,
	DWORD		dwStartTime,
	DWORD		dwStopTime,
	DWORD		dwDelta,
	DWORD		dwSanitySendEveryXAborts
);

//
// SendAndAbort:
//	Send a fax + CP and aborts the job after dwAbortTime ms.
//
// Parameters:
//	szServerName	IN parameter.
//					Name of Fax server to setup.
//  
//	szFaxNumber		IN parameter
//					Phone number to send fax to.
//
//	szDocument		IN parameter
//					Filename of document to send.
//
//	szCoverPage		IN parameter
//					Filename of cover page to send.
//
//	dwAbortTime		IN parameter
//					ms to wait before aborting job.
//
//	fAbortReceiveJob	IN parameter.
//						Represents whether to abort the send or the receive job.
//                      If TRUE then abort the receive job.
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL WINAPIV SendAndAbort(
	LPCTSTR		/* IN */	szServerName,
	LPCTSTR		/* IN */	szFaxNumber,
	LPCTSTR		/* IN */	szDocument,
	LPCTSTR		/* IN */	szCoverPage,
	DWORD		/* IN */	dwAbortTime, 
    DWORD       /* IN */    dwDoWhat = DO_ABORT_SEND_JOB
);


//
// PerformSanityCheck:
//	Returns TRUE if it's time to perform a sanity check.
//	Decision is based on lLoopIndex and dwSanitySendEveryXAborts
//
// NOTE: return TRUE every dwSanitySendEveryXAborts time in loop (lLoopIndex)
BOOL PerformSanityCheck(DWORD lLoopIndex, DWORD dwSanitySendEveryXAborts);


//
// SendRegularFax:
//	Sends a fax.
//
// NOTE: This func returns after send is completed (not after job is queued).
//
// Parameters:
//	szServerName	IN parameter.
//					Name of Fax server to use.
//  
//	szFaxNumber		IN parameter
//					Phone number to send fax to.
//
//	szDocument		IN parameter
//					Filename of document to send.
//
//	szCoverPage		IN parameter
//					Filename of cover page to send.
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL SendRegularFax(
	LPCTSTR		/* IN */	szServerName,
	LPCTSTR		/* IN */	szFaxNumber,
	LPCTSTR		/* IN */	szDocument,
	LPCTSTR		/* IN */	szCoverPage
);


//
// TestSuiteShutdown:
//	Perform test suite cleanup (close logger).
//
// Return Value:
//	TRUE if successful, FALSE otherwise.
//
BOOL WINAPIV TestSuiteShutdown(void);



#ifdef __cplusplus
}
#endif 

#endif //_TEST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\aborttest\test.cpp ===
//
//
// Filename:	bvt.cpp
// Author:		Sigalit Bar (sigalitb)
// Date:		30-Dec-98
//
//

#include "test.h"
#include "util.h"

//
// TestSuiteSetup:
//	Initializes logger and changes the Fax server configuration
//	for the tests.
//
BOOL WINAPIV TestSuiteSetup(
	LPCTSTR		szServerName,
	LPCTSTR		szFaxNumber,
	LPCTSTR		szDocument,
	LPCTSTR		szCoverPage,
    DWORD       dwDoWhat,
	DWORD		dwStartTime,
	DWORD		dwStopTime,
	DWORD		dwDelta,
	DWORD		dwSanitySendEveryXAborts
	)
{
	_ASSERTE(NULL != szServerName);
	_ASSERTE(NULL != szFaxNumber);
	_ASSERTE(NULL != szDocument);
	_ASSERTE(NULL != szCoverPage);

	BOOL fRetVal = FALSE;
	HANDLE hFaxSvc = NULL;
	DWORD dwNumFaxPorts = 0;
	int nPortIndex = 0;
	PFAX_CONFIGURATION pFaxSvcConfig = NULL;
	PFAX_PORT_INFO	pFaxPortsConfig = NULL;

	//
	// Init logger
	//
	if (!::lgInitializeLogger())
	{
		::_tprintf(TEXT("FILE:%s LINE:%d\nlgInitializeLogger failed with GetLastError()=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
		goto ExitFunc;
	}

	//
	// Begin test suite (logger)
	//
	if(!::lgBeginSuite(TEXT("Abort suite")))
	{
		::_tprintf(TEXT("FILE:%s LINE:%d\nlgBeginSuite failed with GetLastError()=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
		goto ExitFunc;
	}

	// log CometFaxSender.exe params using elle logger
	::lgLogDetail(
		LOG_X,
		1,
		TEXT("AbortTest params:\n\tszServerName=%s\n\tszFaxNumber1=%s\n\tszDocument=%s\n\tszCoverPage=%s\n\tdwDoWhat=%d\n\tdwStartTime=%d\n\tdwStopTime=%d\n\tdwDelta=%d\n\tdwSanitySendEveryXAborts=%d\n"),
		szServerName,
		szFaxNumber,
		szDocument,
		szCoverPage,
        dwDoWhat,
		dwStartTime,
		dwStopTime,
		dwDelta,
		dwSanitySendEveryXAborts
		);

	fRetVal = TRUE;

ExitFunc:
	return(fRetVal);
}


//
// SendAndAbort:
//	Send a fax + CP and abort job after dwAbortTime ms
//  if fAbortReceiveJob==FALSE abort the send job.
//  if fAbortReceiveJob==TRUE then check if job with the next id 
//  is a receive job, if so abort it.
//
BOOL WINAPIV SendAndAbort(
	LPCTSTR		/* IN */	szServerName,
	LPCTSTR		/* IN */	szFaxNumber,
	LPCTSTR		/* IN */	szDocument,
	LPCTSTR		/* IN */	szCoverPage,
	DWORD		/* IN */	dwAbortTime,
    DWORD       /* IN */    dwDoWhat
)
{
	_ASSERTE(NULL != szServerName);
	_ASSERTE(NULL != szFaxNumber);
	_ASSERTE(NULL != szDocument);
	_ASSERTE(NULL != szCoverPage);

	BOOL				fRetVal = FALSE;
	HANDLE				hFaxSvc = NULL;
    FAX_JOB_PARAM       FaxJobParams;
	FAX_COVERPAGE_INFO	CPInfo;
	PFAX_COVERPAGE_INFO	pCPInfo = NULL;
	DWORD				dwJobId = 0;
	DWORD				dwErr = 0;
    DWORD               dwAbortJobId = 0;

	DWORD			dwNumOfJobs = 1;
	DWORD			dwLoopIndex = 0;
	DWORD			dwNumOfLoops = 500;

	PFAX_JOB_ENTRY_EX pJobEntryEx = NULL;

	::lgBeginCase(
		1,
		TEXT("Send a fax + CP and abort job")
		);

	if (FALSE == ::FaxConnectFaxServer(szServerName, &hFaxSvc))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE:%s LINE:%d\n FaxConnectFaxServer failed with err=%d"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
		goto ExitFunc;
	}

    //
	// queue the send job
	//
	
	// Initialize the FAX_JOB_PARAM struct
    ZeroMemory(&FaxJobParams, sizeof(FAX_JOB_PARAM));

    // Set the FAX_JOB_PARAM struct
    FaxJobParams.SizeOfStruct = sizeof(FAX_JOB_PARAM);
    //FaxJobParams.RecipientNumber = ::_tcsdup(szFaxNumber); //[19-Dec]
    //FaxJobParams.RecipientName = ::_tcsdup(szFaxNumber);  //[19-Dec]
    FaxJobParams.RecipientNumber = szFaxNumber;
    FaxJobParams.RecipientName = szFaxNumber;
    FaxJobParams.ScheduleAction = JSA_NOW;	//send fax immediately

	// Initialize the FAX_COVERPAGE_INFO struct
	ZeroMemory(&CPInfo, sizeof(FAX_COVERPAGE_INFO));
	if (NULL != szCoverPage)
	{
		// Set the FAX_COVERPAGE_INFO struct
		CPInfo.SizeOfStruct = sizeof(FAX_COVERPAGE_INFO);
		//CPInfo.CoverPageName = ::_tcsdup(szCoverPage); //[19-Dec]
		CPInfo.CoverPageName = szCoverPage;
		CPInfo.Note = TEXT("NOTE1\nNOTE2\nNOTE3\nNOTE4");
		CPInfo.Subject = TEXT("SUBJECT");	
        pCPInfo = &CPInfo;
	}

    if (!::FaxSendDocument(hFaxSvc, szDocument, &FaxJobParams, pCPInfo, &dwJobId)) 
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d\nFaxSendDocument returned FALSE with GetLastError=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
		goto ExitFunc;
    }


	//
	// abort job after dwAbortTime ms
	//

	Sleep(dwAbortTime);
	switch (dwDoWhat)
	{
	case DO_ABORT_SEND_JOB:
        // we want to abort the send job (dwJobId)
        dwAbortJobId = dwJobId;
		break;

	case DO_ABORT_RECEIVE_JOB:
        // we want to abort the receive job (dwJobId + 1)
        dwAbortJobId = dwJobId + 1;
        // NOTICE - we assume there are no other jobs in queue
        //          and thus the receive job will have (dwJobId + 1)
		break;

	case DO_STOP_SERVICE:
		// we want to stop and start the service
		if (ERROR_SUCCESS != StopFaxService())
		{
			goto ExitFunc;
		}
		if (ERROR_SUCCESS != StartFaxService())
		{
			goto ExitFunc;
		}
	    ::lgLogDetail(
		    LOG_X,
		    1,
		    TEXT("FILE:%s LINE:%d\n Queued job %d and restarted the service after %d ms"),
		    TEXT(__FILE__),
		    __LINE__,
            dwJobId,
		    dwAbortTime
		    );
		//dwNumOfLoops = 30; // wait longer to allow for sending
		//goto WaitForQueue;
		fRetVal = TRUE;
		goto ExitFunc;

	default:
		_ASSERTE(FALSE);
	}

	if (FALSE == ::FaxAbort(hFaxSvc, dwAbortJobId))
	{
		dwErr = ::GetLastError();
		if ( ERROR_INVALID_PARAMETER != dwErr ) 
		{
			// FaxAbort failed, but not because the JobId param is invalid => error
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FILE:%s LINE:%d\nFaxAbort for JobId=%d returned FALSE with GetLastError=%d\n"),
				TEXT(__FILE__),
				__LINE__,
                dwAbortJobId,
				::GetLastError()
				);
			goto ExitFunc;
		}
		//the JobId param is invalid guess that this job has already completed => ok
        //or that this is a receive job that hasn't yet started => ok
		::lgLogDetail(
			LOG_X,
			1, 
			TEXT("FILE:%s LINE:%d\nFaxAbort for JobId=%d returned FALSE with ERROR_INVALID_PARAMETER (guess job already completed)\n"),
			TEXT(__FILE__),
			__LINE__,
            dwAbortJobId
			);
	}

    if (DO_ABORT_SEND_JOB == dwDoWhat)
    {
        //
        // we aborted the send job (dwJobId)
        //
	    ::lgLogDetail(
		    LOG_X,
		    1,
		    TEXT("FILE:%s LINE:%d\n Queued job %d and aborted it after %d ms"),
		    TEXT(__FILE__),
		    __LINE__,
		    dwAbortJobId,
		    dwAbortTime
		    );
    }
    else
    {
        //
        // we aborted the receive job (dwJobId + 1)
        //
	    ::lgLogDetail(
		    LOG_X,
		    1,
		    TEXT("FILE:%s LINE:%d\n Queued job %d and aborted its RECEIVE job %d after %d ms"),
		    TEXT(__FILE__),
		    __LINE__,
            dwJobId,
		    dwAbortJobId,
		    dwAbortTime
		    );
    }

	//
	// make sure queue is empty before returning (so we don't attempt another send)
	//
	for (dwLoopIndex=0; dwLoopIndex < dwNumOfLoops ; dwLoopIndex++)
	{
		if (FALSE == FaxEnumJobsEx(hFaxSvc, JT_RECEIVE | JT_SEND, &pJobEntryEx, &dwNumOfJobs))
		{
			// something is wrong.
			// this should not fail.
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FILE:%s LINE:%d\nFaxEnumJobsEx returned FALSE with GetLastError=0x%08X\n"),
				TEXT(__FILE__),
				__LINE__,
				::GetLastError()
				);
			_ASSERTE(FALSE);
			goto ExitFunc;
		}
		if (NULL != pJobEntryEx)
		{
			FaxFreeBuffer(pJobEntryEx);
			pJobEntryEx = NULL;
		}

		if (0 == dwNumOfJobs)
		{
			// no jobs in queue, so we can return
			// lets sleep to make sure modems are free
			Sleep(6*SLEEP_TIME_BETWEEN);
			break;
		}

		// there are some jobs in the queue, lets sleep some (allow them to abort)
		Sleep(SLEEP_TIME_BETWEEN);

	}

	if (0 != dwNumOfJobs)
	{
		// something is wrong ...
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d\nStill %d jobs in queue after %ld*SLEEP_TIME_BETWEEN ms\n"),
			TEXT(__FILE__),
			__LINE__,
			dwNumOfJobs,
			dwNumOfLoops
			);
		_ASSERTE(FALSE);
		goto ExitFunc;
	}
	fRetVal = TRUE;

ExitFunc:
	::lgEndCase();
	return(fRetVal);
}


//
// PerformSanityCheck:
//	Returns TRUE if it's time to perform a sanity check.
//	Decision is based on lLoopIndex and dwSanitySendEveryXAborts
//
BOOL PerformSanityCheck(DWORD lLoopIndex, DWORD dwSanitySendEveryXAborts)
{
	//perform a sanity check every dwSanitySendEveryXAborts time in loop
	return (0 == (lLoopIndex%dwSanitySendEveryXAborts));
}


//
// SendRegularFax:
//	Sends a fax.
//
// NOTE: This function is private to this module, it is not exported.
//
// Parameters:
//	szServerName	IN parameter.
//					Name of Fax server to use.
//  
//	szFaxNumber		IN parameter
//					Phone number to send fax to.
//
//	szDocument		IN parameter
//					Filename of document to send.
//
//	szCoverPage		IN parameter
//					Filename of cover page to send.
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL SendRegularFax(
	LPCTSTR		/* IN */	szServerName,
	LPCTSTR		/* IN */	szFaxNumber,
	LPCTSTR		/* IN */	szDocument,
	LPCTSTR		/* IN */	szCoverPage
)
{
	_ASSERTE(NULL != szServerName);
	_ASSERTE(NULL != szFaxNumber);
	_ASSERTE(NULL != szDocument);
	_ASSERTE(NULL != szCoverPage);

	BOOL fRetVal = FALSE;
	FAX_SENDER_STATUS myFaxSenderStatus;

	::lgBeginCase(
		1,
		TEXT("Sanity Check: Send a fax (no abort)")
		);

	::lgLogDetail(
		LOG_X,
		1,
		TEXT("Server=%s\nFaxNumber=%s\nDocument=%s\nCoverPage=%s\n"),
		szServerName,
		szFaxNumber,
		szDocument,
		szCoverPage
		);

	CFaxSender myFaxSender(szServerName);  //if constructor fail an assertion is raised
	fRetVal = myFaxSender.send( szDocument, szCoverPage, szFaxNumber);
	myFaxSenderStatus = myFaxSender.GetLastStatus();
	if (FALSE == fRetVal)
	{
		// send failed
		::lgLogError(LOG_SEV_1,TEXT("myFaxSender.send returned FALSE"));
	}
	else
	{
		// send succeeded
		::lgLogDetail(LOG_X,1,TEXT("myFaxSender.send returned TRUE"));
	}

	CostrstreamEx os;
	os<<myFaxSenderStatus;
	LPCTSTR myStr = os.cstr();
	::lgLogDetail(LOG_X,1,myStr);
	delete[]((LPTSTR)myStr);

	::lgEndCase();
	return(fRetVal);
}



//
// TestSuiteShutdown:
//	Perform test suite cleanup (close logger).
//
BOOL WINAPIV TestSuiteShutdown(void)
{
	BOOL fRetVal = TRUE;

	//
	// End test suite (logger)
	//
	if (!::lgEndSuite())
	{
		//
		//this is not possible since API always returns TRUE
		//but to be on the safe side
		//
		::_tprintf(TEXT("FILE:%s LINE:%d\nlgEndSuite returned FALSE\n"),
			TEXT(__FILE__),
			__LINE__
			);
		fRetVal = FALSE;
	}

	//
	// Close the Logger
	//
	if (!::lgCloseLogger())
	{
		//this is not possible since API always returns TRUE
		//but to be on the safe side
		::_tprintf(TEXT("FILE:%s LINE:%d\nlgCloseLogger returned FALSE\n"),
			TEXT(__FILE__),
			__LINE__
			);
		fRetVal = FALSE;
	}

	return(fRetVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\commandlinesendfax\simple.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

   simple.c

Abstract:

    This module implements a simple command line fax-send utility with aborting options.
	/as - will abort the sent document within X msecs.
	/ar - will abort any receiv-job within X msecs.
	/aj - will abort a random job, leaving at least X jobs in Q.
    
--*/


#include <windows.h>
#include <winbase.h>
#include <stdio.h>
#include <stdlib.h>
#include <winfax.h>
#include <tchar.h>
#include <assert.h>
#include <shellapi.h>
#include <time.h>

#define SAFE_FaxFreeBuffer(pBuff) {FaxFreeBuffer(pBuff); pBuff = NULL;}



//
// forward declarations
//
DWORD GetDiffTime(DWORD dwFirstTime);

void GiveUsage(LPCTSTR AppName);

DWORD WINAPI SuicideThread(void *pVoid);

DWORD WINAPI SenderThread(void *pVoid);

//
// SEND_PARAMS is used to pass parameters to the SenderThread.
//
typedef struct SEND_PARAMS_tag
{
	HANDLE hFax;
	TCHAR *szDocument;
	PFAX_JOB_PARAM pJobParam;
	BOOL fThreadCompleted;
} SEND_PARAMS;


BOOL PerformKillerThreadCase(
	HANDLE hFax, 
	HANDLE hCompletionPort,
	TCHAR *szDocumentToFax, 
	PFAX_JOB_PARAM pJobParam,
	PFAX_COVERPAGE_INFO pCoverpageInfo,
	DWORD dwMilliSecondsBeforeSuicide,
	DWORD dwFirstTime
	);

//
// main
//
int _cdecl
main(
    int argc,
    char *argvA[]
    ) 
{
	TCHAR szDocumentToFax[MAX_PATH] = TEXT("");
	TCHAR szReceipientNumber[64] = TEXT("");
	TCHAR szCoverPageName[1024] = TEXT("");
	BOOL fUseCoverPage = FALSE;
	HANDLE hFax;
	HANDLE hCompletionPort = INVALID_HANDLE_VALUE;
	PFAX_JOB_PARAM pJobParam;
	PFAX_COVERPAGE_INFO pCoverpageInfo;
	DWORD dwSendJobId;
	DWORD dwReceiveJobId = -2;
	DWORD dwBytes;
	DWORD dwCompletionKey;
	PFAX_EVENT pFaxEvent;
	BOOL fMessageLoop = TRUE;
	DWORD dwRandomDidNotCatchCounter;
	int nLoopCount = 1;
	BOOL fJobQueued = FALSE;
	BOOL fJobDeleted = FALSE;
	BOOL fAbortTheSentJob = FALSE;
	BOOL fAbortReceiveJob = FALSE;
	BOOL fAbortRandomJob = FALSE;
    BOOL fVerifySend = FALSE;
	BOOL fKillMe = FALSE;
	BOOL fKillSenderThread = FALSE;
	int nMaxSleepBeforeAbortingSendJob = 0;
	int nMaxSleepBeforeAbortingReceiveJob = 0;
	DWORD dwAmountOfJobsToLeaveInQueue = 0;
	DWORD dwMilliSecondsBeforeSuicide = 0;
	DWORD dwFirstTime;
    TCHAR szServerName[64];
    TCHAR *pszServerName = NULL;
    int nBusyRetrySleep = 0;
	int retVal = -1;

	_tprintf( TEXT("Starting.\n") );

	LPTSTR *szArgv;
#ifdef UNICODE
	szArgv = CommandLineToArgvW( GetCommandLine(), &argc );
#else
	szArgv = argvA;
#endif

    //
    // set vars according to commandline switches
    //
	for (
        int nArgcount=0; 
        nArgcount < argc-1; // -1, because we always have a param after a /switch
        nArgcount++
        ) 
	{
		if ((szArgv[nArgcount][0] == L'/') || (szArgv[nArgcount][0] == L'-')) 
		{
			switch (towlower(szArgv[nArgcount][1])) 
			{
			//
			// all slash-single-letter params, followed by another param
			//
			case 't': // t == Terminate sender thread
				fKillSenderThread = TRUE;
				dwMilliSecondsBeforeSuicide = _ttoi(szArgv[nArgcount+1]);
				_tprintf( 
					TEXT("will terminate sender thread in no more that %d milliseconds after FaxSendDocument.\n"), 
					dwMilliSecondsBeforeSuicide 
					);
				break;

			case 'k': // k == Kill me (commit suicide)
				fKillMe = TRUE;
				dwMilliSecondsBeforeSuicide = _ttoi(szArgv[nArgcount+1]);
				_tprintf( 
					TEXT("will commit suicide in no more that %d milliseconds after FaxSendDocument.\n"), 
					dwMilliSecondsBeforeSuicide 
					);
				break;

			case 'b': // b == nBusyRetrySleep
				nBusyRetrySleep  = _ttoi(szArgv[nArgcount+1]);
				break;

			case 's': // s == pszServerName
				lstrcpy(szServerName, szArgv[nArgcount+1]);
                pszServerName = szServerName;
				break;

            case 'c': // c == use Cover page
				lstrcpy(szCoverPageName, szArgv[nArgcount+1]);
				fUseCoverPage = TRUE;
				break;

            case 'n': // n == szReceipientNumber to dial
				lstrcpy(szReceipientNumber, szArgv[nArgcount+1]);
				break;

            case 'd': // d == Document to fax
				lstrcpy(szDocumentToFax, szArgv[nArgcount+1]);
				break;

            case 'r': // r == Repeat count
				nLoopCount = _ttoi(szArgv[nArgcount+1]);
				_tprintf( TEXT("nLoopCount=%d.\n"), nLoopCount );
				break;

			//
			// all slash-double-letter params
			//
            case 'v': // aX == Abort an X
				switch (towlower(szArgv[nArgcount][2])) 
                {
				case 's':// vs == verify Send. wait for the completed event
					fVerifySend = TRUE;
					_tprintf(TEXT("will verify each queued job.\n"));
					break;

				default:
					GiveUsage(szArgv[0]);
					return 0;
				}

				break;

			//
			// all slash-double-letter params, followed by another param
			//
            case 'a': // aX == Abort an X
				switch (towlower(szArgv[nArgcount][2])) 
                {
				case 's':// as == Abort Send. Will abort the job that was sent.
					fAbortTheSentJob = TRUE;
					nMaxSleepBeforeAbortingSendJob = _ttoi(szArgv[nArgcount+1]);
					_tprintf( 
						TEXT("will abort send jobs after no more than %d milli.\n"), 
						nMaxSleepBeforeAbortingSendJob 
						);
					break;

				case 'r': // ar == Abort Receive. Abort any received job
					fAbortReceiveJob = TRUE;
					nMaxSleepBeforeAbortingReceiveJob = _ttoi(szArgv[nArgcount+1]);
					_tprintf( 
						TEXT("will abort receive jobs after no more than %d milli.\n"), 
						nMaxSleepBeforeAbortingReceiveJob 
						);
					break;

				case 'j': // aj == Abort Job. Abort a random job from the Q.
					fAbortRandomJob = TRUE;
					dwAmountOfJobsToLeaveInQueue = _ttoi(szArgv[nArgcount+1]);
					_tprintf( 
						TEXT("will abort a random job if there are more than %d jobs in the Q.\n"), 
						dwAmountOfJobsToLeaveInQueue 
						);
					break;

				default:
					GiveUsage(szArgv[0]);
					return 0;
				}

				break;

			}//switch (towlower(szArgv[nArgcount][1]))
		}//if ((szArgv[nArgcount][0] == L'/') || (szArgv[nArgcount][0] == L'-'))
	}//for (nArgcount=0; nArgcount<argc; nArgcount++)

	//
	// verify that command line parameters make sense.
	//
	if (szReceipientNumber[0] && !szDocumentToFax[0]) 
	{
		_tprintf( TEXT("Missing args: (szReceipientNumber[0] && !szDocumentToFax[0]).\n") );
		GiveUsage(szArgv[0]);
		return -1;
	}
	if (!szReceipientNumber[0] && szDocumentToFax[0]) 
	{
		_tprintf( TEXT("Missing args: (!szReceipientNumber[0] && szDocumentToFax[0]).\n") );
		GiveUsage(szArgv[0]);
		return -1;
	}

	if (fKillSenderThread && (!szReceipientNumber[0] || !szDocumentToFax[0])) 
	{
		_tprintf( TEXT("Missing args: fKillSenderThread && (!szReceipientNumber[0] || !szDocumentToFax[0]).\n") );
		GiveUsage(szArgv[0]);
		return -1;
	}

	if (fKillMe && (!szReceipientNumber[0] || !szDocumentToFax[0])) 
	{
		_tprintf( TEXT("Missing args: fKillMe && (!szReceipientNumber[0] || !szDocumentToFax[0]).\n") );
		GiveUsage(szArgv[0]);
		return -1;
	}



	if (!fAbortReceiveJob && !fAbortRandomJob && !fAbortTheSentJob && !szReceipientNumber[0] && !szDocumentToFax[0])
	{
		_tprintf( TEXT("ooops.\n") );
		GiveUsage(szArgv[0]);
		return -1;
	}

	//
	// connect to fax service
	//
	_tprintf( TEXT("Before FaxConnectFaxServer.\n") );
	if (!FaxConnectFaxServer(pszServerName,&hFax)) 
	{
		_tprintf( TEXT("ERROR: FaxConnectFaxServer(%s) failed, ec = %d\n"),pszServerName, GetLastError() );
		return -1;
	}
	_tprintf( TEXT("FaxConnectFaxServer(%s) succeeded.\n"), pszServerName );

	assert (hFax != NULL);

	_tprintf( TEXT("Before CreateIoCompletionPort.\n") );
	hCompletionPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE,NULL,0,0);
	if (!hCompletionPort) 
	{
		_tprintf( TEXT("ERROR: CreateIoCompletionPort failed, ec = %d\n"), GetLastError() );
		FaxClose( hFax );
		return -1;
	}
	_tprintf( TEXT("CreateIoCompletionPort succeeded.\n") );

   _tprintf( TEXT("Before FaxInitializeEventQueue.\n") );
	if (!FaxInitializeEventQueue(
		hFax,
		hCompletionPort,
		0,
		NULL, 
		0 ) ) 
	{
		_tprintf( TEXT("ERROR: FaxInitializeEventQueue failed, ec = %d\n"), GetLastError() );
		FaxClose( hFax );
		return -1;
	}
	_tprintf( TEXT("FaxInitializeEventQueue succeeded.\n") );

	_tprintf( TEXT("Before FaxCompleteJobParams.\n") );
	if (!FaxCompleteJobParams(&pJobParam,&pCoverpageInfo))
	{
		_tprintf( TEXT("ERROR: FaxCompleteJobParams failed, ec = %d\n"), GetLastError() );
		FaxClose( hFax );
		return -1;
	}
	_tprintf( TEXT("FaxCompleteJobParams succeeded.\n") );

	//
	// prepare the job params
	//
	pJobParam->RecipientNumber = szReceipientNumber;
	pJobParam->RecipientName = TEXT("pJobParam->RecipientName");
	pJobParam->SenderCompany = TEXT("pJobParam->SenderCompany");
	pJobParam->SenderDept = TEXT("pJobParam->SenderDept");
	pJobParam->BillingCode = TEXT("pJobParam->BillingCode");
	pJobParam->DeliveryReportAddress = TEXT("pJobParam->DeliveryReportAddress");
	pJobParam->DocumentName = szDocumentToFax;//TEXT("pJobParam->DocumentName");
	pJobParam->ScheduleAction = JSA_NOW;

/*
	_tprintf( TEXT("pJobParam->SizeOfStruct=%d.\n"), pJobParam->SizeOfStruct);
	_tprintf( TEXT("pJobParam->RecipientName=%s.\n"), pJobParam->RecipientName);
	_tprintf( TEXT("pJobParam->RecipientNumber=%s.\n"), pJobParam->RecipientNumber);
	_tprintf( TEXT("pJobParam->Tsid=%s.\n"), pJobParam->Tsid);
	_tprintf( TEXT("pJobParam->SenderName=%s.\n"), pJobParam->SenderName);
	_tprintf( TEXT("pJobParam->SenderCompany=%s.\n"), pJobParam->SenderCompany);
	_tprintf( TEXT("pJobParam->SenderDept=%s.\n"), pJobParam->SenderDept);
	_tprintf( TEXT("pJobParam->BillingCode=%s.\n"), pJobParam->BillingCode);
	_tprintf( TEXT("pJobParam->ScheduleAction=0x%08X.\n"), pJobParam->ScheduleAction);
	_tprintf( TEXT("pJobParam->DeliveryReportType=0x%08X.\n"), pJobParam->DeliveryReportType);
	_tprintf( TEXT("pJobParam->DeliveryReportAddress=%s.\n"), pJobParam->DeliveryReportAddress);
	_tprintf( TEXT("pJobParam->DocumentName=%s.\n"), pJobParam->DocumentName);
	_tprintf( TEXT("pJobParam->CallHandle=0x%08X.\n"), pJobParam->CallHandle);
	_tprintf( TEXT("pJobParam->Reserved[0]=0x%08X.\n"), pJobParam->Reserved[0]);
	_tprintf( TEXT("pJobParam->Reserved[1]=0x%08X.\n"), pJobParam->Reserved[1]);
	_tprintf( TEXT("pJobParam->Reserved[2]=0x%08X.\n"), pJobParam->Reserved[2]);
	_tprintf( TEXT("pJobParam->ScheduleTime.wYear=%d.\n"), pJobParam->ScheduleTime.wYear);
	_tprintf( TEXT("pJobParam->ScheduleTime.wMonth=%d.\n"), pJobParam->ScheduleTime.wMonth);
	_tprintf( TEXT("pJobParam->ScheduleTime.wDayOfWeek=%d.\n"), pJobParam->ScheduleTime.wDayOfWeek);
	_tprintf( TEXT("pJobParam->ScheduleTime.wDay=%d.\n"), pJobParam->ScheduleTime.wDay);
	_tprintf( TEXT("pJobParam->ScheduleTime.pJobParam->.wHour=%d.\n"), pJobParam->ScheduleTime.wHour);
	_tprintf( TEXT("pJobParam->ScheduleTime.wMinute=%d.\n"), pJobParam->ScheduleTime.wMinute);
	_tprintf( TEXT("pJobParam->ScheduleTime.wSecond=%d.\n"), pJobParam->ScheduleTime.wSecond);
	_tprintf( TEXT("pJobParam->ScheduleTime.wMilliseconds=%d.\n"), pJobParam->ScheduleTime.wMilliseconds);

*/
	//
	// prepare cover page info
	//
	if (fUseCoverPage)
	{
		pCoverpageInfo->CoverPageName = szCoverPageName;
		//pCoverpageInfo->CoverPageName = TEXT("e:\\nt\\private\\fax\\samples\\simple\\debug\\fyi.cov");
		pCoverpageInfo->RecName = TEXT("pCoverpageInfo->RecName");
		pCoverpageInfo->RecFaxNumber = TEXT("pCoverpageInfo->RecFaxNumber");
		pCoverpageInfo->RecCompany = TEXT("pCoverpageInfo->RecCompany");
		pCoverpageInfo->RecStreetAddress = TEXT("pCoverpageInfo->RecStreetAddress");
		pCoverpageInfo->RecCity = TEXT("pCoverpageInfo->RecCity");
		pCoverpageInfo->RecState = TEXT("pCoverpageInfo->RecState");
		pCoverpageInfo->RecZip = TEXT("pCoverpageInfo->RecZip");
		pCoverpageInfo->RecCountry = TEXT("pCoverpageInfo->RecCountry");
		pCoverpageInfo->RecTitle = TEXT("pCoverpageInfo->RecTitle");
		pCoverpageInfo->RecDepartment = TEXT("pCoverpageInfo->RecDepartment");
		pCoverpageInfo->RecOfficeLocation = TEXT("pCoverpageInfo->RecOfficeLocation");
		pCoverpageInfo->RecHomePhone = TEXT("pCoverpageInfo->RecHomePhone");
		pCoverpageInfo->RecOfficePhone = TEXT("pCoverpageInfo->RecOfficePhone");
		pCoverpageInfo->SdrName = TEXT("pCoverpageInfo->SdrName");
		pCoverpageInfo->SdrFaxNumber = TEXT("pCoverpageInfo->SdrFaxNumber pCoverpageInfo->SdrFaxNumber pCoverpageInfo->SdrFaxNumber pCoverpageInfo->SdrFaxNumber ");
		pCoverpageInfo->SdrCompany = TEXT("pCoverpageInfo->SdrCompany pCoverpageInfo->SdrCompany pCoverpageInfo->SdrCompany pCoverpageInfo->SdrCompany ");
		pCoverpageInfo->SdrAddress = TEXT("pCoverpageInfo->SdrAddress");
		pCoverpageInfo->SdrTitle = TEXT("pCoverpageInfo->SdrTitle");
		pCoverpageInfo->SdrDepartment = TEXT("pCoverpageInfo->SdrDepartment");
		pCoverpageInfo->SdrOfficeLocation = TEXT("pCoverpageInfo->SdrOfficeLocation");
		pCoverpageInfo->SdrHomePhone = TEXT("pCoverpageInfo->SdrHomePhone");
		pCoverpageInfo->SdrOfficePhone = TEXT("pCoverpageInfo->SdrOfficePhone");
		pCoverpageInfo->Note = TEXT("pCoverpageInfo->Note");
		pCoverpageInfo->Subject = TEXT("pCoverpageInfo->Subject pCoverpageInfo->Subject pCoverpageInfo->Subject pCoverpageInfo->Subject pCoverpageInfo->Subject ");
		GetLocalTime(&pCoverpageInfo->TimeSent);
		pCoverpageInfo->PageCount = 999;

		_tprintf( TEXT("pCoverpageInfo->SizeOfStruct=0x%08X.\n"), pCoverpageInfo->SizeOfStruct);
		_tprintf( TEXT("pCoverpageInfo->CoverPageName=%s.\n"), pCoverpageInfo->CoverPageName);
		_tprintf( TEXT("pCoverpageInfo->RecName=%s.\n"), pCoverpageInfo->RecName);
		_tprintf( TEXT("pCoverpageInfo->RecFaxNumber=%s.\n"), pCoverpageInfo->RecFaxNumber);
		_tprintf( TEXT("pCoverpageInfo->RecCompany=%s.\n"), pCoverpageInfo->RecCompany);
		_tprintf( TEXT("pCoverpageInfo->RecStreetAddress=%s.\n"), pCoverpageInfo->RecStreetAddress);
		_tprintf( TEXT("pCoverpageInfo->RecCity=%s.\n"), pCoverpageInfo->RecCity);
		_tprintf( TEXT("pCoverpageInfo->RecState=%s.\n"), pCoverpageInfo->RecState);
		_tprintf( TEXT("pCoverpageInfo->RecZip=%s.\n"), pCoverpageInfo->RecZip);
		_tprintf( TEXT("pCoverpageInfo->RecCountry=%s.\n"), pCoverpageInfo->RecCountry);
		_tprintf( TEXT("pCoverpageInfo->RecTitle=%s.\n"), pCoverpageInfo->RecTitle);
		_tprintf( TEXT("pCoverpageInfo->RecDepartment=%s.\n"), pCoverpageInfo->RecDepartment);
		_tprintf( TEXT("pCoverpageInfo->RecOfficeLocation=%s.\n"), pCoverpageInfo->RecOfficeLocation);
		_tprintf( TEXT("pCoverpageInfo->RecHomePhone=%s.\n"), pCoverpageInfo->RecHomePhone);
		_tprintf( TEXT("pCoverpageInfo->RecOfficePhone=%s.\n"), pCoverpageInfo->RecOfficePhone);
		_tprintf( TEXT("pCoverpageInfo->SdrName=%s.\n"), pCoverpageInfo->SdrName);
		_tprintf( TEXT("pCoverpageInfo->SdrFaxNumber=%s.\n"), pCoverpageInfo->SdrFaxNumber);
		_tprintf( TEXT("pCoverpageInfo->SdrCompany=%s.\n"), pCoverpageInfo->SdrCompany);
		_tprintf( TEXT("pCoverpageInfo->SdrAddress=%s.\n"), pCoverpageInfo->SdrAddress);
		_tprintf( TEXT("pCoverpageInfo->SdrTitle=%s.\n"), pCoverpageInfo->SdrTitle);
		_tprintf( TEXT("pCoverpageInfo->SdrDepartment=%s.\n"), pCoverpageInfo->SdrDepartment);
		_tprintf( TEXT("pCoverpageInfo->SdrOfficeLocation=%s.\n"), pCoverpageInfo->SdrOfficeLocation);
		_tprintf( TEXT("pCoverpageInfo->SdrHomePhone=%s.\n"), pCoverpageInfo->SdrHomePhone);
		_tprintf( TEXT("pCoverpageInfo->SdrOfficePhone=%s.\n"), pCoverpageInfo->SdrOfficePhone);
		_tprintf( TEXT("pCoverpageInfo->Note=%s.\n"), pCoverpageInfo->Note);
		_tprintf( TEXT("pCoverpageInfo->Subject=%s.\n"), pCoverpageInfo->Subject);
		_tprintf( TEXT("pCoverpageInfo->UseServerCoverPage=%d.\n"), pCoverpageInfo->UseServerCoverPage);
		_tprintf( TEXT("pCoverpageInfo->PageCount=%d.\n"), pCoverpageInfo->PageCount);
		_tprintf( TEXT("pCoverpageInfo->TimeSent.wYear=%d.\n"), pCoverpageInfo->TimeSent.wYear);
		_tprintf( TEXT("pCoverpageInfo->TimeSent.wMonth=%d.\n"), pCoverpageInfo->TimeSent.wMonth);
		_tprintf( TEXT("pCoverpageInfo->TimeSent.wDayOfWeek=%d.\n"), pCoverpageInfo->TimeSent.wDayOfWeek);
		_tprintf( TEXT("pCoverpageInfo->TimeSent.wDay=%d.\n"), pCoverpageInfo->TimeSent.wDay);
		_tprintf( TEXT("pCoverpageInfo->TimeSent.pCoverpageInfo->.wHour=%d.\n"), pCoverpageInfo->TimeSent.wHour);
		_tprintf( TEXT("pCoverpageInfo->TimeSent.wMinute=%d.\n"), pCoverpageInfo->TimeSent.wMinute);
		_tprintf( TEXT("pCoverpageInfo->TimeSent.wSecond=%d.\n"), pCoverpageInfo->TimeSent.wSecond);
		_tprintf( TEXT("pCoverpageInfo->TimeSent.wMilliseconds=%d.\n"), pCoverpageInfo->TimeSent.wMilliseconds);
	}//if (fUseCoverPage)

	//
	// each print will show the diff time from now.
	//
	dwFirstTime = GetTickCount();

	//
	// perform nLoopCount loops.
	// each loop sends a job.
	// if we have the command line swith /as (fAbortTheSentJob), the job will be aborted
	//   some time after it's queued.
	// if we have the command line swith /ar (fAbortReceiveJob), a received job will be aborted
	//   some time after it's noticed.
	// if we have the command line swith /aj (fAbortRandomJob), a random job will be aborted
	//   some time after it's noticed.
	//
	srand( (unsigned)time( NULL ) );
	while(nLoopCount--)
	{
		fJobQueued = FALSE;
		//
		// if we actually send a document
		//
		if (szReceipientNumber[0] && szDocumentToFax[0]) 
		{
			if (fKillSenderThread)
			{
				if (!PerformKillerThreadCase(
						hFax,
						hCompletionPort,
						szDocumentToFax,
						pJobParam,
						pCoverpageInfo,
						dwMilliSecondsBeforeSuicide,
						dwFirstTime
						)
				   )
				{
					goto out;
				}
				continue; // to while(nLoopCount--)
			}
			else
			{
				_tprintf( TEXT("(%d) NOT launching sender thread.\n"), GetDiffTime(dwFirstTime) );
			}

			//
			// if the suicide switch is on, call the suicide thread that will call _exit(1)
			//
			if (fKillMe)
			{
				DWORD dwThreadId;
				HANDLE hSuicideThread = CreateThread(
					NULL,// pointer to thread security attributes
					0,      // initial thread stack size, in bytes
					SuicideThread,// pointer to thread function
					(void*)dwMilliSecondsBeforeSuicide,     // argument for new thread
					0,  // creation flags
					&dwThreadId      // pointer to returned thread identifier
					);
				if (NULL == hSuicideThread)
				{
					_tprintf( TEXT("(%d) ERROR: CreateThread(hSuicideThread) failed, ec = %d \n"), GetDiffTime(dwFirstTime), GetLastError() );
					FaxClose( hFax );
					CloseHandle( hCompletionPort );
					SAFE_FaxFreeBuffer(pJobParam);
					SAFE_FaxFreeBuffer(pCoverpageInfo);
					goto out;
				}
				_tprintf( TEXT("(%d) killer thread created.\n"), GetDiffTime(dwFirstTime) );
			}
			else
			{
				_tprintf( TEXT("(%d) not committing suicide.\n"), GetDiffTime(dwFirstTime) );
			}

			//
			// send a fax document
			//
			_tprintf( 
				TEXT("(%d) Before FaxSendDocument %s cover page.\n"), 
				GetDiffTime(dwFirstTime),
				fUseCoverPage ? TEXT("++with++") : TEXT("--without--")
				);
			if (!FaxSendDocument(
					hFax,
					szDocumentToFax,
					pJobParam,
					fUseCoverPage ? pCoverpageInfo : NULL ,
					&dwSendJobId) 
			  )
			{
				_tprintf( TEXT("(%d) ERROR: FaxSendDocument failed, ec = %d \n"), GetDiffTime(dwFirstTime), GetLastError() );
				FaxClose( hFax );
				CloseHandle( hCompletionPort );
				SAFE_FaxFreeBuffer(pJobParam);
				SAFE_FaxFreeBuffer(pCoverpageInfo);
				goto out;
			}

			_tprintf( TEXT("(%d) FaxSendDocument(%s) succeeded, phone#=%s, JobID = %d\n"),
				GetDiffTime(dwFirstTime),
				szDocumentToFax,
				szReceipientNumber,
				dwSendJobId 
				);
		}//if (szReceipientNumber[0] && szDocumentToFax[0])

		//
		// if there's nothing to abort, or no need to verify send, continue queuing jobs
		//
		if ((!fAbortTheSentJob) && (!fAbortReceiveJob) && (!fAbortRandomJob) && (!fVerifySend))
		{
			_tprintf( TEXT("((!fAbortTheSentJob) && (!fAbortReceiveJob) && (!fAbortRandomJob) && (!fVerifySend))\n"));
			continue;//while(nLoopCount--)
		}

		//
		// mark the job as not deleted yet
		//
		fJobDeleted = FALSE;

		//
		// get messages until getting the expected message.
		// for example, if fAbortTheSentJob, then wait for this job to be deleted
		//
		dwRandomDidNotCatchCounter = 0;
		fMessageLoop = TRUE;
		while (fMessageLoop) 
		{
			//
			// used to know if to translate a message
			//
			BOOL fGetQueuedCompletionStatusTimedOut = FALSE;

			//
			// I don't want to be blocked on this call, since I want to be able 
			// to abort the job at a random time.
			// therefor I wait for 1 millisecond for a message
			//
			if (!GetQueuedCompletionStatus(
					hCompletionPort,
					&dwBytes,
					&dwCompletionKey,
					(LPOVERLAPPED *)&pFaxEvent,
					1
					)
			   )
			{
				DWORD dwLastError = GetLastError();

				if (WAIT_TIMEOUT != dwLastError)
				{
					_tprintf( 
						TEXT("(%d) ERROR: GetQueuedCompletionStatus() failed with %d\n"),
						GetDiffTime(dwFirstTime),
						dwLastError
						);
					goto out;
				}

				//
				// we timed out.
				// mark, so that we will not try to translate a non-existing message
				//
				fGetQueuedCompletionStatusTimedOut = TRUE;
			}

			//
			// if aborting any job, enumerate the jobs and choose 1 randomly and delete it.
			// we may fail, since the job may meanwhile comlete, or be deleted by someone else
			//
			if (fAbortRandomJob)
			{
				PFAX_JOB_ENTRY aJobEntry;
				DWORD dwJobsReturned;
				DWORD dwJobIndexToAbort;

				if (!FaxEnumJobs(
					hFax,          // handle to the fax server
					&aJobEntry,  // buffer to receive array of job data
					&dwJobsReturned       // number of fax job structures returned
					)
				   )
				{
					_tprintf( 
						TEXT("(%d) ERROR:FaxEnumJobs() failed with %d\n"),
						GetDiffTime(dwFirstTime),
						GetLastError() 
						);
					goto out;
				}

				//
				// print no more than 1 message per second
				//
				if (0 == (nLoopCount % 1000))
				{
					_tprintf( 
						TEXT("(%d) FaxEnumJobs() returned %d jobs\n"),
						GetDiffTime(dwFirstTime),
						dwJobsReturned 
						);
				}

				if ( (0 == dwJobsReturned) && (0 == dwAmountOfJobsToLeaveInQueue) )
				{
					//
					// there's nothing to delete, keep polling
					//
					break;
				}

				if ( (0 != dwJobsReturned) && (dwAmountOfJobsToLeaveInQueue < dwJobsReturned) )
				{
					dwJobIndexToAbort = rand() % dwJobsReturned;
					_tprintf( 
						TEXT("(%d) aborting job %d\n"),
						GetDiffTime(dwFirstTime),
						aJobEntry[dwJobIndexToAbort].JobId
						);

					if (!FaxAbort(
							hFax,  // handle to the fax server
							aJobEntry[dwJobIndexToAbort].JobId // identifier of fax job to terminate
							)
						)
					{
						DWORD dwLastError = GetLastError();
						if (ERROR_INVALID_PARAMETER != dwLastError)
						{
							_tprintf( 
								TEXT("(%d) ERROR:FaxAbort dwSendJobId %d failed with %d.\n"),
								GetDiffTime(dwFirstTime),
								aJobEntry[dwJobIndexToAbort].JobId,
								GetLastError() 
								);
							goto out;
						}

						//
						// print no more than 1 message per second
						//
						if (0 == (nLoopCount % 1000))
						{
							_tprintf( 
								TEXT("(%d) :FaxAbort dwSendJobId %d failed with ERROR_INVALID_PARAMETER.\n  Could be that this job was completed or aborted by someone else\n"),
								GetDiffTime(dwFirstTime),
								aJobEntry[dwJobIndexToAbort].JobId,
								GetLastError() 
								);
						}
					}
					else
					{
						//
						//hack: this way i can tell if the job was deleted
						//
						dwSendJobId = aJobEntry[dwJobIndexToAbort].JobId;
					}
				}//if ( (0 != dwJobsReturned) && (dwAmountOfJobsToLeaveInQueue < dwJobsReturned) )
				else
				{
					//
					// print no more than 1 message per second
					//
					if (0 == (nLoopCount % 1000))
					{
						_tprintf( 
							TEXT("(%d) will not abort, %d jobs in Q, need to leave %d jobs in Q\n"),
							GetDiffTime(dwFirstTime),
							dwJobsReturned,
							dwAmountOfJobsToLeaveInQueue
							);
					}
				}

				SAFE_FaxFreeBuffer(aJobEntry);
			}//if (fAbortRandomJob)

			//
			// abort this job if needed
			//
			if ( fAbortTheSentJob && fJobQueued )
			{
				int iSleep = (nMaxSleepBeforeAbortingSendJob == 0) ? 0 : rand()%nMaxSleepBeforeAbortingSendJob;;
				dwRandomDidNotCatchCounter = 0;

				_tprintf( TEXT("(%d) will abort job %d after sleeping %d milli\n"), GetDiffTime(dwFirstTime),dwSendJobId, iSleep );

                Sleep(iSleep);

				_tprintf( TEXT("(%d) aborting send job %d\n"), GetDiffTime(dwFirstTime),dwSendJobId );
				if (!FaxAbort(
						hFax,  // handle to the fax server
						dwSendJobId        // identifier of fax job to terminate
						)
				   )
				{
                    if (::GetLastError() != ERROR_INVALID_PARAMETER)
                    {
					    _tprintf( 
						    TEXT("(%d) ERROR:FaxAbort dwSendJobId %d failed with ERROR_INVALID_PARAMETER, job has probably completed.\n"),
						    GetDiffTime(dwFirstTime),
						    dwSendJobId
						    );
                    }
                    else
                    {
					    _tprintf( 
						    TEXT("(%d) ERROR:FaxAbort dwSendJobId %d failed with %d\n"),
						    GetDiffTime(dwFirstTime),
						    dwSendJobId,
						    GetLastError() 
						    );
					    goto out;
                    }
				}

                //
                // BUGBUG: this sleep is for Asaf
                //
				_tprintf( TEXT("(%d) after abort job %d, will sleep %d milli\n"), GetDiffTime(dwFirstTime),dwSendJobId, nBusyRetrySleep );
                ::Sleep(nBusyRetrySleep);

				fJobQueued = FALSE;
				_tprintf( TEXT("(%d) <<<<<<dwSendJobId %d aborted\n"), GetDiffTime(dwFirstTime),dwSendJobId );
			}
			else
			{
				dwRandomDidNotCatchCounter++;
				if (20000 < dwRandomDidNotCatchCounter)
				{
					dwRandomDidNotCatchCounter = 0;
					_tprintf( TEXT("(%d) dwRandomDidNotCatchCounter=%d\n"), GetDiffTime(dwFirstTime),dwRandomDidNotCatchCounter );
				}
			}

			//
			// we will not try to translate a non-existing message
			//
			if (fGetQueuedCompletionStatusTimedOut)
			{
				continue;
			}

			//
			// translate the message
			// all events are ignored, except:
			// FEI_COMPLETED - for tiff files large enough, we should not get it, since we abort
			// FEI_JOB_QUEUED - mark that our job is queued
			// FEI_FATAL_ERROR - ignored only if receive-abort is enabled.
			// FEI_ANSWERED - if receive-abort is enabled, abort the job within random time
			// FEI_DELETED - mark job as deleted. this means that we may finish the loop.
			//
			//
			// the following events cause immediate termination:
			//   FEI_MODEM_POWERED_OFF
			//   FEI_FAXSVC_ENDED
			//   FEI_BAD_ADDRESS
			//   FEI_NO_DIAL_TONE
			//   FEI_DISCONNECTED
			//   FEI_NOT_FAX_CALL
			//   default
			//
			_tprintf( TEXT("(%d) Received event 0x%x\n"), GetDiffTime(dwFirstTime),pFaxEvent->EventId);

			switch (pFaxEvent->EventId) 
			{
			case FEI_IDLE:
				_tprintf( TEXT("(%d) JobId %d FEI_IDLE\n"), GetDiffTime(dwFirstTime),pFaxEvent->JobId );
				break;

			case FEI_INITIALIZING:
				_tprintf( TEXT("(%d) JobId %d FEI_INITIALIZING\n"), GetDiffTime(dwFirstTime),pFaxEvent->JobId );
				break;

			case FEI_COMPLETED:
				_tprintf( TEXT("(%d) JobId %d FEI_COMPLETED\n\n"), GetDiffTime(dwFirstTime),pFaxEvent->JobId );

				if ((dwSendJobId == pFaxEvent->JobId) && fAbortTheSentJob)
				{
					//
					// it should have been aborted
					//
					_tprintf( TEXT("(%d) JobId %d FEI_COMPLETED, but should have been aborted\n"), GetDiffTime(dwFirstTime),pFaxEvent->JobId );
					goto out;
				}

				if ((dwSendJobId == pFaxEvent->JobId) && fVerifySend)
				{
					//
					// it should have been aborted
					//
					_tprintf( TEXT("(%d) JobId %d FEI_COMPLETED as expected\n"), GetDiffTime(dwFirstTime),pFaxEvent->JobId );
    				fMessageLoop = FALSE;
				}

				fMessageLoop = FALSE;

				break;

			case FEI_MODEM_POWERED_ON: 
				_tprintf( TEXT("(%d) JobId %d FEI_MODEM_POWERED_ON\n"), GetDiffTime(dwFirstTime),pFaxEvent->JobId );
				break;

			case FEI_MODEM_POWERED_OFF:
				_tprintf( TEXT("(%d) JobId %d FEI_MODEM_POWERED_OFF\n"), GetDiffTime(dwFirstTime),pFaxEvent->JobId );
				goto out;
				break;

			case FEI_FAXSVC_ENDED:     
				_tprintf( TEXT("(%d) JobId %d FEI_FAXSVC_ENDED\n"), GetDiffTime(dwFirstTime),pFaxEvent->JobId );
				goto out;
				break;

			case FEI_JOB_QUEUED:
				_tprintf( TEXT("(%d) >>>>>>JobId %d queued\n"), GetDiffTime(dwFirstTime),pFaxEvent->JobId );
				if ((dwSendJobId == pFaxEvent->JobId) && fAbortTheSentJob)
				{
    				_tprintf( TEXT("(%d) >>>>>>JobId %d queued, mark: fJobQueued = TRUE\n"), GetDiffTime(dwFirstTime),pFaxEvent->JobId );
					fJobQueued = TRUE;
				}
				break;

			case FEI_DIALING:          
				_tprintf( TEXT("(%d) JobId %d FEI_DIALING\n"), GetDiffTime(dwFirstTime),pFaxEvent->JobId );
				break;

			case FEI_SENDING:          
				_tprintf( TEXT("(%d) JobId %d FEI_SENDING\n"), GetDiffTime(dwFirstTime),pFaxEvent->JobId );
				break;

			case FEI_RECEIVING:              
				_tprintf( TEXT("(%d) JobId %d FEI_RECEIVING\n"), GetDiffTime(dwFirstTime),pFaxEvent->JobId );
				break;

			case FEI_BUSY:  
				_tprintf( TEXT("(%d) JobId %d FEI_BUSY\n"), GetDiffTime(dwFirstTime),pFaxEvent->JobId );
				break;

			case FEI_NO_ANSWER:        
				_tprintf( TEXT("(%d) JobId %d FEI_NO_ANSWER\n"), GetDiffTime(dwFirstTime),pFaxEvent->JobId );
				break;

			case FEI_BAD_ADDRESS:      
				_tprintf( TEXT("(%d) ERROR: JobId %d FEI_BAD_ADDRESS\n"), GetDiffTime(dwFirstTime),pFaxEvent->JobId );
				goto out;

			case FEI_NO_DIAL_TONE:     
				_tprintf( TEXT("(%d) ERROR: JobId %d FEI_NO_DIAL_TONE\n"), GetDiffTime(dwFirstTime),pFaxEvent->JobId );
				goto out;

			case FEI_DISCONNECTED:           
				_tprintf( TEXT("(%d) JobId %d FEI_DISCONNECTED\n"), GetDiffTime(dwFirstTime),pFaxEvent->JobId );
				goto out;

			case FEI_FATAL_ERROR:      
				_tprintf( TEXT("(%d) JobId %d: FEI_FATAL_ERROR\n"), GetDiffTime(dwFirstTime),pFaxEvent->JobId );

				if (fAbortTheSentJob || fAbortReceiveJob || fAbortRandomJob)
				{
					//
					// can happen due to aborts
					//
					break;
				}

				//
				// error
				//
				_tprintf( TEXT("(%d) JobId %d FEI_FATAL_ERROR, but there were no aborts\n"), GetDiffTime(dwFirstTime),pFaxEvent->JobId );
				goto out;
				break;

			case FEI_NOT_FAX_CALL:          
				_tprintf( TEXT("(%d) ERROR: JobId %d FEI_NOT_FAX_CALL\n"), GetDiffTime(dwFirstTime),pFaxEvent->JobId );
				goto out;

			case FEI_CALL_BLACKLISTED:          
				_tprintf( TEXT("(%d) ERROR: JobId %d FEI_CALL_BLACKLISTED\n"), GetDiffTime(dwFirstTime),pFaxEvent->JobId );
				goto out;

			case FEI_RINGING:          
				_tprintf( TEXT("(%d) JobId %d FEI_RINGING\n"), GetDiffTime(dwFirstTime),pFaxEvent->JobId );
				break;

			case FEI_ABORTING:          
				_tprintf( TEXT("(%d) JobId %d FEI_ABORTING\n"), GetDiffTime(dwFirstTime),pFaxEvent->JobId );
				if ((dwSendJobId == pFaxEvent->JobId) && fVerifySend)
				{
					//
					// it should have been aborted
					//
					_tprintf( TEXT("(%d) JobId %d FEI_ABORTING but fVerifySend\n"), GetDiffTime(dwFirstTime),pFaxEvent->JobId );
    				goto out;
				}
				break;

			case FEI_ROUTING:          
				_tprintf( TEXT("(%d) JobId %d FEI_ROUTING\n"), GetDiffTime(dwFirstTime),pFaxEvent->JobId );
				break;

			case FEI_ANSWERED:          
				_tprintf( TEXT("(%d) JobId %d FEI_ANSWERED\n"), GetDiffTime(dwFirstTime),pFaxEvent->JobId );

				//
				// delete any incoming job, within random time, up to 20 secs
				// this job may be a job that another application / thread will abort
				// so accept failure with ERROR_INVALID_PARAMETER
				//
				//TODO: use a timer, and another thread to FaxAbort()
				if (fAbortReceiveJob)
				{
					int nSleep = nMaxSleepBeforeAbortingReceiveJob == 0 ? 0 : rand()%nMaxSleepBeforeAbortingReceiveJob;
					_tprintf( 
						TEXT("(%d) sleeping %d milli before aborting receive job %d\n"), 
						GetDiffTime(dwFirstTime),
						nSleep,
						pFaxEvent->JobId 
						);
					Sleep(nSleep);

					_tprintf( TEXT("(%d) aborting receive job %d\n"), GetDiffTime(dwFirstTime),pFaxEvent->JobId );
					if (!FaxAbort(
							hFax,  // handle to the fax server
							pFaxEvent->JobId        // identifier of fax job to terminate
							)
					   )
					{
						DWORD dwLastError = GetLastError();

						if (ERROR_INVALID_PARAMETER != dwLastError)
						{
							_tprintf( 
							TEXT("(%d) ERROR:FaxAbort(receive job) JobId %d failed with %d\n"),
							GetDiffTime(dwFirstTime),
							pFaxEvent->JobId,
							dwLastError 
							);
							goto out;
						}
						_tprintf( TEXT("(%d) <<<<<<JobId %d abortion failed, probably aborted by another app\n"), GetDiffTime(dwFirstTime),pFaxEvent->JobId );
					}
					else
					{
						_tprintf( TEXT("(%d) <<<<<<JobId %d aborted\n"), GetDiffTime(dwFirstTime),pFaxEvent->JobId );
					}
				}//if (fAbortReceiveJob)
				break;

			case FEI_FAXSVC_STARTED:          
				_tprintf( TEXT("(%d) JobId %d FEI_FAXSVC_STARTED\n"), GetDiffTime(dwFirstTime),pFaxEvent->JobId );
				break;

			case FEI_CALL_DELAYED:          
				_tprintf( TEXT("(%d) JobId %d FEI_CALL_DELAYED\n"), GetDiffTime(dwFirstTime),pFaxEvent->JobId );
				break;

			case FEI_LINE_UNAVAILABLE:          
				_tprintf( TEXT("(%d) JobId %d FEI_LINE_UNAVAILABLE\n"), GetDiffTime(dwFirstTime),pFaxEvent->JobId );
				break;

			case FEI_HANDLED:          
				_tprintf( TEXT("(%d) JobId %d FEI_HANDLED\n"), GetDiffTime(dwFirstTime),pFaxEvent->JobId );
				break;

			case FEI_DELETED: 
				_tprintf( TEXT("(%d) JobId %d FEI_DELETED\n"), GetDiffTime(dwFirstTime),pFaxEvent->JobId );

				if (dwSendJobId == pFaxEvent->JobId)
				{
					if(fAbortRandomJob || fAbortTheSentJob || fAbortReceiveJob)
					{
						//
						// expected send-job deletion
						//
						fJobDeleted = TRUE;
						fMessageLoop = FALSE;
						fJobQueued = FALSE;
					}
					else
					{
						//
						// unexpected delete
						//
						_tprintf( TEXT("(%d) JobId %d FEI_DELETED, but was not aborted\n"), GetDiffTime(dwFirstTime),pFaxEvent->JobId );
						goto out;
					}
				}
				else if (!fAbortReceiveJob)
				{
					//
					// unexpected delete.
					// some other app / person deleted a job
					//
					//_tprintf( TEXT("(%d) JobId %d FEI_DELETED, but recv was not aborted\n"), GetDiffTime(dwFirstTime),pFaxEvent->JobId );
					//goto out;
				}

				break;

			default:
				_tprintf( 
					TEXT("(%d) DEFAULT!!! JobId %d reached default!, pFaxEvent->EventId=%d\n"),
					GetDiffTime(dwFirstTime),
					pFaxEvent->JobId, 
					pFaxEvent->EventId 
					);
				goto out;

			}//switch (pFaxEvent->EventId)
		}//while (fMessageLoop)

		if (fAbortTheSentJob && !fJobDeleted)
		{
			_tprintf(
				TEXT("(%d) INTERNAL ERROR: (fAbortTheSentJob && !fJobDeleted) outside loop.\n"), 
				GetDiffTime(dwFirstTime)
				);
		}
	}//while(nLoopCount--)

	//
	// success
	//
	retVal = 0;

out:
	SAFE_FaxFreeBuffer( pJobParam );
	SAFE_FaxFreeBuffer( pCoverpageInfo );

	FaxClose( hFax );
	CloseHandle( hCompletionPort );

	if (0 != retVal)
	{
		_tprintf( TEXT("(%d) FAILED!\n"), GetDiffTime(dwFirstTime),dwSendJobId );
        if (fVerifySend)
        {
            MessageBox(NULL, TEXT("failed"), TEXT("simple.exe"), MB_OK);
        }
	}
	else
	{
		_tprintf( TEXT("(%d) success.\n"), GetDiffTime(dwFirstTime),dwSendJobId );
	}

	return retVal;
}//main()


DWORD GetDiffTime(DWORD dwFirstTime)
{
	DWORD dwNow = GetTickCount();
	if (dwFirstTime <= dwNow) return dwNow - dwFirstTime;

	return 0xFFFFFFFF - dwFirstTime + dwNow;
}



void GiveUsage(LPCTSTR AppName)
{
   _tprintf( TEXT("Usage : \n"));
   _tprintf( TEXT("  %s [/c <cover page filename>] /d <full path to doc> /n <number> /r <repeat count> \n"),AppName);
   _tprintf( TEXT("Or : \n"));
   _tprintf( TEXT("  %s [/c <cover page filename>] /d <full path to doc> /n <number> /r <repeat count> /as <max sleep before aborting this document> \n"),AppName);
   _tprintf( TEXT("Or : \n"));
   _tprintf( TEXT("  %s [[/c <cover page filename>] /d <full path to doc> /n <number>] /r <repeat count> /ar <max sleep before aborting the next receive job>\n"),AppName);
   _tprintf( TEXT("Or : \n"));
   _tprintf( TEXT("  %s [[/c <cover page filename>] /d <full path to doc> /n <number>] /r <repeat count> /aj <num of jobs to leave in Q>\n"),AppName);
   _tprintf( TEXT("Or : \n"));
   _tprintf( TEXT("  %s [/c <cover page filename>] /d <full path to doc> /n <number> /r <repeat count> /t <max msecs until sender thread termination>\n"),AppName);
   _tprintf( TEXT("Or : \n"));
   _tprintf( TEXT("  %s [/c <cover page filename>] /d <full path to doc> /n <number> /r <repeat count> /k <max msecs until killing myself>\n"),AppName);
   _tprintf( TEXT("Or : \n"));
   _tprintf( TEXT("  %s /?\n"),AppName);

}

//
// this thread will call _exit(-1) within (rand()%(DWORD) pVoid) milliseconds
//
DWORD WINAPI SuicideThread(void *pVoid)
{
	DWORD dwMilliSecondsBeforeSuicide = rand()%(DWORD) pVoid;
   _tprintf(TEXT("Comitting suicide in %d milliseconds\n"),dwMilliSecondsBeforeSuicide);
	Sleep(dwMilliSecondsBeforeSuicide);
	_exit(-1);
	return 0;
}

//
// SenderThread.
// just calls FaxSendDocument(), that's it.
// The paramter is memory-managed by the caller, so no need to free anything.
//
DWORD WINAPI SenderThread(void *pVoid)
{
	SEND_PARAMS *PSendParams = (SEND_PARAMS *)pVoid;
	DWORD dwSendJobId;
	_tprintf( TEXT("Before FaxSendDocument(%s).\n"), PSendParams->szDocument);
	if (!FaxSendDocument( PSendParams->hFax, PSendParams->szDocument, PSendParams->pJobParam, NULL , &dwSendJobId) ) {
		_tprintf( TEXT("ERROR: FaxSendDocument failed, ec = %d \n"), GetLastError() );
		PSendParams->fThreadCompleted = TRUE;
		return GetLastError();
	}
	else
	{
		_tprintf( TEXT("FaxSendDocument succeeded.\n"));
		PSendParams->fThreadCompleted = TRUE;
		return 0;
	}
}


BOOL PerformKillerThreadCase(
	HANDLE hFax, 
	HANDLE hCompletionPort,
	TCHAR *szDocumentToFax, 
	PFAX_JOB_PARAM pJobParam,
	PFAX_COVERPAGE_INFO pCoverpageInfo,
	DWORD dwMilliSecondsBeforeSuicide,
	DWORD dwFirstTime
	)
{
	HANDLE hSenderThread;
	DWORD dwThreadId;
	SEND_PARAMS sendParams;

	//
	// prepare thread params and launch the thread
	//
	sendParams.hFax = hFax;
	sendParams.szDocument = szDocumentToFax;
	sendParams.pJobParam = pJobParam;
	sendParams.fThreadCompleted = FALSE;

	hSenderThread = CreateThread(
		NULL,// pointer to thread security attributes
		0,      // initial thread stack size, in bytes
		SenderThread,// pointer to thread function
		(void*)&sendParams,     // argument for new thread
		0,  // creation flags
		&dwThreadId      // pointer to returned thread identifier
		);
	if (NULL == hSenderThread)
	{
		_tprintf( TEXT("(%d) ERROR: CreateThread(hSenderThread) failed, ec = %d \n"), GetDiffTime(dwFirstTime), GetLastError() );
		FaxClose( hFax );
		CloseHandle( hCompletionPort );
		SAFE_FaxFreeBuffer(pJobParam);
		SAFE_FaxFreeBuffer(pCoverpageInfo);
		return FALSE;
	}

	//
	// sleep a randon time, no more than dwMilliSecondsBeforeSuicide.
	//
	{
		DWORD dwSleep = rand()%dwMilliSecondsBeforeSuicide;
		_tprintf(TEXT("killing thread in %d milliseconds\n"),dwSleep);
		Sleep(dwSleep);
	}

	//
	// trminate the thread
	//
	if (!TerminateThread(hSenderThread, 0))
	{
		//
		// we may fail if the thread has terminated before we tried to.
		//
		if (!sendParams.fThreadCompleted)
		{
			_tprintf( TEXT("(%d) ERROR: TerminateThread(hSenderThread) failed, ec = %d \n"), GetDiffTime(dwFirstTime), GetLastError() );
			return FALSE;
		}
		else
		{
			//
			// thread has completed, check out if it failed
			//
			DWORD dwSenderThreadExitCode;
			if (!GetExitCodeThread(hSenderThread, &dwSenderThreadExitCode))
			{
				_tprintf( TEXT("(%d) ERROR: GetExitCodeThread(hSenderThread) failed, ec = %d \n"), GetDiffTime(dwFirstTime), GetLastError() );
				return FALSE;
			}

			//
			// verify that the thread succeeded
			//
			if (0 != dwSenderThreadExitCode)
			{
				_tprintf( TEXT("(%d) ERROR: hSenderThread returned %d instead 0\n"), GetDiffTime(dwFirstTime), dwSenderThreadExitCode );
				return FALSE;
			}

			_tprintf( TEXT("(%d) Thread has completed successfully before it was terminated\n"), GetDiffTime(dwFirstTime));
		}
	}

	if (!CloseHandle(hSenderThread))
	{
		_tprintf( TEXT("(%d) ERROR: CloseHandle(hSenderThread) failed, ec = %d \n"), GetDiffTime(dwFirstTime), GetLastError() );
		return FALSE;
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\jobmngr\cbasefaxjob.h ===
#ifndef _BASE_FAX_JOB_H
#define _BASE_FAX_JOB_H

#include <winfax.h>
#include <AutoPtrs.h>
#include <CFaxEvent.h>

class CBaseFaxJob
{
public:
	CBaseFaxJob():
		hOperationThread(NULL),
		m_hFax(NULL),
		m_EvJobCompleted(NULL, FALSE, FALSE,TEXT("")),
		m_EvJobSending(NULL, FALSE, FALSE,TEXT("")),
		m_EvOperationCompleted(NULL, FALSE, FALSE,TEXT("")){};

	virtual ~CBaseFaxJob(){}; 
	virtual DWORD HandleMessage(CFaxEvent& pFaxEvent) = 0;
	virtual DWORD StartOperation() = 0;
	HANDLE GethEvJobCompleted()const {return  m_EvJobCompleted.get();};
	HANDLE GethEvJobSending()const {return  m_EvJobSending.get();};
	HANDLE GethEvOperationCompleted()const {return m_EvOperationCompleted.get();};
	void SetFaxHandle(HANDLE hFax){ m_hFax = hFax;};
	DWORD GetJobStatus();
	DWORD PrintJobStatus(DWORD dwJobStatus);
	
	// thread handle
	HANDLE hOperationThread;
	DWORD dwThreadId;

protected:
	HANDLE m_hFax;
	DWORD m_dwJobId; 
	DWORD m_dwJobStatus;
	BYTE m_bJobType;

	// events flags
	Event_t m_EvJobCompleted;
	Event_t m_EvJobSending;
	Event_t m_EvOperationCompleted;

	DWORD _AbortFax(){return 0;};
	DWORD _PaueFax(){return 0;};
	DWORD _ResumeFax(){return 0;};
	DWORD _GetFaxJob(){return 0;}; 
	
};

// GetJobStatus
// returns -1 on fail, the job's queue status on success
//
inline DWORD CBaseFaxJob::GetJobStatus()
{
	DWORD dwFuncRetVal = 0;
	
	PFAX_JOB_ENTRY pJobEntry = NULL;
	if(!FaxGetJob( m_hFax, m_dwJobId,&pJobEntry))
	{
		dwFuncRetVal = GetLastError();
		assert(dwFuncRetVal);
		lgLogDetail(LOG_X, 0, TEXT("FaxGetJob() Failed with error code %d"), dwFuncRetVal);
		dwFuncRetVal =  -1;
	}
	else
	{
		dwFuncRetVal = pJobEntry->QueueStatus;
	}

	FaxFreeBuffer(pJobEntry);
	return dwFuncRetVal;
}

inline DWORD CBaseFaxJob::PrintJobStatus(DWORD dwJobStatus)
{

	DWORD dwTestStatus = 0;

	if(dwJobStatus & JS_PENDING)
	{
		dwTestStatus |= JS_PENDING;
		lgLogDetail(LOG_X, 0, TEXT("job %d, Status is JS_PENDING"),m_dwJobId);
	}
	if(dwJobStatus & JS_INPROGRESS)
	{
		dwTestStatus |= JS_INPROGRESS;
		lgLogDetail(LOG_X, 0, TEXT("job %d, Status is JS_INPROGRESS"),m_dwJobId);
	}
	if(dwJobStatus & JS_CANCELED)
	{
		dwTestStatus |= JS_CANCELED;
		lgLogDetail(LOG_X, 0, TEXT("job %d, Status is JS_CANCELED"),m_dwJobId);
	}
	if(dwJobStatus & JS_CANCELING)
	{
		dwTestStatus |= JS_CANCELING;
		lgLogDetail(LOG_X, 0, TEXT("job %d, Status is JS_CANCELING"),m_dwJobId);
	}
	if(dwJobStatus & JS_FAILED)
	{
		dwTestStatus |= JS_FAILED;
		lgLogDetail(LOG_X, 0, TEXT("job %d, Status is JS_FAILED"),m_dwJobId);
	}
	if(dwJobStatus & JS_RETRYING)
	{
		dwTestStatus |= JS_RETRYING;
		lgLogDetail(LOG_X, 0, TEXT("job %d, Status is JS_RETRYING"),m_dwJobId);
	}
	if(dwJobStatus & JS_RETRIES_EXCEEDED)
	{
		dwTestStatus |= JS_RETRIES_EXCEEDED;
		lgLogDetail(LOG_X, 0, TEXT("job %d, Status is JS_RETRIES_EXCEEDED"),m_dwJobId);
	}
	if(dwJobStatus & JS_PAUSING)
	{
		dwTestStatus |= JS_PAUSING;
		lgLogDetail(LOG_X, 0, TEXT("job %d, State Modifier is JS_PAUSING"),m_dwJobId);
	}
	if(dwJobStatus & JS_COMPLETED)
	{
		dwTestStatus |= JS_COMPLETED;
		lgLogDetail(LOG_X, 0, TEXT("job %d, State Modifier is JS_COMPLETED"),m_dwJobId);
	}	
	if(dwJobStatus & JS_PAUSED)
	{
		dwTestStatus |= JS_PAUSED;
		lgLogDetail(LOG_X, 0, TEXT("job %d, State Modifier is JS_PAUSED"),m_dwJobId);
	}
	if(dwJobStatus & JS_NOLINE)
	{
		dwTestStatus |= JS_NOLINE;
		lgLogDetail(LOG_X, 0, TEXT("job %d, State Modifier is JS_NOLINE"),m_dwJobId);
	}
	if(dwJobStatus & JS_DELETING)
	{
		dwTestStatus |= JS_DELETING;
		lgLogDetail(LOG_X, 0, TEXT("job %d, State Modifier is JS_DELETING"),m_dwJobId);
	}
	if(dwTestStatus != dwJobStatus)
	{
		lgLogDetail(LOG_X, 0, TEXT("job %d, Unexpected State %d"),m_dwJobId, dwTestStatus ^ dwJobStatus);
	}

	return 0;
}

#endif //_BASE_FAX_JOB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\aborttest\util.cpp ===
//
//
// Filename:	util.cpp
// Author:		Sigalit Bar (sigalitb)
// Date:		7-Oct-00
//
//

#include "util.h"

HRESULT StartFaxService(void)
{
    HRESULT     hrRetVal = E_UNEXPECTED;
    SC_HANDLE   hSCM = NULL;
    SC_HANDLE   hFaxService = NULL;
    DWORD       dwHints = 0;
    DWORD       dwOldCheckPoint = 0;     
    DWORD       dwStartTickCount = 0;
    DWORD       dwWaitTime = 0;    
    DWORD       dwStatus = 0;
    SERVICE_STATUS ssStatus;     

    ::lgLogDetail(LOG_X,1,TEXT("[StartFaxService] Entry"));

    ZeroMemory(&ssStatus, sizeof(SERVICE_STATUS));

    hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT); 
    if (NULL == hSCM)
    {
		::lgLogError(
            LOG_SEV_1,
            TEXT("[StartFaxService] OpenSCManager failed with err=0x%08X"),
            ::GetLastError()
            );
        goto ExitFunc;
    }

    hFaxService = OpenService(
                            hSCM, 
                            SHARED_FAX_SERVICE_NAME, 
                            (SERVICE_STOP | SERVICE_START | SERVICE_QUERY_STATUS)
                            );
    if (NULL == hFaxService)
    {
		::lgLogError(
            LOG_SEV_1,
            TEXT("[StartFaxService] OpenService(%s) failed with err=0x%08X"),
            SHARED_FAX_SERVICE_NAME,
            ::GetLastError()
            );
        goto ExitFunc;
    }
  
    if (FALSE == StartService(hFaxService, 0, NULL))
    {
		::lgLogError(
            LOG_SEV_1,
            TEXT("[StartFaxService] StartService(%s) failed with err=0x%08X"),
            SHARED_FAX_SERVICE_NAME,
            ::GetLastError()
            );
        goto ExitFunc;
    }

    //
    // Check the status until the service is no longer start pending.  
    //
    if (!QueryServiceStatus(hFaxService,&ssStatus))  
    {
		::lgLogError(
            LOG_SEV_1,
            TEXT("[StartFaxService] QueryServiceStatus(%s) failed with err=0x%08X"),
            SHARED_FAX_SERVICE_NAME,
            ::GetLastError()
            );
        goto ExitFunc;
    } 
    // Save the tick count and initial checkpoint.
    dwStartTickCount = GetTickCount();
    dwOldCheckPoint = ssStatus.dwCheckPoint;
    while (ssStatus.dwCurrentState == SERVICE_START_PENDING)     
    { 
        // Do not wait longer than the wait hint. and always between 1sec to 10sec.          
        dwWaitTime = ssStatus.dwWaitHint / 10;
        if( dwWaitTime < 1000 ) 
        {
            dwWaitTime = 1000;
        }
        else if ( dwWaitTime > 10000 ) 
        {
            dwWaitTime = 10000;
        }
        Sleep( dwWaitTime );        
        // Check the status again.  
        if (!QueryServiceStatus(hFaxService, &ssStatus) ) 
        {
		    ::lgLogError(
                LOG_SEV_1,
                TEXT("[StartFaxService] QueryServiceStatus(%s) failed with err=0x%08X"),
                SHARED_FAX_SERVICE_NAME,
                ::GetLastError()
                );
            break;  
        }
        if ( ssStatus.dwCheckPoint > dwOldCheckPoint )        
        {
            // The service is making progress.
            dwStartTickCount = GetTickCount();
            dwOldCheckPoint = ssStatus.dwCheckPoint;        
        }        
        else
        {            
            if(GetTickCount()-dwStartTickCount > ssStatus.dwWaitHint)
            {                
                // No progress made within the wait hint
                dwHints++;
		        ::lgLogDetail(
                    LOG_X,
                    1,
                    TEXT("[StartFaxService] No progress made within the wait hint (%d).\n"),
                    dwHints
                    );
                if (dwHints < MAX_HINTS)
                {
                    continue;
                }
                else
                {
                    break;            
                }
            }        
        }    
    } 
    if (ssStatus.dwCurrentState == SERVICE_RUNNING)     
    {
		::lgLogDetail(
            LOG_X,
            1,
            TEXT("[StartFaxService] Service started.\n")
            );
    }
    else     
    {         
		::lgLogError(
            LOG_SEV_1,
            TEXT("[StartFaxService] Service NOT started.\n")
            );
		::lgLogDetail(
            LOG_X,
            1,
            TEXT("[StartFaxService] Current State: %d\nExit Code: %d\nService Specific Exit Code: %d\nCheck Point: %d\nWait Hint: %d\nLast Error: 0x%08X"),
            ssStatus.dwCurrentState,
            ssStatus.dwWin32ExitCode,
            ssStatus.dwServiceSpecificExitCode,
            ssStatus.dwCheckPoint,
            ssStatus.dwWaitHint,
            ::GetLastError()
            );
        goto ExitFunc;
    }  

    hrRetVal = S_OK;

ExitFunc:
    CloseServiceHandle(hSCM);
    CloseServiceHandle(hFaxService);
    return(hrRetVal);
}


HRESULT StopFaxService(void)
{
    HRESULT     hrRetVal = E_UNEXPECTED;
    SC_HANDLE   hSCM = NULL;
    SC_HANDLE   hFaxService = NULL;
    DWORD       dwOldCheckPoint = 0;     
    DWORD       dwStartTickCount = 0;
    DWORD       dwWaitTime = 0;    
    DWORD       dwStatus = 0;
    SERVICE_STATUS ssStatus;     

    ::lgLogDetail(LOG_X,1,TEXT("[StopFaxService] Entry"));

    ZeroMemory(&ssStatus, sizeof(SERVICE_STATUS));

    hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if (NULL == hSCM)
    {
		::lgLogError(
            LOG_SEV_1,
            TEXT("[StopFaxService] OpenSCManager failed with err=0x%08X"),
            ::GetLastError()
            );
        goto ExitFunc;
    }

    hFaxService = OpenService(
                            hSCM, 
                            SHARED_FAX_SERVICE_NAME, 
                            (SERVICE_STOP | SERVICE_START | SERVICE_QUERY_STATUS)
                            );
    if (NULL == hFaxService)
    {
		::lgLogError(
            LOG_SEV_1,
            TEXT("[StopFaxService] OpenService(%s) failed with err=0x%08X"),
            SHARED_FAX_SERVICE_NAME,
            ::GetLastError()
            );
        goto ExitFunc;
    }
  
    if (FALSE == ControlService(hFaxService, SERVICE_CONTROL_STOP, &ssStatus))
    {
        if(ERROR_SERVICE_NOT_ACTIVE == ::GetLastError())
        {
            //ok
		    ::lgLogDetail(
                LOG_X,
                1,
                TEXT("[StopFaxService] Service was already stopped.\n")
                );
            hrRetVal = S_OK;
            goto ExitFunc;
        }
		::lgLogError(
            LOG_SEV_1,
            TEXT("[StopFaxService] ControlService(%s) failed with err=0x%08X"),
            SHARED_FAX_SERVICE_NAME,
            ::GetLastError()
            );
        goto ExitFunc;
    }

    // Save the tick count and initial checkpoint.
    dwStartTickCount = GetTickCount();
    dwOldCheckPoint = ssStatus.dwCheckPoint;
    while (ssStatus.dwCurrentState == SERVICE_STOP_PENDING)     
    { 
        // Do not wait longer than the wait hint. and always between 1sec to 10sec.          
        dwWaitTime = ssStatus.dwWaitHint / 10;
        if( dwWaitTime < 1000 ) 
        {
            dwWaitTime = 1000;
        }
        else if ( dwWaitTime > 10000 ) 
        {
            dwWaitTime = 10000;
        }
        Sleep( dwWaitTime );        
        // Check the status again.  
        if (!QueryServiceStatus(hFaxService, &ssStatus) ) 
        {
            break;  
        }
        if ( ssStatus.dwCheckPoint > dwOldCheckPoint )        
        {
            // The service is making progress.
            dwStartTickCount = GetTickCount();
            dwOldCheckPoint = ssStatus.dwCheckPoint;        
        }        
        else
        {            
            if(GetTickCount()-dwStartTickCount > ssStatus.dwWaitHint)
            {                
                // No progress made within the wait hint
                break;            
            }        
        }    
    } 
    if (ssStatus.dwCurrentState == SERVICE_STOPPED)     
    {
		::lgLogDetail(
            LOG_X,
            1,
            TEXT("[StopFaxService] Service stopped.\n")
            );
    }
    else     
    {         
		::lgLogError(
            LOG_SEV_1,
            TEXT("[StopFaxService] Service NOT stopped.\n")
            );
		::lgLogDetail(
            LOG_X,
            1,
            TEXT("[StopFaxService] Current State: %d\nExit Code: %d\nService Specific Exit Code: %d\nCheck Point: %d\nWait Hint: %d\nLast Error: 0x%08X"),
            ssStatus.dwCurrentState,
            ssStatus.dwWin32ExitCode,
            ssStatus.dwServiceSpecificExitCode,
            ssStatus.dwCheckPoint,
            ssStatus.dwWaitHint,
            ::GetLastError()
            );
        goto ExitFunc;
    }  

    hrRetVal = S_OK;

ExitFunc:
    CloseServiceHandle(hSCM);
    CloseServiceHandle(hFaxService);
    return(hrRetVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\jobmngr\ceventjobthread.h ===
#ifndef EVENT_JOB_THREAD_H
#define EVENT_JOB_THREAD_H

//utilities
#include <cthread.h>

//specific
#include "CJobContainer.h"


//
//
//
class CEventJobThread: public ThreadBase_t
{
public:
	CEventJobThread(const HANDLE hCompletionPort, 
					const DWORD dwEventPollingTime,
					const CJobContainer* pJobContainer);
	~CEventJobThread();
	DWORD SetThreadParameters(const HANDLE hCompletionPort, 
							  const DWORD dwEventPollingTime,
							  const CJobContainer* pJobContainer);
   	unsigned int ThreadMain();
    void StopThreadMain();
	HANDLE GetEvThreadCompleted()const {return  m_EventEndThread.get();};

private:
	DWORD m_dwEventPollingTime;
	BOOL m_fStopFlag;
	HANDLE m_hCompletionPort;
	CJobContainer* m_pJobContainer;

	// event signifying thread has terminated 
	Event_t  m_EventEndThread; 
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\jobmngr\ceventjobthread.cpp ===
//project specific
#include "CEventJobThread.h"
#include <CFaxEvent.h>

//
// CEventJobThread
// constructor
// [in] hCompletionPort - IO completion port handle.
//		dwEventPollingTime - thread's polling time for
//							  completion port package.
//		pJobContainer - pointer to jobs container.
//
CEventJobThread::CEventJobThread(const HANDLE hCompletionPort,
								 const DWORD dwEventPollingTime,
								 const CJobContainer* pJobContainer):
    m_EventEndThread(NULL, TRUE, FALSE, TEXT("")),
	m_fStopFlag(FALSE),
	m_dwEventPollingTime(dwEventPollingTime)
{
	assert( hCompletionPort && (hCompletionPort != INVALID_HANDLE_VALUE) );
	m_hCompletionPort = hCompletionPort; 
	
	assert(pJobContainer);
	m_pJobContainer = const_cast <CJobContainer*>(pJobContainer);
	
}

DWORD CEventJobThread::SetThreadParameters(const HANDLE hCompletionPort, 
							  const DWORD dwEventPollingTime,
							  const CJobContainer* pJobContainer)
{
	verify(ResetEvent(m_EventEndThread.get()));
	m_fStopFlag = FALSE;
	
	m_dwEventPollingTime = dwEventPollingTime;

	assert( hCompletionPort && (hCompletionPort != INVALID_HANDLE_VALUE) );
	m_hCompletionPort = hCompletionPort; 
	
	assert(pJobContainer);
	m_pJobContainer = const_cast <CJobContainer*>(pJobContainer);

	return 0;
}

//
// destructor
//
CEventJobThread::~CEventJobThread()
{
	// if thread is not terminated, stop it
	if( WaitForSingleObjectEx( GetEvThreadCompleted() , 0, FALSE) != WAIT_OBJECT_0)
	{
		StopThreadMain();
		// time out is set to (thread's polling for IOCP package time out) * 3
		if(WaitForSingleObjectEx(GetEvThreadCompleted(), 3 * m_dwEventPollingTime, FALSE) != WAIT_OBJECT_0)
		{
			Win32Err err(GetLastError(),__LINE__,TEXT(__FILE__),
						 TEXT("~CEventJobThread, WaitForSingleObjectEx"));
			::lgLogError(LOG_SEV_2, TEXT("Exception:%s."), err.description());
		}
	}

}


//	
// ThreadMain
//
unsigned int CEventJobThread::ThreadMain()
{
	DWORD dwBytes, dwCompletionKey, dwHndleMsgRet;
	DWORD dwFunRetVal = 0;
	CFaxEvent* pFaxEvent = NULL;
	try
	{
		while(!m_fStopFlag)
		{
			

			// wait on io completion port for event
			BOOL bVal = GetQueuedCompletionStatus(m_hCompletionPort,
												  &dwBytes,
												  &dwCompletionKey,
											      (LPOVERLAPPED *)&pFaxEvent,
												  m_dwEventPollingTime);
			
			if(!bVal)
			{
				if(GetLastError() == WAIT_TIMEOUT)
				{
					#ifdef _DEBUG
					::lgLogDetail(LOG_X, 3, TEXT("WAIT_TIMEOUT in CEventJobThread"));
					#endif
					continue;
				}
			
				// error, terminate thread
				THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT("CEventJobThread::ThreadMain, GetCompletionStatus"));
			}
			
			// hand event to JobContainer
			if(dwHndleMsgRet = m_pJobContainer->HandleMessage(*pFaxEvent))
			{
				//TODO:  error, report but continue
				Win32Err err(dwHndleMsgRet,__LINE__,TEXT(__FILE__),TEXT("CEventJobThread::ThreadMain, HandleMessage"));
				::lgLogError(LOG_SEV_1, TEXT("Exception:%s."), err.description());
			}
			
			delete pFaxEvent;
			pFaxEvent = NULL;
		
		}
	}
	catch(Win32Err& err)
	{
		delete pFaxEvent;
		::lgLogError(LOG_SEV_1, TEXT("Exception:%s."), err.description());
		dwFunRetVal = err.error();
	}

	// signal thread has terminated.
	verify(SetEvent(m_EventEndThread.get()));
	::lgLogDetail(LOG_X, 3, TEXT("Terminated CEventJobThread"));
	return dwFunRetVal;
}

//
// set stop condition
//
void CEventJobThread::StopThreadMain()
{
	m_fStopFlag = TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\jobmngr\ceventsource.h ===
#ifndef _EVENT_SOURCE_H
#define _EVENT_SOURCE_H

#include <cthread.h>
#include <CEventRedirectionThread.h>

class CEventSource
{
public:
	CEventSource(const DWORD dwEventPollingTime = 3*60*1000):
		m_dwEventPollingTime(dwEventPollingTime){;};
	~CEventSource( ){delete m_EventThread;};
	DWORD Initialize(const tstring tstrServerName, 
					 const HANDLE hCompletionPort);
	DWORD RestartThread(const tstring tstrServerName, 
						const HANDLE hCompletionPort);
	DWORD TerminateThreads();
	BOOL IsThreadActive();
private:
	DWORD m_dwEventPollingTime;
	tstring m_tstrServerName;
	HANDLE m_hCompletionPort;
	CEventRedirectionThread* m_EventThread;
	
	
};


#endif //_EVENT_SOURCE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\jobmngr\cbaseparentfaxjob.h ===
#ifndef _BASE_PARENT_FAX_JOB_H
#define _BASE_PARENT_FAX_JOB_H

#include <windows.h>
#include <CFaxEvent.h>
#include <ptrs.h>
#include "..\hash\hash.h"
#include "CBaseFaxJob.h"

typedef  class CBaseParentFaxJob CBaseParentFaxJob;
#include "CJobContainer.h"

// SetJobFaxHandle, applied for each recipient in the table,
// need the new fax handle. But since  it can
// get as parameter only the object itself we use a global.
static HANDLE hFaxGlobal;

static DWORD RemoveJobFromJobContainer(CBaseParentFaxJob* pFaxJob);
static bool SetJobFaxHandleFunc(void* pParam);
static bool WaitForOperationCompFunc(void* pParam);

class CBaseParentFaxJob
{
public:
	CBaseParentFaxJob():
		m_hFax(NULL),
		m_pJobContainer(NULL),
		m_EvJobCompleted(NULL, TRUE, FALSE,TEXT("")),
		m_EvJobSending(NULL, TRUE, FALSE,TEXT("")),
		m_EvOperationsCompleted(NULL, TRUE, FALSE,TEXT("")),
		m_CountOperationCompleted(),
		m_RecipientNum(){};

	virtual ~CBaseParentFaxJob(){}; 
	virtual DWORD HandleMessage(CFaxEvent& pFaxEvent) = 0;
	virtual	DWORD AddRecipient(DWORD dwRecepientId) = 0;
	HANDLE GethEvJobCompleted()const {return  m_EvJobCompleted.get();};
	HANDLE GethEvJobSending()const {return  m_EvJobSending.get();};
	void SetFaxHandle(HANDLE hFax);
	bool WaitForOperationsCompletion();
	
	friend DWORD RemoveJobFromJobContainer(CBaseParentFaxJob* pFaxJob);
	friend bool SetJobFaxHandleFunc(void* pParam);
	friend bool WaitForOperationCompFunc(void* pParam);

protected:
	HANDLE m_hFax;
	DWORD m_dwJobId; 
	DWORD m_dwJobStatus;
	BYTE m_JobType;
	
	// events flags
	Event_t m_EvJobCompleted;
	Event_t m_EvJobSending;
	Event_t m_EvOperationsCompleted;
	
	Counter m_CountOperationCompleted;
	Counter m_RecipientNum;

	CJobContainer* m_pJobContainer;
	CHash<CBaseFaxJob, DWORD, 10> m_RecipientTable; // hash table of recipients entries

	DWORD _GetJobStatus();
	DWORD _VlidateParentStatus(DWORD dwParentJobStatus);
	
	DWORD _AbortFax(){return 0;};
	DWORD _PaueFax(){return 0;};
	DWORD _ResumeFax(){return 0;};
	DWORD _GetFaxJob(){return 0;}; 
};


#endif //_BASE_PARENT_FAX_JOB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\jobmngr\cjobcontainer.h ===
#ifndef _JOB_CONTAINER_H
#define _JOB_CONTAINER_H

// utilities
#include <..\Hash\Hash.h>

typedef  class CJobContainer CJobContainer;

// project specific
#include <Defs.h>
#include <CFaxEvent.h>
#include "CBaseParentFaxJob.h"
#include "CJobParams.h"

// events definition
#define EV_COMPLETED   0
#define EV_SENDING     1
#define EV_OPERATION_COMPLETED 2

class CJobContainer
{
public:
	CJobContainer();
	Initialize(const HANDLE hFax);
	~CJobContainer(){};
	DWORD AddJob(const DWORD type, JOB_PARAMS& params);
	DWORD AddMultiTypeJob(JOB_PARAMS_EX& params);
	DWORD HandleMessage(CFaxEvent& pFaxEvent);
	DWORD WaitOnJobEvent(DWORD JobId, BYTE EventType);
	DWORD AddAlreadyExistingJobs();
	DWORD NewFaxConnection();
	bool  SetJobFaxHandle(void* pJob);
	BOOL RemoveJobFromTable(DWORD dwJobId);

private:
	DWORD _AddJobEntry(PFAX_JOB_ENTRY pJobEntry, CBaseParentFaxJob*& pJob);

	HANDLE m_hFax;
	CHash<CBaseParentFaxJob, DWORD, 100> m_JobsTable;	// hash table of Parent jobs entries
};

#endif //_JOB_CONTAINER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\jobmngr\ceventsource.cpp ===
#include "CEventSource.h"


// CEventSource
//
//

DWORD CEventSource::Initialize(const tstring tstrServerName, 
							   const HANDLE hCompletionPort)
{

	m_tstrServerName  = tstrServerName;
	m_hCompletionPort = hCompletionPort;


	DWORD dwStartThreadRet;
	try
	{
		// init fax event redirection thread
		m_EventThread = new CEventRedirectionThread(m_tstrServerName, 
													m_hCompletionPort,
													m_dwEventPollingTime);
		if(!m_EventThread)
		{
			THROW_TEST_RUN_TIME_WIN32(ERROR_OUTOFMEMORY,TEXT(""));
		}

		if( dwStartThreadRet = m_EventThread->StartThread())
		{
			delete m_EventThread;
			THROW_TEST_RUN_TIME_WIN32(dwStartThreadRet,TEXT(""))
		}
	
	}
	catch(Win32Err& err)
	{
		return err.error();
	}

	return ERROR_SUCCESS;

}	

DWORD CEventSource::RestartThread(const tstring tstrServerName, 
								  const HANDLE hCompletionPort)
{

	m_tstrServerName  = tstrServerName;
	m_hCompletionPort = hCompletionPort;

	if( WaitForSingleObjectEx( m_EventThread->GetEvThreadCompleted() , 0, FALSE) != WAIT_OBJECT_0)
	{
		m_EventThread->StopThreadMain();
		// time out is set to (thread's polling for IOCP package time out) * 3
		if(WaitForSingleObjectEx(m_EventThread->GetEvThreadCompleted(), 3 * m_dwEventPollingTime, FALSE) != WAIT_OBJECT_0)
		{
			Win32Err err(GetLastError(),__LINE__,TEXT(__FILE__),TEXT("CEventSource::RestartThread, WaitForSingleObjectEx"));
			::lgLogError(LOG_SEV_2, TEXT("Exception:%s."), err.description());
			return err.error();
		}
		
	}

	delete m_EventThread;

	DWORD dwStartThreadRet;
	try
	{
		// init fax event redirection thread
		m_EventThread = new CEventRedirectionThread(m_tstrServerName, 
													m_hCompletionPort,
													m_dwEventPollingTime);
		if(!m_EventThread)
		{
			THROW_TEST_RUN_TIME_WIN32(ERROR_OUTOFMEMORY,TEXT(""));
		}

		if( dwStartThreadRet = m_EventThread->StartThread())
		{
			delete m_EventThread;
			THROW_TEST_RUN_TIME_WIN32(dwStartThreadRet,TEXT(""))
		}
	
	}
	catch(Win32Err& err)
	{
		return err.error();
	}

	return ERROR_SUCCESS;

}	

DWORD CEventSource::TerminateThreads()
{
	if( WaitForSingleObjectEx( m_EventThread->GetEvThreadCompleted() , 0, FALSE) != WAIT_OBJECT_0)
	{
		m_EventThread->StopThreadMain();
		// time out is set to (thread's polling for IOCP package time out) * 3
		if(WaitForSingleObjectEx(m_EventThread->GetEvThreadCompleted(), 3 * m_dwEventPollingTime, FALSE) != WAIT_OBJECT_0)
		{
			return GetLastError();
		
		}
	}
	return 0;
}

BOOL CEventSource::IsThreadActive()
{

	if( WaitForSingleObjectEx( m_EventThread->GetEvThreadCompleted() , 0, FALSE) == WAIT_OBJECT_0)
	{
		return TRUE;
	}
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\jobmngr\cbaseparentfaxjob.cpp ===
#include "CBaseParentFaxJob.h"

//
// SetJobFaxHandle
// friend , the function will be applied for each of recipient jobs
static bool SetJobFaxHandleFunc(void* pParam)
{
	CBaseFaxJob* pJob =  (CBaseFaxJob*)pParam;
	pJob->SetFaxHandle(hFaxGlobal);
	return true;
}

static FUNCTION_FOREACH pfnSetJobFaxHandle = SetJobFaxHandleFunc;

void CBaseParentFaxJob::SetFaxHandle(HANDLE hFax)
{
	m_hFax = hFax;
	hFaxGlobal = m_hFax;
	m_RecipientTable.ForEach(pfnSetJobFaxHandle);
}

//
// WaitForOperationCompletion
// friend , the function will be applied for each of recipient jobs
static bool WaitForOperationCompFunc(void* pParam)
{
	CBaseFaxJob* pJob =  (CBaseFaxJob*)pParam;
	WaitForSingleObject( pJob->GethEvOperationCompleted(),INFINITE);
	return true;
}

static FUNCTION_FOREACH pfnWaitForOperationCompletion = WaitForOperationCompFunc;

bool CBaseParentFaxJob::WaitForOperationsCompletion()
{
	return(m_RecipientTable.ForEach(pfnWaitForOperationCompletion));
}

//
// RemoveJobFromJobContainer
// friend, remove a job from jobs' container
//
static DWORD RemoveJobFromJobContainer(CBaseParentFaxJob* pFaxJob)
{
	assert(pFaxJob->m_pJobContainer);
	CJobContainer* pJobContainer = pFaxJob->m_pJobContainer;
	pJobContainer->RemoveJobFromTable(pFaxJob->m_dwJobId);

	return 0;
}

// GetJobStatus
// returns -1 on fail, the job's queue status on success
//
DWORD CBaseParentFaxJob::_GetJobStatus()
{
	DWORD dwFuncRetVal = 0;

	PFAX_JOB_ENTRY pJobEntry = NULL;
	if(!FaxGetJob( m_hFax, m_dwJobId,&pJobEntry))
	{
		dwFuncRetVal = GetLastError();
		assert(dwFuncRetVal);
		lgLogDetail(LOG_X, 0, TEXT("FaxGetJob() Failed with error code %d"), dwFuncRetVal);
		dwFuncRetVal =  -1;
	}
	else
	{
		dwFuncRetVal = pJobEntry->QueueStatus;
	}
	FaxFreeBuffer(pJobEntry);

	return dwFuncRetVal;
}

// VlidateParentStatus
//
//
DWORD CBaseParentFaxJob::_VlidateParentStatus(DWORD dwParentJobStatus)
{
	DWORD dwFuncRetVal = 0;
	DWORD dwRecipientsNum = 0;
	DWORD dwAccumulatedStatus = 0;
	DWORD* pdwRecipientsArray = NULL;
	
	if(!FaxGetRecipientJobs(m_hFax, m_dwJobId, NULL, &dwRecipientsNum))
	{
		dwFuncRetVal = GetLastError();
		assert(dwFuncRetVal);
		lgLogDetail(LOG_X, 0, TEXT("FaxGetRecipientJobs() Failed with error code %d"), dwFuncRetVal);
	}
	else
	{
		if(!FaxGetRecipientJobs(m_hFax, m_dwJobId, &pdwRecipientsArray, &dwRecipientsNum))
		{
			dwFuncRetVal = GetLastError();
			assert(dwFuncRetVal);
			lgLogDetail(LOG_X, 0, TEXT("FaxGetRecipientJobs() Failed with error code %d"), dwFuncRetVal);
		}
		else
		{
			
			for(int index = 0; index < dwRecipientsNum; index++)
			{
				PFAX_JOB_ENTRY pJobEntry = NULL;
				// TODO: FaxGetJob is for testing FAX_RECIPIENT_JOB_INFO status
				if(!FaxGetJob( m_hFax, pdwRecipientsArray[index],&pJobEntry))
				{
						dwFuncRetVal = GetLastError();
						assert(dwFuncRetVal);
						FaxFreeBuffer(pJobEntry);
						lgLogDetail(LOG_X, 0, TEXT("FaxGetJob() Failed with error code %d"), dwFuncRetVal);
						break;

				}
			//	assert(pdwRecipientsArray[index].dwQueueStatus == pJobEntry->QueueStatus);
				dwAccumulatedStatus |= pJobEntry->QueueStatus;
				FaxFreeBuffer(pJobEntry);
			}
		}
			
	}

	if(!dwFuncRetVal)
	{
		#ifdef _DEBUG
		if(dwAccumulatedStatus != dwParentJobStatus)
		{
			lgLogDetail(LOG_X, 0, TEXT("Parent Job %d, Queue Status %x"),m_dwJobId, dwParentJobStatus);
			lgLogDetail(LOG_X, 0, TEXT("Parent Job %d, Accumulated Recipients Status %x"),m_dwJobId, dwAccumulatedStatus);
			lgLogDetail(LOG_X, 0, TEXT("Parent Job %d, Unexpected State %x"),m_dwJobId, dwAccumulatedStatus ^ dwParentJobStatus);
		}
		#endif
	}

	FaxFreeBuffer(pdwRecipientsArray);
	return dwFuncRetVal;
}


// TODO: Future Implementation
/*
inline DWORD CBaseFaxJob::PrintJobStatus(DWORD dwJobStatus)
{

	DWORD dwTestStatus = 0;

	if(dwJobStatus & JS_PENDING)
	{
		dwTestStatus |= JS_PENDING;
		lgLogDetail(LOG_X, 0, TEXT("job %d, Status is JS_PENDING"),m_dwJobId);
	}
	if(dwJobStatus & JS_INPROGRESS)
	{
		dwTestStatus |= JS_INPROGRESS;
		lgLogDetail(LOG_X, 0, TEXT("job %d, Status is JS_INPROGRESS"),m_dwJobId);
	}
	if(dwJobStatus & JS_CANCELING)
	{
		dwTestStatus |= JS_CANCELING;
		lgLogDetail(LOG_X, 0, TEXT("job %d, Status is JS_CANCELING"),m_dwJobId);
	}
	if(dwJobStatus & JS_FAILED)
	{
		dwTestStatus |= JS_FAILED;
		lgLogDetail(LOG_X, 0, TEXT("job %d, Status is JS_FAILED"),m_dwJobId);
	}
	if(dwJobStatus & JS_RETRYING)
	{
		dwTestStatus |= JS_RETRYING;
		lgLogDetail(LOG_X, 0, TEXT("job %d, Status is JS_RETRYING"),m_dwJobId);
	}
	if(dwJobStatus & JS_RETRIES_EXCEEDED)
	{
		dwTestStatus |= JS_RETRIES_EXCEEDED;
		lgLogDetail(LOG_X, 0, TEXT("job %d, Status is JS_RETRIES_EXCEEDED"),m_dwJobId);
	}
	if(dwJobStatus & JS_PAUSING)
	{
		dwTestStatus |= JS_PAUSING;
		lgLogDetail(LOG_X, 0, TEXT("job %d, State Modifier is JS_PAUSING"),m_dwJobId);
	}
	if(dwJobStatus & JS_COMPLETED)
	{
		dwTestStatus |= JS_COMPLETED;
		lgLogDetail(LOG_X, 0, TEXT("job %d, State Modifier is JS_COMPLETED"),m_dwJobId);
	}	
	if(dwJobStatus & JS_PAUSED)
	{
		dwTestStatus |= JS_PAUSED;
		lgLogDetail(LOG_X, 0, TEXT("job %d, State Modifier is JS_PAUSED"),m_dwJobId);
	}
	if(dwJobStatus & JS_NOLINE)
	{
		dwTestStatus |= JS_NOLINE;
		lgLogDetail(LOG_X, 0, TEXT("job %d, State Modifier is JS_NOLINE"),m_dwJobId);
	}
	if(dwJobStatus & JS_DELETING)
	{
		dwTestStatus |= JS_DELETING;
		lgLogDetail(LOG_X, 0, TEXT("job %d, State Modifier is JS_DELETING"),m_dwJobId);
	}
	if(dwTestStatus != dwJobStatus)
	{
		lgLogDetail(LOG_X, 0, TEXT("job %d, Unexpected State %d"),m_dwJobId, dwTestStatus ^ dwJobStatus);
	}

	return 0;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\jobmngr\cjobcontainer.cpp ===
#include <winfax.h>

#include "CJobContainer.h"
#include "CJobTypes.h"

static HANDLE hLocalFaxGlobal;

// TODO: internal testing function, to be remove
void HandleFaxEvent(CFaxEvent pFaxEvent);

// CJobContainer
//
CJobContainer::CJobContainer():
	m_hFax(NULL)
{;}

// Initialize
//
CJobContainer::Initialize(const HANDLE hFax)
{
	assert(hFax);
	m_hFax = hFax;
	return 0;

}
// AddAlreadyExistingJobs
//
DWORD CJobContainer::AddAlreadyExistingJobs()
{
	PFAX_JOB_ENTRY pJobEntry = NULL;
	DWORD dwJobsReturned;
	DWORD dwFunRetVal = 0;

	::lgLogDetail(LOG_X, 0, TEXT("AddExistingJobs()"));

	if (!FaxEnumJobs( m_hFax, &pJobEntry, &dwJobsReturned))
	{
		dwFunRetVal = GetLastError();
	}
	else
	{
		DWORD dwParentJobId;
		for (DWORD dwJobIndex = 0; dwJobIndex < dwJobsReturned; dwJobIndex++)
		{
			DWORD dwJobId = pJobEntry[dwJobIndex].JobId;
			
			//Receive Job
			if(pJobEntry[dwJobIndex].JobType == JT_RECEIVE)
			{
				m_JobsTable.Lock(dwJobId);
				CBaseParentFaxJob *pFaxJob = NULL;
				if (!m_JobsTable.Get(dwJobId, &pFaxJob))
				{
					// receive not found, add it
					if(dwFunRetVal |=  _AddJobEntry( &pJobEntry[dwJobIndex] , pFaxJob))
					{
						::lgLogDetail(LOG_X, 0, TEXT("FAILED Add Receive Job %d"),dwJobId);
					}
					
				}
				m_JobsTable.UnLock(dwParentJobId);
				continue;
			}

			//Send Job
			// find recipient's parent
			if( !FaxGetParentJobId( m_hFax ,dwJobId, &dwParentJobId))
			{
				dwFunRetVal |= GetLastError();
			}
			else
			{
				PFAX_JOB_ENTRY pParentJobEntry = NULL;
				if(!FaxGetJob( m_hFax, dwParentJobId,&pParentJobEntry))
				{
					dwFunRetVal |= GetLastError();
				}
				else
				{
					m_JobsTable.Lock(dwParentJobId);
					try
					{
						CBaseParentFaxJob *pFaxJob = NULL;
						if (!m_JobsTable.Get(dwParentJobId, &pFaxJob))
						{
							//parent wasn't found: add parent
							if(dwFunRetVal |=  _AddJobEntry( pParentJobEntry , pFaxJob))
							{
								THROW_TEST_RUN_TIME_WIN32(dwFunRetVal, TEXT(""));
							}
							
							// add recipient
							if(dwFunRetVal |= pFaxJob->AddRecipient(dwJobId))
							{
								THROW_TEST_RUN_TIME_WIN32(dwFunRetVal, TEXT(""));
							}
							::lgLogDetail(LOG_X, 0, TEXT("Add Recipient %d to Parent %d"),dwJobId, dwParentJobId);
						
						}
						else
						{
							//add recipient
							if(dwFunRetVal |= pFaxJob->AddRecipient(dwJobId))
							{
								THROW_TEST_RUN_TIME_WIN32(dwFunRetVal, TEXT(""));
							}
							::lgLogDetail(LOG_X, 0, TEXT("Add Recipient %d to Parent %d"),dwJobId, dwParentJobId);
						}
					}
					catch(Win32Err&)
					{
					}	
					FaxFreeBuffer(pParentJobEntry);
					m_JobsTable.UnLock(dwParentJobId);
				}
			}
		}
	}

	FaxFreeBuffer(pJobEntry);
	return dwFunRetVal;
}


//
// AddJobEntry
// if fails, function returns a win32 error.
//
DWORD CJobContainer::_AddJobEntry(PFAX_JOB_ENTRY pJobEntry, CBaseParentFaxJob*& pJob)
{

	pJob = NULL;
	DWORD dwFuncRetVal = 0;

	switch(pJobEntry->JobType)
	{
	case JT_RECEIVE:
		{
			//TODO internal test messaging
			::lgLogDetail(LOG_X, 0, TEXT("Add JobId %d, JT_RECEIVE job type"),pJobEntry->JobId);
			
			//pJob = new CSimpleReceive(pJobEntry->JobId); 
			pJob = new CRandomAbortReceive(m_hFax, pJobEntry->JobId); 
			if(!pJob)
			{
				dwFuncRetVal = ERROR_OUTOFMEMORY;
				break;
			}
			
			// function returns false if element exist
			assert(m_JobsTable.Add(pJobEntry->JobId, pJob));
		
		}
		break;

	case JT_SEND:
		assert(FALSE);
		break;
	case JT_BROADCAST:
		{
			//TODO internal test messaging
			::lgLogDetail(LOG_X, 0, TEXT("Add JobId %d, JT_BROADCAST job type"),pJobEntry->JobId);
				
			pJob = new CSimpleParentJob(pJobEntry->JobId); 
			if(!pJob)
			{
				dwFuncRetVal = ERROR_OUTOFMEMORY;
				break;
			}
		
			assert(m_JobsTable.Add(pJobEntry->JobId, pJob));
		}
		break;
		
	default:
		::lgLogError(LOG_SEV_1, TEXT("JobId %d, Unexpected job type:%d."),pJobEntry->JobId, pJobEntry->JobType);
		; //TODO: more types to investigate
		dwFuncRetVal = E_FAIL;
	}

	return dwFuncRetVal;
}

//
// AddJob
// Using FaxSendDocument
//
DWORD CJobContainer::AddJob(const DWORD type, JOB_PARAMS& params)
{

	DWORD dwRetVal = 0;
	BOOL bVal = FaxSendDocument(m_hFax,
							    params.szDocument,
								params.pJobParam,
								params.pCoverpageInfo,
								&params.dwParentJobId);
							
				
	if(!bVal)
	{
		dwRetVal = GetLastError();
		
	}
	else
	{
		m_JobsTable.Lock(params.dwParentJobId);
		switch(type)
		{
		case JT_SIMPLE_SEND:
			CSimpleParentJob* pJob = new CSimpleParentJob(params.dwParentJobId); 
			if(!pJob)
			{
				dwRetVal = ERROR_OUTOFMEMORY;
			}
			else
			{
				CBaseParentFaxJob *pFaxJob = NULL;
				// function returns false if element does not exist
				if (!m_JobsTable.Get(params.dwParentJobId, &pFaxJob))
				{
					verify(m_JobsTable.Add(params.dwParentJobId, pJob));
				}
				else
				{
					verify(m_JobsTable.OverWrite(params.dwParentJobId, pJob));
				}

			}
			break;
		}
		m_JobsTable.UnLock(params.dwParentJobId);
	}

	return dwRetVal;
}


//
// AddMultiTypeJob
//
DWORD CJobContainer::AddMultiTypeJob(JOB_PARAMS_EX& params)
{
	DWORD dwRetVal = 0;
	params.pdwRecepientsId = SPTR<DWORD>(new DWORD[params.dwNumRecipients]);
	if(!(params.pdwRecepientsId).get()) 
	{
		return ERROR_OUTOFMEMORY;
	}

	
	BOOL bVal = FaxSendDocumentEx(m_hFax,
								  params.szDocument,
								  params.pCoverpageInfo,
								  params.pSenderProfile,
								  params.dwNumRecipients,
								  params.pRecepientList,
								  params.pJobParam,
								  &params.dwParentJobId,
								  (params.pdwRecepientsId).get());
								  
	if(!bVal)
	{
		dwRetVal = GetLastError();
	}
	else
	{
		m_JobsTable.Lock(params.dwParentJobId);
		
		CMultiTypeJob* pJob = new CMultiTypeJob(m_hFax, params.dwParentJobId, params.dwNumRecipients); 
		if(!pJob)
		{
			dwRetVal = ERROR_OUTOFMEMORY;
		}

		else
		{
			CBaseParentFaxJob *pFaxJob = NULL;
			// function returns false if element does not exist
			if (!m_JobsTable.Get(params.dwParentJobId, &pFaxJob))
			{
				verify(m_JobsTable.Add(params.dwParentJobId, pJob));
			}
			else
			{
				verify(m_JobsTable.OverWrite(params.dwParentJobId, pJob));
			}

			::lgLogDetail(LOG_X, 0, TEXT("Test Add Multi Type Job %d"),params.dwParentJobId);
			
			// add recepient job object
			
			for( int index1 = 0; index1 < params.dwNumRecipients; index1++)
			{
				
				DWORD dwRecepientId = (params.pdwRecepientsId.get())[index1];

				switch(params.pRecipientsBehavior[index1].dwJobType)
				{
				case JT_RANDOM_ABORT:
					if(params.pRecipientsBehavior[index1].dwParam1 == -1)
					{
						pJob->AddAbortRecipient(dwRecepientId);
					}
					else
					{
						if(params.pRecipientsBehavior[index1].dwParam2 == -1)
						{
							pJob->AddAbortRecipient(dwRecepientId, params.pRecipientsBehavior[index1].dwParam1);
						}
						else
						{
							pJob->AddAbortRecipient(dwRecepientId, 
								                    params.pRecipientsBehavior[index1].dwParam1,
													params.pRecipientsBehavior[index1].dwParam2);
						}
					}
				
					::lgLogDetail(LOG_X, 0, TEXT("Test Add Random Abort Recipient %d to Parent %d"),dwRecepientId, params.dwParentJobId);
					break;
				case JT_RANDOM_PAUSE:
					if(params.pRecipientsBehavior[index1].dwParam1 == -1)
					{
						pJob->AddPauseRecipient(dwRecepientId);
					}
					else
					{
						if(params.pRecipientsBehavior[index1].dwParam2 == -1)
						{
							pJob->AddPauseRecipient(dwRecepientId, params.pRecipientsBehavior[index1].dwParam1);
						}
						else
						{
							pJob->AddPauseRecipient(dwRecepientId, 
								                    params.pRecipientsBehavior[index1].dwParam1,
													params.pRecipientsBehavior[index1].dwParam2);
						}
					}
					
					::lgLogDetail(LOG_X, 0, TEXT("Test Add Random PauseRecipient %d to Parent %d"),dwRecepientId, params.dwParentJobId);
					break;
				case JT_ABORT_PAGE:
					pJob->AddAbortAtXPage(dwRecepientId, params.pRecipientsBehavior[index1].dwParam1);
					::lgLogDetail(LOG_X, 0, TEXT("Test Add Abort At Page X Job Recipient %d to Parent %d"),dwRecepientId, params.dwParentJobId);
					break;
				case JT_ABORT_AFTER_X_SEC:
					if(params.pRecipientsBehavior[index1].dwParam1 == -1)
					{
						pJob->AddAbortAfterXSec(dwRecepientId);
					}
					else
					{
						pJob->AddAbortAfterXSec(dwRecepientId, params.pRecipientsBehavior[index1].dwParam1);
					}

					::lgLogDetail(LOG_X, 0, TEXT("Test Add Abort After X Seconds Job %d to Parent %d"),dwRecepientId, params.dwParentJobId);
					break;
				case JT_SIMPLE_SEND: // fall into
				default:
					pJob->AddRecipient(dwRecepientId);
					::lgLogDetail(LOG_X, 0, TEXT("Test Add Simple Recipient %d to Parent %d"),dwRecepientId, params.dwParentJobId);
					break;
				}
				// TODO:if AddRecipient, fails that means a parent without or 
				// with partial recipients. Parent job class should 
				// handle it
			}
			
		}

		m_JobsTable.UnLock(params.dwParentJobId);
	}

	return dwRetVal;
}

static bool SetParentFaxHandle(void* pParam)
{
	CBaseParentFaxJob* pJob =  (CBaseParentFaxJob*)pParam;
	pJob->SetFaxHandle(hLocalFaxGlobal);
	return true;
}

static FUNCTION_FOREACH pfSetParentFaxHandle = SetParentFaxHandle;

DWORD CJobContainer::NewFaxConnection()
{
	//CBaseParentFaxJob
	hLocalFaxGlobal = m_hFax;
	m_JobsTable.ForEach(pfSetParentFaxHandle);
	return 0;
}

//
//
//
BOOL CJobContainer::RemoveJobFromTable(DWORD dwJobId)
{
	return m_JobsTable.Remove(dwJobId);
}

//
// HandleMessage
//
DWORD CJobContainer::HandleMessage(CFaxEvent& pFaxEvent)
{
	DWORD dwRetVal = 0;
	PFAX_JOB_ENTRY pJobEntry = NULL; 
	DWORD dwJobId = pFaxEvent.GetJobId();
	DWORD dwParentJobId = dwJobId;

	if(dwJobId != 0xffffffff && dwJobId != 0)
	{
		#ifdef _DEBUG
		cout << "Event received for job " << dwJobId << "  ";
		HandleFaxEvent(pFaxEvent);
		#endif
		
		m_JobsTable.Lock(dwParentJobId);
		CBaseParentFaxJob *pFaxJob = NULL;
			
		if (!m_JobsTable.Get(dwParentJobId, &pFaxJob))
		{
			// 2 possibilities : a new parent/ receive job or a recipient
			if(!FaxGetJob( m_hFax, dwParentJobId,&pJobEntry))
			{
					dwRetVal = GetLastError();
			}
			else
			{
				// TODOT : investigate types
				if(pJobEntry->JobType != JT_RECEIVE && pJobEntry->JobType != JT_BROADCAST)
				{
				
					if(!FaxGetParentJobId( m_hFax ,pFaxEvent.GetJobId(),&dwParentJobId))
					{
					
						dwRetVal = GetLastError();
					}
					else
					{
						m_JobsTable.Lock(dwParentJobId);
						m_JobsTable.UnLock(dwJobId);
					}
				}
				
				if(!dwRetVal)
				{
					
					if (!m_JobsTable.Get(dwParentJobId, &pFaxJob))
					{ // new parent/receive job
						verify( (pFaxEvent.GetEventId() == FEI_JOB_QUEUED) ||
								(pFaxEvent.GetEventId() == FEI_ANSWERED));
				
						FaxFreeBuffer(pJobEntry);
					    if(!FaxGetJob( m_hFax, dwParentJobId,&pJobEntry))
						{
							dwRetVal = GetLastError();
						}
						else
						{
							CBaseParentFaxJob* pJob;
							DWORD dwError = _AddJobEntry( pJobEntry , pJob);
							if(dwError)
							{
								dwRetVal = dwError;
							}
							else
							{
								pJob->HandleMessage(pFaxEvent);
							}
						}
					}
					else
					{
						pFaxJob->HandleMessage(pFaxEvent);
					}
				}
						
			}
			m_JobsTable.UnLock(dwParentJobId);
		}
		else
		{
			pFaxJob->HandleMessage(pFaxEvent);
			m_JobsTable.UnLock(dwParentJobId);
		}
	
	}
	else // Fax service general message
	{
		#ifdef _DEBUG
		HandleFaxEvent(pFaxEvent);
		#endif
	}

	FaxFreeBuffer(pJobEntry);
	return dwRetVal;
}

//
// WaitOnJobEvent
//
//returned value:
//ERROR_INVALID_PARAMETER - no job object with specified JobId / event type does not exist.
//WAIT_OBJECT_0 - The state of the event is signaled. 
//WAIT_TIMEOUT - The time-out interval elapsed, event is nonsignaled. 
//WAIT_FAILED - The function failed.
//
DWORD CJobContainer::WaitOnJobEvent(DWORD dwJobId, BYTE EventType)
{
	CBaseParentFaxJob *pFaxJob = NULL;
	
	m_JobsTable.Lock(dwJobId);
	if (!m_JobsTable.Get(dwJobId, &pFaxJob))
	{
		m_JobsTable.UnLock(dwJobId);
		return ERROR_INVALID_PARAMETER; // object not found
	}
	m_JobsTable.UnLock(dwJobId);

	switch(EventType)
	{
	case EV_COMPLETED:
		return(WaitForSingleObject( pFaxJob->GethEvJobCompleted(),INFINITE));
		break;
	case EV_SENDING:
		return(WaitForSingleObject( pFaxJob->GethEvJobSending(),INFINITE));
		break;
		case EV_OPERATION_COMPLETED:
		if(pFaxJob->WaitForOperationsCompletion())
		{
			return WAIT_OBJECT_0;
		}
		return WAIT_FAILED;
		break;
	default:
		;
		return ERROR_INVALID_PARAMETER;
		break;
	}
	
 
}

//
//
//
void HandleFaxEvent(CFaxEvent pFaxEvent)
{
   
	switch(pFaxEvent.GetEventId())
	{
	case FEI_DIALING :
		cout << "Dialing Fax number\n";
		break;
	case FEI_SENDING :
		cout << "Sending Fax\n";
		break;
	case FEI_RECEIVING :
		cout << "The receiving device is receiveing fax\n";
		break;
	case  FEI_COMPLETED:
		cout << "The device has completed a fax transmission call.\n";
		break;
	case FEI_BUSY:
		cout << "The sending device has encountered a busy signal. \n";
		break;
	case FEI_NO_ANSWER:
		cout << "No answer.\n";
		break;
	case FEI_BAD_ADDRESS:
		cout << "Bad Fax number.\n";
		break;
	case FEI_NO_DIAL_TONE :
		cout << "No dial tone.\n";
		break;
	case FEI_DISCONNECTED:
		cout  << "Disconection.\n";
		break;
	case FEI_DELETED:
		cout << "The job has been deleted.\n";
		break;
	case FEI_FAXSVC_ENDED :
		cout << "The Fax service has terminates.\n";
		break;
	case FEI_FATAL_ERROR:
		cout << "The device encountered a fatal protocol error.\n";
		break;
	case FEI_NOT_FAX_CALL:
		cout << "The modem device received a data call or a voice call.\n";
		break;
	case FEI_JOB_QUEUED:
		cout << "The fax job has been queued.\n";
		break;
	case FEI_FAXSVC_STARTED:
		cout << "The fax service has started.\n";
		break;
	case FEI_ANSWERED:
		cout << "The receiving device answered a new call.\n";
		break;
	case FEI_IDLE:
		cout << "The device is idle.\n"; 
	case FEI_MODEM_POWERED_ON:
		cout << "The modem device was turned on.\n";
		break;
	case FEI_MODEM_POWERED_OFF:
		cout << "The modem device was turned off.\n";
		break;
	case FEI_ROUTING:
		cout << "The receiving device is routing a received fax document.\n";
		break;
	case FEI_ABORTING:
		cout << "The device is aborting a fax job.\n";
		break;
	case FEI_RINGING:
		cout << "The receiving device is ringing.\n";
		break;
	case FEI_CALL_DELAYED:
		cout << "The sending device received a busy signal multiple times.\n";
		break;
	case FEI_CALL_BLACKLISTED:
		cout << "The device cannot complete the call because the telephone number\n" <<
				"is blocked or reserved.\n";
		break;
  	
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\jobmngr\cjobparams.h ===
#ifndef JOB_PARAMS_H
#define JOB_PARAMS_H

#include <winfax.h>
#include <ptrs.h>

typedef struct JOB_PARAMS_p 
{
	const TCHAR *szDocument;
	PFAX_JOB_PARAM pJobParam;
	PFAX_COVERPAGE_INFO pCoverpageInfo;
	DWORD dwParentJobId;
}JOB_PARAMS;

typedef struct JOB_BEHAVIOR_p
{
	DWORD dwJobType;
	DWORD dwParam1;
	DWORD dwParam2;
}JOB_BEHAVIOR;

typedef struct JOB_PARAMS_EX_p
{
	//JOB_PARAMS_EX():pdwRecepientsId(SPTR<DWORD>(NULL)){};
	const TCHAR *szDocument;
	PFAX_PERSONAL_PROFILE pSenderProfile;
	PFAX_PERSONAL_PROFILE pRecepientList;
	PFAX_JOB_PARAM_EX pJobParam;
	PFAX_COVERPAGE_INFO_EX pCoverpageInfo;
	DWORD dwNumRecipients;
	DWORD dwParentJobId;
	SPTR<DWORD> pdwRecepientsId;
	JOB_BEHAVIOR* pRecipientsBehavior;

}JOB_PARAMS_EX;

#endif //JOB_PARAMS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\jobmngr\cjobmanager.cpp ===
#include <testruntimeerr.h>
#include "CJobManager.h"

//
// Initialize
// return valuse: SUCCESS - success.
//				  NO_IOCP_THREADS - failed to create any IOCP thread.
//				  NON_GENERIC_ERROR - failed to add already existing jobs to jobs
//                                    hash table
DWORD CJobManager::Initialize(const HANDLE hFax,
							  const HANDLE hCompletionPort,
							  const BOOL fTrackExistingJobs)
	 
{
	assert(hFax);
	m_hFax = hFax;
	m_hCompletionPort = hCompletionPort;

	DWORD dwFuncRetVal = SUCCESS;

	// initialize jobs container
	JobsContainer.Initialize(m_hFax);
	
	if(hCompletionPort && (hCompletionPort != INVALID_HANDLE_VALUE))
	{
		// initialize io completion port threads container
		if(!m_JobThreads.Initialize(m_hCompletionPort))
		{
			// logging
			::lgLogError(LOG_SEV_1, TEXT("CJobManager::Initialize, no IOCP polling threads created"));
			dwFuncRetVal = NO_IOCP_THREADS;
		}
		else
		{
			if(fTrackExistingJobs)
			{
				// register already existing jobs in hash table
				if(JobsContainer.AddAlreadyExistingJobs())
				{
					::lgLogError(LOG_SEV_1, TEXT("CJobManager::Initialize, JobsContainer.AddAlreadyExistingJobs"));
					dwFuncRetVal = NON_GENERIC_ERROR;
				}
			}
		}
	}

	return dwFuncRetVal;
}

DWORD CJobManager::Restart(const HANDLE hFax,
						   const HANDLE hCompletionPort)
{
	assert(hFax);
	m_hFax = hFax;
	m_hCompletionPort = hCompletionPort;

	DWORD dwFuncRetVal = SUCCESS;

	// renew fax job container conection
	JobsContainer.NewFaxConnection();

	if(hCompletionPort && (hCompletionPort != INVALID_HANDLE_VALUE))
	{
		// restart io completion port threads container
		if(!m_JobThreads.RestartThreads(m_hCompletionPort,
										m_dwIOCPortThreads,
										m_dwEventPollingTime,
										&JobsContainer))
		{
			// logging
			::lgLogError(LOG_SEV_1, TEXT("CJobManager::Restart, no IOCP polling threads created"));
			dwFuncRetVal = NO_IOCP_THREADS;
		}

		// We keep on tracking the already existing jobs.
	}
	
	return dwFuncRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\jobmngr\cjobmanager.h ===
#ifndef _JOB_MANAGER_H
#define _JOB_MANAGER_H

// project specific
#include "CThreadJobPool.h"
#include "CJobContainer.h"

// CJobManager error codes
#define SUCCESS     0
#define NO_IOCP_THREADS   1
#define NON_GENERIC_ERROR 2

class CJobManager
{
public:
	CJobManager(const DWORD dwIOCPortThreads = 3,
				const DWORD dwEventPollingTime = 3*60*1000):
		m_hFax(NULL),
		m_hCompletionPort(INVALID_HANDLE_VALUE),
		m_dwIOCPortThreads(dwIOCPortThreads),
		m_dwEventPollingTime(dwEventPollingTime),
		m_JobThreads(m_dwIOCPortThreads, m_dwEventPollingTime, &JobsContainer){};
	DWORD Initialize(const HANDLE hFax,
				     const HANDLE hCompletionPort,
					 const BOOL fTrackExistingJobs = TRUE);
	DWORD Restart(const HANDLE hFax, const HANDLE hCompletionPort);
	DWORD TerminateThreads(){return m_JobThreads.TerminateThreads();};
	~CJobManager(){};
	
	CJobContainer JobsContainer;
private:
	
	DWORD m_dwIOCPortThreads;
	DWORD m_dwEventPollingTime;
	
	HANDLE m_hFax;
	HANDLE m_hCompletionPort;

	CThreadJobPool m_JobThreads; 

};

#endif //_JOB_MANAGER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\jobmngr\cjobtypes.h ===
#ifndef JOB_TYPES_H
#define JOB_TYPES_H

#include <winfax.h>
#include <assert.h>
#include <StringTable.h>

// jobs types
#include "CBaseParentFaxJob.h"
#include "JobBehavior\CSimpleParentJob.h"
#include "JobBehavior\CRandomAbortParentJob.h"
#include "JobBehavior\CMultiTypeJob.h"
#include "JobBehavior\CRandomAbortReceive.h"

// Job types definitions
//
#define JT_SIMPLE_SEND    1
#define JT_SIMPLE_RECEIVE 2

#define JT_RANDOM_ABORT   3
#define JT_RANDOM_PAUSE   4
#define JT_ABORT_PAGE     5
#define JT_ABORT_AFTER_X_SEC  6

typedef std::pair<DWORD, tstring> JOB_TYPE_STR;

const JOB_TYPE_STR SendJobTypeStrTable[]  = {
	std::make_pair( DWORD(JT_SIMPLE_SEND), tstring(TEXT("Simple"))),
	std::make_pair( DWORD(JT_RANDOM_ABORT), tstring(TEXT("Abort"))),
	std::make_pair( DWORD(JT_RANDOM_PAUSE), tstring(TEXT("Pause"))),
	std::make_pair( DWORD(JT_ABORT_AFTER_X_SEC), tstring(TEXT("AbortAfterXSec")))};

#define SendJobTypeStrTableSize ( sizeof(SendJobTypeStrTable) / sizeof(JOB_TYPE_STR))

class CSimpleReceive:public virtual CBaseParentFaxJob
{
public:
	CSimpleReceive(DWORD dwJobId){ m_dwJobId = dwJobId;};
	~CSimpleReceive(){};
	DWORD HandleMessage(CFaxEvent& pFaxEvent);
	DWORD AddRecipient(DWORD dwRecepientId) { assert(FALSE); return 0;};
private:
};


inline DWORD CSimpleReceive::HandleMessage(CFaxEvent& Event)
{

	switch(Event.GetEventId()) 
	{
	case  FEI_COMPLETED:
		// any verfications
		// loging
		assert(SetEvent(m_EvJobCompleted.get()));
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_COMPLETED"),Event.GetJobId());
		break;
	case FEI_DELETED:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_DELETED"),Event.GetJobId());
		break;

	case FEI_ABORTING:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_ABORTING"),Event.GetJobId());
		break;
	case FEI_ANSWERED:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_ANSWERED"),Event.GetJobId());
		break;

	case FEI_RECEIVING :
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_RECEIVING"),Event.GetJobId());
		break;
	
	default:
		{
			for(int index = 0; index <  FaxTableSize; index++)
			{
				if(FaxEventTable[index].first == Event.GetEventId())
				{
					::lgLogError(LOG_SEV_1, TEXT("UNEXPECTED JobId %d, %s"),
											Event.GetJobId(),
											(FaxEventTable[index].second).c_str());
					goto Exit;
				}
			
 			}
			// handle unexpected notifications
			::lgLogError(LOG_SEV_1, TEXT("UNEXPECTED JobId %d, %d"),
									Event.GetJobId(),
									Event.GetEventId());
		
Exit:		break;
		}
	}
		
	
	return 0;
}


#endif //JOB_TYPES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\jobmngr\ctestmanager.cpp ===
#include <winfax.h>
#include <testruntimeerr.h>

#include "CTestManager.h"


// Constructor
// Initialize completion ports & event hooking threads
// [in] tstrServerName - fax server name.
// [in] dwIOCPortThreads - number of threads per fax notification completion port, 
//                         by default 3.
// [in] dwEventPollingTime - Event source thread's polling time for completion 
//                           port package, by default 3 min.

CTestManager::CTestManager(const tstring tstrServerName,
						   const BOOL fHookForEvents,
						   const BOOL fTrackExistingJobs,
						   const DWORD dwIOCPortThreads,
						   const DWORD dwEventPollingTime):
	m_hCompletionPort(INVALID_HANDLE_VALUE),
	m_hFax(NULL),
	m_pEventSource(NULL),
	m_tstrServerName(tstrServerName),
	m_dwIOCPortThreads(dwIOCPortThreads),
	m_dwEventPollingTime(dwEventPollingTime),
	m_pJobManager(NULL)

{

	//initialize service conection
	BOOL bVal = FaxConnectFaxServer( m_tstrServerName.c_str(), &m_hFax);
	if(!bVal)
	{
		DWORD dwErr = GetLastError();
		if(!dwErr)
		{
			::lgLogError(LOG_SEV_2, TEXT("FaxConnectFaxServer-GetLastError returned 0 on fail, module CTestManager."));
		}
		THROW_TEST_RUN_TIME_WIN32(dwErr, TEXT("CTestManager, ConnectFaxServer"));
	}

	if(fHookForEvents)
	{
		// new completion port
		m_hCompletionPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE,NULL,0,0);
		if (!m_hCompletionPort) 
		{
			//constructor is failing, cleanup
			_HandlesCleanup();
			THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT("CTestManager, Completion Port"));
		}
	}

	m_pJobManager = new CJobManager(m_dwIOCPortThreads, m_dwEventPollingTime);
	if(!m_pJobManager)
	{
		//constructor is failing, cleanup
		_HandlesCleanup();
		THROW_TEST_RUN_TIME_WIN32(ERROR_OUTOFMEMORY, TEXT("CTestManager, new CJobManager"));
	}
	if(m_pJobManager->Initialize(m_hFax, m_hCompletionPort, fTrackExistingJobs))
	{
		//constructor is failing, cleanup
		_HandlesCleanup();
		THROW_TEST_RUN_TIME_WIN32(E_FAIL, TEXT("CTestManager, m_JobManager.initialize - no threads created"));
	}

	if(fHookForEvents)
	{
		m_pEventSource = new CEventSource();
		if(!m_pEventSource)
		{
			//constructor is failing, cleanup
			_HandlesCleanup();
			THROW_TEST_RUN_TIME_WIN32(ERROR_OUTOFMEMORY, TEXT("CTestManager, new m_pEventSource"));
		}
		// init fax event redirection thread
		DWORD dwRetVal = m_pEventSource->Initialize(m_tstrServerName, m_hCompletionPort);
		if(dwRetVal)
		{
			//constructor is failing, cleanup
			_HandlesCleanup();
			THROW_TEST_RUN_TIME_WIN32(dwRetVal, TEXT("CTestManager, m_EventSource.Initialize"));
			
		}
	}
	
	
}



//
// Destructor
//
CTestManager::~CTestManager()
{
	delete m_pEventSource;
	m_pEventSource = NULL;
	delete m_pJobManager;
	m_pJobManager = NULL;

	_HandlesCleanup();

}


//
// m_HandlesCleanup
//
void CTestManager::_HandlesCleanup()
{
	if (m_hCompletionPort != INVALID_HANDLE_VALUE)
	{
		if (!CloseHandle( m_hCompletionPort ))
		{
			Win32Err err(GetLastError(),__LINE__,TEXT(__FILE__),TEXT("~CTestManager, CloseHandle"));
			::lgLogError(LOG_SEV_1, TEXT("Exception:%s."), err.description());
		}

	}
	if (m_hFax != NULL)
	{
		if (!FaxClose( m_hFax ))
		{
			Win32Err err(GetLastError(),__LINE__,TEXT(__FILE__),TEXT("~CTestManager, FaxClose"));
			::lgLogError(LOG_SEV_1, TEXT("Exception:%s."), err.description());
		}
	}

}

//
// CancelAllFaxes
//
DWORD CTestManager::CancelAllFaxes()
{
	PFAX_JOB_ENTRY pJobEntry = NULL;
	DWORD dwJobsReturned;
	DWORD dwFunRetVal = 0;

	::lgLogDetail(LOG_X, 0, TEXT("CancelAllFaxes()"));

	if (!FaxEnumJobs( m_hFax, &pJobEntry, &dwJobsReturned))
	{
		dwFunRetVal = GetLastError();
	}
	else
	{
		for (DWORD dwJobIndex = 0; dwJobIndex < dwJobsReturned; dwJobIndex++)
		{
			DWORD dwJobId = pJobEntry[dwJobIndex].JobId;
			if (!FaxAbort(m_hFax, dwJobId))
			{
				lgLogDetail(LOG_X, 0, TEXT("job %d, FaxAbort() failed with %d"),dwJobId,GetLastError());
			}
			else
			{
				lgLogDetail(LOG_X, 0, TEXT("job %d, FaxAbort() succedded"),dwJobId);
			}
		}
	}
		
	FaxFreeBuffer(pJobEntry);
	return dwFunRetVal;
}

//
// StopFaxService
//
BOOL CTestManager::StopFaxService()
{	
	// TODO: check return values of _wsystem
	int ret = _wsystem(L"net stop cometfax");
	if(ret && (ret != ENOENT))
	{
		return FALSE;
	}


	// Terminate source event threads. The call is blocking
	DWORD dwTerminateThreads;
	if(dwTerminateThreads = m_pEventSource->TerminateThreads())
	{
		Win32Err err(dwTerminateThreads,__LINE__,TEXT(__FILE__),TEXT("CTestManager::StopFaxService, m_EventSource.TerminateThread"));
		::lgLogError(LOG_SEV_2, TEXT("Exception:%s."), err.description());
	}

	// Terminate job manager threads. The call is blocking 
	if(dwTerminateThreads = m_pJobManager->TerminateThreads())
	{
		Win32Err err(dwTerminateThreads,__LINE__,TEXT(__FILE__),TEXT("CTestManager::StopFaxService, m_JobManager.TerminateThreads"));
		::lgLogError(LOG_SEV_2, TEXT("Exception:%s."), err.description());
	}
	
	if (m_hFax != NULL)
	{
		if (!FaxClose( m_hFax ))
		{
			Win32Err err(GetLastError(),__LINE__,TEXT(__FILE__),TEXT("~CTestManager, FaxClose"));
			::lgLogError(LOG_SEV_1, TEXT("Exception:%s."), err.description());
			return FALSE;
		}
	}
	return TRUE;

}

BOOL CTestManager::StartFaxService()
{	
	// TODO: check return values of _wsystem
	int ret = _wsystem(L"net start cometfax");
	if(ret && (ret != ENOENT))
	{
		return FALSE;
	}

	try
	{
		//initialize service conection
		BOOL bVal = FaxConnectFaxServer( m_tstrServerName.c_str(), &m_hFax);
		if(!bVal)
		{
			DWORD dwErr = GetLastError();
			if(!dwErr)
			{
				::lgLogError(LOG_SEV_2, TEXT("FaxConnectFaxServer-GetLastError returned 0 on fail, module CTestManager."));
			}
			THROW_TEST_RUN_TIME_WIN32(dwErr, TEXT("CTestManager, ConnectFaxServer"));
		}

	
		// TODO: And if classes weren't initialized?
		// update jobs fax handle
		if(m_pJobManager->Restart(m_hFax, m_hCompletionPort))
		{
			//constructor is failing, cleanup
			_HandlesCleanup();
			THROW_TEST_RUN_TIME_WIN32(E_FAIL, TEXT("CTestManager, m_JobManager.restart - no threads created"));
		}

		
		// init fax event redirection thread
		DWORD dwRetVal = m_pEventSource->RestartThread(m_tstrServerName, m_hCompletionPort);
		if(dwRetVal)
		{
		
			THROW_TEST_RUN_TIME_WIN32(dwRetVal, TEXT("CTestManager, m_EventSource.restartthread"));
			
		}
	}
	catch(Win32Err& err)
	{
		_HandlesCleanup();
		::lgLogError(LOG_SEV_1,TEXT("Exception, CTestManager::StartFaxService %s"), err.description());
		return FALSE;
	}

	return TRUE;
}


inline DWORD _PrintJobStatus(DWORD dwJobId, DWORD dwJobStatus)
{

	DWORD dwTestStatus = 0;

	if(dwJobStatus & JS_PENDING)
	{
		dwTestStatus |= JS_PENDING;
		lgLogDetail(LOG_X, 0, TEXT("job %d, Status is JS_PENDING"),dwJobId);
	}
	if(dwJobStatus & JS_INPROGRESS)
	{
		dwTestStatus |= JS_INPROGRESS;
		lgLogDetail(LOG_X, 0, TEXT("job %d, Status is JS_INPROGRESS"),dwJobId);
	}
	if(dwJobStatus & JS_CANCELING)
	{
		dwTestStatus |= JS_CANCELING;
		lgLogDetail(LOG_X, 0, TEXT("job %d, Status is JS_CANCELING"),dwJobId);
	}
	if(dwJobStatus & JS_FAILED)
	{
		dwTestStatus |= JS_FAILED;
		lgLogDetail(LOG_X, 0, TEXT("job %d, Status is JS_FAILED"),dwJobId);
	}
	if(dwJobStatus & JS_RETRYING)
	{
		dwTestStatus |= JS_RETRYING;
		lgLogDetail(LOG_X, 0, TEXT("job %d, Status is JS_RETRYING"),dwJobId);
	}
	if(dwJobStatus & JS_RETRIES_EXCEEDED)
	{
		dwTestStatus |= JS_RETRIES_EXCEEDED;
		lgLogDetail(LOG_X, 0, TEXT("job %d, Status is JS_RETRIES_EXCEEDED"),dwJobId);
	}
	if(dwJobStatus & JS_PAUSING)
	{
		dwTestStatus |= JS_PAUSING;
		lgLogDetail(LOG_X, 0, TEXT("job %d, State Modifier is JS_PAUSING"),dwJobId);
	}
	if(dwJobStatus & JS_COMPLETED)
	{
		dwTestStatus |= JS_COMPLETED;
		lgLogDetail(LOG_X, 0, TEXT("job %d, State Modifier is JS_COMPLETED"),dwJobId);
	}	
	if(dwJobStatus & JS_PAUSED)
	{
		dwTestStatus |= JS_PAUSED;
		lgLogDetail(LOG_X, 0, TEXT("job %d, State Modifier is JS_PAUSED"),dwJobId);
	}
	if(dwJobStatus & JS_NOLINE)
	{
		dwTestStatus |= JS_NOLINE;
		lgLogDetail(LOG_X, 0, TEXT("job %d, State Modifier is JS_NOLINE"),dwJobId);
	}
	if(dwJobStatus & JS_DELETING)
	{
		dwTestStatus |= JS_DELETING;
		lgLogDetail(LOG_X, 0, TEXT("job %d, State Modifier is JS_DELETING"),dwJobId);
	}
	if(dwTestStatus != dwJobStatus)
	{
		lgLogDetail(LOG_X, 0, TEXT("job %d, Unexpected State %d"),dwJobId, dwTestStatus ^ dwJobStatus);
	}

	return 0;
}

DWORD CTestManager::PrintJobsStatus()
{
	PFAX_JOB_ENTRY pJobEntry = NULL;
	DWORD dwJobsReturned;
	DWORD dwFunRetVal = 0;

	::lgLogDetail(LOG_X, 0, TEXT("PrintJobsStatus()"));

	if (!FaxEnumJobs( m_hFax, &pJobEntry, &dwJobsReturned))
	{
		dwFunRetVal = GetLastError();
	}
	else
	{
		for (DWORD dwJobIndex = 0; dwJobIndex < dwJobsReturned; dwJobIndex++)
		{
			DWORD dwJobId = pJobEntry[dwJobIndex].JobId;
			DWORD dwJobStatus = pJobEntry[dwJobIndex].QueueStatus;
			switch(pJobEntry[dwJobIndex].JobType)
			{
			case JT_RECEIVE:
				lgLogDetail(LOG_X, 0, TEXT("RECEIVE JOB"));
				_PrintJobStatus(dwJobId, dwJobStatus);
				break;
			case JT_SEND:
				DWORD dwParentJobId;
				if( !FaxGetParentJobId( m_hFax ,dwJobId, &dwParentJobId))
				{
					lgLogDetail(LOG_X, 0, TEXT("FAILEF to get Parent Job id for Job: %d error %d"),dwJobId, GetLastError());
				}
				else
				{
					PFAX_JOB_ENTRY pParentJobEntry = NULL;
					if(!FaxGetJob( m_hFax, dwParentJobId,&pParentJobEntry))
					{
						lgLogDetail(LOG_X, 0, TEXT("FAILEF to get Parent Job entry for Job: %d error %d"),dwJobId, GetLastError());
					}
					else
					{
						lgLogDetail(LOG_X, 0, TEXT("PARENT STATUS"));
						_PrintJobStatus(dwParentJobId, dwJobStatus);
						lgLogDetail(LOG_X, 0, TEXT("RECIPIENT STATUS"));
						_PrintJobStatus(dwJobId, dwJobStatus);
					}
				}
		
				break;
			default:
				break;
				}
					
		}
	}
		
	FaxFreeBuffer(pJobEntry);
	return dwFunRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\jobmngr\ctestmanager.h ===
#ifndef _TEST_MANAGER_H
#define _TEST_MANAGER_H


// project specific
#include <Defs.h>
#include <CFaxEvent.h>
#include "CEventSource.h"
#include "CJobParams.h"
#include "CJobManager.h"


class CTestManager
{
public:
	CTestManager(const tstring tstrServerName,
				 const BOOL fHookForEvents = TRUE,
				 const BOOL fTrackExistingJobs = TRUE,
				 const DWORD dwIOCPortThreads = 3,
				 const DWORD dwEventPollingTime = 3*60*1000);

	~CTestManager();
	DWORD AddJob(const DWORD type, JOB_PARAMS& params)
	{return m_pJobManager->JobsContainer.AddJob(type, params);};
	DWORD AddMultiTypeJob(JOB_PARAMS_EX& params)
	{return m_pJobManager->JobsContainer.AddMultiTypeJob(params);};
	DWORD HandleMessage(CFaxEvent& pFaxEvent)
	{return m_pJobManager->JobsContainer.HandleMessage(pFaxEvent);};
	DWORD WaitOnJobEvent(DWORD JobId, BYTE EventType)
	{return m_pJobManager->JobsContainer.WaitOnJobEvent(JobId,EventType);};

	BOOL StopFaxService();
	BOOL StartFaxService();
	DWORD CancelAllFaxes();
	DWORD PrintJobsStatus();
	DWORD SetServiceConfiguration(){return 0;};
	DWORD StopServiceQueue(){return 0;};
	DWORD ResumeServiceQueue(){return 0;};

private:
	void _HandlesCleanup();

	tstring m_tstrServerName;
	HANDLE m_hFax;
	HANDLE m_hCompletionPort;
	DWORD m_dwIOCPortThreads;
	DWORD m_dwEventPollingTime;

	// force explicit destructors in order to
	// control order of objects' destruction (hFax should be relased later).
	CEventSource* m_pEventSource;
	CJobManager* m_pJobManager;

};

#endif  //_TEST_MANAGER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\jobmngr\cthreadjobpool.cpp ===
#include <windows.h>
#include <Defs.h>
#include "CThreadJobPool.h"

//
// Pool of CEventJobThread
//

//
//	CThreadJobPool
//	[in] hCompletionPort - Completion port handle.
//		 dwThreadCount - Number of threads per completion port.
//		 dwEventPollingTime - Threads polling time for completion port package.
//
CThreadJobPool::CThreadJobPool(const DWORD dwThreadCount,
							   const DWORD dwEventPollingTime,
							   const CJobContainer* pJobContainer):
	m_dwThreadCount(dwThreadCount),
	m_dwEventPollingTime(dwEventPollingTime),
	m_hCompletionPort(INVALID_HANDLE_VALUE)
{
	assert(pJobContainer);
	m_pJobContainer = const_cast <CJobContainer*>(pJobContainer);
}

//
// ~CThreadJobPool
//
CThreadJobPool::~CThreadJobPool()
{
	vector<CEventJobThread*>::iterator it;
	
	// stop all threads. Is done instead of letting the default destructors handle it 
	// for performance reasons.
	for(it = m_JobThreadsList.begin(); it != m_JobThreadsList.end(); it++)
	{
		if( WaitForSingleObjectEx( (*it)->GetEvThreadCompleted() , 0, FALSE) != WAIT_OBJECT_0)
		{
			(*it)->StopThreadMain();
		}
	}

	// wait for threads termination.
	for(it = m_JobThreadsList.begin(); it != m_JobThreadsList.end(); it++)
	{
		// time out is set to (thread's polling for IOCP package time out) * 3
	  if(WaitForSingleObjectEx((*it)->GetEvThreadCompleted(), 3 * m_dwEventPollingTime, FALSE) != WAIT_OBJECT_0)
	  {
		  Win32Err err(GetLastError(),__LINE__,TEXT(__FILE__),TEXT("~CThreadJobPool, WaitForSingleObjectEx"));
		  ::lgLogError(LOG_SEV_2, TEXT("Exception:%s."), err.description());
	  }

	  delete (*it);
	 
	}

	m_JobThreadsList.clear();
}


//
// Initialize
// initialize threads.
// [in] hCompletionPort - handle to completion port
// return: number of threads creates successfully
//
DWORD CThreadJobPool::Initialize(const HANDLE hCompletionPort)
{

	assert(hCompletionPort && (hCompletionPort !=INVALID_HANDLE_VALUE));
	m_hCompletionPort = hCompletionPort;

	DWORD dwStartThreadRet; 
	for(int index = 0; index < m_dwThreadCount; index++)
	{
		CEventJobThread*  pThread = NULL;
		try
		{
			pThread = new CEventJobThread(m_hCompletionPort, m_dwEventPollingTime, m_pJobContainer);
			if(!pThread)
			{
				THROW_TEST_RUN_TIME_WIN32(ERROR_OUTOFMEMORY,TEXT(""))
			}
			if( dwStartThreadRet = pThread->StartThread())
			{
				THROW_TEST_RUN_TIME_WIN32(dwStartThreadRet,TEXT(""))
			}
			
		}
		catch(Win32Err& err)
		{
			delete pThread;
			pThread = NULL;
			::lgLogError(LOG_SEV_2, TEXT("Exception:%s."), err.description());
			continue;
		}
		
		m_JobThreadsList.push_back(pThread);
		pThread = NULL;
	}

	return m_JobThreadsList.size();

}

DWORD CThreadJobPool::RestartThreads(const HANDLE hCompletionPort,
									 const DWORD dwThreadCount,
									 const DWORD dwEventPollingTime,
									 const CJobContainer* pJobContainer)

{

	assert(hCompletionPort && (hCompletionPort !=INVALID_HANDLE_VALUE));
	
	TerminateThreads();
	assert(m_JobThreadsList.empty());

	m_hCompletionPort = hCompletionPort;

	DWORD dwStartThreadRet; 

	for(int index = 0; index < m_dwThreadCount; index++)
	{
		CEventJobThread*  pThread = NULL;
		try
		{
			pThread = new CEventJobThread(m_hCompletionPort, m_dwEventPollingTime, m_pJobContainer);
			if(!pThread)
			{
				THROW_TEST_RUN_TIME_WIN32(ERROR_OUTOFMEMORY,TEXT(""))
			}
			if( dwStartThreadRet = pThread->StartThread())
			{
				THROW_TEST_RUN_TIME_WIN32(dwStartThreadRet,TEXT(""))
			}
			
		}
		catch(Win32Err& err)
		{
			delete pThread;
			pThread = NULL;
			::lgLogError(LOG_SEV_2, TEXT("Exception:%s."), err.description());
			continue;
		}
		
		m_JobThreadsList.push_back(pThread);
		pThread = NULL;
	}

	return m_JobThreadsList.size();

}

//
//	return value: threads not terminated
//
DWORD CThreadJobPool::TerminateThreads()
{
	vector<CEventJobThread*>::iterator it;
	
	// stop all threads. 
	for(it = m_JobThreadsList.begin(); it != m_JobThreadsList.end(); it++)
	{
		if( WaitForSingleObjectEx( (*it)->GetEvThreadCompleted() , 0, FALSE) != WAIT_OBJECT_0)
		{
			(*it)->StopThreadMain();
		}
	}

	// wait for threads termination.
	for(it = m_JobThreadsList.begin(); it != m_JobThreadsList.end(); it++)
	{
		// time out is set to (thread's polling for IOCP package time out) * 3
	  if(WaitForSingleObjectEx((*it)->GetEvThreadCompleted(), 3 * m_dwEventPollingTime, FALSE) != WAIT_OBJECT_0)
	  {
		  Win32Err err(GetLastError(),__LINE__,TEXT(__FILE__),TEXT("~CThreadJobPool, WaitForSingleObjectEx"));
		  ::lgLogError(LOG_SEV_2, TEXT("Exception:%s."), err.description());
		  // TODO:: continue;
		  
	  }
	  delete (*it);
	}

	m_JobThreadsList.clear();
	 
	return m_JobThreadsList.size();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\jobmngr\cthreadjobpool.h ===
#ifndef _THREAD_POOL_H
#define _THREAD_POOL_H

#include <vector>

#include "CEventJobThread.h"
#include "CJobContainer.h"

//
// Pool of CEventJobThread
//
class CThreadJobPool
{
public:
	CThreadJobPool(const DWORD dwThreadCount,
				   const DWORD dwEventPollingTime,
				   const CJobContainer* m_JobContainer);
	~CThreadJobPool();
	DWORD Initialize(const HANDLE hCompletionPort);
	DWORD RestartThreads(const HANDLE hCompletionPort,
						 const DWORD dwThreadCount,
					     const DWORD dwEventPollingTime,
					     const CJobContainer* m_JobContainer);
	DWORD TerminateThreads();
private:
	HANDLE m_hCompletionPort; // Handle is passed, do not free.
	DWORD m_dwThreadCount;
	DWORD m_dwEventPollingTime;
	std::vector<CEventJobThread*> m_JobThreadsList;
	CJobContainer* m_pJobContainer;

};

#endif //_THREAD_POOL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\jobmngr\jobbehavior\crandomabortjob.h ===
#ifndef RANDOM_ABORT_JOB_H
#define RANDOM_ABORT_JOB_H

#include <winfax.h>
#include <Defs.h>
#include <StringTable.h>
#include "..\CBaseFaxJob.h"


//
// CRandomAbortJob
// Min seconds to abort = 0
// Max minutes to abort = 5
class CRandomAbortJob:public virtual CBaseFaxJob
{
public:
	CRandomAbortJob(HANDLE m_hFax, DWORD dwRecepientId, DWORD dwMaxInterval = 5*60, DWORD dwMinInterval = 0);
	~CRandomAbortJob(){};
	DWORD StartOperation();
	DWORD HandleMessage(CFaxEvent& pFaxEvent);
private:
	DWORD _HandleRecipientEvent(DWORD dwEventId);
	Event_t m_EvJobAborted;
	// TODO consider
	BOOL fAborted;
	DWORD m_dwMaxInterval;
	DWORD m_dwMinInterval;
};


inline CRandomAbortJob::CRandomAbortJob(HANDLE hFax,
										DWORD dwRecepientId,
										DWORD dwMaxInterval,
										DWORD dwMinInterval):
	m_EvJobAborted(NULL, TRUE, FALSE,TEXT("")),
	fAborted(FALSE)
{ 
	assert(hFax);
	m_hFax = hFax;
	m_dwJobId = dwRecepientId;
	assert(m_dwMaxInterval >= 0);
	m_dwMaxInterval = dwMaxInterval;
	assert(m_dwMinInterval >= 0);
	m_dwMinInterval = dwMinInterval;
}

inline DWORD CRandomAbortJob::StartOperation()
{
	srand(GetTickCount() * m_dwJobId);
	DWORD dwMiliSecsToAbort;
	DWORD dwAbsInterval = ( abs(m_dwMaxInterval - m_dwMinInterval) == 0) ? 1 :
							abs(m_dwMaxInterval - m_dwMinInterval);
	dwMiliSecsToAbort =  m_dwMinInterval*1000 +  (rand()*100) % (dwAbsInterval*1000);

	lgLogDetail(LOG_X, 0, TEXT("job %d, Aborting in %d miliseconds"),m_dwJobId, dwMiliSecsToAbort);
	Sleep(dwMiliSecsToAbort);
	
	m_dwJobStatus = GetJobStatus();
		
	if(m_dwJobStatus != -1)
	{
		#ifdef _DEBUG
			PrintJobStatus(m_dwJobStatus);
		#endif
		if (!FaxAbort(m_hFax, m_dwJobId))
		{
			lgLogDetail(LOG_X, 0, TEXT("job %d, FaxAbort() failed with %d"),m_dwJobId,GetLastError());
		}
		else
		{
		
	#ifdef _DEBUG
				PrintJobStatus(m_dwJobStatus);
			#endif
			lgLogDetail(LOG_X, 0, TEXT("job %d, FaxAbort() succedded"),m_dwJobId);
		}
	}
	else
	{
		lgLogDetail(LOG_X, 0, TEXT("job %d, GetJobStatus() faile with %d"),m_dwJobId, GetLastError());
	}

	
	verify (SetEvent(m_EvOperationCompleted.get()));
	return 0;
}

inline DWORD CRandomAbortJob::HandleMessage(CFaxEvent& Event)
{

	DWORD dwJobId = Event.GetJobId();
	verify(dwJobId == m_dwJobId);
	// update jobs status
	m_dwJobStatus = GetJobStatus();
	_HandleRecipientEvent(Event.GetEventId());
	return 0;
}

inline DWORD CRandomAbortJob::_HandleRecipientEvent(DWORD dwEventId)
{
	if(fAborted)
	{
		for(int index = 0; index <  FaxTableSize; index++)
		{
			if(FaxEventTable[index].first == dwEventId)
			{
				::lgLogError(LOG_SEV_1, TEXT("UNEXPECTED JobId %d is ABORTED, %s"),
										m_dwJobId,
										(FaxEventTable[index].second).c_str());
				return 0;
			}
			
 		}
	}

	switch(dwEventId) 
	{
	case FEI_INITIALIZING :
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_INITIALIZING"),m_dwJobId);
	break;
	case FEI_DIALING :
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_DIALING"),m_dwJobId);
		break;
	case FEI_SENDING :
		// any verfications
		// loging
		verify(SetEvent(m_EvJobSending.get()));
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_SENDING"),m_dwJobId);
		break;
	case  FEI_COMPLETED:
		// any verfications
		// loging
		verify(SetEvent(m_EvJobCompleted.get()));
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_COMPLETED"),m_dwJobId);
		break;
	case FEI_BUSY:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_BUSY"),m_dwJobId);
		break;
	case FEI_NO_ANSWER:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_NO_ANSWER"),m_dwJobId);
		break;
	case FEI_BAD_ADDRESS:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_BAD_ADDRESS"),m_dwJobId);
		break;
	case FEI_NO_DIAL_TONE :
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_NO_DIAL_TONE"),m_dwJobId);
		break;
	case FEI_DISCONNECTED:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_DISCONNECTED"),m_dwJobId);
		break;
	case FEI_ROUTING:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_ROUTING"),m_dwJobId);
		break;
	case FEI_ABORTING:
		// any verfications
		// loging
		fAborted = TRUE;
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_ABORTING"),m_dwJobId);
		break;
	case FEI_CALL_DELAYED:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_CALL_DELAYED"),m_dwJobId);
		break;
	case FEI_CALL_BLACKLISTED:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_CALL_BLACKLISTED"),m_dwJobId);
		break;
	case FEI_JOB_QUEUED:
	case FEI_ANSWERED:
	case FEI_RECEIVING :
	case FEI_FAXSVC_STARTED:
	case FEI_MODEM_POWERED_ON:
	case FEI_MODEM_POWERED_OFF:
	case FEI_FAXSVC_ENDED :
	case FEI_FATAL_ERROR:
	case FEI_IDLE:
	case FEI_RINGING:
	case FEI_DELETED:
	case FEI_NOT_FAX_CALL:
	default:
		{
			for(int index = 0; index <  FaxTableSize; index++)
			{
				if(FaxEventTable[index].first == dwEventId)
				{
					::lgLogError(LOG_SEV_1, TEXT("UNEXPECTED JobId %d, %s"),
											m_dwJobId,
											(FaxEventTable[index].second).c_str());
					goto Exit;
				}
			
 			}
			// handle unexpected notifications
			::lgLogError(LOG_SEV_1, TEXT("UNEXPECTED JobId %d, %d"),
									m_dwJobId,
									dwEventId);
		
Exit:		break;
		}
	}
		
	
	return 0;
}

#endif // RANDOM_ABORT_JOB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\jobmngr\jobbehavior\cabortafterxsec.h ===
#ifndef _ABORT_AFTER_X_SEC_H
#define _ABORT_AFTER_X_SEC_H

#include <winfax.h>
#include <Defs.h>
#include <StringTable.h>
#include "..\CBaseFaxJob.h"


//
// CRandomAbortJob
//
class CAbortAfterXSec:public virtual CBaseFaxJob
{
public:
	CAbortAfterXSec(HANDLE m_hFax, DWORD dwRecepientId, DWORD dwSecToAbort = 0);
	~CAbortAfterXSec(){};
	DWORD StartOperation();
	DWORD HandleMessage(CFaxEvent& pFaxEvent);
private:
	DWORD _HandleRecipientEvent(DWORD dwEventId);
	Event_t m_EvJobAborted;
	// TODO consider
	BOOL fAborted;
	DWORD m_dwSecToAbort;
};

inline CAbortAfterXSec::CAbortAfterXSec(HANDLE hFax, DWORD dwRecepientId, DWORD dwSecToAbort):
	m_EvJobAborted(NULL, TRUE, FALSE,TEXT("")),
	fAborted(FALSE)
{ 
	assert(hFax);
	m_hFax = hFax;
	m_dwJobId = dwRecepientId;
	m_dwSecToAbort = dwSecToAbort;

}

inline DWORD CAbortAfterXSec::StartOperation()
{

	lgLogDetail(LOG_X, 0, TEXT("job %d, Aborting in %d seconds"),m_dwJobId, m_dwSecToAbort);
	Sleep(m_dwSecToAbort);
	
	m_dwJobStatus = GetJobStatus();
		
	if(m_dwJobStatus != -1)
	{
		#ifdef _DEBUG
			PrintJobStatus(m_dwJobStatus);
		#endif
		if (!FaxAbort(m_hFax, m_dwJobId))
		{
			lgLogDetail(LOG_X, 0, TEXT("job %d, FaxAbort() failed with %d"),m_dwJobId,GetLastError());
		}
		else
		{
		
	#ifdef _DEBUG
				PrintJobStatus(m_dwJobStatus);
			#endif
			lgLogDetail(LOG_X, 0, TEXT("job %d, FaxAbort() succedded"),m_dwJobId);
		}
	}
	else
	{
		lgLogDetail(LOG_X, 0, TEXT("job %d, GetJobStatus() faile with %d"),m_dwJobId, GetLastError());
	}

	
	verify (SetEvent(m_EvOperationCompleted.get()));
	return 0;
}

inline DWORD CAbortAfterXSec::HandleMessage(CFaxEvent& Event)
{

	DWORD dwJobId = Event.GetJobId();
	verify(dwJobId == m_dwJobId);
	// update jobs status
	m_dwJobStatus = GetJobStatus();
	_HandleRecipientEvent(Event.GetEventId());
	return 0;
}

inline DWORD CAbortAfterXSec::_HandleRecipientEvent(DWORD dwEventId)
{
	if(fAborted)
	{
		for(int index = 0; index <  FaxTableSize; index++)
		{
			if(FaxEventTable[index].first == dwEventId)
			{
				::lgLogError(LOG_SEV_1, TEXT("UNEXPECTED JobId %d is ABORTED, %s"),
										m_dwJobId,
										(FaxEventTable[index].second).c_str());
				return 0;
			}
			
 		}
	}

	switch(dwEventId) 
	{
	case FEI_INITIALIZING :
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_INITIALIZING"),m_dwJobId);
	break;
	case FEI_DIALING :
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_DIALING"),m_dwJobId);
		break;
	case FEI_SENDING :
		// any verfications
		// loging
		verify(SetEvent(m_EvJobSending.get()));
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_SENDING"),m_dwJobId);
		break;
	case  FEI_COMPLETED:
		// any verfications
		// loging
		verify(SetEvent(m_EvJobCompleted.get()));
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_COMPLETED"),m_dwJobId);
		break;
	case FEI_BUSY:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_BUSY"),m_dwJobId);
		break;
	case FEI_NO_ANSWER:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_NO_ANSWER"),m_dwJobId);
		break;
	case FEI_BAD_ADDRESS:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_BAD_ADDRESS"),m_dwJobId);
		break;
	case FEI_NO_DIAL_TONE :
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_NO_DIAL_TONE"),m_dwJobId);
		break;
	case FEI_DISCONNECTED:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_DISCONNECTED"),m_dwJobId);
		break;
	case FEI_ROUTING:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_ROUTING"),m_dwJobId);
		break;
	case FEI_ABORTING:
		// any verfications
		// loging
		fAborted = TRUE;
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_ABORTING"),m_dwJobId);
		break;
	case FEI_CALL_DELAYED:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_CALL_DELAYED"),m_dwJobId);
		break;
	case FEI_CALL_BLACKLISTED:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_CALL_BLACKLISTED"),m_dwJobId);
		break;
	case FEI_JOB_QUEUED:
	case FEI_ANSWERED:
	case FEI_RECEIVING :
	case FEI_FAXSVC_STARTED:
	case FEI_MODEM_POWERED_ON:
	case FEI_MODEM_POWERED_OFF:
	case FEI_FAXSVC_ENDED :
	case FEI_FATAL_ERROR:
	case FEI_IDLE:
	case FEI_RINGING:
	case FEI_DELETED:
	case FEI_NOT_FAX_CALL:
	default:
		{
			for(int index = 0; index <  FaxTableSize; index++)
			{
				if(FaxEventTable[index].first == dwEventId)
				{
					::lgLogError(LOG_SEV_1, TEXT("UNEXPECTED JobId %d, %s"),
											m_dwJobId,
											(FaxEventTable[index].second).c_str());
					goto Exit;
				}
			
 			}
			// handle unexpected notifications
			::lgLogError(LOG_SEV_1, TEXT("UNEXPECTED JobId %d, %d"),
									m_dwJobId,
									dwEventId);
		
Exit:		break;
		}
	}
		
	
	return 0;
}

#endif // _ABORT_AFTER_X_SEC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\jobmngr\jobbehavior\cabortatxpage.h ===
#ifndef ABORT_AT_X_PAGE_H
#define ABORT_AT_X_PAGE_H

#include <winfax.h>
#include <Defs.h>
#include <StringTable.h>
#include "..\CBaseFaxJob.h"


//
// CAbortAtXPage
//
class CAbortAtXPage:public virtual CBaseFaxJob
{
public:
	CAbortAtXPage(const HANDLE hFax, const DWORD dwRecepientId, const DWORD dwPageNum);
	~CAbortAtXPage(){};
	DWORD StartOperation() { return 0;};
	DWORD HandleMessage(CFaxEvent& pFaxEvent);
private:
	DWORD _HandleRecipientEvent(DWORD dwEventId);
	DWORD m_dwPageCounter;
	DWORD m_dwPageNumber;
	Event_t m_EvJobAborted;
};

inline CAbortAtXPage::CAbortAtXPage(const HANDLE hFax, const DWORD dwRecepientId, const DWORD dwPageNum):
	m_EvJobAborted(NULL, TRUE, FALSE,TEXT(""))
{ 
	m_hFax = hFax;
	m_dwJobId = dwRecepientId;
	m_dwPageNumber = dwPageNum;
	m_dwPageCounter = 0;
	
}

inline DWORD CAbortAtXPage::HandleMessage(CFaxEvent& Event)
{

	DWORD dwJobId = Event.GetJobId();
	verify(dwJobId == m_dwJobId);
	
	// update jobs status
	m_dwJobStatus = GetJobStatus();
	
	BYTE StatusCode = m_dwJobStatus % 256;
	switch(StatusCode)
	{
	case JS_RETRYING:
		m_dwPageCounter = 0;
		break;
			
	}
	
	_HandleRecipientEvent(Event.GetEventId());
	return 0;
}

inline DWORD CAbortAtXPage::_HandleRecipientEvent(DWORD dwEventId)
{
	switch(dwEventId) 
	{
	case FEI_DIALING :
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_DIALING"),m_dwJobId);
		break;
	case FEI_SENDING :
		// any verfications
		// loging
		
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_SENDING"),m_dwJobId);
		m_dwPageCounter++;
		if(m_dwPageNumber == m_dwPageCounter)
		{
			lgLogDetail(LOG_X, 0, TEXT("job %d, Aborting"),m_dwJobId);
			if (!FaxAbort(m_hFax, m_dwJobId))
			{
				Win32Err err(GetLastError(),__LINE__,TEXT(__FILE__),TEXT(""));
				lgLogDetail(LOG_X, 0, TEXT("job %d, FaxAbort() %s"),m_dwJobId,err.description());
			}
		}
		break;
	case  FEI_COMPLETED:
		verify(SetEvent(m_EvJobCompleted.get()));
		//::lgLogError(LOG_SEV_1, TEXT("JobId %d, FEI_COMPLETED "),m_dwJobId)
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_COMPLETED"),m_dwJobId);
		break;
	case FEI_BUSY:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_BUSY"),m_dwJobId);
		break;
	case FEI_NO_ANSWER:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_NO_ANSWER"),m_dwJobId);
		break;
	case FEI_BAD_ADDRESS:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_BAD_ADDRESS"),m_dwJobId);
		break;
	case FEI_NO_DIAL_TONE :
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_NO_DIAL_TONE"),m_dwJobId);
		break;
	case FEI_DISCONNECTED:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_DISCONNECTED"),m_dwJobId);
		break;
	case FEI_DELETED:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_DELETED"),m_dwJobId);
		break;
	case FEI_ROUTING:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_ROUTING"),m_dwJobId);
		break;
	case FEI_ABORTING:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_ABORTING"),m_dwJobId);
		break;
	case FEI_CALL_DELAYED:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_CALL_DELAYED"),m_dwJobId);
		break;
	case FEI_CALL_BLACKLISTED:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_CALL_BLACKLISTED"),m_dwJobId);
		break;
	case FEI_JOB_QUEUED:
	case FEI_ANSWERED:
	case FEI_RECEIVING :
	case FEI_FAXSVC_STARTED:
	case FEI_MODEM_POWERED_ON:
	case FEI_MODEM_POWERED_OFF:
	case FEI_FAXSVC_ENDED :
	case FEI_FATAL_ERROR:
	case FEI_IDLE:
	case FEI_RINGING:
	case FEI_NOT_FAX_CALL:
	default:
		{
			for(int index = 0; index <  FaxTableSize; index++)
			{
				if(FaxEventTable[index].first == dwEventId)
				{
					::lgLogError(LOG_SEV_1, TEXT("UNEXPECTED JobId %d, %s"),
											m_dwJobId,
											(FaxEventTable[index].second).c_str());
					goto Exit;
				}
			
 			}
			// handle unexpected notifications
			::lgLogError(LOG_SEV_1, TEXT("UNEXPECTED JobId %d, %d"),
									m_dwJobId,
									dwEventId);
		
Exit:		break;
		}
	}
		
	
	return 0;
}

#endif // ABORT_AT_X_PAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\jobmngr\maptofaxstruct.h ===
#ifndef _MAP_TO_FAX_STRUCT
#define _MAP_TO_FAX_STRUCT

#include <winfax.h>
#include <map>
#include <tstring.h>
#include <iniutils.h>

// Declarations
//
void MapToFAX_JOB_PARAM_EX(const std::map<tstring, tstring>& JobParamsMap,
						   FAX_JOB_PARAM_EX& FaxJobParams);
BOOL MapNumberToFAX_PERSONAL_PROFILE(const std::map<tstring, tstring>& SectionEntriesMap,
									 FAX_PERSONAL_PROFILE& FaxPersonalProfile);
void ChargeFAX_PERSONAL_PROFILE(const std::map<tstring, tstring>& PersonalProfileMap,
							    FAX_PERSONAL_PROFILE& FaxPersonalProfile);
void MapToFAX_COVERPAGE_INFO_EX(const tstring& tstrCoverPage,
								FAX_COVERPAGE_INFO_EX& FaxCoverPage);


//
// MapToFAX_JOB_PARAM_EX
//
// [in] JobParamsMap - Map of FAX_JOB_PARAM_EX structure
// [out] FaxJobParams - FAX_JOB_PARAM_EX structure
//
inline void MapToFAX_JOB_PARAM_EX(const std::map<tstring, tstring>& JobParamsMap,
								  FAX_JOB_PARAM_EX& FaxJobParams)
{
	memset(&FaxJobParams, 0, sizeof(FAX_JOB_PARAM_EX));
	FaxJobParams.dwSizeOfStruct = sizeof(FAX_JOB_PARAM_EX);
	
	std::map<tstring, tstring>::const_iterator iterMap;
	iterMap = JobParamsMap.find( TEXT("DeliveryType"));
	if(iterMap != JobParamsMap.end() && (((*iterMap).second) != tstring(TEXT(""))))
	{ 
		long  lDeliveryType = _tcstol( ((*iterMap).second).c_str(), NULL, 10);
		FaxJobParams.dwReceiptDeliveryType = lDeliveryType;
	}
	
	iterMap = JobParamsMap.find( TEXT("DeliveryProfile"));
	if( (iterMap != JobParamsMap.end()) && (((*iterMap).second) != tstring(TEXT(""))))
	{ 
		FaxJobParams.lptstrReceiptDeliveryProfile = _tcsdup(((*iterMap).second).c_str());
		assert(FaxJobParams.lptstrReceiptDeliveryProfile);
	}

	iterMap = JobParamsMap.find( TEXT("FaxName"));
	if( (iterMap != JobParamsMap.end()) && (((*iterMap).second) != tstring(TEXT(""))))
	{ 
		FaxJobParams.lptstrDocumentName = _tcsdup(((*iterMap).second).c_str());
		assert(FaxJobParams.lptstrDocumentName);
	}

	iterMap = JobParamsMap.find( TEXT("PageCount"));
	
	if(iterMap != JobParamsMap.end() && (((*iterMap).second) != tstring(TEXT(""))))
	{ 
		long  lPageCount = _tcstol( ((*iterMap).second.c_str()), NULL, 10);
		FaxJobParams.dwPageCount = lPageCount;
	}

	FaxJobParams.dwScheduleAction = JSA_SPECIFIC_TIME;
	
	SYSTEMTIME tmSys;
	GetLocalTime(&tmSys);

	iterMap = JobParamsMap.find( TEXT("Time(xx:xx)"));
	
	if( (iterMap != JobParamsMap.end()) && (((*iterMap).second) != tstring(TEXT(""))))
	{ 
		DWORD dwHour,dwMinutes;
		dwHour = dwMinutes = 0;
		tstring tstrHour, tstrMinute;
		DWORD  dwSeparatorIndex = ((*iterMap).second).find_first_of(TEXT(":"));

		if(dwSeparatorIndex != tstring::npos)
		{
			tstrHour = ((*iterMap).second).substr(0,dwSeparatorIndex);
			if( ((*iterMap).second).size() > dwSeparatorIndex + 1)
			{
				tstrMinute =  ((*iterMap).second).substr(dwSeparatorIndex + 1);
			}
			if( (tstrHour != tstring(TEXT(""))) && (tstrMinute != tstring(TEXT(""))))
			{
				dwHour = _tcstoul(tstrHour.c_str(), NULL, 10);
				dwMinutes = _tcstoul(tstrMinute.c_str(), NULL, 10);
		
				if((dwHour > 0) && (dwHour < 24))
				{
					tmSys.wHour = dwHour;

				}
				if((dwMinutes >= 0) && (dwMinutes < 60))
				{
					tmSys.wMinute = dwMinutes;
				}
			}
		}
	}

	FaxJobParams.tmSchedule = tmSys;
}

//
// MapNumberToFAX_PERSONAL_PROFILE
//
// [in] tstrCoverPage - cover page path
// [out] FaxCoverPage - FAX_COVERPAGE_INFO_EX structure initialized.
inline void MapToFAX_COVERPAGE_INFO_EX(const tstring& tstrCoverPage,
									   FAX_COVERPAGE_INFO_EX& FaxCoverPage)
{
	memset(&FaxCoverPage, 0, sizeof(FAX_COVERPAGE_INFO_EX));
	FaxCoverPage.dwSizeOfStruct = sizeof(FAX_COVERPAGE_INFO_EX);

	FaxCoverPage.lptstrCoverPageFileName = _tcsdup(tstrCoverPage.c_str());
	assert(FaxCoverPage.lptstrCoverPageFileName);
}
//
// MapNumberToFAX_PERSONAL_PROFILE
//
// [in] SectionEntriesMap - Map of personal profile number and rest of profile details section name.
// [out] FaxPersonalProfile - FAX_PERSONAL_PROFILE structure initialized
//
// returns - FALSE if Fax Number not found or has no value.
//

inline BOOL MapNumberToFAX_PERSONAL_PROFILE(const std::map<tstring, tstring>& SectionEntriesMap,
											FAX_PERSONAL_PROFILE& FaxPersonalProfile)
{
	std::map<tstring, tstring>::const_iterator iterMap;
	memset(&FaxPersonalProfile, 0, sizeof(FAX_PERSONAL_PROFILE));
	FaxPersonalProfile.dwSizeOfStruct = sizeof(FAX_PERSONAL_PROFILE);

	iterMap = SectionEntriesMap.find( TEXT("Fax Number"));
	if( (iterMap != SectionEntriesMap.end()) && (((*iterMap).second) != tstring(TEXT(""))))
	{ 
		FaxPersonalProfile.lptstrFaxNumber = _tcsdup(((*iterMap).second).c_str());
		assert(FaxPersonalProfile.lptstrFaxNumber);
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}



//
// ChargeFAX_PERSONAL_PROFILE
//
//FAX_PERSONAL_PROFILE structure should be initialized before function calling
inline void ChargeFAX_PERSONAL_PROFILE(const std::map<tstring, tstring>& PersonalProfileMap,
								       FAX_PERSONAL_PROFILE& FaxPersonalProfile)
{ 
		
	std::map<tstring, tstring>::const_iterator iterMap;

	iterMap = PersonalProfileMap.find( TEXT("Name"));
	if( (iterMap != PersonalProfileMap.end()) && (((*iterMap).second) != tstring(TEXT(""))))
	{ 
		FaxPersonalProfile.lptstrName = _tcsdup(((*iterMap).second).c_str());
		assert(FaxPersonalProfile.lptstrName);
	}

	iterMap = PersonalProfileMap.find( TEXT("Company"));
	if( (iterMap != PersonalProfileMap.end()) && (((*iterMap).second) != tstring(TEXT(""))))
	{ 
		FaxPersonalProfile.lptstrCompany = _tcsdup(((*iterMap).second).c_str());
		assert(FaxPersonalProfile.lptstrCompany);
	}
	
	iterMap = PersonalProfileMap.find( TEXT("StreetAddress"));
	if( (iterMap != PersonalProfileMap.end()) && (((*iterMap).second) != tstring(TEXT(""))))
	{ 
		FaxPersonalProfile.lptstrStreetAddress = _tcsdup(((*iterMap).second).c_str());
		assert(FaxPersonalProfile.lptstrStreetAddress);
	}

	iterMap = PersonalProfileMap.find( TEXT("City"));
	if( (iterMap != PersonalProfileMap.end()) && (((*iterMap).second) != tstring(TEXT(""))))
	{ 
		FaxPersonalProfile.lptstrCity = _tcsdup(((*iterMap).second).c_str());
		assert(FaxPersonalProfile.lptstrCity);
	}

	iterMap = PersonalProfileMap.find( TEXT("State"));
	if( (iterMap != PersonalProfileMap.end()) && (((*iterMap).second) != tstring(TEXT(""))))
	{ 
		FaxPersonalProfile.lptstrState = _tcsdup(((*iterMap).second).c_str());
		assert(FaxPersonalProfile.lptstrState);
	}

	iterMap = PersonalProfileMap.find( TEXT("Zip"));
	if( (iterMap != PersonalProfileMap.end()) && (((*iterMap).second) != tstring(TEXT(""))))
	{ 
		FaxPersonalProfile.lptstrZip = _tcsdup(((*iterMap).second).c_str());
		assert(FaxPersonalProfile.lptstrZip);
	}

	iterMap = PersonalProfileMap.find( TEXT("Country"));
	if( (iterMap != PersonalProfileMap.end()) && (((*iterMap).second) != tstring(TEXT(""))))
	{ 
		FaxPersonalProfile.lptstrCountry = _tcsdup(((*iterMap).second).c_str());
		assert(FaxPersonalProfile.lptstrCountry);
	}

	iterMap = PersonalProfileMap.find( TEXT("Title"));
	if( (iterMap != PersonalProfileMap.end()) && (((*iterMap).second) != tstring(TEXT(""))))
	{ 
		FaxPersonalProfile.lptstrTitle = _tcsdup(((*iterMap).second).c_str());
		assert(FaxPersonalProfile.lptstrTitle);
	}

	iterMap = PersonalProfileMap.find( TEXT("Department"));
	if( (iterMap != PersonalProfileMap.end()) && (((*iterMap).second) != tstring(TEXT(""))))
	{ 
		FaxPersonalProfile.lptstrDepartment = _tcsdup(((*iterMap).second).c_str());
		assert(FaxPersonalProfile.lptstrDepartment);
	}

	iterMap = PersonalProfileMap.find( TEXT("Location"));
	if( (iterMap != PersonalProfileMap.end()) && (((*iterMap).second) != tstring(TEXT(""))))
	{ 
		FaxPersonalProfile.lptstrOfficeLocation = _tcsdup(((*iterMap).second).c_str());
		assert(FaxPersonalProfile.lptstrOfficeLocation);
	}
	
	iterMap = PersonalProfileMap.find( TEXT("HomePhone"));
	if( (iterMap != PersonalProfileMap.end()) && (((*iterMap).second) != tstring(TEXT(""))))
	{ 
		FaxPersonalProfile.lptstrHomePhone = _tcsdup(((*iterMap).second).c_str());
		assert(FaxPersonalProfile.lptstrHomePhone);
	}

	iterMap = PersonalProfileMap.find( TEXT("OfficePhone"));
	if( (iterMap != PersonalProfileMap.end()) && (((*iterMap).second) != tstring(TEXT(""))))
	{ 
		FaxPersonalProfile.lptstrOfficePhone = _tcsdup(((*iterMap).second).c_str());
		assert(FaxPersonalProfile.lptstrOfficePhone);
	}

	iterMap = PersonalProfileMap.find( TEXT("OrganizationalMail"));
	if( (iterMap != PersonalProfileMap.end()) && (((*iterMap).second) != tstring(TEXT(""))))
	{ 
		FaxPersonalProfile.lptstrOrganizationalMail = _tcsdup(((*iterMap).second).c_str());
		assert(FaxPersonalProfile.lptstrOrganizationalMail);
	}

	iterMap = PersonalProfileMap.find( TEXT("InternetMail"));
	if( (iterMap != PersonalProfileMap.end()) && (((*iterMap).second) != tstring(TEXT(""))))
	{ 
		FaxPersonalProfile.lptstrInternetMail = _tcsdup(((*iterMap).second).c_str());
		assert(FaxPersonalProfile.lptstrInternetMail);
	}

	iterMap = PersonalProfileMap.find( TEXT("BillingCode"));
	if( (iterMap != PersonalProfileMap.end()) && (((*iterMap).second) != tstring(TEXT(""))))
	{ 
		FaxPersonalProfile.lptstrBillingCode = _tcsdup(((*iterMap).second).c_str());
		assert(FaxPersonalProfile.lptstrBillingCode);
	}

	iterMap = PersonalProfileMap.find( TEXT("TSID"));
	if( (iterMap != PersonalProfileMap.end()) && (((*iterMap).second) != tstring(TEXT(""))))
	{ 
		FaxPersonalProfile.lptstrTSID = _tcsdup(((*iterMap).second).c_str());
		assert(FaxPersonalProfile.lptstrTSID);
	}
}


#endif //_MAP_TO_FAX_STRUCT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\jobmngr\jobbehavior\cmultitypejob.h ===
#ifndef MULTI_TYPE_JOB_H
#define MULTI_TYPE_JOB_H

#include <winfax.h>
#include <Defs.h>
#include <StringTable.h>
#include "..\CBaseParentFaxJob.h"
#include "CRandomAbortJob.h"
#include "CRandomPauseJob.h"
#include "CAbortAtXPage.h"
#include "CAbortAfterXSec.h"
#include "CSimpleJob.h"

static DWORD WINAPI _RandomAbortJob(void* params);
static DWORD WINAPI _RandomPauseJob(void* params);
static DWORD WINAPI _AbortAfterXSecJob(void* params);

//
//  CRandomAbortParentJob
//
class CMultiTypeJob:public virtual CBaseParentFaxJob
{
public:
	CMultiTypeJob(HANDLE hFax, DWORD dwJobId, DWORD dwRecipientNum);
	~CMultiTypeJob(){};
	DWORD HandleMessage(CFaxEvent& pFaxEvent);
	DWORD AddRecipient(DWORD dwRecepientId);
	DWORD AddPauseRecipient(DWORD dwRecepientId, DWORD dwMaxInterval = 5*60, DWORD dwMinInterval = 0);
	DWORD AddAbortAtXPage(DWORD dwRecepientId, DWORD dwPageNum);
	DWORD AddAbortRecipient(DWORD dwRecepientId, DWORD dwMaxInterval = 5*60, DWORD dwMinInterval = 0);
	DWORD CMultiTypeJob::AddAbortAfterXSec(DWORD dwRecepientId, DWORD dwSecToAbort = 0);
	CBaseFaxJob* dwCurrentRecipientObj;
private:
	DWORD _HandleParentEvent(DWORD dwEventId);

};


inline CMultiTypeJob::CMultiTypeJob(HANDLE hFax, DWORD dwJobId, DWORD dwRecipientNum)
{
	assert(hFax);
	m_hFax = hFax;
	m_dwJobId = dwJobId;
	m_RecipientNum = dwRecipientNum;
};


inline DWORD CMultiTypeJob::AddRecipient(DWORD dwRecepientId)
{
	DWORD dwRetVal = 0;
	// add recepient job object
	CSimpleJob* pJob = new CSimpleJob(dwRecepientId); 
	if(!pJob)
	{
		dwRetVal = ERROR_OUTOFMEMORY;
	}
	else
	{
		m_RecipientTable.Lock(dwRecepientId); // lock recipient
		verify(m_RecipientTable.Add(dwRecepientId, pJob));
		m_RecipientTable.UnLock(dwRecepientId);
		
	}
	return dwRetVal;
}
inline DWORD CMultiTypeJob::AddAbortAtXPage(DWORD dwRecepientId, DWORD dwPageNum)
{
		DWORD dwRetVal = 0;
	// add recepient job object
	CAbortAtXPage* pJob = new CAbortAtXPage(m_hFax, dwRecepientId,dwPageNum); 
	if(!pJob)
	{
		dwRetVal = ERROR_OUTOFMEMORY;
	}
	else
	{
		m_RecipientTable.Lock(dwRecepientId); // lock recipient
		verify(m_RecipientTable.Add(dwRecepientId, pJob));
		m_RecipientTable.UnLock(dwRecepientId);
		
	}
	return dwRetVal;
}
inline DWORD CMultiTypeJob::AddPauseRecipient(DWORD dwRecepientId, DWORD dwMaxInterval, DWORD dwMinInterval)
{
		DWORD dwRetVal = 0;
	// add recepient job object
	CRandomPauseJob* pJob = new CRandomPauseJob(m_hFax, dwRecepientId, dwMaxInterval, dwMinInterval); 
	if(!pJob)
	{
		dwRetVal = ERROR_OUTOFMEMORY;
	}
	else
	{
		pJob->hOperationThread = CreateThread(NULL, 0, _RandomPauseJob, (void*)pJob ,0 ,&pJob->dwThreadId);
		if(!pJob->hOperationThread )
		{
			::lgLogDetail(LOG_X, 0, TEXT("JobId %d, Failed to create random pause thread"), dwRecepientId,GetLastError());
		}
		m_RecipientTable.Lock(dwRecepientId); // lock recipient
		verify(m_RecipientTable.Add(dwRecepientId, pJob));
		m_RecipientTable.UnLock(dwRecepientId);
		
	}
	return dwRetVal;
}
inline DWORD CMultiTypeJob::AddAbortRecipient(DWORD dwRecepientId, DWORD dwMaxInterval, DWORD dwMinInterval)
{
	DWORD dwRetVal = 0;

	// add recepient job object
	CRandomAbortJob* pJob = new CRandomAbortJob(m_hFax, dwRecepientId, dwMaxInterval, dwMinInterval);
	if(!pJob)
	{
		dwRetVal = ERROR_OUTOFMEMORY;
	}
	else
	{
		pJob->hOperationThread = CreateThread(NULL, 0, _RandomAbortJob, (void*)pJob ,0 ,&pJob->dwThreadId);
		if(!pJob->hOperationThread )
		{
			::lgLogDetail(LOG_X, 0, TEXT("JobId %d, Failed to create random abort thread"), dwRecepientId,GetLastError());
		}
		m_RecipientTable.Lock(dwRecepientId); // lock recipient
		verify(m_RecipientTable.Add(dwRecepientId, pJob));
		m_RecipientTable.UnLock(dwRecepientId);
		
	}
	return dwRetVal;
}

inline DWORD CMultiTypeJob::AddAbortAfterXSec(DWORD dwRecepientId, DWORD dwSecToAbort)
{
	DWORD dwRetVal = 0;

	// add recepient job object
	CAbortAfterXSec* pJob = new CAbortAfterXSec(m_hFax, dwRecepientId, dwSecToAbort);
	if(!pJob)
	{
		dwRetVal = ERROR_OUTOFMEMORY;
	}
	else
	{
		pJob->hOperationThread = CreateThread(NULL, 0, _AbortAfterXSecJob, (void*)pJob ,0 ,&pJob->dwThreadId);
		if(!pJob->hOperationThread )
		{
			::lgLogDetail(LOG_X, 0, TEXT("JobId %d, Failed to create random abort thread"), dwRecepientId,GetLastError());
		}
		m_RecipientTable.Lock(dwRecepientId); // lock recipient
		verify(m_RecipientTable.Add(dwRecepientId, pJob));
		m_RecipientTable.UnLock(dwRecepientId);
		
	}
	return dwRetVal;
}

inline DWORD WINAPI _RandomAbortJob(void* params)
{
	CRandomAbortJob* thread = (CRandomAbortJob*)params;
	thread->StartOperation();
	return 0;
}

inline DWORD WINAPI _RandomPauseJob(void* params)
{
	CRandomPauseJob* thread = (CRandomPauseJob*)params;
	thread->StartOperation();
	return 0;
}

inline DWORD WINAPI _AbortAfterXSecJob(void* params)
{
	CAbortAfterXSec* thread = (CAbortAfterXSec*)params;
	thread->StartOperation();
	return 0;
}

inline DWORD CMultiTypeJob::HandleMessage(CFaxEvent& Event)
{

	DWORD dwJobId = Event.GetJobId();
	
	m_dwJobStatus = _GetJobStatus();
	if(m_dwJobStatus != -1)
	{
		_VlidateParentStatus(m_dwJobStatus);
	}

	if(dwJobId != m_dwJobId)
	{
		// recipient
		CBaseFaxJob *pFaxJob = NULL;
		if(!m_RecipientTable.Get(dwJobId, &pFaxJob))
		{
			AddRecipient(dwJobId);
		}
		else
		{
			pFaxJob->HandleMessage(Event);	
		}
	
	}
	else
	{
		// parent
		_HandleParentEvent(Event.GetEventId());
	}
	
	return 0;
}


inline DWORD CMultiTypeJob::_HandleParentEvent(DWORD dwEventId)
{
	switch(dwEventId) 
	{
	case FEI_JOB_QUEUED:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_JOB_QUEUED"),m_dwJobId);
		break;
	case FEI_DELETED:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_DELETED"),m_dwJobId);
		break;
	/*case FEI_ABORTING:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_ABORTING"),m_dwJobId);
		break;
		*/
	default:
		{
			for(int index = 0; index <  FaxTableSize; index++)
			{
				if(FaxEventTable[index].first == dwEventId)
				{
					::lgLogError(LOG_SEV_1, TEXT("UNEXPECTED JobId %d, %s"),
								m_dwJobId,
								(FaxEventTable[index].second).c_str());
					goto Exit;
				}
			
 			}
			// handle unexpected notifications
			::lgLogError(LOG_SEV_1, TEXT("UNEXPECTED JobId %d, %d"),
									m_dwJobId,
									dwEventId);
		
Exit:		break;
		}
	}
		
	
	return 0;
}

#endif // MULTI_TYPE_JOB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\jobmngr\jobbehavior\crandomabortparentjob.h ===
#ifndef RANDOM_ABORT_PARENT_JOB_H
#define RANDOM_ABORT_PARENT_JOB_H

#include <winfax.h>
#include <Defs.h>
#include <StringTable.h>
#include "..\CBaseParentFaxJob.h"
#include "CRandomAbortJob.h"
#include "CRandomPauseJob.h"
#include "CAbortAtXPage.h"


DWORD WINAPI RandomAbortJob(void* params);
//
//  CRandomAbortParentJob
//
class CRandomAbortParentJob:public virtual CBaseParentFaxJob
{
public:
	CRandomAbortParentJob(HANDLE hFax, DWORD dwJobId);
	~CRandomAbortParentJob(){};
	DWORD HandleMessage(CFaxEvent& pFaxEvent);
	DWORD AddRecipient(DWORD dwRecepientId);
	DWORD AddPauseRecipient(DWORD dwRecepientId);
	DWORD AddAbortAtXPage(DWORD dwRecepientId, DWORD dwPageNum);
	DWORD AddAbortRecipient(DWORD dwRecepientId);
	CBaseFaxJob* dwCurrentRecipientObj;
private:
	DWORD _HandleParentEvent(DWORD dwEventId);

};

inline CRandomAbortParentJob::CRandomAbortParentJob(HANDLE hFax, DWORD dwJobId)
{
	assert(hFax);
	m_hFax = hFax;
	m_dwJobId = dwJobId;
};

inline DWORD CRandomAbortParentJob::AddRecipient(DWORD dwRecepientId)
{
	DWORD dwRetVal = 0;
	// add recepient job object
	CSimpleJob* pJob = new CSimpleJob(dwRecepientId); 
	if(!pJob)
	{
		dwRetVal = ERROR_OUTOFMEMORY;
	}
	else
	{
		m_RecipientTable.Lock(dwRecepientId); // lock recipient
		verify(m_RecipientTable.Add(dwRecepientId, pJob));
		m_RecipientTable.UnLock(dwRecepientId);
		
	}
	return dwRetVal;
}
inline DWORD CRandomAbortParentJob::AddAbortAtXPage(DWORD dwRecepientId, DWORD dwPageNum)
{
		DWORD dwRetVal = 0;
	// add recepient job object
	CAbortAtXPage* pJob = new CAbortAtXPage(m_hFax, dwRecepientId,dwPageNum); 
	if(!pJob)
	{
		dwRetVal = ERROR_OUTOFMEMORY;
	}
	else
	{
		m_RecipientTable.Lock(dwRecepientId); // lock recipient
		verify(m_RecipientTable.Add(dwRecepientId, pJob));
		m_RecipientTable.UnLock(dwRecepientId);
		
	}
	return dwRetVal;
}
inline DWORD CRandomAbortParentJob::AddPauseRecipient(DWORD dwRecepientId)
{
		DWORD dwRetVal = 0;
	// add recepient job object
	CRandomPauseJob* pJob = new CRandomPauseJob(m_hFax, dwRecepientId); 
	if(!pJob)
	{
		dwRetVal = ERROR_OUTOFMEMORY;
	}
	else
	{
		m_RecipientTable.Lock(dwRecepientId); // lock recipient
		verify(m_RecipientTable.Add(dwRecepientId, pJob));
		m_RecipientTable.UnLock(dwRecepientId);
		
	}
	return dwRetVal;
}
inline DWORD CRandomAbortParentJob::AddAbortRecipient(DWORD dwRecepientId)
{
	DWORD dwRetVal = 0;

	// add recepient job object
	//CRandomAbortJob* pJob = new CRandomAbortJob(m_hFax, dwRecepientId); 
	CRandomAbortJob* pObj = new CRandomAbortJob(m_hFax, dwRecepientId);
	if(!pObj)
	{
		dwRetVal = ERROR_OUTOFMEMORY;
	}
	else
	{
		pObj->hOperationThread = CreateThread(NULL, 0, RandomAbortJob, (void*)pObj ,0 ,&pObj->dwThreadId);
		if(!pObj->hOperationThread )
		{
			::lgLogDetail(LOG_X, 0, TEXT("JobId %d, Failed to random abort create thread"), dwRecepientId,GetLastError());
		}
		m_RecipientTable.Lock(dwRecepientId); // lock recipient
		verify(m_RecipientTable.Add(dwRecepientId, pObj));
		m_RecipientTable.UnLock(dwRecepientId);
		
	}
	return dwRetVal;
}

inline DWORD WINAPI RandomAbortJob(void* params)
{
	CRandomAbortJob* thread = (CRandomAbortJob*)params;
	thread->StartOperation();
	return 0;
}

inline DWORD CRandomAbortParentJob::HandleMessage(CFaxEvent& Event)
{

	DWORD dwJobId = Event.GetJobId();
	if(dwJobId != m_dwJobId)
	{
		// recipient
		CBaseFaxJob *pFaxJob = NULL;
		if(!m_RecipientTable.Get(dwJobId, &pFaxJob))
		{
			AddRecipient(dwJobId);
		}
		else
		{
			pFaxJob->HandleMessage(Event);	
		}
	
	}
	else
	{
		// parent
		_HandleParentEvent(Event.GetEventId());
	}
	
	return 0;
}


inline DWORD CRandomAbortParentJob::_HandleParentEvent(DWORD dwEventId)
{
	switch(dwEventId) 
	{
	case FEI_JOB_QUEUED:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_JOB_QUEUED"),m_dwJobId);
		break;
	case FEI_DIALING :
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_DIALING"),m_dwJobId);
		break;
	case FEI_SENDING :
		// any verfications
		// loging
		verify(SetEvent(m_EvJobSending.get()));
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_SENDING"),m_dwJobId);
		break;
	case  FEI_COMPLETED:
		// any verfications
		// loging
		verify(SetEvent(m_EvJobCompleted.get()));
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_COMPLETED"),m_dwJobId);
		break;
	case FEI_BUSY:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_BUSY"),m_dwJobId);
		break;
	case FEI_NO_ANSWER:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_NO_ANSWER"),m_dwJobId);
		break;
	case FEI_BAD_ADDRESS:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_BAD_ADDRESS"),m_dwJobId);
		break;
	case FEI_NO_DIAL_TONE :
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_NO_DIAL_TONE"),m_dwJobId);
		break;
	case FEI_DISCONNECTED:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_DISCONNECTED"),m_dwJobId);
		break;
	case FEI_DELETED:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_DELETED"),m_dwJobId);
		break;
	case FEI_ROUTING:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_ROUTING"),m_dwJobId);
		break;
	case FEI_ABORTING:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_ABORTING"),m_dwJobId);
		break;
	case FEI_CALL_DELAYED:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_CALL_DELAYED"),m_dwJobId);
		break;
	case FEI_CALL_BLACKLISTED:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_CALL_BLACKLISTED"),m_dwJobId);
		break;
	case FEI_ANSWERED:
	case FEI_RECEIVING :
	case FEI_FAXSVC_STARTED:
	case FEI_MODEM_POWERED_ON:
	case FEI_MODEM_POWERED_OFF:
	case FEI_FAXSVC_ENDED :
	case FEI_FATAL_ERROR:
	case FEI_IDLE:
	case FEI_RINGING:
	case FEI_NOT_FAX_CALL:
	default:
		{
			for(int index = 0; index <  FaxTableSize; index++)
			{
				if(FaxEventTable[index].first == dwEventId)
				{
					::lgLogError(LOG_SEV_1, TEXT("UNEXPECTED JobId %d, %s"),
								m_dwJobId,
								(FaxEventTable[index].second).c_str());
					goto Exit;
				}
			
 			}
			// handle unexpected notifications
			::lgLogError(LOG_SEV_1, TEXT("UNEXPECTED JobId %d, %d"),
									m_dwJobId,
									dwEventId);
		
Exit:		break;
		}
	}
		
	
	return 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\jobmngr\jobbehavior\crandompausejob.h ===
#ifndef RANDOM_PAUSE_JOB_H
#define RANDOM_PAUSE_JOB_H

#include <winfax.h>
#include <Defs.h>
#include <StringTable.h>
#include <testruntimeerr.h>
#include "..\CBaseFaxJob.h"


//
// CRandomPauseJob
//
class CRandomPauseJob:public virtual CBaseFaxJob
{
public:
	CRandomPauseJob(HANDLE hFax, DWORD dwRecepientId, DWORD dwMaxInterval = 5*60, DWORD dwMinInterval = 0);
	~CRandomPauseJob(){};
	DWORD HandleMessage(CFaxEvent& pFaxEvent);
	DWORD ResumeJob();
	DWORD StartOperation();
	HANDLE GetEvJobPaused()const {return  m_EvJobPaused.get();};
private:
	DWORD _HandleRecipientEvent(DWORD dwEventId);
	Event_t m_EvJobPaused;
	DWORD m_dwMaxInterval; 
	DWORD m_dwMinInterval;
};


// Randomly pause the job
// 
inline CRandomPauseJob::CRandomPauseJob(HANDLE hFax, 
										DWORD dwRecepientId, 
										DWORD dwMaxInterval, 
										DWORD dwMinInterval):
	m_EvJobPaused(NULL, TRUE, FALSE,TEXT(""))
{ 
	assert(hFax);
	m_hFax = hFax;
	m_dwJobId = dwRecepientId;
	
	assert(dwMaxInterval >= 0);
	m_dwMaxInterval = dwMaxInterval;

	assert(dwMinInterval >= 0);
	m_dwMinInterval = dwMinInterval;
}

inline DWORD CRandomPauseJob::StartOperation()
{
	PFAX_JOB_ENTRY pJobEntry = NULL; 
	if(!FaxGetJob( m_hFax, m_dwJobId,&pJobEntry))
	{
		Win32Err err(GetLastError(),__LINE__,TEXT(__FILE__),TEXT(""));
		lgLogDetail(LOG_X, 0, TEXT("job %d, FaxGetJob()  %s"),m_dwJobId,err.description());
	}
	else
	{
		srand(GetTickCount() * m_dwJobId);
		DWORD dwMiliSecsToPause;
		DWORD dwAbsInterval = ( abs(m_dwMaxInterval - m_dwMinInterval) == 0) ? 1 :
							    abs(m_dwMaxInterval - m_dwMinInterval);
		dwMiliSecsToPause =  m_dwMinInterval*1000 +  (rand()*100) % (dwAbsInterval*1000);
			
		lgLogDetail(LOG_X, 0, TEXT("job %d, Pausing in %d miliseconds"),m_dwJobId, dwMiliSecsToPause);
		// sleep before pausing
		Sleep(dwMiliSecsToPause);

		m_dwJobStatus = GetJobStatus();
		
		if(m_dwJobStatus != -1)
		{
			#ifdef _DEBUG
				PrintJobStatus(m_dwJobStatus);
			#endif
			// Pause the Job
			if (!FaxSetJob(m_hFax, m_dwJobId,JC_PAUSE, pJobEntry))
			{
				Win32Err err(GetLastError(),__LINE__,TEXT(__FILE__),TEXT(""));
				lgLogDetail(LOG_X, 0, TEXT("job %d, Pause job failed with  %s"),m_dwJobId,err.description());
			}
			else
			{
				#ifdef _DEBUG
				PrintJobStatus(m_dwJobStatus);
				#endif
				lgLogDetail(LOG_X, 0, TEXT("job %d, is paused"),m_dwJobId);
				//verify(SetEvent(m_EvJobPaused.get()));
			}

			FaxFreeBuffer(pJobEntry);
		}
		else //probably job does not exists
		{
			lgLogDetail(LOG_X, 0, TEXT("job %d, GetJobStatus() faile with %d"),m_dwJobId, GetLastError());
		}
	}

	verify (SetEvent(m_EvOperationCompleted.get()));
	return 0;
	
}


// Resume a pused job
//
inline DWORD CRandomPauseJob::ResumeJob()
{
	PFAX_JOB_ENTRY pJobEntry = NULL; 
	BOOL bRetVal = FaxGetJob( m_hFax, m_dwJobId,&pJobEntry);
	if(!bRetVal)
	{
		Win32Err err(GetLastError(),__LINE__,TEXT(__FILE__),TEXT(""));
		lgLogDetail(LOG_X, 0, TEXT("job %d, FaxGetJob()  %s"),m_dwJobId,err.description());
	}
	else
	{
		if (pJobEntry->QueueStatus & JS_PAUSED)
		{
			lgLogDetail(LOG_X, 0, TEXT("job %d, Resuming"),m_dwJobId);
		
			// Resume the Job
			if (!FaxSetJob(m_hFax, m_dwJobId,JC_RESUME, pJobEntry))
			{
				Win32Err err(GetLastError(),__LINE__,TEXT(__FILE__),TEXT(""));
				lgLogDetail(LOG_X, 0, TEXT("job %d, FaxSetJob() - JC_RESUME  %s"),m_dwJobId,err.description());
			}
		}
		else
		{
			lgLogDetail(LOG_X, 0, TEXT("job %d, The job is not paused"),m_dwJobId);
		}

		FaxFreeBuffer(pJobEntry);
	}
	return 0;
}


// HandleMessage
//
inline DWORD CRandomPauseJob::HandleMessage(CFaxEvent& Event)
{

	DWORD dwJobId = Event.GetJobId();
	verify(dwJobId == m_dwJobId);
	// update jobs status
	m_dwJobStatus = GetJobStatus();
	_HandleRecipientEvent(Event.GetEventId());
	return 0;
}


//	_HandleRecipientEvent
//
inline DWORD CRandomPauseJob::_HandleRecipientEvent(DWORD dwEventId)
{
	switch(dwEventId) 
	{
	case FEI_INITIALIZING :
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_INITIALIZING"),m_dwJobId);
		break;
	case FEI_DIALING :
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_DIALING"),m_dwJobId);
		break;
	case FEI_SENDING :
		// any verfications
		// loging
		verify(SetEvent(m_EvJobSending.get()));
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_SENDING"),m_dwJobId);
		break;
	case  FEI_COMPLETED:
		// any verfications
		// loging
		verify(SetEvent(m_EvJobCompleted.get()));
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_COMPLETED"),m_dwJobId);
		break;
	case FEI_BUSY:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_BUSY"),m_dwJobId);
		break;
	case FEI_NO_ANSWER:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_NO_ANSWER"),m_dwJobId);
		break;
	case FEI_BAD_ADDRESS:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_BAD_ADDRESS"),m_dwJobId);
		break;
	case FEI_NO_DIAL_TONE :
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_NO_DIAL_TONE"),m_dwJobId);
		break;
	case FEI_DISCONNECTED:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_DISCONNECTED"),m_dwJobId);
		break;
	case FEI_DELETED:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_DELETED"),m_dwJobId);
		break;
	case FEI_ROUTING:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_ROUTING"),m_dwJobId);
		break;
	case FEI_ABORTING:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_ABORTING"),m_dwJobId);
		break;
	case FEI_CALL_DELAYED:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_CALL_DELAYED"),m_dwJobId);
		break;
	case FEI_CALL_BLACKLISTED:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_CALL_BLACKLISTED"),m_dwJobId);
		break;
	case FEI_JOB_QUEUED:
	case FEI_ANSWERED:
	case FEI_RECEIVING :
	case FEI_FAXSVC_STARTED:
	case FEI_MODEM_POWERED_ON:
	case FEI_MODEM_POWERED_OFF:
	case FEI_FAXSVC_ENDED :
	case FEI_FATAL_ERROR:
	case FEI_IDLE:
	case FEI_RINGING:
	case FEI_NOT_FAX_CALL:
	default:
		{
			for(int index = 0; index <  FaxTableSize; index++)
			{
				if(FaxEventTable[index].first == dwEventId)
				{
					::lgLogError(LOG_SEV_1, TEXT("UNEXPECTED JobId %d, %s"),
											m_dwJobId,
											(FaxEventTable[index].second).c_str());
					goto Exit;
				}
			
 			}
			// handle unexpected notifications
			::lgLogError(LOG_SEV_1, TEXT("UNEXPECTED JobId %d, %d"),
									m_dwJobId,
									dwEventId);
		
Exit:		break;
		}
	}
		
	
	return 0;
}

#endif //RANDOM_PAUSE_JOB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\jobmngr\jobbehavior\crandomabortreceive.h ===
#ifndef RANDOM_ABORT_RECEIVE_H
#define RANDOM_ABORT_RECEIVE_H

#include <winfax.h>
#include <Defs.h>
#include <StringTable.h>
#include "..\CBaseFaxJob.h"


DWORD WINAPI ReceiveRandomAbortJob(void* params);
//
// CRandomAbortReceive
//
class CRandomAbortReceive:public virtual CBaseParentFaxJob
{
public:
	CRandomAbortReceive(HANDLE m_hFax, DWORD dwJobId);
	~CRandomAbortReceive(){};
	DWORD AddRecipient(DWORD dwRecepientId);
	DWORD HandleMessage(CFaxEvent& pFaxEvent);
	DWORD GetJobId(){ return m_dwJobId;};
	HANDLE GetFaxHandle(){ return m_hFax;};
private:
	DWORD _HandleRecipientEvent(DWORD dwEventId);
	Event_t m_EvJobAborted;
};

inline DWORD CRandomAbortReceive::AddRecipient(DWORD dwJobId)
{
	return 0;
}

/*inline CRandomAbortReceive::CRandomAbortReceive(HANDLE hFax, DWORD dwRecepientId):
	m_EvJobAborted(NULL, TRUE, FALSE,TEXT(""))
{ 
	m_dwJobId = dwRecepientId;
	m_hFax = hFax;

	DWORD dwSecsToAbort;
	dwSecsToAbort = ( (rand() * 10) % 8000);
	lgLogDetail(LOG_X, 0, TEXT("job %d, Aborting in %d seconds"),m_dwJobId, dwSecsToAbort / 1000);
	Sleep(dwSecsToAbort);
	if (!FaxAbort(m_hFax, m_dwJobId))
	{
		lgLogDetail(LOG_X, 0, TEXT("job %d, FaxAbort() failed with %d"),m_dwJobId,GetLastError());
	}
}
*/

inline CRandomAbortReceive::CRandomAbortReceive(HANDLE hFax, DWORD dwJobId):
	m_EvJobAborted(NULL, TRUE, FALSE,TEXT(""))
{
	m_dwJobId = dwJobId;
	DWORD dwThreadId;
	HANDLE hOperationThread;
	
	hOperationThread = CreateThread(NULL, 0, RandomAbortJob, (void*)this ,0,&dwThreadId);
	if(!hOperationThread )
	{
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, receive random abort, Failed to create thread"), m_dwJobId,GetLastError());
	}
}

inline DWORD WINAPI ReceiveRandomAbortJob(void* params)
{
	CRandomAbortReceive* thread = (CRandomAbortReceive*)params;

	srand(GetTickCount() * thread->GetJobId());
	DWORD dwMiliSecsToAbort;
	dwMiliSecsToAbort = ( (rand() * 100) % (3*60*1000));

	lgLogDetail(LOG_X, 0, TEXT("job %d, Aborting in %d miliseconds"),thread->GetJobId(), dwMiliSecsToAbort);
	Sleep(dwMiliSecsToAbort);
	if (!FaxAbort(thread->GetFaxHandle(), thread->GetJobId()))
	{
		lgLogDetail(LOG_X, 0, TEXT("job %d, FaxAbort() failed with %d"),thread->GetJobId(),GetLastError());
	}
	return 0;
}


inline DWORD CRandomAbortReceive::HandleMessage(CFaxEvent& Event)
{

	DWORD dwJobId = Event.GetJobId();
	verify(dwJobId == m_dwJobId);
	// update jobs status
//	m_dwJobStatus = GetJobStatus();
	_HandleRecipientEvent(Event.GetEventId());
	return 0;
}

inline DWORD CRandomAbortReceive::_HandleRecipientEvent(DWORD dwEventId)
{
	switch(dwEventId) 
	{
	case FEI_ANSWERED :
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_ANSWERED"),m_dwJobId);
		break;
	case FEI_RECEIVING :
		// any verfications
		// loging
		verify(SetEvent(m_EvJobSending.get()));
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_RECEIVING"),m_dwJobId);
		break;
	case  FEI_COMPLETED:
		// any verfications
		// loging
		verify(SetEvent(m_EvJobCompleted.get()));
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_COMPLETED"),m_dwJobId);
		break;
	case FEI_BUSY:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_BUSY"),m_dwJobId);
		break;
	case FEI_NO_ANSWER:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_NO_ANSWER"),m_dwJobId);
		break;
	case FEI_BAD_ADDRESS:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_BAD_ADDRESS"),m_dwJobId);
		break;
	case FEI_NO_DIAL_TONE :
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_NO_DIAL_TONE"),m_dwJobId);
		break;
	case FEI_DISCONNECTED:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_DISCONNECTED"),m_dwJobId);
		break;
	case FEI_DELETED:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_DELETED"),m_dwJobId);
		break;
	case FEI_ROUTING:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_ROUTING"),m_dwJobId);
		break;
	case FEI_ABORTING:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_ABORTING"),m_dwJobId);
		break;
	case FEI_CALL_DELAYED:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_CALL_DELAYED"),m_dwJobId);
		break;
	case FEI_CALL_BLACKLISTED:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_CALL_BLACKLISTED"),m_dwJobId);
		break;
	default:
		{
			for(int index = 0; index <  FaxTableSize; index++)
			{
				if(FaxEventTable[index].first == dwEventId)
				{
					::lgLogError(LOG_SEV_1, TEXT("UNEXPECTED JobId %d, %s"),
											m_dwJobId,
											(FaxEventTable[index].second).c_str());
					goto Exit;
				}
			
 			}
			// handle unexpected notifications
			::lgLogError(LOG_SEV_1, TEXT("UNEXPECTED JobId %d, %d"),
									m_dwJobId,
									dwEventId);
		
Exit:		break;
		}
	}
		
	
	return 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\jobmngr\jobbehavior\csimpleparentjob.h ===
#ifndef SIMPLE_PARENT_JOB_H
#define SIMPLE_PARENT_JOB_H

#include <winfax.h>
#include <Defs.h>
#include <StringTable.h>
#include "..\CBaseParentFaxJob.h"
#include "CSimpleJob.h"



//
//  CSimpleParentJob
//
class CSimpleParentJob:public virtual CBaseParentFaxJob
{
public:
	CSimpleParentJob(DWORD dwJobId){m_dwJobId = dwJobId;};
	~CSimpleParentJob(){};
	DWORD HandleMessage(CFaxEvent& pFaxEvent);
	DWORD AddRecipient(DWORD dwRecepientId);
private:
	DWORD _HandleParentEvent(DWORD dwEventId);
};

inline DWORD CSimpleParentJob::AddRecipient(DWORD dwRecepientId)
{
	DWORD dwRetVal = 0;
	// add recepient job object
	CSimpleJob* pJob = new CSimpleJob(dwRecepientId); 
	if(!pJob)
	{
		dwRetVal = ERROR_OUTOFMEMORY;
	}
	else
	{
		m_RecipientTable.Lock(dwRecepientId); // lock recipient
		verify(m_RecipientTable.Add(dwRecepientId, pJob));
		m_RecipientTable.UnLock(dwRecepientId);
		
	}
	return dwRetVal;
}

inline DWORD CSimpleParentJob::HandleMessage(CFaxEvent& Event)
{

	DWORD dwJobId = Event.GetJobId();
	if(dwJobId != m_dwJobId)
	{
		// recipient
		CBaseFaxJob *pFaxJob = NULL;
		if(!m_RecipientTable.Get(dwJobId, &pFaxJob))
		{
			AddRecipient(dwJobId);
			verify(m_RecipientTable.Get(dwJobId, &pFaxJob));
		}
	
		pFaxJob->HandleMessage(Event);
			
	}
	else
	{
		// parent
		_HandleParentEvent(Event.GetEventId());
	}
	
	return 0;
}


inline DWORD CSimpleParentJob::_HandleParentEvent(DWORD dwEventId)
{
	switch(dwEventId) 
	{
	case FEI_JOB_QUEUED:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_JOB_QUEUED"),m_dwJobId);
		break;
	case FEI_SENDING :
		// any verfications
		// loging
		verify(SetEvent(m_EvJobSending.get()));
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_SENDING"),m_dwJobId);
		break;
	case FEI_DELETED:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_DELETED"),m_dwJobId);
		break;
	case FEI_ABORTING:
		// any verfications
		// loging
		// TODO: Future implementation
		//::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_ABORTING"),m_dwJobId);
	default:
		{
			for(int index = 0; index <  FaxTableSize; index++)
			{
				if(FaxEventTable[index].first == dwEventId)
				{
					::lgLogError(LOG_SEV_1, TEXT("UNEXPECTED JobId %d, %s"),
								m_dwJobId,
								(FaxEventTable[index].second).c_str());
					goto Exit;
				}
			
 			}
			// handle unexpected notifications
			::lgLogError(LOG_SEV_1, TEXT("UNEXPECTED JobId %d, %d"),
									m_dwJobId,
									dwEventId);
		
Exit:		break;
		}
	}
		
	
	return 0;
}

#endif //SIMPLE_PARENT_JOB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\jobmngr\testcases\abort.cpp ===
#pragma warning(disable :4786)
// standard
#include <iostream>

// utilities
#include <testruntimeerr.h>
#include <params.h>

// project specific
#include <Defs.h>
#include <PrepareJobParams.cpp>
#include "..\CTestManager.h"
#include "..\CJobTypes.h"
 

void main(int argc,char** argv)
{
	CInput input(GetCommandLine());
	tstring tstrServerName;
	tstring tstrDocumentPath;

	if(input.IsExists(TEXT("d")))
	{
		tstrDocumentPath = input[TEXT("d")];
	}
	else
	{
		std::cout << "TstMng Usage:\n" <<
					 "/d:[fax file path] spaces in path are allowed do not use the \" char \n" <<
					 "/s:[server name] by default server is the local machine\n";
		exit(0);
	}

	if(input.IsExists(TEXT("s")))
	{
		tstrServerName = input[TEXT("s")];
	}

	::lgInitializeLogger();
	::lgBeginSuite(TEXT("Abort"));
	::lgBeginCase(0, TEXT("0"));
	
	CTestManager* pTest = NULL;	
	try
	{
		DWORD x_ComputerNameLenth = 256;//MAX_COMPUTERNAME_LENGTH;
		if(tstrServerName == TEXT(""))
		{
			TCHAR buffServerName[256];//[MAX_COMPUTERNAME_LENGTH + 1 ];
			if(!GetComputerName(buffServerName, &x_ComputerNameLenth))
			{
				THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT(" GetComputerName"));
			}
			tstrServerName = buffServerName;
		}
	
		// initialize test manager
		pTest = new CTestManager(tstrServerName);
		
		if(!pTest)
		{
			THROW_TEST_RUN_TIME_WIN32( ERROR_OUTOFMEMORY, TEXT(" Main, new CTestManager"));
		}

		JOB_PARAMS_EX Jparams;

		// prepare job params
		JobParamExNow JobParam( TEXT("test"));
			
		Jparams.pJobParam = JobParam.GetData();
		Jparams.szDocument = tstrDocumentPath.c_str();
		Jparams.pCoverpageInfo = NULL;
		Jparams.dwNumRecipients = 10;
			
		PersonalProfile SenderProfile(TEXT("585"));
		PersonalProfile RecepientProfile[18] ;
		JOB_BEHAVIOR RecipientsBehavior[18];
		RecepientProfile[0] = PersonalProfile(TEXT("581"));
		RecipientsBehavior[0].dwJobType = JT_RANDOM_ABORT;
		RecepientProfile[1] = PersonalProfile(TEXT("581"));
		RecipientsBehavior[1].dwJobType = JT_ABORT_PAGE;
		RecipientsBehavior[1].dwParam1 = 2;
		RecepientProfile[2] = PersonalProfile(TEXT("582"));
		RecipientsBehavior[2].dwJobType = JT_RANDOM_ABORT;
		RecepientProfile[3] = PersonalProfile(TEXT("582"));
		RecipientsBehavior[3].dwJobType = JT_ABORT_PAGE;
		RecipientsBehavior[3].dwParam1 = 3;
		RecepientProfile[4] = PersonalProfile(TEXT("583"));
		RecipientsBehavior[4].dwJobType = JT_RANDOM_ABORT;
		RecepientProfile[5] = PersonalProfile(TEXT("583"));
		RecipientsBehavior[5].dwJobType = JT_SIMPLE_SEND;
		RecepientProfile[6] = PersonalProfile(TEXT("584"));
		RecipientsBehavior[6].dwJobType = JT_RANDOM_ABORT;
		RecepientProfile[7] = PersonalProfile(TEXT("584"));
		RecipientsBehavior[7].dwJobType = JT_RANDOM_ABORT;
		RecepientProfile[8] = PersonalProfile(TEXT("585"));
		RecipientsBehavior[8].dwJobType = JT_SIMPLE_SEND;
		RecepientProfile[9] = PersonalProfile(TEXT("585"));
		RecipientsBehavior[9].dwJobType = JT_ABORT_PAGE;
		RecipientsBehavior[9].dwParam1 = 1;


		ListPersonalProfile RecepientProfileList(10, RecepientProfile);
		
		Jparams.pRecepientList = RecepientProfileList.GetData();
		Jparams.pSenderProfile = SenderProfile.GetData();
		
		
		DWORD dwAddRetVal;
		
		if(dwAddRetVal = pTest->AddMultiTypeJob(Jparams))
		{
			THROW_TEST_RUN_TIME_WIN32(dwAddRetVal, TEXT(" AddMultiTypeJob"));
		}

		getchar();
	
	}
	catch(Win32Err& err)
	{
		::lgLogError(LOG_SEV_1, TEXT("Exception:%s."), err.Desc());
	}

  	
	::lgEndCase();
	::lgEndSuite();
	::lgCloseLogger();  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\jobmngr\testcases\abort1.cpp ===
#pragma warning(disable :4786)

// standard
#include <iostream>

// utilities
#include <testruntimeerr.h>
#include <params.h>

// project specific
#include <Defs.h>
#include <PrepareJobParams.cpp>
#include "..\CTestManager.h"
#include "..\CJobTypes.h"

void main(int argc,char** argv)
{
	CInput input(GetCommandLine());
	tstring tstrServerName;
	tstring tstrDocumentPath;

	if(input.IsExists(TEXT("d")))
	{
		tstrDocumentPath = input[TEXT("d")];
	}
	else
	{
		std::cout << "TstMng Usage:\n" <<
					 "/d:[fax file path] spaces in path are allowed do not use the \" char \n" <<
					 "/s:[server name] by default server is the local machine\n";
		exit(0);
	}

	if(input.IsExists(TEXT("s")))
	{
		tstrServerName = input[TEXT("s")];
	}

	::lgInitializeLogger();
	::lgBeginSuite(TEXT("Abort"));
	::lgBeginCase(0, TEXT("0"));
	
	CTestManager* pTest = NULL;	
	try
	{
		DWORD x_ComputerNameLenth = 256;//MAX_COMPUTERNAME_LENGTH;
		if(tstrServerName == TEXT(""))
		{
			TCHAR buffServerName[256];//[MAX_COMPUTERNAME_LENGTH + 1 ];
			if(!GetComputerName(buffServerName, &x_ComputerNameLenth))
			{
				THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT(" GetComputerName"));
			}
			tstrServerName = buffServerName;
		}
	
		// initialize test manager
		pTest = new CTestManager(tstrServerName);
		
		if(!pTest)
		{
			THROW_TEST_RUN_TIME_WIN32( ERROR_OUTOFMEMORY, TEXT(" Main, new CTestManager"));
		}

		JOB_PARAMS_EX Jparams;

		// prepare job params
		JobParamExNow JobParam( TEXT("test"));
			
		Jparams.pJobParam = JobParam.GetData();
		Jparams.szDocument = tstrDocumentPath.c_str();
		Jparams.pCoverpageInfo = NULL;
		Jparams.dwNumRecipients = 1;
			
		PersonalProfile SenderProfile(TEXT("585"));
		PersonalProfile RecepientProfile[18];
		JOB_BEHAVIOR RecipientsBehavior[18];
		RecepientProfile[0] = PersonalProfile(TEXT("581"));
		RecipientsBehavior[0].dwJobType = JT_SIMPLE_SEND;
		RecepientProfile[1] = PersonalProfile(TEXT("582"));
		RecipientsBehavior[1].dwJobType = JT_ABORT_PAGE;
		RecipientsBehavior[1].dwParam1 = 1;
		RecepientProfile[2] = PersonalProfile(TEXT("583"));
		RecipientsBehavior[2].dwJobType = JT_ABORT_PAGE;
		RecipientsBehavior[2].dwParam1 = 2;
		RecepientProfile[3] = PersonalProfile(TEXT("584"));
		RecipientsBehavior[3].dwJobType = JT_RANDOM_ABORT;
		RecepientProfile[4] = PersonalProfile(TEXT("585"));
		RecipientsBehavior[4].dwJobType = JT_RANDOM_ABORT;
		RecepientProfile[5] = PersonalProfile(TEXT("586"));
		RecipientsBehavior[5].dwJobType = JT_RANDOM_ABORT;
		RecepientProfile[6] = PersonalProfile(TEXT("587"));
		RecipientsBehavior[6].dwJobType = JT_RANDOM_ABORT;
		RecepientProfile[7] = PersonalProfile(TEXT("588"));
		RecipientsBehavior[7].dwJobType = JT_RANDOM_ABORT;
		RecepientProfile[8] = PersonalProfile(TEXT("589"));
		RecipientsBehavior[8].dwJobType = JT_RANDOM_ABORT;
		RecepientProfile[9] = PersonalProfile(TEXT("581"));
		RecipientsBehavior[9].dwJobType = JT_RANDOM_ABORT;
	
		ListPersonalProfile RecepientProfileList(1, RecepientProfile);
		
		Jparams.pRecepientList = RecepientProfileList.GetData();
		Jparams.pSenderProfile = SenderProfile.GetData();
		Jparams.pRecipientsBehavior = RecipientsBehavior;
		
			
		DWORD dwAddRetVal;
		
		if(dwAddRetVal = pTest->AddMultiTypeJob(Jparams))
		{
			THROW_TEST_RUN_TIME_WIN32(dwAddRetVal, TEXT(" AddMultiTypeJob"));
		}

		getchar();
	
	}
	catch(Win32Err& err)
	{
		::lgLogError(LOG_SEV_1, TEXT("Exception:%s."), err.Desc());
	}

  
	::lgEndCase();
	::lgEndSuite();
	::lgCloseLogger();  // Holds the process?
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\jobmngr\testcases\inifilesettings.h ===
#ifndef _INI_FILE_SETTINGS
#define _INI_FILE_SETTINGS

#include <tstring.h>

#define GENERAL_PARAMS	TEXT("General")
#define SEND_PARAMS		TEXT("Send Parameters")
#define SENDER_DETAILS  TEXT("Sender Details")
#define RECIPIENT_LIST  TEXT("Recipient List")

tstring SectionEntriesArray[] = { GENERAL_PARAMS,
								  RECIPIENT_LIST,
								  SEND_PARAMS};

#define SectionEntriesArraySize ( sizeof(SectionEntriesArray) / sizeof(tstring))

#endif //_INI_FILE_SETTINGS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\jobmngr\jobbehavior\csimplejob.h ===
#ifndef _SIMPLE_JOB_H
#define _SIMPLE_JOB_H

#include <winfax.h>
#include <Defs.h>
#include <StringTable.h>
#include "..\CBaseFaxJob.h"

//
// CSimpleJob
//
class CSimpleJob:public virtual CBaseFaxJob
{
public:
	CSimpleJob(DWORD dwRecepientId)
	{
		m_dwJobId = dwRecepientId; 
		verify (SetEvent(m_EvOperationCompleted.get()));
	};
	~CSimpleJob(){};
	DWORD StartOperation() {return 0;};
	DWORD HandleMessage(CFaxEvent& pFaxEvent);

private:
	DWORD _HandleRecipientEvent(DWORD dwEventId);
};

inline DWORD CSimpleJob::HandleMessage(CFaxEvent& Event)
{

	DWORD dwJobId = Event.GetJobId();
	verify(dwJobId == m_dwJobId);
	_HandleRecipientEvent(Event.GetEventId());
	return 0;
}

inline DWORD CSimpleJob::_HandleRecipientEvent(DWORD dwEventId)
{
	switch(dwEventId) 
	{
	case FEI_INITIALIZING :
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_INITIALIZING"),m_dwJobId);
		break;
	case FEI_DIALING :
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_DIALING"),m_dwJobId);
		break;
	case FEI_SENDING :
		// any verfications
		// loging
		verify(SetEvent(m_EvJobSending.get()));
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_SENDING"),m_dwJobId);
		break;
	case  FEI_COMPLETED:
		// any verfications
		// loging
		verify(SetEvent(m_EvJobCompleted.get()));
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_COMPLETED"),m_dwJobId);
		break;
	case FEI_BUSY:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_BUSY"),m_dwJobId);
		break;
	case FEI_NO_ANSWER:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_NO_ANSWER"),m_dwJobId);
		break;
	case FEI_BAD_ADDRESS:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_BAD_ADDRESS"),m_dwJobId);
		break;
	case FEI_NO_DIAL_TONE :
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_NO_DIAL_TONE"),m_dwJobId);
		break;
	case FEI_DISCONNECTED:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_DISCONNECTED"),m_dwJobId);
		break;
	case FEI_DELETED:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_DELETED"),m_dwJobId);
		break;
	case FEI_ROUTING:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_ROUTING"),m_dwJobId);
		break;
	case FEI_ABORTING:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_ABORTING"),m_dwJobId);
		break;
	case FEI_CALL_DELAYED:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_CALL_DELAYED"),m_dwJobId);
		break;
	case FEI_CALL_BLACKLISTED:
		// any verfications
		// loging
		::lgLogDetail(LOG_X, 0, TEXT("JobId %d, FEI_CALL_BLACKLISTED"),m_dwJobId);
		break;
	case FEI_JOB_QUEUED:
	case FEI_ANSWERED:
	case FEI_RECEIVING :
	case FEI_FAXSVC_STARTED:
	case FEI_MODEM_POWERED_ON:
	case FEI_MODEM_POWERED_OFF:
	case FEI_FAXSVC_ENDED :
	case FEI_FATAL_ERROR:
	case FEI_IDLE:
	case FEI_RINGING:
	case FEI_NOT_FAX_CALL:
	default:
		{
			for(int index = 0; index <  FaxTableSize; index++)
			{
				if(FaxEventTable[index].first == dwEventId)
				{
					::lgLogError(LOG_SEV_1, TEXT("UNEXPECTED JobId %d, %s"),
											m_dwJobId,
											(FaxEventTable[index].second).c_str());
					goto Exit;
				}
			
 			}
			// handle unexpected notifications
			::lgLogError(LOG_SEV_1, TEXT("UNEXPECTED JobId %d, %d"),
									m_dwJobId,
									dwEventId);
		
Exit:		break;
		}
	}
		
	
	return 0;
}

#endif //_SIMPLE_JOB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\jobmngr\testcases\5879.cpp ===
/*
Bug #5879

configuration:
virtual FSP with 10 devices.

scenario
- Send a job with 18 different recipients. 11 out of the 18 recipients
will randomly abort the send.
- Wait until all 10 devices handle a send job.
- Cancel all faxes through the fax queue UI.

The assert is in function: IsJobReadyForArchiving(), service\server\job.c:
and becuse the parent's recipients number is 0, and number of canceled recipients is 19(we sent only 18 recipients).

the function, causing assert , was called from Abort() and HandleFailedSendJob().

*/
#pragma warning(disable :4786)
// standard
#include <iostream>

// utilities
#include <testruntimeerr.h>
#include <params.h>

// project specific
#include <Defs.h>
#include <PrepareJobParams.cpp>
#include "..\CTestManager.h"
#include "..\CJobTypes.h"
 

void main(int argc,char** argv)
{
	
	CInput input(GetCommandLine());
	tstring tstrServerName;
	tstring tstrDocumentPath;

	if(input.IsExists(TEXT("d")))
	{
		tstrDocumentPath = input[TEXT("d")];
	}
	else
	{
		std::cout << "5879 Usage:\n" <<
					 "/d:[fax file path] spaces in path are do not use the \" char \n" <<
					 "/s:[server name] by default server is the local machine\n";
		exit(0);
	}
	
	if(input.IsExists(TEXT("s")))
	{
		tstrServerName = input[TEXT("s")];
	}
	
	::lgInitializeLogger();
	::lgBeginSuite(TEXT("Bug 5879"));
	::lgBeginCase(0, TEXT("0"));
	
	// We want exception to be printed before the very long destructor process of this object. 
	CTestManager* pTest = NULL;	
	try
	{
		DWORD x_ComputerNameLenth;
		if(tstrServerName == TEXT(""))
		{
			TCHAR buffServerName[MAX_COMPUTERNAME_LENGTH + 1 ];
			if(!GetComputerName(buffServerName, &x_ComputerNameLenth))
			{
				THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT(" GetComputerName"));
			}
			tstrServerName = buffServerName;
		}

		// initialize test manager
		pTest = new CTestManager(tstrServerName);
		
		if(!pTest)
		{
			THROW_TEST_RUN_TIME_WIN32( ERROR_OUTOFMEMORY, TEXT(" Main, new CTestManager"));
		}
		
		JOB_PARAMS_EX Jparams;

		// prepare job params
		JobParamExNow JobParam( TEXT("test"));
			
		Jparams.pJobParam = JobParam.GetData();
		Jparams.szDocument = tstrDocumentPath.c_str();
		Jparams.pCoverpageInfo = NULL;
		Jparams.dwNumRecipients = 18;
			
		PersonalProfile SenderProfile(TEXT("585"));
		PersonalProfile RecepientProfile[18];
		JOB_BEHAVIOR RecipientsBehavior[18];
		RecepientProfile[0] = PersonalProfile(TEXT("581"));
		RecipientsBehavior[0].dwJobType = JT_RANDOM_ABORT;
		RecepientProfile[1] = PersonalProfile(TEXT("582"));
		RecipientsBehavior[1].dwJobType = JT_RANDOM_ABORT;
		RecepientProfile[2] = PersonalProfile(TEXT("583"));
		RecipientsBehavior[2].dwJobType = JT_RANDOM_ABORT;
		RecepientProfile[3] = PersonalProfile(TEXT("584"));
		RecipientsBehavior[3].dwJobType = JT_RANDOM_ABORT;
		RecepientProfile[4] = PersonalProfile(TEXT("585"));
		RecipientsBehavior[4].dwJobType = JT_RANDOM_ABORT;
		RecepientProfile[5] = PersonalProfile(TEXT("586"));
		RecipientsBehavior[5].dwJobType = JT_RANDOM_ABORT;
		RecepientProfile[6] = PersonalProfile(TEXT("587"));
		RecipientsBehavior[6].dwJobType = JT_RANDOM_ABORT;
		RecepientProfile[7] = PersonalProfile(TEXT("588"));
		RecipientsBehavior[7].dwJobType = JT_RANDOM_ABORT;
		RecepientProfile[8] = PersonalProfile(TEXT("589"));
		RecipientsBehavior[8].dwJobType = JT_RANDOM_ABORT;
		RecepientProfile[9] = PersonalProfile(TEXT("5810"));
		RecipientsBehavior[9].dwJobType = JT_RANDOM_ABORT;
		RecepientProfile[10] = PersonalProfile(TEXT("5811"));
		RecipientsBehavior[10].dwJobType = JT_RANDOM_ABORT;
		RecepientProfile[11] = PersonalProfile(TEXT("5812"));
		RecipientsBehavior[11].dwJobType = JT_RANDOM_ABORT;
		RecepientProfile[12] = PersonalProfile(TEXT("5813"));
		RecipientsBehavior[12].dwJobType = JT_RANDOM_ABORT;
		RecepientProfile[13] = PersonalProfile(TEXT("5814"));
		RecipientsBehavior[13].dwJobType = JT_RANDOM_ABORT;
		RecepientProfile[14] = PersonalProfile(TEXT("5815"));
		RecipientsBehavior[14].dwJobType = JT_RANDOM_ABORT;
		RecepientProfile[15] = PersonalProfile(TEXT("5816"));
		RecipientsBehavior[15].dwJobType = JT_RANDOM_ABORT;
		RecepientProfile[16] = PersonalProfile(TEXT("5817"));
		RecipientsBehavior[16].dwJobType = JT_RANDOM_ABORT;
		RecepientProfile[17] = PersonalProfile(TEXT("5818"));
		RecipientsBehavior[17].dwJobType = JT_RANDOM_ABORT;
	
		ListPersonalProfile RecepientProfileList(18, RecepientProfile);
		
		Jparams.pRecepientList = RecepientProfileList.GetData();
		Jparams.pSenderProfile = SenderProfile.GetData();
		
		
		DWORD dwAddRetVal;
		
		if(dwAddRetVal = pTest->AddMultiTypeJob(Jparams))
		{
			THROW_TEST_RUN_TIME_WIN32(dwAddRetVal, TEXT(" AddMultiTypeJob"));
		}
		
		getchar();
	
	}
	catch(Win32Err& err)
	{
		::lgLogError(LOG_SEV_1, TEXT("Exception:%s."), err.Desc());
	}

  	::lgEndCase();
	::lgEndSuite();
	::lgCloseLogger();  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\jobmngr\testcases\functionality.cpp ===
#pragma warning(disable :4786)
#include <iostream>

// utilities
#include <testruntimeerr.h>
#include <params.h>

// project specific
#include <Defs.h>
#include <PrepareJobParams.cpp>
#include "..\CTestManager.h"
#include "..\CJobTypes.h"
 
using namespace std;


void main(int argc,char** argv)
{
	CInput input(GetCommandLine());
	tstring tstrServerName;
	tstring tstrDocumentPath;

	if(input.IsExists(TEXT("d")))
	{
		tstrDocumentPath = input[TEXT("d")];
	}
	else
	{
		std::cout << "5879 Usage:\n" <<
					 "/d:[fax file path] spaces in path are allowed do not use the \" char \n" <<
					 "/s:[server name] by default server is the local machine\n";
		exit(0);
	}

	::lgInitializeLogger();
	::lgBeginSuite(TEXT("Functionality"));
	::lgBeginCase(0, TEXT("0"));
	
	CTestManager* pTest = NULL;	
	try
	{
		DWORD x_ComputerNameLenth;
		if(tstrServerName == TEXT(""))
		{
			TCHAR buffServerName[MAX_COMPUTERNAME_LENGTH + 1 ];
			if(!GetComputerName(buffServerName, &x_ComputerNameLenth))
			{
				THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT(" GetComputerName"));
			}
			tstrServerName = buffServerName;
		}
	
		// initialize test manager
		pTest = new CTestManager(tstrServerName);
		
		if(!pTest)
		{
			THROW_TEST_RUN_TIME_WIN32( ERROR_OUTOFMEMORY, TEXT(" Main, new CTestManager"));
		}

		JOB_PARAMS_EX Jparams;

		// prepare job params
		JobParamExNow JobParam( TEXT("test"));
			
		Jparams.pJobParam = JobParam.GetData();
		Jparams.szDocument = tstrDocumentPath.c_str();
		Jparams.pCoverpageInfo = NULL;
		Jparams.dwNumRecipients = 1;
		
		PersonalProfile RecepientProfile[1] ;
		JOB_BEHAVIOR RecipientsBehavior[1];
		PersonalProfile SenderProfile(TEXT("585"));
		
		DWORD dwAddRetVal;
		
		RecepientProfile[0] = PersonalProfile(TEXT("581"));
		RecipientsBehavior[0].dwJobType = JT_SIMPLE_SEND;
		ListPersonalProfile RecepientProfileList1(1, RecepientProfile);
		
		Jparams.pRecepientList = RecepientProfileList1.GetData();
		Jparams.pSenderProfile = SenderProfile.GetData();
		
		if(dwAddRetVal = pTest->AddMultiTypeJob(Jparams))
		{
			THROW_TEST_RUN_TIME_WIN32(dwAddRetVal, TEXT(" AddMultiTypeJob"));
		}

		if(dwAddRetVal = pTest->AddMultiTypeJob(Jparams))
		{
			THROW_TEST_RUN_TIME_WIN32(dwAddRetVal, TEXT(" AddMultiTypeJob"));
		}


		RecepientProfile[0] = PersonalProfile(TEXT("582"));

		ListPersonalProfile RecepientProfileList2(1, RecepientProfile);
		
		Jparams.pRecepientList = RecepientProfileList2.GetData();
		Jparams.pSenderProfile = SenderProfile.GetData();
		if(dwAddRetVal = pTest->AddMultiTypeJob(Jparams))
		{
			THROW_TEST_RUN_TIME_WIN32(dwAddRetVal, TEXT(" AddMultiTypeJob"));
		}

		if(dwAddRetVal = pTest->AddMultiTypeJob(Jparams))
		{
			THROW_TEST_RUN_TIME_WIN32(dwAddRetVal, TEXT(" AddMultiTypeJob"));
		}


		RecepientProfile[0] = PersonalProfile(TEXT("583"));
		
		ListPersonalProfile RecepientProfileList3(1, RecepientProfile);
		
		Jparams.pRecepientList = RecepientProfileList3.GetData();
		Jparams.pSenderProfile = SenderProfile.GetData();
		if(dwAddRetVal = pTest->AddMultiTypeJob(Jparams))
		{
			THROW_TEST_RUN_TIME_WIN32(dwAddRetVal, TEXT(" AddMultiTypeJob"));
		}
		if(dwAddRetVal = pTest->AddMultiTypeJob(Jparams))
		{
			THROW_TEST_RUN_TIME_WIN32(dwAddRetVal, TEXT(" AddMultiTypeJob"));
		}


		RecepientProfile[0] = PersonalProfile(TEXT("584"));

		ListPersonalProfile RecepientProfileList4(1, RecepientProfile);
		
		Jparams.pRecepientList = RecepientProfileList4.GetData();
		Jparams.pSenderProfile = SenderProfile.GetData();
		if(dwAddRetVal = pTest->AddMultiTypeJob(Jparams))
		{
			THROW_TEST_RUN_TIME_WIN32(dwAddRetVal, TEXT(" AddMultiTypeJob"));
		}
		if(dwAddRetVal = pTest->AddMultiTypeJob(Jparams))
		{
			THROW_TEST_RUN_TIME_WIN32(dwAddRetVal, TEXT(" AddMultiTypeJob"));
		}

		RecepientProfile[0] = PersonalProfile(TEXT("586"));

		ListPersonalProfile RecepientProfileList5(1, RecepientProfile);
		
		Jparams.pRecepientList = RecepientProfileList5.GetData();
		Jparams.pSenderProfile = SenderProfile.GetData();
		if(dwAddRetVal = pTest->AddMultiTypeJob(Jparams))
		{
			THROW_TEST_RUN_TIME_WIN32(dwAddRetVal, TEXT(" AddMultiTypeJob"));
		}
		if(dwAddRetVal = pTest->AddMultiTypeJob(Jparams))
		{
			THROW_TEST_RUN_TIME_WIN32(dwAddRetVal, TEXT(" AddMultiTypeJob"));
		}

		RecepientProfile[0] = PersonalProfile(TEXT("587"));
		ListPersonalProfile RecepientProfileList6(1, RecepientProfile);
		
		Jparams.pRecepientList = RecepientProfileList6.GetData();
		Jparams.pSenderProfile = SenderProfile.GetData();
		if(dwAddRetVal = pTest->AddMultiTypeJob(Jparams))
		{
			THROW_TEST_RUN_TIME_WIN32(dwAddRetVal, TEXT(" AddMultiTypeJob"));
		}
		if(dwAddRetVal = pTest->AddMultiTypeJob(Jparams))
		{
			THROW_TEST_RUN_TIME_WIN32(dwAddRetVal, TEXT(" AddMultiTypeJob"));
		}

		RecepientProfile[0] = PersonalProfile(TEXT("588"));
		
		ListPersonalProfile RecepientProfileList7(1, RecepientProfile);
		
		Jparams.pRecepientList = RecepientProfileList7.GetData();
		Jparams.pSenderProfile = SenderProfile.GetData();
		if(dwAddRetVal = pTest->AddMultiTypeJob(Jparams))
		{
			THROW_TEST_RUN_TIME_WIN32(dwAddRetVal, TEXT(" AddMultiTypeJob"));
		}
		if(dwAddRetVal = pTest->AddMultiTypeJob(Jparams))
		{
			THROW_TEST_RUN_TIME_WIN32(dwAddRetVal, TEXT(" AddMultiTypeJob"));
		}

		RecepientProfile[0] = PersonalProfile(TEXT("589"));

		ListPersonalProfile RecepientProfileList8(1, RecepientProfile);
		
		Jparams.pRecepientList = RecepientProfileList8.GetData();
		Jparams.pSenderProfile = SenderProfile.GetData();
		if(dwAddRetVal = pTest->AddMultiTypeJob(Jparams))
		{
			THROW_TEST_RUN_TIME_WIN32(dwAddRetVal, TEXT(" AddMultiTypeJob"));
		}
				if(dwAddRetVal = pTest->AddMultiTypeJob(Jparams))
		{
			THROW_TEST_RUN_TIME_WIN32(dwAddRetVal, TEXT(" AddMultiTypeJob"));
		}

		RecepientProfile[11] = PersonalProfile(TEXT("5810"));
		ListPersonalProfile RecepientProfileList9(1, RecepientProfile);
		
		Jparams.pRecepientList = RecepientProfileList9.GetData();
		Jparams.pSenderProfile = SenderProfile.GetData();
		if(dwAddRetVal = pTest->AddMultiTypeJob(Jparams))
		{
			THROW_TEST_RUN_TIME_WIN32(dwAddRetVal, TEXT(" AddMultiTypeJob"));
		}
		if(dwAddRetVal = pTest->AddMultiTypeJob(Jparams))
		{
			THROW_TEST_RUN_TIME_WIN32(dwAddRetVal, TEXT(" AddMultiTypeJob"));
		}

		
		getchar();
	
	}
	catch(Win32Err& err)
	{
		::lgLogError(LOG_SEV_1, TEXT("Exception:%s."), err.Desc());
	}

	
	::lgEndCase();
	::lgEndSuite();
	::lgCloseLogger();  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\jobmngr\testcases\functionality2.cpp ===
#pragma warning(disable :4786)
#include <iostream>

// utilities
#include <testruntimeerr.h>
#include <params.h>

// project specific
#include <Defs.h>
#include <PrepareJobParams.cpp>
#include "..\CTestManager.h"
#include "..\CJobTypes.h"
 

void main(int argc,char** argv)
{
	CInput input(GetCommandLine());
	tstring tstrServerName;
	tstring tstrDocumentPath;

	if(input.IsExists(TEXT("d")))
	{
		tstrDocumentPath = input[TEXT("d")];
	}
	else
	{
		std::cout << "5879 Usage:\n" <<
					 "/d:[fax file path] spaces in path are allowed do not use the \" char \n" <<
					 "/s:[server name] by default server is the local machine\n";
		exit(0);
	}

	if(input.IsExists(TEXT("s")))
	{
		tstrServerName = input[TEXT("s")];
	}

	::lgInitializeLogger();
	::lgBeginSuite(TEXT("Functionality"));
	::lgBeginCase(0, TEXT("0"));

	CTestManager* pTest = NULL;	
	try
	{
		DWORD x_ComputerNameLenth;
		if(tstrServerName == TEXT(""))
		{
			TCHAR buffServerName[MAX_COMPUTERNAME_LENGTH + 1 ];
			if(!GetComputerName(buffServerName, &x_ComputerNameLenth))
			{
				THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT(" GetComputerName"));
			}
			tstrServerName = buffServerName;
		}
	
		// initialize test manager
		pTest = new CTestManager(tstrServerName);
		
		if(!pTest)
		{
			THROW_TEST_RUN_TIME_WIN32( ERROR_OUTOFMEMORY, TEXT(" Main, new CTestManager"));
		}

		JOB_PARAMS_EX Jparams;

		// prepare job params
		JobParamExNow JobParam( TEXT("test"));
			
		Jparams.pJobParam = JobParam.GetData();
		Jparams.szDocument = tstrDocumentPath.c_str();
		Jparams.pCoverpageInfo = NULL;
		Jparams.dwNumRecipients = 1;
		
		PersonalProfile RecepientProfile[1] ;
		JOB_BEHAVIOR RecipientsBehavior[1];
		PersonalProfile SenderProfile(TEXT("585"));
		
		DWORD dwAddRetVal;
		
		RecepientProfile[0] = PersonalProfile(TEXT("581"));
		RecipientsBehavior[0].dwJobType = JT_SIMPLE_SEND;
		ListPersonalProfile RecepientProfileList1(1, RecepientProfile);
		
		Jparams.pRecepientList = RecepientProfileList1.GetData();
		Jparams.pSenderProfile = SenderProfile.GetData();
		
		if(dwAddRetVal = pTest->AddMultiTypeJob(Jparams))
		{
			THROW_TEST_RUN_TIME_WIN32(dwAddRetVal, TEXT(" AddMultiTypeJob"));
		}

		RecepientProfile[0] = PersonalProfile(TEXT("582"));

		ListPersonalProfile RecepientProfileList2(1, RecepientProfile);
		
		Jparams.pRecepientList = RecepientProfileList2.GetData();
		Jparams.pSenderProfile = SenderProfile.GetData();
		if(dwAddRetVal = pTest->AddMultiTypeJob(Jparams))
		{
			THROW_TEST_RUN_TIME_WIN32(dwAddRetVal, TEXT(" AddMultiTypeJob"));
		}

		RecepientProfile[0] = PersonalProfile(TEXT("583"));
		
		ListPersonalProfile RecepientProfileList3(1, RecepientProfile);
		
		Jparams.pRecepientList = RecepientProfileList3.GetData();
		Jparams.pSenderProfile = SenderProfile.GetData();
		if(dwAddRetVal = pTest->AddMultiTypeJob(Jparams))
		{
			THROW_TEST_RUN_TIME_WIN32(dwAddRetVal, TEXT(" AddMultiTypeJob"));
		}
	
		RecepientProfile[0] = PersonalProfile(TEXT("584"));

		ListPersonalProfile RecepientProfileList4(1, RecepientProfile);
		
		Jparams.pRecepientList = RecepientProfileList4.GetData();
		Jparams.pSenderProfile = SenderProfile.GetData();
		if(dwAddRetVal = pTest->AddMultiTypeJob(Jparams))
		{
			THROW_TEST_RUN_TIME_WIN32(dwAddRetVal, TEXT(" AddMultiTypeJob"));
		}
	

		RecepientProfile[0] = PersonalProfile(TEXT("581"));
			
		Jparams.pRecepientList = RecepientProfileList1.GetData();
		Jparams.pSenderProfile = SenderProfile.GetData();
		
		if(dwAddRetVal = pTest->AddMultiTypeJob(Jparams))
		{
			THROW_TEST_RUN_TIME_WIN32(dwAddRetVal, TEXT(" AddMultiTypeJob"));
		}

		RecepientProfile[0] = PersonalProfile(TEXT("582"));

		Jparams.pRecepientList = RecepientProfileList2.GetData();
		Jparams.pSenderProfile = SenderProfile.GetData();
		if(dwAddRetVal = pTest->AddMultiTypeJob(Jparams))
		{
			THROW_TEST_RUN_TIME_WIN32(dwAddRetVal, TEXT(" AddMultiTypeJob"));
		}

		RecepientProfile[0] = PersonalProfile(TEXT("583"));
	
		Jparams.pRecepientList = RecepientProfileList3.GetData();
		Jparams.pSenderProfile = SenderProfile.GetData();
		if(dwAddRetVal = pTest->AddMultiTypeJob(Jparams))
		{
			THROW_TEST_RUN_TIME_WIN32(dwAddRetVal, TEXT(" AddMultiTypeJob"));
		}
	
		RecepientProfile[0] = PersonalProfile(TEXT("584"));

		Jparams.pRecepientList = RecepientProfileList4.GetData();
		Jparams.pSenderProfile = SenderProfile.GetData();
		if(dwAddRetVal = pTest->AddMultiTypeJob(Jparams))
		{
			THROW_TEST_RUN_TIME_WIN32(dwAddRetVal, TEXT(" AddMultiTypeJob"));
		}
	
		
		getchar();
	
	}
	catch(Win32Err& err)
	{
		::lgLogError(LOG_SEV_1, TEXT("Exception:%s."), err.Desc());
	}

	
	::lgEndCase();
	::lgEndSuite();
	::lgCloseLogger(); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\jobmngr\testcases\pauseq1.cpp ===
#pragma warning(disable :4786)
// standard
#include <iostream>

// utilities
#include <testruntimeerr.h>
#include <params.h>

// project specific
#include <Defs.h>
#include <PrepareJobParams.cpp>
#include "..\CTestManager.h"
#include "..\CJobTypes.h"


void main(int argc,char** argv)
{
	CInput input(GetCommandLine());
	tstring tstrServerName;
	tstring tstrDocumentPath;

	if(input.IsExists(TEXT("d")))
	{
		tstrDocumentPath = input[TEXT("d")];
	}
	else
	{
		std::cout << "TstMng Usage:\n" <<
					 "/d:[fax file path] spaces in path are allowed do not use the \" char \n" <<
					 "/s:[server name] by default server is the local machine\n";
		exit(0);
	}

	if(input.IsExists(TEXT("s")))
	{
		tstrServerName = input[TEXT("s")];
	}

	::lgInitializeLogger();
	::lgBeginSuite(TEXT("PauseQ"));
	::lgBeginCase(0, TEXT("0"));

	CTestManager* pTest = NULL;	
	try
	{
		DWORD x_ComputerNameLenth = 256;//MAX_COMPUTERNAME_LENGTH;
		if(tstrServerName == TEXT(""))
		{
			TCHAR buffServerName[256];//[MAX_COMPUTERNAME_LENGTH + 1 ];
			if(!GetComputerName(buffServerName, &x_ComputerNameLenth))
			{
				THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT(" GetComputerName"));
			}
			tstrServerName = buffServerName;
		}
	
		// initialize test manager
		pTest = new CTestManager(tstrServerName);
		
		if(!pTest)
		{
			THROW_TEST_RUN_TIME_WIN32( ERROR_OUTOFMEMORY, TEXT(" Main, new CTestManager"));
		}

		JOB_PARAMS_EX Jparams;

		// prepare job params
		JobParamExNow JobParam( TEXT("test"));
			
		Jparams.pJobParam = JobParam.GetData();
		Jparams.szDocument = tstrDocumentPath.c_str();
		Jparams.pCoverpageInfo = NULL;
		Jparams.dwNumRecipients = 1;
			
		PersonalProfile SenderProfile(TEXT("585"));
		PersonalProfile RecepientProfile[1];
		JOB_BEHAVIOR RecipientsBehavior[1];
		RecepientProfile[0] = PersonalProfile(TEXT("581"));
		RecipientsBehavior[0].dwJobType = JT_SIMPLE_SEND;
	
		ListPersonalProfile RecepientProfileList(1, RecepientProfile);
		
		Jparams.pRecepientList = RecepientProfileList.GetData();
		Jparams.pSenderProfile = SenderProfile.GetData();
		Jparams.pRecipientsBehavior = RecipientsBehavior;
		
		
		DWORD dwAddRetVal;
			
		if(dwAddRetVal = pTest->AddMultiTypeJob(Jparams))
		{
			THROW_TEST_RUN_TIME_WIN32(dwAddRetVal, TEXT(" AddSimpleJobEx"));
		}

		RecepientProfile[0] = PersonalProfile(TEXT("582"));
		RecipientsBehavior[0].dwJobType = JT_SIMPLE_SEND;
		ListPersonalProfile RecepientProfileList2(1, RecepientProfile);
		
		Jparams.pRecepientList = RecepientProfileList2.GetData();

		if(dwAddRetVal = pTest->AddMultiTypeJob(Jparams))
		{
			THROW_TEST_RUN_TIME_WIN32(dwAddRetVal, TEXT(" AddMultiTypeJob"));
		}

		
		RecepientProfile[0] = PersonalProfile(TEXT("583"));
		RecipientsBehavior[0].dwJobType = JT_SIMPLE_SEND;
		ListPersonalProfile RecepientProfileList3(1, RecepientProfile);
		
		Jparams.pRecepientList = RecepientProfileList3.GetData();

		if(dwAddRetVal = pTest->AddMultiTypeJob(Jparams))
		{
			THROW_TEST_RUN_TIME_WIN32(dwAddRetVal, TEXT(" AddMultiTypeJob"));
		}

		
		RecepientProfile[0] = PersonalProfile(TEXT("584"));
		RecipientsBehavior[0].dwJobType = JT_SIMPLE_SEND;
		ListPersonalProfile RecepientProfileList4(1, RecepientProfile);
		
		Jparams.pRecepientList = RecepientProfileList4.GetData();

		if(dwAddRetVal = pTest->AddMultiTypeJob(Jparams))
		{
			THROW_TEST_RUN_TIME_WIN32(dwAddRetVal, TEXT(" AddMultiTypeJob"));
		}

		
		RecepientProfile[0] = PersonalProfile(TEXT("585"));
		RecipientsBehavior[0].dwJobType = JT_SIMPLE_SEND;
		ListPersonalProfile RecepientProfileList5(1, RecepientProfile);
		
		Jparams.pRecepientList = RecepientProfileList5.GetData();

		if(dwAddRetVal = pTest->AddMultiTypeJob(Jparams))
		{
			THROW_TEST_RUN_TIME_WIN32(dwAddRetVal, TEXT(" AddMultiTypeJob"));
		}

			RecepientProfile[0] = PersonalProfile(TEXT("586"));
		RecipientsBehavior[0].dwJobType = JT_SIMPLE_SEND;
		ListPersonalProfile RecepientProfileList6(1, RecepientProfile);
		
		Jparams.pRecepientList = RecepientProfileList6.GetData();
		if(dwAddRetVal = pTest->AddMultiTypeJob(Jparams))
		{
			THROW_TEST_RUN_TIME_WIN32(dwAddRetVal, TEXT(" AddMultiTypeJob"));
		}

		
		RecepientProfile[0] = PersonalProfile(TEXT("587"));
		RecipientsBehavior[0].dwJobType = JT_SIMPLE_SEND;
		ListPersonalProfile RecepientProfileList7(1, RecepientProfile);
		
		Jparams.pRecepientList = RecepientProfileList7.GetData();
		if(dwAddRetVal = pTest->AddMultiTypeJob(Jparams))
		{
			THROW_TEST_RUN_TIME_WIN32(dwAddRetVal, TEXT(" AddMultiTypeJob"));
		}

		
		RecepientProfile[0] = PersonalProfile(TEXT("588"));
		RecipientsBehavior[0].dwJobType = JT_SIMPLE_SEND;
		ListPersonalProfile RecepientProfileList8(1, RecepientProfile);
		
		Jparams.pRecepientList = RecepientProfileList8.GetData();
		if(dwAddRetVal = pTest->AddMultiTypeJob(Jparams))
		{
			THROW_TEST_RUN_TIME_WIN32(dwAddRetVal, TEXT(" AddMultiTypeJob"));
		}

		getchar();
	
	}
	catch(Win32Err& err)
	{
		::lgLogError(LOG_SEV_1, TEXT("Exception:%s."), err.Desc());
	}

  

	
	::lgEndCase();
	::lgEndSuite();
	::lgCloseLogger();  // Holds the process?
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\jobmngr\testcases\multitypes1.cpp ===
#pragma warning(disable :4786)
// standard
#include <iostream>

// utilities
#include <testruntimeerr.h>
#include <params.h>

// project specific
#include <Defs.h>
#include <PrepareJobParams.cpp>
#include "..\CTestManager.h"
#include "..\CJobTypes.h"
 

void main(int argc,char** argv)
{
	CInput input(GetCommandLine());
	tstring tstrServerName;
	tstring tstrDocumentPath;

	if(input.IsExists(TEXT("d")))
	{
		tstrDocumentPath = input[TEXT("d")];
	}
	else
	{
		std::cout << "TstMng Usage:\n" <<
					 "/d:[fax file path] spaces in path are allowed do not use the \" char \n" <<
					 "/s:[server name] by default server is the local machine\n";
		exit(0);
	}

	if(input.IsExists(TEXT("s")))
	{
		tstrServerName = input[TEXT("s")];
	}

	::lgInitializeLogger();
	::lgBeginSuite(TEXT("MultiTypes"));
	::lgBeginCase(0, TEXT("0"));
	
	CTestManager* pTest = NULL;	
	try
	{
		DWORD x_ComputerNameLenth = 256;//MAX_COMPUTERNAME_LENGTH;
		if(tstrServerName == TEXT(""))
		{
			TCHAR buffServerName[256];//[MAX_COMPUTERNAME_LENGTH + 1 ];
			if(!GetComputerName(buffServerName, &x_ComputerNameLenth))
			{
				THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT(" GetComputerName"));
			}
			tstrServerName = buffServerName;
		}
	
		// initialize test manager
		pTest = new CTestManager(tstrServerName);
		
		if(!pTest)
		{
			THROW_TEST_RUN_TIME_WIN32( ERROR_OUTOFMEMORY, TEXT(" Main, new CTestManager"));
		}

		JOB_PARAMS_EX Jparams;

		// prepare job params
		JobParamExNow JobParam( TEXT("test"));
			
		Jparams.pJobParam = JobParam.GetData();
		Jparams.szDocument = tstrDocumentPath.c_str();
		Jparams.pCoverpageInfo = NULL;
		Jparams.dwNumRecipients = 25;
			
		PersonalProfile SenderProfile(TEXT("585"));
		PersonalProfile RecepientProfile[25];
		JOB_BEHAVIOR RecipientsBehavior[25];
		RecepientProfile[0] = PersonalProfile(TEXT("581"));
		RecipientsBehavior[0].dwJobType = JT_RANDOM_ABORT;
		RecepientProfile[1] = PersonalProfile(TEXT("582"));
		RecipientsBehavior[1].dwJobType = JT_RANDOM_ABORT;
		RecepientProfile[2] = PersonalProfile(TEXT("583"));
		RecipientsBehavior[2].dwJobType = JT_RANDOM_ABORT;
		RecepientProfile[3] = PersonalProfile(TEXT("584"));
		RecipientsBehavior[3].dwJobType = JT_SIMPLE_SEND;
		RecepientProfile[4] = PersonalProfile(TEXT("585"));
		RecipientsBehavior[4].dwJobType = JT_SIMPLE_SEND;
		RecepientProfile[5] = PersonalProfile(TEXT("586"));
		RecipientsBehavior[5].dwJobType = JT_RANDOM_ABORT;
		RecepientProfile[6] = PersonalProfile(TEXT("587"));
		RecipientsBehavior[6].dwJobType = JT_ABORT_PAGE;
		RecipientsBehavior[6].dwParam1 = 3;
		RecepientProfile[7] = PersonalProfile(TEXT("588"));
		RecipientsBehavior[7].dwJobType = JT_SIMPLE_SEND;
		RecepientProfile[8] = PersonalProfile(TEXT("589"));
		RecipientsBehavior[8].dwJobType = JT_RANDOM_ABORT;
		RecepientProfile[9] = PersonalProfile(TEXT("581"));
		RecipientsBehavior[9].dwJobType = JT_SIMPLE_SEND;
		RecepientProfile[10] = PersonalProfile(TEXT("586"));
		RecipientsBehavior[10].dwJobType = JT_RANDOM_PAUSE;
		RecepientProfile[11] = PersonalProfile(TEXT("587"));
		RecipientsBehavior[11].dwJobType = JT_ABORT_PAGE;
		RecipientsBehavior[11].dwParam1 = 1;
		RecepientProfile[12] = PersonalProfile(TEXT("588"));
		RecipientsBehavior[12].dwJobType = JT_SIMPLE_SEND;
		RecepientProfile[13] = PersonalProfile(TEXT("589"));
		RecipientsBehavior[13].dwJobType = JT_SIMPLE_SEND;
		RecepientProfile[14] = PersonalProfile(TEXT("590"));
		RecipientsBehavior[14].dwJobType = JT_RANDOM_PAUSE;
		RecepientProfile[15] = PersonalProfile(TEXT("598"));
		RecipientsBehavior[15].dwJobType = JT_ABORT_PAGE;
		RecipientsBehavior[15].dwParam1 = 2;
		RecepientProfile[16] = PersonalProfile(TEXT("593"));
		RecipientsBehavior[16].dwJobType = JT_RANDOM_ABORT;
		RecepientProfile[17] = PersonalProfile(TEXT("581"));
		RecipientsBehavior[17].dwJobType = JT_RANDOM_PAUSE;
		
		RecepientProfile[18] = PersonalProfile(TEXT("582"));
		RecipientsBehavior[18].dwJobType = JT_ABORT_PAGE;
		RecipientsBehavior[18].dwParam1 = 1;
		RecepientProfile[19] = PersonalProfile(TEXT("583"));
		RecipientsBehavior[19].dwJobType = JT_SIMPLE_SEND;
		RecepientProfile[20] = PersonalProfile(TEXT("584"));
		RecipientsBehavior[20].dwJobType = JT_SIMPLE_SEND;
		RecepientProfile[21] = PersonalProfile(TEXT("585"));
		RecipientsBehavior[21].dwJobType = JT_RANDOM_PAUSE;
		RecepientProfile[22] = PersonalProfile(TEXT("588"));
		RecipientsBehavior[22].dwJobType = JT_ABORT_PAGE;
		RecipientsBehavior[22].dwParam1 = 2;
		RecepientProfile[23] = PersonalProfile(TEXT("589"));
		RecipientsBehavior[23].dwJobType = JT_RANDOM_ABORT;
		RecepientProfile[24] = PersonalProfile(TEXT("590"));
		RecipientsBehavior[24].dwJobType = JT_SIMPLE_SEND;




		ListPersonalProfile RecepientProfileList(25, RecepientProfile);
		
		Jparams.pRecepientList = RecepientProfileList.GetData();
		Jparams.pSenderProfile = SenderProfile.GetData();
		Jparams.pRecipientsBehavior = RecipientsBehavior;
		
			
	
		DWORD dwAddRetVal;
		
		if(dwAddRetVal = pTest->AddMultiTypeJob(Jparams))
		{
			THROW_TEST_RUN_TIME_WIN32(dwAddRetVal, TEXT(" AddMultiTypeJob"));
		}

		getchar();
	
	}
	catch(Win32Err& err)
	{
		::lgLogError(LOG_SEV_1, TEXT("Exception:%s."), err.Desc());
	}

  	
	::lgEndCase();
	::lgEndSuite();
	::lgCloseLogger();  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\jobmngr\testcases\pause1.cpp ===
#pragma warning(disable :4786)
// standard
#include <iostream>

// utilities
#include <testruntimeerr.h>
#include <params.h>

// project specific
#include <Defs.h>
#include <PrepareJobParams.cpp>
#include "..\CTestManager.h"
#include "..\CJobTypes.h"


void main(int argc,char** argv)
{
	CInput input(GetCommandLine());
	tstring tstrServerName;
	tstring tstrDocumentPath;

	if(input.IsExists(TEXT("d")))
	{
		tstrDocumentPath = input[TEXT("d")];
	}
	else
	{
		std::cout << "5879 Usage:\n" <<
					 "/d:[fax file path] spaces in path are allowed do not use the \" char \n" <<
					 "/s:[server name] by default server is the local machine\n";
		exit(0);
	}

	::lgInitializeLogger();
	::lgBeginSuite(TEXT("Pause1"));
	::lgBeginCase(0, TEXT("0"));
	
			
	if(input.IsExists(TEXT("s")))
	{
		tstrServerName = input[TEXT("s")];
	}

	CTestManager* pTest = NULL;	
	try
	{
	
		DWORD x_ComputerNameLenth;
		if(tstrServerName == TEXT(""))
		{
			TCHAR buffServerName[MAX_COMPUTERNAME_LENGTH + 1 ];
			if(!GetComputerName(buffServerName, &x_ComputerNameLenth))
			{
				THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT(" GetComputerName"));
			}
			tstrServerName = buffServerName;
		}

		// initialize test manager
		pTest = new CTestManager(tstrServerName);
		
		if(!pTest)
		{
			THROW_TEST_RUN_TIME_WIN32( ERROR_OUTOFMEMORY, TEXT(" Main, new CTestManager"));
		}
	
		JOB_PARAMS_EX Jparams;

		// prepare job params
		JobParamExNow JobParam( TEXT("test"));
			
		Jparams.pJobParam = JobParam.GetData();
		Jparams.szDocument = tstrDocumentPath.c_str();
		Jparams.pCoverpageInfo = NULL;
		Jparams.dwNumRecipients = 10;
			
		PersonalProfile SenderProfile(TEXT("585"));
		PersonalProfile RecepientProfile[18] ;
		JOB_BEHAVIOR RecipientsBehavior[18];

		RecepientProfile[0] = PersonalProfile(TEXT("581"));
		RecipientsBehavior[0].dwJobType = JT_RANDOM_PAUSE;
		RecepientProfile[1] = PersonalProfile(TEXT("582"));
		RecipientsBehavior[1].dwJobType = JT_RANDOM_PAUSE;
		RecepientProfile[2] = PersonalProfile(TEXT("583"));
		RecipientsBehavior[2].dwJobType = JT_RANDOM_PAUSE;
		RecepientProfile[3] = PersonalProfile(TEXT("584"));
		RecipientsBehavior[3].dwJobType = JT_RANDOM_PAUSE;
		RecepientProfile[4] = PersonalProfile(TEXT("585"));
		RecipientsBehavior[4].dwJobType = JT_RANDOM_PAUSE;
		RecepientProfile[5] = PersonalProfile(TEXT("586"));
		RecipientsBehavior[5].dwJobType = JT_RANDOM_PAUSE;
		RecepientProfile[6] = PersonalProfile(TEXT("587"));
		RecipientsBehavior[6].dwJobType = JT_RANDOM_PAUSE;
		RecepientProfile[7] = PersonalProfile(TEXT("588"));
		RecipientsBehavior[7].dwJobType = JT_RANDOM_PAUSE;
		RecepientProfile[8] = PersonalProfile(TEXT("589"));
		RecipientsBehavior[8].dwJobType = JT_RANDOM_PAUSE;
		RecepientProfile[9] = PersonalProfile(TEXT("5810"));
		RecipientsBehavior[9].dwJobType = JT_RANDOM_PAUSE;
		RecepientProfile[10] = PersonalProfile(TEXT("5811"));
		RecipientsBehavior[10].dwJobType = JT_RANDOM_PAUSE;
		RecepientProfile[11] = PersonalProfile(TEXT("5812"));
		RecepientProfile[12] = PersonalProfile(TEXT("5813"));
		RecepientProfile[13] = PersonalProfile(TEXT("5814"));
		RecepientProfile[14] = PersonalProfile(TEXT("5815"));
		RecepientProfile[15] = PersonalProfile(TEXT("5816"));
		RecepientProfile[16] = PersonalProfile(TEXT("5817"));
		RecepientProfile[17] = PersonalProfile(TEXT("5818"));
		
		ListPersonalProfile RecepientProfileList(10, RecepientProfile);
		
		Jparams.pRecepientList = RecepientProfileList.GetData();
		Jparams.pSenderProfile = SenderProfile.GetData();
		Jparams.pRecipientsBehavior = RecipientsBehavior;
		
		
		
		DWORD dwAddRetVal;
		
			if(dwAddRetVal = pTest->AddMultiTypeJob(Jparams))
		{
			THROW_TEST_RUN_TIME_WIN32(dwAddRetVal, TEXT(" AddMultiTypeJob"));
		}
		
		getchar();
	
	}
	catch(Win32Err& err)
	{
		::lgLogError(LOG_SEV_1, TEXT("Exception:%s."), err.Desc());
	}

  	
	::lgEndCase();
	::lgEndSuite();
	::lgCloseLogger();  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\jobmngr\testcases\multitypes.cpp ===
#pragma warning(disable :4786)
// standard
#include <iostream>

// utilities
#include <testruntimeerr.h>
#include <params.h>

// project specific
#include <Defs.h>
#include <PrepareJobParams.cpp>
#include "..\CTestManager.h"
#include "..\CJobTypes.h"
 

void main(int argc,char** argv)
{
	CInput input(GetCommandLine());
	tstring tstrServerName;
	tstring tstrDocumentPath;

	if(input.IsExists(TEXT("d")))
	{
		tstrDocumentPath = input[TEXT("d")];
	}
	else
	{
		std::cout << "TstMng Usage:\n" <<
					 "/d:[fax file path] spaces in path are allowed do not use the \" char \n" <<
					 "/s:[server name] by default server is the local machine\n";
		exit(0);
	}

	if(input.IsExists(TEXT("s")))
	{
		tstrServerName = input[TEXT("s")];
	}

	::lgInitializeLogger();
	::lgBeginSuite(TEXT("MultiTypes"));
	::lgBeginCase(0, TEXT("0"));
	
	
	CTestManager* pTest = NULL;	
	try
	{
		DWORD x_ComputerNameLenth = 256;//MAX_COMPUTERNAME_LENGTH;
		if(tstrServerName == TEXT(""))
		{
			TCHAR buffServerName[256];//[MAX_COMPUTERNAME_LENGTH + 1 ];
			if(!GetComputerName(buffServerName, &x_ComputerNameLenth))
			{
				THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT(" GetComputerName"));
			}
			tstrServerName = buffServerName;
		}
	
		// initialize test manager
		pTest = new CTestManager(tstrServerName);
		
		if(!pTest)
		{
			THROW_TEST_RUN_TIME_WIN32( ERROR_OUTOFMEMORY, TEXT(" Main, new CTestManager"));
		}

		JOB_PARAMS_EX Jparams;


		// prepare job params
		JobParamExNow JobParam( TEXT("test"));
			
		Jparams.pJobParam = JobParam.GetData();
		Jparams.szDocument = tstrDocumentPath.c_str();
		Jparams.pCoverpageInfo = NULL;
		Jparams.dwNumRecipients = 18;
			
		PersonalProfile SenderProfile(TEXT("585"));
		PersonalProfile RecepientProfile[18];
		JOB_BEHAVIOR RecipientsBehavior[18];
		RecepientProfile[0] = PersonalProfile(TEXT("581"));
		RecipientsBehavior[0].dwJobType = JT_RANDOM_ABORT;
		RecepientProfile[1] = PersonalProfile(TEXT("582"));
		RecipientsBehavior[1].dwJobType = JT_RANDOM_ABORT;
		RecepientProfile[2] = PersonalProfile(TEXT("583"));
		RecipientsBehavior[2].dwJobType = JT_RANDOM_ABORT;
		RecepientProfile[3] = PersonalProfile(TEXT("584"));
		RecipientsBehavior[3].dwJobType = JT_SIMPLE_SEND;
		RecepientProfile[4] = PersonalProfile(TEXT("585"));
		RecipientsBehavior[4].dwJobType = JT_SIMPLE_SEND;
		RecepientProfile[5] = PersonalProfile(TEXT("586"));
		RecipientsBehavior[5].dwJobType = JT_RANDOM_ABORT;
		RecepientProfile[6] = PersonalProfile(TEXT("587"));
		RecipientsBehavior[6].dwJobType = JT_RANDOM_PAUSE;
		RecipientsBehavior[6].dwParam1 = 3;
		RecepientProfile[7] = PersonalProfile(TEXT("588"));
		RecipientsBehavior[7].dwJobType = JT_SIMPLE_SEND;
		RecepientProfile[8] = PersonalProfile(TEXT("589"));
		RecipientsBehavior[8].dwJobType = JT_RANDOM_ABORT;
		RecepientProfile[9] = PersonalProfile(TEXT("581"));
		RecipientsBehavior[9].dwJobType = JT_SIMPLE_SEND;
		RecepientProfile[10] = PersonalProfile(TEXT("586"));
		RecipientsBehavior[10].dwJobType = JT_RANDOM_PAUSE;
		RecepientProfile[11] = PersonalProfile(TEXT("586"));
		RecipientsBehavior[11].dwJobType = JT_ABORT_PAGE;
		RecipientsBehavior[11].dwParam1 = 1;
		RecepientProfile[12] = PersonalProfile(TEXT("587"));
		RecipientsBehavior[12].dwJobType = JT_SIMPLE_SEND;
		RecepientProfile[13] = PersonalProfile(TEXT("587"));
		RecipientsBehavior[13].dwJobType = JT_SIMPLE_SEND;
		RecepientProfile[14] = PersonalProfile(TEXT("588"));
		RecipientsBehavior[14].dwJobType = JT_RANDOM_PAUSE;
		RecepientProfile[15] = PersonalProfile(TEXT("588"));
		RecipientsBehavior[15].dwJobType = JT_ABORT_PAGE;
		RecipientsBehavior[15].dwParam1 = 2;
		RecepientProfile[16] = PersonalProfile(TEXT("589"));
		RecipientsBehavior[16].dwJobType = JT_RANDOM_ABORT;
		RecepientProfile[17] = PersonalProfile(TEXT("589"));
		RecipientsBehavior[17].dwJobType = JT_RANDOM_PAUSE;

		ListPersonalProfile RecepientProfileList(18, RecepientProfile);
		
		Jparams.pRecepientList = RecepientProfileList.GetData();
		Jparams.pSenderProfile = SenderProfile.GetData();
		Jparams.pRecipientsBehavior = RecipientsBehavior;
		
			
	
		DWORD dwAddRetVal;
		
		if(dwAddRetVal = pTest->AddMultiTypeJob(Jparams))
		{
			THROW_TEST_RUN_TIME_WIN32(dwAddRetVal, TEXT(" AddMultiTypeJob"));
		}

		Sleep(rand() % (6 * 60 * 1000));

		getchar();
	
	}
	catch(Win32Err& err)
	{
		::lgLogError(LOG_SEV_1, TEXT("Exception:%s."), err.Desc());
	}

  

	
	::lgEndCase();
	::lgEndSuite();
	::lgCloseLogger();  // Holds the process?
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\jobmngr\testcases\schedule1.cpp ===
#pragma warning(disable :4786)
// standard
#include <iostream>

// utilities
#include <testruntimeerr.h>
#include <params.h>

// project specific
#include <Defs.h>
#include <PrepareJobParams.cpp>
#include "..\CTestManager.h"
#include "..\CJobTypes.h"


void main(int argc,char** argv)
{
	
	::lgInitializeLogger();
	::lgBeginSuite(TEXT("Schedule1"));
	::lgBeginCase(0, TEXT("0"));
	
	CInput input(GetCommandLine());
	tstring tstrServerName;


	if(input.IsExists( TEXT("s")))
	{
		tstrServerName = input[TEXT("s")];
	}
	else
	{
	}
	
	CTestManager* pTest = NULL;	
	try
	{
	
		// initialize test manager
		pTest = new CTestManager(tstrServerName);
		
		if(!pTest)
		{
			THROW_TEST_RUN_TIME_WIN32( ERROR_OUTOFMEMORY, TEXT(" Main, new CTestManager"));
		}

		JOB_PARAMS_EX Jparams;

		// prepare job params
		JobParamExNow JobParam( TEXT("Group1"));
			
		Jparams.pJobParam = JobParam.GetData();
		Jparams.szDocument = TEXT("D:\\Documents and Settings\\t-mirias\\My Documents\\Test document.doc");
		Jparams.pCoverpageInfo = NULL;
		Jparams.dwNumRecipients = 10;
			
		PersonalProfile SenderProfile(TEXT("585"));
		PersonalProfile RecepientProfile[10] ;
		JOB_BEHAVIOR RecipientsBehavior[10];
		
		RecepientProfile[0] = PersonalProfile(TEXT("581"));
		RecipientsBehavior[0].dwJobType = JT_SIMPLE_SEND;
		RecepientProfile[1] = PersonalProfile(TEXT("581"));
		RecipientsBehavior[1].dwJobType = JT_SIMPLE_SEND;
		RecepientProfile[2] = PersonalProfile(TEXT("581"));
		RecipientsBehavior[2].dwJobType = JT_SIMPLE_SEND;
		RecepientProfile[3] = PersonalProfile(TEXT("581"));
		RecipientsBehavior[3].dwJobType = JT_SIMPLE_SEND;
		RecepientProfile[4] = PersonalProfile(TEXT("581"));
		RecipientsBehavior[4].dwJobType = JT_SIMPLE_SEND;
		RecepientProfile[5] = PersonalProfile(TEXT("581"));
		RecipientsBehavior[5].dwJobType = JT_SIMPLE_SEND;
		RecepientProfile[6] = PersonalProfile(TEXT("581"));
		RecipientsBehavior[6].dwJobType = JT_SIMPLE_SEND;
		RecepientProfile[7] = PersonalProfile(TEXT("581"));
		RecipientsBehavior[7].dwJobType = JT_SIMPLE_SEND;
		RecepientProfile[8] = PersonalProfile(TEXT("581"));
		RecipientsBehavior[8].dwJobType = JT_SIMPLE_SEND;
		RecepientProfile[9] = PersonalProfile(TEXT("581"));
		RecipientsBehavior[9].dwJobType = JT_SIMPLE_SEND;
			
	
		ListPersonalProfile RecepientProfileList(10, RecepientProfile);
		
		Jparams.pRecepientList = RecepientProfileList.GetData();
		Jparams.pSenderProfile = SenderProfile.GetData();
		
			DWORD dwAddRetVal;
		
		if(dwAddRetVal =  pTest->AddMultiTypeJob(Jparams))
		{
			THROW_TEST_RUN_TIME_WIN32(dwAddRetVal, TEXT(" AddMultiTypeJob"));
		}
		
	    Sleep(7*60*1000);

		// prepare job params
		JobParamExNow JobParam2( TEXT("Group2"));
		
		Jparams.pJobParam = JobParam2.GetData();
		Jparams.dwNumRecipients = 1;
				
		::lgLogDetail(LOG_X, 0, TEXT("New job is sent"));
		if(dwAddRetVal = pTest->AddMultiTypeJob(Jparams))
		{
			THROW_TEST_RUN_TIME_WIN32(dwAddRetVal, TEXT(" AddMultiTypeJob"));
		}
		getchar();
	
	}
	catch(Win32Err& err)
	{
		::lgLogError(LOG_SEV_1, TEXT("Exception:%s."), err.Desc());
	}

 	
	::lgEndCase();
	::lgEndSuite();
	::lgCloseLogger();  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\jobmngr\testcases\sendbroadcastjob.cpp ===
#pragma warning(disable :4786)
// standard
#include <iostream>

// utilities
#include <testruntimeerr.h>
#include <params.h>
#include <iniutils.h>

// project specific
#include <Defs.h>
#include "..\CTestManager.h"
#include "..\CJobTypes.h"
#include "IniFileSettings.h"
#include "..\MapToFaxStruct.h"
using namespace std;



void main(int argc,char** argv)
{
	CInput input(GetCommandLine());
	tstring tstrIniFile;
	tstring tstrServerName;
	tstring tstrDocumentPath;

	if( input.IsExists(TEXT("f")) && ( input[TEXT("f")] != tstring(TEXT(""))))
	{
		tstrIniFile = input[TEXT("f")];
	}
	else
	{
		std::cout << "SendBroadcastJob Usage:\n" <<
					 "/f:[ini file full(!) path] spaces in path are allowed do not use the \" char \n";
					
		exit(0);
	}

	::lgInitializeLogger();
	::lgBeginSuite(TEXT("Send Broadcast Fax"));
	::lgBeginCase(0, TEXT("0"));
	
	// We want exception to be printed before the very long destructor process of this object. 
	CTestManager* pTest = NULL;		
	try
	{
	
		// The function throws test run time exception on fail
		std::map<tstring, DWORD> SectionsMap = INI_GetSectionNames(tstrIniFile);
		std::map<tstring, DWORD>::iterator iterSections;

		if(SectionsMap.empty())
		{
			::lgLogDetail(LOG_X, 0, TEXT("File does not exist or not does contain any entries"));
			THROW_TEST_RUN_TIME_WIN32( E_FAIL, TEXT(" Main"));
		}

		// Verify mandatory section entries exist.
		for( DWORD index = 0; index < SectionEntriesArraySize; index++)
		{
			iterSections = SectionsMap.find( SectionEntriesArray[index]);
		    if(iterSections == SectionsMap.end())
			{ 

				::lgLogDetail(LOG_X, 0, TEXT("Ini file is missing mandatory section entry: %s"),
							  (SectionEntriesArray[index]).c_str());
				THROW_TEST_RUN_TIME_WIN32( E_FAIL, TEXT(" Main"));
			}
		}

		// ---------------------------
		// Get General section entries
		// ---------------------------

		std::map<tstring, tstring> SectionEntriesMap = INI_GetSectionEntries(tstrIniFile, GENERAL_PARAMS);
		std::map<tstring, tstring>::iterator iterMap;
	
		// Get server name
		iterMap = SectionEntriesMap.find( TEXT("Server"));
		if( (iterMap != SectionEntriesMap.end()) && (((*iterMap).second) != tstring(TEXT(""))))
		{ 
			tstrServerName = (*iterMap).second;
		}
		// Server is local machine
		else
		{
			DWORD x_ComputerNameLenth = MAX_COMPUTERNAME_LENGTH;
			if(tstrServerName == TEXT(""))
			{
				TCHAR buffServerName[MAX_COMPUTERNAME_LENGTH + 1 ];
				if(!GetComputerName(buffServerName, &x_ComputerNameLenth))
				{
					THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT(" GetComputerName"));
				}
				tstrServerName = buffServerName;
			}
		}
	
		SectionEntriesMap.clear();
		JOB_PARAMS_EX BroadcastParams;

		// -----------------------------------
		// Get Send Parameters section entries
		// -----------------------------------
		
		SectionEntriesMap = INI_GetSectionEntries(tstrIniFile, SEND_PARAMS);
	
		iterMap = SectionEntriesMap.find( TEXT("Fax Document"));
		if( (iterMap != SectionEntriesMap.end()) && (((*iterMap).second) != tstring(TEXT(""))))
		{ 
			BroadcastParams.szDocument = _tcsdup(((*iterMap).second).c_str());
			assert(BroadcastParams.szDocument);
		}
		else
		{
			::lgLogDetail(LOG_X, 0, TEXT("%s section must specify the Fax Document path"),
										  SEND_PARAMS);
			THROW_TEST_RUN_TIME_WIN32( E_FAIL, TEXT(" Main"));
		}
		
		// Cover Page
		BroadcastParams.pCoverpageInfo = NULL;
		FAX_COVERPAGE_INFO_EX FaxCoverPage;
		
		iterMap = SectionEntriesMap.find( TEXT("CoverPage"));
		if( (iterMap != SectionEntriesMap.end()) && (((*iterMap).second) != tstring(TEXT(""))))
		{ 
			MapToFAX_COVERPAGE_INFO_EX( (*iterMap).second, FaxCoverPage);
			BroadcastParams.pCoverpageInfo = &FaxCoverPage;
		}
	

		FAX_JOB_PARAM_EX FaxJobParams;
		// Read broadcast job parameters into structure.
		MapToFAX_JOB_PARAM_EX(SectionEntriesMap, FaxJobParams);
		BroadcastParams.pJobParam = &FaxJobParams;
		
		SectionEntriesMap.clear();

		// ----------------------------------
		// Get Sender Details section entries
		// ----------------------------------

		SectionEntriesMap = INI_GetSectionEntries(tstrIniFile, SENDER_DETAILS);

		if(!SectionEntriesMap.empty())
		{
			FAX_PERSONAL_PROFILE SenderProfile;
			MapNumberToFAX_PERSONAL_PROFILE(SectionEntriesMap,
											SenderProfile);

			// Read personal profile parameters into structure.
			iterMap = SectionEntriesMap.find( TEXT("Profile"));
			if( (iterMap != SectionEntriesMap.end()) && (((*iterMap).second) != tstring(TEXT(""))))
			{ 
				std::map<tstring, tstring> ProfileMap = INI_GetSectionEntries(tstrIniFile, 
																			  ((*iterMap).second).c_str());
				
				if(ProfileMap.empty())
				{
					::lgLogDetail(LOG_X, 0, TEXT("%s section does not exist or is empty"), ((*iterMap).second).c_str());
				}

				// Read broadcast job parameters into structure.
				ChargeFAX_PERSONAL_PROFILE(ProfileMap, SenderProfile);
			}
					
			BroadcastParams.pSenderProfile = &SenderProfile;
		}
		else
		{
			BroadcastParams.pSenderProfile = NULL;
		}

		SectionEntriesMap.clear();

		// ----------------------------------
		// Get Recipient List section entries
		// ----------------------------------

		SectionEntriesMap = INI_GetSectionEntries(tstrIniFile, RECIPIENT_LIST);

		// Create recipient list arrays
		SPTR<FAX_PERSONAL_PROFILE> pRecepientProfileList = SPTR<FAX_PERSONAL_PROFILE>(new FAX_PERSONAL_PROFILE[SectionEntriesMap.size()]); 
		SPTR<JOB_BEHAVIOR> pRecipientsBehavior = SPTR<JOB_BEHAVIOR>(new JOB_BEHAVIOR[SectionEntriesMap.size()]);

		if( !pRecepientProfileList.get() || !pRecipientsBehavior.get())
		{
			THROW_TEST_RUN_TIME_WIN32( ERROR_OUTOFMEMORY, TEXT(" Main, new SPTR"));
		}

		DWORD dwRecipientindex = 0;
		// Walk on recipient list
		for( iterMap = SectionEntriesMap.begin(); iterMap != SectionEntriesMap.end(); iterMap++)
		{
			std::map<tstring, tstring>::iterator iterEntries;
			std::map<tstring, tstring> RecipientEntriesMap = INI_GetSectionEntries(tstrIniFile, 
																				  ((*iterMap).first).c_str());
			if(RecipientEntriesMap.empty())
			{
				::lgLogDetail(LOG_X, 0, TEXT("%s section not found or no entries"),
										    ((*iterMap).first).c_str());
				continue;
			}
			
			FAX_PERSONAL_PROFILE RecipientProfile;

			if(!MapNumberToFAX_PERSONAL_PROFILE(RecipientEntriesMap,
 												RecipientProfile))
			{
				::lgLogDetail(LOG_X, 0, TEXT("%s section must specify Fax Number"),
										    ((*iterMap).first).c_str());
				continue;
			}

			// Read personal profile parameters into structure.
			iterEntries = RecipientEntriesMap.find( TEXT("Profile"));
		 	if( (iterEntries != RecipientEntriesMap.end()) && (((*iterEntries).second) != tstring(TEXT(""))))
			{ 
				std::map<tstring, tstring> ProfileMap = INI_GetSectionEntries(tstrIniFile, 
																			  ((*iterEntries).second).c_str());
				
				if(ProfileMap.empty())
				{
					::lgLogDetail(LOG_X, 0, TEXT("%s section does not exist or is empty"), ((*iterEntries).second).c_str());
				}

				// Read broadcast job parameters into structure.
				ChargeFAX_PERSONAL_PROFILE(ProfileMap, RecipientProfile);
			}
		
			iterEntries = RecipientEntriesMap.find( TEXT("Type"));
			// Set default values
			pRecipientsBehavior[dwRecipientindex].dwJobType = JT_SIMPLE_SEND;
			pRecipientsBehavior[dwRecipientindex].dwParam1 = -1;  // -1 for not initializes
			pRecipientsBehavior[dwRecipientindex].dwParam2 = -1;

			if( (iterEntries != RecipientEntriesMap.end()) && (((*iterEntries).second) != tstring(TEXT(""))))
			{ 
				// Validate job type
				for( int tableindex = 0; tableindex < SendJobTypeStrTableSize; tableindex++)
				{
					if( !_tcscmp( (SendJobTypeStrTable[tableindex].second).c_str(),
						         ((*iterEntries).second).c_str()))
					{
						pRecipientsBehavior[dwRecipientindex].dwJobType = SendJobTypeStrTable[tableindex].first;
						iterEntries = RecipientEntriesMap.find( TEXT("Param1"));
						if( (iterEntries != RecipientEntriesMap.end()) && (((*iterEntries).second) != tstring(TEXT(""))))
						{
							pRecipientsBehavior[dwRecipientindex].dwParam1 =  _tcstol( ((*iterEntries).second.c_str()), NULL, 10);
						}
						iterEntries = RecipientEntriesMap.find( TEXT("Param2"));
						if( (iterEntries != RecipientEntriesMap.end()) && (((*iterEntries).second) != tstring(TEXT(""))))
						{
							pRecipientsBehavior[dwRecipientindex].dwParam2 =  _tcstol( ((*iterEntries).second.c_str()), NULL, 10);
						}
						break;
					}
				
				}
				
				if(tableindex == SendJobTypeStrTableSize)
				{
					::lgLogDetail(LOG_X, 0, TEXT("Job type %s doesn't exist, replaced with Simple"),
								                ((*iterEntries).second).c_str());
			
				}
			}
		
			pRecepientProfileList[dwRecipientindex++] = RecipientProfile;

		}
	
		if(!dwRecipientindex)
		{
			::lgLogDetail(LOG_X, 0, TEXT("No recipients in broadcast"));
			THROW_TEST_RUN_TIME_WIN32( E_FAIL, TEXT(" Main"));
		}

		BroadcastParams.pRecepientList = pRecepientProfileList.get();
		BroadcastParams.dwNumRecipients = dwRecipientindex;
		BroadcastParams.pRecipientsBehavior = pRecipientsBehavior.get();

		pTest = new CTestManager(tstrServerName, FALSE);
		
		if(!pTest)
		{
			THROW_TEST_RUN_TIME_WIN32( ERROR_OUTOFMEMORY, TEXT(" Main, new CTestManager"));
		}
			
		if(DWORD dwAddRetVal = pTest->AddMultiTypeJob(BroadcastParams))
		{
			THROW_TEST_RUN_TIME_WIN32(dwAddRetVal, TEXT(" AddMultiTypeJob"));
		}
		
		// Wait for recipient jobs termination.
		pTest->WaitOnJobEvent(BroadcastParams.dwParentJobId, EV_OPERATION_COMPLETED);
	
	}
	catch(Win32Err& err)
	{
		::lgLogError(LOG_SEV_1, TEXT("Exception:%s."), err.description());
	}
	
	::lgLogDetail(LOG_X, 0, TEXT("Test is terminating execution........."));
	delete pTest;

  	::lgEndCase();
	::lgEndSuite();
	::lgCloseLogger();  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\jobmngr\testcases\schedule2.cpp ===
#pragma warning(disable :4786)
// standard
#include <iostream>

// utilities
#include <testruntimeerr.h>
#include <params.h>

// project specific
#include <Defs.h>
#include <PrepareJobParams.cpp>
#include "..\CTestManager.h"
#include "..\CJobTypes.h"
 

void main(int argc,char** argv)
{
	
	::lgInitializeLogger();
	::lgBeginSuite(TEXT("Schedule2"));
	::lgBeginCase(0, TEXT("0"));
	
	CInput input(GetCommandLine());
	tstring tstrServerName;


	if(input.IsExists(TEXT("s")))
	{
		tstrServerName = input[TEXT("s")];
	}

	CTestManager* pTest = NULL;	
	try
	{
	
		// initialize test manager
		pTest = new CTestManager(tstrServerName);
		
		if(!pTest)
		{
			THROW_TEST_RUN_TIME_WIN32( ERROR_OUTOFMEMORY, TEXT(" Main, new CTestManager"));
		}

		JOB_PARAMS_EX Jparams;

		// prepare job params
		JobParamSchedule JobParam(TEXT("test"), 0, 0);
			
		Jparams.pJobParam = JobParam.GetData();
		Jparams.szDocument = TEXT("D:\\Documents and Settings\\v-mirias\\My Documents\\Test document.doc");
		Jparams.pCoverpageInfo = NULL;
		Jparams.dwNumRecipients = 1;
			
		PersonalProfile SenderProfile(TEXT("585"));
		PersonalProfile RecepientProfile[1] ;
		JOB_BEHAVIOR RecipientsBehavior[1];
	
		RecepientProfile[0] = PersonalProfile(TEXT("581"));
		RecipientsBehavior[0].dwJobType = JT_SIMPLE_SEND;
		
		ListPersonalProfile RecepientProfileList(1, RecepientProfile);
		
		Jparams.pRecepientList = RecepientProfileList.GetData();
		Jparams.pSenderProfile = SenderProfile.GetData();
		
	
		DWORD dwAddRetVal;
		
		if(dwAddRetVal = pTest->AddMultiTypeJob(Jparams))
		{
			THROW_TEST_RUN_TIME_WIN32(dwAddRetVal, TEXT(" AddMultiTypeJob"));
		}

		if(dwAddRetVal = pTest->AddMultiTypeJob(Jparams))
		{
			THROW_TEST_RUN_TIME_WIN32(dwAddRetVal, TEXT(" AddMultiTypeJob"));
		}
		

		getchar();
	
	}
	catch(Win32Err& err)
	{
		::lgLogError(LOG_SEV_1, TEXT("Exception:%s."), err.Desc());
	}

  	
	::lgEndCase();
	::lgEndSuite();
	::lgCloseLogger();  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\jobmngr\testcases\simple.cpp ===
#pragma warning(disable :4786)

// standard
#include <iostream>

// utilities
#include <testruntimeerr.h>
#include <params.h>

// project specific
#include <Defs.h>
#include <PrepareJobParams.cpp>
#include "..\CTestManager.h"
#include "..\CJobTypes.h"
 

void main(int argc,char** argv)
{
	CInput input(GetCommandLine());
	tstring tstrServerName;
	tstring tstrDocumentPath;

	if(input.IsExists(TEXT("d")))
	{
		tstrDocumentPath = input[TEXT("d")];
	}
	else
	{
		std::cout << "TstMng Usage:\n" <<
					 "/d:[fax file path] spaces in path are allowed do not use the \" char \n" <<
					 "/s:[server name] by default server is the local machine\n";
		exit(0);
	}

	if(input.IsExists(TEXT("s")))
	{
		tstrServerName = input[TEXT("s")];
	}

	::lgInitializeLogger();
	::lgBeginSuite(TEXT("Simple"));
	::lgBeginCase(0, TEXT("0"));
	
	// We want exception to be printed before the very long destructor process of this object. 
	CTestManager* pTest = NULL;	
	try
	{
		DWORD x_ComputerNameLenth = 256;//MAX_COMPUTERNAME_LENGTH;
		if(tstrServerName == TEXT(""))
		{
			TCHAR buffServerName[256];//[MAX_COMPUTERNAME_LENGTH + 1 ];
			if(!GetComputerName(buffServerName, &x_ComputerNameLenth))
			{
				THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT(" GetComputerName"));
			}
			tstrServerName = buffServerName;
		}
	
		// initialize test manager
		pTest = new CTestManager(tstrServerName);
		
		if(!pTest)
		{
			THROW_TEST_RUN_TIME_WIN32( ERROR_OUTOFMEMORY, TEXT(" Main, new CTestManager"));
		}

		JOB_PARAMS_EX Jparams;

		// prepare job params
		JobParamExNow JobParam( TEXT("test"));
			
		Jparams.pJobParam = JobParam.GetData();
		Jparams.szDocument = tstrDocumentPath.c_str();
		Jparams.pCoverpageInfo = NULL;
		Jparams.dwNumRecipients = 5;
			
		PersonalProfile SenderProfile(TEXT("585"));
		PersonalProfile RecepientProfile[25];
		JOB_BEHAVIOR RecipientsBehavior[25];
		RecepientProfile[0] = PersonalProfile(TEXT("581"));
		RecipientsBehavior[0].dwJobType = JT_SIMPLE_SEND;
		RecepientProfile[1] = PersonalProfile(TEXT("612"));
		RecipientsBehavior[1].dwJobType = JT_SIMPLE_SEND;
		RecepientProfile[2] = PersonalProfile(TEXT("613"));
		RecipientsBehavior[2].dwJobType = JT_SIMPLE_SEND;
		RecepientProfile[3] = PersonalProfile(TEXT("581"));
		RecipientsBehavior[3].dwJobType = JT_SIMPLE_SEND;
		RecepientProfile[4] = PersonalProfile(TEXT("615"));
		RecipientsBehavior[4].dwJobType = JT_SIMPLE_SEND;
		RecepientProfile[5] = PersonalProfile(TEXT("616"));
	
		ListPersonalProfile RecepientProfileList(5, RecepientProfile);
		
		Jparams.pRecepientList = RecepientProfileList.GetData();
		Jparams.pSenderProfile = SenderProfile.GetData();
		Jparams.pRecipientsBehavior = RecipientsBehavior;
		
		
		DWORD dwAddRetVal;
		
		if(dwAddRetVal = pTest->AddMultiTypeJob(Jparams))
		{
			THROW_TEST_RUN_TIME_WIN32(dwAddRetVal, TEXT(" AddMultiTypeJob"));
		}

		
		while(1)
		{
			Sleep(60*1000);
			pTest->PrintJobsStatus();
		}

		getchar();
	
	}
	catch(Win32Err& err)
	{
		::lgLogError(LOG_SEV_1, TEXT("Exception:%s."), err.Desc());
	}

  	::lgEndCase();
	::lgEndSuite();
	::lgCloseLogger(); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\jobmngr\testcases\test1.cpp ===
#pragma warning(disable :4786)
// standard
#include <iostream>

// utilities
#include <testruntimeerr.h>
#include <params.h>

// project specific
#include <Defs.h>
#include <PrepareJobParams.cpp>
#include "..\CTestManager.h"
#include "..\CJobTypes.h"


void main(int argc,char** argv)
{
	CInput input(GetCommandLine());
	tstring tstrServerName;
	tstring tstrDocumentPath;

	if(input.IsExists(TEXT("d")))
	{
		tstrDocumentPath = input[TEXT("d")];
	}
	else
	{
		std::cout << "TstMng Usage:\n" <<
					 "/d:[fax file path] spaces in path are allowed do not use the \" char \n" <<
					 "/s:[server name] by default server is the local machine\n";
		exit(0);
	}

	if(input.IsExists(TEXT("s")))
	{
		tstrServerName = input[TEXT("s")];
	}

	::lgInitializeLogger();
	::lgBeginSuite(TEXT("Test1"));
	::lgBeginCase(0, TEXT("0"));

	CTestManager* pTest = NULL;	
	try
	{
		DWORD x_ComputerNameLenth = 256;//MAX_COMPUTERNAME_LENGTH;
		if(tstrServerName == TEXT(""))
		{
			TCHAR buffServerName[256];//[MAX_COMPUTERNAME_LENGTH + 1 ];
			if(!GetComputerName(buffServerName, &x_ComputerNameLenth))
			{
				THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT(" GetComputerName"));
			}
			tstrServerName = buffServerName;
		}
	
		// initialize test manager
		pTest = new CTestManager(tstrServerName);
		
		if(!pTest)
		{
			THROW_TEST_RUN_TIME_WIN32( ERROR_OUTOFMEMORY, TEXT(" Main, new CTestManager"));
		}

		JOB_PARAMS_EX Jparams;

		// prepare job params
		JobParamExNow JobParam( TEXT("test"));
			
		Jparams.pJobParam = JobParam.GetData();
		Jparams.szDocument = tstrDocumentPath.c_str();
		Jparams.pCoverpageInfo = NULL;
		Jparams.dwNumRecipients = 3;
			
		PersonalProfile SenderProfile(TEXT("585"));
		PersonalProfile RecepientProfile[25];
		JOB_BEHAVIOR RecipientsBehavior[25];
		RecepientProfile[0] = PersonalProfile(TEXT("581"));
		RecipientsBehavior[0].dwJobType = JT_SIMPLE_SEND;
		RecepientProfile[1] = PersonalProfile(TEXT("444"));
		RecipientsBehavior[1].dwJobType = JT_SIMPLE_SEND;
		RecepientProfile[2] = PersonalProfile(TEXT("7231"));
		RecipientsBehavior[2].dwJobType = JT_SIMPLE_SEND;
/*		RecepientProfile[3] = PersonalProfile(TEXT("584"));
		RecipientsBehavior[3].dwJobType = JT_SIMPLE_SEND;
		RecepientProfile[4] = PersonalProfile(TEXT("585"));
		RecipientsBehavior[4].dwJobType = JT_SIMPLE_SEND;
		RecepientProfile[5] = PersonalProfile(TEXT("586"));
		RecipientsBehavior[5].dwJobType = JT_RANDOM_ABORT;
		RecepientProfile[6] = PersonalProfile(TEXT("587"));
		RecipientsBehavior[6].dwJobType = JT_RANDOM_PAUSE;
		RecipientsBehavior[6].dwParam1 = 3;
		RecepientProfile[7] = PersonalProfile(TEXT("588"));
		RecipientsBehavior[7].dwJobType = JT_SIMPLE_SEND;
		RecepientProfile[8] = PersonalProfile(TEXT("589"));
		RecipientsBehavior[8].dwJobType = JT_RANDOM_ABORT;
		RecepientProfile[9] = PersonalProfile(TEXT("581"));
		RecipientsBehavior[9].dwJobType = JT_SIMPLE_SEND;
		RecepientProfile[10] = PersonalProfile(TEXT("586"));
		RecipientsBehavior[10].dwJobType = JT_RANDOM_PAUSE;
		RecepientProfile[11] = PersonalProfile(TEXT("587"));
		RecipientsBehavior[11].dwJobType = JT_ABORT_PAGE;
		RecipientsBehavior[11].dwParam1 = 1;
		RecepientProfile[12] = PersonalProfile(TEXT("588"));
		RecipientsBehavior[12].dwJobType = JT_SIMPLE_SEND;
		RecepientProfile[13] = PersonalProfile(TEXT("589"));
		RecipientsBehavior[13].dwJobType = JT_SIMPLE_SEND;
		RecepientProfile[14] = PersonalProfile(TEXT("590"));
		RecipientsBehavior[14].dwJobType = JT_RANDOM_PAUSE;
		RecepientProfile[15] = PersonalProfile(TEXT("591"));
		RecipientsBehavior[15].dwJobType = JT_ABORT_PAGE;
		RecipientsBehavior[15].dwParam1 = 2;
		RecepientProfile[16] = PersonalProfile(TEXT("593"));
		RecipientsBehavior[16].dwJobType = JT_RANDOM_ABORT;
		RecepientProfile[17] = PersonalProfile(TEXT("581"));
		RecipientsBehavior[17].dwJobType = JT_RANDOM_PAUSE;
		
		RecepientProfile[18] = PersonalProfile(TEXT("582"));
		RecipientsBehavior[18].dwJobType = JT_ABORT_PAGE;
		RecipientsBehavior[18].dwParam1 = 1;
		RecepientProfile[19] = PersonalProfile(TEXT("583"));
		RecipientsBehavior[19].dwJobType = JT_SIMPLE_SEND;
		RecepientProfile[20] = PersonalProfile(TEXT("584"));
		RecipientsBehavior[20].dwJobType = JT_SIMPLE_SEND;
		RecepientProfile[21] = PersonalProfile(TEXT("585"));
		RecipientsBehavior[21].dwJobType = JT_RANDOM_PAUSE;
		RecepientProfile[22] = PersonalProfile(TEXT("588"));
		RecipientsBehavior[22].dwJobType = JT_ABORT_PAGE;
		RecipientsBehavior[22].dwParam1 = 2;
		RecepientProfile[23] = PersonalProfile(TEXT("589"));
		RecipientsBehavior[23].dwJobType = JT_RANDOM_ABORT;
		RecepientProfile[24] = PersonalProfile(TEXT("590"));
		RecipientsBehavior[24].dwJobType = JT_SIMPLE_SEND;

*/


		ListPersonalProfile RecepientProfileList(3, RecepientProfile);
		
		Jparams.pRecepientList = RecepientProfileList.GetData();
		Jparams.pSenderProfile = SenderProfile.GetData();
		Jparams.pRecipientsBehavior = RecipientsBehavior;
		
		DWORD dwAddRetVal;
		
		if(dwAddRetVal = pTest->AddMultiTypeJob(Jparams))
		{
			THROW_TEST_RUN_TIME_WIN32(dwAddRetVal, TEXT(" AddSimpleJobEx"));
		}

		Sleep(rand() % (6 * 60 * 1000));

		getchar();
	
	}
	catch(Win32Err& err)
	{
		::lgLogError(LOG_SEV_1, TEXT("Exception:%s."), err.Desc());
	}

  

	
	::lgEndCase();
	::lgEndSuite();
	::lgCloseLogger();  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\jobmngr\testcases\test2.cpp ===
#pragma warning(disable :4786)
// standard
#include <iostream>

// utilities
#include <testruntimeerr.h>
#include <params.h>

// project specific
#include <Defs.h>
#include <PrepareJobParams.cpp>
#include "..\CTestManager.h"
#include "..\CJobTypes.h"


void main(int argc,char** argv)
{
	CInput input(GetCommandLine());
	tstring tstrServerName;
	tstring tstrDocumentPath;

	if(input.IsExists(TEXT("d")))
	{
		tstrDocumentPath = input[TEXT("d")];
	}
	else
	{
		std::cout << "TstMng Usage:\n" <<
					 "/d:[fax file path] spaces in path are allowed do not use the \" char \n" <<
					 "/s:[server name] by default server is the local machine\n";
		exit(0);
	}

	if(input.IsExists(TEXT("s")))
	{
		tstrServerName = input[TEXT("s")];
	}

	::lgInitializeLogger();
	::lgBeginSuite(TEXT("Test2"));
	::lgBeginCase(0, TEXT("0"));

	CTestManager* pTest = NULL;	
	try
	{
		DWORD x_ComputerNameLenth = 256;//MAX_COMPUTERNAME_LENGTH;
		if(tstrServerName == TEXT(""))
		{
			TCHAR buffServerName[256];//[MAX_COMPUTERNAME_LENGTH + 1 ];
			if(!GetComputerName(buffServerName, &x_ComputerNameLenth))
			{
				THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT(" GetComputerName"));
			}
			tstrServerName = buffServerName;
		}
	
		// initialize test manager
		pTest = new CTestManager(tstrServerName);
		
		if(!pTest)
		{
			THROW_TEST_RUN_TIME_WIN32( ERROR_OUTOFMEMORY, TEXT(" Main, new CTestManager"));
		}

		JOB_PARAMS_EX Jparams;

		// prepare job params
		JobParamExNow JobParam( TEXT("test"));
			
		Jparams.pJobParam = JobParam.GetData();
		Jparams.szDocument = tstrDocumentPath.c_str();
		Jparams.pCoverpageInfo = NULL;
		Jparams.dwNumRecipients = 18;
			
		PersonalProfile SenderProfile(TEXT("585"));
		PersonalProfile RecepientProfile[25];
		JOB_BEHAVIOR RecipientsBehavior[25];
		RecepientProfile[0] = PersonalProfile(TEXT("581"));
		RecipientsBehavior[0].dwJobType = JT_RANDOM_PAUSE;
		RecepientProfile[1] = PersonalProfile(TEXT("444"));
		RecipientsBehavior[1].dwJobType = JT_ABORT_PAGE;
		RecipientsBehavior[1].dwParam1 = 2;
		RecepientProfile[2] = PersonalProfile(TEXT("7231"));
		RecipientsBehavior[2].dwJobType = JT_SIMPLE_SEND;
		RecepientProfile[3] = PersonalProfile(TEXT("7230"));
		RecipientsBehavior[3].dwJobType = JT_SIMPLE_SEND;
		RecepientProfile[4] = PersonalProfile(TEXT("582"));
		RecipientsBehavior[4].dwJobType = JT_SIMPLE_SEND;
		RecepientProfile[5] = PersonalProfile(TEXT("445"));
		RecipientsBehavior[5].dwJobType = JT_RANDOM_ABORT;
		RecepientProfile[6] = PersonalProfile(TEXT("586"));
		RecipientsBehavior[6].dwJobType = JT_RANDOM_PAUSE;
		RecipientsBehavior[6].dwParam1 = 4;
		RecepientProfile[7] = PersonalProfile(TEXT("7237"));
		RecipientsBehavior[7].dwJobType = JT_SIMPLE_SEND;
		RecepientProfile[8] = PersonalProfile(TEXT("444"));
		RecipientsBehavior[8].dwJobType = JT_RANDOM_ABORT;
		RecepientProfile[9] = PersonalProfile(TEXT("581"));
		RecipientsBehavior[9].dwJobType = JT_SIMPLE_SEND;
		RecepientProfile[10] = PersonalProfile(TEXT("7230"));
		RecipientsBehavior[10].dwJobType = JT_RANDOM_PAUSE;
		RecepientProfile[11] = PersonalProfile(TEXT("583"));
		RecipientsBehavior[11].dwJobType = JT_ABORT_PAGE;
		RecipientsBehavior[11].dwParam1 = 1;
		RecepientProfile[12] = PersonalProfile(TEXT("444"));
		RecipientsBehavior[12].dwJobType = JT_SIMPLE_SEND;
		RecepientProfile[13] = PersonalProfile(TEXT("7231"));
		RecipientsBehavior[13].dwJobType = JT_SIMPLE_SEND;
		RecepientProfile[14] = PersonalProfile(TEXT("444"));
		RecipientsBehavior[14].dwJobType = JT_RANDOM_PAUSE;
		RecepientProfile[15] = PersonalProfile(TEXT("581"));
		RecipientsBehavior[15].dwJobType = JT_ABORT_PAGE;
		RecipientsBehavior[15].dwParam1 = 2;
		RecepientProfile[16] = PersonalProfile(TEXT("7230"));
		RecipientsBehavior[16].dwJobType = JT_RANDOM_ABORT;
		RecepientProfile[17] = PersonalProfile(TEXT("581"));
		RecipientsBehavior[17].dwJobType = JT_RANDOM_ABORT;
		
		ListPersonalProfile RecepientProfileList(18, RecepientProfile);
		
		Jparams.pRecepientList = RecepientProfileList.GetData();
		Jparams.pSenderProfile = SenderProfile.GetData();
		Jparams.pRecipientsBehavior = RecipientsBehavior;
		
			
	
		DWORD dwAddRetVal;
		
		if(dwAddRetVal = pTest->AddMultiTypeJob(Jparams))
		{
			THROW_TEST_RUN_TIME_WIN32(dwAddRetVal, TEXT(" AddMultiTypeJob"));
		}

	
		while(1)
		{
			Sleep(6*60*1000);
			pTest->PrintJobsStatus();
		}
	//	Test.CancelAllFaxes();
		
		getchar();
	
	}
	catch(Win32Err& err)
	{
		::lgLogError(LOG_SEV_1, TEXT("Exception:%s."), err.Desc());
	}

  
	::lgEndCase();
	::lgEndSuite();
	::lgCloseLogger(); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\queuefunctionality\queuefax\qfax.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  qfax.c

Abstract:

  This module:
    1) Sends a fax
    2) Monitors the status of the fax

Author:

  Steven Kehrli (steveke) 8/28/1998

--*/

#include <stdio.h>
#include <winfax.h>
#include <wchar.h>

#define HELP_SWITCH_1        L"/?"
#define HELP_SWITCH_2        L"/H"
#define HELP_SWITCH_3        L"-?"
#define HELP_SWITCH_4        L"-H"
#define FAXNUMBER_SWITCH_1   L"/#:"
#define FAXNUMBER_SWITCH_2   L"-#:"
#define MULTIPLIER_SWITCH_1  L"/X:"
#define MULTIPLIER_SWITCH_2  L"-X:"
#define COVERPAGE_SWITCH_1   L"/C:"
#define COVERPAGE_SWITCH_2   L"-C:"
#define DOCUMENT_SWITCH_1    L"/D:"
#define DOCUMENT_SWITCH_2    L"-D:"

typedef struct _FAX_INFO {
    DWORD  dwFaxId;     // Fax job id
    DWORD  dwAttempt;   // Attempt number of the fax
    DWORD  dwDeviceId;  // Current device of the fax job
    BOOL   bComplete;   // Indicates the fax job is complete
    BOOL   bPass;       // Indicates the fax job was successful
} FAX_INFO, *PFAX_INFO;

// g_hProcessHeap is a global handle to the process heap
HANDLE  g_hProcessHeap = NULL;



LPVOID
MyMemAlloc(
    DWORD  dwBytes
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Allocates a block of memory from the process heap

Arguments:

  dwBytes - size, in bytes, of the block of memory

Return Value:

  LPVOID - pointer to the block of memory
  NULL if an error occurs

------------------------------------------------------------------------------*/
{
    if (g_hProcessHeap == NULL) {
        g_hProcessHeap = GetProcessHeap();

        if (g_hProcessHeap == NULL) {
            return NULL;
        }
    }

    return HeapAlloc(g_hProcessHeap, HEAP_ZERO_MEMORY, dwBytes);
}



BOOL
MyMemFree(
    LPVOID  lpMem
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Frees a block of memory from the process heap

Arguments:

  lpMem - pointer to the block of memory

Return Value:

  TRUE on success

------------------------------------------------------------------------------*/
{
    if (g_hProcessHeap == NULL) {
        g_hProcessHeap = GetProcessHeap();

        if (g_hProcessHeap == NULL) {
            return FALSE;
        }
    }

    return HeapFree(g_hProcessHeap, 0, lpMem);
}



VOID
LocalEcho(
    LPWSTR  szFormatString,
    ...
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Displays a string in stdout

Arguments:

  szFormatString - pointer to the string

Return Value:

  None

------------------------------------------------------------------------------*/
{
    va_list     varg_ptr;
    SYSTEMTIME  SystemTime;
    // szOutputBuffer is the output string
    WCHAR       szOutputBuffer[1024];

    // Initialize the buffer
    ZeroMemory(szOutputBuffer, sizeof(szOutputBuffer));

    // Retrieve the current time
    GetLocalTime(&SystemTime);
    wsprintf(szOutputBuffer, L"%02d.%02d.%04d@%02d:%02d:%02d.%03d:\n", SystemTime.wMonth, SystemTime.wDay, SystemTime.wYear, SystemTime.wHour, SystemTime.wMinute, SystemTime.wSecond, SystemTime.wMilliseconds);

    va_start(varg_ptr, szFormatString);
    _vsnwprintf(&szOutputBuffer[25], 999, szFormatString, varg_ptr);
    wprintf(L"%s\n", szOutputBuffer);
}



VOID
fnUsageInfo(
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Displays the usage info in stdout

Return Value:

  None

------------------------------------------------------------------------------*/
{
    wprintf(L"Faxes a document to a list of fax numbers.\n");
    wprintf(L"\n");
    wprintf(L"QFAX /#:fax number[;fax number...] [/X:number]\n");
    wprintf(L"     [/C:cover page[;cover page...]] /D:document[;document...]\n");
    wprintf(L"\n");
    wprintf(L"  /#:fax number[;fax number...]  Semi-colon delimited list of fax numbers.\n");
    wprintf(L"  /X:number                      Number of faxes to send per fax number.\n");
    wprintf(L"  /C:cover page[;cover page...]  Semi-colon delimited list of cover pages.\n");
    wprintf(L"  /D:document[;document...]      Semi-colon delimited list of documents.\n");
    wprintf(L"\n");
}



BOOL
fnIsPortValid(
    PFAX_PORT_INFO  pFaxPortsConfig,
    DWORD           dwNumFaxPorts,
    DWORD           dwDeviceId
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Determines if the port is valid

Arguments:

  pFaxPortsConfig - pointer to the fax ports configuration
  dwNumFaxPorts - number of fax ports
  dwDeviceId - port id

Return Value:

  TRUE on success

------------------------------------------------------------------------------*/
{
    // dwIndex is a counter to enumerate each fax port
    DWORD  dwIndex;

    for (dwIndex = 0; dwIndex < dwNumFaxPorts; dwIndex++) {
        // Search each fax port for the appropriate fax port
        if (pFaxPortsConfig[dwIndex].DeviceId == dwDeviceId) {
            return TRUE;
        }
    }

    return FALSE;
}



VOID
fnFindDeviceName(
    PFAX_PORT_INFO  pFaxPortsConfig,
    DWORD           dwNumFaxPorts,
    DWORD           dwDeviceId,
    LPWSTR          *pszDeviceName
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Finds the device name of a fax port

Arguments:

  pFaxPortsConfig - pointer to the fax ports configuration
  dwNumFaxPorts - number of fax ports
  dwDeviceId - fax port id
  pszDeviceName - device name

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // dwIndex is a counter to enumerate each fax port
    DWORD  dwIndex;

    // Set szDeviceName to NULL
    *pszDeviceName = NULL;

    for (dwIndex = 0; dwIndex < dwNumFaxPorts; dwIndex++) {
        // Search each fax port for the appropriate fax port
        if (pFaxPortsConfig[dwIndex].DeviceId == dwDeviceId) {
            if (pFaxPortsConfig[dwIndex].DeviceName) {
                *pszDeviceName = (LPWSTR) pFaxPortsConfig[dwIndex].DeviceName;
            }
            return;
        }
    }
}



VOID
fnSetFaxInfo(
    PFAX_INFO  pFaxInfo,
    DWORD      dwNumFaxes,
    DWORD      dwFaxId,
    DWORD      dwDeviceId,
    LPDWORD    pdwAttempt
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Sets the port id and attempt number of a fax

Arguments:

  pFaxInfo - pointer to the FAX_INFO structs
  dwNumFaxes - number of faxes
  dwFaxId - fax job id
  dwDeviceId - port id
  pdwAttempt - pointer to the attempt number

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // dwIndex is a counter to enumerate each FAX_INFO struct
    DWORD  dwIndex;

    // Set dwAttempt to 0
    *pdwAttempt = 0;

    for (dwIndex = 0; dwIndex < dwNumFaxes; dwIndex++) {
        // Search each FAX_INFO struct for the appropriate struct
        if (pFaxInfo[dwIndex].dwFaxId == dwFaxId) {
            // Set the port id
            pFaxInfo[dwIndex].dwDeviceId = dwDeviceId;

            // Set the attempt number
            pFaxInfo[dwIndex].dwAttempt++;
            *pdwAttempt = pFaxInfo[dwIndex].dwAttempt;
            return;
        }
    }
}



BOOL
fnGetFaxInfo(
    PFAX_INFO  pFaxInfo,
    DWORD      dwNumFaxes,
    DWORD      dwFaxId,
    LPDWORD    pdwAttempt
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Gets the attempt number of a fax

Arguments:

  pFaxInfo - pointer to the FAX_INFO structs
  dwNumFaxes - number of faxes
  dwFaxId - fax job id
  pdwAttempt - pointer to the attempt number

Return Value:

  TRUE on success

------------------------------------------------------------------------------*/
{
    // dwIndex is a counter to enumerate each FAX_INFO struct
    DWORD  dwIndex;

    // Set dwAttempt to 0
    *pdwAttempt = 0;

    for (dwIndex = 0; dwIndex < dwNumFaxes; dwIndex++) {
        // Search each FAX_INFO struct for the appropriate struct
        if (pFaxInfo[dwIndex].dwFaxId == dwFaxId) {
            // Set the attempt number
            *pdwAttempt = pFaxInfo[dwIndex].dwAttempt;
            return TRUE;
        }
    }

    return FALSE;
}



VOID
fnUpdateFaxInfoPass(
    PFAX_INFO  pFaxInfo,
    DWORD      dwNumFaxes,
    DWORD      dwFaxId
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Sets the complete and pass flags of a fax

Arguments:

  pFaxInfo - pointer to the FAX_INFO structs
  dwNumFaxes - number of faxes
  dwFaxId - fax job id

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // dwIndex is a counter to enumerate each FAX_INFO struct
    DWORD  dwIndex;

    for (dwIndex = 0; dwIndex < dwNumFaxes; dwIndex++) {
        // Search each FAX_INFO struct for the appropriate struct
        if (pFaxInfo[dwIndex].dwFaxId == dwFaxId) {
            // Set the port id
            pFaxInfo[dwIndex].dwDeviceId = 0;

            // Set the attempt number
            pFaxInfo[dwIndex].dwAttempt = 0;

            // Set the complete flag
            pFaxInfo[dwIndex].bComplete = TRUE;

            // Set the pass flag
            pFaxInfo[dwIndex].bPass = TRUE;

            return;
        }
    }
}



VOID
fnUpdateFaxInfoFail(
    PFAX_INFO  pFaxInfo,
    DWORD      dwNumFaxes,
    DWORD      dwFaxId
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Sets the complete flag of a fax

Arguments:

  pFaxInfo - pointer to the FAX_INFO structs
  dwNumFaxes - number of faxes
  dwFaxId - fax job id

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // dwIndex is a counter to enumerate each FAX_INFO struct
    DWORD    dwIndex;

    for (dwIndex = 0; dwIndex < dwNumFaxes; dwIndex++) {
        // Search each FAX_INFO struct for the appropriate struct
        if (pFaxInfo[dwIndex].dwFaxId == dwFaxId) {
            // Set the port id
            pFaxInfo[dwIndex].dwDeviceId = 0;

            // Set the attempt number
            pFaxInfo[dwIndex].dwAttempt = 0;

            // Set the complete flag
            pFaxInfo[dwIndex].bComplete = TRUE;

            // Set the pass flag
            pFaxInfo[dwIndex].bPass = FALSE;

            return;
        }
    }
}



BOOL
fnCompleteFaxInfo(
    PFAX_INFO  pFaxInfo,
    DWORD      dwNumFaxes
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Checks the complete flag of each fax

Arguments:

  pFaxInfo - pointer to the FAX_INFO structs
  dwNumFaxes - number of faxes

Return Value:

  TRUE on success

------------------------------------------------------------------------------*/
{
    // dwIndex is a counter to enumerate each FAX_INFO struct
    DWORD  dwIndex;

    for (dwIndex = 0; dwIndex < dwNumFaxes; dwIndex++) {
        // Search each FAX_INFO struct for the appropriate struct
        if (pFaxInfo[dwIndex].bComplete == FALSE) {
            return FALSE;
        }
    }

    return TRUE;
}



BOOL
fnFaxInfoResult(
    PFAX_INFO  pFaxInfo,
    DWORD      dwNumFaxes
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Checks the pass flag of each fax

Arguments:

  pFaxInfo - pointer to the FAX_INFO structs
  dwNumFaxes - number of faxes

Return Value:

  TRUE on success

------------------------------------------------------------------------------*/
{
    // dwIndex is a counter to enumerate each FAX_INFO struct
    DWORD  dwIndex;

    for (dwIndex = 0; dwIndex < dwNumFaxes; dwIndex++) {
        // Search each FAX_INFO struct for the appropriate struct
        if (pFaxInfo[dwIndex].bPass == FALSE) {
            return FALSE;
        }
    }

    return TRUE;
}



BOOL
fnFaxPrint(
    HANDLE   hFaxSvcHandle,
    LPWSTR   szFaxNumber,
    LPWSTR   szDocumentName,
    LPWSTR   szCoverPageName,
    LPDWORD  pdwFaxId
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Prints a fax

Arguments:

  hFaxSvcHandle - handle to the fax service
  szFaxNumber - fax number
  szDocumentName - document name
  szCoverPageName - cover page name
  pdwFaxId - pointer to the fax job id of the fax

Return Value:

  TRUE on success

------------------------------------------------------------------------------*/
{
    // FaxJobParams is the FAX_JOB_PARAM struct
    FAX_JOB_PARAM       FaxJobParams;
    // FaxCpInfo is the FAX_COVERPAGE_INFO struct
    FAX_COVERPAGE_INFO  FaxCpInfo;

    // Initialize the FAX_JOB_PARAM struct
    ZeroMemory(&FaxJobParams, sizeof(FAX_JOB_PARAM));

    // Set the FAX_JOB_PARAM struct
    FaxJobParams.SizeOfStruct = sizeof(FAX_JOB_PARAM);
    FaxJobParams.RecipientNumber = szFaxNumber;
    FaxJobParams.RecipientName = szFaxNumber;
    FaxJobParams.ScheduleAction = JSA_NOW;

    if (szCoverPageName != NULL) {
        // Initialize the FAX_COVERPAGE_INFO struct
        ZeroMemory(&FaxCpInfo, sizeof(FAX_COVERPAGE_INFO));

        // Set the FAX_COVERPAGE_INFO struct
        FaxCpInfo.SizeOfStruct = sizeof(FAX_COVERPAGE_INFO);
        FaxCpInfo.CoverPageName = szCoverPageName;
        FaxCpInfo.RecName = FaxJobParams.RecipientName;
        FaxCpInfo.RecFaxNumber = FaxJobParams.RecipientNumber;
        FaxCpInfo.Subject = szDocumentName;
        GetLocalTime(&FaxCpInfo.TimeSent);
    }

    if (szCoverPageName != NULL) {
        if (FaxSendDocument(hFaxSvcHandle, szDocumentName, &FaxJobParams, &FaxCpInfo, pdwFaxId) == FALSE) {
            return FALSE;
        }
    }
    else {
        if (FaxSendDocument(hFaxSvcHandle, szDocumentName, &FaxJobParams, NULL, pdwFaxId) == FALSE) {
            return FALSE;
        }
    }

    return TRUE;
}



VOID
fnPostExitToCompletionPort(
    HANDLE  hCompletionPort
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Post a completion packet to a completion port.  This packet indicates for the loop to exit.

Arguments:

  hCompletionPort - handle to the completion port

Return Value:

  None

------------------------------------------------------------------------------*/
{
    PFAX_EVENT  pFaxEvent;

    pFaxEvent = LocalAlloc(LPTR, sizeof(FAX_EVENT));
    if (pFaxEvent != NULL) {
        pFaxEvent->EventId = -1;

        PostQueuedCompletionStatus(hCompletionPort, sizeof(FAX_EVENT), 0, (LPOVERLAPPED) pFaxEvent);
    }
}

int _cdecl
wmain(
    INT   argc,
    WCHAR  *argvW[]
)
{
    // bFaxNumber indicates a fax number was found
    BOOL                bFaxNumber = FALSE;
    // szFaxNumbers is the list of fax numbers
    LPWSTR              szFaxNumbers = NULL;
    // szNextFaxNumber is the next fax number
    LPWSTR              szNextFaxNumber;
    // dwNumFaxNumbers is the number of fax numbers
    DWORD               dwNumFaxNumbers = 0;
    // dwCurFaxNumber is the current number of the fax numbers
    DWORD               dwCurFaxNumber;

    // bMultiplier indicates a multiplier was found
    BOOL                bMultiplier = FALSE;
    // dwNumFaxesPerFaxNumber is the number of faxes per fax number
    DWORD               dwNumFaxesPerFaxNumber = 0;
    // dwCurFax is the current number of faxes per fax number
    DWORD               dwCurFax;

    // bCoverPage indicates a cover page was found
    BOOL                bCoverPage = FALSE;
    // szCoverPageNames is the list of cover page names
    LPWSTR              szCoverPageNames = NULL;
    // szNextCoverPageName is the next cover page name
    LPWSTR              szNextCoverPageName;
    // dwNumCoverPages is the number of cover pages
    DWORD               dwNumCoverPages = 0;
    // dwCurCoverPage is the current number of the cover pages
    DWORD               dwCurCoverPage;

    // bDocument indicates a document was found
    BOOL                bDocument = FALSE;
    // szDocumentNames is the list of document name
    LPWSTR              szDocumentNames = NULL;
    // szNextDocumentName is the next document name
    LPWSTR              szNextDocumentName;
    // dwNumDocuments is the number of documents
    DWORD               dwNumDocuments = 0;
    // dwCurDocument is the current number of the documents
    DWORD               dwCurDocument = 0;

    // dwNumFaxes is the number of faxes
    DWORD               dwNumFaxes = 0;

    // wParamChar is a command line parameter character
    WCHAR               wParamChar;

    // hFaxSvcHandle is the handle to the fax service
    HANDLE              hFaxSvcHandle = NULL;
    // pFaxSvcConfig is a pointer to the fax service configuration
    PFAX_CONFIGURATION  pFaxSvcConfig = NULL;
    // pFaxPortsConfig is a pointer to the fax ports configuration
    PFAX_PORT_INFO      pFaxPortsConfig = NULL;
    // dwNumFaxPorts is the number of fax ports
    DWORD               dwNumFaxPorts;
    // dwNumAvailFaxPorts is the number of available fax ports
    DWORD               dwNumAvailFaxPorts;

    // hCompletionPort is a handle to the completion port
    HANDLE              hCompletionPort;
    // pFaxEvent is a pointer to the fax port event
    PFAX_EVENT          pFaxEvent;
    // szDeviceName is the device name
    LPWSTR              szDeviceName;
    DWORD               dwBytes;
    DWORD               dwCompletionKey;

    // pFaxInfo is a pointer to the FAX_INFO structs
    PFAX_INFO           pFaxInfo = NULL;

    // dwAttempt is the attempt number of the fax
    DWORD               dwAttempt;

    // iVal is the return value
    INT                 iVal = -1;

    // dwIndex is a counter
    DWORD               dwIndex = 0;

    for (dwIndex = 1; dwIndex < (DWORD) argc; dwIndex++) {
        if ((lstrcmpi(HELP_SWITCH_1, argvW[dwIndex]) == 0) || (lstrcmpi(HELP_SWITCH_2, argvW[dwIndex]) == 0) || (lstrcmpi(HELP_SWITCH_3, argvW[dwIndex]) == 0) || (lstrcmpi(HELP_SWITCH_4, argvW[dwIndex]) == 0)) {
            fnUsageInfo();
            goto ExitLevel0;
        }

        // Set wParamChar
        wParamChar = argvW[dwIndex][3];

        if (wParamChar != L'\0') {
            // Replace wParamChar
            argvW[dwIndex][3] = '\0';

            if ((bFaxNumber == FALSE) && ((lstrcmpi(FAXNUMBER_SWITCH_1, argvW[dwIndex]) == 0) || (lstrcmpi(FAXNUMBER_SWITCH_2, argvW[dwIndex]) == 0))) {
                // Reset wParamChar
                argvW[dwIndex][3] = wParamChar;

                // Set bFaxNumber to TRUE
                bFaxNumber = TRUE;

                // Get the fax numbers
                szFaxNumbers = &argvW[dwIndex][3];
                // Set szNextFaxNumber
                szNextFaxNumber = szFaxNumbers;

                do {
                    dwNumFaxNumbers++;

                    szNextFaxNumber = wcschr(szNextFaxNumber, L';');
                    if (szNextFaxNumber != NULL) {
                        *szNextFaxNumber = L'\0';
                        szNextFaxNumber++;
                    }
                } while (szNextFaxNumber != NULL);
            }
            else if ((bMultiplier == FALSE) && ((lstrcmpi(MULTIPLIER_SWITCH_1, argvW[dwIndex]) == 0) || (lstrcmpi(MULTIPLIER_SWITCH_2, argvW[dwIndex]) == 0))) {
                // Reset wParamChar
                argvW[dwIndex][3] = wParamChar;

                dwNumFaxesPerFaxNumber = _wtol(&argvW[dwIndex][3]);

                if (dwNumFaxesPerFaxNumber != 0) {
                    // Set bMultiplier to TRUE
                    bMultiplier = TRUE;
                }
            }
            else if ((bDocument == FALSE) && ((lstrcmpi(DOCUMENT_SWITCH_1, argvW[dwIndex]) == 0) || (lstrcmpi(DOCUMENT_SWITCH_2, argvW[dwIndex]) == 0))) {
                // Reset wParamChar
                argvW[dwIndex][3] = wParamChar;

                // Set bDocument to TRUE
                bDocument = TRUE;

                // Get the documents
                szDocumentNames = &argvW[dwIndex][3];
                // Set szNextDocumentName
                szNextDocumentName = szDocumentNames;

                do {
                    dwNumDocuments++;

                    szNextDocumentName = wcschr(szNextDocumentName, L';');
                    if (szNextDocumentName != NULL) {
                        *szNextDocumentName = L'\0';
                        szNextDocumentName++;
                    }
                } while (szNextDocumentName != NULL);
            }
            else if ((bCoverPage == FALSE) && ((lstrcmpi(COVERPAGE_SWITCH_1, argvW[dwIndex]) == 0) || (lstrcmpi(COVERPAGE_SWITCH_2, argvW[dwIndex]) == 0))) {
                // Reset wParamChar
                argvW[dwIndex][3] = wParamChar;

                // Set bCoverPage to TRUE
                bCoverPage = TRUE;

                // Get the cover pages
                szCoverPageNames = &argvW[dwIndex][3];
                // Set szNextCoverPageName
                szNextCoverPageName = szCoverPageNames;

                do {
                    dwNumCoverPages++;

                    szNextCoverPageName = wcschr(szNextCoverPageName, L';');
                    if (szNextCoverPageName != NULL) {
                        *szNextCoverPageName = L'\0';
                        szNextCoverPageName++;
                    }
                } while (szNextCoverPageName != NULL);
            }
        }
    }

    if ((bFaxNumber == FALSE) || (bDocument == FALSE)) {
        if (bFaxNumber == FALSE) {
            wprintf(L"The fax number is missing.  Use the %s switch.\n", FAXNUMBER_SWITCH_1);
        }

        if (bDocument == FALSE) {
            wprintf(L"The document is missing.  Use the %s switch.\n", DOCUMENT_SWITCH_1);
        }

        wprintf(L"\n");
        fnUsageInfo();
        goto ExitLevel0;
    }

    // Connect to the fax service
    if (FaxConnectFaxServer(NULL, &hFaxSvcHandle) == FALSE) {
        LocalEcho(L"Cannot connect to the fax service.  An error occurred: 0x%08x.\n", GetLastError());
        goto ExitLevel0;
    }

    // Retrieve the fax service configuration
    if (FaxGetConfiguration(hFaxSvcHandle, &pFaxSvcConfig) == FALSE) {
        LocalEcho(L"Cannot retrieve the fax service configuration.  An error occurred: 0x%08x.\n", GetLastError());
        goto ExitLevel1;
    }

    // Retrieve the fax ports configuration
    if (FaxEnumPorts(hFaxSvcHandle, &pFaxPortsConfig, &dwNumFaxPorts) == FALSE) {
        LocalEcho(L"Cannot retrieve the fax ports.  An error occurred: 0x%08x.\n", GetLastError());
        goto ExitLevel2;
    }

    // Retrieve the number of available fax ports
    for (dwIndex = 0, dwNumAvailFaxPorts = 0; dwIndex < dwNumFaxPorts; dwIndex++) {
        if (pFaxPortsConfig[dwIndex].Flags & FPF_SEND) {
            dwNumAvailFaxPorts++;
        }
    }

    if (dwNumAvailFaxPorts == 0) {
        LocalEcho(L"There are no fax ports enabled for send.\n");
        goto ExitLevel3;
    }

    // Create the completion port
    hCompletionPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 1);
    if (hCompletionPort == NULL) {
        LocalEcho(L"Cannot create the I/O completion port.  An error occurred: 0x%08x.\n", GetLastError());
        goto ExitLevel3;
    }

    // Initialize the fax event queue
    if (FaxInitializeEventQueue(hFaxSvcHandle, hCompletionPort, 0, NULL, 0) == FALSE) {
        LocalEcho(L"Cannot initialize the fax event queue.  An error occurred: 0x%08x.\n", GetLastError());
        goto ExitLevel4;
    }

    if (bMultiplier == 0) {
        dwNumFaxesPerFaxNumber = 1;
    }
    if (bCoverPage == FALSE) {
        dwNumCoverPages = 1;
    }
    dwNumFaxes = dwNumFaxesPerFaxNumber * dwNumCoverPages * dwNumDocuments * dwNumFaxNumbers;

    LocalEcho(L"Printing %d faxes.\n", dwNumFaxes);

    // Initialize the FAX_INFO structs
    pFaxInfo = MyMemAlloc(sizeof(FAX_INFO) * dwNumFaxes);

    if (pFaxInfo == NULL) {
        LocalEcho(L"Cannot allocate the fax information structures.  An error occurred: 0x%08x.\n", GetLastError());
        goto ExitLevel4;
    }

    for (dwCurFax = 0, dwIndex = 0; dwCurFax < dwNumFaxesPerFaxNumber; dwCurFax++) {
        // Get the first fax number
        szNextFaxNumber = szFaxNumbers;

        for (dwCurFaxNumber = 0; dwCurFaxNumber < dwNumFaxNumbers; dwCurFaxNumber++) {
            // Get the first document
            szNextDocumentName = szDocumentNames;

            for (dwCurDocument = 0; dwCurDocument < dwNumDocuments; dwCurDocument++) {
                // Get the first cover page
                szNextCoverPageName = szCoverPageNames;

                for (dwCurCoverPage = 0; dwCurCoverPage < dwNumCoverPages; dwCurCoverPage++) {
                    if (szNextCoverPageName != NULL) {
                        LocalEcho(L"Printing a fax:\n  Cover Page: %s.\n  Document: %s.\n  Fax Number: %s.\n", szNextCoverPageName, szNextDocumentName, szNextFaxNumber);
                    }
                    else {
                        LocalEcho(L"Printing a fax:\n  Document Name: %s\n  Fax Number: %s.\n", szNextDocumentName, szNextFaxNumber);
                    }

                    // Print the fax
                    if (fnFaxPrint(hFaxSvcHandle, szNextFaxNumber, szNextDocumentName, szNextCoverPageName, &pFaxInfo[dwIndex].dwFaxId) == FALSE) {
                        LocalEcho(L"Cannot print the fax.  An error occurred: 0x%08x.\n", GetLastError());
                    }
                    else {
                        LocalEcho(L"Printed a fax.  Job Id: %d.\n", pFaxInfo[dwIndex].dwFaxId);
                    }

                    dwIndex++;

                    // Get the next cover page
                    if (szNextCoverPageName != NULL) {
                        szNextCoverPageName += lstrlen(szNextCoverPageName) + 1;
                    }
                }

                // Get the next document
                szNextDocumentName += lstrlen(szNextDocumentName) + 1;
            }

            // Get the next fax number
            szNextFaxNumber += lstrlen(szNextFaxNumber) + 1;
        }
    }

    for (dwIndex = 0; dwIndex < dwNumFaxes; dwIndex++) {
        if (pFaxInfo[dwIndex].dwFaxId == 0) {
            // Set the complete flag
            pFaxInfo[dwIndex].bComplete = TRUE;

            // Set the pass flag
            pFaxInfo[dwIndex].bPass = FALSE;
        }
    }

    // Complete the fax info
    if (fnCompleteFaxInfo(pFaxInfo, dwNumFaxes) == TRUE) {
        fnPostExitToCompletionPort(hCompletionPort);
    }

    while (GetQueuedCompletionStatus(hCompletionPort, &dwBytes, &dwCompletionKey, (LPOVERLAPPED *) &pFaxEvent, INFINITE)) {

        if (pFaxEvent->EventId == -1) {
            // A completion packet was posted indicating for the loop to exit
            // Free the packet
            LocalFree(pFaxEvent);
            break;
        }

        if (pFaxEvent->EventId == FEI_FAXSVC_ENDED) {
            LocalEcho(L"The fax service stopped.\n");

            // Free the packet
            LocalFree(pFaxEvent);
            break;
        }

        if (pFaxEvent->EventId == FEI_FAXSVC_STARTED) {
            LocalEcho(L"The fax service started.\n");

            // Free the packet
            LocalFree(pFaxEvent);
            continue;
        }

        if (pFaxEvent->EventId == FEI_MODEM_POWERED_OFF) {
            // Find the device name
            fnFindDeviceName(pFaxPortsConfig, dwNumFaxPorts, pFaxEvent->DeviceId, &szDeviceName);
            LocalEcho(L"The fax service received a LINE_CLOSE message for fax port: %s.\n", szDeviceName);

            // Free the packet
            LocalFree(pFaxEvent);

            // Decrement dwNumAvailFaxPorts
            dwNumAvailFaxPorts--;
            if (dwNumAvailFaxPorts == 0) {
                LocalEcho(L"There are no fax ports available.\n");
                break;
            }

            continue;
        }

        if (pFaxEvent->EventId == FEI_MODEM_POWERED_ON) {
            // Find the device name
            fnFindDeviceName(pFaxPortsConfig, dwNumFaxPorts, pFaxEvent->DeviceId, &szDeviceName);
            LocalEcho(L"The fax service received a LINE_OPEN message for fax port: %s.\n", szDeviceName);

            // Free the packet
            LocalFree(pFaxEvent);

            // Increment dwNumAvailFaxPorts
            dwNumAvailFaxPorts++;

            continue;
        }

        if (fnIsPortValid(pFaxPortsConfig, dwNumFaxPorts, pFaxEvent->DeviceId) == FALSE) {
            // Free the packet
            LocalFree(pFaxEvent);
            continue;
        }

        // Find the device name
        fnFindDeviceName(pFaxPortsConfig, dwNumFaxPorts, pFaxEvent->DeviceId, &szDeviceName);

        switch (pFaxEvent->EventId) {
            case FEI_IDLE:
                // Complete the fax info
                if (fnCompleteFaxInfo(pFaxInfo, dwNumFaxes) == TRUE) {
                    fnPostExitToCompletionPort(hCompletionPort);
                }
                LocalEcho(L"Fax Port: %s: Idle.\n", szDeviceName);
                break;

            case FEI_DIALING:
                // Set the fax info
                fnSetFaxInfo(pFaxInfo, dwNumFaxes, pFaxEvent->JobId, pFaxEvent->DeviceId, &dwAttempt);
                LocalEcho(L"Fax Port: %s: Dialing.  Job Id: %d, Attempt #%d.\n", szDeviceName, pFaxEvent->JobId, dwAttempt);
                break;

            case FEI_NO_DIAL_TONE:
                // Get the fax info
                if (fnGetFaxInfo(pFaxInfo, dwNumFaxes, pFaxEvent->JobId, &dwAttempt) == TRUE) {
                    if (dwAttempt < (pFaxSvcConfig->Retries + 1)) {
                        LocalEcho(L"Fax Port: %s: No Dial Tone, Retry.\n", szDeviceName);
                    }
                    else {
                        // Update the fax info
                        fnUpdateFaxInfoFail(pFaxInfo, dwNumFaxes, pFaxEvent->JobId);
                        LocalEcho(L"Fax Port: %s: No Dial Tone, Abort.\n", szDeviceName);
                    }
                }
                else {
                    LocalEcho(L"Fax Port: %s: No Dial Tone.\n", szDeviceName);
                }
                break;

            case FEI_BUSY:
                // Get the fax info
                if (fnGetFaxInfo(pFaxInfo, dwNumFaxes, pFaxEvent->JobId, &dwAttempt) == TRUE) {
                    if (dwAttempt < (pFaxSvcConfig->Retries + 1)) {
                        LocalEcho(L"Fax Port: %s: Busy, Retry.\n", szDeviceName);
                    }
                    else {
                        // Update the fax info
                        fnUpdateFaxInfoFail(pFaxInfo, dwNumFaxes, pFaxEvent->JobId);
                        LocalEcho(L"Fax Port: %s: Busy, Abort.\n", szDeviceName);
                    }
                }
                else {
                    LocalEcho(L"Fax Port: %s: Busy.\n", szDeviceName);
                }
                break;

            case FEI_NO_ANSWER:
                // Get the fax info
                if (fnGetFaxInfo(pFaxInfo, dwNumFaxes, pFaxEvent->JobId, &dwAttempt) == TRUE) {
                    if (dwAttempt < (pFaxSvcConfig->Retries + 1)) {
                        LocalEcho(L"Fax Port: %s: No Answer, Retry.\n", szDeviceName);
                    }
                    else {
                        // Update the fax info
                        fnUpdateFaxInfoFail(pFaxInfo, dwNumFaxes, pFaxEvent->JobId);
                        LocalEcho(L"Fax Port: %s: No Answer, Abort.\n", szDeviceName);
                    }
                }
                else {
                    LocalEcho(L"Fax Port: %s: No Answer.\n", szDeviceName);
                }
                break;

            case FEI_FATAL_ERROR:
                // Get the fax info
                if (fnGetFaxInfo(pFaxInfo, dwNumFaxes, pFaxEvent->JobId, &dwAttempt) == TRUE) {
                    if (dwAttempt < (pFaxSvcConfig->Retries + 1)) {
                        LocalEcho(L"Fax Port: %s: Unknown Fatal Error, Retry.\n", szDeviceName);
                    }
                    else {
                        // Update the fax info
                        fnUpdateFaxInfoFail(pFaxInfo, dwNumFaxes, pFaxEvent->JobId);
                        LocalEcho(L"Fax Port: %s: Unknown Fatal Error, Abort.\n", szDeviceName);
                    }
                }
                else {
                    LocalEcho(L"Fax Port: %s: Unknown Fatal Error.\n", szDeviceName);
                }
                break;

            case FEI_SENDING:
                LocalEcho(L"Fax Port: %s: Sending.\n", szDeviceName);
                break;

            case FEI_COMPLETED:
                // Update the fax info
                fnUpdateFaxInfoPass(pFaxInfo, dwNumFaxes, pFaxEvent->JobId);
                LocalEcho(L"Fax Port: %s: Completed.\n", szDeviceName);
                break;

            case FEI_ABORTING:
                // Update the fax info
                fnUpdateFaxInfoFail(pFaxInfo, dwNumFaxes, pFaxEvent->JobId);
                LocalEcho(L"Fax Port: %s: Aborting.\n", szDeviceName);
                break;

            case FEI_DELETED:
                // Update the fax info
                fnUpdateFaxInfoFail(pFaxInfo, dwNumFaxes, pFaxEvent->JobId);
                LocalEcho(L"Fax Job: %d: Deleting.\n", pFaxEvent->JobId);
                break;

            default:
                LocalEcho(L"Fax Port: %s: Unexpected State: 0x%08x.\n", szDeviceName, pFaxEvent->EventId);
                break;
        }

        // Free the packet
        LocalFree(pFaxEvent);
    }

    // Compile the fax info result
    if (fnFaxInfoResult(pFaxInfo, dwNumFaxes) == TRUE) {
        iVal = 0;
    }

    // Free the FAX_INFO structs
    MyMemFree(pFaxInfo);

ExitLevel4:
    // Close the completion port
    CloseHandle(hCompletionPort);

ExitLevel3:
    // Free the fax ports configuration
    FaxFreeBuffer(pFaxPortsConfig);

ExitLevel2:
    // Free the fax service configuration
    FaxFreeBuffer(pFaxSvcConfig);

ExitLevel1:
    // Disconnect from the fax service
    FaxClose(hFaxSvcHandle);

ExitLevel0:
    return iVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\reconnectfaxservice\reconnect.cpp ===
#include <windows.h>
#include <winbase.h>
#include <stdio.h>
#include <stdlib.h>
#include <winfax.h>
#include <tchar.h>
#include <assert.h>

int _cdecl
main(
    int argc,
    char *argvA[]
    ) 
{
	HANDLE hFax = NULL;
	HANDLE hCompletionPort = INVALID_HANDLE_VALUE;
	DWORD dwBytes;
	DWORD CompletionKey;
	PFAX_EVENT FaxEvent;

	_tprintf( TEXT("Starting.\n") );

	while (TRUE)
	{
		//
		// connect to fax service
		//
		_tprintf( TEXT("Before FaxConnectFaxServer.\n") );
		if (!FaxConnectFaxServer(NULL,&hFax)) 
		{
			_tprintf( TEXT("ERROR: FaxConnectFaxServer failed, ec = %d\n"),GetLastError() );
			continue;
		}
		_tprintf( TEXT("FaxConnectFaxServer succeeded.\n") );

		assert (hFax != NULL);

		_tprintf( TEXT("Before CreateIoCompletionPort.\n") );
		hCompletionPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE,NULL,0,0);

		if (!hCompletionPort) 
		{
			_tprintf( TEXT("ERROR: CreateIoCompletionPort failed, ec = %d\n"), GetLastError() );
			FaxClose( hFax );
			continue;
		}
		_tprintf( TEXT("CreateIoCompletionPort succeeded.\n") );


		_tprintf( TEXT("Before FaxInitializeEventQueue.\n") );
		if (!FaxInitializeEventQueue(
			hFax,
			hCompletionPort,
			0,
			NULL, 
			0 ) 
			) 
		{
			_tprintf( TEXT("ERROR: FaxInitializeEventQueue failed, ec = %d\n"), GetLastError() );
			FaxClose( hFax );
			CloseHandle(hCompletionPort);
			continue;
		}
		_tprintf( TEXT("FaxInitializeEventQueue succeeded.\n") );

		while(TRUE)
		{
			if (!GetQueuedCompletionStatus(
					hCompletionPort,
					&dwBytes,
					&CompletionKey,
					(LPOVERLAPPED *)&FaxEvent,
					10000
					)
			   )
			{
				DWORD dwLastError = GetLastError();

				if (WAIT_TIMEOUT != dwLastError)
				{
					_tprintf( 
						TEXT("GetQueuedCompletionStatus() failed with %d\n"),
						dwLastError
						);
					FaxClose( hFax );
					CloseHandle(hCompletionPort);
					break;
				}

				_tprintf(TEXT("GetQueuedCompletionStatus() timeout out\n"));
			}
			else
			{
				if ((0xFFFFFFFF == FaxEvent->JobId) && (FEI_FAXSVC_ENDED == FaxEvent->EventId))
				{
					_tprintf(TEXT("FEI_FAXSVC_ENDED, reconnecting.\n"));
					//reconnect
					FaxClose( hFax );
					CloseHandle(hCompletionPort);
					break;
				}
				else
				{
					_tprintf(TEXT("FaxEvent->JobId=%d, FaxEvent->EventId=%d.\n"),FaxEvent->JobId , FaxEvent->EventId);
				}

			}
		}//while(TRUE)
		FaxClose( hFax );
		CloseHandle(hCompletionPort);

	}//while(TRUE)
	
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\servicemonitor\faxdevice.cpp ===
/*
	FaxDevice.cpp.
	This module encapsulates a fax device (port), for use by the 
	ServiceMonitor class. It is not generic enough for use by other components.
	The main methid is SetMessage(const int nEventId), that gets an event id
	from the fax service, that had its DeviceId member as this object does.
	This object then calls ::FaxGetPort() and (huristically) verifies the state
	of the object in relation to the nEventId, PFAX_PORT_INFO, and in relation
	to itself.
	The object also verifies timeouts of DIAL to SENDING, and RINGING to 
	ANSWERED.

	It asumes a single threaded application.












	written by Micky Snir (MickyS), October 26, 98.
*/
#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include <winfax.h>
#include <crtdbg.h>

#include "..\common\log\log.h"
#include "ServiceMonitor.h"

#include "FaxDevice.h"


//
// ctor.
// creates a fax port handle if needed.
// Gets the port data, and verifies state.
// 
CFaxDevice::CFaxDevice(
	const DWORD dwDeviceId, 
	CServiceMonitor *pServiceMonitor,
	const DWORD dwDisallowedStates
	):
	  m_dwDeviceId(dwDeviceId),
	  m_pServiceMonitor(pServiceMonitor),
	  m_pPortInfo(NULL),
	  m_fValidLastEvent(false),
	  m_dwDisallowedStates(dwDisallowedStates),
	  m_dwLastEvent(0),
	  m_FaxPortHandle(NULL),
	  m_dwStamp(__CFAX_DEVICE_STAMP)
{
	m_dwCreationTickCount = ::GetTickCount();

	//
	// we must have a pointer to our container
	//
	if (NULL == pServiceMonitor)
	{
		throw CException(
			TEXT("%s(%d): Device %d, CFaxDevice::CFaxDevice(): pServiceMonitor == NULL"), 
			TEXT(__FILE__), 
			__LINE__, 
			m_dwDeviceId
			);
	}

	//
	// get a fax port handle
	//
	if (!::FaxOpenPort(
			m_pServiceMonitor->m_hFax,       // handle to the fax server
			m_dwDeviceId,         // receiving device identifier
			PORT_OPEN_QUERY,            // set of port access level bit flags
			&m_FaxPortHandle  // fax port handle
			)
	   )
	{
		DWORD dwLastError = ::GetLastError();
		switch (dwLastError)
		{
		//BUGBUG: is it an error?
		case ERROR_INVALID_PARAMETER:
			::lgLogError(
				LOG_SEV_1, 
				TEXT("%s(%d): ::FaxOpenPort(%d) failed with ERROR_INVALID_PARAMETER, Device has probably been deleted"), 
				TEXT(__FILE__), 
				__LINE__, 
				m_dwDeviceId
				);
			throw CException(
				TEXT("%s(%d): ::FaxOpenPort(%d) failed with ERROR_INVALID_PARAMETER, Device has probably been deleted"), 
				TEXT(__FILE__), 
				__LINE__, 
				m_dwDeviceId
				);
			break;

		//valid condition: fax server went down
		case RPC_S_CALL_FAILED:
		case RPC_S_SERVER_UNAVAILABLE:
			pServiceMonitor->SetFaxServiceWentDown();
			throw CException(
				TEXT("%s(%d): ::FaxOpenPort(%d) failed with RPC_S_ error %d, probably because the fax service is shutting down"), 
				TEXT(__FILE__), 
				__LINE__, 
				m_dwDeviceId,
				dwLastError
				);
			break;

		//error
		default:
			::lgLogError(
				LOG_SEV_1, 
				TEXT("ERROR: ::FaxOpenPort(%d) failed, ec = %d"),
				m_dwDeviceId,
				dwLastError
				);
			throw CException(
				TEXT("%s(%d): ERROR: ::FaxOpenPort(%d) failed, ec = %d"), 
				TEXT(__FILE__), 
				__LINE__, 
				m_dwDeviceId, 
				dwLastError 
				);
		}//switch (dwLastError)
	}//if (!::FaxOpenPort

	if (NULL == m_FaxPortHandle)
	{
		throw CException(
			TEXT("%s(%d): Device %d, CFaxDevice::CFaxDevice(): ::FaxOpenPort() succeeded but m_FaxPortHandle == NULL"), 
			TEXT(__FILE__), 
			__LINE__, 
			m_dwDeviceId
			);
	}

	//
	// also verifies state
	//
	FaxGetPortWrapper();

	LogDeviceState(5);


	////////////////////////
	// impossible conditions
	////////////////////////
	CheckImpossibleConditions();

	/////////////////////////////
	// (all known to me) possible conditions
	/////////////////////////////
	CheckValidConditions();

	m_pServiceMonitor->IncDeviceCount();

}//CFaxDevice::CFaxDevice


//
// calls ::FaxGetPort(), remembers the PFAX_PORT_INFO, and verifies state
//
void CFaxDevice::FaxGetPortWrapper()
{
	if (m_pPortInfo) SAFE_FaxFreeBuffer(m_pPortInfo);

	if (!::FaxGetPort(
			m_FaxPortHandle,         // handle to the fax server
			&m_pPortInfo  // pointer to Device data structure
			)
	   )
	{
		DWORD dwLastError = ::GetLastError();
		switch (dwLastError)
		{
		//valid condition: port may have been removed dynamically
		case ERROR_INVALID_PARAMETER:
			throw CException(
				TEXT("%s(%d): ::FaxGetPort(%d) failed with ERROR_INVALID_PARAMETER, Device has probably been deleted"), 
				TEXT(__FILE__), 
				__LINE__, 
				m_dwDeviceId
				);
			break;

		//valid condition: fax server went down
		case RPC_S_CALL_FAILED:
		case RPC_S_SERVER_UNAVAILABLE:
			m_pServiceMonitor->SetFaxServiceWentDown();
			throw CException(
				TEXT("%s(%d): ::FaxGetPort(%d) failed with RPC_S_ error %d, probably because the fax service is shutting down"), 
				TEXT(__FILE__), 
				__LINE__, 
				m_dwDeviceId,
				dwLastError
				);
			break;

		//error
		default:
			::lgLogError(
				LOG_SEV_1, 
				TEXT("ERROR: ::FaxGetPort(%d) failed, ec = %d"),
				m_dwDeviceId,
				dwLastError
				);
			throw CException(
				TEXT("%s(%d): ERROR: ::FaxGetPort(%d) failed, ec = %d"), 
				TEXT(__FILE__), 
				__LINE__, 
				m_dwDeviceId, 
				dwLastError 
				);
		}//switch (dwLastError)
	}//if (!::FaxGetPort(

	VerifyDeviceId();

	VerifyLegalFlags();

	VerifyLegalState();
}

//
// ctor.
//
CFaxDevice::~CFaxDevice()
{
	AssertStamp();

	//
	// not good because I'm deleted also when ServiceMonitor ends
	//
	//_ASSERTE(IsDeletable());

	SAFE_FaxFreeBuffer(m_pPortInfo);
	m_dwStamp = 0;
	m_pServiceMonitor->DecDeviceCount();
}


bool CFaxDevice::SetMessage(const int nEventId)
{
	AssertStamp();

	FaxGetPortWrapper();

	//
	// verify that this event should come after the previous one
	//
	switch (nEventId) 
	{
	////////////////////////////////////////
	// events that must be with event id -1
	////////////////////////////////////////
	case FEI_INITIALIZING:
		::lgLogDetail(LOG_X, 8, TEXT("(%d) Device %d FEI_INITIALIZING"), ::GetTickCount(),m_dwDeviceId );
		VerifyThatLastEventIsOneOf(FEI_IDLE, nEventId);
		break;

	case FEI_IDLE:
		::lgLogDetail(LOG_X, 8, TEXT("(%d) Device %d FEI_IDLE"), ::GetTickCount(),m_dwDeviceId );
		VerifyThatLastEventIsOneOf(FEI_COMPLETED | FEI_IDLE, nEventId);
		break;

	case FEI_FAXSVC_STARTED:          
		::lgLogDetail(LOG_X, 0, TEXT("(%d) Device %d FEI_FAXSVC_STARTED"), ::GetTickCount(),m_dwDeviceId );
		VerifyThatLastEventIsOneOf(FEI_IDLE, nEventId);
		break;

	case FEI_FAXSVC_ENDED:     
		::lgLogDetail(LOG_X, 0, TEXT("(%d) Device %d FEI_FAXSVC_ENDED"), ::GetTickCount(),m_dwDeviceId );
		m_pServiceMonitor->SetFaxServiceWentDown();
		VerifyThatLastEventIsOneOf(0, nEventId);
		break;

	case FEI_MODEM_POWERED_ON: 
		::lgLogError(LOG_SEV_1, TEXT("(%d) this cannot be! Device %d FEI_MODEM_POWERED_ON"), ::GetTickCount(),m_dwDeviceId );
		break;

	case FEI_MODEM_POWERED_OFF:
		::lgLogError(LOG_SEV_1, TEXT("(%d) Device %d FEI_MODEM_POWERED_OFF"), ::GetTickCount(),m_dwDeviceId );
		break;

	case FEI_RINGING:          
		::lgLogDetail(LOG_X, 8, TEXT("(%d) Device %d FEI_RINGING"), ::GetTickCount(),m_dwDeviceId );
		VerifyThatLastEventIsOneOf(FEI_RINGING | FEI_IDLE, nEventId);
		if (FEI_RINGING != m_dwLastEvent) m_dwStartedRinging = ::GetTickCount();
		break;

	////////////////////////////////////////
	// events that may not have event id -1
	////////////////////////////////////////

	//must be a 1st event for this id
	case FEI_JOB_QUEUED:
		::lgLogDetail(LOG_X, 8, TEXT("(%d) >>>>>>Device %d FEI_JOB_QUEUED"), ::GetTickCount(),m_dwDeviceId );
		VerifyThatDeviceIdIs(-1, TEXT("After FEI_JOB_QUEUED"));
		break;

	//must be a 1st event for this id
	case FEI_ANSWERED:          
		::lgLogDetail(LOG_X, 8, TEXT("(%d) Device %d FEI_ANSWERED"), ::GetTickCount(),m_dwDeviceId );
		VerifyThatLastEventIsOneOf(FEI_RINGING, nEventId);
		VerifyThatDeviceIsCapableOf(FPF_RECEIVE, TEXT("FEI_ANSWERED"));
		LogTimeFromRingToAnswer(20000);
		break;

	case FEI_DIALING:          
		::lgLogDetail(LOG_X, 8, TEXT("(%d) Device %d FEI_DIALING"), ::GetTickCount(),m_dwDeviceId );
		VerifyThatLastEventIsOneOf(FEI_JOB_QUEUED | FEI_NO_ANSWER | FEI_BUSY, nEventId);
		VerifyThatDeviceIsCapableOf(FPF_SEND, TEXT("FEI_DIALING"));
		if (FEI_DIALING != m_dwLastEvent) m_dwStartedRinging = ::GetTickCount();
		break;

	case FEI_RECEIVING:              
		::lgLogDetail(LOG_X, 8, TEXT("(%d) Device %d FEI_RECEIVING"), ::GetTickCount(),m_dwDeviceId );
		VerifyThatDeviceIsCapableOf(FPF_RECEIVE, TEXT("FEI_RECEIVING"));
		VerifyThatLastEventIsOneOf(FEI_ANSWERED, nEventId);
		break;

	case FEI_COMPLETED:
		::lgLogDetail(LOG_X, 8, TEXT("(%d) Device %d FEI_COMPLETED"), ::GetTickCount(),m_dwDeviceId );
		VerifyThatLastEventIsOneOf(FEI_RECEIVING | FEI_SENDING, nEventId);
		VerifyThatDeviceIsCapableOf(FPF_SEND | FPF_RECEIVE, TEXT("FEI_COMPLETED"));
		break;

	case FEI_SENDING:          
		::lgLogDetail(LOG_X, 8, TEXT("(%d) Device %d FEI_SENDING"), ::GetTickCount(),m_dwDeviceId );
		VerifyThatLastEventIsOneOf(FEI_DIALING | FEI_SENDING, nEventId);
		VerifyThatDeviceIsCapableOf(FPF_SEND, TEXT("FEI_SENDING"));
		if (FEI_DIALING == m_dwLastEvent) LogTimeFromRingToDial(40000);
		break;

	case FEI_BUSY:             
		::lgLogDetail(LOG_X, 1, TEXT("(%d) Device %d FEI_BUSY"), ::GetTickCount(),m_dwDeviceId );
		VerifyThatLastEventIsOneOf(FEI_DIALING, nEventId);
		VerifyThatDeviceIsCapableOf(FPF_SEND, TEXT("FEI_BUSY"));
		break;

	case FEI_NO_ANSWER:        
		::lgLogDetail(LOG_X, 1, TEXT("(%d) Device %d FEI_NO_ANSWER"), ::GetTickCount(),m_dwDeviceId );
		VerifyThatLastEventIsOneOf(FEI_DIALING, nEventId);
		VerifyThatDeviceIsCapableOf(FPF_SEND, TEXT("FEI_NO_ANSWER"));
		break;

	case FEI_BAD_ADDRESS:      
		::lgLogDetail(LOG_X, 0, TEXT("(%d) ERROR: Device %d FEI_BAD_ADDRESS"), ::GetTickCount(),m_dwDeviceId );
		VerifyThatLastEventIsOneOf(FEI_DIALING, nEventId);
		VerifyThatDeviceIsCapableOf(FPF_SEND, TEXT("FEI_BAD_ADDRESS"));
		break;

	case FEI_NO_DIAL_TONE:     
		::lgLogError(LOG_SEV_1, TEXT("(%d) ERROR: Device %d FEI_NO_DIAL_TONE"), ::GetTickCount(),m_dwDeviceId );
		VerifyThatLastEventIsOneOf(FEI_DIALING, nEventId);
		VerifyThatDeviceIsCapableOf(FPF_SEND, TEXT("FEI_NO_DIAL_TONE"));
		break;

	case FEI_DISCONNECTED:           
		::lgLogDetail(LOG_X, 1, TEXT("(%d) Device %d FEI_DISCONNECTED"), ::GetTickCount(),m_dwDeviceId );
		VerifyThatLastEventIsOneOf(FEI_DIALING, nEventId);
		VerifyThatDeviceIsCapableOf(FPF_SEND | FPF_RECEIVE, TEXT("FEI_DISCONNECTED"));
		break;

	case FEI_FATAL_ERROR:      
		::lgLogDetail(LOG_X, 1, TEXT("(%d) Device %d: FEI_FATAL_ERROR"), ::GetTickCount(),m_dwDeviceId );
		VerifyThatLastEventIsOneOf(FEI_SENDING | FEI_RECEIVING, nEventId);
		VerifyThatDeviceIsCapableOf(FPF_SEND | FPF_RECEIVE, TEXT("FEI_FATAL_ERROR"));
		break;

	case FEI_NOT_FAX_CALL:          
		::lgLogDetail(LOG_X, 2, TEXT("(%d) ERROR: Device %d FEI_NOT_FAX_CALL"), ::GetTickCount(),m_dwDeviceId );
		VerifyThatLastEventIsOneOf(FEI_ANSWERED, nEventId);
		VerifyThatDeviceIsCapableOf(FPF_RECEIVE, TEXT("FEI_NOT_FAX_CALL"));
		break;

	case FEI_CALL_BLACKLISTED:          
		::lgLogError(LOG_SEV_1, TEXT("(%d) ERROR: Device %d FEI_CALL_BLACKLISTED"), ::GetTickCount(),m_dwDeviceId );
		VerifyThatLastEventIsOneOf(0, nEventId);
		VerifyThatDeviceIsCapableOf(FPF_SEND, TEXT("FEI_CALL_BLACKLISTED"));
		break;

	case FEI_HANDLED: 
		::lgLogDetail(LOG_X, 2, TEXT("(%d) ERROR: Device %d FEI_HANDLED"), ::GetTickCount(),m_dwDeviceId );
		VerifyThatLastEventIsOneOf(0, nEventId);
		VerifyThatDeviceIsCapableOf(FPF_SEND | FPF_RECEIVE, TEXT("FEI_HANDLED"));
		break;

	case FEI_LINE_UNAVAILABLE: 
		::lgLogError(LOG_SEV_1, TEXT("(%d) ERROR: Device %d FEI_LINE_UNAVAILABLE"), ::GetTickCount(),m_dwDeviceId );
		VerifyThatLastEventIsOneOf(0, nEventId);
		VerifyThatDeviceIsCapableOf(FPF_SEND | FPF_RECEIVE, TEXT("FEI_LINE_UNAVAILABLE"));
		break;

	case FEI_ABORTING:          
		::lgLogDetail(LOG_X, 1, TEXT("(%d) Device %d FEI_ABORTING"), ::GetTickCount(),m_dwDeviceId );
		VerifyThatLastEventIsOneOf(FEI_SENDING | FEI_RECEIVING, nEventId);
		VerifyThatDeviceIsCapableOf(FPF_SEND | FPF_RECEIVE, TEXT("FEI_ABORTING"));
		break;

	case FEI_ROUTING:          
		::lgLogDetail(LOG_X, 8, TEXT("(%d) Device %d FEI_ROUTING"), ::GetTickCount(),m_dwDeviceId );
		VerifyThatLastEventIsOneOf(0, nEventId);
		VerifyThatDeviceIsCapableOf(FPF_RECEIVE, TEXT("FEI_ROUTING"));
		break;

	case FEI_CALL_DELAYED:          
		::lgLogError(LOG_SEV_1, TEXT("(%d) Device %d FEI_CALL_DELAYED"), ::GetTickCount(),m_dwDeviceId );
		VerifyThatLastEventIsOneOf(0, nEventId);
		VerifyThatDeviceIsCapableOf(FPF_SEND, TEXT("FEI_CALL_DELAYED"));
		break;

	case FEI_DELETED: 
		::lgLogDetail(LOG_X, 8, TEXT("(%d) Device %d FEI_DELETED"), ::GetTickCount(),m_dwDeviceId );
		VerifyThatLastEventIsOneOf(FEI_COMPLETED | FEI_ABORTING, nEventId);
		VerifyThatDeviceIsCapableOf(FPF_SEND | FPF_RECEIVE, TEXT("FEI_DELETED"));
		break;

	case 0: //BUG#226290
		::lgLogError(LOG_SEV_1, TEXT("(%d) BUG#226290 Device %d got event=0"), ::GetTickCount(),m_dwDeviceId );
		break;

	default:
		::lgLogError(LOG_SEV_1, 
			TEXT("(%d) DEFAULT!!! Device %d reached default!, nEventId=%d"),
			::GetTickCount(),
			m_dwDeviceId, 
			nEventId 
			);
		return FALSE;

	}//switch (nEventId)

	m_dwLastEvent = nEventId;
	m_fValidLastEvent = true;

	return true;
}//bool CFaxDevice::SetMessage(const int nEventId)


//
// the conditions are huristic.
// each failure report by this method must be revised, and the method
// may need to be changed.
//
bool CFaxDevice::CheckValidConditions() const
{
	AssertStamp();

	bool fRetval = true;

	//TODO

	return fRetval;
}//CFaxDevice::CheckValidConditions


//
// the conditions are huristic.
// each failure report by this method must be revised, and the method
// may need to be changed.
//
bool CFaxDevice::CheckImpossibleConditions() const
{
	AssertStamp();

	bool fRetval = true;
	
	//TODO

	return fRetval;
}//CFaxDevice::CheckImpossibleConditions




void CFaxDevice::LogDeviceState(const int nLogLevel) const
{
	::lgLogDetail(LOG_X, nLogLevel, 
		TEXT("device(%d) m_pPortInfo->SizeOfStruct=%d"), m_dwDeviceId,m_pPortInfo->SizeOfStruct );
	::lgLogDetail(LOG_X, nLogLevel, 
		TEXT("device(%d) m_pPortInfo->DeviceId=%d"), m_dwDeviceId,m_pPortInfo->DeviceId );

	switch(m_pPortInfo->State)
	{
	case FPS_DIALING:
		::lgLogDetail(LOG_X, nLogLevel, TEXT("device(%d) State=FPS_DIALING"), m_dwDeviceId);
		break;

	case FPS_SENDING:
		::lgLogDetail(LOG_X, nLogLevel, TEXT("device(%d) State=FPS_SENDING"), m_dwDeviceId);
		break;

	case FPS_RECEIVING:
		::lgLogDetail(LOG_X, nLogLevel, TEXT("device(%d) State=FPS_RECEIVING"), m_dwDeviceId);
		break;

	case FPS_COMPLETED:
		::lgLogDetail(LOG_X, nLogLevel, TEXT("device(%d) State=FPS_COMPLETED"), m_dwDeviceId);
		break;

	case FPS_HANDLED:
		::lgLogDetail(LOG_X, nLogLevel, TEXT("device(%d) State=FPS_HANDLED"), m_dwDeviceId);
		break;

	case FPS_UNAVAILABLE:
		::lgLogDetail(LOG_X, nLogLevel, TEXT("device(%d) State=FPS_UNAVAILABLE"), m_dwDeviceId);
		break;

	case FPS_BUSY:
		::lgLogDetail(LOG_X, nLogLevel, TEXT("device(%d) State=FPS_BUSY"), m_dwDeviceId);
		break;

	case FPS_NO_ANSWER:
		::lgLogDetail(LOG_X, nLogLevel, TEXT("device(%d) State=FPS_NO_ANSWER"), m_dwDeviceId);
		break;

	case FPS_BAD_ADDRESS:
		::lgLogDetail(LOG_X, nLogLevel, TEXT("device(%d) State=FPS_BAD_ADDRESS"), m_dwDeviceId);
		break;

	case FPS_NO_DIAL_TONE:
		::lgLogDetail(LOG_X, nLogLevel, TEXT("device(%d) State=FPS_NO_DIAL_TONE"), m_dwDeviceId);
		break;

	case FPS_DISCONNECTED:
		::lgLogDetail(LOG_X, nLogLevel, TEXT("device(%d) State=FPS_DISCONNECTED"), m_dwDeviceId);
		break;

	case FPS_FATAL_ERROR:
		::lgLogDetail(LOG_X, nLogLevel, TEXT("device(%d) State=FPS_FATAL_ERROR"), m_dwDeviceId);
		break;

	case FPS_NOT_FAX_CALL:
		::lgLogDetail(LOG_X, nLogLevel, TEXT("device(%d) State=FPS_NOT_FAX_CALL"), m_dwDeviceId);
		break;

	case FPS_CALL_DELAYED:
		::lgLogDetail(LOG_X, nLogLevel, TEXT("device(%d) State=FPS_CALL_DELAYED"), m_dwDeviceId);
		break;

	case FPS_CALL_BLACKLISTED:
		::lgLogDetail(LOG_X, nLogLevel, TEXT("device(%d) State=FPS_CALL_BLACKLISTED"), m_dwDeviceId);
		break;

	case FPS_INITIALIZING:
		::lgLogDetail(LOG_X, nLogLevel, TEXT("device(%d) State=FPS_INITIALIZING"), m_dwDeviceId);
		break;

	case FPS_OFFLINE:
		::lgLogDetail(LOG_X, nLogLevel, TEXT("device(%d) State=FPS_OFFLINE"), m_dwDeviceId);
		break;

	case FPS_RINGING:
		::lgLogDetail(LOG_X, nLogLevel, TEXT("device(%d) State=FPS_RINGING"), m_dwDeviceId);
		break;

	case FPS_AVAILABLE:
		::lgLogDetail(LOG_X, nLogLevel, TEXT("device(%d) State=FPS_AVAILABLE"), m_dwDeviceId);
		break;

	case FPS_ABORTING:
		::lgLogDetail(LOG_X, nLogLevel, TEXT("device(%d) State=FPS_ABORTING"), m_dwDeviceId);
		break;

	case FPS_ROUTING:
		::lgLogDetail(LOG_X, nLogLevel, TEXT("device(%d) State=FPS_ROUTING"), m_dwDeviceId);
		break;

	case FPS_ANSWERED:
		::lgLogDetail(LOG_X, nLogLevel, TEXT("device(%d) State=FPS_ANSWERED"), m_dwDeviceId);
		break;

	case 0:
		::lgLogDetail(LOG_X, nLogLevel, TEXT("device(%d) State=0"), m_dwDeviceId);
		break;

	default:
		::lgLogError(LOG_SEV_1, TEXT("device(%d), illegal State=0x%08X"), m_dwDeviceId, m_pPortInfo->State);
		_ASSERTE(FALSE);
		break;

	}

	TCHAR szFlags[1024] = TEXT("");
	if (FPF_RECEIVE & m_pPortInfo->Flags)
	{
		::lstrcat(szFlags, TEXT("FPF_RECEIVE"));
	}
	if (FPF_SEND & m_pPortInfo->Flags)
	{
		::lstrcat(szFlags, TEXT(", FPF_SEND"));
	}
	if (FPF_VIRTUAL & m_pPortInfo->Flags)
	{
		::lstrcat(szFlags, TEXT(", FPF_VIRTUAL"));
	}
	::lgLogDetail(LOG_X, nLogLevel, 
		TEXT("device(%d) m_pPortInfo->Flags=%s"), m_dwDeviceId,szFlags );


	::lgLogDetail(LOG_X, nLogLevel, 
		TEXT("device(%d) m_pPortInfo->Rings=%d"), m_dwDeviceId,m_pPortInfo->Rings );
	::lgLogDetail(LOG_X, nLogLevel, 
		TEXT("device(%d) m_pPortInfo->Priority=%d"), m_dwDeviceId,m_pPortInfo->Priority );
	::lgLogDetail(LOG_X, nLogLevel, 
		TEXT("device(%d) m_pPortInfo->DeviceName=%s"), m_dwDeviceId,m_pPortInfo->DeviceName );
	::lgLogDetail(LOG_X, nLogLevel, 
		TEXT("device(%d) m_pPortInfo->Tsid=%s"), m_dwDeviceId,m_pPortInfo->Tsid );
	::lgLogDetail(LOG_X, nLogLevel, 
		TEXT("device(%d) m_pPortInfo->Csid=%s"), m_dwDeviceId,m_pPortInfo->Csid );

	::lgLogDetail(LOG_X, nLogLevel, TEXT(""));
}


void CFaxDevice::VerifyDeviceId() const
{
	if (m_dwDeviceId != m_pPortInfo->DeviceId)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("(m_dwDeviceId(%d) != m_pPortInfo->DeviceId(%d))"),
			m_dwDeviceId,
			m_pPortInfo->DeviceId
			);
	}
}


void CFaxDevice::VerifyLegalFlags() const
{
	if (m_pPortInfo->Flags & (~(FPF_RECEIVE | FPF_SEND | FPF_VIRTUAL)))
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("(m_pPortInfo->Flags(0x%08X) & (~(FPF_RECEIVE(0x%08X) | FPF_SEND(0x%08X) | FPF_VIRTUAL(0x%08X))))"), 
			m_pPortInfo->Flags,
			FPF_RECEIVE,
			FPF_SEND,
			FPF_VIRTUAL
			);
	}
}


void CFaxDevice::VerifyLegalState() const
{
	switch(m_pPortInfo->State)
	{
	case FPS_DIALING:
		if (FPS_DIALING & m_dwDisallowedStates)
		{
			::lgLogError(LOG_SEV_1, TEXT("Device(%d) - state FPS_DIALING is not allowed (0x%08X)"), m_dwDeviceId, FPS_DIALING);
		}
		break;

	case FPS_SENDING:
		if (FPS_SENDING & m_dwDisallowedStates)
		{
			::lgLogError(LOG_SEV_1, TEXT("Device(%d) - state FPS_SENDING is not allowed (0x%08X)"), m_dwDeviceId, FPS_SENDING);
		}
		break;

	case FPS_RECEIVING:
		if (FPS_RECEIVING & m_dwDisallowedStates)
		{
			::lgLogError(LOG_SEV_1, TEXT("Device(%d) - state FPS_RECEIVING is not allowed (0x%08X)"), m_dwDeviceId, FPS_RECEIVING);
		}
		break;

	case FPS_COMPLETED:
		if (FPS_COMPLETED & m_dwDisallowedStates)
		{
			::lgLogError(LOG_SEV_1, TEXT("Device(%d) - state FPS_COMPLETED is not allowed (0x%08X)"), m_dwDeviceId, FPS_COMPLETED);
		}
		break;

	case FPS_HANDLED:
		if (FPS_HANDLED & m_dwDisallowedStates)
		{
			::lgLogError(LOG_SEV_1, TEXT("Device(%d) - state FPS_HANDLED is not allowed (0x%08X)"), m_dwDeviceId, FPS_HANDLED);
		}
		break;

	case FPS_UNAVAILABLE:
		if (FPS_UNAVAILABLE & m_dwDisallowedStates)
		{
			::lgLogError(LOG_SEV_1, TEXT("Device(%d) - state FPS_UNAVAILABLE is not allowed (0x%08X)"), m_dwDeviceId, FPS_UNAVAILABLE);
		}
		break;

	case FPS_BUSY:
		if (FPS_BUSY & m_dwDisallowedStates)
		{
			::lgLogError(LOG_SEV_1, TEXT("Device(%d) - state FPS_BUSY is not allowed (0x%08X)"), m_dwDeviceId, FPS_BUSY);
		}
		break;

	case FPS_NO_ANSWER:
		if (FPS_NO_ANSWER & m_dwDisallowedStates)
		{
			::lgLogError(LOG_SEV_1, TEXT("Device(%d) - state FPS_NO_ANSWER is not allowed (0x%08X)"), m_dwDeviceId, FPS_NO_ANSWER);
		}
		break;

	case FPS_BAD_ADDRESS:
		if (FPS_BAD_ADDRESS & m_dwDisallowedStates)
		{
			::lgLogError(LOG_SEV_1, TEXT("Device(%d) - state FPS_BAD_ADDRESS is not allowed (0x%08X)"), m_dwDeviceId, FPS_BAD_ADDRESS);
		}
		break;

	case FPS_NO_DIAL_TONE:
		if (FPS_NO_DIAL_TONE & m_dwDisallowedStates)
		{
			::lgLogError(LOG_SEV_1, TEXT("Device(%d) - state FPS_NO_DIAL_TONE is not allowed (0x%08X)"), m_dwDeviceId, FPS_NO_DIAL_TONE);
		}
		break;

	case FPS_DISCONNECTED:
		if (FPS_DISCONNECTED & m_dwDisallowedStates)
		{
			::lgLogError(LOG_SEV_1, TEXT("Device(%d) - state FPS_DISCONNECTED is not allowed (0x%08X)"), m_dwDeviceId, FPS_DISCONNECTED);
		}
		break;

	case FPS_FATAL_ERROR:
		if (FPS_FATAL_ERROR & m_dwDisallowedStates)
		{
			::lgLogError(LOG_SEV_1, TEXT("Device(%d) - state FPS_FATAL_ERROR is not allowed (0x%08X)"), m_dwDeviceId, FPS_FATAL_ERROR);
		}
		break;

	case FPS_NOT_FAX_CALL:
		if (FPS_NOT_FAX_CALL & m_dwDisallowedStates)
		{
			::lgLogError(LOG_SEV_1, TEXT("Device(%d) - state FPS_NOT_FAX_CALL is not allowed (0x%08X)"), m_dwDeviceId, FPS_NOT_FAX_CALL);
		}
		break;

	case FPS_CALL_DELAYED:
		if (FPS_CALL_DELAYED & m_dwDisallowedStates)
		{
			::lgLogError(LOG_SEV_1, TEXT("Device(%d) - state FPS_CALL_DELAYED is not allowed (0x%08X)"), m_dwDeviceId, FPS_CALL_DELAYED);
		}
		break;

	case FPS_CALL_BLACKLISTED:
		if (FPS_CALL_BLACKLISTED & m_dwDisallowedStates)
		{
			::lgLogError(LOG_SEV_1, TEXT("Device(%d) - state FPS_CALL_BLACKLISTED is not allowed (0x%08X)"), m_dwDeviceId, FPS_CALL_BLACKLISTED);
		}
		break;

	case FPS_INITIALIZING:
		if (FPS_INITIALIZING & m_dwDisallowedStates)
		{
			::lgLogError(LOG_SEV_1, TEXT("Device(%d) - state FPS_INITIALIZING is not allowed (0x%08X)"), m_dwDeviceId, FPS_INITIALIZING);
		}
		break;

	case FPS_OFFLINE:
		if (FPS_OFFLINE & m_dwDisallowedStates)
		{
			::lgLogError(LOG_SEV_1, TEXT("Device(%d) - state FPS_OFFLINE is not allowed (0x%08X)"), m_dwDeviceId, FPS_OFFLINE);
		}
		break;

	case FPS_RINGING:
		if (FPS_RINGING & m_dwDisallowedStates)
		{
			::lgLogError(LOG_SEV_1, TEXT("Device(%d) - state FPS_RINGING is not allowed (0x%08X)"), m_dwDeviceId, FPS_RINGING);
		}
		break;

	case FPS_AVAILABLE:
		if (FPS_AVAILABLE & m_dwDisallowedStates)
		{
			::lgLogError(LOG_SEV_1, TEXT("Device(%d) - state FPS_AVAILABLE is not allowed (0x%08X)"), m_dwDeviceId, FPS_AVAILABLE);
		}
		break;

	case FPS_ABORTING:
		if (FPS_ABORTING & m_dwDisallowedStates)
		{
			::lgLogError(LOG_SEV_1, TEXT("Device(%d) - state FPS_ABORTING is not allowed (0x%08X)"), m_dwDeviceId, FPS_ABORTING);
		}
		break;

	case FPS_ROUTING:
		if (FPS_ROUTING & m_dwDisallowedStates)
		{
			::lgLogError(LOG_SEV_1, TEXT("Device(%d) - state FPS_ROUTING is not allowed (0x%08X)"), m_dwDeviceId, FPS_ROUTING);
		}
		break;

	case FPS_ANSWERED:
		if (FPS_ANSWERED & m_dwDisallowedStates)
		{
			::lgLogError(LOG_SEV_1, TEXT("Device(%d) - state FPS_ANSWERED is not allowed (0x%08X)"), m_dwDeviceId, FPS_ANSWERED);
		}
		break;

	case 0:
		::lgLogDetail(LOG_X, 0, TEXT("device(%d) State=0"), m_dwDeviceId);
		break;

	default:
		::lgLogError(LOG_SEV_1, TEXT("device(%d), illegal State=0x%08X"), m_dwDeviceId, m_pPortInfo->State);
		_ASSERTE(FALSE);
		break;

	}
}


bool CFaxDevice::VerifyThatLastEventIsOneOf(
	const DWORD dwExpectedPreviousEventsMask,
	const DWORD dwCurrentEventId
	) const
{
	AssertStamp();

	if (!m_fValidLastEvent) return true;

	if (! (dwExpectedPreviousEventsMask & m_dwLastEvent))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("(%d) Device %d: event 0x%08X did not come after these events 0x%08X, but after 0x%08X."),
			::GetTickCount(),
			m_dwDeviceId, 
			dwCurrentEventId,
			dwExpectedPreviousEventsMask,
			m_dwLastEvent
			);
		return false;
	}

	return true;
}

void CFaxDevice::VerifyThatDeviceIdIs(const DWORD dwDeviceId, LPCTSTR szDesc) const
{
	if (dwDeviceId != m_dwDeviceId)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("(%d) %s: (dwDeviceId(%d) != m_dwDeviceId(%d))"),
			::GetTickCount(),
			szDesc,
			dwDeviceId,
			m_dwDeviceId
			);
	}
}



void CFaxDevice::LogTimeFromRingToAnswer(const DWORD dwTimeout) const
{
	LogTimeItTook(TEXT("answer"), dwTimeout);
}

void CFaxDevice::LogTimeFromRingToDial(const DWORD dwTimeout) const
{
	LogTimeItTook(TEXT("dial"), dwTimeout);
}

void CFaxDevice::LogTimeItTook(LPCTSTR szDesc, const DWORD dwTimeout) const
{
	DWORD dwElapsed = m_pServiceMonitor->GetDiffTime(m_dwStartedRinging);
	if (dwTimeout < dwElapsed)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("(%d) device %d took %d msecs to %s, which is more than %d"),
			::GetTickCount(),
			m_dwDeviceId,
			dwElapsed,
			szDesc,
			dwTimeout
			);
		return;
	}

	::lgLogDetail(
		LOG_X,
		5,
		TEXT("(%d) device %d took %d msecs to %s"),
		::GetTickCount(),
		m_dwDeviceId,
		dwElapsed,
		szDesc
		);

}

void CFaxDevice::VerifyThatDeviceIsCapableOf(const DWORD dwFlags, LPCTSTR szDesc) const
{
	if (!(m_pPortInfo->Flags & dwFlags))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("(%d) device %d Flags(0x%08X) do not include (0x%08X) but got %s"),
			::GetTickCount(),
			m_dwDeviceId,
			m_pPortInfo->Flags,
			dwFlags,
			szDesc
			);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\servicemonitor\faxdevice.h ===
#ifndef __FAX_DEVICE_H
#define __FAX_DEVICE_H


#include <windows.h>

/*
	TODO: document here.
*/

class CServiceMonitor;


#define __CFAX_DEVICE_STAMP 0x028194637


#define SAFE_FaxFreeBuffer(pBuff) {::FaxFreeBuffer(pBuff); pBuff = NULL;}



class CFaxDevice
{
public:
	CFaxDevice(
	const DWORD dwDeviceId, 
	CServiceMonitor *pServiceMonitor,
	const DWORD dwErrorReporting
	);

	~CFaxDevice();

	bool SetMessage(const int nMessage);

	void AssertStamp() const {_ASSERTE(__CFAX_DEVICE_STAMP == m_dwStamp);}

	void LogDeviceState(const int nLogLevel = 5) const;

private:

	void FaxGetPortWrapper();

	void VerifyLegalFlags() const;

	void VerifyLegalState() const;

	void VerifyDeviceId() const;

	bool VerifyThatLastEventIsOneOf(
		const DWORD dwExpectedPreviousEventsMask,
		const DWORD dwCurrentEventId
		) const;

	void MarkMeForDeletion() { m_fDeleteMe = true; }

	bool IsMarkedForDeletion() const { return m_fDeleteMe; }

	bool CheckImpossibleConditions() const;

	bool CheckValidConditions() const;

	void VerifyThatDeviceIdIs(const DWORD dwDeviceId, LPCTSTR szDesc) const;

	void LogTimeFromRingToAnswer(const DWORD dwTimeout) const;

	void LogTimeFromRingToDial(const DWORD dwTimeout) const;

	void LogTimeItTook(LPCTSTR szDesc, const DWORD dwTimeout) const;

	void VerifyThatDeviceIsCapableOf(const DWORD dwFlags, LPCTSTR szDesc) const;



	bool m_fDeleteMe;

	DWORD m_dwStamp;

	DWORD m_dwDisallowedStates;

	//
	// originator or answerer
	//
	DWORD m_dwStartedRinging;
	//
	// CfaxJob(s) are usually contained within a CServiceMonitor,
	// and they need to notify it sometimes.
	//
	CServiceMonitor *m_pServiceMonitor;

	//
	// my id
	//
	DWORD m_dwDeviceId;

	DWORD m_dwLastEvent;

	bool m_fValidLastEvent;

	DWORD m_dwCreationTickCount;

	PFAX_PORT_INFO m_pPortInfo;

	HANDLE m_FaxPortHandle;

};

#endif //__FAX_DEVICE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\servicemonitor\faxjob.cpp ===
#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include <winfax.h>
#include <crtdbg.h>
#include <stdlib.h>

#include "..\common\log\log.h"
#include "ServiceMonitor.h"

#include "FaxJob.h"

CFaxJob::CFaxJob(
	const int nJobId, 
	CServiceMonitor *pServiceMonitor, 
	const DWORD dwBehavior, 
	const bool fSetLastEvent,
	const DWORD dwDisallowedEvents
	):
	  m_dwJobId(nJobId),
	  m_pServiceMonitor(pServiceMonitor),
	  m_fValidLastEvent(false),
	  m_dwLastEvent(0xffffffff),
	  m_pJobEntry(NULL),
	  m_dwStamp(__CFAX_JOB_STAMP),
	  m_fDeleteMe(false),
	  m_dwBehavior(dwBehavior),
	  m_fCommittedSuicide(false),
	  m_dwDisallowedEvents(dwDisallowedEvents),
	  m_dwDialingCount(0)
{
	if (NULL == pServiceMonitor)
	{
		throw CException(
			TEXT("%s(%d): job %d, CFaxJob::CFaxJob(): pServiceMonitor == NULL"), 
			TEXT(__FILE__), 
			__LINE__, 
			m_dwJobId
			);
	}

	if (!::FaxGetJob(
			m_pServiceMonitor->m_hFax,         // handle to the fax server
			m_dwJobId,              // fax job identifier
			&m_pJobEntry  // pointer to job data structure
			)
	   )
	{
		DWORD dwLastError = ::GetLastError();
		switch (dwLastError)
		{
		case ERROR_INVALID_PARAMETER:
			//
			// if these are general fax jobs, and not a specific job
			//
			if (0xffffffff == m_dwJobId)
			{
				// it's ok, it must fail;
				break;
			}
			else
			{
				//
				// do not log an error, this may happen, if jobs are meanwhile deleted
				//
				throw CException(
					TEXT("%s(%d): ::FaxGetJob(%d) failed with ERROR_INVALID_PARAMETER, job has probably been deleted"), 
					TEXT(__FILE__), 
					__LINE__, 
					m_dwJobId
					);
			}
			break;

		case RPC_S_CALL_FAILED:
		case RPC_S_SERVER_UNAVAILABLE:
			//
			// may happen if fax service is shutting down
			//
			pServiceMonitor->SetFaxServiceWentDown();
			throw CException(
				TEXT("%s(%d): ::FaxGetJob(%d) failed with RPC_S_ error %d, probably because the fax service is shutting down"), 
				TEXT(__FILE__), 
				__LINE__, 
				m_dwJobId,
				dwLastError
				);
			break;

		default:
			::lgLogError(
				LOG_SEV_1, 
				TEXT("ERROR: ::FaxGetJob(%d) failed, ec = %d"),
				m_dwJobId,
				dwLastError
				);
			throw CException(
				TEXT("%s(%d): ERROR: ::FaxGetJob(%d) failed, ec = %d"), 
				TEXT(__FILE__), 
				__LINE__, 
				m_dwJobId, 
				dwLastError 
				);
		}//switch (dwLastError)
	}
	else
	{
		//
		// these are general fax jobs, and not a specific job
		//
		if (0xffffffff == m_dwJobId)
		{
			SAFE_FaxFreeBuffer(m_pJobEntry);

			::lgLogError(
				LOG_SEV_1, 
				TEXT("%s(%d): job %d, CFaxJob::CFaxJob(): ::FaxGetJob() succeeded for id=-1"), 
				TEXT(__FILE__), 
				__LINE__, 
				m_dwJobId
				);
			throw CException(
				TEXT("%s(%d): job %d, CFaxJob::CFaxJob(): ::FaxGetJob() succeeded for id=-1"), 
				TEXT(__FILE__), 
				__LINE__, 
				m_dwJobId
				);
		}

		LogQueueStatus();

		LogJobType();

		LogStatus();
		
		LogScheduleAction();

		////////////////////////
		// impossible conditions
		////////////////////////
		CheckImpossibleConditions(m_pJobEntry->JobType, m_pJobEntry->Status, m_pJobEntry->QueueStatus);

		/////////////////////////////
		// (all known to me) possible conditions
		/////////////////////////////
		CheckValidConditions(
			m_pJobEntry->JobType, 
			m_pJobEntry->Status, 
			m_pJobEntry->QueueStatus, 
			fSetLastEvent
			);
	}

	m_pServiceMonitor->IncJobCount();

	return;
}//CFaxJob::CFaxJob



CFaxJob::~CFaxJob()
{
	AssertStamp();

	//
	// not good because I'm deleted also when ServiceMonitor ends
	//
	//_ASSERTE(IsDeletable());

	SAFE_FaxFreeBuffer(m_pJobEntry);
	m_dwStamp = 0;
	m_pServiceMonitor->DecJobCount();
}

void CFaxJob::VerifyThatJobIdIs0xFFFFFFFF(LPCTSTR szEvent) const 
{
	AssertStamp();

	if (0xFFFFFFFF != m_dwJobId)
	{
		::lgLogError(LOG_SEV_1, TEXT("(%d) JobId %d %s but JobId is not -1."), ::GetTickCount(),m_dwJobId, szEvent);
	}
}

void CFaxJob::VerifyThatJobIdIsNot0xFFFFFFFF(LPCTSTR szEvent) const 
{
	AssertStamp();

	if (0xFFFFFFFF == m_dwJobId)
	{
		::lgLogError(LOG_SEV_1, TEXT("(%d) JobId %d %s but JobId is not -1."), ::GetTickCount(),m_dwJobId, szEvent);
	}
}


bool CFaxJob::SetMessage(const int nEventId, const DWORD dwDeviceId)
{
	AssertStamp();

	if(m_fCommittedSuicide)
	{
		_ASSERTE(FJB_MAY_COMMIT_SUICIDE & m_dwBehavior);
	}

	if (FJB_MAY_COMMIT_SUICIDE & m_dwBehavior)
	{
		if (::rand()%20 == 1)
		{
			::lgLogDetail(
				LOG_X, 
				0, 
				TEXT("job %d, Committing suicide"),
				m_dwJobId
				);
			::Sleep(::rand()%1000);
			if (! ::FaxAbort(m_pServiceMonitor->m_hFax, m_dwJobId))
			{
				::lgLogDetail(
					LOG_X, 
					0, 
					TEXT("job %d, ::FaxAbort() failed with %d"),
					m_dwJobId,
					::GetLastError()
					);
			}
			else
			{
				if (-1 == m_dwJobId)
				{
					::lgLogError(
						LOG_SEV_1, 
						TEXT("ERROR: job -1, ::FaxAbort() succeeded.")
						);
				}
				else
				{
					m_fCommittedSuicide = true;
					::lgLogDetail(
						LOG_X, 
						0, 
						TEXT("******** job %d, ::FaxAbort() succeeded *******"),
						m_dwJobId
						);
				}
			}

		}//if (::rand()%20 == 1)

	}//if (FJB_MAY_COMMIT_SUICIDE & m_dwBehavior)

	//
	// verify that the state from ::FaxGetJob() is reasonable
	//
	if (0xffffffff != m_dwJobId)
	{
		PFAX_JOB_ENTRY pPrevJobEntry = m_pJobEntry;

		if (!::FaxGetJob(
				m_pServiceMonitor->m_hFax,         // handle to the fax server
				m_dwJobId,              // fax job identifier
				&m_pJobEntry  // pointer to job data structure
				)
		   )
		{
			DWORD dwLastError = ::GetLastError();
			switch (dwLastError)
			{
			case ERROR_INVALID_PARAMETER:
				//
				// next message is not necessarily a DELETED message,
				// since it may come only in a few messages
				//
				::lgLogDetail(
					LOG_X, 
					3, 
					TEXT("job %d: cannot ::FaxGetJob() last error ERROR_INVALID_PARAMETER."),
					m_dwJobId
					);

				MarkMeForDeletion();
				break;

			case RPC_S_CALL_FAILED:
			case RPC_S_SERVER_UNAVAILABLE:
				//
				// may happen if fax service is shutting down
				//
				m_pServiceMonitor->SetFaxServiceWentDown();
				::lgLogDetail(
					LOG_X, 
					3, 
					TEXT("%s(%d): ::FaxGetJob(%d) failed with RPC_S_ error %d, probably because the fax service is shutting down"), 
					TEXT(__FILE__), 
					__LINE__, 
					m_dwJobId,
					dwLastError
					);
				MarkMeForDeletion();
				break;

			default:
				::lgLogError(
					LOG_SEV_1, 
					TEXT("%s(%d): ERROR: nEventId=0x%02X, ::FaxGetJob(%d) failed, ec = %d"), 
					TEXT(__FILE__), 
					__LINE__,
					nEventId, 
					m_dwJobId, 
					::GetLastError() 
					);
			}//switch (dwLastError)

			m_pJobEntry = NULL;
		}
		else
		{
			::lgLogDetail(
				LOG_X, 
				0, 
				TEXT("------------------job %d, QueueStatus=0x%02X, JobType=0x%02X, Status=0x%02X, "),
				m_dwJobId,
				m_pJobEntry->QueueStatus,
				m_pJobEntry->JobType,
				m_pJobEntry->Status
				);

			VerifyCurrentJobEntry(pPrevJobEntry);

			LogQueueStatus();

			LogJobType();

			LogStatus();
			
			////////////////////////
			// impossible conditions
			////////////////////////
			CheckImpossibleConditions(m_pJobEntry->JobType, m_pJobEntry->Status, m_pJobEntry->QueueStatus);

			/////////////////////////////
			// (all known to me) possible conditions
			/////////////////////////////
			CheckValidConditions(m_pJobEntry->JobType, m_pJobEntry->Status, m_pJobEntry->QueueStatus, NULL);
		}

		if (pPrevJobEntry)
		{
			SAFE_FaxFreeBuffer(pPrevJobEntry);
			pPrevJobEntry = NULL;
		}
	}//if (0xffffffff != m_dwJobId)

	//
	// verify that this event should come after the previous one
	//
	switch (nEventId) 
	{
	////////////////////////////////////////
	// events that must be with event id -1
	////////////////////////////////////////
	case FEI_INITIALIZING:
		if (m_dwDisallowedEvents & nEventId) ::lgLogError(LOG_SEV_1, TEXT("(%d) JobId %d, Device %d FEI_INITIALIZING"), ::GetTickCount(),m_dwJobId, dwDeviceId );
		else ::lgLogDetail(LOG_X, 8, TEXT("(%d) JobId %d, Device %d FEI_INITIALIZING"), ::GetTickCount(),m_dwJobId, dwDeviceId );

		VerifyThatJobIdIs0xFFFFFFFF(TEXT("FEI_INITIALIZING"));
		VerifyThatLastEventIsOneOf(0, nEventId);//BUGBUG: replace ) with real number
		break;

	case FEI_IDLE:
		if (m_dwDisallowedEvents & nEventId) ::lgLogError(LOG_SEV_1, TEXT("(%d) JobId %d, Device %d FEI_IDLE"), ::GetTickCount(),m_dwJobId, dwDeviceId );
		else ::lgLogDetail(LOG_X, 8, TEXT("(%d) JobId %d, Device %d FEI_IDLE"), ::GetTickCount(),m_dwJobId, dwDeviceId );

		VerifyThatJobIdIs0xFFFFFFFF(TEXT("FEI_IDLE"));
		VerifyThatLastEventIsOneOf(FEI_FAXSVC_STARTED | FEI_COMPLETED, nEventId);
		break;

	case FEI_FAXSVC_STARTED:          
		if (m_dwDisallowedEvents & nEventId) ::lgLogError(LOG_SEV_1, TEXT("(%d) JobId %d, Device %d FEI_FAXSVC_STARTED"), ::GetTickCount(),m_dwJobId, dwDeviceId );
		else ::lgLogDetail(LOG_X, 8, TEXT("(%d) JobId %d, Device %d FEI_FAXSVC_STARTED"), ::GetTickCount(),m_dwJobId, dwDeviceId );
		
		VerifyThatJobIdIs0xFFFFFFFF(TEXT("FEI_FAXSVC_STARTED"));
		break;

	case FEI_FAXSVC_ENDED:     
		if (m_dwDisallowedEvents & nEventId) ::lgLogError(LOG_SEV_1, TEXT("(%d) JobId %d, Device %d FEI_FAXSVC_ENDED"), ::GetTickCount(),m_dwJobId, dwDeviceId );
		else ::lgLogDetail(LOG_X, 8, TEXT("(%d) JobId %d, Device %d FEI_FAXSVC_ENDED"), ::GetTickCount(),m_dwJobId, dwDeviceId );

		VerifyThatJobIdIs0xFFFFFFFF(TEXT("FEI_FAXSVC_ENDED"));
		m_pServiceMonitor->SetFaxServiceWentDown();
		break;

	case FEI_MODEM_POWERED_ON: 
		::lgLogError(LOG_SEV_1, TEXT("(%d) this cannot be! JobId %d, Device %d FEI_MODEM_POWERED_ON"), ::GetTickCount(),m_dwJobId, dwDeviceId );
		VerifyThatJobIdIs0xFFFFFFFF(TEXT("FEI_MODEM_POWERED_ON"));
		VerifyThatLastEventIsOneOf(0, nEventId);//BUGBUG: replace ) with real number
		break;

	case FEI_MODEM_POWERED_OFF:
		if (m_dwDisallowedEvents & nEventId) ::lgLogError(LOG_SEV_1, TEXT("(%d) JobId %d, Device %d FEI_MODEM_POWERED_OFF"), ::GetTickCount(),m_dwJobId, dwDeviceId );
		else ::lgLogDetail(LOG_X, 8, TEXT("(%d) JobId %d, Device %d FEI_MODEM_POWERED_OFF"), ::GetTickCount(),m_dwJobId, dwDeviceId );

		VerifyThatJobIdIs0xFFFFFFFF(TEXT("FEI_MODEM_POWERED_OFF"));
		break;

	case FEI_RINGING:          
		if (m_dwDisallowedEvents & nEventId) ::lgLogError(LOG_SEV_1, TEXT("(%d) JobId %d, Device %d FEI_RINGING"), ::GetTickCount(),m_dwJobId, dwDeviceId );
		else ::lgLogDetail(LOG_X, 8, TEXT("(%d) JobId %d, Device %d FEI_RINGING"), ::GetTickCount(),m_dwJobId, dwDeviceId );

		VerifyThatJobIdIs0xFFFFFFFF(TEXT("FEI_RINGING"));
		VerifyThatLastEventIsOneOf(FEI_FAXSVC_STARTED | FEI_RINGING, nEventId);//BUGBUG: replace ) with real number
		break;

	////////////////////////////////////////
	// events that may not have event id -1
	////////////////////////////////////////

	//must be a 1st event for this id
	case FEI_JOB_QUEUED:
		m_dwDialingCount = 0;
		if (m_dwDisallowedEvents & nEventId) ::lgLogError(LOG_SEV_1, TEXT("(%d) JobId %d, Device %d FEI_JOB_QUEUED"), ::GetTickCount(),m_dwJobId, dwDeviceId );
		else ::lgLogDetail(LOG_X, 8, TEXT("(%d) JobId %d, Device %d FEI_JOB_QUEUED"), ::GetTickCount(),m_dwJobId, dwDeviceId );

		VerifyThatJobIdIsNot0xFFFFFFFF(TEXT("FEI_JOB_QUEUED"));

		if (m_fValidLastEvent)
		{
			//
			// this cannot be! this job has just been queued!
			//
			::lgLogError(LOG_SEV_1, TEXT("(%d) >>>>>>JobId %d, Device %d FEI_JOB_QUEUED, but m_fValidLastEvent is true"), ::GetTickCount(),m_dwJobId, dwDeviceId );
		}

		m_fValidLastEvent = true;

		VerifyJobTypeIs(JT_SEND);

		break;

	//must be a 1st event for this id
	case FEI_ANSWERED:          
		if (m_dwDisallowedEvents & nEventId) ::lgLogError(LOG_SEV_1, TEXT("(%d) JobId %d, Device %d FEI_ANSWERED"), ::GetTickCount(),m_dwJobId, dwDeviceId );
		else ::lgLogDetail(LOG_X, 8, TEXT("(%d) JobId %d, Device %d FEI_ANSWERED"), ::GetTickCount(),m_dwJobId, dwDeviceId );

		VerifyThatJobIdIsNot0xFFFFFFFF(TEXT("FEI_ANSWERED"));

		if (m_fValidLastEvent)
		{
			//
			// this cannot be! this job has just been queued!
			//
			::lgLogError(LOG_SEV_1, TEXT("(%d) >>>>>>JobId %d, Device %d FEI_ANSWERED, but m_fValidLastEvent is true"), ::GetTickCount(),m_dwJobId, dwDeviceId );
		}

		m_fValidLastEvent = true;

		VerifyJobTypeIs(JT_RECEIVE);

		break;

	case FEI_DIALING:          
		if (m_dwDisallowedEvents & nEventId) ::lgLogError(LOG_SEV_1, TEXT("(%d) JobId %d, Device %d FEI_DIALING"), ::GetTickCount(),m_dwJobId, dwDeviceId );
		else ::lgLogDetail(LOG_X, 8, TEXT("(%d) JobId %d, Device %d FEI_DIALING"), ::GetTickCount(),m_dwJobId, dwDeviceId );

		VerifyThatJobIdIsNot0xFFFFFFFF(TEXT("FEI_DIALING"));
		VerifyThatLastEventIsOneOf(FEI_JOB_QUEUED | FEI_NO_ANSWER | FEI_BUSY, nEventId);

		VerifyJobTypeIs(JT_SEND);

		VerifyJobIsNotScheduledForFuture();

		//
		// count the number of times this job has dialed, and see that it does not exceed max retries.
		// Also verify that the elapes time from last dial is not less than RetryDelay.
		//
		if (FEI_DIALING != nEventId)
		{
			m_dwDialingCount++;
			if (m_dwDialingCount > 1)
			{
				if (m_pServiceMonitor->GetDiffTime(m_dwLastDialTickCount) < 1000 * m_pServiceMonitor->m_pFaxConfig->RetryDelay)
				{
					::lgLogError(
						LOG_SEV_1, 
						TEXT("ERROR: CFaxJob::SetMessage(): m_pServiceMonitor->GetDiffTime(m_dwLastDialTickCount)(%d) < 1000 * m_pServiceMonitor->m_pFaxConfig->RetryDelay(%d)"), 
						m_pServiceMonitor->GetDiffTime(m_dwLastDialTickCount), 
						1000 * m_pServiceMonitor->m_pFaxConfig->RetryDelay
						);
				}
			}

			m_dwLastDialTickCount = ::GetTickCount();

			if (m_dwDialingCount > m_pServiceMonitor->m_pFaxConfig->Retries)
			{
				::lgLogError(
					LOG_SEV_1, 
					TEXT("ERROR: CFaxJob::SetMessage(): m_dwDialingCount(%d) > m_pServiceMonitor->m_pFaxConfig->Retries(%d)"), 
					m_dwDialingCount, 
					m_pServiceMonitor->m_pFaxConfig->Retries
					);
			}

		}

		break;

	case FEI_RECEIVING:              
		if (m_dwDisallowedEvents & nEventId) ::lgLogError(LOG_SEV_1, TEXT("(%d) JobId %d, Device %d FEI_RECEIVING"), ::GetTickCount(),m_dwJobId, dwDeviceId );
		else ::lgLogDetail(LOG_X, 8, TEXT("(%d) JobId %d, Device %d FEI_RECEIVING"), ::GetTickCount(),m_dwJobId, dwDeviceId );

		VerifyThatJobIdIsNot0xFFFFFFFF(TEXT("FEI_RECEIVING"));
		VerifyThatLastEventIsOneOf(FEI_ANSWERED | FEI_RECEIVING, nEventId);

		VerifyJobTypeIs(JT_RECEIVE);

		break;

	case FEI_COMPLETED:
		if (m_dwDisallowedEvents & nEventId) ::lgLogError(LOG_SEV_1, TEXT("(%d) JobId %d, Device %d FEI_COMPLETED"), ::GetTickCount(),m_dwJobId, dwDeviceId );
		else ::lgLogDetail(LOG_X, 8, TEXT("(%d) JobId %d, Device %d FEI_COMPLETED"), ::GetTickCount(),m_dwJobId, dwDeviceId );

		VerifyThatJobIdIsNot0xFFFFFFFF(TEXT("FEI_COMPLETED"));
		VerifyThatLastEventIsOneOf(FEI_SENDING | FEI_RECEIVING, nEventId);
		VerifyBehaviorIsNot(FJB_MUST_FAIL);
		if(m_fCommittedSuicide)
		{
			::lgLogError(LOG_SEV_1,TEXT("(%d) ERROR: JobId %d, Device %d FEI_COMPLETED but m_fCommittedSuicide is true!"), ::GetTickCount(),m_dwJobId, dwDeviceId );
		}

		break;

	case FEI_SENDING:          
		if (m_dwDisallowedEvents & nEventId) ::lgLogError(LOG_SEV_1, TEXT("(%d) JobId %d, Device %d FEI_SENDING"), ::GetTickCount(),m_dwJobId, dwDeviceId );
		else ::lgLogDetail(LOG_X, 8, TEXT("(%d) JobId %d, Device %d FEI_SENDING"), ::GetTickCount(),m_dwJobId, dwDeviceId );

		VerifyThatJobIdIsNot0xFFFFFFFF(TEXT("FEI_SENDING"));
		VerifyThatLastEventIsOneOf(FEI_DIALING | FEI_SENDING, nEventId);

		VerifyJobTypeIs(JT_SEND);

		break;

	case FEI_BUSY:             
		if (m_dwDisallowedEvents & nEventId) ::lgLogError(LOG_SEV_1, TEXT("(%d) JobId %d, Device %d FEI_BUSY"), ::GetTickCount(),m_dwJobId, dwDeviceId );
		else ::lgLogDetail(LOG_X, 8, TEXT("(%d) JobId %d, Device %d FEI_BUSY"), ::GetTickCount(),m_dwJobId, dwDeviceId );

		VerifyThatJobIdIsNot0xFFFFFFFF(TEXT("FEI_BUSY"));
		VerifyThatLastEventIs(FEI_DIALING, nEventId);

		VerifyJobTypeIs(JT_SEND);
		VerifyBehaviorIsNot(FJB_MUST_SUCCEED);

		break;

	case FEI_NO_ANSWER:        
		if (m_dwDisallowedEvents & nEventId) ::lgLogError(LOG_SEV_1, TEXT("(%d) JobId %d, Device %d FEI_NO_ANSWER"), ::GetTickCount(),m_dwJobId, dwDeviceId );
		else ::lgLogDetail(LOG_X, 8, TEXT("(%d) JobId %d, Device %d FEI_NO_ANSWER"), ::GetTickCount(),m_dwJobId, dwDeviceId );

		VerifyThatJobIdIsNot0xFFFFFFFF(TEXT("FEI_NO_ANSWER"));
		VerifyThatLastEventIsOneOf(FEI_DIALING | FEI_NO_ANSWER, nEventId);

		VerifyJobTypeIs(JT_SEND);
		VerifyBehaviorIsNot(FJB_MUST_SUCCEED);

		break;

	case FEI_BAD_ADDRESS:      
		if (m_dwDisallowedEvents & nEventId) ::lgLogError(LOG_SEV_1, TEXT("(%d) JobId %d, Device %d FEI_BAD_ADDRESS"), ::GetTickCount(),m_dwJobId, dwDeviceId );
		else ::lgLogDetail(LOG_X, 8, TEXT("(%d) JobId %d, Device %d FEI_BAD_ADDRESS"), ::GetTickCount(),m_dwJobId, dwDeviceId );

		VerifyThatJobIdIsNot0xFFFFFFFF(TEXT("FEI_BAD_ADDRESS"));
		//
		//just to log the previous event, so that i'll put the right one when it happens
		//
		VerifyThatLastEventIs(0, nEventId);

		VerifyJobTypeIs(JT_SEND);
		VerifyBehaviorIsNot(FJB_MUST_SUCCEED);

		break;

	case FEI_NO_DIAL_TONE:     
		if (m_dwDisallowedEvents & nEventId) ::lgLogError(LOG_SEV_1, TEXT("(%d) JobId %d, Device %d FEI_NO_DIAL_TONE"), ::GetTickCount(),m_dwJobId, dwDeviceId );
		else ::lgLogDetail(LOG_X, 8, TEXT("(%d) JobId %d, Device %d FEI_NO_DIAL_TONE"), ::GetTickCount(),m_dwJobId, dwDeviceId );

		VerifyThatJobIdIsNot0xFFFFFFFF(TEXT("FEI_NO_DIAL_TONE"));
		VerifyThatLastEventIs(FEI_DIALING, nEventId);

		VerifyJobTypeIs(JT_SEND);
		VerifyBehaviorIsNot(FJB_MUST_SUCCEED);

		break;

	case FEI_DISCONNECTED:           
		if (m_dwDisallowedEvents & nEventId) ::lgLogError(LOG_SEV_1, TEXT("(%d) JobId %d, Device %d FEI_DISCONNECTED"), ::GetTickCount(),m_dwJobId, dwDeviceId );
		else ::lgLogDetail(LOG_X, 8, TEXT("(%d) JobId %d, Device %d FEI_DISCONNECTED"), ::GetTickCount(),m_dwJobId, dwDeviceId );

		VerifyThatJobIdIsNot0xFFFFFFFF(TEXT("FEI_DISCONNECTED"));
		VerifyThatLastEventIsOneOf(FEI_SENDING | FEI_RECEIVING, nEventId);

		VerifyJobTypeIs(JT_SEND);
		VerifyBehaviorIsNot(FJB_MUST_SUCCEED);

		break;

	case FEI_FATAL_ERROR:      
		if (m_dwDisallowedEvents & nEventId) ::lgLogError(LOG_SEV_1, TEXT("(%d) JobId %d, Device %d FEI_FATAL_ERROR"), ::GetTickCount(),m_dwJobId, dwDeviceId );
		else ::lgLogDetail(LOG_X, 8, TEXT("(%d) JobId %d, Device %d FEI_FATAL_ERROR"), ::GetTickCount(),m_dwJobId, dwDeviceId );

		VerifyThatJobIdIsNot0xFFFFFFFF(TEXT("FEI_FATAL_ERROR"));
		VerifyThatLastEventIsOneOf(FEI_SENDING | FEI_RECEIVING, nEventId);
		VerifyBehaviorIsNot(FJB_MUST_SUCCEED);
		break;

	case FEI_NOT_FAX_CALL:          
		if (m_dwDisallowedEvents & nEventId) ::lgLogError(LOG_SEV_1, TEXT("(%d) JobId %d, Device %d FEI_NOT_FAX_CALL"), ::GetTickCount(),m_dwJobId, dwDeviceId );
		else ::lgLogDetail(LOG_X, 8, TEXT("(%d) JobId %d, Device %d FEI_NOT_FAX_CALL"), ::GetTickCount(),m_dwJobId, dwDeviceId );

		VerifyThatJobIdIsNot0xFFFFFFFF(TEXT("FEI_NOT_FAX_CALL"));
		VerifyThatLastEventIs(FEI_RECEIVING, nEventId);

		VerifyJobTypeIs(JT_RECEIVE);
		VerifyBehaviorIsNot(FJB_MUST_SUCCEED);

		break;

	case FEI_CALL_BLACKLISTED: 
		if (m_dwDisallowedEvents & nEventId) ::lgLogError(LOG_SEV_1, TEXT("(%d) JobId %d, Device %d FEI_CALL_BLACKLISTED"), ::GetTickCount(),m_dwJobId, dwDeviceId );
		else ::lgLogDetail(LOG_X, 8, TEXT("(%d) JobId %d, Device %d FEI_CALL_BLACKLISTED"), ::GetTickCount(),m_dwJobId, dwDeviceId );

		VerifyThatJobIdIsNot0xFFFFFFFF(TEXT("FEI_CALL_BLACKLISTED"));
		//
		//just to log the previous event, so that i'll put the right one when it happens
		//
		VerifyThatLastEventIs(0, nEventId);
		VerifyBehaviorIsNot(FJB_MUST_SUCCEED);
		break;

	case FEI_HANDLED: 
		if (m_dwDisallowedEvents & nEventId) ::lgLogError(LOG_SEV_1, TEXT("(%d) JobId %d, Device %d FEI_HANDLED"), ::GetTickCount(),m_dwJobId, dwDeviceId );
		else ::lgLogDetail(LOG_X, 8, TEXT("(%d) JobId %d, Device %d FEI_HANDLED"), ::GetTickCount(),m_dwJobId, dwDeviceId );

		VerifyThatJobIdIsNot0xFFFFFFFF(TEXT("FEI_HANDLED"));
		//
		//just to log the previous event, so that i'll put the right one when it happens
		//
		VerifyThatLastEventIs(0, nEventId);
		VerifyBehaviorIsNot(FJB_MUST_SUCCEED);
		break;

	case FEI_LINE_UNAVAILABLE: 
		if (m_dwDisallowedEvents & nEventId) ::lgLogError(LOG_SEV_1, TEXT("(%d) JobId %d, Device %d FEI_LINE_UNAVAILABLE"), ::GetTickCount(),m_dwJobId, dwDeviceId );
		else ::lgLogDetail(LOG_X, 8, TEXT("(%d) JobId %d, Device %d FEI_LINE_UNAVAILABLE"), ::GetTickCount(),m_dwJobId, dwDeviceId );

		VerifyThatJobIdIsNot0xFFFFFFFF(TEXT("FEI_LINE_UNAVAILABLE"));
		//
		//just to log the previous event, so that i'll put the right one when it happens
		//
		VerifyThatLastEventIs(0, nEventId);
		VerifyBehaviorIsNot(FJB_MUST_SUCCEED);
		break;

	case FEI_ABORTING:          
		if (m_dwDisallowedEvents & nEventId) ::lgLogError(LOG_SEV_1, TEXT("(%d) JobId %d, Device %d FEI_ABORTING"), ::GetTickCount(),m_dwJobId, dwDeviceId );
		else ::lgLogDetail(LOG_X, 8, TEXT("(%d) JobId %d, Device %d FEI_ABORTING"), ::GetTickCount(),m_dwJobId, dwDeviceId );

		VerifyThatJobIdIsNot0xFFFFFFFF(TEXT("FEI_ABORTING"));
		VerifyThatLastEventIsOneOf(FEI_SENDING | FEI_RECEIVING, nEventId);
		VerifyBehaviorIsNot(FJB_MUST_SUCCEED);
		if (JT_SEND == m_pJobEntry->JobType)
		{
			VerifyBehaviorIncludes(FJB_MAY_BE_TX_ABORTED);
		}

		if (JT_RECEIVE == m_pJobEntry->JobType)
		{
			VerifyBehaviorIncludes(FJB_MAY_BE_RX_ABORTED);
		}

		break;

	case FEI_ROUTING:          
		if (m_dwDisallowedEvents & nEventId) ::lgLogError(LOG_SEV_1, TEXT("(%d) JobId %d, Device %d FEI_ROUTING"), ::GetTickCount(),m_dwJobId, dwDeviceId );
		else ::lgLogDetail(LOG_X, 8, TEXT("(%d) JobId %d, Device %d FEI_ROUTING"), ::GetTickCount(),m_dwJobId, dwDeviceId );

		VerifyThatJobIdIsNot0xFFFFFFFF(TEXT("FEI_ROUTING"));
		//
		//just to log the previous event, so that i'll put the right one when it happens
		//
		VerifyThatLastEventIs(0, nEventId);

		VerifyJobTypeIs(JT_ROUTING);

		break;

	case FEI_CALL_DELAYED:          
		if (m_dwDisallowedEvents & nEventId) ::lgLogError(LOG_SEV_1, TEXT("(%d) JobId %d, Device %d FEI_CALL_DELAYED"), ::GetTickCount(),m_dwJobId, dwDeviceId );
		else ::lgLogDetail(LOG_X, 8, TEXT("(%d) JobId %d, Device %d FEI_CALL_DELAYED"), ::GetTickCount(),m_dwJobId, dwDeviceId );

		VerifyThatJobIdIsNot0xFFFFFFFF(TEXT("FEI_CALL_DELAYED"));
		//
		//just to log the previous event, so that i'll put the right one when it happens
		//
		VerifyThatLastEventIs(0, nEventId);

		VerifyJobTypeIs(JT_SEND);
		VerifyBehaviorIsNot(FJB_MUST_SUCCEED);

		break;

	case FEI_DELETED: 
		m_dwDialingCount = 0;
		if (m_dwDisallowedEvents & nEventId) ::lgLogError(LOG_SEV_1, TEXT("(%d) JobId %d, Device %d FEI_DELETED"), ::GetTickCount(),m_dwJobId, dwDeviceId );
		else ::lgLogDetail(LOG_X, 8, TEXT("(%d) JobId %d, Device %d FEI_DELETED"), ::GetTickCount(),m_dwJobId, dwDeviceId );

		VerifyThatJobIdIsNot0xFFFFFFFF(TEXT("FEI_DELETED"));
		VerifyThatLastEventIsOneOf(FEI_COMPLETED | FEI_ABORTING, nEventId);
		MarkMeForDeletion();
		_ASSERTE(NULL == m_pJobEntry);
		break;

	case 0: //BUG#226290
		::lgLogError(LOG_SEV_1, TEXT("(%d) BUG#226290 JobId %d, Device %d got event=0"), ::GetTickCount(),m_dwJobId, dwDeviceId );
		break;

	default:
		::lgLogError(LOG_SEV_1, 
			TEXT("(%d) DEFAULT!!! JobId %d, Device %d reached default!, nEventId=%d"),
			::GetTickCount(),
			m_dwJobId,
			dwDeviceId,
			nEventId 
			);
		return FALSE;

	}//switch (nEventId)

	m_dwLastEvent = nEventId;

	return TRUE;
}

bool CFaxJob::VerifyThatLastEventIs(
	const DWORD dwExpectedPreviousEventId,
	const DWORD dwCurrentEventId
	) const 
{
	AssertStamp();

	if (dwExpectedPreviousEventId != m_dwLastEvent)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("(%d) JobId %d: event 0x%08X came after 0x%08X instead after 0x%08X."),
			::GetTickCount(),
			m_dwJobId, 
			dwCurrentEventId,
			m_dwLastEvent,
			dwExpectedPreviousEventId
			);
		return false;
	}

	return true;
}
bool CFaxJob::VerifyThatLastEventIsOneOf(
	const DWORD dwExpectedPreviousEventsMask,
	const DWORD dwCurrentEventId
	) const 
{
	AssertStamp();

	if (! (dwExpectedPreviousEventsMask & m_dwLastEvent))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("(%d) JobId %d: event 0x%08X did not come after these events 0x%08X, but after 0x%08X."),
			::GetTickCount(),
			m_dwJobId, 
			dwCurrentEventId,
			dwExpectedPreviousEventsMask,
			m_dwLastEvent
			);
		return false;
	}

	return true;
}

//
// the conditions are huristic.
// each failure report by this method must be revised, and the method
// may need to be changed.
//
bool CFaxJob::CheckValidConditions(
	const DWORD dwJobType, 
	const DWORD dwStatus, 
	const DWORD dwQueueStatus,
	const bool fSetLastEvent
	) 
{
	AssertStamp();

	bool fRetval = true;

	if (	(JS_NOLINE == m_pJobEntry->QueueStatus) && 
			(JT_SEND == m_pJobEntry->JobType) && 
			(0 == m_pJobEntry->Status)
			)
	{
		if (fSetLastEvent) m_dwLastEvent = FEI_JOB_QUEUED;
	}
	else if (	(JS_PENDING == m_pJobEntry->QueueStatus) && 
				(JT_SEND == m_pJobEntry->JobType) && 
				(0 == m_pJobEntry->Status)
				)
	{
		if (fSetLastEvent) m_dwLastEvent = FEI_JOB_QUEUED;
	}
	else if (	(JS_PENDING == m_pJobEntry->QueueStatus) && 
				(JT_ROUTING == m_pJobEntry->JobType) && 
				(0 == m_pJobEntry->Status)
				)
	{
		if (fSetLastEvent) m_dwLastEvent = FEI_ROUTING;
	}
	else if (	(JS_INPROGRESS == m_pJobEntry->QueueStatus) && 
				(JT_SEND == m_pJobEntry->JobType) && 
				(FPS_HANDLED == m_pJobEntry->Status)
				)
	{
		if (fSetLastEvent) m_dwLastEvent = FEI_JOB_QUEUED;
	}
	else if (	(JS_INPROGRESS == m_pJobEntry->QueueStatus) && 
				(JT_SEND == m_pJobEntry->JobType) && 
				(FPS_INITIALIZING == m_pJobEntry->Status)
				)
	{
		if (fSetLastEvent) m_dwLastEvent = FEI_JOB_QUEUED;
	}
	else if (	(JS_DELETING == m_pJobEntry->QueueStatus) && 
				(JT_SEND == m_pJobEntry->JobType) 
				//&& any device status
				)
	{
		if (fSetLastEvent) m_dwLastEvent = FEI_ABORTING;//is it?
	}
	else if (	(JS_INPROGRESS == m_pJobEntry->QueueStatus) && 
				(JT_SEND == m_pJobEntry->JobType) && 
				(FPS_AVAILABLE == m_pJobEntry->Status)
				)
	{
		if (fSetLastEvent) m_dwLastEvent = FEI_JOB_QUEUED;//is it?
	}
	else if (	(JS_INPROGRESS /*bug#231221, replace & with == */& m_pJobEntry->QueueStatus) && 
				(JT_SEND == m_pJobEntry->JobType) && 
				(FPS_DIALING == m_pJobEntry->Status)
				)
	{
		if (fSetLastEvent) m_dwLastEvent = FEI_DIALING;
	}
	else if (	(JS_INPROGRESS == m_pJobEntry->QueueStatus) && 
				(JT_SEND == m_pJobEntry->JobType) && 
				(FPS_BUSY == m_pJobEntry->Status)
				)
	{
		if (fSetLastEvent) m_dwLastEvent = FEI_BUSY;//is it?
	}
	else if (	(JS_INPROGRESS == m_pJobEntry->QueueStatus) && 
				(JT_SEND == m_pJobEntry->JobType) && 
				(FPS_NO_ANSWER == m_pJobEntry->Status)
				)
	{
		if (fSetLastEvent) m_dwLastEvent = FEI_NO_ANSWER;//is it?
	}
	else if (	(JS_INPROGRESS == m_pJobEntry->QueueStatus) && 
				(JT_SEND == m_pJobEntry->JobType) && 
				(FPS_SENDING == m_pJobEntry->Status)
				)
	{
		if (fSetLastEvent) m_dwLastEvent = FEI_SENDING;
	}
	else if (	(JS_INPROGRESS == m_pJobEntry->QueueStatus) && 
				(JT_SEND == m_pJobEntry->JobType) && 
				(FPS_FATAL_ERROR == m_pJobEntry->Status)
				)
	{
		if (fSetLastEvent) m_dwLastEvent = FEI_SENDING;
	}
	else if (	(JS_INPROGRESS == m_pJobEntry->QueueStatus) && 
				(JT_SEND == m_pJobEntry->JobType) && 
				(FPS_ABORTING == m_pJobEntry->Status)
				)
	{
		if (fSetLastEvent) m_dwLastEvent = FEI_SENDING;
	}
	else if (	(JS_INPROGRESS == m_pJobEntry->QueueStatus) && 
				(JT_SEND == m_pJobEntry->JobType) && 
				(FPS_COMPLETED == m_pJobEntry->Status)
				)
	{
		if (fSetLastEvent) m_dwLastEvent = FEI_COMPLETED;
	}
	else if (	(JS_INPROGRESS == m_pJobEntry->QueueStatus) && 
				(JT_SEND == m_pJobEntry->JobType) && 
				(0 == m_pJobEntry->Status)
				)
	{
		//BUG#unknown
		//I think that status should not be 0
		if (fSetLastEvent) m_dwLastEvent = FEI_JOB_QUEUED;//is it?
	}
	else if (	(JS_RETRYING == m_pJobEntry->QueueStatus) && 
				(JT_SEND == m_pJobEntry->JobType) && 
				(0 == m_pJobEntry->Status)//BUG#232151
				)
	{
		if (fSetLastEvent) m_dwLastEvent = FEI_JOB_QUEUED;
	}
	else if (	(JS_INPROGRESS == m_pJobEntry->QueueStatus) && 
				(JT_RECEIVE == m_pJobEntry->JobType) && 
				(FPS_AVAILABLE == m_pJobEntry->Status)
				)
	{
		//
		// seen this when starting the fax service, after it was stopped while reception error
		//
		if (fSetLastEvent) m_dwLastEvent = FEI_RECEIVING;//is it?
	}
	else if (	(JS_INPROGRESS == m_pJobEntry->QueueStatus) && 
				(JT_RECEIVE == m_pJobEntry->JobType) && 
				(FPS_RECEIVING == m_pJobEntry->Status)
				)
	{
		if (fSetLastEvent) m_dwLastEvent = FEI_RECEIVING;
	}
	else if (	(JS_INPROGRESS == m_pJobEntry->QueueStatus) && 
				(JT_RECEIVE == m_pJobEntry->JobType) && 
				(FPS_ANSWERED == m_pJobEntry->Status)
				)
	{
		if (fSetLastEvent) m_dwLastEvent = FEI_RECEIVING;
	}
	else if (	(JS_DELETING == m_pJobEntry->QueueStatus) && 
				(JT_RECEIVE == m_pJobEntry->JobType) && 
				(FPS_ANSWERED == m_pJobEntry->Status)
				)
	{
		if (fSetLastEvent) m_dwLastEvent = FEI_ABORTING;
	}
	else if (	( (JS_DELETING == m_pJobEntry->QueueStatus) || (JS_NOLINE == m_pJobEntry->QueueStatus) ) && //bug#231221
				(JT_SEND == m_pJobEntry->JobType) && 
				(FPS_ABORTING == m_pJobEntry->Status)
				)
	{
		if (fSetLastEvent) m_dwLastEvent = FEI_ABORTING;
	}
	else if (	( (JS_DELETING == m_pJobEntry->QueueStatus) || (JS_NOLINE == m_pJobEntry->QueueStatus) ) && //bug#231221
				(JT_SEND == m_pJobEntry->JobType) && 
				(FPS_AVAILABLE == m_pJobEntry->Status)
				)
	{
		if (fSetLastEvent) m_dwLastEvent = FEI_ABORTING;
	}
	else if (	( (JS_DELETING == m_pJobEntry->QueueStatus) || (JS_NOLINE == m_pJobEntry->QueueStatus) ) && //bug#231221
				(JT_RECEIVE == m_pJobEntry->JobType) && 
				(FPS_ABORTING == m_pJobEntry->Status)
				)
	{
		if (fSetLastEvent) m_dwLastEvent = FEI_ABORTING;
	}
	else if (	(JS_DELETING == m_pJobEntry->QueueStatus) && 
				(JT_RECEIVE == m_pJobEntry->JobType) && 
				(FPS_RECEIVING == m_pJobEntry->Status)
				)
	{
		if (fSetLastEvent) m_dwLastEvent = FEI_ABORTING;
	}
	else if (	(JS_DELETING == m_pJobEntry->QueueStatus) && 
				(JT_RECEIVE == m_pJobEntry->JobType) && 
				(FPS_AVAILABLE == m_pJobEntry->Status)
				)
	{
		if (fSetLastEvent) m_dwLastEvent = FEI_ABORTING;
	}
	else if (	(JS_INPROGRESS == m_pJobEntry->QueueStatus) && 
				((JT_RECEIVE | JT_SEND) & m_pJobEntry->JobType) && 
				(FPS_FATAL_ERROR == m_pJobEntry->Status)
				)
	{
		if (fSetLastEvent) m_dwLastEvent = FEI_RECEIVING;
	}
	else if (	(JS_INPROGRESS == m_pJobEntry->QueueStatus) && 
				((JT_RECEIVE | JT_SEND) & m_pJobEntry->JobType) && 
				(FPS_COMPLETED == m_pJobEntry->Status)
				)
	{
		//
		// device completed, but q did not finish yet
		//
		if (fSetLastEvent) m_dwLastEvent = FEI_RECEIVING;
	}
	else
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT(	"job %d, there's no valid condition: ")
			TEXT(	"m_pJobEntry->JobType=0x%02X, ")
			TEXT(	"m_pJobEntry->Status=0x%02X, ")
			TEXT(	"m_pJobEntry->QueueStatus=0x%02X"),
			m_dwJobId,
			m_pJobEntry->JobType,
			m_pJobEntry->Status,
			m_pJobEntry->QueueStatus
			);
		fRetval = false;
	}

	if (fSetLastEvent && fRetval) m_fValidLastEvent = true;

	return fRetval;
}//CFaxJob::CheckValidConditions


//
// the conditions are huristic.
// each failure report by this method must be revised, and the method
// may need to be changed.
//
bool CFaxJob::CheckImpossibleConditions(
	const DWORD dwJobType, 
	const DWORD dwStatus, 
	const DWORD dwQueueStatus
	) const 
{
	AssertStamp();

	bool fRetval = true;

	
	if (FPS_ROUTING == dwStatus)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("job %d, FPS_ROUTING == dwStatus"),
			m_dwJobId
			);
		fRetval = false;
	}

	//
	// send & Status cases
	//
	if (	(JT_SEND != dwJobType) && 
			(FPS_HANDLED == dwStatus)
			)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("job %d, (JT_SEND != dwJobType(0x%02X)) && (FPS_HANDLED == dwStatus)"),
			m_dwJobId,
			dwJobType
			);
		fRetval = false;
	}

	if (	(JT_SEND != dwJobType) && 
			(FPS_DIALING == dwStatus)
			)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("job %d, (JT_SEND != dwJobType(0x%02X)) && (FPS_DIALING == dwStatus)"),
			m_dwJobId,
			dwJobType
			);
		fRetval = false;
	}

	if (	(JT_SEND != dwJobType) && 
			(FPS_BUSY == dwStatus)
			)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("job %d, (JT_SEND != dwJobType(0x%02X)) && (FPS_BUSY == dwStatus)"),
			m_dwJobId,
			dwJobType
			);
		fRetval = false;
	}

	if (	(JT_SEND != dwJobType) && 
			(FPS_NO_ANSWER == dwStatus)
			)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("job %d, (JT_SEND != dwJobType(0x%02X)) && (FPS_NO_ANSWER == dwStatus)"),
			m_dwJobId,
			dwJobType
			);
		fRetval = false;
	}

	if (	(JT_SEND != dwJobType) && 
			(FPS_BAD_ADDRESS == dwStatus)
			)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("job %d, (JT_SEND != dwJobType(0x%02X)) && (FPS_BAD_ADDRESS == dwStatus)"),
			m_dwJobId,
			dwJobType
			);
		fRetval = false;
	}

	if (	(JT_SEND != dwJobType) && 
			(FPS_NO_DIAL_TONE == dwStatus)
			)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("job %d, (JT_SEND != dwJobType(0x%02X)) && (FPS_NO_DIAL_TONE == dwStatus)"),
			m_dwJobId,
			dwJobType
			);
		fRetval = false;
	}

	if (	(JT_SEND != dwJobType) && 
			(FPS_CALL_DELAYED == dwStatus)
			)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("job %d, (JT_SEND != dwJobType(0x%02X)) && (FPS_CALL_DELAYED == dwStatus)"),
			m_dwJobId,
			dwJobType
			);
		fRetval = false;
	}

	if (	(JT_SEND != dwJobType) && 
			(FPS_CALL_BLACKLISTED == dwStatus)
			)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("job %d, (JT_SEND != dwJobType(0x%02X)) && (FPS_CALL_BLACKLISTED == dwStatus)"),
			m_dwJobId,
			dwJobType
			);
		fRetval = false;
	}

	if (	(JT_SEND != dwJobType) && 
			(FPS_INITIALIZING == dwStatus)
			)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("job %d, (JT_SEND != dwJobType(0x%02X)) && (FPS_INITIALIZING == dwStatus)"),
			m_dwJobId,
			dwJobType
			);
		fRetval = false;
	}

	if (	(JT_SEND != dwJobType) && 
			(FPS_UNAVAILABLE == dwStatus)
			)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("job %d, (JT_SEND != dwJobType(0x%02X)) && (FPS_UNAVAILABLE == dwStatus)"),
			m_dwJobId,
			dwJobType
			);
		fRetval = false;
	}

	//
	// send & QueueStatus cases
	//
	if (	( (JT_SEND != dwJobType) && (JT_ROUTING != dwJobType) )&& 
			(JS_PENDING == dwQueueStatus)
			)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("job %d, (JT_SEND != dwJobType(0x%02X)) && (JS_PENDING == dwQueueStatus)"),
			m_dwJobId,
			dwJobType
			);
		fRetval = false;
	}

	if (	(JT_SEND != dwJobType) && 
			(JS_PAUSED == dwQueueStatus)
			)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("job %d, (JT_SEND != dwJobType(0x%02X)) && (JS_PAUSED == dwQueueStatus)"),
			m_dwJobId,
			dwJobType
			);
		fRetval = false;
	}

	if (	(JT_SEND != dwJobType) && 
			(JS_NOLINE == dwQueueStatus)
			)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("job %d, (JT_SEND != dwJobType(0x%02X)) && (JS_NOLINE == dwQueueStatus)"),
			m_dwJobId,
			dwJobType
			);
		fRetval = false;
	}

	if (	(JT_SEND != dwJobType) && 
			(JS_RETRYING == dwQueueStatus)
			)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("job %d, (JT_SEND != dwJobType(0x%02X)) && (JS_RETRYING == dwQueueStatus)"),
			m_dwJobId,
			dwJobType
			);
		fRetval = false;
	}

	if (	(JT_SEND != dwJobType) && 
			(JS_RETRIES_EXCEEDED == dwQueueStatus)
			)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("job %d, (JT_SEND != dwJobType(0x%02X)) && (JS_RETRIES_EXCEEDED == dwQueueStatus)"),
			m_dwJobId,
			dwJobType
			);
		fRetval = false;
	}



	//
	// recv & Status cases 
	//
	if (	(JT_RECEIVE != dwJobType) && 
			(FPS_NOT_FAX_CALL == dwStatus)
			)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("job %d, (JT_RECEIVE != dwJobType(0x%02X)) && (FPS_NOT_FAX_CALL == dwStatus)"),
			m_dwJobId,
			dwJobType
			);
		fRetval = false;
	}

	if (	(JT_RECEIVE != dwJobType) && 
			(FPS_ANSWERED == dwStatus)
			)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("job %d, (JT_RECEIVE != dwJobType(0x%02X)) && (FPS_ANSWERED == dwStatus)"),
			m_dwJobId,
			dwJobType
			);
		fRetval = false;
	}

	if (	( (JT_RECEIVE != dwJobType) && (JT_SEND != dwJobType) ) && 
			(FPS_AVAILABLE == dwStatus)
			)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("job %d, (JT_RECEIVE != dwJobType(0x%02X)) && (FPS_AVAILABLE == dwStatus)"),
			m_dwJobId,
			dwJobType
			);
		fRetval = false;
	}


	
	//
	// send&recv Status cases
	//
	if (	((JT_SEND != dwJobType) && (JT_RECEIVE != dwJobType)) && 
			(FPS_COMPLETED == dwStatus)
			)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("job %d, dwJobType(0x%02X) is not JT_SEND nor JT_RECEIVE, yet (FPS_COMPLETED == dwStatus)"),
			m_dwJobId,
			dwJobType
			);
		fRetval = false;
	}

	if (	((JT_SEND != dwJobType) && (JT_RECEIVE != dwJobType)) && 
			(FPS_DISCONNECTED == dwStatus)
			)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("job %d, dwJobType(0x%02X) is not JT_SEND nor JT_RECEIVE, yet (FPS_DISCONNECTED == dwStatus)"),
			m_dwJobId,
			dwJobType
			);
		fRetval = false;
	}

	if (	((JT_SEND != dwJobType) && (JT_RECEIVE != dwJobType)) && 
			(FPS_FATAL_ERROR == dwStatus)
			)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("job %d, dwJobType(0x%02X) is not JT_SEND nor JT_RECEIVE, yet (FPS_FATAL_ERROR == dwStatus)"),
			m_dwJobId,
			dwJobType
			);
		fRetval = false;
	}

	if (	((JT_SEND != dwJobType) && (JT_RECEIVE != dwJobType)) && 
			(FPS_OFFLINE == dwStatus)
			)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("job %d, dwJobType(0x%02X) is not JT_SEND nor JT_RECEIVE, yet (FPS_OFFLINE == dwStatus)"),
			m_dwJobId,
			dwJobType
			);
		fRetval = false;
	}

	if (	((JT_SEND != dwJobType) && (JT_RECEIVE != dwJobType)) && 
			(FPS_ABORTING == dwStatus)
			)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("job %d, dwJobType(0x%02X) is not JT_SEND nor JT_RECEIVE, yet (FPS_ABORTING == dwStatus)"),
			m_dwJobId,
			dwJobType
			);
		fRetval = false;
	}

	//
	// send&recv & QueueStatus cases
	//
	if (	((JT_SEND != dwJobType) && (JT_RECEIVE != dwJobType)) && 
			(JS_INPROGRESS == dwQueueStatus)
			)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("job %d, dwJobType(0x%02X) is not JT_SEND nor JT_RECEIVE, yet (JS_INPROGRESS == dwQueueStatus)"),
			m_dwJobId,
			dwJobType
			);
		fRetval = false;
	}

	if (	((JT_SEND != dwJobType) && (JT_RECEIVE != dwJobType)) && 
			(JS_DELETING == dwQueueStatus)
			)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("job %d, dwJobType(0x%02X) is not JT_SEND nor JT_RECEIVE, yet (JS_DELETING == dwQueueStatus)"),
			m_dwJobId,
			dwJobType
			);
		fRetval = false;
	}

	if (	((JT_SEND != dwJobType) && (JT_RECEIVE != dwJobType)) && 
			(JS_FAILED == dwQueueStatus)
			)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("job %d, dwJobType(0x%02X) is not JT_SEND nor JT_RECEIVE, yet (JS_FAILED == dwQueueStatus)"),
			m_dwJobId,
			dwJobType
			);
		fRetval = false;
	}



	//
	// dwStatus cases
	// BUG#232151: status 0 is not valid
	//
	/*
	if (0 == dwStatus)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("job %d, 0 == dwStatus"),
			m_dwJobId
			);
		fRetval = false;
	}
	*/

	//
	// routing cases
	// BUG#232151: status 0 is not valid
	//
	if (	(JT_ROUTING == dwJobType) && 
			(0 != dwStatus)
			)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("job %d, dwJobType is JT_ROUTING, yet (0 != dwStatus(0x%02X))"),
			m_dwJobId,
			dwStatus
			);
		fRetval = false;
	}

	//
	// unknown cases
	//
	if (	(JT_UNKNOWN == dwJobType) && 
			(0 != dwStatus)
			)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("job %d, dwJobType is JT_UNKNOWN, yet (0 == dwStatus(0x%02X))"),
			m_dwJobId,
			dwStatus
			);
		fRetval = false;
	}


	
	//
	// fail receive cases
	//
	if (	(JT_FAIL_RECEIVE == dwJobType) && 
			(FPS_FATAL_ERROR != dwStatus)
			)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("job %d, dwJobType is JT_FAIL_RECEIVE, yet (FPS_FATAL_ERROR == dwStatus(0x%02X))"),
			m_dwJobId,
			dwStatus
			);
		fRetval = false;
	}


	
	
	
	return fRetval;
}//CFaxJob::CheckImpossibleConditions


void CFaxJob::LogStatus(const int nLogLevel) const 
{
	AssertStamp();

	if (-1 == m_dwJobId) return;
	_ASSERTE(m_pJobEntry);
	//if (NULL == m_pJobEntry) return;

	switch(m_pJobEntry->Status)
	{
	case FPS_DIALING:
		::lgLogDetail(LOG_X, nLogLevel, TEXT("job %d, Status=FPS_DIALING"), m_dwJobId);
		break;

	case FPS_SENDING:
		::lgLogDetail(LOG_X, nLogLevel, TEXT("job %d, Status=FPS_SENDING"), m_dwJobId);
		break;

	case FPS_RECEIVING:
		::lgLogDetail(LOG_X, nLogLevel, TEXT("job %d, Status=FPS_RECEIVING"), m_dwJobId);
		break;

	case FPS_COMPLETED:
		if (FJB_MUST_FAIL & m_dwBehavior) ::lgLogError(LOG_SEV_1, TEXT("job %d, Status=FPS_COMPLETED"), m_dwJobId);
		else ::lgLogDetail(LOG_X, nLogLevel, TEXT("job %d, Status=FPS_COMPLETED"), m_dwJobId);
		break;

	case FPS_HANDLED:
		::lgLogDetail(LOG_X, nLogLevel, TEXT("job %d, Status=FPS_HANDLED"), m_dwJobId);
		break;

	case FPS_UNAVAILABLE:
		if (FJB_MUST_SUCCEED & m_dwBehavior) ::lgLogError(LOG_SEV_1, TEXT("job %d, Status=FPS_UNAVAILABLE"), m_dwJobId);
		else ::lgLogDetail(LOG_X, nLogLevel, TEXT("job %d, Status=FPS_UNAVAILABLE"), m_dwJobId);
		
		break;

	case FPS_BUSY:
		if (FJB_MUST_SUCCEED & m_dwBehavior) ::lgLogError(LOG_SEV_1, TEXT("job %d, Status=FPS_BUSY"), m_dwJobId);
		else ::lgLogDetail(LOG_X, nLogLevel, TEXT("job %d, Status=FPS_BUSY"), m_dwJobId);
		break;

	case FPS_NO_ANSWER:
		if (FJB_MUST_SUCCEED & m_dwBehavior) ::lgLogError(LOG_SEV_1, TEXT("job %d, Status=FPS_NO_ANSWER"), m_dwJobId);
		else ::lgLogDetail(LOG_X, nLogLevel, TEXT("job %d, Status=FPS_NO_ANSWER"), m_dwJobId);
		break;

	case FPS_BAD_ADDRESS:
		if (FJB_MUST_SUCCEED & m_dwBehavior) ::lgLogError(LOG_SEV_1, TEXT("job %d, Status=FPS_BAD_ADDRESS"), m_dwJobId);
		else ::lgLogDetail(LOG_X, nLogLevel, TEXT("job %d, Status=FPS_BAD_ADDRESS"), m_dwJobId);
		break;

	case FPS_NO_DIAL_TONE:
		if (FJB_MUST_SUCCEED & m_dwBehavior) ::lgLogError(LOG_SEV_1, TEXT("job %d, Status=FPS_NO_DIAL_TONE"), m_dwJobId);
		else ::lgLogDetail(LOG_X, nLogLevel, TEXT("job %d, Status=FPS_NO_DIAL_TONE"), m_dwJobId);
		break;

	case FPS_DISCONNECTED:
		if (FJB_MUST_SUCCEED & m_dwBehavior) ::lgLogError(LOG_SEV_1, TEXT("job %d, Status=FPS_DISCONNECTED"), m_dwJobId);
		else ::lgLogDetail(LOG_X, nLogLevel, TEXT("job %d, Status=FPS_DISCONNECTED"), m_dwJobId);
		break;

	case FPS_FATAL_ERROR:
		if (FJB_MUST_SUCCEED & m_dwBehavior) ::lgLogError(LOG_SEV_1, TEXT("job %d, Status=FPS_FATAL_ERROR"), m_dwJobId);
		else ::lgLogDetail(LOG_X, nLogLevel, TEXT("job %d, Status=FPS_FATAL_ERROR"), m_dwJobId);
		break;

	case FPS_NOT_FAX_CALL:
		if (FJB_MUST_SUCCEED & m_dwBehavior) ::lgLogError(LOG_SEV_1, TEXT("job %d, Status=FPS_NOT_FAX_CALL"), m_dwJobId);
		else ::lgLogDetail(LOG_X, nLogLevel, TEXT("job %d, Status=FPS_NOT_FAX_CALL"), m_dwJobId);
		break;

	case FPS_CALL_DELAYED:
		if (FJB_MUST_SUCCEED & m_dwBehavior) ::lgLogError(LOG_SEV_1, TEXT("job %d, Status=FPS_CALL_DELAYED"), m_dwJobId);
		else ::lgLogDetail(LOG_X, nLogLevel, TEXT("job %d, Status=FPS_CALL_DELAYED"), m_dwJobId);
		break;

	case FPS_CALL_BLACKLISTED:
		if (FJB_MUST_SUCCEED & m_dwBehavior) ::lgLogError(LOG_SEV_1, TEXT("job %d, Status=FPS_CALL_BLACKLISTED"), m_dwJobId);
		else ::lgLogDetail(LOG_X, nLogLevel, TEXT("job %d, Status=FPS_CALL_BLACKLISTED"), m_dwJobId);
		break;

	case FPS_INITIALIZING:
		::lgLogDetail(LOG_X, nLogLevel, TEXT("job %d, Status=FPS_INITIALIZING"), m_dwJobId);
		break;

	case FPS_OFFLINE:
		if (FJB_MUST_SUCCEED & m_dwBehavior) ::lgLogError(LOG_SEV_1, TEXT("job %d, Status=FPS_OFFLINE"), m_dwJobId);
		else ::lgLogDetail(LOG_X, nLogLevel, TEXT("job %d, Status=FPS_OFFLINE"), m_dwJobId);
		break;

	case FPS_RINGING:
		::lgLogDetail(LOG_X, nLogLevel, TEXT("job %d, Status=FPS_RINGING"), m_dwJobId);
		break;

	case FPS_AVAILABLE:
		::lgLogDetail(LOG_X, nLogLevel, TEXT("job %d, Status=FPS_AVAILABLE"), m_dwJobId);
		break;

	case FPS_ABORTING:
		if (FJB_MUST_SUCCEED & m_dwBehavior) ::lgLogError(LOG_SEV_1, TEXT("job %d, Status=FPS_ABORTING"), m_dwJobId);
		else ::lgLogDetail(LOG_X, nLogLevel, TEXT("job %d, Status=FPS_ABORTING"), m_dwJobId);
		break;

	case FPS_ROUTING:
		::lgLogDetail(LOG_X, nLogLevel, TEXT("job %d, Status=FPS_ROUTING"), m_dwJobId);
		break;

	case FPS_ANSWERED:
		::lgLogDetail(LOG_X, nLogLevel, TEXT("job %d, Status=FPS_ANSWERED"), m_dwJobId);
		break;

	case 0://BUG#244569
		//::lgLogError(LOG_SEV_1, TEXT("BUG#244569:job %d, Status=0"), m_dwJobId);
		::lgLogDetail(LOG_X, 0, TEXT("BUG#244569:job %d, Status=0"), m_dwJobId);
		break;

	default:
		::lgLogError(LOG_SEV_1, TEXT("job %d, illegal Status=0x%08X"), m_dwJobId, m_pJobEntry->Status);
		_ASSERTE(FALSE);
		break;

	}
}//CFaxJob::LogStatus()


void CFaxJob::LogJobType(const int nLogLevel) const 
{
	AssertStamp();

	if (-1 == m_dwJobId) return;
	_ASSERTE(m_pJobEntry);
	//if (NULL == m_pJobEntry) return;

	switch(m_pJobEntry->JobType)
	{
	case JT_UNKNOWN:
		::lgLogDetail(LOG_X, nLogLevel, TEXT("job %d, JobType=JT_UNKNOWN"), m_dwJobId);
		break;

	case JT_SEND:
		::lgLogDetail(LOG_X, nLogLevel, TEXT("job %d, JobType=JT_SEND"), m_dwJobId);
		break;

	case JT_RECEIVE:
		::lgLogDetail(LOG_X, nLogLevel, TEXT("job %d, JobType=JT_RECEIVE"), m_dwJobId);
		break;

	case JT_ROUTING:
		::lgLogDetail(LOG_X, nLogLevel, TEXT("job %d, JobType=JT_ROUTING"), m_dwJobId);
		break;

	case JT_FAIL_RECEIVE:
		if (FJB_MUST_SUCCEED & m_dwBehavior) ::lgLogError(LOG_SEV_1, TEXT("job %d, JobType=JT_FAIL_RECEIVE"), m_dwJobId);
		else ::lgLogDetail(LOG_X, nLogLevel, TEXT("job %d, JobType=JT_FAIL_RECEIVE"), m_dwJobId);
		
		break;

	default:
		::lgLogError(LOG_SEV_1, TEXT("job %d, illegal JobType=0x%08X"), m_dwJobId, m_pJobEntry->JobType);
		_ASSERTE(FALSE);
		break;

	}
}//CFaxJob::LogJobType()

void CFaxJob::LogQueueStatus(const int nLogLevel) const 
{
	AssertStamp();

	if (-1 == m_dwJobId) return;
	_ASSERTE(m_pJobEntry);
	//if (NULL == m_pJobEntry) return;

	switch(m_pJobEntry->QueueStatus)
	{
	case JS_PENDING:
		::lgLogDetail(LOG_X, nLogLevel, TEXT("job %d, QueueStatus=JS_PENDING"), m_dwJobId);
		break;

	case JS_INPROGRESS:
		::lgLogDetail(LOG_X, nLogLevel, TEXT("job %d, QueueStatus=JS_INPROGRESS"), m_dwJobId);
		break;

	case JS_DELETING:
		if (FJB_MUST_FAIL & m_dwBehavior) ::lgLogError(LOG_SEV_1, TEXT("job %d, QueueStatus=JS_DELETING"), m_dwJobId);
		else ::lgLogDetail(LOG_X, nLogLevel, TEXT("job %d, QueueStatus=JS_DELETING"), m_dwJobId);
		
		break;

	case JS_FAILED:
		if (FJB_MUST_SUCCEED & m_dwBehavior) ::lgLogError(LOG_SEV_1, TEXT("job %d, QueueStatus=JS_FAILED"), m_dwJobId);
		else ::lgLogDetail(LOG_X, nLogLevel, TEXT("job %d, QueueStatus=JS_FAILED"), m_dwJobId);
		
		break;

	case JS_PAUSED:
		::lgLogDetail(LOG_X, nLogLevel, TEXT("job %d, QueueStatus=JS_PAUSED"), m_dwJobId);
		break;

	case JS_NOLINE:
		::lgLogDetail(LOG_X, nLogLevel, TEXT("job %d, QueueStatus=JS_NOLINE"), m_dwJobId);
		break;

	case JS_RETRYING:
		if (FJB_MUST_SUCCEED & m_dwBehavior) ::lgLogError(LOG_SEV_1, TEXT("job %d, QueueStatus=JS_RETRYING"), m_dwJobId);
		else ::lgLogDetail(LOG_X, nLogLevel, TEXT("job %d, QueueStatus=JS_RETRYING"), m_dwJobId);
		break;

	case JS_RETRIES_EXCEEDED:
		if (FJB_MUST_SUCCEED & m_dwBehavior) ::lgLogError(LOG_SEV_1, TEXT("job %d, QueueStatus=JS_RETRIES_EXCEEDED"), m_dwJobId);
		else ::lgLogDetail(LOG_X, nLogLevel, TEXT("job %d, QueueStatus=JS_RETRIES_EXCEEDED"), m_dwJobId);
		break;

	//BUG#231221
	case JS_NOLINE | JS_RETRYING:
		::lgLogDetail(LOG_X, 0, TEXT("BUG#231221:job %d, QueueStatus=JS_NOLINE | JS_RETRYING"), m_dwJobId);
		break;

	//BUG#231221
	case JS_NOLINE | JS_DELETING:
		::lgLogDetail(LOG_X, 0, TEXT("BUG#231221:job %d, QueueStatus=JS_NOLINE | JS_DELETING"), m_dwJobId);
		break;

	//BUG#231221
	case JS_NOLINE | JS_INPROGRESS:
		::lgLogDetail(LOG_X, 0, TEXT("BUG#231221:job %d, QueueStatus=JS_NOLINE | JS_DELETING"), m_dwJobId);
		break;

	default:
		::lgLogError(LOG_SEV_1, TEXT("job %d, illegal QueueStatus=0x%08X"), m_dwJobId, m_pJobEntry->QueueStatus);
		_ASSERTE(FALSE);
		break;

	}
}//CFaxJob::LogQueueStatus()

void CFaxJob::LogJobStruct(
	const PFAX_JOB_ENTRY pFaxJobEntry, 
	LPCTSTR szDesc, 
	const int nLogLevel
	) const 
{
	AssertStamp();

	::lgLogDetail(LOG_X, nLogLevel, TEXT("%s.SizeOfStruct=%d"), szDesc, pFaxJobEntry->SizeOfStruct);
	::lgLogDetail(LOG_X, nLogLevel, TEXT("%s.JobId=%d"), szDesc, pFaxJobEntry->JobId);
	::lgLogDetail(LOG_X, nLogLevel, TEXT("%s.UserName=%s"), szDesc, pFaxJobEntry->UserName);
	::lgLogDetail(LOG_X, nLogLevel, TEXT("%s.JobType=%d"), szDesc, pFaxJobEntry->JobType);
	::lgLogDetail(LOG_X, nLogLevel, TEXT("%s.QueueStatus=%d"), szDesc, pFaxJobEntry->QueueStatus);
	::lgLogDetail(LOG_X, nLogLevel, TEXT("%s.Size=%d"), szDesc, pFaxJobEntry->Size);
	::lgLogDetail(LOG_X, nLogLevel, TEXT("%s.PageCount=%d"), szDesc, pFaxJobEntry->PageCount);
	::lgLogDetail(LOG_X, nLogLevel, TEXT("%s.RecipientNumber=%s"), szDesc, pFaxJobEntry->RecipientNumber);
	::lgLogDetail(LOG_X, nLogLevel, TEXT("%s.RecipientName=%s"), szDesc, pFaxJobEntry->RecipientName);
	::lgLogDetail(LOG_X, nLogLevel, TEXT("%s.Tsid=%s"), szDesc, pFaxJobEntry->Tsid);
	::lgLogDetail(LOG_X, nLogLevel, TEXT("%s.SenderName=%s"), szDesc, pFaxJobEntry->SenderName);
	::lgLogDetail(LOG_X, nLogLevel, TEXT("%s.SenderCompany=%s"), szDesc, pFaxJobEntry->SenderCompany);
	::lgLogDetail(LOG_X, nLogLevel, TEXT("%s.SenderDept=%s"), szDesc, pFaxJobEntry->SenderDept);
	::lgLogDetail(LOG_X, nLogLevel, TEXT("%s.BillingCode=%s"), szDesc, pFaxJobEntry->BillingCode);
	::lgLogDetail(LOG_X, nLogLevel, TEXT("%s.ScheduleAction=%d"), szDesc, pFaxJobEntry->ScheduleAction);
	::lgLogDetail(LOG_X, nLogLevel, TEXT("%s.ScheduleTime.wYear=%d"), szDesc, pFaxJobEntry->ScheduleTime.wYear);
	::lgLogDetail(LOG_X, nLogLevel, TEXT("%s.ScheduleTime.wMonth=%d"), szDesc, pFaxJobEntry->ScheduleTime.wMonth);
	::lgLogDetail(LOG_X, nLogLevel, TEXT("%s.ScheduleTime.wDayOfWeek=%d"), szDesc, pFaxJobEntry->ScheduleTime.wDayOfWeek);
	::lgLogDetail(LOG_X, nLogLevel, TEXT("%s.ScheduleTime.wDay=%d"), szDesc, pFaxJobEntry->ScheduleTime.wDay);
	::lgLogDetail(LOG_X, nLogLevel, TEXT("%s.ScheduleTime.wHour=%d"), szDesc, pFaxJobEntry->ScheduleTime.wHour);
	::lgLogDetail(LOG_X, nLogLevel, TEXT("%s.ScheduleTime.wMinute=%d"), szDesc, pFaxJobEntry->ScheduleTime.wMinute);
	::lgLogDetail(LOG_X, nLogLevel, TEXT("%s.ScheduleTime.wSecond=%d"), szDesc, pFaxJobEntry->ScheduleTime.wSecond);
	::lgLogDetail(LOG_X, nLogLevel, TEXT("%s.ScheduleTime.wMilliseconds=%d"), szDesc, pFaxJobEntry->ScheduleTime.wMilliseconds);

	switch(pFaxJobEntry->DeliveryReportType)
	{
	case DRT_NONE:
		::lgLogDetail(LOG_X, nLogLevel, TEXT("%s.DeliveryReportType=DRT_NONE"), szDesc);
		break;

	case DRT_EMAIL:
		::lgLogDetail(LOG_X, nLogLevel, TEXT("%s.DeliveryReportType=DRT_EMAIL"), szDesc);
		break;

	case DRT_INBOX:
		::lgLogDetail(LOG_X, nLogLevel, TEXT("%s.DeliveryReportType=DRT_INBOX"), szDesc);
		break;

	default :
		::lgLogError(LOG_SEV_1, TEXT("unknown %s.DeliveryReportType=%d"), szDesc, pFaxJobEntry->DeliveryReportType);
		break;
	}

	::lgLogDetail(LOG_X, nLogLevel, TEXT("%s.DeliveryReportAddress=%s"), szDesc, pFaxJobEntry->DeliveryReportAddress);
	::lgLogDetail(LOG_X, nLogLevel, TEXT("%s.DocumentName=%s"), szDesc, pFaxJobEntry->DocumentName);
}//CFaxJob::LogJobStruct()

void CFaxJob::LogScheduleAction(const int nLogLevel) const 
{
	switch(m_pJobEntry->ScheduleAction)
	{
	case JSA_NOW:
		::lgLogDetail(LOG_X, nLogLevel, TEXT("m_pJobEntry->ScheduleAction=JSA_NOW"));
		break;

	case JSA_SPECIFIC_TIME:
		::lgLogDetail(LOG_X, nLogLevel, TEXT("m_pJobEntry->ScheduleAction=JSA_SPECIFIC_TIME"));
		break;

	case JSA_DISCOUNT_PERIOD:
		::lgLogDetail(LOG_X, nLogLevel, TEXT("m_pJobEntry->ScheduleAction=JSA_DISCOUNT_PERIOD"));
		break;

	default:
		::lgLogError(
			LOG_SEV_1, 
			TEXT("CFaxJob::LogScheduleAction(): m_pJobEntry->ScheduleAction(0x%08X)"),
			m_pJobEntry->ScheduleAction
			);
		break;

	}
}


void CFaxJob::VerifyJobTypeIs(const DWORD dwExpectedJobType) const 
{
	if (IsMarkedForDeletion()) return;

	if (NULL == m_pJobEntry)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("CFaxJob::VerifyJobTypeIs(): NULL == m_pJobEntry")
			);
		return;
	}

	if (dwExpectedJobType != m_pJobEntry->JobType)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("CFaxJob::VerifyJobTypeIs(): (dwExpectedJobType(0x%08X) != m_pJobEntry->JobType(0x%08X))"),
			dwExpectedJobType, 
			m_pJobEntry->JobType
			);
	}

}//CFaxJob::VerifyJobTypeIs()

void CFaxJob::VerifyCurrentJobEntry(const PFAX_JOB_ENTRY pPrevJobEntry) const 
{
	if (NULL == pPrevJobEntry) return;

	if (IsMarkedForDeletion()) return;

	if (pPrevJobEntry->JobType != m_pJobEntry->JobType)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("CFaxJob::VerifyCurrentJobEntry(): (pPrevJobEntry->JobType(0x%08X) != m_pJobEntry->JobType(0x%08X))"),
			pPrevJobEntry->JobType, 
			m_pJobEntry->JobType
			);
	}

}//CFaxJob::VerifyCurrentJobEntry()


void CFaxJob::VerifyBehaviorIncludes(const DWORD dwBehavior) const 
{
	if (!(m_dwBehavior & dwBehavior))
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("CFaxJob::VerifyBehaviorIncludes(): (!(m_dwBehavior(0x%08X) & dwBehavior(0x%08X)))"),
			m_dwBehavior, 
			dwBehavior
			);
	}

}//CFaxJob::VerifyBehaviorIncludes()


void CFaxJob::VerifyBehaviorIsNot(const DWORD dwBehavior) const 
{
	if ((m_dwBehavior & dwBehavior))
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("CFaxJob::VerifyBehaviorIsNot(): ((m_dwBehavior(0x%08X) & dwBehavior(0x%08X)))"),
			m_dwBehavior, 
			dwBehavior
			);
	}

}//CFaxJob::VerifyBehaviorIsNot()


void CFaxJob::VerifyJobIsNotScheduledForFuture() const 
{
	if (JSA_NOW == m_pJobEntry->ScheduleAction) return;

	SYSTEMTIME SystemTime;
	GetSystemTime(&SystemTime);

	if (JSA_SPECIFIC_TIME == m_pJobEntry->ScheduleAction)
	{
		_ASSERTE(m_pServiceMonitor->m_pFaxConfig);

		if (m_pJobEntry->ScheduleTime.wYear > SystemTime.wYear)
		{
			::lgLogError(
				LOG_SEV_1, 
				TEXT("CFaxJob::VerifyJobIsNotScheduledForFuture(): m_pJobEntry->ScheduleTime.wYear(%d) > SystemTime.wYear(%d)"),
				(int)m_pJobEntry->ScheduleTime.wYear, 
				(int)SystemTime.wYear
				);
			return;
		}

		if (m_pJobEntry->ScheduleTime.wMonth > SystemTime.wMonth)
		{
			::lgLogError(
				LOG_SEV_1, 
				TEXT("CFaxJob::VerifyJobIsNotScheduledForFuture(): m_pJobEntry->ScheduleTime.wMonth(%d) > SystemTime.wMonth(%d)"),
				(int)m_pJobEntry->ScheduleTime.wMonth, 
				(int)SystemTime.wMonth
				);
			return;
		}

		if (m_pJobEntry->ScheduleTime.wDay > SystemTime.wDay)
		{
			::lgLogError(
				LOG_SEV_1, 
				TEXT("CFaxJob::VerifyJobIsNotScheduledForFuture(): m_pJobEntry->ScheduleTime.wDay(%d) > SystemTime.wDay(%d)"),
				(int)m_pJobEntry->ScheduleTime.wDay, 
				(int)SystemTime.wDay
				);
			return;
		}

		if (m_pJobEntry->ScheduleTime.wHour > SystemTime.wHour)
		{
			::lgLogError(
				LOG_SEV_1, 
				TEXT("CFaxJob::VerifyJobIsNotScheduledForFuture(): m_pJobEntry->ScheduleTime.wHour(%d) > SystemTime.wHour(%d)"),
				(int)m_pJobEntry->ScheduleTime.wHour, 
				(int)SystemTime.wHour
				);
			return;
		}

		if (m_pJobEntry->ScheduleTime.wMinute > SystemTime.wMinute)
		{
			::lgLogError(
				LOG_SEV_1, 
				TEXT("CFaxJob::VerifyJobIsNotScheduledForFuture(): m_pJobEntry->ScheduleTime.wMinute(%d) > SystemTime.wMinute%d)"),
				(int)m_pJobEntry->ScheduleTime.wMinute, 
				(int)SystemTime.wMinute
				);
			return;
		}

		if (m_pJobEntry->ScheduleTime.wSecond > SystemTime.wSecond)
		{
			::lgLogError(
				LOG_SEV_1, 
				TEXT("CFaxJob::VerifyJobIsNotScheduledForFuture(): m_pJobEntry->ScheduleTime.wSecond(%d) > SystemTime.wSecond%d)"),
				(int)m_pJobEntry->ScheduleTime.wSecond, 
				(int)SystemTime.wSecond
				);
			return;
		}

		return;
	}//if (JSA_SPECIFIC_TIME == m_pJobEntry->ScheduleAction)

	if (JSA_DISCOUNT_PERIOD == m_pJobEntry->ScheduleAction)
	{
		//
		// we may not be before start of discount rates
		//
		if (m_pServiceMonitor->m_pFaxConfig->StartCheapTime.Hour > SystemTime.wHour)
		{
			::lgLogError(
				LOG_SEV_1, 
				TEXT("CFaxJob::VerifyJobIsNotScheduledForFuture(): m_pServiceMonitor->m_pFaxConfig->StartCheapTime.wHour(%d) > SystemTime.wHour(%d)"),
				(int)m_pServiceMonitor->m_pFaxConfig->StartCheapTime.Hour, 
				(int)SystemTime.wHour
				);
			return;
		}

		if (m_pServiceMonitor->m_pFaxConfig->StartCheapTime.Minute > SystemTime.wMinute)
		{
			::lgLogError(
				LOG_SEV_1, 
				TEXT("CFaxJob::VerifyJobIsNotScheduledForFuture(): m_pServiceMonitor->m_pFaxConfig->StartCheapTime.Minute(%d) > SystemTime.wMinute%d)"),
				(int)m_pServiceMonitor->m_pFaxConfig->StartCheapTime.Minute, 
				(int)SystemTime.wMinute
				);
			return;
		}

		//
		// we may not be after end of discount rates
		//
		if (m_pServiceMonitor->m_pFaxConfig->StopCheapTime.Hour < SystemTime.wHour)
		{
			::lgLogError(
				LOG_SEV_1, 
				TEXT("CFaxJob::VerifyJobIsNotScheduledForFuture(): m_pServiceMonitor->m_pFaxConfig->StopCheapTime.wHour(%d) < SystemTime.wHour(%d)"),
				(int)m_pServiceMonitor->m_pFaxConfig->StopCheapTime.Hour, 
				(int)SystemTime.wHour
				);
			return;
		}

		if (m_pServiceMonitor->m_pFaxConfig->StopCheapTime.Minute < SystemTime.wMinute)
		{
			::lgLogError(
				LOG_SEV_1, 
				TEXT("CFaxJob::VerifyJobIsNotScheduledForFuture(): m_pServiceMonitor->m_pFaxConfig->StopCheapTime.Minute(%d) < SystemTime.wMinute%d)"),
				(int)m_pServiceMonitor->m_pFaxConfig->StopCheapTime.Minute, 
				(int)SystemTime.wMinute
				);
			return;
		}

	}//if (JSA_DISCOUNT_PERIOD == m_pJobEntry->ScheduleAction)

	_ASSERTE(FALSE);

}//void CFaxJob::VerifyJobIsNotScheduledForFuture()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\servicemonitor\faxjob.h ===
#ifndef __FAX_JOB_H
#define __FAX_JOB_H


#include <windows.h>

/*
	This class is used for holding fax job information.
	It is used in conjunction with the CServiceMonitor class.
	Each object of this class holds information pertaining to only one fax job.
	Each new object tries to FaxGetJob() in order to initialize itself. It may
	fail since the job may have been deleted meanwhile. Its initoal status is 
	verified as valid.
	All this class does is expose SetMessage() that handles a fax event.
	It is verified against previous event and against FaxGetJob().
*/
class CServiceMonitor;

#define SAFE_FaxFreeBuffer(pBuff) {::FaxFreeBuffer(pBuff); pBuff = NULL;}

#define __CFAX_JOB_STAMP 0x019283746


#define FJB_MAY_BE_TX_ABORTED		0x00000001
#define FJB_MAY_BE_RX_ABORTED		0x00000002
#define FJB_MUST_FAIL				0x00000004
#define FJB_MAY_COMMIT_SUICIDE		0x00000008
#define FJB_MUST_SUCCEED			0x00000010

class CFaxJob
{
public:
	CFaxJob(
		const int nJobId, 
		CServiceMonitor *pServiceMonitor, 
		const DWORD dwBehavior, 
		const bool fSetLastEvent,
		const DWORD dwDisallowedEvents
		);

	~CFaxJob();

	//
	// notify that this job id got a fax message
	//
	bool SetMessage(const int nEventId, const DWORD dwDeviceId);

	bool IsDeletable()const  { return m_fDeleteMe; }

	//
	// logging functions
	//
	void LogStatus(const int nLogLevel=5) const ;
	void LogJobType(const int nLogLevel=5) const ;
	void LogQueueStatus(const int nLogLevel=5) const ;
	void LogJobStruct(
		const PFAX_JOB_ENTRY pFaxJobEntry, 
		LPCTSTR szDesc, 
		const int nLogLevel=5
		) const ;
	void LogScheduleAction(const int nLogLevel=5) const ;

	void AssertStamp() const {_ASSERTE(__CFAX_JOB_STAMP == m_dwStamp);}

private:
	//
	// false if the 3 input vars constitute an illegal state.
	// The illegal states are huristic, so this method should be updated
	// accordingly.
	//
	bool CheckImpossibleConditions(
		const DWORD dwJobType, 
		const DWORD dwStatus, 
		const DWORD dwQueueStatus
		) const ;

	//
	// true if the 3 input vars constitute a legal state.
	// The legal states are huristic, so this method should be updated
	// accordingly.
	//
	bool CheckValidConditions(
		const DWORD dwJobType, 
		const DWORD dwStatus, 
		const DWORD dwQueueStatus,
		const bool fSetLastEvent
		);

	//
	// job id 0xffffffff is general fax event and not a specific job
	//
	void VerifyThatJobIdIs0xFFFFFFFF(LPCTSTR szEvent) const ;
	void VerifyThatJobIdIsNot0xFFFFFFFF(LPCTSTR szEvent) const ;

	//
	// methods to assert that the previous event correlates to the current event
	//
	bool VerifyThatLastEventIs(
		const DWORD dwExpectedPreviousEventId,
		const DWORD dwCurrentEventId
		) const ;
	bool VerifyThatLastEventIsOneOf(
		const DWORD dwExpectedPreviousEventsMask,
		const DWORD dwCurrentEventId
		) const ;

	void VerifyJobTypeIs(const DWORD dwExpectedJobType) const ;

	void VerifyCurrentJobEntry(const PFAX_JOB_ENTRY pPrevJobEntry) const ;

	void VerifyBehaviorIncludes(const DWORD dwCap) const ;

	void VerifyBehaviorIsNot(const DWORD dwCap) const ;

	void VerifyJobIsNotScheduledForFuture() const ;

	void MarkMeForDeletion() { m_fDeleteMe = true; }

	bool IsMarkedForDeletion() const { return m_fDeleteMe; }

	bool m_fDeleteMe;

	DWORD m_dwStamp;
	//
	// CfaxJob(s) are usually contained within a CServiceMonitor,
	// and they need to notify it sometimes.
	//
	CServiceMonitor *m_pServiceMonitor;

	//
	// for FaxGetJob()
	//
	PFAX_JOB_ENTRY m_pJobEntry;

	//
	// my id
	//
	DWORD m_dwJobId;

	//
	// new events may not have a valid last event yet
	//
	bool m_fValidLastEvent;

	//
	// see FJB_XXX constants
	//
	DWORD m_dwBehavior;

	//
	// ...
	//
	DWORD m_dwLastEvent;

	//
	// counts the times dialing has started (I meant it to count retries)
	//
	DWORD m_dwDialingCount;

	//
	// counts msecs from last dial attempt
	//
	DWORD m_dwLastDialTickCount;

	DWORD m_dwDisallowedEvents;

	//
	// mark if I aborted myself
	//
	bool m_fCommittedSuicide;
};

#endif //__FAX_JOB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\spooler\faxspooler_bvt\dummylogelle.cpp ===
#include <LogElle.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\servicemonitor\servicemonitor.cpp ===
#include <windows.h>
#include <TCHAR.h>
#include <crtdbg.h>

#include <winfax.h>
#include "..\common\log\log.h"
#include "ServiceMonitor.h"
#include "FaxJob.h"
#include "FaxDevice.h"


CServiceMonitor::CServiceMonitor(const DWORD dwJobBehavior, LPCTSTR szFaxServerName):
	m_hFax(NULL),
	m_hCompletionPort(INVALID_HANDLE_VALUE),
	m_pFaxConfig(NULL),
	m_fFaxServiceIsDown(true),
	m_nJobCount(0),
	m_nDeviceCount(0),
	m_dwJobBehavior(dwJobBehavior)
{
	if (NULL != szFaxServerName)
	{
		m_szFaxServerName = new TCHAR[lstrlen(szFaxServerName)+1];
		if (NULL == m_szFaxServerName)
		{
			throw CException(
				TEXT("%s(%d): ERROR: new TCHAR[%d] (%s) failed with %d"), 
				TEXT(__FILE__), 
				__LINE__,
				lstrlen(szFaxServerName)+1,
				m_szFaxServerName,
				::GetLastError() 
				);
		}

		m_szFaxServerName[lstrlen(szFaxServerName)] = NULL;
		lstrcpy(m_szFaxServerName, szFaxServerName);
		_ASSERTE(NULL == m_szFaxServerName[lstrlen(szFaxServerName)]);
	}
    else
    {
        m_szFaxServerName = NULL;
    }

	::lgLogDetail(LOG_X, 0, TEXT("Starting.") );
	Init();
}



CServiceMonitor::~CServiceMonitor()
{
	Cleanup();

	delete[] m_szFaxServerName;
	//
	// go over all jobs, and verify their status.
	// fax service should be down by now.
	//
	VerifyExistingJobsAfterFaxServiceIsDown();

}

void CServiceMonitor::Cleanup()
{
	if (NULL != m_hFax)
	{
		if (!::FaxClose( m_hFax ))
		{
			::lgLogError(LOG_SEV_1, TEXT("ERROR: ::FaxClose() failed with %d"), ::GetLastError());
		}
		m_hFax = NULL;
	}
	else
	{
		_ASSERTE(INVALID_HANDLE_VALUE == m_hCompletionPort);
	}

	if (INVALID_HANDLE_VALUE != m_hCompletionPort)
	{
		if (!::CloseHandle( m_hCompletionPort ))
		{
			::lgLogError(LOG_SEV_1, TEXT("ERROR: ::CloseHandle(m_hCompletionPort) failed with %d"), ::GetLastError());
		}
		m_hCompletionPort = INVALID_HANDLE_VALUE;
	}

	if (m_pFaxConfig) SAFE_FaxFreeBuffer(m_pFaxConfig);
}

void CServiceMonitor::Init()
{
	Cleanup();
	//
	// connect to fax service
	//
	::lgLogDetail(LOG_X, 3, TEXT("Before ::FaxConnectFaxServer."));
	_ASSERTE(NULL == m_hFax);
	if (!::FaxConnectFaxServer(m_szFaxServerName,&m_hFax)) 
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("ERROR: ::FaxConnectFaxServer(%s) failed, ec = %d"),
			m_szFaxServerName,
			::GetLastError()
			);
		throw CException(
			TEXT("%s(%d): ERROR: ::FaxConnectFaxServer(%s) failed, ec = %d"), 
			TEXT(__FILE__), 
			__LINE__,
			m_szFaxServerName,
			::GetLastError() 
			);
	}
	if (NULL == m_hFax) 
	{
		::lgLogError(LOG_SEV_1, TEXT("ERROR: (NULL == m_hFax)"));
		throw CException(TEXT("%s(%d): ERROR: (NULL == m_hFax)"), TEXT(__FILE__), __LINE__);
	}

	::lgLogDetail(LOG_X, 3, TEXT("::FaxConnectFaxServer(%s) succeeded."), m_szFaxServerName );

	AddExistingDevices();
	AddExistingJobs();

	::lgLogDetail(LOG_X, 3, TEXT("Before ::CreateIoCompletionPort.") );
	_ASSERTE(INVALID_HANDLE_VALUE == m_hCompletionPort);
	m_hCompletionPort = ::CreateIoCompletionPort(INVALID_HANDLE_VALUE,NULL,0,0);
	if (NULL == m_hCompletionPort) 
	{
		::FaxClose( m_hFax );
		::lgLogError(LOG_SEV_1, TEXT("ERROR: ::CreateIoCompletionPort failed, ec = %d"), ::GetLastError());
		throw CException(TEXT("%s(%d): ERROR: ::CreateIoCompletionPort failed, ec = %d"), TEXT(__FILE__), __LINE__, ::GetLastError());
	}
	::lgLogDetail(LOG_X, 3, TEXT("::CreateIoCompletionPort succeeded.") );

	::lgLogDetail(LOG_X, 3, TEXT("Before ::FaxInitializeEventQueue.") );
	if (!::FaxInitializeEventQueue(
			m_hFax,
			m_hCompletionPort,
			0,
			NULL, 
			0 ) 
			)
	{
		::CloseHandle(m_hCompletionPort);
		::FaxClose( m_hFax );
		::lgLogError(LOG_SEV_1, TEXT("ERROR: ::FaxInitializeEventQueue failed, ec = %d"), ::GetLastError());
		throw CException(TEXT("%s(%d): ERROR: ::FaxInitializeEventQueue failed, ec = %d"), TEXT(__FILE__), __LINE__, ::GetLastError());
	}
	::lgLogDetail(LOG_X, 3, TEXT("::FaxInitializeEventQueue succeeded.") );

	SafeFaxGetConfiguration();

	m_fFaxServiceIsDown = false;
}

BOOL CServiceMonitor::Start()
{
	DWORD dwCompletionKey;
	DWORD dwBytes;
	PFAX_EVENT pFaxEvent;

	//
	// perform nLoopCount loops.
	// each loop sends a job.
	// if we have the command line swith /as (fAbortJob), the job will be aborted
	//   some time after it's queued.
	// if we have the command line swith /ar (fAbortReceiveJob), a received job will be aborted
	//   some time after it's noticed.
	// a loop ends only after the job was seleted.
	//
	DWORD dwFirstTime = ::GetTickCount();
	while(!m_fFaxServiceIsDown)
	{
		//
		// I don't want to be blocked on this call, since I want to be able 
		// to abort the job at a random time.
		// therefor I wait for 1 millisecond for a message
		//
		pFaxEvent = NULL;
		if (!::GetQueuedCompletionStatus(
				m_hCompletionPort,
				&dwBytes,
				&dwCompletionKey,
				(LPOVERLAPPED *)&pFaxEvent,
				60*1000
				)
		   )
		{
			DWORD dwLastError = ::GetLastError();

			if (WAIT_TIMEOUT != dwLastError)
			{
				::lgLogError(LOG_SEV_1,  
				 TEXT("(%d) ERROR: ::GetQueuedCompletionStatus() failed with %d"),
					 GetDiffTime(dwFirstTime),
					 dwLastError
				 );
				throw CException(TEXT("%s(%d): ERROR: ::GetQueuedCompletionStatus() failed with %d"), TEXT(__FILE__), __LINE__, dwLastError);
			}

			::lgLogDetail(LOG_X, 9, TEXT("(%d) ::GetQueuedCompletionStatus() timed out (1 minute)"));
			continue;
		}

		_ASSERTE( NULL != pFaxEvent);

		CFaxJob *pFaxJob = NULL;
		if (!m_Jobs.Get(pFaxEvent->JobId, &pFaxJob))
		{
			try
			{
				pFaxJob = new CFaxJob(
					pFaxEvent->JobId, 
					this,
					m_dwJobBehavior,
					false,
					0//dwDisallowedEvents
					);
			}catch(CException e)
			{
				::lgLogDetail(
					LOG_X, 
					2,
					TEXT("CServiceMonitor::CServiceMonitor(): new CFaxJob() threw an exception:%s"),
					(const TCHAR*)e
					);
				//
				// this job has probably been deleted meanwhile
				//
				continue;
			}//catch(...)
			{
				//_ASSERTE(FALSE);
				//throw CException(TEXT("%s(%d): CServiceMonitor::CServiceMonitor(): new CFaxJob() threw an exception"), TEXT(__FILE__), __LINE__);
			}

			if (NULL == pFaxJob)
			{
				_ASSERTE(FALSE);
				return false;
			}
			if (!m_Jobs.Add(pFaxEvent->JobId, pFaxJob))
			{
				_ASSERTE(FALSE);
				return false;
			}
		}//if (!m_Jobs.Get(pFaxEvent->JobId, &pFaxJob))

		_ASSERTE(NULL != pFaxJob);

		//
		// no need to check retval, since errors are logged
		//
		pFaxJob->SetMessage(pFaxEvent->EventId, pFaxEvent->DeviceId);
		SetMessageToDevice(pFaxEvent->EventId, pFaxEvent->DeviceId);

		//
		// BUGBUG: job must wait for a certain event before
		// being deletable
		//
		if (pFaxJob->IsDeletable())
		{
			if (!m_Jobs.Remove(pFaxEvent->JobId))
			{
				_ASSERTE(FALSE);
				return false;
			}
		}

	}//while(!m_fFaxServiceIsDown)

   return FALSE;
}


void CServiceMonitor::AddExistingJobs()
{
	PFAX_JOB_ENTRY aJobEntry;
	DWORD dwJobsReturned;

	::lgLogDetail(LOG_X, 0, TEXT("Starting CServiceMonitor::AddExistingJobs()"));

	if (!::FaxEnumJobs(
		m_hFax,          // handle to the fax server
		&aJobEntry,  // buffer to receive array of job data
		&dwJobsReturned       // number of fax job structures returned
		)
	   )
	{
		throw CException(TEXT("%s(%d): CServiceMonitor::AddExistingJobs(): ::FaxEnumJobs() failed with %d"), ::GetLastError());
	}

	for (DWORD dwJob = 0; dwJob < dwJobsReturned; dwJob++)
	{
		CFaxJob *pFaxJob = NULL;
		try
		{
			pFaxJob = new CFaxJob(
					aJobEntry[dwJob].JobId, 
					this,
					m_dwJobBehavior,
					true,
					0//dwDisallowedEvents
					);
		}catch(CException e)
		{
			::lgLogDetail(
				LOG_X, 
				2,
				TEXT("CServiceMonitor::AddExistingJobs(): new CFaxJob() threw an exception:%s"),
				(const TCHAR*)e
				);
			//
			// this job has probably been deleted meanwhile
			//
			continue;
		}//catch(...)
		{
			//_ASSERTE(FALSE);
			//SAFE_FaxFreeBuffer(aJobEntry);
			//throw CException(TEXT("%s(%d): CServiceMonitor::AddExistingJobs(): new CFaxJob() threw an exception"), TEXT(__FILE__), __LINE__);
		}

		if (NULL == pFaxJob)
		{
			SAFE_FaxFreeBuffer(aJobEntry);
			throw CException(TEXT("%s(%d): CServiceMonitor::AddExistingJobs(): new failed"), TEXT(__FILE__), __LINE__);
		}

		if (!m_Jobs.Add(aJobEntry[dwJob].JobId, pFaxJob))
		{
			SAFE_FaxFreeBuffer(aJobEntry);
			throw CException(TEXT("%s(%d): CServiceMonitor::AddExistingJobs(): m_Jobs.Add(%d) failed"), TEXT(__FILE__), __LINE__, aJobEntry[dwJob].JobId);
		}
	}

	SAFE_FaxFreeBuffer(aJobEntry);

	::lgLogDetail(LOG_X, 0, TEXT("Ending CServiceMonitor::AddExistingJobs()"));
}//CServiceMonitor::AddExistingJobs()

void CServiceMonitor::AddExistingDevices()
{
	PFAX_PORT_INFO aPortEntry;
	DWORD dwPortsReturned;

	::lgLogDetail(LOG_X, 0, TEXT("Starting CServiceMonitor::AddExistingDevices()"));

	if (!::FaxEnumPorts(
		m_hFax,          // handle to the fax server
		&aPortEntry,  // buffer to receive array of Port data
		&dwPortsReturned       // number of fax Port structures returned
		)
	   )
	{
		throw CException(TEXT("%s(%d): CServiceMonitor::AddExistingDevices(): ::FaxEnumPorts() failed with %d"), ::GetLastError());
	}

	for (DWORD dwPort = 0; dwPort < dwPortsReturned; dwPort++)
	{
		CFaxDevice *pFaxDevice = NULL;
		try
		{
			pFaxDevice = new CFaxDevice(
					aPortEntry[dwPort].DeviceId, 
					this,
					0//dwDisallowedEvents
					);
		}catch(CException e)
		{
			_ASSERTE(FALSE);
			SAFE_FaxFreeBuffer(aPortEntry);
			throw e;
		}//catch(...)
		{
			//_ASSERTE(FALSE);
			//SAFE_FaxFreeBuffer(aPortEntry);
			//throw CException(TEXT("%s(%d): CServiceMonitor::AddExistingDevices(): new CFaxDevice() threw an exception"), TEXT(__FILE__), __LINE__);
		}

		if (NULL == pFaxDevice)
		{
			SAFE_FaxFreeBuffer(aPortEntry);
			throw CException(TEXT("%s(%d): CServiceMonitor::AddExistingDevices(): new failed"), TEXT(__FILE__), __LINE__);
		}

		if (!m_FaxDevices.Add(aPortEntry[dwPort].DeviceId, pFaxDevice))
		{
			SAFE_FaxFreeBuffer(aPortEntry);
			throw CException(
				TEXT("%s(%d): CServiceMonitor::AddExistingDevices(): m_Ports.Add(%d) failed"), 
				TEXT(__FILE__), 
				__LINE__, 
				aPortEntry[dwPort].DeviceId
				);
		}
	}

	SAFE_FaxFreeBuffer(aPortEntry);

	::lgLogDetail(LOG_X, 0, TEXT("Ending CServiceMonitor::AddExistingDevices()"));
}//CServiceMonitor::AddExistingDevices()

//
// TODO: use the DeviceId member of pFaxEvent, to associate
// a "RINGING" with an "ANSWERED"
// do a hash table of "RINGING" devices.
// also verify that it matches the device properties.
// BUGBUG: what happens when CRM comes in?
//
void CServiceMonitor::SetMessageToDevice(const int nEventId, const DWORD dwDeviceId)
//bool CServiceMonitor::Ringing(DWORD dwDeviceId)
{
	if (0 == dwDeviceId) return;//this is a non-device

	bool fRetval = true;

	CFaxDevice *pFaxDevice = NULL;
	if (!m_FaxDevices.Get(dwDeviceId, &pFaxDevice))
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("CServiceMonitor::CServiceMonitor(): device %d added dynamically with event 0x%08X!"),
			dwDeviceId,
			nEventId
			);

		_ASSERTE(FALSE);

		try
		{
			pFaxDevice = new CFaxDevice(
				dwDeviceId, 
				this,
				0//dwDisallowedEvents
				);
		}catch(CException e)
		{
			::lgLogError(
				LOG_SEV_1, 
				TEXT("CServiceMonitor::CServiceMonitor(): new CFaxDevice(%d) threw an exception:%s"),
				dwDeviceId,
				(const TCHAR*)e
				);

		}//catch(...)
		{
			//_ASSERTE(FALSE);
			//throw CException(
			//	TEXT("%s(%d): CServiceMonitor::CServiceMonitor(): new CFaxDevice(%d) threw an exception"), 
			//	TEXT(__FILE__), 
			//	__LINE__,
			//	dwDeviceId
			//	);
		}

		if (NULL == pFaxDevice)
		{
			_ASSERTE(FALSE);
			return ;//false;
		}
		if (!m_FaxDevices.Add(dwDeviceId, pFaxDevice))
		{
			_ASSERTE(FALSE);
			return ;//false;
		}
	}//if (!m_FaxDevices.Get(dwDeviceId, &pFaxDevice))

	_ASSERTE(NULL != pFaxDevice);

	//
	// let the device know of the message
	//

	pFaxDevice->SetMessage(nEventId);


/*
	if (m_fRinging)
	{
		//
		// check how long it took from the last ring.
		// it should be less than 20 seconds
		//
		DWORD dwDiffTicks = GetDiffTime(m_dwLastRingTickCount);

		if (20*1000 < dwDiffTicks)
		{
			::lgLogError(LOG_SEV_1, TEXT("WARNING:CServiceMonitor::Ringing(): 20*1000 < dwDiffTicks(0x%08X)"), dwDiffTicks);
			fRetval = false;
			//
			// because i don't want the next ring to warn again
			//
			m_dwLastRingTickCount = ::GetTickCount();
		}
	}
	else
	{
		m_fRinging = true;
		m_dwLastRingTickCount = ::GetTickCount();
	}
	
*/
//	return fRetval;
}//CServiceMonitor::Ringing()


bool CServiceMonitor::Answered(const DWORD dwDeviceId)
{
	bool fRetval = true;
/*
	if (m_fRinging)
	{
		//
		// check how long it took from the last ring.
		// it should be less than 20 seconds
		//
		DWORD dwDiffTicks = GetDiffTime(m_dwLastRingTickCount);

		if (20*1000 < dwDiffTicks)
		{
			::lgLogError(LOG_SEV_1, TEXT("WARNING:CServiceMonitor::Answered(): 20*1000 < dwDiffTicks(0x%08X)"), dwDiffTicks);
			fRetval = false;
		}
	}
	else
	{
		//
		// BUGBUG: if the service monitor is launched after a job is ringing, and before
		// it's answered, then I will fail here!
		//
		::lgLogError(LOG_SEV_1, TEXT("CServiceMonitor::Answered(): m_fRinging is false! was ervice monitor launced while a job was aleady ringing?"));
		fRetval = false;
	}

	m_fRinging = false;
*/
	
	return fRetval;
}//CServiceMonitor::Answered()


static bool fnForEachJob(void *pVoid)
{
	CFaxJob *pFaxJob = (CFaxJob *)pVoid;
	pFaxJob->AssertStamp();

	pFaxJob->LogQueueStatus();

	pFaxJob->LogJobType();

	pFaxJob->LogStatus();

	::lgLogDetail(LOG_X, 5, TEXT(""));

	return true;
}

void CServiceMonitor::VerifyExistingJobsAfterFaxServiceIsDown()
{
	m_Jobs.ForEach(fnForEachJob);

}

static bool fnForEachDevice(void *pVoid)
{
	CFaxDevice *pFaxDevice = (CFaxDevice *)pVoid;
	pFaxDevice->AssertStamp();

	pFaxDevice->LogDeviceState();

	::lgLogDetail(LOG_X, 5, TEXT(""));

	return true;
}

void CServiceMonitor::VerifyDevicesAfterFaxServiceIsDown()
{
	m_FaxDevices.ForEach(fnForEachDevice);

}


DWORD CServiceMonitor::GetDiffTime(const DWORD dwFirstTime)
{
	DWORD dwNow = ::GetTickCount();
	if (dwFirstTime <= dwNow) return dwNow - dwFirstTime;

	return 0xFFFFFFFF - dwFirstTime + dwNow;
}


void CServiceMonitor::SafeFaxGetConfiguration()
{
	if (!FaxGetConfiguration(
			m_hFax,              // handle to the fax server
			&m_pFaxConfig  // structure to receive configuration data
			)
	   )
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("CServiceMonitor::SafeFaxGetConfiguration(): FaxGetConfiguration() failed with %d"),
			GetLastError()
			);
		throw CException(
			TEXT("CServiceMonitor::SafeFaxGetConfiguration(): FaxGetConfiguration() failed with %d"),
			GetLastError()
			);
	}
	if (NULL == m_pFaxConfig)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("CServiceMonitor::SafeFaxGetConfiguration(): (NULL == m_pFaxConfig) after FaxGetConfiguration()"));
		throw CException(
			TEXT("CServiceMonitor::SafeFaxGetConfiguration(): (NULL == m_pFaxConfig) after FaxGetConfiguration()")
			);
	}

	if (sizeof(*m_pFaxConfig) != m_pFaxConfig->SizeOfStruct)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("sizeof(*m_pFaxConfig)(%d) != m_pFaxConfig->SizeOfStruct(%d)"),
			sizeof(m_pFaxConfig),
			m_pFaxConfig->SizeOfStruct
			);
	}
	else
	{
		::lgLogDetail(LOG_X, 5, TEXT("m_pFaxConfig->SizeOfStruct=%d"), m_pFaxConfig->SizeOfStruct);
	}

	::lgLogDetail(LOG_X, 5, TEXT("m_pFaxConfig->Retries=%d"), m_pFaxConfig->Retries);
	::lgLogDetail(LOG_X, 5, TEXT("m_pFaxConfig->RetryDelay=%d"), m_pFaxConfig->RetryDelay);
	::lgLogDetail(LOG_X, 5, TEXT("m_pFaxConfig->DirtyDays=%d"), m_pFaxConfig->DirtyDays);
	::lgLogDetail(LOG_X, 5, TEXT("m_pFaxConfig->Branding=%s"), m_pFaxConfig->Branding ? TEXT("TRUE") : TEXT("FALSE"));
	::lgLogDetail(LOG_X, 5, TEXT("m_pFaxConfig->UseDeviceTsid=%s"), m_pFaxConfig->UseDeviceTsid ? TEXT("TRUE") : TEXT("FALSE"));
	::lgLogDetail(LOG_X, 5, TEXT("m_pFaxConfig->ServerCp=%s"), m_pFaxConfig->ServerCp ? TEXT("TRUE") : TEXT("FALSE"));
	::lgLogDetail(LOG_X, 5, TEXT("m_pFaxConfig->PauseServerQueue=%s"), m_pFaxConfig->PauseServerQueue ? TEXT("TRUE") : TEXT("FALSE"));
	::lgLogDetail(LOG_X, 5, TEXT("m_pFaxConfig->ArchiveOutgoingFaxes=%s"), m_pFaxConfig->ArchiveOutgoingFaxes ? TEXT("TRUE") : TEXT("FALSE"));
	::lgLogDetail(LOG_X, 5, TEXT("m_pFaxConfig->ArchiveDirectory=%s"), m_pFaxConfig->ArchiveDirectory);
	::lgLogDetail(LOG_X, 5, TEXT("m_pFaxConfig->InboundProfile=%s"), m_pFaxConfig->InboundProfile);

	//
	// verify that arcive directory exists if m_pFaxConfig->ArchiveOutgoingFaxes
	//
	if (m_pFaxConfig->ArchiveOutgoingFaxes)
	{
		if (CreateDirectory(m_pFaxConfig->ArchiveDirectory, NULL))
		{
			::lgLogError(
				LOG_SEV_1, 
				TEXT("CServiceMonitor::SafeFaxGetConfiguration(): ArchiveOutgoingFaxes=TRUE but CreateDirectory(m_pFaxConfig->ArchiveDirectory(%s)) succeeded!"),
				m_pFaxConfig->ArchiveDirectory
				);
			if (!RemoveDirectory(m_pFaxConfig->ArchiveDirectory))
			{
				::lgLogError(
					LOG_SEV_1, 
					TEXT("CServiceMonitor::SafeFaxGetConfiguration(): RemoveDirectory(m_pFaxConfig->ArchiveDirectory(%s)) failed with %d!"),
					m_pFaxConfig->ArchiveDirectory,
					GetLastError()
					);
			}
			throw CException(
				TEXT("CServiceMonitor::SafeFaxGetConfiguration(): ArchiveOutgoingFaxes=TRUE but CreateDirectory(m_pFaxConfig->ArchiveDirectory(%s)) succeeded!"),
				m_pFaxConfig->ArchiveDirectory
				);
		}

		if (GetLastError() != ERROR_ALREADY_EXISTS)
		{
			::lgLogError(
				LOG_SEV_1, 
				TEXT("CServiceMonitor::SafeFaxGetConfiguration(): ArchiveOutgoingFaxes=TRUE but CreateDirectory(m_pFaxConfig->ArchiveDirectory(%s)) failed with %d and not ERROR_ALREADY_EXISTS!"),
				m_pFaxConfig->ArchiveDirectory,
				GetLastError()
				);
			throw CException(
				TEXT("CServiceMonitor::SafeFaxGetConfiguration(): ArchiveOutgoingFaxes=TRUE but CreateDirectory(m_pFaxConfig->ArchiveDirectory(%s)) failed with %d and not ERROR_ALREADY_EXISTS!"),
				m_pFaxConfig->ArchiveDirectory,
				GetLastError()
				);
		}

		::lgLogDetail(LOG_X, 5, TEXT("CreateDirectory(m_pFaxConfig->ArchiveDirectory(%s)) failed as expected with ERROR_ALREADY_EXISTS"), m_pFaxConfig->ArchiveDirectory);
	}//if (m_pFaxConfig->ArchiveOutgoingFaxes)

	::lgLogDetail(LOG_X, 5, 
		TEXT("m_pFaxConfig->StartCheapTime=%d.%d"), 
		m_pFaxConfig->StartCheapTime.Hour,
		m_pFaxConfig->StartCheapTime.Minute
		);
	::lgLogDetail(LOG_X, 5, 
		TEXT("m_pFaxConfig->StopCheapTime=%d.%d"), 
		m_pFaxConfig->StopCheapTime.Hour,
		m_pFaxConfig->StopCheapTime.Minute
		);
}//void CServiceMonitor::SafeFaxGetConfiguration()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\servicemonitor\main.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

   simple.c

Abstract:

    This module implements a simple command line fax-send utility 
    
--*/


#include <windows.h>
#include <winbase.h>
#include <stdio.h>
#include <stdlib.h>
#include <winfax.h>
#include <tchar.h>
#include <crtdbg.h>
#include <shellapi.h>
#include <time.h>

#include "..\common\log\log.h"
#include "ServiceMonitor.h"



int _cdecl
main(
    int argc,
    char *argvA[]
    ) 
{
	TCHAR **argv;

#ifdef UNICODE
	if (NULL == (argv = CommandLineToArgvW(GetCommandLine(), &argc)))
	{
		_tprintf(TEXT("Internal error: CommandLineToArgvW() failed with %d"), GetLastError());
		exit(-1);
	}
#else
	argv = argvA;
#endif

	::lgInitializeLogger();
	::lgBeginSuite(TEXT("FaxServiceMonitor"));
	::lgBeginCase(0, TEXT("0"));

	//
	// FJB_MAY_BE_TX_ABORTED - any outgoing job may fail for whatever reason.
	// examples: an app submitted a job and aborted it, or the phone was busy.
	// this app will not abort any job
	//
	_tprintf(TEXT("FJB_MAY_BE_TX_ABORTED  0x00000001\n"));

	//
	// FJB_MAY_BE_TX_ABORTED - any incoming job may fail for whatever reason.
	// this app will not abort any job
	//
	_tprintf(TEXT("FJB_MAY_BE_RX_ABORTED  0x00000002\n"));

	//
	// FJB_MUST_FAIL - any job may not reach the FEI_COMPLETED state.
	// this app will not abort any job
	//
	_tprintf(TEXT("FJB_MUST_FAIL          0x00000004\n"));

	//
	// FJB_MAY_COMMIT_SUICIDE - this app may abort any job it chooses (randomly)
	//
	_tprintf(TEXT("FJB_MAY_COMMIT_SUICIDE 0x00000008\n"));

	//
	// FJB_MUST_SUCCEED - all jobs must reach the FEI_COMPLETED state
	//
	_tprintf(TEXT("FJB_MUST_SUCCEED       0x00000010\n"));

	_tprintf(TEXT("Please enter a combination of the above:"));

	DWORD dwJobBehavior;
	_tscanf(TEXT("%X"), &dwJobBehavior);
	_tprintf(TEXT("Entered 0x%08X\n"), dwJobBehavior);
	if (FJB_MUST_SUCCEED & dwJobBehavior)
	{
		if (FJB_MAY_BE_TX_ABORTED & dwJobBehavior)
		{
			_tprintf(TEXT("Error: FJB_MUST_SUCCEED and FJB_MAY_BE_TX_ABORTED\n"));
			exit(-1);
		}

		if (FJB_MAY_BE_RX_ABORTED & dwJobBehavior)
		{
			_tprintf(TEXT("Error: FJB_MUST_SUCCEED and FJB_MAY_BE_RX_ABORTED\n"));
			exit(-1);
		}

		if (FJB_MAY_COMMIT_SUICIDE & dwJobBehavior)
		{
			_tprintf(TEXT("Error: FJB_MUST_SUCCEED and FJB_MAY_COMMIT_SUICIDE\n"));
			exit(-1);
		}

		if (FJB_MUST_FAIL & dwJobBehavior)
		{
			_tprintf(TEXT("Error: FJB_MUST_SUCCEED and FJB_MUST_FAIL\n"));
			exit(-1);
		}

	}

	try
	{
		CServiceMonitor monitor(dwJobBehavior, argc == 1 ? NULL : argv[1]);

		if (!monitor.Start())
		{
			//_ASSERTE(FALSE);
		}
	}catch(CException e)
	{
		::lgLogError(LOG_SEV_1, TEXT("Exception:%s."), (const TCHAR*)e);
	}//catch(...)
	{
		//::lgLogError(LOG_SEV_4, TEXT("Unknown Exception"));
	}

	::lgEndCase();
	::lgEndSuite();
	::lgCloseLogger();
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\spooler\faxspooler_bvt\dummygenutils.cpp ===
#include <genutils.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\spooler\faxspooler_bvt\dummysecurity.cpp ===
#include <securityutils.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\spooler\faxspooler_bvt\dummyservice.cpp ===
#include <service.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\servicemonitor\servicemonitor.h ===
#ifndef __SERVICE_MONITOR_H
#define __SERVICE_MONITOR_H

#include "..\common\Exception\Exception.h"
#include "..\common\hash\hash.h"

#include "FaxJob.h"

class CFaxJob;
class CFaxDevice;

class CServiceMonitor
{
public:
	CServiceMonitor(const DWORD dwJobBehavior, LPCTSTR szFaxServerName = NULL);
	~CServiceMonitor();
	BOOL Start();

	friend class CFaxJob;
	friend class CFaxDevice;
	

private:
	static DWORD GetDiffTime(DWORD dwFirstTime);

	void SetMessageToDevice(const int nEventId, const DWORD dwDeviceId);
	bool Answered(const DWORD dwDeviceId);
	void SetFaxServiceWentDown(){m_fFaxServiceIsDown = true;}
	void Cleanup();
	void Init();
	void AddExistingJobs();
	void AddExistingDevices();
	void VerifyExistingJobsAfterFaxServiceIsDown();
	void VerifyDevicesAfterFaxServiceIsDown();
	void IncJobCount() { m_nJobCount++; }
	void DecJobCount() { m_nJobCount--; _ASSERTE(0 <= m_nJobCount);  if (0 > m_nJobCount) _tprintf(TEXT("(0 > m_nJobCount(%d))"), m_nJobCount);}
	void IncDeviceCount() { m_nDeviceCount++; }
	void DecDeviceCount() { m_nDeviceCount--; _ASSERTE(0 <= m_nDeviceCount);}
	void SafeFaxGetConfiguration();


	PFAX_CONFIGURATION m_pFaxConfig;
	TCHAR *m_szFaxServerName;
	HANDLE m_hFax;
	HANDLE m_hCompletionPort;
	CHash<CFaxJob, int, 100> m_Jobs;
	CHash<CFaxDevice, int, 100> m_FaxDevices;
	bool m_fFaxServiceIsDown;
	int m_nJobCount;
	int m_nDeviceCount;
	DWORD m_dwJobBehavior;
};

#endif //__SERVICE_MONITOR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\spooler\printfaxtodevicecontext\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by simple.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\spooler\faxspooler_bvt\dummytestsuite.cpp ===
#include <testsuite.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\spooler\faxspooler_bvt\queuing.h ===
#ifndef __QUEUING_H__
#define __QUEUING_H__

#include <testsuite.h>

extern const TESTAREA gc_QueuingTestArea;

DWORD TestCase_SendAndVerify	(const TESTPARAMS *pTestParams, LPCTSTR lpctstrSection, BOOL *pbPassed);
DWORD TestCase_CheckFileName	(const TESTPARAMS *pTestParams, LPCTSTR lpctstrSection, BOOL *pbPassed);

#endif /* #ifndef __QUEUING_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\spooler\faxspooler_bvt\faxspoolerbvt.h ===
#ifndef __FAX_SPOOLER_BVT_H__
#define __FAX_SPOOLER_BVT_H__

// SendWizard registry hack
#define REGKEY_WZRDHACK         TEXT("Software\\Microsoft\\Fax\\UserInfo\\WzrdHack")
#define REGVAL_FAKECOVERPAGE    TEXT("FakeCoverPage")
#define REGVAL_FAKETESTSCOUNT   TEXT("FakeTestsCount")
#define REGVAL_FAKERECIPIENT    TEXT("FakeRecipient0")


typedef struct recipientinfo_tag {
    LPTSTR lptstrName;
    LPTSTR lptstrNumber;
} RECIPIENTINFO;


struct testparams_tag {
    LPTSTR              lptstrIniFile;
    LPTSTR              lptstrServer;
    LPTSTR              lptstrRemotePrinter;
    LPTSTR              lptstrRegHackKey;
    LPTSTR              lptstrDocument;
    LPTSTR              lptstrPersonalCoverPage;
    LPTSTR              lptstrServerCoverPage;
    LPTSTR              lptstrWorkDirectory;
    LPTSTR              lptstrVFSPFullPathLocal;
    LPTSTR              lptstrVFSPFullPathRemote;
    LPTSTR              lptstrVFSPGUID;
    LPTSTR              lptstrVFSPFriendlyName;
    LPTSTR              lptstrVFSPTSPName;
    DWORD               dwVFSPIVersion;
    DWORD               dwVFSPCapabilities;
    BOOL                bSaveNotIdenticalFiles;
    const RECIPIENTINFO *pRecipients;
    DWORD               dwRecipientsCount;
};

#endif // #ifndef __FAX_SPOOLER_BVT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\stress\stressmngr\cjobparams.h ===
#ifndef _JOB_PARAMS_H
#define _JOB_PARAMS_H

#include <winfax.h>
#include <ptrs.h>
#include "PrepareJobParams.cpp"

typedef struct JOB_PARAMS_p 
{
	const TCHAR *szDocument;
	PFAX_JOB_PARAM pJobParam;
	PFAX_COVERPAGE_INFO pCoverpageInfo;
	DWORD dwParentJobId;
}JOB_PARAMS;

typedef struct JOB_BEHAVIOR_p
{
	DWORD dwJobType;
	DWORD dwParam1;
	DWORD dwParam2;
}JOB_BEHAVIOR;


class JOB_PARAMS_EX
{
public:
	JOB_PARAMS_EX();
	~JOB_PARAMS_EX();

	//
	//JOB_PARAMS_EX():pdwRecepientsId(SPTR<DWORD>(NULL)){};
	SPTR<TCHAR> szDocument;
	PersonalProfile pSenderProfile;
	ListPersonalProfile pRecepientList;
	BasicJobParamsEx* pJobParam;
	CoverPageInfo pCoverpageInfo;
	DWORD dwNumRecipients;
	DWORD dwParentJobId;
	SPTR<DWORD> pdwRecepientsId;
	JOB_BEHAVIOR* pRecipientsBehavior;

};

inline JOB_PARAMS_EX::JOB_PARAMS_EX():
pJobParam(NULL)
{
}

inline JOB_PARAMS_EX::~JOB_PARAMS_EX()
{
	delete pJobParam;
}
#endif //JOB_PARAMS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\spooler\faxspooler_bvt\faxspoolerbvt.cpp ===
/*++
    This file implements main driver and common utils for Spooler test

    Author: Yury Berezansky (yuryb)

    23-Jan-2001
--*/

#pragma warning(disable :4786)

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <tchar.h>
#include <crtdbg.h>
#include <stddef.h>
#include <winspool.h>
#include <fxsapip.h>
#include <faxreg.h>

#include <iniutils.h>
#include <log.h>
#include <RegHackUtils.h>
#include <genutils.h>
#include <testsuite.h>
#include <service.h>

#include "FaxSpoolerBVT.h"
#include "Queuing.h"





/**************************************************************************************************************************
    General declarations and definitions
**************************************************************************************************************************/

#define COUNT_ARGUMENTS         1
#define ARG_INIFILE             1

#define INI_SEC_GENERAL         TEXT("General")
#define INI_DEFAULT_FILE        TEXT("TestParams.ini")


// Used to read TESTPARAMS from inifile
static const MEMBERDESCRIPTOR sc_aTestParamsDescIni[] = {
    {TEXT("Server"),                TYPE_LPTSTR,    offsetof(TESTPARAMS, lptstrServer)              },
    {TEXT("Document"),              TYPE_LPTSTR,    offsetof(TESTPARAMS, lptstrDocument)            },
    {TEXT("PersonalCoverPage"),     TYPE_LPTSTR,    offsetof(TESTPARAMS, lptstrPersonalCoverPage)   },
    {TEXT("ServerCoverPage"),       TYPE_LPTSTR,    offsetof(TESTPARAMS, lptstrServerCoverPage)     },
    {TEXT("WorkDirectory"),         TYPE_LPTSTR,    offsetof(TESTPARAMS, lptstrWorkDirectory)       },
    {TEXT("VFSPFullPathLocal"),     TYPE_LPTSTR,    offsetof(TESTPARAMS, lptstrVFSPFullPathLocal)   },
    {TEXT("VFSPFullPathRemote"),    TYPE_LPTSTR,    offsetof(TESTPARAMS, lptstrVFSPFullPathRemote)  },
    {TEXT("VFSPGUID"),              TYPE_LPTSTR,    offsetof(TESTPARAMS, lptstrVFSPGUID)            },
    {TEXT("VFSPFriendlyName"),      TYPE_LPTSTR,    offsetof(TESTPARAMS, lptstrVFSPFriendlyName)    },
    {TEXT("VFSPTSPName"),           TYPE_LPTSTR,    offsetof(TESTPARAMS, lptstrVFSPTSPName)         },
    {TEXT("VFSPIVersion"),          TYPE_DWORD,     offsetof(TESTPARAMS, dwVFSPIVersion)            },
    {TEXT("VFSPCapabilities"),      TYPE_DWORD,     offsetof(TESTPARAMS, dwVFSPCapabilities)        },
    {TEXT("SaveNotIdenticalFiles"), TYPE_BOOL,      offsetof(TESTPARAMS, bSaveNotIdenticalFiles)    }
};

// Used to log and free TESTPARAMS
static const MEMBERDESCRIPTOR sc_aSendParamsDescFree[] = {
    {TEXT("IniFile"),                   TYPE_LPTSTR,    offsetof(TESTPARAMS, lptstrIniFile)             },
    {TEXT("Server"),                    TYPE_LPTSTR,    offsetof(TESTPARAMS, lptstrServer)              },
    {TEXT("RemotePrinter"),             TYPE_LPTSTR,    offsetof(TESTPARAMS, lptstrRemotePrinter)       },
    {TEXT("RegHackKey"),                TYPE_LPTSTR,    offsetof(TESTPARAMS, lptstrRegHackKey)          },
    {TEXT("Document"),                  TYPE_LPTSTR,    offsetof(TESTPARAMS, lptstrDocument)            },
    {TEXT("PersonalCoverPage"),         TYPE_LPTSTR,    offsetof(TESTPARAMS, lptstrPersonalCoverPage)   },
    {TEXT("ServerCoverPage"),           TYPE_LPTSTR,    offsetof(TESTPARAMS, lptstrServerCoverPage)     },
    {TEXT("WorkDirectory"),             TYPE_LPTSTR,    offsetof(TESTPARAMS, lptstrWorkDirectory)       },
    {TEXT("VFSPFullPathLocal"),         TYPE_LPTSTR,    offsetof(TESTPARAMS, lptstrVFSPFullPathLocal)   },
    {TEXT("VFSPFullPathRemote"),        TYPE_LPTSTR,    offsetof(TESTPARAMS, lptstrVFSPFullPathRemote)  },
    {TEXT("VFSPGUID"),                  TYPE_LPTSTR,    offsetof(TESTPARAMS, lptstrVFSPGUID)            },
    {TEXT("VFSPFriendlyName"),          TYPE_LPTSTR,    offsetof(TESTPARAMS, lptstrVFSPFriendlyName)    },
    {TEXT("VFSPTSPName"),               TYPE_LPTSTR,    offsetof(TESTPARAMS, lptstrVFSPTSPName)         },
    {TEXT("VFSPIVersion"),              TYPE_DWORD,     offsetof(TESTPARAMS, dwVFSPIVersion)            },
    {TEXT("VFSPCapabilities"),          TYPE_DWORD,     offsetof(TESTPARAMS, dwVFSPCapabilities)        },
    {TEXT("SaveNotIdenticalFiles"),     TYPE_BOOL,      offsetof(TESTPARAMS, bSaveNotIdenticalFiles)    },
    {TEXT("Recipients"),                TYPE_UNKNOWN,   offsetof(TESTPARAMS, pRecipients)               },
    {TEXT("RecipientsCount"),           TYPE_DWORD,     offsetof(TESTPARAMS, dwRecipientsCount)         }
};


static const RECIPIENTINFO sc_aRecipients[] = {
    {TEXT("Recipient1"), TEXT("XXXX")},
    {TEXT("Recipient2"), TEXT("XXXX")},
    {TEXT("Recipient3"), TEXT("XXXX")}
};



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Test Suite definition
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// add here test areas, you want to be available
static const TESTAREA *sc_aSpoolerSuiteTestAreas[] = {
    &gc_QueuingTestArea
};


// the structure describes the test suite
static const TESTSUITE sc_SpoolerTestSuite = {
    TEXT("Spooler test"),
    sc_aSpoolerSuiteTestAreas,
    sizeof(sc_aSpoolerSuiteTestAreas) / sizeof(sc_aSpoolerSuiteTestAreas[0])
};





/**************************************************************************************************************************
    Static functions declarations
**************************************************************************************************************************/

static DWORD GetFileFullPath            (LPCTSTR lpctstrFileName, LPTSTR *lplptstrFileFullPath);
static DWORD GetTestParams              (TESTPARAMS **ppTestParams, LPCTSTR lpctstrIniFile);
static DWORD FreeTestParams             (TESTPARAMS **ppTestParams);
static DWORD RegisterFSP                (const TESTPARAMS *pTestParams, BOOL bRemote);
static DWORD GetRegHackKey              (LPTSTR *lplptstrKey);
static DWORD TurnOffCfgWzrd             (void);





/**************************************************************************************************************************
    Functions definitions
**************************************************************************************************************************/

#ifdef _UNICODE

int __cdecl wmain(int argc, wchar_t *argv[])

#else

int __cdecl main(int argc, char *argv[])

#endif
{
    LPTSTR      lptstrIniFileName       = NULL;
    TESTPARAMS  *pTestParams            = NULL;
    DWORD       dwEC                    = ERROR_SUCCESS;
    DWORD       dwCleanUpEC             = ERROR_SUCCESS;

    // check number of command line argumnets
    if (argc == COUNT_ARGUMENTS + 1)
    {
        lptstrIniFileName = argv[ARG_INIFILE];
    }
    else if (argc == 1)
    {
        // supply defaults

        lptstrIniFileName = INI_DEFAULT_FILE;
    }
    else
    {
        _tprintf(TEXT("Usage: SpoolerTest [inifile]\n"));
        return ERROR_INVALID_COMMAND_LINE;
    }
    
    dwEC = InitSuiteLog(sc_SpoolerTestSuite.szName);
    if (dwEC != ERROR_SUCCESS)
    {
        _tprintf(
            TEXT("FILE:%s LINE:%ld InitSuiteLog failed (ec = 0x%08lX)\n"),
            TEXT(__FILE__),
            __LINE__,
            dwEC
            );
        return dwEC;
    }

    dwEC = GetTestParams(&pTestParams, lptstrIniFileName);
    if (dwEC != ERROR_SUCCESS)
    {
        lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%ld GetTestParams failed (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            dwEC
            );
        goto exit_func;
    }

    // Register FSP on the remote server
    dwEC = RegisterFSP(pTestParams, TRUE);
    if (dwEC != ERROR_SUCCESS)
    {
        lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%ld Failed to register FSP on the remote server %s (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            pTestParams->lptstrServer,
            dwEC
            );
        goto exit_func;
    }

    // Register FSP on the local server
    dwEC = RegisterFSP(pTestParams, FALSE);
    if (dwEC != ERROR_SUCCESS)
    {
        lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%ld Failed to register FSP on the local server (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            dwEC
            );
        goto exit_func;
    }

    // Add printer connection to the fax printer on the remote server
    if (!AddPrinterConnection(pTestParams->lptstrRemotePrinter))
    {
        dwEC = GetLastError();
        lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%ld Failed to add printer connection to %s (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            pTestParams->lptstrRemotePrinter,
            dwEC
            );
        goto exit_func;
    }

    // Prevent implicit invocation of the configuration wizard on the local server
    dwEC = TurnOffCfgWzrd();
    if (dwEC != ERROR_SUCCESS)
    {
        lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%ld TurnOffCfgWzrd failed (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            dwEC
            );
        goto exit_func;
    }

    // Run the suite
    dwEC = RunSuite(&sc_SpoolerTestSuite, pTestParams, pTestParams->lptstrIniFile);
    if (dwEC != ERROR_SUCCESS)
    {
        lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%ld RunSuite failed (ec = 0x%08lX)\n"),
            TEXT(__FILE__),
            __LINE__,
            dwEC
            );
        goto exit_func;
    }

exit_func:
    
    if (pTestParams)
    {
        dwCleanUpEC = FreeTestParams(&pTestParams);
        if (dwCleanUpEC != ERROR_SUCCESS)
        {
            _tprintf(
                TEXT("FILE:%s LINE:%ld FreeTestParams failed (ec = 0x%08lX)\n"),
                TEXT(__FILE__),
                __LINE__,
                dwCleanUpEC
                );
        }
    }

    dwCleanUpEC = EndSuiteLog();
    if (dwCleanUpEC != ERROR_SUCCESS)
    {
        _tprintf(
            TEXT("FILE:%s LINE:%ld EndSuiteLog failed (ec = 0x%08lX)\n"),
            TEXT(__FILE__),
            __LINE__,
            dwCleanUpEC
            );
    }

    return dwEC;
}



/*++
    Creates the full path of file.
    For more details on searched directories see Platform SDK, Files and I/O, SearchPath()
  
    [IN]    lpctstrIniFile              Name of file

    [OUT]   lplptstrFileFullPath        Pointer to pointer to a full path of the file
                                        *lplptstrFileFullPath remains untouched if the function failes

    Return value:                       Win32 error code
--*/
static DWORD GetFileFullPath (LPCTSTR lpctstrFileName, LPTSTR *lplptstrFileFullPath)
{
    LPTSTR  lptstrFilePart  = NULL;
    DWORD   dwRequiredSize  = 0;
    DWORD   dwEC            = ERROR_SUCCESS;

    lgLogDetail(
        LOG_X, 
        5,
        TEXT("Entering GetFileFullPath\n\tlpctstrFileName = %s\n\tlplptstrFileFullPath = 0x%08lX"),
        lpctstrFileName,
        (DWORD)lplptstrFileFullPath
        );

    if (!(lpctstrFileName && lplptstrFileFullPath))
    {
        lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%ld Call to GetFileFullPath() with invalid parameters"),
            TEXT(__FILE__),
            __LINE__
            );

        // no clean up needed at this stage
        return ERROR_INVALID_PARAMETER;
    }

    dwRequiredSize = SearchPath(NULL, lpctstrFileName, NULL, 0, NULL, &lptstrFilePart);
    if (dwRequiredSize == 0)
    {
        dwEC = GetLastError();
        lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%ld SearchPath failed to find %s (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            lptstrFilePart,
            dwEC
            );
        goto exit_func;
    }

    if (!(*lplptstrFileFullPath = (LPTSTR)LocalAlloc(LMEM_FIXED, dwRequiredSize * sizeof(TCHAR))))
    {
        dwEC = GetLastError();
        lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%ld LocalAlloc failed (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            dwEC
            );
        goto exit_func;
    }

    dwRequiredSize = SearchPath(NULL, lpctstrFileName, NULL, dwRequiredSize, *lplptstrFileFullPath, &lptstrFilePart);
    if (dwRequiredSize == 0)
    {
        dwEC = GetLastError();
        lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%ld SearchPath failed to find %s (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            lptstrFilePart,
            dwEC
            );
        goto exit_func;
    }

exit_func:

    if (dwEC != ERROR_SUCCESS)
    {
        if (*lplptstrFileFullPath && LocalFree(*lplptstrFileFullPath) != NULL)
        {
            lgLogError(
                LOG_SEV_2, 
                TEXT("FILE:%s LINE:%ld LocalAlloc failed (ec = 0x%08lX)"),
                TEXT(__FILE__),
                __LINE__,
                GetLastError()
                );
        }
    }
    
    return dwEC;
}



/*++
    Reads settings from inifile and saves them in TESTPARAMS structure
    The structure is allocated by the function and should be freed by FreeTestParams()
  
    [OUT]   ppTestParams        Pointer to pointer to TESTPARAMS structure
                                *ppTestParams must be NULL when the function is called
                                *ppTestParams remains NULL if the function failes
    [IN]    lpctstrIniFile      Name of inifile

    Return value:               Win32 error code

    If the function failes, it destroyes partially initialized structure and sets *ppTestParams to NULL
--*/
static DWORD GetTestParams(TESTPARAMS **ppTestParams, LPCTSTR lpctstrIniFile)
{
    std::map<tstring, tstring>::const_iterator MapIterator;

    LPTSTR  lptstrIniFileFullPath   = NULL;
    DWORD   dwInd                   = 0;
    DWORD   dwEC                    = ERROR_SUCCESS;

    lgLogDetail(
        LOG_X, 
        5,
        TEXT("Entering GetTestParams\n\tppTestParams = 0x%08lX\n\tlpctstrIniFile = %s"),
        (DWORD)ppTestParams,
        lpctstrIniFile
        );

    if (!(ppTestParams && lpctstrIniFile))
    {
        lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%ld Call to GetTestParams() with invalid parameters"),
            TEXT(__FILE__),
            __LINE__
            );

        // no clean up needed at this stage
        return ERROR_INVALID_PARAMETER;
    }

    // Get full path of inifile
    dwEC = GetFileFullPath(lpctstrIniFile, &lptstrIniFileFullPath);
    if (dwEC != ERROR_SUCCESS)
    {
        lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%ld Failed to get inifile full path (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            dwEC
            );
        goto exit_func;
    }

    // Allocate and initialize to zero (LPTR flag)
    if (!(*ppTestParams = (TESTPARAMS *)LocalAlloc(LPTR, sizeof(TESTPARAMS))))
    {
        dwEC = GetLastError();
        lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%ld LocalAlloc failed (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            dwEC
            );
        goto exit_func;
    }

    dwEC = StrAllocAndCopy(&((*ppTestParams)->lptstrIniFile), lptstrIniFileFullPath);
    if (dwEC != ERROR_SUCCESS)
    {
        lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%ld StrAllocAndCopy failed (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            dwEC
            );
        goto exit_func;
    }

    dwEC = GetRegHackKey(&((*ppTestParams)->lptstrRegHackKey));
    if (dwEC != ERROR_SUCCESS)
    {
        lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%ld GetRegHackKey failed (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            dwEC
            );
        goto exit_func;
    }

    dwEC = ReadStructFromIniFile(
        *ppTestParams,
        sc_aTestParamsDescIni,
        sizeof(sc_aTestParamsDescIni) / sizeof(sc_aTestParamsDescIni[0]),
        (*ppTestParams)->lptstrIniFile,
        INI_SEC_GENERAL
        );
    if (dwEC != ERROR_SUCCESS)
    {
        lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%ld Failed to read TESTPARAMS structure from %s section of %s file (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            INI_SEC_GENERAL,
            (*ppTestParams)->lptstrIniFile,
            dwEC
            );
        goto exit_func;
    }

    // Allocate memory for remote printer UNC name: "\\", server, "\", printer, '\0'
    (*ppTestParams)->lptstrRemotePrinter = (TCHAR*)LocalAlloc(
        LMEM_FIXED,
        (_tcslen((*ppTestParams)->lptstrServer) + _tcslen(FAX_PRINTER_NAME) + 4) * sizeof(TCHAR)
        );
    if(!(*ppTestParams)->lptstrRemotePrinter)
    {
        dwEC = GetLastError();
        lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%ld LocalAlloc failed (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            dwEC
            );
        goto exit_func;
    }

    // Combine server and printer into UNC name
    _stprintf((*ppTestParams)->lptstrRemotePrinter, TEXT("\\\\%s\\%s"), (*ppTestParams)->lptstrServer, FAX_PRINTER_NAME);
    
    (*ppTestParams)->pRecipients = sc_aRecipients;
    (*ppTestParams)->dwRecipientsCount = sizeof(sc_aRecipients) / sizeof(sc_aRecipients[0]);

exit_func:

    if (lptstrIniFileFullPath && LocalFree(lptstrIniFileFullPath) != NULL)
    {
        lgLogError(
            LOG_SEV_2, 
            TEXT("FILE:%s LINE:%ld LocalFree failed (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            GetLastError()
            );
    }

    if (dwEC != ERROR_SUCCESS && *ppTestParams)
    {
        // TESTPARAMS structure is partially initialized, should free

        DWORD dwCleanUpEC = FreeTestParams(ppTestParams);
        if (dwCleanUpEC != ERROR_SUCCESS)
        {
            lgLogError(
                LOG_SEV_2, 
                TEXT("FILE:%s LINE:%ld FreeTestParams failed (ec = 0x%08lX)"),
                TEXT(__FILE__),
                __LINE__,
                dwCleanUpEC
                );
        }
    }

    return dwEC;
}



/*++
    Frees TESTPARAMS structure, initialized by GetTestParams()
  
    [IN/OUT]    ppTestParams    Pointer to pointer to TESTPARAMS structure
                                ppTestParams must point to a valid pointer
                                *ppTestParams is set to NULL
    [IN]        pTestSuite      Pointer to TESTSUITE structure

    Return value:               Win32 error code
--*/
static DWORD FreeTestParams(TESTPARAMS **ppTestParams)
{
    DWORD dwInd = 0;
    DWORD dwEC  = ERROR_SUCCESS;

    lgLogDetail(
        LOG_X, 
        5,
        TEXT("Entering FreeTestParams\n\tppTestParams = 0x%08lX"),
        (DWORD)ppTestParams
        );

    if (!(ppTestParams && *ppTestParams))
    {
        lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%ld Call to FreeTestParams() with invalid parameters"),
            TEXT(__FILE__),
            __LINE__
            );

        return ERROR_INVALID_PARAMETER;
    }

    // Free all strings and TESTPARAMS structure itself
    dwEC = FreeStruct(
        *ppTestParams,
        sc_aSendParamsDescFree,
        sizeof(sc_aSendParamsDescFree) / sizeof(sc_aSendParamsDescFree[0]),
        TRUE
        );
    if (dwEC != ERROR_SUCCESS)
    {
        lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%ld FreeStruct failed (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            dwEC
            );
    }

    *ppTestParams = NULL;

    return dwEC;
}



/*++
    Registers FSP on local or remote server

    [IN]    pTestParams     Pointer to TESTPARAMS structure
    [IN]    bRemote         Specifies whether an FSP should be registered on the remote server
                            (otherwise on the local server)

    Return value:           Win32 error code
--*/
static DWORD RegisterFSP(const TESTPARAMS *pTestParams, BOOL bRemote)
{
    LPCTSTR lpctstrServer       = NULL;
    LPCTSTR lpctstrVFSPFullPath = NULL;
    HANDLE  hFaxServer          = NULL;
    DWORD   dwEC                = ERROR_SUCCESS;

    lgLogDetail(
        LOG_X, 
        5,
        TEXT("Entering RegisterFSP\n\tpTestParams = 0x%08lX\n\tbRemote = %ld"),
        pTestParams,
        bRemote
        );

    if (!pTestParams)
    {
        lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%ld Call to RegisterFSP() with invalid parameters"),
            TEXT(__FILE__),
            __LINE__
            );

        // no clean up needed at this stage
        return ERROR_INVALID_PARAMETER;
    }

    // Take server name and VFSP full path according to local/remote
    lpctstrServer       = bRemote ? pTestParams->lptstrServer : NULL;
    lpctstrVFSPFullPath = bRemote ? pTestParams->lptstrVFSPFullPathRemote : pTestParams->lptstrVFSPFullPathLocal;

    // Connect to the fax server
    if (!FaxConnectFaxServer(lpctstrServer, &hFaxServer))
    {
        dwEC = GetLastError();
        lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%ld FaxConnectFaxServer failed (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            dwEC
            );
        goto exit_func;
    }

    // Register FSP
    if (!FaxRegisterServiceProviderEx(
        hFaxServer,
        pTestParams->lptstrVFSPGUID,
        pTestParams->lptstrVFSPFriendlyName,
        lpctstrVFSPFullPath,
        pTestParams->lptstrVFSPTSPName,
        pTestParams->dwVFSPIVersion,
        pTestParams->dwVFSPCapabilities
        ))
    {
        dwEC = GetLastError();
        if (dwEC == ERROR_ALREADY_EXISTS)
        {
            dwEC = ERROR_SUCCESS;
        }
        else
        {
            lgLogError(
                LOG_SEV_1, 
                TEXT("FILE:%s LINE:%ld FaxRegisterServiceProviderEx failed (ec = 0x%08lX)"),
                TEXT(__FILE__),
                __LINE__,
                dwEC
                );
        }

        goto exit_func;
    }

    // Disconnect from the fax server
    if (!FaxClose(hFaxServer))
    {
        dwEC = GetLastError();
        lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%ld FaxClose failed (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            dwEC
            );
        goto exit_func;
    }
    hFaxServer = NULL;
    
    // Restart fax service
    if (!ServiceRequest(lpctstrServer, FAX_SERVICE_NAME, SERVICE_REQUEST_STOP))
    {
        dwEC = GetLastError();
        if (dwEC != ERROR_SERVICE_NOT_ACTIVE)
        {
            lgLogError(
                LOG_SEV_1, 
                TEXT("FILE:%s LINE:%ld Failed to stop Fax service (ec = 0x%08lX)"),
                TEXT(__FILE__),
                __LINE__,
                dwEC
                );
            goto exit_func;
        }
        dwEC = ERROR_SUCCESS;
    }

    if (!ServiceRequest(lpctstrServer, FAX_SERVICE_NAME, SERVICE_REQUEST_START))
    {
        dwEC = GetLastError();
        if (dwEC != ERROR_SERVICE_ALREADY_RUNNING)
        {
            lgLogError(
                LOG_SEV_1, 
                TEXT("FILE:%s LINE:%ld Failed to start Fax service (ec = 0x%08lX)"),
                TEXT(__FILE__),
                __LINE__,
                dwEC
                );
            goto exit_func;
        }
        dwEC = ERROR_SUCCESS;
    }

exit_func:

    if (hFaxServer && !FaxClose(hFaxServer))
    {
        lgLogError(
            LOG_SEV_2, 
            TEXT("FILE:%s LINE:%ld FaxClose failed (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
             GetLastError()
            );
    }

    return dwEC;
}



/*++
    Composes the registry hack key name
    The function allocates memory that should be freed by call to LocalFree().

    [OUT]   lplpctstrKey    Pointer to pointer to key name
                            *lplpctstrKey must be NULL when the function is called
                            *lplpctstrKey remains NULL if the function failes

    Return value:           Win32 error code
--*/
static DWORD GetRegHackKey(LPTSTR *lplptstrKey)
{
    PSID    pCurrentUserSid = NULL;
    LPTSTR  lptstrTmp       = NULL;
    DWORD   dwEC            = ERROR_SUCCESS;

    lgLogDetail(
        LOG_X, 
        5,
        TEXT("Entering GetRegHackKey\n\tlplptstrKey = 0x%08lX"),
        (DWORD)lplptstrKey
        );

    if (!lplptstrKey)
    {
        lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%ld Call to GetRegHackKey() with invalid parameters"),
            TEXT(__FILE__),
            __LINE__
            );

        // no clean up needed at this stage
        return ERROR_INVALID_PARAMETER;
    }
    
    dwEC = GetCurrentUserSid((PBYTE*)&pCurrentUserSid);
    if (dwEC != ERROR_SUCCESS)
    {
        lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%ld QueryServiceStatus failed (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            dwEC
            );
        goto exit_func;
    }

    dwEC = FormatUserKeyPath(pCurrentUserSid, REGKEY_WZRDHACK, &lptstrTmp);
    if (dwEC != ERROR_SUCCESS)
    {
        lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%ld FormatUserKeyPath failed (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            dwEC
            );
        goto exit_func;
    }

    dwEC = StrAllocAndCopy(lplptstrKey, lptstrTmp);
    if (dwEC != ERROR_SUCCESS)
    {
        lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%ld StrAllocAndCopy failed (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            dwEC
            );
        goto exit_func;
    }

exit_func:

    if (lptstrTmp)
    {
        delete lptstrTmp;
    }

    return dwEC;
}



/*++
    Turns off implicit invocation of Configuration Wizard.

    Return value:           Win32 error code
--*/
static DWORD TurnOffCfgWzrd(void)
{
    DWORD           dwVersion       = 0;
    DWORD           dwMajorWinVer   = 0;
    DWORD           dwMinorWinVer   = 0;
    HKEY            hkService       = NULL;
    HKEY            hkUserInfo      = NULL;
    const DWORD     dwValue         = 1;
    DWORD           dwEC            = ERROR_SUCCESS;
    DWORD           dwCleanUpEC     = ERROR_SUCCESS;

    lgLogDetail(
        LOG_X, 
        5,
        TEXT("Entering TurnOffCfgWzrd")
        );

    dwVersion = GetVersion();
    dwMajorWinVer = (DWORD)(LOBYTE(LOWORD(dwVersion)));
    dwMinorWinVer = (DWORD)(HIBYTE(LOWORD(dwVersion)));

    if (!(dwMajorWinVer == 5 && dwMinorWinVer >= 1))
    {
        // OS is not Whistler - Configuration Wizard doesn't exist

        goto exit_func;
    }

    // set the flag responsible for service part
    dwEC = RegCreateKeyEx(
        HKEY_LOCAL_MACHINE,
        REGKEY_FAXSERVER,
        0,
        NULL,
        REG_OPTION_NON_VOLATILE,
        KEY_SET_VALUE,
        NULL,
        &hkService,
        NULL
        );
    if (dwEC != ERROR_SUCCESS)
    {
        lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%ld Failed to create HKEY_LOCAL_MACHINE\\%s registry key (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            REGKEY_FAXSERVER,
            dwEC
            );
        return dwEC;
    }
    dwEC = RegSetValueEx(
        hkService,
        REGVAL_CFGWZRD_DEVICE,
        0,
        REG_DWORD,
        (CONST BYTE *)&dwValue,
        sizeof(dwValue)
        );
    if (dwEC != ERROR_SUCCESS)
    {
        lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%ld Failed to set %s registry value (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            REGVAL_CFGWZRD_DEVICE,
            dwEC
            );
        goto exit_func;
    }

    // set the flag responsible for user part
    dwEC = RegCreateKeyEx(
        HKEY_CURRENT_USER,
        REGKEY_FAX_SETUP,
        0,
        NULL,
        REG_OPTION_NON_VOLATILE,
        KEY_SET_VALUE,
        NULL,
        &hkUserInfo,
        NULL
        );
    if (dwEC != ERROR_SUCCESS)
    {
        lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%ld Failed to create HKEY_CURRENT_USER\\%s registry key (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            REGKEY_FAX_SETUP,
            dwEC
            );
        goto exit_func;
    }
    dwEC = RegSetValueEx(
        hkUserInfo,
        REGVAL_CFGWZRD_USER_INFO,
        0,
        REG_DWORD,
        (CONST BYTE *)&dwValue,
        sizeof(dwValue)
        );
    if (dwEC != ERROR_SUCCESS)
    {
        lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%ld Failed to set %s registry value (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            REGVAL_CFGWZRD_USER_INFO,
            dwEC
            );
        goto exit_func;
    }

exit_func:

    if (hkService)
    {
        dwCleanUpEC = RegCloseKey(hkService);
        if (dwCleanUpEC != ERROR_SUCCESS)
        {
            lgLogError(
                LOG_SEV_2,
                TEXT("FILE:%s LINE:%ld RegCloseKey failed (ec = 0x%08lX)"),
                TEXT(__FILE__),
                __LINE__,
                dwCleanUpEC
                );
        }
    }
    if (hkUserInfo)
    {
        dwCleanUpEC = RegCloseKey(hkUserInfo);
        if (dwCleanUpEC != ERROR_SUCCESS)
        {
            lgLogError(
                LOG_SEV_2,
                TEXT("FILE:%s LINE:%ld RegCloseKey failed (ec = 0x%08lX)"),
                TEXT(__FILE__),
                __LINE__,
                dwCleanUpEC
                );
        }
    }

    return dwEC;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\spooler\faxspooler_bvt\queuing.cpp ===
/*++
    This file implements a test of interaction of Fax Service with the spooler

    Author: Yury Berezansky (yuryb)

    23-Jan-2001
--*/

#pragma warning(disable :4786)

#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include <crtdbg.h>
#include <stddef.h>
#include <FXSAPIP.h>
#include <faxreg.h>

#include <securityutils.h>
#include <log.h>

#ifdef __cplusplus
extern "C" {
#endif
#include <TiffTools.h>
#ifdef __cplusplus
}
#endif

#include "FaxSpoolerBVT.h"
#include "Queuing.h"





/**************************************************************************************************************************
    General declarations and definitions
**************************************************************************************************************************/

// Used as timeout for server notifications (in GetQueuedCompletionStatus() call)
#define NOTIFICATIONS_TIMEOUT       1000*60

#define FAX_ACCESS_RIGHTS_ALL      (FAX_ACCESS_SUBMIT               |   \
                                    FAX_ACCESS_SUBMIT_NORMAL        |   \
                                    FAX_ACCESS_SUBMIT_HIGH          |   \
                                    FAX_ACCESS_QUERY_JOBS           |   \
                                    FAX_ACCESS_MANAGE_JOBS          |   \
                                    FAX_ACCESS_QUERY_CONFIG         |   \
                                    FAX_ACCESS_MANAGE_CONFIG        |   \
                                    FAX_ACCESS_QUERY_IN_ARCHIVE     |   \
                                    FAX_ACCESS_MANAGE_IN_ARCHIVE    |   \
                                    FAX_ACCESS_QUERY_OUT_ARCHIVE    |   \
                                    FAX_ACCESS_MANAGE_OUT_ARCHIVE)

#define FAX_ACCESS_RIGHTS_USER     (FAX_ACCESS_SUBMIT               |   \
                                    FAX_ACCESS_SUBMIT_NORMAL)


typedef struct sendparams_tag {
    BOOL    bTemporaryDisabled;
    BOOL    bDocument;
    DWORD   dwCoverPageType;
    BOOL    bBroadcast;
    BOOL    bRemote;
} SENDPARAMS;

static const MEMBERDESCRIPTOR sc_aSendParamsDescIni[] = {
    {TEXT("TemporaryDisabled"), TYPE_BOOL,  offsetof(SENDPARAMS, bTemporaryDisabled)    },
    {TEXT("Document"),          TYPE_BOOL,  offsetof(SENDPARAMS, bDocument)             },
    {TEXT("CoverPageType"),     TYPE_DWORD, offsetof(SENDPARAMS, dwCoverPageType)       },
    {TEXT("Broadcast"),         TYPE_BOOL,  offsetof(SENDPARAMS, bBroadcast)            },
    {TEXT("Remote"),            TYPE_BOOL,  offsetof(SENDPARAMS, bRemote)               }
};

#define COVER_PAGE_NONE         0
#define COVER_PAGE_PERSONAL     1
#define COVER_PAGE_SERVER       2


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Test Area definition
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static const TESTCASE sc_aQueuingAreaTestCases[] = {
    {TestCase_SendAndVerify, TEXT("SendAndVerify")}
};

extern const TESTAREA gc_QueuingTestArea = {
    TEXT("Queuing"),
    sc_aQueuingAreaTestCases,
    sizeof(sc_aQueuingAreaTestCases) / sizeof(sc_aQueuingAreaTestCases[0])
};





/**************************************************************************************************************************
    Static functions declarations
**************************************************************************************************************************/

static DWORD SendAndVerify(
    LPCTSTR                 lpctstrServer,
    LPCTSTR                 lpctstrPrinter,
    LPCTSTR                 lpctstrRegHackKey,
    LPCTSTR                 lpctstrDocument,
    LPCTSTR                 lpctstrCoverPage,
    BOOL                    bServerCoverPage,
    const RECIPIENTINFO     *pRecipients,
    DWORD                   dwRecipientsCount,
    LPCTSTR                 lptstrWorkDirectory,
    BOOL                    bSaveNotIdenticalFiles,
    BOOL                    *pbResult
    );

static DWORD SendFaxFromApp(
    HANDLE                  hFaxServer,
    LPCTSTR                 lpctstrPrinter,
    LPCTSTR                 lpctstrRegHackKey,
    LPCTSTR                 lpctstrDocument,
    LPCTSTR                 lpctstrCoverPage,
    BOOL                    bServerCoverPage,
    const RECIPIENTINFO     *pRecipients,
    DWORD                   dwRecipientsCount,
    DWORDLONG               *pMsgIDs
    );

static DWORD SetRegHack(
    LPCTSTR                 lpctstrRegHackKey,
    LPCTSTR                 lpctstrCoverPage,
    BOOL                    bServerCoverPage,
    const RECIPIENTINFO     *pRecipients,
    DWORD                   dwRecipientsCount
    );

static DWORD VerifyQueuedJobs(
    HANDLE                  hFaxServer,
    LPCTSTR                 lpctstrDocument,
    LPCTSTR                 lpctstrCoverPage,
    BOOL                    bServerCoverPage,
    const RECIPIENTINFO     *pRecipients,
    DWORD                   dwRecipientsCount,
    const DWORDLONG         *pdwlMsgIDs,
    LPCTSTR                 lptstrWorkDirectory,
    BOOL                    bSaveNotIdenticalFiles,
    BOOL                    *pbResult
    );

static DWORD CompareJobsInQueue(
    HANDLE      hFaxServer,
    DWORDLONG   dwlMsgID1,
    DWORDLONG   dwlMsgID2,
    LPCTSTR     lptstrWorkDirectory,
    BOOL        bSaveNotIdenticalFiles,
    BOOL        *pbResult
    );



/**************************************************************************************************************************
    Functions definitions
**************************************************************************************************************************/

DWORD TestCase_SendAndVerify (const TESTPARAMS *pTestParams, LPCTSTR lpctstrSection, BOOL *pbPassed)
{
    BOOL        bRes                = FALSE;
    SENDPARAMS  SendParams;
    LPCTSTR     lpctstrCoverPage    = NULL;
    BOOL        bServerCoverPage    = FALSE;
    DWORD       dwEC                = ERROR_SUCCESS;
    DWORD       dwCleanUpEC         = ERROR_SUCCESS;
    
    lgLogDetail(
        LOG_X, 
        5,
        TEXT("Entering TestCase_SendAndVerify\n\tpTestParams = 0x%08lX\n\tlpctstrSection = %s\n\tpbPassed = 0x%08lX"),
        (DWORD)pTestParams,
        lpctstrSection,
        (DWORD)pbPassed
        );

    if (!(pTestParams && lpctstrSection && pbPassed))
    {
        lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%ld Call to TestCase_SendAndVerify() with invalid parameters"),
            TEXT(__FILE__),
            __LINE__
            );

        // no clean up needed at this stage
        return ERROR_INVALID_PARAMETER;
    }

    dwEC = ReadStructFromIniFile(
        &SendParams,
        sc_aSendParamsDescIni,
        sizeof(sc_aSendParamsDescIni) / sizeof(sc_aSendParamsDescIni[0]),
        pTestParams->lptstrIniFile,
        lpctstrSection
        );
    if (dwEC != ERROR_SUCCESS)
    {
        lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%ld Failed to read SENDPARAMS structure from %s section of %s file (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            lpctstrSection,
            pTestParams->lptstrIniFile,
            dwEC
            );
        return dwEC;
    }
    
    switch (SendParams.dwCoverPageType)
    {
    case COVER_PAGE_NONE:
        lpctstrCoverPage = NULL;
        break;
    case COVER_PAGE_PERSONAL:
        lpctstrCoverPage = pTestParams->lptstrPersonalCoverPage;
        bServerCoverPage = FALSE;
        break;
    case COVER_PAGE_SERVER:
        lpctstrCoverPage = pTestParams->lptstrServerCoverPage;
        bServerCoverPage = TRUE;
        break;
    default:
        lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%ld Invalid coner page type %ld"),
            TEXT(__FILE__),
            __LINE__,
            SendParams.dwCoverPageType
            );
        return ERROR_INVALID_PARAMETER;
    }

    lgLogDetail(
        LOG_X,
        1,
        TEXT("SendAndVerify:\n\tServer\t\t%s\n\tBroadcast\t%s\n\tDocument\t%s\n\tCoverPage\t%s"),
        SendParams.bRemote ? TEXT("remote") : TEXT("local"),
        SendParams.bBroadcast ? TEXT("yes") : TEXT("no"),
        SendParams.bDocument ? pTestParams->lptstrDocument : TEXT("none"),
        lpctstrCoverPage ? lpctstrCoverPage : TEXT("none")
        );

    if (SendParams.bTemporaryDisabled)
    {
        lgLogDetail(
            LOG_X,
            1,
            TEXT("This test case is temporary disabled.")
            );

        *pbPassed = TRUE;
        return ERROR_SUCCESS;
    }

    dwEC = SendAndVerify(
        SendParams.bRemote ? pTestParams->lptstrServer : NULL,
        SendParams.bRemote ? pTestParams->lptstrRemotePrinter : FAX_PRINTER_NAME,
        pTestParams->lptstrRegHackKey,
        SendParams.bDocument ? pTestParams->lptstrDocument : NULL,
        lpctstrCoverPage,
        bServerCoverPage,
        pTestParams->pRecipients,
        SendParams.bBroadcast ? pTestParams->dwRecipientsCount : 1,
        pTestParams->lptstrWorkDirectory,
        pTestParams->bSaveNotIdenticalFiles,
        &bRes
        );
    if (dwEC != ERROR_SUCCESS)
    {
        lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%ld SendAndVerify failed (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            dwEC
            );
        return dwEC;
    }

    *pbPassed = bRes;

    return ERROR_SUCCESS;
}   



/*++
    Sends a fax from application, using "printto" verb and verifies its successful queuing
  
    [IN]    lpctstrServer           Fax server machine name (may be NULL for local server)
    [IN]    lpctstrPrinter          Fax printer name (UNC for remote printer)
    [IN]    lpctstrRegHackKey       Name of registry hack key
    [IN]    lpctstrDocument         Name of the document file to be sent (may be NULL if lpctstrCoverPage is not NULL)
    [IN]    lpctstrCoverPage        Name of the cover page file (with full path in case of server cover page,
                                    may be NULL if lpctstrDocument is not NULL)
    [IN]    bServerCoverPage        Specifies whether lpctstrCoverPage points to a server cover page. If lpctstrCoverPage
                                    is NULL, the value of bServerCoverPage is ignored.
    [IN]    pRecipients             Pointer to array of RECIPIENTINFO structures
    [IN]    dwRecipientsCount       Number of RECIPIENTINFO structures in the array, pointed to by pRecipients
    [IN]    lptstrWorkDirectory     Directory for intermediate files
    [IN]    bSaveNotIdenticalFiles  Indicates whether not identical tiff files should be preserved
    [OUT]   pbResult                Pointer to a boolean that receives the result of sending and verification

    Return value:               Win32 error code
--*/
static DWORD SendAndVerify(
    LPCTSTR                 lpctstrServer,
    LPCTSTR                 lpctstrPrinter,
    LPCTSTR                 lpctstrRegHackKey,
    LPCTSTR                 lpctstrDocument,
    LPCTSTR                 lpctstrCoverPage,
    BOOL                    bServerCoverPage,
    const RECIPIENTINFO     *pRecipients,
    DWORD                   dwRecipientsCount,
    LPCTSTR                 lptstrWorkDirectory,
    BOOL                    bSaveNotIdenticalFiles,
    BOOL                    *pbResult
    )
{
    HANDLE                  hFaxServer          = NULL;
    PSECURITY_DESCRIPTOR    pOriginalSecDesc    = NULL;
    PSECURITY_DESCRIPTOR    pAdminSecDesc       = NULL;
    PSECURITY_DESCRIPTOR    pUserSecDesc        = NULL;
    DWORDLONG               *pdwlMsgIDs         = NULL;
    BOOL                    bRes                = FALSE;
    DWORD                   dwInd               = 0;
    DWORD                   dwEC                = ERROR_SUCCESS;

    lgLogDetail(
        LOG_X, 
        5,
        TEXT("Entering SendAndVerify\n\tlpctstrServer = %s\n\tlpctstrPrinter = %s\n\tlpctstrRegHackKey = %s\n\tlpctstrDocument = %s\n\tlpctstrCoverPage = %s\n\tbServerCoverPage = %ld\n\tpRecipients = 0x%08lX\n\tdwRecipientsCount = %ld\n\tlptstrWorkDirectory = %s\n\tbSaveNotIdenticalFiles = %ld\n\tpbResult = 0x%08lX"),
        lpctstrServer,
        lpctstrPrinter,
        lpctstrRegHackKey,
        lpctstrDocument,
        lpctstrCoverPage,
        bServerCoverPage,
        (DWORD)pRecipients,
        dwRecipientsCount,
        lptstrWorkDirectory,
        bSaveNotIdenticalFiles,
        (DWORD)pbResult
        );

    if (!(
        lpctstrPrinter                          &&
        lpctstrRegHackKey                       &&
        (lpctstrDocument || lpctstrCoverPage)   &&
        pRecipients                             &&
        dwRecipientsCount > 0                   &&
        lptstrWorkDirectory                     &&
        pbResult
        ))
    {
        lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%ld Call to SendAndVerify() with invalid parameters"),
            TEXT(__FILE__),
            __LINE__
            );

        // no clean up needed at this stage
        return ERROR_INVALID_PARAMETER;
    }

    if (!FaxConnectFaxServer(lpctstrServer, &hFaxServer))
    {
        dwEC = GetLastError();
        lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%ld FaxConnectFaxServer failed (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            dwEC
            );
        goto exit_func;
    }

    // Get current security descriptor from the service
    if (!FaxGetSecurityEx(hFaxServer, DACL_SECURITY_INFORMATION, &pOriginalSecDesc))
    {
        dwEC = GetLastError();
        lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%ld FaxGetSecurity failed (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            dwEC
            );
        goto exit_func;
    }

    // Create security descriptor with the current user as fax admin
    if (!CreateSecDescWithModifiedDacl(
        pOriginalSecDesc,
        NULL,
        FAX_ACCESS_RIGHTS_ALL,
        0,
        TRUE,
        TRUE,
        &pAdminSecDesc
        ))
    {
        dwEC = GetLastError();
        lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%ld Failed to create security descriptor with the current user as fax admin (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            dwEC
            );
        goto exit_func;
    }

    // Create security descriptor with the current user as fax non-admin user
    if (!CreateSecDescWithModifiedDacl(
        pOriginalSecDesc,
        NULL,
        FAX_ACCESS_RIGHTS_USER,
        FAX_ACCESS_RIGHTS_ALL & ~FAX_ACCESS_RIGHTS_USER,
        TRUE,
        TRUE,
        &pUserSecDesc
        ))
    {
        dwEC = GetLastError();
        lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%ld Failed to create security descriptor with the current user as fax non-admin user (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            dwEC
            );
        goto exit_func;
    }

    // Apply security descriptor with the current user as fax admin
    // in order to pause the queue
    if (!FaxSetSecurity(hFaxServer, DACL_SECURITY_INFORMATION, pAdminSecDesc))
    {
        dwEC = GetLastError();
        lgLogError(
            LOG_SEV_1, 
			TEXT("FILE:%s LINE:%ld Failed to set fax admin rights for the current user (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            dwEC
            );
        goto exit_func;
    }

    // Pause queue
    if (!FaxSetQueue(hFaxServer, FAX_OUTBOX_PAUSED))
    {
        dwEC = GetLastError();
        lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%ld Failed to pause the queue (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            dwEC
            );
        goto exit_func;
    }
    
    // Apply security descriptor with the current user as fax non-admin user
    // in order to send and verify as non-admin user
    if (!FaxSetSecurity(hFaxServer, DACL_SECURITY_INFORMATION, pUserSecDesc))
    {
        dwEC = GetLastError();
        lgLogError(
            LOG_SEV_1, 
			TEXT("FILE:%s LINE:%ld Failed to set fax user rights for the current user (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            dwEC
            );
        goto exit_func;
    }
    
    // Allocate array of MsgIDs and initialize to zero (LPTR flag)
    if (!(pdwlMsgIDs = (DWORDLONG *)LocalAlloc(LPTR, dwRecipientsCount * sizeof(DWORDLONG))))
    {
        dwEC = GetLastError();
        lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%ld LocalAlloc failed (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            dwEC
            );
        goto exit_func;
    }

    // Send the fax and perform basic verification
    dwEC = SendFaxFromApp(
        hFaxServer,
        lpctstrPrinter,
        lpctstrRegHackKey,
        lpctstrDocument,
        lpctstrCoverPage,
        bServerCoverPage,
        pRecipients,
        dwRecipientsCount,
        pdwlMsgIDs
        );
    if (dwEC != ERROR_SUCCESS)
    {
        lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%ld SendFaxFromApp failed (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            dwEC
            );
        goto exit_func;
    }

    // Perform some additional verification of the queued jobs
    dwEC = VerifyQueuedJobs(
        hFaxServer,
        lpctstrDocument,
        lpctstrCoverPage,
        bServerCoverPage,
        pRecipients,
        dwRecipientsCount,
        pdwlMsgIDs,
        lptstrWorkDirectory,
        bSaveNotIdenticalFiles,
        &bRes
        );
    if (dwEC != ERROR_SUCCESS)
    {
        lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%ld VerifyQueuedJobs failed (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            dwEC
            );
        goto exit_func;
    }

    *pbResult = bRes;

exit_func:

    if (pdwlMsgIDs)
    {
        // Cancel all queued jobs
        for (dwInd = 0; dwInd < dwRecipientsCount; dwInd++)
        {
            PFAX_JOB_ENTRY_EX pJob = NULL;

            if (!FaxGetJobEx(hFaxServer, pdwlMsgIDs[dwInd], &pJob))
            {
                lgLogError(
                    LOG_SEV_2, 
                    TEXT("FILE:%s LINE:%ld FaxGetJobEx failed for MsgId = 0x%I64x (ec = 0x%08lX)"),
                    TEXT(__FILE__),
                    __LINE__,
                    pdwlMsgIDs[dwInd],
                    GetLastError()
                    );

                // Don't give up, try to delete other jobs
                continue;
            }
            _ASSERT(pJob && pJob->pStatus);

            if (!FaxAbort(hFaxServer, pJob->pStatus->dwJobID))
            {
                lgLogError(
                    LOG_SEV_2, 
                    TEXT("FILE:%s LINE:%ld FaxAbort failed for JobId = 0x%lx (ec = 0x%08lX)"),
                    TEXT(__FILE__),
                    __LINE__,
                    pJob->pStatus->dwJobID,
                    GetLastError()
                    );
            }

            if (pJob)
            {
                FaxFreeBuffer(pJob);
                pJob = NULL;
            }
        }

        if (LocalFree(pdwlMsgIDs) != NULL)
        {
            lgLogError(
                LOG_SEV_2, 
                TEXT("FILE:%s LINE:%ld LocalFree failed (ec = 0x%08lX)"),
                TEXT(__FILE__),
                __LINE__,
                GetLastError()
                );
        }
    }

    // Apply security descriptor with the current user as fax admin
    // in order to resume the queue
    if (!FaxSetSecurity(hFaxServer, DACL_SECURITY_INFORMATION, pAdminSecDesc))
    {
        lgLogError(
            LOG_SEV_2, 
			TEXT("FILE:%s LINE:%ld Failed to set fax admin rights for the current user (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            GetLastError()
            );
        goto exit_func;
    }

    // Resume queue
    if (!FaxSetQueue(hFaxServer, 0))
    {
        lgLogError(
            LOG_SEV_2, 
            TEXT("FILE:%s LINE:%ld Failed to resume the queue (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            GetLastError()
            );
    }
    
    // Restore original security descriptor
    if (!FaxSetSecurity(hFaxServer, DACL_SECURITY_INFORMATION, pOriginalSecDesc))
    {
        dwEC = GetLastError();
        lgLogError(
            LOG_SEV_2, 
			TEXT("FILE:%s LINE:%ld Failed to restore original rights for the current user (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            GetLastError()
            );
        goto exit_func;
    }

    if (pOriginalSecDesc)
    {
        FaxFreeBuffer(pOriginalSecDesc);
    }

    if (pAdminSecDesc && LocalFree(pAdminSecDesc) != NULL)
    {
        lgLogError(
            LOG_SEV_2, 
            TEXT("FILE:%s LINE:%ld LocalFree failed (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            GetLastError()
            );
    }

    if (pUserSecDesc && LocalFree(pUserSecDesc) != NULL)
    {
        lgLogError(
            LOG_SEV_2, 
            TEXT("FILE:%s LINE:%ld LocalFree failed (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            GetLastError()
            );
    }

    if (hFaxServer && !FaxClose(hFaxServer))
    {
        lgLogError(
            LOG_SEV_2, 
            TEXT("FILE:%s LINE:%ld FaxClose failed (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            GetLastError()
            );
    }

    return dwEC;
}



/*++
    Sends a fax (single or broadcas) from application, using "printto" verb,
    performs basic verification of queued jobs and returns MsgIDs for all sent jobs.
  
    [IN]    hFaxServer          Handle to Fax server
    [IN]    lpctstrPrinter      Fax printer name (UNC for remote printer)
    [IN]    lpctstrRegHackKey   Name of registry hack key
    [IN]    lpctstrDocument     Name of the document file to be sent (may be NULL if lpctstrCoverPage is not NULL)
    [IN]    lpctstrCoverPage    Name of the cover page file (with full path in case of server conver page,
                                may be NULL if lpctstrDocument is not NULL)
    [IN]    bServerCoverPage    Specifies whether lpctstrCoverPage points to a server cover page. If lpctstrCoverPage
                                is NULL, the value of bServerCoverPage is ignored.
    [IN]    pRecipients         Pointer to array of RECIPIENTINFO structures
    [IN]    dwRecipientsCount   Number of RECIPIENTINFO structures in the array, pointed to by pRecipients
    [OUT]   pdwlMsgIDs          A pointer to an array of DWORDLONGs that receives MsgID(s) for each recipient.
                                The number of elements in this array must be at least dwRecipientsCount.
                                The order of JobIDs in the array is guaranteed to be the same with the order
                                of recipients.
                                The memory for this array must be allocated and freed by the caller.

    Return value:               Win32 error code
--*/
static DWORD SendFaxFromApp(
    HANDLE                  hFaxServer,
    LPCTSTR                 lpctstrPrinter,
    LPCTSTR                 lpctstrRegHackKey,
    LPCTSTR                 lpctstrDocument,
    LPCTSTR                 lpctstrCoverPage,
    BOOL                    bServerCoverPage,
    const RECIPIENTINFO     *pRecipients,
    DWORD                   dwRecipientsCount,
    DWORDLONG               *pdwlMsgIDs
    )
{
    SHELLEXECUTEINFO    ShellExecInfo;
    HANDLE              hCompletionPort         = NULL;
    DWORD               dwBytes                 = 0;
    ULONG_PTR           pulCompletionKey        = 0;
    HANDLE              hServerEvents           = NULL;
    DWORD               dwTickCountWhenFaxSent  = 0;
    DWORDLONG           dwlBroadcastID          = 0;
    DWORD               dwJobsCount             = 0;
    PFAX_EVENT_EX       pFaxEventEx             = NULL;
    PFAX_JOB_ENTRY_EX   pJob                    = NULL;
    DWORD               dwEC                    = ERROR_SUCCESS;
    DWORD               dwCleanUpEC             = ERROR_SUCCESS;

    lgLogDetail(
        LOG_X, 
        5,
        TEXT("Entering SendFaxFromApp\n\thFaxServer = 0x%08lX\n\tlpctstrPrinter = %s\n\tlpctstrRegHackKey = %s\n\tlpctstrDocument = %s\n\tlpctstrCoverPage = %s\n\tbServerCoverPage = %ld\n\tpRecipients = 0x%08lX\n\tdwRecipientsCount = %ld\n\tpdwlMsgIDs = 0x%08lX"),
        (DWORD)hFaxServer,
        lpctstrPrinter,
        lpctstrRegHackKey,
        lpctstrDocument,
        lpctstrCoverPage,
        bServerCoverPage,
        (DWORD)pRecipients,
        dwRecipientsCount,
        (DWORD)pdwlMsgIDs
        );

    if (!(
        hFaxServer                              &&
        lpctstrPrinter                          &&
        lpctstrRegHackKey                       &&
        (lpctstrDocument || lpctstrCoverPage)   &&
        pRecipients                             &&
        dwRecipientsCount > 0                   &&
        pdwlMsgIDs
        ))
    {
        lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%ld Call to SendFaxFromApp() with invalid parameters"),
            TEXT(__FILE__),
            __LINE__
            );

        // no clean up needed at this stage
        return ERROR_INVALID_PARAMETER;
    }
    
    dwEC = SetRegHack(
        lpctstrRegHackKey,
        lpctstrCoverPage ? lpctstrCoverPage : TEXT(""),
        bServerCoverPage,
        pRecipients,
        dwRecipientsCount
        );
    if (dwEC != ERROR_SUCCESS)
    {
        lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%ld Failed to set SendWizard registry hack (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            dwEC
            );
        goto exit_func;
    }

    // Register for notifications
    hCompletionPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 1);
    if (!hCompletionPort) 
    {
        dwEC = GetLastError();
        lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%ld CreateIoCompletionPort failed (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            dwEC
            );
        goto exit_func;
    }
    if (!FaxRegisterForServerEvents(hFaxServer, FAX_EVENT_TYPE_OUT_QUEUE, hCompletionPort, 0, NULL, 0, &hServerEvents))
    {
        dwEC = GetLastError();
        lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%ld FaxRegisterForServerEvents failed (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            dwEC
            );
        goto exit_func;
    }
    
    // Initialize ShellExecInfo structure:
    //  * in order to send a document, we should pass "printto", document name and printer name.
    //  * in order to send a cover page fax, we should pass send wizard command line and printer name.
    ZeroMemory(&ShellExecInfo, sizeof(ShellExecInfo));
    ShellExecInfo.cbSize        = sizeof(ShellExecInfo);
    ShellExecInfo.fMask         = SEE_MASK_FLAG_NO_UI;
    ShellExecInfo.lpVerb        = lpctstrDocument ? TEXT("printto") : NULL;
    ShellExecInfo.lpFile        = lpctstrDocument ? lpctstrDocument : FAX_SEND_IMAGE_NAME;
    ShellExecInfo.lpParameters  = lpctstrPrinter;
    ShellExecInfo.nShow         = SW_SHOWMINNOACTIVE;

    // Print document, using "printto" verb
    if (!ShellExecuteEx(&ShellExecInfo))
    {
        dwEC = GetLastError();
        lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%ld ShellExecuteEx failed (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            dwEC
            );
        goto exit_func;
    }

    // Remember the moment, fax has been sent
    dwTickCountWhenFaxSent = GetTickCount();

    // Initialize contents of MsgIDs array to zero
    // (in order to be able to associate job with recipient)
    ZeroMemory(pdwlMsgIDs, dwRecipientsCount * sizeof(DWORDLONG));

    // Get MsgID(s) of sent job(s)
    while (GetQueuedCompletionStatus(
            hCompletionPort, 
            &dwBytes, 
            &pulCompletionKey, 
            (LPOVERLAPPED *) &pFaxEventEx, 
            NOTIFICATIONS_TIMEOUT
            )) 
    {
        if (!_CrtIsValidPointer((const void*) pFaxEventEx, sizeof(FAX_EVENT_EX), TRUE))
        {
            dwEC = ERROR_INVALID_DATA;
            lgLogError(
                LOG_SEV_1, 
                TEXT("FILE:%s LINE:%ld Got invalid pointer to FAX_EVENT_EX from completion port: 0x%08lX"),
                TEXT(__FILE__),
                __LINE__,
                (DWORD)pFaxEventEx
                );
            goto exit_func;
        }

        // We are registered only for OUT_QUEUE events
        _ASSERT(pFaxEventEx->EventType == FAX_EVENT_TYPE_OUT_QUEUE);

        if (pFaxEventEx->EventInfo.JobInfo.Type == FAX_JOB_EVENT_TYPE_ADDED)
        {
            DWORDLONG   dwlMsgID        = pFaxEventEx->EventInfo.JobInfo.dwlMessageId;
            DWORD       dwRecipientInd  = 0;

            if (!FaxGetJobEx(hFaxServer, dwlMsgID, &pJob))
            {
                dwEC = GetLastError();
                lgLogError(
                    LOG_SEV_1, 
                    TEXT("FILE:%s LINE:%ld FaxGetJobEx failed for MsgID = 0x%I64x (ec = 0x%08lX)"),
                    TEXT(__FILE__),
                    __LINE__,
                    dwlMsgID,
                    dwEC
                    );
                goto exit_func;
            }

            if (dwJobsCount == 0)
            {
                // The first job we get

                dwlBroadcastID = pJob->dwlBroadcastId;
            }
            else if (dwlBroadcastID != pJob->dwlBroadcastId)
            {
                lgLogDetail(
                    LOG_X,
                    5,
                    TEXT("FILE:%s LINE:%ld Extraneous job added to the queue: MsgID = 0x%I64x, BroadcastID = 0x%I64x\n"),
                    TEXT(__FILE__),
                    __LINE__,
                    dwlMsgID,
                    pJob->dwlBroadcastId,
                    dwEC
                    );

                if (GetTickCount() - dwTickCountWhenFaxSent > NOTIFICATIONS_TIMEOUT)
                {
                    dwEC = ERROR_TIMEOUT;
                    lgLogError(
                        LOG_SEV_1,
                        TEXT("FILE:%s LINE:%ld Job not queued during %ld msec"),
                        TEXT(__FILE__),
                        __LINE__,
                        NOTIFICATIONS_TIMEOUT
                        );
                    goto exit_func;
                }
            }

            // Associate the job with a recipient and place MsgID in appropriate position in the array
            for (dwRecipientInd = 0; dwRecipientInd < dwRecipientsCount; dwRecipientInd++)
            {
                if (
                    pJob->lpctstrRecipientNumber                                                            &&
                    pRecipients[dwRecipientInd].lptstrNumber                                                &&
                    pJob->lpctstrRecipientName                                                              &&
                    pRecipients[dwRecipientInd].lptstrName                                                  &&
                    _tcscmp(pJob->lpctstrRecipientNumber, pRecipients[dwRecipientInd].lptstrNumber) == 0    &&
                    _tcscmp(pJob->lpctstrRecipientName, pRecipients[dwRecipientInd].lptstrName) == 0
                    )
                {
                    // Recipient's number and name match the job

                    if (pdwlMsgIDs[dwRecipientInd] == 0)
                    {
                        // The position in the array is not occupied yet.
                        // I.e. this is the first job we've found for this recipient

                        pdwlMsgIDs[dwRecipientInd] = dwlMsgID;
                        dwJobsCount++;
                        break;
                    }
                    // else, continue to search
                }
            }

            if (dwRecipientInd == dwRecipientsCount)
            {
                // We get here if we've exited from the above for loop because of the condition and not with break.
                // This means that we failed to associate a job with a recipient.

                dwEC = ERROR_INVALID_DATA;
                lgLogError(
                    LOG_SEV_1, 
                    TEXT("Cannot associate a job with a recipient"),
                    TEXT(__FILE__),
                    __LINE__
                    );
                lgLogDetail(
                    LOG_X, 
                    3,
                    TEXT("\tMsgID = 0x%I64x\n\tBroadcastID = 0x%I64x\n\tRecipientName = %s\n\tRecipientNumber = %s"),
                    dwlMsgID,
                    pJob->dwlBroadcastId,
                    pJob->lpctstrRecipientName,
                    pJob->lpctstrRecipientNumber
                    );
                goto exit_func;
            }

            if (pJob)
            {
                FaxFreeBuffer(pJob);
                pJob = NULL;
            }
        }

        if (pFaxEventEx)
        {
            FaxFreeBuffer(pFaxEventEx);
            pFaxEventEx = NULL;
        }

        if (dwJobsCount == dwRecipientsCount)
        {
            // All jobs already associated with recipients
            break;
        }
    }

    if (dwJobsCount != dwRecipientsCount)
    {
        // We get here if we've exited from the above while loop because GetQueuedCompletionStatus() has returned FALSE

        dwEC = GetLastError();
        lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%ld GetQueuedCompletionStatus failed (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            dwEC
            );
        goto exit_func;
    }

exit_func:

    // remove SendWizard registry hack
    dwCleanUpEC = RegDeleteKey(HKEY_LOCAL_MACHINE, lpctstrRegHackKey);
    if (dwCleanUpEC != ERROR_SUCCESS && dwCleanUpEC != ERROR_FILE_NOT_FOUND)
    {
        lgLogError(
            LOG_SEV_2, 
            TEXT("FILE:%s LINE:%ld Failed to remove registry hack (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            dwCleanUpEC
            );
    }

    if (hServerEvents && !FaxUnregisterForServerEvents(hServerEvents))
    {
        lgLogError(
            LOG_SEV_2, 
            TEXT("FILE:%s LINE:%ld FaxUnregisterForServerEvents failed (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            GetLastError()
            );
    }
    if (hCompletionPort && !CloseHandle(hCompletionPort))
    {
        lgLogError(
            LOG_SEV_2, 
            TEXT("FILE:%s LINE:%ld Failed to close handle of completion port (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            GetLastError()
            );
    }
    if (pFaxEventEx)
    {
        FaxFreeBuffer(pFaxEventEx);
    }
    if (pJob)
    {
        FaxFreeBuffer(pJob);
    }

    return dwEC;
}



/*++
    Verifies that fax (broadcast) sent from application (via spooler mechanism)
    successfully queued. For this perpose the function queues the same fax (broadcast)
    using the FaxSendDocumentEx() (RPC mechanism) and compares tiffs.
  
    [IN]    hFaxServer              Handle to Fax server
    [IN]    lpctstrDocument         Name of the document file to be sent (may be NULL if lpctstrCoverPage is not NULL)
    [IN]    lpctstrCoverPage        Name of the cover page file (with full path in case of server conver page,
                                    may be NULL if lpctstrDocument is not NULL)
    [IN]    bServerCoverPage        Specifies whether lpctstrCoverPage points to a server cover page. If lpctstrCoverPage
                                    is NULL, the value of bServerCoverPage is ignored.
    [IN]    pRecipients             Pointer to array of RECIPIENTINFO structures
    [IN]    dwRecipientsCount       Number of RECIPIENTINFO structures in the arrays, pointed to by pRecipients
                                    and pdwlMsgIDs
    [IN]    pdwlMsgIDs              Pointer to an array of MsgIDs of queued jobs. The order of JobIDs in the array
                                    must be the same with the order of recipients.
    [IN]    lptstrWorkDirectory     Directory for intermediate files
    [IN]    bSaveNotIdenticalFiles  Indicates whether not identical tiff files should be preserved
    [OUT]   pbResult                Pointer to a boolean that receives the result of verification.
                                    Valid only if the return value is ERROR_SUCCESS

    Return value:                   Win32 error code
--*/
static DWORD VerifyQueuedJobs(
    HANDLE                  hFaxServer,
    LPCTSTR                 lpctstrDocument,
    LPCTSTR                 lpctstrCoverPage,
    BOOL                    bServerCoverPage,
    const RECIPIENTINFO     *pSpoolerRecipients,
    DWORD                   dwRecipientsCount,
    const DWORDLONG         *pdwlSpoolerMsgIDs,
    LPCTSTR                 lptstrWorkDirectory,
    BOOL                    bSaveNotIdenticalFiles,
    BOOL                    *pbResult
    )
{
    const FAX_COVERPAGE_INFO_EX RPCCoverPageInfo    =   {
                                                        sizeof(FAX_COVERPAGE_INFO_EX),
                                                        FAX_COVERPAGE_FMT_COV,
                                                        (LPTSTR)lpctstrCoverPage, // the cast is safe, since the struct is const
                                                        bServerCoverPage,
                                                        NULL,
                                                        NULL
                                                    };

    const FAX_JOB_PARAM_EX      RPCJobParams        =   {
                                                        sizeof(FAX_JOB_PARAM_EX),
                                                        JSA_NOW,
                                                        {0},
                                                        DRT_NONE,
                                                        NULL,
                                                        FAX_PRIORITY_TYPE_NORMAL,
                                                        NULL,
                                                        {0},
                                                        (LPTSTR)lpctstrDocument, // the cast is safe, since the struct is const
                                                        0
                                                    };

    PFAX_PERSONAL_PROFILE   pRPCSender                  = NULL;
    PFAX_PERSONAL_PROFILE   pRPCRecipients              = NULL;
    DWORDLONG               dwlRPCBroadcastID           = 0;
    DWORDLONG               *pdwlRPCMsgIDs              = 0;
    BOOL                    bRes                        = FALSE;
    DWORD                   dwInd                       = 0;
    DWORD                   dwEC                        = ERROR_SUCCESS;

    lgLogDetail(
        LOG_X, 
        5,
        TEXT("Entering VerifyQueuedJobs\n\thFaxServer = 0x%08lX\n\tlpctstrDocument = %s\n\tlpctstrCoverPage = %s\n\tbServerCoverPage = %ld\n\tpSpoolerRecipients = 0x%08lX\n\tdwRecipientsCount = %ld\n\tpdwlSpoolerMsgIDs = 0x%08lX\n\tlptstrWorkDirectory = %s\n\tbSaveNotIdenticalFiles = %ld\n\tpbResult = 0x%08lX"),
        (DWORD)hFaxServer,
        lpctstrDocument,
        lpctstrCoverPage,
        bServerCoverPage,
        (DWORD)pSpoolerRecipients,
        dwRecipientsCount,
        (DWORD)pdwlSpoolerMsgIDs,
        lptstrWorkDirectory,
        bSaveNotIdenticalFiles,
        (DWORD)pbResult
        );

    if (!(
        hFaxServer                              &&
        (lpctstrDocument || lpctstrCoverPage)   &&
        pSpoolerRecipients                      &&
        dwRecipientsCount > 0                   &&
        pdwlSpoolerMsgIDs                       &&
        pbResult
        ))
    {
        lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%ld Call to VerifyQueuedJobs() with invalid parameters"),
            TEXT(__FILE__),
            __LINE__
            );

        // no clean up needed at this stage
        return ERROR_INVALID_PARAMETER;
    }

    // Allocate array of FAX_PERSONAL_PROFILE and initialize to zero (LPTR flag)
    if (!(pRPCRecipients = (PFAX_PERSONAL_PROFILE)LocalAlloc(LPTR, dwRecipientsCount * sizeof(FAX_PERSONAL_PROFILE))))
    {
        dwEC = GetLastError();
        lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%ld LocalAlloc failed (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            dwEC
            );
        goto exit_func;
    }

    // Initialize recipients
    for (dwInd = 0; dwInd < dwRecipientsCount; dwInd++)
    {
        pRPCRecipients[dwInd].dwSizeOfStruct = sizeof(FAX_PERSONAL_PROFILE);
        pRPCRecipients[dwInd].lptstrName = pSpoolerRecipients[dwInd].lptstrName;
        pRPCRecipients[dwInd].lptstrFaxNumber = pSpoolerRecipients[dwInd].lptstrNumber;
    }

    // Initialize sender to be the same as in spooler fax
    if (!FaxGetSenderInfo(hFaxServer, pdwlSpoolerMsgIDs[0], FAX_MESSAGE_FOLDER_QUEUE, &pRPCSender))
    {
        dwEC = GetLastError();
        lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%ld FaxGetSenderInfo failed for MsgID = 0x%I64x (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            pdwlSpoolerMsgIDs[0],
            dwEC
            );
        goto exit_func;
    }
    
    // Allocate array of MsgIDs and initialize to zero (LPTR flag)
    if (!(pdwlRPCMsgIDs = (DWORDLONG *)LocalAlloc(LPTR, dwRecipientsCount * sizeof(DWORDLONG))))
    {
        dwEC = GetLastError();
        lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%ld LocalAlloc failed (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            dwEC
            );
        goto exit_func;
    }

    // Send using RPC mechanism
    if (!FaxSendDocumentEx(
        hFaxServer,
        lpctstrDocument,
        lpctstrCoverPage ? &RPCCoverPageInfo : NULL,
        pRPCSender,
        dwRecipientsCount,
        pRPCRecipients,
        &RPCJobParams,
        &dwlRPCBroadcastID,
        pdwlRPCMsgIDs
        ))
    {
        dwEC = GetLastError();
        lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%ld FaxSendDocumentEx failed (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            dwEC
            );
        goto exit_func;
    }

    // Compare jobs
    for (dwInd = 0; dwInd < dwRecipientsCount; dwInd++)
    {
        dwEC = CompareJobsInQueue(
            hFaxServer,
            pdwlSpoolerMsgIDs[dwInd],
            pdwlRPCMsgIDs[dwInd],
            lptstrWorkDirectory,
            bSaveNotIdenticalFiles,
            &bRes
            );
        if (dwEC != ERROR_SUCCESS)
        {
            lgLogError(
                LOG_SEV_1,
                TEXT("FILE:%s LINE:%ld CompareJobsInQueue failed (ec = 0x%08lX)"),
                TEXT(__FILE__),
                __LINE__,
                dwEC
                );
            goto exit_func;
        }

        if (!bRes)
        {
            break;
        }
    }

    *pbResult = bRes;

exit_func:

    if (pRPCSender)
    {
        FaxFreeBuffer(pRPCSender);
    }
    if (pRPCRecipients && LocalFree(pRPCRecipients) != NULL)
    {
        lgLogError(
            LOG_SEV_2, 
            TEXT("FILE:%s LINE:%ld LocalFree failed (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            GetLastError()
            );
    }
    if (pdwlRPCMsgIDs)
    {
        // Cancel all queued jobs
        for (dwInd = 0; dwInd < dwRecipientsCount; dwInd++)
        {
            PFAX_JOB_ENTRY_EX pJob = NULL;

            if (!FaxGetJobEx(hFaxServer, pdwlRPCMsgIDs[dwInd], &pJob))
            {
                lgLogError(
                    LOG_SEV_2,
                    TEXT("FILE:%s LINE:%ld FaxGetJobEx failed for MsgID = 0x%I64x (ec = 0x%08lX)"),
                    TEXT(__FILE__),
                    __LINE__,
                    pdwlRPCMsgIDs[dwInd],
                    GetLastError()
                    );

                // Don't give up, try to delete other jobs
                continue;
            }
            _ASSERT(pJob && pJob->pStatus);

            if (!FaxAbort(hFaxServer, pJob->pStatus->dwJobID))
            {
                lgLogError(
                    LOG_SEV_2,
                    TEXT("FILE:%s LINE:%ld FaxAbort failed for JobID = %lx (ec = 0x%08lX)"),
                    TEXT(__FILE__),
                    __LINE__,
                    pJob->pStatus->dwJobID,
                    GetLastError()
                    );
            }

            if (pJob)
            {
                FaxFreeBuffer(pJob);
                pJob = NULL;
            }
        }

        if (LocalFree(pdwlRPCMsgIDs) != NULL)
        {
            lgLogError(
                LOG_SEV_2, 
                TEXT("FILE:%s LINE:%ld LocalFree failed (ec = 0x%08lX)"),
                TEXT(__FILE__),
                __LINE__,
                GetLastError()
                );
        }
    }

    return dwEC;
}



/*++
    Compares tiffs for two jobs in the queue.
  
    [IN]    hFaxServer              Handle to Fax server
    [IN]    dwlMsgID1               Message ID of the first job
    [IN]    dwlMsgID2               Message ID of the second job
    [IN]    lptstrWorkDirectory     Directory for tiff files
    [IN]    bSaveNotIdenticalFiles  Indicates whether not identical tiff files should be preserved
                                    for later inspection
    [OUT]   pbResult                Pointer to a boolean that receives the result of verification.
                                    Valid only if the return value is ERROR_SUCCESS

    Return value:                   Win32 error code
--*/
static DWORD CompareJobsInQueue(
    HANDLE      hFaxServer,
    DWORDLONG   dwlMsgID1,
    DWORDLONG   dwlMsgID2,
    LPCTSTR     lptstrWorkDirectory,
    BOOL        bSaveNotIdenticalFiles,
    BOOL        *pbResult
    )
{
    TCHAR   tszTiffName1[MAX_PATH + 1];
    TCHAR   tszTiffName2[MAX_PATH + 1];
    BOOL    bFileCreated1           = FALSE;
    BOOL    bFileCreated2           = FALSE;
    DWORD   dwDifferentBitsCount    = 0;
    DWORD   dwEC                    = ERROR_SUCCESS;

    lgLogDetail(
        LOG_X, 
        5,
        TEXT("Entering CompareJobsInQueue\n\thFaxServer = 0x%08lX\n\tdwlMsgID1 = 0x%I64x\n\tdwlMsgID2 = 0x%I64x\n\tlptstrWorkDirectory = %s\n\tbSaveNotIdenticalFiles = %ld\n\tpbResult = 0x%08lX"),
        (DWORD)hFaxServer,
        dwlMsgID1,
        dwlMsgID2,
        lptstrWorkDirectory,
        bSaveNotIdenticalFiles,
        (DWORD)pbResult
        );

    if (!(hFaxServer && pbResult))
    {
        lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%ld Call to CompareJobsInQueue() with invalid parameters"),
            TEXT(__FILE__),
            __LINE__
            );
        // no clean up needed at this stage
        return ERROR_INVALID_PARAMETER;
    }

    // Get filenames
    if (!GetTempFileName(lptstrWorkDirectory, TEXT("Fax"), 0, tszTiffName1))
    {
        dwEC = GetLastError();
        lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%ld GetTempFileName failed (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            dwEC
            );
        goto exit_func;
    }
    if (!GetTempFileName(lptstrWorkDirectory, TEXT("Fax"), 0, tszTiffName2))
    {
        dwEC = GetLastError();
        lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%ld GetTempFileName failed (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            dwEC
            );
        goto exit_func;
    }

    // Get tiff files
    if (!FaxGetMessageTiff(hFaxServer, dwlMsgID1, FAX_MESSAGE_FOLDER_QUEUE, tszTiffName1))
    {
        dwEC = GetLastError();
        lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%ld GetTempFileName failed for MsgID = 0x%I64x (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            dwlMsgID1,
            dwEC
            );
        goto exit_func;
    }
    bFileCreated1 = TRUE;

    if (!FaxGetMessageTiff(hFaxServer, dwlMsgID2, FAX_MESSAGE_FOLDER_QUEUE, tszTiffName2))
    {
        dwEC = GetLastError();
        lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%ld GetTempFileName failed for MsgID = 0x%I64x (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            dwlMsgID2,
            dwEC
            );
        goto exit_func;
    }
    bFileCreated2 = TRUE;

    lgLogDetail(
        LOG_X, 
        3,
        TEXT("Comparing tiff files:\n\t%s\n\t%s"),
        tszTiffName1,
        tszTiffName2
        );

    dwDifferentBitsCount = TiffCompare(tszTiffName1, tszTiffName2, FALSE);
    dwEC = GetLastError();
    if (dwEC != ERROR_SUCCESS)
    {
        lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%ld TiffCompare failed (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            dwlMsgID2,
            dwEC
            );
        goto exit_func;
    }

    if (dwDifferentBitsCount == 0)
    {
        *pbResult = TRUE;
        lgLogDetail(
            LOG_X, 
            3,
            TEXT("Tiff files are identical")
            );
    }
    else
    {
        *pbResult = FALSE;
        lgLogError(
            LOG_SEV_1,
            TEXT("Tiff files are different in %ld bits"),
            dwDifferentBitsCount
            );
    }

exit_func:

    if (dwEC != ERROR_SUCCESS || *pbResult || !bSaveNotIdenticalFiles)
    {
        // Delete tmp files

        if (bFileCreated1 && !DeleteFile(tszTiffName1))
        {
            lgLogError(
                LOG_SEV_2,
                TEXT("FILE:%s LINE:%ld Failed to delete tmp file %s (ec = 0x%08lX)"),
                TEXT(__FILE__),
                __LINE__,
                tszTiffName1,
                GetLastError()
                );
        }
        if (bFileCreated2 && !DeleteFile(tszTiffName2))
        {
            lgLogError(
                LOG_SEV_2,
                TEXT("FILE:%s LINE:%ld Failed to delete tmp file %s (ec = 0x%08lX)"),
                TEXT(__FILE__),
                __LINE__,
                tszTiffName2,
                GetLastError()
                );
        }
    }
    else
    {
        lgLogDetail(
            LOG_X, 
            3,
            TEXT("The files will not be deleted. You can examine them later.")
            );
    }

    return dwEC;
}



/*++
    Sets the registry hack
  
    [IN]    lpctstrRegHackKey   Name of registry hack key
    [IN]    lpctstrCoverPage    Name of the cover page file (with full path in case of server conver page,
                                may be NULL if lpctstrDocument is not NULL)
    [IN]    bServerCoverPage    Specifies whether lpctstrCoverPage points to a server cover page. If lpctstrCoverPage
                                is NULL, the value of bServerCoverPage is ignored.
    [IN]    pRecipients         Pointer to array of RECIPIENTINFO structures
    [IN]    dwRecipientsCount   Number of RECIPIENTINFO structures in the array, pointed to by pRecipients

    Return value:               Win32 error code
--*/
static DWORD SetRegHack(
    LPCTSTR                 lpctstrRegHackKey,
    LPCTSTR                 lpctstrCoverPage,
    BOOL                    bServerCoverPage,
    const RECIPIENTINFO     *pRecipients,
    DWORD                   dwRecipientsCount
    )
{
    HKEY            hkWzrdHack                  = NULL;
    DWORD           dwInd                       = 0;
    const DWORD     dwTestsCount                = 1;
    DWORD           dwMultiStringBytes          = 0;
    LPTSTR          lptstrRecipientMultiString  = NULL;
    LPTSTR          lptstrMultiStringCurrPos    = NULL;
    DWORD           dwEC                        = ERROR_SUCCESS;
    DWORD           dwCleanUpEC                 = ERROR_SUCCESS;

    lgLogDetail(
        LOG_X, 
        5,
        TEXT("Entering SetRegHack\n\tlpctstrRegHackKey = %s\n\tlpctstrCoverPage = %s\n\tbServerCoverPage = %ld\n\tpRecipients = 0x%08lX\n\tdwRecipientsCount = %ld"),
        lpctstrRegHackKey,
        lpctstrCoverPage,
        bServerCoverPage,
        (DWORD)pRecipients,
        dwRecipientsCount
        );

    if (!(lpctstrRegHackKey && lpctstrCoverPage && pRecipients && dwRecipientsCount >= 1))
    {
        lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%ld Call to VerifyQueuedJobs() with invalid parameters"),
            TEXT(__FILE__),
            __LINE__
            );

        // no clean up needed at this stage
        return ERROR_INVALID_PARAMETER;
    }
    
    // Create (or open if already exists) the SendWizard registry hack key
    dwEC = RegCreateKey(HKEY_LOCAL_MACHINE, lpctstrRegHackKey, &hkWzrdHack);
    if (dwEC != ERROR_SUCCESS)
    {
        lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%ld Failed to create HKEY_LOCAL_MACHINE\\%s registry key (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            lpctstrRegHackKey,
            dwEC
            );
        goto exit_func;
    }

    // Calculate the buffer size for recipients mutlistring:
    for (dwInd = 0; dwInd < dwRecipientsCount; dwInd++)
    {
        dwMultiStringBytes += (_tcslen(pRecipients[dwInd].lptstrName) + _tcslen(pRecipients[dwInd].lptstrNumber) + 2);
    }
    dwMultiStringBytes = (dwMultiStringBytes + 1) * sizeof(TCHAR);

    // Allocate memory for multistring
    lptstrRecipientMultiString = (LPTSTR)LocalAlloc(LMEM_FIXED, dwMultiStringBytes);
    if (!lptstrRecipientMultiString)
    {
        dwEC = GetLastError();
        lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%ld LocalAlloc failed (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            dwEC
            );
        goto exit_func;
    }

    // Combine recipients multistring
    lptstrMultiStringCurrPos = lptstrRecipientMultiString;
    for (dwInd = 0; dwInd < dwRecipientsCount; dwInd++)
    {
        DWORD dwRet = _stprintf(
            lptstrMultiStringCurrPos,
            TEXT("%s%c%s%c"),
            pRecipients[dwInd].lptstrName,
            (TCHAR)'\0',
            pRecipients[dwInd].lptstrNumber,
            (TCHAR)'\0'
            );
        lptstrMultiStringCurrPos += dwRet;
    }

    // Set desired cover page
    dwEC = RegSetValueEx(
        hkWzrdHack,
        REGVAL_FAKECOVERPAGE,
        0,
        REG_SZ,
        (CONST BYTE *)lpctstrCoverPage,
        (_tcslen(lpctstrCoverPage) + 1) * sizeof(TCHAR) 
        );
    if (dwEC != ERROR_SUCCESS)
    {
        lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%ld Failed to set %s registry value (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            REGVAL_FAKECOVERPAGE,
            dwEC
            );
        goto exit_func;
    }

    // Set tests count to 1
    dwEC = RegSetValueEx(
        hkWzrdHack,
        REGVAL_FAKETESTSCOUNT,
        0,
        REG_DWORD,
        (CONST BYTE *)&dwTestsCount,
        sizeof(dwTestsCount)
        );
    if (dwEC != ERROR_SUCCESS)
    {
        lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%ld Failed to set %s registry value (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            REGVAL_FAKETESTSCOUNT,
            dwEC
            );
        goto exit_func;
    }

    // Set desired recipients
    dwEC = RegSetValueEx(
        hkWzrdHack,
        REGVAL_FAKERECIPIENT,
        0,
        REG_MULTI_SZ,
        (CONST BYTE *)lptstrRecipientMultiString,
        dwMultiStringBytes
        );
    if (dwEC != ERROR_SUCCESS)
    {
        lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%ld Failed to set %s registry value (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            REGVAL_FAKERECIPIENT,
            dwEC
            );
        goto exit_func;
    }

exit_func:

    if (lptstrRecipientMultiString && LocalFree(lptstrRecipientMultiString) != NULL)
    {
        lgLogError(
            LOG_SEV_2,
            TEXT("FILE:%s LINE:%ld LocalFree failed (ec = 0x%08lX)"),
            TEXT(__FILE__),
            __LINE__,
            GetLastError()
            );
    }
    if (hkWzrdHack)
    {
        dwCleanUpEC = RegCloseKey(hkWzrdHack);
        if (dwCleanUpEC != ERROR_SUCCESS)
        {
            lgLogError(
                LOG_SEV_2,
                TEXT("FILE:%s LINE:%ld RegCloseKey failed (ec = 0x%08lX)"),
                TEXT(__FILE__),
                __LINE__,
                dwCleanUpEC
                );
        }
    }

    return dwEC;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\spooler\printfaxtodevicecontext\test1.cpp ===
/*++

Print a fax to a device context

lior shmueli (liors)



    
--*/

#include <windows.h>
#include <winbase.h>
#include <stdio.h>
#include <stdlib.h>
#include <winfax.h>
#include <tchar.h>
#include <assert.h>
#include <shellapi.h>
#include <time.h>
//
// main
//
int _cdecl
main(
    int argc,
    char *argvA[]
    ) 
{
	TCHAR szDocumentToFax[MAX_PATH] = TEXT("test.tif");
	TCHAR szReceipientNumber[64] = TEXT("5064");
	TCHAR szCoverPageName[1024] = TEXT("test.cov");
	TCHAR szServerName[MAX_PATH]=TEXT("");
	
	FAX_PRINT_INFO    FaxPrintInfo;
	DWORD             dwFaxId;
	FAX_CONTEXT_INFO  FaxContextInfo;
	FAX_COVERPAGE_INFO  CoverPageInfo;
	TCHAR szFaxPrinterName[MAX_PATH] = TEXT("");


	BOOL fUseCoverPage = FALSE;
	PFAX_JOB_PARAM pJobParam=NULL;
	PFAX_COVERPAGE_INFO pCoverpageInfo=NULL;


	LPTSTR *szArgv;
	#ifdef UNICODE
		szArgv = CommandLineToArgvW( GetCommandLine(), &argc );
	#else
		szArgv = argvA;
	#endif

	if (argc > 1) {
					_tcscpy(szFaxPrinterName,szArgv[1]);
		}
	else	{
					_tprintf(TEXT("Please specify a fax printer name\n"));
					return -1;
	}

				



	_tprintf( TEXT("Starting with fax printer %s\n"),szFaxPrinterName);
	GetFullPathName(TEXT("test.tif"), sizeof(szDocumentToFax) / sizeof(TCHAR), szDocumentToFax, NULL);
	GetFullPathName(TEXT("test.cov"), sizeof(szCoverPageName) / sizeof(TCHAR), szCoverPageName, NULL);
	  

	ZeroMemory(&FaxPrintInfo, sizeof(FAX_PRINT_INFO));
	FaxPrintInfo.SizeOfStruct = sizeof(FAX_PRINT_INFO);
	FaxPrintInfo.RecipientNumber = szReceipientNumber;
	ZeroMemory(&FaxContextInfo, sizeof(FAX_CONTEXT_INFO));
	FaxContextInfo.SizeOfStruct = sizeof(FAX_CONTEXT_INFO);
	ZeroMemory(&CoverPageInfo, sizeof(FAX_COVERPAGE_INFO));
	CoverPageInfo.SizeOfStruct = sizeof(FAX_COVERPAGE_INFO);
	
	if (!FaxStartPrintJob(szFaxPrinterName, &FaxPrintInfo, &dwFaxId, &FaxContextInfo)) {
	        _tprintf(TEXT("FaxStartPrintJob() failed.  The error code is 0x%08x.\r\n"), GetLastError());
		return -1;
	}
	else	
	{
		_tprintf(TEXT("StartPrintJob: OK. JobId=%d\n"),dwFaxId);
	}
	
	CoverPageInfo.UseServerCoverPage = TRUE;
    	CoverPageInfo.CoverPageName = szCoverPageName;
    
	
    	if (!FaxPrintCoverPage(&FaxContextInfo, &CoverPageInfo)) {
      		  _tprintf(TEXT("FaxPrintCoverPage() failed.  The error code is 0x%08x.\r\n"), GetLastError());
	}
	else	{
		_tprintf(TEXT("FaxPrintCoverPage: OK\n"));

	}

	StartPage(FaxContextInfo.hDC);



	if (!Arc(FaxContextInfo.hDC,10,10,100,100,5,5,75,75))
		{
		_tprintf(TEXT("Arc failed with error code 0x%08x\n"),GetLastError());
	}
	else
	{
		_tprintf(TEXT("Printed an Arc: OK\n"));
	}

	EndPage(FaxContextInfo.hDC);

	if (!EndDoc(FaxContextInfo.hDC))
		{
		_tprintf(TEXT("EndDoc failed with error code 0x%08x"),GetLastError());
	}
    
return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\stress\stressmngr\ctestmanager.cpp ===
#include <windows.h>
#include <winfax.h>
#include <testruntimeerr.h>
#include <RandomUtilities.h>

// specific
#include "CTestManager.h"
#include "Defs.h"
#include "RegUtilities.cpp"
#include "HandleServerEventsFuncs.h"

// Constructor
// Initialize fax connection, start test timer
// [in] tstrServerName - fax server name.
// [in] dwTestDuration - test duration.
//
CTestManager::CTestManager(const tstring tstrServerName,
						   const DWORD dwTestDuration):
	m_hFax(NULL),
	m_hTestTimer(NULL),
	m_tstrServerName(tstrServerName),
	m_dwTestDuration(dwTestDuration),
	m_EvTestTimePassed(NULL, FALSE, FALSE,TEXT("")),
	m_pAbortMng(NULL),
	m_pEventHook(NULL),
	m_hCleanStorageTimer(NULL)
{

	// TODO : This is by default setting
	// The model should be enhanced.
	//
	// Set the function to handle server notifications.
	m_fnHandleNotification = _HandleTestMustSucceed;
	
	// initialize service conection
	BOOL bVal = FaxConnectFaxServer( m_tstrServerName.c_str(), &m_hFax);
	if(!bVal)
	{
		DWORD dwErr = GetLastError();
		if(!dwErr)
		{
			::lgLogError(LOG_SEV_2, TEXT("FaxConnectFaxServer - GetLastError returned 0 on fail, module CTestManager."));
		}
		THROW_TEST_RUN_TIME_WIN32(dwErr, TEXT("CTestManager, ConnectFaxServer"));
	}
	

	// initialize test timer
	if(m_dwTestDuration)
	{
		if( !RegisterWaitForSingleObject( &m_hTestTimer,
										  m_EvTestTimePassed.get(),
									      TestTimerCallBack, 
									      (PVOID)m_EvTestTimePassed.get(), 
									      m_dwTestDuration * 1000, 
									      WT_EXECUTEINWAITTHREAD | WT_EXECUTEONLYONCE))
		{
			//constructor is failing, cleanup
			_HandlesCleanup();
			THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT("CTestManager, Failed to create test timer object"));
		}
	}
}

  
//
// StartEventHookThread
//
DWORD CTestManager::StartEventHookThread(const DWORD dwEventPollingTime)
{
	try
	{
		m_pEventHook = new CEventThread();
	}
	catch(Win32Err& err)
	{
		return err.error();
	}

	if(!m_pEventHook)
	{
		return ERROR_OUTOFMEMORY;
	}

	DWORD dwInitRetVal = m_pEventHook->Initialize(m_tstrServerName,
											      m_fnHandleNotification,
									              dwEventPollingTime);
	if(dwInitRetVal)
	{
		delete m_pEventHook;
		m_pEventHook = NULL;
	}

	return dwInitRetVal;
}

//
// InitAbortThread
//
DWORD CTestManager::InitAbortThread(const DWORD dwAbortPercent, 
									const DWORD dwAbortWindow,
									const DWORD dwMinAbortRate,
									const DWORD dwMaxAbortRate)
{

	try
	{
		m_pAbortMng = new CThreadAbortMng();
	}
	catch(Win32Err& err)
	{
		return err.error();
	}

	if(!m_pAbortMng)
	{
		return ERROR_OUTOFMEMORY;
	}

	DWORD dwFuncAbortPercent, dwFuncAbortWindow, dwFuncMinAbortRate, dwFuncMaxAbortRate;
	dwFuncAbortPercent = dwAbortPercent ? dwAbortPercent : DEFAULT_ABORT_PERCENT;
	dwFuncAbortWindow = dwAbortWindow ? dwAbortWindow : DEFAULT_ABORT_WINDOW;
	dwFuncMinAbortRate = dwMinAbortRate ? dwMinAbortRate * 60 : DEFAULT_MIN_ABORT_RATE;
	dwFuncMaxAbortRate = dwMaxAbortRate ? dwMaxAbortRate * 60 : (dwFuncMinAbortRate + DEFAULT_ABORT_RATE_INTERVAL);

	DWORD dwInitRetVal = m_pAbortMng->Initialize(m_hFax,
												 dwFuncAbortPercent, 
												 dwFuncAbortWindow,
												 dwFuncMinAbortRate,
												 dwFuncMaxAbortRate);

	if(dwInitRetVal)
	{
		delete m_pAbortMng;
		m_pAbortMng = NULL;
	}

	return dwInitRetVal;

}


//
// CleanStorageThread
//
DWORD CTestManager::CleanStorageThread(const DWORD dwPeriodMin)
{
	HKEY hServerArrayKey = NULL;
	DWORD dwRetVal = 0;
	tstring tstrSentArchiveFolder;
	tstring tstrReceivedArchiveFolder;
  
	try
	{
		// !!!!!!!!!!!!! TODO !!!!!!!!!!!!!!
		//  Fax is moving out of comet.
		//  Registry hierarchy will change.
		//
		// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		
		// Open the fax server array registry key
		if(dwRetVal = FindServerArrayEntry(hServerArrayKey) != S_OK)
		{
			THROW_TEST_RUN_TIME_WIN32(dwRetVal, TEXT("CTestManager, CleanStorageThread"));
		}

		// get sent archive folder path
		dwRetVal = GetArchiveFolderName(SENT_ARCIVE, hServerArrayKey, tstrSentArchiveFolder);

		if (ERROR_SUCCESS != dwRetVal)
		{
			 THROW_TEST_RUN_TIME_WIN32(dwRetVal, TEXT("CTestManager, CleanStorageThread"));
		}

		
		// get folder full path
		if(dwRetVal = GetCometRelativePath (tstrSentArchiveFolder,
											m_StorageFolders.tstrSentArchive))
		{
			THROW_TEST_RUN_TIME_WIN32(dwRetVal, TEXT("CTestManager, CleanStorageThread"));
		}


		// get received archive folder path
		dwRetVal = GetArchiveFolderName(RECEIVED_ARCIVE, hServerArrayKey, tstrReceivedArchiveFolder);

		if (ERROR_SUCCESS != dwRetVal)
		{
			 THROW_TEST_RUN_TIME_WIN32(dwRetVal, TEXT("CTestManager, CleanStorageThread"));
		}

		
		// get folder full path
		if(dwRetVal = GetCometRelativePath (tstrReceivedArchiveFolder,
											m_StorageFolders.tstrReceivedArchive))
		{
			THROW_TEST_RUN_TIME_WIN32(dwRetVal, TEXT("CTestManager, CleanStorageThread"));
		}


	
		if (!RegisterWaitForSingleObject( &m_hCleanStorageTimer,
										  m_EvTestTimePassed.get(),
										  CleanStorageCallBack, 
										  (PVOID) &m_StorageFolders, 
										  dwPeriodMin * 60 * 1000, 
										  WT_EXECUTEINWAITTHREAD | WT_EXECUTEONLYONCE))
		{
			THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT("CTestManager, CleanStorageThread"));
		}
	
	}
	catch(Win32Err& err)
	{
		::lgLogError(LOG_SEV_1, TEXT("Exception:%s."), err.what());
		dwRetVal = err.error();
	}

	//cleanup
	RegCloseKey(hServerArrayKey);
	return dwRetVal;
}


//
// Destructor
//
CTestManager::~CTestManager()
{
	delete m_pAbortMng;
	m_pAbortMng = NULL;

	delete m_pEventHook;
	m_pEventHook = NULL;

	_TimersCleanup();

	_HandlesCleanup();
}


//
// _HandlesCleanup
//
void CTestManager::_HandlesCleanup()
{
	if (m_hFax != NULL)
	{
		if (!FaxClose( m_hFax ))
		{
			Win32Err err(GetLastError(),__LINE__,TEXT(__FILE__),TEXT("~CTestManager, FaxClose"));
			::lgLogError(LOG_SEV_1, TEXT("Exception:%s."), err.description());
		}

		m_hFax = NULL;
	}

}

//
// _TimersCleanup
//
void CTestManager::_TimersCleanup()
{

	// This event will signify the timer's callback funcs returned or,
	// it was unregistered successfully while it was still pending.
	Event_t hTimerCompletionEvent(NULL, TRUE, FALSE,TEXT(""));
	
	if(m_hTestTimer != NULL)
	{
		if(!UnregisterWaitEx(m_hTestTimer, hTimerCompletionEvent.get()))
		{
			Win32Err err(GetLastError(),__LINE__,TEXT(__FILE__),TEXT("CTestManager::_TimersCleanup"));
			::lgLogError(LOG_SEV_1, TEXT("Exception:%s."), err.description());
		}
		else
		{
			DWORD dwRetVal = WaitForSingleObjectEx( hTimerCompletionEvent.get() , 0, FALSE);
	
			if( dwRetVal == WAIT_FAILED)
			{
				Win32Err err(GetLastError(),__LINE__,TEXT(__FILE__),TEXT("CTestManager::_TimersCleanup, WaitForSingleObjectEx"));
				::lgLogError(LOG_SEV_1, TEXT("Exception:%s."), err.description());
			}
		}
	
		m_hTestTimer = NULL;
	}


	if(!ResetEvent(hTimerCompletionEvent.get()))
	{
		Win32Err err(GetLastError(),__LINE__,TEXT(__FILE__),TEXT("CTestManager::_TimersCleanup, ResetEvent"));
		::lgLogError(LOG_SEV_1, TEXT("Exception:%s."), err.description());
		// But still we'll try unregistreting rest of the timers
	}

	if(m_hCleanStorageTimer != NULL)
	{
		if(!UnregisterWaitEx(m_hCleanStorageTimer, hTimerCompletionEvent.get()))
		{
			Win32Err err(GetLastError(),__LINE__,TEXT(__FILE__),TEXT("CTestManager::_TimersCleanup"));
			::lgLogError(LOG_SEV_1, TEXT("Exception:%s."), err.description());
		}
		else
		{
			DWORD dwRetVal = WaitForSingleObjectEx( hTimerCompletionEvent.get() , 0, FALSE);
	
			if( dwRetVal == WAIT_FAILED)
			{
				Win32Err err(GetLastError(),__LINE__,TEXT(__FILE__),TEXT("CTestManager::_TimersCleanup, WaitForSingleObjectEx"));
				::lgLogError(LOG_SEV_1, TEXT("Exception:%s."), err.description());
			}
		}

		m_hCleanStorageTimer = NULL;
	}

}


//
// AddSimpleJobEx
// using FaxSendDocumentEx api
//
DWORD CTestManager::AddSimpleJobEx(JOB_PARAMS_EX& params)
{
	DWORD dwRetVal = 0;
	params.pdwRecepientsId = SPTR<DWORD>(new DWORD[params.dwNumRecipients]);
	if(!(params.pdwRecepientsId).get()) 
	{
		return ERROR_OUTOFMEMORY;
	}

	BOOL bVal = FaxSendDocumentEx(m_hFax,
								  params.szDocument,
								  (params.pCoverpageInfo).GetData(),
								  (params.pSenderProfile).GetData(),
								  params.dwNumRecipients,
								  (params.pRecepientList).GetData(),
								  (params.pJobParam)->GetData(),
								  &params.dwParentJobId,
								  params.pdwRecepientsId.get()); 

	if(!bVal)
	{
		dwRetVal = GetLastError();
	}
	
	return dwRetVal;
}


//
// TestTimePassed
//
BOOL CTestManager::TestTimePassed()
{
	DWORD dwRetVal;
	
	dwRetVal = WaitForSingleObjectEx( m_EvTestTimePassed.get() , 0, FALSE);
	
	if( dwRetVal == WAIT_TIMEOUT)
	{
		return FALSE;
	}

	if( dwRetVal == WAIT_FAILED)
	{
		Win32Err err(GetLastError(),__LINE__,TEXT(__FILE__),TEXT("CTestManager::TestTimePassed, WaitForSingleObjectEx"));
		::lgLogError(LOG_SEV_1, TEXT("Exception:%s."), err.description());
	}

	return TRUE;

}


//
// CancelAllFaxes
// TODO: to be implemented
//
DWORD CTestManager::CancelAllFaxes()
{
	PFAX_JOB_ENTRY pJobEntry = NULL;
	DWORD dwJobsReturned;
	DWORD dwFunRetVal = 0;

	::lgLogDetail(LOG_X, 0, TEXT("CancelAllFaxes()"));

	if (!FaxEnumJobs( m_hFax, &pJobEntry, &dwJobsReturned))
	{
		dwFunRetVal = GetLastError();
	}
	else
	{
		for (DWORD dwJobIndex = 0; dwJobIndex < dwJobsReturned; dwJobIndex++)
		{
			DWORD dwJobId = pJobEntry[dwJobIndex].JobId;
			if (!FaxAbort(m_hFax, dwJobId))
			{
				lgLogDetail(LOG_X, 0, TEXT("job %d, FaxAbort() failed with %d"),dwJobId,GetLastError());
			}
			else
			{
				lgLogDetail(LOG_X, 0, TEXT("job %d, FaxAbort() succedded"),dwJobId);
			}
		}
	}
		
	FaxFreeBuffer(pJobEntry);
	return dwFunRetVal;
}

//
// StopFaxService
// TODO: to be implemented
//
BOOL CTestManager::StopFaxService()
{	
	::lgLogDetail(LOG_X, 0, TEXT("StopFaxService()"));
	int ret = _wsystem(L"net stop cometfax");
	if(ret && (ret != ENOENT))
	{
		return FALSE;
	}

	
	if (m_hFax != NULL)
	{
		if (!FaxClose( m_hFax ))
		{
			Win32Err err(GetLastError(),__LINE__,TEXT(__FILE__),TEXT("~CTestManager, FaxClose"));
			::lgLogError(LOG_SEV_1, TEXT("Exception:%s."), err.description());
			return FALSE;
		}
	}
	return TRUE;

}

//
// StartFaxService
// TODO: to be implemented
//
BOOL CTestManager::StartFaxService()
{	
	::lgLogDetail(LOG_X, 0, TEXT("StartFaxService()"));
	int ret = _wsystem(L"net start cometfax");
	if(ret && (ret != ENOENT))
	{
		return FALSE;
	}

	try
	{
		//initialize service conection
		BOOL bVal = FaxConnectFaxServer( m_tstrServerName.c_str(), &m_hFax);
		if(!bVal)
		{
			DWORD dwErr = GetLastError();
			if(!dwErr)
			{
				::lgLogError(LOG_SEV_2, TEXT("FaxConnectFaxServer-GetLastError returned 0 on fail, module CTestManager."));
			}
			THROW_TEST_RUN_TIME_WIN32(dwErr, TEXT("CTestManager, ConnectFaxServer"));
		}
	
	}
	catch(Win32Err& err)
	{
		_HandlesCleanup();
		::lgLogError(LOG_SEV_1,TEXT("Exception, CTestManager::StartFaxService %s"), err.description());
		return FALSE;
	}

	return TRUE;
}


// 
//  TODO: Saved for backup purpose
//
// CleanStorageThread
//
/*DWORD CTestManager::CleanStorageThread(DWORD dwPeriodMin)
{
	HKEY hServerArrayKey = NULL;
	HKEY hSentArchivePolicy = NULL;
	HKEY hReceivedArchivePolicy = NULL;
	BYTE* szFolderName = NULL;
	DWORD dwRetVal = 0;
	tstring tstrSentArchiveFolder;
	tstring	tstrSentArchivePath;
	tstring tstrReceivedArchiveFolder;
    tstring tstrReceivedArchivePath;

	try
	{
		// !!!!!!!!!!!!! TODO !!!!!!!!!!!!!!
		//  Fax is moving out of comet.
		//  Registry hierarchy will completely change.
		//
		// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		
		// Open the fax server array registry key
		if(dwRetVal = FindServerArrayEntry(hServerArrayKey) != S_OK)
		{
			THROW_TEST_RUN_TIME_WIN32(dwRetVal, TEXT("CTestManager, CleanStorageThread"));
		}

		// TODO : merge to  a single func

	    // Open the sent archive policy registry key
		dwRetVal = RegOpenKeyEx( hServerArrayKey, 
								 FAX_SENT_ARCHIVE_POLICY, 
								 0, 
								 KEY_ALL_ACCESS, 
								 &hSentArchivePolicy
								 );
		if (ERROR_SUCCESS != dwRetVal)
		{
			 THROW_TEST_RUN_TIME_WIN32(dwRetVal, TEXT("CTestManager, CleanStorageThread"));
		}

		// query folder name value
		DWORD dwBufferSize = 0;
		DWORD dwType = 0;
		dwRetVal =  RegQueryValueEx( hSentArchivePolicy,
									 COMET_FOLDER_STR,
									 NULL,
									 &dwType,
									 NULL,  
									 &dwBufferSize);

		if(ERROR_SUCCESS != dwRetVal)
		{
			 THROW_TEST_RUN_TIME_WIN32(dwRetVal, TEXT("CTestManager, CleanStorageThread"));
		}

		// alocate folder name buffer
		szFolderName = new BYTE[dwBufferSize + 1];
		if(!szFolderName)
		{
			THROW_TEST_RUN_TIME_WIN32(ERROR_OUTOFMEMORY, TEXT("CTestManager, CleanStorageThread"));
		}

		// query folder name value
		dwRetVal =  RegQueryValueEx( hSentArchivePolicy,
									 COMET_FOLDER_STR,
									 NULL,
									 &dwType,
									 szFolderName,  
									 &dwBufferSize);
		if (ERROR_SUCCESS != dwRetVal)
		{
			THROW_TEST_RUN_TIME_WIN32(dwRetVal, TEXT("CTestManager, CleanStorageThread"));
		}



		// get folder full path
		TCHAR* tchFolderName = (TCHAR*)szFolderName;
		tstrSentArchiveFolder = tchFolderName;
		if(dwRetVal = GetCometRelativePath (tstrSentArchiveFolder,
											m_StorageFolders.SentArchivePath))
		{
			THROW_TEST_RUN_TIME_WIN32(dwRetVal, TEXT("CTestManager, CleanStorageThread"));
		}


		delete(szFolderName);
		szFolderName = NULL;

		// Open the received archive policy registry key
		dwRetVal = RegOpenKeyEx( hServerArrayKey, 
								 FAX_SENT_ARCHIVE_POLICY, 
								 0, 
								 KEY_ALL_ACCESS, 
								 &hReceivedArchivePolicy
								 );
		if (ERROR_SUCCESS != dwRetVal)
		{
			 THROW_TEST_RUN_TIME_WIN32(dwRetVal, TEXT("CTestManager, CleanStorageThread"));
		}


		// Open the received archive policy registry key
		dwRetVal = RegOpenKeyEx( hServerArrayKey, 
								 FAX_RECEIVED_ARCHIVE_POLICY, 
								 0, 
								 KEY_ALL_ACCESS, 
								 &hReceivedArchivePolicy
								 );
		if (ERROR_SUCCESS != dwRetVal)
		{
			 THROW_TEST_RUN_TIME_WIN32(dwRetVal, TEXT("CTestManager, CleanStorageThread"));
		}

		// query folder name value
		dwRetVal =  RegQueryValueEx( hReceivedArchivePolicy,
									 COMET_FOLDER_STR,
									 NULL,
									 &dwType,
									 NULL,  
									 &dwBufferSize);

		if(ERROR_SUCCESS != dwRetVal)
		{
			 THROW_TEST_RUN_TIME_WIN32(dwRetVal, TEXT("CTestManager, CleanStorageThread"));
		}

		// alocate folder name buffer
		szFolderName = new BYTE[dwBufferSize + 1];
		if(!szFolderName)
		{
			THROW_TEST_RUN_TIME_WIN32(ERROR_OUTOFMEMORY, TEXT("CTestManager, CleanStorageThread"));
		}

		// query folder name value
		dwRetVal =  RegQueryValueEx( hReceivedArchivePolicy,
									 COMET_FOLDER_STR,
									 NULL,
									 &dwType,
									 szFolderName,  
									 &dwBufferSize);
		if (ERROR_SUCCESS != dwRetVal)
		{
			THROW_TEST_RUN_TIME_WIN32(dwRetVal, TEXT("CTestManager, CleanStorageThread"));
		}

		// get folder full path
		tstrReceivedArchiveFolder = (TCHAR*)szFolderName;
		if(dwRetVal = GetCometRelativePath (tstrReceivedArchiveFolder,
											m_StorageFolders.ReceivedArchivePath))
		{
			THROW_TEST_RUN_TIME_WIN32(dwRetVal, TEXT("CTestManager, CleanStorageThread"));
		}


	
		if (!RegisterWaitForSingleObject( &m_hCleanStorageTimer,
										  m_EvTestTimePassed.get(),
										  CleanStorageCallBack, 
										  (PVOID) &m_StorageFolders, 
										  dwPeriodMin * 60 * 1000, 
										  WT_EXECUTEINWAITTHREAD | WT_EXECUTEONLYONCE))
		{
			THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT("CTestManager, CleanStorageThread"));
		}
	
	}
	catch(Win32Err& err)
	{
		::lgLogError(LOG_SEV_1, TEXT("Exception:%s."), err.what());
		dwRetVal = err.error();
	}

	//cleanup
	RegCloseKey(hServerArrayKey);
	RegCloseKey(hSentArchivePolicy);
	RegCloseKey(hReceivedArchivePolicy);
	
	delete szFolderName;
	return dwRetVal;
}
*/

//
// TODO: will those be useful?
//
// RandomAbortSubset
//
// TODO: delete
/*DWORD CTestManager::RandomAbortSubset(DWORD dwSubsetSize,
									  DWORD dwMinAbortSleep,
									  DWORD dwMaxAbortSleep)
{
	DWORD dwFunRetVal = 0;
	
	m_dwMinAbortSleep = dwMinAbortSleep;
	m_dwMaxAbortSleep = dwMaxAbortSleep;
	
	m_phAbortThread = CreateThread(NULL, 0, ThreadAbortMng, (void*)this,0 , &m_dwAbortThreadId);
	
	if(!m_phAbortThread )
	{
		dwFunRetVal = GetLastError();
	}
	return dwFunRetVal;
}

//
// ThreadAbortMng
// 
// TODO :delete
inline DWORD WINAPI ThreadAbortMng(void* params)
{

	CTestManager* thread = (CTestManager*)params;

	DWORD dwThreadRetVal = 0;

	PFAX_JOB_ENTRY pJobEntry = NULL;
	DWORD* pdwSubsetArray = NULL;
	ABORT_PARAMS* pParamsArray = NULL;
	HANDLE* pAbortJobHandles = NULL;
	HANDLE hTimersCountSem = NULL;
	HANDLE hTimerQueue = NULL;
	
	try
	{
		//set random starting point
		srand(GetTickCount());
		
		DWORD dwJobsReturned;// enumerate jobs
		if (!FaxEnumJobs( thread->GetFaxHandle(), &pJobEntry, &dwJobsReturned))
		{
			THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT("ThreadAbortMng, FaxEnumJobs"));
		}
		if(dwJobsReturned)
		{
			pdwSubsetArray = new DWORD[dwJobsReturned];
			if(!pdwSubsetArray)
			{
				THROW_TEST_RUN_TIME_WIN32(ERROR_OUTOFMEMORY, TEXT("ThreadAbortMng, new"));
			}
					
			// select subset of jobs to abort
			DWORD dwSubsetSize = RandomSelectSubset(pdwSubsetArray, dwJobsReturned);
			
			if(dwSubsetSize)
			{
				pAbortJobHandles = new HANDLE[dwSubsetSize];
				pParamsArray = new ABORT_PARAMS[dwSubsetSize];
				if(!pAbortJobHandles || !pParamsArray)
				{
					THROW_TEST_RUN_TIME_WIN32(ERROR_OUTOFMEMORY, TEXT("ThreadAbortMng, new"));
				}

				hTimerQueue = CreateTimerQueue();
				if(!hTimerQueue)
				{
					THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT("ThreadAbortMng, new"));
				}

				// the semaphore is used to signal the timer queue timer
				// call backs terminated execution.
				hTimersCountSem = CreateSemaphore(NULL,
												  0,
												  dwSubsetSize,
												  TEXT("TimersCountSemaphore"));

				if(!hTimersCountSem)
				{
					THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT("ThreadAbortMng, CreateSemaphore"));
				}
				
				DWORD dwHandleCount = 0;
				for (DWORD dwJobIndex = 0; dwJobIndex < dwJobsReturned; dwJobIndex++)
				{
					// job was selected for abort
					if(pdwSubsetArray[dwJobIndex])
					{
						// set timer queue timer received data
						pParamsArray[dwHandleCount].dwJobId = pJobEntry[dwJobIndex].JobId;
						pParamsArray[dwHandleCount].hFax = thread->GetFaxHandle();
						pParamsArray[dwHandleCount].hSemaphore = hTimersCountSem;

						// calc sleep before abort
						DWORD dwAbortDueTime = (rand()*100) % abs(thread->GetMaxAbortSleep() - thread->GetMinAbortSleep());
						dwAbortDueTime += thread->GetMinAbortSleep();
						
						if(!CreateTimerQueueTimer( &pAbortJobHandles[dwHandleCount],
												   hTimerQueue,
												   ThreadAbortJob,
												   &pParamsArray[dwHandleCount],
												   dwAbortDueTime,
												   0,
												   0))
						{
							Win32Err err(GetLastError(),__LINE__,TEXT(__FILE__),TEXT("ThreadAbortMng, CreateTimerQueueTimer"));
							::lgLogError(LOG_SEV_1, TEXT("Exception:%s."), err.Desc());
							continue;
						}

						dwHandleCount++;
					}
				}
					
				// wait for timer queue timers call back termination
				for(DWORD index = 0; index < dwHandleCount; index++)
				{
					if(WaitForSingleObject(hTimersCountSem, thread->GetMaxAbortSleep()*3) == WAIT_FAILED)
					{
						Win32Err err(GetLastError(),__LINE__,TEXT(__FILE__),TEXT("ThreadAbortMng, WaitForSingleObject"));
						::lgLogError(LOG_SEV_1, TEXT("Exception:%s."), err.Desc());
						break;
					}
				}
			}
		}
		
	}
	catch(Win32Err& err)
	{
		::lgLogError(LOG_SEV_1, TEXT("Exception:%s."), err.what());
		dwThreadRetVal = err.error();
	}

	// cleanup
	FaxFreeBuffer(pJobEntry);
	delete pdwSubsetArray;
	delete pParamsArray;
	delete pAbortJobHandles;
	if(hTimersCountSem)
	{
		if(!CloseHandle(hTimersCountSem))
		{
			Win32Err err(GetLastError(),__LINE__,TEXT(__FILE__),TEXT("ThreadAbortMng, CloseHandle"));
			::lgLogError(LOG_SEV_2, TEXT("Exception:%s."), err.Desc());
		}
	}
	
	if(!DeleteTimerQueueEx(hTimerQueue,NULL))
	{
		Win32Err err(GetLastError(),__LINE__,TEXT(__FILE__),TEXT("ThreadAbortMng, DeleteTimerQueueEx"));
		::lgLogError(LOG_SEV_2, TEXT("Exception:%s."), err.Desc());
	}

	return dwThreadRetVal; 
}
*/

// 
//  TODO: Saved for backup purpose
//
/*	if(m_dwTestDuration)
	{
		m_hThreadTimer = CreateThread(NULL, 0, ThreadTimerFunc, (void*)this ,0 , &m_dwThreadTimerId);
		if(!m_hThreadTimer )
		{
			//constructor is failing, cleanup
			_HandlesCleanup();
			THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT("CTestManager, Failed to create thread timer object"));
		}
	}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\stress\stressmngr\cthreadabortmng.h ===
#ifndef _CTHREAD_ABORT_MNG_H
#define _CTHREAD_ABORT_MNG_H

#include <cthread.h>
#include <autoptrs.h>


class CThreadAbortMng: public ThreadBase_t
{
public:
		
	CThreadAbortMng();
	DWORD Initialize(const HANDLE hFax,
					 const DWORD dwAbortPercent, 
					 const DWORD dwAbortWindow,
					 const DWORD dwMinAbortRate,
					 const DWORD dwMaxAbortRate);
	~CThreadAbortMng();
	unsigned int ThreadMain();
	void StopThreadMain();
	HANDLE GetEvThreadCompleted()const {return  m_EventEndThread.get();};

private:
	BOOL m_fStopFlag;
	HANDLE m_hTimerQueue;
	HANDLE m_hFax;
	// event signifying thread termination 
	Event_t  m_EventEndThread;

	DWORD m_dwAbortPercent;
	DWORD m_dwAbortWindow;
	DWORD m_dwMinAbortRate;
	DWORD m_dwMaxAbortRate;

};


#endif //_CTHREAD_ABORT_MNG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\stress\stressmngr\handleservereventsfuncs.h ===
#ifndef _HANDEL_SERVER_EVENTS_FUNCS
#define _HANDEL_SERVER_EVENTS_FUNCS

#include <CEventThread.h>
#include <StringTable.h>

// Declarations
//
DWORD WINAPI _HandleTestMustSucceed(CFaxEvent& pFaxEvent);


//
// _HandleTestMustSucceed
//
//
inline DWORD WINAPI _HandleTestMustSucceed(CFaxEvent& pFaxEvent)
{
	switch(pFaxEvent.GetEventId()) 
	{

	case FEI_FAXSVC_STARTED:
	case FEI_MODEM_POWERED_ON:
	case FEI_MODEM_POWERED_OFF:
	case FEI_FAXSVC_ENDED:
	case FEI_IDLE:
	case FEI_RINGING:
	case FEI_RECEIVING:
	case FEI_INITIALIZING:
	case FEI_HANDLED: // TODO: what is that?
	case FEI_ROUTING:
	case FEI_ANSWERED:
	case FEI_DIALING:
	case FEI_DELETED:
	case FEI_SENDING:
	case FEI_COMPLETED:
	case FEI_JOB_QUEUED:
		break;

	default:
		{
			for(int index = 0; index <  FaxTableSize; index++)
			{
				if(FaxEventTable[index].first == pFaxEvent.GetEventId())
				{
					if(pFaxEvent.GetJobId() != 0xffffffff && pFaxEvent.GetJobId() != 0)
					{
						::lgLogError(LOG_SEV_1, TEXT("UNEXPECTED JobId %d, %s"),
												pFaxEvent.GetJobId(),
												(FaxEventTable[index].second).c_str());
					}
					else
					{
						::lgLogError(LOG_SEV_1, TEXT("UNEXPECTED service status %s"),
												(FaxEventTable[index].second).c_str());
					}

					goto Exit;
				}
			
 			}
			// handle unexpected notifications
			if(pFaxEvent.GetJobId() != 0xffffffff && pFaxEvent.GetJobId()!= 0)
			{
				::lgLogError(LOG_SEV_1, TEXT("UNDEFINED JobId %d, %s"),
										pFaxEvent.GetJobId(),
										(FaxEventTable[index].second).c_str());
			}
			else
			{
				::lgLogError(LOG_SEV_1, TEXT("UNDEFINED service status %s"),
										(FaxEventTable[index].second).c_str());
			}
		
Exit:		break;
		}	
	}
	return 0;
}


#endif //_HANDEL_SERVER_EVENTS_FUNCS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\stress\stressmngr\preparerandomjob.cpp ===
#ifndef _PREPARE_RANDOM_JOB_H
#define _PREPARE_RANDOM_JOB_H

//
// Prepare a random broadcast job
//

#pragma warning(disable :4786)
#include <vector>
#include <map>
#include <testruntimeerr.h>
#include <RandomUtilities.h>
#include "PrepareJobParams.cpp"
#include "CJobParams.h"

// Definitions
//
#define RECIPIENTS_MAX_NUM 20
#define MAX_FAX_NUMBER 9999

static DWORD x_FaxNumberIndex = 0;

// Declarations
//
DWORD PrepareRandomJob(JOB_PARAMS_EX& pJparams,
					   const std::vector<tstring> FaxFileVector,
					   const tstring tstrTestName,
					   const std::vector<tstring> CoverPageVector,
					   const std::vector<tstring> RecipientNumbersList,
					   const BOOL fUniqRecipNum = FALSE);


static aaptr<PersonalProfile> PrepareRecipientProfileArray(const std::vector<tstring> RecipientNumbersList,
														   const DWORD dwRecipientsNumber,
														   const BOOL fUniqRecipNum);
//
// PrepareRandomJob
//
//
inline DWORD PrepareRandomJob(JOB_PARAMS_EX& pJparams,
							  const std::vector<tstring> FaxFileVector,
							  const tstring tstrTestName,
							  const std::vector<tstring> CoverPageVector,
							  const std::vector<tstring> RecipientNumbersList,
							  const BOOL fUniqRecipNum)
{
	srand(GetTickCount());
	assert(!FaxFileVector.empty());
	
	try
	{
		// prepare job params, job is scheduledd for the current system time.
		//
		pJparams.pJobParam = new JobParamExNow(tstrTestName.c_str());
		if(!pJparams.pJobParam)
		{
			THROW_TEST_RUN_TIME_WIN32(ERROR_OUTOFMEMORY, TEXT("PrepareRandomJob, new"));
		}

		// select fax document path
		//
		DWORD dwFaxFileEntry = 0;
		if(FaxFileVector.size() > 1)
		{
			dwFaxFileEntry +=  rand() % (FaxFileVector.size());
		}

		TCHAR*  tstrDupDocName = _tcsdup(FaxFileVector[dwFaxFileEntry].c_str());
		assert(tstrDupDocName);
		pJparams.szDocument = tstrDupDocName;
		
		// prepare CoverPageInfo
		// 
		DWORD dwCPEntry = 0;
		if(CoverPageVector.size() > 1)
		{
			dwCPEntry +=  rand() % (CoverPageVector.size());
			
			CoverPageInfo CPInfo(CoverPageVector[dwCPEntry].c_str());
			pJparams.pCoverpageInfo = CPInfo;
		}

		// Number of recipients
		//
		if(RecipientNumbersList.empty())
		{
			// gain random number of recipients
			pJparams.dwNumRecipients = 1 + ( rand() % RECIPIENTS_MAX_NUM);
		}
		else
		{
			pJparams.dwNumRecipients = 1 + ( rand() % RecipientNumbersList.size());
		}
		
		// prepare sender profile
		//
		FAX_PERSONAL_PROFILE SenderInfo;
		memset(&SenderInfo, 0, sizeof(FAX_PERSONAL_PROFILE));
		SenderInfo.dwSizeOfStruct = sizeof(FAX_PERSONAL_PROFILE);
		
		//gain random sender number
		DWORD dwSenderNum = ( (rand() * 100) % MAX_FAX_NUMBER);
		otstringstream otstrSenderNum;
		otstrSenderNum << dwSenderNum;
		SenderInfo.lptstrFaxNumber = const_cast<TCHAR*>((otstrSenderNum.str()).c_str());
		PersonalProfile SenderProfile(SenderInfo);

		// prepare recipients profile array
		//
		aaptr<PersonalProfile> RecepientProfile = PrepareRecipientProfileArray(RecipientNumbersList,
																			  pJparams.dwNumRecipients,
																			  fUniqRecipNum);

		ListPersonalProfile RecepientProfileList(pJparams.dwNumRecipients, RecepientProfile.get());
		pJparams.pRecepientList = RecepientProfileList;
		pJparams.pSenderProfile = SenderProfile;
	}
	catch(Win32Err& err)
	{
		return err.error();
	}

	return 0;
}

//
// PrepareRecipientProfileArray
//
inline static aaptr<PersonalProfile> PrepareRecipientProfileArray(const std::vector<tstring> RecipientNumbersList,
																  const DWORD dwRecipientsNumber,
																  const BOOL fUniqRecipNum)
{

	DWORD* pdwSubsetArray = NULL;
	aaptr<PersonalProfile> RecepientProfile = new PersonalProfile[dwRecipientsNumber];
	if(!RecepientProfile.get())
	{
		THROW_TEST_RUN_TIME_WIN32(ERROR_OUTOFMEMORY, TEXT("PrepareRandomJob, new"));
	}

	FAX_PERSONAL_PROFILE RecipientInfo;
	memset(&RecipientInfo, 0, sizeof(FAX_PERSONAL_PROFILE));
	RecipientInfo.dwSizeOfStruct = sizeof(FAX_PERSONAL_PROFILE);

	if(!RecipientNumbersList.empty())
	{
		pdwSubsetArray = new DWORD[RecipientNumbersList.size()];
		if(!pdwSubsetArray)
		{
			THROW_TEST_RUN_TIME_WIN32(ERROR_OUTOFMEMORY, TEXT("PrepareRandomJob, new"));
		}
	
		RandomSelectSizedSubset(pdwSubsetArray, RecipientNumbersList.size(), dwRecipientsNumber);
	}
	
	DWORD index, dwRecipientCount;
	for(index = 0, dwRecipientCount = 0; index < RecipientNumbersList.size(); index++)
	{
		DWORD dwRecipientNum;
			
		if(!RecipientNumbersList.empty())
		{
			if(pdwSubsetArray[index])
			{
				RecipientInfo.lptstrFaxNumber = const_cast<TCHAR*>(RecipientNumbersList[index].c_str());
			}
			else
			{
				continue;
			}
		}
		else
		{
			if( index == dwRecipientsNumber)
				break;

			if(fUniqRecipNum)
			{
				dwRecipientNum = InterlockedIncrement( (LPLONG )&x_FaxNumberIndex); 

			}
			else 	// gain random recipient number 
			{
				dwRecipientNum = ( (rand() * 100) % MAX_FAX_NUMBER);
			}
		
			otstringstream otstrRecipientNum;
			otstrRecipientNum << dwRecipientNum;
			RecipientInfo.lptstrFaxNumber = const_cast<TCHAR*>((otstrRecipientNum.str()).c_str());
		}

		RecepientProfile[dwRecipientCount++] = PersonalProfile(RecipientInfo);
	}

	delete pdwSubsetArray;
	return RecepientProfile;
}

#endif  //_PREPARE_RANDOM_JOB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\stress\stressmngr\ctestmanager.h ===
#ifndef _TEST_MANAGER_H
#define _TEST_MANAGER_H

#include <autoptrs.h>
#include "CJobParams.h"
#include "CThreadAbortMng.h"
#include "CEventThread.h"
#include "TimerQueueTimer.h"

#define DEFAULT_ABORT_PERCENT        50
#define DEFAULT_ABORT_WINDOW         45
#define DEFAULT_MIN_ABORT_RATE       (20*60)
#define DEFAULT_ABORT_RATE_INTERVAL  (10*60)

class CTestManager
{
public:
	CTestManager(const tstring strServerName,
				 const DWORD dwTestTime = (30*60));
	~CTestManager();
	DWORD AddSimpleJobEx(JOB_PARAMS_EX& params);
	DWORD InitAbortThread(const DWORD dwAbortPercent, 
						  const DWORD dwAbortWindow,
						  const DWORD dwMinAbortRate,
						  const DWORD dwMaxAbortRate);
	DWORD StartEventHookThread(const DWORD dwEventPollingTime = 3*60*1000);
    DWORD CleanStorageThread(const DWORD dwPeriodMin = 30);


	BOOL TestTimePassed();
	HANDLE GetFaxHandle(){ return m_hFax;};
	HANDLE GetEvHTimePassed(){ return m_EvTestTimePassed.get();};
	
	DWORD SetServiceConfiguration(){return 0;};
	DWORD GetTestDuration(){ return m_dwTestDuration;};
	DWORD GetMinAbortSleep(){ return m_dwMinAbortSleep;};
	DWORD GetMaxAbortSleep(){ return m_dwMaxAbortSleep;};
	
	BOOL StopFaxService();
	BOOL StartFaxService();
	DWORD CancelAllFaxes();

	DWORD StopServiceQueue(){return 0;};
	DWORD ResumeServiceQueue(){return 0;};

private:
	void _HandlesCleanup();
	void _TimersCleanup();

	HANDLE m_hFax;
	HANDLE m_hTestTimer;
	HANDLE m_hCleanStorageTimer;

	Event_t m_EvTestTimePassed;
	
	tstring m_tstrServerName;

	DWORD m_dwTestDuration;
	DWORD m_dwAbortThreadId;
	DWORD m_dwMinAbortSleep;
	DWORD m_dwMaxAbortSleep;

	ARCHIVE_DIRS m_StorageFolders;

	CThreadAbortMng* m_pAbortMng;
	CEventThread*  m_pEventHook;
	
	MsgHandleRoutine m_fnHandleNotification;
};


#endif  //_TEST_MANAGER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\stress\stressmngr\cthreadabortmng.cpp ===
#include <winfax.h>
#include <testruntimeerr.h>
#include <RandomUtilities.h>

#include "CThreadAbortMng.h"
#include "Defs.h"
#include "TimerQueueTimer.h"


//
// CThreadAbortMng
// constructor
//
CThreadAbortMng::CThreadAbortMng():
	m_EventEndThread(NULL, TRUE, FALSE, TEXT("")),
	m_fStopFlag(FALSE),
	m_hTimerQueue(NULL),
	m_hFax(NULL)
{;}


//
// destructor
//
CThreadAbortMng::~CThreadAbortMng()
{
	// Thread terminated?
	if( WaitForSingleObjectEx( GetEvThreadCompleted() , 0, FALSE) != WAIT_OBJECT_0)
	{
		StopThreadMain();
		// timeout is set to (dwMaxIntervalSleep + dwMaxAbortSleep)*2
		if(WaitForSingleObjectEx(GetEvThreadCompleted(), (m_dwMaxAbortRate + m_dwAbortWindow)*2, FALSE) != WAIT_OBJECT_0)
		{
			Win32Err err(GetLastError(),__LINE__,TEXT(__FILE__),TEXT("~CThreadAbortMng, WaitForSingleObjectEx"));
			::lgLogError(LOG_SEV_2, TEXT("Exception:%s."), err.description());
		}
	}

	if( !DeleteTimerQueueEx(m_hTimerQueue,NULL))
	{
		Win32Err err(GetLastError(),__LINE__,TEXT(__FILE__),TEXT("~CThreadAbortMng, DeleteTimerQueueEx"));
		::lgLogError(LOG_SEV_2, TEXT("Exception:%s."), err.description());
	}
}


//
// Initialize
//
// set parameters and start the thread.
//
DWORD CThreadAbortMng::Initialize(const HANDLE hFax,
								  const DWORD dwAbortPercent, 
								  const DWORD dwAbortWindow,
								  const DWORD dwMinAbortRate,
								  const DWORD dwMaxAbortRate)
{
	assert(hFax);
	m_hFax = hFax;
	m_dwAbortPercent = dwAbortPercent;
	m_dwAbortWindow = dwAbortWindow ? dwAbortWindow * 1000 : 1000;
	m_dwMinAbortRate = dwMinAbortRate * 1000;
	m_dwMaxAbortRate = dwMaxAbortRate ? dwMaxAbortRate * 1000 : 1000;
	if(m_dwMinAbortRate > m_dwMaxAbortRate)
	{
		DWORD dwTedmp = m_dwMinAbortRate;
		m_dwMinAbortRate = m_dwMaxAbortRate;
		m_dwMaxAbortRate = dwTedmp;
	}
	
	m_hTimerQueue = CreateTimerQueue();
	if(!m_hTimerQueue)
	{
		return GetLastError();
	}

	return StartThread();
}

//
// ThreadMain
//
unsigned int CThreadAbortMng::ThreadMain()
{
	DWORD dwThreadMainRetVal = 0;
	try
	{
		//set random starting point
		srand(GetTickCount());
	
		// calc interval to sleep before selecting jobs to abort
		DWORD dwMiliSecsToSleep;
		DWORD dwIntervalToSleep = abs(m_dwMaxAbortRate - m_dwMinAbortRate);

		dwMiliSecsToSleep = dwIntervalToSleep ? (rand()*100) % dwIntervalToSleep :
												(rand()*100) % 1000;
	
		dwMiliSecsToSleep += m_dwMinAbortRate;
		Sleep(dwMiliSecsToSleep);

		while(!m_fStopFlag)
		{
			
			PFAX_JOB_ENTRY pJobEntry = NULL;
			DWORD* pdwSubsetArray = NULL;
			ABORT_PARAMS* pParamsArray = NULL;
			HANDLE* pAbortJobHandles = NULL;
			HANDLE hTimersCountSem = NULL;
	
			try
			{
				DWORD dwJobsReturned;// enumerate jobs
				if (!FaxEnumJobs( m_hFax, &pJobEntry, &dwJobsReturned))
				{
					THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT("CThreadAbortMng::ThreadMain, FaxEnumJobs"));
				}
				if(dwJobsReturned)
				{
					pdwSubsetArray = new DWORD[dwJobsReturned];
					if(!pdwSubsetArray)
					{
						THROW_TEST_RUN_TIME_WIN32(ERROR_OUTOFMEMORY, TEXT("CThreadAbortMng::ThreadMain, new"));
					}
					
					// select subset of jobs to abort
					DWORD dwSubsetSize = RandomSelectSubset(pdwSubsetArray, dwJobsReturned, m_dwAbortPercent);
					
					// calc interval to sleep before selecting jobs to abort
					dwMiliSecsToSleep = dwIntervalToSleep ? (rand()*100) % dwIntervalToSleep :
															(rand()*100) % 1000;
					dwMiliSecsToSleep += m_dwMinAbortRate;
					DWORD dwMiliSecsPassed = 0;

					if(dwSubsetSize)
					{
						pAbortJobHandles = new HANDLE[dwSubsetSize];
						pParamsArray = new ABORT_PARAMS[dwSubsetSize];
						if(!pAbortJobHandles || !pParamsArray)
						{
							THROW_TEST_RUN_TIME_WIN32(ERROR_OUTOFMEMORY, TEXT("CThreadAbortMng::ThreadMain, new"));
						}

						// the semaphore will signify that all the timer queue timers
						// call backs terminated execution.
						hTimersCountSem = CreateSemaphore(NULL,
														  0,
														  dwSubsetSize,
												 		  TEXT(""));

						if(!hTimersCountSem)
						{
							THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT("CThreadAbortMng::ThreadMain, CreateSemaphore"));
						}
					
						DWORD dwHandleCount = 0;
						for (DWORD dwJobIndex = 0; dwJobIndex < dwJobsReturned; dwJobIndex++)
						{
							// job was selected for abort
							if(pdwSubsetArray[dwJobIndex])
							{
								// set timer queue timer received data
								pParamsArray[dwHandleCount].dwJobId = pJobEntry[dwJobIndex].JobId;
								pParamsArray[dwHandleCount].hFax = m_hFax;
								pParamsArray[dwHandleCount].hSemaphore = hTimersCountSem;

								// calc sleep before abort
								DWORD dwAbortDueTime = (rand()*100) % m_dwAbortWindow;
																
								if(!CreateTimerQueueTimer( &pAbortJobHandles[dwHandleCount],
														   m_hTimerQueue,
														   ThreadAbortJob,
														   &pParamsArray[dwHandleCount],
														   dwAbortDueTime,
														   0,
														   0))
								{
									Win32Err err(GetLastError(),__LINE__,TEXT(__FILE__),TEXT("CThreadAbortMng, CreateTimerQueueTimer"));
									::lgLogError(LOG_SEV_1, TEXT("Exception:%s."), err.description());
									continue;
								}

								// counting only successfully created timers.
								dwHandleCount++;
							}
						
						}
					 
						SYSTEMTIME tmBeforeSemSignaled;
						GetSystemTime(&tmBeforeSemSignaled);
   
						// wait for timer queue timers call back termination
						for(DWORD index = 0; index < dwHandleCount; index++)
						{
							if(WaitForSingleObject(hTimersCountSem, m_dwAbortWindow*3) == WAIT_FAILED)
							{
								Win32Err err(GetLastError(),__LINE__,TEXT(__FILE__),TEXT("CThreadAbortMng, FaxClose"));
								::lgLogError(LOG_SEV_1, TEXT("Exception:%s."), err.description());
								break;
							}
						}

						// delete the timers from queue.
						for(index = 0; index < dwHandleCount; index++)
						{
							if(!DeleteTimerQueueTimer(m_hTimerQueue, pAbortJobHandles[index],NULL))
							{
								Win32Err err(GetLastError(),__LINE__,TEXT(__FILE__),TEXT("CThreadAbortMng, DeleteTimerQueueTimer"));
								::lgLogError(LOG_SEV_1, TEXT("Exception:%s."), err.description());
							}
						}

						SYSTEMTIME tmAfterSemSignaled;
						GetSystemTime(&tmAfterSemSignaled);
						// we take into consider the time we spent waiting for semaphore to be signaled
						// (abort operations terminated).
						dwMiliSecsPassed = tmAfterSemSignaled.wMilliseconds - tmAfterSemSignaled.wMilliseconds;
					}

					dwMiliSecsToSleep -= (dwMiliSecsPassed < dwMiliSecsToSleep) ? dwMiliSecsPassed : 0;
					Sleep(dwMiliSecsToSleep);

				}
			}
			catch(Win32Err& err)
			{
				::lgLogError(LOG_SEV_1, TEXT("Exception:%s."), err.description());
			}

			// cleanup
			FaxFreeBuffer(pJobEntry);
			delete pdwSubsetArray;
			delete pParamsArray;
			delete pAbortJobHandles;
			if(hTimersCountSem)
			{
				CloseHandle(hTimersCountSem);
			}
		}
		
	}
	catch(Win32Err& err)
	{
		::lgLogError(LOG_SEV_1, TEXT("Exception:%s."), err.what());
		dwThreadMainRetVal = err.error();
	}

	
	// signal thread has terminated.
	verify(SetEvent(m_EventEndThread.get()));
	::lgLogDetail(LOG_X, 3, TEXT("Terminated CThreadAbortMng"));
	return dwThreadMainRetVal; 
}


//
// set stop condition
//
void CThreadAbortMng::StopThreadMain()
{
	m_fStopFlag = TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\stress\stressmngr\regutilities.cpp ===
#ifndef _REG_UTILITIES_H
#define _REG_UTILITIES_H

//
// Registry Utilities:
// - Key definitions
// - Retrieve an archive folder relative path.
// - Convert a relative comet path to an absolute comet path.
// - Get registry key of the local machine in th comet array.

#include <windows.h>
#include <tstring.h>
#include <assert.h>

// Registry keys definitions
//
#define REGKEY_COMET_ROOT	             TEXT("Software\\Microsoft\\Comet")
#define REGVAL_COMETPATH                 TEXT("CometPath")
#define FAX_ARRAYS_REGKEY                TEXT("Software\\Microsoft\\Comet\\Arrays")
#define FAX_SENT_ARCHIVE_POLICY          TEXT("Fax-Application\\Fax-SentArchive\\Fax-ArchivePolicy")
#define FAX_RECEIVED_ARCHIVE_POLICY      TEXT("Fax-Application\\Fax-ReceivedArchive\\Fax-ArchivePolicy")
#define COMET_FOLDER_STR                 TEXT("msCometFolderName")
#define COMET_SERVER_STR                 TEXT("msCometName")

#define SENT_ARCIVE      1
#define RECEIVED_ARCIVE  2

// Declarations
//
DWORD GetCometRelativePath (const tstring& tstrInitialPath,
							tstring& tstrFinalPath);
HRESULT FindServerArrayEntry(HKEY& hServerArrayKey);
DWORD GetArchiveFolderName(const BYTE bArchiveType,
			 			   const HKEY hServerArrayKey, 
						   tstring& tstrArchiveFolder );


// GetArchiveFolderName
//
// retrieves the fax archive path form registry
//
// [in] bArchiveType - which archive diregtory to look for
// [in] hServerArrayKey - opened registry key of the server entry 
// [out] tstrArchiveFolder - the archive folder path.
// 
//	returns win32 error. 0 for success.
//
inline DWORD GetArchiveFolderName(const BYTE bArchiveType,
								  const HKEY hServerArrayKey, 
								  tstring& tstrArchiveFolder )
{

	HKEY hArchivePolicyKey = NULL;
	BYTE* szFolderName = NULL;
	TCHAR* tstrArchiveSubKey = TEXT("");  

	assert(hServerArrayKey);
	tstrArchiveFolder = tstring(TEXT(""));

	switch(bArchiveType)
	{
	case SENT_ARCIVE:
		tstrArchiveSubKey = FAX_SENT_ARCHIVE_POLICY;
		break;
	case RECEIVED_ARCIVE:
		tstrArchiveSubKey = FAX_RECEIVED_ARCHIVE_POLICY;
		break;
	default:
		return ERROR_INVALID_PARAMETER;
	}

	// Open the archive policy registry key
	DWORD dwRetVal = RegOpenKeyEx( hServerArrayKey, 
								   tstrArchiveSubKey, 
								   0, 
							       KEY_ALL_ACCESS, 
							       &hArchivePolicyKey
							       );
	if (ERROR_SUCCESS != dwRetVal)
	{
		RegCloseKey(hArchivePolicyKey);
		return dwRetVal;
	}

	// query folder name value
	DWORD dwBufferSize = 0;
	DWORD dwType = 0;
	dwRetVal =  RegQueryValueEx( hArchivePolicyKey,
								 COMET_FOLDER_STR,
								 NULL,
								 &dwType,
								 NULL,  
								 &dwBufferSize);

	if(ERROR_SUCCESS != dwRetVal)
	{
		RegCloseKey(hArchivePolicyKey);
		return dwRetVal;
	}

	// alocate folder name buffer
	szFolderName = new BYTE[dwBufferSize + 1];
	if(!szFolderName)
	{
		RegCloseKey(hArchivePolicyKey);
		return ERROR_OUTOFMEMORY;
	}

	// query folder name value
	dwRetVal =  RegQueryValueEx( hArchivePolicyKey,
								 COMET_FOLDER_STR,
								 NULL,
								 &dwType,
								 szFolderName,  
								 &dwBufferSize);
	if (ERROR_SUCCESS != dwRetVal)
	{
		delete(szFolderName);
		RegCloseKey(hArchivePolicyKey);
		return dwRetVal;
	}

	tstrArchiveFolder = (TCHAR*)szFolderName; // copy constructor

	delete(szFolderName);
	szFolderName = NULL;
	
	return ERROR_SUCCESS;
}


// GetCometRelativePath

// Given a path string checks to see if this is a relative path.
// If so, it returns a string containing the Comet installation
// directory appended with that path.
// If the input path is absolute (either begins with '\' or with 'x:\')
// it returns it as is.
//
// [in]  tstrInitialPath - given paht.
// [out] tstrFinalPath - returned absolute path.
// returns win32 error. 0 for success.
//
inline DWORD GetCometRelativePath (const tstring& tstrInitialPath,
								   tstring& tstrFinalPath)

{

    DWORD dwInitialPathLen = tstrInitialPath.size();

    if ( ( (0 < dwInitialPathLen) && ('\\' == tstrInitialPath.c_str()[0]) ) || // UNC or absolute path or
         ( (dwInitialPathLen >= 3) &&
           _istalpha (tstrInitialPath.c_str()[0]) &&
           (':' == tstrInitialPath.c_str()[1])   &&
           ('\\' == tstrInitialPath.c_str()[2])) // in mask 'x:\'
       )
    {
        // Abosulte path found
        //
        tstrFinalPath = tstrInitialPath;
        return 0;
    }
	
	// This is a relative path. Make it relative to Comet installation path
    //
    HKEY hKey;
    TCHAR tszCometPath [MAX_PATH];

    DWORD dwRet = RegOpenKey (HKEY_LOCAL_MACHINE,
                              REGKEY_COMET_ROOT,
                              &hKey);
    if (ERROR_SUCCESS != dwRet)
    {
        return dwRet;
    }
    
	DWORD dwType;
    DWORD dwDataSize = MAX_PATH;
    dwRet = RegQueryValueEx (hKey,
                             REGVAL_COMETPATH,
                             NULL,
                             &dwType,
                             (LPBYTE)tszCometPath,
                             &dwDataSize);
    if (ERROR_SUCCESS != dwRet)
    {
        RegCloseKey (hKey);
        return dwRet;
    }
    
	RegCloseKey (hKey);
    
	//
    // Create a return buffer to hold tszCometPath + '\' + tstrInitialPath + NULL
    //
    tstrFinalPath = tszCometPath;
    tstrFinalPath += TEXT("\\");
    tstrFinalPath += tstrInitialPath;
    return ERROR_SUCCESS;
}  



// FindServerArrayEntry()
//
// search in the comet storage registry and returns the
// array key with server name identical to local machine name.
//
// [out] hServerArrayKey - is NULL if no such key was found, 
//						   and a valid registry key if found.
// returned value - 0 for success.
//
// TODO: It is more elegant to search the array by a given input
// server name. But fax is out of comet and this function will probably 
// become obsolete.
//
inline HRESULT FindServerArrayEntry(HKEY& hServerArrayKey)
{
	HRESULT hRetVal = E_UNEXPECTED;
 	LONG lRet = E_UNEXPECTED;
    
	HKEY hArraysKey = NULL;
	TCHAR* tstrSubKeyName = NULL;
	BYTE* tstrCometServerName = NULL;
	DWORD dwMaxSubKeyLen = 0;
	DWORD dwSubKeysNum = 0;
	int index;
	DWORD dwComputerNameLenth = 0;
	
	// initialize 
	hServerArrayKey = NULL;

	// open comet storage arrays key
	lRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE, 
						 FAX_ARRAYS_REGKEY, 
						 0, 
						 KEY_ALL_ACCESS, 
						 &hArraysKey);
   
	if (ERROR_SUCCESS != lRet)
    {
	    goto ExitFunc;
    }
	
	// find arrays number and the maximum lenth of array name
	lRet = RegQueryInfoKey( hArraysKey, 
							NULL, 
							NULL, 
							NULL,
							&dwSubKeysNum,     
							&dwMaxSubKeyLen, 
							NULL,
							NULL, 
							NULL, 
							NULL,  
							NULL,
							NULL );
 
	if (ERROR_SUCCESS != lRet)
    {
	    goto ExitFunc;
    }

	// allocate buffer for array key name
	tstrSubKeyName = new TCHAR[dwMaxSubKeyLen + 1];
	if(!tstrSubKeyName)
	{
		goto ExitFunc;
	}

	// get local server name
	TCHAR strLocalServerName[MAX_COMPUTERNAME_LENGTH + 1 ];
	dwComputerNameLenth = MAX_COMPUTERNAME_LENGTH;
	if(!GetComputerName(strLocalServerName, &dwComputerNameLenth))
	{
		 goto ExitFunc;
	}

	// walk on arrays key entries
	for( index = 0; index < dwSubKeysNum; index++)
	{
		// get array name
		lRet = RegEnumKey( hArraysKey, 
						   index,  
						   tstrSubKeyName,    
						   dwMaxSubKeyLen + 1);
	
		if (ERROR_SUCCESS != lRet)
		{
			goto ExitFunc;
		}

		// open array key
		lRet = RegOpenKeyEx( hArraysKey, 
							 tstrSubKeyName, 
							 0, 
							 KEY_ALL_ACCESS, 
							 &hServerArrayKey);
		
		if (ERROR_SUCCESS != lRet)
		{
			goto ExitFunc;
		}

		// query server name value
		DWORD dwBufferSize = 0;
		DWORD dwType;
		lRet =  RegQueryValueEx( hServerArrayKey,
								 COMET_SERVER_STR,
								 NULL,
								 &dwType,
								 NULL,  
								 &dwBufferSize);
 
		if(ERROR_SUCCESS != lRet)
		{
			// Value name may not exist(?) so go over the rest of the keys 
			lRet = RegCloseKey(hServerArrayKey);
			hServerArrayKey = NULL;
			if (ERROR_SUCCESS != lRet)
			{
				goto ExitFunc;
			}
			continue;
		}

		// alocate server name buffer
		tstrCometServerName = new BYTE[dwBufferSize + 1];
		if(!tstrCometServerName)
		{
			lRet = RegCloseKey(hServerArrayKey);
			hServerArrayKey = NULL;
			if (ERROR_SUCCESS != lRet)
			{
			}
			goto ExitFunc;
		}

		// query server name value
		lRet =  RegQueryValueEx( hServerArrayKey,
								 COMET_SERVER_STR,
								 NULL,
								 &dwType,
								 tstrCometServerName,  
								 &dwBufferSize);

		if (ERROR_SUCCESS != lRet)
		{
			lRet = RegCloseKey(hServerArrayKey);
			hServerArrayKey = NULL;
			if (ERROR_SUCCESS != lRet)
			{
			}
			goto ExitFunc;
		}

		// found it
		if(!_tcscmp((TCHAR*)tstrCometServerName, strLocalServerName))
		{
			break;
		}

		// cleanup
		lRet = RegCloseKey(hServerArrayKey);
		hServerArrayKey = NULL;
		if (ERROR_SUCCESS != lRet)
		{
			//TODO: ?
		}
		delete tstrCometServerName;
		tstrCometServerName = NULL;
	}
	hRetVal = S_OK;

ExitFunc:
	delete tstrCometServerName;
	delete tstrSubKeyName;
	lRet = RegCloseKey(hArraysKey);
    if (ERROR_SUCCESS != lRet)
    {
		RegCloseKey(hServerArrayKey);
		hServerArrayKey = NULL;
	    hRetVal = E_UNEXPECTED;
    }
   
    return hRetVal;
}

#endif //_REG_UTILITIES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\stress\stressmngr\timerqueuetimer.h ===
#ifndef _TIMER_QUEUE_TIMER_H
#define _TIMER_QUEUE_TIMER_H

// data structures to pass to timer queue timer call back
//
typedef struct ABORT_PARAMS_p
{
	DWORD dwJobId;
	HANDLE hFax;
	HANDLE hSemaphore;

}ABORT_PARAMS;

typedef struct ARCHIVE_DIRS_p
{
	tstring tstrSentArchive;
	tstring tstrReceivedArchive;

}ARCHIVE_DIRS;

// Declarations
//
VOID WINAPI ThreadAbortJob( PVOID lpParameter, unsigned char TimerOrWaitFired);
VOID WINAPI ThreadPauseJob( PVOID lpParameter, unsigned char TimerOrWaitFired);
VOID WINAPI CleanStorageCallBack( PVOID lpParameter, unsigned char TimerOrWaitFired);
VOID WINAPI ThreadTimerCallBack( PVOID lpParameter, unsigned char TimerOrWaitFired);


//
// CleanStorageCallBack
//
// Timer queue timer call back
//
inline VOID WINAPI CleanStorageCallBack( PVOID lpParameter, unsigned char TimerOrWaitFired)
{

	assert(lpParameter);
	ARCHIVE_DIRS* pStorageFolders = (ARCHIVE_DIRS*)lpParameter;
	if(pStorageFolders->tstrSentArchive != tstring(TEXT("")))
	{
		lgLogDetail(LOG_X, 0, TEXT("Deleting files in Sent Archive Folder %s"),
									pStorageFolders->tstrSentArchive.c_str());
	
		tstring tstrCommandLine = TEXT("del /Q \"");
		tstrCommandLine += pStorageFolders->tstrSentArchive;
		tstrCommandLine += TEXT("\\*.*\"");
		_tsystem(tstrCommandLine.c_str());
	}

	if(pStorageFolders->tstrReceivedArchive != TEXT(""))
	{
		lgLogDetail(LOG_X, 0, TEXT("Deleting files in Received Archive Folder %s"),
								    pStorageFolders->tstrReceivedArchive.c_str());
	
		tstring tstrCommandLine = TEXT("del /Q \"");
		tstrCommandLine += pStorageFolders->tstrReceivedArchive;
		tstrCommandLine += TEXT("\\*.*\"");
		_tsystem(tstrCommandLine.c_str());
	}

}

//
// ThreadTimerCallBack
//
// Timer queue timer call back
//
inline VOID WINAPI TestTimerCallBack( PVOID lpParameter, unsigned char TimerOrWaitFired)
{
	assert(lpParameter);
	HANDLE hEvToSignal = (HANDLE)lpParameter;
	verify(SetEvent(hEvToSignal));
}


//
// ThreadAbortJob
//
// Timer queue timer call back
//
inline VOID WINAPI ThreadAbortJob( PVOID lpParameter, unsigned char TimerOrWaitFired)
{
	assert(lpParameter);
	ABORT_PARAMS* AbortParams = (ABORT_PARAMS*)lpParameter;
	
	// Abort the job
	if (!FaxAbort(AbortParams->hFax, AbortParams->dwJobId))
	{
		lgLogDetail(LOG_X, 0, TEXT("job %d, FaxAbort() failed with %d"),AbortParams->dwJobId,GetLastError());
	}

	if(!ReleaseSemaphore(AbortParams->hSemaphore, 1, NULL))
	{
		lgLogDetail(LOG_X, 0, TEXT("ReleaseSemaphore() failed with %d"),GetLastError());
	}
}

//
// ThreadPauseJob
//
// Timer queue timer call back
//
// TODO: has not been tested. possibly changes in api call FaxSetJob
inline VOID WINAPI ThreadPauseJob( PVOID lpParameter, unsigned char TimerOrWaitFired)
{
	assert(lpParameter);
	ABORT_PARAMS* AbortParams = (ABORT_PARAMS*)lpParameter;
	
	// Pause the Job
	if (!FaxSetJob(AbortParams->hFax, AbortParams->dwJobId, JC_PAUSE, NULL))
	{
		lgLogDetail(LOG_X, 0, TEXT("job %d, Pause job failed with  %s"),AbortParams->dwJobId,GetLastError());
	}

	if(!ReleaseSemaphore(AbortParams->hSemaphore, 1, NULL))
	{
		lgLogDetail(LOG_X, 0, TEXT("ReleaseSemaphore() failed with %d"),GetLastError());
	}
}

#endif //_TIMER_QUEUE_TIMER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\tapitools\isfaxcapable\passthroughutil\passthroughutil.h ===
#ifndef __PASSTHROUGHUTIL_H__
#define __PASSTHROUGHUTIL_H__
#include <Windows.h>

void WINAPI GetSupportedFClass(DWORD dwDeviceId, LPSTR pszString, LONG cSize);


#endif //__PASSTHROUGHUTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\stress\stressmngr\tests\main.cpp ===
#pragma warning(disable :4786)

// standard
#include <iostream>
#include <string>
#include <vector>

// utilities
#include <testruntimeerr.h>
#include <params.h>
#include <DirectoryUtilities.h>
#include <log\log.h>

// project specific
#include "..\CTestManager.h"
#include "..\PrepareRandomJob.cpp"

using namespace std;


// Definitions
//
#define MIN_SLEEP_BETWEEN_SEND (3*30)
#define MAX_SLEEP_BETWEEN_SEND (5*30)
#define CLEAN_STORAGE_RATE  (20)

void main(int argc,char** argv)
{
	CInput input(GetCommandLine());
	tstring tstrServerName;
	DWORD dwTestDuration = 0;
	BOOL fAbort = FALSE;
	BOOL fMustSecceed = FALSE;
	BOOL fOnServerMachine = TRUE;
	std::vector<tstring> FaxFileVector;
	std::vector<tstring> CoverPageVector;
	std::vector<tstring> RecipientNumbersList;
	DWORD dwMinMiliSecSleep = MIN_SLEEP_BETWEEN_SEND * 1000;
	DWORD dwMaxMiliSecSleep = MAX_SLEEP_BETWEEN_SEND * 1000;
	
	::lgInitializeLogger();
	::lgBeginSuite(TEXT("Stress"));
	::lgBeginCase(0, TEXT("0"));
	
	// We want exception to be printed before the very long destructor process of this object. 
	CTestManager* pTest = NULL;	

	try
	{
		if(input.IsExists(TEXT("d")))
		{
			tstring tstrDocumentPath = input[TEXT("d")];
 			FaxFileVector = GetDirectoryFileNames(tstrDocumentPath);
		}
		else
		{
			std::cout << "StressMng Usage:\n" <<
						 "/d:[Fax File Path or Fax Documents Repository Directory] mandatory parameter \n" <<
						 "/s:[Server Name] by default server is the local machine\n" <<
						 "/p:[Cover Page Path or CP Repository Directory] optional parameter \n"<<
						 "/t:[Minutes to execute test] by default will run \"forever\" \n" <<
						 "/Abort - will run the aborting thread. by default no client aborts during execution\n" <<
						 "/Success - all jobs in session must succeed. by default they may fail.\n\n" <<
						 "Note: spaces in path are allowed do not use the \" char \n";
			
			THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT(" Main, bad application usage"));
		}

		if(input.IsExists(TEXT("s")))
		{
			fOnServerMachine = FALSE;
			tstrServerName = input[TEXT("s")];
		}

		if(input.IsExists(TEXT("p")))
		{
			tstring tstrCoverPagePath = input[TEXT("p")];
			CoverPageVector = GetDirectoryFileNames(tstrCoverPagePath);
		}
		if(input.IsExists(TEXT("t")))
		{
			dwTestDuration = input.GetNumber(TEXT("t"));
		}

		if(input.IsExists(TEXT("Abort")))
		{
			fAbort = TRUE;
		}
		if(input.IsExists(TEXT("Success")))
		{
			fMustSecceed = TRUE;
		}

		//PrepareRandomJob( in the context of current thread
		srand(GetTickCount());

		DWORD x_ComputerNameLenth = MAX_COMPUTERNAME_LENGTH;
			
		// if server name wasn't specified, use local machine name as the server.
		if(tstrServerName == TEXT(""))
		{
			TCHAR buffServerName[MAX_COMPUTERNAME_LENGTH + 1 ];
			if(!GetComputerName(buffServerName, &x_ComputerNameLenth))
			{
				THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT(" GetComputerName"));
			}
			
			tstrServerName = buffServerName;
		}
	
		// initialize test manager
		pTest = new CTestManager(tstrServerName, dwTestDuration * 60);
		
		if(!pTest)
		{
			THROW_TEST_RUN_TIME_WIN32( ERROR_OUTOFMEMORY, TEXT(" Main, new CTestManager"));
		}
		
		// the test on server machine
		if(fOnServerMachine)
		{
			if(pTest->CleanStorageThread(CLEAN_STORAGE_RATE))
			{
				THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT(" Test.InitAbortThread"));
			}
		}

		// start send abort operations thread
		if(fAbort)
		{
			if(pTest->InitAbortThread(0,0,0,0))
			{
				THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT(" Test.InitAbortThread"));
			}
		}

		// track server notifications and alert on failures
		if(fMustSecceed)
		{
			if(pTest->StartEventHookThread())
			{
				THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT(" Test.StartEventHookThread()"));
			}
		}

		DWORD dwJobNumber = 0;
		tstring tstrTestPref(TEXT(" StressTest"));

		// loop for test.
		while(!pTest->TestTimePassed())
		{
			JOB_PARAMS_EX pJparams;
		
			// Prepare job name
			++dwJobNumber;
			otstringstream otstrTestNum;
			otstrTestNum << dwJobNumber;
			tstring tstrTestName = tstrTestPref + otstrTestNum.str();
			
			PrepareRandomJob(pJparams,
							 FaxFileVector,
							 tstrTestName.c_str(),
							 CoverPageVector,
 							 RecipientNumbersList);
			
			DWORD dwAddRetVal;
			if(dwAddRetVal = pTest->AddSimpleJobEx(pJparams))
			{
				THROW_TEST_RUN_TIME_WIN32(dwAddRetVal, TEXT(" AddSimpleJobEx"));
			}

			DWORD dwMiliSecondsToSleep = (rand()*100) % abs(dwMaxMiliSecSleep - dwMinMiliSecSleep);
			dwMiliSecondsToSleep += dwMinMiliSecSleep;
			Sleep(dwMiliSecondsToSleep);
		
		}
		
	}
	catch(Win32Err& err)
	{
		::lgLogError(LOG_SEV_1, TEXT("Exception:%s."), err.Desc());
	}

  	::lgEndCase();
	::lgEndSuite();
	::lgCloseLogger();  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\stress\stressmngr\tests\inibasedstress.cpp ===
#pragma warning(disable :4786)

// standard
#include <iostream>
#include <vector>
#include <map>

// utilities
#include <testruntimeerr.h>
#include <params.h>
#include <iniutils.h>
#include <DirectoryUtilities.h>
#include <log\log.h>

// project specific
#include "..\CTestManager.h"
#include "..\PrepareRandomJob.cpp"


using namespace std;

// Definitions
//
#define MIN_SLEEP_BETWEEN_SEND (3*30)
#define MAX_SLEEP_BETWEEN_SEND (5*30)
#define CLEAN_STORAGE_RATE  (20)

#define GENERAL_PARAMS       TEXT("General")

// Declarations
//
static std::map<tstring, tstring> ProcessIniFile(const tstring tstrIniFile,
												tstring& tstrServerName,
											    std::vector<tstring>& FaxFileVector,
												std::vector<tstring>& CoverPageVector,
											    std::vector<tstring>& RecipientNumbersList,
											    DWORD& dwMinMiliSecSleep, 
											    DWORD& dwMaxMiliSecSleep,
											    BOOL& fAbort,
											    BOOL& fMustSecceed,
											    BOOL& fOnServerMachine);

static void MapAbortParameters(const std::map<tstring, tstring>& SectionEntriesMap,
							   DWORD& dwMinAbortRate,
							   DWORD& dwMaxAbortRate,
							   DWORD& dwAbortWindow,
							   DWORD& dwAbortPercent);

void main(int argc,char** argv)
{

	tstring tstrIniFile;
	tstring tstrServerName;
	BOOL fAbort = FALSE;
	BOOL fMustSecceed = FALSE;
	BOOL fOnServerMachine = TRUE;
	std::vector<tstring> FaxFileVector;
	std::vector<tstring> CoverPageVector;
	std::vector<tstring> RecipientNumbersList;
	DWORD dwMinMiliSecSleep = MIN_SLEEP_BETWEEN_SEND * 1000;
	DWORD dwMaxMiliSecSleep = MAX_SLEEP_BETWEEN_SEND * 1000;
	DWORD dwTestDuration = 0;
	
	CInput input(GetCommandLine());
	if( input.IsExists(TEXT("f")) && ( input[TEXT("f")] != tstring(TEXT(""))))
	{
		tstrIniFile = input[TEXT("f")];
	}
	else
	{
		std::cout << "IniBasedStress Usage:\n" <<
					 "/f:[ini file full(!) path] spaces in path are allowed do not use the \" char \n"
				  << "/t:[Minutes to execute test] by default will run \"forever\" \n";	
		exit(0);
	}

	::lgInitializeLogger();
	::lgBeginSuite(TEXT("Stress"));
	::lgBeginCase(0, TEXT("0"));
	
	// We want exception to be printed before the very long destructor process of this object. 
	CTestManager* pTest = NULL;	
	try
	{

		std::map<tstring, tstring> SectionEntriesMap = ProcessIniFile(tstrIniFile, 
																	  tstrServerName,
																	  FaxFileVector,
																	  CoverPageVector,
																	  RecipientNumbersList,
																	  dwMinMiliSecSleep, dwMaxMiliSecSleep,
																	  fAbort, fMustSecceed, fOnServerMachine);

		if(input.IsExists(TEXT("t")))
		{
			dwTestDuration = input.GetNumber(TEXT("t"));
		}
	

		//PrepareRandomJob, in the context of current thread
		srand(GetTickCount());

		DWORD x_ComputerNameLenth = MAX_COMPUTERNAME_LENGTH;
			
		// if server name wasn't specified, use local machine name as the server.
		if(tstrServerName == TEXT(""))
		{
			TCHAR buffServerName[MAX_COMPUTERNAME_LENGTH + 1 ];
			if(!GetComputerName(buffServerName, &x_ComputerNameLenth))
			{
				THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT(" GetComputerName"));
			}
			
			tstrServerName = buffServerName;
		}
	
		// initialize test manager
		pTest = new CTestManager(tstrServerName, dwTestDuration * 60);
		
		if(!pTest)
		{
			THROW_TEST_RUN_TIME_WIN32( ERROR_OUTOFMEMORY, TEXT(" Main, new CTestManager"));
		}

		// the test on server machine
		if(fOnServerMachine)
		{
			if(pTest->CleanStorageThread(CLEAN_STORAGE_RATE))
			{
				THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT(" Test.InitAbortThread"));
			}
		}

		// start send abort operations thread
		if(fAbort)
		{
	
			DWORD dwMinAbortRate, dwMaxAbortRate, dwAbortWindow, dwAbortPercent;
			dwMinAbortRate = dwMaxAbortRate = dwAbortWindow = dwAbortPercent = 0;

			MapAbortParameters(SectionEntriesMap,
							   dwMinAbortRate, dwMaxAbortRate, dwAbortWindow, dwAbortPercent);
		
			if(pTest->InitAbortThread(dwAbortPercent, dwAbortWindow, dwMinAbortRate, dwMaxAbortRate))
			{
				THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT(" Test.InitAbortThread"));
			}
		}

		// track server notifications and alert on failures
		if(fMustSecceed)
		{
			if(pTest->StartEventHookThread())
			{
				THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT(" Test.StartEventHookThread()"));
			}
		}

		DWORD dwJobNumber = 0;
		tstring tstrTestPref(TEXT(" StressTest"));

		// loop for test.
		while(!pTest->TestTimePassed())
		{
			JOB_PARAMS_EX pJparams;
		
			// Prepare job name
			++dwJobNumber;
			otstringstream otstrTestNum;
			otstrTestNum << dwJobNumber;
			tstring tstrTestName = tstrTestPref + otstrTestNum.str();
			
			PrepareRandomJob(pJparams,
							 FaxFileVector,
							 tstrTestName.c_str(),
							 CoverPageVector,
 							 RecipientNumbersList);
			
			DWORD dwAddRetVal;
			if(dwAddRetVal = pTest->AddSimpleJobEx(pJparams))
			{
				THROW_TEST_RUN_TIME_WIN32(dwAddRetVal, TEXT(" AddSimpleJobEx"));
			}

			DWORD dwMiliSecondsToSleep = (rand()*100) % abs(dwMaxMiliSecSleep - dwMinMiliSecSleep);
			dwMiliSecondsToSleep += dwMinMiliSecSleep;
			Sleep(dwMiliSecondsToSleep);
		
		}
		
	}
	catch(Win32Err& err)
	{
		::lgLogError(LOG_SEV_1, TEXT("Exception:%s."), err.description());
	}

  	::lgEndCase();
	::lgEndSuite();
	::lgCloseLogger();  
}



//
// ProcessIniFile
//
static std::map<tstring, tstring> ProcessIniFile(const tstring tstrIniFile,
												tstring& tstrServerName,
											    std::vector<tstring>& FaxFileVector,
												std::vector<tstring>& CoverPageVector,
											    std::vector<tstring>& RecipientNumbersList,
											    DWORD& dwMinMiliSecSleep, 
											    DWORD& dwMaxMiliSecSleep,
											    BOOL& fAbort,
											    BOOL& fMustSecceed,
											    BOOL& fOnServerMachine)
{
	// ---------------------------
	// Get General section entries
	// ---------------------------

	std::map<tstring, tstring> SectionEntriesMap = INI_GetSectionEntries(tstrIniFile, GENERAL_PARAMS);
	std::map<tstring, tstring>::iterator iterMap;

	if(SectionEntriesMap.empty())
	{
		::lgLogDetail(LOG_X, 0, TEXT("Ini file does not exist or no General section"));
		THROW_TEST_RUN_TIME_WIN32(E_FAIL, TEXT("Main"));
	}

	// Get server name
	iterMap = SectionEntriesMap.find( TEXT("Server"));
	if( (iterMap != SectionEntriesMap.end()) && (((*iterMap).second) != tstring(TEXT(""))))
	{ 
		fOnServerMachine = FALSE;
		tstrServerName = (*iterMap).second;
		assert( tstrServerName != tstring(TEXT("")));
	}
	// Server is local machine
	else
	{
		DWORD x_ComputerNameLenth;
		if(tstrServerName == TEXT(""))
		{
			TCHAR buffServerName[MAX_COMPUTERNAME_LENGTH + 1 ];
			if(!GetComputerName(buffServerName, &x_ComputerNameLenth))
			{
				THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT("Main, GetComputerName"));
			}
			tstrServerName = buffServerName;
		}
	}

	iterMap = SectionEntriesMap.find( TEXT("Fax Document"));
	if( (iterMap != SectionEntriesMap.end()) && (((*iterMap).second) != tstring(TEXT(""))))
	{ 
		tstring& tstrDocumentPath = (*iterMap).second;
		assert( tstrDocumentPath != tstring(TEXT("")));
		FaxFileVector = GetDirectoryFileNames(tstrDocumentPath);
	}
	else
	{
		::lgLogDetail(LOG_X, 0, TEXT("%s section must specify the Fax Document entry"),
									  GENERAL_PARAMS);
		THROW_TEST_RUN_TIME_WIN32( E_FAIL, TEXT(" Main"));
	}
	

	iterMap = SectionEntriesMap.find( TEXT("Cover Page"));
	if( (iterMap != SectionEntriesMap.end()) && (((*iterMap).second) != tstring(TEXT(""))))
	{ 
		tstring& tstrCoverPagePath = (*iterMap).second;
		assert( tstrCoverPagePath != tstring(TEXT("")));
		CoverPageVector = GetDirectoryFileNames(tstrCoverPagePath);
	}
	
	iterMap = SectionEntriesMap.find( TEXT("Abort"));
	if( (iterMap != SectionEntriesMap.end()) && (((*iterMap).second) != tstring(TEXT(""))))
	{ 
		fAbort = ( (*iterMap).second == tstring(TEXT("Yes"))) ? TRUE : FALSE;
	}

	iterMap = SectionEntriesMap.find( TEXT("Success"));
	if( (iterMap != SectionEntriesMap.end()) && (((*iterMap).second) != tstring(TEXT(""))))
	{ 
		fMustSecceed = ( (*iterMap).second == tstring(TEXT("Yes"))) ? TRUE : FALSE;
	}
	
	iterMap = SectionEntriesMap.find( TEXT("MinSendRate(sec)"));
	if( (iterMap != SectionEntriesMap.end()) && (((*iterMap).second) != tstring(TEXT(""))))
	{ 
		dwMinMiliSecSleep = (_tcstol( ((*iterMap).second.c_str()), NULL, 10)) * 1000;
	}

	iterMap = SectionEntriesMap.find( TEXT("MaxSendRate(sec)"));
	if( (iterMap != SectionEntriesMap.end()) && (((*iterMap).second) != tstring(TEXT(""))))
	{ 
		dwMaxMiliSecSleep = (_tcstol( ((*iterMap).second.c_str()), NULL, 10)) * 1000;
	}
	
	iterMap = SectionEntriesMap.find( TEXT("Recipient List"));
	if( (iterMap != SectionEntriesMap.end()) && (((*iterMap).second) != tstring(TEXT(""))))
	{ 
		RecipientNumbersList = INI_GetSectionList( tstrIniFile, (*iterMap).second);
	}

	return SectionEntriesMap;
}


//
// MapAbortParameters
//
static void MapAbortParameters(const std::map<tstring, tstring>& SectionEntriesMap,
							   DWORD& dwMinAbortRate,
							   DWORD& dwMaxAbortRate,
							   DWORD& dwAbortWindow,
							   DWORD& dwAbortPercent)
{
	std::map<tstring, tstring>::const_iterator iterMap;

	iterMap = SectionEntriesMap.find( TEXT("MinAbortRate(min)"));
	if( (iterMap != SectionEntriesMap.end()) && (((*iterMap).second) != tstring(TEXT(""))))
	{ 
		dwMinAbortRate = (_tcstol( ((*iterMap).second.c_str()), NULL, 10));
	}

	iterMap = SectionEntriesMap.find( TEXT("MaxAbortRate(min)"));
	if( (iterMap != SectionEntriesMap.end()) && (((*iterMap).second) != tstring(TEXT(""))))
	{ 
		dwMaxAbortRate = (_tcstol( ((*iterMap).second.c_str()), NULL, 10));
	}

	iterMap = SectionEntriesMap.find( TEXT("AbortWindow(sec)"));
	if( (iterMap != SectionEntriesMap.end()) && (((*iterMap).second) != tstring(TEXT(""))))
	{ 
		dwAbortWindow = (_tcstol( ((*iterMap).second.c_str()), NULL, 10));
	}

	iterMap = SectionEntriesMap.find( TEXT("AbortPercent(%)"));
	if( (iterMap != SectionEntriesMap.end()) && (((*iterMap).second) != tstring(TEXT(""))))
	{ 
		dwAbortPercent = (_tcstol( ((*iterMap).second.c_str()), NULL, 10));
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\tapitools\isfaxcapable\passthroughutil\main.cpp ===
#include "Tapi3Device.h"
#include "PassThroughUtil.h"

void WINAPI GetSupportedFClass(DWORD dwDeviceId, LPSTR pszString, LONG cSize)
{
	
	try
	{
		char szSupportedClass[100];

		HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
		if (FAILED(hr))
		{
			//
			//check which error we failed on
			//
			if (0x80010106 == hr)
			{
				//
				//error 0x80010106, means: Cannot change thread mode after it is set. 
				// This means that CoInit was already called, continue
				// continue
				//
			}
			else
			{
				throw CException(TEXT("CoInitializeEx() failed error:0x%08x"),hr);
			}
		}

		CTapi3Device myTapiDevice(dwDeviceId);
		
		myTapiDevice.OpenLineForOutgoingCall();
		myTapiDevice.MoveToPassThroughMode();
		myTapiDevice.GetFaxClass(szSupportedClass,100);
		strncpy(pszString,szSupportedClass,100);
	}
	catch(CException thrownException)
	{
		return;
	}
}

BOOL WINAPI DllMain(
  HINSTANCE hinstDLL,  // handle to the DLL module
  DWORD fdwReason,     // reason for calling function
  LPVOID lpvReserved   // reserved
)
/*++

Routine Description:

  DLL entry point

Arguments:

  hInstance - handle to the module
  dwReason - indicates the reason for being called
  pContext - context

Return Value:

  TRUE on success

--*/
{
    switch (fdwReason) {
        case DLL_PROCESS_ATTACH:
            break;

        case DLL_PROCESS_DETACH:
            break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\stress\stressmngr\tests\unicnumstress.cpp ===
#pragma warning(disable :4786)

// standard
#include <iostream>
#include <string>
#include <vector>

// utilities
#include <testruntimeerr.h>
#include <params.h>
#include <DirectoryUtilities.h>
#include <log\log.h>

// project specific
#include "..\CTestManager.h"
#include "..\PrepareRandomJob.cpp"

using namespace std;

// Definitions
//
#define MIN_SLEEP_BETWEEN_SEND (3*30)
#define MAX_SLEEP_BETWEEN_SEND (5*30)

DWORD main(int argc,char** argv)
{
	CInput input(GetCommandLine());
	tstring tstrServerName;
	DWORD dwTestDuration = 0;
	BOOL fGenericFail = FALSE;
	std::vector<tstring> FaxFileVector;
	std::vector<tstring> CoverPageVector;
	std::vector<tstring> RecipientNumbersList;

	::lgInitializeLogger();
	::lgBeginSuite(TEXT("Stress"));
	::lgBeginCase(0, TEXT("0"));
	
	// We want exception to be printed before the very long destructor process of this object. 
	CTestManager* pTest = NULL;	

	try
	{
		if(input.IsExists(TEXT("d")))
		{
			tstring tstrDocumentPath = input[TEXT("d")];
 			FaxFileVector = GetDirectoryFileNames(tstrDocumentPath);
		}
		else
		{
			std::cout << "StressMng Usage:\n" <<
						 "/d:[Fax File Path or Fax Documents Repository Directory] mandatory parameter \n" <<
						 "/s:[Server Name] by default server is the local machine\n" <<
						 "/p:[Cover Page Path or CP Repository Directory] optional parameter \n"<<
						 "/t:[Minutes to execute test] by default will run \"forever\" \n" <<
						 "Note: spaces in path are allowed do not use the \" char \n";
			
			THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT(" Main, bad application usage"));
		}

		if(input.IsExists(TEXT("s")))
		{
			tstrServerName = input[TEXT("s")];
		}

		if(input.IsExists(TEXT("p")))
		{
			tstring tstrCoverPagePath = input[TEXT("p")];
			CoverPageVector = GetDirectoryFileNames(tstrCoverPagePath);
		}
		if(input.IsExists(TEXT("t")))
		{
			dwTestDuration = input.GetNumber(TEXT("t"));
		}


		::lgInitializeLogger();
		::lgBeginSuite(TEXT("Stress"));
		::lgBeginCase(0, TEXT("0"));
		

		srand(GetTickCount());

		DWORD x_ComputerNameLenth = MAX_COMPUTERNAME_LENGTH;
			
		// if server name wasn't specified, use local machine name as the server.
		if(tstrServerName == TEXT(""))
		{
			TCHAR buffServerName[MAX_COMPUTERNAME_LENGTH + 1 ];
			if(!GetComputerName(buffServerName, &x_ComputerNameLenth))
			{
				THROW_TEST_RUN_TIME_WIN32(GetLastError(), TEXT(" GetComputerName"));
			}
			
			tstrServerName = buffServerName;
		}
	
		// initialize test manager
		pTest = new CTestManager(tstrServerName, dwTestDuration * 60);
		
		if(!pTest)
		{
			THROW_TEST_RUN_TIME_WIN32( ERROR_OUTOFMEMORY, TEXT(" Main, new CTestManager"));
		}
		
	
		DWORD dwJobNumber = 0;
		tstring tstrTestPref(TEXT(" StressTest"));

		// loop while test duration hasn't passed.
		while(!pTest->TestTimePassed())
		{
			JOB_PARAMS_EX pJparams;
		
			// Prepare job name
			++dwJobNumber;
			otstringstream otstrTestNum;
			otstrTestNum << dwJobNumber;
			tstring tstrTestName = tstrTestPref + otstrTestNum.str();
			
			PrepareRandomJob(pJparams,
							 FaxFileVector,
							 tstrTestName.c_str(),
							 CoverPageVector,
 							 RecipientNumbersList);
			
			DWORD dwAddRetVal;
			if(dwAddRetVal = pTest->AddSimpleJobEx(pJparams))
			{
				THROW_TEST_RUN_TIME_WIN32(dwAddRetVal, TEXT(" AddSimpleJobEx"));
			}

		}

		
	}
	catch(Win32Err& err)
	{
		::lgLogError(LOG_SEV_1, TEXT("Exception:%s."), err.Desc());
		fGenericFail = TRUE;
	}

  	
	::lgEndCase();
	::lgEndSuite();
	::lgCloseLogger();  

	if(	fGenericFail)
	{
		return 0;
	}
	return x_FaxNumberIndex;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\tapitools\isfaxcapable\passthroughutil\tapi3device.cpp ===
//Tapi3Device.cpp

#include "tapi3Device.h"
#include "Log.h"
#include <crtdbg.h>
#include <stdio.h>
#include <comdef.h>
#include "smrtptrs.h"
#include "cbstr.h"
#include <stddef.h>
#include "atlconv.h"
//
//We add this pragma, because CTapi3Device uses this in the initilaztion list
//
#pragma warning( disable : 4355 ) 


#define MEDIA_NOT_REGISTERED	-1
#define CALLSTATE_CONNECT_EVENT_TIMEOUT				10000

#define MODEM_INIT_AT__COMMAND						"ATZ\r\n"
#define MODEM_ECHO_OFF__AT_COMMAND					"ATE0\r\n"
#define MODEM_FCLASS_QUERY_AT__COMMAND				"AT+FCLASS=?\r\n"

#define MODEM_RESPONSE_TO_AT_COMMANDS				"OK"
#define MODEM_RESPONSE_TIMEOUT						(20000)


//constructor
CTapi3Device::CTapi3Device(const DWORD dwId):
	m_dwId(dwId),
	m_pAddress(NULL),
	m_pTerminal(NULL),
	m_pBasicCallControl(NULL),
	m_Tapi(NULL),
	m_modemCommPortHandle(NULL)
{
	
	//
	//the constructor is wrapped with try/catch,  because it might call RegisterTapiEventInterface()
	//then fail and not call UnRegisterTapiEventInterface()
	//so the catch block has UnRegisterTapiEventInterface() and ShutdownTapi().
	//
	try
	{
		TapiCoCreateInstance();
			
		//
		//before sending any tapi command init Tapi 
		//
		InitializeTapi();
		
		//
		// Register the event interface
		//
	}
	catch(CException thrownException)
	{
		printf("thrownException is: %s",thrownException);
		if (NULL != m_Tapi)
		{
			ShutdownTapi();
		}

		throw thrownException;
	}
}




//destructor
CTapi3Device::~CTapi3Device()
{
	TapiLogDetail(LOG_X, 8, TEXT("Entering CTapi3Device Destructor"));
	
	//
	//check if we have an active call, if so call HangUp() first.
	//
	if (IsCallActive())
	{
		HangUp();
	}
	
	//
	//tapi shutdown
	//
	ShutdownTapi();
	
}//CTapi3Device::~CTapi3Device()




//*********************************************************************************
//* Name:	ThrowOnComError
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		checks the HRESULT status and throws a CException if status is FAILED
//* PARAMETERS:
//*		[IN]	HRESULT hr
//*					HRESULT status to check
//*		[IN]	const TCHAR * const szExceptionDescription
//*					description format
//*		[IN]	...
//*					parameters corresponding to the description format
//*	RETURN VALUE:
//*		NONE
//*	REMARKS:
//*		the function throws an exception of CException
//*********************************************************************************
void CTapi3Device::ThrowOnComError(
   HRESULT hr,
   const TCHAR * const szExceptionDescription,
   ...
   )
{
	if FAILED(hr)
	{
		va_list argList;
		va_start(argList, szExceptionDescription);
		throw CException(szExceptionDescription,argList);
	}

}//void CTapi3Device::ThrowOnComError()





//*********************************************************************************
//* Name:	PrepareForStreaming
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		move to passthrough mode and retrieve a handle to the comm port
//* PARAMETERS:
//*		[IN]	const StreamingType streamingType
//*					DATA,VOICE,FAX streaming type to prepare to
//*		[IN]	const StreamingDirection streamingDirection
//*					ANSWER,CALLER direction of streaming to prepare to
//*	RETURN VALUE:
//*		In Tapi3Device answerer and caller StreamingDirection have the
//*		same prepare method.
//*********************************************************************************
void CTapi3Device::PrepareForStreaming(
	const StreamingType streamingType,
	const StreamingDirection streaminDirection
	)
{
	_ASSERT(NULL != m_Tapi);
	_ASSERT(NULL != m_pBasicCallControl);
	_ASSERT(NULL != m_pAddress);

	if (
		(VOICE_STREAMING != streamingType) &&
		(DATA_STREAMING != streamingType) &&
		(FAX_STREAMING != streamingType)
		)
	{
	    throw CException(
            TEXT("CTapi3Device::PrepareForStreaming() : streamingType %d is unsupported."),
            streamingType
            );
	}

	if ( (CALLER_STREAMING != streaminDirection) && (ANSWERER_STREAMING != streaminDirection) )
	{
	    throw CException(
            TEXT("CTapi3Device::PrepareForStreaming() : streamingDirection %d is unsupported."),
            streaminDirection
            );
	}

	//
	//no special preparation if FAX or VOICE streaming
	//
	if (DATA_STREAMING == streamingType)
	{
		//SetBearerModeToPASSTHROUGH();
		SetCommPortHandleFromCallHandle();
	}
}


//*********************************************************************************
//* Name:	MoveToPassThroughMode
//* Author: Guy Merin / 05-Apr-01
//*********************************************************************************
//* DESCRIPTION:
//*		Transfer to pass through mode on an unallocated call
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		Use this function on a unallocated call, to switch to passthrough on
//*		an existing call use SetBearerModeToPASSTHROUGH.
//*********************************************************************************
void CTapi3Device::MoveToPassThroughMode()
{
	//
	//create a Dummy address and a Dummy call
	//
	CreateCallWrapper();

	//
	//change the call to a passthrough call
	//
	SetBearerModeToPASSTHROUGH();

	//
	//connect the call
	//
	ConnectCall();

	//
	//transfer to passthrough mode sucessded
	//get the handle to the comm port
	//
	SetCommPortHandleFromCallHandle();


}




//*********************************************************************************
//* Name:	VerifyCallFromCallStateEvent
//* Author: Guy Merin / 19-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Verifies that the ITCallInfo in the digit generation event
//*		is the same as the current call's ITCallInfo 
//* PARAMETERS:
//*		[IN]	ITDigitGenerationEvent *pDigitGenerationEvent
//*					the event to query the ITCallInfo from
//*	RETURN VALUE:
//*		NONE
//*********************************************************************************
void CTapi3Device::VerifyCallFromCallStateEvent(ITCallStateEvent * const pCallStateEvent) const
{
	_ASSERT(NULL != pCallStateEvent);
	_ASSERT(NULL != m_pBasicCallControl);

	ITCallInfoPtr pCallInfoFromEvent;
	HRESULT hr = pCallStateEvent->get_Call(&pCallInfoFromEvent);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::VerifyCallFromCallStateEvent(), ITDigitGenerationEvent::get_Call() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);

	//
	//get the callInfo from the event and verify it's equal to our call
	//
	ITCallInfoPtr pCallInfo;
	pCallInfo = GetCallInfoFromBasicCallControl();
	if (pCallInfo != pCallInfoFromEvent)
	{
		throw CException (TEXT("CTapi3Device::VerifyCallFromCallStateEvent(), call handle from digit generation event isn't equal to the member call handle"));
	}
	
}//void CTapi3Device::VerifyCallFromCallStateEvent()




//*********************************************************************************
//* Name:	GetCallInfoFromBasicCallControl
//* Author: Guy Merin / 18-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		return the ITCallInfo associated with the m_BasicCallControl object
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		the ITCallInfo Object
//*********************************************************************************
ITCallInfo *CTapi3Device::GetCallInfoFromBasicCallControl() const
{
	_ASSERT(NULL != m_pBasicCallControl);
	
	ITCallInfoPtr pCallInfo;
	HRESULT hr = m_pBasicCallControl->QueryInterface(IID_ITCallInfo, (LPVOID *)&pCallInfo);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::GetCallInfoFromBasicCallControl(), ITBasicCallControl::QueryInterface() on IID_ITCallInfo failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);
	_ASSERT(NULL != pCallInfo);
	return pCallInfo.Detach();
}//ITCallInfo *CTapi3Device::GetCallInfoFromBasicCallControl



//*********************************************************************************
//* Name:	SetBearerModeToPASSTHROUGH
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		set the call bearer mode to PASSTHROUGH.
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		NONE
//*	REMARKS:
//*		Use this function on an existing call, to set passthrough mode on a
//*		unallocated call use MoveToPassThroughMode
//*********************************************************************************
void CTapi3Device::SetBearerModeToPASSTHROUGH()
{
	_ASSERT(NULL != m_Tapi);
	_ASSERT(NULL != m_pBasicCallControl);
	_ASSERT(NULL != m_pAddress);


	ITCallInfoPtr pCallInfo;
	HRESULT hr = m_pBasicCallControl->QueryInterface(IID_ITCallInfo, (LPVOID *)&pCallInfo);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::SetBearerModeToPASSTHROUGH(), ITBasicCallControl::QueryInterface() on IID_ITCallInfo failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);
	_ASSERT(NULL != pCallInfo);

	//
	//set bearer mode to PASSTHROUGH
	//
	hr = pCallInfo->put_CallInfoLong(CIL_BEARERMODE,LINEBEARERMODE_PASSTHROUGH);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::SetBearerModeToPASSTHROUGH(), ITCallInfo::put_CallInfoLong(CIL_BEARERMODE,LINEBEARERMODE_PASSTHROUGH) failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);

	TapiLogDetail(LOG_X, 5, TEXT("Call in PASSTHROUGH MODE"));

}//void CTapi3Device::SetBearerModeToPASSTHROUGH()




//*********************************************************************************
//* Name:	InitializeTapi
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Wrapper for ITTAPI::Initialize()
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		NONE
//*********************************************************************************
void CTapi3Device::InitializeTapi()
{
	_ASSERT(NULL != m_Tapi);

	//
    // initialize tapi3
    //
    HRESULT hr = m_Tapi->Initialize();
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::InitializeTapi(), ITTAPI::Initialize(), error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);
}//void CTapi3Device::InitializeTapi()



//*********************************************************************************
//* Name:	InitializeTapi
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Wrapper for ITTAPI::Shutdown()
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		NONE
//*********************************************************************************
void CTapi3Device::ShutdownTapi()
{
	_ASSERT(NULL != m_Tapi);
			
	//
    // shutdown tapi
    //
    HRESULT hr = m_Tapi->Shutdown();
	m_Tapi.Release();
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::ShutdownTapi(), ITTAPI::Shutdown() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);

}


//*********************************************************************************
//* Name:	TapiCoCreateInstance
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Wrapper for ::CoCreateInstance(ITTAPI)
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		NONE
//*********************************************************************************
void CTapi3Device::TapiCoCreateInstance()
{
	_ASSERT(NULL == m_Tapi);
	
    //
    // CoCreate the TAPI object
    //
    HRESULT hr = CoCreateInstance(
		CLSID_TAPI,
		NULL,
		CLSCTX_INPROC_SERVER,
		IID_ITTAPI,
		(LPVOID *)&m_Tapi
		);
    ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::InitializeTapi(), CoCreateInstance() on TAPI failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);
	_ASSERT(NULL != m_Tapi);
}




//*********************************************************************************
//* Name:	SetAddressProperty
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		set m_pAddress with the address handle according to m_dwId and dwMedia
//* PARAMETERS:
//*		[IN]	const DWORD dwMedia
//*					desirable media mode for address
//*	RETURN VALUE:
//*		NONE
//*	REMARKS:
//*		The function checks if tapi device m_dwId supports dwMedia
//*		if not an exception is thrown
//*********************************************************************************
void CTapi3Device::SetAddressProperty(const DWORD dwMedia)
{
	_ASSERT(NULL != m_Tapi);
	_ASSERT(NULL == m_pAddress);
	_ASSERT(NULL == m_pBasicCallControl);

	//
	//set m_pAddress according to m_dwId
	//
	SetAddressFromTapiID();

	//
	//log the Tapi address name
	//
	LogAddressName();

	//
	//check if device state is OK
	//
	VerifyAddressState();

	//
	//check if address supports wanted media mode
	//
	VerifyAddressSupportMediaMode(dwMedia);
}



//*********************************************************************************
//* Name:	SetAddressFromTapiID
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Set m_pAddress with the m_dwId address count
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		NONE
//*	REMARKS:
//*		The function enumerates all the addresses and skips to the m_dwId address count
//*********************************************************************************
void CTapi3Device::SetAddressFromTapiID()
{
	_ASSERT(NULL != m_Tapi);
	_ASSERT(NULL == m_pAddress);

	//
	//enum the addresses and find device ID m_dwId
	//

	IEnumAddressPtr pEnumAddress;

	HRESULT hr = m_Tapi->EnumerateAddresses(&pEnumAddress);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::SetAddressFromTapiID(), ITTAPI::EnumerateAddresses() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);

	
	//
	//skip to the desired tapi deviceID
	//
	hr = pEnumAddress->Skip(m_dwId); 
	if FAILED(hr)
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::SetAddressFromTapiID(), IEnumAddress::Skip() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);
	
	//
	//get the desired address
	//
	ULONG cAddresses;
	hr = pEnumAddress->Next(1, &m_pAddress, &cAddresses);
	_ASSERT(1 == cAddresses);		//we asked from Next() for only 1 ITADDRESS

	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::SetAddressFromTapiID(), IEnumAddress::Next() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);

}//void CTapi3Device::SetAddressFromTapiID()
	



//*********************************************************************************
//* Name:	VerifyAddressSupportMediaMode
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Verify that the address supports the desired media mode.
//* PARAMETERS:
//*		[IN]	const DWORD dwMedia
//*					media mode to verify
//*	RETURN VALUE:
//*		NONE
//*	REMARKS:
//*		The function uses ITMediaSupport::QueryMediaType()
//*********************************************************************************
void CTapi3Device::VerifyAddressSupportMediaMode(const DWORD dwMedia) const
{
	_ASSERT(NULL != m_Tapi);
	_ASSERT(NULL != m_pAddress);
	
	//
	//get the address supported media modes through the ITMediaSupport interface
	//
	ITMediaSupportPtr    pMediaSupport;
	HRESULT hr = m_pAddress->QueryInterface(IID_ITMediaSupport,(void **)&pMediaSupport);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::VerifyAddressSupportMediaMode(), ITAddress::QueryInterface() on IID_ITMediaSupport failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);

	//
	// does this address support our needed MEDIAMODE?
	//
	VARIANT_BOOL bSupport;
	pMediaSupport->QueryMediaType(dwMedia,&bSupport);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::VerifyAddressSupportMediaMode(), ITMediaSupport::QueryMediaType() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);
	
	if (!bSupport)
    {
		throw CException(
			TEXT("%s(%d): CTapi3Device::VerifyAddressSupportMediaMode(), %d media mode is not supported by this address"), 
			TEXT(__FILE__),
			__LINE__,
			dwMedia
			);
	}
}//void CTapi3Device::VerifyAddressSupportMediaMode(dwMedia)



//*********************************************************************************
//* Name:	LogAddressName
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		echoes the device name (string)
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		NONE
//*	REMARKS:
//*		The function uses ::lgLogDetail()
//*********************************************************************************
void CTapi3Device::LogAddressName() const
{
	_ASSERT(NULL != m_Tapi);
	_ASSERT(NULL != m_pAddress);
	
	//
	//szAddressName is allocated by get_AddressName(), we need to free it.
	//
	CBSTR szAddressNameAsBSTR;
	HRESULT hr = m_pAddress->get_AddressName(&szAddressNameAsBSTR);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::LogAddressName(), ITAddress::get_AddressName() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);

	//
	//create a _bstr_t so we can cast it to char* or wchar*
	//
	_bstr_t szAddressNameAs_BSTR_t(szAddressNameAsBSTR);

#ifdef UNICODE
	TapiLogDetail(LOG_X, 5, TEXT("Provider name is %s"),(wchar_t*) szAddressNameAs_BSTR_t);
#else
	TapiLogDetail(LOG_X, 5, TEXT("Provider name is %s"),(char*) szAddressNameAs_BSTR_t);
#endif
	//
	//szAddressName is not needed anymore
	//
	::SysFreeString(szAddressNameAsBSTR);
}//void CTapi3Device::LogAddressName()


//*********************************************************************************
//* Name:	VerifyAddressState
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Verify that the address state is in-service
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		NONE
//*	REMARKS:
//*		The function uses ITAddress::get_State()
//*********************************************************************************
void CTapi3Device::VerifyAddressState() const
{
	_ASSERT(NULL != m_Tapi);
	_ASSERT(NULL != m_pAddress);

	ADDRESS_STATE asAddressState;
	HRESULT hr = m_pAddress->get_State(&asAddressState);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::VerifyAddressState(), ITAddress::get_State() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);
	if (AS_OUTOFSERVICE == asAddressState)
	{
		throw CException(TEXT("CTapi3Device::VerifyAddressState(), address is OUT OF SERVICE"));
	}
	_ASSERT(AS_INSERVICE == asAddressState);
}//void CTapi3Device::VerifyAddressState()



//*********************************************************************************
//* Name:	SetTerminalForIncomingCall
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* TBD
//*********************************************************************************
void CTapi3Device::SetTerminalForOutgoingCall(const DWORD dwMedia)
{
	_ASSERT(NULL != m_Tapi);
	_ASSERT(NULL != m_pAddress);
	_ASSERT(NULL == m_pTerminal);
	HRESULT hr;
	
	//
	//set the terminal
	//
	ITTerminalSupportPtr pTerminalSupport;
	hr = m_pAddress->QueryInterface(IID_ITTerminalSupport,(void **)&pTerminalSupport);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::SetTerminalForOutgoingCall(), ITAddress::QueryInterface() on IID_ITTerminalSupport failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);

	hr = pTerminalSupport->GetDefaultStaticTerminal(
		dwMedia,
		TD_CAPTURE,
		&m_pTerminal
		);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::SetTerminalForOutgoingCall(), ITTerminalSupport::GetDefaultStaticTerminal() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);
	_ASSERT(NULL != m_pTerminal);
	
	TERMINAL_STATE ts_TerminalState;
	hr = m_pTerminal->get_State(&ts_TerminalState);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::SetTerminalForOutgoingCall(), ITTerminal::get_State() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);
	//TBD: check if the terminal state should be here a
	//TS_INUSE or a TS_NOTINUSE

}//CTapi3Device::SetTerminalForOutgoingCall(const DWORD dwMedia)


//*********************************************************************************
//* Name:	GetCallState
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		returns Tapi CallState enum
//* PARAMETERS:
//*		[IN] ITCallInfo *pCallInfo
//*			pointer to the call's ITCallInfo
//*			(If this parameter is not supplied it's default value is NULL)
//*	RETURN VALUE:
//*		the call's CallState
//*	REMARKS:
//*		This function calls ITCallInfo::get_CallState() 
//*		If pCallInfo is NULL it calls QueryInterface to get pCallInfo
//*********************************************************************************
CALL_STATE CTapi3Device::GetCallState(ITCallInfo *pCallInfo) const
{
	_ASSERT(NULL != m_Tapi);
	_ASSERT(NULL != m_pBasicCallControl);
	_ASSERT(NULL != m_pAddress);

	HRESULT hr;
	if (NULL == pCallInfo )
	{
		hr = m_pBasicCallControl->QueryInterface(IID_ITCallInfo, (LPVOID *)&pCallInfo);
		ThrowOnComError(
			hr,
			TEXT("%s(%d): CTapi3Device::GetCallState(), ITBasicCallControl::QueryInterface() on IID_ITCallInfo failed, error code:0x%08x"), 
			TEXT(__FILE__),
			__LINE__,
			hr
			);
		_ASSERT(NULL != pCallInfo);
	}
	else
	{
		//
		//increase reference by one, this way in both cases 
		// we have to call Release() at the end of the function.
		//
		pCallInfo->AddRef();
	}

	CALL_STATE csCurrentCallState;
	hr = pCallInfo->get_CallState(&csCurrentCallState);
	pCallInfo->Release();
	pCallInfo = NULL;
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::GetCallState(), ITCallInfo::get_CallState() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);

	return csCurrentCallState;
}


//*********************************************************************************
//* Name:	IsCallActive
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Check if the call is in a callstate different than CS_IDLE or CS_DISCONNECTED
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		TRUE
//*			The call is in an active state (CONNECT, OFFERING etc)
//*		FALSE
//*			The call handle is either NULL or the callstate is IDLE or DISCONNECTED
//*	REMARKS:
//*		This function uses ::GetCallState()
///*********************************************************************************
bool CTapi3Device::IsCallActive() const
{
	_ASSERT(NULL != m_Tapi);

	if (NULL == m_pBasicCallControl)
	{
		return false;
	}
	CALL_STATE csCurrentCallState = GetCallState();
	if ( (CS_IDLE == csCurrentCallState) || (CS_DISCONNECTED == csCurrentCallState) )
	{
		return false;
	}
	else
	{
		return true;
	}

}



//*********************************************************************************
//* Name:	GetCallInfoFromCallEvent
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		return the CallInfo and check if the call's privilege is OWNER
//* PARAMETERS:
//*		[IN]	ITCallNotificationEvent *pCallNotificationEvent
//*					new call event to query callInfo
//*	RETURN VALUE:
//*		the callInfo pointer
//*	REMARK:
//*		This function uses ITCallNotificationEvent::get_Call()
//*********************************************************************************
ITCallInfo *CTapi3Device::GetCallInfoFromCallEvent(ITCallNotificationEvent *pCallNotificationEvent) const
{
	_ASSERT(NULL != m_Tapi);
	_ASSERT(NULL != pCallNotificationEvent);
	
	CALL_NOTIFICATION_EVENT csePrivilege;

	HRESULT hr = pCallNotificationEvent->get_Event(&csePrivilege);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::GetCallInfoFromCallEvent(), ITCallNotificationEvent::get_Event() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);

	if (CNE_MONITOR == csePrivilege)
	{
		throw CException(TEXT("CTapi3Device::GetCallInfoFromCallEvent(), New call is with MONITOR privilege only"));
	}
	_ASSERT(CNE_OWNER == csePrivilege);

	ITCallInfoPtr pCallInfo;
	hr = pCallNotificationEvent->get_Call(&pCallInfo);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::GetCallInfoFromCallEvent(), ITCallNotificationEvent::get_Call() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);
	_ASSERT(pCallInfo != NULL);
	return (pCallInfo.Detach());

}//void CTapi3Device::GetCallInfoFromCallEvent()


//*********************************************************************************
//* Name:	VerifyAddressFromCallInfo
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		get the address from the callInfo and verify that it's the registered
//*		address (stored in m_pAddress)
//* PARAMETERS:
//*		[IN]	ITCallInfo *pCallInfo
//*					callInfo which will be used to get the address from
//*	RETURN VALUE:
//*		NONE
//*	REMARK:
//*		This function uses ITCallInfo::get_Address()
//*********************************************************************************
void CTapi3Device::VerifyAddressFromCallInfo(ITCallInfo *pCallInfo) const
{
	_ASSERT(NULL != m_Tapi);
	_ASSERT(NULL != pCallInfo);
	_ASSERT(NULL != m_pAddress);

	//
	//get the ITAddress from pCallInfo
	//
	ITAddressPtr pAddress;

	HRESULT hr = pCallInfo->get_Address(&pAddress);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::VerifyAddressFromCallInfo(), ITCallInfo::get_Address() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);
	
	//
	//We're registered to listen on 1 address only
	// so the address on the new call should be the same address as 
	// the tapi device address defined in Tapi3Device::Tapi3Device().
	//
	if(pAddress != m_pAddress)
	{
		throw CException(TEXT("CTapi3Device::VerifyAddressFromCallInfo() new call doesn't match wanted address"));
	}
}//void CTapi3Device::VerifyAddressFromCallInfo()


//*********************************************************************************
//* Name:	SetCommPortHandleFromCallHandle
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		sets the comm port handle(m_modemCommPortHandle) using the call object
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		NONE
//*	REMARKS:
//*		This function uses ITLegacyCallMediaControl::GetID()
//*********************************************************************************
void CTapi3Device::SetCommPortHandleFromCallHandle()
{
	_ASSERT(NULL != m_Tapi);
	_ASSERT(NULL == m_modemCommPortHandle);
	_ASSERT(NULL != m_pBasicCallControl);

	//
	//get a ITLegacyCallMediaControl interface
	//
	ITLegacyCallMediaControlPtr pLegacyCallMediaControl;
	HRESULT hr = m_pBasicCallControl->QueryInterface(IID_ITLegacyCallMediaControl, (LPVOID *)&pLegacyCallMediaControl);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::SetCommPortHandleFromCallHandle(), ITBasicCallControl::QueryInterface() on IID_ITLegacyCallMediaControl failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);
	_ASSERT(NULL != pLegacyCallMediaControl);


	CBSTR bstrDeviceClass = SysAllocString(TEXT("comm/datamodem"));
	if (!bstrDeviceClass)
	{
		throw CException(TEXT("CTapi3Device::SetCommPortHandleFromCallHandle(), SysAllocString() failed"));
	}

	//
	//get a handle to the comm port
	//
	LPBYTE		lpDeviceInfo = NULL;
	DWORD dwSize = 0;
	hr = pLegacyCallMediaControl->GetID(
		bstrDeviceClass,
		&dwSize,
		(BYTE **) &lpDeviceInfo
		);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::SetCommPortHandleFromCallHandle(), ITLegacyCallMediaControl::GetID() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);
	
	_ASSERT(dwSize >= sizeof(m_modemCommPortHandle));
	m_modemCommPortHandle	= *((LPHANDLE) lpDeviceInfo);
	_ASSERT(NULL != m_modemCommPortHandle);


}//void CTapi3Device::SetCommPortHandleFromCallHandle()




//*********************************************************************************
//* Name:	SetCommPortHandleFromAddressHandle
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		sets the comm port handle(m_modemCommPortHandle) using the 
//*		address object
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		NONE
//*	REMARKS:
//*		This function uses ITLegacyCallMediaControl::GetID()
//*********************************************************************************
void CTapi3Device::SetCommPortHandleFromAddressHandle()
{
	_ASSERT(NULL != m_Tapi);
	_ASSERT(NULL == m_modemCommPortHandle);
	_ASSERT(NULL != m_pAddress);

	//
	//get a ITLegacyAddressMediaControl interface
	//
	ITLegacyAddressMediaControlPtr pLegacyAddressMediaControl = NULL;
	HRESULT hr = m_pAddress->QueryInterface(IID_ITLegacyAddressMediaControl, (LPVOID *)&pLegacyAddressMediaControl);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::SetCommPortHandleFromAddressHandle(), ITAddress::QueryInterface() on IID_ITLegacyAddressMediaControl failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);
	
	CBSTR bstrDeviceClass = SysAllocString(TEXT("comm/datamodem"));
	if (!bstrDeviceClass)
	{
		throw CException(TEXT("CTapi3Device::SetCommPortHandleFromAddressHandle(), SysAllocString() failed"));
	}


	//
	//get a handle to the comm port
	//
	DWORD	dwSize = 0;
	LPBYTE	lpDeviceInfo = NULL;
	
	hr = pLegacyAddressMediaControl->GetID(
		bstrDeviceClass,
		&dwSize,
		(BYTE **) &lpDeviceInfo
		);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::SetCommPortHandleFromAddressHandle(), ITLegacyAddressMediaControl::GetID() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);

	_ASSERT(dwSize >= sizeof(m_modemCommPortHandle));
	m_modemCommPortHandle	= *((LPHANDLE) lpDeviceInfo);
	_ASSERT(NULL != m_modemCommPortHandle);

}//void CTapi3Device::SetCommPortHandleFromAddressHandle()





//*********************************************************************************
//* Name:	CreateCallWrapper
//* Author: Guy Merin / 05-Apr-01
//*********************************************************************************
//* DESCRIPTION:
//*		Wrapper for ITAddress::CreateCall()
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		NONE
//*********************************************************************************
void CTapi3Device::CreateCallWrapper()
{
	_ASSERT(NULL != m_Tapi);
	_ASSERT(NULL != m_pAddress);
	_ASSERT(NULL == m_pBasicCallControl);
	
	//
	//ITADDRESS::CreateCall() takes a BSTR, so prepare a BSTR from A dummy number (1111)
	//
	CBSTR numberToCallAsBSTR = SysAllocString(TEXT("1111"));
	if (!numberToCallAsBSTR)
	{
		throw CException(TEXT("CTapi3Device::CreateCallWrapper(), SysAllocString() failed"));
	}

	//
	//create call, returns a ITBasicCallControl, to actuly make the call
	//we need to call ITBasicCallControl::Connect()
	//
	
	HRESULT hr = m_pAddress->CreateCall(numberToCallAsBSTR ,LINEADDRESSTYPE_PHONENUMBER,TAPIMEDIATYPE_DATAMODEM,&m_pBasicCallControl);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::CreateCallWrapper(), ITAddress::CreateCall() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);
	_ASSERT(NULL != m_pBasicCallControl);
	
}//void CTapi3Device::CreateCallWrapper()



//*********************************************************************************
//* Name:	ConnectCall
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Connect the call previously initialized by makeCall
//*		and verify that the call is in CONNECTED state
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		NONE
//*********************************************************************************
void CTapi3Device::ConnectCall() const
{
	_ASSERT(NULL != m_Tapi);
	_ASSERT(NULL != m_pAddress);
	_ASSERT(NULL != m_pBasicCallControl);

	//
	//dial the number given to makeCall, and wait till a CONNECT message is received
	//the TRUE parameter indicates that the Connect() is sync
	//
	HRESULT hr = m_pBasicCallControl->Connect(TRUE);	
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::ConnectCall(), ITBasicCallControl::Connect() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);

	if (CS_CONNECTED == GetCallState())
	{
		return;
	}
	else
	{
		throw CException(TEXT("CTapi3Device::ConnectCall(), Call not in CONNECT state"));
	}

}//void CTapi3Device::ConnectCall() const


//*********************************************************************************
//* Name:	GetCallSupportedMediaModes
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		return the call's supported media mode, based on the m_pBasicCallControl
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		call's supported media modes
//*	REMARKS:
//*		this function uses ITCallInfo::get_MediaTypesAvailable()
//*********************************************************************************
DWORD CTapi3Device::GetCallSupportedMediaModes() const
{
	_ASSERT(NULL != m_Tapi);
	_ASSERT(NULL != m_pBasicCallControl);

	ITCallInfoPtr pCallInfo = NULL;
	HRESULT hr = m_pBasicCallControl->QueryInterface(IID_ITCallInfo, (LPVOID *)&pCallInfo);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::GetCallSupportedMediaModes(), ITBasicCallControl::QueryInterface() on IID_ITCallInfo failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);
	_ASSERT(NULL != pCallInfo);
	
	long lMediaTypes;
	hr = pCallInfo->get_CallInfoLong(CIL_MEDIATYPESAVAILABLE,&lMediaTypes);
	//hr = pCallInfo->get_MediaTypesAvailable(&lMediaTypes);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::GetCallSupportedMediaModes(), ITCallInfo::get_MediaTypesAvailable() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);
	
	long lBearerMode;
	hr = pCallInfo->get_CallInfoLong(CIL_BEARERMODE,&lBearerMode);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::GetCallSupportedMediaModes(), ITCallInfo::get_BearerMode() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);
	
	_ASSERT(LINEBEARERMODE_PASSTHROUGH == lBearerMode);
	_ASSERT(TAPIMEDIATYPE_DATAMODEM == lMediaTypes);
	lMediaTypes = TAPIMEDIATYPE_G3FAX;
	
	return lMediaTypes;
}//void CTapi3Device::GetCallSupportedMediaModes()



////////////////////////////////////////////////////////////////////////////////////////////////
//public functions
////////////////////////////////////////////////////////////////////////////////////////////////



//*********************************************************************************
//* Name:	CleanUp
//* Author: Guy Merin / 03-Dec-98
//*********************************************************************************
//* DESCRIPTION:
//*		A cleanup function that dealloctes, releases, resets all the member variables
//*		The state of the object after calling this function is the same as a
//*		construcated object
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		NONE
//*	REMARKS:
//*		The object's message queue is cleared (from all the call's queued events)
//*********************************************************************************
void CTapi3Device::CleanUp()
{

	if (NULL != m_pBasicCallControl)
	{
		HangUp();
		_ASSERT(NULL == m_pBasicCallControl);
	}
	
	if (NULL != m_pAddress)
	{
		m_pAddress.Release();
	}

	if (NULL != m_pTerminal)
	{
		m_pTerminal.Release();
	}

	CloseCommPortHandle();
	m_modemCommPortHandle = NULL;


}//void CTapi3Device::CleanUp()


//*********************************************************************************
//* Name:	HangUp
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Hangup the call and unregister the call's media mode
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		NONE
//*	REMARKS:
//*		The object's message queue is cleared (from all the call's queued events)
//*********************************************************************************
void CTapi3Device::HangUp()
{
	_ASSERT(NULL != m_Tapi);
	_ASSERT(NULL != m_pBasicCallControl);
	_ASSERT(NULL != m_pAddress);
	
	if (IsCallActive())
	{
		HRESULT hr = m_pBasicCallControl->Disconnect(DC_NORMAL);
		ThrowOnComError(
			hr,
			TEXT("%s(%d): CTapi3Device::HangUp(), ITBasicCallControl::Disconnect() failed, error code:0x%08x"), 
			TEXT(__FILE__),
			__LINE__,
			hr
			);
	}
	
	//
	//call now is in DISCONNECT state or IDLE state
	//
	if (NULL != m_pBasicCallControl)
	{
		m_pBasicCallControl.Release();
	}
	
	if (NULL != m_pAddress)
	{
		m_pAddress.Release();
	}

	if (NULL != m_pTerminal)
	{
		m_pTerminal.Release();
	}


	CloseCommPortHandle();

}//CTapi3Device::HangUp()







//*********************************************************************************
//* Name:	TapiLogDetail
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Wrapper for ::lgLogDetail(), logs a message with the Tapi's properties
//* PARAMETERS:
//*		[IN]	DWORD dwLevel
//*					log level, passed to ::lgLogDetail()
//*		[IN]	DWORD dwSeverity 
//*					log severity, passed to ::lgLogDetail()
//*		[IN]	const TCHAR * const szLogDescription
//*					description format, 
//*		[IN]	...
//*					extra parameters as specified in szLogDescription parameter
//*	RETURN VALUE:
//*		NONE
//*********************************************************************************
void CTapi3Device::TapiLogDetail(
	DWORD dwLevel,
	DWORD dwSeverity,
	const TCHAR * const szLogDescription,
	...
	) const
{
	TCHAR szLog[MaxLogSize];
	szLog[MaxLogSize-1] = '\0';
	va_list argList;
	va_start(argList, szLogDescription);
	::_vsntprintf(szLog, MaxLogSize-1, szLogDescription, argList);
	va_end(argList);

	::printf("LogInfo:%d,%d,%s:",
		dwLevel, 
		dwSeverity, 
		TEXT("AddressID=0x%08x, DeviceId=%d, %s"),
		m_pAddress,
		m_dwId,
		szLog
		);

}//void CTapi3Device::TapiLogDetail()


//*********************************************************************************
//* Name:	TapiLogError
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Wrapper for ::lgLogError(), logs a message with the Tapi's properties
//* PARAMETERS:
//*		[IN]	DWORD dwSeverity 
//*					log severity, passed to ::lgLogError()
//*		[IN]	const TCHAR * const szLogDescription
//*					description format, 
//*		[IN]	...
//*					extra parameters as specified in szLogDescription parameter
//*	RETURN VALUE:
//*		NONE
//*********************************************************************************
void CTapi3Device::TapiLogError(
	DWORD dwSeverity,
	const TCHAR * const szLogDescription,
	...
	) const
{
	TCHAR szLog[MaxLogSize];
	szLog[MaxLogSize-1] = '\0';
	va_list argList;
	va_start(argList, szLogDescription);
	::_vsntprintf(szLog, MaxLogSize-1, szLogDescription, argList);
	va_end(argList);

	::printf("LogError:%d,%s:",
		dwSeverity, 
		TEXT("AddressID=0x%08x, DeviceId=%d, %s"),
		m_pAddress,
		m_dwId,
		szLog
		);

}//void CTapi3Device::TapiLogError()



//*********************************************************************************
//* Name:	OpenLineForOutgoingCall
//* Author: Guy Merin / 05-Apr-01
//*********************************************************************************
//* DESCRIPTION:
//*		Opens a line for outgoing calls
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		NONE
//*	REMARKS:
//*		the function uses CTapi3Device::SetAddressProperty()
//*********************************************************************************
void CTapi3Device::OpenLineForOutgoingCall()
{

	//
	//Set the device address to make the outgoing call
	//
	SetAddressProperty(TAPIMEDIATYPE_DATAMODEM);

}//void CTapi3Device::OpenLineForOutgoingCall()


//*********************************************************************************
//* Name:	CTapi3Device::GetFriendlyMediaMode()
//* Author:	Guy Merin
//* Date:	December 31, 1998
//*********************************************************************************
//* DESCRIPTION:
//*		A mapping between Tapi3.h media modes and abstract media type
//* PARAMETERS:
//*		NONE
//* RETURN VALUE:
//*		A combination of the following
//*			MEDIAMODE_VOICE
//*			MEDIAMODE_INTERACTIVE_VOICE
//*			MEDIAMODE_AUTOMATED_VOICE
//*			MEDIAMODE_FAX
//*			MEDIAMODE_DATA
//*			MEDIAMODE_UNKNOWN
//*********************************************************************************
DWORD CTapi3Device::GetFriendlyMediaMode(void) const
{

	DWORD dwCallSupportedMediaMode = GetCallSupportedMediaModes();
	DWORD dwAbstractMediaMode = 0;

	if (dwCallSupportedMediaMode & TAPIMEDIATYPE_AUDIO)
	{
		dwAbstractMediaMode = (dwAbstractMediaMode | MEDIAMODE_VOICE);
	}

	if (dwCallSupportedMediaMode & TAPIMEDIATYPE_DATAMODEM)
	{
		dwAbstractMediaMode = (dwAbstractMediaMode | MEDIAMODE_DATA);
	}

	if (dwCallSupportedMediaMode & TAPIMEDIATYPE_G3FAX)
	{
		dwAbstractMediaMode = (dwAbstractMediaMode | MEDIAMODE_FAX);
	}

	if (0 == dwAbstractMediaMode)
	{
		throw CException(
			TEXT("%s(%d): CTapi3Device::GetFriendlyMediaMode(), CTapi3Device::GetCallSupportedMediaModes() returned unsupported media mode(%d)"), 
			TEXT(__FILE__),
			__LINE__,
			dwCallSupportedMediaMode 
			);
	}

	return dwAbstractMediaMode;
}//CTapi3Device::GetFriendlyMediaMode()





//*********************************************************************************
//* Name:	CTapi3Device::GetDeviceSpecificMediaMode()
//* Author:	Guy Merin
//* Date:	January 11, 1999
//*********************************************************************************
//* DESCRIPTION:
//*		mapping between abstract media type and tapi2 media types
//* PARAMETERS:
//*		[IN]	const DWORD dwMedia
//*			abstract media mode
//* RETURN VALUE:
//*		a combination of the following:
//*			TAPIMEDIATYPE_AUDIO
//*			TAPIMEDIATYPE_DATAMODEM
//*			TAPIMEDIATYPE_G3FAX
//*********************************************************************************
DWORD CTapi3Device::GetDeviceSpecificMediaMode(const DWORD dwMedia)
{

	DWORD dwDeviceSpecificMediaMode = 0;

	//
	//voice
	//
	if (dwMedia & MEDIAMODE_AUTOMATED_VOICE)
	{
		dwDeviceSpecificMediaMode = (dwDeviceSpecificMediaMode | TAPIMEDIATYPE_AUDIO);
	}

	if (dwMedia & MEDIAMODE_INTERACTIVE_VOICE)
	{
		dwDeviceSpecificMediaMode = (dwDeviceSpecificMediaMode | TAPIMEDIATYPE_AUDIO);
	}

	if (dwMedia & MEDIAMODE_VOICE)
	{
		dwDeviceSpecificMediaMode = (dwDeviceSpecificMediaMode | TAPIMEDIATYPE_AUDIO);	
	}

	//
	//data
	//
	if (dwMedia & MEDIAMODE_DATA)
	{
		dwDeviceSpecificMediaMode = (dwDeviceSpecificMediaMode | TAPIMEDIATYPE_DATAMODEM);
	}

	//
	//fax
	//
	if (dwMedia & MEDIAMODE_FAX)
	{
		dwDeviceSpecificMediaMode = (dwDeviceSpecificMediaMode | TAPIMEDIATYPE_G3FAX);
	}

	//
	//unknown media mode isn't supported in Tapi3
	//
	if (dwMedia & MEDIAMODE_UNKNOWN)
	{
		throw CException(
			TEXT("%s(%d): CTapi3Device::GetDeviceSpecificMediaMode(), Unsupported media mode(MEDIAMODE_UNKNOWN)"), 
			TEXT(__FILE__),
			__LINE__
			);
	}

	
	//
	//other unsupported media modes
	//
	if (0 == dwDeviceSpecificMediaMode)
	{
		throw CException(
			TEXT("%s(%d): CTapi3Device::GetDeviceSpecificMediaMode(), Unsupported media mode(%x)"), 
			TEXT(__FILE__),
			__LINE__,
			dwMedia
			);
	}
	
	return dwDeviceSpecificMediaMode;

}//DWORD CTapi3Device::GetDeviceSpecificMediaMode()



//*********************************************************************************
//* Name:	CTapi3Device::SetCallMediaMode()
//* Author:	Guy Merin
//* Date:	January 07, 1999
//*********************************************************************************
//* DESCRIPTION:
//*		TBD
//* PARAMETERS:
//*		[IN]	const DWORD dwMedia
//*			The new media mode(s) for the call. 
//* RETURN VALUE:
//*		NONE
//*********************************************************************************
void CTapi3Device::SetCallMediaMode(const DWORD dwMedia)
{
	//TBD

}//void CTapi3Device::SetCallMediaMode()


//*********************************************************************************
//* Name:	CloseCommPortHandle
//* Author: Guy Merin / 24-Sep-98
//*********************************************************************************
//* DESCRIPTION:
//*		closes the file handle and resets m_modemCommPortHandle handle.
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		NONE
//*********************************************************************************
void CTapi3Device::CloseCommPortHandle()
{
	if(NULL == m_modemCommPortHandle)
	{
		return;
	}

	if (!CloseHandle(m_modemCommPortHandle))
	{
		throw CException(
			TEXT("%s(%d): CTapi3Device::CloseCommPortHandle(): closeHandle failed with error %d \n"), 
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
	}
	m_modemCommPortHandle = NULL;
}//CTapi3Device::CloseCommPortHandle()



//*********************************************************************************
//* Name:	SetOverlappedStruct
//* Author: Guy Merin / 08-Oct-98
//*********************************************************************************
//* DESCRIPTION:
//*		return an initialized overlapped structure
//* PARAMETERS:
//*		[OUT]	OVERLAPPED * const ol
//*					overlapped variable to be initilazed
//*	RETURN VALUE:
//*		NONE
//*********************************************************************************
void CTapi3Device::SetOverlappedStruct(OVERLAPPED * const ol)
{
    ol->OffsetHigh = ol->Offset = 0;
    ol->hEvent = CreateEvent (NULL, TRUE,  FALSE, NULL);
    if (NULL == ol->hEvent)
    {
        throw CException(
            TEXT("CTapi3Device::SetOverlappedStruct() : CreateEvent() failed with %d."),
            ::GetLastError()
            );
    }
}//CTapi3Device::SetOverlappedStruct


//*****************************************************************************
//* Name:	SynchReadFile
//* Author: Guy Merin/ 27-Sep-98
//*****************************************************************************
//* DESCRIPTION:
//*		Performs SYNCHRONOUS file read using overllaped IO.
//* PARAMETERS:
//*		[IN]	LPVOID lpBuffer:
//*					see documentation for Win32 WriteFile API
//*		[OUT]	DWORD nNumberOfBytesToWrite:
//*					see documentation for Win32 WriteFile API
//*		[IN]  	LPDWORD lpNumberOfBytesWritten:
//*					see documentation for Win32 WriteFile API
//*	RETURN VALUE:
//*		TRUE
//*			The write operation was successful
//*		FALSE
//*			The write operation failed
//*****************************************************************************
bool CTapi3Device::SynchReadFile(
	LPVOID lpBuffer,                
	DWORD nNumberOfBytesToRead,    
	LPDWORD lpNumberOfBytesRead
	) const
{

	OVERLAPPED ol_read;
	::ZeroMemory(&ol_read,sizeof(ol_read));
	SetOverlappedStruct(&ol_read);

	_ASSERT(m_modemCommPortHandle);
	_ASSERT(lpBuffer);
	_ASSERT(lpNumberOfBytesRead);

	if (!::ReadFile(
				m_modemCommPortHandle,
				lpBuffer,nNumberOfBytesToRead,
				lpNumberOfBytesRead,
				&ol_read
				))
	{
		if (ERROR_IO_PENDING == ::GetLastError())
		{
			//OVERLAPPED IO was started
			BOOL bRes;
			*lpNumberOfBytesRead=0;
			bRes = ::GetOverlappedResult(
						m_modemCommPortHandle,
						&ol_read,
						lpNumberOfBytesRead,
						TRUE
						);
			if (TRUE == bRes)
			{
				goto SynchReadFile_SUCCESS;
			}
			else
			{
				goto SynchReadFile_ERROR;
			}
		} 
		else
		{
			//Write operation failed
			goto SynchReadFile_ERROR;
		}
	} 
	else
	{
		//Read operation successful and was performed synchronously
		goto SynchReadFile_SUCCESS;
	}

SynchReadFile_SUCCESS:
	if ( !CloseHandle(ol_read.hEvent) )
	{
		throw CException(
			TEXT("%s(%d): CTapi3Device::SynchReadFile(), CloseHandle() failed, error code:%d"), 
			TEXT(__FILE__),
			__LINE__,
			GetLastError()
			);
	}
	return (true);

SynchReadFile_ERROR:
	if ( !CloseHandle(ol_read.hEvent) )
	{
		throw CException(
			TEXT("%s(%d): CTapi3Device::SynchReadFile(), CloseHandle() failed, error code:%d"), 
			TEXT(__FILE__),
			__LINE__,
			GetLastError()
			);
	}
	return (false);



}//CTapi3Device::SynchReadFile()



//*****************************************************************************
//* Name:	ReadResponse
//* Author: Guy Merin / 27-Sep-98
//*****************************************************************************
//* DESCRIPTION:
//*		Reads the next modem response.
//*		The function skips any CR or LF chars that perceed the response and 
//*		then reads into the result buffer all the chars up to the next (not 
//*		including the next CR or LF char).
//*		The function implies timeout constraints.
//*		If the first response char is not received within dwTimeOut a timeout
//*		error will be returned. 
//*		If while reading the next chars of the response a delay of more than
//*		150ms occurs a timeout error will be returned as well.
//*	
//* PARAMETERS:
//*		[OUT]	char * szResponse:
//*					A pointer to a buffer where the response string will be 
//*					placed. The string is always ANSI string.
//*		[IN]	int nResponseMaxSize:
//*					The total size of the response buffer.
//*		[OUT]	DWORD *pdwActualRead:
//*					The number of bytes that were read into the response
//*					buffer (not including terminating NULL char).
//*		[IN]	DWORD dwTimeOut:
//*					The number of milliseconds to wait for the first
//*					char of the response.
//*	RETURN VALUE:
//*		READRESPONSE_TIMEOUT: 
//*			If a timeout occurred waiting for the first response char or while
//*			reading the reminder of the response.
//*		READRESPONSE_SUCCESS:
//*			If the response was read succesffuly
//*		READRESPONSE_BUFFERFULL:
//*			If the provided buffer is too small for the response
//*		READRESPONSE_FAIL:
//*			If an error other then timeout occurred while reading the response
//*****************************************************************************
ReadResponseErros CTapi3Device::ReadResponse(
	char * szResponse, 
	int nResponseMaxSize,
	DWORD *pdwActualRead,
	DWORD dwTimeOut
	) const
{

	COMMTIMEOUTS to;
	char chNext;
	int nCharIdx;
	DWORD dwRead;
	
	_ASSERT(m_modemCommPortHandle);
	_ASSERT(szResponse);
	_ASSERT(pdwActualRead);

	::memset(szResponse,0,nResponseMaxSize);

	//Set the timeouts for the read operation.
	//Since we read 1 char at a time we use the TotalTimeoutMultiplier
	//To set the time we are willing to wait for the next char to show up.
	//We do not use the ReadIntervalTimeout and ReadTotalTimeoutConstants
	//since we read only 1 char at a time.
	//(see the documentation for COMMTIMEOUTS for a detailed description
	// of this mechanism).
	
	::GetCommTimeouts(m_modemCommPortHandle,&to);
	to.ReadIntervalTimeout=50; 
	to.ReadTotalTimeoutMultiplier=dwTimeOut;
	to.ReadTotalTimeoutConstant=0;
	::SetCommTimeouts(m_modemCommPortHandle,&to);


//	PurgeComm(hComm,PURGE_RXCLEAR);

	
	chNext=0;
	nCharIdx=0;
	*pdwActualRead=0;

	//Skip any CR or LF chars that might be left from the previous response.
		
	//read the next available input char. If it is #10 or #13 try reading another char.
	//otherwise get out of the loop and start processing the response (the char we just got
	//is the first char of the response).
	//If timeout is encountered or failure return the appropriate return code.
	do
	{
		if (!SynchReadFile(&chNext,1,&dwRead))
		{
			return READRESPONSE_FAIL;
		}
		if (!dwRead)
		{
			return READRESPONSE_TIMEOUT;
		}
	} while (chNext==10 || chNext==13);


	//Continue reading the actual response. 
	//The dwTimeout parameter specified how much time to wait for the 
	//start of the response. 
	//Once the first char of the response (past CR,LF) was read we go 
	//down to a usually lower timeout that will allow us to detect communication
	//errors sooner. (i.e. dwTimeOut will be 30 seconds after ATA but when reading the 
	//"CONNECT" response we do not want to use 30 seconds timeout between chars.)

	to.ReadIntervalTimeout=50;
	to.ReadTotalTimeoutMultiplier=0;
	to.ReadTotalTimeoutConstant=150; //this should be enough even for 300 bps DTE-DCE connection
	SetCommTimeouts(m_modemCommPortHandle,&to);
	//read all that response chars until the next #10 or #13
    do
	{
		//add the last read char to the response string
		szResponse[nCharIdx]=chNext;
		nCharIdx++;
		if (nCharIdx==nResponseMaxSize-1)
		{ //leave room for terminating NULL
			*pdwActualRead=nCharIdx;
			szResponse[nCharIdx]=0;
			return READRESPONSE_BUFFERFULL;
		}
		if (!SynchReadFile(&chNext,1,&dwRead))
		{
			return READRESPONSE_FAIL;
		}
		if (!dwRead)
		{
			return READRESPONSE_TIMEOUT;
		}
	}	while (chNext!=10 && chNext!=13);
	
	//response read successfully
	*pdwActualRead=nCharIdx;
	szResponse[nCharIdx]=0; //turn it into a null terminated string
	return READRESPONSE_SUCCESS;
}//CTapi3Device::ReadResponse



//*********************************************************************************
//* Name:	WaitForModemResponse
//* Author: Guy Merin / 09-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Wait for a specific response from the modem
//* PARAMETERS:
//*		[IN]  	LPCSTR szWantedResponse 
//*					response to wait for.
//*		[IN]	DWORD dwWantedResponseSize
//*					buffer size
//*		[IN]	const DWORD dwTimeout
//*					timeout in milliseconds 
//*	RETURN VALUE:
//*		NONE
//* REMARKS:
//*********************************************************************************
void CTapi3Device::WaitForModemResponse(LPCSTR szWantedResponse, DWORD dwWantedResponseSize, const DWORD dwTimeout) const
{
	::Sleep(100);

	ReadResponseErros readResponseStatus = READRESPONSE_SUCCESS;
	char response[MAX_DATA_RESPONSE];
	::ZeroMemory(response,sizeof(response));
	DWORD pdwActualRead = 0;
	

	DWORD dwStartTickCount = GetTickCount();
	DWORD dwDiffernceTickCount = 0;
	
	DWORD dwReminingTimeout = dwTimeout;


	while(dwDiffernceTickCount <= dwTimeout)
	{
		readResponseStatus = ReadResponse(
			response, 
			MAX_DATA_RESPONSE,
			&pdwActualRead,
			(dwReminingTimeout)
			);

		switch (readResponseStatus)
		{
		
		case READRESPONSE_SUCCESS:
			if (strncmp(response,szWantedResponse,dwWantedResponseSize) == 0)
			{
				return;
			}
			else
			{
				//DWORD
				//recalculate the new timeout and continue
				//
				dwDiffernceTickCount = GetTickDiff(dwStartTickCount);
				dwReminingTimeout = dwTimeout - dwDiffernceTickCount;
				continue;
			}
		
		case READRESPONSE_FAIL:
			throw CException(TEXT("CTapi3Device::WaitForModemResponse(), ReadResponse() return FAIL"));
			break;
		
		case READRESPONSE_BUFFERFULL:
			throw CException(TEXT("CTapi3Device::WaitForModemResponse(), ReadResponse() BUFFER_FULL"));
			break;
		
		case READRESPONSE_TIMEOUT:
		{
			throw CException(TEXT("CTapi3Device::WaitForModemResponse(), TIMEOUT"));
			break;
		}

		default:
			throw CException(
				TEXT("CTapi3Device::WaitForModemResponse(), ReadResponse() return unknown error %d"),
				readResponseStatus
				);
		}//switch
	}//while



	//
	//TIMEOUT
	//
	if (response)
	{
		throw CException(TEXT("CTapi3Device::WaitForModemResponse(), Timeout"));
	}
	else
	{
		throw CException(TEXT("CTapi3Device::WaitForModemResponse(), Timeout"));
	}
}



//*********************************************************************************
//* Name:	ClearCommInputBuffer
//* Author: Guy Merin / 09-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Clears the comm port TX(output) buffer
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		NONE
//* REMARKS:
//*		Call this function to clear the buffer before waiting for a specific 
//*		response.
//*********************************************************************************
void CTapi3Device::ClearCommInputBuffer() const
{
	_ASSERT(NULL != m_modemCommPortHandle);

	if (!PurgeComm(
		m_modemCommPortHandle,	// handle to communications resource
		PURGE_RXCLEAR			// action to perform
		))
	{
		throw CException(
			TEXT("%s(%d): CTapi3Device::ClearCommInputBuffer(), PurgeComm() failed, error code:%d"), 
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
	}

}//void CTapi3Device::ClearCommInputBuffer()



//*********************************************************************************
//* Name:	ReadData
//* Author: Guy Merin / 05-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		read data stream from modem using the ReadResponse function
//* PARAMETERS:
//*		[IN]	char * szResponse
//*					buffer to read into
//*		[IN]	int nResponseMaxSize
//*					size of buffer
//*		[IN]	const DWORD dwTimeout
//*					timeout to wait for the read operation
//*	RETURN VALUE:
//*		NONE
//* REMARKS:
//*		this function is a wrapper function for ReadResponse()
//*********************************************************************************
void CTapi3Device::ReadData(char * szResponse,int nResponseMaxSize,const DWORD dwTimeout) const
{
	DWORD pdwActualRead = 0;

	ReadResponseErros readResponseStatus = ReadResponse(
		szResponse, 
		nResponseMaxSize,
		&pdwActualRead,
		dwTimeout
		);
	
	if (READRESPONSE_SUCCESS != readResponseStatus)
	{
		switch (readResponseStatus)
		{
		
		case READRESPONSE_SUCCESS:
			return;
		
		case READRESPONSE_FAIL:
			throw CException(TEXT("CTapi3Device::ReadData(), ReadResponse() returned FAIL"));
		
		case READRESPONSE_BUFFERFULL:
			throw CException(TEXT("CTapi3Device::ReadData(), ReadResponse() returned buffer full"));
		
		case READRESPONSE_TIMEOUT:
			throw CException(TEXT("CTapi3Device::ReadData(), ReadResponse() returned TIMEOUT"));
		}
	}	

}//void CTapi3Device::ReadData()



//*********************************************************************************
//* Name:	SendData
//* Author: Guy Merin / 24-Sep-98
//*********************************************************************************
//* DESCRIPTION:
//*		Writes the specified command to the provided port followed by a carriage
//*		return character.
//* PARAMETERS:
//*		[IN]  	SynchFileHandle * pSynchFile:
//*					Pointer to a SynchFileHandle that holds the comm port handle
//*					to which the command is to be sent.
//*		[IN] 	const char const *szCommand:
//*					The command to send.
//*	RETURN VALUE:
//*		NONE
//*********************************************************************************
void CTapi3Device::SendData(const char *szCommand) const
{
	_ASSERT(m_modemCommPortHandle);
	_ASSERT(szCommand);


	OVERLAPPED ol_write;
	::ZeroMemory(&ol_write,sizeof(ol_write));
	SetOverlappedStruct(&ol_write);

	DWORD dwAct;
	int nCommandLen = strlen(szCommand);
	if (!::WriteFile(m_modemCommPortHandle,szCommand,nCommandLen,&dwAct,&ol_write))
	{
		DWORD dwLastError = ::GetLastError(); 
		if (ERROR_IO_PENDING == dwLastError)
		{
			//
			//OVERLAPPED IO was started
			//
			dwAct=0;
			BOOL bRes = ::GetOverlappedResult(m_modemCommPortHandle,&ol_write,&dwAct,TRUE);
			if (FALSE == bRes)
			{
				throw CException(TEXT("CTapi3Device::SendData(), GetOverlappedResult() failed"));
			}
		} 
		else
		{
			throw CException(TEXT("CTapi3Device::SendData(), WriteFile() failed, error code: %d"),dwLastError);
		}
	}
	if ( !CloseHandle(ol_write.hEvent) )
	{
		throw CException(
			TEXT("%s(%d): CTapi3Device::SendData(), CloseHandle() failed, error code:%d"), 
			TEXT(__FILE__),
			__LINE__,
			GetLastError()
			);
	}
}//CTapi3Device::SendData()


//*********************************************************************************
//* Name:	GetTickDiff
//* Author: Guy Merin / 25-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		calculates the differnce in miliseconds between now and dwStartTickTime
//* PARAMETERS:
//*		[IN]	const DWORD dwStartTickCount
//*					the start time to calculate the differnce from
//*	RETURN VALUE:
//*		differnce in miliseconds
//*	REMARKS:
//*		This function uses ::GetTickCount() and deals with possible wrap-around
//*********************************************************************************
DWORD CTapi3Device::GetTickDiff(const DWORD dwStartTickCount) 
{
	DWORD dwNowTickCount = ::GetTickCount();
	if (dwNowTickCount >= dwStartTickCount)
	{
		return (dwNowTickCount - dwStartTickCount);
	}
	else
	{
		return ( (0xffffffff - dwStartTickCount) + dwNowTickCount + 1);

	}

}//DWORD CTapi3Device::GetTickDiff()


//*********************************************************************************
//* Name:	GetFaxClass
//* Author: Guy Merin / 05-Apr-01
//*********************************************************************************
//* DESCRIPTION:
//*		TBD
//*********************************************************************************
void CTapi3Device::GetFaxClass(char* szResponse,DWORD dwSizeOfResponse)
{
	_ASSERT(m_modemCommPortHandle);

	
	//
	//send modem init command and wait for response
	//
	//ClearCommInputBuffer();
	//SendData(MODEM_INIT_AT__COMMAND);
	//WaitForModemResponse(MODEM_RESPONSE_TO_AT_COMMANDS,sizeof(MODEM_RESPONSE_TO_AT_COMMANDS),MODEM_RESPONSE_TIMEOUT);
	
	//
	//send echo off command and wait for response
	//echo is set to off so that every modem sent command wouldn't be queued at the
	// RX queue.
	//
	ClearCommInputBuffer();
	SendData(MODEM_ECHO_OFF__AT_COMMAND);
	WaitForModemResponse(MODEM_RESPONSE_TO_AT_COMMANDS,sizeof(MODEM_RESPONSE_TO_AT_COMMANDS),MODEM_RESPONSE_TIMEOUT);
	
	//
	//send to modem the AT+FCLASS=? command
	//
	ClearCommInputBuffer();
	SendData(MODEM_FCLASS_QUERY_AT__COMMAND);

	ReadResponseErros readResponseStatus = READRESPONSE_SUCCESS;
	char response[MAX_DATA_RESPONSE];
	::ZeroMemory(response,sizeof(response));
	DWORD pdwActualRead = 0;

	::Sleep(100);
	
	readResponseStatus = ReadResponse(
		response, 
		MAX_DATA_RESPONSE,
		&pdwActualRead,
		MODEM_RESPONSE_TIMEOUT
		);

	//USES_CONVERSION;
	//TCHAR* szTmpString= (TCHAR*) malloc(sizeof(TCHAR)*dwSizeOfResponse);
	//if (NULL == szTmpString)
	//{
		//throw CException(TEXT("CTapi3Device::GetFaxClass(), Out of memory"));
	//}

	switch (readResponseStatus)
	{
		case READRESPONSE_SUCCESS:

			//
			//A2T allocates on the stack, so we need to copy into the dest string
			//

			//szTmpString = A2T(response);
			strncpy(szResponse, response,dwSizeOfResponse);
			break;
		
		case READRESPONSE_TIMEOUT:
		{
			throw CException(TEXT("CTapi3Device::GetFaxClass(), TIMEOUT"));
			break;
		}

	}

}//TCHAR* CTapi3Device::GetFaxClass(void)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\tapitools\tapidevice\queueeventitem.h ===
//QueueEventItem.h
#ifndef QUEUE_EVENT_ITEM_H_
#define QUEUE_EVENT_ITEM_H_



class TapiEventItem
{
private:
	TAPI_EVENT m_tapiEventId;
	IDispatch *m_pEvent;
public:
	TapiEventItem(TAPI_EVENT tapiEvent,IDispatch *pEvent):
		m_pEvent(pEvent),
		m_tapiEventId(tapiEvent)
	{	
		if (NULL != m_pEvent)
		{
			m_pEvent->AddRef();
		}
	}

	~TapiEventItem()
	{
		m_tapiEventId = (TAPI_EVENT) -1;
		if (NULL != m_pEvent)
		{
			m_pEvent->Release();
		}
		m_pEvent = NULL;
	}

	TAPI_EVENT GetTapiEventID(void)
	{
		return (m_tapiEventId);
	}

	IDispatch *GetEvent(void)
	{
		ULONG ref = m_pEvent->AddRef();
		return (m_pEvent);
	}


};




#endif //QUEUE_EVENT_ITEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\tapitools\querymodemcaps\main.cpp ===
#include <tapi3.h>
#include <windows.h>
#include <atlbase.h>
#include <tchar.h>
#include <assert.h>
#include <stdio.h>
#include <Shellapi.h>

#include <autorel.h>
#include <smrtptrs.h>
#include "main.h"

R<ITTAPI> g_pTapi;


/*********************************************************************/
/*Function Name:	Usage
/*Date:				12/8/99
/*Developer:		Guy Merin(guym)
/*********************************************************************/
/*Description:
/*	Print the usage banner
/*Parameters:
/*	NONE
/*Return Value:
/*	NONE
/*********************************************************************/
void Usage()
{
	printf("\nUsage:\n");

	printf("ModemCaps.exe <Tapi Device ID> :Query if the modem supports Fax and adaptive answering\n");
	printf("\nModemCaps.exe -?      :This message");
	printf("\nModemCaps.exe -list   :List all Unimodem Devices\n");

	::exit(-1);

}

/*********************************************************************/
/*Function Name:	main
/*Date:				12/8/99
/*Developer:		Guy Merin(guym)
/*********************************************************************/
/*Description:
/*	main function
/*Parameters:
/*	command line params
/*Return Value:
/*	application exit code
/*********************************************************************/
void __cdecl main (int argc, char ** argvA)
{
	if (2 != argc)
	{
		Usage();
	}
		
	TCHAR **argv;
#ifdef UNICODE
	UNREFERENCED_PARAMETER(argvA);
	argv = CommandLineToArgvW( GetCommandLine(), &argc );		
	if (NULL == argv)
	{
		printf("INTERNAL ERROR: CommandLineToArgvW failed - %d\n",::GetLastError());
		::exit(-1);
	}
#else
	argv = argvA;
#endif

	if ( (0 == _tcscmp(argv[1],TEXT("-?"))) || (0 == _tcscmp(argv[1],TEXT("/?"))) || (0 == _tcscmp(argv[1],TEXT("?"))) )
	{
		Usage();
	}

	if ( (0 == _tcscmp(argv[1],TEXT("-list"))) || (0 == _tcscmp(argv[1],TEXT("/list"))) || (0 == _tcscmp(argv[1],TEXT("list"))) )
	{
		ListAllDevices();
		::exit(0);
	}


	DWORD dwDeviceID = _ttoi(argv[1]);


	InitComAndTapi();


	
	R<ITAddress> pITAddress;
	GetAddressFromTapiID(dwDeviceID,&pITAddress);

	
	//
	//get the name of the device for echoing reasons
	//
	CComBSTR bstrAddressName;
	HRESULT hr = pITAddress->get_AddressName(&bstrAddressName);
	if (FAILED(hr))
	{
		printf("INTERNAL ERROR: ITAddress::get_AddressName() failed - 0x%08x\n",hr);
		::exit(-1);
	}


	if (false == IsDeviceUnimodemTSP(pITAddress))
	{
		//
		// The device isn't a unimodem device, exit
		//
		printf("INTERNAL ERROR: device:\"%S\" #%d, isn't a Unimodem Device\n",bstrAddressName,dwDeviceID);
		ShutdownTapi();
		::exit(-1);
	}
	
	printf("Device:\"%S\" TapiID #%d\n",bstrAddressName,dwDeviceID);
	
	//
	//check if device supports fax
	//
	QueryFaxCapabilityOfModem(pITAddress);

	//
	//check if device supports adaptive answering
	//
	QueryAdaptiveAnswering(pITAddress);

	ShutdownTapi();

}



/*********************************************************************/
/*Function Name:	ListAllDevices
/*Date:				12/8/99
/*Developer:		Guy Merin(guym)
/*********************************************************************/
/*Description:
/*	list all tapi devices which are unimodem devices 
/*	(unimodem tsp as the provider)
/*Parameters:
/*	NONE
/*Return Value:
/*	NONE
/*********************************************************************/
void ListAllDevices()
{
	InitComAndTapi();

	//
	//enum the addresses and find device ID m_dwId
	//

	R<IEnumAddress> pEnumAddress;

	HRESULT hr = g_pTapi->EnumerateAddresses(&pEnumAddress);
	if FAILED(hr)
	{
		printf("INTERNAL ERROR: ITTAPI::EnumerateAddresses() failed, error code:0x%08x\n",hr);
		::exit(-1);
	}

	int iDeviceIndex = 0;

	//
	// Now we're running on all Tapi Devices
	// If the device is Unimodem device (unimodem tsp) we print it
	//
	while(TRUE)
	{
		R<ITAddress> pAddress;

		//
		//get the next address
		//
		hr = pEnumAddress->Next(1, &pAddress, NULL);
		if (S_OK == hr)
		{
			
			if (IsDeviceUnimodemTSP(pAddress))
			{
				//
				//device is a Unimodem device so print it
				//
				CComBSTR bstrAddressName;

				hr = pAddress->get_AddressName(&bstrAddressName);
				if (FAILED(hr))
				{
					printf("INTERNAL ERROR: ITAddress::get_AddressName() failed - 0x%08x\n",hr);
					::exit(-1);
				}

				printf("Device #%d is:%S\n",iDeviceIndex,bstrAddressName);
			}

			iDeviceIndex++;
			continue;
		}
		else if (S_FALSE == hr)
		{
			//
			//no more devices
			//
			break;
		}
		else
		{
			//
			//another error
			//
			printf("INTERNAL ERROR: IEnumAddress::Next() failed, error code:0x%08x\n",hr);
			::exit(-1);
		}
	}
		
	ShutdownTapi();
}






/*********************************************************************/
/*Function Name:	InitComAndTapi
/*Date:				12/8/99
/*Developer:		Guy Merin(guym)
/*********************************************************************/
/*Description:
/*	Init com (CoInitializeEx) and Tapi(CoCreateInstance)
/*Parameters:
/*	NONE
/*Return Value:
/*	NONE
/*Remarks:
/*	This function sets the global variable g_pTapi
/*********************************************************************/
void InitComAndTapi()
{
	assert((ITTAPI*) NULL == g_pTapi);
	
	
	//
	//CoInit Com
	//
	HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
	if (FAILED(hr))
	{
		printf("INTERNAL ERROR: CoInitializeEx() failed, error:0x%08x\n",hr);
		::exit(-1);
	}
	
	//
	//Create Tapi Object and init it
	//
	hr = CoCreateInstance(
		CLSID_TAPI,
		NULL,
		CLSCTX_INPROC_SERVER,
		IID_ITTAPI,
		(LPVOID *)&g_pTapi
		);
    if FAILED(hr)
	{
		printf("INTERNAL ERROR: CoCreateInstance() on TAPI failed, error code:0x%08x\n",hr);
		::exit(-1);
	}
	assert((ITTAPI*) NULL != g_pTapi);

	hr = g_pTapi->Initialize();
	if FAILED(hr)
	{
		printf("INTERNAL ERROR: ITTAPI::Initialize() failed, error code:0x%08x\n",hr);
		::exit(-1);
	}
}



/*********************************************************************/
/*Function Name:	ShutdownTapi
/*Date:				12/8/99
/*Developer:		Guy Merin(guym)
/*********************************************************************/
/*Description:
/*	Shuts down tapi
/*Parameters:
/*	NONE
/*Return Value:
/*	NONE
/*********************************************************************/
void ShutdownTapi()
{
	//
	//shut down Tapi
	//
	g_pTapi->Shutdown();
}




/*********************************************************************/
/*Function Name:	DisconnectCall
/*Date:				12/8/99
/*Developer:		Guy Merin(guym)
/*********************************************************************/
/*Description:
/*	disconnects the active call
/*Parameters:
/*	ITBasicCallControl *pBasicCallControl
/*		Call object to disconnect
/*Return Value:
/*	NONE
/*********************************************************************/
void DisconnectCall(ITBasicCallControl *pBasicCallControl)
{

    HRESULT hr = pBasicCallControl->Disconnect(DC_NORMAL);
	if (FAILED(hr))
    {
    	printf("INTERNAL ERROR: ITBasicCallControl::Disconnect(DC_NORMAL) failed - 0x%08x\n",hr);
		::exit(-1);
    }
}








/*********************************************************************/
/*Function Name:	QueryAdaptiveAnswering
/*Date:				12/8/99
/*Developer:		Guy Merin(guym)
/*********************************************************************/
/*Description:
/*	This function checks if the given device supports adaptive answering
/*Parameters:
/*	ITAddress *pAddress
/*		The device address to query
/*Return Value:
/*	NONE
/*********************************************************************/
void QueryAdaptiveAnswering(ITAddress *pAddress)
{
    //
    // Get the friendly name of the device.
    //
    CComBSTR bstrAddressName;

    HRESULT hr = pAddress->get_AddressName(&bstrAddressName);
	if (FAILED(hr))
    {
    	printf("INTERNAL ERROR: ITAddress::get_AddressName() failed - 0x%08x\n",hr);
        ::exit(-1);
    }

	//
	//Query through the registry if the device supports adaptive answering
	//
	RegistryQueryAdaptiveAnswering(bstrAddressName);

}



/*********************************************************************/
/*Function Name:	QueryAdaptiveAnswering
/*Date:				12/8/99
/*Developer:		Guy Merin(guym)
/*********************************************************************/
/*Description:
/*	This function check if the given device is a UniModem device
/*Parameters:
/*	ITAddress *pAddress
/*		The device address to query
/*Return Value:
/*	True
/*		Device is a Unimodem device
/*	False
/*		Device is not a Unimodem device
/*********************************************************************/
bool IsDeviceUnimodemTSP(ITAddress *pAddress)
{
	//
    // Get the TSP name of the device.
    //
    CComBSTR bstrAddressProviderName;

    HRESULT hr = pAddress->get_ServiceProviderName(&bstrAddressProviderName);
    if (FAILED(hr))
    {
    	printf("INTERNAL ERROR: ITAddress::get_ServiceProviderName() failed - 0x%08x\n",hr);
        ::exit(-1);
    }

    if (0 == _tcscmp(bstrAddressProviderName, UNIMODEM_TSP_NAME))
    {
        return true;
	}
	return false;
}




/*********************************************************************/
/*Function Name:	GetAddressFromTapiID
/*Date:				12/8/99
/*Developer:		Guy Merin(guym)
/*********************************************************************/
/*Description:
/*	This function returns a device address object according to it's TapiID
/*Parameters:
/*	DWORD dwId
/*		The deviceID to find
/*	ITAddress **pAddress
/*		The returned device address
/*Return Value:
/*	NONE
/*********************************************************************/
void GetAddressFromTapiID(DWORD dwId,
						 ITAddress** ppAddress)
{
	_ASSERT((ITTAPI*) NULL != g_pTapi);

	//
	//enum the addresses and find device ID dwId
	//

	R<IEnumAddress> pEnumAddress;

	HRESULT hr = g_pTapi->EnumerateAddresses(&pEnumAddress);
	if FAILED(hr)
	{
		printf("INTERNAL ERROR: ITTAPI::EnumerateAddresses() failed, error code:0x%08x\n",hr);
		::exit(-1);
	}

	
	//
	//skip to the desired tapi deviceID
	//
	hr = pEnumAddress->Skip(dwId); 
	if FAILED(hr)
	{
		printf("INTERNAL ERROR: IEnumAddress::Skip() failed, error code:0x%08x\n",hr);
		::exit(-1);
	}
	
	//
	//get the desired address
	//
	ULONG cAddresses;
	hr = pEnumAddress->Next(1, ppAddress, &cAddresses);
	if (S_FALSE == hr)
	{
		//
		//Device not found
		//
		printf("INTERNAL ERROR: Device with TapiID #%d was not found\n",dwId);
		::exit(-1);
	}
	assert(1 == cAddresses);
	if FAILED(hr)
	{
		printf("INTERNAL ERROR: IEnumAddress::Next() failed, error code:0x%08x\n",hr);
		::exit(-1);
	}

}





/*********************************************************************/
/*Function Name:	QueryFaxCapabilityOfModem
/*Date:				12/8/99
/*Developer:		Guy Merin(guym)
/*********************************************************************/
/*Description:
/*	This function checks if the claims to have fax capabilities
/*  The function does not check it through Tapi API
/*	The verification is made through sending fax query AT commands
/*Parameters:
/*	ITAddress *pAddress
/*		The device address to query
/*Return Value:
/*	NONE
/*********************************************************************/
void QueryFaxCapabilityOfModem(ITAddress *pAddress)
{
    //
    // Retrieve the ITAddressCapabilities of the address.
    //
    R<ITAddressCapabilities> pAddressCaps;

    HRESULT hr = pAddress->QueryInterface(
                        IID_ITAddressCapabilities,
                        (LPVOID *)&pAddressCaps);
	if (FAILED(hr))
    {
    	printf("INTERNAL ERROR: ITAddress::QueryInterface(IID_ITAddressCapabilities), failed 0x%08x\n",hr);
        ::exit(-1);
    }

    //
    // Retrieve the bearer modes of the address.
    //
    LONG lBearerModes;

    hr = pAddressCaps->get_AddressCapability(AC_BEARERMODES, &lBearerModes);
	if (FAILED(hr))
    {
    	printf("INTERNAL ERROR: ITAddressCapabilities::get_AddressCapability(AC_BEARERMODES) failed - 0x%08x\n",hr);
        ::exit(-1);
    }

    
	//
    // If the device does not support passthrough and voice bearer modes,
    // it means it is not a modem device.
    //
    if ((lBearerModes & (LINEBEARERMODE_PASSTHROUGH | LINEBEARERMODE_VOICE)) !=
        (LINEBEARERMODE_PASSTHROUGH | LINEBEARERMODE_VOICE))
    {
		//
		// Device doesn't support passthrough or voice bearer modes
		//
		CComBSTR bstrAddressName;

		hr = pAddress->get_AddressName(&bstrAddressName);
		if (FAILED(hr))
		{
			printf("INTERNAL ERROR: ITAddress::get_AddressName() failed - 0x%08x\n",hr);
			::exit(-1);
		}

        printf("INTERNAL ERROR: Device(%S) does not support Passthrough bearer mode or Voice bearer mode\n",bstrAddressName);
		::exit(-1);
    }

	
    //
    // Device supports passthrough
	// create a call object, and set as passthrough mode and send the fax class query commands (AT)
    //
    R<ITBasicCallControl> pBasicCallControl;

    hr = pAddress->CreateCall(NULL,
                              LINEADDRESSTYPE_PHONENUMBER,
                              TAPIMEDIATYPE_DATAMODEM,
                              &pBasicCallControl);
    if (FAILED(hr))
    {
    	printf("INTERNAL ERROR: ITBasicCallControl::CreateCall() failed - 0x%08x\n",hr);
        ::exit(-1);
    }

    //
    // Get the call info object of the call.
    //
    R<ITCallInfo> pCallInfo;

    hr = pBasicCallControl->QueryInterface(IID_ITCallInfo, (LPVOID*)&pCallInfo);
    if (FAILED(hr))
    {
    	printf("INTERNAL ERROR: ITBasicCallControl:QueryInterface(IID_ITCallInfo) failed - 0x%08x\n",hr);
        ::exit(-1);
    }

    //
    // Set the bearer mode to passthrough.
    //
    hr = pCallInfo->put_CallInfoLong(CIL_BEARERMODE,
                                     LINEBEARERMODE_PASSTHROUGH);
	if (FAILED(hr))
    {
    	printf("INTERNAL ERROR: ITCallInfo->put_CallInfoLong(CIL_BEARERMODE, LINEBEARERMODE_PASSTHROUGH) failed - 0x%08x\n",hr);
        ::exit(-1);
    }

    //
    // Connect the call.
    //
    hr = pBasicCallControl->Connect(TRUE);
	if (FAILED(hr))
    {
    	printf("INTERNAL ERROR: ITBasicCallControl::Connect(TRUE) failed - 0x%08x\n",hr);
        ::exit(-1);
    }

	//
	//call in passthrough mode
	//

    //
    // Get the device ID, this includes an open file handle to the modem's
    // COM port and the device name ANSI string. First get the legacy call
    // media control object.
    //
    R<ITLegacyCallMediaControl> pLegacyCallMediaControl;

    hr = pBasicCallControl->QueryInterface(IID_ITLegacyCallMediaControl,
                                           (LPVOID*)&pLegacyCallMediaControl);
    if (FAILED(hr))
    {
    	printf("INTERNAL ERROR: ITBasicCallControl::QueryInterface(IID_ITLegacyAddressMediaControl), failed - 0x%08x\n",hr);
        DisconnectCall(pBasicCallControl);
        ::exit(-1);
    }

    //
    // Get the device ID.
    //
    CComBSTR bstrDeviceClass("comm/datamodem");
    P<DEVICE_ID> pDeviceId;
    DWORD dwSize = 0;

    hr = pLegacyCallMediaControl->GetID(bstrDeviceClass,
                                        &dwSize,
                                        (PBYTE*)&pDeviceId);
	if (FAILED(hr))
    {
    	printf("INTERNAL ERROR: ITLegacyCallMediaControl::GetID(%S) failed - 0x%08x\n",bstrDeviceClass,hr);
        DisconnectCall(pBasicCallControl);
        ::exit(-1);
    }

    //
    // Write "at+fclass=?" to the modem.
    //
    hr = SynchWriteFile(pDeviceId->hComm,
                        MODEM_CLASS_QUERY_STRING,
                        MODEM_CLASS_QUERY_STRING_LENGTH,
                        &dwSize);
	if (FAILED(hr))
    {
    	printf("INTERNAL ERROR: SynchWriteFile failed - 0x%08x\n",hr);
        CloseHandle(pDeviceId->hComm);
        DisconnectCall(pBasicCallControl);
        ::exit(-1);
    }

    _ASSERT(MODEM_CLASS_QUERY_STRING_LENGTH == dwSize);

    //
    // Get the modem response.
    //
    BOOL fReadAgain = FALSE;
    char abClassResp[32];

    do
    {
        hr = ReadModemResponse(pDeviceId->hComm,
                               abClassResp,
                               sizeof(abClassResp),
                               &dwSize,
                               1000);
		if (FAILED(hr))
        {
        	printf("INTERNAL ERROR: ReadModemResponse() failed - 0x%08x\n",hr);
            CloseHandle(pDeviceId->hComm);
            DisconnectCall(pBasicCallControl);
            ::exit(-1);
        }
        //
        // It is possible that the modem is in echo mode. In this case, the
        // read string would be "at+fclass=?", without the '\r' as the last
        // character in the string. So if we read "at+fclass=?", we assume
        // that the modem is in echo mode and read once again from the modem.
        //
        fReadAgain = !fReadAgain &&
                     (strncmp(abClassResp,
                              MODEM_CLASS_QUERY_STRING,
                              MODEM_CLASS_QUERY_STRING_LENGTH - 1) == 0) &&
                     (abClassResp[MODEM_CLASS_QUERY_STRING_LENGTH] == '\0');
    } while (fReadAgain);

	
	//
	// We no longer need the call object
	//
	CloseHandle(pDeviceId->hComm);
    DisconnectCall(pBasicCallControl);

    //
    // Parse the modem response and decide whether or not the modem
    // supports fax.
    //
    BOOL fFaxCapable = FALSE;

    hr = IsFaxCapable(abClassResp, &fFaxCapable);
    if (FAILED(hr))
    {
        printf("INTERNAL ERROR: IsFaxCapable() failed - 0x%08x\n",hr);
        ::exit(-1);
    }

    printf("The Modem responded to \"AT+FCLASS=?\" with:\"%s\"\n\n",abClassResp);
	if (fFaxCapable)
    {
        //
        // modem supports fax
        //
		printf("The Modem claims to support Fax\n");
    }
	else
	{
		printf("The Modem claims it does not support Fax\n");
	}


    
}





/*********************************************************************/
/*Function Name:	RegistryQueryAdaptiveAnswering
/*Date:				12/8/99
/*Developer:		Guy Merin(guym)
/*********************************************************************/
/*Description:
/*	This function checks if the given device supports adaptive answering
/*	in it's INF file(through the registry)
/*Parameters:
/*	BSTR szFriendlyName
/*		The device name to query
/*Return Value:
/*	NONE
/*********************************************************************/
void RegistryQueryAdaptiveAnswering(BSTR szFriendlyName)
{
	
	
	LONG    Rslt;
    DWORD   Index = 0;
    DWORD   MaxSubKeyLen;
	DWORD   SubKeyCount;
    LPTSTR  SubKeyName = NULL;

	HKEY    hSubKey = NULL;
	HKEY	hkDeviceKey = NULL;
	HKEY	hkAdaptiveKey = NULL;
	
	Rslt = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        REG_UNIMODEM,
        0,
        KEY_READ,
        &hSubKey
        );
    if (Rslt != ERROR_SUCCESS)
	{
		//
        // could not open the registry key
        //
        printf("INTERNAL ERROR: RegOpenKeyEx() failed, error=%d", Rslt);
        goto exit;
    }
	
	
	//
	//Run through all the sons
	//
	
	//
	//first let's find out how many sons it has
	//
	Rslt = RegQueryInfoKey(
        hSubKey,
        NULL,
        NULL,
        NULL,
        &SubKeyCount,
        &MaxSubKeyLen,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL
        );
    if (Rslt != ERROR_SUCCESS) {
        //
        // could not open the registry key
        //
        printf("INTERNAL ERROR: RegQueryInfoKey() failed, error=%d", Rslt);
        goto exit;
    }

	//
	// We will append to the key string, the adaptive answering keys
	// so we need to add a place for them
	//
	MaxSubKeyLen += REG_FAX_ADAPTIVE_SIZE;

    SubKeyName = (LPTSTR) malloc ( (MaxSubKeyLen+1) * sizeof(TCHAR) );
    if (!SubKeyName) {
        printf("INTERNAL ERROR: malloc() failed\n");
		goto exit;
    }


	//
	//now let's enum each son
	//
	while( TRUE )
	{
        Rslt = RegEnumKey(
            hSubKey,
            Index,
            (LPTSTR) SubKeyName,
            MaxSubKeyLen
            );
        if (Rslt != ERROR_SUCCESS)
		{
            if (Rslt == ERROR_NO_MORE_ITEMS)
			{
                break;
            }
            printf("INTERNAL ERROR: RegEnumKey() failed, error=%d", Rslt);
            goto exit;
        }
		
		
		//
		//Is this the desired device?
		//
		Rslt = RegOpenKeyEx(
			hSubKey,
			SubKeyName,
			0,
			KEY_READ,
			&hkDeviceKey
			);
		if (Rslt != ERROR_SUCCESS)
		{
			//
			// could not open the registry key
			//
			printf("INTERNAL ERROR: RegOpenKeyEx() failed, error=%d", Rslt);
			goto exit;
		}

		TCHAR szDeviceFriendlyName[1024];
		DWORD dwBufferSize = sizeof(szDeviceFriendlyName);
		
		Rslt = RegQueryValueEx(
			hkDeviceKey,
			REG_FRIENDLY_NAME,
			NULL,
			NULL,
			(LPBYTE) szDeviceFriendlyName,
			&dwBufferSize
			);
		if (Rslt != ERROR_SUCCESS)
		{
			//
			// could not query the registry key
			//
			printf("INTERNAL ERROR: RegQueryValueEx() failed, error=%d", Rslt);
			goto exit;
		}

		if (0 != (_tcscmp(szFriendlyName,szDeviceFriendlyName)))
		{
			//
			// this is not the wanted device, enumrate to the next device
			//
			RegCloseKey(hkDeviceKey);
			hkDeviceKey = NULL;
			Index++;
			continue;
		}

		
		
		//
		//the wanted device was found, check if it supports adaptive answering
		//

		//
		//append the adaptive answering keys to the child key string
		//
		_tcscat(SubKeyName,REG_FAX_ADAPTIVE);
		

		//
		//try to open the key, if succeded, the device has adaptive keys
		//
		Rslt = RegOpenKeyEx(
			hSubKey,
			SubKeyName,
			0,
			KEY_READ,
			&hkAdaptiveKey
			);
		
		//
		//free all the resources
		//
		if (hSubKey)
		{
			RegCloseKey( hSubKey );
			hSubKey = NULL;
		}
		if (hkDeviceKey)
		{
			RegCloseKey( hkDeviceKey );
			hkDeviceKey = NULL;
		}
		if (hkAdaptiveKey)
		{
			RegCloseKey( hkAdaptiveKey );
			hkAdaptiveKey = NULL;
		}

		//
		//check if the device supports adaptive answering according to the success / failure of RegOpen
		//
		if (ERROR_SUCCESS == Rslt)
		{
			//
			//key found
			//
			printf("The Modem claims to support Class1 Adaptive Answering\n");
			return;
		}
		else if (ERROR_FILE_NOT_FOUND == Rslt)
		{
			//
			//key doesn't exist
			//
			printf("The Modem claims it does not support Class1 Adaptive Answering\n");
			return;
		}
		else
		{
			//
			//another error
			//
			printf("INTERNAL ERROR: RegOpenKeyEx() failed, error=%d", Rslt);
			::exit(-1);
		}
	}
	printf("INTERNAL ERROR: The wanted device(%S) wasn't found\n", szFriendlyName);
	assert(-1);

exit:
    if (hSubKey)
	{
        RegCloseKey( hSubKey );
    }
	if (hkDeviceKey)
	{
        RegCloseKey( hkDeviceKey );
    }
	if (hkAdaptiveKey)
	{
        RegCloseKey( hkAdaptiveKey );
    }
	::exit(-1);
}


/*********************************************************************/
/*Function Name:	SynchWriteFile
/*Date:				Unknown
/*Developer:		Boaz Feldbaum(boazf), stolen by: Guy Merin(guym)
/*********************************************************************/
/*Description:
/*	This function writes synchronously to a COM port that was opened
/*	with FILE_FLAG_OVERLAPPED. This type of handle is returned by
/*	ITLegacyCallMediaControl::GetID().
/*Parameters:
/*	HANDLE hFile
/*		A handle to the COM port of the modem.
/*	LPCVOID lpBuffer
/*		A pointer to a buffer the bytes to be written.
/*	DWORD nNumberOfBytesToRead
/*		The Amount of bytes to write.
/*	LPDWORD lpNumberOfBytesRead 
/*		A pointer to a DWORD the receives the number of 
/*		bytes that were actually written to the COM port
/*Return Value:
/*	If the function succeeds, the return value is S_OK, else the return
/*	value is an error code.
/*********************************************************************/
static HRESULT SynchWriteFile(
    HANDLE hFile,
    LPCVOID lpBuffer,
    DWORD nNumberOfBytesToWrite,
    LPDWORD lpNumberOfBytesWritten)
{

    _ASSERT(lpBuffer);
    _ASSERT(lpNumberOfBytesWritten);

    //
    // Create an event for the overlapped structure.
    //
    CAutoCloseHandle hEvent;

    hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (hEvent == NULL)
    {
        printf("INTERNAL ERROR: CreateEvent() failed - 0x%08x\n",GetLastError());
        return E_OUTOFMEMORY;
    }

    //
    // Prepare the overlapped structure.
    //
    OVERLAPPED overlapped;

    memset(&overlapped, 0, sizeof(OVERLAPPED));
    overlapped.hEvent=hEvent;

    //
    // Make sure the event is in reset state before we begin
    //
    if (!ResetEvent(overlapped.hEvent))
    {
        printf("INTERNAL ERROR: ResetEvent() failed - %d\n",GetLastError());
        return E_OUTOFMEMORY;
    }

    //
    // Write the buffer.
    //
    if (!WriteFile(hFile,
                   lpBuffer,
                   nNumberOfBytesToWrite,
                   lpNumberOfBytesWritten,
                   &overlapped))
    {
        if (GetLastError()==ERROR_IO_PENDING)
        {
            //
            //Overlapped I/O was started.
            //
            *lpNumberOfBytesWritten=0;
            if (!GetOverlappedResult(hFile,
                                     &overlapped,
                                     lpNumberOfBytesWritten,
                                     TRUE))
            {
                printf("INTERNAL ERROR: GetOverlappedResult() failed - %d\n",GetLastError());
                return E_OUTOFMEMORY;
            }
        }
        else
        {
            //
            // Write operation failed
            //
            printf("INTERNAL ERROR: WriteFile() failed - %d\n",GetLastError());
            return E_OUTOFMEMORY;
        }
    }

    return S_OK;
}

/*********************************************************************/
/*Function Name:	ReadModemResponse
/*Date:				Unknown
/*Developer:		Boaz Feldbaum(boazf), stolen by: Guy Merin(guym)
/*********************************************************************/
/*Description:
/*	The function receives a response string from the modem. First it skips
/*      carriage return and new line characters, then it receives a string until
/*      a carriage return or a new line character is received. All the non
/*      carriage return and non new line characters are placed in szResponse.
/*      If no character is received within the timeout period, the function
/*      returns with S_OK, and *pdwActualRead is set to zero.
/*Parameters:
/*	HANDLE hFile
/*		The file handle to the modem COM port
/*	CHAR* szResponse
/*		A pointer toa buffer that receives the modem response
/*	int nResponseMaxSize
/*		The size in bytes of szResponse.
/*	DWORD pdwActualRead
/*		The number of bytes that were written in szResponse.
/*	DWORD dwTimeOut
/*		A timeout period in milliseconds to wait until the first
/*		characters are received from the modem.
/*Return Value:
/*	If the function succeeds, the return value is S_OK, else the return
/*      value is an error code.
/*********************************************************************/
static HRESULT ReadModemResponse(
    HANDLE hFile,
    CHAR *szResponse,
    int nResponseMaxSize,
    DWORD *pdwActualRead,
    DWORD dwTimeOut)

{
    
    COMMTIMEOUTS CommTimeOuts;
    char chNext = 0;
    int nCharIdx = 0;
    DWORD dwRead;
    HRESULT hr;

    _ASSERT(hFile);
    _ASSERT(szResponse);
    _ASSERT(pdwActualRead);

    //
    // Zero out the response buffer.
    //
    memset(szResponse, 0, nResponseMaxSize);

    //
    // Set the timeouts for the read operation.
    // Since we read 1 char at a time, we use the TotalTimeoutMultiplier
    // To set the time we are willing to wait for the next char to show up.
    // We do not use the ReadIntervalTimeout and ReadTotalTimeoutConstants
    // since we read only 1 char at a time.
    // (see the documentation for COMMTIMEOUTS for a detailed description
    // of this mechanism).
    //
    if (!GetCommTimeouts(hFile, &CommTimeOuts))
    {
        printf("INTERNAL ERROR: GetCommTimeouts failed - %d\n",GetLastError());
        return E_OUTOFMEMORY;
    }

    CommTimeOuts.ReadIntervalTimeout = 50;
    CommTimeOuts.ReadTotalTimeoutMultiplier = dwTimeOut;
    CommTimeOuts.ReadTotalTimeoutConstant = dwTimeOut;

    if (!SetCommTimeouts(hFile, &CommTimeOuts))
    {
        printf("INTERNAL ERROR: SetCommTimeouts failed - %d\n",GetLastError());
        return E_OUTOFMEMORY;
    }


    *pdwActualRead=0;

    //
    // Skip any CR or LF chars that might be left from the previous response.
    //

    //
    // Read the next availble input char. If it is CR or LF, try reading another
    // char. Otherwise get out of the loop and start processing the response
    // (the char we just got is the first char of the response). If timeout
    // is encountered or failure, return with an appropriate return code.
    //
    do
    {
        hr = SynchReadFile(hFile, &chNext, 1, &dwRead);
        if (FAILED(hr))
        {
            printf("INTERNAL ERROR: SynchReadFile failed - 0x%08x\n", hr);
            return hr;
        }

        if (0 == dwRead)
        {
            //
            // Timeout
            //
            return S_OK;
        }
    } while ((chNext == '\r') || (chNext == '\n'));

    //
    // Read all the response chars until the next CR or LF
    //
	nCharIdx = 0;
    do
    {
        //
        // Add the last read char to the response string.
        //
        szResponse[nCharIdx] = chNext;
        nCharIdx++;
        if (nCharIdx == nResponseMaxSize - 1)
        {
            //
            // Leave room for terminating NULL
            //
            *pdwActualRead = nCharIdx;

            return S_OK;
        }

        //
        // Get the next character.
        //
        hr = SynchReadFile(hFile, &chNext, 1, &dwRead);
        if (FAILED(hr))
        {
            printf("INTERNAL ERROR: SynchReadFile failed - 0x%08x\n", hr);
            return hr;
        }

        if (0 == dwRead)
        {
            //
            // Timeout
            //
            return S_OK;
        }
    }   while ((chNext != '\r') && (chNext != '\n'));

    //
    // Response read successfully
    //
    *pdwActualRead=nCharIdx;

    return S_OK;
}


//
// Function:
//      IsFaxCapable
//
// Parameters:
//      szClassResp - The string that the mode reponded to "at+fclass=?"
//      pfFaxCapable - A pointer to a BOOL variable that receives TRUE
//          if the string in szClassResp indicates that the modem supports
//          fax.
//
// Returned Value:
//      If the function succeeds, the return value is S_OK, else the return
//      value is an error code.
//
// Description:
//      The function parses the string that the modem responded to
//      "at+fclass=?" and decids whether or not the modem supports fax.
//
static HRESULT IsFaxCapable(
    LPCSTR szClassResp,
    BOOL *pfFaxCapable)
{
    
    LPCSTR p = szClassResp;
    int iLowClass = -1;
    int iCurrClass = -1;
    int iExp;

    //
    // First set the result to FALSE.
    //
    *pfFaxCapable = FALSE;

    if (_stricmp(szClassResp, MODEM_ERROR_RESPONSE_STRING) == 0)
    {
        //
        // The modem does not support at+fclass=?. This means also
        // that the modem does not support fax.
        //

        return S_OK;
    }

    //
    // Traverse the reponce string of the modem.
    //
    for (p = szClassResp; *p; p++)
    {
        CHAR ch = *p;

        if (('0' <= ch) && (ch <= '9'))
        {
            //
            // Calculate the class number. The class number may have the
            // following formats:
            //      Any integer number with any number of digits.
            //      Any floating point number with any number of
            //          digits before and after the decimal point.
            // Not all the above formats may represent a valid class
            // number however the code below is general enough to handle
            // any type of format. However, we're interested only in the
            // part before the decimal point. the part after the decimal
            // point does not make any difference to the media type.
            //
            iCurrClass = ch - '0';
            iExp = 1;

            //
            // Calculate the class number from the rest of the characters.
            //
            ch = *(p+1);
            for (;;)
            {
                if (('0' <= ch) && (ch <= '9'))
                {
                    //
                    // Accumulate the class number digits as long we're left
                    // from the the decimal digit.
                    //
                    if (iExp == 1)
                    {
                        iCurrClass = iCurrClass * 10 + (int)(ch - '0');
                    }
                }
                else
                {
                    if (ch == '.')
                    {
                        iExp = 0;
                    }
                    else
                    {
                        //
                        // We've encountered a non digit and a non '.' character,
                        // this brings us outside of a class number.
                        //
                        break;
                    }
                }
                ch = *(++p + 1);
            }

            if ((iCurrClass == 1) || (iCurrClass == 2))
            {
                //
                // Class types 1 and 2 represents fax. We do not really
                // care whether the class is a 1.x or 2.x
                //
                *pfFaxCapable = TRUE;

                return S_OK;
            }

            if (iLowClass != -1)
            {
                //
                // If we're in the upper value of a class range definition
                // see if 1 or 2 is within the calss range.
                //
                if ((iLowClass <= 2) && (iCurrClass >= 1))
                {
                    //
                    // 1 or2 is within the class range - the modem supports fax.
                    //
                    *pfFaxCapable = TRUE;

                    return S_OK;
                }
            }
        }
        else
        {
            if (ch == '-')
            {
                //
                // We just examined the lower value of a class range.
                // The next characters represents the upper value of a
                // class range. The lower value of the class range is
                // stored in iLowClass.
                //
                iLowClass = iCurrClass;
            }
            else
            {
                if (ch == ',')
                {
                    //
                    // We just examined a single class number, no class range.
                    //
                    iLowClass = -1;
                }
            }
        }
    }

    return S_OK;
}


//
// Function:
//      SynchReadFile
//
// Parameters:
//      hFile - A handle to the COM port of the modem.
//      lpBuffer - A pointer to a buffer the receives the read bytes.
//      nNumberOfBytesToRead - Number of bytes to read.
//      lpNumberOfBytesRead - A pointer to a DWORD the receives the
//          number of bytes that were actually read into the buffer.
//
// Returned Value:
//      If the function succeeds, the return value is S_OK, else the return
//      value is an error code.
//
// Description:
//      This function reads synchronously from a COM port that was opened
//      with FILE_FLAG_OVERLAPPED. This type of handle is returned by
//      ITLegacyCallMediaControl::GetID().
//
//
static HRESULT SynchReadFile(
    HANDLE hFile,
    LPVOID lpBuffer,
    DWORD nNumberOfBytesToRead,
    LPDWORD lpNumberOfBytesRead)
{
    
    _ASSERT(lpBuffer);
    _ASSERT(lpNumberOfBytesRead);

    //
    // Create an event for the overlapped structure.
    //
    CAutoCloseHandle hEvent;

    hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (hEvent == NULL)
    {
        printf("INTERNAL ERROR: CreateEvent() failed - 0x%08x\n",GetLastError());
        return E_OUTOFMEMORY;
    }

    //
    // Prepare the overlapped structure.
    //
    OVERLAPPED overlapped;

    memset(&overlapped, 0, sizeof(OVERLAPPED));
    overlapped.hEvent=hEvent;

    //
    // Make sure the event is in reset state before we begin
    //
    if (!ResetEvent(overlapped.hEvent))
    {
        printf("INTERNAL ERROR: ResetEvent() failed - %d\n",GetLastError());
        return E_OUTOFMEMORY;
    }

    //
    // Read the buffer.
    //
    if (!ReadFile(hFile,
                  lpBuffer,
                  nNumberOfBytesToRead,
                  lpNumberOfBytesRead,
                  &overlapped))
    {
        if (GetLastError()==ERROR_IO_PENDING)
        {
            //
            //Overlapped I/O was started.
            //
            *lpNumberOfBytesRead = 0;
            if (!GetOverlappedResult(hFile,
                                     &overlapped,
                                     lpNumberOfBytesRead,
                                     TRUE))
            {
                printf("INTERNAL ERROR: GetOverlappedResult() failed - %d\n",GetLastError());
                return E_OUTOFMEMORY;
            }
        }
        else
        {
            //
            // Read operation failed
            //
            printf("INTERNAL ERROR: ReadFile() failed - %d\n",GetLastError());
            return E_OUTOFMEMORY;
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\tapitools\isfaxcapable\passthroughutil\tapi3device.h ===
//tapi3device.h

#ifndef _TAPI3DEVICE_H
#define _TAPI3DEVICE_H

#include <tapi3.h>
#include "exception.h"
#include "MtQueue.h"
#include <comdef.h>


_COM_SMARTPTR_TYPEDEF(ITCallInfo, IID_ITCallInfo);
_COM_SMARTPTR_TYPEDEF(ITCallStateEvent, IID_ITCallStateEvent);
_COM_SMARTPTR_TYPEDEF(ITBasicCallControl, IID_ITBasicCallControl);

_COM_SMARTPTR_TYPEDEF(ITTerminalSupport, IID_ITTerminalSupport);

_COM_SMARTPTR_TYPEDEF(ITMediaSupport, IID_ITMediaSupport);

_COM_SMARTPTR_TYPEDEF(IEnumAddress, IID_IEnumAddress);

_COM_SMARTPTR_TYPEDEF(ITAddress, IID_ITAddress);

_COM_SMARTPTR_TYPEDEF(ITLegacyCallMediaControl, IID_ITLegacyCallMediaControl);
_COM_SMARTPTR_TYPEDEF(ITLegacyAddressMediaControl, IID_ITLegacyAddressMediaControl);


_COM_SMARTPTR_TYPEDEF(ITDigitGenerationEvent, IID_ITDigitGenerationEvent);
_COM_SMARTPTR_TYPEDEF(ITDigitDetectionEvent, IID_ITDigitDetectionEvent);
_COM_SMARTPTR_TYPEDEF(ITCallNotificationEvent, IID_ITCallNotificationEvent);

_COM_SMARTPTR_TYPEDEF(ITTAPI, IID_ITTAPI);
_COM_SMARTPTR_TYPEDEF(ITTerminal, IID_ITTerminal);


enum {MaxLogSize =		1024};

enum SetNewCallHandleErrors	{
								NO_CALL=0,
								ACTIVE_CALL,
								IDLE_CALL,
								OFFERING_CALL
							};


enum ReadResponseErros	{
						READRESPONSE_SUCCESS=0,
						READRESPONSE_FAIL,
						READRESPONSE_BUFFERFULL,
						READRESPONSE_TIMEOUT
						};


enum StreamingType	{
						VOICE_STREAMING =0,
						DATA_STREAMING,
						FAX_STREAMING
					};


enum StreamingDirection	{
							CALLER_STREAMING =0,
							ANSWERER_STREAMING
						};

#define	MEDIAMODE_UNKNOWN				0x00000002
#define	MEDIAMODE_VOICE					0x00000004
#define	MEDIAMODE_AUTOMATED_VOICE		0x00000008
#define	MEDIAMODE_INTERACTIVE_VOICE		0x00000010
#define	MEDIAMODE_DATA					0x00000020
#define	MEDIAMODE_FAX					0x00000040
//#define	MEDIAMODE_UNSUPPORTED		0x00000080

#define MAX_DATA_RESPONSE						100


class CTapi3Device
{

	//friend class CTAPIEventNotification;


public:
	CTapi3Device(const DWORD dwId);
	~CTapi3Device(void);

	void HangUp(void);
	void MoveToPassThroughMode(void);
	void GetFaxClass(char* szResponse,DWORD dwSizeOfResponse);
	void OpenLineForOutgoingCall();




//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////data members////////////////////////////////////////////////////////////
private:
	DWORD m_dwId;
	HANDLE m_modemCommPortHandle;	//handle to the comm port (used in Pass Through mode)
	
	ITTAPIPtr				m_Tapi;
	ITAddressPtr			m_pAddress;
	ITTerminalPtr			m_pTerminal;
	ITBasicCallControlPtr	m_pBasicCallControl;

//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////Methods////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////
//helper functions
	
	void PrepareForStreaming(
		const StreamingType streamingType,
		const StreamingDirection streaminDirection
		);

	void TapiLogDetail(
		DWORD dwLevel,
		DWORD dwSeverity,
		const TCHAR * const szLogDescription,
		...
		) const;
	void TapiLogError(
		DWORD dwSeverity,
		const TCHAR * const szLogDescription,
		...
		) const;
	static void ThrowOnComError(
		HRESULT hr,
		const TCHAR * const szExceptionDescription,
		...
		);

	void CleanUp();
	static DWORD GetTickDiff(const DWORD dwStartTickCount);


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//PASSTHROUGH 
	
	void SetBearerModeToPASSTHROUGH(void);
	void SetCommPortHandleFromCallHandle(void);
	void SetCommPortHandleFromAddressHandle(void);
	void CloseCommPortHandle(void);


/////////////////////////////////////////////
//TAPI OBJECT functions
	
	void TapiCoCreateInstance(void);
	void InitializeTapi(void);
	void ShutdownTapi(void);
	
	
	
/////////////////////////////////////////////
//ADDRESS OBJECT functions
	
	void SetAddressProperty(const DWORD dwMedia);
	void SetAddressFromTapiID(void);
	void VerifyAddressState(void) const;
	void VerifyAddressSupportMediaMode(const DWORD dwMedia) const;
	void LogAddressName(void) const;
	void VerifyAddressFromCallInfo(ITCallInfo *pCallInfo) const;
		
/////////////////////////////////////////////
//TERMINAL OBJECT functions
	
	void SetTerminalForOutgoingCall(const DWORD dwMedia);
	void SetTerminalForIncomingCall(const DWORD dwMedia);
	
/////////////////////////////////////////////
//CALL OBJECT functions
	
	SetNewCallHandleErrors SetNewCallHandle(const DWORD dwTimeOut);
	ITCallInfo *GetCallInfoFromCallEvent(ITCallNotificationEvent *pCallNotificationEvent) const;
	ITCallInfo *GetCallInfoFromBasicCallControl(void) const;
	void CreateCallWrapper();
	void VerifyCallFromDigitGenerationEvent(ITDigitGenerationEvent* const pDigitGenerationEvent) const;
	void VerifyCallFromDigitDetectionEvent(ITDigitDetectionEvent* const pDigitDetectionEvent) const;
	void VerifyCallFromCallStateEvent(ITCallStateEvent* const pCallStateEvent) const;
	
	//call media mode
	DWORD GetCallSupportedMediaModes(void) const;
	void VerifyValidMediaModeForOutgoingCall(const DWORD dwMediaMode) const;
	void VerifyValidMediaModeForIncomingCall(const DWORD dwMediaMode) const;
	DWORD GetFriendlyMediaMode(void) const;
	DWORD GetDeviceSpecificMediaMode(const DWORD dwMedia);
	void SetCallMediaMode(const DWORD dwMedia);
	
	//call state functions
	bool IsCallActive(void) const;
	CALL_STATE GetCallState(ITCallInfo *pCallInfo = NULL) const;
	
	//call control functions:
	void CreateAndConnectCall(LPCTSTR szNum, const DWORD dwMedia);
	void ConnectCall(void) const;
	void FaxCreateAndConnectCall(LPCTSTR szNum);


	/////////////////////////////////////////////////////////////////////////////////////
	//COMM PORT functions

	//data
	void ReadData(char * szResponse,int nResponseMaxSize, const DWORD dwTimeout) const;
	void SendData(const char *szCommand) const;

	//
	// general COMM port functions:
	//
	static void SetOverlappedStruct(OVERLAPPED * const ol);
	void ClearCommInputBuffer(void) const;

	//read
	bool SynchReadFile(
		LPVOID lpBuffer,
		DWORD nNumberOfBytesToRead,
		LPDWORD lpNumberOfBytesRead
		) const;
	ReadResponseErros ReadResponse(
		char * szResponse,
		int nResponseMaxSize,
		DWORD *pdwActualRead,
		DWORD dwTimeOut
		) const;
	void WaitForModemResponse(
		LPCSTR szWantedResponse, 
		DWORD dwWantedResponseSize,
		const DWORD dwTimeout
		) const;

};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\tapitools\tapidevice\tapi2device.cpp ===
//Tapi2Device.cpp
#include "tapi2Device.h"
#include "Log.h"
#include <crtdbg.h>
#include "smrtptrs.h"

#pragma warning (disable: 4201)


#define API_VERSION					0x00020000
#define USER_USER_INFO				"Guy Merin"   //used with ISDN


#define IGNORE_LINEREPLY_MESSAGES		-1

#define TAPI2_DEFAULT_WAIT_FOR_MESSAGE_TIMEOUT			60000


//This structure is used to get the handle of the comm port and the device name
//when using the TAPI API lineGetID.
typedef struct DeviceID_tag {
	HANDLE hComm;
	TCHAR  szDeviceName[1];
} DeviceID;


//////////////////////////////////////////////////////////////////////////////////////////
//constructor
CTapi2Device::CTapi2Device(const DWORD dwId) : 
	CTapiDevice(dwId),
	m_hCall(NULL),
	m_hLine(NULL),
	m_hLineApp(NULL),
	m_dwNumDevs(NULL),
	m_dwAPIVersion(API_VERSION),
	m_lineAnswerID(0)
{
	
	LineInitializeExWrapper();

}//CTapi2Device::CTapi2Device(const DWORD dwId)

//////////////////////////////////////////////////////////////////////////////////////////
//destructor
CTapi2Device::~CTapi2Device()
{
	TapiLogDetail(LOG_X, 8, TEXT("Entering CTapi2Device Destructor"));
	
	//
	//check if we have an active call, if so call HangUp() first.
	//
	if (IsCallActive())
	{
		HangUp();
	}
	
	//
	//m_hLine and m_hLineApp can be NULL, if the destructor is activated after a throw from the constructor .
	//
	if (m_hLine)
	{
		m_hLine.Release();
	}


	if (m_hLineApp)
	{
		m_hLineApp.Release();
	}
}//CTapi2Device::~CTapi2Device()



//*********************************************************************************
//* Name:	LineGetDevCapsWrapper
//* Author: Guy Merin / 25-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		wrapper for ::lineGetDevCaps()
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		LINEDEVCAPS as returned from ::lineGetDevCaps()
//*********************************************************************************
LINEDEVCAPS CTapi2Device::LineGetDevCapsWrapper() const
{

	//
	//call lineGetDevCaps() for retrieving some lineDevice information
	//such as supported media modes
	//
	LINEDEVCAPS ldLineDevCaps;
	::ZeroMemory(&ldLineDevCaps,sizeof(ldLineDevCaps));
	ldLineDevCaps.dwTotalSize = sizeof(ldLineDevCaps);
	
	long lineGetDevCapsStatus = ::lineGetDevCaps(
		m_hLineApp,           
		m_dwId,
		m_dwAPIVersion,
		NULL,
		&ldLineDevCaps
		);
	if (0 != lineGetDevCapsStatus)
	{
		throw CException(
			TEXT("%s(%d): CTapi2Device::LineGetDevCapsWrapper(), lineGetDevCaps() failed, error code:0x%08x"), 
			TEXT(__FILE__),
			__LINE__,
			lineGetDevCapsStatus
			);
	}
	return ldLineDevCaps;


}//void CTapi2Device::LineGetDevCapsWrapper()


//*********************************************************************************
//* Name:	InitLineCallParams
//* Author: Guy Merin / 25-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		wrapper for ::lineOpen()
//* PARAMETERS:
//*		[OUT]	LINECALLPARAMS *callParams
//*					callParams to be initilazed		
//*		[IN]	const DWORD dwMediaMode
//*					media mode to open line with, possible values are:
//*						LINEMEDIAMODE_UNKNOWN
//*						LINEMEDIAMODE_G3FAX
//*						LINEMEDIAMODE_DATAMODEM
//*						LINEMEDIAMODE_INTERACTIVEVOICE
//*						LINEMEDIAMODE_AUTOMATEDVOICE
//*	RETURN VALUE:
//*		NONE
//*********************************************************************************
void CTapi2Device::InitLineCallParams(LINECALLPARAMS *callParams,const DWORD dwMediaMode) const
{

	//
	//CallParams structure init
	//
	callParams->dwBearerMode		=	LINEBEARERMODE_VOICE;
	callParams->dwMinRate		=	0;
	callParams->dwMaxRate		=	0;	//0 = highest rate.
	callParams->dwMediaMode		=	dwMediaMode;
	callParams->dwAddressMode	=	1;
	callParams->dwAddressID		=	0;

}//void CTapi2Device::InitLineCallParams()



//*********************************************************************************
//* Name:	LineOpenWrapper
//* Author: Guy Merin / 25-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		wrapper for ::lineOpen()
//* PARAMETERS:
//*		[IN]	const DWORD dwMediaMode
//*					media mode to open line with, possible values are:
//*						LINEMEDIAMODE_G3FAX
//*						LINEMEDIAMODE_DATAMODEM
//*						LINEMEDIAMODE_INTERACTIVEVOICE
//*						LINEMEDIAMODE_AUTOMATEDVOICE
//*						LINEMEDIAMODE_UNKNOWN
//*		[IN]	const DWORD dwPrivileges
//*					prevelige mode to open the line with,possible values are:
//*						LINECALLPRIVILEGE_NONE
//*						LINECALLPRIVILEGE_OWNER
//*	RETURN VALUE:
//*		NONE
//*********************************************************************************
void CTapi2Device::LineOpenWrapper(const DWORD dwMediaMode, const DWORD dwPrivileges)
{

	if (LINECALLPRIVILEGE_NONE == dwPrivileges)
	{
		//
		//NONE privilege is an outgoing call
		//
		VerifyValidMediaModeForOutgoingCall(dwMediaMode);
	}
	else if (LINECALLPRIVILEGE_OWNER == dwPrivileges)
	{
		//
		//OWNER privilege is an incoming call
		//
		VerifyValidMediaModeForIncomingCall(dwMediaMode);
	}
	else
	{
		throw CException(
			TEXT("CTapi2Device::LineOpenWrapper(), The desired dwPrivileges mode(0x%x) is unsupported"),
			dwPrivileges
			);
	}

	LINEDEVCAPS ldLineDevCaps = LineGetDevCapsWrapper();

	if ( !(dwMediaMode & ldLineDevCaps.dwMediaModes) )
	{
		//
		//the desired media mode is not supported by this device
		//
		throw CException(
			TEXT("CTapi2Device::LineOpenWrapper(), The desired media mode(%x) isn't supported by this device(%d), the supported modes are: 0x%x"),
			dwMediaMode,
			m_dwId,
			ldLineDevCaps.dwMediaModes
			);
	}

	//
	//proceed with opening the line:
	//
	LINECALLPARAMS callParams;
	::ZeroMemory(&callParams, sizeof(callParams));
	callParams.dwTotalSize = sizeof(callParams);
	InitLineCallParams(&callParams,dwMediaMode);
	

	TapiLogDetail(
		LOG_X,
		5,
		TEXT("Opening Line with media mode 0x%x"),
		dwMediaMode
		);
	
	m_hLine = NULL;
	long lineOpenStatus = ::lineOpen(
		m_hLineApp,
		m_dwId,
		&m_hLine,
		m_dwAPIVersion,
		NULL,						//Extension version number
		NULL,						//callback instance
		dwPrivileges,
		dwMediaMode,
		&callParams);				//extra call parameters
	if (0 != lineOpenStatus)
	{
		m_hLine = NULL;				//BUG IN TAPI, m_hLine changes even if ::lineOpen() failed
		throw CException(
			TEXT("%s(%d): CTapi2Device::LineOpenWrapper(), lineOpen() failed, error code:0x%08x"), 
			TEXT(__FILE__),
			__LINE__,
			lineOpenStatus
			);
	}
}



//*********************************************************************************
//* Name:	PrepareForStreaming
//* Author: Guy Merin / 08-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Retrieve a handle to the comm port
//* PARAMETERS:
//*		[IN]	const StreamingType streamingType
//*					DATA,VOICE,FAX streaming type to prepare to
//*		[IN]	const StreamingDirection streamingDirection
//*					ANSWER,CALLER direction of streaming to prepare to
//*	RETURN VALUE:
//*		In Tapi2Device answerer and caller StreamingDirection have the
//*		same prepare method.
//*********************************************************************************
void CTapi2Device::PrepareForStreaming(
	const StreamingType streamingType,
	const StreamingDirection streaminDirection
	)
{
	if (
		(VOICE_STREAMING != streamingType) &&
		(DATA_STREAMING != streamingType) &&
		(FAX_STREAMING != streamingType)
		)
	{
	    throw CException(
            TEXT("CTapi2Device::PrepareForStreaming() : streamingType %d is unsupported."),
            streamingType
            );
	}

	if ( (CALLER_STREAMING != streaminDirection) && (ANSWERER_STREAMING != streaminDirection) )
	{
	    throw CException(
            TEXT("CTapi2Device::PrepareForStreaming() : streamingDirection %d is unsupported."),
            streaminDirection
            );
	}

	//
	//no special preparation if FAX or VOICE streaming
	//
	if (DATA_STREAMING == streamingType)
	{
		SetBearerModeToPASSTHROUGH();
		SetCommPortHandleFromCallHandle();
	}
}


//*********************************************************************************
//* Name:	LineInitializeExWrapper
//* Author: Guy Merin / 08-Oct-98
//*********************************************************************************
//* DESCRIPTION:
//*		set's m_hLineApp and m_dwNumDevs static member with the 
//*		returned value of TAPI's lineInitializeEx()
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		NONE
//*********************************************************************************
void CTapi2Device::LineInitializeExWrapper()
{

	
	//
	//lineInitializeExParams structure init
	//
	LINEINITIALIZEEXPARAMS lineInitializeExParams;
	::ZeroMemory(&lineInitializeExParams,sizeof (lineInitializeExParams));
	lineInitializeExParams.dwTotalSize = sizeof (lineInitializeExParams);
	lineInitializeExParams.dwOptions = LINEINITIALIZEEXOPTION_USEEVENT;

	long lineInitializeStatus = ::lineInitializeEx(
		&m_hLineApp,
		GetModuleHandle(NULL),		//client application HINSTANCE.
		NULL,						//TAPI messages through Events, no callback function.
		APPLICATION_NAME_T,
		&m_dwNumDevs,				//Number of devices.
		&m_dwAPIVersion,			//TAPI API highest supported version.
		&lineInitializeExParams
		);
	if (0 != lineInitializeStatus)
	{
		throw CException(
			TEXT("%s(%d): CTapi2Device::CTapi2Device(), lineInitializeEx() failed, error code:0x%08x"), 
			TEXT(__FILE__),
			__LINE__,
			lineInitializeStatus 
			);
	}

	if (m_dwId >= m_dwNumDevs)
	{
		throw CException(
			TEXT("%s(%d): CTapi2Device::CTapi2Device(), given deviceID(%d) exceed dwNumDevs(%d)"), 
			TEXT(__FILE__),
			__LINE__,
			m_dwId, 
			m_dwNumDevs
			);
	}

}//CTapi2Device::LineInitializeExWrapper()








//*********************************************************************************
//* Name:	IsCallIdle
//* Author: Guy Merin / 24-Sep-98
//*********************************************************************************
//* DESCRIPTION:
//*		Checks if the call Handle is valid (not NULL) and that the call is in
//*		IDLE state.
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		TRUE
//*			The call is in IDLE state and handle != NULL
//*		FALSE
//*			Otherwise
//*********************************************************************************

bool CTapi2Device::IsCallIdle() const
{
	if (NULL == m_hCall)
	{
		return (FALSE);
	}
	
	//
	//lineCallStatus init
	//
	LINECALLSTATUS lineCallStatus;
	::ZeroMemory(&lineCallStatus,sizeof(lineCallStatus));
	lineCallStatus.dwTotalSize = sizeof(lineCallStatus);
	lineCallStatus.dwCallState = 0;

	long fLineGetCallStatus = ::lineGetCallStatus(m_hCall,&lineCallStatus);
	if (fLineGetCallStatus < 0)
	{
		throw CException(
			TEXT("%s(%d): CTapi2Device::IsCallIdle(), lineGetCallStatus() call failed, error code 0x%08x"),
			TEXT(__FILE__),
			__LINE__,
			fLineGetCallStatus 
			);
	}

	//
	//A call in IDLE state isn't active.
	//
	if (LINECALLSTATE_IDLE == lineCallStatus.dwCallState)
	{
		return(TRUE);
	}

	return (FALSE);
}//CTapi2Device::IsCallIdle()


//*********************************************************************************
//* Name:	IsCallActive
//* Author: Guy Merin / 24-Sep-98
//*********************************************************************************
//* DESCRIPTION:
//*		Checks if the call Handle is valid (not NULL) and that the call is different than
//*		IDLE state.
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		TRUE
//*			The call is not in IDLE state and handle != NULL
//*		FALSE
//*			Otherwise
//*********************************************************************************
bool CTapi2Device::IsCallActive() const
{
	if (m_hCall == NULL)
	{
		return (FALSE);
	}

	//
	//lineCallStatus init
	//
	LINECALLSTATUS lineCallStatus;
	::ZeroMemory(&lineCallStatus,sizeof(lineCallStatus));
	lineCallStatus.dwTotalSize = sizeof(lineCallStatus);
	lineCallStatus.dwCallState = 0;

	//
	//Get the call state
	//
	long fLineGetCallStatus = ::lineGetCallStatus(m_hCall,&lineCallStatus);
	if (fLineGetCallStatus < 0)
	{
		throw CException(
			TEXT("%s(%d): CTapi2Device::IsCallActive(), lineGetCallStatus() call failed, error code 0x%08x"),
			TEXT(__FILE__),
			__LINE__,
			fLineGetCallStatus 
			);
	}

	//
	//A call in IDLE state isn't active.
	//
	if (LINECALLSTATE_IDLE == lineCallStatus.dwCallState)
	{
		return(FALSE);
	}

	return (TRUE);
}//CTapi2Device::IsCallActive()





//*********************************************************************************
//* Name:	receiveDTMF
//* Author: Guy Merin / 14-oct-98
//*********************************************************************************
//* DESCRIPTION:
//*		receive some digits(tones) from the remote modem, 
//*		using TAPI lineGatherDigits()
//* PARAMETERS:
//*		[OUT]	LPTSTR DTMFresponse
//*					buffer to receive the gathered digits
//*		[IN]	DWORD dwNumberOfDigitsToCollect
//*					number of digits to receive before the function returns
//*		[IN]	const DWORD dwTimeout
//*					miliseconds to wait till first digit is received
//*	RETURN VALUE:
//*		NONE
//* REMARKS:
//*		the function returns after all the desired digits were received
//*		and a LINE_GATHERDIGITS confirmation message was received.
//*		NOTE: lineGatherDigits has some timeouts for quitting
//*********************************************************************************
void CTapi2Device::receiveDTMF(LPTSTR DTMFresponse,DWORD dwNumberOfDigitsToCollect, const DWORD dwTimeout) const
{

	LONG lineMonitorDigitsStatus = ::lineMonitorDigits(m_hCall,LINEDIGITMODE_DTMF);
	if (lineMonitorDigitsStatus != 0)
	{
		throw CException(
			TEXT("%s(%d): CTapi2Device::receiveDTMF(): lineMonitorDigits() returned error: 0x%08x"), 
			TEXT(__FILE__),
			__LINE__,
			lineMonitorDigitsStatus
			);
	}
	
	try
	{
		AP<TCHAR> tszDigitBuffer = new TCHAR[dwNumberOfDigitsToCollect+1];
		if (!tszDigitBuffer)
		{
			throw CException(TEXT("CTapi2Device::receiveDTMF(), new failed"));
		}
		tszDigitBuffer[dwNumberOfDigitsToCollect] = TEXT('\0');
		
		LINEMESSAGE lineMessage;
		
		for (DWORD i=0; i < dwNumberOfDigitsToCollect; i++)
		{
			::ZeroMemory(&lineMessage,sizeof(lineMessage));
			lineGetRelevantMessage(&lineMessage, dwTimeout, IGNORE_LINEREPLY_MESSAGES);

			if (LINE_MONITORDIGITS != lineMessage.dwMessageID)
			{
				throw CException(
					TEXT("CTapi2Device::MoveToPassThroughMode(): Got an unrelated message, message ID=%d"),
					lineMessage.dwMessageID
					);	
			}
			tszDigitBuffer[i] = LOBYTE(lineMessage.dwParam1);
		}
		lstrcpy(DTMFresponse,tszDigitBuffer);

		//
		//disable digit monitoring
		//
		lineMonitorDigitsStatus = ::lineMonitorDigits(m_hCall,0);
		if (lineMonitorDigitsStatus != 0)
		{
			throw CException(
				TEXT("%s(%d): CTapi2Device::receiveDTMF(): lineMonitorDigits() returned error: 0x%08x"), 
				TEXT(__FILE__),
				__LINE__,
				lineMonitorDigitsStatus
				);
		}
	}
	catch(CException e)
	{
		//
		//disable digit monitoring
		//
		lineMonitorDigitsStatus = ::lineMonitorDigits(m_hCall,0);
		if (0 != lineMonitorDigitsStatus)
		{
			TapiLogError(
				LOG_SEV_1, 
				TEXT("%s(%d): CTapi2Device::receiveDTMF(): lineMonitorDigits() returned error: 0x%08x"), 
				TEXT(__FILE__),
				__LINE__,
				lineMonitorDigitsStatus
				);
		}
		throw e;
	}

}//CTapi2Device::receiveDTMF()



//*********************************************************************************
//* Name:	sendDTMF
//* Author: Guy Merin / 14-oct-98
//*********************************************************************************
//* DESCRIPTION:
//*		send some digits to the remote modem, using TAPI lineGenerateDigits()
//* PARAMETERS:
//*		[IN] LPCTSTR digitsToSend
//*			the digits to send to the remote modem
//*	RETURN VALUE:
//*		NONE
//* REMARKS:
//*		the function returns after all the desired digits were sent
//*		and a LINE_GENERATE confirmation message was received
//*********************************************************************************
void CTapi2Device::sendDTMF(LPCTSTR digitsToSend) const
{
	long lineGenerateDigitsStatus = lineGenerateDigits(
		m_hCall,			//the call handle
		LINEDIGITMODE_DTMF,	//use DTMF
		digitsToSend,		//digits to send
		0					//default spacing time
		);
	if (lineGenerateDigitsStatus < 0)
	{
		throw CException(
			TEXT("%s(%d): CTapi2Device::sendDTMF(): lineGenerateDigits() returned error: 0x%08x"), 
			TEXT(__FILE__),
			__LINE__,
			lineGenerateDigitsStatus
			);
	}

	//
	//The lineGenerateDigits function is considered to have completed
	// successfully when the digit generation has been successfully initiated,
	// not when all digits have been generated.
	//
	_ASSERT (0 == lineGenerateDigitsStatus);

	//
	//the finish of the digit generation is async
	//so we need to check if the LINE_GENERATE message is OK
	//
	long lineGetMessageStatus = 0;
	LINEMESSAGE lineMessage;
		
	lineGetRelevantMessage(&lineMessage, TAPI2_DEFAULT_WAIT_FOR_MESSAGE_TIMEOUT, IGNORE_LINEREPLY_MESSAGES);
	if (LINE_GENERATE != lineMessage.dwMessageID)
	{
		throw CException(
			TEXT("CTapi2Device::sendDTMF(): Got an unrelated message, message ID=%d"),
			lineMessage.dwMessageID
			);	
	}
	
	//
	//the message is a LINE_GENERATE message
	//now let's check the reason of the termination
	//
	if (LINEGENERATETERM_DONE == lineMessage.dwParam1)
	{
		//
		//all the desired digits were sent
		//
		return;
	}
	else
	{
		throw CException(
			TEXT("%s(%d): CTapi2Device::sendDTMF(): returned LINE_GENERATE MESSAGE of type : 0x%08x"), 
			TEXT(__FILE__),
			__LINE__,
			lineMessage.dwParam1
			);
	}
	
}//CTapi2Device::sendDTMF()


//*********************************************************************************
//* Name:	MoveToPassThroughMode
//* Author: Guy Merin / 24-Sep-98
//*********************************************************************************
//* DESCRIPTION:
//*		transfer to pass through mode using LineMakeCall() and LineGetId()
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		Use this function on a unallocated call, to switch to passthrough on
//*		an existing call use SetBearerModeToPASSTHROUGH
//*********************************************************************************
void CTapi2Device::MoveToPassThroughMode()
{
	_ASSERT(NULL == m_hCall);

	//
	//No offering call, move to passthrough mode and then wait for "RING"
	//

	//
	//CallParams structure init
	//
	LINECALLPARAMS callParams;
	::ZeroMemory(&callParams,sizeof(callParams));
	callParams.dwTotalSize			=	sizeof(callParams);
	callParams.dwBearerMode			=	LINEBEARERMODE_PASSTHROUGH;
	callParams.dwMinRate			=	0;
	callParams.dwMaxRate			=	0;		//0 meaning highest rate.
	callParams.dwMediaMode			=	LINEMEDIAMODE_DATAMODEM ;
	callParams.dwAddressMode		=	LINEADDRESSMODE_ADDRESSID;
	callParams.dwAddressID			=	0;
	callParams.dwCallParamFlags		=	0;
	callParams.dwCalledPartySize	=	0; 
	callParams.dwCalledPartyOffset	=	0; 


	long lineMakeCallStatus = ::lineMakeCall(
		m_hLine,
		&m_hCall,
		NULL,			//dest address will be giving in ATDT command.
		NULL,			//country code,NULL = default
		&callParams		//extra call parameters
		);
	_ASSERT(lineMakeCallStatus != 0);
	if (lineMakeCallStatus < 0)
	{
		throw CException(
			TEXT("%s(%d): CTapi2Device::MoveToPassThroughMode(), lineMakeCall() failed, error code:0x%08x"), 
			TEXT(__FILE__),
			__LINE__,
			lineMakeCallStatus
			);
	}

	TapiLogDetail(LOG_X, 9, TEXT("::lineMakeCall() request identifier=0x%x"),lineMakeCallStatus);
	LINEMESSAGE lineMakeCallMessage;
	::ZeroMemory(&lineMakeCallMessage,sizeof(lineMakeCallMessage));
	lineGetRelevantMessage(&lineMakeCallMessage, TAPI2_DEFAULT_WAIT_FOR_MESSAGE_TIMEOUT, lineMakeCallStatus);
		
	//
	//check if the async lineMakeCall successed
	//
	if(LINE_REPLY == lineMakeCallMessage.dwMessageID)
	{
		if (0 != lineMakeCallMessage.dwParam2)
		{
			throw CException(
				TEXT("%s(%d): CTapi2Device::MoveToPassThroughMode(): after lineMakeCall(), LINE_REPLY returned error: 0x%08x"), 
				TEXT(__FILE__),
				__LINE__,
				lineMakeCallMessage.dwParam2
				);
		}
		//
		//the call state should change to CONNECTED
		//
		lineGetRelevantMessage(&lineMakeCallMessage, TAPI2_DEFAULT_WAIT_FOR_MESSAGE_TIMEOUT, lineMakeCallStatus);
		if ( (LINE_CALLSTATE != lineMakeCallMessage.dwMessageID) || (LINECALLSTATE_CONNECTED != lineMakeCallMessage.dwParam1) )
		{
			throw CException(TEXT("CTapi2Device::MoveToPassThroughMode(): after lineMakeCall(), expected LINECALLSTATE_CONNECTED message didn't arrive"));	
		}
	}
	_ASSERT(NULL != m_hCall);
	TapiLogDetail(LOG_X, 5, TEXT("Call in PASSTHROUGH MODE"));
}//CTapi2Device::MoveToPassThroughMode()





//*********************************************************************************
//* Name:	SetCommPortHandleFromCallHandle
//* Author: Guy Merin / 24-Sep-98
//*********************************************************************************
//* DESCRIPTION:
//*		sets the comm port handle(m_modemCommPortHandle) using LineGetId() and the 
//*		call handle member variable
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		NONE
//*********************************************************************************
void CTapi2Device::SetCommPortHandleFromCallHandle()
{
	LPVARSTRING lpVarStr = (LPVARSTRING) ::malloc(sizeof(VARSTRING));
	if (!lpVarStr)
	{
		throw CException(TEXT("CTapi2Device::SetCommPortHandleFromCallHandle(), OUT OF MEMORY"));
	}
	lpVarStr->dwTotalSize = sizeof(VARSTRING);
	
	DWORD dwSize;
	while (TRUE)
	{
		long lRet = ::lineGetID(
			m_hLine,
			0,
			m_hCall,
			LINECALLSELECT_CALL,	// dwSelect,
			lpVarStr,				//lpDeviceID,
			TEXT("comm/datamodem") 
			);						//lpszDeviceClass
		
		if (lRet<0)
		{
			::free(lpVarStr);
			throw CException(
				TEXT("%s(%d): CTapi2Device::SetCommPortHandleFromCallHandle(), lineGetID() failed, error code:0x%08x"), 
				TEXT(__FILE__),
				__LINE__,
				lRet
				);
		} 

		if (lpVarStr->dwNeededSize > lpVarStr->dwTotalSize)
		{ 
			//More room is required
			dwSize = lpVarStr->dwNeededSize;
			::free(lpVarStr);
			lpVarStr = (LPVARSTRING) ::malloc(dwSize);
			if (!lpVarStr)
			{
				throw CException(TEXT("CTapi2Device::SetCommPortHandleFromCallHandle(), OUT OF MEMORY"));
			}
			lpVarStr->dwTotalSize = dwSize;

		} 
		else 
		{
			//
			//Make sure we did not get bizzare result for DeviceID
			//make sure the type is binary
			//
			if (STRINGFORMAT_BINARY != lpVarStr->dwStringFormat)
			{
				::free(lpVarStr);
				throw CException(TEXT("CTapi2Device::SetCommPortHandleFromCallHandle(), DeviceID format is not STRINGFORMAT_BINARY"));
			}
			// Success. No error and there was enough room in the buffer.
			break;
		}
	} //while

	
	DeviceID * lpDeviceId;
	lpDeviceId=(DeviceID *)((LPSTR)lpVarStr+lpVarStr->dwStringOffset);
	HANDLE phComm =lpDeviceId->hComm;

	::free(lpVarStr);
	_ASSERT(NULL != phComm);
	m_modemCommPortHandle = phComm;
}//CTapi2Device::SetCommPortHandleFromCallHandle




//*********************************************************************************
//* Name:	DirectHandoffCall
//* Author: Guy Merin / 21-Oct-98
//*********************************************************************************
//* DESCRIPTION:
//*		handoff the call to a specific application
//* PARAMETERS:
//*		[IN]	LPCTSTR szAppName
//*					the application to receive the handoff
//*	RETURN VALUE:
//*		an exception is thrown if the handoff failed or the target application
//*		wasn't found.
//*********************************************************************************
void CTapi2Device::DirectHandoffCall(LPCTSTR szAppName)
{
	if (NULL == szAppName)
	{
		throw CException(TEXT("CTapi2Device::DirectHandoffCall(): No application given"));
	}
	long status = ::lineHandoff(m_hCall,szAppName,NULL);
	if (0 > status)
	{
		throw CException(
			TEXT("%s(%d): CTapi2Device::DirectHandoffCall() ::lineHandoff() returned error code 0x%08x"), 
			TEXT(__FILE__),
			__LINE__,
			status 
			);
	}

}//void CTapi2Device::DirectHandoffCall()



//*********************************************************************************
//* Name:	MediaHandoffCall
//* Author: Guy Merin / 21-Oct-98
//*********************************************************************************
//* DESCRIPTION:
//*		run through all the call media modes and try to handoff the call to
//*		another TAPI application
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		TRUE
//*			the call was handed off succesfuly
//*		FALSE
//*			the call wasn't handed off (no higher priority application is
//*			registered to the call's media mode).
//*	REMARKS:
//*		lineHandoff() takes only one media mode at a time, so for every media mode
//*		the call supports, a lineHandoff should be invoked.
//*********************************************************************************
bool CTapi2Device::MediaHandoffCall()
{
	
	//
	//first get the call media mode
	//
	LINECALLINFO incomingCallInfo;
	::ZeroMemory(&incomingCallInfo,sizeof(incomingCallInfo));
	incomingCallInfo.dwTotalSize=sizeof(incomingCallInfo);

	long lineGetCallInfoStatus = ::lineGetCallInfo(m_hCall,&incomingCallInfo);
	if (lineGetCallInfoStatus < 0)
	{
		throw CException(
			TEXT("%s(%d): CTapi2Device::MediaHandoffCall(): after lineGetCallInfo(), returned error code 0x%08x"), 
			TEXT(__FILE__),
			__LINE__,
			lineGetCallInfoStatus 
			);
	}

	long lineHandoffStatus;
	DWORD dwHandoffToMediaMode = LINEMEDIAMODE_VOICEVIEW;
	while (1)
	{
		switch (dwHandoffToMediaMode)
		{
		case LINEMEDIAMODE_VOICEVIEW:
			dwHandoffToMediaMode = LINEMEDIAMODE_ADSI;
			break;
		case LINEMEDIAMODE_ADSI:
			dwHandoffToMediaMode = LINEMEDIAMODE_MIXED;
			break;
		case LINEMEDIAMODE_MIXED:
			dwHandoffToMediaMode = LINEMEDIAMODE_TELEX;
			break;
		case LINEMEDIAMODE_TELEX:
			dwHandoffToMediaMode = LINEMEDIAMODE_VIDEOTEX;
			break;
		case LINEMEDIAMODE_VIDEOTEX:
			dwHandoffToMediaMode = LINEMEDIAMODE_TELETEX;
			break;
		case LINEMEDIAMODE_TELETEX:
			dwHandoffToMediaMode = LINEMEDIAMODE_DIGITALDATA;
			break;
		case LINEMEDIAMODE_DIGITALDATA:
			dwHandoffToMediaMode = LINEMEDIAMODE_G4FAX;
			break;
		case LINEMEDIAMODE_G4FAX:
			dwHandoffToMediaMode = LINEMEDIAMODE_TDD;
			break;
		case LINEMEDIAMODE_TDD:
			dwHandoffToMediaMode = LINEMEDIAMODE_G3FAX;
			break;
		case LINEMEDIAMODE_G3FAX:
			dwHandoffToMediaMode = LINEMEDIAMODE_DATAMODEM;
			break;
		case LINEMEDIAMODE_DATAMODEM:
			dwHandoffToMediaMode = LINEMEDIAMODE_AUTOMATEDVOICE;
			break;
		case LINEMEDIAMODE_AUTOMATEDVOICE:
			dwHandoffToMediaMode = LINEMEDIAMODE_INTERACTIVEVOICE;
			break;
		case LINEMEDIAMODE_INTERACTIVEVOICE:
			dwHandoffToMediaMode = LINEMEDIAMODE_UNKNOWN;
			break;
		}
		if (incomingCallInfo.dwMediaMode & dwHandoffToMediaMode)
		{
			lineHandoffStatus = ::lineHandoff(m_hCall,NULL,dwHandoffToMediaMode);
			if (0 == lineHandoffStatus)
			{
				//
				//handoff succeeded, so return
				//
				return (true);
			}
			else if (
				(LINEERR_TARGETSELF == lineHandoffStatus) || 
				(LINEERR_TARGETNOTFOUND == lineHandoffStatus) 
				)
			{
				if (LINEMEDIAMODE_UNKNOWN == dwHandoffToMediaMode)
				{
					TapiLogDetail(LOG_X, 5, TEXT("Handoff failed with all media modes"));
					//
					//handoff failed with all media modes
					//
					return (false);
				}
				//
				//no other application wants the call with the current media mode
				//try another media mode
				//

				//
				//erase the current dwHandoffToMediaMode from the call media modes
				//
				incomingCallInfo.dwMediaMode = incomingCallInfo.dwMediaMode & !dwHandoffToMediaMode;
				lineSetMediaMode(m_hCall,incomingCallInfo.dwMediaMode);

				//
				//try handoff with the next available media mode
				//
				continue;
			}
			else
			{
				throw CException(
					TEXT("%s(%d): CTapi2Device::MediaHandoffCall(): lineHandoff(), returned error code 0x%08x"), 
					TEXT(__FILE__),
					__LINE__,
					lineHandoffStatus 
					);
			}
		}
	}
}//bool CTapi2Device::MediaHandoffCall()



//*********************************************************************************
//* Name:	GetCallSupportedMediaModes
//* Author: Guy Merin / 29-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		return the call's media mode
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		the call's media mode as a DWORD (only one media mode is returned)
//*********************************************************************************
DWORD CTapi2Device::GetCallSupportedMediaModes() const
{
	LINECALLINFO incomingCallInfo;
	::ZeroMemory(&incomingCallInfo,sizeof(incomingCallInfo));
	incomingCallInfo.dwTotalSize=sizeof(incomingCallInfo);

	long lineGetCallInfoStatus = ::lineGetCallInfo(m_hCall,&incomingCallInfo);
	if (lineGetCallInfoStatus < 0)
	{
		throw CException(
			TEXT("%s(%d): CTapi2Device::GetCallSupportedMediaModes(): after lineGetCallInfo(), returned error code 0x%08x"), 
			TEXT(__FILE__),
			__LINE__,
			lineGetCallInfoStatus 
			);
	}

	//
	//fax calls should be in passthrough mode (not TAPI)
	//
	if( (LINEBEARERMODE_PASSTHROUGH == incomingCallInfo.dwBearerMode) && m_isFaxCall)
	{
		return LINEMEDIAMODE_G3FAX;
	}
	
	
	return (incomingCallInfo.dwMediaMode);
}//CTapi2Device::GetCallSupportedMediaModes


//*********************************************************************************
//* Name:	SetNewCallHandle
//* Author: Guy Merin / 13-Oct-98
//*********************************************************************************
//* DESCRIPTION:
//*		Check if we have a new call, set it's call handle and return the 
//*		call's state
//* PARAMETERS:
//*		[IN]	DWORD dwTimeOut
//*					timeout in milliseconds to wait for the new call.
//*	RETURN VALUE:
//*		OFFERING_CALL
//*			We have a new offering call (at OFFERING or ACCEPT state)
//*		ACTIVE_CALL
//*			We have a new call in an active state (CONNECTED, DAILING etc.)
//*		IDLE_CALL
//*			We have a new offering call (at IDLE or DISCONNECT state)
//*			this kind of call probably arrived through a handoff
//*		NO_NEW_CALL
//*			No offering call.
//*********************************************************************************
SetNewCallHandleErrors CTapi2Device::SetNewCallHandle(
	const DWORD dwTimeOut
	)
{
	HCALL hcOfferingCall = NULL;
	DWORD dwPrivilegeMode = 0;

	long lineGetMessageStatus = 0;
	SetNewCallHandleErrors newCallErrorStatus;
	
	LINEMESSAGE lineMessage;
	while(TRUE)
	{
		lineGetMessageStatus = ::lineGetMessage(m_hLineApp,&lineMessage,dwTimeOut);
		if (LINEERR_OPERATIONFAILED == lineGetMessageStatus)
		{
			return (NO_CALL);
		}

		//
		//log the message 
		//
		TapiLogDetail(
			LOG_X, 
			9, 
			TEXT("Got message of type %d hDevice=%x0x, dwParam1=%x0x, dwParam2=%x0x, dwParam3=%x0x"),
			lineMessage.dwMessageID,
			lineMessage.hDevice,
			lineMessage.dwParam1,
			lineMessage.dwParam2,
			lineMessage.dwParam3
			);

		
		if(LINE_APPNEWCALL == lineMessage.dwMessageID)
		{
			hcOfferingCall = (HCALL) lineMessage.dwParam2;
			dwPrivilegeMode = (DWORD) lineMessage.dwParam3;
			continue;
		}

		if(LINE_CALLSTATE == lineMessage.dwMessageID)
		{
			switch(lineMessage.dwParam1)
			{
	
			case LINECALLSTATE_IDLE:
				newCallErrorStatus = IDLE_CALL;
				goto IS_NEW_CALL_SUCCESS;
			
			case LINECALLSTATE_OFFERING:
				newCallErrorStatus = OFFERING_CALL;
				goto IS_NEW_CALL_SUCCESS;
			
			case LINECALLSTATE_ACCEPTED:
				//
				//the call was handed off to our application at ACCEPT state
				//we still have to call TAPI's answer() on this call
				//
				newCallErrorStatus = OFFERING_CALL;
				goto IS_NEW_CALL_SUCCESS;
			
			case LINECALLSTATE_DIALTONE:
				newCallErrorStatus = ACTIVE_CALL;
				goto IS_NEW_CALL_SUCCESS;
				
			case LINECALLSTATE_DIALING:
				newCallErrorStatus = ACTIVE_CALL;
				goto IS_NEW_CALL_SUCCESS;
			
			case LINECALLSTATE_RINGBACK:
				newCallErrorStatus = ACTIVE_CALL;
				goto IS_NEW_CALL_SUCCESS;
			
			case LINECALLSTATE_BUSY:
				newCallErrorStatus = ACTIVE_CALL;
				goto IS_NEW_CALL_SUCCESS;

			case LINECALLSTATE_SPECIALINFO:
				newCallErrorStatus = ACTIVE_CALL;
				goto IS_NEW_CALL_SUCCESS;

			case LINECALLSTATE_CONNECTED:
				newCallErrorStatus = ACTIVE_CALL;
				goto IS_NEW_CALL_SUCCESS;
			
			case LINECALLSTATE_PROCEEDING:
				newCallErrorStatus = ACTIVE_CALL;
				goto IS_NEW_CALL_SUCCESS;
			
			case LINECALLSTATE_ONHOLD:
				newCallErrorStatus = ACTIVE_CALL;
				goto IS_NEW_CALL_SUCCESS;
			
			case LINECALLSTATE_CONFERENCED:
				newCallErrorStatus = ACTIVE_CALL;
				goto IS_NEW_CALL_SUCCESS;
			
			case LINECALLSTATE_ONHOLDPENDCONF:
				newCallErrorStatus = ACTIVE_CALL;
				goto IS_NEW_CALL_SUCCESS;

			case LINECALLSTATE_ONHOLDPENDTRANSFER:
				newCallErrorStatus = ACTIVE_CALL;
				goto IS_NEW_CALL_SUCCESS;
			
			case LINECALLSTATE_DISCONNECTED:
				newCallErrorStatus = IDLE_CALL;
				goto IS_NEW_CALL_SUCCESS;

			case LINECALLSTATE_UNKNOWN:
				throw CException(TEXT("CTapi2Device::SetNewCallHandle, New call with LINECALLSTATE_UNKNOWN state"));

			default:
				//
				//We have a call in a differnt state
				//
				throw CException(TEXT("CTapi2Device::SetNewCallHandle, New call with unsupported state"));
							
			}
		}
	}

IS_NEW_CALL_SUCCESS:
	if (LINECALLPRIVILEGE_OWNER == dwPrivilegeMode)
	{
		m_hCall = hcOfferingCall;
		return (newCallErrorStatus);
	}
	else
	{
		throw CException(TEXT("CTapi2Device::SetNewCallHandle, New call is not doesn't have OWNER privilege"));
		
		//
		//just to igonre the compile error
		//
		return NO_CALL;	
	}


}//CTapi2Device::SetNewCallHandle


//*********************************************************************************
//* Name:	lineGetRelevantMessage
//* Author: Guy Merin / 24-Sep-98
//*********************************************************************************
//* DESCRIPTION:
//*		fetches only the messages related to the current call (m_hCall)
//*		or to the current requestID
//*		the only returned messages are of type:
//*			LINE_REPLY
//*			LINE_CALLSTATE
//*			LINE_CALLINFO
//*			LINE_MONITORDIGITS
//*			LINE_GENERATE
//* PARAMETERS:
//*		[OUT]	LINEMESSAGE *lineMessage
//*					the message
//*		[IN]	DWORD dwTimeOut
//*					timeout in milliseconds to wait for the message.
//*		[IN]	long requestID
//*					the related request ID for this message,
//*					If this parameter is IGNORE_LINEREPLY_MESSAGES, the caller 
//*					isn't interested in LINE_REPLY messages
//*	RETURN VALUE:
//*		NONE
//*********************************************************************************
void CTapi2Device::lineGetRelevantMessage(
	LINEMESSAGE *lineMessage,
	const DWORD dwTimeOut,
	const long requestID
	) const
{

	long lineGetMessageStatus = 0;
	
	while(TRUE)
	{
		lineGetMessageStatus = ::lineGetMessage(m_hLineApp,lineMessage,dwTimeOut);
		
		if (LINEERR_OPERATIONFAILED == lineGetMessageStatus)
		{
			throw CException(
				TEXT("%s(%d): CTapi2Device::lineGetRelevantMessage(): TIMEOUT for lineGetMessage() using %d milliseconds"), 
				TEXT(__FILE__),
				__LINE__,
				dwTimeOut
				);
		}

		//
		//log the message 
		//
		TapiLogDetail(
			LOG_X, 
			9, 
			TEXT("Got message of type %d hDevice=%x0x, dwParam1=%x0x, dwParam2=%x0x, dwParam3=%x0x"),
			lineMessage->dwMessageID,
			lineMessage->hDevice,
			lineMessage->dwParam1,
			lineMessage->dwParam2,
			lineMessage->dwParam3
			);

		
		switch (lineMessage->dwMessageID)
		{
		
		case LINE_REPLY:
			if (requestID == IGNORE_LINEREPLY_MESSAGES)
			{
				//
				//caller isn't interested in LINE_REPLY messages
				//so fetch next message
				//
				continue;
			}
			else if (requestID == (long) lineMessage->dwParam1)
			{
				//
				//the message is a LINE_REPLY message
				//related to the requestID
				//
				return;
			}
			else
			{
				TapiLogError(
					LOG_SEV_1, 
					TEXT("Got an unrelated LINE_REPLY message, param1=0x%x, param2=0x%x"),
					lineMessage->dwParam1,
					lineMessage->dwParam2
					);
			}
			break;
		
		
		case LINE_CALLSTATE:
			if (m_hCall != (HCALL) lineMessage->hDevice)
			{
				TapiLogError(
					LOG_SEV_1, 
					TEXT("Got an unrelated LINE_CALLSTATE message, param1=0x%x, hDevice=0x%x"),
					lineMessage->dwParam1,
					lineMessage->hDevice
					);
			}
	
			//
			//the message is a LINE_CALLSTATE message
			//related to the h_call 
			//
			return;
		
		
		case LINE_CALLINFO:
			if (m_hCall != (HCALL) lineMessage->hDevice)
			{
				TapiLogError(
					LOG_SEV_1, 
					TEXT("Got an unrelated LINE_CALLINFO message, param1=0x%x, hDevice=0x%x"),
					lineMessage->dwParam1,
					lineMessage->hDevice
					);
			}
			
			TapiLogDetail(LOG_X,9, TEXT("Got a LINE_CALLINFO of type 0x%x"),lineMessage->dwParam1);
			break;

		case LINE_MONITORDIGITS:
			if (m_hCall != (HCALL) lineMessage->hDevice)
			{
				TapiLogError(
					LOG_SEV_1, 
					TEXT("Got an unrelated LINE_MONITORDIGITS message, param1=0x%x, hDevice=0x%x"),
					lineMessage->dwParam1,
					lineMessage->hDevice
					);
			}
			if (LINEDIGITMODE_DTMF != lineMessage->dwParam2)
			{
				TapiLogError(
					LOG_SEV_1, 
					TEXT("Got a LINE_MONITORDIGITS message without DTMF digit mode, digit mode = %d"),
					lineMessage->dwParam2
					);
			}
			return;

		case	LINE_GENERATE:
			if (m_hCall != (HCALL) lineMessage->hDevice)
			{
				TapiLogError(
					LOG_SEV_1, 
					TEXT("Got an unrelated LINE_MONITORDIGITS message, param1=0x%x, hDevice=0x%x"),
					lineMessage->dwParam1,
					lineMessage->hDevice
					);
			}
			return;

		default:
			TapiLogError(
					LOG_SEV_1, 
					TEXT("Got an unrelated 0x%x message, hDevice=0x%x, param1=0x%x, param2=0x%x, param3=0x%x"),
					lineMessage->dwMessageID,
					lineMessage->hDevice,
					lineMessage->dwParam1,
					lineMessage->dwParam2,
					lineMessage->dwParam3
					);
			break;
		}
	}//while

}//CTapi2Device::lineGetRelevantMessage




//*********************************************************************************
//* Name:	HangUp
//* Author: Guy Merin / 24-Sep-98
//*********************************************************************************
//* DESCRIPTION:
//*		hangs up a call, and deallocate the call.
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		NONE
//*	REMARKS:
//*		If the call is already in IDLE state the function deallocate the call.
//*		if the call is a FAX call then this function also 
//*		closes the comm port handle.
//*		
//*********************************************************************************
void CTapi2Device::HangUp()
{
	if (NULL == m_hCall)
	{
		return;
	}

	//
	//We return TRUE if the call is in IDLE state because maybe the remote side(not us),
	//disconnected the call (without knowing it), so the Hangup has "succeed".
	//
	if (TRUE == IsCallIdle())		//IDLE state call, free the call handle.
	{
		m_hCall.Release();
		return;
	}
	
	//
	//if the call is a FAX call and the modem is already in PASSTHROUGH mode
	//send ATH and ATZ commands and then hangup
	//
	if (m_isFaxCall && m_modemCommPortHandle)
	{
		SendFaxHangUpCommands();
	}
	//
	//hangup the call
	//
	long lineDropStatus = ::lineDrop(m_hCall,USER_USER_INFO,sizeof(USER_USER_INFO));
	_ASSERT(0 != lineDropStatus);	//return value shouldn't be 0, asynchronous function.
	if (0 > lineDropStatus)
	{
		throw CException(
			TEXT("%s(%d): CTapi2Device::HangUp, lineDrop() failed, error code:0x%08x"), 
			TEXT(__FILE__),
			__LINE__,
			lineDropStatus
			);
	}
	TapiLogDetail(LOG_X, 9, TEXT("::lineDrop() request identifier=0x%x"),lineDropStatus);

	//
	//check if the hangup succeed, the call state should change to IDLE:
	//
	
	LINEMESSAGE lineMessage;
	::ZeroMemory(&lineMessage,sizeof(lineMessage));

	bool bGotCallStateIDLEMessage = false;
	bool bGotLineReplyMessage = false;
	while (!bGotCallStateIDLEMessage || !bGotLineReplyMessage)
	{
		lineGetRelevantMessage(&lineMessage,TAPI2_DEFAULT_WAIT_FOR_MESSAGE_TIMEOUT,lineDropStatus);	

		if (LINE_CALLSTATE == lineMessage.dwMessageID)
		{
			switch (lineMessage.dwParam1)
			{
			case LINECALLSTATE_DISCONNECTED:
				break;
			case LINECALLSTATE_IDLE:
				bGotCallStateIDLEMessage = true;
				break;
			default:
				throw CException(TEXT("CTapi2Device::HangUp(), after lineDrop() didn't recieve a LINECALLSTATE_IDLE message"));
			}
		}
		else if (LINE_REPLY == lineMessage.dwMessageID)
		{
			if (0 != lineMessage.dwParam2)
			{
				throw CException(TEXT("CTapi2Device::HangUp(), lineDrop() didn't send LINE_REPLY Message, or lineDrop() failed"));
			}
			bGotLineReplyMessage = true;
		}
		else 
		{
			throw CException(TEXT("CTapi2Device::HangUp(), after lineDrop() didn't recieve a LINECALLSTATE_IDLE message"));
		}
	}//while

	m_hCall.Release();
	if (m_isFaxCall)
	{
		CloseCommPortHandle();
		m_isFaxCall = false;
	}
	
	_ASSERT(!m_isFaxCall);
	_ASSERT(NULL == m_hCall);
	if (m_hLine)
	{
		m_hLine.Release();
	}
	
}//CTapi2Device::HangUp()



//*********************************************************************************
//* Name:	SetBearerModeToPASSTHROUGH
//* Author: Guy Merin / 26-Oct-98
//*********************************************************************************
//* DESCRIPTION:
//*		set the call bearer mode to PASSTHROUGH.
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		NONE
//*	REMARKS:
//*		Use this function on an existing call, to set passthrough mode on a
//*		unallocated call use MoveToPassThroughMode
//*********************************************************************************
void CTapi2Device::SetBearerModeToPASSTHROUGH()
{
	//
	//save the original call state
	//this is done because if the original state isn't CONNECT
	//after moving to PASSTHROUGH a CONNECT message is sent to the app
	//
	DWORD OriginalCallState = GetCallState();

	long lSetParamsRet = ::lineSetCallParams(
		m_hCall,
		LINEBEARERMODE_PASSTHROUGH,
		0,
		0,
		NULL
		);

	if (lSetParamsRet<0)
	{
		//
		//We failed initiating the request. 
		//drop the call.
		//
		long lDropLineReq = ::lineDrop(m_hCall,NULL,0);
		if (lDropLineReq<0)
		{
			throw CException(TEXT("CTapi2Device::SetBearerModeToPASSTHROUGH(), lineDrop() failed"));
		}
		
		TapiLogDetail(LOG_X, 9, TEXT("::lineDrop() request identifier=0x%x"),lDropLineReq);
		
		//
		//a LINE_REPLY message for the lineDrop() should be received
		//but we throw an exception anyway...
		//
		throw CException(
			TEXT("CTapi2Device::SetBearerModeToPASSTHROUGH(), lineSetCallParams() failed error code 0x%08x"),
			lSetParamsRet
			);
	}
	
	TapiLogDetail(LOG_X, 9, TEXT("::lineSetCallParams() request identifier=0x%x"),lSetParamsRet);
	//
	//lineSetCallParams is async, so the return value shouldn't be 0
	//
	_ASSERT (0 != lSetParamsRet);

	//
	//wait for the LINE_REPLY message for lineSetCallParams
	//
	long lineGetMessageStatus = 0;
	LINEMESSAGE lineMessage;
	while (TRUE)
	{
		lineGetRelevantMessage(&lineMessage, TAPI2_DEFAULT_WAIT_FOR_MESSAGE_TIMEOUT, lSetParamsRet);
		if (LINE_REPLY == lineMessage.dwMessageID)
		{
			if (0 != lineMessage.dwParam2)
			{
				//
				//LINE_REPLY indicates that lineSetCallParams() failed
				//
				throw CException(
					TEXT("CTapi2Device::SetBearerModeToPASSTHROUGH(), lineSetCallParams() returned a LINE_REPLY error code 0x%08x"),
					lineMessage.dwParam2
					);
			}
			else
			{
				//
				//if the original call state was CONNECTED we can return here
				//because our app will not get a CONNECT message
				//
				if (LINECALLSTATE_CONNECTED == OriginalCallState)
				{
					return;
				}
				continue;
			}
		}
		else if (LINE_CALLSTATE == lineMessage.dwMessageID)
		{
			if (LINECALLSTATE_CONNECTED == lineMessage.dwParam1)
			{
				TapiLogDetail(LOG_X, 5, TEXT("Call in PASSTHROUGH MODE"));
				return;
			}
			else
			{
				throw CException(
					TEXT("CTapi2Device::SetBearerModeToPASSTHROUGH(), didn't receive a LINE_CALLSTATE CONNECTED recieved a LINE_CALLSTATE 0x%08x"),
					lineMessage.dwParam1
					);
			}
		}
		continue;
	}
}//void CTapi2Device::SetBearerModeToPASSTHROUGH()


//*********************************************************************************
//* Name:	VerifyValidMediaModeForIncomingCall
//* Author: Guy Merin / 19-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Check if the given media mode is valid in Tapi2 for incoming calls
//* PARAMETERS:
//*		[IN]	const DWORD dwMediaMode
//*					a combination of the following media mode:
//*						LINEMEDIAMODE_G3FAX
//*						LINEMEDIAMODE_DATAMODEM
//*						LINEMEDIAMODE_INTERACTIVEVOICE
//*						LINEMEDIAMODE_AUTOMATEDVOICE
//*						LINEMEDIAMODE_UNKNOWN
//*	RETURN VALUE:
//*		NONE
//*	REMARKS:
//*		incoming call can have more than one supported media modes
//*********************************************************************************
void CTapi2Device::VerifyValidMediaModeForIncomingCall(const DWORD dwMediaMode) const
{

	if	(
			(LINEMEDIAMODE_G3FAX & dwMediaMode) ||
			(LINEMEDIAMODE_DATAMODEM & dwMediaMode) ||
			(LINEMEDIAMODE_INTERACTIVEVOICE & dwMediaMode) ||
			(LINEMEDIAMODE_AUTOMATEDVOICE & dwMediaMode) ||
			(LINEMEDIAMODE_UNKNOWN & dwMediaMode)
		)
	{
		return;
	}
	else
	{
		throw CException(
			TEXT("%s(%d): CTapi2Device::VerifyValidMediaModeForIncomingCall(), unknown media mode(0x%08x)"), 
			TEXT(__FILE__),
			__LINE__,
			dwMediaMode
			);
	}
}//void CTapi2Device::VerifyValidMediaModeForIncomingCall()


//*********************************************************************************
//* Name:	VerifyValidMediaModeForOutgoingCall
//* Author: Guy Merin / 19-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Check if the given media mode is valid in Tapi2
//* PARAMETERS:
//*		[IN]	const DWORD dwMediaMode
//*					only one of the following media modes:
//*						LINEMEDIAMODE_G3FAX
//*						LINEMEDIAMODE_DATAMODEM
//*						LINEMEDIAMODE_INTERACTIVEVOICE
//*						LINEMEDIAMODE_AUTOMATEDVOICE
//*	RETURN VALUE:
//*		NONE
//*	REMARKS:
//*		outgoing call can have only 1 supported media modes
//*********************************************************************************
void CTapi2Device::VerifyValidMediaModeForOutgoingCall(const DWORD dwMediaMode) const
{

	if	(
			(LINEMEDIAMODE_G3FAX == dwMediaMode) ||
			(LINEMEDIAMODE_DATAMODEM == dwMediaMode) ||
			(LINEMEDIAMODE_INTERACTIVEVOICE == dwMediaMode) ||
			(LINEMEDIAMODE_AUTOMATEDVOICE == dwMediaMode)
		)
	{
		return;
	}
	else
	{
		throw CException(
			TEXT("%s(%d): CTapi2Device::VerifyValidMediaModeForOutgoingCall(), unknown media mode(0x%08x)"), 
			TEXT(__FILE__),
			__LINE__,
			dwMediaMode
			);
	}
}//void CTapi2Device::VerifyValidMediaModeForOutgoingCall()



//*********************************************************************************
//* Name:	TapiLogDetail
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Wrapper for ::lgLogDetail(), logs a message with the Tapi's properties
//* PARAMETERS:
//*		[IN]	DWORD dwLevel
//*					log level, passed to ::lgLogDetail()
//*		[IN]	DWORD dwSeverity 
//*					log severity, passed to ::lgLogDetail()
//*		[IN]	const TCHAR * const szLogDescription
//*					description format, 
//*		[IN]	...
//*					extra parameters as specified in szLogDescription parameter
//*	RETURN VALUE:
//*		NONE
//*********************************************************************************
void CTapi2Device::TapiLogDetail(
	DWORD dwLevel,
	DWORD dwSeverity,
	const TCHAR * const szLogDescription,
	...
	) const
{
	TCHAR szLog[1024];
	szLog[1023] = '\0';
	va_list argList;
	va_start(argList, szLogDescription);
	::_vsntprintf(szLog, 1023, szLogDescription, argList);
	va_end(argList);

	::lgLogDetail(
		dwLevel, 
		dwSeverity, 
		TEXT("LINEAPP=0x%08x, DeviceId=%d, %s"),
		m_hLineApp,
		m_dwId,
		szLog
		);

}//void CTapi2Device::lgLogDetail()


//*********************************************************************************
//* Name:	TapiLogError
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Wrapper for ::lgLogError(), logs a message with the Tapi's properties
//* PARAMETERS:
//*		[IN]	DWORD dwSeverity 
//*					log severity, passed to ::lgLogError()
//*		[IN]	const TCHAR * const szLogDescription
//*					description format, 
//*		[IN]	...
//*					extra parameters as specified in szLogDescription parameter
//*	RETURN VALUE:
//*		NONE
//*********************************************************************************
void CTapi2Device::TapiLogError(
	DWORD dwSeverity,
	const TCHAR * const szLogDescription,
	...
	) const
{
	TCHAR szLog[1024];
	szLog[1023] = '\0';
	va_list argList;
	va_start(argList, szLogDescription);
	::_vsntprintf(szLog, 1023, szLogDescription, argList);
	va_end(argList);

	::lgLogError(
		dwSeverity, 
		TEXT("LINEAPP=0x%08x, DeviceId=%d, %s"),
		m_hLineApp,
		m_dwId,
		szLog
		);

}//void CTapi2Device::TapiLogError()



DWORD CTapi2Device::GetCallState() const
{
	_ASSERT(NULL != m_hCall);

	//
	//lineCallStatus init
	//
	LINECALLSTATUS lcsLineCallStatus;
	::ZeroMemory(&lcsLineCallStatus,sizeof(lcsLineCallStatus));
	lcsLineCallStatus.dwTotalSize = sizeof(lcsLineCallStatus);
	lcsLineCallStatus.dwCallState = 0;

	//
	//Get the call state
	//
	long lLineGetCallStatus = ::lineGetCallStatus(m_hCall,&lcsLineCallStatus);
	if (lLineGetCallStatus < 0)
	{
		throw CException(
			TEXT("%s(%d): CTapi2Device::IsCallActive(), lineGetCallStatus() call failed, error code 0x%08x"),
			TEXT(__FILE__),
			__LINE__,
			lLineGetCallStatus 
			);
	}

	return (lcsLineCallStatus.dwCallState);
}//DWORD CTapi2Device::GetCallState()



//*********************************************************************************
//* Name:	OpenLineForIncomingCall
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Opens a line for incoming call
//* PARAMETERS:
//*		[IN]	const DWORD dwMedia
//*					media mode to open line with, can be ANY combination of the followings:
//*						LINEMEDIAMODE_INTERACTIVEVOICE,
//*						LINEMEDIAMODE_AUTOMATEDVOICE,
//*						LINEMEDIAMODE_DATAMODEM,
//*						LINEMEDIAMODE_G3FAX,
//*						LINEMEDIAMODE_UNKNOWN
//*	RETURN VALUE:
//*		NONE
//*	REMARKS:
//*		the function uses CTapi2Device::LineOpenWrapper() with owner privilege mode
//*********************************************************************************
void CTapi2Device::OpenLineForIncomingCall(const DWORD dwMedia)
{
	_ASSERT(NULL == m_hLine);


	DWORD dwMediaForOpeningLine = dwMedia;
	if ( LINEMEDIAMODE_G3FAX & dwMedia)
	{
		//
		//fax calls are handled through data mode and passthrough
		//so we extract LINEMEDIAMODE_G3FAX and add LINEMEDIAMODE_DATAMODEM
		//
		dwMediaForOpeningLine = dwMediaForOpeningLine & ~LINEMEDIAMODE_G3FAX;
		dwMediaForOpeningLine = dwMediaForOpeningLine | LINEMEDIAMODE_DATAMODEM;
		m_isFaxCall = true;
	}

	//
	//we want to listen for incoming calls
	//we need to open the line at OWNER privilege
	//
	LineOpenWrapper(dwMediaForOpeningLine, LINECALLPRIVILEGE_OWNER);
}//void CTapi2Device::OpenLineForIncomingCall()



//*********************************************************************************
//* Name:	OpenLineForOutgoingCall
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Opens a line for outgoing call
//* PARAMETERS:
//*		[IN]	const DWORD dwMedia
//*					media mode to open line with, can be ONE of the followings:
//*						LINEMEDIAMODE_INTERACTIVEVOICE,
//*						LINEMEDIAMODE_AUTOMATEDVOICE,
//*						LINEMEDIAMODE_DATAMODEM,
//*						LINEMEDIAMODE_G3FAX
//*	RETURN VALUE:
//*		NONE
//*	REMARKS:
//*		the function uses CTapi2Device::LineOpenWrapper() with none privilege mode
//*********************************************************************************
void CTapi2Device::OpenLineForOutgoingCall(const DWORD dwMedia)
{
	_ASSERT(NULL == m_hLine);


	DWORD dwMediaForOpeningLine;
	if ( LINEMEDIAMODE_G3FAX == dwMedia)
	{
		//
		//fax calls are handled through data mode and passthrough
		//
		dwMediaForOpeningLine = LINEMEDIAMODE_DATAMODEM;
		m_isFaxCall = true;
	}
	else
	{
		dwMediaForOpeningLine = dwMedia;
	}

	//
	//we want to create outgoing calls
	//so we can open the line at NONE privilege
	//
	LineOpenWrapper(dwMediaForOpeningLine, LINECALLPRIVILEGE_NONE);
}//void CTapi2Device::OpenLineForOutgoingCall()




//*********************************************************************************
//* Name:	AnswerOfferingCall
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Answer the offering call using ::lineAnswer()
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		NONE
//*	REMARKS:
//*		we don't wait for a LINE_REPLY message here because of differnt behaviour:
//*		in NT4:
//*			A LINE_REPLY message arrives and then LINE_CALLSTATE
//*		in NT5
//*			A LINE_CALLSTATE message arrives and the a LINE_REPLY message
//*********************************************************************************
void CTapi2Device::AnswerOfferingCall()
{
	_ASSERT(NULL != m_hCall);


	if (m_isFaxCall)
	{
		//
		//FAX calls should be handled using PASS_THROUGH mode not using TAPI API:

		SetBearerModeToPASSTHROUGH();
		SetCommPortHandleFromCallHandle();
		FaxAnswerOfferingCall();
		return;
	}
	else
	{

		
		long lLineAnswerStatus = ::lineAnswer(m_hCall,APPLICATION_NAME_A,sizeof(APPLICATION_NAME_A));
		_ASSERT(0 != lLineAnswerStatus);		//return value shouldn't be 0, asynchronous function.
		if (0 > lLineAnswerStatus)
		{
			throw CException(
				TEXT("%s(%d): CTapi2Device::AnswerOfferingCall(), lineAnswer() failed, error code:0x%08x"), 
				TEXT(__FILE__),
				__LINE__,
				lLineAnswerStatus 
				);
		}
		_ASSERT(0 == m_lineAnswerID);
		m_lineAnswerID = lLineAnswerStatus;
	
		TapiLogDetail(LOG_X, 9, TEXT("::lineAnswer() request identifier=0x%x"),lLineAnswerStatus);
		//
		//we don't wait for a LINE_REPLY message here because of differnt behaviour:
		//in NT4:
		//	A LINE_REPLY message arrives and then LINE_CALLSTATE
		//in NT5
		//	A LINE_CALLSTATE message arrives and the a LINE_REPLY message
		//
	}
	return;
}//void CTapi2Device::AnswerOfferingCall()



//*********************************************************************************
//* Name:	CreateAndConnectCall
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Creates an outgoing call and connects it
//* PARAMETERS:
//*		[IN]	LPCTSTR szNum
//*					number to call to
//*		[IN]	const DWORD dwMedia
//*					media mode to open line with, must be ONE of the followings:
//*						LINEMEDIAMODE_INTERACTIVEVOICE,
//*						LINEMEDIAMODE_AUTOMATEDVOICE,
//*						LINEMEDIAMODE_DATAMODEM,
//*						LINEMEDIAMODE_G3FAX
//*	RETURN VALUE:
//*		NONE
//*	REMARKS:
//*		create a call using CTapi2Device::lineMakeCall()
//*		in tapi2 CTapi3Device::lineMakeCall() connects the call
//*********************************************************************************
void CTapi2Device::CreateAndConnectCall(LPCTSTR szNum, const DWORD dwMedia)
{
	_ASSERT(NULL == m_hCall);

	VerifyValidMediaModeForOutgoingCall(dwMedia);

	if (m_isFaxCall)
	{
		//
		//FAX calls should be handled using PASS_THROUGH mode not using TAPI API
		//
		FaxCreateAndConnectCall(szNum);
		return;
	}
	//
	//CallParams structure init
	//
	LINECALLPARAMS callParams;
	::ZeroMemory(&callParams,sizeof(callParams));
	callParams.dwTotalSize		=	sizeof(callParams);
	callParams.dwBearerMode		=	LINEBEARERMODE_VOICE;
	callParams.dwMinRate		=	0;
	callParams.dwMaxRate		=	0;			//0 meaning highest rate.
	callParams.dwMediaMode		=	dwMedia;
	callParams.dwAddressMode	=	LINEADDRESSMODE_ADDRESSID;
	callParams.dwAddressID		=	0;
	
	if (TRUE == IsCallActive())
	{
		throw CException(TEXT("CTapi2Device::CreateAndConnectCall(), there's another active call."));
	}
	
	long lineMakeCallStatus = ::lineMakeCall(
		m_hLine,
		&m_hCall,
		szNum,			//dest address.
		NULL,			//country code,NULL = default
		&callParams		//extra call parameters
		);
	_ASSERT(lineMakeCallStatus != 0);
	if (lineMakeCallStatus < 0)
	{
		m_hCall = NULL;		//m_hLine can change to be a non NULL value, this is a TAPI bug.
		throw CException(
			TEXT("%s(%d): CTapi2Device::CreateAndConnectCall(), lineMakeCall() failed, error code:0x%08x"), 
			TEXT(__FILE__),
			__LINE__,
			lineMakeCallStatus
			);
	}
	
	TapiLogDetail(LOG_X, 9, TEXT("::lineMakeCall() request identifier=0x%x"),lineMakeCallStatus);
	LINEMESSAGE lineMakeCallMessage;
	::ZeroMemory(&lineMakeCallMessage,sizeof(lineMakeCallMessage));
	lineGetRelevantMessage(&lineMakeCallMessage, TAPI2_DEFAULT_WAIT_FOR_MESSAGE_TIMEOUT, lineMakeCallStatus);

	//
	//check if the async lineMakeCall successed
	//
	if( (LINE_REPLY != lineMakeCallMessage.dwMessageID) || (0 != lineMakeCallMessage.dwParam2) )
	{
		m_hCall = NULL;		//m_hLine can change to be a non NULL value, this is a TAPI bug.
		throw CException(
			TEXT("%s(%d): CTapi2Device::CreateAndConnectCall(): after lineMakeCall(), LINE_REPLY returned error: 0x%08x"), 
			TEXT(__FILE__),
			__LINE__,
			lineMakeCallMessage.dwParam2
			);
	}
	_ASSERT(NULL != m_hCall);

}//void CTapi2Device::CreateAndConnectCall()





//*********************************************************************************
//* Name:	WaitForAnswererConnectState
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Wait for a connect state
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		NONE
//*	REMARKS:
//*		wait for a LINE_CALLSTATE which holds a CONNECT call state
//*		if the call is with fax media mode we invoke CTapi2Device::FaxWaitForConnectcall()
//*********************************************************************************
void CTapi2Device::WaitForAnswererConnectState()
{
	_ASSERT(NULL != m_hCall);


	if (m_isFaxCall)
	{
		//
		//FAX calls should be handled using PASS_THROUGH mode not using TAPI API:
		//
		FaxWaitForConnect();
		return;
	}
	
	LINEMESSAGE lineMessage;
	::ZeroMemory(&lineMessage,sizeof(lineMessage));
	
	//
	//we set IGNORE_LINEREPLY_MESSAGES because we don't won't any LINE_REPLY messages
	//
	while (1)
	{
		lineGetRelevantMessage(&lineMessage,TAPI2_DEFAULT_WAIT_FOR_MESSAGE_TIMEOUT,m_lineAnswerID);
		if( LINE_REPLY == lineMessage.dwMessageID)
		{
			if (0 != lineMessage.dwParam2)
			{
				m_lineAnswerID = 0;
				throw CException(
					TEXT("%s(%d): CTapi2Device::Call(): after lineAnswer(), failed, LINE_REPLY returned error: 0x%08x"), 
					TEXT(__FILE__),
					__LINE__,
					lineMessage.dwParam2
					);
			}
			continue;
		}
		if (LINE_CALLSTATE == lineMessage.dwMessageID)
		{
			if (lineMessage.hDevice != (HCALL) m_hCall)
			{
				TapiLogError(
					LOG_SEV_1, 
					TEXT("Got an unrelated LINE_CALLSTATE message, param1=0x%x, hDevice=0x%x"),
					lineMessage.dwParam1,
					lineMessage.hDevice
					);
			}

			switch(lineMessage.dwParam1)
			{
					
			case LINECALLSTATE_CONNECTED:
				TapiLogDetail(LOG_X, 5, TEXT("CONNECTED"));
				return;
			
			case LINECALLSTATE_ACCEPTED:
				TapiLogDetail(LOG_X, 8, TEXT("LINECALLSTATE_ACCEPTED"));
				break;

			case LINECALLSTATE_RINGBACK:
				TapiLogDetail(LOG_X, 8, TEXT("LINECALLSTATE_RINGBACK"));
				break;

			case LINECALLSTATE_PROCEEDING:
				TapiLogDetail(LOG_X, 8, TEXT("LINECALLSTATE_PROCEEDING"));
				break;

			case LINECALLSTATE_DISCONNECTED:
				throw CException(
					TEXT("%s(%d): CTapi2Device::Answer(), received LINE_CALLSTATE message of type LINECALLSTATE_DISCONNECTED"), 
					TEXT(__FILE__),
					__LINE__
					);
				
			default:
				m_lineAnswerID = 0;
				throw CException(
					TEXT("%s(%d): CTapi2Device::Answer(), received LINE_CALLSTATE message of type:0x%08x"), 
					TEXT(__FILE__),
					__LINE__,
					lineMessage.dwParam1
					);
				break;
			}
		}
	}//while(1)
	m_lineAnswerID= 0;		
}//void CTapi2Device::WaitForAnswererConnectState()



//*********************************************************************************
//* Name:	WaitForCallerConnectState
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Wait for a connect state
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		NONE
//*	REMARKS:
//*		wait for a LINE_CALLSTATE which holds a CONNECT call state
//*		if the call is with fax media mode we invoke CTapi2Device::FaxWaitForConnectcall()
//*********************************************************************************
void CTapi2Device::WaitForCallerConnectState()
{
	_ASSERT(NULL != m_hCall);


	if (m_isFaxCall)
	{
		//
		//FAX calls should be handled using PASS_THROUGH mode not using TAPI API
		FaxWaitForConnect();
		return;
	}

	LINEMESSAGE lineMakeCallMessage;
	::ZeroMemory(&lineMakeCallMessage,sizeof(lineMakeCallMessage));
	//
	//pass through all outgoing call-states (DialTone, Dialing, Proceeding, Connected):
	//
	while (TRUE)
	{
		//
		//we set IGNORE_LINEREPLY_MESSAGES because we don't won't any LINE_REPLY messages
		//
		lineGetRelevantMessage(&lineMakeCallMessage,TAPI2_DEFAULT_WAIT_FOR_MESSAGE_TIMEOUT,IGNORE_LINEREPLY_MESSAGES);

		if (LINE_CALLSTATE != lineMakeCallMessage.dwMessageID)
		{
			throw CException(TEXT("CTapi2Device::WaitForCallerConnectState(): LINECALL_STATE message didn't arrive"));
		}

		//
		//the message is a LINE_CALLSTATE message
		//
		if (lineMakeCallMessage.hDevice != (HCALL) m_hCall)
		{
			//
			//a LINE_CALLSTATE message which isn't releated to m_hCall
			TapiLogError(
				LOG_SEV_1, 
				TEXT("Got an unrelated LINE_CALLSTATE message, param1=0x%x, hDevice=0x%x"),
				lineMakeCallMessage.dwParam1,
				lineMakeCallMessage.hDevice
				);
		}

		
		switch(lineMakeCallMessage.dwParam1)
		{
		case LINECALLSTATE_DIALTONE:
			TapiLogDetail(LOG_X, 8, TEXT("LINECALLSTATE_DIALTONE"));
			break;

		case LINECALLSTATE_DIALING:
			TapiLogDetail(LOG_X, 8, TEXT("LINECALLSTATE_DIALING"));
			break;

		case LINECALLSTATE_PROCEEDING:
			TapiLogDetail(LOG_X, 8, TEXT("LINECALLSTATE_PROCEEDING"));
			break;

		case LINECALLSTATE_RINGBACK:
			TapiLogDetail(LOG_X, 8, TEXT("LINECALLSTATE_RINGBACK"));
			break;

		case LINECALLSTATE_SPECIALINFO:
			TapiLogDetail(LOG_X, 8, TEXT("LINECALLSTATE_SPECIALINFO"));
			break;

		case LINECALLSTATE_CONNECTED:
			TapiLogDetail(LOG_X, 5, TEXT("CONNECTED"));
			return;
		
		case LINECALLSTATE_BUSY:
			throw CException(TEXT("CTapi2Device::WaitForCallerConnectState(): the desired number is busy"));
			break;

		case LINECALLSTATE_DISCONNECTED:
			switch (lineMakeCallMessage.dwParam2)
			{
			case LINEDISCONNECTMODE_NOANSWER:
				throw CException(TEXT("CTapi2Device::WaitForCallerConnectState(): the remote end didn't answer"));
			case LINEDISCONNECTMODE_REJECT:
				throw CException(TEXT("CTapi2Device::WaitForCallerConnectState(): the remote end rejected the call"));
			case LINEDISCONNECTMODE_BUSY:
				throw CException(TEXT("CTapi2Device::WaitForCallerConnectState(): the desired number is busy"));
			case LINEDISCONNECTMODE_NODIALTONE:
				throw CException(TEXT("CTapi2Device::WaitForCallerConnectState(): No Dial Tone"));

			default:
				throw CException(
					TEXT("%s(%d): CTapi2Device::WaitForCallerConnectState(): after lineMakeCall(), LINE_DISCONNECTMODE is : 0x%08x"), 
					TEXT(__FILE__),
					__LINE__,
					lineMakeCallMessage.dwParam2
					);
			}
		default:
			throw CException(
				TEXT("%s(%d): CTapi2Device::WaitForCallerConnectState(), received LINE_CALLSTATE message of type:0x%08x"), 
				TEXT(__FILE__),
				__LINE__,
				lineMakeCallMessage.dwParam1
				);
			break; 
		}
	}
}//void CTapi2Device::WaitForCallerConnectState()





//*********************************************************************************
//* Name:	SendAnswerStream
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Send the answer stream according to the call's media mode
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		NONE
//*********************************************************************************
void CTapi2Device::SendAnswerStream()
{
	
	DWORD dwCallMediaMode = GetCallSupportedMediaModes();
		
	//
	//remove the UNKNOWN bit from the media modes
	//this is done becuase:
	//From the MSDN:
	//"If the unknown media-mode flag is set, other media flags can 
	//also be set. This is used to signify that the media is unknown
	//but that it is likely to be one of the other selected media modes." 
	dwCallMediaMode = (dwCallMediaMode & ~(LINEMEDIAMODE_UNKNOWN));

	switch (dwCallMediaMode)
	{
	
	case LINEMEDIAMODE_DATAMODEM :
		SendAnswerDataStream();
		break;
	
	case LINEMEDIAMODE_INTERACTIVEVOICE:
		SendAnswerVoiceStream();
		break;

	case LINEMEDIAMODE_AUTOMATEDVOICE:
		SendAnswerVoiceStream();
		break;

	case (LINEMEDIAMODE_INTERACTIVEVOICE | LINEMEDIAMODE_AUTOMATEDVOICE):
		SendAnswerVoiceStream();
		break;
	
	case LINEMEDIAMODE_G3FAX:
		SendAnswerFaxStream();
		break;
	
	default:
		throw CException(TEXT("CTapi2Device::SendAnswerStream(), Unknown media mode"));
	}

}//void CTapi2Device::SendAnswerStream()



//*********************************************************************************
//* Name:	SendCallerStream
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Send the caller stream according to the call's media mode
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		NONE
//*********************************************************************************
void CTapi2Device::SendCallerStream()
{
	DWORD dwCallMediaMode = GetCallSupportedMediaModes();

	switch (dwCallMediaMode)
	{
	
	case LINEMEDIAMODE_DATAMODEM :
		SendCallerDataStream();
		break;
	
	case LINEMEDIAMODE_INTERACTIVEVOICE:
		SendCallerVoiceStream();
		break;

	case LINEMEDIAMODE_AUTOMATEDVOICE:
		SendCallerVoiceStream();
		break;
	
	case LINEMEDIAMODE_G3FAX:
		SendCallerFaxStream();
		break;
	
	default:
		throw CException(TEXT("CTapi2Device::SendCallerStream(), Unknown media mode"));
	}

}



//*********************************************************************************
//* Name:	CleanUp
//* Author: Guy Merin / 03-Dec-98
//*********************************************************************************
//* DESCRIPTION:
//*		A cleanup function that dealloctes, releases, resets all the member variables
//*		The state of the object after calling this function is the same as a
//*		construcated object
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		NONE
//*	REMARKS:
//*		The object's message queue is cleared (from all the call's queued events)
//*********************************************************************************
void CTapi2Device::CleanUp()
{

	if (m_hCall)
	{
		HangUp();
		m_hCall = NULL;
	}

	if (m_isFaxCall)
	{
		CloseCommPortHandle();
		m_modemCommPortHandle = NULL;
		m_isFaxCall = false;
	}

	if (m_hLine)
	{
		m_hLine.Release();
	}
	m_lineAnswerID = 0;
	m_isFaxCall = false; 

}//void CTapi2Device::CleanUp()




//*********************************************************************************
//* Name:	CTapi2Device::GetFriendlyMediaMode()
//* Author:	Guy Merin
//* Date:	December 31, 1998
//*********************************************************************************
//* DESCRIPTION:
//*		A mapping between Tapi2 media modes to an abstarct media type
//* PARAMETERS:
//*		NONE
//* RETURN VALUE:
//*		A combination of the following
//*			MEDIAMODE_VOICE
//*			MEDIAMODE_INTERACTIVE_VOICE
//*			MEDIAMODE_AUTOMATED_VOICE
//*			MEDIAMODE_FAX
//*			MEDIAMODE_DATA
//*			MEDIAMODE_UNKNOWN
//*********************************************************************************
DWORD CTapi2Device::GetFriendlyMediaMode(void) const
{

	DWORD dwCallSupportedMediaMode = GetCallSupportedMediaModes();
	DWORD dwAbstractMediaMode = 0;
	
	if (dwCallSupportedMediaMode & LINEMEDIAMODE_UNKNOWN)
	{
		dwAbstractMediaMode = (dwAbstractMediaMode | MEDIAMODE_UNKNOWN);
	}

	if (dwCallSupportedMediaMode & LINEMEDIAMODE_INTERACTIVEVOICE)
	{
		dwAbstractMediaMode = (dwAbstractMediaMode | MEDIAMODE_INTERACTIVE_VOICE);
	}

	if (dwCallSupportedMediaMode & LINEMEDIAMODE_AUTOMATEDVOICE)
	{
		dwAbstractMediaMode = (dwAbstractMediaMode | MEDIAMODE_AUTOMATED_VOICE);
	}

	if (dwCallSupportedMediaMode & LINEMEDIAMODE_DATAMODEM)
	{
		dwAbstractMediaMode = (dwAbstractMediaMode | MEDIAMODE_DATA);
	}

	if (dwCallSupportedMediaMode & LINEMEDIAMODE_G3FAX)
	{
		dwAbstractMediaMode = (dwAbstractMediaMode | MEDIAMODE_FAX);
	}

	if (0 == dwAbstractMediaMode)
	{
		throw CException(
			TEXT("%s(%d): CTapi2Device::GetFriendlyMediaMode(), CTapi2Device::GetCallSupportedMediaModes() returned unsupported media mode(%d)"), 
			TEXT(__FILE__),
			__LINE__,
			dwCallSupportedMediaMode 
			);
	}
	
	return dwAbstractMediaMode;
}//CTapi2Device::GetFriendlyMediaMode()



//*********************************************************************************
//* Name:	CTapi2Device::GetDeviceSpecificMediaMode()
//* Author:	Guy Merin
//* Date:	January 07, 1999
//*********************************************************************************
//* DESCRIPTION:
//*		mapping between abstract media type and tapi2 media types
//* PARAMETERS:
//*		[IN]	const DWORD dwMedia
//*			abstract media mode
//* RETURN VALUE:
//*		a combination of the following Tapi2 media modes:
//*			LINEMEDIAMODE_AUTOMATEDVOICE
//*			LINEMEDIAMODE_INTERACTIVEVOICE
//*			LINEMEDIAMODE_DATAMODEM
//*			LINEMEDIAMODE_G3FAX
//*			LINEMEDIAMODE_UNKNOWN
//*********************************************************************************
DWORD CTapi2Device::GetDeviceSpecificMediaMode(const DWORD dwMedia)
{

	DWORD dwDeviceSpecificMediaMode = 0;

	//
	//voice
	//
	if (dwMedia & MEDIAMODE_AUTOMATED_VOICE)
	{
		dwDeviceSpecificMediaMode = (dwDeviceSpecificMediaMode | LINEMEDIAMODE_AUTOMATEDVOICE);
	}

	if (dwMedia & MEDIAMODE_INTERACTIVE_VOICE)
	{
		dwDeviceSpecificMediaMode = (dwDeviceSpecificMediaMode | LINEMEDIAMODE_INTERACTIVEVOICE);
	}

	if (dwMedia & MEDIAMODE_VOICE)
	{
		dwDeviceSpecificMediaMode = (dwDeviceSpecificMediaMode | LINEMEDIAMODE_INTERACTIVEVOICE);	
	}

	//
	//data
	//
	if (dwMedia & MEDIAMODE_DATA)
	{
		dwDeviceSpecificMediaMode = (dwDeviceSpecificMediaMode | LINEMEDIAMODE_DATAMODEM);
	}

	//
	//fax
	//
	if (dwMedia & MEDIAMODE_FAX)
	{
		dwDeviceSpecificMediaMode = (dwDeviceSpecificMediaMode | LINEMEDIAMODE_G3FAX);
	}

	//
	//unknown media mode
	//
	if (dwMedia & MEDIAMODE_UNKNOWN)
	{
		dwDeviceSpecificMediaMode = (dwDeviceSpecificMediaMode | LINEMEDIAMODE_UNKNOWN);
	}

	
	//
	//other unsupported media modes
	//
	if (0 == dwDeviceSpecificMediaMode)
	{
		throw CException(
			TEXT("%s(%d): CTapi2Device::GetDeviceSpecificMediaMode(), Unsupported media mode(%x)"), 
			TEXT(__FILE__),
			__LINE__,
			dwMedia
			);
	}

	return dwDeviceSpecificMediaMode;

	
}//DWORD CTapi2Device::GetDeviceSpecificMediaMode()











//*********************************************************************************
//* Name:	CTapi2Device::SetCallMediaMode()
//* Author:	Guy Merin
//* Date:	January 07, 1999
//*********************************************************************************
//* DESCRIPTION:
//*		This function sets the media mode(s) of the specified call in its 
//*		LINECALLINFO structure
//* PARAMETERS:
//*		[IN]	const DWORD dwMedia
//*			The new media mode(s) for the call. 
//*			 As long as the UNKNOWN media mode flag is set, 
//*			 other media mode flags may be set as well.
//*			 This is used to identify a call's media mode as not fully determined, 
//*			 but narrowed down to one of a small set of specified media modes. 
//*			 If the UNKNOWN flag is not set, only a single media mode can be specified
//* RETURN VALUE:
//*		NONE
//*********************************************************************************
void CTapi2Device::SetCallMediaMode(const DWORD dwMedia)
{
	_ASSERT(dwMedia);
	LONG lLineSetMediaModeStatus = ::lineSetMediaMode(m_hCall,dwMedia);		
	if (0 != lLineSetMediaModeStatus)
	{
		throw CException(
			TEXT("%s(%d): CTapi2Device::SetCallMediaMode(), ::lineSetMediaMode() failed with error: 0x%x"), 
			TEXT(__FILE__),
			__LINE__,
			lLineSetMediaModeStatus
			);
	}

}//void CTapi2Device::SetCallMediaMode()




//*********************************************************************************
//* Name:	CTapi2Device::SetApplicationPriorityForSpecificTapiDevice()
//* Author:	Guy Merin
//* Date:	January 11, 1999
//*********************************************************************************
//* DESCRIPTION:
//*		Make the current application as the highest/lowest priority application
//*		for a given combination of media modes
//* PARAMETERS:
//*		[IN]	const DWORD dwMedia
//*		a combination of the following Tapi2 media modes:
//*			LINEMEDIAMODE_AUTOMATEDVOICE
//*			LINEMEDIAMODE_INTERACTIVEVOICE
//*			LINEMEDIAMODE_DATAMODEM
//*			LINEMEDIAMODE_G3FAX
//*			LINEMEDIAMODE_UNKNOWN
//*		[IN]	const DWORD dwPriority
//*			0 lowest priority
//*			1 highest priority
//* RETURN VALUE:
//*		NONE
//*********************************************************************************
void CTapi2Device::SetApplicationPriorityForSpecificTapiDevice(const DWORD dwMedia,const DWORD dwPriority)
{
	//
	//unknown
	//
	if (LINEMEDIAMODE_UNKNOWN & dwMedia)
	{
		SetApplicationPriorityForOneMediaMode(LINEMEDIAMODE_UNKNOWN,dwPriority);	
	}

	//
	//voice
	//
	if (LINEMEDIAMODE_AUTOMATEDVOICE & dwMedia)
	{
		SetApplicationPriorityForOneMediaMode(LINEMEDIAMODE_AUTOMATEDVOICE,dwPriority);	
	}
	if (LINEMEDIAMODE_INTERACTIVEVOICE & dwMedia)
	{
		SetApplicationPriorityForOneMediaMode(LINEMEDIAMODE_INTERACTIVEVOICE,dwPriority);	
	}

	//
	//data
	//
	if (LINEMEDIAMODE_DATAMODEM & dwMedia)
	{
		SetApplicationPriorityForOneMediaMode(LINEMEDIAMODE_DATAMODEM,dwPriority);	
	}

	//
	//fax
	//
	if (LINEMEDIAMODE_G3FAX & dwMedia)
	{
		SetApplicationPriorityForOneMediaMode(LINEMEDIAMODE_G3FAX,dwPriority);	
	}
	
}//void CTapi2Device::SetApplicationPriorityForSpecificTapiDevice()




//*********************************************************************************
//* Name:	CTapi2Device::SetApplicationPriorityForOneMediaMode()
//* Author:	Guy Merin
//* Date:	January 11, 1999
//*********************************************************************************
//* DESCRIPTION:
//*		 wrapper function for ::lineSetAppPriority()
//* PARAMETERS:
//*		[IN]	const DWORD dwMediaMode
//*			media mode to change priority on	
//*		[IN]	const DWORD dwPriority
//*			new priority, possible values:
//*				0 for lowest priority
//*				1 for highest priority 
//* RETURN VALUE:
//*		NONE
//*********************************************************************************
void CTapi2Device::SetApplicationPriorityForOneMediaMode(const DWORD dwMediaMode,const DWORD dwPriority)
{
	_ASSERT( (1 == dwPriority) || (0 == dwPriority) );

	LONG lLineSetAppPriorityStatus = ::lineSetAppPriority(
		APPLICATION_NAME_T,                 
		dwMediaMode,                      
		NULL,  
		NULL,                    
		NULL,               
		dwPriority
		);
	if (0 != lLineSetAppPriorityStatus)
	{
		throw CException(
			TEXT("%s(%d): CTapi2Device::SetApplicationPriorityForOneMediaMode(), ::lineSetAppPriority() failed with error: 0x%x"), 
			TEXT(__FILE__),
			__LINE__,
			lLineSetAppPriorityStatus
			); 
	}
}//void CTapi2Device::SetApplicationPriorityForOneMediaMode()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\tapitools\querymodemcaps\main.h ===
void InitComAndTapi();
void ShutdownTapi();

void ListAllDevices();


void GetAddressFromTapiID(DWORD dwId,ITAddress** ppAddress);



bool IsDeviceUnimodemTSP(ITAddress *pAddress);

void QueryFaxCapabilityOfModem(ITAddress *pAddress);

void QueryAdaptiveAnswering(ITAddress *pAddress);

void RegistryQueryAdaptiveAnswering(BSTR szFriendlyName);


static HRESULT IsFaxCapable(
    LPCSTR szClassResp,
    BOOL *pfFaxCapable
	);

static void DisconnectCall(ITBasicCallControl *pBasicCallControl);

static HRESULT SynchWriteFile(
    HANDLE hFile,
    LPCVOID lpBuffer,
    DWORD nNumberOfBytesToWrite,
    LPDWORD lpNumberOfBytesWritten
	);

static HRESULT ReadModemResponse(
    HANDLE hFile,
    CHAR *szResponse,
    int nResponseMaxSize,
    DWORD *pdwActualRead,
    DWORD dwTimeOut
	);

static HRESULT SynchReadFile(
    HANDLE hFile,
    LPVOID lpBuffer,
    DWORD nNumberOfBytesToRead,
    LPDWORD lpNumberOfBytesRead
	);


//
// This structure is used to get the handle of the comm port
// and the device name when using the TAPI API lineGetID.
//
class DEVICE_ID {
public:
    HANDLE hComm;
    CHAR  szDeviceName[1];
    void __cdecl operator delete(void *p) { if (p) CoTaskMemFree(p); };
};

//
// The TSP name for unimodem as returned by
// pAddress->get_ServiceProviderName()
//
#define UNIMODEM_TSP_NAME TEXT("unimdm.tsp")

//
// the following string MUST be ANSI (sent to the modem)
// The modem class query string
//
#define MODEM_CLASS_QUERY_STRING "at+fclass=?\r"
#define MODEM_CLASS_QUERY_STRING_LENGTH \
    (sizeof(MODEM_CLASS_QUERY_STRING) - sizeof(char))


#define MODEM_ERROR_RESPONSE_STRING "ERROR"


//The maximum length of each adaptive answering command
#define MAX_ADAPTIVE_COMMAND_LEN 256


#define REG_FRIENDLY_NAME		TEXT("FriendlyName")
#define REG_UNIMODEM			TEXT("SYSTEM\\CurrentControlSet\\Control\\Class\\{4D36E96D-E325-11CE-BFC1-08002BE10318}")
#define REG_FAX_ADAPTIVE		TEXT("\\Fax\\Class1\\AdaptiveAnswer")
#define REG_FAX_ADAPTIVE_SIZE	sizeof(REG_FAX_ADAPTIVE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\tapitools\tapidevice\main.cpp ===
#include "Tapi3Device.h"
#include "Tapi2Device.h"
#include <iostream.h>
#include "log.h"
#include <TCHAR.H>

//////////////////////////////////////////////////////////////////////////////////////////
DWORD GetMediaModeEnumFromString(LPCTSTR mediaType);


//syntax:
// TapiDevice.exe <tapi3 / tapi2 > <call> <device id to call from> <number to call> <media mode>
// TapiDevice.exe <tapi3 / tapi2 > <answer> <device id to answer the incoming call on> <time out> <media mode>


void Usage()
{
	printf("\nUsage:\n");
	
	//
	//outbound call
	//
	printf("For outbound call:\n");
	printf("TapiDevice.exe <tapi3/tapi2 > <call> <Tapi device ID> <number to call> <media mode>\n");
	
	//
	//incoming call
	//
	printf("\nFor incoming call:\n");
	printf("TapiDevice.exe <tapi3/tapi2 > <answer> <Tapi device ID> <time out> <media mode>\n");
	
	//
	//tapi2 supported media modes
	//
	printf("\nTapi2 Supported Media modes:\n");
	printf(" voice \n voice_both \n voice_modem \n data \n fax \n");
	
	//
	//tapi3 supported media modes
	//
	printf("\nTapi3 Supported Media modes:\n");
	printf(" voice \n data \n fax \n");

	::exit(-1);

}//void Usage()




void main (int argc, char ** argvA)
{


	CTapiDevice * myTapiDevice = NULL;

	try
	{
		
		lgInitializeLogger();

		lgBeginSuite(TEXT("suite1"));
	
		lgBeginCase(1, TEXT("case 1"));
		
		if (6 != argc)
		{
			printf("Need 5 arguments\n");
			Usage();
		}
		
		TCHAR **argv;
#ifdef UNICODE
	   argv = CommandLineToArgvW( GetCommandLine(), &argc );
#else
		argv = argvA;
#endif
	
	
		if ( (0 != lstrcmp(argv[2],TEXT("call"))) && (0 != lstrcmp(argv[2],TEXT("answer"))) )
		{
			printf("agrv[2] must specify call or answer\n");
			Usage();
		}
	
		if (0 == lstrcmp(argv[1],TEXT("tapi3")))
		{
			//
			// need to coinit
			//
			HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
			if (FAILED(hr))
			{
				throw CException(TEXT("CoInitializeEx() failed error:0x%08x"),hr);
			}
			myTapiDevice = new CTapi3Device(_ttoi(argv[3]));
		}
		else if (0 == lstrcmp(argv[1],TEXT("tapi2")))
		{
			myTapiDevice = new CTapi2Device(_ttoi(argv[3]));
		}
		else
		{
			printf("agrv[1] must specify tapi3 or tapi2\n");
			Usage();
		}

		
		if (0 == lstrcmp(argv[2],TEXT("call")) )
		{
			//
			//call handling
			//
			myTapiDevice->Call(argv[4], GetMediaModeEnumFromString(argv[5]),true);
			::lgLogDetail(LOG_PASS, 2, TEXT("Call test "));
		}//call
		else if (0 == lstrcmp(argv[2],TEXT("answer")) )
		{
			//
			//answer handling
			//
			myTapiDevice->Answer(
				GetMediaModeEnumFromString(argv[5]),
				_ttol(argv[4]),
				true
				);
			::lgLogDetail(LOG_PASS, 2, TEXT("Answer test "));
		}//answer
		else
		{
			_ASSERT(false);
			Usage();
		}

		//
		//Convert to Fax Call
		//
		//myTapiDevice->ChangeToFaxCall(FAX_ANSWERER);
		myTapiDevice->ChangeToFaxCall(FAX_CALLER);
		
		
		//
		//proceed to hangup
		//
		myTapiDevice->HangUp();
		::lgLogDetail(LOG_PASS, 2, TEXT("HangUp test "));


	}
	catch(CException thrownException)
	{
		lgLogError(LOG_SEV_1,thrownException);
	}

	delete myTapiDevice;

	lgEndCase();

	lgEndSuite();

	lgCloseLogger();	
}


///////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////TAPI2//////////////////////////////////


//*****************************************************************************
//* Name:	GetMediaModeEnumFromString
//* Author: Guy Merin
//*****************************************************************************
//* DESCRIPTION:
//*		Receives a string of Media mode and returns the media mode as DWORD 
//*		the media mode is defined in TAPI.H
//* PARAMETERS:
//*		[IN]	LPCTSTR mediaType
//*					A pointer to a string that holds the media type
//*	RETURN VALUE:
//*		LINEMEDIAMODE_INTERACTIVEVOICE
//*			voice call made through a regular telephone
//*		LINEMEDIAMODE_AUTOMATEDVOICE
//*			voice call made through a voice modem
//*		LINEMEDIAMODE_DATAMODEM
//*			data call
//*		LINEMEDIAMODE_G3FAX
//*			fax call
//*		0		
//*			mediaType is NULL or ""
//*		LINEMEDIAMODE_UNKNOWN
//*			not one of the above media modes
//*****************************************************************************
DWORD GetMediaModeEnumFromString(LPCTSTR mediaType)
{

	if ( (lstrcmp(mediaType,TEXT("")) == 0) && (NULL == mediaType) )
	{
		return (0);
	}
	
	
	if (lstrcmp(mediaType,TEXT("voice_both")) == 0)
	{
		return(MEDIAMODE_INTERACTIVE_VOICE | MEDIAMODE_AUTOMATED_VOICE);
	}
	

	if (lstrcmp(mediaType,TEXT("voice")) == 0)
	{
		return(MEDIAMODE_INTERACTIVE_VOICE);
	}

	if (lstrcmp(mediaType,TEXT("voice_modem")) == 0)
	{
		return(MEDIAMODE_AUTOMATED_VOICE);
	}
	
	if (lstrcmp(mediaType,TEXT("data")) == 0)
	{
		return(MEDIAMODE_DATA);
	}

	if (lstrcmp(mediaType,TEXT("fax")) == 0)
	{
		return(MEDIAMODE_FAX);
	}

	_ASSERT(false);
	Usage();
	
	return(0); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\tapitools\sendonactivecall\main.cpp ===
//usage: SendOnActiveCall.exe <Tapi2/Tapi3> <deviceID> <Number to dial> <Voice/data> <Call State>


//
//headers
//
#include <windows.h>
#include <tapi.h>
#include <Exception.h>
#include <winfax.h>
#include <iostream.h>
#include <crtdbg.h>


//
//defines
//

//command loine params defines
#define NUMBER_OF_COMMANDLINE_PARAMS	6	//including application name
#define COMMANDLINE_PARAM_0				TEXT("SendOnActiveCall")
#define COMMANDLINE_PARAM_0_DESCRIPTION	TEXT("Application Name")				
#define COMMANDLINE_PARAM_1				TEXT("Tapi2/Tapi3")
#define COMMANDLINE_PARAM_1_DESCRIPTION	TEXT("Specify wheater to originate call in Tapi2 or Tapi3 APIs")				
#define COMMANDLINE_PARAM_2				TEXT("DeviceID")
#define COMMANDLINE_PARAM_2_DESCRIPTION	TEXT("Tapi DeviceID to use for calling")				
#define COMMANDLINE_PARAM_3				TEXT("Number To Dial")
#define COMMANDLINE_PARAM_3_DESCRIPTION	TEXT("Destination number to call")				
#define COMMANDLINE_PARAM_4				TEXT("Original Call media mode")
#define COMMANDLINE_PARAM_4_DESCRIPTION	TEXT("Specify wheater to originatte the call as Voice, InteractiveVoice or Data media mode")				
#define COMMANDLINE_PARAM_5				TEXT("Call state to handoff")
#define COMMANDLINE_PARAM_5_DESCRIPTION	TEXT("Handoff the call to Fax Service at this call state, possible states are:IDLE/DIALING/PROCEEDING/BUSY/CONNECTED/DISCONNECTED")				

//
//Tapi defines
//
#define IGNORE_LINEREPLY_MESSAGES		-1
#define TAPI2_DEFAULT_WAIT_FOR_MESSAGE_TIMEOUT			60000


//
//log defines
//
#define LOG_X 0
#define LOG_SEVERITY_DONT_CARE 0

#define LOG_SEV_1 1
#define LOG_SEV_2 2
#define LOG_SEV_3 3
#define LOG_SEV_4 4


//
//globals
//

//
//Tapi stuff
//
HLINEAPP g_hLineApp		= NULL;
HLINE g_hLine			= NULL;
HCALL g_hCall			= NULL;
DWORD g_dwAPIVersion	= 0x00020000;
DWORD g_dwUserDeviceID	= 0;

//
//Fax service
//
HANDLE	g_hFaxServer	= NULL;






//*********************************************************************************
//* Name:	TapiLogError
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Wrapper for ::lgLogError(), logs a message with the Tapi's properties
//* PARAMETERS:
//*		[IN]	DWORD dwSeverity 
//*					log severity, passed to ::lgLogError()
//*		[IN]	const TCHAR * const szLogDescription
//*					description format, 
//*		[IN]	...
//*					extra parameters as specified in szLogDescription parameter
//*	RETURN VALUE:
//*		NONE
//*********************************************************************************
void TapiLogError(
	DWORD dwSeverity,
	const TCHAR * const szLogDescription,
	...
	)
{
	TCHAR szLog[1024];
	szLog[1023] = '\0';
	va_list argList;
	va_start(argList, szLogDescription);
	::_vsntprintf(szLog, 1023, szLogDescription, argList);
	va_end(argList);

	cout<<endl<<"*************Tapi Log ERROR******************************"<<endl;
	cout <<"Error, severity("<<dwSeverity<<"):"<<endl;
	cout <<"LINEAPP= 0x"<<g_hLineApp<<endl;
	cout <<"DeviceID= "<<g_dwUserDeviceID<<endl;
	cout <<"Decription: "<<szLog<<endl;
	cout<<"*********************************************************"<<endl;
	

}//TapiLogError()

void TapiLogDetail(
	DWORD dwLevel,
	DWORD dwSeverity,
	const TCHAR * const szLogDescription,
	...
	)
{
	TCHAR szLog[1024];
	szLog[1023] = '\0';
	va_list argList;
	va_start(argList, szLogDescription);
	::_vsntprintf(szLog, 1023, szLogDescription, argList);
	va_end(argList);

	cout<<endl<<"*************Tapi Log Detail******************************"<<endl;
	cout <<"Details, Level("<<dwLevel<<"), severity("<<dwSeverity<<"):"<<endl;
	cout <<"LINEAPP= 0x"<<g_hLineApp<<endl;
	cout <<"DeviceID= "<<g_dwUserDeviceID<<endl;
	cout <<"Decription: "<<szLog<<endl;
	cout<<endl<<"**********************************************************"<<endl;
	
}//TapiLogDetail()

//*********************************************************************************
//* Name:	lineGetRelevantMessage
//* Author: Guy Merin / 24-Sep-98
//*********************************************************************************
//* DESCRIPTION:
//*		fetches only the messages related to the current call (g_hCall)
//*		or to the current requestID
//*		the only returned messages are of type:
//*			LINE_REPLY
//*			LINE_CALLSTATE
//*			LINE_CALLINFO
//*			LINE_MONITORDIGITS
//*			LINE_GENERATE
//* PARAMETERS:
//*		[OUT]	LINEMESSAGE *lineMessage
//*					the message
//*		[IN]	DWORD dwTimeOut
//*					timeout in milliseconds to wait for the message.
//*		[IN]	long requestID
//*					the related request ID for this message,
//*					If this parameter is IGNORE_LINEREPLY_MESSAGES, the caller 
//*					isn't interested in LINE_REPLY messages
//*	RETURN VALUE:
//*		NONE
//*********************************************************************************
void lineGetRelevantMessage(
	LINEMESSAGE *lineMessage,
	const DWORD dwTimeOut,
	const long requestID
	)
{

	long lineGetMessageStatus = 0;
	
	while(TRUE)
	{
		lineGetMessageStatus = ::lineGetMessage(g_hLineApp,lineMessage,dwTimeOut);
		
		if (LINEERR_OPERATIONFAILED == lineGetMessageStatus)
		{
			throw CException(
				TEXT("%s(%d): lineGetRelevantMessage(): TIMEOUT for lineGetMessage() using %d milliseconds"), 
				TEXT(__FILE__),
				__LINE__,
				dwTimeOut
				);
		}

		//
		//log the message 
		//
		//TapiLogDetail(
		//	LOG_X, 
		//	9, 
		//	TEXT("Got message of type %d hDevice=%x0x, dwParam1=%x0x, dwParam2=%x0x, dwParam3=%x0x"),
		//	lineMessage->dwMessageID,
		//	lineMessage->hDevice,
		//	lineMessage->dwParam1,
		//	lineMessage->dwParam2,
		//	lineMessage->dwParam3
		//	);

		
		switch (lineMessage->dwMessageID)
		{
		
		case LINE_REPLY:
			if (requestID == IGNORE_LINEREPLY_MESSAGES)
			{
				//
				//caller isn't interested in LINE_REPLY messages
				//so fetch next message
				//
				continue;
			}
			else if (requestID == (long) lineMessage->dwParam1)
			{
				//
				//the message is a LINE_REPLY message
				//related to the requestID
				//
				return;
			}
			else
			{
				TapiLogError(
					LOG_SEV_1, 
					TEXT("Got an unrelated LINE_REPLY message, param1= 0x%x, param2= 0x%x"),
					lineMessage->dwParam1,
					lineMessage->dwParam2
					);
			}
			break;
		
		
		case LINE_CALLSTATE:
			if (g_hCall != (HCALL) lineMessage->hDevice)
			{
				TapiLogError(
					LOG_SEV_1, 
					TEXT("Got an unrelated LINE_CALLSTATE message, param1= 0x%x, hDevice= 0x%x"),
					lineMessage->dwParam1,
					lineMessage->hDevice
					);
			}
	
			//
			//the message is a LINE_CALLSTATE message
			//related to the h_call 
			//
			return;
		
		
		case LINE_CALLINFO:
			if (g_hCall != (HCALL) lineMessage->hDevice)
			{
				TapiLogError(
					LOG_SEV_1, 
					TEXT("Got an unrelated LINE_CALLINFO message, param1=0x%x, hDevice=0x%x"),
					lineMessage->dwParam1,
					lineMessage->hDevice
					);
			}
			
			TapiLogDetail(LOG_X,9, TEXT("Got a LINE_CALLINFO of type 0x%x"),lineMessage->dwParam1);
			break;

		case LINE_MONITORDIGITS:
			if (g_hCall != (HCALL) lineMessage->hDevice)
			{
				TapiLogError(
					LOG_SEV_1, 
					TEXT("Got an unrelated LINE_MONITORDIGITS message, param1= 0x%x, hDevice= 0x%x"),
					lineMessage->dwParam1,
					lineMessage->hDevice
					);
			}
			if (LINEDIGITMODE_DTMF != lineMessage->dwParam2)
			{
				TapiLogError(
					LOG_SEV_1, 
					TEXT("Got a LINE_MONITORDIGITS message without DTMF digit mode, digit mode = %d"),
					lineMessage->dwParam2
					);
			}
			return;

		case	LINE_GENERATE:
			if (g_hCall != (HCALL) lineMessage->hDevice)
			{
				TapiLogError(
					LOG_SEV_1, 
					TEXT("Got an unrelated LINE_MONITORDIGITS message, param1= 0x%x, hDevice= 0x%x"),
					lineMessage->dwParam1,
					lineMessage->hDevice
					);
			}
			return;

		default:
			TapiLogError(
					LOG_SEV_1, 
					TEXT("Got an unrelated 0x%x message, hDevice= 0x%x, param1= 0x%x, param2= 0x%x, param3= 0x%x"),
					lineMessage->dwMessageID,
					lineMessage->hDevice,
					lineMessage->dwParam1,
					lineMessage->dwParam2,
					lineMessage->dwParam3
					);
			break;
		}
	}//while

}//lineGetRelevantMessage

//*********************************************************************************
//* Name:	WaitForDesiredCallState
//* Author: Guy Merin / 22-May-01
//*********************************************************************************
//* DESCRIPTION:
//*		Wait for a desired Tapi call state and then return
//* PARAMETERS:
//*		DWORD dwCallStateToHandoffIn
//*			The Tapi Call state to wait for
//*	RETURN VALUE:
//*		NONE
//*	REMARKS:
//*		wait for a LINE_CALLSTATE which holds a desired call state
//*********************************************************************************
void WaitForDesiredCallState(DWORD dwCallStateToHandoffIn)
{
	_ASSERT(NULL != g_hCall);


	LINEMESSAGE lineMakeCallMessage;
	::ZeroMemory(&lineMakeCallMessage,sizeof(lineMakeCallMessage));
	
	//
	//pass through all outgoing call-states (DialTone, Dialing, Proceeding, Connected):
	//
	while (TRUE)
	{
		//
		//we set IGNORE_LINEREPLY_MESSAGES because we don't won't any LINE_REPLY messages
		//
		lineGetRelevantMessage(&lineMakeCallMessage,TAPI2_DEFAULT_WAIT_FOR_MESSAGE_TIMEOUT,IGNORE_LINEREPLY_MESSAGES);

		if (LINE_CALLSTATE != lineMakeCallMessage.dwMessageID)
		{
			throw CException(TEXT("WaitForDesiredCallState(): LINECALL_STATE message didn't arrive"));
		}

		//
		//the message is a LINE_CALLSTATE message
		//
		if (lineMakeCallMessage.hDevice != (HCALL) g_hCall)
		{
			//
			//a LINE_CALLSTATE message which isn't releated to g_hCall
			TapiLogError(
				LOG_SEV_1, 
				TEXT("Got an unrelated LINE_CALLSTATE message, param1= 0x%x, hDevice= 0x%x"),
				lineMakeCallMessage.dwParam1,
				lineMakeCallMessage.hDevice
				);
		}

		
		switch(lineMakeCallMessage.dwParam1)
		{
		case LINECALLSTATE_IDLE:
			TapiLogDetail(LOG_X, 8, TEXT("LINECALLSTATE_IDLE"));
			break;
		
		case LINECALLSTATE_DIALTONE:
			TapiLogDetail(LOG_X, 8, TEXT("LINECALLSTATE_DIALTONE"));
			break;

		case LINECALLSTATE_DIALING:
			TapiLogDetail(LOG_X, 8, TEXT("LINECALLSTATE_DIALING"));
			break;

		case LINECALLSTATE_PROCEEDING:
			TapiLogDetail(LOG_X, 8, TEXT("LINECALLSTATE_PROCEEDING"));
			break;

		case LINECALLSTATE_RINGBACK:
			TapiLogDetail(LOG_X, 8, TEXT("LINECALLSTATE_RINGBACK"));
			break;

		case LINECALLSTATE_SPECIALINFO:
			TapiLogDetail(LOG_X, 8, TEXT("LINECALLSTATE_SPECIALINFO"));
			break;

		case LINECALLSTATE_CONNECTED:
			TapiLogDetail(LOG_X, 5, TEXT("LINECALLSTATE_CONNECTED"));
			break;
		
		case LINECALLSTATE_BUSY:
			throw CException(TEXT("WaitForDesiredCallState(): the desired number is busy"));
			break;

		case LINECALLSTATE_DISCONNECTED:
			switch (lineMakeCallMessage.dwParam2)
			{
			case LINEDISCONNECTMODE_NORMAL:
				TapiLogDetail(LOG_X, 8, TEXT("LINECALLSTATE_DISCONNECTED"));
				break;
			case LINEDISCONNECTMODE_NOANSWER:
				TapiLogDetail(LOG_X, 8, TEXT("LINECALLSTATE_DISCONNECTED: the remote end didn't answer"));
				break;
			case LINEDISCONNECTMODE_REJECT:
				TapiLogDetail(LOG_X, 8, TEXT("LINECALLSTATE_DISCONNECTED: the remote end rejected the call"));
				break;
			case LINEDISCONNECTMODE_BUSY:
				TapiLogDetail(LOG_X, 8, TEXT("LINECALLSTATE_DISCONNECTED: the desired number is busy"));
				break;
			case LINEDISCONNECTMODE_NODIALTONE:
				TapiLogDetail(LOG_X, 8, TEXT("LINECALLSTATE_DISCONNECTED: No Dial Tone"));
				break;
			case LINEDISCONNECTMODE_BADADDRESS:
				TapiLogDetail(LOG_X, 8, TEXT("LINECALLSTATE_DISCONNECTED: Bad Number"));
				break;
			default:
				TapiLogDetail(LOG_X, 8, TEXT("LINECALLSTATE_DISCONNECTED: of type: 0x%08x"),lineMakeCallMessage.dwParam2);
			}
			break;
		default:
			throw CException(
				TEXT("%s(%d): WaitForDesiredCallState(), received LINE_CALLSTATE message of type: 0x%08x"), 
				TEXT(__FILE__),
				__LINE__,
				lineMakeCallMessage.dwParam1
				);
			break; 
		}

		//
		//OK, after we logged the event, is it the event we're waiting for?
		//
		if (lineMakeCallMessage.dwParam1 == dwCallStateToHandoffIn)
		{
			//
			//We got it, we can now return
			//
			return;
		}

		//
		//Didn't get the desired message, wait for it again...
		//
	}
}//WaitForDesiredCallState()





void LineInitializeExWrapper()
{

	
	//
	//lineInitializeExParams structure init
	//
	LINEINITIALIZEEXPARAMS lineInitializeExParams;
	::ZeroMemory(&lineInitializeExParams,sizeof (lineInitializeExParams));
	lineInitializeExParams.dwTotalSize = sizeof (lineInitializeExParams);
	lineInitializeExParams.dwOptions = LINEINITIALIZEEXOPTION_USEEVENT;

	DWORD dwNumDevs=0;

	long lineInitializeStatus = ::lineInitializeEx(
		&g_hLineApp,
		GetModuleHandle(NULL),		//client application HINSTANCE.
		NULL,						//TAPI messages through Events, no callback function.
		TEXT("SendOnActiveCall"),
		&dwNumDevs,				//Number of devices.
		&g_dwAPIVersion,			//TAPI API highest supported version.
		&lineInitializeExParams
		);
	if (0 != lineInitializeStatus)
	{
		throw CException(
			TEXT("%s(%d): LineInitializeExWrapper() lineInitializeEx() failed, error code: 0x%08x"), 
			TEXT(__FILE__),
			__LINE__,
			lineInitializeStatus 
			);
	}

	if (g_dwUserDeviceID >= dwNumDevs)
	{
		throw CException(
			TEXT("%s(%d): LineInitializeExWrapper(), given deviceID(%d) exceed dwNumDevs(%d)"), 
			TEXT(__FILE__),
			__LINE__,
			g_dwUserDeviceID, 
			dwNumDevs
			);
	}


}//LineInitializeExWrapper()

void InitLineCallParams(LINECALLPARAMS *callParams,const DWORD dwMediaMode) 
{

	//
	//CallParams structure init
	//
	callParams->dwBearerMode		=	LINEBEARERMODE_VOICE;
	callParams->dwMinRate		=	0;
	callParams->dwMaxRate		=	0;	//0 = highest rate.
	callParams->dwMediaMode		=	dwMediaMode;
	callParams->dwAddressMode	=	1;
	callParams->dwAddressID		=	0;

}//InitLineCallParams()


void LineOpenWrapper(DWORD dwDeviceID,DWORD dwMediaMode)
{
	//
	//proceed with opening the line:
	//
	LINECALLPARAMS callParams;
	::ZeroMemory(&callParams, sizeof(callParams));
	callParams.dwTotalSize = sizeof(callParams);
	InitLineCallParams(&callParams,dwMediaMode);
	

	
	g_hLine = NULL;
	
	long lLineOpenStatus = ::lineOpen(
		g_hLineApp,
		dwDeviceID,
		&g_hLine,
		g_dwAPIVersion,
		NULL,						//Extension version number
		NULL,						//callback instance
		LINECALLPRIVILEGE_NONE,		//LINECALLPRIVILEGE_OWNER + LINECALLPRIVILEGE_MONITOR,
		dwMediaMode,
		&callParams);				//extra call parameters
	if (0 != lLineOpenStatus)
	{
		g_hLine = NULL;				//BUG IN TAPI, m_hLine changes even if ::lineOpen() failed
		throw CException(
			TEXT("%s(%d): LineOpenWrapper(), lineOpen() failed, error code: 0x%08x"), 
			TEXT(__FILE__),
			__LINE__,
			lLineOpenStatus
			);
	}

}//LineOpenWrapper



void LineMakeCallWrapper(TCHAR *szNumberToDial,DWORD dwMediaMode)
{
	//
	//CallParams structure init
	//
	LINECALLPARAMS callParams;
	::ZeroMemory(&callParams,sizeof(callParams));
	callParams.dwTotalSize		=	sizeof(callParams);
	callParams.dwBearerMode		=	LINEBEARERMODE_VOICE;
	callParams.dwMinRate		=	0;
	callParams.dwMaxRate		=	0;			//0 meaning highest rate.
	callParams.dwMediaMode		=	dwMediaMode;
	callParams.dwAddressMode	=	LINEADDRESSMODE_ADDRESSID;
	callParams.dwAddressID		=	0;
	
	
	long lLineMakeCallStatus = ::lineMakeCall(
		g_hLine,
		&g_hCall,
		szNumberToDial,	//dest address.
		NULL,			//country code,NULL = default
		&callParams		//extra call parameters
		);
	
	if (lLineMakeCallStatus < 0)
	{
		g_hCall = NULL;		//m_hLine can change to be a non NULL value, this is a TAPI bug.
		throw CException(
			TEXT("%s(%d): LineMakeCallWrapper(), lineMakeCall() failed, error code: 0x%08x"), 
			TEXT(__FILE__),
			__LINE__,
			lLineMakeCallStatus
			);
	}
	
	//
	//Let's verify the async lineMakeCall succeded
	//
	TapiLogDetail(LOG_X, 9, TEXT("lineMakeCall() sucedded, request identifier= 0x%x"),lLineMakeCallStatus);
	LINEMESSAGE lineMakeCallMessage;
	::ZeroMemory(&lineMakeCallMessage,sizeof(lineMakeCallMessage));
	lineGetRelevantMessage(&lineMakeCallMessage, TAPI2_DEFAULT_WAIT_FOR_MESSAGE_TIMEOUT, lLineMakeCallStatus);

	//
	//check if the async lineMakeCall successed
	//
	if (LINE_REPLY != lineMakeCallMessage.dwMessageID)
	{
		throw CException(
			TEXT("%s(%d): LineMakeCallWrapper(): after lineMakeCall(), received message isn't LINE_REPLY, Tapi returned the message type: 0x%08x"), 
			TEXT(__FILE__),
			__LINE__,
			lineMakeCallMessage.dwMessageID
			);
	}
	else
	{
		//
		//verify the async LineMakeCall returned a valid LINE_REPLY
		//
		if (0 != lineMakeCallMessage.dwParam2)
		{
			throw CException(
				TEXT("%s(%d): LineMakeCallWrapper(): after lineMakeCall(), LINE_REPLY returned error: 0x%08x"), 
				TEXT(__FILE__),
				__LINE__,
				lineMakeCallMessage.dwParam2
				);
		}
		//
		//LINE_REPLY is good, continue
		//
	}
	_ASSERT(NULL != g_hCall);


}//LineMakeCallWrapper



void FaxConnectFaxServerWrapper()
{	
	//
	//Connect to the local fax server
	//
	if (!FaxConnectFaxServer(NULL, &g_hFaxServer))
	{
		throw CException(
			TEXT("%s(%d): FaxConnectFaxServerWrapper: FaxConnectFaxServer, failed, error code: 0x%08x"), 
			TEXT(__FILE__),
			__LINE__,
			GetLastError()
			);
	}


}//FaxConnectFaxSeverWrapper



void FaxSendDocumentWrapper()
{	
	FAX_JOB_PARAM FaxJobParams = {0};
	FAX_COVERPAGE_INFO FaxCoverpageInfo = {0};
	DWORD dwJobId = 0;

	FaxJobParams.SizeOfStruct = sizeof(FAX_JOB_PARAM);
	
	
	//
	//The following are because of a bug in Fax binaries, EdgeBugs#:
	//
	FaxJobParams.RecipientName = TEXT("Recip Name");
	FaxJobParams.ScheduleAction  = JSA_NOW;
	FaxJobParams.RecipientNumber = TEXT("ThisIsANumber");
	
	
	FaxJobParams.DeliveryReportType = DRT_NONE;
	FaxJobParams.CallHandle = g_hCall; 
	
	FaxCoverpageInfo.SizeOfStruct = sizeof(FAX_COVERPAGE_INFO);
	FaxCoverpageInfo.CoverPageName = TEXT("FYI");
	FaxCoverpageInfo.UseServerCoverPage = TRUE;	

	//
	//Send a fax with the following info:
	//File name to send: fax.txt on the current directory
	//
	if (!FaxSendDocument(
		g_hFaxServer,			// handle to the fax server
		//TEXT("fax.txt"),					// file with data to transmit
		NULL,
		&FaxJobParams,			// pointer to job information structure
		&FaxCoverpageInfo,      // pointer to local cover page structure
		&dwJobId				// fax job identifier
		))	
	{
		throw CException(
			TEXT("%s(%d): FaxSendDocumentWrapper: FaxSendDocument(), failed, error code: 0x%08x"), 
			TEXT(__FILE__),
			__LINE__,
			GetLastError()
			);
	}


}//FaxSendDocumentWrapper

void ShowUsage()
{
	//
	//usage: SendOnActiveCall.exe <Tapi2/Tapi3> <deviceID> <Number to dial> <Voice/InteractiveVoice/data> <Call State>
	//
	cout<<COMMANDLINE_PARAM_0<<endl;
	cout<<endl<<"This tool is used for testing faxing on an active call (with a valid Call Handle HCALL)"<<endl;
	cout<<endl<<"Usage:"<<endl;
	cout<<COMMANDLINE_PARAM_0;
	cout<<" <"<<COMMANDLINE_PARAM_1<<">";
	cout<<" <"<<COMMANDLINE_PARAM_2<<">";
	cout<<" <"<<COMMANDLINE_PARAM_3<<">";
	cout<<" <"<<COMMANDLINE_PARAM_4<<">";
	cout<<" <"<<COMMANDLINE_PARAM_5<<">"<<endl;
	cout<<"where the params are:"<<endl;
	cout<<COMMANDLINE_PARAM_1<<" : "<<COMMANDLINE_PARAM_1_DESCRIPTION<<endl;
	cout<<COMMANDLINE_PARAM_2<<" : "<<COMMANDLINE_PARAM_2_DESCRIPTION<<endl;
	cout<<COMMANDLINE_PARAM_3<<" : "<<COMMANDLINE_PARAM_3_DESCRIPTION<<endl;
	cout<<COMMANDLINE_PARAM_4<<" : "<<COMMANDLINE_PARAM_4_DESCRIPTION<<endl;
	cout<<COMMANDLINE_PARAM_5<<" : "<<COMMANDLINE_PARAM_5_DESCRIPTION<<endl;
}//ShowUsage

void ParseCommandLineParas(int argc, TCHAR *argv[], bool *bUseTapi2, DWORD *dwDeviceID,TCHAR *szNumberToDial,DWORD *dwMediaMode,DWORD *dwCallStateToHandoffIn)
{
	if (NUMBER_OF_COMMANDLINE_PARAMS != argc)
	{
		ShowUsage();
		throw CException(
			TEXT("%s(%d): Not enough parameters, you should supply %d parameteres not %d"), 
			TEXT(__FILE__),
			__LINE__,
			NUMBER_OF_COMMANDLINE_PARAMS-1,
			argc 
			);
	}
	//
	//Parse command line params
	//usage: SendOnActiveCall.exe <Tapi2/Tapi3> <deviceID> <Number to dial> <Voice/InteractiveVoice/data> <Call State>
	//
	if (0 == _tcsicmp(TEXT("tapi3"), argv[1]))
	{
		//
		//user wants a Tapi3 call handle
		//
		*bUseTapi2 = false;
	}
	else
	{	//
		//the default is Tapi2
		//
		*bUseTapi2 = true;
	}
	*dwDeviceID = _ttoi(argv[2]);
	_tcscpy(szNumberToDial,argv[3]);
	if (0 == _tcsicmp(TEXT("voice"), argv[4]))
	{
		//
		//user selected Voice media mode
		//
		*dwMediaMode = LINEMEDIAMODE_AUTOMATEDVOICE;
	}
	if (0 == _tcsicmp(TEXT("InteractiveVoice"), argv[4]))
	{
		//
		//user selected Interactive Voice media mode
		//
		*dwMediaMode = LINEMEDIAMODE_INTERACTIVEVOICE;
	}
	else
	{
		//
		//Default is data mediamode
		//
		*dwMediaMode = LINEMEDIAMODE_DATAMODEM;
	}

	//
	//find out which call state we should handoff the call
	//
	if (0 == _tcsicmp(TEXT("IDLE"), argv[5]))
	{
		*dwCallStateToHandoffIn = LINECALLSTATE_IDLE;
	}
	else if (0 == _tcsicmp(TEXT("DIALING"), argv[5]))
	{
		*dwCallStateToHandoffIn = LINECALLSTATE_DIALING;
	}
	else if (0 == _tcsicmp(TEXT("PROCEEDING"), argv[5]))
	{
		*dwCallStateToHandoffIn = LINECALLSTATE_PROCEEDING;
	}
	else if (0 == _tcsicmp(TEXT("BUSY"), argv[5]))
	{
		*dwCallStateToHandoffIn = LINECALLSTATE_BUSY;
	}
	else if (0 == _tcsicmp(TEXT("CONNECTED"), argv[5]))
	{
		*dwCallStateToHandoffIn = LINECALLSTATE_CONNECTED;
	}
	else if (0 == _tcsicmp(TEXT("DISCONNECTED"), argv[5]))
	{
		*dwCallStateToHandoffIn = LINECALLSTATE_DISCONNECTED;
	}
	else
	{
		//
		//We default to Connected
		//
		*dwCallStateToHandoffIn = LINECALLSTATE_CONNECTED;
	}


}//ParseCommandLineParas

int __cdecl wmain(int argc, wchar_t *argv[ ], wchar_t *envp[ ])
{
	TCHAR szNumberToDial[MAX_PATH];
	DWORD dwMediaMode = LINEMEDIAMODE_UNKNOWN;
	DWORD dwCallStateToHandoffIn = LINECALLSTATE_CONNECTED;
	bool bUseTapi2 = true;
	
	try
	{
		ParseCommandLineParas(argc,argv,&bUseTapi2,&g_dwUserDeviceID,szNumberToDial,&dwMediaMode,&dwCallStateToHandoffIn);
		
		//
		//Connect to the fax service (we do this now because this operqation is time consuming)
		//
		FaxConnectFaxServerWrapper();
		LineInitializeExWrapper();
		LineOpenWrapper(g_dwUserDeviceID, dwMediaMode);
		LineMakeCallWrapper(szNumberToDial, dwMediaMode);
		WaitForDesiredCallState(dwCallStateToHandoffIn);
		
		//
		//Call is ready for handoff, let's now send a fax document on this call
		//
		FaxSendDocumentWrapper();
	}
	catch(CException ceThrownException)
	{
		cout<<ceThrownException;
	}

	char cPauseChar;
	cout <<endl<<"Press any key and Enter to continue"<<endl;
	cin	>> cPauseChar;
	
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\tapitools\tapidevice\tapi2smartpointer.h ===
//Tapi2SmartPointer.h

#ifndef _TAPI2_SMARTPOINTER_H
#define _TAPI2_SMARTPOINTER_H

#include <tapi.h>



class CAutoCloseHCALL
{
public:
	CAutoCloseHCALL(HCALL hCall = NULL)
	{ 
		m_hCall = hCall;
	};
    
	~CAutoCloseHCALL()
	{
		Release();
	};
   
	CAutoCloseHCALL & operator =(HCALL hCall) 
	{
		m_hCall = hCall; 
		return *this; 
	};
    
	HCALL * operator &()
	{ 
		return &m_hCall; 
	};
    
	operator HCALL() const
	{
		return m_hCall; 
	};

	HCALL Detach()
	{
		HCALL oldHLINE = m_hCall;
		m_hCall = NULL;
		return oldHLINE;
	};

	void Release()
	{
		if (m_hCall)
		{
			long lineDeallocateCallStatus = ::lineDeallocateCall(m_hCall);
			if (lineDeallocateCallStatus)
			{
				throw CException(
					TEXT("%s(%d): CAutoCloseHCALL::Release(), ::lineDeallocateCall() failed, error code:0x%08x"), 
					TEXT(__FILE__),
					__LINE__,
					lineDeallocateCallStatus
					);
			}
			m_hCall = NULL;
		}
	};
		

private:
    HCALL m_hCall;
};




class CAutoCloseLineHandle
{
public:
	CAutoCloseLineHandle(HLINE hLine = NULL)
	{ 
		m_hLine = hLine;
	};
    
	~CAutoCloseLineHandle()
	{
		Release();
	};
   
	CAutoCloseLineHandle & operator =(HLINE hLine) 
	{
		m_hLine = hLine; 
		return *this; 
	};
    
	HLINE * operator &()
	{ 
		return &m_hLine; 
	};
    
	operator HLINE() 
	{
		return m_hLine; 
	};

	HLINE Detach()
	{
		HLINE oldHLINE = m_hLine;
		m_hLine = NULL;
		return oldHLINE;
	};

	void Release()
	{
		if (m_hLine) 
		{
			long status = ::lineClose(m_hLine);
			if (status)
			{
				throw CException(
					TEXT("%s(%d): CAutoCloseLineHandle::Release(), ::lineClose() call failed, error code 0x%08x"),
					TEXT(__FILE__),
					__LINE__,
					status
					);
			}
		}
		m_hLine = NULL;
	};
		

private:
    HLINE m_hLine;
};



class CAutoCloseLineAppHandle
{
public:
	CAutoCloseLineAppHandle(HLINEAPP hLineApp = NULL)
	{ 
		m_hLineApp = hLineApp;
	};
    
	~CAutoCloseLineAppHandle()
	{
		Release();
	};
   
	CAutoCloseLineAppHandle & operator =(HLINEAPP hLineApp) 
	{
		m_hLineApp = hLineApp; 
		return *this; 
	};
    
	HLINEAPP * operator &()
	{ 
		return &m_hLineApp; 
	};
    
	operator HLINEAPP() const
	{
		return m_hLineApp; 
	};

	HLINEAPP Detach()
	{
		HLINEAPP oldHLINE = m_hLineApp;
		m_hLineApp = NULL;
		return oldHLINE;
	};

	void Release()
	{
		if (m_hLineApp)
		{
			long status = ::lineShutdown(m_hLineApp);
			if (status)
			{
				throw CException(
					TEXT("%s(%d): CAutoCloseLineAppHandle::~CAutoCloseLineAppHandle(), ::lineShutdown() call failed, error code 0x%08x"),
					TEXT(__FILE__),
					__LINE__,
					status
					);
			}
			m_hLineApp = NULL;
		}
	};
		

private:
    HLINEAPP m_hLineApp;
};


#endif //_TAPI2_SMARTPOINTER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\tapitools\tapidevice\tapi3device.cpp ===
//Tapi3Device.cpp

#include "tapi3Device.h"
#include "Log.h"
#include <crtdbg.h>
#include <stdio.h>
#include <comdef.h>
#include "smrtptrs.h"
#include "cbstr.h"

//
//We add this pragma, because CTapi3Device uses this in the initilaztion list
//
#pragma warning( disable : 4355 ) 


#define MEDIA_NOT_REGISTERED	-1
#define GENERATE_DIGIT_EVENT_TIMEOUT				10000
#define CALLSTATE_CONNECT_EVENT_TIMEOUT				10000

#define TAPI3_DEFAULT_WAIT_FOR_MESSAGE_TIMEOUT		60000



//constructor
CTapi3Device::CTapi3Device(const DWORD dwId):
	CTapiDevice(dwId),
	m_lAdvise(0),
	m_lRegisterIndex(MEDIA_NOT_REGISTERED),
	m_pAddress(NULL),
	m_pTerminal(NULL),
	m_pBasicCallControl(NULL),
	m_Tapi(NULL),
	m_pDeviceEventCallbackObject(this)
{
	
	//
	//the constructor is wrapped with try/catch,  because it might call RegisterTapiEventInterface()
	//then fail and not call UnRegisterTapiEventInterface()
	//so the catch block has UnRegisterTapiEventInterface() and ShutdownTapi().
	//
	try
	{
		TapiCoCreateInstance();
			
		//
		//before sending any tapi command init Tapi 
		//
		InitializeTapi();
		
		//
		// Register the event interface
		//
		RegisterTapiEventInterface();
	}
	catch(CException thrownException)
	{
		if ( (NULL != m_Tapi) && (!m_lAdvise) )
		{
			UnRegisterTapiEventInterface();
		}
		
		if (NULL != m_Tapi)
		{
			ShutdownTapi();
		}

		throw thrownException;
	}
}




//destructor
CTapi3Device::~CTapi3Device()
{
	TapiLogDetail(LOG_X, 8, TEXT("Entering CTapi3Device Destructor"));
	
	//
	//check if we have an active call, if so call HangUp() first.
	//
	if (IsCallActive())
	{
		HangUp();
	}
	
	//
	//unregister the event interface
	//
	UnRegisterTapiEventInterface();

	//
	//clear the object message queue
	//
	ClearMessageQueue();

	//
	//tapi shutdown
	//
	ShutdownTapi();
	
}//CTapi3Device::~CTapi3Device()




//*********************************************************************************
//* Name:	ThrowOnComError
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		checks the HRESULT status and throws a CException if status is FAILED
//* PARAMETERS:
//*		[IN]	HRESULT hr
//*					HRESULT status to check
//*		[IN]	const TCHAR * const szExceptionDescription
//*					description format
//*		[IN]	...
//*					parameters corresponding to the description format
//*	RETURN VALUE:
//*		NONE
//*	REMARKS:
//*		the function throws an exception of CException
//*********************************************************************************
void CTapi3Device::ThrowOnComError(
   HRESULT hr,
   const TCHAR * const szExceptionDescription,
   ...
   )
{
	if FAILED(hr)
	{
		va_list argList;
		va_start(argList, szExceptionDescription);
		throw CException(szExceptionDescription,argList);
	}

}//void CTapi3Device::ThrowOnComError()





//*********************************************************************************
//* Name:	PrepareForStreaming
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		move to passthrough mode and retrieve a handle to the comm port
//* PARAMETERS:
//*		[IN]	const StreamingType streamingType
//*					DATA,VOICE,FAX streaming type to prepare to
//*		[IN]	const StreamingDirection streamingDirection
//*					ANSWER,CALLER direction of streaming to prepare to
//*	RETURN VALUE:
//*		In Tapi3Device answerer and caller StreamingDirection have the
//*		same prepare method.
//*********************************************************************************
void CTapi3Device::PrepareForStreaming(
	const StreamingType streamingType,
	const StreamingDirection streaminDirection
	)
{
	_ASSERT(NULL != m_Tapi);
	_ASSERT(NULL != m_pBasicCallControl);
	_ASSERT(NULL != m_pAddress);

	if (
		(VOICE_STREAMING != streamingType) &&
		(DATA_STREAMING != streamingType) &&
		(FAX_STREAMING != streamingType)
		)
	{
	    throw CException(
            TEXT("CTapi3Device::PrepareForStreaming() : streamingType %d is unsupported."),
            streamingType
            );
	}

	if ( (CALLER_STREAMING != streaminDirection) && (ANSWERER_STREAMING != streaminDirection) )
	{
	    throw CException(
            TEXT("CTapi3Device::PrepareForStreaming() : streamingDirection %d is unsupported."),
            streaminDirection
            );
	}

	//
	//no special preparation if FAX or VOICE streaming
	//
	if (DATA_STREAMING == streamingType)
	{
		//SetBearerModeToPASSTHROUGH();
		SetCommPortHandleFromCallHandle();
	}
}


//*********************************************************************************
//* Name:	MoveToPassThroughMode
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Transfer to pass through mode on an unallocated call
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		Use this function on a unallocated call, to switch to passthrough on
//*		an existing call use SetBearerModeToPASSTHROUGH.
//*********************************************************************************
void CTapi3Device::MoveToPassThroughMode()
{
	//
	//create a Dummy address and a Dummy call
	//
	CreateCallWrapper(TEXT("1111"),TAPIMEDIATYPE_DATAMODEM);

	//
	//change the call to a passthrough call
	//
	SetBearerModeToPASSTHROUGH();

	//
	//connect the call
	//
	ConnectCall();

	
}




//*********************************************************************************
//* Name:	sendDTMF
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		send some digits to the remote modem, using 
//*		ITLegacyCallMediaControl::GenerateDigits()
//* PARAMETERS:
//*		[IN] LPCTSTR digitsToSend
//*			the digits to send to the remote modem
//*	RETURN VALUE:
//*		NONE
//* REMARKS:
//*		After ITLegacyCallMediaControl::GenerateDigits() is called, the function 
//*		waits for an ITDigitGenerationEvent for an acknowlegement of the digit
//*		generation success.
//*********************************************************************************
void CTapi3Device::sendDTMF(LPCTSTR digitsToSend) const
{

	_ASSERT(NULL != m_Tapi);
	_ASSERT(NULL != m_pBasicCallControl);
	_ASSERT(NULL != m_pAddress);


	ITLegacyCallMediaControlPtr pLegacyCallMediaControl;
	HRESULT hr = m_pBasicCallControl->QueryInterface(IID_ITLegacyCallMediaControl, (LPVOID *)&pLegacyCallMediaControl);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::sendDTMF(), ITBasicCallControl::QueryInterface() on IID_ITLegacyCallMediaControl failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);
	_ASSERT(NULL != pLegacyCallMediaControl);

	CBSTR digitsAsBSTR = SysAllocString(digitsToSend); 
	if (NULL == (BSTR) digitsAsBSTR)
	{
		throw CException(TEXT("CTapi3Device::sendDTMF(), SysAllocString() failed"));
	}

	hr = pLegacyCallMediaControl->GenerateDigits(
		digitsAsBSTR,
		LINEDIGITMODE_DTMF
		);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::sendDTMF(), ITLegacyCallMediaControl::GenerateDigits() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);
	
	//
	//wait for a generate digit event
	//
	P<TapiEventItem> pQueuedTapiEventItem = GetEventItemFromQueue(TE_GENERATEEVENT,GENERATE_DIGIT_EVENT_TIMEOUT);
	ITDigitGenerationEventPtr pDigitGenerationEvent;
	pDigitGenerationEvent = dynamic_cast<ITDigitGenerationEvent *>(pQueuedTapiEventItem->GetEvent());
	if (NULL == pDigitGenerationEvent )
	{
		throw CException(TEXT("CTapi3Device::sendDTMF() dynamic_cast<ITDigitGenerationEvent *> failed"));
	}
	VerifyCallFromDigitGenerationEvent(pDigitGenerationEvent);

	long lGenerationTermination;
	hr = pDigitGenerationEvent->get_GenerationTermination(&lGenerationTermination);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::sendDTMF(), ITDigitGenerationEvent::get_GenerationTermination() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);
}//void CTapi3Device::sendDTMF()





//*********************************************************************************
//* Name:	VerifyCallFromDigitGenerationEvent
//* Author: Guy Merin / 18-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Verifies that the ITCallInfo in the digit generation event
//*		is the same as the current call's ITCallInfo 
//* PARAMETERS:
//*		[IN]	ITDigitGenerationEvent *pDigitGenerationEvent
//*					ITDigitGenerationEvent event which we need to verify
//*					the ITCallInfo from
//*	RETURN VALUE:
//*		NONE
//*********************************************************************************
void CTapi3Device::VerifyCallFromDigitGenerationEvent(ITDigitGenerationEvent* const pDigitGenerationEvent) const
{
	_ASSERT(NULL != pDigitGenerationEvent);
	_ASSERT(NULL != m_pBasicCallControl);

	ITCallInfoPtr pCallInfoFromEvent;
	HRESULT hr = pDigitGenerationEvent->get_Call(&pCallInfoFromEvent);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::VerifyCallFromDigitGenerationEvent(), ITDigitGenerationEvent::get_Call() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);
	
	//
	//get the callInfo from the event and verify it's equal to our call
	//
	ITCallInfoPtr pCallInfo = GetCallInfoFromBasicCallControl();
	if (pCallInfo != pCallInfoFromEvent)
	{
		throw CException (TEXT("CTapi3Device::VerifyCallFromDigitGenerationEvent(), call handle from digit generation event isn't equal to the member call handle"));
	}
	
}//void CTapi3Device::VerifyCallFromDigitGenerationEvent()



//*********************************************************************************
//* Name:	VerifyCallFromCallStateEvent
//* Author: Guy Merin / 19-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Verifies that the ITCallInfo in the digit generation event
//*		is the same as the current call's ITCallInfo 
//* PARAMETERS:
//*		[IN]	ITDigitGenerationEvent *pDigitGenerationEvent
//*					the event to query the ITCallInfo from
//*	RETURN VALUE:
//*		NONE
//*********************************************************************************
void CTapi3Device::VerifyCallFromCallStateEvent(ITCallStateEvent * const pCallStateEvent) const
{
	_ASSERT(NULL != pCallStateEvent);
	_ASSERT(NULL != m_pBasicCallControl);

	ITCallInfoPtr pCallInfoFromEvent;
	HRESULT hr = pCallStateEvent->get_Call(&pCallInfoFromEvent);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::VerifyCallFromCallStateEvent(), ITDigitGenerationEvent::get_Call() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);

	//
	//get the callInfo from the event and verify it's equal to our call
	//
	ITCallInfoPtr pCallInfo;
	pCallInfo = GetCallInfoFromBasicCallControl();
	if (pCallInfo != pCallInfoFromEvent)
	{
		throw CException (TEXT("CTapi3Device::VerifyCallFromCallStateEvent(), call handle from digit generation event isn't equal to the member call handle"));
	}
	
}//void CTapi3Device::VerifyCallFromCallStateEvent()



//*********************************************************************************
//* Name:	VerifyCallFromDigitDetectionEvent
//* Author: Guy Merin / 18-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Verifies that the ITCallInfo in the digit detection event
//*		is the same as the current call's ITCallInfo 
//* PARAMETERS:
//*		[IN]	ITDigitDetectionEvent *pDigitDetectionEvent
//*					the event to query the ITCallInfo from
//*	RETURN VALUE:
//*		NONE
//*********************************************************************************
void CTapi3Device::VerifyCallFromDigitDetectionEvent(ITDigitDetectionEvent* const pDigitDetectionEvent) const
{
	_ASSERT(NULL != pDigitDetectionEvent);
	_ASSERT(NULL != m_pBasicCallControl);

	ITCallInfoPtr pCallInfoFromEvent;
	HRESULT hr = pDigitDetectionEvent->get_Call(&pCallInfoFromEvent);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::VerifyCallFromDigitDetectionEvent(), ITDigitGenerationEvent::get_Call() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);
	
	//
	//get the callInfo from the event and verify it's equal to our call
	//
	ITCallInfoPtr pCallInfo = GetCallInfoFromBasicCallControl();
	if (pCallInfo != pCallInfoFromEvent)
	{
		throw CException (TEXT("CTapi3Device::VerifyCallFromDigitDetectionEvent(), call handle from digit generation event isn't equal to the member call handle"));
	}
	
}//void CTapi3Device::VerifyCallFromDigitDetectionEvent()




//*********************************************************************************
//* Name:	GetCallInfoFromBasicCallControl
//* Author: Guy Merin / 18-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		return the ITCallInfo associated with the m_BasicCallControl object
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		the ITCallInfo Object
//*********************************************************************************
ITCallInfo *CTapi3Device::GetCallInfoFromBasicCallControl() const
{
	_ASSERT(NULL != m_pBasicCallControl);
	
	ITCallInfoPtr pCallInfo;
	HRESULT hr = m_pBasicCallControl->QueryInterface(IID_ITCallInfo, (LPVOID *)&pCallInfo);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::GetCallInfoFromBasicCallControl(), ITBasicCallControl::QueryInterface() on IID_ITCallInfo failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);
	_ASSERT(NULL != pCallInfo);
	return pCallInfo.Detach();
}//ITCallInfo *CTapi3Device::GetCallInfoFromBasicCallControl



//*********************************************************************************
//* Name:	receiveDTMF
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		receive some digits(tones) from the remote modem, 
//*		using ITLegacyCallMediaControl::DetectDigits
//* PARAMETERS:
//*		[OUT]	LPTSTR DTMFresponse
//*					buffer to receive the gathered digits
//*		[IN]	DWORD dwNumberOfDigitsToCollect
//*					number of digits to receive before the function returns
//*		[IN]	const DWORD dwTimeout
//*					milliseconds to wait till first digit is received
//*	RETURN VALUE:
//*		NONE
//* REMARKS:
//*		After ITLegacyCallMediaControl::DetectDigits() is called, the function 
//*		waits for an ITDigitDetectionEvent for an acknowlegement of the digit
//*		detection success.
//*********************************************************************************
void CTapi3Device::receiveDTMF(LPTSTR DTMFresponse,DWORD dwNumberOfDigitsToCollect, const DWORD dwTimeout) const
{
	_ASSERT(NULL != m_Tapi);
	_ASSERT(NULL != m_pBasicCallControl);
	_ASSERT(NULL != m_pAddress);


	ITLegacyCallMediaControlPtr pLegacyCallMediaControl;
	HRESULT hr = m_pBasicCallControl->QueryInterface(IID_ITLegacyCallMediaControl, (LPVOID *)&pLegacyCallMediaControl);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::receiveDTMF(), ITBasicCallControl::QueryInterface() on IID_ITLegacyCallMediaControl failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);
	_ASSERT(NULL != pLegacyCallMediaControl);

	//
	//register to monitor digits
	//
	hr = pLegacyCallMediaControl->DetectDigits(
		LINEDIGITMODE_DTMF
		);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::receiveDTMF(), ITLegacyCallMediaControl::DetectDigits() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);


	
	//
	//wait for the digit detection event
	//
	
	TCHAR tcDigit;

	AP<TCHAR> tszDigitBuffer = new TCHAR[dwNumberOfDigitsToCollect+1];
	if (!tszDigitBuffer)
	{
		throw CException(TEXT("CTapi3Device::receiveDTMF(), new failed"));
	}
	
	
	try 
	{
		tszDigitBuffer[dwNumberOfDigitsToCollect] = TEXT('\0');
		
		P<TapiEventItem>			pQueuedTapiEventItem	=	NULL;
		ITDigitDetectionEventPtr	pDigitDetectionEvent	=	NULL;

		
		for (DWORD i=0; i < dwNumberOfDigitsToCollect; i++)
		{
			pQueuedTapiEventItem = GetEventItemFromQueue(TE_DIGITEVENT, dwTimeout);
			if (pQueuedTapiEventItem == NULL)
			{
				//
				//no TE_DIGITEVENT, so no new digit have arrived
				//
				throw CException(
					TEXT("%s(%d): CTapi3Device::receiveDTMF(), CTapi3Device::GetEventItemFromQueue() returned TIMEOUT"), 
					TEXT(__FILE__),
					__LINE__
					);
			}

			pDigitDetectionEvent = dynamic_cast<ITDigitDetectionEvent *>(pQueuedTapiEventItem->GetEvent());
			if (NULL == pDigitDetectionEvent)
			{
				throw CException(TEXT("CTapi3Device::receiveDTMF() dynamic_cast<ITDigitDetectionEvent *> failed"));
			}
			
			VerifyCallFromDigitDetectionEvent(pDigitDetectionEvent);
			
			//
			//get the digit from the event
			//
			tcDigit = GetDigitFromDigitDetectionEvent(pDigitDetectionEvent);
			tszDigitBuffer[i] = tcDigit;

			//
			//release the event
			//
			pDigitDetectionEvent.Release();
			delete pQueuedTapiEventItem;
			pQueuedTapiEventItem = NULL;
			
		
		}//for
		lstrcpy(DTMFresponse,tszDigitBuffer);

		//
		//disable Digits detection
		//
		hr = pLegacyCallMediaControl->DetectDigits(0);
		ThrowOnComError(
			hr,
			TEXT("%s(%d): CTapi3Device::receiveDTMF(), ITLegacyCallMediaControl::DetectDigits() failed, error code:0x%08x"), 
			TEXT(__FILE__),
			__LINE__,
			hr
			);

	}
	catch (CException e)
	{
		
		//
		//disable Digits detection
		//
		hr = pLegacyCallMediaControl->DetectDigits(0);
		ThrowOnComError(
			hr,
			TEXT("%s(%d): CTapi3Device::receiveDTMF(), ITLegacyCallMediaControl::DetectDigits() failed, error code:0x%08x"), 
			TEXT(__FILE__),
			__LINE__,
			hr
			);
		
		//
		//rethrow the exception
		//
		throw e;
	}

}//void CTapi3Device::receiveDTMF()


//*********************************************************************************
//* Name:	GetDigitFromDigitDetectionEvent
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Return the detected digit retrived from the ITDigitDetectionEvent
//* PARAMETERS:
//*		[IN]	ITDigitDetectionEvent *pDigitDetectionEvent
//*					pointer to the digit event to query the digit
//*	RETURN VALUE:
//*		the detected digit as a TCHAR
//* REMARKS:
//*		The function uses ITDigitDetectionEvent::get_Digit()
//*********************************************************************************
TCHAR CTapi3Device::GetDigitFromDigitDetectionEvent(ITDigitDetectionEvent * const pDigitDetectionEvent) const
{
	_ASSERT(NULL !=pDigitDetectionEvent);

	unsigned char cDigit;

	HRESULT hr = pDigitDetectionEvent->get_Digit(&cDigit);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::GetDigitFromDigitDetectionEvent(), ITLegacyCallMediaControl::Get_Digit() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);

	TCHAR tcDigit;

	


#ifdef UNICODE

	//
	//MultiByteToWideChar takes a string, so prepare a string from the char
	//
	char cszDigit[2];
	cszDigit[0]=cDigit;
	cszDigit[1]='\0';
	
	TCHAR tszDigit[2];
	tszDigit[1]='\0';

	int  status = MultiByteToWideChar(
		CP_ACP ,					// code page 
		MB_PRECOMPOSED ,			// character-type options 
		cszDigit,					// address of string to map 
		1,							// number of characters in string 
		tszDigit,					// address of wide-character buffer 
		2							// size of buffer 
		);
	_ASSERT(1 == status);

	tcDigit = tszDigit[0];

#else
	tcDigit = cDigit;
#endif

	return tcDigit;

}//TCHAR CTapi3Device::GetDigitFromDigitDetectionEvent()




//*********************************************************************************
//* Name:	GetEventItemFromQueue
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Wait for a desired event, dequeue it and return a handle to it
//* PARAMETERS:
//*		[IN]	const TAPI_EVENT teWantedEvent
//*					the desired event type to wait for
//*		[IN]	const DWORD dwTimeOut
//*					timeout in miliseconds to wait for the event
//*					if 0 is given, the function will check if we
//*					already have an item in the queue and return it
//*					or return NULL if there're no elements
//*	RETURN VALUE:
//*		the dequeued event item
//*********************************************************************************
TapiEventItem *CTapi3Device::GetEventItemFromQueue(const TAPI_EVENT teWantedEvent, const DWORD dwTimeOut) const
{
	
	DWORD dwStartTickCount = GetTickCount();
	DWORD dwDiffernceTickCount = 0;

	TapiEventItem *pQueuedEvent = NULL;
		
	while (1)
	{
		if (!m_eventQueue.SyncDeQueue(pQueuedEvent,dwTimeOut))
		{
			DWORD dwLastError = GetLastError(); 
			if (WAIT_TIMEOUT == dwLastError)
			{
				return (NULL);
			}
			else
			{
				throw CException(TEXT("CTapi3Device::GetEventItemFromQueue(), CMtQueue::SyncDeQueue() failed error code %d"),dwLastError); 
			}
		}
		if (teWantedEvent == pQueuedEvent->GetTapiEventID())
		{
			return (pQueuedEvent);
		}
	}
}//TapiEventItem *CTapi3Device::GetEventItemFromQueue(const TAPI_EVENT teWantedEvent, const DWORD dwTimeOut)


//*********************************************************************************
//* Name:	SetBearerModeToPASSTHROUGH
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		set the call bearer mode to PASSTHROUGH.
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		NONE
//*	REMARKS:
//*		Use this function on an existing call, to set passthrough mode on a
//*		unallocated call use MoveToPassThroughMode
//*********************************************************************************
void CTapi3Device::SetBearerModeToPASSTHROUGH()
{
	_ASSERT(NULL != m_Tapi);
	_ASSERT(NULL != m_pBasicCallControl);
	_ASSERT(NULL != m_pAddress);


	ITCallInfoPtr pCallInfo;
	HRESULT hr = m_pBasicCallControl->QueryInterface(IID_ITCallInfo, (LPVOID *)&pCallInfo);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::SetBearerModeToPASSTHROUGH(), ITBasicCallControl::QueryInterface() on IID_ITCallInfo failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);
	_ASSERT(NULL != pCallInfo);

	//
	//set bearer mode to PASSTHROUGH
	//
	hr = pCallInfo->put_CallInfoLong(CIL_BEARERMODE,LINEBEARERMODE_PASSTHROUGH);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::SetBearerModeToPASSTHROUGH(), ITCallInfo::put_CallInfoLong(CIL_BEARERMODE,LINEBEARERMODE_PASSTHROUGH) failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);

	TapiLogDetail(LOG_X, 5, TEXT("Call in PASSTHROUGH MODE"));

}//void CTapi3Device::SetBearerModeToPASSTHROUGH()



//*********************************************************************************
//* Name:	RegisterTapiEventInterface
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Creates a CTAPIEventNotification object and registers the outgoing 
//*		interface with it
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		NONE
//*	REMARKS:
//*		This function creates a CTAPIEventNotification object and initiazles it
//*		With a 'this' pointer (a CTapi3Device object).
//*		m_lAdvise is saved for UnAdvise
//*********************************************************************************
void CTapi3Device::RegisterTapiEventInterface()
{
    _ASSERT(NULL != m_Tapi);
	
	HRESULT	hr = S_OK;
	IConnectionPointContainerPtr pCPC;
	IConnectionPointPtr pCP;

    //
    // get the connectionpointcontainter interface off the tapi object
    //
    hr = m_Tapi->QueryInterface(IID_IConnectionPointContainer,(void **)&pCPC);
    ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::RegisterTapiEventInterface(), ITTAPI::QueryInterface() on IID_IConnectionPointContainer failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);

    //
    // get the correct connection point
    //
    hr = pCPC->FindConnectionPoint(IID_ITTAPIEventNotification,&pCP);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::RegisterTapiEventInterface(), IConnectionPointContainer::FindConnectionPoint() on IID_ITTAPIEventNotification failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);
	

	//
	//Establish the connection between the connection point object and the client's sink
	//
    hr = pCP->Advise((IUnknown*)&m_pDeviceEventCallbackObject,&m_lAdvise);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::RegisterTapiEventInterface(), IConnectionPoint::Advise() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);

}


//*********************************************************************************
//* Name:	UnRegisterTapiEventInterface
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Unregisters the outgoing event interface
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		NONE
//*	REMARKS:
//*		m_lAdvise is used for the UnAdvise
//*********************************************************************************
void CTapi3Device::UnRegisterTapiEventInterface()
{
	_ASSERT(NULL != m_Tapi);
	
	
	IConnectionPointContainerPtr	pCPC;
    IConnectionPointPtr				pCP;
    
	//
    // unadvise our connection point
    //
    HRESULT hr = m_Tapi->QueryInterface(
       IID_IConnectionPointContainer,
       (void**) &pCPC
	   );
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::UnRegisterTapiEventInterface(), ITTAPI::QueryInterface() on IID_IConnectionPointContainer failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);
	
    hr = pCPC->FindConnectionPoint(IID_ITTAPIEventNotification,&pCP);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::UnRegisterTapiEventInterface(), IConnectionPointContainer::FindConnectionPoint() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);

    hr = pCP->Unadvise(m_lAdvise);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::UnRegisterTapiEventInterface(), IConnectionPoint::Unadvise() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);
	m_lAdvise = 0;
	
}//void CTapi3Device::UnRegisterTapiEventInterface()




//*********************************************************************************
//* Name:	InitializeTapi
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Wrapper for ITTAPI::Initialize()
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		NONE
//*********************************************************************************
void CTapi3Device::InitializeTapi()
{
	_ASSERT(NULL != m_Tapi);

	//
    // initialize tapi3
    //
    HRESULT hr = m_Tapi->Initialize();
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::InitializeTapi(), ITTAPI::Initialize(), error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);
}//void CTapi3Device::InitializeTapi()



//*********************************************************************************
//* Name:	InitializeTapi
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Wrapper for ITTAPI::Shutdown()
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		NONE
//*********************************************************************************
void CTapi3Device::ShutdownTapi()
{
	_ASSERT(NULL != m_Tapi);
			
	//
    // shutdown tapi
    //
    HRESULT hr = m_Tapi->Shutdown();
	m_Tapi.Release();
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::ShutdownTapi(), ITTAPI::Shutdown() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);

}


//*********************************************************************************
//* Name:	TapiCoCreateInstance
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Wrapper for ::CoCreateInstance(ITTAPI)
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		NONE
//*********************************************************************************
void CTapi3Device::TapiCoCreateInstance()
{
	_ASSERT(NULL == m_Tapi);
	
    //
    // CoCreate the TAPI object
    //
    HRESULT hr = CoCreateInstance(
		CLSID_TAPI,
		NULL,
		CLSCTX_INPROC_SERVER,
		IID_ITTAPI,
		(LPVOID *)&m_Tapi
		);
    ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::InitializeTapi(), CoCreateInstance() on TAPI failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);
	_ASSERT(NULL != m_Tapi);
}




//*********************************************************************************
//* Name:	SetAddressProperty
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		set m_pAddress with the address handle according to m_dwId and dwMedia
//* PARAMETERS:
//*		[IN]	const DWORD dwMedia
//*					desirable media mode for address
//*	RETURN VALUE:
//*		NONE
//*	REMARKS:
//*		The function checks if tapi device m_dwId supports dwMedia
//*		if not an exception is thrown
//*********************************************************************************
void CTapi3Device::SetAddressProperty(const DWORD dwMedia)
{
	_ASSERT(NULL != m_Tapi);
	_ASSERT(NULL == m_pAddress);
	_ASSERT(NULL == m_pBasicCallControl);

	//
	//set m_pAddress according to m_dwId
	//
	SetAddressFromTapiID();

	//
	//log the Tapi address name
	//
	LogAddressName();

	//
	//check if device state is OK
	//
	VerifyAddressState();

	//
	//check if address supports wanted media mode
	//
	VerifyAddressSupportMediaMode(dwMedia);
}



//*********************************************************************************
//* Name:	SetAddressFromTapiID
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Set m_pAddress with the m_dwId address count
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		NONE
//*	REMARKS:
//*		The function enumerates all the addresses and skips to the m_dwId address count
//*********************************************************************************
void CTapi3Device::SetAddressFromTapiID()
{
	_ASSERT(NULL != m_Tapi);
	_ASSERT(NULL == m_pAddress);

	//
	//enum the addresses and find device ID m_dwId
	//

	IEnumAddressPtr pEnumAddress;

	HRESULT hr = m_Tapi->EnumerateAddresses(&pEnumAddress);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::SetAddressFromTapiID(), ITTAPI::EnumerateAddresses() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);

	
	//
	//skip to the desired tapi deviceID
	//
	hr = pEnumAddress->Skip(m_dwId); 
	if FAILED(hr)
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::SetAddressFromTapiID(), IEnumAddress::Skip() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);
	
	//
	//get the desired address
	//
	ULONG cAddresses;
	hr = pEnumAddress->Next(1, &m_pAddress, &cAddresses);
	_ASSERT(1 == cAddresses);		//we asked from Next() for only 1 ITADDRESS

	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::SetAddressFromTapiID(), IEnumAddress::Next() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);

}//void CTapi3Device::SetAddressFromTapiID()
	



//*********************************************************************************
//* Name:	VerifyAddressSupportMediaMode
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Verify that the address supports the desired media mode.
//* PARAMETERS:
//*		[IN]	const DWORD dwMedia
//*					media mode to verify
//*	RETURN VALUE:
//*		NONE
//*	REMARKS:
//*		The function uses ITMediaSupport::QueryMediaType()
//*********************************************************************************
void CTapi3Device::VerifyAddressSupportMediaMode(const DWORD dwMedia) const
{
	_ASSERT(NULL != m_Tapi);
	_ASSERT(NULL != m_pAddress);
	
	//
	//get the address supported media modes through the ITMediaSupport interface
	//
	ITMediaSupportPtr    pMediaSupport;
	HRESULT hr = m_pAddress->QueryInterface(IID_ITMediaSupport,(void **)&pMediaSupport);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::VerifyAddressSupportMediaMode(), ITAddress::QueryInterface() on IID_ITMediaSupport failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);

	//
	// does this address support our needed MEDIAMODE?
	//
	VARIANT_BOOL bSupport;
	pMediaSupport->QueryMediaType(dwMedia,&bSupport);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::VerifyAddressSupportMediaMode(), ITMediaSupport::QueryMediaType() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);
	
	if (!bSupport)
    {
		throw CException(
			TEXT("%s(%d): CTapi3Device::VerifyAddressSupportMediaMode(), %d media mode is not supported by this address"), 
			TEXT(__FILE__),
			__LINE__,
			dwMedia
			);
	}
}//void CTapi3Device::VerifyAddressSupportMediaMode(dwMedia)



//*********************************************************************************
//* Name:	LogAddressName
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		echoes the device name (string)
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		NONE
//*	REMARKS:
//*		The function uses ::lgLogDetail()
//*********************************************************************************
void CTapi3Device::LogAddressName() const
{
	_ASSERT(NULL != m_Tapi);
	_ASSERT(NULL != m_pAddress);
	
	//
	//szAddressName is allocated by get_AddressName(), we need to free it.
	//
	CBSTR szAddressNameAsBSTR;
	HRESULT hr = m_pAddress->get_AddressName(&szAddressNameAsBSTR);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::LogAddressName(), ITAddress::get_AddressName() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);

	//
	//create a _bstr_t so we can cast it to char* or wchar*
	//
	_bstr_t szAddressNameAs_BSTR_t(szAddressNameAsBSTR);

#ifdef UNICODE
	TapiLogDetail(LOG_X, 5, TEXT("Provider name is %s"),(wchar_t*) szAddressNameAs_BSTR_t);
#else
	TapiLogDetail(LOG_X, 5, TEXT("Provider name is %s"),(char*) szAddressNameAs_BSTR_t);
#endif
	//
	//szAddressName is not needed anymore
	//
	::SysFreeString(szAddressNameAsBSTR);
}//void CTapi3Device::LogAddressName()


//*********************************************************************************
//* Name:	VerifyAddressState
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Verify that the address state is in-service
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		NONE
//*	REMARKS:
//*		The function uses ITAddress::get_State()
//*********************************************************************************
void CTapi3Device::VerifyAddressState() const
{
	_ASSERT(NULL != m_Tapi);
	_ASSERT(NULL != m_pAddress);

	ADDRESS_STATE asAddressState;
	HRESULT hr = m_pAddress->get_State(&asAddressState);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::VerifyAddressState(), ITAddress::get_State() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);
	if (AS_OUTOFSERVICE == asAddressState)
	{
		throw CException(TEXT("CTapi3Device::VerifyAddressState(), address is OUT OF SERVICE"));
	}
	_ASSERT(AS_INSERVICE == asAddressState);
}//void CTapi3Device::VerifyAddressState()



//*********************************************************************************
//* Name:	SetTerminalForIncomingCall
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* TBD
//*********************************************************************************
void CTapi3Device::SetTerminalForIncomingCall(const DWORD dwMedia)
{
	_ASSERT(NULL != m_Tapi);
	_ASSERT(NULL != m_pAddress);
	_ASSERT(NULL == m_pTerminal);

	HRESULT hr;
	ITTerminalSupportPtr pTerminalSupport;
	hr = m_pAddress->QueryInterface(IID_ITTerminalSupport,(void **)&pTerminalSupport);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::SetTerminalForIncomingCall(), ITAddress::QueryInterface() on IID_ITTerminalSupport failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);

	hr = pTerminalSupport->GetDefaultStaticTerminal(
		dwMedia,
		TD_CAPTURE,
		&m_pTerminal
		);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::SetTerminalForIncomingCall(), ITTerminalSupport::GetDefaultStaticTerminal() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);
	_ASSERT(NULL != m_pTerminal);
	
	TERMINAL_STATE ts_TerminalState;
	hr = m_pTerminal->get_State(&ts_TerminalState);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::SetTerminalForIncomingCall(), ITTerminal::get_State() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);
	//TBD: check if the terminal state should be here a
	//TS_INUSE or a TS_NOTINUSE
	
}//CTapi3Device::SetTerminalForIncomingCall()



//*********************************************************************************
//* Name:	SetTerminalForIncomingCall
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* TBD
//*********************************************************************************
void CTapi3Device::SetTerminalForOutgoingCall(const DWORD dwMedia)
{
	_ASSERT(NULL != m_Tapi);
	_ASSERT(NULL != m_pAddress);
	_ASSERT(NULL == m_pTerminal);
	HRESULT hr;
	
	//
	//set the terminal
	//
	ITTerminalSupportPtr pTerminalSupport;
	hr = m_pAddress->QueryInterface(IID_ITTerminalSupport,(void **)&pTerminalSupport);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::SetTerminalForOutgoingCall(), ITAddress::QueryInterface() on IID_ITTerminalSupport failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);

	hr = pTerminalSupport->GetDefaultStaticTerminal(
		dwMedia,
		TD_CAPTURE,
		&m_pTerminal
		);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::SetTerminalForOutgoingCall(), ITTerminalSupport::GetDefaultStaticTerminal() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);
	_ASSERT(NULL != m_pTerminal);
	
	TERMINAL_STATE ts_TerminalState;
	hr = m_pTerminal->get_State(&ts_TerminalState);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::SetTerminalForOutgoingCall(), ITTerminal::get_State() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);
	//TBD: check if the terminal state should be here a
	//TS_INUSE or a TS_NOTINUSE

}//CTapi3Device::SetTerminalForOutgoingCall(const DWORD dwMedia)


//*********************************************************************************
//* Name:	RegisterNotificationForMediaMode
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Registers an interest in receiving events on an address and media mode.
//* PARAMETERS:
//*		[IN]	const DWORD dwMedia
//*	RETURN VALUE:
//*		NONE		
//*	REMARKS:
//*		The function calls ITTAPI::RegisterCallNotifications() 
//*		for a specific media mode, and saves the registration handle 
//*		in m_lRegisterIndex, which is used for ITTAPI::UnregisterNotifications()
//*********************************************************************************
void CTapi3Device::RegisterNotificationForMediaMode(const DWORD dwMedia)
{
	_ASSERT(NULL != m_Tapi);
	_ASSERT(NULL != m_pAddress);
	_ASSERT(NULL == m_pBasicCallControl);
	_ASSERT(MEDIA_NOT_REGISTERED == m_lRegisterIndex);

	
	HRESULT hr = m_Tapi->RegisterCallNotifications(
       m_pAddress,
       VARIANT_FALSE,	// no monitor privilege
       VARIANT_TRUE,	// owner privilege only
       dwMedia,			// media to listen for
       0,				// callback instance
       &m_lRegisterIndex// registration instance
      );
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::RegisterMediaModeToListenOn(), ITTAPI::RegisterCallNotifications() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);
}//CTapi3Device::RegisterNotificationForMediaMode()


//*********************************************************************************
//* Name:	UnRegisterNotificationForMediaMode
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		unRegisters an interest in receiving events on an address and media mode.
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		NONE
//*	REMARKS:
//*		The function calls ITTAPI::UnregisterCallNotifications() 
//*		with the registration index handle from ITTAPI::RegisterNotifications()
//*********************************************************************************
void CTapi3Device::UnRegisterNotificationForMediaMode()
{
	_ASSERT(NULL != m_Tapi);
	_ASSERT(NULL == m_pBasicCallControl);
	
	HRESULT hr = m_Tapi->UnregisterNotifications(m_lRegisterIndex);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::UnRegisterNotificationForMediaMode(), ITTAPI::UnregisterNotifications() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);
	m_lRegisterIndex = MEDIA_NOT_REGISTERED;
}//CTapi3Device::UnRegisterNotificationForMediaMode()


//*********************************************************************************
//* Name:	GetCallState
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		returns Tapi CallState enum
//* PARAMETERS:
//*		[IN] ITCallInfo *pCallInfo
//*			pointer to the call's ITCallInfo
//*			(If this parameter is not supplied it's default value is NULL)
//*	RETURN VALUE:
//*		the call's CallState
//*	REMARKS:
//*		This function calls ITCallInfo::get_CallState() 
//*		If pCallInfo is NULL it calls QueryInterface to get pCallInfo
//*********************************************************************************
CALL_STATE CTapi3Device::GetCallState(ITCallInfo *pCallInfo) const
{
	_ASSERT(NULL != m_Tapi);
	_ASSERT(NULL != m_pBasicCallControl);
	_ASSERT(NULL != m_pAddress);

	HRESULT hr;
	if (NULL == pCallInfo )
	{
		hr = m_pBasicCallControl->QueryInterface(IID_ITCallInfo, (LPVOID *)&pCallInfo);
		ThrowOnComError(
			hr,
			TEXT("%s(%d): CTapi3Device::GetCallState(), ITBasicCallControl::QueryInterface() on IID_ITCallInfo failed, error code:0x%08x"), 
			TEXT(__FILE__),
			__LINE__,
			hr
			);
		_ASSERT(NULL != pCallInfo);
	}
	else
	{
		//
		//increase reference by one, this way in both cases 
		// we have to call Release() at the end of the function.
		//
		pCallInfo->AddRef();
	}

	CALL_STATE csCurrentCallState;
	hr = pCallInfo->get_CallState(&csCurrentCallState);
	pCallInfo->Release();
	pCallInfo = NULL;
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::GetCallState(), ITCallInfo::get_CallState() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);

	return csCurrentCallState;
}


//*********************************************************************************
//* Name:	IsCallActive
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Check if the call is in a callstate different than CS_IDLE or CS_DISCONNECTED
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		TRUE
//*			The call is in an active state (CONNECT, OFFERING etc)
//*		FALSE
//*			The call handle is either NULL or the callstate is IDLE or DISCONNECTED
//*	REMARKS:
//*		This function uses ::GetCallState()
///*********************************************************************************
bool CTapi3Device::IsCallActive() const
{
	_ASSERT(NULL != m_Tapi);

	if (NULL == m_pBasicCallControl)
	{
		return false;
	}
	CALL_STATE csCurrentCallState = GetCallState();
	if ( (CS_IDLE == csCurrentCallState) || (CS_DISCONNECTED == csCurrentCallState) )
	{
		return false;
	}
	else
	{
		return true;
	}

}

//*********************************************************************************
//* Name:	DequeueCallStateMessage
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Dequeue a callstate event from the queue
//* PARAMETERS:
//*		[IN]	const CALL_STATE csCallState
//*			the callstate to dequeue from the queue
//*	RETURN VALUE:
//*		NONE
//*********************************************************************************
void CTapi3Device::DequeueCallStateMessage(const CALL_STATE csCallState)
{
	_ASSERT(NULL != m_Tapi);
	_ASSERT(NULL != m_pBasicCallControl);
	_ASSERT(NULL != m_pAddress);

	P<TapiEventItem> pQueuedTapiEventItem = GetEventItemFromQueue(TE_CALLSTATE,TAPI3_DEFAULT_WAIT_FOR_MESSAGE_TIMEOUT);
	if (!pQueuedTapiEventItem )
	{
		if (WAIT_TIMEOUT == ::GetLastError())
		{
			throw CException(TEXT("CTapi3Device::DequeueCallStateMessage() Timeout for get %d message"),csCallState);
		}
		else
		{
			throw CException(TEXT("CTapi3Device::DequeueCallStateMessage(), GetEventItemFromQueue() returned NULL"));
		}
	}

	ITCallStateEventPtr pCallStateEvent = NULL;
	pCallStateEvent = dynamic_cast<ITCallStateEvent *>( pQueuedTapiEventItem->GetEvent());
	if (NULL == pCallStateEvent)
	{
		throw CException(TEXT("CTapi3Device::DequeueCallStateMessage() dynamic_cast<ITCallStateEvent *> failed"));
	}
		
	//
	//get the call state from the event
	//
	CALL_STATE csEventCallState;
	HRESULT hr = pCallStateEvent->get_State(&csEventCallState);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::DequeueCallStateMessage(), ITCallStateEvent::get_State() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);
	if (csCallState != csEventCallState)
	{
		throw CException(TEXT("CTapi3Device::DequeueCallStateMessage() the call state in the queue is %d, current callstate is=%d"),
			csEventCallState,
			csCallState
			);
	}
	
	
	CALL_STATE_EVENT_CAUSE CallStateCause;
	hr = pCallStateEvent->get_Cause(&CallStateCause);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::DequeueCallStateMessage(), ITCallStateEvent::get_Cause() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);
	
	//
	//get CallInfo handle from the event
	//
	ITCallInfoPtr pEventCallInfo;
	hr = pCallStateEvent->get_Call(&pEventCallInfo);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::DequeueCallStateMessage(), ITCallStateEvent::get_Call() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);

	
	

	ITBasicCallControlPtr	pEventBasicCallControl;
	hr = pEventCallInfo->QueryInterface(IID_ITBasicCallControl, (LPVOID *)&pEventBasicCallControl);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::DequeueCallStateMessage(), ITCallInfo::QueryInterface() on IID_ITBasicCallControl failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);

	//
	//both calls should have the same call handle
	//
	_ASSERT(pEventBasicCallControl == m_pBasicCallControl);

}//void CTapi3Device::DequeueCallStateMessage()



//*********************************************************************************
//* Name:	SetNewCallHandle
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Check if we have a new call, set it's call handle and return the 
//*		call's state
//* PARAMETERS:
//*		[IN]	DWORD dwTimeOut
//*					timeout in milliseconds to wait for the new call.
//*	RETURN VALUE:
//*		OFFERING_CALL
//*			We have a new offering call (at OFFERING or ACCEPT state)
//*		ACTIVE_CALL
//*			We have a new call in an active state (CONNECTED, DAILING etc.)
//*		IDLE_CALL
//*			We have a new offering call (at IDLE or DISCONNECT state)
//*			this kind of call probably arrived through a handoff
//*		NO_NEW_CALL
//*			No offering call.
//*********************************************************************************
SetNewCallHandleErrors CTapi3Device::SetNewCallHandle(const DWORD dwTimeOut)
{
	_ASSERT(NULL != m_Tapi);
	_ASSERT(NULL == m_pBasicCallControl);

	
	P<TapiEventItem> pQueuedTapiEventItem = GetEventItemFromQueue(TE_CALLNOTIFICATION,dwTimeOut);
	if (!pQueuedTapiEventItem)
	{
		//
		//no CallNotificationEvent, so we don't have a new call
		//
		return (NO_CALL);
	}

	ITCallNotificationEventPtr pCallNotificationEvent = NULL;
	pCallNotificationEvent = dynamic_cast<ITCallNotificationEvent *>(pQueuedTapiEventItem->GetEvent());
	if (NULL == pCallNotificationEvent)
	{
		throw CException(TEXT("CTapi3Device::SetNewCallHandle() dynamic_cast<ITCallNotificationEvent *> failed"));
	}

	
	ITCallInfoPtr pCallInfo = GetCallInfoFromCallEvent(pCallNotificationEvent);
			
	if (NULL == pCallInfo)
	{
		throw CException(TEXT("CTapi3Device::SetNewCallHandle(), CTapi3Device::GetCallInfoFromCallEvent() return NULL"));
	}

	//
	//check if new call is on the correct address
	//
	VerifyAddressFromCallInfo(pCallInfo);

	//
	//Set m_pBasicCallControl from pCallInfo
	//
	HRESULT hr = pCallInfo->QueryInterface(
		IID_ITBasicCallControl,
		(LPVOID *)&m_pBasicCallControl
		);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::SetNewCallHandle(), ITCallInfo::QueryInterface() on IID_ITBasicCallControl failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);
	_ASSERT(NULL != m_pBasicCallControl);
	
	CALL_STATE csCallState = GetCallState();
	
	//
	//dequeue the callstate from the queue
	//
	DequeueCallStateMessage(csCallState);
	
	//
	//check the call state
	//
	switch(csCallState)
	{
		
	case CS_IDLE:
		return IDLE_CALL;

	case CS_INPROGRESS:
		return ACTIVE_CALL;
	
	case CS_CONNECTED:
		return ACTIVE_CALL;

	case CS_DISCONNECTED:
		return IDLE_CALL;
		
	case CS_OFFERING:
		return OFFERING_CALL;

	case CS_HOLD:
		return ACTIVE_CALL;
	
	case CS_QUEUED:
		return ACTIVE_CALL;
	
	default:
		throw CException(TEXT("CTapi3Device::SetNewCallHandle, New call with unsupported state"));
	}

	//
	//this is just for compiler error, control never gets here
	//
	return ACTIVE_CALL;

}//void CTapi3Device::SetCallHandle()



//*********************************************************************************
//* Name:	GetCallInfoFromCallEvent
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		return the CallInfo and check if the call's privilege is OWNER
//* PARAMETERS:
//*		[IN]	ITCallNotificationEvent *pCallNotificationEvent
//*					new call event to query callInfo
//*	RETURN VALUE:
//*		the callInfo pointer
//*	REMARK:
//*		This function uses ITCallNotificationEvent::get_Call()
//*********************************************************************************
ITCallInfo *CTapi3Device::GetCallInfoFromCallEvent(ITCallNotificationEvent *pCallNotificationEvent) const
{
	_ASSERT(NULL != m_Tapi);
	_ASSERT(NULL != pCallNotificationEvent);
	
	CALL_NOTIFICATION_EVENT csePrivilege;

	HRESULT hr = pCallNotificationEvent->get_Event(&csePrivilege);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::GetCallInfoFromCallEvent(), ITCallNotificationEvent::get_Event() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);

	if (CNE_MONITOR == csePrivilege)
	{
		throw CException(TEXT("CTapi3Device::GetCallInfoFromCallEvent(), New call is with MONITOR privilege only"));
	}
	_ASSERT(CNE_OWNER == csePrivilege);

	ITCallInfoPtr pCallInfo;
	hr = pCallNotificationEvent->get_Call(&pCallInfo);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::GetCallInfoFromCallEvent(), ITCallNotificationEvent::get_Call() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);
	_ASSERT(pCallInfo != NULL);
	return (pCallInfo.Detach());

}//void CTapi3Device::GetCallInfoFromCallEvent()


//*********************************************************************************
//* Name:	VerifyAddressFromCallInfo
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		get the address from the callInfo and verify that it's the registered
//*		address (stored in m_pAddress)
//* PARAMETERS:
//*		[IN]	ITCallInfo *pCallInfo
//*					callInfo which will be used to get the address from
//*	RETURN VALUE:
//*		NONE
//*	REMARK:
//*		This function uses ITCallInfo::get_Address()
//*********************************************************************************
void CTapi3Device::VerifyAddressFromCallInfo(ITCallInfo *pCallInfo) const
{
	_ASSERT(NULL != m_Tapi);
	_ASSERT(NULL != pCallInfo);
	_ASSERT(NULL != m_pAddress);

	//
	//get the ITAddress from pCallInfo
	//
	ITAddressPtr pAddress;

	HRESULT hr = pCallInfo->get_Address(&pAddress);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::VerifyAddressFromCallInfo(), ITCallInfo::get_Address() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);
	
	//
	//We're registered to listen on 1 address only
	// so the address on the new call should be the same address as 
	// the tapi device address defined in Tapi3Device::Tapi3Device().
	//
	if(pAddress != m_pAddress)
	{
		throw CException(TEXT("CTapi3Device::VerifyAddressFromCallInfo() new call doesn't match wanted address"));
	}
}//void CTapi3Device::VerifyAddressFromCallInfo()


//*********************************************************************************
//* Name:	SetCommPortHandleFromCallHandle
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		sets the comm port handle(m_modemCommPortHandle) using the call object
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		NONE
//*	REMARKS:
//*		This function uses ITLegacyCallMediaControl::GetID()
//*********************************************************************************
void CTapi3Device::SetCommPortHandleFromCallHandle()
{
	_ASSERT(NULL != m_Tapi);
	_ASSERT(NULL == m_modemCommPortHandle);
	_ASSERT(NULL != m_pBasicCallControl);

	//
	//get a ITLegacyCallMediaControl interface
	//
	ITLegacyCallMediaControlPtr pLegacyCallMediaControl;
	HRESULT hr = m_pBasicCallControl->QueryInterface(IID_ITLegacyCallMediaControl, (LPVOID *)&pLegacyCallMediaControl);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::SetCommPortHandleFromCallHandle(), ITBasicCallControl::QueryInterface() on IID_ITLegacyCallMediaControl failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);
	_ASSERT(NULL != pLegacyCallMediaControl);


	CBSTR bstrDeviceClass = SysAllocString(TEXT("comm/datamodem"));
	if (!bstrDeviceClass)
	{
		throw CException(TEXT("CTapi3Device::SetCommPortHandleFromCallHandle(), SysAllocString() failed"));
	}

	//
	//get a handle to the comm port
	//
	LPBYTE		lpDeviceInfo = NULL;
	DWORD dwSize = 0;
	hr = pLegacyCallMediaControl->GetID(
		bstrDeviceClass,
		&dwSize,
		(BYTE **) &lpDeviceInfo
		);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::SetCommPortHandleFromCallHandle(), ITLegacyCallMediaControl::GetID() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);
	
	_ASSERT(dwSize >= sizeof(m_modemCommPortHandle));
	m_modemCommPortHandle	= *((LPHANDLE) lpDeviceInfo);
	_ASSERT(NULL != m_modemCommPortHandle);


}//void CTapi3Device::SetCommPortHandleFromCallHandle()




//*********************************************************************************
//* Name:	SetCommPortHandleFromAddressHandle
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		sets the comm port handle(m_modemCommPortHandle) using the 
//*		address object
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		NONE
//*	REMARKS:
//*		This function uses ITLegacyCallMediaControl::GetID()
//*********************************************************************************
void CTapi3Device::SetCommPortHandleFromAddressHandle()
{
	_ASSERT(NULL != m_Tapi);
	_ASSERT(NULL == m_modemCommPortHandle);
	_ASSERT(NULL != m_pAddress);

	//
	//get a ITLegacyAddressMediaControl interface
	//
	ITLegacyAddressMediaControlPtr pLegacyAddressMediaControl = NULL;
	HRESULT hr = m_pAddress->QueryInterface(IID_ITLegacyAddressMediaControl, (LPVOID *)&pLegacyAddressMediaControl);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::SetCommPortHandleFromAddressHandle(), ITAddress::QueryInterface() on IID_ITLegacyAddressMediaControl failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);
	
	CBSTR bstrDeviceClass = SysAllocString(TEXT("comm/datamodem"));
	if (!bstrDeviceClass)
	{
		throw CException(TEXT("CTapi3Device::SetCommPortHandleFromAddressHandle(), SysAllocString() failed"));
	}


	//
	//get a handle to the comm port
	//
	DWORD	dwSize = 0;
	LPBYTE	lpDeviceInfo = NULL;
	
	hr = pLegacyAddressMediaControl->GetID(
		bstrDeviceClass,
		&dwSize,
		(BYTE **) &lpDeviceInfo
		);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::SetCommPortHandleFromAddressHandle(), ITLegacyAddressMediaControl::GetID() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);

	_ASSERT(dwSize >= sizeof(m_modemCommPortHandle));
	m_modemCommPortHandle	= *((LPHANDLE) lpDeviceInfo);
	_ASSERT(NULL != m_modemCommPortHandle);

}//void CTapi3Device::SetCommPortHandleFromAddressHandle()





//*********************************************************************************
//* Name:	CreateCallWrapper
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Wrapper for ITAddress::CreateCall()
//* PARAMETERS:
//*		[IN]	LPCTSTR szNum
//*			number to call
//*		[IN]	const DWORD dwMedia
//*					media mode possible values are:
//*						TAPIMEDIATYPE_AUDIO
//*						TAPIMEDIATYPE_DATAMODEM
//*						TAPIMEDIATYPE_G3FAX
//*			
//*	RETURN VALUE:
//*		NONE
//*********************************************************************************
void CTapi3Device::CreateCallWrapper(LPCTSTR szNum,const DWORD dwMedia)
{
	_ASSERT(NULL != m_Tapi);
	_ASSERT(NULL != m_pAddress);
	_ASSERT(NULL == m_pBasicCallControl);
	_ASSERT(NULL != szNum);
	
	VerifyValidMediaModeForOutgoingCall(dwMedia);
	
	//
	//ITADDRESS::CreateCall() takes a BSTR, so prepare a BSTR from the szNum
	//
	CBSTR numberToCallAsBSTR = SysAllocString(szNum);
	if (!numberToCallAsBSTR)
	{
		throw CException(TEXT("CTapi3Device::CreateCallWrapper(), SysAllocString() failed"));
	}

	//
	//create call, returns a ITBasicCallControl, to actuly make the call
	//we need to call ITBasicCallControl::Connect()
	//
	
	HRESULT hr = m_pAddress->CreateCall(numberToCallAsBSTR ,LINEADDRESSTYPE_PHONENUMBER,dwMedia,&m_pBasicCallControl);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::CreateCallWrapper(), ITAddress::CreateCall() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);
	_ASSERT(NULL != m_pBasicCallControl);
	
}//void CTapi3Device::CreateCallWrapper()


//*********************************************************************************
//* Name:	AnswerOfferingCall
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Answer the offering call using ITBasicCallControl::Answer() and verify
//*		that the call is in CONNECTED state
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		NONE
//*********************************************************************************
void CTapi3Device::AnswerOfferingCall()
{
	_ASSERT(NULL != m_Tapi);
	_ASSERT(NULL != m_pAddress);
	_ASSERT(NULL != m_pBasicCallControl);

	if (m_isFaxCall)
	{
		//
		//FAX calls should be handled using PASS_THROUGH mode not using TAPI API:

		SetBearerModeToPASSTHROUGH();
		SetCommPortHandleFromCallHandle();
		FaxAnswerOfferingCall();
		return;
	}
	
	ClearMessageQueue();
	
	HRESULT hr = m_pBasicCallControl->Answer();
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::AnswerOfferingCall(), ITBasicCallControl::Answer() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);

}//void CTapi3Device::AnswerOfferingCall()


//*********************************************************************************
//* Name:	ConnectCall
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Connect the call previously initialized by makeCall
//*		and verify that the call is in CONNECTED state
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		NONE
//*********************************************************************************
void CTapi3Device::ConnectCall() const
{
	_ASSERT(NULL != m_Tapi);
	_ASSERT(NULL != m_pAddress);
	_ASSERT(NULL != m_pBasicCallControl);

	//
	//dial the number given to makeCall, and wait till a CONNECT message is received
	//the TRUE parameter indicates that the Connect() is sync
	//
	HRESULT hr = m_pBasicCallControl->Connect(TRUE);	
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::ConnectCall(), ITBasicCallControl::Connect() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);

	if (CS_CONNECTED == GetCallState())
	{
		return;
	}
	else
	{
		throw CException(TEXT("CTapi3Device::ConnectCall(), Call not in CONNECT state"));
	}

}//void CTapi3Device::ConnectCall() const


//*********************************************************************************
//* Name:	ClearMessageQueue
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Clear the event message queue
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		NONE
//*	REMARKS:
//*		for each queued is deleted causing a Release() to be called
//*********************************************************************************


void CTapi3Device::ClearMessageQueue() const
{
	_ASSERT(NULL != m_Tapi);
	
	TapiEventItem *pQueuedEventItem;
	while (m_eventQueue.DeQueue(pQueuedEventItem))
	{
		//
		//delete the queued event (this causes a Release to be called from the destructor)
		//
		delete pQueuedEventItem;
		pQueuedEventItem = NULL;
	}
}



//*********************************************************************************
//* Name:	GetCallSupportedMediaModes
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		return the call's supported media mode, based on the m_pBasicCallControl
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		call's supported media modes
//*	REMARKS:
//*		this function uses ITCallInfo::get_MediaTypesAvailable()
//*********************************************************************************
DWORD CTapi3Device::GetCallSupportedMediaModes() const
{
	_ASSERT(NULL != m_Tapi);
	_ASSERT(NULL != m_pBasicCallControl);

	ITCallInfoPtr pCallInfo = NULL;
	HRESULT hr = m_pBasicCallControl->QueryInterface(IID_ITCallInfo, (LPVOID *)&pCallInfo);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::GetCallSupportedMediaModes(), ITBasicCallControl::QueryInterface() on IID_ITCallInfo failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);
	_ASSERT(NULL != pCallInfo);
	
	long lMediaTypes;
	hr = pCallInfo->get_CallInfoLong(CIL_MEDIATYPESAVAILABLE,&lMediaTypes);
	//hr = pCallInfo->get_MediaTypesAvailable(&lMediaTypes);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::GetCallSupportedMediaModes(), ITCallInfo::get_MediaTypesAvailable() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);
	
	long lBearerMode;
	hr = pCallInfo->get_CallInfoLong(CIL_BEARERMODE,&lBearerMode);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::GetCallSupportedMediaModes(), ITCallInfo::get_BearerMode() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);
	
	if (m_isFaxCall)
	{
		_ASSERT(LINEBEARERMODE_PASSTHROUGH == lBearerMode);
		_ASSERT(TAPIMEDIATYPE_DATAMODEM == lMediaTypes);
		lMediaTypes = TAPIMEDIATYPE_G3FAX;
	}
	
	return lMediaTypes;
}//void CTapi3Device::GetCallSupportedMediaModes()



////////////////////////////////////////////////////////////////////////////////////////////////
//public functions
////////////////////////////////////////////////////////////////////////////////////////////////




///*********************************************************************************
//* Name:	VerifyValidMediaModeForIncomingCall
//* Author: Guy Merin / 30-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Check if the given media mode is valid in Tapi2 for incoming calls
//* PARAMETERS:
//*		[IN]	const DWORD dwMediaMode
//*					a combination of the following media mode:
//*						TAPIMEDIATYPE_AUDIO
//*						TAPIMEDIATYPE_DATAMODEM
//*						TAPIMEDIATYPE_G3FAX
//*	RETURN VALUE:
//*		NONE
//*	REMARKS:
//*		incoming call can have more than one supported media modes
//*********************************************************************************
void CTapi3Device::VerifyValidMediaModeForIncomingCall(const DWORD dwMediaMode) const
{
	if	(
			(TAPIMEDIATYPE_AUDIO & dwMediaMode) ||
			(TAPIMEDIATYPE_DATAMODEM & dwMediaMode) ||
			(TAPIMEDIATYPE_G3FAX & dwMediaMode)
		)
	{
		return;
	}
	else
	{
		throw CException(
			TEXT("%s(%d): CTapi3Device::VerifyValidMediaModeForIncomingCall(), unknown media mode(0x%08x)"), 
			TEXT(__FILE__),
			__LINE__,
			dwMediaMode
			);
	}

}//void CTapi3Device::VerifyValidMediaModeForIncomingCall()



///*********************************************************************************
//* Name:	VerifyValidMediaModeForOutgoingCall
//* Author: Guy Merin / 30-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Check if the given media mode is valid in Tapi2 for incoming calls
//* PARAMETERS:
//*		[IN]	const DWORD dwMediaMode
//*					a combination of the following media mode:
//*						TAPIMEDIATYPE_AUDIO
//*						TAPIMEDIATYPE_DATAMODEM
//*						TAPIMEDIATYPE_G3FAX
//*	RETURN VALUE:
//*		NONE
//*	REMARKS:
//*		incoming call can have more than one supported media modes
//*********************************************************************************
void CTapi3Device::VerifyValidMediaModeForOutgoingCall(const DWORD dwMediaMode) const
{
	if	(
			(TAPIMEDIATYPE_AUDIO == dwMediaMode) ||
			(TAPIMEDIATYPE_DATAMODEM == dwMediaMode) ||
			(TAPIMEDIATYPE_G3FAX == dwMediaMode)
		)
	{
		return;
	}
	else
	{
		throw CException(
			TEXT("%s(%d): CTapi3Device::VerifyValidMediaModeForOutgoingCall(), unknown media mode(0x%08x)"), 
			TEXT(__FILE__),
			__LINE__,
			dwMediaMode
			);
	}

}//void CTapi3Device::VerifyValidMediaModeForOutgoingCall()



//*********************************************************************************
//* Name:	CleanUp
//* Author: Guy Merin / 03-Dec-98
//*********************************************************************************
//* DESCRIPTION:
//*		A cleanup function that dealloctes, releases, resets all the member variables
//*		The state of the object after calling this function is the same as a
//*		construcated object
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		NONE
//*	REMARKS:
//*		The object's message queue is cleared (from all the call's queued events)
//*********************************************************************************
void CTapi3Device::CleanUp()
{

	if (NULL != m_pBasicCallControl)
	{
		HangUp();
		_ASSERT(NULL == m_pBasicCallControl);
	}
	
	if (NULL != m_pAddress)
	{
		m_pAddress.Release();
	}

	if (NULL != m_pTerminal)
	{
		m_pTerminal.Release();
	}

	ClearMessageQueue();

	
	if (MEDIA_NOT_REGISTERED != m_lRegisterIndex)
	{
		//
		//Register has been called on this tapi3Device object
		// call unRegister
		//
		UnRegisterNotificationForMediaMode();
	}

	if (m_isFaxCall)
	{
		CloseCommPortHandle();
		m_modemCommPortHandle = NULL;
		m_isFaxCall = false;
	}




}//void CTapi3Device::CleanUp()


//*********************************************************************************
//* Name:	HangUp
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Hangup the call and unregister the call's media mode
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		NONE
//*	REMARKS:
//*		The object's message queue is cleared (from all the call's queued events)
//*********************************************************************************
void CTapi3Device::HangUp()
{
	_ASSERT(NULL != m_Tapi);
	_ASSERT(NULL != m_pBasicCallControl);
	_ASSERT(NULL != m_pAddress);
	
	if (IsCallActive())
	{
		//
		//if the call is a FAX call and the modem is already in PASSTHROUGH mode
		//we need to hangup using AT commands
		//
		if (m_isFaxCall && m_modemCommPortHandle)
		{
			SendFaxHangUpCommands();
		}
		
		HRESULT hr = m_pBasicCallControl->Disconnect(DC_NORMAL);
		ThrowOnComError(
			hr,
			TEXT("%s(%d): CTapi3Device::HangUp(), ITBasicCallControl::Disconnect() failed, error code:0x%08x"), 
			TEXT(__FILE__),
			__LINE__,
			hr
			);
	}
	
	//
	//call now is in DISCONNECT state or IDLE state
	//
	if (NULL != m_pBasicCallControl)
	{
		m_pBasicCallControl.Release();
	}
	
	if (NULL != m_pAddress)
	{
		m_pAddress.Release();
	}

	if (NULL != m_pTerminal)
	{
		m_pTerminal.Release();
	}

	//
	//release all the call messages stored in the queue
	//
	ClearMessageQueue();

	
	if (MEDIA_NOT_REGISTERED != m_lRegisterIndex)
	{
		//
		//Register has been called on this tapi3Device object
		// call unRegister
		//
		UnRegisterNotificationForMediaMode();
	}

	if (m_isFaxCall)
	{
		CloseCommPortHandle();
		m_isFaxCall = false;
	}

}//CTapi3Device::HangUp()




//*********************************************************************************
//* Name:	DirectHandoffCall
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		handoff the call to a specific application
//* PARAMETERS:
//*		[IN]	LPCTSTR szAppName
//*					the application to receive the handoff
//*	RETURN VALUE:
//*		an exception is thrown if the handoff failed or the target application
//*		wasn't found.
//*********************************************************************************
void CTapi3Device::DirectHandoffCall(LPCTSTR szAppName)
{
	_ASSERT(NULL != m_Tapi);
	_ASSERT(NULL != m_pAddress);
	_ASSERT(NULL != m_pBasicCallControl);

	if (NULL == szAppName)
	{
		throw CException(TEXT("CTapi3Device::DirectHandoffCall(): No application given"));
	}
	
	//
	//ITBasicCallControl::HandoffDirect() takes a BSTR so we need to
	// allocate a BSTR and free it after the call to ITBasicCallControl::HandoffDirect()
	//
	CBSTR pApplicationToHandoff = SysAllocString(szAppName);
	if (!pApplicationToHandoff)
	{
		throw CException(TEXT("CTapi3Device::DirectHandoffCall(), SysAllocString() failed"));
	}

	HRESULT hr = m_pBasicCallControl->HandoffDirect(pApplicationToHandoff);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::DirectHandoffCall(), ITBasicCallControl::HandoffDirect() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);
}//void CTapi3Device::DirectHandoffCall()


//*********************************************************************************
//* Name:	MediaHandoffCall
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		run through all the call media modes and try to handoff the call to
//*		another TAPI application
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		TRUE
//*			the call was handed off succesfuly
//*		FALSE
//*			the call wasn't handed off (no higher priority application is
//*			registered to the call's media mode).
//*	REMARKS:
//*		ITBasicCallControl::HandoffIndirect() takes only one media mode at a time,
//*		so for every media mode the call supports, 
//*     we need to call ITBasicCallControl::HandoffIndirect().
//*********************************************************************************
bool CTapi3Device::MediaHandoffCall()
{
	_ASSERT(NULL != m_Tapi);
	_ASSERT(NULL != m_pAddress);
	_ASSERT(NULL != m_pBasicCallControl);

	HRESULT hr;
	//
	//get the call's supported media modes
	//
	long lMediaTypes = GetCallSupportedMediaModes();
	
	//
	//for each supported media mode try a indirect handoff 
	//
	if (lMediaTypes & TAPIMEDIATYPE_AUDIO)
	{
		hr = m_pBasicCallControl->HandoffIndirect(TAPIMEDIATYPE_AUDIO);
		if SUCCEEDED(hr)
		{
			goto INDIRECT_SUCCESS;
		}
	}
	
	if (lMediaTypes & TAPIMEDIATYPE_DATAMODEM)
	{
		hr = m_pBasicCallControl->HandoffIndirect(TAPIMEDIATYPE_DATAMODEM);
		if SUCCEEDED(hr)
		{
			goto INDIRECT_SUCCESS;
		}
	}
	
	if (lMediaTypes & TAPIMEDIATYPE_G3FAX)
	{
		hr = m_pBasicCallControl->HandoffIndirect(TAPIMEDIATYPE_G3FAX);
		if SUCCEEDED(hr)
		{
			goto INDIRECT_SUCCESS;
		}
	}

	//
	//all supported media modes on the current call failed an indirect handoff
	//
	m_pBasicCallControl.Release();
	TapiLogDetail(LOG_X, 5, TEXT("Handoff failed with all media modes"));
	return false;


INDIRECT_SUCCESS:
	m_pBasicCallControl.Release();
	TapiLogDetail(LOG_X, 5, TEXT("Handoff succeded"));
	return true;


}//bool CTapi3Device::MediaHandoffCall()



//*********************************************************************************
//* Name:	AddEventToQueue
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		The object has a new event, queue it.
//* PARAMETERS:
//*		[IN]	TapiEventItem eventToBeQueued
//*					new event to be queued
//*	RETURN VALUE:
//*		NONE
//*********************************************************************************
void CTapi3Device::AddEventToQueue(TapiEventItem *pEventToBeQueued)
{
	_ASSERT(NULL != m_Tapi);
	_ASSERT(NULL != pEventToBeQueued);

	
	//
	//a new event arrived add it to the queue
	//
	if (!m_eventQueue.Queue(pEventToBeQueued))
	{
		delete pEventToBeQueued;
		pEventToBeQueued = NULL;
		throw CException(TEXT("CTapi3Device::AddEventToQueue(), CMtQueue::Queue() failed"));
	}
	
}//CTapi3Device::AddEventToQueue





//*********************************************************************************
//* Name:	SendAnswerStream
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Send the answer stream according to the call's media mode
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		NONE
//*********************************************************************************
void CTapi3Device::SendAnswerStream()
{
	DWORD dwCallMediaMode = GetCallSupportedMediaModes();

	switch (dwCallMediaMode)
	{
	
	case TAPIMEDIATYPE_DATAMODEM :
		SendAnswerDataStream();
		break;
	
	case TAPIMEDIATYPE_AUDIO:
		SendAnswerVoiceStream();
		break;
	
	case TAPIMEDIATYPE_G3FAX:
		SendAnswerFaxStream();
		break;
	
	default:
		throw CException(TEXT("CTapi3Device::SendAnswerStream(), Unknown media mode"));
	}
}//void CTapi3Device::SendAnswerStream()



//*********************************************************************************
//* Name:	SendCallerStream
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Send the caller stream according to the call's media mode
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		NONE
//*********************************************************************************
void CTapi3Device::SendCallerStream()
{
	DWORD dwCallMediaMode = GetCallSupportedMediaModes();

	switch (dwCallMediaMode)
	{
	
	case TAPIMEDIATYPE_DATAMODEM :
		SendCallerDataStream();
		break;
	
	case TAPIMEDIATYPE_AUDIO:
		SendCallerVoiceStream();
		break;

	case TAPIMEDIATYPE_G3FAX:
		SendCallerFaxStream();
		break;
	
	default:
		throw CException(TEXT("CTapi3Device::SendCallerStream(), Unknown media mode"));
	}

}//void CTapi3Device::SendCallerStream()





//*********************************************************************************
//* Name:	TapiLogDetail
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Wrapper for ::lgLogDetail(), logs a message with the Tapi's properties
//* PARAMETERS:
//*		[IN]	DWORD dwLevel
//*					log level, passed to ::lgLogDetail()
//*		[IN]	DWORD dwSeverity 
//*					log severity, passed to ::lgLogDetail()
//*		[IN]	const TCHAR * const szLogDescription
//*					description format, 
//*		[IN]	...
//*					extra parameters as specified in szLogDescription parameter
//*	RETURN VALUE:
//*		NONE
//*********************************************************************************
void CTapi3Device::TapiLogDetail(
	DWORD dwLevel,
	DWORD dwSeverity,
	const TCHAR * const szLogDescription,
	...
	) const
{
	TCHAR szLog[MaxLogSize];
	szLog[MaxLogSize-1] = '\0';
	va_list argList;
	va_start(argList, szLogDescription);
	::_vsntprintf(szLog, MaxLogSize-1, szLogDescription, argList);
	va_end(argList);

	::lgLogDetail(
		dwLevel, 
		dwSeverity, 
		TEXT("AddressID=0x%08x, DeviceId=%d, %s"),
		m_pAddress,
		m_dwId,
		szLog
		);

}//void CTapi3Device::TapiLogDetail()


//*********************************************************************************
//* Name:	TapiLogError
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Wrapper for ::lgLogError(), logs a message with the Tapi's properties
//* PARAMETERS:
//*		[IN]	DWORD dwSeverity 
//*					log severity, passed to ::lgLogError()
//*		[IN]	const TCHAR * const szLogDescription
//*					description format, 
//*		[IN]	...
//*					extra parameters as specified in szLogDescription parameter
//*	RETURN VALUE:
//*		NONE
//*********************************************************************************
void CTapi3Device::TapiLogError(
	DWORD dwSeverity,
	const TCHAR * const szLogDescription,
	...
	) const
{
	TCHAR szLog[MaxLogSize];
	szLog[MaxLogSize-1] = '\0';
	va_list argList;
	va_start(argList, szLogDescription);
	::_vsntprintf(szLog, MaxLogSize-1, szLogDescription, argList);
	va_end(argList);

	::lgLogError(
		dwSeverity, 
		TEXT("AddressID=0x%08x, DeviceId=%d, %s"),
		m_pAddress,
		m_dwId,
		szLog
		);

}//void CTapi3Device::TapiLogError()



//*********************************************************************************
//* Name:	OpenLineForOutgoingCall
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Opens a line for outgoing calls
//* PARAMETERS:
//*		[IN]	const DWORD dwMedia
//*					media mode to open line with, must be ONE of the followings:
//*						TAPIMEDIATYPE_AUDIO,
//*						TAPIMEDIATYPE_DATAMODEM,
//*						TAPIMEDIATYPE_G3FAX
//*	RETURN VALUE:
//*		NONE
//*	REMARKS:
//*		the function uses CTapi3Device::SetAddressProperty()
//*********************************************************************************
void CTapi3Device::OpenLineForOutgoingCall(const DWORD dwMedia)
{
	DWORD dwMediaForOpeningLine;
	if ( TAPIMEDIATYPE_G3FAX == dwMedia)
	{
		//
		//fax calls are handled through data mode and passthrough
		//
		dwMediaForOpeningLine = TAPIMEDIATYPE_DATAMODEM;
		m_isFaxCall = true;
	}
	else
	{
		dwMediaForOpeningLine = dwMedia;
	}

	//
	//Set the device address to make the outgoing call
	//
	SetAddressProperty(dwMediaForOpeningLine);

}//void CTapi3Device::OpenLineForOutgoingCall()


//*********************************************************************************
//* Name:	OpenLineForIncomingCall
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Opens a line for incoming call
//* PARAMETERS:
//*		[IN]	const DWORD dwMedia
//*					media mode to open line with, can be ANY combination of the followings:
//*						TAPIMEDIATYPE_AUDIO,
//*						TAPIMEDIATYPE_DATAMODEM,
//*						TAPIMEDIATYPE_G3FAX
//*	RETURN VALUE:
//*		NONE
//*	REMARKS:
//*		the function uses CTapi3Device::SetAddressProperty()
//*		and register to listen on the address using CTapi3Device::RegisterNotificationForMediaMode()
//*********************************************************************************
void CTapi3Device::OpenLineForIncomingCall(const DWORD dwMedia)
{
	DWORD dwMediaForOpeningLine;
	if ( TAPIMEDIATYPE_G3FAX == dwMedia)
	{
		//
		//fax calls are handled through data mode and passthrough
		//
		dwMediaForOpeningLine = TAPIMEDIATYPE_DATAMODEM;
		m_isFaxCall = true;
	}
	else
	{
		dwMediaForOpeningLine = dwMedia;
	}

	//
	//set m_pAddress to hold an address which supports the desired media mode to listen on
	//
	SetAddressProperty(dwMediaForOpeningLine);
	
	RegisterNotificationForMediaMode(dwMediaForOpeningLine);

}//void CTapi3Device::OpenLineForIncomingCall(


//*********************************************************************************
//* Name:	CreateAndConnectCall
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Creates an outgoing call and connects it
//* PARAMETERS:
//*		[IN]	LPCTSTR szNum
//*					number to call to
//*		[IN]	const DWORD dwMedia
//*					media mode to open line with, must be ONE of the followings:
//*						TAPIMEDIATYPE_AUDIO,
//*						TAPIMEDIATYPE_DATAMODEM,
//*						TAPIMEDIATYPE_G3FAX
//*	RETURN VALUE:
//*		NONE
//*	REMARKS:
//*		create a call using CTapi3Device::CreateCallWrapper()
//*		connect the call using CTapi3Device::ConnectCall()
//*********************************************************************************
void CTapi3Device::CreateAndConnectCall(LPCTSTR szNum, const DWORD dwMedia)
{
	_ASSERT(NULL != szNum);

	VerifyValidMediaModeForOutgoingCall(dwMedia);

	if (m_isFaxCall)
	{
		//
		//FAX calls should be handled using PASS_THROUGH mode not using TAPI API
		//
		FaxCreateAndConnectCall(szNum);
		return;
	}
	
	//
	//allocate a call and set the call handle
	//
	CreateCallWrapper(szNum,dwMedia);

	//
	//connect the call (dial and wait for connect state)
	//
	ConnectCall();

}//void CTapi3Device::CreateAndConnectCall()


//*********************************************************************************
//* Name:	WaitForCallerConnectState
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Wait for a connect state
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		NONE
//*	REMARKS:
//*		in TAPI3 call() is a sync function, so we don't need to wait for a 
//*		connect state, we'll just verify that the state is connected
//*		if the call is with fax media mode we invoke CTapi2Device::FaxWaitForConnectcall()
//*********************************************************************************
void CTapi3Device::WaitForCallerConnectState()
{
	if (m_isFaxCall)
	{
		//
		//FAX calls should be handled using PASS_THROUGH mode not using TAPI API:
		//
		FaxWaitForConnect();
		return;
	}
	
	//
	//call() is a sync so we only need to verify that the 
	//call's state is CONNECTED
	//
	_ASSERT(CS_CONNECTED == GetCallState());
	TapiLogDetail(LOG_X, 5, TEXT("CONNECTED"));
}//void CTapi3Device::WaitForCallerConnectState()


//*********************************************************************************
//* Name:	WaitForAnswererConnectState
//* Author: Guy Merin / 15-Nov-98
//*********************************************************************************
//* DESCRIPTION:
//*		Wait for a connect state
//* PARAMETERS:
//*		NONE
//*	RETURN VALUE:
//*		NONE
//*	REMARKS:
//*		wait for TE_CALLSTATE event which holds a CONNECT call state
//*		if the call is with fax media mode we invoke CTapi2Device::FaxWaitForConnectcall()
//*********************************************************************************
void CTapi3Device::WaitForAnswererConnectState()
{
	if (m_isFaxCall)
	{
		//
		//FAX calls should be handled using PASS_THROUGH mode not using TAPI API:
		//
		FaxWaitForConnect();
		return;
	}

	P<TapiEventItem> pQueuedTapiEventItem = GetEventItemFromQueue(TE_CALLSTATE,CALLSTATE_CONNECT_EVENT_TIMEOUT);
	
	if (!pQueuedTapiEventItem)
	{
		throw CException(TEXT("CTapi3Device::AnswerOfferingCall(), timeout for receiving CONNECT message"));
	}

	ITCallStateEventPtr pCallStateEvent = NULL;
	pCallStateEvent = dynamic_cast<ITCallStateEvent *>(pQueuedTapiEventItem->GetEvent());
	if (NULL == pCallStateEvent)
	{
		throw CException(TEXT("CTapi3Device::WaitForAnswererConnectState() dynamic_cast<ITCallStateEvent *> failed"));
	}

	VerifyCallFromCallStateEvent(pCallStateEvent);

	CALL_STATE CallState;
	HRESULT hr = pCallStateEvent->get_State(&CallState);
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::AnswerOfferingCall(), ITCallStateEvent::get_State() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);

	if (CS_CONNECTED != CallState)
	{
		throw CException(TEXT("CTapi3Device::AnswerOfferingCall(), Call not in CONNECT state"));
	}

	_ASSERT(CS_CONNECTED == GetCallState());
	TapiLogDetail(LOG_X, 5, TEXT("CONNECTED"));
}//void CTapi3Device::WaitForAnswererConnectState()



//*********************************************************************************
//* Name:	CTapi3Device::GetFriendlyMediaMode()
//* Author:	Guy Merin
//* Date:	December 31, 1998
//*********************************************************************************
//* DESCRIPTION:
//*		A mapping between Tapi3.h media modes and abstract media type
//* PARAMETERS:
//*		NONE
//* RETURN VALUE:
//*		A combination of the following
//*			MEDIAMODE_VOICE
//*			MEDIAMODE_INTERACTIVE_VOICE
//*			MEDIAMODE_AUTOMATED_VOICE
//*			MEDIAMODE_FAX
//*			MEDIAMODE_DATA
//*			MEDIAMODE_UNKNOWN
//*********************************************************************************
DWORD CTapi3Device::GetFriendlyMediaMode(void) const
{

	DWORD dwCallSupportedMediaMode = GetCallSupportedMediaModes();
	DWORD dwAbstractMediaMode = 0;

	if (dwCallSupportedMediaMode & TAPIMEDIATYPE_AUDIO)
	{
		dwAbstractMediaMode = (dwAbstractMediaMode | MEDIAMODE_VOICE);
	}

	if (dwCallSupportedMediaMode & TAPIMEDIATYPE_DATAMODEM)
	{
		dwAbstractMediaMode = (dwAbstractMediaMode | MEDIAMODE_DATA);
	}

	if (dwCallSupportedMediaMode & TAPIMEDIATYPE_G3FAX)
	{
		dwAbstractMediaMode = (dwAbstractMediaMode | MEDIAMODE_FAX);
	}

	if (0 == dwAbstractMediaMode)
	{
		throw CException(
			TEXT("%s(%d): CTapi3Device::GetFriendlyMediaMode(), CTapi3Device::GetCallSupportedMediaModes() returned unsupported media mode(%d)"), 
			TEXT(__FILE__),
			__LINE__,
			dwCallSupportedMediaMode 
			);
	}

	return dwAbstractMediaMode;
}//CTapi3Device::GetFriendlyMediaMode()





//*********************************************************************************
//* Name:	CTapi3Device::GetDeviceSpecificMediaMode()
//* Author:	Guy Merin
//* Date:	January 11, 1999
//*********************************************************************************
//* DESCRIPTION:
//*		mapping between abstract media type and tapi2 media types
//* PARAMETERS:
//*		[IN]	const DWORD dwMedia
//*			abstract media mode
//* RETURN VALUE:
//*		a combination of the following:
//*			TAPIMEDIATYPE_AUDIO
//*			TAPIMEDIATYPE_DATAMODEM
//*			TAPIMEDIATYPE_G3FAX
//*********************************************************************************
DWORD CTapi3Device::GetDeviceSpecificMediaMode(const DWORD dwMedia)
{

	DWORD dwDeviceSpecificMediaMode = 0;

	//
	//voice
	//
	if (dwMedia & MEDIAMODE_AUTOMATED_VOICE)
	{
		dwDeviceSpecificMediaMode = (dwDeviceSpecificMediaMode | TAPIMEDIATYPE_AUDIO);
	}

	if (dwMedia & MEDIAMODE_INTERACTIVE_VOICE)
	{
		dwDeviceSpecificMediaMode = (dwDeviceSpecificMediaMode | TAPIMEDIATYPE_AUDIO);
	}

	if (dwMedia & MEDIAMODE_VOICE)
	{
		dwDeviceSpecificMediaMode = (dwDeviceSpecificMediaMode | TAPIMEDIATYPE_AUDIO);	
	}

	//
	//data
	//
	if (dwMedia & MEDIAMODE_DATA)
	{
		dwDeviceSpecificMediaMode = (dwDeviceSpecificMediaMode | TAPIMEDIATYPE_DATAMODEM);
	}

	//
	//fax
	//
	if (dwMedia & MEDIAMODE_FAX)
	{
		dwDeviceSpecificMediaMode = (dwDeviceSpecificMediaMode | TAPIMEDIATYPE_G3FAX);
	}

	//
	//unknown media mode isn't supported in Tapi3
	//
	if (dwMedia & MEDIAMODE_UNKNOWN)
	{
		throw CException(
			TEXT("%s(%d): CTapi3Device::GetDeviceSpecificMediaMode(), Unsupported media mode(MEDIAMODE_UNKNOWN)"), 
			TEXT(__FILE__),
			__LINE__
			);
	}

	
	//
	//other unsupported media modes
	//
	if (0 == dwDeviceSpecificMediaMode)
	{
		throw CException(
			TEXT("%s(%d): CTapi3Device::GetDeviceSpecificMediaMode(), Unsupported media mode(%x)"), 
			TEXT(__FILE__),
			__LINE__,
			dwMedia
			);
	}
	
	return dwDeviceSpecificMediaMode;

}//DWORD CTapi3Device::GetDeviceSpecificMediaMode()



//*********************************************************************************
//* Name:	CTapi3Device::SetCallMediaMode()
//* Author:	Guy Merin
//* Date:	January 07, 1999
//*********************************************************************************
//* DESCRIPTION:
//*		TBD
//* PARAMETERS:
//*		[IN]	const DWORD dwMedia
//*			The new media mode(s) for the call. 
//* RETURN VALUE:
//*		NONE
//*********************************************************************************
void CTapi3Device::SetCallMediaMode(const DWORD dwMedia)
{
	//TBD

}//void CTapi3Device::SetCallMediaMode()






//*********************************************************************************
//* Name:	CTapi3Device::SetApplicationPriorityForSpecificTapiDevice()
//* Author:	Guy Merin
//* Date:	January 11, 1999
//*********************************************************************************
//* DESCRIPTION:
//*		Make the current application as the highest/lowest priority application
//*		for a given combination of media modes
//* PARAMETERS:
//*		[IN]	const DWORD dwMedia
//*		a combination of the following Tapi3 media modes:
//*			TAPIMEDIATYPE_AUDIO
//*			TAPIMEDIATYPE_DATAMODEM
//*			TAPIMEDIATYPE_G3FAX
//* RETURN VALUE:
//*		NONE
//*********************************************************************************
void CTapi3Device::SetApplicationPriorityForSpecificTapiDevice(const DWORD dwMedia,const DWORD dwPriority)
{
	
	//
	//voice
	//
	if (TAPIMEDIATYPE_AUDIO & dwMedia)
	{
		SetApplicationPriorityForOneMediaMode(TAPIMEDIATYPE_AUDIO,dwPriority);	
	}
	
	//
	//data
	//
	if (TAPIMEDIATYPE_DATAMODEM & dwMedia)
	{
		SetApplicationPriorityForOneMediaMode(TAPIMEDIATYPE_DATAMODEM,dwPriority);	
	}

	//
	//fax
	//
	if (TAPIMEDIATYPE_G3FAX & dwMedia)
	{
		SetApplicationPriorityForOneMediaMode(TAPIMEDIATYPE_G3FAX,dwPriority);	
	}
	
}//void CTapi3Device::SetApplicationPriorityForSpecificTapiDevice()




//*********************************************************************************
//* Name:	CTapi3Device::SetApplicationPriorityForOneMediaMode()
//* Author:	Guy Merin
//* Date:	January 11, 1999
//*********************************************************************************
//* DESCRIPTION:
//*		 wrapper function for ITTAPI::SetApplicationPriority()
//* PARAMETERS:
//*		[IN]	const DWORD dwMediaMode
//*			media mode to change priority on	
//*		[IN]	const DWORD dwPriority
//*			new priority, possible values:
//*				0 for lowest priority
//*				1 for highest priority 
//* RETURN VALUE:
//*		NONE
//*********************************************************************************
void CTapi3Device::SetApplicationPriorityForOneMediaMode(const DWORD dwMediaMode,const DWORD dwPriority)
{
	CBSTR applicationAsBSTR = SysAllocString(APPLICATION_NAME_T); 
	if (NULL == (BSTR) applicationAsBSTR)
	{
		throw CException(TEXT("CTapi3Device::SetApplicationPriorityForOneMediaMode(), SysAllocString() failed"));
	}
	
	
	bool bPriority;
	if (0 == dwPriority)
	{
		bPriority = false;
	}
	else if (1 == dwPriority)
	{
		bPriority = true;
	}
	else
	{
		throw CException(
			TEXT("CTapi3Device::SetApplicationPriorityForOneMediaMode(), priority can be only 0 or 1 not (%d)"),
			dwPriority
			);
	}
	HRESULT hr = m_Tapi->SetApplicationPriority(
		applicationAsBSTR,
		dwMediaMode,
		bPriority
		);
	
	ThrowOnComError(
		hr,
		TEXT("%s(%d): CTapi3Device::SetApplicationPriorityForOneMediaMode(), ITTAPI::SetApplicationPriority() failed, error code:0x%08x"), 
		TEXT(__FILE__),
		__LINE__,
		hr
		);
}//void CTapi3Device::SetApplicationPriorityForOneMediaMode()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\tapitools\tapidevice\tapi2device.h ===
//Tapi2Device.h

#ifndef _TAPI2DEVICE_H
#define _TAPI2DEVICE_H

#include <tapi.h>

#include "TapiDevice.h"
#include "exception.h"
#include "Tapi2SmartPointer.h"




class CTapi2Device : public CTapiDevice
{

public:
	CTapi2Device(const DWORD dwId);
	~CTapi2Device(void);

	void HangUp(void);
	virtual void DirectHandoffCall(LPCTSTR szAppName);
	virtual bool MediaHandoffCall(void);
		
	void PassSomeDataTmpCode(void);
	void ReceiveSomeDataTmpCode(void);
	virtual HCALL GetTapi2CallHandle() {return m_hCall;};

//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////data members////////////////////////////////////////////////////////////
private:
	CAutoCloseLineAppHandle m_hLineApp;
	CAutoCloseLineHandle m_hLine;
	CAutoCloseHCALL m_hCall;
	
	DWORD m_dwNumDevs;
	DWORD m_dwAPIVersion;
	long m_lineAnswerID;


//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////Methods////////////////////////////////////////////////////////////

private:

/////////////////////////////////////////////////////////////////////////////////////
//helper functions

	virtual void TapiLogDetail(
		DWORD dwLevel,
		DWORD dwSeverity,
		const TCHAR * const szLogDescription,
		...
		) const;
	virtual void TapiLogError(
		DWORD dwSeverity,
		const TCHAR * const szLogDescription,
		...
		) const;

	virtual void CleanUp();

/////////////////////////////////////////////////////////////////////////////////////
//streaming
	
	virtual void PrepareForStreaming(const StreamingType streamingType,const StreamingDirection streaminDirection);
	virtual void SendCallerStream(void);
	virtual void SendAnswerStream(void);
	virtual void sendDTMF(LPCTSTR digitsToSend) const;
	virtual void receiveDTMF(
		LPTSTR DTMFresponse,
		DWORD dwNumberOfDigitsToCollect,
		const DWORD dwTimeout
		) const;

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//PASSTHROUGH 
	
	virtual void MoveToPassThroughMode(void);
	virtual void SetBearerModeToPASSTHROUGH(void);
	virtual void SetCommPortHandleFromCallHandle(void);

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//TAPI INIT

	//init functions
	void LineInitializeExWrapper(void);
	void LineOpenWrapper(const DWORD dwMediaMode, const DWORD dwPrivileges);
	void InitLineCallParams(LINECALLPARAMS *callParams,const DWORD dwMediaMode) const;
	LINEDEVCAPS LineGetDevCapsWrapper(void) const;
	

/////////////////////////////////////////////
//NOTIFICATION functions

	void lineGetRelevantMessage(
		LINEMESSAGE *lineMessage,
		const DWORD dwTimeOut,
		const long requestID
		) const;

/////////////////////////////////////////////
//LINE object functions
	virtual void OpenLineForOutgoingCall(const DWORD dwMedia);
	virtual void OpenLineForIncomingCall(const DWORD dwMedia);
	
/////////////////////////////////////////////
//CALL functions

	//call state functions
	DWORD GetCallState(void) const;
	bool IsCallActive(void) const;
	bool IsCallIdle(void) const;
	virtual SetNewCallHandleErrors SetNewCallHandle(const DWORD dwTimeOut);
	
	//call media mode
	virtual void VerifyValidMediaModeForOutgoingCall(const DWORD dwMediaMode) const;
	virtual void VerifyValidMediaModeForIncomingCall(const DWORD dwMediaMode) const;
	virtual DWORD GetCallSupportedMediaModes(void) const;
	virtual DWORD GetFriendlyMediaMode(void) const;
	virtual DWORD GetDeviceSpecificMediaMode(const DWORD dwMedia);
	virtual void SetCallMediaMode(const DWORD dwMedia);

	//call control functions:
	virtual void WaitForCallerConnectState(void);
	virtual void WaitForAnswererConnectState(void);
	virtual void CreateAndConnectCall(LPCTSTR szNum, const DWORD dwMedia);
	virtual void AnswerOfferingCall(void);

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Application priority
	void virtual SetApplicationPriorityForSpecificTapiDevice(const DWORD dwMedia,const DWORD dwPriority);
	void virtual SetApplicationPriorityForOneMediaMode(const DWORD dwMediaMode,const DWORD dwPriority);

	
};

#endif //#ifndef _TAPI2DEVICE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\tapitools\tapidevice\tapieventnotification.cpp ===
//TAPIEventNotification.cpp
#include "TAPIEventNotification.h"
#include "QueueEventItem.h"
#include "Tapi3.h"
#include "Tapi3Device.h"



CTAPIEventNotification::CTAPIEventNotification(CTapi3Device *tapi3Device) : 
	m_tapi3Object(tapi3Device),
	m_dwRefCount(0)
{
	_ASSERTE(m_tapi3Object);
}//CTAPIEventNotification::CTAPIEventNotification()


CTAPIEventNotification::~CTAPIEventNotification()
{
	m_dwRefCount = (DWORD)-1;
	m_tapi3Object = NULL;
}//CTAPIEventNotification::~CTAPIEventNotification()


HRESULT STDMETHODCALLTYPE CTAPIEventNotification::Event(
	TAPI_EVENT TapiEvent, 
	IDispatch __RPC_FAR *pEvent
	)
{
	_ASSERT(NULL != pEvent);
	
	//
	//queue the new event,
	//TapiEventItem construcator calls AddRef()
	//
	switch(TapiEvent)
	{
	case TE_CALLNOTIFICATION:
	case TE_CALLSTATE:
	case TE_DIGITEVENT:
	case TE_GENERATEEVENT:
		TapiEventItem * pEventToBeQueued = new TapiEventItem(TapiEvent,pEvent);
		if (!pEventToBeQueued)
		{
			m_tapi3Object->CleanUp();
			return E_OUTOFMEMORY;
		}
		m_tapi3Object->AddEventToQueue(pEventToBeQueued);
	}

	return S_OK;
}



HRESULT STDMETHODCALLTYPE CTAPIEventNotification::QueryInterface(REFIID iid, void **ppvObject)
{
    if (iid == IID_IUnknown)
    {
        m_dwRefCount++;
        *ppvObject = (IUnknown *)this;
        return S_OK;
    }
    else if (iid == IID_ITTAPIEventNotification)
    {
        m_dwRefCount++;
        *ppvObject = (ITTAPIEventNotification *)this;
        return S_OK;
    }

    *ppvObject = NULL;
    return E_NOINTERFACE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\tapitools\tapidevice\tapi3device.h ===
//tapi3device.h

#ifndef _TAPI3DEVICE_H
#define _TAPI3DEVICE_H

#include <tapi3.h>
#include "TAPIEventNotification.h"
#include "TapiDevice.h"
#include "exception.h"
#include "MtQueue.h"
#include "QueueEventItem.h"
#include <comdef.h>

_COM_SMARTPTR_TYPEDEF(ITCallInfo, IID_ITCallInfo);
_COM_SMARTPTR_TYPEDEF(ITCallStateEvent, IID_ITCallStateEvent);
_COM_SMARTPTR_TYPEDEF(ITBasicCallControl, IID_ITBasicCallControl);

_COM_SMARTPTR_TYPEDEF(ITTerminalSupport, IID_ITTerminalSupport);

_COM_SMARTPTR_TYPEDEF(ITMediaSupport, IID_ITMediaSupport);

_COM_SMARTPTR_TYPEDEF(IEnumAddress, IID_IEnumAddress);

_COM_SMARTPTR_TYPEDEF(ITAddress, IID_ITAddress);

_COM_SMARTPTR_TYPEDEF(ITLegacyCallMediaControl, IID_ITLegacyCallMediaControl);
_COM_SMARTPTR_TYPEDEF(ITLegacyAddressMediaControl, IID_ITLegacyAddressMediaControl);


_COM_SMARTPTR_TYPEDEF(ITDigitGenerationEvent, IID_ITDigitGenerationEvent);
_COM_SMARTPTR_TYPEDEF(ITDigitDetectionEvent, IID_ITDigitDetectionEvent);
_COM_SMARTPTR_TYPEDEF(ITCallNotificationEvent, IID_ITCallNotificationEvent);

_COM_SMARTPTR_TYPEDEF(ITTAPI, IID_ITTAPI);
_COM_SMARTPTR_TYPEDEF(ITTerminal, IID_ITTerminal);





class CTapi3Device : public CTapiDevice
{

	friend class CTAPIEventNotification;


public:
	CTapi3Device(const DWORD dwId);
	~CTapi3Device(void);

	virtual void HangUp(void);
	virtual void DirectHandoffCall(LPCTSTR szAppName);
	virtual bool MediaHandoffCall(void);

//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////data members////////////////////////////////////////////////////////////
private:
	ITTAPIPtr				m_Tapi;
	ITAddressPtr			m_pAddress;
	ITTerminalPtr			m_pTerminal;
	ITBasicCallControlPtr	m_pBasicCallControl;
	CTAPIEventNotification m_pDeviceEventCallbackObject;	//the object which the event() callback function will be called through
	mutable CMtQueue<TapiEventItem *> m_eventQueue;			//messages queue
	ULONG	m_lAdvise;		//used for unadvise
	long m_lRegisterIndex;	//used for ITTAPI::Unregister()

//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////Methods////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////
//helper functions
	
	virtual void TapiLogDetail(
		DWORD dwLevel,
		DWORD dwSeverity,
		const TCHAR * const szLogDescription,
		...
		) const;
	virtual void TapiLogError(
		DWORD dwSeverity,
		const TCHAR * const szLogDescription,
		...
		) const;
	static void ThrowOnComError(
		HRESULT hr,
		const TCHAR * const szExceptionDescription,
		...
		);

	virtual void CleanUp();


/////////////////////////////////////////////////////////////////////////////////////
//streaming
	
	TCHAR GetDigitFromDigitDetectionEvent(ITDigitDetectionEvent * const pDigitDetectionEvent) const;
	virtual void PrepareForStreaming(const StreamingType streamingType,const StreamingDirection streaminDirection);
	virtual void SendCallerStream(void);
	virtual void SendAnswerStream(void);
	virtual void sendDTMF(LPCTSTR digitsToSend) const;
	virtual void receiveDTMF(
		LPTSTR DTMFresponse,
		DWORD dwNumberOfDigitsToCollect,
		const DWORD dwTimeout
		) const;
	

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//PASSTHROUGH 
	
	virtual void MoveToPassThroughMode(void);
	virtual void SetBearerModeToPASSTHROUGH(void);
	virtual void SetCommPortHandleFromCallHandle(void);
	void SetCommPortHandleFromAddressHandle(void);


/////////////////////////////////////////////
//TAPI OBJECT functions
	
	void TapiCoCreateInstance(void);
	void InitializeTapi(void);
	void ShutdownTapi(void);
	
	
/////////////////////////////////////////////
//NOTIFICATION functions

	void ClearMessageQueue(void) const;
	TapiEventItem *GetEventItemFromQueue(const TAPI_EVENT teWantedEvent, const DWORD dwTimeOut) const;
	void DequeueCallStateMessage(const CALL_STATE csCallState);
	void AddEventToQueue(TapiEventItem *pEventToBeQueued);
	
	//events functions
	void RegisterTapiEventInterface(void);
	void UnRegisterTapiEventInterface(void);
	
	//notification register for media modes
	void RegisterNotificationForMediaMode(const DWORD dwMedia);
	void UnRegisterNotificationForMediaMode(void);
	
/////////////////////////////////////////////
//ADDRESS OBJECT functions
	
	void SetAddressProperty(const DWORD dwMedia);
	void SetAddressFromTapiID(void);
	void VerifyAddressState(void) const;
	void VerifyAddressSupportMediaMode(const DWORD dwMedia) const;
	void LogAddressName(void) const;
	void VerifyAddressFromCallInfo(ITCallInfo *pCallInfo) const;
	virtual void OpenLineForOutgoingCall(const DWORD dwMedia);
	virtual void OpenLineForIncomingCall(const DWORD dwMedia);
	
/////////////////////////////////////////////
//TERMINAL OBJECT functions
	
	void SetTerminalForOutgoingCall(const DWORD dwMedia);
	void SetTerminalForIncomingCall(const DWORD dwMedia);
	
/////////////////////////////////////////////
//CALL OBJECT functions
	
	virtual SetNewCallHandleErrors SetNewCallHandle(const DWORD dwTimeOut);
	ITCallInfo *GetCallInfoFromCallEvent(ITCallNotificationEvent *pCallNotificationEvent) const;
	ITCallInfo *GetCallInfoFromBasicCallControl(void) const;
	void CreateCallWrapper(LPCTSTR szNum,const DWORD dwMedia);
	void VerifyCallFromDigitGenerationEvent(ITDigitGenerationEvent* const pDigitGenerationEvent) const;
	void VerifyCallFromDigitDetectionEvent(ITDigitDetectionEvent* const pDigitDetectionEvent) const;
	void VerifyCallFromCallStateEvent(ITCallStateEvent* const pCallStateEvent) const;
	
	//call media mode
	virtual DWORD GetCallSupportedMediaModes(void) const;
	virtual void VerifyValidMediaModeForOutgoingCall(const DWORD dwMediaMode) const;
	virtual void VerifyValidMediaModeForIncomingCall(const DWORD dwMediaMode) const;
	virtual DWORD GetFriendlyMediaMode(void) const;
	virtual DWORD GetDeviceSpecificMediaMode(const DWORD dwMedia);
	virtual void SetCallMediaMode(const DWORD dwMedia);
	
	//call state functions
	bool IsCallActive(void) const;
	CALL_STATE GetCallState(ITCallInfo *pCallInfo = NULL) const;
	
	//call control functions:
	virtual void CreateAndConnectCall(LPCTSTR szNum, const DWORD dwMedia);
	virtual void WaitForCallerConnectState(void);
	virtual void WaitForAnswererConnectState(void);
	virtual void AnswerOfferingCall(void);
	void ConnectCall(void) const;	

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Application priority
	void virtual SetApplicationPriorityForSpecificTapiDevice(const DWORD dwMedia,const DWORD dwPriority);
	void virtual SetApplicationPriorityForOneMediaMode(const DWORD dwMediaMode,const DWORD dwPriority);

};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\test\src\tifftools\commandlinetiffcompare\main.c ===
#include "..\TiffTools\TiffTools.h"


// VBTESTIT

// this program is a re-write of TESTIT, intended to us