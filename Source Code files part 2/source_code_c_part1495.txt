********************
// Function prototypes
//**********************************************************************

//
//	DirectNet Core Message Handler
//
HRESULT	DN_CoreMessageHandler(PVOID const pv,
							  const DWORD dwMsgId,
							  const HANDLE hEndPt,
							  PBYTE const pData,
							  const DWORD dwDataSize,
							  PVOID const pvUserContext,
							  const HANDLE hProtocol,
							  const HRESULT hr);


//
//	Protocol Ref Counts
//
void DNProtocolAddRef(DIRECTNETOBJECT *const pdnObject);
void DNProtocolRelease(DIRECTNETOBJECT *const pdnObject);


//
//	DirectNet - Host Migration routines
//
HRESULT	DNFindNewHost(DIRECTNETOBJECT *const pdnObject,
					  DPNID *const pdpnidNewHost);

HRESULT	DNPerformHostMigration1(DIRECTNETOBJECT *const pdnObject,
								const DPNID dpnidOldHost);

HRESULT	DNPerformHostMigration2(DIRECTNETOBJECT *const pdnObject);

HRESULT	DNPerformHostMigration3(DIRECTNETOBJECT *const pdnObject,
								void *const pMsg);

HRESULT	DNProcessHostMigration1(DIRECTNETOBJECT *const pdnObject,
								void *const pvMsg);

HRESULT	DNProcessHostMigration2(DIRECTNETOBJECT *const pdnObject,
								void *const pMsg);

HRESULT	DNProcessHostMigration3(DIRECTNETOBJECT *const pdnObject,
								const DPNID dpnid);

HRESULT DNCompleteOutstandingOperations(DIRECTNETOBJECT *const pdnObject);

HRESULT DNCheckReceivedAllVersions(DIRECTNETOBJECT *const pdnObject);

HRESULT DNCleanUpNameTable(DIRECTNETOBJECT *const pdnObject);

HRESULT	DNSendHostMigrateCompleteMessage(DIRECTNETOBJECT *const pdnObject);


//
//	DirectNet - Protocol Interface (message handler callback functions)
//
HRESULT DNPIIndicateEnumQuery(void *const pvUserContext,
							  void *const pvEndPtContext,
							  const HANDLE hCommand,
							  void *const pvEnumQueryData,
							  const DWORD dwEnumQueryDataSize);

HRESULT DNPIIndicateEnumResponse(void *const pvUserContext,
								 const HANDLE hCommand,
								 void *const pvCommandContext,
								 void *const pvEnumResponseData,
								 const DWORD dwEnumResponseDataSize);

HRESULT DNPIIndicateConnect(void *const pvUserContext,
							void *const pvListenContext,
							const HANDLE hEndPt,
							void **const ppvEndPtContext);

HRESULT DNPIIndicateDisconnect(void *const pvUserContext,
							   void *const pvEndPtContext);

HRESULT DNPIIndicateConnectionTerminated(void *const pvUserContext,
										 void *const pvEndPtContext,
										 const HRESULT hr);

HRESULT DNPIIndicateReceive(void *const pvUserContext,
							void *const pvEndPtContext,
							void *const pvData,
							const DWORD dwDataSize,
							const HANDLE hBuffer,
							const DWORD dwFlags);

HRESULT DNPICompleteListen(void *const pvUserContext,
						   void **const ppvCommandContext,
						   const HRESULT hr,
						   const HANDLE hEndPt);

HRESULT DNPICompleteListenTerminate(void *const pvUserContext,
									void *const pvCommandContext,
									const HRESULT hr);

HRESULT DNPICompleteEnumQuery(void *const pvUserContext,
							  void *const pvCommandContext,
							  const HRESULT hr);

HRESULT DNPICompleteEnumResponse(void *const pvUserContext,
								 void *const pvCommandContext,
								 const HRESULT hr);

HRESULT DNPICompleteConnect(void *const pvUserContext,
							void *const pvCommandContext,
							const HRESULT hr,
							const HANDLE hEndPt,
							void **const ppvEndPtContext);

HRESULT DNPICompleteDisconnect(void *const pvUserContext,
							   void *const pvCommandContext,
							   const HRESULT hr);

HRESULT DNPICompleteSend(void *const pvUserContext,
						 void *const pvCommandContext,
						 const HRESULT hr);

HRESULT DNPIAddressInfoConnect(void *const pvUserContext,
							   void *const pvCommandContext,
							   const HRESULT hr,
							   IDirectPlay8Address *const pHostAddress,
							   IDirectPlay8Address *const pDeviceAddress );

HRESULT DNPIAddressInfoEnum(void *const pvUserContext,
							void *const pvCommandContext,
							const HRESULT hr,
							IDirectPlay8Address *const pHostAddress,
							IDirectPlay8Address *const pDeviceAddress );

HRESULT DNPIAddressInfoListen(void *const pvUserContext,
							  void *const pvCommandContext,
							  const HRESULT hr,
							  IDirectPlay8Address *const pDeviceAddress );

//**********************************************************************
// Class prototypes
//**********************************************************************


#endif	// __DNCORE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\enumhosts.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Enum.h
 *  Content:    Enumeration Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  04/10/00	mjn		Created
 *	04/17/00	mjn		Replaced BUFFERDESC with DPN_BUFFER_DESC
 *	07/10/00	mjn		Removed DNCompleteEnumQuery() and DNCompleteEnumResponse()
 *	07/11/00	mjn		Added fields to DN_ENUM_QUERY
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__ENUMHOSTS_H__
#define	__ENUMHOSTS_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	DN_ENUM_QUERY_WITH_APPLICATION_GUID			0x01
#define	DN_ENUM_QUERY_WITHOUT_APPLICATION_GUID		0x02

#define	DN_ENUM_BUFFERDESC_QUERY_SP_RESERVED		0
#define	DN_ENUM_BUFFERDESC_QUERY_DN_PAYLOAD			1
#define	DN_ENUM_BUFFERDESC_QUERY_USER_PAYLOAD		2
#define	DN_ENUM_BUFFERDESC_QUERY_COUNT				2

#define	DN_ENUM_BUFFERDESC_RESPONSE_SP_RESERVED		0
#define	DN_ENUM_BUFFERDESC_RESPONSE_DN_PAYLOAD		1
#define	DN_ENUM_BUFFERDESC_RESPONSE_USER_PAYLOAD	2
#define	DN_ENUM_BUFFERDESC_RESPONSE_COUNT			2

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

#pragma pack( push, 1 )
typedef	struct	_DN_ENUM_QUERY_PAYLOAD
{
	BYTE	QueryType;
	GUID	guidApplication;
} DN_ENUM_QUERY_PAYLOAD;

typedef	struct	_DN_ENUM_RESPONSE_PAYLOAD
{
//	BYTE	ResponseType;
//	GUID	guidInstance;
	DWORD	dwResponseOffset;
	DWORD	dwResponseSize;
} DN_ENUM_RESPONSE_PAYLOAD;
#pragma pack( pop )

typedef struct _DN_ENUM_QUERY
{
	DWORD					dwNumAdapters;
	DWORD					dwCurrentAdapter;
	DWORD					dwRetryCount;
	DWORD					dwRetryInterval;
	DWORD					dwTimeOut;
	DN_ENUM_QUERY_PAYLOAD	EnumQueryPayload;
	DPN_BUFFER_DESC			BufferDesc[3];
	DWORD					dwBufferCount;
} DN_ENUM_QUERY,*PDN_ENUM_QUERY;

typedef struct _DN_ENUM_RESPONSE
{
	DN_ENUM_RESPONSE_PAYLOAD	EnumResponsePayload;
	DPN_BUFFER_DESC				BufferDesc[3];
	void						*pvUserContext;
} DN_ENUM_RESPONSE,*PDN_ENUM_RESPONSE;

typedef struct _DIRECTNETOBJECT DIRECTNETOBJECT;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

void DNProcessEnumQuery(DIRECTNETOBJECT *const pdnObject,
						CAsyncOp *const pAsyncOp,
						const PROTOCOL_ENUM_DATA *const pEnumQueryData );

void DNProcessEnumResponse(DIRECTNETOBJECT *const pdnObject,
						   CAsyncOp *const pAsyncOp,
						   const PROTOCOL_ENUM_RESPONSE_DATA *const pEnumResponseData );

//**********************************************************************
// Class prototypes
//**********************************************************************


#endif	// __ENUMHOSTS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\enum_sp.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Enum_SP.cpp
 *  Content:    DNET service provider enumeration routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  07/28/99	mjn		Created
 *	01/05/00	mjn		Return DPNERR_NOINTERFACE if CoCreateInstance fails
 *	01/07/00	mjn		Moved Misc Functions to DNMisc.h
 *	01/11/00	mjn		Use CPackedBuffers instead of DN_ENUM_BUFFER_INFOs
 *	01/18/00	mjn		Converted EnumAdapters registry interface to use CRegistry
 *	01/24/00	mjn		Converted EnumSP registry interface to use CRegistry
 *	04/07/00	mjn		Fixed MemoryHeap corruption problem in DN_EnumSP
 *	04/08/00	mjn		Added DN_SPCrackEndPoint()
 *	05/01/00	mjn		Prevent unusable SPs from being enumerated.
 *	05/02/00	mjn		Better clean-up for DN_SPEnsureLoaded()
 *	05/03/00	mjn		Added DPNENUMSERVICEPROVIDERS_ALL flag
 *	05/23/00	mjn		Fixed cast from LPGUID to GUID*
 *	06/27/00	rmt		Added COM abstraction
 *	07/20/00	mjn		Return SP count from DN_EnumSP() even when buffer is too small
 *	07/29/00	mjn		Added fUseCachedCaps to DN_SPEnsureLoaded()
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *	08/16/00	mjn		Removed DN_SPCrackEndPoint()
 *	08/20/00	mjn		Added DN_SPInstantiate(), DN_SPLoad()
 *				mjn		Removed fUseCachedCaps from DN_SPEnsureLoaded()
 *	09/25/00	mjn		Handle SP initialization failure in DN_EnumAdapters()
 *	03/30/01	mjn		Changes to prevent multiple loading/unloading of SP's
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"



#undef DPF_MODNAME
#define DPF_MODNAME "DN_EnumSP"

HRESULT DN_EnumSP(DIRECTNETOBJECT *const pdnObject,
				  const DWORD dwFlags,
				  const GUID *const lpguidApplication,
				  DPN_SERVICE_PROVIDER_INFO *const pSPInfoBuffer,
				  DWORD *const pcbEnumData,
				  DWORD *const pcReturned)
{
	GUID	guid;
	DWORD	dwSizeRequired;
	DWORD	dwEntrySize;
	DWORD	dwEnumCount;
	DWORD	dwEnumIndex;
	DWORD	dwFriendlyNameLen;
	DWORD	dwGuidSize;
	DWORD	dwKeyLen;
	DWORD	dwMaxFriendlyNameLen;
	DWORD	dwMaxKeyLen;
	PWSTR	pwszFriendlyName;
	PWSTR	pwszKeyName;
	HRESULT	hResultCode = DPN_OK;
	CPackedBuffer				packedBuffer;
	DPN_SERVICE_PROVIDER_INFO	dnSpInfo;
	CRegistry	RegistryEntry;
	CRegistry	SubEntry;
	CServiceProvider	*pSP;

	DPFX(DPFPREP, 4,"Parameters: dwFlags [0x%lx], lpguidApplication [0x%p], pSPInfoBuffer [0x%p], pcbEnumData [0x%p], pcReturned [0x%p]",
		dwFlags,lpguidApplication,pSPInfoBuffer,pcbEnumData,pcReturned);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pcbEnumData != NULL);
	DNASSERT(pcReturned != NULL);

	pwszFriendlyName = NULL;
	pwszKeyName = NULL;
	pSP = NULL;

	dwSizeRequired = *pcbEnumData;
	packedBuffer.Initialize(static_cast<void*>(pSPInfoBuffer),dwSizeRequired);

	if (!RegistryEntry.Open(HKEY_LOCAL_MACHINE,DPN_REG_LOCAL_SP_SUBKEY,TRUE,FALSE))
	{
		DPFERR("RegistryEntry.Open() failed");
		hResultCode = DPNERR_GENERIC;
		goto Failure;
	}

	//
	//	Set up to enumerate
	//
	if (!RegistryEntry.GetMaxKeyLen(dwMaxKeyLen))
	{
		DPFERR("RegistryEntry.GetMaxKeyLen() failed");
		hResultCode = DPNERR_GENERIC;
		goto Failure;
	}
	dwMaxKeyLen++;	// Null terminator
	DPFX(DPFPREP, 5,"dwMaxKeyLen = %ld",dwMaxKeyLen);
	if ((pwszKeyName = static_cast<WCHAR*>(DNMalloc(dwMaxKeyLen * sizeof(WCHAR)))) == NULL)
	{
		DPFERR("DNMalloc() failed");
		hResultCode = DPNERR_OUTOFMEMORY;
		goto Failure;
	}
	dwMaxFriendlyNameLen = dwMaxKeyLen;
	if ((pwszFriendlyName = static_cast<WCHAR*>(DNMalloc(dwMaxFriendlyNameLen * sizeof(WCHAR)))) == NULL)	// Seed friendly name size
	{
		DPFERR("DNMalloc() failed");
		hResultCode = DPNERR_OUTOFMEMORY;
		goto Failure;
	}
	dwGuidSize = (GUID_STRING_LENGTH + 1) * sizeof(WCHAR);
	dwEnumIndex = 0;
	dwKeyLen = dwMaxKeyLen;
	dwEnumCount = 0;

	//
	//	Enumerate SP's !
	//
	while (RegistryEntry.EnumKeys(pwszKeyName,&dwKeyLen,dwEnumIndex))
	{
		dwEntrySize = 0;
		DPFX(DPFPREP, 5,"%ld - %S (%ld)",dwEnumIndex,pwszKeyName,dwKeyLen);
		if (!SubEntry.Open(RegistryEntry,pwszKeyName,TRUE,FALSE))
		{
			DPFX(DPFPREP, 0,"Couldn't open subentry.  Skipping [%S]", pwszKeyName);
			dwEnumIndex++;
			dwKeyLen = dwMaxKeyLen;
			continue;
		}

		//
		//	GUID
		//
		dwGuidSize = (DN_GUID_STR_LEN + 1) * sizeof(WCHAR);
		if (!SubEntry.ReadGUID(DPN_REG_KEYNAME_GUID,guid))
		{
			DPFX(DPFPREP, 0,"SubEntry.ReadGUID failed.  Skipping [%S]", pwszKeyName);
			SubEntry.Close();
			dwEnumIndex++;
			dwKeyLen = dwMaxKeyLen;
			continue;
		}

		//
		//	If the SP is not already loaded, try loading it to ensure that it's usable
		//
		if (!(dwFlags & DPNENUMSERVICEPROVIDERS_ALL))
		{
			DPFX(DPFPREP, 5,"Checking [%S]",pwszKeyName);

			if ((hResultCode = DN_SPEnsureLoaded(pdnObject,&guid,lpguidApplication,&pSP)) != DPN_OK)
			{
				DPFERR("Could not find or load SP");
				DisplayDNError(0,hResultCode);
				SubEntry.Close();
				dwEnumIndex++;
				dwKeyLen = dwMaxKeyLen;
				hResultCode = DPN_OK; // override return code
				continue;
			}
			pSP->Release();
			pSP = NULL;
		}

		//
		//	Friendly Name
		//
		if (!SubEntry.GetValueLength(DPN_REG_KEYNAME_FRIENDLY_NAME,&dwFriendlyNameLen))
		{
			DPFX(DPFPREP, 0,"Could not get FriendlyName length.  Skipping [%S]",pwszKeyName);
			SubEntry.Close();
			dwEnumIndex++;
			dwKeyLen = dwMaxKeyLen;
			continue;
		}
		if (dwFriendlyNameLen > dwMaxFriendlyNameLen)
		{
			// grow buffer (noting that the registry functions always return WCHAR) and try again
			DPFX(DPFPREP, 5,"Need to grow pwszFriendlyName from %ld to %ld",
					dwMaxFriendlyNameLen * sizeof(WCHAR),dwFriendlyNameLen * sizeof(WCHAR));
			if (pwszFriendlyName != NULL)
			{
				DNFree(pwszFriendlyName);
			}
			dwMaxFriendlyNameLen = dwFriendlyNameLen;
			if ((pwszFriendlyName = static_cast<WCHAR*>(DNMalloc(dwMaxFriendlyNameLen * sizeof( WCHAR )))) == NULL)
			{
				DPFERR("DNMalloc() failed");
				hResultCode = DPNERR_OUTOFMEMORY;
				goto Failure;
			}
		}
		if (!SubEntry.ReadString(DPN_REG_KEYNAME_FRIENDLY_NAME,pwszFriendlyName,&dwFriendlyNameLen))
		{
			DPFX(DPFPREP, 0,"Could not read friendly name.  Skipping [%S]",pwszKeyName);
			SubEntry.Close();
			dwEnumIndex++;
			dwKeyLen = dwMaxKeyLen;
			continue;
		}
		DPFX(DPFPREP, 5,"Friendly Name = %S (%ld WCHARs)",pwszFriendlyName,dwFriendlyNameLen);

		hResultCode = packedBuffer.AddToBack(pwszFriendlyName,dwFriendlyNameLen * sizeof(WCHAR));
		dnSpInfo.pwszName = static_cast<WCHAR*>(packedBuffer.GetTailAddress());
		memcpy(&dnSpInfo.guid,&guid,sizeof(GUID));
		dnSpInfo.dwFlags = 0;
		dnSpInfo.dwReserved = 0;
		dnSpInfo.pvReserved = NULL;
		hResultCode = packedBuffer.AddToFront(&dnSpInfo,sizeof(DPN_SERVICE_PROVIDER_INFO));

		dwEnumCount++;
		SubEntry.Close();
		dwEnumIndex++;
		dwKeyLen = dwMaxKeyLen;
	}

	RegistryEntry.Close();

	//
	//	Success ?
	//
	dwSizeRequired = packedBuffer.GetSizeRequired();
	if (dwSizeRequired > *pcbEnumData)
	{
		DPFX(DPFPREP, 5,"Buffer too small");
		*pcbEnumData = dwSizeRequired;
		*pcReturned = dwEnumCount;
		hResultCode = DPNERR_BUFFERTOOSMALL;
		goto Failure;
	}
	else
	{
		*pcReturned = dwEnumCount;
		hResultCode = DPN_OK;
	}

	DPFX(DPFPREP, 5,"*pcbEnumData [%ld], *pcReturned [%ld]",*pcbEnumData,*pcReturned);

	DNFree(pwszKeyName);
	pwszKeyName = NULL;
	DNFree(pwszFriendlyName);
	pwszFriendlyName = NULL;

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pwszKeyName)
	{
		DNFree(pwszKeyName);
		pwszKeyName = NULL;
	}
	if (pwszFriendlyName)
	{
		DNFree(pwszFriendlyName);
		pwszFriendlyName = NULL;
	}
	if (SubEntry.IsOpen())
	{
		SubEntry.Close();
	}
	if (RegistryEntry.IsOpen())
	{
		RegistryEntry.Close();
	}
	if (pSP)
	{
		pSP->Release();
		pSP = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_EnumAdapters"

HRESULT DN_EnumAdapters(DIRECTNETOBJECT *const pdnObject,
						const DWORD dwFlags,
						const GUID *const pguidSP,
						const GUID *const pguidApplication,
						DPN_SERVICE_PROVIDER_INFO *const pSPInfoBuffer,
						DWORD *const pcbEnumData,
						DWORD *const pcReturned)
{
	BOOL	bFound;
	GUID	guid;
	DWORD	dwEnumIndex;
	DWORD	dwKeyLen;
	DWORD	dwMaxKeyLen;
	LPWSTR	lpwszKeyName;
	HRESULT	hResultCode = DPN_OK;
	IDP8ServiceProvider		*pDNSP = NULL;
	SPENUMADAPTERSDATA		spEnumData;
	CRegistry	RegistryEntry;
	CRegistry	SubEntry;
	CServiceProvider	*pSP;

	DPFX(DPFPREP, 4,"Parameters: dwFlags [0x%lx], pguidSP [0x%p], pguidApplication [0x%p], pSPInfoBuffer [0x%p], pcbEnumData [0x%p], pcReturned [0x%p]",
		dwFlags,pguidSP,pguidApplication,pSPInfoBuffer,pcbEnumData,pcReturned);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pcbEnumData != NULL);
	DNASSERT(pcReturned != NULL);

	pSP = NULL;
	pDNSP = NULL;
	lpwszKeyName = NULL;

	if (!RegistryEntry.Open(HKEY_LOCAL_MACHINE,DPN_REG_LOCAL_SP_SUBKEY,TRUE,FALSE))
	{
		DPFERR("RegOpenKeyExA() failed");
		hResultCode = DPNERR_GENERIC;
		goto Failure;
	}

	//
	//	Set up to enumerate
	//
	if (!RegistryEntry.GetMaxKeyLen(dwMaxKeyLen))
	{
		DPFERR("RegQueryInfoKey() failed");
		hResultCode = DPNERR_GENERIC;
		goto Failure;
	}
	dwMaxKeyLen++;	// Null terminator
	DPFX(DPFPREP, 7,"dwMaxKeyLen = %ld",dwMaxKeyLen);
	if ((lpwszKeyName = static_cast<WCHAR*>(DNMalloc(dwMaxKeyLen*sizeof(WCHAR)))) == NULL)
	{
		DPFERR("DNMalloc() failed");
		hResultCode = DPNERR_OUTOFMEMORY;
		goto Failure;
	}
	dwEnumIndex = 0;
	dwKeyLen = dwMaxKeyLen;

	//
	//	Locate Service Provider
	//
	bFound = FALSE;
	while (RegistryEntry.EnumKeys(lpwszKeyName,&dwKeyLen,dwEnumIndex))
	{
		// For each service provider
		if (!SubEntry.Open(RegistryEntry,lpwszKeyName,TRUE,FALSE))
		{
			DPFERR("RegOpenKeyExA() failed");
			hResultCode = DPNERR_GENERIC;
			goto Failure;
		}

		// Get SP GUID
		if (!SubEntry.ReadGUID(DPN_REG_KEYNAME_GUID,guid))
		{
			DPFERR("Could not read GUID");
			SubEntry.Close();
			dwEnumIndex++;
			dwKeyLen = dwMaxKeyLen;
			continue;
		}

		// Check SP GUID
		if (guid == *pguidSP)
		{
			bFound = TRUE;
			break;
		}
		SubEntry.Close();
		dwKeyLen = dwMaxKeyLen;
		dwEnumIndex++;
	}

	if (!bFound)
	{
		hResultCode = DPNERR_DOESNOTEXIST;
		goto Failure;
	}

	//
	//	Ensure SP is loaded
	//
	if ((hResultCode = DN_SPEnsureLoaded(pdnObject,pguidSP,pguidApplication,&pSP)) != DPN_OK)
	{
		DPFX(DPFPREP,1,"Could not find or load SP");
		DisplayDNError(1,hResultCode);
		goto Failure;
	}

	//
	//	Get SP interface
	//
	if ((hResultCode = pSP->GetInterfaceRef(&pDNSP)) != DPN_OK)
	{
		DPFERR("Could not get SP interface");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	pSP->Release();
	pSP = NULL;

	spEnumData.pAdapterData = pSPInfoBuffer;
	spEnumData.dwAdapterDataSize = *pcbEnumData;
	spEnumData.dwAdapterCount = *pcReturned;
	spEnumData.dwFlags = 0;

	hResultCode = pDNSP->lpVtbl->EnumAdapters(pDNSP,&spEnumData);
	*pcbEnumData = spEnumData.dwAdapterDataSize;
	*pcReturned = spEnumData.dwAdapterCount;

	pDNSP->lpVtbl->Release(pDNSP);
	pDNSP = NULL;

	if (lpwszKeyName)
	{
		DNFree(lpwszKeyName);
		lpwszKeyName = NULL;
	}

	DPFX(DPFPREP, 5,"*pcbEnumData [%ld], *pcReturned [%ld]",*pcbEnumData,*pcReturned);

Exit:
	DNASSERT( pSP == NULL );
	DNASSERT( pDNSP == NULL );
	DNASSERT( lpwszKeyName == NULL );

	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pSP)
	{
		pSP->Release();
		pSP = NULL;
	}
	if (pDNSP)
	{
		pDNSP->lpVtbl->Release(pDNSP);
		pDNSP = NULL;
	}
	if (lpwszKeyName)
	{
		DNFree(lpwszKeyName);
		lpwszKeyName = NULL;
	}
	goto Exit;
}


//	DN_SPRelease
//
//	Release an attached ServiceProvider

#undef DPF_MODNAME
#define DPF_MODNAME "DN_SPRelease"

void DN_SPRelease(DIRECTNETOBJECT *const pdnObject,
					 const GUID *const pguid)
{
	HRESULT				hResultCode;
	CBilink				*pBilink;
	CServiceProvider	*pSP;

	DPFX(DPFPREP, 6,"Parameters: pguid [0x%p]",pguid);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pguid != NULL);

	DNEnterCriticalSection(&pdnObject->csServiceProviders);

	hResultCode = DPNERR_DOESNOTEXIST;
	pBilink = pdnObject->m_bilinkServiceProviders.GetNext();
	while (pBilink != &pdnObject->m_bilinkServiceProviders)
	{
		pSP = CONTAINING_OBJECT(pBilink,CServiceProvider,m_bilinkServiceProviders);
		if (pSP->CheckGUID(pguid))
		{
			pSP->m_bilinkServiceProviders.RemoveFromList();
			pSP->Release();
			hResultCode = DPN_OK;
			break;
		}
		pBilink = pBilink->GetNext();
	}

	if (hResultCode != DPN_OK)
	{
		DNASSERT(FALSE);
	}

	DNLeaveCriticalSection(&pdnObject->csServiceProviders);

	DPFX(DPFPREP, 6,"Returning");
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_SPReleaseAll"

void DN_SPReleaseAll(DIRECTNETOBJECT *const pdnObject)
{
	CBilink				*pBilink;
	CServiceProvider	*pSP;

	DPFX(DPFPREP, 6,"Parameters: (none)");

	DNASSERT(pdnObject != NULL);

	DNEnterCriticalSection(&pdnObject->csServiceProviders);

	pBilink = pdnObject->m_bilinkServiceProviders.GetNext();
	while (pBilink != &pdnObject->m_bilinkServiceProviders)
	{
		pSP = CONTAINING_OBJECT(pBilink,CServiceProvider,m_bilinkServiceProviders);
		pBilink = pBilink->GetNext();
		pSP->m_bilinkServiceProviders.RemoveFromList();
		pSP->Release();
		pSP = NULL;
	}

	DNLeaveCriticalSection(&pdnObject->csServiceProviders);

	DPFX(DPFPREP, 6,"Returning");
}



//	DN_SPFindEntry
//
//	Find a connected SP and AddRef it if it exists

#undef DPF_MODNAME
#define DPF_MODNAME "DN_SPFindEntry"

HRESULT DN_SPFindEntry(DIRECTNETOBJECT *const pdnObject,
					   const GUID *const pguid,
					   CServiceProvider **const ppSP)
{
	HRESULT				hResultCode;
	CBilink				*pBilink;
	CServiceProvider	*pSP;

	DPFX(DPFPREP, 6,"Parameters: pguid [0x%p], ppSP [0x%p]",pguid,ppSP);

	DNEnterCriticalSection(&pdnObject->csServiceProviders);

	hResultCode = DPNERR_DOESNOTEXIST;
	pBilink = pdnObject->m_bilinkServiceProviders.GetNext();
	while (pBilink != &pdnObject->m_bilinkServiceProviders)
	{
		pSP = CONTAINING_OBJECT(pBilink,CServiceProvider,m_bilinkServiceProviders);
		if (pSP->CheckGUID(pguid))
		{
			pSP->AddRef();
			*ppSP = pSP;
			hResultCode = DPN_OK;
			break;
		}
		pBilink = pBilink->GetNext();
	}

	DNLeaveCriticalSection(&pdnObject->csServiceProviders);

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//	DN_SPInstantiate
//
//	Instantiate an SP, regardless of whether it's loaded or not

#undef DPF_MODNAME
#define DPF_MODNAME "DN_SPInstantiate"

HRESULT DN_SPInstantiate(DIRECTNETOBJECT *const pdnObject,
						 const GUID *const pguid,
						 const GUID *const pguidApplication,
						 CServiceProvider **const ppSP)
{
	HRESULT		hResultCode;
	CServiceProvider	*pSP;

	DPFX(DPFPREP, 6,"Parameters: pguid [0x%p], pguidApplication [0x%p], ppSP [0x%p]",pguid,pguidApplication,ppSP);

	pSP = NULL;

	//
	//	Create and initialize SP
	//
	pSP = new CServiceProvider;
	if (pSP == NULL)
	{
		DPFERR("Could not create SP");
		hResultCode = DPNERR_OUTOFMEMORY;
		goto Failure;
	}
	if ((hResultCode = pSP->Initialize(pdnObject,pguid,pguidApplication)) != DPN_OK)
	{
		DPFX(DPFPREP,1,"Could not initialize SP");
		DisplayDNError(1,hResultCode);
		goto Failure;
	}
	

	if (ppSP)
	{
		pSP->AddRef();
		*ppSP = pSP;
	}

	pSP->Release();
	pSP = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pSP)
	{
		pSP->Release();
		pSP = NULL;
	}
	goto Exit;
}


//	DN_SPLoad
//
//	Load an SP, and set caps

#undef DPF_MODNAME
#define DPF_MODNAME "DN_SPLoad"

HRESULT DN_SPLoad(DIRECTNETOBJECT *const pdnObject,
				  const GUID *const pguid,
				  const GUID *const pguidApplication,
				  CServiceProvider **const ppSP)
{
	HRESULT		hResultCode;
	DPN_SP_CAPS	*pCaps;
	CBilink		*pBilink;
	CServiceProvider	*pSP;

	DPFX(DPFPREP, 6,"Parameters: pguid [0x%p], pguidApplication [0x%p], ppSP [0x%p]",pguid,pguidApplication,ppSP);

	pSP = NULL;
	pCaps = NULL;

	//
	//	Instantiate SP
	//
	if ((hResultCode = DN_SPInstantiate(pdnObject,pguid,pguidApplication,&pSP)) != DPN_OK)
	{
		DPFX(DPFPREP,1,"Could not instantiate SP");
		DisplayDNError(1,hResultCode);
		goto Failure;
	}

	DNASSERT(pSP != NULL);

	//
	//	Keep this loaded on the DirectNet object.  We will also check for duplicates.
	//
	DNEnterCriticalSection(&pdnObject->csServiceProviders);

	pBilink = pdnObject->m_bilinkServiceProviders.GetNext();
	while (pBilink != &pdnObject->m_bilinkServiceProviders)
	{
		if ((CONTAINING_OBJECT(pBilink,CServiceProvider,m_bilinkServiceProviders))->CheckGUID(pguid))
		{
			DNLeaveCriticalSection(&pdnObject->csServiceProviders);
			DPFERR("SP is already loaded!");
			hResultCode = DPNERR_ALREADYINITIALIZED;
			goto Failure;
		}
		pBilink = pBilink->GetNext();
	}

	//
	//	Add the SP to the SP list off the DirectNet object and add a reference for it
	//
	pSP->AddRef();
	pSP->m_bilinkServiceProviders.InsertBefore(&pdnObject->m_bilinkServiceProviders);

	DNLeaveCriticalSection(&pdnObject->csServiceProviders);

	if (ppSP)
	{
		pSP->AddRef();
		*ppSP = pSP;
	}

	pSP->Release();
	pSP = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pSP)
	{
		pSP->Release();
		pSP = NULL;
	}
	goto Exit;
}


//	DN_SPEnsureLoaded
//
//	Ensure that an SP is loaded.  If the SP is not loaded,
//	it will be instantiated, and connected to the protocol.
//	If it is loaded, its RefCount will be increased.

#undef DPF_MODNAME
#define DPF_MODNAME "DN_SPEnsureLoaded"

HRESULT DN_SPEnsureLoaded(DIRECTNETOBJECT *const pdnObject,
						  const GUID *const pguid,
						  const GUID *const pguidApplication,
						  CServiceProvider **const ppSP)
{
	HRESULT				hResultCode;
	CServiceProvider	*pSP;

	DPFX(DPFPREP, 6,"Parameters: pguid [0x%p], pguidApplication [0x%p], ppSP [0x%p]",pguid,pguidApplication,ppSP);

	pSP = NULL;

	//
	//	Try to find the SP
	//
	if ((hResultCode = DN_SPFindEntry(pdnObject,pguid,&pSP)) == DPNERR_DOESNOTEXIST)
	{
		//
		//	Instantiate SP and add to Protocol
		//
		if ((hResultCode = DN_SPLoad(pdnObject,pguid,pguidApplication,&pSP)) != DPN_OK)
		{
			DPFX(DPFPREP,1,"Could not load SP");
			DisplayDNError(1,hResultCode);
			goto Failure;
		}
	}
	else
	{
		if (hResultCode != DPN_OK)
		{
			DPFERR("Could not find SP");
			DisplayDNError(0,hResultCode);
			goto Failure;
		}
	}

	DNASSERT(pSP != NULL);

	if (ppSP != NULL)
	{
		pSP->AddRef();
		*ppSP = pSP;
	}

	pSP->Release();
	pSP = NULL;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pSP)
	{
		pSP->Release();
		pSP = NULL;
	}
	goto Exit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\groupcon.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       GroupCon.cpp
 *  Content:    Group Connection object routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/02/00	mjn		Created
 *	04/18/00	mjn		CConnection tracks connection status better
 *	05/05/00	mjn		Added GetConnectionRef()
 *	08/15/00	mjn		Added SetGroup()
 *				mjn		Fixed Release() to take locks and cleanup m_pGroup
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


void CGroupConnection::ReturnSelfToPool( void )
{
	m_pdnObject->m_pFPOOLGroupConnection->Release( this );
}

#undef DPF_MODNAME
#define DPF_MODNAME "CGroupConnection::Release"

void CGroupConnection::Release(void)
{
	LONG	lRefCount;

	DNASSERT(m_lRefCount > 0);
	lRefCount = InterlockedDecrement(const_cast<LONG*>(&m_lRefCount));
	if (lRefCount == 0)
	{
		if (m_pGroup)
		{
			m_pGroup->Lock();
			RemoveFromConnectionList();
			m_pGroup->Unlock();

			m_pGroup->Release();
			m_pGroup = NULL;
		}
		if (m_pConnection)
		{
			m_pConnection->Release();
			m_pConnection = NULL;
		}
		m_dwFlags = 0;
		m_lRefCount = 0;
		ReturnSelfToPool();
	}
}


void CGroupConnection::SetConnection( CConnection *const pConnection )
{
	if (pConnection)
	{
		pConnection->Lock();
		if (pConnection->IsConnected())
		{
			pConnection->AddRef();
			m_pConnection = pConnection;
		}
		pConnection->Unlock();
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CGroupConnection::GetConnectionRef"

HRESULT	CGroupConnection::GetConnectionRef( CConnection **const ppConnection )
{
	HRESULT		hResultCode;

	DNASSERT( ppConnection != NULL);

	Lock();
	if ( m_pConnection && !m_pConnection->IsInvalid())
	{
		m_pConnection->AddRef();
		*ppConnection = m_pConnection;
		hResultCode = DPN_OK;
	}
	else
	{
		hResultCode = DPNERR_NOCONNECTION;
	}
	Unlock();

	return( hResultCode );
}


void CGroupConnection::SetGroup( CNameTableEntry *const pGroup )
{
	if (pGroup)
	{
		pGroup->AddRef();
	}
	m_pGroup = pGroup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\globals.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Globals.cpp
 *  Content:    Definition of global variables.
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  07/21/99	mjn		Created
 *	04/13/00	mjn		Added g_ProtocolVTBL
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


//
//	Global Variables
//

DWORD	GdwHLocks = 0;
DWORD	GdwHObjects = 0;


DN_PROTOCOL_INTERFACE_VTBL	g_ProtocolVTBL =
{
	DNPIIndicateEnumQuery,
	DNPIIndicateEnumResponse,
	DNPIIndicateConnect,
	DNPIIndicateDisconnect,
	DNPIIndicateConnectionTerminated,
	DNPIIndicateReceive,
	DNPICompleteListen,
	DNPICompleteListenTerminate,
	DNPICompleteEnumQuery,
	DNPICompleteEnumResponse,
	DNPICompleteConnect,
	DNPICompleteDisconnect,
	DNPICompleteSend,
	DNPIAddressInfoConnect,
	DNPIAddressInfoEnum,
	DNPIAddressInfoListen
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\groupmem.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       GroupMem.h
 *  Content:    Group Membership Object Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *	03/03/00	mjn		Created
 *	08/05/99	mjn		Modified SetMembership to perform duplicate check and get NameTable version internally 
 *	09/17/99	mjn		Added GROUP_MEMBER_FLAG_NEED_TO_ADD,GROUP_MEMBER_FLAG_NEED_TO_REMOVE
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__GROUPMEM_H__
#define	__GROUPMEM_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	GROUP_MEMBER_FLAG_VALID				0x0001
#define	GROUP_MEMBER_FLAG_AVAILABLE			0x0002
#define	GROUP_MEMBER_FLAG_NEED_TO_ADD		0x0004
#define	GROUP_MEMBER_FLAG_NEED_TO_REMOVE	0x0008

//**********************************************************************
// Macro definitions
//**********************************************************************

#ifndef	OFFSETOF
#define OFFSETOF(s,m)				( ( INT_PTR ) ( ( PVOID ) &( ( (s*) 0 )->m ) ) )
#endif

#ifndef	CONTAINING_OBJECT
#define	CONTAINING_OBJECT(b,t,m)	(reinterpret_cast<t*>(&reinterpret_cast<BYTE*>(b)[-OFFSETOF(t,m)]))
#endif

//**********************************************************************
// Structure definitions
//**********************************************************************

template< class CGroupMember > class CLockedContextClassFixedPool;

class CPackedBuffer;
class CGroupConnection;
class CNameTableEntry;

typedef struct _DIRECTNETOBJECT DIRECTNETOBJECT;

//
//	Used to pass NameTable group membership
//
typedef struct _DN_NAMETABLE_MEMBERSHIP_INFO
{
	DPNID	dpnidPlayer;
	DPNID	dpnidGroup;
	DWORD	dwVersion;
	DWORD	dwVersionNotUsed;
} DN_NAMETABLE_MEMBERSHIP_INFO, *PDN_NAMETABLE_MEMBERSHIP_INFO;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************

// class for Group Members

class CGroupMember
{
public:
	CGroupMember()					// Constructor
		{
			m_Sig[0] = 'G';
			m_Sig[1] = 'M';
			m_Sig[2] = 'E';
			m_Sig[3] = 'M';
		};

	~CGroupMember() { };			// Destructor

	BOOL FPMAlloc( void *const pvContext )
		{
			if (!DNInitializeCriticalSection(&m_cs))
			{
				return(FALSE);
			}
			DebugSetCriticalSectionRecursionCount(&m_cs,0);

			m_pdnObject = static_cast<DIRECTNETOBJECT*>(pvContext);

			return(TRUE);
		};

	BOOL FPMInitialize( void *const pvContext )
		{
			m_dwFlags = 0;
			m_lRefCount = 1;
			m_pGroup = NULL;
			m_pPlayer = NULL;
			m_bilinkPlayers.Initialize();
			m_bilinkGroups.Initialize();
			m_pGroupConnection = NULL;

			return(TRUE);
		};

	void FPMRelease( void *const pvContext )
		{
		};

	void FPMDealloc( void *const pvContext )
		{
			DNDeleteCriticalSection(&m_cs);
		};

	void MakeValid( void )
		{
			m_dwFlags |= GROUP_MEMBER_FLAG_VALID;
		};

	void MakeInvalid( void )
		{
			m_dwFlags &= (~GROUP_MEMBER_FLAG_VALID);
		};

	BOOL IsValid( void )
		{
			if (m_dwFlags & GROUP_MEMBER_FLAG_VALID)
				return(TRUE);

			return(FALSE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CGroupMember::MakeAvailable"
	void MakeAvailable( void )
		{
			DNASSERT(m_pGroup != NULL);
			DNASSERT(m_pPlayer != NULL);

			m_dwFlags |= GROUP_MEMBER_FLAG_AVAILABLE;
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CGroupMember::MakeUnavailable"
	void MakeUnavailable( void )
		{
			m_dwFlags &= (~GROUP_MEMBER_FLAG_AVAILABLE);
		};

	BOOL IsAvailable( void )
		{
			if (m_dwFlags & GROUP_MEMBER_FLAG_AVAILABLE)
				return(TRUE);

			return(FALSE);
		};

	void SetNeedToAdd( void )
		{
			m_dwFlags |= GROUP_MEMBER_FLAG_NEED_TO_ADD;
		};

	void ClearNeedToAdd( void )
		{
			m_dwFlags &= (~GROUP_MEMBER_FLAG_NEED_TO_ADD);
		};

	BOOL IsNeedToAdd( void )
		{
			if (m_dwFlags & GROUP_MEMBER_FLAG_NEED_TO_ADD)
			{
				return( TRUE );
			}
			return( FALSE );
		};

	void SetNeedToRemove( void )
		{
			m_dwFlags |= GROUP_MEMBER_FLAG_NEED_TO_REMOVE;
		};

	void ClearNeedToRemove( void )
		{
			m_dwFlags &= (~GROUP_MEMBER_FLAG_NEED_TO_REMOVE);
		};

	BOOL IsNeedToRemove( void )
		{
			if (m_dwFlags & GROUP_MEMBER_FLAG_NEED_TO_REMOVE)
			{
				return( TRUE );
			}
			return( FALSE );
		};

	void AddRef( void )
		{
			InterlockedIncrement(&m_lRefCount);
		};

	void Release( void );

	void ReturnSelfToPool( void );

	void Lock( void )
		{
			DNEnterCriticalSection(&m_cs);
		};

	void Unlock( void )
		{
			DNLeaveCriticalSection(&m_cs);
		};

	void CGroupMember::RemoveMembership( DWORD *const pdnVersion );

	void SetVersion( const DWORD dwVersion )
		{
			m_dwVersion = dwVersion;
		};

	DWORD GetVersion( void )
		{
			return(m_dwVersion);
		};

	HRESULT CGroupMember::SetMembership(CNameTableEntry *const pGroup,
										CNameTableEntry *const pPlayer,
										DWORD *const pdwVersion);

	CNameTableEntry *GetGroup( void )
		{
			return(m_pGroup);
		};

	CNameTableEntry *GetPlayer( void )
		{
			return(m_pPlayer);
		};

	void SetGroupConnection( CGroupConnection *const pGroupConnection );

	CGroupConnection *GetGroupConnection( void )
		{
			return(m_pGroupConnection);
		};

	HRESULT	CGroupMember::PackMembershipInfo(CPackedBuffer *const pPackedBuffer);

	CBilink				m_bilinkPlayers;	// Players in this group
	CBilink				m_bilinkGroups;		// Groups this player belongs to

private:
	BYTE				m_Sig[4];
	DWORD				m_dwFlags;
	LONG				m_lRefCount;

	CNameTableEntry		*m_pPlayer;
	CNameTableEntry		*m_pGroup;
	CGroupConnection	*m_pGroupConnection;

	DWORD				m_dwVersion;
	DWORD				m_dwVersionNotUsed;

	DIRECTNETOBJECT		*m_pdnObject;

	DNCRITICAL_SECTION	m_cs;
};

#undef DPF_MODNAME

#endif	// __GROUPMEM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\enum_sp.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Enum_SP.h
 *  Content:    DirectNet SP/Adapter Enumeration
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *	01/15/00	mjn		Created
 *	04/08/00	mjn		Added DN_SPCrackEndPoint()
 *	05/01/00	mjn		Prevent unusable SPs from being enumerated.
 *	07/29/00	mjn		Added fUseCachedCaps to DN_SPEnsureLoaded()
 *	08/16/00	mjn		Removed DN_SPCrackEndPoint()
 *	08/20/00	mjn		Added DN_SPInstantiate(), DN_SPLoad()
 *				mjn		Removed fUseCachedCaps from DN_SPEnsureLoaded()
 *	03/30/01	mjn		Changes to prevent multiple loading/unloading of SP's
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__ENUM_SP_H__
#define	__ENUM_SP_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

#ifndef	GUID_STRING_LENGTH
#define	GUID_STRING_LENGTH	((sizeof(GUID) * 2) + 2 + 4)
#endif
//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

class CServiceProvider;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//
//	Enumeration
//
HRESULT DN_EnumSP(DIRECTNETOBJECT *const pdnObject,
				  const DWORD dwFlags,
				  const GUID *const lpguidApplication,
				  DPN_SERVICE_PROVIDER_INFO *const pSPInfoBuffer,
				  DWORD *const pcbEnumData,
				  DWORD *const pcReturned);

HRESULT DN_EnumAdapters(DIRECTNETOBJECT *const pdnObject,
						const DWORD dwFlags,
						const GUID *const lpguidSP,
						const GUID *const lpguidApplication,
						DPN_SERVICE_PROVIDER_INFO *const pSPInfoBuffer,
						DWORD *const pcbEnumData,
						DWORD *const pcReturned);

void DN_SPRelease(DIRECTNETOBJECT *const pdnObject,
					 const GUID *const pguid);

void DN_SPReleaseAll(DIRECTNETOBJECT *const pdnObject);

HRESULT DN_SPFindEntry(DIRECTNETOBJECT *const pdnObject,
					   const GUID *const pguidSP,
					   CServiceProvider **const ppSP);

HRESULT DN_SPInstantiate(DIRECTNETOBJECT *const pdnObject,
						 const GUID *const pguid,
						 const GUID *const pguidApplication,
						 CServiceProvider **const ppSP);

HRESULT DN_SPLoad(DIRECTNETOBJECT *const pdnObject,
				  const GUID *const pguid,
				  const GUID *const pguidApplication,
				  CServiceProvider **const ppSP);

HRESULT DN_SPEnsureLoaded(DIRECTNETOBJECT *const pdnObject,
						  const GUID *const pguid,
						  const GUID *const pguidApplication,
						  CServiceProvider **const ppSP);


#endif	// __ENUM_SP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\groupmem.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       GroupMem.cpp
 *  Content:    Group Membership object routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *	03/03/00	mjn		Created
 *	08/05/99	mjn		Modified SetMembership to perform duplicate check and get NameTable version internally
 *	08/15/00	mjn		Allow NULL pGroupConnection in SetGroupConnection()
 *	09/17/00	mjn		Remove locks from SetMembership()
 *	09/26/00	mjn		Assume NameTable locks are taken for AddMembership() and RemoveMembership()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


void CGroupMember::ReturnSelfToPool( void )
{
	m_pdnObject->m_pFPOOLGroupMember->Release( this );
};


#undef DPF_MODNAME
#define DPF_MODNAME "CGroupMember::Release"
void CGroupMember::Release( void )
{
	LONG	lRefCount;

	lRefCount = InterlockedDecrement(&m_lRefCount);

	if (lRefCount == 0)
	{
		DNASSERT(!(m_dwFlags & GROUP_MEMBER_FLAG_AVAILABLE));

		if (m_pGroup != NULL)
		{
			m_pGroup->Release();
			m_pGroup = NULL;
		}
		if (m_pPlayer != NULL)
		{
			m_pPlayer->Release();
			m_pPlayer = NULL;
		}
		if (m_pGroupConnection != NULL)
		{
			m_pGroupConnection->Release();
			m_pGroupConnection = NULL;
		}

		ReturnSelfToPool();
	}
}


#undef DPF_MODNAME
#define DPF_MODNAME "CGroupMember::SetMembership"

HRESULT CGroupMember::SetMembership(CNameTableEntry *const pGroup,
									CNameTableEntry *const pPlayer,
									DWORD *const pdwVersion)
{
	HRESULT			hResultCode;
	CBilink			*pBilink;
	CGroupMember	*pGroupMember;

	DNASSERT(pGroup != NULL);
	DNASSERT(pPlayer != NULL);

	//
	//	THIS ASSUMES THAT LOCKS FOR NameTable,pGroup,pPlayer and 'this' are taken (in that order) !
	//

	//
	//	Scan group list to ensure this player is not a member already
	//
	pBilink = pGroup->m_bilinkMembership.GetNext();
	while (pBilink != &pGroup->m_bilinkMembership)
	{
		pGroupMember = CONTAINING_OBJECT(pBilink,CGroupMember,m_bilinkPlayers);
		if (pGroupMember->GetPlayer() == pPlayer)
		{
			hResultCode = DPNERR_PLAYERALREADYINGROUP;
			goto Failure;
		}
		pBilink = pBilink->GetNext();
	}

	//
	//	Version stuff
	//
	if (pdwVersion)
	{
		if (*pdwVersion)
		{
			DPFX(DPFPREP, 7,"Version already specified");
			m_dwVersion = *pdwVersion;
			m_pdnObject->NameTable.SetVersion(*pdwVersion);
		}
		else
		{
			DPFX(DPFPREP, 7,"New version required");
			m_pdnObject->NameTable.GetNewVersion( &m_dwVersion );
			*pdwVersion = m_dwVersion;
		}
	}
	else
	{
		m_dwVersion = 0;
	}

	//
	//	Update
	//
	AddRef();
	pGroup->AddRef();
	m_pGroup = pGroup;

	AddRef();
	pPlayer->AddRef();
	m_pPlayer = pPlayer;

	m_bilinkGroups.InsertBefore(&pPlayer->m_bilinkMembership);
	m_bilinkPlayers.InsertBefore(&pGroup->m_bilinkMembership);

	if (m_pGroupConnection)
	{
		m_pGroupConnection->AddToConnectionList( &pGroup->m_bilinkConnections );
	}

	hResultCode = DPN_OK;

Exit:
	return(hResultCode);

Failure:
	goto Exit;
}


void CGroupMember::RemoveMembership( DWORD *const pdnVersion )
{
	//
	//	THIS ASSUMES THAT LOCKS FOR NameTable,pGroup,pPlayer and 'this' are taken (in that order) !
	//	Since there will be several Release()'d items, someone should keep a reference on them
	//		so that they don't get free'd with all of the locks taken !
	//

	m_pGroup->Release();
	m_pGroup = NULL;
	Release();

	m_pPlayer->Release();
	m_pPlayer = NULL;
	Release();

	m_bilinkGroups.RemoveFromList();
	m_bilinkPlayers.RemoveFromList();

	if (m_pGroupConnection)
	{
		m_pGroupConnection->RemoveFromConnectionList();
	}

	if (pdnVersion)
	{
		if (*pdnVersion != 0)
		{
			m_pdnObject->NameTable.SetVersion( *pdnVersion );
		}
		else
		{
			m_pdnObject->NameTable.GetNewVersion( pdnVersion );
		}
	}
};


void CGroupMember::SetGroupConnection( CGroupConnection *const pGroupConnection )
{
	if (pGroupConnection)
	{
		pGroupConnection->AddRef();
	}
	m_pGroupConnection = pGroupConnection;
}


HRESULT	CGroupMember::PackMembershipInfo(CPackedBuffer *const pPackedBuffer)
{
	HRESULT		hResultCode;
	DN_NAMETABLE_MEMBERSHIP_INFO	*pdnMembershipInfo;

	pdnMembershipInfo = static_cast<DN_NAMETABLE_MEMBERSHIP_INFO*>(pPackedBuffer->GetHeadAddress());
	if ((hResultCode = pPackedBuffer->AddToFront(NULL,sizeof(DN_NAMETABLE_MEMBERSHIP_INFO))) == DPN_OK)
	{
		pdnMembershipInfo->dpnidGroup = m_pGroup->GetDPNID();
		pdnMembershipInfo->dpnidPlayer = m_pPlayer->GetDPNID();
		pdnMembershipInfo->dwVersion = m_dwVersion;
		pdnMembershipInfo->dwVersionNotUsed = 0;
	}

	return(hResultCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\groupcon.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       GroupCon.h
 *  Content:    Group Connection Object Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/02/00	mjn		Created
 *	05/05/00	mjn		Added GetConnectionRef()
 *	08/15/00	mjn		Added m_pGroup,SetGroup(),GetGroup()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__GROUPCON_H__
#define	__GROUPCON_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	VALID		0x0001

//**********************************************************************
// Macro definitions
//**********************************************************************

#ifndef	OFFSETOF
#define OFFSETOF(s,m)				( ( INT_PTR ) ( ( PVOID ) &( ( (s*) 0 )->m ) ) )
#endif

#ifndef	CONTAINING_OBJECT
#define	CONTAINING_OBJECT(b,t,m)	(reinterpret_cast<t*>(&reinterpret_cast<BYTE*>(b)[-OFFSETOF(t,m)]))
#endif

//**********************************************************************
// Structure definitions
//**********************************************************************

template< class CGroupConnection > class CLockedContextClassFixedPool;

class CConnection;
class CNameTableEntry;

typedef struct _DIRECTNETOBJECT DIRECTNETOBJECT;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************

// class for Group Connections

class CGroupConnection
{
public:
	CGroupConnection()				// Constructor
		{
			m_Sig[0] = 'G';
			m_Sig[1] = 'C';
			m_Sig[2] = 'O';
			m_Sig[3] = 'N';
		};

	~CGroupConnection() { };			// Destructor

	BOOL FPMAlloc( void *const pvContext )
		{
			if (!DNInitializeCriticalSection(&m_cs))
			{
				return(FALSE);
			}
			DebugSetCriticalSectionRecursionCount(&m_cs,0);
		
			m_pdnObject = static_cast<DIRECTNETOBJECT*>(pvContext);

			return(TRUE);
		};

	BOOL FPMInitialize( void *const pvContext )
		{
			m_dwFlags = 0;
			m_bilink.Initialize();
			m_pConnection = NULL;
			m_lRefCount = 1;
			m_pGroup = NULL;

			return(TRUE);
		};

	void FPMRelease( void *const pvContext )
		{
		};

	void FPMDealloc( void *const pvContext )
		{
			DNDeleteCriticalSection(&m_cs);
		};

	void ReturnSelfToPool( void );

	#undef DPF_MODNAME
	#define DPF_MODNAME "CGroupConnection::AddRef"
	void AddRef(void)
		{
			DNASSERT(m_lRefCount > 0);
			InterlockedIncrement(const_cast<LONG*>(&m_lRefCount));
		};

	void Release(void);

	void Lock( void )
		{
			DNEnterCriticalSection(&m_cs);
		};

	void Unlock( void )
		{
			DNLeaveCriticalSection(&m_cs);
		};

	void AddToConnectionList( CBilink *const pBilink )
		{
			m_bilink.InsertBefore(pBilink);
		};

	void RemoveFromConnectionList( void )
		{
			m_bilink.RemoveFromList();
		};

	void SetConnection( CConnection *const pConnection );

	CConnection *GetConnection( void )
	{
		return(m_pConnection);
	};

	HRESULT	GetConnectionRef( CConnection **const ppConnection );

	void SetGroup( CNameTableEntry *const pGroup );

	CNameTableEntry *GetGroup( void )
		{
			return( m_pGroup );
		};

	void MakeValid( void )
		{
			m_dwFlags |= VALID;
		};

	void MakeInvalid( void )
		{
			m_dwFlags &= (~VALID);
		};

	BOOL IsConnected( void )
		{
			if (m_pConnection != NULL)
				return(TRUE);

			return(FALSE);
		};

	CBilink				m_bilink;

private:
	BYTE				m_Sig[4];
	DWORD	volatile	m_dwFlags;
	LONG	volatile	m_lRefCount;
	CConnection			*m_pConnection;
	CNameTableEntry		*m_pGroup;
	DNCRITICAL_SECTION	m_cs;
	DIRECTNETOBJECT		*m_pdnObject;
};

#undef DPF_MODNAME

#endif	// __GROUPCON_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\memoryfpm.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       MemoryFPM.cpp
 *  Content:	Memory Block FPM
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/31/00	mjn		Created
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 ***************************************************************************/

#include "dncorei.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// MemoryBlockAlloc
//
// Entry:		DWORD dwSize
//
// Exit:		PVOID		NULL or pointer to memory block
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "MemoryBlockAlloc"

PVOID MemoryBlockAlloc(void *const pvContext,
					   const DWORD dwSize )
{
	DIRECTNETOBJECT		*pdnObject;
	CMemoryBlockTiny	*pMBTiny;
	CMemoryBlockSmall	*pMBSmall;
	CMemoryBlockMedium	*pMBMedium;
	CMemoryBlockLarge	*pMBLarge;
	CMemoryBlockHuge	*pMBHuge;
	DN_MEMORY_BLOCK_HEADER	*pMBHeader;
	PVOID				pv;

	DPFX(DPFPREP, 8,"Parameters: pvContext [0x%p], dwSize [%ld]",pvContext,dwSize);

	pdnObject = static_cast<DIRECTNETOBJECT*>(pvContext);

	pv = NULL;
	if (dwSize <= DN_MEMORY_BLOCK_SIZE_TINY)
	{
		pMBTiny = pdnObject->m_pFPOOLMemoryBlockTiny->Get(pdnObject->m_pFPOOLMemoryBlockTiny);
		DPFX(DPFPREP, 9,"Got TINY at [0x%p]",pMBTiny);
		if (pMBTiny != NULL)
			pv = pMBTiny->GetBuffer();
	}
	else if (dwSize <= DN_MEMORY_BLOCK_SIZE_SMALL)
	{
		pMBSmall = pdnObject->m_pFPOOLMemoryBlockSmall->Get(pdnObject->m_pFPOOLMemoryBlockSmall);
		DPFX(DPFPREP, 9,"Got SMALL at [0x%p]",pMBSmall);
		if (pMBSmall != NULL)
			pv = pMBSmall->GetBuffer();
	}
	else if (dwSize <= DN_MEMORY_BLOCK_SIZE_MEDIUM)
	{
		pMBMedium = pdnObject->m_pFPOOLMemoryBlockMedium->Get(pdnObject->m_pFPOOLMemoryBlockMedium);
		DPFX(DPFPREP, 9,"Got MEDIUM at [0x%p]",pMBMedium);
		if (pMBMedium != NULL)
			pv = pMBMedium->GetBuffer();
	}
	else if (dwSize <= DN_MEMORY_BLOCK_SIZE_LARGE)
	{
		pMBLarge = pdnObject->m_pFPOOLMemoryBlockLarge->Get(pdnObject->m_pFPOOLMemoryBlockLarge);
		DPFX(DPFPREP, 9,"Got LARGE at [0x%p]",pMBLarge);
		if (pMBLarge != NULL)
			pv = pMBLarge->GetBuffer();
	}
	else if (dwSize <= DN_MEMORY_BLOCK_SIZE_HUGE)
	{
		pMBHuge = pdnObject->m_pFPOOLMemoryBlockHuge->Get(pdnObject->m_pFPOOLMemoryBlockHuge);
		DPFX(DPFPREP, 9,"Got HUGE at [0x%p]",pMBHuge);
		if (pMBHuge != NULL)
			pv = pMBHuge->GetBuffer();
	}
	else
	{
		pMBHeader = static_cast<DN_MEMORY_BLOCK_HEADER*>(DNMalloc( dwSize + sizeof( DN_MEMORY_BLOCK_HEADER ) ));
		if (pMBHeader != NULL)
		{
			pMBHeader->dwSize = DN_MEMORY_BLOCK_SIZE_CUSTOM;
			pMBHeader->FixedPoolPlaceHolder = NULL;
			pv = pMBHeader + 1;
		}
		DPFX(DPFPREP, 9,"malloc odd size at [0x%p]",pMBHeader);
	}

	DPFX(DPFPREP, 8,"Returning: [0x%p]",pv);
	return(pv);
}


//**********************************************************************
// ------------------------------
// MemoryBlockFree
//
// Entry:		PVOID	pvMemoryBlock
//
// Exit:		Nothing
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "MemoryBlockFree"

void MemoryBlockFree(void *const pvContext,
					 void *const pvMemoryBlock)
{
	CMemoryBlockTiny	*pMBTiny;
	CMemoryBlockSmall	*pMBSmall;
	CMemoryBlockMedium	*pMBMedium;
	CMemoryBlockLarge	*pMBLarge;
	CMemoryBlockHuge	*pMBHuge;
	DN_MEMORY_BLOCK_HEADER	*pMBHeader;

	DPFX(DPFPREP, 8,"Parameters: pvContext [0x%p], pvMemoryBlock [0x%p]",
			pvContext,pvMemoryBlock);

	pMBTiny = CMemoryBlockTiny::GetObjectFromBuffer(pvMemoryBlock);
	if (pMBTiny->GetSize() == DN_MEMORY_BLOCK_SIZE_TINY)
	{
		pMBTiny->ReturnSelfToPool();
	}
	else if (pMBTiny->GetSize() == DN_MEMORY_BLOCK_SIZE_SMALL)
	{
		pMBSmall = reinterpret_cast<CMemoryBlockSmall*>(pMBTiny);
		pMBSmall->ReturnSelfToPool();
	}
	else if (pMBTiny->GetSize() == DN_MEMORY_BLOCK_SIZE_MEDIUM)
	{
		pMBMedium = reinterpret_cast<CMemoryBlockMedium*>(pMBTiny);
		pMBMedium->ReturnSelfToPool();
	}
	else if (pMBTiny->GetSize() == DN_MEMORY_BLOCK_SIZE_LARGE)
	{
		pMBLarge = reinterpret_cast<CMemoryBlockLarge*>(pMBTiny);
		pMBLarge->ReturnSelfToPool();
	}
	else if (pMBTiny->GetSize() == DN_MEMORY_BLOCK_SIZE_HUGE)
	{
		pMBHuge = reinterpret_cast<CMemoryBlockHuge*>(pMBTiny);
		pMBHuge->ReturnSelfToPool();
	}
	else
	{
		pMBHeader = reinterpret_cast<DN_MEMORY_BLOCK_HEADER*>(pMBTiny);
		DNFree(pMBHeader);
	}

	DPFX(DPFPREP, 8,"Returning: (nothing)");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\message.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Message.cpp
 *  Content:    DNET internal messages
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  10/18/99	mjn		Created
 *  12/23/99	mjn		Hand all NameTable update sends from Host to worker thread
 *	12/23/99	mjn		Added DNSendHostMigrateMessage
 *	12/28/99	mjn		Moved Async Op stuff to Async.h
 *	01/06/00	mjn		Moved NameTable stuff to NameTable.h
 *	01/10/00	mjn		Added DNSendUpdateAppDescMessage
 *	01/15/00	mjn		Replaced DN_COUNT_BUFFER with CRefCountBuffer
 *	01/24/00	mjn		Added messages for NameTable operation list clean-up
 *	01/25/00	mjn		Added DNSendHostMigrateCompleteMessage
 *	04/04/00	mjn		Added DNSendTerminateSession()
 *	04/20/00	mjn		NameTable operations are sent directly by WorkerThread
 *				mjn		DNSendHostMigrateCompleteMessage uses CAsyncOp's
 *	04/23/00	mjn		Added parameter to DNPerformChildSend()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


//	DNSendHostMigrateCompleteMessage
//
//	Send a HOST_MIGRATE_COMPLETE message to connected players

#undef DPF_MODNAME
#define DPF_MODNAME "DNSendHostMigrateCompleteMessage"

HRESULT	DNSendHostMigrateCompleteMessage(DIRECTNETOBJECT *const pdnObject)
{
	HRESULT		hResultCode;
	CAsyncOp	*pParent;
	CBilink		*pBilink;
	CNameTableEntry	*pNTEntry;

	DPFX(DPFPREP, 6,"Parameters: (none)");

	DNASSERT(pdnObject != NULL);

	pParent = NULL;
	pNTEntry = NULL;

	hResultCode = DNCreateSendParent(	pdnObject,
										DN_MSG_INTERNAL_HOST_MIGRATE_COMPLETE,
										NULL,
										DN_SENDFLAGS_RELIABLE,
										&pParent);
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not create AsyncOp");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

	//
	//	Lock NameTable
	//
	pdnObject->NameTable.Lock();

	pBilink = pdnObject->NameTable.m_bilinkEntries.GetNext();
	while (pBilink != &pdnObject->NameTable.m_bilinkEntries)
	{
		pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
		if (	   !pNTEntry->IsGroup()
				&& !pNTEntry->IsDisconnecting()
				&& !pNTEntry->IsLocal()
			)
		{
			DNASSERT(pNTEntry->GetConnection() != NULL);
			hResultCode = DNPerformChildSend(	pdnObject,
												pParent,
												pNTEntry->GetConnection(),
												0,
												NULL);
			if (hResultCode != DPNERR_PENDING)
			{
				DPFERR("Could not perform part of group send - ignore and continue");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
			}
		}

		pBilink = pBilink->GetNext();
	}

	//
	//	Unlock NameTable
	//
	pdnObject->NameTable.Unlock();

	pParent->Release();
	pParent = NULL;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pParent)
	{
		pParent->Release();
		pParent = NULL;
	}
	goto Exit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\memoryfpm.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       MemoryFPM.h
 *  Content:	Memory Block FPM
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/31/00	mjn		Created
 ***************************************************************************/

#ifndef __MEMORYFPM_H__
#define __MEMORYFPM_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	DN_MEMORY_BLOCK_SIZE_CUSTOM		0

#define	DN_MEMORY_BLOCK_SIZE_TINY		128
#define	DN_MEMORY_BLOCK_SIZE_SMALL		256
#define	DN_MEMORY_BLOCK_SIZE_MEDIUM		512
#define	DN_MEMORY_BLOCK_SIZE_LARGE		1024
#define	DN_MEMORY_BLOCK_SIZE_HUGE		2048
/*
#define	DN_MEMORY_BLOCK_SIZE_TINY		1
#define	DN_MEMORY_BLOCK_SIZE_SMALL		2
#define	DN_MEMORY_BLOCK_SIZE_MEDIUM		4
#define	DN_MEMORY_BLOCK_SIZE_LARGE		8
#define	DN_MEMORY_BLOCK_SIZE_HUGE		16
*/
//**********************************************************************
// Macro definitions
//**********************************************************************

#define OFFSETOF(s,m)				( ( INT_PTR ) ( ( PVOID ) &( ( (s*) 0 )->m ) ) )

//**********************************************************************
// Structure definitions
//**********************************************************************

template< class CMemoryBlockTiny > class CLockedContextClassFixedPool;
template< class CMemoryBlockSmall > class CLockedContextClassFixedPool;
template< class CMemoryBlockMedium > class CLockedContextClassFixedPool;
template< class CMemoryBlockLarge > class CLockedContextClassFixedPool;
template< class CMemoryBlockHuge > class CLockedContextClassFixedPool;

typedef struct _DN_MEMORY_BLOCK_HEADER
{
	DWORD	dwSize;
	void*	FixedPoolPlaceHolder;
} DN_MEMORY_BLOCK_HEADER;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

PVOID MemoryBlockAlloc(void *const pvContext,const DWORD dwSize);
void MemoryBlockFree(void *const pvContext,void *const pvMemoryBlock);

//**********************************************************************
// Class prototypes
//**********************************************************************

// class for TINY memory block

class CMemoryBlockTiny
{
public:
	CMemoryBlockTiny()		// Constructor
		{
			m_dwSize = DN_MEMORY_BLOCK_SIZE_TINY;
		};

	~CMemoryBlockTiny() { };		// Destructor

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMemoryBlockTiny::FPMAlloc"
	BOOL FPMAlloc( void *const pvContext )
		{
			DNASSERT(pvContext != NULL);
			m_pFPOOL = static_cast<CLockedContextClassFixedPool<CMemoryBlockTiny>*>(pvContext);
			return(TRUE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMemoryBlockTiny::FPMInitialize"
	BOOL FPMInitialize( void *const pvContext )
		{
			DNASSERT(m_pFPOOL != NULL);
			return(TRUE);
		};

	void FPMRelease( void *const pvContext )
		{
		};

	void FPMDealloc( void *const pvContext )
		{
		};

	DWORD GetSize(void)
		{
			return(m_dwSize);
		};

	void * GetBuffer(void)
		{
			return( m_pBuffer );
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMemoryBlockTiny::ReturnSelfToPool"
	void ReturnSelfToPool( void )
		{
			DNASSERT(m_pFPOOL != NULL);
			m_pFPOOL->Release( this );
		};

	static CMemoryBlockTiny *GetObjectFromBuffer( void *const pvBuffer )
		{
			return( reinterpret_cast<CMemoryBlockTiny*>( &reinterpret_cast<BYTE*>( pvBuffer )[ -OFFSETOF( CMemoryBlockTiny, m_pBuffer ) ] ) );
		};

private:
	DWORD	m_dwSize;
	CLockedContextClassFixedPool<CMemoryBlockTiny>	*m_pFPOOL;
	BYTE	m_pBuffer[DN_MEMORY_BLOCK_SIZE_TINY];
};


// class for SMALL memory block

class CMemoryBlockSmall
{
public:
	CMemoryBlockSmall()		// Constructor
	{
		m_dwSize = DN_MEMORY_BLOCK_SIZE_SMALL;
	};

	~CMemoryBlockSmall() { };		// Destructor

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMemoryBlockSmall::FPMAlloc"
	BOOL FPMAlloc( void *const pvContext )
		{
			DNASSERT(pvContext != NULL);
			m_pFPOOL = static_cast<CLockedContextClassFixedPool<CMemoryBlockSmall>*>(pvContext);
			return(TRUE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMemoryBlockSmall::FPMInitialize"
	BOOL FPMInitialize( void *const pvContext )
		{
			DNASSERT(m_pFPOOL != NULL);
			return(TRUE);
		};

	void FPMRelease( void *const pvContext )
		{
		};

	void FPMDealloc( void *const pvContext )
		{
		};

	DWORD GetSize(void)
		{
			return(m_dwSize);
		};

	void * GetBuffer(void)
		{
			return( m_pBuffer );
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMemoryBlockSmall::ReturnSelfToPool"
	void ReturnSelfToPool( void )
		{
			DNASSERT(m_pFPOOL != NULL);
			m_pFPOOL->Release( this );
		};

	static CMemoryBlockSmall *GetObjectFromBuffer( void *const pvBuffer )
		{
			return( reinterpret_cast<CMemoryBlockSmall*>( &reinterpret_cast<BYTE*>( pvBuffer )[ -OFFSETOF( CMemoryBlockSmall, m_pBuffer ) ] ) );
		};

private:
	DWORD	m_dwSize;
	CLockedContextClassFixedPool<CMemoryBlockSmall>	*m_pFPOOL;
	BYTE	m_pBuffer[DN_MEMORY_BLOCK_SIZE_SMALL];	
};


// class for MEDIUM memory block

class CMemoryBlockMedium
{
public:
	CMemoryBlockMedium()		// Constructor
	{
		m_dwSize = DN_MEMORY_BLOCK_SIZE_MEDIUM;
	};

	~CMemoryBlockMedium() { };		// Destructor

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMemoryBlockMedium::FPMAlloc"
	BOOL FPMAlloc( void *const pvContext )
		{
			DNASSERT(pvContext != NULL);
			m_pFPOOL = static_cast<CLockedContextClassFixedPool<CMemoryBlockMedium>*>(pvContext);
			return(TRUE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMemoryBlockMedium::FPMInitialize"
	BOOL FPMInitialize( void *const pvContext )
		{
			DNASSERT(m_pFPOOL != NULL);
			return(TRUE);
		};

	void FPMRelease( void *const pvContext )
		{
		};

	void FPMDealloc( void *const pvContext )
		{
		};

	DWORD GetSize(void)
		{
			return(m_dwSize);
		};

	void * GetBuffer(void)
		{
			return( m_pBuffer );
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMemoryBlockMedium::ReturnSelfToPool"
	void ReturnSelfToPool( void )
		{
			DNASSERT(m_pFPOOL != NULL);
			m_pFPOOL->Release( this );
		};

	static CMemoryBlockMedium *GetObjectFromBuffer( void *const pvBuffer )
		{
			return( reinterpret_cast<CMemoryBlockMedium*>( &reinterpret_cast<BYTE*>( pvBuffer )[ -OFFSETOF( CMemoryBlockMedium, m_pBuffer ) ] ) );
		};

private:
	DWORD	m_dwSize;
	CLockedContextClassFixedPool<CMemoryBlockMedium>	*m_pFPOOL;
	BYTE	m_pBuffer[DN_MEMORY_BLOCK_SIZE_MEDIUM];	
};


// class for LARGE memory block

class CMemoryBlockLarge
{
public:
	CMemoryBlockLarge()		// Constructor
	{
		m_dwSize = DN_MEMORY_BLOCK_SIZE_LARGE;
	};

	~CMemoryBlockLarge() { };		// Destructor

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMemoryBlockLarge::FPMAlloc"
	BOOL FPMAlloc( void *const pvContext )
		{
			DNASSERT(pvContext != NULL);
			m_pFPOOL = static_cast<CLockedContextClassFixedPool<CMemoryBlockLarge>*>(pvContext);
			return(TRUE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMemoryBlockLarge::FPMInitialize"
	BOOL FPMInitialize( void *const pvContext )
		{
			DNASSERT(m_pFPOOL != NULL);
			return(TRUE);
		};

	void FPMRelease( void *const pvContext )
		{
		};

	void FPMDealloc( void *const pvContext )
		{
		};

	DWORD GetSize(void)
		{
			return(m_dwSize);
		};

	void * GetBuffer(void)
		{
			return( m_pBuffer );
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMemoryBlockLarge::ReturnSelfToPool"
	void ReturnSelfToPool( void )
		{
			DNASSERT(m_pFPOOL != NULL);
			m_pFPOOL->Release( this );
		};

	static CMemoryBlockLarge *GetObjectFromBuffer( void *const pvBuffer )
		{
			return( reinterpret_cast<CMemoryBlockLarge*>( &reinterpret_cast<BYTE*>( pvBuffer )[ -OFFSETOF( CMemoryBlockLarge, m_pBuffer ) ] ) );
		};

private:
	DWORD	m_dwSize;
	CLockedContextClassFixedPool<CMemoryBlockLarge>	*m_pFPOOL;
	BYTE	m_pBuffer[DN_MEMORY_BLOCK_SIZE_LARGE];	
};


// class for HUGE memory block

class CMemoryBlockHuge
{
public:
	CMemoryBlockHuge()		// Constructor
	{
		m_dwSize = DN_MEMORY_BLOCK_SIZE_HUGE;
	};

	~CMemoryBlockHuge() { };		// Destructor

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMemoryBlockHuge::FPMAlloc"
	BOOL FPMAlloc( void *const pvContext )
		{
			DNASSERT(pvContext != NULL);
			m_pFPOOL = static_cast<CLockedContextClassFixedPool<CMemoryBlockHuge>*>(pvContext);
			return(TRUE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMemoryBlockHuge::FPMInitialize"
	BOOL FPMInitialize( void *const pvContext )
		{
			DNASSERT(m_pFPOOL != NULL);
			return(TRUE);
		};

	void FPMRelease( void *const pvContext )
		{
		};

	void FPMDealloc( void *const pvContext )
		{
		};

	DWORD GetSize(void)
		{
			return(m_dwSize);
		};

	void * GetBuffer(void)
		{
			return( m_pBuffer );
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMemoryBlockHuge::ReturnSelfToPool"
	void ReturnSelfToPool( void )
		{
			DNASSERT(m_pFPOOL != NULL);
			m_pFPOOL->Release( this );
		};

	static CMemoryBlockHuge *GetObjectFromBuffer( void *const pvBuffer )
		{
			return( reinterpret_cast<CMemoryBlockHuge*>( &reinterpret_cast<BYTE*>( pvBuffer )[ -OFFSETOF( CMemoryBlockHuge, m_pBuffer ) ] ) );
		};

private:
	DWORD	m_dwSize;
	CLockedContextClassFixedPool<CMemoryBlockHuge>	*m_pFPOOL;
	BYTE	m_pBuffer[DN_MEMORY_BLOCK_SIZE_HUGE];	
};


#undef DPF_MODNAME

#endif	// __MEMORYFPM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\handletable.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       HandleTable.h
 *  Content:    Handle Table Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  04/08/00	mjn		Created
 *	04/16/00	mjn		Added Update() and allow NULL data for Handles
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__HANDLETABLE_H__
#define	__HANDLETABLE_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	HANDLETABLE_FLAG_INITIALIZED		0x0001

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

class CAsyncOp;

typedef struct _HANDLETABLE_ARRAY_ENTRY HANDLETABLE_ARRAY_ENTRY;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************

// class for Handle Table

class CHandleTable
{
public:
	CHandleTable()			// Constructor
		{
			m_dwFlags = 0;
		};

	~CHandleTable() { };	// Destructor

	HRESULT CHandleTable::Initialize( void );

	void CHandleTable::Deinitialize( void );

	void Lock( void )
		{
			DNEnterCriticalSection(&m_cs);
		};

	void Unlock( void )
		{
			DNLeaveCriticalSection(&m_cs);
		};

	HRESULT CHandleTable::GrowTable( void );

	HRESULT CHandleTable::Create( CAsyncOp *const pAsyncOp,
								  DPNHANDLE *const pHandle );

	HRESULT CHandleTable::Destroy( const DPNHANDLE handle );

	HRESULT CHandleTable::Update( const DPNHANDLE handle,
								  CAsyncOp *const pAsyncOp );

	HRESULT CHandleTable::Find( const DPNHANDLE handle,
								CAsyncOp **const ppAsyncOp );

	HRESULT CHandleTable::Enum( DPNHANDLE *const rgHandles,
								DWORD *const cHandle );

private:
	DWORD	volatile	m_dwFlags;

	DWORD	volatile	m_dwNumEntries;
	DWORD	volatile	m_dwNumFreeEntries;
	DWORD	volatile	m_dwFirstFreeEntry;
	DWORD	volatile	m_dwLastFreeEntry;

	DWORD	volatile	m_dwVersion;

	HANDLETABLE_ARRAY_ENTRY	*m_pTable;

	DNCRITICAL_SECTION		m_cs;
};

#endif	// __HANDLETABLE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\migration.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Migration.cpp
 *  Content:    DNET Host Migration Routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/23/99	mjn		Created
 *	12/23/99	mjn		Fixed basic host migration
 *	12/28/99	mjn		Added DNCompleteOutstandingOperations
 *	12/28/99	mjn		Added NameTable version to Host migration message
 *	12/28/99	mjn		Moved Async Op stuff to Async.h
 *	01/04/00	mjn		Added code to allow outstanding ops to complete at host migration
 *	01/06/00	mjn		Moved NameTable stuff to NameTable.h
 *	01/11/00	mjn		Moved connect/disconnect stuff to Connect.h
 *	01/15/00	mjn		Replaced DN_COUNT_BUFFER with CRefCountBuffer
 *	01/16/00	mjn		Moved User callback stuff to User.h
 *	01/17/00	mjn		Generate DN_MSGID_HOST_MIGRATE at host migration
 *	01/19/00	mjn		Auto destruct groups at host migration
 *	01/24/00	mjn		Use DNNTUpdateVersion to update NameTable version
 *	01/25/00	mjn		Send dwLatestVersion to Host at migration
 *	01/25/00	mjn		Changed Host Migration to multi-step affair
 *	01/26/00	mjn		Implemented NameTable re-sync at host migration
 *	02/01/00	mjn		Implement Player/Group context values
 *	02/04/00	mjn		Clean up NameTable to remove old entries
 *  03/25/00    rmt     Added calls into DPNSVR modules
 *  04/04/00	rmt		Added check for DPNSVR disable flag before attempting to register w/DPNSVR
 *	04/16/00	mjn		DNSendMessage() used CAsyncOp
 *	04/18/00	mjn		CConnection tracks connection status better
 *				mjn		Fixed player count problem
 *	04/19/00	mjn		Update NameTable operations to use DN_WORKER_JOB_SEND_NAMETABLE_OPERATION
 *	04/25/00	mjn		Fixed migration process to ensure use of CAsyncOp
 *				mjn		Migration calls CoInitialize()/CoUninitialize() before registering w/ DPNSVR
 *	05/03/00	mjn		Use GetHostPlayerRef() rather than GetHostPlayer()
 *	05/04/00	mjn		Ensure local player still in session for Host migration
 *	05/16/00	mjn		Do not take locks when clearing NameTable short-cut pointers
 *	06/25/00	mjn		Ignore players older than old Host when determining new Host in DNFindNewHost()
 *	07/06/00	mjn		Fixed locking problem in CNameTable::MakeLocalPlayer,MakeHostPlayer,MakeAllPlayersGroup
 *	07/07/00	mjn		Added shut down checks to migration code.
 *	07/20/00	mjn		Cleaned up leaking RefCountBuffers and added closing tests
 *	07/21/00	mjn		Added code in DNCheckReceivedAllVersions() to skip disconnecting players
 *  07/27/00	rmt		Bug #40882 - DPLSESSION_HOSTMIGRATED status update is not sent
 *	07/31/00	mjn		Added dwDestroyReason to DNHostDisconnect()
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *	08/05/00	mjn		Added pParent to DNSendGroupMessage and DNSendMessage()
 *				mjn		Added fInternal to DNPerformChildSend()
 *	08/06/00	mjn		Added CWorkerJob
 *	08/07/00	mjn		Handle integrity check requests during host migration
 *	08/08/00	mjn		Moved DN_NAMETABLE_OP_INFO to Message.h
 *	08/11/00	mjn		Added DN_OBJECT_FLAG_HOST_MIGRATING_2 to prevent multiple threads from passing DNCheckReceivedAllVersions()
 *	08/15/00	mjn		Perform LISTEN registration with DPNSVR in PerformHostMigration3()
 *	08/24/00	mjn		Replace DN_NAMETABLE_OP with CNameTableOp
 *	09/04/00	mjn		Added CApplicationDesc
 *	09/06/00	mjn		Fixed register with DPNSVR problem
 *	09/17/00	mjn		Split CNameTable.m_bilinkEntries into m_bilinkPlayers and m_bilinkGroups
 *	10/12/00	mjn		Ensure proper locks taken when traversing CNameTable::m_bilinkEntries
 *	01/25/01	mjn		Fixed 64-bit alignment problem in received messages
 *	03/30/01	mjn		Changes to prevent multiple loading/unloading of SP's
 *	04/05/01	mjn		Added DPNID parameter to DNProcessHostMigration3() to ensure correct new host is completing host migration
 *	04/13/01	mjn		Use request list instead of async op list when retrying outstanding requests
 *	05/17/01	mjn		Wait for threads performing NameTable operations to finish before sending NameTable version during host migration
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


//	DNFindNewHost
//
//	Find the new host from the entries in the NameTable.
//	This is based on version number of the players in the NameTable.  The player with
//		the oldest version number (after the old Host) will be the new Host.
//
//	DPNID	*pdpnidNewHost		New Host DNID

#undef DPF_MODNAME
#define DPF_MODNAME "DNFindNewHost"

HRESULT	DNFindNewHost(DIRECTNETOBJECT *const pdnObject,
					  DPNID *const pdpnidNewHost)
{
	CBilink			*pBilink;
	CNameTableEntry	*pNTEntry;
	CNameTableEntry	*pLocalPlayer;
	CNameTableEntry	*pHostPlayer;
	HRESULT			hResultCode;
	DWORD			dwVersionNewHost;
	DWORD			dwVersionOldHost;
	DPNID			dpnidNewHost;

	DPFX(DPFPREP, 6,"Parameters: pdpnidNewHost [0x%p]",pdpnidNewHost);

	DNASSERT(pdnObject != NULL);

	pNTEntry = NULL;
	pLocalPlayer = NULL;
	pHostPlayer = NULL;

	//
	//	Seed local player as new Host
	//
	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		hResultCode = DPNERR_INVALIDPLAYER;
		goto Failure;
	}
	dpnidNewHost = pLocalPlayer->GetDPNID();
	dwVersionNewHost = pLocalPlayer->GetVersion();
	DPFX(DPFPREP, 7,"First Host Candidate: dpnid [0x%lx], dwVersion [%ld]",dpnidNewHost,dwVersionNewHost);
	pLocalPlayer->Release();
	pLocalPlayer = NULL;

	//
	//	Determine old host player version
	//
	if ((hResultCode = pdnObject->NameTable.GetHostPlayerRef( &pHostPlayer )) == DPN_OK)
	{
		dwVersionOldHost = pHostPlayer->GetVersion();
		pHostPlayer->Release();
		pHostPlayer = NULL;
	}
	else
	{
		dwVersionOldHost = 0;
	}

	//
	//	Lock down NameTable
	//
	pdnObject->NameTable.ReadLock();

	// Traverse NameTable to find player with next older version
	//	TODO - we should release the NameTable CS so that leaving players get updated in NameTable
	pBilink = pdnObject->NameTable.m_bilinkPlayers.GetNext();
	while (pBilink != &pdnObject->NameTable.m_bilinkPlayers)
	{
		pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
		pNTEntry->Lock();
		if (!pNTEntry->IsDisconnecting() && (pNTEntry->GetVersion() < dwVersionNewHost))
		{
			//
			//	There are some conditions where we might have players older than the Host in the NameTable
			//	Consider the following: P1,P2,P3,P4 (P1 is Host)
			//		- P1, P2 drop
			//		- P3 detects drop of P1 and P2
			//		- P4 detects drop of P1 only (P2 may not yet have timed out)
			//		- P3 sends HOST_MIGRATE message to P4
			//		- P4 makes P3 new Host, but P2 is still in NameTable (at this stage)
			//		- P3 drops (P2's drop sill has not been detected!)
			//	We should therefore ignore all players older than the old Host,
			//
			if (pNTEntry->GetVersion() < dwVersionOldHost)
			{
				DPFERR("Found player older than old Host ! (Have we missed a drop ?)");
			}
			else
			{
				dpnidNewHost = pNTEntry->GetDPNID();
				dwVersionNewHost = pNTEntry->GetVersion();
				DPFX(DPFPREP, 7,"Better Host Candidate: dpnid [0x%lx], dwVersion [%ld]",
						dpnidNewHost,dwVersionNewHost);
			}
		}
		pNTEntry->Unlock();
		pNTEntry = NULL;
		pBilink = pBilink->GetNext();
	}

	//
	//	Unlock NameTable
	//
	pdnObject->NameTable.Unlock();

	DPFX(DPFPREP, 7,"Found New Host: dpnid [0x%lx], dwVersion [%ld]",dpnidNewHost,dwVersionNewHost);

	if (pdpnidNewHost)
		*pdpnidNewHost = dpnidNewHost;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	if (pHostPlayer)
	{
		pHostPlayer->Release();
		pHostPlayer = NULL;
	}
	goto Exit;
}


//	DNPerformHostMigration1
//
//	Perform host migration to become the new Host.

#undef DPF_MODNAME
#define DPF_MODNAME "DNPerformHostMigration1"

HRESULT	DNPerformHostMigration1(DIRECTNETOBJECT *const pdnObject,
								const DPNID dpnidOldHost)
{
	HRESULT				hResultCode;
	CRefCountBuffer		*pRefCountBuffer;
	CWorkerJob			*pWorkerJob;
	CNameTableEntry		*pLocalPlayer;
	CPendingDeletion	*pPending;
	DN_INTERNAL_MESSAGE_HOST_MIGRATE	*pInfo;
	CBilink				*pBilink;
	CNameTableOp		*pNTOp;

	DPFX(DPFPREP, 6,"Parameters: dpnidOldHost [0x%lx]",dpnidOldHost);

	DNASSERT(pdnObject != NULL);

	pLocalPlayer = NULL;
	pRefCountBuffer = NULL;
	pPending = NULL;
	pWorkerJob = NULL;
	pNTOp = NULL;

	//
	//	Need reference on local player
	//
	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get reference on LocalPlayer");
		goto Failure;
	}

	//
	//	Flag as performing host migration - ensure we're not already running this from another thread
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_CLOSING)
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		hResultCode = DPN_OK;
		goto Failure;
	}
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_HOST_MIGRATING)
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		hResultCode = DPN_OK;
		goto Failure;
	}
	pdnObject->dwFlags |= DN_OBJECT_FLAG_HOST_MIGRATING;
	DNASSERT(pdnObject->pNewHost == NULL);
	pLocalPlayer->AddRef();
	pdnObject->pNewHost = pLocalPlayer;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	//
	//	Put this on the Outstanding operation list
	//
	if ((hResultCode = PendingDeletionNew(pdnObject,&pPending)) == DPN_OK)
	{
		pPending->SetDPNID( dpnidOldHost );

		DNEnterCriticalSection(&pdnObject->csNameTableOpList);
		pPending->m_bilinkPendingDeletions.InsertBefore(&pdnObject->m_bilinkPendingDeletions);
		DNLeaveCriticalSection(&pdnObject->csNameTableOpList);

		pPending = NULL;
	}
	DNUpdateLobbyStatus(pdnObject,DPLSESSION_HOSTMIGRATEDHERE);	

	//
	//	Make new host
	//
	pdnObject->NameTable.UpdateHostPlayer( pLocalPlayer );

	//
	//	We will need to wait for all threads performing name table operations to finish running
	//	before we send the current name table version to the host player
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pdnObject->dwFlags |= DN_OBJECT_FLAG_HOST_MIGRATING_WAIT;
	if (pdnObject->dwRunningOpCount > 0)
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		DPFX(DPFPREP,7,"Waiting for running threads to finish");
		WaitForSingleObject(pdnObject->hRunningOpEvent,INFINITE);
		DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	}
	else
	{
		DPFX(DPFPREP,7,"No running threads to wait for");
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	//
	//	Clean-up outstanding operations
	//
	DPFX(DPFPREP,7,"Cleaning up outstanding NameTable operations");
	pdnObject->NameTable.WriteLock();
	DPFX(DPFPREP,7,"NameTable version [%ld]",pdnObject->NameTable.GetVersion());
	pBilink = pdnObject->NameTable.m_bilinkNameTableOps.GetNext();
	while (pBilink != &pdnObject->NameTable.m_bilinkNameTableOps)
	{
		pNTOp = CONTAINING_OBJECT(pBilink,CNameTableOp,m_bilinkNameTableOps);
		pBilink = pBilink->GetNext();
		if (pNTOp->GetVersion() > pdnObject->NameTable.GetVersion())
		{
			DPFX(DPFPREP,7,"Removing outstanding operation [0x%p], version [%ld]",pNTOp,pNTOp->GetVersion());
			pNTOp->m_bilinkNameTableOps.RemoveFromList();
			if (pNTOp->GetRefCountBuffer())
			{
				pNTOp->GetRefCountBuffer()->Release();
				pNTOp->SetRefCountBuffer( NULL );
			}
			if (pNTOp->GetSP())
			{
				pNTOp->GetSP()->Release();
				pNTOp->SetSP( NULL );
			}
			pNTOp->ReturnSelfToPool();
		}
		pNTOp = NULL;
	}
	pdnObject->NameTable.Unlock();

	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pdnObject->dwFlags &= (~DN_OBJECT_FLAG_HOST_MIGRATING_WAIT);
	ResetEvent(pdnObject->hRunningOpEvent);
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	//
	//	Update NameTable operation list version
	//
	hResultCode = DNNTPlayerSendVersion(pdnObject);

	// Only need to proceed if we're not the only player left in the session
	if ((hResultCode = DNCheckReceivedAllVersions(pdnObject)) != DPN_OK)
	{
		// Inform other players of host migration
		DPFX(DPFPREP, 7,"Informing other players of host migration");
		if ((hResultCode = RefCountBufferNew(pdnObject,sizeof(DN_INTERNAL_MESSAGE_HOST_MIGRATE),
				&pRefCountBuffer)) != DPN_OK)
		{
			DPFERR("Could not create RefCountBuffer for Host Migration");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pInfo = reinterpret_cast<DN_INTERNAL_MESSAGE_HOST_MIGRATE*>(pRefCountBuffer->GetBufferAddress());
		pInfo->dpnidNewHost = pLocalPlayer->GetDPNID();
		pInfo->dpnidOldHost = dpnidOldHost;

		if ((hResultCode = WorkerJobNew(pdnObject,&pWorkerJob)) != DPN_OK)
		{
			DPFERR("Could not create WorkerJob for Host Migration");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pWorkerJob->SetJobType( WORKER_JOB_SEND_NAMETABLE_OPERATION );
		pWorkerJob->SetSendNameTableOperationMsgId( DN_MSG_INTERNAL_HOST_MIGRATE );
		pWorkerJob->SetSendNameTableOperationVersion( 0 );
		pWorkerJob->SetSendNameTableOperationDPNIDExclude( 0 );
		pWorkerJob->SetRefCountBuffer( pRefCountBuffer );

		DNQueueWorkerJob(pdnObject,pWorkerJob);
		pWorkerJob = NULL;

		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}

	pLocalPlayer->Release();
	pLocalPlayer = NULL;

	hResultCode = DPN_OK;

Exit:
	DNASSERT( pNTOp == NULL );

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pPending)
	{
		pPending->ReturnSelfToPool();
		pPending = NULL;
	}
	goto Exit;
}


//	DNPerformHostMigration2
//
//	Resynchronize NameTables of all connected players

#undef DPF_MODNAME
#define DPF_MODNAME "DNPerformHostMigration2"

HRESULT	DNPerformHostMigration2(DIRECTNETOBJECT *const pdnObject)
{
	HRESULT			hResultCode;
	CRefCountBuffer	*pRefCountBuffer;
	CBilink			*pBilink;
	CNameTableEntry	*pLocalPlayer;
	CNameTableEntry	*pNTEntry;
	CNameTableEntry	*pNTELatest;
	CConnection		*pConnection;
	DN_INTERNAL_MESSAGE_REQ_NAMETABLE_OP	*pInfo;

	DPFX(DPFPREP, 6,"Parameters: (none)");

	DNASSERT(pdnObject != NULL);

	pRefCountBuffer = NULL;
	pLocalPlayer = NULL;
	pNTEntry = NULL;
	pNTELatest = NULL;
	pConnection = NULL;

	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	See if we (Host player) have the latest NameTable
	//
	pLocalPlayer->AddRef();
	pNTELatest = pLocalPlayer;
	DPFX(DPFPREP, 7,"Seed latest version [%ld] - player [0x%lx]",pNTELatest->GetLatestVersion(),pNTELatest->GetDPNID());

	pdnObject->NameTable.ReadLock();
	pBilink = pdnObject->NameTable.m_bilinkPlayers.GetNext();
	while (pBilink != &pdnObject->NameTable.m_bilinkPlayers)
	{
		pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
		pNTEntry->Lock();
		if (!pNTEntry->IsDisconnecting() && (pNTEntry->GetLatestVersion() > pNTELatest->GetLatestVersion()))
		{
			//
			// Only want players we can actually reach !
			//
			pNTEntry->Unlock();
			if ((hResultCode = pNTEntry->GetConnectionRef( &pConnection )) == DPN_OK)
			{
				if (!pConnection->IsDisconnecting() && !pConnection->IsInvalid())
				{
					pNTELatest->Release();
					pNTEntry->AddRef();
					pNTELatest = pNTEntry;

					DPFX(DPFPREP, 7,"New latest version [%ld] - player [0x%lx]",
							pNTELatest->GetLatestVersion(),pNTELatest->GetDPNID());
				}
				pConnection->Release();
				pConnection = NULL;
			}
			else
			{
				DNASSERT(pConnection == NULL);
			}
		}
		else
		{
			pNTEntry->Unlock();
		}
		pNTEntry = NULL;

		pBilink = pBilink->GetNext();
	}
	pdnObject->NameTable.Unlock();

	if (!pNTELatest->IsLocal())
	{
		// Request missing entries from player w/ latest NameTable
		DPFX(DPFPREP, 7,"Host DOES NOT have latest NameTable !");
		DPFX(DPFPREP, 7,"Host has [%ld], player [0x%lx] has [%ld]",pLocalPlayer->GetLatestVersion(),
				pNTELatest->GetDPNID(),pNTELatest->GetLatestVersion());

		// Create REQ
		if ((hResultCode = RefCountBufferNew(pdnObject,
				sizeof(DN_INTERNAL_MESSAGE_REQ_NAMETABLE_OP),&pRefCountBuffer)) != DPN_OK)
		{
			DPFERR("Could not create RefCount buffer for NameTable re-sync");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pInfo = reinterpret_cast<DN_INTERNAL_MESSAGE_REQ_NAMETABLE_OP*>(pRefCountBuffer->GetBufferAddress());
		pInfo->dwVersion = pLocalPlayer->GetLatestVersion() + 1;
		pInfo->dwVersionNotUsed = 0;

		// Send REQ
		if ((hResultCode = pNTELatest->GetConnectionRef( &pConnection )) == DPN_OK)
		{
			hResultCode = DNSendMessage(pdnObject,
										pConnection,
										DN_MSG_INTERNAL_REQ_NAMETABLE_OP,
										pNTELatest->GetDPNID(),
										pRefCountBuffer->BufferDescAddress(),
										pRefCountBuffer,
										0,
										DN_SENDFLAGS_RELIABLE,
										NULL,
										NULL);
			if (hResultCode != DPNERR_PENDING)
			{
				DPFERR("Could not send NameTable re-sync REQ");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
				goto Failure;
			}
			pConnection->Release();
			pConnection = NULL;
		}

		pRefCountBuffer->Release();	// Added 19/07/00 MJN - is this needed ?
		pRefCountBuffer = NULL;
	}
	else
	{
		DPFX(DPFPREP, 7,"Host has latest NameTable - proceed with Host Migration");
		hResultCode = DNPerformHostMigration3(pdnObject,NULL);
	}

	pNTELatest->Release();
	pNTELatest = NULL;

	pLocalPlayer->Release();
	pLocalPlayer = NULL;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pNTELatest)
	{
		pNTELatest->Release();
		pNTELatest = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	goto Exit;
}


//	DNPerformHostMigration3
//
//	Finish host migration.
//		- perform missing NameTable operations and pass them on
//		- send pending operations
//		- inform players that host migration is complete
//		- complete (local) outstanding async operations
//		- initiate new listen (if required) to handle enums on known port
//	As they say on the TTC, "All operations have returned to normal."

#undef DPF_MODNAME
#define DPF_MODNAME "DNPerformHostMigration3"

HRESULT	DNPerformHostMigration3(DIRECTNETOBJECT *const pdnObject,
								void *const pMsg)
{
	HRESULT				hResultCode;
	CBilink				*pBilink;
	CNameTableEntry		**PlayerList;
	CNameTableEntry		*pNTEntry;
	CConnection			*pConnection;
	CPendingDeletion	*pPending;
	DWORD				dwNameTableVersion;
	DWORD				dw;
	DWORD				dwCount;
	DWORD				dwActual;
	CNameTableOp		*pNTOp;
	UNALIGNED DN_NAMETABLE_OP_INFO	*pInfo;
	UNALIGNED DN_INTERNAL_MESSAGE_ACK_NAMETABLE_OP	*pAck;

	DPFX(DPFPREP, 6,"Parameters: pMsg [0x%p]",pMsg);

	DNASSERT(pdnObject != NULL);

	pNTOp = NULL;
	pNTEntry = NULL;
	pConnection = NULL;
	pPending = NULL;
	PlayerList = NULL;

	//
	//	Update missing NameTable operations on Host
	//
	if (pMsg != NULL)
	{
		pAck = static_cast<DN_INTERNAL_MESSAGE_ACK_NAMETABLE_OP*>(pMsg);
		DPFX(DPFPREP, 7,"Number of missing NameTable entries [%ld]",pAck->dwNumEntries);
		pInfo = reinterpret_cast<DN_NAMETABLE_OP_INFO*>(pAck+1);
		for (dw = 0; dw < pAck->dwNumEntries ; dw++)
		{
			DPFX(DPFPREP, 7,"Adding missing entry [%ld] of [%ld]",dw+1,pAck->dwNumEntries);
			hResultCode = DNNTAddOperation(	pdnObject,
											pInfo->dwMsgId,
											static_cast<void*>(reinterpret_cast<BYTE*>(pMsg) + pInfo->dwOpOffset),
											pInfo->dwOpSize,
											0,
											NULL );
			if (hResultCode != DPN_OK)
			{
				DPFERR("Could not add missing NameTable operation - ignore and continue");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
			}
			pInfo++;
		}
	}

	//
	//	Update missing NameTable operations on other players
	//

	//
	//	Determine player list
	//
	dwCount = 0;
	dwActual = 0;
	pdnObject->NameTable.ReadLock();
	dwNameTableVersion = pdnObject->NameTable.GetVersion();
	pBilink = pdnObject->NameTable.m_bilinkPlayers.GetNext();
	while (pBilink != &pdnObject->NameTable.m_bilinkPlayers)
	{
		pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
		pNTEntry->Lock();
		if (!pNTEntry->IsDisconnecting() && (pNTEntry->GetLatestVersion() < dwNameTableVersion))
		{
			dwCount++;
		}
		pNTEntry->Unlock();
		pNTEntry = NULL;

		pBilink = pBilink->GetNext();
	}
	if (dwCount)
	{
		if ((PlayerList = static_cast<CNameTableEntry**>(DNMalloc(dwCount * sizeof(CNameTableEntry*)))) == NULL)
		{
			DPFERR("Could not allocate target list");
			DNASSERT(FALSE);
			pdnObject->NameTable.Unlock();
			hResultCode = DPN_OK;
			goto Exit;
		}
		pBilink = pdnObject->NameTable.m_bilinkPlayers.GetNext();
		while (pBilink != &pdnObject->NameTable.m_bilinkPlayers)
		{
			pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
			pNTEntry->Lock();
			if (!pNTEntry->IsDisconnecting() && (pNTEntry->GetLatestVersion() < dwNameTableVersion))
			{
				DNASSERT(dwActual < dwCount);
				pNTEntry->AddRef();
				PlayerList[dwActual] = pNTEntry;
				dwActual++;
			}
			pNTEntry->Unlock();
			pNTEntry = NULL;

			pBilink = pBilink->GetNext();
		}
	}
	pdnObject->NameTable.Unlock();

	//
	//	Send missing entries to players in player list
	//
	for (dwCount = 0 ; dwCount < dwActual ; dwCount++)
	{
		//
		//	Ensure player is reachable
		//
		if ((hResultCode = PlayerList[dwCount]->GetConnectionRef( &pConnection )) == DPN_OK)
		{
			if (!pConnection->IsDisconnecting() && !pConnection->IsInvalid())
			{
				DPFX(DPFPREP, 7,"Player [0x%lx] is missing entries: dwLatestVersion [%ld] should be [%ld]",
						PlayerList[dwCount]->GetDPNID(),PlayerList[dwCount]->GetLatestVersion(),dwNameTableVersion);

				// Send required entries
				for (	dw = PlayerList[dwCount]->GetLatestVersion() + 1 ; dw <= dwNameTableVersion ; dw++ )
				{
					DPFX(DPFPREP, 7,"Send entry [%ld] to player [0x%lx]",dw,PlayerList[dwCount]->GetDPNID());

					// Get entry to send
					pNTOp = NULL;
					if ((hResultCode = DNNTFindOperation(pdnObject,dw,&pNTOp)) != DPN_OK)
					{
						DPFERR("Could not retrieve NameTable operation - advance to next player");
						DisplayDNError(0,hResultCode);
						break;
					}

					hResultCode = DNSendMessage(pdnObject,
												pConnection,
												pNTOp->GetMsgId(),
												PlayerList[dwCount]->GetDPNID(),
												pNTOp->GetRefCountBuffer()->BufferDescAddress(),
												pNTOp->GetRefCountBuffer(),
												0,
												DN_SENDFLAGS_RELIABLE,
												NULL,
												NULL);
					if (hResultCode != DPNERR_PENDING)
					{
						DPFERR("Could not send missing NameTable entry - advance to next player");
						DisplayDNError(0,hResultCode);
						DNASSERT(FALSE);
						break;
					}
				} // for
			} // if
			pConnection->Release();
			pConnection = NULL;
		} // if
		PlayerList[dwCount]->Release();
		PlayerList[dwCount] = NULL;
	}
	if (PlayerList != NULL)
	{
		DNFree(PlayerList);
		PlayerList = NULL;
	}

	//
	//	Host finished migration process
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pdnObject->dwFlags &= (~(DN_OBJECT_FLAG_HOST_MIGRATING | DN_OBJECT_FLAG_HOST_MIGRATING_2));
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_CLOSING)
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		hResultCode = DPN_OK;
		goto Exit;
	}
	DNASSERT(pdnObject->pNewHost != NULL);	// This should be set !
	pdnObject->pNewHost->Release();
	pdnObject->pNewHost = NULL;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	//
	//	Cleanup NameTable
	//
	DPFX(DPFPREP, 7,"Cleaning up NameTable");
	hResultCode = DNCleanUpNameTable(pdnObject);

	//
	//	Send pending deletions
	//
	DPFX(DPFPREP, 7,"Running pending operations");
	DNEnterCriticalSection(&pdnObject->csNameTableOpList);
	pBilink = pdnObject->m_bilinkPendingDeletions.GetNext();
	while (pBilink != &pdnObject->m_bilinkPendingDeletions)
	{
		pPending = CONTAINING_OBJECT(pBilink,CPendingDeletion,m_bilinkPendingDeletions);

		pPending->m_bilinkPendingDeletions.RemoveFromList();

		DNLeaveCriticalSection(&pdnObject->csNameTableOpList);

		DNHostDisconnect(pdnObject,pPending->GetDPNID(),DPNDESTROYPLAYERREASON_HOSTDESTROYEDPLAYER);
		pPending->ReturnSelfToPool();
		pPending = NULL;

		DNEnterCriticalSection(&pdnObject->csNameTableOpList);
		pBilink = pdnObject->m_bilinkPendingDeletions.GetNext();
	}
	DNLeaveCriticalSection(&pdnObject->csNameTableOpList);

	//
	//	Inform connected players that Host migration is complete
	//
	DPFX(DPFPREP, 7,"Sending HOST_MIGRATE_COMPLETE messages");
	hResultCode = DNSendHostMigrateCompleteMessage(pdnObject);

	//
	//	Ensure outstanding operations complete
	//
	DPFX(DPFPREP, 7,"Completing outstanding operations");
	hResultCode = DNCompleteOutstandingOperations(pdnObject);

	//
	//	Register with DPNSVR
	//
	if(pdnObject->ApplicationDesc.UseDPNSVR())
	{
		DNRegisterWithDPNSVR(pdnObject);
	}

	hResultCode = DPN_OK;

Exit:
	DNASSERT(pNTEntry == NULL);
	DNASSERT(pConnection == NULL);
	DNASSERT(pPending == NULL);
	DNASSERT(PlayerList == NULL);

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//	DNProcessHostMigration1
//
//	Perform an instructed host migration

#undef DPF_MODNAME
#define DPF_MODNAME "DNProcessHostMigration1"

HRESULT	DNProcessHostMigration1(DIRECTNETOBJECT *const pdnObject,
								void *const pvMsg)
{
	HRESULT			hResultCode;
	CNameTableEntry	*pNTEntry;
	UNALIGNED DN_INTERNAL_MESSAGE_HOST_MIGRATE	*pInfo;

	DPFX(DPFPREP, 6,"Parameters: pvMsg [0x%p]",pvMsg);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pvMsg != NULL);

	pNTEntry = NULL;

	pInfo = static_cast<DN_INTERNAL_MESSAGE_HOST_MIGRATE*>(pvMsg);

	DPFX(DPFPREP, 7,"New Host [0x%lx], Old Host [0x%lx]",pInfo->dpnidNewHost,pInfo->dpnidOldHost);

	DNASSERT(pInfo->dpnidNewHost != NULL);
	DNASSERT(pInfo->dpnidOldHost != NULL);

	//
	//	Update destruction of old host as normal, and disconnect if possible
	//
	if ((hResultCode = pdnObject->NameTable.FindEntry(pInfo->dpnidOldHost,&pNTEntry)) == DPN_OK)
	{
		CConnection	*pConnection;

		pConnection = NULL;

		pNTEntry->Lock();
		if (pNTEntry->GetDestroyReason() == 0)
		{
			pNTEntry->SetDestroyReason( DPNDESTROYPLAYERREASON_NORMAL );
		}
		pNTEntry->Unlock();

		if ((hResultCode = pNTEntry->GetConnectionRef( &pConnection )) == DPN_OK)
		{
			if (pConnection->IsConnected())
			{
				pConnection->Disconnect();
			}
			pConnection->Release();
			pConnection = NULL;
		}

		pNTEntry->Release();
		pNTEntry = NULL;

		DNASSERT( pConnection == NULL );
	}

	//
	//	Get new host entry
	//
	if ((hResultCode = pdnObject->NameTable.FindEntry(pInfo->dpnidNewHost,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not find new host NameTableEntry");
		DisplayDNError(0,hResultCode);
		hResultCode = DPN_OK;
		goto Failure;
	}

	//
	//	Set HOST_MIGRATE status on DirectNet object
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_CLOSING)
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		hResultCode = DPN_OK;
		goto Failure;
	}
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_HOST_MIGRATING)
	{
		//
		//	If we are already host migrating, ensure that this message
		//	is not from on older host than we expect.  If it is, we
		//	will ignore it, and continue
		//
		DNASSERT(pdnObject->pNewHost != NULL);
		if (pdnObject->pNewHost->GetVersion() > pNTEntry->GetVersion())
		{
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
			hResultCode = DPN_OK;
			goto Failure;
		}
		pdnObject->pNewHost->Release();
		pdnObject->pNewHost = NULL;
	}
	pdnObject->dwFlags |= DN_OBJECT_FLAG_HOST_MIGRATING;
	DNASSERT( pdnObject->pNewHost == NULL );
	pNTEntry->AddRef();
	pdnObject->pNewHost = pNTEntry;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	// Delete old host
	pdnObject->NameTable.DeletePlayer(pInfo->dpnidOldHost,NULL);

	// 
	// Indicate to lobby (if there is one) that a host migration has occured
	//
	DNUpdateLobbyStatus(pdnObject,DPLSESSION_HOSTMIGRATED);		

	//
	//	Make new host
	//
	pdnObject->NameTable.UpdateHostPlayer( pNTEntry );

	//
	//	We will need to wait for all threads performing name table operations to finish running
	//	before we send the current name table version to the host player
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pdnObject->dwFlags |= DN_OBJECT_FLAG_HOST_MIGRATING_WAIT;
	pdnObject->dwWaitingThreadID = GetCurrentThreadId();
	if (pdnObject->dwRunningOpCount > 0)
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		DPFX(DPFPREP,7,"Waiting for running threads to finish");
		WaitForSingleObject(pdnObject->hRunningOpEvent,INFINITE);
		DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	}
	else
	{
		DPFX(DPFPREP,7,"No running threads to wait for");
	}
	if (pdnObject->dwWaitingThreadID == GetCurrentThreadId())
	{
		CBilink			*pBilink;
		CNameTableOp	*pNTOp;

		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

		//
		//	Clean-up outstanding operations
		//
		DPFX(DPFPREP,7,"Cleaning up outstanding NameTable operations");
		pdnObject->NameTable.WriteLock();
		DPFX(DPFPREP,7,"NameTable version [%ld]",pdnObject->NameTable.GetVersion());
		pBilink = pdnObject->NameTable.m_bilinkNameTableOps.GetNext();
		while (pBilink != &pdnObject->NameTable.m_bilinkNameTableOps)
		{
			pNTOp = CONTAINING_OBJECT(pBilink,CNameTableOp,m_bilinkNameTableOps);
			pBilink = pBilink->GetNext();
			if (pNTOp->GetVersion() > pdnObject->NameTable.GetVersion())
			{
				DPFX(DPFPREP,7,"Removing outstanding operation [0x%p], version [%ld]",pNTOp,pNTOp->GetVersion());
				pNTOp->m_bilinkNameTableOps.RemoveFromList();
				if (pNTOp->GetRefCountBuffer())
				{
					pNTOp->GetRefCountBuffer()->Release();
					pNTOp->SetRefCountBuffer( NULL );
				}
				if (pNTOp->GetSP())
				{
					pNTOp->GetSP()->Release();
					pNTOp->SetSP( NULL );
				}
				pNTOp->ReturnSelfToPool();
			}
			pNTOp = NULL;
		}
		pdnObject->NameTable.Unlock();

		DNEnterCriticalSection(&pdnObject->csDirectNetObject);
		pdnObject->dwFlags &= (~DN_OBJECT_FLAG_HOST_MIGRATING_WAIT);
		pdnObject->dwWaitingThreadID = 0;
		ResetEvent(pdnObject->hRunningOpEvent);
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
	}
	else
	{
		//
		//	Don't continue because a newer host migration on another thread is now waiting
		//
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		DPFX(DPFPREP,7,"Looks like a newer host migration is running - exiting");
		goto Failure;
	}

	//
	//	Send NameTable version to Host player
	//
	DNNTPlayerSendVersion(pdnObject);

	pNTEntry->Release();
	pNTEntry = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	goto Exit;
}


//	DNProcessHostMigration2
//
//	Send Host player NameTable entries missing from its (Host's) NameTable	

#undef DPF_MODNAME
#define DPF_MODNAME "DNProcessHostMigration2"

HRESULT	DNProcessHostMigration2(DIRECTNETOBJECT *const pdnObject,
								void *const pMsg)
{
	HRESULT			hResultCode;
	DWORD			dwAckMsgSize;
	CBilink			*pBilink;
	CNameTableEntry	*pHostPlayer;
	CConnection		*pConnection;
	CRefCountBuffer	*pRefCountBuffer;
	CPackedBuffer	PackedBuffer;
	CNameTableOp	*pNTOp;
	DN_NAMETABLE_OP_INFO					*pInfo;
	UNALIGNED DN_INTERNAL_MESSAGE_REQ_NAMETABLE_OP	*pReq;
	DN_INTERNAL_MESSAGE_ACK_NAMETABLE_OP	*pAck;

	DPFX(DPFPREP, 6,"Parameters: pMsg [0x%p]",pMsg);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pMsg != NULL);

	pHostPlayer = NULL;
	pConnection = NULL;
	pRefCountBuffer = NULL;

	pReq = static_cast<DN_INTERNAL_MESSAGE_REQ_NAMETABLE_OP*>(pMsg);

	DPFX(DPFPREP, 5,"Host requested NameTable ops [%ld] to [%ld]",
			pReq->dwVersion,pdnObject->NameTable.GetVersion());

	//
	//	Determine ACK message size
	//
	pdnObject->NameTable.ReadLock();
	DNASSERT(pdnObject->NameTable.GetVersion() >= pReq->dwVersion);
	dwAckMsgSize = sizeof(DN_INTERNAL_MESSAGE_ACK_NAMETABLE_OP);			// Number of entries
	dwAckMsgSize +=	((pdnObject->NameTable.GetVersion() - pReq->dwVersion + 1)	// Message info
			* sizeof(DN_NAMETABLE_OP_INFO));

	pBilink = pdnObject->NameTable.m_bilinkNameTableOps.GetNext();
	while (pBilink != &pdnObject->NameTable.m_bilinkNameTableOps)
	{
		pNTOp = CONTAINING_OBJECT(pBilink,CNameTableOp,m_bilinkNameTableOps);
		if ((pNTOp->GetVersion() >= pReq->dwVersion) && (pNTOp->GetVersion() <= pdnObject->NameTable.GetVersion()))
		{
			DNASSERT(pNTOp->GetRefCountBuffer() != NULL);
			dwAckMsgSize += pNTOp->GetRefCountBuffer()->GetBufferSize();
		}
		pBilink = pBilink->GetNext();
	}

	//
	//	Create ACK buffer
	//
	if ((hResultCode = RefCountBufferNew(pdnObject,dwAckMsgSize,&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not create RefCount buffer for NameTable re-sync ACK");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		pdnObject->NameTable.Unlock();
		goto Failure;
	}
	PackedBuffer.Initialize(pRefCountBuffer->GetBufferAddress(),pRefCountBuffer->GetBufferSize());
	pAck = reinterpret_cast<DN_INTERNAL_MESSAGE_ACK_NAMETABLE_OP *>(pRefCountBuffer->GetBufferAddress());

	// Header
	pAck->dwNumEntries = pdnObject->NameTable.GetVersion() - pReq->dwVersion + 1;
	PackedBuffer.AddToFront(NULL,sizeof(DN_INTERNAL_MESSAGE_ACK_NAMETABLE_OP));

	// Offset list
	pInfo = reinterpret_cast<DN_NAMETABLE_OP_INFO*>(PackedBuffer.GetHeadAddress());
	PackedBuffer.AddToFront(NULL,pAck->dwNumEntries * sizeof(DN_NAMETABLE_OP_INFO));

	// Messages
	pBilink = pdnObject->NameTable.m_bilinkNameTableOps.GetNext();
	while (pBilink != &pdnObject->NameTable.m_bilinkNameTableOps)
	{
		pNTOp = CONTAINING_OBJECT(pBilink,CNameTableOp,m_bilinkNameTableOps);
		if ((pNTOp->GetVersion() >= pReq->dwVersion) && (pNTOp->GetVersion() <= pdnObject->NameTable.GetVersion()))
		{
			DNASSERT(pNTOp->GetRefCountBuffer() != NULL);
			if ((hResultCode = PackedBuffer.AddToBack(pNTOp->GetRefCountBuffer()->GetBufferAddress(),
					pNTOp->GetRefCountBuffer()->GetBufferSize())) != DPN_OK)
			{
				DPFERR("Could not fill NameTable re-sync ACK");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
				pdnObject->NameTable.Unlock();
				goto Failure;
			}
			pInfo->dwMsgId = pNTOp->GetMsgId();
			pInfo->dwOpOffset = PackedBuffer.GetTailOffset();
			pInfo->dwOpSize = pNTOp->GetRefCountBuffer()->GetBufferSize();
			pInfo++;
		}
		pBilink = pBilink->GetNext();
	}
	pdnObject->NameTable.Unlock();

	// Send ACK buffer
	if ((hResultCode = pdnObject->NameTable.GetHostPlayerRef( &pHostPlayer )) != DPN_OK)
	{
		DPFERR("Could not find Host player");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	if ((hResultCode = pHostPlayer->GetConnectionRef( &pConnection )) != DPN_OK)
	{
		DPFERR("Could not get Connection reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	hResultCode = DNSendMessage(pdnObject,
								pConnection,
								DN_MSG_INTERNAL_ACK_NAMETABLE_OP,
								pHostPlayer->GetDPNID(),
								pRefCountBuffer->BufferDescAddress(),
								pRefCountBuffer,
								0,
								DN_SENDFLAGS_RELIABLE,
								NULL,
								NULL);
	if (hResultCode != DPNERR_PENDING)
	{
		DPFERR("Could not send NameTable re-sync ACK");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

	pRefCountBuffer->Release();		// Added 19/07/00 MJN - Is this needed ?
	pRefCountBuffer = NULL;
	pConnection->Release();
	pConnection = NULL;
	pHostPlayer->Release();
	pHostPlayer = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pHostPlayer)
	{
		pHostPlayer->Release();
		pHostPlayer = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	goto Exit;
}


//	DNProcessHostMigration3
//
//	

#undef DPF_MODNAME
#define DPF_MODNAME "DNProcessHostMigration3"

HRESULT	DNProcessHostMigration3(DIRECTNETOBJECT *const pdnObject,
								const DPNID dpnid)
{
	HRESULT		hResultCode;
	CNameTableEntry	*pNTEntry;

	DPFX(DPFPREP, 6,"Parameters: dpnid [0x%lx]",dpnid);

	pNTEntry = NULL;

	// No longer in Host migration mode
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pdnObject->dwFlags &= (~DN_OBJECT_FLAG_HOST_MIGRATING);
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_CLOSING)
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		hResultCode = DPN_OK;
		goto Exit;
	}

	//
	//	If we receive a HOST_MIGRATION_COMPLETE, we need to ensure that it is for the current host migration,
	//	and that another one hasn't started after.
	//	If this is the correct new host (i.e. pdnObject->pNewHost != NULL and DPNID's match),
	//	then we will continue.  Otherwise, we will exit this function.
	//
	if (pdnObject->pNewHost)
	{
		if (pdnObject->pNewHost->GetDPNID() == dpnid)
		{
			pNTEntry = pdnObject->pNewHost;
			pdnObject->pNewHost = NULL;
		}
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;

		//
		//	Complete outstanding operations
		//
		DPFX(DPFPREP, 7,"Completing outstanding operations");
		hResultCode = DNCompleteOutstandingOperations(pdnObject);
	}
	else
	{
		DPFX(DPFPREP,7,"Host migration completed by wrong new host - ignore and continue");
	}

	hResultCode = DPN_OK;

Exit:
	DNASSERT( pNTEntry == NULL );

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//	DNCompleteOutstandingOperations
//
//	We will attempt to complete any outstanding asynchronous NameTable operations
//	(i.e. create/destroy group, add/delete player to/from group, update info).
//	If we are the Host player,
//		- try processing the request directly
//		- release the async op to generate completions
//	Otherwise
//		- resend the request to the Host

#undef DPF_MODNAME
#define DPF_MODNAME "DNCompleteOutstandingOperations"

HRESULT DNCompleteOutstandingOperations(DIRECTNETOBJECT *const pdnObject)
{
	HRESULT			hResultCode;
	CBilink			*pBilink;
	CAsyncOp		*pAsyncOp;
	CAsyncOp		*pSend;
	CAsyncOp		**RequestList;
	CConnection		*pConnection;
	CNameTableEntry	*pHostPlayer;
	CNameTableEntry	*pLocalPlayer;
	DN_SEND_OP_DATA	*pSendOpData;
	DWORD			dwCount;
	DWORD			dwActual;

	DPFX(DPFPREP, 6,"Parameters: none");

	DNASSERT(pdnObject != NULL);

	pAsyncOp = NULL;
	pSend = NULL;
	RequestList = NULL;
	pConnection = NULL;
	pHostPlayer = NULL;
	pLocalPlayer = NULL;

	//
	//	Get Host connection
	//
	if ((hResultCode = pdnObject->NameTable.GetHostPlayerRef( &pHostPlayer )) != DPN_OK)
	{
		DPFERR("Could not get host player reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	if ((hResultCode = pHostPlayer->GetConnectionRef( &pConnection )) != DPN_OK)
	{
		DPFERR("Could not get host connection reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pHostPlayer->Release();
	pHostPlayer = NULL;

	//
	//	Get local player
	//
	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	dwCount = 0;
	dwActual = 0;

	//
	//	Determine outstanding request list size and build it
	//
	DNEnterCriticalSection(&pdnObject->csActiveList);
	pBilink = pdnObject->m_bilinkRequestList.GetNext();
	while (pBilink != &pdnObject->m_bilinkRequestList)
	{
		dwCount++;
		pBilink = pBilink->GetNext();
	}
	if (dwCount > 0)
	{
		if ((RequestList = static_cast<CAsyncOp**>(MemoryBlockAlloc(pdnObject,dwCount * sizeof(CAsyncOp*)))) == NULL)
		{
			DNLeaveCriticalSection(&pdnObject->csAsyncOperations);
			DPFERR("Could not allocate request list");
			hResultCode = DPNERR_OUTOFMEMORY;
			goto Failure;
		}
		pBilink = pdnObject->m_bilinkRequestList.GetNext();
		while (pBilink != &pdnObject->m_bilinkRequestList)
		{
			pAsyncOp = CONTAINING_OBJECT(pBilink,CAsyncOp,m_bilinkActiveList);
			DNASSERT(dwActual < dwCount);
			DNASSERT(pAsyncOp->GetOpType() == ASYNC_OP_REQUEST);
			pAsyncOp->AddRef();
			RequestList[dwActual] = pAsyncOp;
			pAsyncOp = NULL;
			dwActual++;
			pBilink = pBilink->GetNext();
		}
	}
	DNLeaveCriticalSection(&pdnObject->csActiveList);

	//
	//	Perform outstanding requests
	//

	if (RequestList)
	{
		DWORD	dw;

		for ( dw = 0 ; dw < dwActual ; dw++ )
		{
			pSendOpData = static_cast<DN_SEND_OP_DATA*>(RequestList[dw]->GetOpData());
			if (	pSendOpData->dwMsgId == DN_MSG_INTERNAL_REQ_CREATE_GROUP
				||	pSendOpData->dwMsgId == DN_MSG_INTERNAL_REQ_DESTROY_GROUP
				||	pSendOpData->dwMsgId == DN_MSG_INTERNAL_REQ_ADD_PLAYER_TO_GROUP
				||	pSendOpData->dwMsgId == DN_MSG_INTERNAL_REQ_DELETE_PLAYER_FROM_GROUP
				||	pSendOpData->dwMsgId == DN_MSG_INTERNAL_REQ_UPDATE_INFO
				||	pSendOpData->dwMsgId == DN_MSG_INTERNAL_REQ_INTEGRITY_CHECK)
			{
				DPFX(DPFPREP, 7,"Found outstanding operation: dwMsgId [0x%lx]",pSendOpData->dwMsgId);

				if (pLocalPlayer->IsHost())
				{
					//
					//	Remove request from request list
					//
					DNEnterCriticalSection(&pdnObject->csActiveList);
					RequestList[dw]->m_bilinkActiveList.RemoveFromList();
					DNLeaveCriticalSection(&pdnObject->csActiveList);

					hResultCode = DNHostProcessRequest(	pdnObject,
														pSendOpData->dwMsgId,
														pSendOpData->BufferDesc[1].pBufferData,
														pLocalPlayer->GetDPNID() );
				}
				else
				{
					//
					//	re-SEND REQUEST
					//
					hResultCode = DNPerformChildSend(	pdnObject,
														RequestList[dw],
														pConnection,
														0,
														&pSend,
														TRUE);
					if (hResultCode == DPNERR_PENDING)
					{
						//
						//	Reset SEND AsyncOp to complete apropriately.
						//
						pSend->SetCompletion( DNCompleteSendRequest );

						pSend->Release();
						pSend = NULL;
					}
				}
			}
			RequestList[dw]->Release();
			RequestList[dw] = NULL;
		}
		MemoryBlockFree(pdnObject,RequestList);
		RequestList = NULL;
	}

	pLocalPlayer->Release();
	pLocalPlayer = NULL;
	pConnection->Release();
	pConnection = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	if (pHostPlayer)
	{
		pHostPlayer->Release();
		pHostPlayer = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	if (RequestList)
	{
		MemoryBlockFree(pdnObject,RequestList);
		RequestList = NULL;
	}
	goto Exit;
}


//	DNCheckReceivedAllVersions
//
//	Check to see if all players in the NameTable have returned their
//	NameTable versions.  If so, ensure the NameTables are re-sync'd and
//	then finish the Host migration

#undef DPF_MODNAME
#define DPF_MODNAME "DNCheckReceivedAllVersions"

HRESULT DNCheckReceivedAllVersions(DIRECTNETOBJECT *const pdnObject)
{
	HRESULT			hResultCode;
	CBilink			*pBilink;
	CNameTableEntry	*pNTEntry;
	BOOL			bNotReady;

	DPFX(DPFPREP, 6,"Parameters: (none)");

	DNASSERT(pdnObject != NULL);

	bNotReady = FALSE;
	pdnObject->NameTable.ReadLock();
	pBilink = pdnObject->NameTable.m_bilinkPlayers.GetNext();
	while ((pBilink != &pdnObject->NameTable.m_bilinkPlayers) && (!bNotReady))
	{
		pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
		pNTEntry->Lock();
		if (!pNTEntry->IsDisconnecting() && (pNTEntry->GetLatestVersion() == 0))
		{
			//
			//	Ensure that we are not including dropped/disconnected players who have yet to be processed
			//
			CConnection	*pConnection;

			pConnection = NULL;

			pNTEntry->Unlock();
			if ((hResultCode = pNTEntry->GetConnectionRef( &pConnection )) == DPN_OK)
			{
				if (!pConnection->IsDisconnecting() && !pConnection->IsInvalid())
				{
					DPFX(DPFPREP, 7,"Player [0x%lx] has not returned dwLatestVersion",pNTEntry->GetDPNID());
					bNotReady = TRUE;	// these must all be non-zero
				}
				pConnection->Release();
				pConnection = NULL;
			}
		}
		else
		{
			pNTEntry->Unlock();
		}
		pNTEntry = NULL;

		pBilink = pBilink->GetNext();
	}
	pdnObject->NameTable.Unlock();

	if (bNotReady)
	{
		DPFX(DPFPREP, 7,"All players have not responded");
		return(DPNERR_PENDING);
	}

	//
	//	Ensure only one thread runs this from here on out
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_HOST_MIGRATING_2)
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		DPFX(DPFPREP, 7,"Another thread will proceed with Host Migration - returning");
		hResultCode = DPN_OK;
		goto Exit;
	}
	pdnObject->dwFlags |= DN_OBJECT_FLAG_HOST_MIGRATING_2;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	DPFX(DPFPREP, 7,"All players have responded - host migration stage 1 complete");
	hResultCode = DNPerformHostMigration2(pdnObject);

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//	DNCleanUpNameTable
//
//	Clean up the NameTable.
//	There are some cases where dropped players are not properly removed from the NameTable.
//		An example is when the Host-elect drops right after the Host before it has a chance
//		to send out a HOST_MIGRATE message.  In this case, since the HOST_MIGRATE message
//		implicitly includes the DELETE_PLAYER message for the original Host, the original
//		Host player never gets removed from current players' NameTables, though it DOES get
//		marked as DISCONNECTING.
//	Delete all DISCONNECTING players with older NameTable versions than ourselves.
//	Players with newer NameTable versions imply WE are the Host player, so we will
//		take care of them later (Pending Operations)

#undef DPF_MODNAME
#define DPF_MODNAME "DNCleanUpNameTable"

HRESULT DNCleanUpNameTable(DIRECTNETOBJECT *const pdnObject)
{
	HRESULT			hResultCode;
	CBilink			*pBilink;
	CNameTableEntry	*pNTEntry;
	DPNID			*List;
	DWORD			dwCount;
	DWORD			dwActual;
	DWORD			dw;

	DPFX(DPFPREP, 6,"Parameters: (none)");

	DNASSERT(pdnObject != NULL);

	List = NULL;

	//
	//	Create list of old player DPNID's
	//
	dwCount = 0;
	dwActual = 0;
	pdnObject->NameTable.ReadLock();
	pBilink = pdnObject->NameTable.m_bilinkPlayers.GetNext();
	while (pBilink != &pdnObject->NameTable.m_bilinkPlayers)
	{
		pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
		pNTEntry->Lock();
		if (pNTEntry->IsDisconnecting() && (pNTEntry->GetVersion() < pdnObject->NameTable.GetLocalPlayer()->GetVersion()))
		{
			DPFX(DPFPREP, 7,"Found old player [0x%lx]",pNTEntry->GetDPNID());
			dwCount++;
		}
		pNTEntry->Unlock();

		pBilink = pBilink->GetNext();
	}
	if (dwCount)
	{
		if ((List = static_cast<DPNID*>(DNMalloc(dwCount * sizeof(DPNID*)))) != NULL)
		{
			pBilink = pdnObject->NameTable.m_bilinkPlayers.GetNext();
			while (pBilink != &pdnObject->NameTable.m_bilinkPlayers)
			{
				pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
				pNTEntry->Lock();
				if (pNTEntry->IsDisconnecting() && (pNTEntry->GetVersion() < pdnObject->NameTable.GetLocalPlayer()->GetVersion()))
				{
					DNASSERT(dwActual < dwCount);
					List[dwActual] = pNTEntry->GetDPNID();
					dwActual++;
				}
				pNTEntry->Unlock();

				pBilink = pBilink->GetNext();
			}
		}
	}
	pdnObject->NameTable.Unlock();

	//
	//	Remove old players
	//
	if (List)
	{
		for (dw = 0 ; dw < dwActual ; dw++)
		{
			DPFX(DPFPREP, 7,"Removing old player [0x%lx]",List[dw]);
			DNHostDisconnect(pdnObject,List[dw],DPNDESTROYPLAYERREASON_HOSTDESTROYEDPLAYER);
			List[dw] = 0;
		}

		DNFree(List);
		List = NULL;
	}

	hResultCode = DPN_OK;

	DNASSERT(List == NULL);

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//	DNSendHostMigrateCompleteMessage
//
//	Send a HOST_MIGRATE_COMPLETE message to connected players

#undef DPF_MODNAME
#define DPF_MODNAME "DNSendHostMigrateCompleteMessage"

HRESULT	DNSendHostMigrateCompleteMessage(DIRECTNETOBJECT *const pdnObject)
{
	HRESULT		hResultCode;
	CAsyncOp	*pParent;
	CBilink		*pBilink;
	CNameTableEntry	*pNTEntry;
	CConnection	*pConnection;

	DPFX(DPFPREP, 6,"Parameters: (none)");

	DNASSERT(pdnObject != NULL);

	pParent = NULL;
	pNTEntry = NULL;
	pConnection = NULL;

	hResultCode = DNCreateSendParent(	pdnObject,
										DN_MSG_INTERNAL_HOST_MIGRATE_COMPLETE,
										NULL,
										DN_SENDFLAGS_RELIABLE,
										&pParent);
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not create AsyncOp");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

	//
	//	Lock NameTable
	//
	pdnObject->NameTable.ReadLock();

	pBilink = pdnObject->NameTable.m_bilinkPlayers.GetNext();
	while (pBilink != &pdnObject->NameTable.m_bilinkPlayers)
	{
		pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
		if (!pNTEntry->IsDisconnecting() && !pNTEntry->IsLocal())
		{
			if ((hResultCode = pNTEntry->GetConnectionRef( &pConnection )) == DPN_OK)
			{
				hResultCode = DNPerformChildSend(	pdnObject,
													pParent,
													pConnection,
													0,
													NULL,
													TRUE);
				if (hResultCode != DPNERR_PENDING)
				{
					DPFERR("Could not perform part of group send - ignore and continue");
					DisplayDNError(0,hResultCode);
				}
				pConnection->Release();
				pConnection = NULL;
			}
		}

		pBilink = pBilink->GetNext();
	}

	//
	//	Unlock NameTable
	//
	pdnObject->NameTable.Unlock();

	pParent->Release();
	pParent = NULL;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pParent)
	{
		pParent->Release();
		pParent = NULL;
	}
	goto Exit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\nametable.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       NameTable.cpp
 *  Content:    NameTable Object
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/11/00	mjn		Created
 *	04/09/00	mjn		Track outstanding connections in NameTable
 *	04/18/00	mjn		CConnection tracks connection status better
 *	04/19/00	mjn		PopulateConnection makes the ALL_PLAYERS link valid before posting ADD_PLAYER
 *	05/03/00	mjn		Implemented GetHostPlayerRef, GetLocalPlayerRef, GetAllPlayersGroupRef
 *	05/08/00	mjn		PopulateConnection() only sets the player's connection if it was previously NULL
 *	05/10/00	mjn		Release NameTableEntry lock during notifications in PopulateConnection()
 *	05/16/00	mjn		Ensure dpnidGroup is actually a group in IsMember()
 *				mjn		Better use of locks when clearing short-cut pointers
 *	05/25/00	mjn		Fixed infinite loop in UpdateTable()
 *	06/01/00	mjn		Added code to validate NameTable array
 *	06/02/00	mjn		Fixed logic in GrowNameTable() to handle case of existing free entries
 *	06/07/00	mjn		Fixed logic in UpdateTable() to adjust m_dwLastFreeEntry correctly
 *	06/22/00	mjn		UnpackNameTableInfo() returns local players DPNID
 *	06/29/00	mjn		64-bit build fixes (2)
 *	07/06/00	mjn		Fixed locking problem in CNameTable::MakeLocalPlayer,MakeHostPlayer,MakeAllPlayersGroup
 *	07/07/00	mjn		Fixed validation error in FindEntry()
 *	07/20/00	mjn		Cleaned up CConnection refcounts and added attempted disconnects
 *				mjn		Added ClearHostWithDPNID()
 *	07/21/00	mjn		Fixed DeletePlayer() to properly handle deleted unconnected players
 *	07/26/00	mjn		Moved initialization code from contructor to Initialize()
 *				mjn		Allow DPNID=0 for FindEntry(), but return DPNERR_DOESNOTEXIST
 *	07/30/00	mjn		Set reason codes for destroying players and groups
 *				mjn		Added hrReason to CNameTable::EmptyTable() and extended clean-up to include short-cut pointers
 *	08/02/00	mjn		Dequeue queued messages when propagating CREATE_PLAYER message
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *				mjn		AddPlayerToGroup() does a duplicate check
 *	08/07/00	mjn		Wait until player to be  added to groups before reducing outstanding connections in PopulateConnection()
 *	08/15/00	mjn		Keep group on CGroupConnection objects
 *				mjn		Clear pGroupConnection from CGroupMembership when removing players from groups
 *	08/23/00	mjn		Added CNameTableOp
 *	09/04/00	mjn		Added CApplicationDesc
 *	09/05/00	mjn		Added m_dpnidMask
 *				mjn		Removed dwIndex from InsertEntry()
 *	09/06/00	mjn		Remove queued messages in EmptyTable() and DeletePlayer()
 *	09/14/00	mjn		Added missing pGroupMember->AddRef() in PopulateConnection()
 *	09/17/00	mjn		Split m_bilinkEntries into m_bilinkPlayers and m_bilinkGroups
 *				mjn		Changed AddPlayerToGroup and RemovePlayerFromGroup to use NameTableEntry params
 *	09/26/00	mjn		Assume NameTable locks are taken for AddMembership() and RemoveMembership()
 *				mjn		Attempt to disconnect client from Host in EmptyTable()
 *	09/28/00	mjn		Autodestruct groups in DeletePlayer()
 *	10/18/00	mjn		Reset m_lOutstandingConnections in UnpackNameTableInfo()
 *	01/11/00	mjn		Proper clean up for indicated but not created players in DeletePlayer()
 *	01/25/01	mjn		Fixed 64-bit alignment problem when unpacking NameTable
 *	06/02/01	mjn		Remove receive buffers from active list in EmptyTable()
 *	06/03/01	mjn		Complete and orphan connect parent before releasing in DecOutstandingConnections()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************

#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::Initialize"

HRESULT CNameTable::Initialize(DIRECTNETOBJECT *const pdnObject)
{
	m_pdnObject = NULL;
	m_dpnidMask = 0;
	m_pDefaultPlayer = NULL;
	m_pLocalPlayer = NULL;
	m_pHostPlayer = NULL;
	m_pAllPlayersGroup = NULL;
	m_NameTableArray = NULL;
	m_dwNameTableSize = 0;
	m_dwFirstFreeEntry = 0;
	m_dwLastFreeEntry = 0;
	m_dwNumFreeEntries = 0;
	m_dwVersion = 1;
	m_dwLatestVersion = 0;
	m_dwConnectVersion = 0;
	m_lOutstandingConnections = 0;
	m_bilinkPlayers.Initialize();
	m_bilinkGroups.Initialize();
	m_bilinkDeleted.Initialize();
	m_bilinkNameTableOps.Initialize();

	if (!m_RWLock.Init())
	{
		return(DPNERR_OUTOFMEMORY);
	}

	if (NameTableEntryNew(pdnObject,&m_pDefaultPlayer) != DPN_OK)
	{
		return(DPNERR_OUTOFMEMORY);
	}

	m_pdnObject = pdnObject;

	return(DPN_OK);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::Deinitialize"

void CNameTable::Deinitialize( void )
{
	if (m_NameTableArray)
	{
		DNFree(m_NameTableArray);
		m_NameTableArray = NULL;
	}

	m_pDefaultPlayer->Release();
	m_pDefaultPlayer = NULL;

	DNASSERT(m_bilinkPlayers.IsEmpty());
	DNASSERT(m_bilinkGroups.IsEmpty());
	DNASSERT(m_bilinkDeleted.IsEmpty());
	DNASSERT(m_bilinkNameTableOps.IsEmpty());

	DNASSERT(m_pDefaultPlayer == NULL);
	DNASSERT(m_pLocalPlayer == NULL);
	DNASSERT(m_pHostPlayer == NULL);
	DNASSERT(m_NameTableArray == NULL);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::ValidateArray"

void CNameTable::ValidateArray( void )
{
#ifdef	DEBUG
	DWORD	dw;
	DWORD	dwFreeEntries;

	ReadLock();

	//
	//	Ensure free entry count is correct
	//
	dwFreeEntries = 0;
#ifdef	VANCEO
	for (dw = 2 ; dw < m_dwNameTableSize ; dw++)
#else
	for (dw = 1 ; dw < m_dwNameTableSize ; dw++)
#endif
	{
		if (!(m_NameTableArray[dw].dwFlags & NAMETABLE_ARRAY_ENTRY_FLAG_VALID))
		{
			dwFreeEntries++;
		}
	}
	if (dwFreeEntries != m_dwNumFreeEntries)
	{
		DPFERR("Incorrect number of free entries in NameTable");
		DNASSERT(FALSE);
	}

	//
	//	Ensure free list integrity
	//
	if (m_dwNumFreeEntries)
	{
		dwFreeEntries = 0;
		dw = m_dwFirstFreeEntry;
		do
		{
			if (m_NameTableArray[dw].dwFlags & NAMETABLE_ARRAY_ENTRY_FLAG_VALID)
			{
				DPFERR("Valid entry in NameTable array free list");
				DNASSERT(FALSE);
			}
			dwFreeEntries++;
			dw = static_cast<DWORD>(reinterpret_cast<DWORD_PTR>(m_NameTableArray[dw].pNameTableEntry));
		} while (dw != 0);

		if (dwFreeEntries != m_dwNumFreeEntries)
		{
			DPFERR("Incorrect number of free entries in NameTable array free list");
			DNASSERT(FALSE);
		}
	}

	Unlock();
#endif
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::GrowNameTable"

HRESULT CNameTable::GrowNameTable( void )
{
	NAMETABLE_ARRAY_ENTRY *pNewArray;
	DWORD			dwNewSize;
	DWORD			dw;

	if (m_dwNameTableSize == 0)
	{
		dwNewSize = 2;
	}
	else
	{
		dwNewSize = m_dwNameTableSize * 2;
	}

	// Allocate new array
	pNewArray = static_cast<NAMETABLE_ARRAY_ENTRY*>(DNMalloc(sizeof(NAMETABLE_ARRAY_ENTRY) * dwNewSize));
	if (pNewArray == NULL)
	{
		return(DPNERR_OUTOFMEMORY);
	}

	// Copy old array to new array
	for (dw = 0 ; dw < m_dwNameTableSize ; dw++)
	{
		pNewArray[dw].pNameTableEntry = m_NameTableArray[dw].pNameTableEntry;
		pNewArray[dw].dwFlags = m_NameTableArray[dw].dwFlags;
	}

	//
	//	If the array is being grown because there are no free entries, then all of the new free
	//	entries will be in the new part of the array.  Otherwise, we will need to link the old
	//	free list to the new one
	//
	if (m_dwNumFreeEntries == 0)
	{
		// All free entries at end of new array
		m_dwFirstFreeEntry = m_dwNameTableSize;
	}
	else
	{
		// Only new free entries at end of new array
		pNewArray[m_dwLastFreeEntry].pNameTableEntry = reinterpret_cast<CNameTableEntry*>(static_cast<DWORD_PTR>(m_dwNameTableSize));
	}
	m_dwLastFreeEntry = dwNewSize-1;

	// Very last FREE entry will not wrap to 0
	pNewArray[m_dwLastFreeEntry].pNameTableEntry = reinterpret_cast<CNameTableEntry*>(0);
	pNewArray[m_dwLastFreeEntry].dwFlags = 0;

	// Link new FREE entries
	for (dw = m_dwNameTableSize ; dw < m_dwLastFreeEntry ; dw++)
	{
		pNewArray[dw].pNameTableEntry = reinterpret_cast<CNameTableEntry*>(static_cast<DWORD_PTR>(dw+1));
		pNewArray[dw].dwFlags = 0;
	}

	// Update NameTable
	m_dwNumFreeEntries += (dwNewSize - m_dwNameTableSize);
	m_dwNameTableSize = dwNewSize;

	// New array
	if (m_NameTableArray)
	{
		DNFree(m_NameTableArray);
	}
	m_NameTableArray = pNewArray;

	// We will never allocate 0
	if (m_dwFirstFreeEntry == 0)
	{
		m_dwFirstFreeEntry = static_cast<DWORD>(reinterpret_cast<DWORD_PTR>(m_NameTableArray[m_dwFirstFreeEntry].pNameTableEntry));
		m_dwNumFreeEntries--;
	}

#ifdef	VANCEO
	if (m_dwFirstFreeEntry == 1)
	{
		m_dwFirstFreeEntry = static_cast<DWORD>(reinterpret_cast<DWORD_PTR>(m_NameTableArray[m_dwFirstFreeEntry].pNameTableEntry));
		m_dwNumFreeEntries--;
	}
#endif

	return(DPN_OK);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::UpdateTable"

HRESULT CNameTable::UpdateTable(const DWORD dwIndex,
								CNameTableEntry *const pNameTableEntry)
{
	BOOL	bFound;
	DWORD	dw;

	DNASSERT(dwIndex < m_dwNameTableSize);
	DNASSERT(!(m_NameTableArray[dwIndex].dwFlags & NAMETABLE_ARRAY_ENTRY_FLAG_VALID));

	if (m_dwFirstFreeEntry == dwIndex)
	{
		m_dwFirstFreeEntry = static_cast<DWORD>(reinterpret_cast<DWORD_PTR>(m_NameTableArray[m_dwFirstFreeEntry].pNameTableEntry));
		bFound = TRUE;
	}
	else
	{
		bFound = FALSE;
		dw = m_dwFirstFreeEntry;
		while (!bFound && (dw != m_dwLastFreeEntry))
		{
			if (m_NameTableArray[dw].pNameTableEntry == reinterpret_cast<CNameTableEntry*>(static_cast<DWORD_PTR>(dwIndex)))
			{
				m_NameTableArray[dw].pNameTableEntry = m_NameTableArray[dwIndex].pNameTableEntry;
				if (m_dwLastFreeEntry == dwIndex)
				{
					m_dwLastFreeEntry = dw;
				}
				bFound = TRUE;
			}
			else
			{
				dw = static_cast<DWORD>(reinterpret_cast<DWORD_PTR>(m_NameTableArray[dw].pNameTableEntry));
			}
		}
	}

	if (!bFound)
	{
		return(DPNERR_GENERIC);
	}

	pNameTableEntry->AddRef();
	m_NameTableArray[dwIndex].pNameTableEntry = pNameTableEntry;
	m_NameTableArray[dwIndex].dwFlags |= NAMETABLE_ARRAY_ENTRY_FLAG_VALID;

	//
	//	Insert into entry bilink
	//
	if (pNameTableEntry->IsGroup())
	{
		pNameTableEntry->m_bilinkEntries.InsertBefore(&m_bilinkGroups);
	}
	else
	{
		pNameTableEntry->m_bilinkEntries.InsertBefore(&m_bilinkPlayers);
	}

	m_dwNumFreeEntries--;

	return(DPN_OK);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::InsertEntry"

HRESULT CNameTable::InsertEntry(CNameTableEntry *const pNameTableEntry)
{
	HRESULT	hResultCode;
	DWORD	dwIndex;

	DNASSERT(pNameTableEntry != NULL);
	DNASSERT(pNameTableEntry->GetDPNID() != 0);

	dwIndex = DECODE_INDEX(pNameTableEntry->GetDPNID());

	WriteLock();

	while (dwIndex >= m_dwNameTableSize)
	{
		if (GrowNameTable() != DPN_OK)
		{
			Unlock();
			return(DPNERR_OUTOFMEMORY);
		}
	}

	if ((hResultCode = UpdateTable(dwIndex,pNameTableEntry)) != DPN_OK)
	{
		Unlock();
		return(DPNERR_GENERIC);
	}

	Unlock();

#ifdef	DEBUG
	ValidateArray();
#endif

	return(DPN_OK);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::ReleaseEntry"

void CNameTable::ReleaseEntry(const DWORD dwIndex)
{
	CNameTableEntry	*pNTEntry;

	DNASSERT(dwIndex != 0);

	pNTEntry = m_NameTableArray[dwIndex].pNameTableEntry;
	m_NameTableArray[dwIndex].pNameTableEntry = NULL;
	pNTEntry->m_bilinkEntries.RemoveFromList();
	pNTEntry->Release();

	if (m_dwNumFreeEntries == 0)
	{
		m_dwFirstFreeEntry = dwIndex;
	}
	else
	{
		m_NameTableArray[m_dwLastFreeEntry].pNameTableEntry = reinterpret_cast<CNameTableEntry*>(static_cast<DWORD_PTR>(dwIndex));
	}
	m_dwLastFreeEntry = dwIndex;
	m_NameTableArray[m_dwLastFreeEntry].dwFlags &= (~NAMETABLE_ARRAY_ENTRY_FLAG_VALID);
	m_dwNumFreeEntries++;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::EmptyTable"

void CNameTable::EmptyTable( const HRESULT hrReason )
{
	DWORD			dw;
	CNameTableEntry	*pNTEntry;
	DWORD			dwGroupReason;
	DWORD			dwPlayerReason;
	CBilink			*pBilink;
	CQueuedMsg		*pQueuedMsg;

	DPFX(DPFPREP, 6,"Parameters: hrReason [0x%lx]",hrReason);

	DNASSERT( (hrReason == DPN_OK) || (hrReason == DPNERR_HOSTTERMINATEDSESSION) || (hrReason == DPNERR_CONNECTIONLOST));

	if (!(m_pdnObject->dwFlags & DN_OBJECT_FLAG_CLIENT))
	{
		//
		//	Determine destruction reason to pass to application
		//
		switch (hrReason)
		{
			case DPN_OK:
				{
					dwPlayerReason = DPNDESTROYPLAYERREASON_NORMAL;
					dwGroupReason = DPNDESTROYGROUPREASON_NORMAL;
					break;
				}
			case DPNERR_HOSTTERMINATEDSESSION:
				{
					dwPlayerReason = DPNDESTROYPLAYERREASON_SESSIONTERMINATED;
					dwGroupReason = DPNDESTROYGROUPREASON_SESSIONTERMINATED;
					break;
				}
			case DPNERR_CONNECTIONLOST:
				{
					dwPlayerReason = DPNDESTROYPLAYERREASON_CONNECTIONLOST;
					dwGroupReason = DPNDESTROYGROUPREASON_NORMAL;
					break;
				}
			default:
				{
					DNASSERT( FALSE );	// Should never get here !
					dwPlayerReason = DPNDESTROYPLAYERREASON_NORMAL;
					dwGroupReason = DPNDESTROYGROUPREASON_NORMAL;
					break;
				}
		}

		//
		//	To make VanceO happy, I've agreed to pre-mark the group destructions as NORMAL,
		//	rather than AUTODESTRUCT
		//
		ReadLock();
		pBilink = m_bilinkGroups.GetNext();
		while (pBilink != &m_bilinkGroups)
		{
			pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
			pNTEntry->Lock();
			if (pNTEntry->GetDestroyReason() == 0)
			{
				pNTEntry->SetDestroyReason( dwGroupReason );
			}
			pNTEntry->Unlock();
			pNTEntry = NULL;

			pBilink = pBilink->GetNext();
		}
		Unlock();

		for (dw = 0 ; dw < m_dwNameTableSize ; dw++)
		{
			pNTEntry = NULL;
			ReadLock();
			if ((m_NameTableArray[dw].dwFlags & NAMETABLE_ARRAY_ENTRY_FLAG_VALID) &&
				(m_NameTableArray[dw].pNameTableEntry))
			{
				//
				//	Cleanup this entry (if it's not disconnecting) and then release it
				//
				m_NameTableArray[dw].pNameTableEntry->Lock();
				if (!m_NameTableArray[dw].pNameTableEntry->IsDisconnecting())
				{
					m_NameTableArray[dw].pNameTableEntry->AddRef();
					pNTEntry = m_NameTableArray[dw].pNameTableEntry;
				}
				m_NameTableArray[dw].pNameTableEntry->Unlock();
				Unlock();

				if (pNTEntry)
				{
					//
					//	Set destroy reason if required
					//
					pNTEntry->Lock();
					if (pNTEntry->GetDestroyReason() == 0)
					{
						if (pNTEntry->IsGroup())
						{
							pNTEntry->SetDestroyReason( dwGroupReason );
						}
						else
						{
							pNTEntry->SetDestroyReason( dwPlayerReason );
						}
					}
					pNTEntry->Unlock();

					//
					//	Delete entry
					//
					if (pNTEntry->IsGroup())
					{
						if (!pNTEntry->IsAllPlayersGroup())
						{
							DeleteGroup(pNTEntry->GetDPNID(),NULL);
						}
					}
					else
					{
						CConnection	*pConnection;

						pConnection = NULL;

						pNTEntry->GetConnectionRef( &pConnection );
						if (pConnection)
						{
							pConnection->Disconnect();
							pConnection->Release();
							pConnection = NULL;
						}
						DeletePlayer(pNTEntry->GetDPNID(),NULL);
					}

					pNTEntry->Release();
					pNTEntry = NULL;
				}
			}
			else
			{
				Unlock();
			}
		}


		//
		//	Set reason for short-cut pointers (if required)
		//
		ReadLock();
		if (m_pLocalPlayer)
		{
			m_pLocalPlayer->Lock();
			if (m_pLocalPlayer->GetDestroyReason() == 0)
			{
				m_pLocalPlayer->SetDestroyReason( dwPlayerReason );
			}
			m_pLocalPlayer->Unlock();
		}
		if (m_pHostPlayer)
		{
			m_pHostPlayer->Lock();
			if (m_pHostPlayer->GetDestroyReason() == 0)
			{
				m_pHostPlayer->SetDestroyReason( dwPlayerReason );
			}
			m_pHostPlayer->Unlock();
		}
		if (m_pAllPlayersGroup)
		{
			m_pAllPlayersGroup->Lock();
			if (m_pAllPlayersGroup->GetDestroyReason() == 0)
			{
				m_pAllPlayersGroup->SetDestroyReason( dwGroupReason );
			}
			m_pAllPlayersGroup->Unlock();
		}
		Unlock();
	}
	else
	{
		//
		//	Disconnect from Host and remove any queued messages from Host player (on Client)
		//
		if (GetHostPlayerRef(&pNTEntry) == DPN_OK)
		{
			CConnection	*pConnection;

			pConnection = NULL;

			pNTEntry->GetConnectionRef( &pConnection );
			if (pConnection)
			{
				pConnection->Disconnect();
				pConnection->Release();
				pConnection = NULL;
			}

			pNTEntry->Lock();
			pBilink = pNTEntry->m_bilinkQueuedMsgs.GetNext();
			while (pBilink != &pNTEntry->m_bilinkQueuedMsgs)
			{
				pQueuedMsg = CONTAINING_OBJECT(pBilink,CQueuedMsg,m_bilinkQueuedMsgs);
				pQueuedMsg->m_bilinkQueuedMsgs.RemoveFromList();
				DEBUG_ONLY(pNTEntry->m_lNumQueuedMsgs--);

				pNTEntry->Unlock();
				
				DNASSERT(pQueuedMsg->GetAsyncOp() != NULL);
				DNASSERT(pQueuedMsg->GetAsyncOp()->GetHandle() != 0);

				DNEnterCriticalSection(&m_pdnObject->csActiveList);
				pQueuedMsg->GetAsyncOp()->m_bilinkActiveList.RemoveFromList();
				DNLeaveCriticalSection(&m_pdnObject->csActiveList);

				m_pdnObject->HandleTable.Destroy( pQueuedMsg->GetAsyncOp()->GetHandle() );
				pQueuedMsg->GetAsyncOp()->Release();
				pQueuedMsg->SetAsyncOp( NULL );
				pQueuedMsg->ReturnSelfToPool();
				pQueuedMsg = NULL;

				pNTEntry->Lock();

				pBilink = pNTEntry->m_bilinkQueuedMsgs.GetNext();
			}
			pNTEntry->Unlock();
			pNTEntry->Release();
			pNTEntry = NULL;

			DNASSERT(pConnection == NULL);
		}
	}

	//
	//	Remove short-cut pointers
	//
	ClearLocalPlayer();
	ClearHostPlayer();
	ClearAllPlayersGroup();

	DPFX(DPFPREP, 6,"Returning");
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::FindEntry"

HRESULT CNameTable::FindEntry(const DPNID dpnid,
							  CNameTableEntry **const ppNameTableEntry)
{
	DWORD	dwIndex;
	HRESULT	hResultCode;

	DPFX(DPFPREP, 6,"Parameters: dpnid [0x%lx], ppNameTableEntry [0x%p]",dpnid,ppNameTableEntry);

	DNASSERT(ppNameTableEntry != NULL);

	if (dpnid == 0)
	{
		hResultCode = DPNERR_DOESNOTEXIST;
		goto Failure;
	}

	ReadLock();
	dwIndex = DECODE_INDEX(dpnid);
	if ((dwIndex >= m_dwNameTableSize)
			|| !(m_NameTableArray[dwIndex].dwFlags & NAMETABLE_ARRAY_ENTRY_FLAG_VALID)
			|| (m_NameTableArray[dwIndex].pNameTableEntry == NULL))
	{
		Unlock();
		hResultCode = DPNERR_DOESNOTEXIST;
		goto Failure;
	}

	if (!VERIFY_VERSION(dpnid,m_NameTableArray[dwIndex].pNameTableEntry->GetVersion()))
	{
		Unlock();
		hResultCode = DPNERR_DOESNOTEXIST;
		goto Failure;
	}

	m_NameTableArray[dwIndex].pNameTableEntry->AddRef();
	*ppNameTableEntry = m_NameTableArray[dwIndex].pNameTableEntry;

	Unlock();

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"hResultCode: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::FindDeletedEntry"

HRESULT	CNameTable::FindDeletedEntry(const DPNID dpnid,
									 CNameTableEntry **const ppNTEntry)
{
	HRESULT			hResultCode;
	CBilink			*pBilink;
	CNameTableEntry	*pNTEntry;

	DPFX(DPFPREP, 6,"Parameters: dpnid [0x%lx], ppNTEntry [0x%p]",dpnid,ppNTEntry);

	DNASSERT(ppNTEntry != NULL);

	pNTEntry = NULL;
	hResultCode = DPNERR_DOESNOTEXIST;

	ReadLock();
	pBilink = m_bilinkDeleted.GetNext();
	while (pBilink != &m_bilinkDeleted)
	{
		pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkDeleted);
		if (pNTEntry->GetDPNID() == dpnid)
		{
			pNTEntry->AddRef();
			hResultCode = DPN_OK;
			break;
		}
		else
		{
			pBilink = pBilink->GetNext();
			pNTEntry = NULL;
		}
	}
	Unlock();

	if (pNTEntry)
	{
		pNTEntry->AddRef();
		*ppNTEntry = pNTEntry;
		pNTEntry->Release();
		pNTEntry = NULL;
	}

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::AddEntry"

HRESULT	CNameTable::AddEntry(CNameTableEntry *const pNTEntry)
{
	DPNID	dpnid;
	DWORD	dwIndex;
	DWORD	dwVersion;
	HRESULT	hResultCode;

	WriteLock();

	//
	// Create DPNID
	//

	if (GetFreeIndex(&dwIndex) != DPN_OK)
	{
		return(DPNERR_GENERIC);
	}

	dwVersion = ++m_dwVersion;
	DPFX(DPFPREP, 8,"Setting new version [%ld]",m_dwVersion);

	dpnid = CONSTRUCT_DPNID(dwIndex,dwVersion);
	DNASSERT(dpnid != 0);

	pNTEntry->Lock();
	pNTEntry->SetDPNID(dpnid);
	pNTEntry->SetVersion(dwVersion);
	pNTEntry->Unlock();

	dwIndex = DECODE_INDEX(dpnid);
	hResultCode = UpdateTable(dwIndex,pNTEntry);

	Unlock();

#ifdef	DEBUG
	ValidateArray();
#endif

	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::DeletePlayer"

HRESULT CNameTable::DeletePlayer(const DPNID dpnid,
								 DWORD *const pdwVersion)
{
	HRESULT			hResultCode;
	CNameTableEntry	*pNTEntry;
	BOOL			fNotifyRelease;
	BOOL			fDecConnections;

	DPFX(DPFPREP, 6,"Parameters: dpnid [0x%lx], pdwVersion [0x%p]",dpnid,pdwVersion);

	pNTEntry = NULL;
	fNotifyRelease = FALSE;
	fDecConnections = FALSE;

	if ((hResultCode = FindEntry(dpnid,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Player not in NameTable");
		DisplayDNError(0,hResultCode);

		//
		//	If a version is requested, we will give one back.  This might be a host migration case
		//	in which case even though the player was removed from the NameTable, we will want to
		//	send out a DESTROY_PLAYER message with an updated version number
		//
		if (pdwVersion)
		{
			if (*pdwVersion == 0)
			{
				WriteLock();
				*pdwVersion = ++m_dwVersion;
				DPFX(DPFPREP, 8,"Setting new version [%ld]",m_dwVersion);
				Unlock();
			}
		}
		goto Failure;
	}
	DNASSERT(!pNTEntry->IsGroup());

	//
	//	Don't do anything if already disconnecting.
	//	Otherwise, set disconnecting to prevent others from cleaning up, and clean up
	//
	pNTEntry->Lock();
	if (!pNTEntry->IsDisconnecting())
	{
		pNTEntry->StartDisconnecting();
		if (pNTEntry->IsAvailable())
		{
			pNTEntry->MakeUnavailable();
		}
		if ((pNTEntry->IsCreated() || pNTEntry->IsIndicated() || pNTEntry->IsInUse()) && !pNTEntry->IsNeedToDestroy())
		{
			pNTEntry->SetNeedToDestroy();
			fNotifyRelease = TRUE;
		}
		if (	  !pNTEntry->IsCreated()
				&& pNTEntry->IsConnecting()
				&& (m_pdnObject->dwFlags & (DN_OBJECT_FLAG_CONNECTING | DN_OBJECT_FLAG_CONNECTED))
				&& (pNTEntry->GetVersion() <= m_dwConnectVersion))
		{
			fDecConnections = TRUE;
		}
		pNTEntry->Unlock();

		//
		//	Remove this player from any groups they belong to
		//
		RemoveAllGroupsFromPlayer( pNTEntry );

		//
		//	Autodestruct any groups this player owns (will also remove any players from those groups first)
		//
		if (pNTEntry->GetDPNID() != 0)
		{
			AutoDestructGroups( pNTEntry->GetDPNID() );
		}

		if (fNotifyRelease)
		{
			pNTEntry->NotifyRelease();
		}

		//
		//	Adjust player count
		//
		m_pdnObject->ApplicationDesc.DecPlayerCount();
		if (fDecConnections)
		{
			DecOutstandingConnections();
		}

		//
		//	Update version and remove from NameTable
		//
		WriteLock();
		pNTEntry->Lock();
		if ((pNTEntry->IsCreated() || pNTEntry->IsInUse()) && pNTEntry->IsNeedToDestroy())
		{
			//
			//	The DESTROY_PLAYER message has not been posted, so we will add this entry to our "deleted" list
			//	so that some future operations (get info,context,etc.) may succeed.  This entry will be removed
			//	from the list then the DESTROY_PLAYER notification is posted
			//
			pNTEntry->m_bilinkDeleted.InsertBefore(&m_bilinkDeleted);

			pNTEntry->Unlock();

			ReleaseEntry(DECODE_INDEX(dpnid));

			//
			//	Update version
			//
			if (pdwVersion)
			{
				if (*pdwVersion)
				{
					m_dwVersion = *pdwVersion;
				}
				else
				{
					*pdwVersion = ++m_dwVersion;
				}
				DPFX(DPFPREP, 8,"Setting new version [%ld]",m_dwVersion);
			}
			Unlock();
		}
		else
		{
			CBilink		*pBilink;
			CQueuedMsg	*pQueuedMsg;

			//
			//	Remove any queued messages at this stage.  A CREATE_PLAYER won't be generated, so no messages
			//	will be passed up.
			//
			//	This is probably wrong since for reliable traffic, we assume it got here
			//
			Unlock();

#pragma BUGBUG(minara,"This is probably wrong since reliable traffic should be indicated rather than just thrown away!")
			pBilink = pNTEntry->m_bilinkQueuedMsgs.GetNext();
			while (pBilink != &pNTEntry->m_bilinkQueuedMsgs)
			{
				pQueuedMsg = CONTAINING_OBJECT(pBilink,CQueuedMsg,m_bilinkQueuedMsgs);
				pQueuedMsg->m_bilinkQueuedMsgs.RemoveFromList();
				DEBUG_ONLY(pNTEntry->m_lNumQueuedMsgs--);

				pNTEntry->Unlock();
				
				DNASSERT(pQueuedMsg->GetAsyncOp() != NULL);
				DNASSERT(pQueuedMsg->GetAsyncOp()->GetHandle() != 0);

				DNDoCancelCommand( m_pdnObject,pQueuedMsg->GetAsyncOp() );

				pQueuedMsg->GetAsyncOp()->Release();
				pQueuedMsg->SetAsyncOp( NULL );
				pQueuedMsg->ReturnSelfToPool();
				pQueuedMsg = NULL;

				pNTEntry->Lock();

				pBilink = pNTEntry->m_bilinkQueuedMsgs.GetNext();
			}
			pNTEntry->Unlock();

			//
			//	Update version
			//
			WriteLock();
			ReleaseEntry(DECODE_INDEX(dpnid));
			if (pdwVersion)
			{
				if (*pdwVersion)
				{
					m_dwVersion = *pdwVersion;
				}
				else
				{
					*pdwVersion = ++m_dwVersion;
				}
				DPFX(DPFPREP, 8,"Setting new version [%ld]",m_dwVersion);
			}
			Unlock();
		}
		
		hResultCode = DPN_OK;
	}
	else
	{
		pNTEntry->Unlock();

		hResultCode = DPNERR_INVALIDPLAYER;
	}

	pNTEntry->Release();
	pNTEntry = NULL;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::DeleteGroup"

HRESULT CNameTable::DeleteGroup(const DPNID dpnid,
								DWORD *const pdwVersion)
{
	HRESULT			hResultCode;
	CNameTableEntry	*pNTEntry;
	BOOL			fNotifyRelease;

	DPFX(DPFPREP, 6,"Parameters: dpnid [0x%lx], pdwVersion [0x%p]",dpnid,pdwVersion);

	pNTEntry = NULL;
	fNotifyRelease = FALSE;

	if ((hResultCode = FindEntry(dpnid,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Player not in NameTable");
		DisplayDNError(0,hResultCode);
		return(hResultCode);
	}
	DNASSERT(pNTEntry->IsGroup() && !pNTEntry->IsAllPlayersGroup());

	//
	//	Don't do anything if already disconnecting.
	//	Otherwise, set disconnecting to prevent others from cleaning up, and clean up
	//
	pNTEntry->Lock();
	if (pNTEntry->GetDestroyReason() == 0)
	{
		//
		//	Default this if it isn't set
		//
		pNTEntry->SetDestroyReason( DPNDESTROYGROUPREASON_NORMAL );
	}
	if (!pNTEntry->IsDisconnecting())
	{
		pNTEntry->StartDisconnecting();
		if (pNTEntry->IsAvailable())
		{
			pNTEntry->MakeUnavailable();
		}
		if (pNTEntry->IsCreated() && !pNTEntry->IsNeedToDestroy())
		{
			pNTEntry->SetNeedToDestroy();
			fNotifyRelease = TRUE;
		}
		pNTEntry->Unlock();

		RemoveAllPlayersFromGroup( pNTEntry );

		if (fNotifyRelease)
		{
			pNTEntry->NotifyRelease();
		}

		//
		//	Update version and remove from NameTable
		//
		WriteLock();
		pNTEntry->Lock();
		if (pNTEntry->IsNeedToDestroy())
		{
			//
			//	The DESTROY_GROUP message has not been posted, so we will add this entry to our "deleted" list
			//	so that some future operations (get info,context,etc.) may succeed.  This entry will be removed
			//	from the list then the DESTROY_GROUP notification is posted
			//
			pNTEntry->m_bilinkDeleted.InsertBefore(&m_bilinkDeleted);
		}
		pNTEntry->Unlock();
		ReleaseEntry(DECODE_INDEX(dpnid));
		if (pdwVersion)
		{
			if (*pdwVersion)
			{
				m_dwVersion = *pdwVersion;
			}
			else
			{
				*pdwVersion = ++m_dwVersion;
			}
			DPFX(DPFPREP, 8,"Setting new version [%ld]",m_dwVersion);
		}
		Unlock();

		hResultCode = DPN_OK;
	}
	else
	{
		pNTEntry->Unlock();

		hResultCode = DPNERR_INVALIDGROUP;
	}

	pNTEntry->Release();
	pNTEntry = NULL;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::AddPlayerToGroup"

HRESULT CNameTable::AddPlayerToGroup(CNameTableEntry *const pGroup,
									 CNameTableEntry *const pPlayer,
									 DWORD *const pdwVersion)
{
	HRESULT				hResultCode;
	CGroupMember		*pGroupMember;
	CGroupConnection	*pGroupConnection;
	CConnection			*pConnection;
	BOOL				fNotifyAdd;
	BOOL				fRemove;

	DPFX(DPFPREP, 6,"Parameters: pGroup [0x%p], pPlayer [0x%p], pdwVersion [0x%p]",pGroup,pPlayer,pdwVersion);

	DNASSERT(pGroup != NULL);
	DNASSERT(pPlayer != NULL);

	pGroupConnection = NULL;
	pGroupMember = NULL;
	pConnection = NULL;

	if (!pGroup->IsGroup())
	{
		hResultCode = DPNERR_INVALIDGROUP;
		goto Failure;
	}
	if (pPlayer->IsGroup())
	{
		hResultCode = DPNERR_INVALIDPLAYER;
		goto Failure;
	}

	//
	//	Create the group connection
	//
	if ((hResultCode = GroupConnectionNew(m_pdnObject,&pGroupConnection)) != DPN_OK)
	{
		DPFERR("Could not allocate name table group connection entry from FPM");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pGroupConnection->SetGroup( pGroup );

	//
	//	Create new group membership record
	//
	if ((hResultCode = GroupMemberNew(m_pdnObject,&pGroupMember)) != DPN_OK)
	{
		DPFERR("Could not get new group member");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

	//
	//	Set group connection on group membership record
	//
	pGroupMember->SetGroupConnection(pGroupConnection);

	//
	//	Add player to group
	//
	fNotifyAdd = FALSE;
	fRemove = FALSE;
	WriteLock();
	pGroup->Lock();
	pPlayer->Lock();
	pGroupMember->Lock();
	if (!pGroup->IsDisconnecting() && !pPlayer->IsDisconnecting())
	{
		pGroupMember->MakeValid();
		pGroupMember->GetGroupConnection()->MakeValid();

		//
		//	Set group membership (checks for duplicates as well)
		//
		if ((hResultCode = pGroupMember->SetMembership(pGroup,pPlayer,pdwVersion)) != DPN_OK)
		{
			DPFERR("Could not set membership record");
			DisplayDNError(0,hResultCode);
			Unlock();
			pGroup->Unlock();
			pPlayer->Unlock();
			pGroupMember->Unlock();
			goto Failure;
		}
		//
		//	Generate notification (ALL_PLAYERS GROUP should never be "Created")
		//
		if (pGroup->IsCreated() && pPlayer->IsCreated())
		{
			//
			//	Add the player's connection to the group connection record
			//
			if (pPlayer->GetConnection() != NULL)
			{
				pGroupConnection->SetConnection( pPlayer->GetConnection() );
			}

			if (!pGroupMember->IsNeedToAdd() && !pGroupMember->IsAvailable() && pGroupMember->GetGroupConnection()->IsConnected())
			{
				pGroupMember->SetNeedToAdd();
				fNotifyAdd = TRUE;
			}
		}

		//
		//	Need to set up the group connection if this is the ALL_PLAYERS group
		//
		if (pGroup->IsAllPlayersGroup())
		{
			if (pPlayer->GetConnection() != NULL)
			{
				pGroupConnection->SetConnection( pPlayer->GetConnection() );
			}
		}

		//
		//	Prevent a DESTROY_PLAYER/DESTROY_GROUP from occurring until this GroupMember record is cleared
		//
		pGroup->NotifyAddRef();
		pPlayer->NotifyAddRef();
	}
	Unlock();
	pGroup->Unlock();
	pPlayer->Unlock();
	pGroupMember->Unlock();

	if (fNotifyAdd)
	{
		DNUserAddPlayerToGroup(m_pdnObject,pGroup,pPlayer);

		pGroupMember->Lock();
		pGroupMember->ClearNeedToAdd();
		pGroupMember->MakeAvailable();
		if (pGroupMember->IsNeedToRemove())
		{
			fRemove = TRUE;
		}
		pGroupMember->Unlock();
	}
	if (fRemove)
	{
		RemovePlayerFromGroup(pGroup,pPlayer,NULL);
	}

	pGroupConnection->Release();
	pGroupConnection = NULL;

	pGroupMember->Release();
	pGroupMember = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pGroupConnection)
	{
		pGroupConnection->Release();
		pGroupConnection = NULL;
	}
	if (pGroupMember)
	{
		pGroupMember->Release();
		pGroupMember = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::RemovePlayerFromGroup"

HRESULT CNameTable::RemovePlayerFromGroup(CNameTableEntry *const pGroup,
										  CNameTableEntry *const pPlayer,
										  DWORD *const pdwVersion)
{
	CGroupMember	*pGroupMember;
	CBilink			*pBilink;
	BOOL			fNotifyRemove;
	HRESULT			hResultCode;

	DPFX(DPFPREP, 6,"Parameters: pGroup [0x%p], pPlayer [0x%p], pdwVersion [0x%p]",pGroup,pPlayer,pdwVersion);

	DNASSERT(pGroup != NULL);
	DNASSERT(pPlayer != NULL);

	pGroupMember = NULL;
	fNotifyRemove = FALSE;

	WriteLock();
	pGroup->Lock();
	pPlayer->Lock();

	//
	//	The first order of business is to locate the GroupMembership record.
	//	We will use the player's NameTable entry and scan through the
	//	group membership bilink until we find the required entry.
	//	(We're assuming that this will be faster than going the other route.)
	//
	pBilink = pPlayer->m_bilinkMembership.GetNext();
	while (pBilink != &pPlayer->m_bilinkMembership)
	{
		pGroupMember = CONTAINING_OBJECT(pBilink,CGroupMember,m_bilinkGroups);
		if (pGroupMember->GetGroup() == pGroup)
		{
			pGroupMember->AddRef();
			break;
		}
		pGroupMember = NULL;
		pBilink = pBilink->GetNext();
	}
	if (pGroupMember == NULL)
	{
		Unlock();
		pGroup->Unlock();
		pPlayer->Unlock();
		hResultCode = DPNERR_PLAYERNOTINGROUP;
		goto Failure;
	}

	DNASSERT(pGroupMember != NULL);
	pGroupMember->Lock();

	//
	//	Ensure no one else is trying to remove this already
	//
	if (!pGroupMember->IsValid() || pGroupMember->IsNeedToRemove())
	{
		Unlock();
		pGroup->Unlock();
		pPlayer->Unlock();
		pGroupMember->Unlock();
		hResultCode = DPNERR_PLAYERNOTINGROUP;
		goto Failure;
	}
	pGroupMember->SetNeedToRemove();

	//
	//	We will only notify the application if the player is not being added to a group
	//
	if (!pGroupMember->IsNeedToAdd())
	{
		//
		//	Either this is already indicated, or is not about to be indicated, so remove it
		//	(and see if we need to generate a notification)
		//
		pGroupMember->RemoveMembership( pdwVersion );

		if (pGroupMember->IsAvailable())
		{
			pGroupMember->MakeUnavailable();
			if (!pGroup->IsAllPlayersGroup())
			{
				fNotifyRemove = TRUE;
			}
		}
	}
	Unlock();
	pGroup->Unlock();
	pPlayer->Unlock();
	pGroupMember->Unlock();

	if (fNotifyRemove)
	{
		DNUserRemovePlayerFromGroup(m_pdnObject,pGroup,pPlayer);
	}

	//
	//	Trigger a DESTROY_PLAYER/DESTROY_GROUP if this was the last member
	//
	pGroup->NotifyRelease();
	pPlayer->NotifyRelease();

	pGroupMember->Release();
	pGroupMember = NULL;

	hResultCode = DPN_OK;

Exit:
	return(hResultCode);

Failure:
	if (pGroupMember)
	{
		pGroupMember->Release();
		pGroupMember = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::RemoveAllPlayersFromGroup"

HRESULT CNameTable::RemoveAllPlayersFromGroup(CNameTableEntry *const pGroup)
{
	CNameTableEntry	**PlayerList;
	CBilink			*pBilink;
	HRESULT			hResultCode;
	DWORD			dwCount;
	DWORD			dwActual;

	DPFX(DPFPREP, 6,"Parameters: pGroup [0x%p]",pGroup);

	DNASSERT(pGroup != NULL);

	PlayerList = NULL;

	//
	//	This is not an elegant solution - we will build a list of membership records and remove each one
	//
	dwCount = 0;
	dwActual = 0;
	pGroup->Lock();
	DNASSERT(pGroup->IsDisconnecting());
	pBilink = pGroup->m_bilinkMembership.GetNext();
	while (pBilink != &pGroup->m_bilinkMembership)
	{
		dwCount++;
		pBilink = pBilink->GetNext();
	}
	if (dwCount)
	{
		CGroupMember	*pGroupMember;

		pGroupMember = NULL;

		if ((PlayerList = static_cast<CNameTableEntry**>(MemoryBlockAlloc(m_pdnObject,dwCount*sizeof(CNameTableEntry*)))) == NULL)
		{
			DPFERR("Could not allocate player list");
			hResultCode = DPNERR_OUTOFMEMORY;
			DNASSERT(FALSE);
			pGroup->Unlock();
			goto Failure;
		}
		pBilink = pGroup->m_bilinkMembership.GetNext();
		while (pBilink != &pGroup->m_bilinkMembership)
		{
			pGroupMember = CONTAINING_OBJECT(pBilink,CGroupMember,m_bilinkPlayers);

			pGroupMember->Lock();
			if (pGroupMember->IsValid() && !pGroupMember->IsNeedToRemove() && pGroupMember->GetPlayer())
			{
				DNASSERT(dwActual < dwCount);
				pGroupMember->GetPlayer()->AddRef();
				PlayerList[dwActual] = pGroupMember->GetPlayer();
				dwActual++;
			}
			pGroupMember->Unlock();

			pBilink = pBilink->GetNext();
			pGroupMember = NULL;
		}

		DNASSERT(pGroupMember == NULL);
	}
	pGroup->Unlock();

	if (PlayerList)
	{
		DWORD	dw;

		for (dw = 0 ; dw < dwActual ; dw++)
		{
			DNASSERT(PlayerList[dw] != NULL);

			RemovePlayerFromGroup(pGroup,PlayerList[dw],NULL);
			PlayerList[dw]->Release();
			PlayerList[dw] = NULL;
		}

		MemoryBlockFree(m_pdnObject,PlayerList);
		PlayerList = NULL;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (PlayerList)
	{
		MemoryBlockFree(m_pdnObject,PlayerList);
		PlayerList = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::RemoveAllGroupsFromPlayer"

HRESULT CNameTable::RemoveAllGroupsFromPlayer(CNameTableEntry *const pPlayer)
{
	CNameTableEntry	**GroupList;
	CBilink			*pBilink;
	HRESULT			hResultCode;
	DWORD			dwCount;
	DWORD			dwActual;

	DPFX(DPFPREP, 6,"Parameters: pPlayer [0x%p]",pPlayer);

	DNASSERT(pPlayer != NULL);

	GroupList = NULL;

	//
	//	This is not an elegant solution - we will build a list of membership records and remove each one
	//
	dwCount = 0;
	dwActual = 0;
	pPlayer->Lock();
	DNASSERT(pPlayer->IsDisconnecting());
	pBilink = pPlayer->m_bilinkMembership.GetNext();
	while (pBilink != &pPlayer->m_bilinkMembership)
	{
		dwCount++;
		pBilink = pBilink->GetNext();
	}
	if (dwCount)
	{
		CGroupMember	*pGroupMember;

		pGroupMember = NULL;

		if ((GroupList = static_cast<CNameTableEntry**>(MemoryBlockAlloc(m_pdnObject,dwCount*sizeof(CNameTableEntry*)))) == NULL)
		{
			DPFERR("Could not allocate member list");
			hResultCode = DPNERR_OUTOFMEMORY;
			DNASSERT(FALSE);
			pPlayer->Unlock();
			goto Failure;
		}
		pBilink = pPlayer->m_bilinkMembership.GetNext();
		while (pBilink != &pPlayer->m_bilinkMembership)
		{
			pGroupMember = CONTAINING_OBJECT(pBilink,CGroupMember,m_bilinkGroups);

			pGroupMember->Lock();
			if (pGroupMember->IsValid() && !pGroupMember->IsNeedToRemove() && pGroupMember->GetGroup())
			{
				DNASSERT(dwActual < dwCount);
				pGroupMember->GetGroup()->AddRef();
				GroupList[dwActual] = pGroupMember->GetGroup();
				dwActual++;
			}
			pGroupMember->Unlock();

			pBilink = pBilink->GetNext();
			pGroupMember = NULL;
		}

		DNASSERT(pGroupMember == NULL);
	}
	pPlayer->Unlock();

	if (GroupList)
	{
		DWORD	dw;

		for (dw = 0 ; dw < dwActual ; dw++)
		{
			DNASSERT(GroupList[dw] != NULL);

			RemovePlayerFromGroup(GroupList[dw],pPlayer,NULL);
			GroupList[dw]->Release();
			GroupList[dw] = NULL;
		}

		MemoryBlockFree(m_pdnObject,GroupList);
		GroupList = NULL;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (GroupList)
	{
		MemoryBlockFree(m_pdnObject,GroupList);
		GroupList = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::IsMember"

BOOL CNameTable::IsMember(const DPNID dpnidGroup,
						  const DPNID dpnidPlayer)
{
	CNameTableEntry		*pNTEntry;
	CGroupMember		*pGroupMember;
	CBilink				*pBilink;
	BOOL				bFound;

	bFound = FALSE;

	if (FindEntry(dpnidGroup,&pNTEntry) != DPN_OK)
	{
		goto Exit;
	}

	//
	//	Is this a group ?
	//
	if (!pNTEntry->IsGroup())
	{
		pNTEntry->Release();
		pNTEntry = NULL;
		goto Exit;
	}

	pNTEntry->Lock();
	pBilink = pNTEntry->m_bilinkMembership.GetNext();
	while (pBilink != &pNTEntry->m_bilinkMembership)
	{
		pGroupMember = CONTAINING_OBJECT(pBilink,CGroupMember,m_bilinkPlayers);
		if (pGroupMember->GetPlayer()->GetDPNID() == dpnidPlayer)
		{
			bFound = TRUE;
			break;
		}
		pBilink = pBilink->GetNext();
	}

	pNTEntry->Unlock();
	pNTEntry->Release();
	pNTEntry = NULL;

Exit:
	return(bFound);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::PackNameTable"

HRESULT CNameTable::PackNameTable(CNameTableEntry *const pTarget,
								  CPackedBuffer *const pPackedBuffer)
{
	HRESULT			hResultCode;
	CBilink			*pBilink;
	CBilink			*pBilinkMembership;
	CNameTableEntry	*pNTEntry;
	CGroupMember	*pGroupMember;
	DN_NAMETABLE_INFO	*pdnNTInfo;
	BOOL			bOutOfSpace;
	DWORD			dwEntryCount;
	DWORD			dwMembershipCount;
	DWORD			dwVersion;

	DNASSERT(pTarget != NULL);
	DNASSERT(pPackedBuffer != NULL);

	//
	//	PackedNameTable:
	//		<DN_NAMETABLE_INFO>
	//		<DN_NAMETABLE_ENTRY_INFO>	(DN_NAMETABLE_INFO.dwEntryCount entries)
	//		<DN_MEMBERSHIP_INFO>		(DN_NAMETABLE_INFO.dwMembershipCount entries)
	//			...
	//		<strings>
	//

	//
	//	NameTable Info
	//
	dwVersion = pTarget->GetVersion();
	bOutOfSpace = FALSE;
	pdnNTInfo = static_cast<DN_NAMETABLE_INFO*>(pPackedBuffer->GetHeadAddress());
	if ((hResultCode = pPackedBuffer->AddToFront(NULL,sizeof(DN_NAMETABLE_INFO))) != DPN_OK)
	{
		bOutOfSpace = TRUE;
	}

	//
	//	NameTableEntry Info
	//
	if (m_pdnObject->dwFlags & DN_OBJECT_FLAG_PEER)
	{
		dwEntryCount = 0;

		//
		//	Players
		//
		pBilink = m_bilinkPlayers.GetNext();
		while (pBilink != &m_bilinkPlayers)
		{
			pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
			if (pNTEntry->GetVersion() <= dwVersion)
			{
				if ((hResultCode = pNTEntry->PackEntryInfo(pPackedBuffer)) != DPN_OK)
				{
					bOutOfSpace = TRUE;
				}
				dwEntryCount++;
			}
			pBilink = pBilink->GetNext();
		}

		//
		//	Groups
		//
		pBilink = m_bilinkGroups.GetNext();
		while (pBilink != &m_bilinkGroups)
		{
			pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
			if (pNTEntry->GetVersion() <= dwVersion)
			{
				if ((hResultCode = pNTEntry->PackEntryInfo(pPackedBuffer)) != DPN_OK)
				{
					bOutOfSpace = TRUE;
				}
				dwEntryCount++;
			}
			pBilink = pBilink->GetNext();
		}
	}
	else
	{
		DNASSERT(m_pLocalPlayer != NULL);

		if ((hResultCode = m_pLocalPlayer->PackEntryInfo(pPackedBuffer)) != DPN_OK)
		{
			bOutOfSpace = TRUE;
		}
		if ((hResultCode = pTarget->PackEntryInfo(pPackedBuffer)) != DPN_OK)
		{
			bOutOfSpace = TRUE;
		}
		dwEntryCount = 2;
	}

	//
	//	GroupMember Info
	//
	dwMembershipCount = 0;
	if (m_pdnObject->dwFlags & DN_OBJECT_FLAG_PEER)
	{
		pBilink = m_bilinkGroups.GetNext();
		while (pBilink != &m_bilinkGroups)
		{
			pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
			DNASSERT(pNTEntry->IsGroup());
			if (!pNTEntry->IsAllPlayersGroup())
			{
				pBilinkMembership = pNTEntry->m_bilinkMembership.GetNext();
				while (pBilinkMembership != &pNTEntry->m_bilinkMembership)
				{
					pGroupMember = CONTAINING_OBJECT(pBilinkMembership,CGroupMember,m_bilinkPlayers);
					if (pGroupMember->GetVersion() <= dwVersion)
					{
						if ((hResultCode = pGroupMember->PackMembershipInfo(pPackedBuffer)) != DPN_OK)
						{
							bOutOfSpace = TRUE;
						}
						dwMembershipCount++;
					}
					pBilinkMembership = pBilinkMembership->GetNext();
				}
			}
			pBilink = pBilink->GetNext();
		}
	}

	if (!bOutOfSpace)
	{
		pdnNTInfo->dpnid = pTarget->GetDPNID();
		pdnNTInfo->dwVersion = dwVersion;
		pdnNTInfo->dwVersionNotUsed = 0;
		pdnNTInfo->dwEntryCount = dwEntryCount;
		pdnNTInfo->dwMembershipCount = dwMembershipCount;
	}

	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::UnpackNameTableInfo"

HRESULT	CNameTable::UnpackNameTableInfo(UNALIGNED DN_NAMETABLE_INFO *const pdnNTInfo,
										BYTE *const pBufferStart,
										DPNID *const pdpnid)
{
	HRESULT			hResultCode;
	DWORD			dwCount;
	CNameTableEntry	*pNTEntry;
	UNALIGNED DN_NAMETABLE_ENTRY_INFO			*pdnEntryInfo;
	UNALIGNED DN_NAMETABLE_MEMBERSHIP_INFO	*pdnMembershipInfo;

	DNASSERT(pdnNTInfo != NULL);
	DNASSERT(pBufferStart != NULL);

	//
	//	Preset outstanding connections
	//
	m_lOutstandingConnections = 0;

	//
	//	NameTable Entries
	//
	pdnEntryInfo = reinterpret_cast<DN_NAMETABLE_ENTRY_INFO*>(pdnNTInfo+1);
	for (dwCount = 0 ; dwCount < pdnNTInfo->dwEntryCount ; dwCount++)
	{
		if ((hResultCode = NameTableEntryNew(m_pdnObject,&pNTEntry)) != DPN_OK)
		{
			DPFERR("Could not get new NameTableEntry");
			DNASSERT(FALSE);
			return(hResultCode);
		}

		if ((hResultCode = pNTEntry->UnpackEntryInfo(pdnEntryInfo,pBufferStart)) != DPN_OK)
		{
			DPFERR("Could not unpack NameTableEntryInfo");
			DNASSERT(FALSE);
			pNTEntry->Release();
			return(hResultCode);
		}

		//
		//	Increment outstanding connection count
		//
		if (!pNTEntry->IsGroup() && (pNTEntry->GetVersion() <= pdnNTInfo->dwVersion))
		{
			pNTEntry->StartConnecting();	// This will be cleared when the player has connected or disconnected
			IncOutstandingConnections();
		}

		// Only put in NameTable if Host player
		if (m_pdnObject->dwFlags & (DN_OBJECT_FLAG_PEER | DN_OBJECT_FLAG_SERVER))
		{
			if ((hResultCode = InsertEntry(pNTEntry)) != DPN_OK)
			{
				DPFERR("Could not add NameTableEntry to NameTable");
				DNASSERT(FALSE);
				pNTEntry->Release();
				return(hResultCode);
			}
		}

		// Check for ShortCut pointers
		if (pNTEntry->GetDPNID() == pdnNTInfo->dpnid)
		{
			MakeLocalPlayer(pNTEntry);
		}
		else if (pNTEntry->IsHost())
		{
			MakeHostPlayer(pNTEntry);
		}
		else if (pNTEntry->IsAllPlayersGroup())
		{
			MakeAllPlayersGroup(pNTEntry);
		}

		pNTEntry->Release();
		pNTEntry = NULL;

		pdnEntryInfo++;
	}

	//
	//	Pass back local player's DPNID
	//
	if (pdpnid)
	{
		*pdpnid = pdnNTInfo->dpnid;
	}

	//
	//	Group Memberships
	//
	pdnMembershipInfo = reinterpret_cast<DN_NAMETABLE_MEMBERSHIP_INFO*>(pdnEntryInfo);
	for (dwCount = 0 ; dwCount < pdnNTInfo->dwMembershipCount ; dwCount++)
	{
		CNameTableEntry	*pGroup;

		pGroup = NULL;

		if ((hResultCode = m_pdnObject->NameTable.FindEntry(pdnMembershipInfo->dpnidGroup,&pGroup)) == DPN_OK)
		{
			CNameTableEntry	*pPlayer;

			pPlayer = NULL;

			if ((hResultCode = m_pdnObject->NameTable.FindEntry(pdnMembershipInfo->dpnidPlayer,&pPlayer)) == DPN_OK)
			{
				DWORD	dwVersion;

				dwVersion = pdnMembershipInfo->dwVersion;

				hResultCode = AddPlayerToGroup(pGroup,pPlayer,&dwVersion);
				pPlayer->Release();
				pPlayer = NULL;
			}
			pGroup->Release();
			pGroup = NULL;

			DNASSERT(pPlayer == NULL);
		}
		pdnMembershipInfo++;

		DNASSERT(pGroup == NULL);
	}

	//
	//	Version
	//
	WriteLock();
	SetVersion(pdnNTInfo->dwVersion);
	SetConnectVersion(pdnNTInfo->dwVersion);
	Unlock();

	hResultCode = DPN_OK;
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::MakeLocalPlayer"

void CNameTable::MakeLocalPlayer(CNameTableEntry *const pNTEntry)
{
	DNASSERT(pNTEntry != NULL);
	DNASSERT(m_pLocalPlayer == NULL);

	pNTEntry->AddRef();
	pNTEntry->Lock();
	pNTEntry->MakeLocal();
	pNTEntry->Unlock();

	WriteLock();
	m_pLocalPlayer = pNTEntry;
	Unlock();
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::ClearLocalPlayer"

void CNameTable::ClearLocalPlayer( void )
{
	BOOL	fInform;
	CNameTableEntry	*pNTEntry;
	CConnection		*pConnection;

	fInform = FALSE;
	pNTEntry = NULL;
	pConnection = NULL;

	WriteLock();
	if (m_pLocalPlayer)
	{
		pNTEntry = m_pLocalPlayer;
		m_pLocalPlayer = NULL;

		//
		//	If the player is available, we will make it unavailable.  This will prevent other threads from using it.
		//	We will then ensure that we are the only one indicating a DESTROY_PLAYER notification.
		//
		pNTEntry->Lock();
		if (pNTEntry->GetDestroyReason() == 0)
		{
			pNTEntry->SetDestroyReason( DPNDESTROYPLAYERREASON_NORMAL );
		}
		if (pNTEntry->IsAvailable())
		{
			pNTEntry->MakeUnavailable();

			if (pNTEntry->IsInUse())
			{
				//
				//	Queue destruction notification
				//
				pNTEntry->SetNeedToDestroy();
			}
			else
			{
				//
				//	Notify destruction
				//
				pNTEntry->SetInUse();
				fInform = TRUE;
			}
		}
		pNTEntry->Unlock();
	}
	Unlock();

	if (pNTEntry)
	{
		pNTEntry->GetConnectionRef(&pConnection);

		pNTEntry->Release();
		pNTEntry = NULL;
	}

	//
	//	Try to disconnect
	//
	if (pConnection)
	{
		pConnection->Disconnect();
		pConnection->Release();
		pConnection = NULL;
	}
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::MakeHostPlayer"

void CNameTable::MakeHostPlayer(CNameTableEntry *const pNTEntry)
{
	BOOL	bNotify;
	DPNID	dpnid;
	PVOID	pvContext;

	DNASSERT(pNTEntry != NULL);
	DNASSERT(m_pHostPlayer == NULL);

	pNTEntry->AddRef();

	pNTEntry->Lock();
	pNTEntry->MakeHost();
	if (pNTEntry->IsAvailable())
	{
		bNotify = TRUE;
		dpnid = pNTEntry->GetDPNID();
		pvContext = pNTEntry->GetContext();
	}
	else
	{
		bNotify = FALSE;
	}
	pNTEntry->Unlock();

	WriteLock();
	m_pHostPlayer = pNTEntry;
	Unlock();

	if (bNotify)
	{
		// Inform user that host has migrated
		DN_UserHostMigrate(m_pdnObject,dpnid,pvContext);
	}
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::ClearHostPlayer"

void CNameTable::ClearHostPlayer( void )
{
	BOOL	fInform;
	CNameTableEntry	*pNTEntry;
	CConnection		*pConnection;

	fInform = FALSE;
	pNTEntry = NULL;
	pConnection = NULL;

	WriteLock();
	if (m_pHostPlayer)
	{
		pNTEntry = m_pHostPlayer;
		m_pHostPlayer = NULL;

		//
		//	If the player is available, we will make it unavailable.  This will prevent other threads from using it.
		//	We will then ensure that we are the only one indicating a DESTROY_PLAYER notification.
		//
		pNTEntry->Lock();
		if (pNTEntry->GetDestroyReason() == 0)
		{
			pNTEntry->SetDestroyReason( DPNDESTROYPLAYERREASON_NORMAL );
		}
		if (pNTEntry->IsAvailable())
		{
			pNTEntry->MakeUnavailable();

			if (pNTEntry->IsInUse())
			{
				//
				//	Queue destruction notification
				//
				pNTEntry->SetNeedToDestroy();
			}
			else
			{
				//
				//	Notify destruction
				//
				pNTEntry->SetInUse();
				fInform = TRUE;
			}
		}
		pNTEntry->Unlock();
	}
	Unlock();

	if (pNTEntry)
	{
		pNTEntry->GetConnectionRef(&pConnection);

		pNTEntry->Release();
		pNTEntry = NULL;
	}

	//
	//	Try to disconnect
	//
	if (pConnection)
	{
		pConnection->Disconnect();
		pConnection->Release();
		pConnection = NULL;
	}
}


//
//	Clear the HostPlayer if it has a matching DPNID
//

#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::ClearHostWithDPNID"

BOOL CNameTable::ClearHostWithDPNID( const DPNID dpnid )
{
	BOOL	fCleared;
	BOOL	fInform;
	CNameTableEntry	*pNTEntry;
	CConnection		*pConnection;

	fCleared = FALSE;
	fInform = FALSE;
	pNTEntry = NULL;
	pConnection = NULL;

	WriteLock();
	if (m_pHostPlayer)
	{
		if (m_pHostPlayer->GetDPNID() == dpnid)
		{
			pNTEntry = m_pHostPlayer;
			m_pHostPlayer = NULL;

			//
			//	If the player is available, we will make it unavailable.  This will prevent other threads from using it.
			//	We will then ensure that we are the only one indicating a DESTROY_PLAYER notification.
			//
			pNTEntry->Lock();
			if (pNTEntry->GetDestroyReason() == 0)
			{
				pNTEntry->SetDestroyReason( DPNDESTROYPLAYERREASON_NORMAL );
			}
			if (pNTEntry->IsAvailable())
			{
				pNTEntry->MakeUnavailable();

				if (pNTEntry->IsInUse())
				{
					//
					//	Queue destruction notification
					//
					pNTEntry->SetNeedToDestroy();
				}
				else
				{
					//
					//	Notify destruction
					//
					pNTEntry->SetInUse();
					fInform = TRUE;
				}
			}
			pNTEntry->Unlock();
			fCleared = TRUE;
		}
	}
	Unlock();

	if (pNTEntry)
	{
		pNTEntry->GetConnectionRef(&pConnection);

		pNTEntry->Release();
		pNTEntry = NULL;
	}

	//
	//	Try to disconnect
	//
	if (pConnection)
	{
		pConnection->Disconnect();
		pConnection->Release();
		pConnection = NULL;
	}

	return(fCleared);
}


//
//	Attempt to update the HostPlayer short-cut pointer with a new player entry.
//	This will only be performed if the new entry has a larger version than the
//	existing HostPlayer entry.
//

#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::UpdateHostPlayer"

void CNameTable::UpdateHostPlayer( CNameTableEntry *const pNewHost )
{
	BOOL	fInformDelete;
	BOOL	fInformMigrate;
	DPNID	dpnid;
	PVOID	pvContext;
	CNameTableEntry	*pNTEntry;

	DNASSERT( pNewHost != NULL);

	fInformDelete = FALSE;
	fInformMigrate = FALSE;
	pNTEntry = NULL;

	WriteLock();

	//
	//	Clear old Host
	//
	if (m_pHostPlayer)
	{
		if (pNewHost->GetVersion() > m_pHostPlayer->GetVersion())
		{
			pNTEntry = m_pHostPlayer;
			m_pHostPlayer = NULL;

			//
			//	If the player is available, we will make it unavailable.  This will prevent other threads from using it.
			//	We will then ensure that we are the only one indicating a DESTROY_PLAYER notification.
			//
			pNTEntry->Lock();
			if (pNTEntry->GetDestroyReason() == 0)
			{
				pNTEntry->SetDestroyReason( DPNDESTROYPLAYERREASON_NORMAL );
			}
			if (pNTEntry->IsAvailable())
			{
				pNTEntry->MakeUnavailable();

				if (pNTEntry->IsInUse())
				{
					//
					//	Queue destruction notification
					//
					pNTEntry->SetNeedToDestroy();
				}
				else
				{
					//
					//	Notify destruction
					//
					pNTEntry->SetInUse();
					fInformDelete = TRUE;
				}
			}
			pNTEntry->Unlock();
		}
	}

	//
	//	New Host player
	//
	if (m_pHostPlayer == NULL)
	{
		pNewHost->Lock();
		pNewHost->MakeHost();
		if (pNewHost->IsAvailable())
		{
			fInformMigrate = TRUE;
			dpnid = pNewHost->GetDPNID();
			pvContext = pNewHost->GetContext();
		}
		pNewHost->Unlock();
		pNewHost->AddRef();
		m_pHostPlayer = pNewHost;
	}
	Unlock();

	//
	//	User notifications
	//
	if (pNTEntry)
	{

		pNTEntry->Release();
		pNTEntry = NULL;
	}

	if (fInformMigrate)
	{
		DN_UserHostMigrate(m_pdnObject,dpnid,pvContext);
	}
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::MakeAllPlayersGroup"

void CNameTable::MakeAllPlayersGroup(CNameTableEntry *const pNTEntry)
{
	DNASSERT(pNTEntry != NULL);
	DNASSERT(m_pAllPlayersGroup == NULL);

	pNTEntry->AddRef();
	pNTEntry->Lock();
	pNTEntry->MakeAllPlayersGroup();
	pNTEntry->Unlock();

	WriteLock();
	m_pAllPlayersGroup = pNTEntry;
	Unlock();
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::ClearAllPlayersGroup"

void CNameTable::ClearAllPlayersGroup( void )
{
	BOOL	fInform;
	CNameTableEntry	*pNTEntry;

	fInform = FALSE;
	pNTEntry = NULL;

	WriteLock();
	if (m_pAllPlayersGroup)
	{
		pNTEntry = m_pAllPlayersGroup;
		pNTEntry->Lock();
		if (pNTEntry->IsAvailable())
		{
			pNTEntry->MakeUnavailable();
			fInform = TRUE;
		}
		pNTEntry->Unlock();
		m_pAllPlayersGroup = NULL;
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	Unlock();
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::PopulateConnection"

HRESULT CNameTable::PopulateConnection(CConnection *const pConnection)
{
	HRESULT			hResultCode;
	CBilink			*pBilink;
	CNameTableEntry	*pNTEntry;
	CNameTableEntry	*pAllPlayersGroup;
	CGroupMember	*pGroupMember;
	CGroupMember	*pOldGroupMember;
	BOOL			fNotifyCreate;
	BOOL			fNotifyAddPlayerToGroup;
	BOOL			fNotifyRemovePlayerFromGroup;

	DNASSERT(pConnection != NULL);
	DNASSERT(pConnection->GetDPNID() != 0);

	pNTEntry = NULL;
	pAllPlayersGroup = NULL;
	pGroupMember = NULL;
	pOldGroupMember = NULL;

	if ((hResultCode = FindEntry(pConnection->GetDPNID(),&pNTEntry)) != DPN_OK)
	{
		return(hResultCode);
	}
	DNASSERT(!pNTEntry->IsGroup());

	//
	//	Set the connection for this player
	//
	pNTEntry->Lock();
	if (pNTEntry->GetConnection() == NULL)
	{
		pNTEntry->SetConnection( pConnection );
	}
	DNASSERT( pNTEntry->IsConnecting() );
	DNASSERT( !pNTEntry->IsAvailable() );
	pNTEntry->StopConnecting();
	pNTEntry->MakeAvailable();
	pNTEntry->Unlock();

	//
	//	Add this player to the ALL_PLAYERS group and make the link active
	//
	if ((hResultCode = m_pdnObject->NameTable.GetAllPlayersGroupRef( &pAllPlayersGroup )) != DPN_OK)
	{
		DPFERR("Could not get ALL_PLAYERS_GROUP reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	if ((hResultCode = m_pdnObject->NameTable.AddPlayerToGroup(	pAllPlayersGroup,
																pNTEntry,
																NULL)) != DPN_OK)
	{
		DPFERR("Could not add player to AllPlayersGroup");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pAllPlayersGroup->Release();
	pAllPlayersGroup = NULL;

	fNotifyCreate = FALSE;
	pNTEntry->Lock();
	if (!pNTEntry->IsDisconnecting() && !pNTEntry->IsCreated())
	{
		//
		//	We will set the entry as InUse so that any receives will get queued.
		//	We will also addref the NotifyRefCount twice.  Once for the
		//	CREATE_PLAYER notification if there was no INDICATE_CONNECT
		//	(so that a corresponding release will generate the DESTROY_PLAYER),
		//	and a second one to prevent a premature release from generating
		//	the DESTROY_PLAYER before we return from CREATE_PLAYER.  We will
		//	therefore have to release the refcount as soon as the CREATE_PLAYER
		//	returns back to us from the user (setting the context value).
		//
		DNASSERT(!pNTEntry->IsInUse());
		pNTEntry->SetInUse();
		if (!pNTEntry->IsIndicated())
		{
			pNTEntry->NotifyAddRef();
		}
		pNTEntry->NotifyAddRef();
		fNotifyCreate = TRUE;
	}
	pNTEntry->Unlock();		// Release lock during notifications (CREATE_PLAYER, CONNECT_COMPLETE?)

	if (fNotifyCreate)
	{
		if (!(m_pdnObject->dwFlags & DN_OBJECT_FLAG_CLIENT))
		{
			DNUserCreatePlayer(m_pdnObject,pNTEntry);
		}

		//
		//	Process any queued messages for this player
		//
		pNTEntry->PerformQueuedOperations();
	}

	//
	//	Create any auto-destruct groups belonging to this player
	//
	AutoCreateGroups(pNTEntry);


	pNTEntry->Lock();

	//
	//	Ensure this entry is still available (might have been deleted)
	//
	if (!pNTEntry->IsAvailable() || pNTEntry->IsDisconnecting())
	{
		pNTEntry->Unlock();
		goto Failure;
	}

	pBilink = pNTEntry->m_bilinkMembership.GetNext();
	while (pBilink != &pNTEntry->m_bilinkMembership)
	{
		pGroupMember = CONTAINING_OBJECT(pBilink,CGroupMember,m_bilinkGroups);
		pGroupMember->AddRef();
		pNTEntry->Unlock();

		DNASSERT(pGroupMember->GetGroup() != NULL);
		DNASSERT(pGroupMember->GetPlayer() != NULL);

		fNotifyAddPlayerToGroup = FALSE;
		fNotifyRemovePlayerFromGroup = FALSE;

		pGroupMember->GetGroup()->Lock();
		pGroupMember->Lock();
		DNASSERT(pGroupMember->GetGroupConnection() != NULL);
		if (!pGroupMember->IsAvailable() && !pGroupMember->IsNeedToAdd() && !pGroupMember->GetGroupConnection()->IsConnected())
		{
			//
			//	We will only indicate this up if the group has been created
			//	We don't need to see if the player has been created since he should have been and the NotifyRefCount
			//		on the player's entry for this group member will still be there
			//
			if (	pGroupMember->GetGroup()->IsCreated()
				&&	!pGroupMember->GetGroup()->IsDisconnecting()
				&&	!pGroupMember->GetGroup()->IsAllPlayersGroup())
			{
				pGroupMember->SetNeedToAdd();
				fNotifyAddPlayerToGroup = TRUE;
			}
		}
		pGroupMember->GetGroup()->Unlock();
		pGroupMember->Unlock();

		if (fNotifyAddPlayerToGroup)
		{
			DNASSERT(pGroupMember->GetGroupConnection()->GetConnection() == NULL);
			pGroupMember->Lock();
			pGroupMember->GetGroupConnection()->Lock();
			pGroupMember->GetGroupConnection()->SetConnection(pConnection);
			pGroupMember->GetGroupConnection()->Unlock();
			pGroupMember->MakeAvailable();
			pGroupMember->Unlock();

			DNUserAddPlayerToGroup(	m_pdnObject,pGroupMember->GetGroup(),pGroupMember->GetPlayer());

			pGroupMember->Lock();
			pGroupMember->ClearNeedToAdd();
			if (pGroupMember->IsNeedToRemove())
			{
				fNotifyRemovePlayerFromGroup = TRUE;
			}
			pGroupMember->Unlock();
		}

		if (fNotifyRemovePlayerFromGroup)
		{
			DNUserRemovePlayerFromGroup(m_pdnObject,pGroupMember->GetGroup(),pGroupMember->GetPlayer());
		}

		//
		//	Release old group member and transfer reference
		//
		if (pOldGroupMember)
		{
			pOldGroupMember->Release();
			pOldGroupMember = NULL;
		}
		pOldGroupMember = pGroupMember;
		pGroupMember = NULL;

		pNTEntry->Lock();
		//
		//	Avoid infinite loops by ensuring that we are not on a "disconnected" entry
		//
		if ((pBilink->GetNext() != &pNTEntry->m_bilinkMembership) && (pBilink->GetNext() == pBilink))
		{
			//
			//	We have an invalid entry - need to restart
			//
			pBilink = pNTEntry->m_bilinkMembership.GetNext();
		}
		else
		{
			//
			//	We either have a valid entry or we're finished
			//
			pBilink = pBilink->GetNext();
		}
	}

	pNTEntry->Unlock();

	if (pOldGroupMember)
	{
		pOldGroupMember->Release();
		pOldGroupMember = NULL;
	}

	//
	//	Reduce outstanding connections
	//
	if (pNTEntry->GetVersion() <= m_dwConnectVersion)
	{
		DecOutstandingConnections();
	}

	pNTEntry->Release();
	pNTEntry = NULL;

Exit:
	DNASSERT(pNTEntry == NULL);
	DNASSERT(pGroupMember == NULL);
	DNASSERT(pOldGroupMember == NULL);

	return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pAllPlayersGroup)
	{
		pAllPlayersGroup->Release();
		pAllPlayersGroup = NULL;
	}
	if (pGroupMember)
	{
		pGroupMember->Release();
		pGroupMember = NULL;
	}
	goto Exit;
}


//
//	This will generate ADD_PLAYER_TO_GROUP messages for all of the CREATE'd players in a group
//	(for whom a notification has not been posted)
//
#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::PopulateGroup"

HRESULT CNameTable::PopulateGroup(CNameTableEntry *const pGroup)
{
	HRESULT			hResultCode;
	BOOL			fNotifyAddPlayerToGroup;
	BOOL			fNotifyRemovePlayerFromGroup;
	CBilink			*pBilink;
	CGroupMember	*pGroupMember;
	CGroupMember	*pOldGroupMember;
	CNameTableEntry	*pPlayer;

	DPFX(DPFPREP, 6,"Parameters: pGroup [0x%p]",pGroup);

	DNASSERT(pGroup != NULL);

	hResultCode = DPN_OK;
	pPlayer = NULL;
	pGroupMember = NULL;
	pOldGroupMember = NULL;

	if (!pGroup->IsGroup())
	{
		hResultCode = DPNERR_INVALIDGROUP;
		goto Failure;
	}

	pGroup->Lock();
	pBilink = pGroup->m_bilinkMembership.GetNext();
	while (pBilink != &pGroup->m_bilinkMembership)
	{
		pGroupMember = CONTAINING_OBJECT(pBilink,CGroupMember,m_bilinkPlayers);
		pGroupMember->AddRef();
		pGroupMember->Lock();
		DNASSERT(pGroupMember->GetGroup() != NULL);
		DNASSERT(pGroupMember->GetPlayer() != NULL);
		DNASSERT(pGroupMember->GetGroup() == pGroup);
		pGroupMember->GetPlayer()->AddRef();
		pPlayer = pGroupMember->GetPlayer();
		pGroup->Unlock();
		pGroupMember->Unlock();

		fNotifyAddPlayerToGroup = FALSE;
		fNotifyRemovePlayerFromGroup = FALSE;

		pGroup->Lock();
		pPlayer->Lock();
		pGroupMember->Lock();
		DNASSERT( pGroupMember->GetGroupConnection() != NULL );
		if (	 pPlayer->IsCreated()
			&&	!pPlayer->IsDisconnecting()
			&&	 pGroup->IsCreated()
			&&	!pGroup->IsDisconnecting()
			&&	!pGroupMember->IsAvailable()
			&&	!pGroupMember->IsNeedToAdd()
			&&	!pGroupMember->GetGroupConnection()->IsConnected() )
		{
			pGroupMember->MakeAvailable();
			pGroupMember->SetNeedToAdd();
			fNotifyAddPlayerToGroup = TRUE;
		}
		pGroup->Unlock();
		pPlayer->Unlock();
		pGroupMember->Unlock();

		if (fNotifyAddPlayerToGroup)
		{
			DNUserAddPlayerToGroup(m_pdnObject,pGroup,pPlayer);

			pGroupMember->Lock();
			pGroupMember->ClearNeedToAdd();
			if (pGroupMember->IsNeedToRemove())
			{
				fNotifyRemovePlayerFromGroup = TRUE;
			}
			pGroupMember->Unlock();
		}
		if (fNotifyRemovePlayerFromGroup)
		{
			RemovePlayerFromGroup(pGroup,pPlayer,NULL);
		}

		pPlayer->Release();
		pPlayer = NULL;

		//
		//	Release old group member and transfer reference
		//
		if (pOldGroupMember)
		{
			pOldGroupMember->Release();
			pOldGroupMember = NULL;
		}
		pOldGroupMember = pGroupMember;
		pGroupMember = NULL;

		pGroup->Lock();
		if (pBilink->IsEmpty())
		{
			pBilink = pGroup->m_bilinkMembership.GetNext();
		}
		else
		{
			pBilink = pBilink->GetNext();
		}
	}
	pGroup->Unlock();

	if (pOldGroupMember)
	{
		pOldGroupMember->Release();
		pOldGroupMember = NULL;
	}

Exit:
	DNASSERT(pPlayer == NULL);
	DNASSERT(pGroupMember == NULL);
	DNASSERT(pOldGroupMember == NULL);

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pPlayer)
	{
		pPlayer->Release();
		pPlayer = NULL;
	}
	goto Exit;
}


//
//	This will generate CREATE_GROUP messages for all of the auto-destruct groups owned by a particular player
//
#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::AutoCreateGroups"

HRESULT CNameTable::AutoCreateGroups(CNameTableEntry *const pPlayer)
{
	HRESULT			hResultCode;
	BOOL			fNotify;
	CBilink			*pBilink;
	CNameTableEntry	*pGroup;
	CNameTableEntry	*pOldGroup;

	DPFX(DPFPREP, 6,"Parameters: pPlayer [0x%p]",pPlayer);

	DNASSERT(pPlayer != NULL);

	pGroup = NULL;
	pOldGroup = NULL;

	if (pPlayer->IsGroup())
	{
		hResultCode = DPNERR_INVALIDPLAYER;
		goto Failure;
	}

	ReadLock();

	pBilink = m_bilinkGroups.GetNext();
	while (pBilink != &m_bilinkGroups)
	{
		pGroup = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
		pGroup->AddRef();
		Unlock();

		fNotify = FALSE;
		pGroup->Lock();
		if (	pGroup->IsAutoDestructGroup()
			&&	(pGroup->GetOwner() == pPlayer->GetDPNID())
			&&	!pGroup->IsAvailable()
			&&	!pGroup->IsDisconnecting()	)
		{
			pGroup->MakeAvailable();
			pGroup->NotifyAddRef();
			pGroup->NotifyAddRef();
			pGroup->SetInUse();
			fNotify = TRUE;
		}
		pGroup->Unlock();

		if (fNotify)
		{
			DNASSERT(!pGroup->IsAllPlayersGroup());
			DNUserCreateGroup(m_pdnObject,pGroup);

			pGroup->PerformQueuedOperations();

			//
			//	Attempt to populate group with connected players
			//
			PopulateGroup(pGroup);
		}

		//
		//	Release old group and transfer reference
		//
		if (pOldGroup)
		{
			pOldGroup->Release();
			pOldGroup = NULL;
		}
		pOldGroup = pGroup;
		pGroup = NULL;

		ReadLock();
		if (pBilink->IsEmpty())
		{
			//
			//	We were removed from the list of groups, so re-start at the beginning
			//
			pBilink = m_bilinkGroups.GetNext();
		}
		else
		{
			pBilink = pBilink->GetNext();
		}
	}

	Unlock();

	if (pOldGroup)
	{
		pOldGroup->Release();
		pOldGroup = NULL;
	}

	hResultCode = DPN_OK;

Exit:
	DNASSERT(pGroup == NULL);
	DNASSERT(pOldGroup == NULL);

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pGroup)
	{
		pGroup->Release();
		pGroup = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::AutoDestructGroups"

HRESULT CNameTable::AutoDestructGroups(const DPNID dpnid)
{
	CBilink			*pBilink;
	CNameTableEntry	*pNTEntry;
	CNameTableEntry	*pOldNTEntry;

	pNTEntry = NULL;
	pOldNTEntry = NULL;

	ReadLock();
	pBilink = m_bilinkGroups.GetNext();
	while (pBilink != &m_bilinkGroups)
	{
		pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
		pNTEntry->AddRef();

		Unlock();

		if (pNTEntry->IsAutoDestructGroup() && (pNTEntry->GetOwner() == dpnid))
		{
			pNTEntry->Lock();
			if (pNTEntry->GetDestroyReason() == 0)
			{
				pNTEntry->SetDestroyReason( DPNDESTROYGROUPREASON_AUTODESTRUCTED );
			}
			pNTEntry->Unlock();
			DeleteGroup(pNTEntry->GetDPNID(),NULL);
		}

		//
		//	Release old entry and transfer reference
		//
		if (pOldNTEntry)
		{
			pOldNTEntry->Release();
			pOldNTEntry = NULL;
		}
		pOldNTEntry = pNTEntry;
		pNTEntry = NULL;

		ReadLock();

		//
		//	Avoid infinite loops by ensuring that we are not on a "disconnected" entry
		//
		if ((pBilink->GetNext() != &m_bilinkGroups) && (pBilink->GetNext() == pBilink))
		{
			//
			//	We have an invalid entry - need to restart
			//
			pBilink = m_bilinkGroups.GetNext();
		}
		else
		{
			//
			//	We either have a valid entry or we're finished
			//
			pBilink = pBilink->GetNext();
		}
	}
	Unlock();

	if (pOldNTEntry)
	{
		pOldNTEntry->Release();
		pOldNTEntry = NULL;
	}

	DNASSERT(pNTEntry == NULL);
	DNASSERT(pOldNTEntry == NULL);

	return(DPN_OK);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::DecOutstandingConnections"

void CNameTable::DecOutstandingConnections( void )
{
	LONG		lRefCount;

	lRefCount = InterlockedDecrement(&m_lOutstandingConnections);
	DNASSERT(lRefCount >= 0);
	if (lRefCount == 0)
	{
		CAsyncOp	*pConnectParent;

		pConnectParent = NULL;

		//
		//	Clear connect handle from DirectNetObject if we are connected
		//
		DNEnterCriticalSection(&m_pdnObject->csDirectNetObject);
		if (m_pdnObject->dwFlags & (DN_OBJECT_FLAG_CONNECTED|DN_OBJECT_FLAG_CONNECTING))
		{
			DPFX(DPFPREP, 5,"Clearing connection operation from DirectNetObject");
			pConnectParent = m_pdnObject->pConnectParent;
			m_pdnObject->pConnectParent = NULL;
		}
		DNLeaveCriticalSection(&m_pdnObject->csDirectNetObject);

		if (pConnectParent)
		{
			//
			//	We will set the connect parent as complete and remove this from the parent's (if it exists - it will be the connect handle)
			//	bilink of children to prevent a race condition of the connect being cancelled from above
			//
			pConnectParent->Lock();
			pConnectParent->SetComplete();
			pConnectParent->Unlock();
			pConnectParent->Orphan();

			pConnectParent->Release();
			pConnectParent = NULL;
		}
	}
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::DumpNameTable"

void CNameTable::DumpNameTable(char *const Buffer)
{
	CBilink			*pBilink;
	CNameTableEntry	*pNTEntry;
	char			*p;

	DNASSERT(Buffer != NULL);
	p = Buffer;
	wsprintfA(p,"(empty)");
	pBilink = m_bilinkGroups.GetNext();
	while (pBilink != &m_bilinkGroups)
	{
		pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
		pNTEntry->DumpEntry(p);
		p += strlen(p);
		pBilink = pBilink->GetNext();
	}
	pBilink = m_bilinkPlayers.GetNext();
	while (pBilink != &m_bilinkPlayers)
	{
		pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
		pNTEntry->DumpEntry(p);
		p += strlen(p);
		pBilink = pBilink->GetNext();
	}
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::GetLocalPlayerRef"

HRESULT CNameTable::GetLocalPlayerRef( CNameTableEntry **const ppNTEntry )
{
	HRESULT		hResultCode;

	ReadLock();
	if (m_pLocalPlayer)
	{
		m_pLocalPlayer->AddRef();
		*ppNTEntry = m_pLocalPlayer;
		hResultCode = DPN_OK;
	}
	else
	{
		hResultCode = DPNERR_INVALIDPLAYER;
	}
	Unlock();
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::GetHostPlayerRef"

HRESULT CNameTable::GetHostPlayerRef( CNameTableEntry **const ppNTEntry )
{
	HRESULT		hResultCode;

	ReadLock();
	if (m_pHostPlayer)
	{
		m_pHostPlayer->AddRef();
		*ppNTEntry = m_pHostPlayer;
		hResultCode = DPN_OK;
	}
	else
	{
		hResultCode = DPNERR_INVALIDPLAYER;
	}
	Unlock();
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::GetAllPlayersGroupRef"

HRESULT CNameTable::GetAllPlayersGroupRef( CNameTableEntry **const ppNTEntry )
{
	HRESULT		hResultCode;

	ReadLock();
	if (m_pAllPlayersGroup)
	{
		m_pAllPlayersGroup->AddRef();
		*ppNTEntry = m_pAllPlayersGroup;
		hResultCode = DPN_OK;
	}
	else
	{
		hResultCode = DPNERR_INVALIDPLAYER;
	}
	Unlock();
	return(hResultCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\message.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Message.h
 *  Content:    DirectNet Internal Messages
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *	01/14/00	mjn		Created
 *	01/20/00	mjn		Moved internal messages from DNCore.h
 *	01/24/00	mjn		Replaced on-wire message pointers to offsets
 *	01/24/00	mjn		Added messages for NameTable operation list clean-up
 *	01/25/00	mjn		Added DNSendHostMigrateCompleteMessage
 *	01/26/00	mjn		Implemented NameTable re-sync at host migration
 *	02/09/00	mjn		Implemented DNSEND_COMPLETEONPROCESS
 *	02/15/00	mjn		Added dwInfoFlags to UPDATE_INFO messages
 *	04/04/00	mjn		Added DNSendTerminateSession() and structure
 *	04/05/00	mjn		Modified DN_INTERNAL_MESSAGE_DESTROY_PLAYER
 *	04/23/00	mjn		Removed DN_INTERNAL_MESSAGE_SEND_PROCESSED and DN_INTERNAL_MESSAGE_SEND_PROCESSED_COMPLETE
 *				mjn		Added DN_INTERNAL_MESSAGE_REQ_PROCESS_COMPLETION and DN_INTERNAL_MESSAGE_PROCESS_COMPLETION
 *	04/25/00	mjn		Removed hCompletionOp from group/info REQUESTs
 *	07/12/00	mjn		Moved internal messages back from DNCore.h
 *	07/20/00	mjn		Changed SEND_PLAYER_INFO to PLAYER_CONNECT_INFO
 *				mjn		Added DN_INTERNAL_MESSAGE_CONNECT_INFO structure
 *				mjn		Modified DN_INTERNAL_MESSAGE_CONNECT_FAILED structure
 *				mjn		Moved DN_INTERNAL_MESSAGE_PLAYER_CONNECT_INFO and DN_INTERNAL_MESSAGE_INSTRUCTED_CONNECT_FAILED from connect.h
 *				mjn		Added DN_MSG_INTERNAL_CONNECT_ATTEMPT_FAILED, DN_INTERNAL_MESSAGE_CONNECT_ATTEMPT_FAILED
 *	07/31/00	mjn		DN_INTERNAL_MESSAGE_DESTROY_PLAYER renamed to  DN_INTERNAL_MESSAGE_HOST_DESTROY_PLAYER
 *				mjn		DN_INTERNAL_MESSAGE_DELETE_PLAYER renamed to DN_INTERNAL_MESSAGE_DESTROY_PLAYER
 *				mjn		Added dwDestroyReason to DN_INTERNAL_MESSAGE_DESTROY_PLAYER
 *				mjn		Removed DN_MSG_INTERNAL_HOST_DESTROY_PLAYER and DN_INTERNAL_MESSAGE_HOST_DESTROY_PLAYER structure
 *	07/31/00	mjn		Change DN_MSG_INTERNAL_DELETE_PLAYER to DN_MSG_INTERNAL_DESTROY_PLAYER
 *	08/07/00	mjn		Added structures for peer-peer session integrity checking
 *	08/08/00	mjn		Moved DN_NAMETABLE_OP_INFO from Migration.cpp
 *	08/25/00	mjn		Added NameTable version to DN_INTERNAL_MESSAGE_INSTRUCT_CONNECT
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__MESSAGE_H__
#define	__MESSAGE_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	DN_MSG_INTERNAL									0xc0
#define DN_MSG_INTERNAL_PLAYER_CONNECT_INFO				(0x01 | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_SEND_CONNECT_INFO				(0x02 | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_ACK_CONNECT_INFO				(0x03 | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_SEND_PLAYER_DNID				(0x04 | DN_MSG_INTERNAL)
#define DN_MSG_INTERNAL_CONNECT_FAILED					(0x05 | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_INSTRUCT_CONNECT				(0x06 | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_INSTRUCTED_CONNECT_FAILED		(0x07 | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_CONNECT_ATTEMPT_FAILED			(0x08 | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_NAMETABLE_VERSION				(0x09 | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_RESYNC_VERSION					(0x0a | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_REQ_NAMETABLE_OP				(0x0b | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_ACK_NAMETABLE_OP				(0x0c | DN_MSG_INTERNAL)
#define DN_MSG_INTERNAL_HOST_MIGRATE					(0x0d | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_HOST_MIGRATE_COMPLETE			(0x0e | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_UPDATE_APPLICATION_DESC			(0x0f | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_ADD_PLAYER						(0x10 | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_DESTROY_PLAYER					(0x11 | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_REQ_CREATE_GROUP				(0x12 | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_REQ_ADD_PLAYER_TO_GROUP			(0x13 | DN_MSG_INTERNAL)
#define DN_MSG_INTERNAL_REQ_DELETE_PLAYER_FROM_GROUP	(0x14 | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_REQ_DESTROY_GROUP				(0x15 | DN_MSG_INTERNAL)
#define DN_MSG_INTERNAL_REQ_UPDATE_INFO					(0x16 | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_CREATE_GROUP					(0x17 | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_DESTROY_GROUP					(0x18 | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_ADD_PLAYER_TO_GROUP				(0x19 | DN_MSG_INTERNAL)
#define DN_MSG_INTERNAL_DELETE_PLAYER_FROM_GROUP		(0x1a | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_UPDATE_INFO						(0x1b | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_VOICE_SEND						(0x1c | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_BUFFER_IN_USE					(0x1d | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_REQUEST_FAILED					(0x1e | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_TERMINATE_SESSION				(0x1f | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_REQ_PROCESS_COMPLETION			(0x20 | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_PROCESS_COMPLETION				(0x21 | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_REQ_INTEGRITY_CHECK				(0x22 | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_INTEGRITY_CHECK					(0x23 | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_INTEGRITY_CHECK_RESPONSE		(0x24 | DN_MSG_INTERNAL)

#define	DN_MSG_USER_SEND					0x02

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

typedef struct _DN_INTERNAL_MESSAGE_PLAYER_CONNECT_INFO {
	DWORD	dwFlags;
	DWORD	dwDNETVersion;
	DWORD	dwNameOffset;
	DWORD	dwNameSize;
	DWORD	dwDataOffset;
	DWORD	dwDataSize;
	DWORD	dwPasswordOffset;
	DWORD	dwPasswordSize;
	DWORD	dwConnectDataOffset;
	DWORD	dwConnectDataSize;
	DWORD	dwURLOffset;
	DWORD	dwURLSize;
	GUID	guidInstance;
	GUID	guidApplication;
} DN_INTERNAL_MESSAGE_PLAYER_CONNECT_INFO, *PDN_INTERNAL_MESSAGE_PLAYER_CONNECT_INFO;


typedef struct _DN_INTERNAL_MESSAGE_CONNECT_INFO {
	DWORD	dwReplyOffset;
	DWORD	dwReplySize;
} DN_INTERNAL_MESSAGE_CONNECT_INFO, *PDN_INTERNAL_MESSAGE_CONNECT_INFO;


typedef struct _DN_INTERNAL_MESSAGE_CONNECT_FAILED {
	HRESULT	hResultCode;
	DWORD	dwReplyOffset;
	DWORD	dwReplySize;
} DN_INTERNAL_MESSAGE_CONNECT_FAILED, *PDN_INTERNAL_MESSAGE_CONNECT_FAILED;


typedef struct _DN_INTERNAL_MESSAGE_INSTRUCT_CONNECT {
	DPNID	dpnid;
	DWORD	dwVersion;
	DWORD	dwVersionNotUsed;
} DN_INTERNAL_MESSAGE_INSTRUCT_CONNECT, *PDN_INTERNAL_MESSAGE_INSTRUCT_CONNECT;


typedef struct _DN_INTERNAL_MESSAGE_INSTRUCTED_CONNECT_FAILED {
	DPNID	dpnid;
} DN_INTERNAL_MESSAGE_INSTRUCTED_CONNECT_FAILED;


typedef struct _DN_INTERNAL_MESSAGE_CONNECT_ATTEMPT_FAILED {
	DPNID	dpnid;
} DN_INTERNAL_MESSAGE_CONNECT_ATTEMPT_FAILED;


typedef struct _DN_INTERNAL_MESSAGE_REQUEST_FAILED {
	DPNHANDLE	hCompletionOp;
	HRESULT		hResultCode;
} DN_INTERNAL_MESSAGE_REQUEST_FAILED;


typedef struct _DN_INTERNAL_MESSAGE_SEND_PLAYER_DPNID {
	DPNID	dpnid;
} DN_INTERNAL_MESSAGE_SEND_PLAYER_DPNID, *PDN_INTERNAL_MESSAGE_SEND_PLAYER_DPNID;


typedef struct _DN_INTERNAL_MESSAGE_DESTROY_PLAYER {
	DPNID	dpnidLeaving;		// DPNID of leaving player
	DWORD	dwVersion;			// Name table version of this operation
	DWORD	dwVersionNotUsed;
	DWORD	dwDestroyReason;
} DN_INTERNAL_MESSAGE_DESTROY_PLAYER, *PDN_INTERNAL_MESSAGE_DESTROY_PLAYER;


typedef struct _DN_INTERNAL_MESSAGE_CREATE_GROUP {
	DPNID		dpnidRequesting;
	DPNHANDLE	hCompletionOp;
} DN_INTERNAL_MESSAGE_CREATE_GROUP;


typedef struct _DN_INTERNAL_MESSAGE_DESTROY_GROUP {
	DPNID		dpnidGroup;
	DWORD		dwVersion;
	DWORD		dwVersionNotUsed;
	DPNID		dpnidRequesting;
	DPNHANDLE	hCompletionOp;
} DN_INTERNAL_MESSAGE_DESTROY_GROUP;

typedef struct _DN_INTERNAL_MESSAGE_ADD_PLAYER_TO_GROUP {
	DPNID		dpnidGroup;
	DPNID		dpnidPlayer;
	DWORD		dwVersion;
	DWORD		dwVersionNotUsed;
	DPNID		dpnidRequesting;
	DPNHANDLE	hCompletionOp;
} DN_INTERNAL_MESSAGE_ADD_PLAYER_TO_GROUP, *PDN_INTERNAL_MESSAGE_ADD_PLAYER_TO_GROUP;


typedef struct _DN_INTERNAL_MESSAGE_DELETE_PLAYER_FROM_GROUP {
	DPNID		dpnidGroup;
	DPNID		dpnidPlayer;
	DWORD		dwVersion;
	DWORD		dwVersionNotUsed;
	DPNID		dpnidRequesting;
	DPNHANDLE	hCompletionOp;
} DN_INTERNAL_MESSAGE_DELETE_PLAYER_FROM_GROUP, *PDN_INTERNAL_MESSAGE_DELETE_PLAYER_FROM_GROUP;


typedef struct _DN_INTERNAL_MESSAGE_UPDATE_INFO {
	DPNID		dpnid;
	DWORD		dwVersion;
	DWORD		dwVersionNotUsed;
	DWORD		dwInfoFlags;
	DWORD		dwNameOffset;
	DWORD		dwNameSize;
	DWORD		dwDataOffset;
	DWORD		dwDataSize;
	DPNID		dpnidRequesting;
	DPNHANDLE	hCompletionOp;
} DN_INTERNAL_MESSAGE_UPDATE_INFO, *PDN_INTERNAL_MESSAGE_UPDATE_INFO;


typedef struct _DN_INTERNAL_MESSAGE_HOST_MIGRATE {
	DPNID		dpnidOldHost;
	DPNID		dpnidNewHost;
} DN_INTERNAL_MESSAGE_HOST_MIGRATE, *PDN_INTERNAL_MESSAGE_HOST_MIGRATE;


typedef struct _DN_INTERNAL_MESSAGE_REQ_CREATE_GROUP {
	DWORD		dwGroupFlags;
	DWORD		dwInfoFlags;
	DWORD		dwNameOffset;
	DWORD		dwNameSize;
	DWORD		dwDataOffset;
	DWORD		dwDataSize;
} DN_INTERNAL_MESSAGE_REQ_CREATE_GROUP, *PDN_INTERNAL_MESSAGE_REQ_CREATE_GROUP;


typedef struct _DN_INTERNAL_MESSAGE_REQ_DESTROY_GROUP {
	DPNID		dpnidGroup;
} DN_INTERNAL_MESSAGE_REQ_DESTROY_GROUP, *PDN_INTERNAL_MESSAGE_REQ_DESTROY_GROUP;


typedef struct _DN_INTERNAL_MESSAGE_REQ_ADD_PLAYER_TO_GROUP {
	DPNID		dpnidGroup;
	DPNID		dpnidPlayer;
} DN_INTERNAL_MESSAGE_REQ_ADD_PLAYER_TO_GROUP, *PDN_INTERNAL_MESSAGE_REQ_ADD_PLAYER_TO_GROUP;


typedef struct _DN_INTERNAL_MESSAGE_REQ_DELETE_PLAYER_FROM_GROUP {
	DPNID		dpnidGroup;
	DPNID		dpnidPlayer;
} DN_INTERNAL_MESSAGE_REQ_DELETE_PLAYER_FROM_GROUP, *PDN_INTERNAL_MESSAGE_REQ_DELETE_PLAYER_FROM_GROUP;


typedef struct _DN_INTERNAL_MESSAGE_REQ_UPDATE_INFO {
	DPNID		dpnid;
	DWORD		dwInfoFlags;
	DWORD		dwNameOffset;
	DWORD		dwNameSize;
	DWORD		dwDataOffset;
	DWORD		dwDataSize;
} DN_INTERNAL_MESSAGE_REQ_UPDATE_INFO, *PDN_INTERNAL_MESSAGE_REQ_UPDATE_INFO;

typedef struct _DN_INTERNAL_MESSAGE_NAMETABLE_VERSION {
	DWORD		dwVersion;
	DWORD		dwVersionNotUsed;
} DN_INTERNAL_MESSAGE_NAMETABLE_VERSION, *PDN_INTERNAL_MESSAGE_NAMETABLE_VERSION;


typedef struct _DN_INTERNAL_MESSAGE_RESYNC_VERSION {
	DWORD		dwVersion;
	DWORD		dwVersionNotUsed;
} DN_INTERNAL_MESSAGE_RESYNC_VERSION, *PDN_INTERNAL_MESSAGE_RESYNC_VERSION;


typedef struct _DN_INTERNAL_MESSAGE_REQ_NAMETABLE_OP {
	DWORD		dwVersion;
	DWORD		dwVersionNotUsed;
} DN_INTERNAL_MESSAGE_REQ_NAMETABLE_OP, *PDN_INTERNAL_MESSAGE_REQ_NAMETABLE_OP;


typedef struct _DN_INTERNAL_MESSAGE_ACK_NAMETABLE_OP {
	DWORD		dwNumEntries;
} DN_INTERNAL_MESSAGE_ACK_NAMETABLE_OP, *PDN_INTERNAL_MESSAGE_ACK_NAMETABLE_OP;


typedef struct _DN_INTERNAL_MESSAGE_REQ_PROCESS_COMPLETION {
	DPNHANDLE	hCompletionOp;
} DN_INTERNAL_MESSAGE_REQ_PROCESS_COMPLETION;


typedef struct _DN_INTERNAL_MESSAGE_PROCESS_COMPLETION {
	DPNHANDLE	hCompletionOp;
} DN_INTERNAL_MESSAGE_PROCESS_COMPLETION;


typedef struct _DN_INTERNAL_MESSAGE_TERMINATE_SESSION {
	DWORD		dwTerminateDataOffset;
	DWORD		dwTerminateDataSize;
} DN_INTERNAL_MESSAGE_TERMINATE_SESSION, *PDN_INTERNAL_MESSAGE_TERMINATE_SESSION;


typedef struct _DN_INTERNAL_MESSAGE_REQ_INTEGRITY_CHECK {
	DPNID		dpnidTarget;
} DN_INTERNAL_MESSAGE_REQ_INTEGRITY_CHECK;


typedef struct _DN_INTERNAL_MESSAGE_INTEGRITY_CHECK {
	DPNID		dpnidRequesting;
} DN_INTERNAL_MESSAGE_INTEGRITY_CHECK;


typedef struct _DN_INTERNAL_MESSAGE_INTEGRITY_CHECK_RESPONSE {
	DPNID		dpnidRequesting;
} DN_INTERNAL_MESSAGE_INTEGRITY_CHECK_RESPONSE;


typedef struct _DN_NAMETABLE_OP_INFO {
	DWORD	dwMsgId;
	DWORD	dwOpOffset;
	DWORD	dwOpSize;
} DN_NAMETABLE_OP_INFO, *PDN_NAMETABLE_OP_INFO;


// DN_APPLICATION_DESC_INFO - used to pack / send info
//		Force byte alignment as this may go out on the wire
#pragma pack( push, 1 )

typedef	struct DPN_APPLICATION_DESC_INFO {
	DWORD	dwSize;
	DWORD	dwFlags;
	DWORD	dwMaxPlayers;
	DWORD	dwCurrentPlayers;
	DWORD	dwSessionNameOffset;
	DWORD	dwSessionNameSize;
	DWORD	dwPasswordOffset;
	DWORD	dwPasswordSize;
	DWORD	dwReservedDataOffset;
	DWORD	dwReservedDataSize;
	DWORD	dwApplicationReservedDataOffset;
	DWORD	dwApplicationReservedDataSize;
	GUID	guidInstance;
	GUID	guidApplication;
} DPN_APPLICATION_DESC_INFO;
#pragma pack( pop )


//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************


#endif	// __MESSAGE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\msghandler.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       MsgHandler.cpp
 *  Content:    DirectPlay Core/Protocol Interface
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  01/15/00	mjn		Created
 *	01/27/00	mjn		Added support for retention of receive buffers
 *	04/08/00	mjn		Save SP with connections
 *	04/11/00	mjn		Use CAsyncOp for ENUMs
 *	04/13/00	mjn		Use Protocol Interface VTBL
 *	04/14/00	mjn		DNPICompleteListen sets status and SyncEvent
 *	04/17/00	mjn		DNPICompleteEnumQuery just sets return value of AsyncOp
 *	04/18/00	mjn		CConnection tracks connection status better
 *	04/21/00	mjn		Ensure that RECEIVEs are from a valid connection before passing up notifications
 *				mjn		Disconnect CONNECTing end points on errors
 *	04/22/00	mjn		Consume notifications when closing or disconnecting.
 *	04/26/00	mjn		Removed DN_ASYNC_OP and related functions
 *	05/23/00	mjn		Call DNConnectToPeerFailed if ExistingPlayer connect to NewPlayer fails
 *	06/14/00	mjn		Allow only one connection to Host in DNPICompleteConnect()
 *	06/21/00	mjn		Modified DNSendMessage() and DNCreateSendParent() to use protocol voice bit
 *	06/22/00	mjn		Fixed DNPIIndicateReceive() to properly handle voice messages
 *				mjn		Cleaned up DNPIIndicateConnectionTerminated()
 *	06/24/00	mjn		Fixed DNPICompleteConnect()
 *	07/08/00	mjn		Only signal protocol shutdown event if it exists
 *	07/11/00	mjn		Fixed DNPIAddressInfoXXX() routines to ENUM,LISTEN,CONNECT multiple adapters with address info
 *	07/20/00	mjn		Modified CONNECT process, cleaned up refcount problems
 *	07/24/00	mjn		Decline EnumQueries if not host or if host is migrating
 *	07/28/00	mjn		Added code to validate return value from DPNICompleteSend()
 *	07/29/00	mjn		Fix calls to DNUserConnectionTerminated()
 *	07/30/00	mjn		Use DNUserTerminateSession() rather than DNUserConnectionTerminated()
 *	07/31/00	mjn		Added hrReason to DNTerminateSession()
 *				mjn		Added dwDestroyReason to DNHostDisconnect()
 *	08/02/00	mjn		Pass received voice messages through DNReceiveUserData()
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *	08/05/00	mjn		Added m_bilinkActiveList to CAsyncOp
 *	08/15/00	mjn		Call DNConnectToHostFailed() when connecting player's connection to host drops
 *	08/16/00	mjn		Modified IndicateConnect() and CompleteConnect() to determine SP directly from AsyncOps
 *	08/23/00	mjn		Unregister with DPNSVR when LISTENs terminate
 *	09/04/00	mjn		Added CApplicationDesc
 *	09/06/00	mjn		Fixed DNPIIndicateConnectionTerminated() to better handle disconnects from partially connected players
 *	09/14/00	mjn		Release Protocol refcounts in completions
 *	09/21/00	mjn		Disconnect duplicate connections to Host player in DNPICompleteConnect()
 *	09/29/00	mjn		AddRef/Release locks in DNPIIndicateReceive()
 *	09/30/00	mjn		AddRef/Release locks in DNPIIndicateEnumQuery(),DNPIIndicateEnumResponse()
 *	10/11/00	mjn		Cancel outstanding CONNECTs if one succeeds
 *	10/17/00	mjn		Fixed clean up for unreachable players
 *	02/08/01	mjn		Wait for cancels in DNPICompleteXXX()
 *				mjn		Wait for endpoint users in DNPIIndicateConnectionTerminated()
 *	03/30/01	mjn		Changes to prevent multiple loading/unloading of SP's
 *	04/05/01	mjn		Set destroy reason to DPNDESTROYPLAYERREASON_CONNECTIONLOST in DNPIIndicateConnectionTerminated()
 *	05/23/01	mjn		Cancel LISTEN's that have been flagged as cancelled in DNPICompleteListen()
 *	06/03/01	mjn		Orphan completed CONNECT's and DISCONNECT's
 *	06/25/01	mjn		Don't unregister with DPNSVR in DNPICompleteListenTerminate()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


#undef DPF_MODNAME
#define DPF_MODNAME "DNPIIndicateEnumQuery"

HRESULT DNPIIndicateEnumQuery(void *const pvUserContext,
							  void *const pvEndPtContext,
							  const HANDLE hCommand,
							  void *const pvEnumQueryData,
							  const DWORD dwEnumQueryDataSize)
{
	HRESULT			hResultCode;
	CAsyncOp		*pAsyncOp;
	DIRECTNETOBJECT	*pdnObject;
	CNameTableEntry	*pLocalPlayer;
	BOOL			fReleaseLock;

	DPFX(DPFPREP, 6,"Parameters: pvEndPtContext [0x%p], hCommand [0x%p], pvEnumQueryData [0x%p], dwEnumQueryDataSize [%ld]",
			pvEndPtContext,hCommand,pvEnumQueryData,dwEnumQueryDataSize);

	DNASSERT(pvUserContext != NULL);
	DNASSERT(pvEndPtContext != NULL);

	pLocalPlayer = NULL;
	fReleaseLock = FALSE;

	pdnObject = static_cast<DIRECTNETOBJECT*>(pvUserContext);
	pAsyncOp = static_cast<CAsyncOp*>(pvEndPtContext);

	//
	//	Prevent close while in this call-back
	//
	if ((hResultCode = DNAddRefLock(pdnObject)) != DPN_OK)
	{
		hResultCode = DPN_OK;
		goto Failure;
	}
	fReleaseLock = TRUE;

	//
	//	Don't perform this if host migrating
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_HOST_MIGRATING)
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		hResultCode = DPN_OK;
		goto Failure;
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) == DPN_OK)
	{
		if (pLocalPlayer->IsHost())
		{
#pragma TODO(minara,"The protocol should ensure that the LISTEN does not complete until this call-back returns")
#pragma TODO(minara,"As the context value (AsyncOp) needs to be valid !")
			DNProcessEnumQuery( pdnObject, pAsyncOp, reinterpret_cast<const PROTOCOL_ENUM_DATA*>( pvEnumQueryData ) );
		}
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}

	hResultCode = DPN_OK;

Exit:
	if (fReleaseLock)
	{
		DNDecRefLock(pdnObject);
		fReleaseLock = FALSE;
	}

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNPIIndicateEnumResponse"

HRESULT DNPIIndicateEnumResponse(void *const pvUserContext,
								 const HANDLE hCommand,
								 void *const pvCommandContext,
								 void *const pvEnumResponseData,
								 const DWORD dwEnumResponseDataSize)
{
	HRESULT			hResultCode;
	CAsyncOp		*pAsyncOp;
	DIRECTNETOBJECT	*pdnObject;
	BOOL			fReleaseLock;

	DPFX(DPFPREP, 6,"Parameters: hCommand [0x%p], pvCommandContext [0x%p], pvEnumResponseData [0x%p], dwEnumResponseDataSize [%ld]",
			hCommand,pvCommandContext,pvEnumResponseData,dwEnumResponseDataSize);

	DNASSERT(pvUserContext != NULL);
	DNASSERT(pvCommandContext != NULL);

	fReleaseLock = FALSE;

	pdnObject = static_cast<DIRECTNETOBJECT*>(pvUserContext);
	pAsyncOp = static_cast<CAsyncOp*>(pvCommandContext);

	//
	//	Prevent close while in this call-back
	//
	if ((hResultCode = DNAddRefLock(pdnObject)) != DPN_OK)
	{
		hResultCode = DPN_OK;
		goto Failure;
	}
	fReleaseLock = TRUE;

#pragma TODO(minara,"The protocol should ensure that the ENUM does not complete until this call-back returns")
#pragma TODO(minara,"As the context value (AsyncOp) needs to be valid !")
	DNProcessEnumResponse( pdnObject, pAsyncOp, reinterpret_cast<const PROTOCOL_ENUM_RESPONSE_DATA*>( pvEnumResponseData ) );

	hResultCode = DPN_OK;

Exit:
	if (fReleaseLock)
	{
		DNDecRefLock(pdnObject);
		fReleaseLock = FALSE;
	}

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	goto Exit;
}



//
//	When a new connection is indicated by the Protocol layer, we will perform some basic validation,
//	and then create a CConnection object for it
//

#undef DPF_MODNAME
#define DPF_MODNAME "DNPIIndicateConnect"

HRESULT DNPIIndicateConnect(void *const pvUserContext,
							void *const pvListenContext,
							const HANDLE hEndPt,
							void **const ppvEndPtContext)
{
	HRESULT				hResultCode;
	CConnection			*pConnection;
	DIRECTNETOBJECT		*pdnObject;

#pragma TODO( minara, "Decline connections to non-hosting players and peers who are not expecting them")

	DPFX(DPFPREP, 6,"Parameters: pvListenContext [0x%p], hEndPt [0x%p], ppvEndPtContext [0x%p]",
			pvListenContext,hEndPt,ppvEndPtContext);

	DNASSERT(pvUserContext != NULL);
	DNASSERT(pvListenContext != NULL);

	pdnObject = static_cast<DIRECTNETOBJECT*>(pvUserContext);
	
	pConnection = NULL;

	//
	//	Allocate and set up a CConnection object and hand a reference to the Protocol
	//
	if ((hResultCode = ConnectionNew(pdnObject,&pConnection)) != DPN_OK)
	{
		DPFERR("Could not get new connection");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pConnection->SetStatus( CONNECTING );
	pConnection->SetEndPt(hEndPt);
	DNASSERT( (static_cast<CAsyncOp*>(pvListenContext))->GetParent() != NULL);
	DNASSERT( (static_cast<CAsyncOp*>(pvListenContext))->GetParent()->GetSP() != NULL);
	pConnection->SetSP((static_cast<CAsyncOp*>(pvListenContext))->GetParent()->GetSP());
	pConnection->AddRef();
	*ppvEndPtContext = pConnection;

	if (pdnObject->dwFlags & (DN_OBJECT_FLAG_CLOSING | DN_OBJECT_FLAG_DISCONNECTING))
	{
		DPFERR("CONNECT indicated while closing or disconnecting");
		DNPerformDisconnect(pdnObject,pConnection,hEndPt);
		goto Failure;
	}

	DNASSERT(pdnObject->NameTable.GetLocalPlayer() != NULL);
	if (pdnObject->NameTable.GetLocalPlayer()->IsHost())
	{
		// This connect was detected by a host player
		DPFX(DPFPREP, 7,"Host received connection attempt");
	}
	else
	{
		// This connect was detected by a peer player (should be expecting a connection)
		DPFX(DPFPREP, 7,"Non-Host player received connection attempt");
	}

	//
	//	Add this entry to the bilink of indicated connections.  When we receive more info,
	//	or this connection is terminated, we will remove this entry from the bilink.
	//	This will enable us to clean up properly.
	//
	DNEnterCriticalSection(&pdnObject->csConnectionList);
	pConnection->AddRef();
	pConnection->m_bilinkIndicated.InsertBefore(&pdnObject->m_bilinkIndicated);
	DNLeaveCriticalSection(&pdnObject->csConnectionList);

	pConnection->Release();
	pConnection = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNPIIndicateDisconnect"

HRESULT DNPIIndicateDisconnect(void *const pvUserContext,
							   void *const pvEndPtContext)
{
	HRESULT			hResultCode;
	CConnection		*pConnection;
	DIRECTNETOBJECT	*pdnObject;
	CNameTableEntry	*pNTEntry;

	DPFX(DPFPREP, 6,"Parameters: pvEndPtContext [0x%p]",
			pvEndPtContext);

	DNASSERT(pvUserContext != NULL);
	DNASSERT(pvEndPtContext != NULL);

	pdnObject = static_cast<DIRECTNETOBJECT*>(pvUserContext);
	pConnection = static_cast<CConnection*>(pvEndPtContext);

	//
	//	Mark the connection as DISCONNECTing so that we don't use it any more
	//
	pConnection->Lock();
	pConnection->SetStatus( DISCONNECTING );
	pConnection->Unlock();

	if (pConnection->GetDPNID() == 0)
	{
		if (pdnObject->NameTable.GetLocalPlayer() && pdnObject->NameTable.GetLocalPlayer()->IsHost())
		{
			DPFX(DPFPREP, 7,"Joining player has issued a disconnect to Host (local) player");
		}
		else
		{
			DPFX(DPFPREP, 7,"Host has issued a disconnect to Joining (local) player");
		}
	}
	else
	{
		DNASSERT(!(pdnObject->dwFlags & DN_OBJECT_FLAG_CLIENT));

		if (pdnObject->NameTable.GetLocalPlayer() && pdnObject->NameTable.GetLocalPlayer()->IsHost())
		{
			DPFX(DPFPREP, 7,"Connected player has issued a disconnect to Host (local) player");
		}
		else
		{
			DPFX(DPFPREP, 7,"Connected player has issued a disconnect to local player");
		}

		//
		//	Mark this player for normal destruction since they disconnected and are playing nice
		//
		if ((hResultCode = pdnObject->NameTable.FindEntry(pConnection->GetDPNID(),&pNTEntry)) == DPN_OK)
		{
			pNTEntry->Lock();
			if (pNTEntry->GetDestroyReason() == 0)
			{
				pNTEntry->SetDestroyReason( DPNDESTROYPLAYERREASON_NORMAL );
			}
			pNTEntry->Unlock();
			pNTEntry->Release();
			pNTEntry = NULL;
		}
	}

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNPIIndicateConnectionTerminated"

HRESULT DNPIIndicateConnectionTerminated(void *const pvUserContext,
										 void *const pvEndPtContext,
										 const HRESULT hr)
{
	HRESULT			hResultCode;
	CConnection		*pConnection;
	DIRECTNETOBJECT	*pdnObject;
	BOOL			fWasConnecting;
	CBilink			*pBilink;
	DWORD			dwCount;
	CSyncEvent		*pSyncEvent;

	DPFX(DPFPREP, 6,"Parameters: pvEndPtContext [0x%p], hr [0x%lx]",pvEndPtContext,hr);

	DNASSERT(pvUserContext != NULL);
	DNASSERT(pvEndPtContext != NULL);

	pSyncEvent = NULL;

	pdnObject = static_cast<DIRECTNETOBJECT*>(pvUserContext);
	pConnection = static_cast<CConnection*>(pvEndPtContext);

	//
	//	pConnection should still have at least 1 reference on it at this stage since
	//	INDICATE_CONNECTION_TERMINATED is supposed to be the final release for it.
	//	All outstanding SENDs and RECEIVEs should have already been processed.
	//
	//	If there are any users of the endpoint, then we will need to wait for them
	//	to be done with it.  To do this, we will count the number of threads using
	//	the endpoint (not including any occurances of THIS thread), and set the count
	//	and an event on the Connection
	//

	fWasConnecting = FALSE;
	pConnection->Lock();
	if (pConnection->IsConnecting())
	{
		fWasConnecting = TRUE;
	}
	pConnection->SetStatus( INVALID );

	dwCount = 0;
	pBilink = pConnection->m_bilinkCallbackThreads.GetNext();
	while (pBilink != &pConnection->m_bilinkCallbackThreads)
	{
		if (!(CONTAINING_OBJECT(pBilink,CCallbackThread,m_bilinkCallbackThreads))->IsCurrentThread())
		{
			dwCount++;
		}
		pBilink = pBilink->GetNext();
	}
	if (dwCount != 0)
	{
		if ((hResultCode = SyncEventNew(pdnObject,&pSyncEvent)) != DPN_OK)
		{
			DPFERR("Could not get sync event - ignore and continue (we will not wait!)");
			dwCount = 0;
		}
		else
		{
			pConnection->SetThreadCount( dwCount );
			pConnection->SetThreadEvent( pSyncEvent );
		}
	}
	pConnection->Unlock();

	if (dwCount)
	{
		DNASSERT(pSyncEvent != NULL);

		pSyncEvent->WaitForEvent(INFINITE);
		pConnection->Lock();
		pConnection->SetThreadEvent( NULL );
		pConnection->Unlock();
		pSyncEvent->ReturnSelfToPool();
		pSyncEvent = NULL;
	}

	//
	//	Remove this connection from the indicated connection list
	//
	DNEnterCriticalSection(&pdnObject->csConnectionList);
	if (!pConnection->m_bilinkIndicated.IsEmpty())
	{
		pConnection->Release();
	}
	pConnection->m_bilinkIndicated.RemoveFromList();
	DNLeaveCriticalSection(&pdnObject->csConnectionList);

	//
	//	If we are a client (in client server), and the server has disconnected from us, we have to shut down
	//
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_CLIENT)
	{
		if (fWasConnecting)
		{
			DPFX(DPFPREP, 7,"Server disconnected from local connecting client - failing connect");
		}
		else
		{
			DPFX(DPFPREP, 7,"Server disconnected from local client - shutting down");

			//
			//	Only inform the user if they are IN the session
			//
			if (pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED)
			{
				DNUserTerminateSession(pdnObject,DPNERR_CONNECTIONLOST,NULL,0);
			}
			DNTerminateSession(pdnObject,DPNERR_CONNECTIONLOST);
		}
	}
	else if (pdnObject->dwFlags & DN_OBJECT_FLAG_SERVER)
	{
		if (fWasConnecting || (pConnection->GetDPNID() == 0))
		{
			DPFX(DPFPREP, 7,"Unconnected client has disconnected from server");
		}
		else
		{
			CNameTableEntry	*pNTEntry;
			DWORD			dwReason;

			pNTEntry = NULL;

			//
			//	If the destruction code has not been set, mark as CONNECTIONLOST
			//
			if ((hResultCode = pdnObject->NameTable.FindEntry(pConnection->GetDPNID(),&pNTEntry)) == DPN_OK)
			{
				pNTEntry->Lock();
				if (pNTEntry->GetDestroyReason() == 0)
				{
					pNTEntry->SetDestroyReason( DPNDESTROYPLAYERREASON_CONNECTIONLOST );
				}
				dwReason = pNTEntry->GetDestroyReason();
				pNTEntry->Unlock();
				pNTEntry->Release();
				pNTEntry = NULL;
			}
			else
			{
				dwReason = DPNDESTROYPLAYERREASON_CONNECTIONLOST;
			}

			DNHostDisconnect(pdnObject,pConnection->GetDPNID(),dwReason);
		}
	}
	else //	DN_OBJECT_FLAG_PEER
	{
		DNASSERT( pdnObject->dwFlags & DN_OBJECT_FLAG_PEER );

		if (fWasConnecting || (pConnection->GetDPNID() == 0))
		{
			DPFX(DPFPREP, 7,"Unconnected peer has disconnected from local peer");
			CAsyncOp	*pConnectParent;

			pConnectParent = NULL;

			DNEnterCriticalSection(&pdnObject->csDirectNetObject);
			if (pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING)
			{
				pdnObject->dwFlags &= (~(DN_OBJECT_FLAG_CONNECTED|DN_OBJECT_FLAG_CONNECTING|DN_OBJECT_FLAG_HOST_CONNECTED));
				if (pdnObject->pConnectParent)
				{
					pConnectParent = pdnObject->pConnectParent;
					pdnObject->pConnectParent = NULL;
				}
				if( pdnObject->pIDP8ADevice )
				{
					pdnObject->pIDP8ADevice->lpVtbl->Release( pdnObject->pIDP8ADevice );
					pdnObject->pIDP8ADevice = NULL;
				}
				if( pdnObject->pConnectAddress )
				{
					pdnObject->pConnectAddress->lpVtbl->Release( pdnObject->pConnectAddress );
					pdnObject->pConnectAddress = NULL;
				}
			}
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

			if (pConnectParent)
			{
				pConnectParent->Release();
				pConnectParent = NULL;
			}

			DNASSERT(pConnectParent == NULL);
		}
		else
		{
			CNameTableEntry	*pNTEntry;
			CNameTableEntry	*pLocalPlayer;
			DWORD			dwReason;

			pNTEntry = NULL;
			pLocalPlayer = NULL;

			//
			//	If the destruction code has not been set, mark as CONNECTIONLOST
			//
			if ((hResultCode = pdnObject->NameTable.FindEntry(pConnection->GetDPNID(),&pNTEntry)) == DPN_OK)
			{
				pNTEntry->Lock();
				if (pNTEntry->GetDestroyReason() == 0)
				{
					pNTEntry->SetDestroyReason( DPNDESTROYPLAYERREASON_CONNECTIONLOST );
				}
				dwReason = pNTEntry->GetDestroyReason();
				pNTEntry->Unlock();
				pNTEntry->Release();
				pNTEntry = NULL;
			}
			else
			{
				dwReason = DPNDESTROYPLAYERREASON_CONNECTIONLOST;
			}

			//
			//	Based on who we are, and who's disconnecting, we will have different behaviour
			//
			if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef(&pLocalPlayer)) == DPN_OK)
			{
				if (pLocalPlayer->IsHost())
				{
					DPFX(DPFPREP, 7,"Connected peer has disconnected from Host");
					DNHostDisconnect(pdnObject,pConnection->GetDPNID(),dwReason);
				}
				else
				{
					DPFX(DPFPREP, 7,"Peer has disconnected from non-Host peer");
					DNPlayerDisconnectNew(pdnObject,pConnection->GetDPNID());
				}
				pLocalPlayer->Release();
				pLocalPlayer = NULL;
			}
		}
	}

	pConnection->Release();
	pConnection = NULL;

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNPIIndicateReceive"

HRESULT DNPIIndicateReceive(void *const pvUserContext,
							void *const pvEndPtContext,
							void *const pvData,
							const DWORD dwDataSize,
							const HANDLE hBuffer,
							const DWORD dwFlags)
{
	HRESULT		hResultCode;
	DIRECTNETOBJECT	*pdnObject;
	void			*pvInternalData;
	DWORD			dwInternalDataSize;
	CConnection		*pConnection;
	DWORD			*pdwMsgId;
	BOOL 			fReleaseLock;

	DPFX(DPFPREP, 6,"Parameters: pvEndPtContext [0x%p], pvData [0x%p], dwDataSize [%ld], hBuffer [0x%p], dwFlags [0x%lx]",
			pvEndPtContext,pvData,dwDataSize,hBuffer,dwFlags);

	DNASSERT(pvUserContext != NULL);
	DNASSERT(pvEndPtContext != NULL);
	DNASSERT(pvData != NULL);
	DNASSERT(dwDataSize != 0);
	DNASSERT(hBuffer != NULL);

	fReleaseLock = FALSE;
	
	pdnObject = static_cast<DIRECTNETOBJECT*>(pvUserContext);
	pConnection = static_cast<CConnection*>(pvEndPtContext);

	//
	//	Prevent close while in this call-back
	//
	if ((hResultCode = DNAddRefLock(pdnObject)) != DPN_OK)
	{
		hResultCode = DPN_OK;
		goto Failure;
	}
	fReleaseLock = TRUE;

	//
	//	Ensure that this is a valid connection
	//
	if (!pConnection->IsConnected() && !pConnection->IsConnecting())
	{
		hResultCode = DPN_OK;
		goto Failure;
	}

	pConnection->AddRef();

	if ((dwFlags & DN_SENDFLAGS_SET_USER_FLAG) && !(dwFlags & DN_SENDFLAGS_SET_USER_FLAG_TWO))
	{
		//
		//	Internal message
		//
		DPFX(DPFPREP, 7,"Received INTERNAL message");

		DNASSERT(dwDataSize >= sizeof(DWORD));
		pdwMsgId = static_cast<DWORD*>(pvData);
		dwInternalDataSize = dwDataSize - sizeof(DWORD);
		if (dwInternalDataSize > 0)
		{
			pvInternalData = static_cast<void*>(static_cast<BYTE*>(pvData) + sizeof(DWORD));
		}
		else
		{
			pvInternalData = NULL;
		}

		hResultCode = DNProcessInternalOperation(	pdnObject,
													*pdwMsgId,
													pvInternalData,
													dwInternalDataSize,
													pConnection,
													hBuffer,
													NULL );
	}
	else
	{
		//
		//	User or voice message
		//
		DPFX(DPFPREP, 7,"Received USER or Voice message");

		hResultCode = DNReceiveUserData(pdnObject,
										pConnection->GetDPNID(),
										pConnection->GetSP(),
										static_cast<BYTE*>(pvData),
										dwDataSize,
										hBuffer,
										NULL,
										0,
										dwFlags);
	}

	//
	//	Only allow DPNERR_PENDING or DPN_OK
	//
	if (hResultCode != DPNERR_PENDING)
	{
		hResultCode = DPN_OK;
	}

	pConnection->Release();
	pConnection = NULL;

Exit:
	if (fReleaseLock)
	{
		DNDecRefLock(pdnObject);
		fReleaseLock = FALSE;
	}

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNPICompleteListen"

HRESULT DNPICompleteListen(void *const pvUserContext,
						   void **const ppvCommandContext,
						   const HRESULT hr,
						   const HANDLE hEndPt)
{
	HRESULT		hResultCode;
	CAsyncOp	*pAsyncOp;
	CAsyncOp	*pParent;
	DIRECTNETOBJECT	*pdnObject;

	DPFX(DPFPREP, 6,"Parameters: ppvCommandContext [0x%p], hr [0x%lx], hEndPt [0x%p]",
			ppvCommandContext,hr,hEndPt);

	DNASSERT(pvUserContext != NULL);
	DNASSERT(ppvCommandContext != NULL);
	DNASSERT(*ppvCommandContext != NULL);

	pdnObject = static_cast<DIRECTNETOBJECT*>(pvUserContext);
	pAsyncOp = static_cast<CAsyncOp*>(*ppvCommandContext);

	pParent = NULL;

	//
	//	AddRef pAsyncOp to keep it around in case a CompleteListenTerminated is posted
	//
	pAsyncOp->AddRef();

	pAsyncOp->Lock();
	if (pAsyncOp->GetParent())
	{
		pAsyncOp->GetParent()->AddRef();
		pParent = pAsyncOp->GetParent();
	}
	pAsyncOp->Unlock();

	//
	//	If the LISTEN was cancelled and has been started successfully, we will need to shut it down.
	//	Otherwise, we will keep the result of the LISTEN attempt
	//
	DNASSERT(pAsyncOp->GetResultPointer() != NULL);
	if (hr == DPN_OK)
	{
		if (pAsyncOp->IsCancelled())
		{
			HRESULT	hrCancel;

			if ((hrCancel = DNPCancelCommand(pdnObject->pdnProtocolData,hEndPt)) == DPN_OK)
			{
				*(pAsyncOp->GetResultPointer()) = DPNERR_USERCANCEL;
			}
			else
			{
				*(pAsyncOp->GetResultPointer()) = DPNERR_GENERIC;
			}
		}
		else
		{
			//
			//	We probably don't have to lock pAsyncOp to clear the CANNOT_CANCEL, but better safe than sorry
			//
			pAsyncOp->Lock();
			pAsyncOp->ClearCannotCancel();
			pAsyncOp->Unlock();
			*(pAsyncOp->GetResultPointer()) = hr;
		}
	}
	else
	{
		*(pAsyncOp->GetResultPointer()) = hr;
	}

	//
	//	Set SyncEvent
	//
	DNASSERT(pAsyncOp->GetSyncEvent() != NULL);
	pAsyncOp->GetSyncEvent()->Set();

	//
	//	If there was an SP parent, we will check to see if this is the last completion and then set the
	//	parent's SP listen event (if it exists)
	//
	if (pParent)
	{
		DN_LISTEN_OP_DATA	*pListenOpData;

		if (pParent->GetOpData())
		{
			pListenOpData = static_cast<DN_LISTEN_OP_DATA*>(pParent->GetOpData());
			DNASSERT( pListenOpData->dwCompleteAdapters < pListenOpData->dwNumAdapters );
			pListenOpData->dwCompleteAdapters++;
			if (pListenOpData->dwCompleteAdapters == pListenOpData->dwNumAdapters)
			{
				if (pListenOpData->pSyncEvent)
				{
					pListenOpData->pSyncEvent->Set();
					pListenOpData->pSyncEvent = NULL;
				}
			}
		}
		pParent->Release();
		pParent = NULL;
	}

	//
	//	Done with pAsyncOp - release reference taken earlier
	//
	pAsyncOp->Release();

	hResultCode = DPN_OK;

	DNASSERT( pParent == NULL);

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNPICompleteListenTerminate"

HRESULT DNPICompleteListenTerminate(void *const pvUserContext,
									void *const pvCommandContext,
									const HRESULT hr)
{
	HRESULT		hResultCode;
	CAsyncOp	*pAsyncOp;
//	BOOL		fUnregister;
	DIRECTNETOBJECT	*pdnObject;

	DPFX(DPFPREP, 6,"Parameters: pvCommandContext [0x%p], hr [0x%lx]",
			pvCommandContext,hr);

	DNASSERT(pvUserContext != NULL);
	DNASSERT(pvCommandContext != NULL);

	pdnObject = static_cast<DIRECTNETOBJECT*>(pvUserContext);
	pAsyncOp = static_cast<CAsyncOp*>(pvCommandContext);


	//
	//	Indicate complete and remove from active list
	//
	pAsyncOp->Lock();
	DNASSERT(!pAsyncOp->IsComplete());
	pAsyncOp->SetComplete();
	pAsyncOp->Unlock();

	DNEnterCriticalSection(&pdnObject->csActiveList);
	pAsyncOp->m_bilinkActiveList.RemoveFromList();
	DNLeaveCriticalSection(&pdnObject->csActiveList);

/*	REMOVE
	//
	//	Unregister from DPNSVR when LISTENs start to terminate
	//
	fUnregister = FALSE;
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_DPNSVR_REGISTERED)
	{
		pdnObject->dwFlags &= (~DN_OBJECT_FLAG_DPNSVR_REGISTERED);
		fUnregister = TRUE;
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
	if (fUnregister)
	{
		pdnObject->ApplicationDesc.UnregisterWithDPNSVR();
	}
*/
	DNASSERT(pAsyncOp->IsChild());
	pAsyncOp->Orphan();

	//
	//	Ensure there are no cancels outstanding
	//
	DNWaitForCancel(pdnObject,pAsyncOp);

	pAsyncOp->Release();
	pAsyncOp = NULL;

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNPICompleteEnumQuery"

HRESULT DNPICompleteEnumQuery(void *const pvUserContext,
							  void *const pvCommandContext,
							  const HRESULT hr)
{
	HRESULT			hResultCode;
	CAsyncOp		*pAsyncOp;
	DIRECTNETOBJECT	*pdnObject;

	DPFX(DPFPREP, 6,"Parameters: pvCommandContext [0x%p], hr [0x%lx]",
			pvCommandContext,hr);

	DNASSERT(pvUserContext != NULL);
	DNASSERT(pvCommandContext != NULL);

	pdnObject = static_cast<DIRECTNETOBJECT*>(pvUserContext);
	pAsyncOp = static_cast<CAsyncOp*>(pvCommandContext);

	DNASSERT( pAsyncOp->GetOpType() == ASYNC_OP_ENUM_QUERY );

	//
	//	Indicate complete and remove from active list
	//
	pAsyncOp->Lock();
	DNASSERT(!pAsyncOp->IsComplete());
	pAsyncOp->SetComplete();
	pAsyncOp->Unlock();

	DNEnterCriticalSection(&pdnObject->csActiveList);
	pAsyncOp->m_bilinkActiveList.RemoveFromList();
	DNLeaveCriticalSection(&pdnObject->csActiveList);

	pAsyncOp->SetResult( hr );
	pAsyncOp->Orphan();

	//
	//	Ensure there are no cancels outstanding
	//
	DNWaitForCancel(pdnObject,pAsyncOp);

	pAsyncOp->Release();
	pAsyncOp = NULL;

	//
	//	Release Protocol reference
	//
	DNProtocolRelease(pdnObject);

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNPICompleteEnumResponse"

HRESULT DNPICompleteEnumResponse(void *const pvUserContext,
								 void *const pvCommandContext,
								 const HRESULT hr)
{
	HRESULT			hResultCode;
	CAsyncOp		*pAsyncOp;
	DIRECTNETOBJECT	*pdnObject;

	DPFX(DPFPREP, 6,"Parameters: pvCommandContext [0x%p], hr [0x%lx]",
			pvCommandContext,hr);

	DNASSERT(pvUserContext != NULL);
	DNASSERT(pvCommandContext != NULL);

	pdnObject = static_cast<DIRECTNETOBJECT*>(pvUserContext);
	pAsyncOp = static_cast<CAsyncOp*>(pvCommandContext);

	DNASSERT( pAsyncOp->GetOpType() == ASYNC_OP_ENUM_RESPONSE );

	pAsyncOp->Lock();
	DNASSERT(!pAsyncOp->IsComplete());
	pAsyncOp->SetComplete();
	pAsyncOp->Unlock();

	if (pAsyncOp->IsChild())
	{
		DNASSERT(FALSE);
		pAsyncOp->Orphan();
	}
	if (pAsyncOp->GetHandle())
	{
		pdnObject->HandleTable.Destroy(pAsyncOp->GetHandle());
	}
	pAsyncOp->SetResult( hr );

	//
	//	Ensure there are no cancels outstanding
	//
	DNWaitForCancel(pdnObject,pAsyncOp);

	pAsyncOp->Release();
	pAsyncOp = NULL;

	//
	//	Release protocol reference
	//
	DNProtocolRelease(pdnObject);

	hResultCode = DPN_OK;
	
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNPICompleteConnect"

HRESULT DNPICompleteConnect(void *const pvUserContext,
							void *const pvCommandContext,
							const HRESULT hrProt,
							const HANDLE hEndPt,
							void **const ppvEndPtContext)
{
	HRESULT				hResultCode;
	HRESULT				hr;
	CAsyncOp			*pAsyncOp;
	CConnection			*pConnection;
	DIRECTNETOBJECT		*pdnObject;
	IDirectPlay8Address	*pIDevice;

	DPFX(DPFPREP, 6,"Parameters: pvCommandContext [0x%p], hrProt [0x%lx], hEndPt [0x%p], ppvEndPtContext [0x%p]",
			pvCommandContext,hrProt,hEndPt,ppvEndPtContext);

	DNASSERT(pvUserContext != NULL);
	DNASSERT(pvCommandContext != NULL);
	DNASSERT( (hrProt != DPN_OK) || (ppvEndPtContext != NULL) );

	pdnObject = static_cast<DIRECTNETOBJECT*>(pvUserContext);
	pAsyncOp = static_cast<CAsyncOp*>(pvCommandContext);

	DNASSERT( pAsyncOp->GetOpType() == ASYNC_OP_CONNECT );

	pConnection = NULL;
	pIDevice = NULL;

	//
	//	Re-map DPNERR_ABORTED (!)
	//
#pragma BUGBUG( minara, "Get Evan to change this so we do not have to re-map it !" )
	if (hrProt == DPNERR_ABORTED)
	{
		hr = DPNERR_USERCANCEL;
	}
	else
	{
		hr = hrProt;
	}

	//
	//	Indicate complete and remove from active list
	//
	pAsyncOp->Lock();
	DNASSERT(!pAsyncOp->IsComplete());
	pAsyncOp->SetComplete();
	pAsyncOp->Unlock();

	DNEnterCriticalSection(&pdnObject->csActiveList);
	pAsyncOp->m_bilinkActiveList.RemoveFromList();
	DNLeaveCriticalSection(&pdnObject->csActiveList);

	if (pAsyncOp->IsChild())
	{
		pAsyncOp->Orphan();
	}

	//
	//	If there is a DPNID associated with this operation, then we are an ExistingPlayer
	//	connecting with a NewPlayer.  If there is no DPNID, then we are a NewPlayer connecting
	//	to the Host.
	//

	if (pAsyncOp->GetDPNID())
	{
		DPFX(DPFPREP, 7,"CONNECT completed for existing player connecting to NewPlayer");

		//
		//	We are an existing player attempting to CONNECT to a NewPlayer.
		//	If this CONNECT failed, we must inform the Host
		//
		if (hr != DPN_OK)
		{
			DPFERR("Could not CONNECT to NewPlayer");
			DisplayDNError(0,hr);
			DNConnectToPeerFailed(pdnObject,pAsyncOp->GetDPNID());
			hResultCode = DPN_OK;
			goto Failure;
		}

		//
		//	Allocate and set up a CConnection object and hand a reference to the Protocol
		//
		DNASSERT(pAsyncOp->GetSP() != NULL);
		if ((hResultCode = ConnectionNew(pdnObject,&pConnection)) != DPN_OK)
		{
			DPFERR("Could not get new connection");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pConnection->SetStatus( CONNECTING );
		pConnection->SetEndPt(hEndPt);
		pConnection->SetSP(pAsyncOp->GetSP());
		pConnection->AddRef();
		*ppvEndPtContext = pConnection;

		//
		//	Send this player's DNID to the connecting player to enable name table entry
		//
		if ((hResultCode = DNConnectToPeer3(pdnObject,pAsyncOp->GetDPNID(),pConnection)) != DPN_OK)
		{
			DPFERR("Could not connect to NewPlayer");
			DisplayDNError(0,hr);
			DNPerformDisconnect(pdnObject,pConnection,hEndPt);
			DNConnectToPeerFailed(pdnObject,pAsyncOp->GetDPNID());
			goto Failure;
		}
	}
	else
	{
		DPFX(DPFPREP, 7,"CONNECT completed for NewPlayer connecting to Host");

		//
		//	We are the NewPlayer attempting to CONNECT to the Host.
		//

		//
		//	If this CONNECT succeeded, we will cancell any other CONNECTs.
		//	If this CONNECT failed, we will set the result code on the AsyncOp
		//	and release it.
		//
		if (hr == DPN_OK)
		{
			CAsyncOp	*pParent;

			pParent = NULL;

			pAsyncOp->Lock();
			if (pAsyncOp->GetParent())
			{
				pAsyncOp->GetParent()->AddRef();
				pParent = pAsyncOp->GetParent();
			}
			pAsyncOp->Unlock();
			if (pParent)
			{
				DNCancelChildren(pdnObject,pParent);
				pParent->Release();
				pParent = NULL;
			}

			DNASSERT(pParent == NULL);
		}
		else
		{
			DPFERR("Could not CONNECT to Host");
			DisplayDNError(0,hr);
			pAsyncOp->SetResult( hr );
			hResultCode = DPN_OK;
			goto Failure;
		}

		//
		//	Allocate and set up a CConnection object and hand a reference to the Protocol
		//
		DNASSERT(pAsyncOp->GetSP() != NULL);
		if ((hResultCode = ConnectionNew(pdnObject,&pConnection)) != DPN_OK)
		{
			DPFERR("Could not get new connection");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pConnection->SetStatus( CONNECTING );
		pConnection->SetEndPt(hEndPt);
		pConnection->SetSP(pAsyncOp->GetSP());
		pConnection->AddRef();
		*ppvEndPtContext = pConnection;

		//
		//	Ensure that this is the first CONNECT to succeed.
		//	If it isn't we will just drop the connection.
		//
		DNEnterCriticalSection(&pdnObject->csDirectNetObject);
		if (pdnObject->dwFlags & DN_OBJECT_FLAG_HOST_CONNECTED)
		{
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
			DPFERR("Connect already established - disconnecting");
			DNPerformDisconnect(pdnObject,pConnection,hEndPt);
			hResultCode = DPN_OK;
			goto Failure;
		}
		pdnObject->dwFlags |= DN_OBJECT_FLAG_HOST_CONNECTED;
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

		// rodtoll: Modifying so we always store this information so that when we update
		// 		  lobby settings we return the device we actually connected on for clients

		/*
		//
		//	For Peer-Peer, we will need the device address we connected on so that
		//	we can CONNECT to new players later on.
		//
		if (pdnObject->dwFlags & DN_OBJECT_FLAG_PEER)
		{*/
			if ((hResultCode = DNGetLocalDeviceAddress(pdnObject,hEndPt,&pIDevice)) != DPN_OK)
			{
				DPFERR("Could not determine local address");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
				DNPerformDisconnect(pdnObject,pConnection,hEndPt);
				goto Failure;
			}
			pIDevice->lpVtbl->AddRef(pIDevice);
			pdnObject->pIDP8ADevice = pIDevice;

			pIDevice->lpVtbl->Release(pIDevice);
			pIDevice = NULL;
		// }

		//
		//	Send player and application info for NewPlayer connecting to Host
		//
		if ((hResultCode = DNConnectToHost1(pdnObject,pConnection)) != DPN_OK)
		{
			DPFERR("Could not CONNECT to Host");
			DisplayDNError(0,hResultCode);
			DNPerformDisconnect(pdnObject,pConnection,hEndPt);
			goto Failure;
		}
	}
	pAsyncOp->Lock();
	pAsyncOp->SetResult( DPN_OK );
	pAsyncOp->Unlock();

	pConnection->Release();
	pConnection = NULL;

	hResultCode = DPN_OK;

Exit:
	//
	//	Ensure there are no cancels outstanding
	//
	DNWaitForCancel(pdnObject,pAsyncOp);

	DNASSERT(pAsyncOp != NULL);
	pAsyncOp->Release();
	pAsyncOp = NULL;

	//
	//	Release protocol reference
	//
	DNProtocolRelease(pdnObject);

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	if (pIDevice)
	{
		pIDevice->lpVtbl->Release(pIDevice);
		pIDevice = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNPICompleteDisconnect"

HRESULT DNPICompleteDisconnect(void *const pvUserContext,
							   void *const pvCommandContext,
							   const HRESULT hr)
{
	HRESULT			hResultCode;
	CAsyncOp		*pAsyncOp;
	DIRECTNETOBJECT	*pdnObject;

	DPFX(DPFPREP, 6,"Parameters: pvCommandContext [0x%p], hr [0x%lx]",
			pvCommandContext,hr);

	DNASSERT(pvUserContext != NULL);
	DNASSERT(pvCommandContext != NULL);

	pdnObject = static_cast<DIRECTNETOBJECT*>(pvUserContext);
	pAsyncOp = static_cast<CAsyncOp*>(pvCommandContext);

	DNASSERT( pAsyncOp->GetOpType() == ASYNC_OP_DISCONNECT );

	pAsyncOp->Lock();
	DNASSERT(!pAsyncOp->IsComplete());
	pAsyncOp->SetComplete();
	pAsyncOp->Unlock();

	if (pAsyncOp->IsChild())
	{
		pAsyncOp->Orphan();
	}

	//
	//	If this completed successfully, we can remove the reference on the connection held by the Protocol
	//
	if (hr == DPN_OK)
	{
		pAsyncOp->Lock();
		if (pAsyncOp->GetConnection())
		{
			pAsyncOp->GetConnection()->Release();
		}
		pAsyncOp->Unlock();
	}

	pAsyncOp->SetResult( hr );

	//
	//	Ensure there are no cancels outstanding
	//
	DNWaitForCancel(pdnObject,pAsyncOp);

	pAsyncOp->Release();
	pAsyncOp = NULL;

	//
	//	Release Protocol reference
	//
	DNProtocolRelease(pdnObject);

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNPICompleteSend"

HRESULT DNPICompleteSend(void *const pvUserContext,
						 void *const pvCommandContext,
						 const HRESULT hr)
{
	HRESULT			hResultCode;
	DIRECTNETOBJECT	*pdnObject;
	CAsyncOp		*pAsyncOp;

	DPFX(DPFPREP, 6,"Parameters: pvCommandContext [0x%p], hr [0x%lx]",
			pvCommandContext,hr);

	DNASSERT(pvUserContext != NULL);
	DNASSERT(pvCommandContext != NULL);

	pdnObject = static_cast<DIRECTNETOBJECT*>(pvUserContext);
	pAsyncOp = static_cast<CAsyncOp*>(pvCommandContext);

	DNASSERT( pAsyncOp->GetOpType() == ASYNC_OP_SEND );

	//
	//	Indicate complete and remove from active list
	//
	pAsyncOp->Lock();
	DNASSERT(!pAsyncOp->IsComplete());
	pAsyncOp->SetComplete();
	pAsyncOp->Unlock();

	DNEnterCriticalSection(&pdnObject->csActiveList);
	pAsyncOp->m_bilinkActiveList.RemoveFromList();
	DNLeaveCriticalSection(&pdnObject->csActiveList);

	switch( hr )
	{
		case	DPN_OK:
		case	DPNERR_ABORTED:
#pragma TODO( minara, "remove DPNERR_ABORTED" )
		case	DPNERR_CONNECTIONLOST:
		case	DPNERR_GENERIC:	
		case	DPNERR_OUTOFMEMORY:
		case	DPNERR_TIMEDOUT:
		case	DPNERR_USERCANCEL:
			{
				break;
			}

		default:
			{
				DNASSERT(FALSE);	// unexpected return code !
				break;
			}
	}

	if (pAsyncOp->IsChild())
	{
		pAsyncOp->Orphan();
	}
	pAsyncOp->SetResult( hr );

	//
	//	Ensure there are no cancels outstanding
	//
	DNWaitForCancel(pdnObject,pAsyncOp);

	pAsyncOp->Release();
	pAsyncOp = NULL;

	//
	//	Release Protocol reference
	//
	DNProtocolRelease(pdnObject);

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNPIAddressInfoConnect"

HRESULT DNPIAddressInfoConnect(void *const pvUserContext,
							   void *const pvCommandContext,
							   const HRESULT hr,
							   IDirectPlay8Address *const pHostAddress,
							   IDirectPlay8Address *const pDeviceAddress )
{
	static DWORD	dwFoo = 12;
	HRESULT			hResultCode;
	DIRECTNETOBJECT	*pdnObject;
	CAsyncOp		*pAsyncOp;
#ifdef	DEBUG
	CHAR			DP8ABuffer[512];
	DWORD			DP8ASize;
#endif

	DPFX(DPFPREP, 6,"Parameters: pvCommandContext [0x%p], hr [0x%lx]",
			pvCommandContext,hr);

	DNASSERT(pvUserContext != NULL);
	DNASSERT(pvCommandContext != NULL);

	pdnObject = static_cast<DIRECTNETOBJECT*>(pvUserContext);
	pAsyncOp = static_cast<CAsyncOp*>(pvCommandContext);

	DPFX(DPFPREP, 7,"hr [0x%lx]",hr);
#ifdef	DEBUG
	DP8ASize = 512;
	pHostAddress->lpVtbl->GetURLA(pHostAddress,DP8ABuffer,&DP8ASize);
	DPFX(DPFPREP, 7,"Host address [%s]",DP8ABuffer);

	DP8ASize = 512;
	pDeviceAddress->lpVtbl->GetURLA(pDeviceAddress,DP8ABuffer,&DP8ASize);
	DPFX(DPFPREP, 7,"Device address [%s]",DP8ABuffer);
#endif

	if (hr == DPN_OK)
	{
		hResultCode = DNPerformNextConnect(pdnObject,pAsyncOp,pHostAddress,pDeviceAddress);
	}

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNPIAddressInfoEnum"

HRESULT DNPIAddressInfoEnum(void *const pvUserContext,
							void *const pvCommandContext,
							const HRESULT hr,
							IDirectPlay8Address *const pHostAddress,
							IDirectPlay8Address *const pDeviceAddress )
{
	static DWORD	dwFoo = 11;
	HRESULT			hResultCode;
	DIRECTNETOBJECT	*pdnObject;
	CAsyncOp		*pAsyncOp;

#ifdef	DEBUG
	CHAR			DP8ABuffer[512];
	DWORD			DP8ASize;
#endif

	DPFX(DPFPREP, 6,"Parameters: pvCommandContext [0x%p], hr [0x%lx]",
			pvCommandContext,hr);

	DNASSERT(pvUserContext != NULL);
	DNASSERT(pvCommandContext != NULL);

	pdnObject = static_cast<DIRECTNETOBJECT*>(pvUserContext);
	pAsyncOp = static_cast<CAsyncOp*>(pvCommandContext);

	DPFX(DPFPREP, 7,"hr [0x%lx]",hr);
#ifdef	DEBUG
	DP8ASize = 512;
	pHostAddress->lpVtbl->GetURLA(pHostAddress,DP8ABuffer,&DP8ASize);
	DPFX(DPFPREP, 7,"Host address [%s]",DP8ABuffer);

	DP8ASize = 512;
	pDeviceAddress->lpVtbl->GetURLA(pDeviceAddress,DP8ABuffer,&DP8ASize);
	DPFX(DPFPREP, 7,"Device address [%s]",DP8ABuffer);
#endif

	if (hr == DPN_OK)
	{
		//
		//	Crack open next enum only if not closing
		//
		if ((hResultCode = DNAddRefLock(pdnObject)) == DPN_OK)
		{
			hResultCode = DNPerformNextEnumQuery(pdnObject,pAsyncOp,pHostAddress,pDeviceAddress);
			DNDecRefLock(pdnObject);
		}
	}

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNPIAddressInfoListen"

HRESULT DNPIAddressInfoListen(void *const pvUserContext,
							  void *const pvCommandContext,
							  const HRESULT hr,
							  IDirectPlay8Address *const pDeviceAddress )
{
	static DWORD	dwFoo = 13;
	HRESULT			hResultCode;
	DIRECTNETOBJECT	*pdnObject;
	CAsyncOp		*pAsyncOp;
#ifdef	DEBUG
	CHAR			DP8ABuffer[512];
	DWORD			DP8ASize;
#endif

	DPFX(DPFPREP, 6,"Parameters: pvCommandContext [0x%p], hr [0x%lx]",
			pvCommandContext,hr);

	DNASSERT(pvUserContext != NULL);
	DNASSERT(pvCommandContext != NULL);

	pdnObject = static_cast<DIRECTNETOBJECT*>(pvUserContext);
	pAsyncOp = static_cast<CAsyncOp*>(pvCommandContext);

	DPFX(DPFPREP, 7,"hr [0x%lx]",hr);
#ifdef	DEBUG
	DP8ASize = 512;
	pDeviceAddress->lpVtbl->GetURLA(pDeviceAddress,DP8ABuffer,&DP8ASize);
	DPFX(DPFPREP, 7,"Device address [%s]",DP8ABuffer);
#endif

	if (hr == DPN_OK)
	{
		hResultCode = DNPerformNextListen(pdnObject,pAsyncOp,pDeviceAddress);
	}

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNProtocolAddRef"

void DNProtocolAddRef(DIRECTNETOBJECT *const pdnObject)
{
	LONG	lRefCount;

	DPFX(DPFPREP, 8,"Parameters: (none)");

	lRefCount = InterlockedIncrement(&pdnObject->lProtocolRefCount);

	DPFX(DPFPREP, 8,"Returning (lRefCount = [%ld])",lRefCount);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNProtocolRelease"

void DNProtocolRelease(DIRECTNETOBJECT *const pdnObject)
{
	LONG	lRefCount;

	DPFX(DPFPREP, 8,"Parameters: (none)");

	lRefCount = InterlockedDecrement(&pdnObject->lProtocolRefCount);

	DNASSERT(lRefCount >= 0);

	if (lRefCount == 0)
	{
		DPFX(DPFPREP, 9,"Signalling protocol shutdown !");
		if (pdnObject->hProtocolShutdownEvent)
		{
			pdnObject->hProtocolShutdownEvent->Set();
		}
	}

	DPFX(DPFPREP, 8,"Returning (lRefCount = [%ld])",lRefCount);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\ntentry.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       NTEntry.cpp
 *  Content:    NameTable Entry Objects
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/10/00	mjn		Created
 *	04/06/00	mjn		Added AvailableEvent to block pre-ADD_PLAYER-notification sends
 *	05/05/00	mjn		Added GetConnectionRef()
 *	05/16/00	mjn		Better locking during User notifications
 *	06/27/00	rmt		Added COM abstraction
 *	07/22/00	mjn		Pack/Unpack DNET version in DN_NAMETABLE_ENTRY_INFO
 *	07/26/00	mjn		Fix PackInfo() to handle NULL names and data
 *  08/03/00	rmt		Bug #41386 - Getting player info when no name and/or user data returns garbage in 
 *						name / data field.
 *	09/06/00	mjn		Changed SetAddress() to return void instead of HRESULT
 *	09/13/00	mjn		Added PerformQueuedOperations()
 *	09/17/00	mjn		Added NotifyAddRef() and NotifyRelease()
 *	09/28/00	mjn		Flag AutoDestruct groups in PackInfo()
 *	10/11/00	mjn		Don't take locks in PackInfo()
 *	01/25/01	mjn		Fixed 64-bit alignment problem when unpacking entries
 *	04/19/01	mjn		Lock entry when packing in PackEntryInfo()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


void CNameTableEntry::ReturnSelfToPool( void )
{
	m_pdnObject->m_pFPOOLNameTableEntry->Release( this );
};


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTableEntry::Release"

void CNameTableEntry::Release(void)
{
	LONG	lRefCount;

	DNASSERT(m_lRefCount > 0);
	lRefCount = InterlockedDecrement(const_cast<LONG*>(&m_lRefCount));
	DPFX(DPFPREP, 3,"NameTableEntry::Release [0x%p] RefCount [0x%lx]",this,lRefCount);
	if (lRefCount == 0)
	{
		DNASSERT(!(m_dwFlags & NAMETABLE_ENTRY_FLAG_AVAILABLE));

		DNASSERT(m_bilinkDeleted.IsEmpty());
		DNASSERT(m_bilinkMembership.IsEmpty());
		DNASSERT(m_bilinkConnections.IsEmpty());
		DNASSERT(m_bilinkQueuedMsgs.IsEmpty());

		if (m_pAddress)
		{
			m_pAddress->lpVtbl->Release(m_pAddress);
			m_pAddress = NULL;
		}
		if (m_pConnection)
		{
			m_pConnection->Release();
			m_pConnection = NULL;
		}
		if (m_pwszName)
		{
			DNFree(m_pwszName);
			m_pwszName = NULL;
		}
		if (m_pvData)
		{
			DNFree(m_pvData);
			m_pvData = NULL;
			m_dwDataSize = 0;
		}
		m_dwFlags = 0;
		m_lRefCount = 0;
		ReturnSelfToPool();
	}
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTableEntry::NotifyAddRef"

void CNameTableEntry::NotifyAddRef( void )
{
	LONG	lRefCount;

	lRefCount = InterlockedIncrement( const_cast<LONG*>(&m_lNotifyRefCount) );
	DNASSERT( lRefCount >= 0 );
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTableEntry::NotifyRelease"

void CNameTableEntry::NotifyRelease( void )
{
	LONG	lRefCount;

	lRefCount = InterlockedDecrement( const_cast<LONG*>(&m_lNotifyRefCount) );
	DNASSERT( lRefCount >= 0 );

	if (lRefCount == 0)
	{
		Lock();
//		DNASSERT(IsDisconnecting());
		if (IsNeedToDestroy())
		{
			Unlock();

			//
			//	Generate notifications
			//
			if (IsGroup())
			{
				if (!IsAllPlayersGroup())
				{
					DNUserDestroyGroup(m_pdnObject,this);
				}
			}
			else
			{
				if (IsIndicated() && !IsCreated())
				{
					DNUserIndicatedConnectAborted(m_pdnObject,m_pvContext);
				}
				else
				{
					DNASSERT(IsCreated());
					DNUserDestroyPlayer(m_pdnObject,this);
				}
			}

			m_pdnObject->NameTable.WriteLock();
			Lock();
			m_bilinkDeleted.RemoveFromList();
			m_pdnObject->NameTable.Unlock();
			ClearNeedToDestroy();
			ClearCreated();
		}
		Unlock();
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CNameTableEntry::UpdateEntryInfo"

HRESULT CNameTableEntry::UpdateEntryInfo(UNALIGNED WCHAR *const pwszName,
										 const DWORD dwNameSize,
										 void *const pvData,
										 const DWORD dwDataSize,
										 const DWORD dwInfoFlags,
										 BOOL fNotify)
{
	PWSTR	pwszTempName;
	DWORD	dwTempNameSize;
	void	*pvTempData;
	DWORD	dwTempDataSize;

	Lock();

	if (dwInfoFlags & DPNINFO_NAME)
	{
		if (pwszName && dwNameSize)
		{
			if ((pwszTempName = static_cast<WCHAR*>(DNMalloc(dwNameSize))) == NULL)
			{
				return(DPNERR_OUTOFMEMORY);
			}
			memcpy(pwszTempName,pwszName,dwNameSize);
			dwTempNameSize = dwNameSize;
		}
		else
		{
			pwszTempName = NULL;
			dwTempNameSize = 0;
		}
		if (m_pwszName)
		{
			DNFree(m_pwszName);
		}
		m_pwszName = pwszTempName;
		m_dwNameSize = dwTempNameSize;
	}
	if (dwInfoFlags & DPNINFO_DATA)
	{
		if (pvData && dwDataSize)
		{
			if ((pvTempData = DNMalloc(dwDataSize)) == NULL)
			{
				return(DPNERR_OUTOFMEMORY);
			}
			memcpy(pvTempData,pvData,dwDataSize);
			dwTempDataSize = dwDataSize;
		}
		else
		{
			pvTempData = NULL;
			dwTempDataSize = 0;
		}
		if (m_pvData)
		{
			DNFree(m_pvData);
		}
		m_pvData = pvTempData;
		m_dwDataSize = dwTempDataSize;
	}

	// Generate notifications
	if (m_dwFlags & NAMETABLE_ENTRY_FLAG_AVAILABLE && fNotify)
	{
		DPNID dpnid = m_dpnid;
		PVOID pvContext = m_pvContext;
		DIRECTNETOBJECT* pdnObject = m_pdnObject;

		if (m_dwFlags & NAMETABLE_ENTRY_FLAG_GROUP)
		{
			Unlock();
			DNUserUpdateGroupInfo(pdnObject,dpnid,pvContext);
		}
		else
		{
			if (m_dwFlags & NAMETABLE_ENTRY_FLAG_PEER)
			{
				Unlock();
				DNUserUpdatePeerInfo(pdnObject,dpnid,pvContext);
			}
			else if (m_dwFlags & NAMETABLE_ENTRY_FLAG_CLIENT && pdnObject->dwFlags & DN_OBJECT_FLAG_SERVER)
			{
				Unlock();
				DNUserUpdateClientInfo(pdnObject,dpnid,pvContext);
			}
			else if (m_dwFlags & NAMETABLE_ENTRY_FLAG_SERVER && pdnObject->dwFlags & DN_OBJECT_FLAG_CLIENT)
			{
				Unlock();
				// Clients do not get to see server's DPNID or context
				DNUserUpdateServerInfo(pdnObject,0,0);
			}
			else
			{
				Unlock();
				DNASSERT(FALSE);
			}
		}
	}
	else
	{
		Unlock();
	}

	return(DPN_OK);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTableEntry::SetAddress"

void CNameTableEntry::SetAddress( IDirectPlay8Address *const pAddress )
{
	if (pAddress)
	{
		pAddress->lpVtbl->AddRef(pAddress);
	}

	if (m_pAddress)
	{
		m_pAddress->lpVtbl->Release(m_pAddress);
		m_pAddress = NULL;
	}
	m_pAddress = pAddress;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTableEntry::SetConnection"

void CNameTableEntry::SetConnection( CConnection *const pConnection )
{
	if (pConnection)
	{
		pConnection->AddRef();
	}
	m_pConnection = pConnection;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTableEntry::GetConnectionRef"

HRESULT	CNameTableEntry::GetConnectionRef( CConnection **const ppConnection )
{
	HRESULT		hResultCode;

	DNASSERT( ppConnection != NULL);

	Lock();
	if ( m_pConnection && !m_pConnection->IsInvalid())
	{
		m_pConnection->AddRef();
		*ppConnection = m_pConnection;
		hResultCode = DPN_OK;
	}
	else
	{
		hResultCode = DPNERR_NOCONNECTION;
	}
	Unlock();

	return( hResultCode );
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTableEntry::PackInfo"

HRESULT CNameTableEntry::PackInfo(CPackedBuffer *const pPackedBuffer)
{
	HRESULT			hResultCode;
	DPN_PLAYER_INFO	*pPlayerInfo;
	DPN_GROUP_INFO	*pGroupInfo;

	DNASSERT(pPackedBuffer != NULL);

//	Lock();
	if (m_dwFlags & NAMETABLE_ENTRY_FLAG_GROUP)
	{
		pGroupInfo = static_cast<DPN_GROUP_INFO*>(pPackedBuffer->GetHeadAddress());
		hResultCode = pPackedBuffer->AddToFront(NULL,sizeof(DPN_GROUP_INFO));
		
		//
		//	Add data
		//
		if ((m_pvData) && (m_dwDataSize != 0))
		{
			if ((hResultCode = pPackedBuffer->AddToBack(m_pvData,m_dwDataSize)) == DPN_OK)
			{
				pGroupInfo->pvData = pPackedBuffer->GetTailAddress();
				pGroupInfo->dwDataSize = m_dwDataSize;
			}
		}
		else
		{
			if (pGroupInfo)
			{
				pGroupInfo->pvData = NULL;
				pGroupInfo->dwDataSize = 0;
			}
		}

		//
		//	Add name
		//
		if ((m_pwszName) && (m_dwNameSize != 0))
		{
			if ((hResultCode = pPackedBuffer->AddToBack(m_pwszName,m_dwNameSize)) == DPN_OK)
			{
				pGroupInfo->pwszName = static_cast<WCHAR*>(pPackedBuffer->GetTailAddress());
			}
		}
		else
		{
			if (pGroupInfo)
			{
				pGroupInfo->pwszName = NULL;
			}
		}

		//
		//	Update flags
		//
		if (hResultCode == DPN_OK)
		{
			if (pGroupInfo)
			{
				pGroupInfo->dwSize = sizeof(DPN_GROUP_INFO);
				pGroupInfo->dwInfoFlags = DPNINFO_NAME | DPNINFO_DATA;
				pGroupInfo->dwGroupFlags = 0;
				if (IsAutoDestructGroup())
				{
					pGroupInfo->dwGroupFlags |= DPNGROUP_AUTODESTRUCT;
				}
			}
		}
	}
	else
	{
		pPlayerInfo = static_cast<DPN_PLAYER_INFO*>(pPackedBuffer->GetHeadAddress());
		hResultCode = pPackedBuffer->AddToFront(NULL,sizeof(DPN_PLAYER_INFO));

		if( !m_dwDataSize )
		{
			if( pPlayerInfo )
			{
				pPlayerInfo->pvData = NULL;
				pPlayerInfo->dwDataSize = 0;
			}
		}
		else
		{
			if ((hResultCode = pPackedBuffer->AddToBack(m_pvData,m_dwDataSize)) == DPN_OK)
			{
				pPlayerInfo->pvData = pPackedBuffer->GetTailAddress();
				pPlayerInfo->dwDataSize = m_dwDataSize;
			}
		}

		if( !m_pwszName )
		{
			if( pPlayerInfo )
			{
				pPlayerInfo->pwszName = NULL;
			}
		}
		else
		{
			if ((hResultCode = pPackedBuffer->AddToBack(m_pwszName,m_dwNameSize)) == DPN_OK)
			{
				pPlayerInfo->pwszName = static_cast<WCHAR*>(pPackedBuffer->GetTailAddress());
			}
		}
		
		if (hResultCode == DPN_OK)
		{
			pPlayerInfo->dwSize = sizeof(DPN_PLAYER_INFO);
			pPlayerInfo->dwInfoFlags = DPNINFO_NAME | DPNINFO_DATA;
			pPlayerInfo->dwPlayerFlags = 0;
			if (m_dwFlags & NAMETABLE_ENTRY_FLAG_HOST)
			{
				pPlayerInfo->dwPlayerFlags |= DPNPLAYER_HOST;
			}
			if (m_dwFlags & NAMETABLE_ENTRY_FLAG_LOCAL)
			{
				pPlayerInfo->dwPlayerFlags |= DPNPLAYER_LOCAL;
			}
		}
	}
//	Unlock();

	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTableEntry::PackEntryInfo"

HRESULT CNameTableEntry::PackEntryInfo(CPackedBuffer *const pPackedBuffer)
{
	DWORD			dwURLSize;
	HRESULT			hResultCode;
	DN_NAMETABLE_ENTRY_INFO			dnEntryInfo;

	DPFX(DPFPREP, 6,"Attempting to pack [0x%lx]",m_dpnid);

	DNASSERT(pPackedBuffer != NULL);

	Lock();

	dnEntryInfo.dpnid = m_dpnid;
	dnEntryInfo.dpnidOwner = m_dpnidOwner;
	dnEntryInfo.dwFlags = m_dwFlags & (		NAMETABLE_ENTRY_FLAG_HOST
										|	NAMETABLE_ENTRY_FLAG_ALL_PLAYERS_GROUP
										|	NAMETABLE_ENTRY_FLAG_GROUP
										|	NAMETABLE_ENTRY_FLAG_GROUP_AUTODESTRUCT
										|	NAMETABLE_ENTRY_FLAG_PEER
										|	NAMETABLE_ENTRY_FLAG_CLIENT
										|	NAMETABLE_ENTRY_FLAG_SERVER );
	dnEntryInfo.dwVersion = m_dwVersion;
	dnEntryInfo.dwVersionNotUsed = m_dwVersionNotUsed;
	dnEntryInfo.dwDNETVersion = m_dwDNETVersion;

	// Entry name
	if (m_pwszName != NULL)
	{
		if ((hResultCode = pPackedBuffer->AddToBack(m_pwszName,m_dwNameSize)) == DPN_OK)
		{
			dnEntryInfo.dwNameOffset = pPackedBuffer->GetTailOffset();
			dnEntryInfo.dwNameSize = m_dwNameSize;
		}
	}
	else
	{
		dnEntryInfo.dwNameOffset = 0;
		dnEntryInfo.dwNameSize = 0;
	}

	// Entry data
	if (m_pvData != NULL && m_dwDataSize != 0)
	{
		if ((hResultCode = pPackedBuffer->AddToBack(m_pvData,m_dwDataSize)) == DPN_OK)
		{
			dnEntryInfo.dwDataOffset = pPackedBuffer->GetTailOffset();
			dnEntryInfo.dwDataSize = m_dwDataSize;
		}
	}
	else
	{
		dnEntryInfo.dwDataOffset = 0;
		dnEntryInfo.dwDataSize = 0;
	}

	// Entry address (URL)
	if ((m_pdnObject->dwFlags & DN_OBJECT_FLAG_PEER) && (m_pAddress != NULL))
	{
		dwURLSize = 0;
		hResultCode = m_pAddress->lpVtbl->GetURLA(m_pAddress,NULL,&dwURLSize);
		if (hResultCode != DPN_OK && hResultCode != DPNERR_BUFFERTOOSMALL)
		{
			DPFERR("Could not determine URL size");
			DisplayDNError(0,hResultCode);
			Unlock();
			goto EXIT_PackEntry;
		}
		if (dwURLSize != 0)
		{
			if ((hResultCode = pPackedBuffer->AddToBack(NULL,dwURLSize)) == DPN_OK)
			{
				if ((hResultCode = m_pAddress->lpVtbl->GetURLA(m_pAddress,
						static_cast<char*>(pPackedBuffer->GetTailAddress()),&dwURLSize)) == DPN_OK)
				{
					dnEntryInfo.dwURLOffset = pPackedBuffer->GetTailOffset();
					dnEntryInfo.dwURLSize = dwURLSize;
				}
				else
				{
					DPFERR("Could not extract URL from DirectPlayAddress");
					DisplayDNError(0,hResultCode);
					Unlock();
					goto EXIT_PackEntry;
				}
			}
		}
		else
		{
			dnEntryInfo.dwURLOffset = 0;
			dnEntryInfo.dwURLSize = 0;
		}
	}
	else
	{
		dnEntryInfo.dwURLOffset = 0;
		dnEntryInfo.dwURLSize = 0;
	}

	hResultCode = pPackedBuffer->AddToFront(&dnEntryInfo,sizeof(DN_NAMETABLE_ENTRY_INFO));

	Unlock();

EXIT_PackEntry:

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTableEntry::UnpackEntryInfo"

HRESULT CNameTableEntry::UnpackEntryInfo(UNALIGNED DN_NAMETABLE_ENTRY_INFO *const pdnEntryInfo,
										 BYTE *const pBufferStart)
{
	HRESULT		hResultCode;
	PWSTR		pwszName;
	DWORD		dwNameSize;
	void		*pvData;
	DWORD		dwDataSize;
	IDirectPlay8Address	*pAddress;

	DNASSERT(m_pwszName == NULL);
	DNASSERT(m_pvData == NULL);
	DNASSERT(m_pAddress == NULL);

	if (pdnEntryInfo->dwNameOffset && pdnEntryInfo->dwNameSize)
	{
		pwszName = reinterpret_cast<WCHAR*>(pBufferStart + pdnEntryInfo->dwNameOffset);
		dwNameSize = pdnEntryInfo->dwNameSize;
	}
	else
	{
		pwszName = NULL;
		dwNameSize = 0;
	}

	if (pdnEntryInfo->dwDataOffset && pdnEntryInfo->dwDataSize)
	{
		pvData = static_cast<void*>(pBufferStart + pdnEntryInfo->dwDataOffset);
		dwDataSize = pdnEntryInfo->dwDataSize;
	}
	else
	{
		pvData = NULL;
		dwDataSize = 0;
	}

	// This function takes the lock internally
	UpdateEntryInfo(pwszName,dwNameSize,pvData,dwDataSize,DPNINFO_NAME|DPNINFO_DATA, FALSE);

	pAddress = NULL;
	if (pdnEntryInfo->dwURLOffset)
	{
		hResultCode = COM_CoCreateInstance(	CLSID_DirectPlay8Address,
										NULL,
										CLSCTX_INPROC_SERVER,
										IID_IDirectPlay8Address,
										reinterpret_cast<PVOID*>(&pAddress));
		if (hResultCode != S_OK)
		{
			DPFERR("Could not create empty DirectPlayAddress");
			DisplayDNError(0,hResultCode);
			return(DPNERR_OUTOFMEMORY);
		}
		hResultCode = pAddress->lpVtbl->BuildFromURLA(pAddress,reinterpret_cast<char*>(pBufferStart + pdnEntryInfo->dwURLOffset));
		if (hResultCode != DPN_OK)
		{
			DPFERR("Could not build URL");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			pAddress->lpVtbl->Release(pAddress);
			pAddress = NULL;
			return(hResultCode);
		}
		SetAddress(pAddress);
		pAddress->lpVtbl->Release(pAddress);
		pAddress = NULL;
	}

	m_dpnid = pdnEntryInfo->dpnid;
	m_dpnidOwner = pdnEntryInfo->dpnidOwner;
	m_dwFlags = pdnEntryInfo->dwFlags;
	m_dwDNETVersion = pdnEntryInfo->dwDNETVersion;
	m_dwVersion = pdnEntryInfo->dwVersion;
	m_dwVersionNotUsed = pdnEntryInfo->dwVersionNotUsed;

	return(DPN_OK);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTableEntry::PerformQueuedOperations"

void CNameTableEntry::PerformQueuedOperations( void )
{
	HRESULT		hResultCode;
	CQueuedMsg	*pQueuedMsg;
	BOOL		fDestroy;

	DPFX(DPFPREP, 6,"Parameters: (none)");

	fDestroy = FALSE;

	Lock();
	fDestroy = IsNeedToDestroy();

	//
	//	This assumes that the InUse flag is set.  We will clear it before returning.
	//
#ifdef DEBUG
	DNASSERT( IsInUse() );

	if (!m_bilinkQueuedMsgs.IsEmpty())
	{
		DPFX(DPFPREP, 7, "Nametable entry 0x%p has %i queued messages.", this, m_lNumQueuedMsgs);
	}
#endif // DEBUG

	while (!m_bilinkQueuedMsgs.IsEmpty())
	{
		pQueuedMsg = CONTAINING_OBJECT(m_bilinkQueuedMsgs.GetNext(),CQueuedMsg,m_bilinkQueuedMsgs);
		pQueuedMsg->m_bilinkQueuedMsgs.RemoveFromList();
		DEBUG_ONLY(m_lNumQueuedMsgs--);

		Unlock();

		switch (pQueuedMsg->GetOpType())
		{
			case	RECEIVE:
				{
					HRESULT		hrProcess;

					DNASSERT(pQueuedMsg->GetAsyncOp() != NULL);
					DNASSERT(pQueuedMsg->GetAsyncOp()->GetHandle() != 0);

					if (pQueuedMsg->IsVoiceMessage())
					{
						hrProcess = Voice_Receive(	m_pdnObject,
													GetDPNID(),
													0,
													pQueuedMsg->GetBuffer(),
													pQueuedMsg->GetBufferSize());

						NotifyRelease();

					}
					else
					{
						hrProcess = DNUserReceive(	m_pdnObject,
													this,
													pQueuedMsg->GetBuffer(),
													pQueuedMsg->GetBufferSize(),
													pQueuedMsg->GetAsyncOp()->GetHandle());
						if (pQueuedMsg->GetCompletionOp() != 0)
						{
							//
							//	Send completion message
							//
							CConnection	*pConnection;

							pConnection = NULL;
							if ((hResultCode = GetConnectionRef( &pConnection )) == DPN_OK)
							{
								hResultCode = DNSendUserProcessCompletion(	m_pdnObject,
																			pConnection,
																			pQueuedMsg->GetCompletionOp());
							}
							pConnection->Release();
							pConnection = NULL;
						}
					}

					//
					//	See if we can return this buffer now
					//
					if (hrProcess == DPNERR_PENDING)
					{
						pQueuedMsg->GetAsyncOp()->Release();
						pQueuedMsg->SetAsyncOp( NULL );
					}
					else
					{
						DNEnterCriticalSection(&m_pdnObject->csActiveList);
						pQueuedMsg->GetAsyncOp()->m_bilinkActiveList.RemoveFromList();
						DNLeaveCriticalSection(&m_pdnObject->csActiveList);
						pQueuedMsg->GetAsyncOp()->Lock();
						if (!pQueuedMsg->GetAsyncOp()->IsCancelled() && !pQueuedMsg->GetAsyncOp()->IsComplete())
						{
							pQueuedMsg->GetAsyncOp()->SetComplete();
							pQueuedMsg->GetAsyncOp()->Unlock();
							m_pdnObject->HandleTable.Destroy( pQueuedMsg->GetAsyncOp()->GetHandle() );
						}
						else
						{
							pQueuedMsg->GetAsyncOp()->Unlock();
						}
						pQueuedMsg->GetAsyncOp()->Release();
						pQueuedMsg->SetAsyncOp( NULL );
					}

					break;
				}
			default:
				{
					DPFERR("Invalid Queued Operation");
					DNASSERT(FALSE);
					break;
				}
		}

		//
		//	Return this queued message
		//
		pQueuedMsg->ReturnSelfToPool();
		pQueuedMsg = NULL;

		Lock();
		fDestroy = IsNeedToDestroy();
	}

	//
	//	No longer processing
	//
	ClearInUse();
	Unlock();

	DPFX(DPFPREP, 6,"Returning");
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTableEntry::DumpEntry"

void CNameTableEntry::DumpEntry(char *const pBuffer)
{
	char			*p;
	CBilink			*pBilink;
	CGroupMember	*pGroupMember;

	p = pBuffer;

	wsprintfA(p,"[0x%lx] ver[%ld,%ld] rc[%ld] [%S]",m_dpnid,m_dwVersion,m_dwLatestVersion,m_lRefCount,m_pwszName);
	p += strlen(p);

	if (IsAvailable())
	{
		wsprintfA(p," (available)");
		p += strlen(p);
	}
	if (IsConnecting())
	{
		wsprintfA(p," (connecting)");
		p += strlen(p);
	}
	if (IsDisconnecting())
	{
		wsprintfA(p," (disconnecting)");
		p += strlen(p);
	}
	if (IsLocal())
	{
		wsprintfA(p," (local)");
		p += strlen(p);
	}
	if (IsHost())
	{
		wsprintfA(p," (host)");
		p += strlen(p);
	}
	if (IsGroup())
	{
		wsprintfA(p," (group)");
		p += strlen(p);
	}
	if (IsAllPlayersGroup())
	{
		wsprintfA(p," (all players group)");
		p += strlen(p);
	}
	wsprintfA(p,"\r\n");
	p += strlen(p);

	pBilink = m_bilinkMembership.GetNext();
	while (pBilink != &m_bilinkMembership)
	{
		if (m_dwFlags & NAMETABLE_ENTRY_FLAG_GROUP)
		{
			pGroupMember = CONTAINING_OBJECT(pBilink,CGroupMember,m_bilinkPlayers);
			wsprintfA(p,"\t{[0x%lx] v[%ld]}",pGroupMember->GetPlayer()->GetDPNID(),pGroupMember->GetVersion());
		}
		else
		{
			pGroupMember = CONTAINING_OBJECT(pBilink,CGroupMember,m_bilinkGroups);
			wsprintfA(p,"\t{[0x%lx] v[%ld]}",pGroupMember->GetGroup()->GetDPNID(),pGroupMember->GetVersion());
		}
		p += strlen(p);

		pBilink = pBilink->GetNext();
	}
	wsprintfA(p,"\r\n");
	p += strlen(p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\nametable.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       NameTable.h
 *  Content:    NameTable Object Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/11/00	mjn		Created
 *	04/09/00	mjn		Track outstanding connections in NameTable
 *	05/03/00	mjn		Implemented GetHostPlayerRef, GetLocalPlayerRef, GetAllPlayersGroupRef
 *	07/20/00	mjn		Added ClearHostWithDPNID()
 *	07/30/00	mjn		Added hrReason to CNameTable::EmptyTable()
 *	08/23/00	mjn		Added CNameTableOp
 *	09/05/00	mjn		Added m_dpnidMask
 *				mjn		Removed dwIndex from InsertEntry()
 *	09/17/00	mjn		Split m_bilinkEntries into m_bilinkPlayers and m_bilinkGroups
 *				mjn		Changed AddPlayerToGroup and RemovePlayerFromGroup to use NameTableEntry params
 *	09/26/00	mjn		Removed locking from SetVersion(),GetNewVersion()
 *				mjn		Changed DWORD GetNewVersion(void) to void GetNewVersion( PDWORD )
 *	01/25/01	mjn		Fixed 64-bit alignment problem when unpacking NameTable
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__NAMETABLE_H__
#define	__NAMETABLE_H__

#include "ReadWriteLock.h"

#pragma BUGBUG(minara,"REMOVE THIS!")
#ifndef	VANCEO
#define	VANCEO
#endif

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_CORE

//
//	NameTable
//	
//	The NameTable consists of:
//		- an array of CNameTableEntry pointers
//		- short-cuts to the LocalPlayer, Host and AllPlayersGroup
//		- a version number
//
//	There is a list running through the free entries in the NameTable array.
//	When a free entry is required, it is taken from the front of this list,
//	and when an entry is released, it is added to the end of the list.
//	If a particular entry is required, it must be properly removed from the
//	list.  This may be a little time-consuming, since the entire list may
//	need to be traversed, but this will only happen on non-Host cases and
//	is a small price to pay to keep the Host case timely.
//

//
//	DPNIDs
//
//	DPNIDs are unique identifiers for NameTable entries.  They are constructed
//	from the NameTable array index and the version number of the entry.
//	The value 0x0 is invalid.  As a result, we must prevent it from being
//	generated.  Since the DPNID is constructed from two parts, we can do
//	this by ensuring that one of the two parts is never 0.  The best
//	solution is to ensure that the NameTable array index is never 0.
//	

//
//	Locking
//
//	When locking multiple entries in the NameTable, locks should be taken
//	in order based on DPNIDs.  e.g. Locking two entries with DPNIDs 200 and
//	101, the lock for 101 should be taken before the lock for 200.  Locks for
//	groups should be taken before locks for players.
//


//**********************************************************************
// Constant definitions
//**********************************************************************

#define NAMETABLE_INDEX_MASK			0x000FFFFF
#define NAMETABLE_VERSION_MASK			0xFFF00000
#define NAMETABLE_VERSION_SHIFT			20

#define	NAMETABLE_ARRAY_ENTRY_FLAG_VALID	0x0001

//**********************************************************************
// Macro definitions
//**********************************************************************

#define	CONSTRUCT_DPNID(i,v)	(((i & NAMETABLE_INDEX_MASK) | ((v << NAMETABLE_VERSION_SHIFT) & NAMETABLE_VERSION_MASK)) ^ m_dpnidMask)
#define	DECODE_INDEX(d)			((d ^ m_dpnidMask) & NAMETABLE_INDEX_MASK)
#define	VERIFY_VERSION(d,v)		(((d ^ m_dpnidMask) & NAMETABLE_VERSION_MASK) == (v << NAMETABLE_VERSION_SHIFT))

//**********************************************************************
// Structure definitions
//**********************************************************************

class CPackedBuffer;
class CConnection;
class CNameTableEntry;

typedef struct _DIRECTNETOBJECT DIRECTNETOBJECT;

typedef struct _NAMETABLE_ARRAY_ENTRY
{
	CNameTableEntry	*pNameTableEntry;
	DWORD			dwFlags;
} NAMETABLE_ARRAY_ENTRY;

typedef struct _DN_NAMETABLE_INFO
{
	DPNID	dpnid;
	DWORD	dwVersion;
	DWORD	dwVersionNotUsed;
	DWORD	dwEntryCount;
	DWORD	dwMembershipCount;
} DN_NAMETABLE_INFO;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************

// class for NameTable

class CNameTable
{
public:
	CNameTable()				// Constructor
		{
			m_Sig[0] = 'N';
			m_Sig[1] = 'T';
			m_Sig[2] = 'B';
			m_Sig[3] = 'L';
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CNameTable::~CNameTable"
	~CNameTable()
		{
		};			// Destructor

	HRESULT CNameTable::Initialize(DIRECTNETOBJECT *const pdnObject);

	void CNameTable::Deinitialize( void );

	void ReadLock( void )
		{
			m_RWLock.EnterReadLock();
		};

	void WriteLock( void )
		{
			m_RWLock.EnterWriteLock();
		};

	void Unlock( void )
		{
			m_RWLock.LeaveLock();
		};

	void CNameTable::ValidateArray( void );

	HRESULT CNameTable::GrowNameTable( void );

	#undef DPF_MODNAME
	#define DPF_MODNAME "CNameTable::GetFreeIndex"
	HRESULT CNameTable::GetFreeIndex(DWORD *const pdwFreeIndex)
		{
			DNASSERT(pdwFreeIndex != NULL);

			while (m_dwNumFreeEntries == 0)
			{
				if (GrowNameTable() != DPN_OK)
				{
					return(DPNERR_OUTOFMEMORY);
				}
			}
			DNASSERT(m_dwFirstFreeEntry != 0);
			*pdwFreeIndex = m_dwFirstFreeEntry;

			return(DPN_OK);
		};

	HRESULT CNameTable::UpdateTable(const DWORD dwIndex,
									CNameTableEntry *const pNameTableEntry);

	HRESULT CNameTable::InsertEntry(CNameTableEntry *const pNameTableEntry);

	void CNameTable::ReleaseEntry(const DWORD dwIndex);

	#undef DPF_MODNAME
	#define DPF_MODNAME "CNameTable::GetNewVersion"
	void GetNewVersion( DWORD *const pdwVersion )
		{
			DNASSERT( pdwVersion != NULL );

			*pdwVersion = ++m_dwVersion;

			DPFX(DPFPREP, 8,"Setting new version [%ld]",m_dwVersion);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CNameTable::SetVersion"
	void SetVersion( const DWORD dwVersion )
		{
			m_dwVersion = dwVersion;

			DPFX(DPFPREP, 8,"Setting new version [%ld]",m_dwVersion);
		};

	DWORD GetVersion( void )
		{
			return(m_dwVersion);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CNameTable::CreateDPNID"
	DPNID CreateDPNID( void )
		{
			DWORD	dwVersion;
			DWORD	dwIndex;
			DPNID	dpnid;

			if (GetFreeIndex(&dwIndex) != DPN_OK)
				return(0);

			dwVersion = ++m_dwVersion;

			dpnid = CONSTRUCT_DPNID(dwIndex,dwVersion);
			DNASSERT(dpnid != 0);
			return(dpnid);
		};

	void CNameTable::EmptyTable( const HRESULT hrReason );

	HRESULT CNameTable::FindEntry(const DPNID dpnid,
								  CNameTableEntry **const ppNameTableEntry);

	HRESULT	CNameTable::FindDeletedEntry(const DPNID dpnid,
										 CNameTableEntry **const ppNTEntry);

	HRESULT	CNameTable::AddEntry(CNameTableEntry *const pNTEntry);

	HRESULT CNameTable::DeletePlayer(const DPNID dpnid,
									 DWORD *const pdwVersion);

	HRESULT CNameTable::DeleteGroup(const DPNID dpnid,
									DWORD *const pdwVersion);

	HRESULT CNameTable::AddPlayerToGroup(CNameTableEntry *const pGroup,
										 CNameTableEntry *const pPlayer,
										 DWORD *const pdwVersion);

	HRESULT CNameTable::RemovePlayerFromGroup(CNameTableEntry *const pGroup,
											  CNameTableEntry *const pPlayer,
											  DWORD *const pdwVersion);

	HRESULT CNameTable::RemoveAllPlayersFromGroup(CNameTableEntry *const pGroup);

	HRESULT CNameTable::RemoveAllGroupsFromPlayer(CNameTableEntry *const pPlayer);

	BOOL CNameTable::IsMember(const DPNID dpnidGroup,
							  const DPNID dpnidPlayer);

	HRESULT CNameTable::PackNameTable(CNameTableEntry *const pTarget,
									  CPackedBuffer *const pPackedBuffer);

	HRESULT	CNameTable::UnpackNameTableInfo(UNALIGNED DN_NAMETABLE_INFO *const pdnNTInfo,
											BYTE *const pBufferStart,
											DPNID *const pdpnid);

	CNameTableEntry *GetDefaultPlayer( void )
		{
			return(m_pDefaultPlayer);
		};

	void MakeLocalPlayer(CNameTableEntry *const pNameTableEntry);

	void CNameTable::ClearLocalPlayer( void );

	CNameTableEntry *GetLocalPlayer( void )
		{
			return(m_pLocalPlayer);
		};

	HRESULT CNameTable::GetLocalPlayerRef( CNameTableEntry **const ppNTEntry );

	void MakeHostPlayer(CNameTableEntry *const pNameTableEntry);

	void CNameTable::ClearHostPlayer( void );

	BOOL CNameTable::ClearHostWithDPNID( const DPNID dpnid );

	void CNameTable::UpdateHostPlayer( CNameTableEntry *const pNewHost );

	CNameTableEntry *GetHostPlayer( void )
		{
			return(m_pHostPlayer);
		};

	HRESULT CNameTable::GetHostPlayerRef( CNameTableEntry **const ppNTEntry );

	void MakeAllPlayersGroup(CNameTableEntry *const pNameTableEntry);

	void CNameTable::ClearAllPlayersGroup( void );

	CNameTableEntry *GetAllPlayersGroup( void )
		{
			return(m_pAllPlayersGroup);
		};

	HRESULT CNameTable::GetAllPlayersGroupRef( CNameTableEntry **const ppNTEntry );

	HRESULT CNameTable::PopulateConnection(CConnection *const pConnection);

	HRESULT CNameTable::PopulateGroup(CNameTableEntry *const pGroup);

	HRESULT CNameTable::AutoCreateGroups(CNameTableEntry *const pPlayer);

	HRESULT CNameTable::AutoDestructGroups(const DPNID dpnid);

	void CNameTable::SetLatestVersion( const DWORD dwVersion )
		{
			m_dwLatestVersion = dwVersion;
		};

	DWORD CNameTable::GetLatestVersion( void )
		{
			return( m_dwLatestVersion );
		};

	void CNameTable::SetConnectVersion(const DWORD dwVersion)
		{
			m_dwConnectVersion = dwVersion;
		};

	DWORD CNameTable::GetConnectVersion( void )
		{
			return(m_dwConnectVersion);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CNameTable::IncOutstandingConnections"
	void IncOutstandingConnections( void )
		{
			long	lRefCount;

			lRefCount = InterlockedIncrement(&m_lOutstandingConnections);
			DNASSERT(lRefCount > 0);
		};

	void SetDPNIDMask( const DPNID dpnidMask )
		{
			m_dpnidMask = dpnidMask;
		};

	DPNID GetDPNIDMask( void )
		{
			return( m_dpnidMask );
		};

	void CNameTable::DecOutstandingConnections( void );

	void CNameTable::DumpNameTable(char *const Buffer);

	CBilink		m_bilinkPlayers;
	CBilink		m_bilinkGroups;
	CBilink		m_bilinkDeleted;
	CBilink		m_bilinkNameTableOps;

private:
	BYTE					m_Sig[4];
	DIRECTNETOBJECT			*m_pdnObject;

	DPNID					m_dpnidMask;

	CNameTableEntry			*m_pDefaultPlayer;
	CNameTableEntry			*m_pLocalPlayer;
	CNameTableEntry			*m_pHostPlayer;
	CNameTableEntry			*m_pAllPlayersGroup;

	NAMETABLE_ARRAY_ENTRY	*m_NameTableArray;
	DWORD					m_dwNameTableSize;
	DWORD					m_dwFirstFreeEntry;
	DWORD					m_dwLastFreeEntry;
	DWORD					m_dwNumFreeEntries;

	DWORD					m_dwVersion;

	DWORD					m_dwLatestVersion;	// Only used by Host in PEER

	DWORD					m_dwConnectVersion;
	LONG					m_lOutstandingConnections;

	CReadWriteLock			m_RWLock;
};

#undef DPF_MODNAME

#endif	// __NAMETABLE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\ntop.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       NTOp.h
 *  Content:    NameTable Operation Object Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  09/23/00	mjn		Created
 *	03/30/01	mjn		Changes to prevent multiple loading/unloading of SP's
 *				mjn		Added m_pSP, SetSP(), GetSP()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__NT_OP_H__
#define	__NT_OP_H__

#include "ServProv.h"

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	NAMETABLE_OP_FLAG_IN_USE	0x0001

//**********************************************************************
// Macro definitions
//**********************************************************************

#ifndef	OFFSETOF
#define OFFSETOF(s,m)				( ( INT_PTR ) ( ( PVOID ) &( ( (s*) 0 )->m ) ) )
#endif

#ifndef	CONTAINING_OBJECT
#define	CONTAINING_OBJECT(b,t,m)	(reinterpret_cast<t*>(&reinterpret_cast<BYTE*>(b)[-OFFSETOF(t,m)]))
#endif

//**********************************************************************
// Structure definitions
//**********************************************************************

class CNameTableOp;
template< class CNameTableOp > class CLockedContextClassFixedPool;

class CRefCountBuffer;
class CServiceProvider;

typedef struct _DIRECTNETOBJECT DIRECTNETOBJECT;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************

// class for NameTable Operations

class CNameTableOp
{
public:
	CNameTableOp()				// Constructor
		{
			m_Sig[0] = 'N';
			m_Sig[1] = 'T';
			m_Sig[2] = 'O';
			m_Sig[3] = 'P';
		};

	~CNameTableOp() { };			// Destructor

	BOOL FPMAlloc(void *const pvContext)
		{
			m_pdnObject = static_cast<DIRECTNETOBJECT*>(pvContext);

			return(TRUE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CNameTableOp::FPMInitialize"
	BOOL FPMInitialize(void *const pvContext)
		{
			DNASSERT(m_pdnObject == pvContext);

			m_dwFlags = 0;
			m_dwMsgId = 0;
			m_dwVersion = 0;
			m_dwVersionNotUsed = 0;

			m_pRefCountBuffer = NULL;
			m_pSP = NULL;

			m_bilinkNameTableOps.Initialize();

			return(TRUE);
		};

	void FPMRelease(void *const pvContext) { };

	void FPMDealloc(void *const pvContext) { };

	void ReturnSelfToPool( void )
		{
			m_pdnObject->m_pFPOOLNameTableOp->Release( this );
		};

	void SetInUse( void )
		{
			m_dwFlags |= NAMETABLE_OP_FLAG_IN_USE;
		};

	BOOL IsInUse( void )
		{
			if (m_dwFlags & NAMETABLE_OP_FLAG_IN_USE)
			{
				return( TRUE );
			}
			return( FALSE );
		};

	void SetMsgId( const DWORD dwMsgId )
		{
			m_dwMsgId = dwMsgId;
		};

	DWORD GetMsgId( void )
		{
			return( m_dwMsgId );
		};

	void SetVersion( const DWORD dwVersion )
		{
			m_dwVersion = dwVersion;
		};

	DWORD GetVersion( void )
		{
			return( m_dwVersion );
		};

	void SetRefCountBuffer( CRefCountBuffer *const pRefCountBuffer )
		{
			if (pRefCountBuffer)
			{
				pRefCountBuffer->AddRef();
			}
			m_pRefCountBuffer = pRefCountBuffer;
		};

	CRefCountBuffer *GetRefCountBuffer( void )
		{
			return( m_pRefCountBuffer );
		};

	void SetSP( CServiceProvider *const pSP )
		{
			if (pSP)
			{
				pSP->AddRef();
			}
			m_pSP = pSP;
		};

	CServiceProvider *GetSP( void )
		{
			return( m_pSP );
		};

	CBilink				m_bilinkNameTableOps;

private:
	BYTE				m_Sig[4];			// Signature
	DWORD				m_dwFlags;
	DWORD				m_dwMsgId;
	DWORD				m_dwVersion;
	DWORD				m_dwVersionNotUsed;

	CRefCountBuffer		*m_pRefCountBuffer;

	CServiceProvider	*m_pSP;

	DIRECTNETOBJECT		*m_pdnObject;
};

#undef DPF_MODNAME

#endif	// __NT_OP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\ntentry.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       NTEntry.h
 *  Content:    NameTable Entry Object Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/07/00	mjn		Created
 *	04/06/00	mjn		Added AvailableEvent to block pre-ADD_PLAYER-notification sends
 *	05/05/00	mjn		Added GetConnectionRef()
 *	07/22/00	mjn		Added m_dwDNETVersion
 *	07/29/00	mjn		Added SetIndicated(),ClearIndicated(),IsIndicated()
 *	07/30/00	mjn		Added m_dwDestoyReason
 *	08/02/00	mjn		Added m_bilinkQueuedMsgs
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *	08/08/00	mjn		Added SetCreated(),ClearCreated(),IsCreated()
 *				mjn		Added SetNeedToDestroy(),ClearNeedToDestroy(),IsNeedToDestroy()
 *	09/06/00	mjn		Changed SetAddress() to return void instead of HRESULT
 *	09/12/00	mjn		Added NAMETABLE_ENTRY_FLAG_IN_USE
 *	09/17/00	mjn		Added m_lNotifyRefCount
 *	01/25/01	mjn		Fixed 64-bit alignment problem when unpacking entries
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__NTENTRY_H__
#define	__NTENTRY_H__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_CORE

//**********************************************************************
// Constant definitions
//**********************************************************************

//
//	NameTable Entry Status Flags:
//
//		INDICATED		App was given an INDICATE_CONNECTION message
//
//		CREATED			App was given a CREATE_PLAYER message
//
//		AVAILABLE		The entry is available for use.
//
//		CONNECTING		The player is in the process of connecting.
//
//		DISCONNECTING	The player/group is in the process of disconnecting.
//

#define	NAMETABLE_ENTRY_FLAG_LOCAL				0x00001
#define	NAMETABLE_ENTRY_FLAG_HOST				0x00002
#define	NAMETABLE_ENTRY_FLAG_ALL_PLAYERS_GROUP	0x00004
#define	NAMETABLE_ENTRY_FLAG_GROUP				0x00010
#define	NAMETABLE_ENTRY_FLAG_GROUP_MULTICAST	0x00020
#define	NAMETABLE_ENTRY_FLAG_GROUP_AUTODESTRUCT	0x00040
#define	NAMETABLE_ENTRY_FLAG_PEER				0x00100
#define NAMETABLE_ENTRY_FLAG_CLIENT				0x00200
#define	NAMETABLE_ENTRY_FLAG_SERVER				0x00400
#define	NAMETABLE_ENTRY_FLAG_CONNECTING			0x01000
#define	NAMETABLE_ENTRY_FLAG_AVAILABLE			0x02000
#define	NAMETABLE_ENTRY_FLAG_DISCONNECTING		0x04000
#define	NAMETABLE_ENTRY_FLAG_INDICATED			0x10000	//	INDICATE_CONNECT
#define NAMETABLE_ENTRY_FLAG_CREATED			0x20000	//	CREATE_PLAYER
#define	NAMETABLE_ENTRY_FLAG_NEED_TO_DESTROY	0x40000
#define	NAMETABLE_ENTRY_FLAG_IN_USE				0x80000

//**********************************************************************
// Macro definitions
//**********************************************************************

#ifndef	OFFSETOF
#define OFFSETOF(s,m)				( ( INT_PTR ) ( ( PVOID ) &( ( (s*) 0 )->m ) ) )
#endif

#ifndef	CONTAINING_OBJECT
#define	CONTAINING_OBJECT(b,t,m)	(reinterpret_cast<t*>(&reinterpret_cast<BYTE*>(b)[-OFFSETOF(t,m)]))
#endif

//**********************************************************************
// Structure definitions
//**********************************************************************

template< class CNameTableEntry > class CLockedContextClassFixedPool;

typedef struct IDirectPlay8Address	IDirectPlay8Address;
typedef struct _DIRECTNETOBJECT DIRECTNETOBJECT;

class CPackedBuffer;
class CConnection;

//
//	Used to pass the NameTable entries
//
typedef struct _DN_NAMETABLE_ENTRY_INFO
{
	DPNID	dpnid;
	DPNID	dpnidOwner;
	DWORD	dwFlags;
	DWORD	dwVersion;
	DWORD	dwVersionNotUsed;
	DWORD	dwDNETVersion;
	DWORD	dwNameOffset;
	DWORD	dwNameSize;
	DWORD	dwDataOffset;
	DWORD	dwDataSize;
	DWORD	dwURLOffset;
	DWORD	dwURLSize;
} DN_NAMETABLE_ENTRY_INFO;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************

// class for NameTable Entries

class CNameTableEntry
{
public:
	CNameTableEntry()				// Constructor
		{
			m_Sig[0] = 'N';
			m_Sig[1] = 'T';
			m_Sig[2] = 'E';
			m_Sig[3] = '*';
		};

	~CNameTableEntry() { };			// Destructor

	BOOL FPMAlloc(void *const pvContext)
		{
			m_pdnObject = static_cast<DIRECTNETOBJECT*>(pvContext);

			if (!DNInitializeCriticalSection(&m_csEntry))
			{
				return(FALSE);
			}
			DebugSetCriticalSectionRecursionCount(&m_csEntry,0);
			if (!DNInitializeCriticalSection(&m_csMembership))
			{
				DNDeleteCriticalSection(&m_csEntry);
				return(FALSE);
			}
			DebugSetCriticalSectionRecursionCount(&m_csMembership,0);
			if (!DNInitializeCriticalSection(&m_csConnections))
			{
				DNDeleteCriticalSection(&m_csMembership);
				DNDeleteCriticalSection(&m_csEntry);
				return(FALSE);
			}
			DebugSetCriticalSectionRecursionCount(&m_csConnections,0);

			return(TRUE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CNameTableEntry::FPMInitialize"
	BOOL FPMInitialize(void *const pvContext)
		{
			DNASSERT(m_pdnObject == pvContext);
			m_dpnid = 0;
			m_dpnidOwner = 0;
			m_pvContext = NULL;
			m_lRefCount = 1;
			m_lNotifyRefCount = 0;
			DEBUG_ONLY(m_lNumQueuedMsgs = 0);
			m_dwFlags = 0;
			m_dwDNETVersion = 0;
			m_dwVersion = 0;
			m_dwVersionNotUsed = 0;
			m_dwLatestVersion = 0;
			m_dwDestroyReason = 0;
			m_pwszName = NULL;
			m_dwNameSize = 0;
			m_pvData = NULL;
			m_dwDataSize = 0;
			m_pAddress = NULL;
			m_pConnection = NULL;
			m_bilinkEntries.Initialize();
			m_bilinkDeleted.Initialize();
			m_bilinkMembership.Initialize();
			m_bilinkConnections.Initialize();
			m_bilinkQueuedMsgs.Initialize();

			return(TRUE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CNameTableEntry::FPMRelease"
	void FPMRelease(void *const pvContext)
		{
			DNASSERT(m_bilinkEntries.IsEmpty());
			DNASSERT(m_bilinkDeleted.IsEmpty());
			DNASSERT(m_bilinkMembership.IsEmpty());
			DNASSERT(m_bilinkConnections.IsEmpty());
			DNASSERT(m_bilinkQueuedMsgs.IsEmpty());
		};

	void FPMDealloc(void *const pvContext)
		{
			DNDeleteCriticalSection(&m_csConnections);
			DNDeleteCriticalSection(&m_csMembership);
			DNDeleteCriticalSection(&m_csEntry);
		};

	void ReturnSelfToPool( void );

	void Lock( void )
		{
			DNEnterCriticalSection(&m_csEntry);
		};

	void Unlock( void )
		{
			DNLeaveCriticalSection(&m_csEntry);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CNameTableEntry::AddRef"
	void AddRef(void)
		{
			LONG	lRefCount;

			DNASSERT(m_lRefCount > 0);
			lRefCount = InterlockedIncrement(const_cast<LONG*>(&m_lRefCount));
			DPFX(DPFPREP, 3,"NameTableEntry::AddRef [0x%p] RefCount [0x%lx]",this,lRefCount);
		};

	void Release(void);

	void CNameTableEntry::NotifyAddRef( void );

	void CNameTableEntry::NotifyRelease( void );

	void MakeLocal( void )
		{
			m_dwFlags |= NAMETABLE_ENTRY_FLAG_LOCAL;
		};

	BOOL IsLocal( void )
		{
			if (m_dwFlags & NAMETABLE_ENTRY_FLAG_LOCAL)
				return(TRUE);

			return(FALSE);
		};

	void MakeHost( void )
		{
			m_dwFlags |= NAMETABLE_ENTRY_FLAG_HOST;
		};

	BOOL IsHost( void )
		{
			if (m_dwFlags & NAMETABLE_ENTRY_FLAG_HOST)
				return(TRUE);

			return(FALSE);
		};

	void MakeAllPlayersGroup( void )
		{
			m_dwFlags |= NAMETABLE_ENTRY_FLAG_ALL_PLAYERS_GROUP;
		};

	BOOL IsAllPlayersGroup( void )
		{
			if (m_dwFlags & NAMETABLE_ENTRY_FLAG_ALL_PLAYERS_GROUP)
				return(TRUE);

			return(FALSE);
		};

	void MakeGroup( void )
		{
			m_dwFlags |= NAMETABLE_ENTRY_FLAG_GROUP;
		};

	BOOL IsGroup( void )
		{
			if (m_dwFlags & NAMETABLE_ENTRY_FLAG_GROUP)
				return(TRUE);

			return(FALSE);
		};

	void MakeMulticastGroup( void )
		{
			m_dwFlags |= NAMETABLE_ENTRY_FLAG_GROUP_MULTICAST;
		};

	BOOL IsMulticastGroup( void )
		{
			if (m_dwFlags & NAMETABLE_ENTRY_FLAG_GROUP_MULTICAST)
				return(TRUE);

			return(FALSE);
		};

	void MakeAutoDestructGroup( void )
		{
			m_dwFlags |= NAMETABLE_ENTRY_FLAG_GROUP_AUTODESTRUCT;
		};

	BOOL IsAutoDestructGroup( void )
		{
			if (m_dwFlags & NAMETABLE_ENTRY_FLAG_GROUP_AUTODESTRUCT)
				return(TRUE);

			return(FALSE);
		};

	void MakePeer( void )
		{
			m_dwFlags |= NAMETABLE_ENTRY_FLAG_PEER;
		};

	BOOL IsPeer( void )
		{
			if (m_dwFlags & NAMETABLE_ENTRY_FLAG_PEER)
				return(TRUE);

			return(FALSE);
		};

	void MakeClient( void )
		{
			m_dwFlags |= NAMETABLE_ENTRY_FLAG_CLIENT;
		};

	BOOL IsClient( void )
		{
			if (m_dwFlags & NAMETABLE_ENTRY_FLAG_CLIENT)
				return(TRUE);

			return(FALSE);
		};

	void MakeServer( void )
		{
			m_dwFlags |= NAMETABLE_ENTRY_FLAG_SERVER;
		};

	BOOL IsServer( void )
		{
			if (m_dwFlags & NAMETABLE_ENTRY_FLAG_SERVER)
				return(TRUE);

			return(FALSE);
		};

	void MakeAvailable( void )
		{
			m_dwFlags |= NAMETABLE_ENTRY_FLAG_AVAILABLE;
		};

	void MakeUnavailable( void )
		{
			m_dwFlags &= (~NAMETABLE_ENTRY_FLAG_AVAILABLE);
		};

	BOOL IsAvailable( void )
		{
			if (m_dwFlags & NAMETABLE_ENTRY_FLAG_AVAILABLE)
				return(TRUE);

			return(FALSE);
		};

	void SetIndicated( void )
		{
			m_dwFlags |= NAMETABLE_ENTRY_FLAG_INDICATED;
		};

	void ClearIndicated( void )
		{
			m_dwFlags &= (~NAMETABLE_ENTRY_FLAG_INDICATED);
		};

	BOOL IsIndicated( void )
		{
			if (m_dwFlags & NAMETABLE_ENTRY_FLAG_INDICATED)
			{
				return(TRUE);
			}
			return(FALSE);
		};

	void SetCreated( void )
		{
			m_dwFlags |= NAMETABLE_ENTRY_FLAG_CREATED;
		};

	void ClearCreated( void )
		{
			m_dwFlags &= (~NAMETABLE_ENTRY_FLAG_CREATED);
		};

	BOOL IsCreated( void )
		{
			if (m_dwFlags & NAMETABLE_ENTRY_FLAG_CREATED)
			{
				return(TRUE);
			}
			return(FALSE);
		};

	void SetNeedToDestroy( void )
		{
			m_dwFlags |= NAMETABLE_ENTRY_FLAG_NEED_TO_DESTROY;
		};

	void ClearNeedToDestroy( void )
		{
			m_dwFlags &= (~NAMETABLE_ENTRY_FLAG_NEED_TO_DESTROY);
		};

	BOOL IsNeedToDestroy( void )
		{
			if (m_dwFlags & NAMETABLE_ENTRY_FLAG_NEED_TO_DESTROY)
			{
				return(TRUE);
			}
			return(FALSE);
		};

	void SetInUse( void )
		{
			m_dwFlags |= NAMETABLE_ENTRY_FLAG_IN_USE;
		};

	void ClearInUse( void )
		{
			m_dwFlags &= (~NAMETABLE_ENTRY_FLAG_IN_USE);
		};

	BOOL IsInUse( void )
		{
			if (m_dwFlags & NAMETABLE_ENTRY_FLAG_IN_USE)
			{
				return( TRUE );
			}
			return( FALSE );
		};

	void StartConnecting( void )
		{
			m_dwFlags |= NAMETABLE_ENTRY_FLAG_CONNECTING;
		};

	void StopConnecting( void )
		{
			m_dwFlags &= (~NAMETABLE_ENTRY_FLAG_CONNECTING);
		};

	BOOL IsConnecting( void )
		{
			if (m_dwFlags & NAMETABLE_ENTRY_FLAG_CONNECTING)
				return(TRUE);

			return(FALSE);
		};

	void CNameTableEntry::StartDisconnecting( void )
		{
			m_dwFlags |= NAMETABLE_ENTRY_FLAG_DISCONNECTING;
		};

	void StopDisconnecting( void )
		{
			m_dwFlags &= (~NAMETABLE_ENTRY_FLAG_DISCONNECTING);
		};

	BOOL IsDisconnecting( void )
		{
			if (m_dwFlags & NAMETABLE_ENTRY_FLAG_DISCONNECTING)
				return(TRUE);

			return(FALSE);
		};

	void SetDPNID(const DPNID dpnid)
		{
			m_dpnid = dpnid;
		};

	DPNID GetDPNID(void)
		{
			return(m_dpnid);
		};

	void SetContext(void *const pvContext)
		{
			m_pvContext = pvContext;
		};

	void *GetContext(void)
		{
			return(m_pvContext);
		};

	void SetDNETVersion( const DWORD dwDNETVersion )
		{
			m_dwDNETVersion = dwDNETVersion;
		};

	DWORD GetDNETVersion( void )
		{
			return( m_dwDNETVersion );
		};

	void SetVersion(const DWORD dwVersion)
		{
			m_dwVersion = dwVersion;
		};

	DWORD GetVersion( void )
		{
			return(m_dwVersion);
		};

	void SetLatestVersion(const DWORD dwLatestVersion)
		{
			m_dwLatestVersion = dwLatestVersion;
		};

	DWORD GetLatestVersion( void )
		{
			return(m_dwLatestVersion);
		};

	void SetDestroyReason( const DWORD dwReason )
		{
			m_dwDestroyReason = dwReason;
		};

	DWORD GetDestroyReason( void )
		{
			return( m_dwDestroyReason );
		};

	HRESULT CNameTableEntry::UpdateEntryInfo(UNALIGNED WCHAR *const pwszName,
											 const DWORD dwNameSize,
											 void *const pvData,
											 const DWORD dwDataSize,
											 const DWORD dwInfoFlags,
											 BOOL fNotify);

	WCHAR *GetName( void )
		{
			return(m_pwszName);
		};

	DWORD GetNameSize( void )
		{
			return(m_dwNameSize);
		};

	void *GetData( void )
		{
			return(m_pvData);
		};

	DWORD GetDataSize( void )
		{
			return(m_dwDataSize);
		};

	void SetOwner(const DPNID dpnidOwner)
		{
			m_dpnidOwner = dpnidOwner;
		};

	DPNID GetOwner( void )
		{
			return(m_dpnidOwner);
		};

	void SetAddress( IDirectPlay8Address *const pAddress );

	IDirectPlay8Address *GetAddress( void )
		{
			return(m_pAddress);
		};

	void SetConnection( CConnection *const pConnection );

	CConnection *GetConnection( void )
		{
			return(m_pConnection);
		};

	HRESULT	CNameTableEntry::GetConnectionRef( CConnection **const ppConnection );

	HRESULT	CNameTableEntry::PackInfo(CPackedBuffer *const pPackedBuffer);

	HRESULT CNameTableEntry::PackEntryInfo(CPackedBuffer *const pPackedBuffer);

	HRESULT CNameTableEntry::UnpackEntryInfo(UNALIGNED DN_NAMETABLE_ENTRY_INFO *const pdnEntryInfo,
											 BYTE *const pBufferStart);

	void CNameTableEntry::PerformQueuedOperations(void);

	void CNameTableEntry::DumpEntry(char *const pBuffer);

	CBilink				m_bilinkEntries;
	CBilink				m_bilinkDeleted;
	CBilink				m_bilinkMembership;
	CBilink				m_bilinkConnections;
	CBilink				m_bilinkQueuedMsgs;
	DEBUG_ONLY(LONG		m_lNumQueuedMsgs);

private:
	BYTE				m_Sig[4];
	DPNID				m_dpnid;
	DPNID				m_dpnidOwner;
	void *				m_pvContext;
	LONG	volatile	m_lRefCount;
	LONG	volatile	m_lNotifyRefCount;
	DWORD	volatile	m_dwFlags;
	DWORD				m_dwDNETVersion;
	DWORD				m_dwVersion;
	DWORD				m_dwVersionNotUsed;
	DWORD	volatile	m_dwLatestVersion;
	DWORD	volatile	m_dwDestroyReason;
	PWSTR				m_pwszName;
	DWORD				m_dwNameSize;
	void *				m_pvData;
	DWORD				m_dwDataSize;
	IDirectPlay8Address	*m_pAddress;
	CConnection			*m_pConnection;

	DIRECTNETOBJECT		*m_pdnObject;

	DNCRITICAL_SECTION	m_csEntry;
	DNCRITICAL_SECTION	m_csMembership;
	DNCRITICAL_SECTION	m_csConnections;
};

#undef DPF_MODNAME

#endif	// __NTENTRY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\peer.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Peer.h
 *  Content:    Direct Net Peer interface header file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  07/21/99	mjn		Created
 *  10/08/99	jtk		Split from DNCore.h
 *	12/03/99	jtk		Moved COM interface definitions to DNet.h
 *	01/15/00	mjn		Removed DN_PeerMessageHandler
 *	02/15/00	mjn		Implement INFO flags in SetInfo and return context in GetInfo
 *	04/06/00	mjn		Added GetPeerAddress to API
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__PEER_H__
#define	__PEER_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//
// VTable for peer interface
//
extern IDirectPlay8PeerVtbl DN_PeerVtbl;

//**********************************************************************
// Function prototypes
//**********************************************************************

//
// DirectNet - IDirectPlay8Peer
//
STDMETHODIMP DN_SetPeerInfo( IDirectPlay8Peer *pInterface,
							 const DPN_PLAYER_INFO *const pdpnPlayerInfo,
							 PVOID const pvAsyncContext,
							 DPNHANDLE *const phAsyncHandle,
							 const DWORD dwFlags);

STDMETHODIMP DN_GetPeerInfo(IDirectPlay8Peer *pInterface,
							const DPNID dpnid,
							DPN_PLAYER_INFO *const pdpnPlayerInfo,
							DWORD *const pdwSize,
							const DWORD dwFlags);

STDMETHODIMP DN_GetPeerAddress(IDirectPlay8Peer *pInterface,
							   const DPNID dpnid,
							   IDirectPlay8Address **const ppAddress,
							   const DWORD dwFlags);

#endif	// __PEER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\pendingdel.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       PendingDel.h
 *  Content:    DirectNet NameTable Pending Deletions Header
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  08/28/00	mjn		Created
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__PENDINGDEL_H__
#define	__PENDINGDEL_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

#ifndef	OFFSETOF
#define OFFSETOF(s,m)				( ( INT_PTR ) ( ( PVOID ) &( ( (s*) 0 )->m ) ) )
#endif

#ifndef	CONTAINING_OBJECT
#define	CONTAINING_OBJECT(b,t,m)	(reinterpret_cast<t*>(&reinterpret_cast<BYTE*>(b)[-OFFSETOF(t,m)]))
#endif

//**********************************************************************
// Structure definitions
//**********************************************************************

template< class CPendingDeletion > class CLockedContextClassFixedPool;

typedef struct _DIRECTNETOBJECT DIRECTNETOBJECT;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************

// class for NameTable Pending Deletions

class CPendingDeletion
{
public:

	CPendingDeletion()
	{
		m_Sig[0] = 'N';
		m_Sig[1] = 'T';
		m_Sig[2] = 'P';
		m_Sig[3] = 'D';
	};

	~CPendingDeletion() { };

	BOOL FPMAlloc(void *const pvContext)
		{
			m_pdnObject = static_cast<DIRECTNETOBJECT*>(pvContext);

			return(TRUE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CPendingDeletion::FPMInitialize"
	BOOL FPMInitialize(void *const pvContext)
		{
			DNASSERT(m_pdnObject == pvContext);
			m_dpnid = 0;
			m_bilinkPendingDeletions.Initialize();

			return(TRUE);
		};

	void FPMRelease(void *const pvContext) { };

	void FPMDealloc(void *const pvContext) { };

	void ReturnSelfToPool( void )
		{
			m_pdnObject->m_pFPOOLPendingDeletion->Release( this );
		};

	void SetDPNID( const DPNID dpnid )
		{
			m_dpnid = dpnid;
		};

	DPNID GetDPNID( void )
		{
			return( m_dpnid );
		};

	CBilink			m_bilinkPendingDeletions;

private:
	BYTE			m_Sig[4];
	DIRECTNETOBJECT	*m_pdnObject;
	DPNID			m_dpnid;
};

#undef DPF_MODNAME

#endif	// __PENDINGDEL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\ntoplist.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       NTOpList.h
 *  Content:    DirectNet NameTable Operation List Header
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  01/19/00	mjn		Created
 *	01/20/00	mjn		Added DNNTOLGetVersion,DNNTOLDestroyEntry,
 *						DNNTOLCleanUp,DNNTOLProcessOperation
 *	01/24/00	mjn		Implemented NameTable operation list version cleanup
 *	01/25/00	mjn		Added pending operation list routines DNPOAdd and DNPORun
 *	01/26/00	mjn		Added DNNTOLFindEntry
 *	07/19/00	mjn		Added DNPOCleanUp()
 *	08/28/00	mjn		Moved CPendingDeletion out
 *				mjn		Revamped NameTable operation list routines
 *	03/30/01	mjn		Changes to prevent multiple loading/unloading of SP's
 *				mjn		Added service provider to DNNTAddOperation()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__NTOPLIST_H__
#define	__NTOPLIST_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	DN_NAMETABLE_OP_RESYNC_INTERVAL		4

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************


//
//
//

HRESULT DNNTHostReceiveVersion(DIRECTNETOBJECT *const pdnObject,
							   const DPNID dpnid,
							   void *const pMsg);

HRESULT DNNTPlayerSendVersion(DIRECTNETOBJECT *const pdnObject);

HRESULT DNNTHostResyncVersion(DIRECTNETOBJECT *const pdnObject,
							  const DWORD dwVersion);

HRESULT DNNTPlayerResyncVersion(DIRECTNETOBJECT *const pdnObject,
								void *const pMsg);

//
//
//

HRESULT DNNTGetOperationVersion(DIRECTNETOBJECT *const pdnObject,
								const DWORD dwMsgId,
								void *const pOpBuffer,
								const DWORD dwOpBufferSize,
								DWORD *const pdwVersion,
								DWORD *const pdwVersionNotUsed);

HRESULT DNNTPerformOperation(DIRECTNETOBJECT *const pdnObject,
							 const DWORD dwMsgId,
							 void *const pvBuffer);

HRESULT DNNTAddOperation(DIRECTNETOBJECT *const pdnObject,
						 const DWORD dwMsgId,
						 void *const pOpBuffer,
						 const DWORD dwOpBufferSize,
						 const HANDLE hProtocol,
						 CServiceProvider *const pSP);

HRESULT	DNNTFindOperation(DIRECTNETOBJECT *const pdnObject,
						  const DWORD dwVersion,
						  CNameTableOp **ppNTOp);

void DNNTRemoveOperations(DIRECTNETOBJECT *const pdnObject,
						  const DWORD dwOldestVersion,
						  const BOOL fRemoveAll);


//**********************************************************************
// Class prototypes
//**********************************************************************

#endif	// __NTOPLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\pools.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Pools.h
 *  Content:    DirectNet Fixed Pools
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *	01/15/00	mjn		Created
 *	01/19/00	mjn		Added SyncEventNew()
 *	02/29/00	mjn		Added ConnectionNew()
 *	03/02/00	mjn		Added GroupConnectionNew()
 *	04/08/00	mjn		Added AsyncOpNew()
 *	07/30/00	mjn		Added PendingDeletionNew()
 *	07/31/00	mjn		Added QueuedMsgNew()
 *	08/06/00	mjn		Added CWorkerJob
 *	08/23/00	mjn		Added CNameTableOp
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__POOLS_H__
#define	__POOLS_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

class CRefCountBuffer;
class CSyncEvent;
class CConnection;
class CGroupConnection;
class CGroupMember;
class CNameTableEntry;
class CAsyncOp;
class CPendingDeletion;
class CQueuedMsg;
class CWorkerJob;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

// DirectNet - Fixed Pools
HRESULT RefCountBufferNew(DIRECTNETOBJECT *const pdnObject,
						  const DWORD dwBufferSize,
						  CRefCountBuffer **const ppNewRefCountBuffer);

HRESULT SyncEventNew(DIRECTNETOBJECT *const pdnObject,
					 CSyncEvent **const ppNewSyncEvent);

HRESULT ConnectionNew(DIRECTNETOBJECT *const pdnObject,
					  CConnection **const ppNewConnection);

HRESULT GroupConnectionNew(DIRECTNETOBJECT *const pdnObject,
						   CGroupConnection **const ppNewGroupConnection);

HRESULT GroupMemberNew(DIRECTNETOBJECT *const pdnObject,
					   CGroupMember **const ppNewGroupMember);

HRESULT NameTableEntryNew(DIRECTNETOBJECT *const pdnObject,
						  CNameTableEntry **const ppNewNameTableEntry);

HRESULT AsyncOpNew(DIRECTNETOBJECT *const pdnObject,
				   CAsyncOp **const ppNewAsyncOp);

HRESULT PendingDeletionNew(DIRECTNETOBJECT *const pdnObject,
						   CPendingDeletion **const ppNewPendingDeletion);

HRESULT QueuedMsgNew(DIRECTNETOBJECT *const pdnObject,
					 CQueuedMsg **const ppNewQueuedMsg);

HRESULT WorkerJobNew(DIRECTNETOBJECT *const pdnObject,
					 CWorkerJob **const ppNewWorkerJob);

HRESULT NameTableOpNew(DIRECTNETOBJECT *const pdnObject,
					   CNameTableOp **const ppNewNameTableOp);


#endif	// __POOLS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\ntoplist.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       NTOpList.cpp
 *  Content:    DirectNet NameTable Operation List
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  01/19/00	mjn		Created
 *	01/20/00	mjn		Added DNNTOLGetVersion,DNNTOLDestroyEntry,
 *						DNNTOLCleanUp,DNNTOLProcessOperation
 *	01/21/00	mjn		Host ACKnowledgements contain the actual op and not the REQuest
 *	01/24/00	mjn		Implemented NameTable operation list version cleanup
 *	01/25/00	mjn		Send dwLatestVersion to Host at migration
 *	01/25/00	mjn		Added pending operation list routines DNPOAdd and DNPORun
 *	01/26/00	mjn		Added DNNTOLFindEntry
 *	04/19/00	mjn		Update NameTable operations to use DN_WORKER_JOB_SEND_NAMETABLE_OPERATION
 *	05/03/00	mjn		Use GetHostPlayerRef() rather than GetHostPlayer()
 *	07/19/00	mjn		Added DNPOCleanUp()
 *	07/31/00	mjn		Change DN_MSG_INTERNAL_DELETE_PLAYER to DN_MSG_INTERNAL_DESTROY_PLAYER
 *	08/08/00	mjn		Ensure DNOLPlayerSendVersion() takes player reference correctly
 *	08/24/00	mjn		Added CNameTableOp (to replace DN_NAMETABLE_OP)
 *	09/17/00	mjn		Split CNameTable.m_bilinkEntries into m_bilinkPlayers and m_bilinkGroups
 *	09/28/00	mjn		Fixed logic error in DNNTAddOperation()
 *	01/25/01	mjn		Fixed 64-bit alignment problem in DNNTGetOperationVersion()
 *	03/30/01	mjn		Changes to prevent multiple loading/unloading of SP's
 *				mjn		Added service provider to DNNTAddOperation()
 *	04/05/01	mjn		Overwrite old NameTable operations with newer ones in DNNTAddOperation()
 *	04/11/01	mjn		Cleanup and return CNameTableOp if replaced in DNNTAddOperation()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


//	DNNTHostReceiveVersion
//
//	Update the NameTable version of a player's entry in the Host player's NameTable

#undef DPF_MODNAME
#define DPF_MODNAME "DNNTHostReceiveVersion"

HRESULT DNNTHostReceiveVersion(DIRECTNETOBJECT *const pdnObject,
							   const DPNID dpnid,
							   void *const pMsg)
{
	HRESULT				hResultCode;
	CNameTableEntry		*pNTEntry;
	UNALIGNED DN_INTERNAL_MESSAGE_NAMETABLE_VERSION	*pInfo;

	DPFX(DPFPREP, 6,"Parameters: dpnid [0x%lx], pMsg [0x%p]",dpnid,pMsg);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pMsg != NULL);

	pNTEntry = NULL;

	pInfo = static_cast<DN_INTERNAL_MESSAGE_NAMETABLE_VERSION*>(pMsg);

	//
	//	Find player's entry in NameTable
	//
	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnid,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Player no longer in NameTable");
		DisplayDNError(0,hResultCode);
		hResultCode = DPNERR_INVALIDPLAYER;
		goto Failure;
	}

	//
	//	Update version number of entry
	//
	DPFX(DPFPREP, 7,"Set player [0x%lx] dwLatestVersion [%ld]", dpnid,pInfo->dwVersion);
	pNTEntry->Lock();
	pNTEntry->SetLatestVersion(pInfo->dwVersion);
	pNTEntry->Unlock();
	pNTEntry->Release();
	pNTEntry = NULL;

	//
	//	If the host is migrating, see if we can continue
	//
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_HOST_MIGRATING)
	{
		DNCheckReceivedAllVersions(pdnObject);
	}
	else
	{
		DWORD	dwOldestVersion;
		BOOL	fReSync;
		CBilink	*pBilink;

		//
		//	Determine the oldest version EVERYONE has updated to
		//
		fReSync = FALSE;
		dwOldestVersion = pInfo->dwVersion;
		pdnObject->NameTable.ReadLock();
		pBilink = pdnObject->NameTable.m_bilinkPlayers.GetNext();
		while (pBilink != &pdnObject->NameTable.m_bilinkPlayers)
		{
			pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
			pNTEntry->Lock();
			if (pNTEntry->IsAvailable() && !pNTEntry->IsHost())
			{
				if (pNTEntry->GetLatestVersion() < dwOldestVersion)
				{
					dwOldestVersion = pNTEntry->GetLatestVersion();
				}
			}
			pNTEntry->Unlock();
			pNTEntry = NULL;
			pBilink = pBilink->GetNext();
		}
		if (dwOldestVersion > pdnObject->NameTable.GetLatestVersion())
		{
			fReSync = TRUE;
		}
		pdnObject->NameTable.Unlock();

		//
		//	Resync NameTable versions of other players if required
		//
		if (fReSync)
		{
			DNNTHostResyncVersion(pdnObject,dwOldestVersion);
		}
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	goto Exit;
}


//	DNNTPlayerSendVersion
//
//	Send the Local player's NameTable version to the Host
//	This should only be called in Peer-to-Peer mode

#undef DPF_MODNAME
#define DPF_MODNAME "DNNTPlayerSendVersion"

HRESULT DNNTPlayerSendVersion(DIRECTNETOBJECT *const pdnObject)
{
	HRESULT				hResultCode;
	CNameTableEntry		*pHostPlayer;
	CRefCountBuffer		*pRefCountBuffer;
	CWorkerJob			*pWorkerJob;
	DN_INTERNAL_MESSAGE_NAMETABLE_VERSION	*pInfo;

	DPFX(DPFPREP, 6,"Parameters: (none)");

	DNASSERT(pdnObject != NULL);
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_PEER);
	DNASSERT(pdnObject->NameTable.GetLocalPlayer() != NULL);

	pHostPlayer = NULL;
	pRefCountBuffer = NULL;
	pWorkerJob = NULL;

	//
	//	Get Host player reference
	//
	if ((hResultCode = pdnObject->NameTable.GetHostPlayerRef( &pHostPlayer )) != DPN_OK)
	{
		DPFERR("Could not find Host player");
		DisplayDNError(0,hResultCode);
		hResultCode = DPNERR_NOHOSTPLAYER;
		goto Failure;
	}

	//
	//	Host player updates entry directly
	//
	if (pHostPlayer->IsLocal())
	{
		DWORD	dwVersion;

		pdnObject->NameTable.ReadLock();
		dwVersion = pdnObject->NameTable.GetVersion();
		pdnObject->NameTable.Unlock();

		DPFX(DPFPREP, 7,"Set Host player dwLatestVersion [%ld]",dwVersion);
		pHostPlayer->Lock();
		pHostPlayer->SetLatestVersion(dwVersion);
		pHostPlayer->Unlock();

	}
	else
	{
		//
		//	Create message and send to Host player
		//
		if ((hResultCode = RefCountBufferNew(pdnObject,
				sizeof(DN_INTERNAL_MESSAGE_NAMETABLE_VERSION),&pRefCountBuffer)) != DPN_OK)
		{
			DPFERR("Could not allocate space for RefCount buffer");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pInfo = reinterpret_cast<DN_INTERNAL_MESSAGE_NAMETABLE_VERSION*>(pRefCountBuffer->GetBufferAddress());
		pdnObject->NameTable.ReadLock();
		pInfo->dwVersion = pdnObject->NameTable.GetVersion();
		pInfo->dwVersionNotUsed = 0;
		pdnObject->NameTable.Unlock();

		DPFX(DPFPREP, 7,"Send Local player dwLatestVersion [%ld]",pInfo->dwVersion);

		//
		//	Send message to host player
		//
		if ((hResultCode = WorkerJobNew(pdnObject,&pWorkerJob)) != DPN_OK)
		{
			DPFERR("Could not create worker job");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pWorkerJob->SetJobType( WORKER_JOB_SEND_NAMETABLE_VERSION );
		pWorkerJob->SetRefCountBuffer( pRefCountBuffer );

		DNQueueWorkerJob(pdnObject,pWorkerJob);
		pWorkerJob = NULL;

		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	pHostPlayer->Release();
	pHostPlayer = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pHostPlayer)
	{
		pHostPlayer->Release();
		pHostPlayer = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	goto Exit;
}


//	DNNTHostResyncVersion
//
//	Re-sync of the NameTable operation lists based on lowest common version number

#undef DPF_MODNAME
#define DPF_MODNAME "DNNTHostResyncVersion"

HRESULT DNNTHostResyncVersion(DIRECTNETOBJECT *const pdnObject,
							  const DWORD dwVersion)
{
	HRESULT				hResultCode;
	CRefCountBuffer		*pRefCountBuffer;
	CWorkerJob			*pWorkerJob;
	DN_INTERNAL_MESSAGE_RESYNC_VERSION	*pInfo;

	DPFX(DPFPREP, 6,"Parameters: dwVersion [%ld]",dwVersion);

	DNASSERT(pdnObject != NULL);

	pWorkerJob = NULL;
	pRefCountBuffer = NULL;

	//
	//	Create re-sync message
	//
	if ((hResultCode = RefCountBufferNew(pdnObject,sizeof(DN_INTERNAL_MESSAGE_RESYNC_VERSION),&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not allocate RefCount buffer");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pInfo = (DN_INTERNAL_MESSAGE_RESYNC_VERSION *)(pRefCountBuffer->GetBufferAddress());
	pInfo->dwVersion = dwVersion;
	pInfo->dwVersionNotUsed = 0;

	//
	//	Hand this to worker thread
	//
	if ((hResultCode = WorkerJobNew(pdnObject,&pWorkerJob)) != DPN_OK)
	{
		DPFERR("Could not allocate new worker thread job");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pWorkerJob->SetJobType( WORKER_JOB_SEND_NAMETABLE_OPERATION );
	pWorkerJob->SetSendNameTableOperationMsgId( DN_MSG_INTERNAL_RESYNC_VERSION );
	pWorkerJob->SetSendNameTableOperationVersion( 0 );
	pWorkerJob->SetSendNameTableOperationDPNIDExclude( 0 );
	pWorkerJob->SetRefCountBuffer( pRefCountBuffer );

	DNQueueWorkerJob(pdnObject,pWorkerJob);
	pWorkerJob = NULL;

	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pWorkerJob)
	{
		pWorkerJob->ReturnSelfToPool();
		pWorkerJob = NULL;
	}
	goto Exit;
}


//	DNNTPlayerResyncVersion
//
//	Re-sync of the NameTable operation list from Host player

#undef DPF_MODNAME
#define DPF_MODNAME "DNNTPlayerResyncVersion"

HRESULT DNNTPlayerResyncVersion(DIRECTNETOBJECT *const pdnObject,
								void *const pMsg)
{
	HRESULT		hResultCode;
	UNALIGNED DN_INTERNAL_MESSAGE_RESYNC_VERSION	*pInfo;

	DPFX(DPFPREP, 6,"Parameters: pMsg [0x%p]",pMsg);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pMsg != NULL);

	pInfo = static_cast<DN_INTERNAL_MESSAGE_RESYNC_VERSION*>(pMsg);

	DPFX(DPFPREP, 5,"Instructed to clean up NameTable operation list dwVersion < [%ld]",
			pInfo->dwVersion);
	DNNTRemoveOperations(pdnObject,pInfo->dwVersion,FALSE);

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}



//	DNNTGetOperationVersion
//
//	Find the version number of a NameTable Operation

#undef DPF_MODNAME
#define DPF_MODNAME "DNNTGetOperationVersion"

HRESULT DNNTGetOperationVersion(DIRECTNETOBJECT *const pdnObject,
								const DWORD dwMsgId,
								void *const pOpBuffer,
								const DWORD dwOpBufferSize,
								DWORD *const pdwVersion,
								DWORD *const pdwVersionNotUsed)
{
	HRESULT	hResultCode;

	DPFX(DPFPREP, 6,"Parameters: dwMsgId [0x%lx], pOpBuffer [0x%p], dwOpBufferSize [%ld], pdwVersion [0x%p]",
			dwMsgId,pOpBuffer,dwOpBufferSize,pdwVersion);

	DNASSERT(pdwVersion != NULL);
	DNASSERT(pdwVersionNotUsed != NULL);

	hResultCode = DPN_OK;
	switch (dwMsgId)
	{
	case DN_MSG_INTERNAL_INSTRUCT_CONNECT:
		{
			*pdwVersion = static_cast<UNALIGNED DN_INTERNAL_MESSAGE_INSTRUCT_CONNECT*>(pOpBuffer)->dwVersion;
			*pdwVersionNotUsed = static_cast<UNALIGNED DN_INTERNAL_MESSAGE_INSTRUCT_CONNECT *>(pOpBuffer)->dwVersionNotUsed;
			break;
		}
	case DN_MSG_INTERNAL_ADD_PLAYER:
		{
			*pdwVersion = static_cast<UNALIGNED DN_NAMETABLE_ENTRY_INFO *>(pOpBuffer)->dwVersion;
			*pdwVersionNotUsed = static_cast<UNALIGNED DN_NAMETABLE_ENTRY_INFO *>(pOpBuffer)->dwVersionNotUsed;
			break;
		}
	case DN_MSG_INTERNAL_DESTROY_PLAYER:
		{
			*pdwVersion = static_cast<UNALIGNED DN_INTERNAL_MESSAGE_DESTROY_PLAYER *>(pOpBuffer)->dwVersion;
			*pdwVersionNotUsed = static_cast<UNALIGNED DN_INTERNAL_MESSAGE_DESTROY_PLAYER *>(pOpBuffer)->dwVersionNotUsed;
			break;
		}
	case DN_MSG_INTERNAL_CREATE_GROUP:
		{
			*pdwVersion = (reinterpret_cast<UNALIGNED DN_NAMETABLE_ENTRY_INFO*>((static_cast<DN_INTERNAL_MESSAGE_CREATE_GROUP*>(pOpBuffer)) + 1))->dwVersion;
			*pdwVersionNotUsed = (reinterpret_cast<UNALIGNED DN_NAMETABLE_ENTRY_INFO*>((static_cast<DN_INTERNAL_MESSAGE_CREATE_GROUP*>(pOpBuffer)) + 1))->dwVersionNotUsed;
			break;
		}
	case DN_MSG_INTERNAL_DESTROY_GROUP:
		{
			*pdwVersion = static_cast<UNALIGNED DN_INTERNAL_MESSAGE_DESTROY_GROUP*>(pOpBuffer)->dwVersion;
			*pdwVersionNotUsed = static_cast<UNALIGNED DN_INTERNAL_MESSAGE_DESTROY_GROUP*>(pOpBuffer)->dwVersionNotUsed;
			break;
		}
	case DN_MSG_INTERNAL_ADD_PLAYER_TO_GROUP:
		{
			*pdwVersion = static_cast<UNALIGNED DN_INTERNAL_MESSAGE_ADD_PLAYER_TO_GROUP*>(pOpBuffer)->dwVersion;
			*pdwVersionNotUsed = static_cast<UNALIGNED DN_INTERNAL_MESSAGE_ADD_PLAYER_TO_GROUP*>(pOpBuffer)->dwVersionNotUsed;
			break;
		}
	case DN_MSG_INTERNAL_DELETE_PLAYER_FROM_GROUP:
		{
			*pdwVersion = static_cast<UNALIGNED DN_INTERNAL_MESSAGE_DELETE_PLAYER_FROM_GROUP*>(pOpBuffer)->dwVersion;
			*pdwVersionNotUsed = static_cast<UNALIGNED DN_INTERNAL_MESSAGE_DELETE_PLAYER_FROM_GROUP*>(pOpBuffer)->dwVersionNotUsed;
			break;
		}
	case DN_MSG_INTERNAL_UPDATE_INFO:
		{
			*pdwVersion = static_cast<UNALIGNED DN_INTERNAL_MESSAGE_UPDATE_INFO*>(pOpBuffer)->dwVersion;
			*pdwVersionNotUsed = static_cast<UNALIGNED DN_INTERNAL_MESSAGE_UPDATE_INFO*>(pOpBuffer)->dwVersionNotUsed;
			break;
		}
	default:
		{
			DPFERR("Invalid MessageID");
			DNASSERT(FALSE);
			hResultCode = DPNERR_UNSUPPORTED;
		}
	}
	if (hResultCode == DPN_OK)
	{
		DPFX(DPFPREP, 7,"*pdwVersion = [%ld]",*pdwVersion);
	}

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNNTPerformOperation"

HRESULT DNNTPerformOperation(DIRECTNETOBJECT *const pdnObject,
							 const DWORD dwMsgId,
							 void *const pvBuffer)
{
	HRESULT		hResultCode;

	DPFX(DPFPREP, 6,"Parameters: dwMsgId [0x%lx], pvBuffer [0x%p]",dwMsgId,pvBuffer);

	switch (dwMsgId)
	{
	case DN_MSG_INTERNAL_INSTRUCT_CONNECT:
		{
			DPFX(DPFPREP, 7,"Perform DN_MSG_INTERNAL_INSTRUCT_CONNECT");
			if ((hResultCode = DNConnectToPeer2(pdnObject,pvBuffer)) != DPN_OK)
			{
				DPFERR("Instructed connect failed");
				DisplayDNError(0,hResultCode);
			}
			break;
		}
	case DN_MSG_INTERNAL_ADD_PLAYER:
		{
			DPFX(DPFPREP, 7,"Perform DN_MSG_INTERNAL_ADD_PLAYER");
			if ((hResultCode = DNConnectToPeer1(pdnObject,pvBuffer)) != DPN_OK)
			{
				DPFERR("Add player failed");
				DisplayDNError(0,hResultCode);
			}
			break;
		}
	case DN_MSG_INTERNAL_DESTROY_PLAYER:
		{
			DPFX(DPFPREP, 7,"Perform DN_MSG_INTERNAL_DESTROY_PLAYER");
			if ((hResultCode = DNInstructedDisconnect(pdnObject,pvBuffer)) != DPN_OK)
			{
				DPFERR("Destroy player failed");
				DisplayDNError(0,hResultCode);
			}
			break;
		}
	case DN_MSG_INTERNAL_CREATE_GROUP:
		{
			DPFX(DPFPREP, 7,"Perform DN_MSG_INTERNAL_CREATE_GROUP");
			if ((hResultCode = DNProcessCreateGroup(pdnObject,pvBuffer)) != DPN_OK)
			{
				DPFERR("Create group failed");
				DisplayDNError(0,hResultCode);
			}
			break;
		}
	case DN_MSG_INTERNAL_DESTROY_GROUP:
		{
			DPFX(DPFPREP, 7,"Perform DN_MSG_INTERNAL_DESTROY_GROUP");
			if ((hResultCode = DNProcessDestroyGroup(pdnObject,pvBuffer)) != DPN_OK)
			{
				DPFERR("Destroy group failed");
				DisplayDNError(0,hResultCode);
			}
			break;
		}
	case DN_MSG_INTERNAL_ADD_PLAYER_TO_GROUP:
		{
			DPFX(DPFPREP, 7,"Perform DN_MSG_INTERNAL_ADD_PLAYER_TO_GROUP");
			if ((hResultCode = DNProcessAddPlayerToGroup(pdnObject,pvBuffer)) != DPN_OK)
			{
				DPFERR("Add player to group failed");
				DisplayDNError(0,hResultCode);
			}
			break;
		}
	case DN_MSG_INTERNAL_DELETE_PLAYER_FROM_GROUP:
		{
			DPFX(DPFPREP, 7,"Perform DN_MSG_INTERNAL_DELETE_PLAYER_FROM_GROUP");
			if ((hResultCode = DNProcessDeletePlayerFromGroup(pdnObject,pvBuffer)) != DPN_OK)
			{
				DPFERR("Remove player from group failed");
				DisplayDNError(0,hResultCode);
			}
			break;
		}
	case DN_MSG_INTERNAL_UPDATE_INFO:
		{
			DPFX(DPFPREP, 7,"Perform DN_MSG_INTERNAL_UPDATE_INFO");
			if ((hResultCode = DNProcessUpdateInfo(pdnObject,pvBuffer)) != DPN_OK)
			{
				DPFERR("Update info failed");
				DisplayDNError(0,hResultCode);
			}
			break;
		}
	default:
		{
			DPFERR("Invalid MessageID");
			DNASSERT(FALSE);
			return(DPNERR_UNSUPPORTED);
		}
	}

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//	DNNTAddOperation
//
//	Add an operation to the NameTable operation list

#undef DPF_MODNAME
#define DPF_MODNAME "DNNTAddOperation"

HRESULT DNNTAddOperation(DIRECTNETOBJECT *const pdnObject,
						 const DWORD dwMsgId,
						 void *const pOpBuffer,
						 const DWORD dwOpBufferSize,
						 const HANDLE hProtocol,
						 CServiceProvider *const pSP)
{
	HRESULT			hResultCode;
	CRefCountBuffer	*pRefCountBuffer;
	CNameTableOp	*pNTOp;
	BOOL			fReSync;

	DPFX(DPFPREP, 4,"Parameters: dwMsgId [0x%lx], pOpBuffer [0x%p], dwOpBufferSize [%ld], hProtocol [0x%lx], pSP [0x%p]",
			dwMsgId,pOpBuffer,dwOpBufferSize,hProtocol,pSP);

	pRefCountBuffer = NULL;
	pNTOp = NULL;
	fReSync = FALSE;

	//
	//	We will only need to worry about maintaining the operation list in PEER mode.
	//	Otherwise, just perform the operation
	//
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PEER)
	{
		DWORD			dwVersion;
		DWORD			dwVersionNotUsed;
		BOOL			fFound;
		BOOL			fImmediate;
		CBilink			*pBilink;
		CNameTableOp	*pCurrent;

		dwVersion = 0;
		dwVersionNotUsed = 0;

		//
		//	Get version of this operation
		//
		if ((hResultCode = DNNTGetOperationVersion(	pdnObject,
													dwMsgId,
													pOpBuffer,
													dwOpBufferSize,
													&dwVersion,
													&dwVersionNotUsed)) != DPN_OK)
		{
			DPFERR("Could not determine operation version");
			DisplayDNError(0,hResultCode);
			hResultCode = DPN_OK;
			goto Failure;
		}

		//
		//	Create NameTableOp
		//
		if ((hResultCode = NameTableOpNew(pdnObject,&pNTOp)) != DPN_OK)
		{
			DPFERR("Could not create NameTableOp");
			DisplayDNError(0,hResultCode);
			hResultCode = DPN_OK;
			goto Failure;
		}

		//
		//	Keep operation in a RefCountBuffer.  If a protocol buffer was supplied (with handle)
		//	we will just release the buffer when we're done with it.  Otherwise, we will need
		//	to copy the buffer supplied.
		//
		if (hProtocol)
		{
			if ((hResultCode = RefCountBufferNew(pdnObject,0,&pRefCountBuffer)) != DPN_OK)
			{
				DPFERR("Could not create RefCountBuffer");
				DisplayDNError(0,hResultCode);
				hResultCode = DPN_OK;
				goto Failure;
			}
			pRefCountBuffer->SetBufferDesc(	static_cast<BYTE*>(pOpBuffer),
											dwOpBufferSize,
											DNFreeProtocolBuffer,
											hProtocol);
		}
		else
		{
			if ((hResultCode = RefCountBufferNew(pdnObject,dwOpBufferSize,&pRefCountBuffer)) != DPN_OK)
			{
				DPFERR("Could not create RefCountBuffer");
				DisplayDNError(0,hResultCode);
				hResultCode = DPN_OK;
				goto Failure;
			}
			memcpy(pRefCountBuffer->GetBufferAddress(),pOpBuffer,dwOpBufferSize);
		}

		pNTOp->SetMsgId(dwMsgId);
		pNTOp->SetRefCountBuffer(pRefCountBuffer);
		pNTOp->SetSP( pSP );
		pNTOp->SetVersion(dwVersion);

		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;

		//
		//	Insert into the NameTableOp list
		//
		fFound = FALSE;
		fImmediate = FALSE;
		pdnObject->NameTable.WriteLock();
		pBilink = pdnObject->NameTable.m_bilinkNameTableOps.GetNext();
		while (pBilink != &pdnObject->NameTable.m_bilinkNameTableOps)
		{
			pCurrent = CONTAINING_OBJECT(pBilink,CNameTableOp,m_bilinkNameTableOps);
			if (dwVersion < pCurrent->GetVersion())
			{
				pNTOp->m_bilinkNameTableOps.InsertBefore(&pCurrent->m_bilinkNameTableOps);
				pCurrent = NULL;
				fFound = TRUE;
				break;
			}
			if (dwVersion == pCurrent->GetVersion())
			{
				//
				//	This is a NEWER operation which will replace the current operation in the list
				//
				pNTOp->m_bilinkNameTableOps.InsertBefore(&pCurrent->m_bilinkNameTableOps);
				pCurrent->m_bilinkNameTableOps.RemoveFromList();
				if (pCurrent->GetRefCountBuffer())
				{
					pCurrent->GetRefCountBuffer()->Release();
					pCurrent->SetRefCountBuffer( NULL );
				}
				if (pCurrent->GetSP())
				{
					pCurrent->GetSP()->Release();
					pCurrent->SetSP( NULL );
				}
				pCurrent->ReturnSelfToPool();
				pCurrent = NULL;
				fFound = TRUE;
				break;
			}
			pCurrent = NULL;
			pBilink = pBilink->GetNext();
		}
		if (!fFound)
		{
			pNTOp->m_bilinkNameTableOps.InsertBefore(&pdnObject->NameTable.m_bilinkNameTableOps);
		}

		pBilink = pdnObject->NameTable.m_bilinkNameTableOps.GetNext();
		while (pBilink != &pdnObject->NameTable.m_bilinkNameTableOps)
		{
			pCurrent = CONTAINING_OBJECT(pBilink,CNameTableOp,m_bilinkNameTableOps);
			if (pCurrent->GetVersion() > pdnObject->NameTable.GetVersion())
			{
				DPFX(DPFPREP, 8,"Current [%ld], NameTable [%ld], InUse [%ld]",pCurrent->GetVersion(),
						pdnObject->NameTable.GetVersion(),pCurrent->IsInUse());
				if ((pCurrent->GetVersion() == (pdnObject->NameTable.GetVersion() + 1))
						&& !pCurrent->IsInUse())
				{
					pCurrent->SetInUse();
					if ((pCurrent->GetVersion() % DN_NAMETABLE_OP_RESYNC_INTERVAL) == 0)
					{
						fReSync = TRUE;
					}
					pdnObject->NameTable.Unlock();

					hResultCode = DNNTPerformOperation(	pdnObject,
														pCurrent->GetMsgId(),
														pCurrent->GetRefCountBuffer()->GetBufferAddress() );

					pdnObject->NameTable.WriteLock();
				}
				else
				{
					//
					//	Once we find an operation that we won't perform, there is no point continuing
					//
					break;
				}
			}
			pBilink = pBilink->GetNext();
		}
		pdnObject->NameTable.Unlock();

		//
		//	Send a re-sync to the host if required
		//
		if (fReSync)
		{
			DPFX(DPFPREP, 5,"Send NameTable version re-sync to Host");
			DNNTPlayerSendVersion(pdnObject);
		}

		//
		//	We will keep the operation buffer (if specified) so return DPNERR_PENDING
		//
		if (hProtocol)
		{
			hResultCode = DPNERR_PENDING;
		}
		else
		{
			hResultCode = DPN_OK;
		}
	}
	else
	{
		DNNTPerformOperation(pdnObject,dwMsgId,pOpBuffer);

		//
		//	We will not need to keep the operation buffer so return DPN_OK
		//
		hResultCode = DPN_OK;
	}

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return( hResultCode);

Failure:
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pNTOp)
	{
		pNTOp->ReturnSelfToPool();
		pNTOp = NULL;
	}
	goto Exit;
}


//	DNNTFindOperation
//
//	Find a NameTable Operation

#undef DPF_MODNAME
#define DPF_MODNAME "DNNTFindOperation"

HRESULT	DNNTFindOperation(DIRECTNETOBJECT *const pdnObject,
						  const DWORD dwVersion,
						  CNameTableOp **ppNTOp)
{
	HRESULT			hResultCode;
	CBilink			*pBilink;
	CNameTableOp	*pNTOp;

	DPFX(DPFPREP, 6,"Parameters: dwVersion [%ld = 0x%lx], ppNTOp [0x%p]",dwVersion,dwVersion,ppNTOp);

	DNASSERT(ppNTOp != NULL);

	hResultCode = DPNERR_DOESNOTEXIST;
	pdnObject->NameTable.ReadLock();
	pBilink = pdnObject->NameTable.m_bilinkNameTableOps.GetNext();
	while (pBilink != &pdnObject->NameTable.m_bilinkNameTableOps)
	{
		pNTOp = CONTAINING_OBJECT(pBilink,CNameTableOp,m_bilinkNameTableOps);
		if (pNTOp->GetVersion() == dwVersion)
		{
			*ppNTOp = pNTOp;
			hResultCode = DPN_OK;
			break;
		}
		else if (pNTOp->GetVersion() > dwVersion)
		{
			//
			//	Passed where it could have been, so there is no point in continuing
			//
			break;
		}
		pBilink = pBilink->GetNext();
	}
	pdnObject->NameTable.Unlock();

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//	DNNTRemoveOperations
//
//	Remove NameTable Operations

#undef DPF_MODNAME
#define DPF_MODNAME "DNNTRemoveOperations"

void DNNTRemoveOperations(DIRECTNETOBJECT *const pdnObject,
						  const DWORD dwOldestVersion,
						  const BOOL fRemoveAll)
{
	CBilink			*pBilink;
	CNameTableOp	*pNTOp;

	DPFX(DPFPREP, 4,"Parameters: dwOldestVersion [%ld = 0x%lx], fRemoveAll [%ld]",dwOldestVersion,dwOldestVersion,fRemoveAll);

	DNASSERT(pdnObject != NULL);

	pdnObject->NameTable.WriteLock();
	pBilink = pdnObject->NameTable.m_bilinkNameTableOps.GetNext();
	while (pBilink != &pdnObject->NameTable.m_bilinkNameTableOps)
	{
		pNTOp = CONTAINING_OBJECT(pBilink,CNameTableOp,m_bilinkNameTableOps);
		pBilink = pBilink->GetNext();

		if (fRemoveAll || (pNTOp->GetVersion() < dwOldestVersion))
		{
			pNTOp->m_bilinkNameTableOps.RemoveFromList();
			if (pNTOp->GetRefCountBuffer())
			{
				pNTOp->GetRefCountBuffer()->Release();
				pNTOp->SetRefCountBuffer( NULL );
			}
			if (pNTOp->GetSP())
			{
				pNTOp->GetSP()->Release();
				pNTOp->SetSP( NULL );
			}
			pNTOp->ReturnSelfToPool();
		}
	}
	pdnObject->NameTable.Unlock();

	DPFX(DPFPREP, 4,"Returning");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\paramval.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       paramval.cpp
 *  Content:    DirectPlat8 Parameter Validation helper routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  02/28/00    rmt     Created
 *  04/13/2000  rmt     More parameter validation
 *  04/17/00    rmt     More param validation
 *              rmt     Added DPF_MODNAMES
 *  04/18/00    rmt     Fix: Bug #32669
 *  04/21/00	rmt	Fix: Bug #33056 Param validation preventing read-only buffers
 *  04/25/00    rmt     Fix: Bug #33190 and fixed param validation to allow nodpnsvr flag
 *	04/28/00	mjn		Allow NULL Device Address in DN_ValidateConnect()
 *	05/03/00	mjn		Added DPNENUMSERVICEPROVIDERS_ALL flag
 *	05/31/00	mjn		Added operation specific SYNC flags
 *				mjn		Fix EnumHosts param validation for timeout and enum period
 *	06/12/00	mjn		Removed validation of DPNSEND_ENCRYPTED,DPNSEND_SIGNED,DPNGROUP_MULTICAST,DPNENUM_GROUP_MULTICAST flags
 *	06/27/00	mjn		Allow priorities to be specified to GetSendQueueInfo() API calls
 *				mjn		Added DPNSEND_NONSEQUENTIAL flag to Send/SendTo
 *				mjn		Allow mix-n-match of priorities in GetSendQueueInfo() API call
 *	07/09/00	mjn		Ensure non-null addresses specified to Host
 *  07/12/00	rmt		Bug #39018 - Need param validation on RegisterLobby() API call
 *  07/19/00	aarono	Bug #39751 - fix parameter validation for CancelAsyncOperation
 *	07/20/00	mjn		Fix validation of pvApplicationReservedData in DN_ValidHostAppDesc()
 *	07/26/00	mjn		Fix param validation for Connect(),SendTo(),DestroyGroup(),AddPlayerToGroup()
 *						RemovePlayerFromGroup(),SetGroupInfo()
 *	07/31/00	mjn		Require dwFlags for DN_ValidateEnumClientsAndGroups()
 *  08/03/00	rmt		Bug #41244 - Wrong return codes -- part 2
 *	08/04/00	mjn		Added dwFlags to DN_ValidateGetConnectionInfoHelper()
 *	08/05/00	mjn		Allow NULL Host address to EnumHosts()
 *  08/08/00	rmt		Minor parameter validation error
 *	08/20/00	mjn		Prevent 0 length send buffer
 *	09/04/00	mjn		Ensure pvReservedData in application descriptions is NULL
 *  09/16/00	rmt		Bug #45175 - DPLAY8: [A/V] Param validation prevents non-null async handle w/ no complete
 *	11/27/00	mjn		Fixed spew for async op handle pointers and changed verification order
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


extern IDirectPlayVoiceTransportVtbl DN_VoiceTbl;

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateDestroyPlayer"

HRESULT DN_ValidateDestroyPlayer(PVOID pInterface,
								 const DPNID dnid,
								 const void *const pvDestroyData,
								 const DWORD dwDestroyDataSize,
								 const DWORD dwFlags)
{
    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFX(DPFPREP,  0, "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( dnid == DPNID_ALL_PLAYERS_GROUP )
    {
        DPFERR( "Cannot get player context for all players group" );
        return DPNERR_INVALIDPLAYER;
    }

    if( dwDestroyDataSize > 0 &&
        (pvDestroyData == NULL || !DNVALID_READPTR( pvDestroyData, dwDestroyDataSize  ) ) )
    {
        DPFERR( "Invalid pointer specified for destroy data" );
        return DPNERR_INVALIDPOINTER;
    }

    if( dwFlags != 0 )
    {
        DPFERR( "Invalid flags specified for destroy player" );
        return DPNERR_INVALIDFLAGS;
    }

    return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateReturnBuffer"

HRESULT DN_ValidateReturnBuffer(PVOID pInterface,
								const DPNHANDLE hBufferHandle,
								const DWORD dwFlags)
{
    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFX(DPFPREP,  0, "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( hBufferHandle == NULL )
    {
        DPFERR( "Invalid handle specified" );
        return DPNERR_INVALIDHANDLE;
    }

    if( dwFlags != 0 )
    {
        DPFERR( "Invalid flags specified" );
        return DPNERR_INVALIDFLAGS;
    }

    return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateGetPlayerContext"

HRESULT DN_ValidateGetPlayerContext(PVOID pInterface,
									const DPNID dpnid,
									PVOID *const ppvPlayerContext,
									const DWORD dwFlags)
{
    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFX(DPFPREP,  0, "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( dpnid == DPNID_ALL_PLAYERS_GROUP )
    {
        DPFERR( "Cannot get player context for all players group" );
        return DPNERR_INVALIDPLAYER;
    }

    if( ppvPlayerContext == NULL ||
        !DNVALID_WRITEPTR( ppvPlayerContext, sizeof( PVOID ) ) )
    {
        DPFERR( "Invalid pointer specified for player context" );
        return DPNERR_INVALIDPOINTER;
    }

	if (dwFlags != 0)
	{
		DPFERR("Invalid flags specified");
		return(DPNERR_INVALIDFLAGS);
	}

    return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateGetGroupContext"

HRESULT DN_ValidateGetGroupContext(PVOID pInterface,
								   const DPNID dpnid,
								   PVOID *const ppvGroupContext,
								   const DWORD dwFlags)
{
    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFX(DPFPREP,  0, "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( dpnid == DPNID_ALL_PLAYERS_GROUP )
    {
        DPFERR( "Cannot get group context for all players group" );
        return DPNERR_INVALIDGROUP;
    }

    if( ppvGroupContext == NULL ||
        !DNVALID_WRITEPTR( ppvGroupContext, sizeof( PVOID ) ) )
    {
        DPFERR( "Invalid pointer specified for group context" );
        return DPNERR_INVALIDPOINTER;
    }

	if (dwFlags != 0)
	{
		DPFERR("Invalid flags specified");
		return(DPNERR_INVALIDFLAGS);
	}

    return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateRegisterLobby"

HRESULT DN_ValidateRegisterLobby(PVOID pInterface,
								 const DPNHANDLE dpnhLobbyConnection,
								 IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,
								 const DWORD dwFlags)
{
    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFX(DPFPREP,  0, "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( pIDP8LobbiedApplication != NULL &&
        !DNVALID_READPTR( pIDP8LobbiedApplication, sizeof( IDirectPlay8LobbiedApplication * ) ) )
    {
        DPFERR( "Invalid interface pointer specified for register lobby" );
        return DPNERR_INVALIDPOINTER;
    }

	if( dwFlags == 0 )
	{
		DPFERR( "You must specify either DPNLOBBY_REGISTER or DPNLOBBY_UNREGISTER" );
		return DPNERR_INVALIDFLAGS;
	}

	if( (dwFlags & DPNLOBBY_REGISTER) &&
		(dwFlags & DPNLOBBY_UNREGISTER) )
	{
		DPFERR( "You cannot specify both register and UNREGISTER" );
		return DPNERR_INVALIDPARAM;
	}

    if( dwFlags & ~(DPNLOBBY_REGISTER | DPNLOBBY_UNREGISTER) )
    {
        DPFERR( "Invalid flags specified" );
        return DPNERR_INVALIDFLAGS;
    }

	if( dwFlags & DPNLOBBY_REGISTER )
	{
	    if( dpnhLobbyConnection == 0 )
	    {
	    	DPFX(DPFPREP,  0, "Invalid handle" );
	    	return DPNERR_INVALIDHANDLE;
	    }

	    if( !pIDP8LobbiedApplication )
	    {
	    	DPFERR( "You must specify a lobby application interface to use" );
	    	return DPNERR_INVALIDPOINTER;
	    }
	}
	else
	{
		if( dpnhLobbyConnection != 0 || pIDP8LobbiedApplication != NULL )
		{
			DPFX(DPFPREP,  0, "When unregistering you must specify 0 for handle and NULL for lobbiedapp" );
			return DPNERR_INVALIDPARAM;
		}
	}

    return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateTerminateSession"

HRESULT DN_ValidateTerminateSession(PVOID pInterface,
									void *const pvTerminateData,
									const DWORD dwTerminateDataSize,
									const DWORD dwFlags)
{
    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFX(DPFPREP,  0, "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( dwTerminateDataSize > 0 &&
        (pvTerminateData == NULL || !DNVALID_READPTR( pvTerminateData, dwTerminateDataSize ) ) )
    {
        DPFERR( "Invalid pointer specified for terminate data" );
        return DPNERR_INVALIDPOINTER;
    }

    if( dwFlags != 0 )
    {
        DPFERR( "Invalid flags specified" );
        return DPNERR_INVALIDFLAGS;
    }

    return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateGetHostAddress"

HRESULT DN_ValidateGetHostAddress(PVOID pInterface,
								  IDirectPlay8Address **const prgpAddress,
								  DWORD *const pcAddress,
								  const DWORD dwFlags)
{
    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFX(DPFPREP,  0, "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( pcAddress == NULL || !DNVALID_WRITEPTR( pcAddress, sizeof( DWORD ) ) )
    {
        DPFX(DPFPREP,  0, "Invalid pointer specified for address count" );
        return DPNERR_INVALIDPOINTER;
    }

    if( *pcAddress > 0 &&
         (prgpAddress == NULL || !DNVALID_WRITEPTR( prgpAddress, sizeof( IDirectPlay8Address * ) * (*pcAddress) ) ) )
    {
        DPFERR( "Invalid pointer specified for address" );
        return DPNERR_INVALIDPOINTER;
    }

   	if (dwFlags != 0)
	{
		DPFERR("Invalid flags specified");
		return(DPNERR_INVALIDFLAGS);
	}

	return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateGetClientAddress"

HRESULT DN_ValidateGetClientAddress(IDirectPlay8Server *pInterface,
									const DPNID dpnid,
									IDirectPlay8Address **const ppAddress,
									const DWORD dwFlags)
{
    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFX(DPFPREP,  0, "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( dpnid == DPNID_ALL_PLAYERS_GROUP )
    {
        DPFERR( "Cannot get client address for ALL" );
        return DPNERR_INVALIDPLAYER;
    }

    if( ppAddress == NULL || !DNVALID_WRITEPTR( ppAddress, sizeof( IDirectPlay8Address * ) ) )
    {
        DPFERR( "Invalid pointer specified for address" );
        return DPNERR_INVALIDPOINTER;
    }

	if (dwFlags != 0)
	{
		DPFERR("Invalid flags specified");
		return DPNERR_INVALIDFLAGS;
	}

    return DPN_OK;

}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateGetClientInfo"

HRESULT DN_ValidateGetClientInfo(IDirectPlay8Server *pInterface,
								 const DPNID dpnid,
								 DPN_PLAYER_INFO *const pdpnPlayerInfo,
								 DWORD *const pdwSize,
								 const DWORD dwFlags)
{
    HRESULT hResultCode;

    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFX(DPFPREP,  0, "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( dpnid == DPNID_ALL_PLAYERS_GROUP )
    {
        DPFERR( "Cannot get client info for ALL" );
        return DPNERR_INVALIDPLAYER;
    }

    if( pdwSize == NULL || !DNVALID_WRITEPTR( pdwSize, sizeof( DWORD ) ) )
    {
        DPFERR( "Error validating size param, invalid pointer" );
        return DPNERR_INVALIDPOINTER;
    }

    if( *pdwSize &&
        (pdpnPlayerInfo == NULL || !DNVALID_WRITEPTR( pdpnPlayerInfo, *pdwSize ) ) )
    {
        DPFERR( "Error validating player info buffer, invalid pointer" );
        return DPNERR_INVALIDPOINTER;
    }

    if( pdpnPlayerInfo != NULL )
    {
        if( FAILED( hResultCode = DN_ValidPlayerInfo( pdpnPlayerInfo, FALSE ) ) )
        {
            DPFERR( "Error validating player info" );
            return hResultCode;
        }
    }

    if( dwFlags != 0 )
    {
        DPFERR( "Invalid flags specified" );
        return DPNERR_INVALIDFLAGS;
    }

    return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateSetServerInfo"

HRESULT DN_ValidateSetServerInfo(IDirectPlay8Server *pInterface,
								 const DPN_PLAYER_INFO *const pdpnPlayerInfo,
								 PVOID const pvAsyncContext,
								 DPNHANDLE *const phAsyncHandle,
								 const DWORD dwFlags)
{
    HRESULT hResultCode;

    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFX(DPFPREP,  0, "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( FAILED( hResultCode = DN_ValidPlayerInfo( pdpnPlayerInfo, TRUE ) ) )
    {
        DPFERR( "Error validating player info" );
        return hResultCode;
    }

    if( phAsyncHandle != NULL &&
        !DNVALID_WRITEPTR( phAsyncHandle, sizeof( DPNHANDLE ) ) )
    {
        DPFERR("Invalid async handle specified" );
        return( DPNERR_INVALIDPOINTER );
    }

   if( dwFlags & ~(DPNSETSERVERINFO_SYNC) )
    {
        DPFERR("Invalid flags specified" );
        return( DPNERR_INVALIDFLAGS );
    }

    if( dwFlags & DPNSETSERVERINFO_SYNC )
    {
        if( phAsyncHandle != NULL )
        {
            DPFERR( "You cannot specify an async handle if op is synchronous" );
            return( DPNERR_INVALIDPARAM );
        }
    }
    else
    {
        if( phAsyncHandle == NULL )
        {
            DPFERR( "You MUST specify a valid async handle w/async ops" );
            return( DPNERR_INVALIDPARAM );
        }
    }

    return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateSetPeerInfo"

HRESULT DN_ValidateSetPeerInfo(IDirectPlay8Peer *pInterface,
							   const DPN_PLAYER_INFO *const pdpnPlayerInfo,
							   PVOID const pvAsyncContext,
							   DPNHANDLE *const phAsyncHandle,
							   const DWORD dwFlags)
{
    HRESULT hResultCode;

    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFX(DPFPREP,  0, "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( FAILED( hResultCode = DN_ValidPlayerInfo( pdpnPlayerInfo, TRUE ) ) )
    {
        DPFERR( "Error validating player info" );
        return hResultCode;
    }

    if( phAsyncHandle != NULL &&
        !DNVALID_WRITEPTR( phAsyncHandle, sizeof( DPNHANDLE ) ) )
    {
        DPFERR("Invalid async handle specified" );
        return( DPNERR_INVALIDPOINTER );
    }

   if( dwFlags & ~(DPNSETPEERINFO_SYNC) )
    {
        DPFERR("Invalid flags specified" );
        return( DPNERR_INVALIDFLAGS );
    }

    if( dwFlags & DPNSETPEERINFO_SYNC )
    {
        if( phAsyncHandle != NULL )
        {
            DPFERR( "You cannot specify an async handle if op is synchronous" );
            return( DPNERR_INVALIDPARAM );
        }
    }
    else
    {
        if( phAsyncHandle == NULL )
        {
            DPFERR( "You MUST specify a valid async handle w/async ops" );
            return( DPNERR_INVALIDPARAM );
        }
    }

    return DPN_OK;

}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateGetPeerInfo"

HRESULT DN_ValidateGetPeerInfo(IDirectPlay8Peer *pInterface,
							   const DPNID dpnid,
							   DPN_PLAYER_INFO *const pdpnPlayerInfo,
							   DWORD *const pdwSize,
							   const DWORD dwFlags)
{
    HRESULT hResultCode;

    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFX(DPFPREP,  0, "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( dpnid == DPNID_ALL_PLAYERS_GROUP )
    {
        DPFERR( "Cannot get peer info for ALL" );
        return DPNERR_INVALIDPLAYER;
    }

    if( pdwSize == NULL || !DNVALID_WRITEPTR( pdwSize, sizeof( DWORD ) ) )
    {
        DPFERR( "Error validating size param, invalid pointer" );
        return DPNERR_INVALIDPOINTER;
    }

    if( *pdwSize &&
        (pdpnPlayerInfo == NULL || !DNVALID_WRITEPTR( pdpnPlayerInfo, *pdwSize ) ) )
    {
        DPFERR( "Error validating player info buffer, invalid pointer" );
        return DPNERR_INVALIDPOINTER;
    }

    if( pdpnPlayerInfo != NULL )
    {
        if( FAILED( hResultCode = DN_ValidPlayerInfo( pdpnPlayerInfo, FALSE ) ) )
        {
            DPFERR( "Error validating player info" );
            return hResultCode;
        }
    }

    if( dwFlags != 0 )
    {
        DPFERR( "Invalid flags specified" );
        return DPNERR_INVALIDFLAGS;
    }

    return DPN_OK;

}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateGetPeerAddress"

HRESULT DN_ValidateGetPeerAddress(IDirectPlay8Peer *pInterface,
								  const DPNID dpnid,
								  IDirectPlay8Address **const ppAddress,
								  const DWORD dwFlags)
{
    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFX(DPFPREP,  0, "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( dpnid == DPNID_ALL_PLAYERS_GROUP )
    {
        DPFERR( "Cannot get peer address for ALL" );
        return DPNERR_INVALIDPLAYER;
    }

    if( ppAddress == NULL || !DNVALID_WRITEPTR( ppAddress, sizeof( IDirectPlay8Address * ) ) )
    {
        DPFERR( "Invalid pointer specified for address" );
        return DPNERR_INVALIDPOINTER;
    }

	if (dwFlags != 0)
	{
		DPFERR("Invalid flags specified");
		return DPNERR_INVALIDFLAGS;
	}

    return DPN_OK;

}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateGetServerAddress"

HRESULT DN_ValidateGetServerAddress(IDirectPlay8Client *pInterface,
									IDirectPlay8Address **const ppAddress,
									const DWORD dwFlags)
{
    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFX(DPFPREP,  0, "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( ppAddress == NULL || !DNVALID_WRITEPTR( ppAddress, sizeof( IDirectPlay8Address * ) ) )
    {
        DPFERR( "Invalid pointer specified for address" );
        return DPNERR_INVALIDPOINTER;
    }

     if( dwFlags != 0 )
    {
        DPFERR( "Invalid flags specified" );
        return( DPNERR_INVALIDFLAGS );
    }

   return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateGetHostSendQueueInfo"

HRESULT DN_ValidateGetHostSendQueueInfo(IDirectPlay8Client *pInterface,
										DWORD *const pdwNumMsgs,
										DWORD *const pdwNumBytes,
										const DWORD dwFlags )
{
    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFX(DPFPREP,  0, "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

	if( pdwNumMsgs != NULL &&
	    !DNVALID_WRITEPTR( pdwNumMsgs, sizeof( DWORD ) ) )
	{
	    DPFERR("Invalid num messages specified" );
	    return( DPNERR_INVALIDPOINTER );
	}

	if( pdwNumBytes != NULL &&
	    !DNVALID_WRITEPTR( pdwNumBytes, sizeof( DWORD ) ) )
	{
	    DPFERR("Invalid num bytes specified" );
	    return( DPNERR_INVALIDPOINTER );
	}

	if( pdwNumBytes == NULL && pdwNumMsgs == NULL )
	{
	    DPFERR("Must request at least one of num bytes and num messages" );
	    return( DPNERR_INVALIDPARAM );
	}

    if( dwFlags & ~(DPNGETSENDQUEUEINFO_PRIORITY_HIGH | DPNGETSENDQUEUEINFO_PRIORITY_LOW | DPNGETSENDQUEUEINFO_PRIORITY_NORMAL) )
    {
        DPFERR( "Invalid flags specified" );
        return( DPNERR_INVALIDFLAGS );
    }

    return DPN_OK;

}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateGetServerInfo"

HRESULT DN_ValidateGetServerInfo(IDirectPlay8Client *pInterface,
								 DPN_PLAYER_INFO *const pdpnPlayerInfo,
								 DWORD *const pdwSize,
								 const DWORD dwFlags)
{
    HRESULT hResultCode;

    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFX(DPFPREP,  0, "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( pdwSize == NULL || !DNVALID_WRITEPTR( pdwSize, sizeof( DWORD ) ) )
    {
        DPFERR( "Error validating size param, invalid pointer" );
        return DPNERR_INVALIDPOINTER;
    }

    if( *pdwSize &&
        (pdpnPlayerInfo == NULL || !DNVALID_WRITEPTR( pdpnPlayerInfo, *pdwSize ) ) )
    {
        DPFERR( "Error validating player info buffer, invalid pointer" );
        return DPNERR_INVALIDPOINTER;
    }

    if( pdpnPlayerInfo != NULL )
    {
        if( FAILED( hResultCode = DN_ValidPlayerInfo( pdpnPlayerInfo, FALSE ) ) )
        {
            DPFERR( "Error validating player info" );
            return hResultCode;
        }
    }

    if( dwFlags != 0 )
    {
        DPFERR( "Invalid flags specified" );
        return DPNERR_INVALIDFLAGS;
    }

    return DPN_OK;

}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateSetClientInfo"

HRESULT DN_ValidateSetClientInfo(IDirectPlay8Client *pInterface,
								 const DPN_PLAYER_INFO *const pdpnPlayerInfo,
								 const PVOID pvAsyncContext,
								 DPNHANDLE *const phAsyncHandle,
								 const DWORD dwFlags)
{
    HRESULT hResultCode;

    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFX(DPFPREP,  0, "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( dwFlags & DPNSETCLIENTINFO_SYNC )
    {
        if( phAsyncHandle != NULL )
        {
            DPFERR( "You cannot specify an async handle pointer if op is synchronous" );
            return( DPNERR_INVALIDPARAM );
        }
    }
    else
    {
        if( phAsyncHandle == NULL )
        {
            DPFERR( "You MUST specify a valid async handle pointer w/async ops" );
            return( DPNERR_INVALIDPARAM );
        }
    }

    if( phAsyncHandle != NULL &&
        !DNVALID_WRITEPTR( phAsyncHandle, sizeof( DPNHANDLE ) ) )
    {
        DPFERR("Invalid async handle pointer specified" );
        return( DPNERR_INVALIDPOINTER );
    }

    if( FAILED( hResultCode = DN_ValidPlayerInfo( pdpnPlayerInfo, TRUE ) ) )
    {
        DPFERR("Error validating player info" );
        return hResultCode;
    }

    if( dwFlags & ~(DPNSETCLIENTINFO_SYNC) )
    {
        DPFERR("Invalid flags specified" );
        return( DPNERR_INVALIDFLAGS );
    }

    return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateGetConnectionInfoHelper"

HRESULT DN_ValidateGetConnectionInfoHelper(PVOID pv,
										   const DPNID dpnid,
										   DPN_CONNECTION_INFO *const pdpConnectionInfo,
										   BOOL fServerPlayer,
										   const DWORD dwFlags)
{
    if( !IsValidDirectPlay8Object( pv ) )
    {
        DPFX(DPFPREP,  0, "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( pdpConnectionInfo == NULL ||
        !DNVALID_WRITEPTR( pdpConnectionInfo, sizeof( DPN_CONNECTION_INFO ) ) )
    {
        DPFX(DPFPREP,  0, "Invalid pointer for connection info" );
        return(DPNERR_INVALIDPOINTER);
    }

    if( pdpConnectionInfo->dwSize != sizeof( DPN_CONNECTION_INFO ) &&
		pdpConnectionInfo->dwSize != sizeof( DPN_CONNECTION_INFO_INTERNAL ))
    {
        DPFX(DPFPREP,  0, "Invalid size on connection info structure" );
        return(DPNERR_INVALIDPARAM);
    }

	if (dwFlags != 0)
	{
		DPFERR("Invalid flags specified");
		return(DPNERR_INVALIDFLAGS);
	}
	return DPN_OK;

}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateGetSPCaps"

HRESULT DN_ValidateGetSPCaps(PVOID pv,
							 const GUID * const pguidSP,
							 DPN_SP_CAPS *const pdnSPCaps,
							 const DWORD dwFlags)
{
    if( !IsValidDirectPlay8Object( pv ) )
    {
        DPFX(DPFPREP,  0, "Invalid object" );
	    return(DPNERR_INVALIDOBJECT);
    }

    if( pguidSP == NULL ||
       !DNVALID_READPTR( pguidSP, sizeof( GUID ) ) )
    {
    	DPFERR( "Invalid pointer specified for SP GUID" );
    	return(DPNERR_INVALIDPOINTER);
    }

    if( pdnSPCaps == NULL ||
        !DNVALID_WRITEPTR( pdnSPCaps, sizeof( DPN_SP_CAPS ) ) )
    {
        DPFX(DPFPREP,  0, "Invalid pointer for caps" );
	    return(DPNERR_INVALIDPOINTER);
    }

    if( pdnSPCaps->dwSize != sizeof( DPN_SP_CAPS ) )
    {
        DPFX(DPFPREP,  0, "Invalid size on SP caps structure" );
        return(DPNERR_INVALIDPARAM);
    }

	if (dwFlags != 0)
	{
		DPFERR("Invalid flags specified");
		return(DPNERR_INVALIDFLAGS);
	}

    return DPN_OK;

}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateSetSPCaps"

HRESULT DN_ValidateSetSPCaps(PVOID pv,
							 const GUID * const pguidSP,
							 const DPN_SP_CAPS *const pdnSPCaps,
							 const DWORD dwFlags)
{
    HRESULT hr;

    if( !IsValidDirectPlay8Object( pv ) )
    {
        DPFX(DPFPREP,  0, "Invalid object" );
        return(DPNERR_INVALIDOBJECT);
    }

    if( pguidSP == NULL ||
        !DNVALID_READPTR( pguidSP, sizeof( GUID ) ) )
    {
        DPFX(DPFPREP,  0, "Invalid pointer to GUID specified" );
        return(DPNERR_INVALIDPOINTER);
    }

	if(dwFlags){
		DPFX(DPFPREP,  0, "Invalid Flags specified, must be zero" );
		return DPNERR_INVALIDFLAGS;
	}

    hr = DN_ValidSPCaps( pdnSPCaps );

    if( FAILED( hr ) )
    {
        DPFX(DPFPREP,  0, "Error validating caps structure hr=[0x%lx]", hr );
        return( hr );
    }

    return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateGetCaps"

HRESULT DN_ValidateGetCaps(PVOID pv,
						   DPN_CAPS *const pdnCaps,
						   const DWORD dwFlags)
{
    if( !IsValidDirectPlay8Object( pv ) )
    {
        DPFX(DPFPREP,  0, "Invalid object" );
        return(DPNERR_INVALIDOBJECT);
    }

    if( pdnCaps == NULL ||
        !DNVALID_WRITEPTR( pdnCaps, sizeof( DPN_CAPS ) ) )
    {
        DPFX(DPFPREP,  0, "Invalid pointer for caps" );
        return(DPNERR_INVALIDPOINTER);
    }

    if( pdnCaps->dwSize != sizeof( DPN_CAPS ) )
    {
        DPFX(DPFPREP,  0, "Invalid size on caps structure" );
        return(DPNERR_INVALIDPARAM);
    }

	if (dwFlags != 0)
	{
		DPFERR("Invalid flags specified");
		return(DPNERR_INVALIDFLAGS);
	}

    return DPN_OK;

}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateSetCaps"

HRESULT DN_ValidateSetCaps(PVOID pv,
						   const DPN_CAPS *const pdnCaps,
						   const DWORD dwFlags)
{
    HRESULT hResultCode;

    if( !IsValidDirectPlay8Object( pv ) )
    {
        DPFX(DPFPREP,  0, "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    hResultCode = DN_ValidCaps( pdnCaps );

    if( FAILED( hResultCode ) )
    {
        DPFX(DPFPREP,  0, "Error validating caps structure hr=0x%x", hResultCode );
        return(hResultCode);
    }

    if( dwFlags != 0 )
    {
        DPFX(DPFPREP,  0, "Invalid flags specified" );
        return(DPNERR_INVALIDFLAGS);
    }

    return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateEnumHosts"

HRESULT DN_ValidateEnumHosts(PVOID pv,
							 DPN_APPLICATION_DESC *const pApplicationDesc,
							 IDirectPlay8Address *const pAddrHost,
							 IDirectPlay8Address *const pDeviceInfo,
							 PVOID const pUserEnumData,
							 const DWORD dwUserEnumDataSize,
							 const DWORD dwRetryCount,
							 const DWORD dwRetryInterval,
							 const DWORD dwTimeOut,
							 PVOID const pvAsyncContext,
							 DPNHANDLE *const pAsyncHandle,
							 const DWORD dwFlags )
{
    HRESULT hResultCode;
    GUID guidspHost, guidspDevice;

    if( !IsValidDirectPlay8Object( pv ) )
    {
        DPFERR("Invalid object specified " );
	    return( DPNERR_INVALIDOBJECT );
    }

    if( pApplicationDesc == NULL ||
        !DNVALID_READPTR( pApplicationDesc, sizeof( DPN_APPLICATION_DESC ) ) )
    {
        DPFERR( "Invalid pointer for app desc specified" );
        return( DPNERR_INVALIDPOINTER );
    }

    if( pApplicationDesc->dwSize != sizeof( DPN_APPLICATION_DESC ) )
    {
        DPFERR( "Invalid size for application desc" );
        return( DPNERR_INVALIDPARAM );
    }

    if( pApplicationDesc->dwFlags != 0 || pApplicationDesc->dwMaxPlayers != 0 || pApplicationDesc->dwCurrentPlayers != 0 ||
        pApplicationDesc->pvReservedData != NULL || pApplicationDesc->dwReservedDataSize != 0 ||
        pApplicationDesc->pvApplicationReservedData != NULL || pApplicationDesc->dwApplicationReservedDataSize != 0 )
    {
        DPFERR( "Can only specify dwSize and guidInstance and guidApplication in call to EnumHosts" );
        return DPNERR_INVALIDPARAM;
    }

	if (pAddrHost != NULL)
	{
		if( !DNVALID_READPTR( pAddrHost, sizeof( IDirectPlay8Address * ) ) )
		{
			DPFERR( "Invalid pointer specified for host address" );
			return( DPNERR_INVALIDPOINTER );
		}

		if( FAILED( hResultCode = pAddrHost->lpVtbl->GetSP( pAddrHost, &guidspHost ) ) )
		{
			DPFX(DPFPREP,  0, "Unable to get SP for specified address hr=0x%x", hResultCode );
			return( DPNERR_INVALIDHOSTADDRESS );
		}
	}

    if( pDeviceInfo == NULL || !DNVALID_READPTR( pDeviceInfo, sizeof ( IDirectPlay8Address * ) ) )
    {
        DPFERR("Invalid pointer for device address" );
        return( DPNERR_INVALIDPOINTER );
    }

    if( FAILED( hResultCode = pDeviceInfo->lpVtbl->GetSP( pDeviceInfo, &guidspDevice ) ) )
    {
        DPFX(DPFPREP,  0, "Unable to get SP for specified address hr=0x%x", hResultCode );
        return( DPNERR_INVALIDDEVICEADDRESS );
    }

	if (pAddrHost != NULL)
	{
		if( guidspHost != guidspDevice )
		{
			DPFERR( "Device and remote addresses must use the same SP" );
			return( DPNERR_INVALIDPARAM );
		}
	}

    if( dwUserEnumDataSize > 0 &&
        (pUserEnumData == NULL || !DNVALID_READPTR( pUserEnumData, dwUserEnumDataSize ) ) )
    {
        DPFERR( "Invalid pointer specified for user enum data" );
        return( DPNERR_INVALIDPOINTER );
    }

    if( dwFlags & DPNENUMHOSTS_SYNC )
    {
        if( pAsyncHandle != NULL )
        {
            DPFERR( "You cannot specify an async handle pointer if op is synchronous" );
            return( DPNERR_INVALIDPARAM );
        }
    }
    else
    {
        if( pAsyncHandle == NULL )
        {
            DPFERR( "You MUST specify a valid async handle pointer w/async ops" );
            return( DPNERR_INVALIDPARAM );
        }
    }

    if( pAsyncHandle != NULL &&
        !DNVALID_WRITEPTR( pAsyncHandle, sizeof( DPNHANDLE ) ) )
    {
        DPFERR( "Invalid async handle pointer specified" );
        return( DPNERR_INVALIDPOINTER );
    }

    if( dwFlags & ~(DPNENUMHOSTS_OKTOQUERYFORADDRESSING | DPNENUMHOSTS_SYNC | DPNENUMHOSTS_NOBROADCASTFALLBACK ) )
    {
        DPFX(DPFPREP,  0, "Invalid flags specified" );
        return( DPNERR_INVALIDFLAGS );
    }

    return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateEnumGroupMembers"

HRESULT DN_ValidateEnumGroupMembers(PVOID pInterface,
									const DPNID dpnid,
									DPNID *const prgdpnid,
									DWORD *const pcdpnid,
									const DWORD dwFlags)
{
    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFERR("Invalid object specified " );
	    return( DPNERR_INVALIDOBJECT );
    }

    if( dpnid == DPNID_ALL_PLAYERS_GROUP )
    {
        DPFERR("Cannot enumerate all players group" );
        return DPNERR_INVALIDGROUP;
    }

    if( pcdpnid == NULL ||
        !DNVALID_WRITEPTR( pcdpnid, sizeof( DWORD ) ) )
    {
        DPFERR("Invalid count param specified" );
        return( DPNERR_INVALIDPOINTER );
    }

    if( *pcdpnid > 0 &&
        (prgdpnid == NULL || !DNVALID_WRITEPTR( prgdpnid, *pcdpnid ) ) )
    {
        DPFERR("Invalid pointer specified for buffer" );
        return( DPNERR_INVALIDPOINTER );
    }

    if( dwFlags != 0 )
    {
        DPFERR( "Invalid flags specified" );
        return( DPNERR_INVALIDFLAGS );
    }

    return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateEnumClientsAndGroups"

HRESULT DN_ValidateEnumClientsAndGroups(PVOID pInterface,
										DPNID *const prgdpnid,
										DWORD *const pcdpnid,
										const DWORD dwFlags)
{
    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFERR("Invalid object specified " );
	    return( DPNERR_INVALIDOBJECT );
    }

    if( pcdpnid == NULL ||
        !DNVALID_WRITEPTR( pcdpnid, sizeof( DWORD ) ) )
    {
        DPFERR("Invalid count param specified" );
        return( DPNERR_INVALIDPOINTER );
    }

    if( *pcdpnid > 0 &&
        (prgdpnid == NULL || !DNVALID_WRITEPTR( prgdpnid, *pcdpnid ) ) )
    {
        DPFERR("Invalid pointer specified for buffer" );
        return( DPNERR_INVALIDPOINTER );
    }

	if (dwFlags == 0)
	{
		DPFERR("Flags must be specified");
		return( DPNERR_INVALIDPARAM );
	}

    if (dwFlags & ~(DPNENUM_GROUPS | DPNENUM_PLAYERS))
    {
        DPFERR( "Invalid flags specified" );
        return( DPNERR_INVALIDFLAGS );
    }

    return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateGetGroupInfo"

HRESULT DN_ValidateGetGroupInfo(PVOID pv,
								const DPNID dpnid,
								DPN_GROUP_INFO *const pdpnGroupInfo,
								DWORD *const pdwSize,
								const DWORD dwFlags)
{
    HRESULT hResultCode;

    if( !IsValidDirectPlay8Object( pv ) )
    {
        DPFERR("Invalid object specified " );
	    return( DPNERR_INVALIDOBJECT );
    }

    if( dpnid == DPNID_ALL_PLAYERS_GROUP )
    {
        DPFERR("Cannot get group info for all players group" );
        return( DPNERR_INVALIDGROUP );
    }

    if( pdwSize == NULL ||
        !DNVALID_WRITEPTR( pdwSize, sizeof( DWORD ) ) )
    {
        DPFERR("Invalid pdwSize parameter specified" );
        return( DPNERR_INVALIDPOINTER );
    }

    // Only validate group info pointer if size is > 0
    if( *pdwSize > 0 )
    {
        if( pdpnGroupInfo == NULL ||
            !DNVALID_WRITEPTR( pdpnGroupInfo, *pdwSize ) )
        {
            DPFERR("Invalid pointer specified for group info" );
            return( DPNERR_INVALIDPOINTER );
        }

        if( FAILED( hResultCode = DN_ValidGroupInfo( pdpnGroupInfo, FALSE ) ) )
        {
            DPFERR("Error validating group info parameter" );
            return( hResultCode );
        }
    }

    if( dwFlags != 0 )
    {
        DPFERR( "Invalid flags specified" );
        return( DPNERR_INVALIDFLAGS );
    }

    return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateSetGroupInfo"

HRESULT DN_ValidateSetGroupInfo(PVOID pv,
								const DPNID dpnid,
								DPN_GROUP_INFO *const pdpnGroupInfo,
								PVOID const pvAsyncContext,
								DPNHANDLE *const phAsyncHandle,
								const DWORD dwFlags)
{
    HRESULT hResultCode;

    if( !IsValidDirectPlay8Object( pv ) )
    {
        DPFERR("Invalid object specified " );
	    return( DPNERR_INVALIDOBJECT );
    }

    if( dpnid == DPNID_ALL_PLAYERS_GROUP )
    {
        DPFERR( "Cannot remove from all players group" );
        return( DPNERR_INVALIDGROUP );
    }

    if( FAILED( hResultCode = DN_ValidGroupInfo( pdpnGroupInfo, TRUE ) ) )
    {
        DPFERR( "Error validating group info structure" );
        return(hResultCode);
    }

    if( dwFlags & DPNSETGROUPINFO_SYNC )
    {
        if( phAsyncHandle != NULL )
        {
            DPFERR( "You cannot specify an async handle pointer if op is synchronous" );
            return( DPNERR_INVALIDPARAM );
        }
    }
    else
    {
        if( phAsyncHandle == NULL )
        {
            DPFERR( "You MUST specify a valid async handle pointer w/async ops" );
            return( DPNERR_INVALIDPARAM );
        }
    }

    if( phAsyncHandle != NULL &&
        !DNVALID_WRITEPTR( phAsyncHandle, sizeof( DPNHANDLE ) ) )
    {
        DPFERR("Invalid async handle pointer specified" );
        return( DPNERR_INVALIDPOINTER );
    }

    if( dwFlags & ~(DPNSETGROUPINFO_SYNC) )
    {
        DPFERR("Invalid flags specified" );
        return( DPNERR_INVALIDFLAGS );
    }

    return DPN_OK;

}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateRemoveClientFromGroup"

HRESULT DN_ValidateRemoveClientFromGroup(PVOID pInterface,
										 const DPNID dpnidGroup,
										 const DPNID dpnidClient,
										 PVOID const pvAsyncContext,
										 DPNHANDLE *const phAsyncHandle,
										 const DWORD dwFlags)
{
    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFERR("Invalid object specified " );
	    return( DPNERR_INVALIDOBJECT );
    }

    if( dpnidGroup == DPNID_ALL_PLAYERS_GROUP )
    {
        DPFERR( "Cannot remove from all players group" );
        return( DPNERR_INVALIDGROUP );
    }

    if( dpnidClient == DPNID_ALL_PLAYERS_GROUP )
    {
        DPFERR( "Cannot specify all players group as client to remove" );
        return( DPNERR_INVALIDPARAM );
    }

    if( dwFlags & DPNREMOVEPLAYERFROMGROUP_SYNC )
    {
        if( phAsyncHandle != NULL )
        {
            DPFERR( "You cannot specify an async handle pointer if op is synchronous" );
            return( DPNERR_INVALIDPARAM );
        }
    }
    else
    {
        if( phAsyncHandle == NULL )
        {
            DPFERR( "You MUST specify a valid async handle pointer w/async ops" );
            return( DPNERR_INVALIDPARAM );
        }
    }

    if( phAsyncHandle != NULL &&
        !DNVALID_WRITEPTR( phAsyncHandle, sizeof( DPNHANDLE ) ) )
    {
        DPFERR("Invalid async handle pointer specified" );
        return( DPNERR_INVALIDPOINTER );
    }

    if( dwFlags & ~(DPNREMOVEPLAYERFROMGROUP_SYNC) )
    {
        DPFERR("Invalid flags specified" );
        return( DPNERR_INVALIDFLAGS );
    }

    return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateAddClientToGroup"

HRESULT DN_ValidateAddClientToGroup(PVOID pInterface,
									const DPNID dpnidGroup,
									const DPNID dpnidClient,
									PVOID const pvAsyncContext,
									DPNHANDLE *const phAsyncHandle,
									const DWORD dwFlags)
{
    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFERR("Invalid object specified " );
	    return( DPNERR_INVALIDOBJECT );
    }

    if( dpnidGroup == DPNID_ALL_PLAYERS_GROUP )
    {
        DPFERR( "Cannot add from all players group" );
        return( DPNERR_INVALIDGROUP );
    }

    if( dpnidClient == DPNID_ALL_PLAYERS_GROUP )
    {
        DPFERR( "Cannot specify all players group as client to add" );
        return( DPNERR_INVALIDPLAYER );
    }

    if( dwFlags & DPNADDPLAYERTOGROUP_SYNC )
    {
        if( phAsyncHandle != NULL )
        {
            DPFERR( "You cannot specify an async handle pointer if op is synchronous" );
            return( DPNERR_INVALIDPARAM );
        }
    }
    else
    {
        if( phAsyncHandle == NULL )
        {
            DPFERR( "You MUST specify a valid async handle pointer w/async ops" );
            return( DPNERR_INVALIDPARAM );
        }
    }

    if( phAsyncHandle != NULL &&
        !DNVALID_WRITEPTR( phAsyncHandle, sizeof( DPNHANDLE ) ) )
    {
        DPFERR("Invalid async handle pointer specified" );
        return( DPNERR_INVALIDPOINTER );
    }

    if( dwFlags & ~(DPNADDPLAYERTOGROUP_SYNC) )
    {
        DPFERR("Invalid flags specified" );
        return( DPNERR_INVALIDFLAGS );
    }

    return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateDestroyGroup"

HRESULT DN_ValidateDestroyGroup(PVOID pInterface,
								const DPNID dpnidGroup,
								PVOID const pvAsyncContext,
								DPNHANDLE *const phAsyncHandle,
								const DWORD dwFlags)
{
    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFERR("Invalid object specified " );
	    return( DPNERR_INVALIDOBJECT );
    }

    if( dpnidGroup == DPNID_ALL_PLAYERS_GROUP )
    {
        DPFERR( "Cannot destroy all players group" );
        return( DPNERR_INVALIDGROUP );
    }

    if( dwFlags & DPNDESTROYGROUP_SYNC )
    {
        if( phAsyncHandle != NULL )
        {
            DPFERR( "You cannot specify an async handle pointer if op is synchronous" );
            return( DPNERR_INVALIDPARAM );
        }
    }
    else
    {
        if( phAsyncHandle == NULL )
        {
            DPFERR( "You MUST specify a valid async handle pointer w/async ops" );
            return( DPNERR_INVALIDPARAM );
        }
    }

    if( phAsyncHandle != NULL &&
        !DNVALID_WRITEPTR( phAsyncHandle, sizeof( DPNHANDLE ) ) )
    {
        DPFERR("Invalid async handle pointer specified" );
        return( DPNERR_INVALIDPOINTER );
    }

    if( dwFlags & ~(DPNDESTROYGROUP_SYNC) )
    {
        DPFERR("Invalid flags specified" );
        return( DPNERR_INVALIDFLAGS );
    }

    return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateCreateGroup"

HRESULT DN_ValidateCreateGroup(PVOID pInterface,
							   const DPN_GROUP_INFO *const pdpnGroupInfo,
							   void *const pvGroupContext,
							   void *const pvAsyncContext,
							   DPNHANDLE *const phAsyncHandle,
							   const DWORD dwFlags)
{
    HRESULT hResultCode;

    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFERR("Invalid object specified " );
	    return( DPNERR_INVALIDOBJECT );
    }

    if( FAILED( hResultCode = DN_ValidGroupInfo( pdpnGroupInfo, TRUE ) ) )
    {
        DPFERR("Invalid group info structure" );
        return( DPNERR_INVALIDPARAM );
    }

    if( dwFlags & DPNCREATEGROUP_SYNC )
    {
        if( phAsyncHandle != NULL )
        {
            DPFERR( "You cannot specify an async handle pointer if op is synchronous" );
            return( DPNERR_INVALIDPARAM );
        }
    }
    else
    {
        if( phAsyncHandle == NULL )
        {
            DPFERR( "You MUST specify a valid async handle pointer w/async ops" );
            return( DPNERR_INVALIDPARAM );
        }
    }

    if( phAsyncHandle != NULL &&
        !DNVALID_WRITEPTR( phAsyncHandle, sizeof( DPNHANDLE ) ) )
    {
        DPFERR("Invalid async handle pointer specified" );
        return( DPNERR_INVALIDPOINTER );
    }

    if( dwFlags & ~(DPNCREATEGROUP_SYNC) )
    {
        DPFERR( "Invalid flags specified" );
        return( DPNERR_INVALIDFLAGS );
    }

	return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateHost"

HRESULT DN_ValidateHost(PVOID pInterface,
						const DPN_APPLICATION_DESC *const pdnAppDesc,
						IDirectPlay8Address **const prgpDeviceInfo,
						const DWORD cDeviceInfo,
						const DPN_SECURITY_DESC *const pdnSecurity,
						const DPN_SECURITY_CREDENTIALS *const pdnCredentials,
						void *const pvPlayerContext,
						const DWORD dwFlags)
{
    HRESULT hResultCode;
	GUID guidSP;
	DWORD dwTmpPort;
	DWORD dwPortType;
	DWORD dwPortSize;

    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFERR("Invalid object specified " );
	    return( DPNERR_INVALIDOBJECT );
    }

    if( FAILED( hResultCode = DN_ValidHostAppDesc( pdnAppDesc ) ) )
    {
        DPFERR("Invalid host app desc specified");
        return( hResultCode );
    }

    if( prgpDeviceInfo == NULL || cDeviceInfo == 0 )
    {
        DPFERR("You MUST specify a device address");
        return( DPNERR_INVALIDDEVICEADDRESS );
    }
    else
    {
        if( cDeviceInfo > 0 &&
            !DNVALID_READPTR( prgpDeviceInfo, sizeof( IDirectPlay8Address * ) * cDeviceInfo ) )
        {
            DPFERR("Invalid pointer specified for device info" );
            return( DPNERR_INVALIDPOINTER );
        }

    	// ensure SPs are specified in addresses
    	for (DWORD dw = 0 ; dw < cDeviceInfo ; dw++)
    	{
			if ( prgpDeviceInfo[dw] == NULL )
			{
				DPFERR( "Null device address interface pointer specified" );
				return( DPNERR_INVALIDDEVICEADDRESS );
			}
    		if (prgpDeviceInfo[dw]->lpVtbl->GetSP(prgpDeviceInfo[dw],&guidSP) != DPN_OK)
    		{
    		    DPFERR("SP not specified for one of the addresses" );
    			return(DPNERR_INVALIDDEVICEADDRESS);
    		}

    		dwPortType = DPNA_DATATYPE_DWORD;
    		dwPortSize = sizeof( DWORD );
			// Check to ensure it's not using the default DPNSVR port
			if( SUCCEEDED( hResultCode = IDirectPlay8Address_GetComponentByName( prgpDeviceInfo[dw], DPNA_KEY_PORT, &dwTmpPort, &dwPortSize, &dwPortType ) ) )
			{
				if( dwTmpPort == DPNA_DPNSVR_PORT )
				{
					DPFERR( "Cannot use the DPNSVR port in device addresses" );
					DPFERR( "This port is reserved for DPNSVR" );
					return( DPNERR_INVALIDDEVICEADDRESS );
				}
			}    		
    	}
    }

    if( FAILED( hResultCode = DN_ValidSecurityDesc( pdnSecurity ) ) )
    {
        DPFERR("Error validating reserved param" );
        return( hResultCode );
    }

    if( FAILED( hResultCode = DN_ValidSecurityCredentials(pdnCredentials) ) )
    {
        DPFERR("Error validating reserved param" );
        return( hResultCode );
    }

    if( ( dwFlags & ~( DPNHOST_OKTOQUERYFORADDRESSING ) ) != 0 )
    {
        DPFERR("Invalid flags specified" );
        return( DPNERR_INVALIDFLAGS );
    }

    return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateEnumServiceProviders"

HRESULT DN_ValidateEnumServiceProviders(PVOID pInterface,
										const GUID *const pguidServiceProvider,
										const GUID *const pguidApplication,
										DPN_SERVICE_PROVIDER_INFO *const pSPInfoBuffer,
										DWORD *const pcbEnumData,
										DWORD *const pcReturned,
										const DWORD dwFlags )
{
    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFERR("Invalid object specified " );
	    return( DPNERR_INVALIDOBJECT );
    }

	if( pguidServiceProvider != NULL &&
	    !DNVALID_READPTR( pguidServiceProvider, sizeof( GUID ) ) )
	{
	    DPFERR("Invalid service provider specified" );
	    return( DPNERR_INVALIDPOINTER );
	}

	if( pguidApplication != NULL &&
	    !DNVALID_READPTR( pguidApplication, sizeof( GUID ) ) )
	{
	    DPFERR("Invalid application GUID specified" );
	    return( DPNERR_INVALIDPOINTER );
	}

	if( pcbEnumData == NULL ||
	    !DNVALID_READPTR( pcbEnumData, sizeof( DWORD ) ) )
	{
	    DPFERR("Invalid enum data pointer" );
	    return( DPNERR_INVALIDPOINTER );
	}

	if( pcReturned == NULL ||
	    !DNVALID_READPTR( pcReturned, sizeof( DWORD ) ) )
	{
	    DPFERR("Invalid retuned count" );
	    return( DPNERR_INVALIDPOINTER );
	}

	if( *pcbEnumData > 0 &&
	    (pSPInfoBuffer == NULL || !DNVALID_WRITEPTR(pSPInfoBuffer,*pcbEnumData) ) )
	{
	    DPFERR("Invalid enum buffer specified" );
	    return( DPNERR_INVALIDPOINTER );
	}

	if( dwFlags & (~(DPNENUMSERVICEPROVIDERS_ALL)) )
	{
	    DPFERR("Invalid flags specified" );
	    return( DPNERR_INVALIDFLAGS );
	}

    return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateCancelAsyncOperation"

HRESULT DN_ValidateCancelAsyncOperation(PVOID pvInterface,
										const DPNHANDLE hAsyncOp,
										const DWORD dwFlags )
{
	if( !IsValidDirectPlay8Object( pvInterface ) )
    {
        DPFERR("Invalid object specified " );
	    return( DPNERR_INVALIDOBJECT );
    }

	if( dwFlags )
	{
		if( hAsyncOp )
		{
			DPFERR("Invalid parameter, hAsyncOp specified with flags");
			return ( DPNERR_INVALIDPARAM );
		}

		// make sure only correct bits are set, AND only 1 bit is set.
		if(  ( dwFlags != ( dwFlags & ( DPNCANCEL_ALL_OPERATIONS | DPNCANCEL_CONNECT | DPNCANCEL_ENUM | DPNCANCEL_SEND ) ) ) ||
			( ( ( dwFlags - 1 ) & dwFlags ) != 0 ) )
		{
		    DPFERR("Invalid flags specified" );
		    return( DPNERR_INVALIDFLAGS );
		}
	}
	else
	{
		if( hAsyncOp == NULL)
		{
		    DPFERR("Invalid handle specified" );
		    return( DPNERR_INVALIDHANDLE );
		}
	}
	return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateConnect"

HRESULT DN_ValidateConnect(PVOID pInterface,
						   const DPN_APPLICATION_DESC *const pdnAppDesc,
						   IDirectPlay8Address *const pHostAddr,
						   IDirectPlay8Address *const pDeviceInfo,
						   const DPN_SECURITY_DESC *const pdnSecurity,
						   const DPN_SECURITY_CREDENTIALS *const pdnCredentials,
						   const void *const pvUserConnectData,
						   const DWORD dwUserConnectDataSize,
						   void *const pvPlayerContext,
						   void *const pvAsyncContext,
						   DPNHANDLE *const phAsyncHandle,
						   const DWORD dwFlags)
{
    HRESULT hResultCode;
    GUID guidHost, guidDevice;

	if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFERR("Invalid object specified " );
	    return( DPNERR_INVALIDOBJECT );
    }

    hResultCode = DN_ValidConnectAppDesc( pdnAppDesc );

    if( FAILED( hResultCode ) )
    {
        DPFX(DPFPREP, 0, "Invalid connect app desc hr=[0x%lx]", hResultCode );
        return( hResultCode );
    }

	if( pHostAddr == NULL ||
	    !DNVALID_READPTR( pHostAddr, sizeof( IDirectPlay8Address * ) ) )
	{
	    DPFERR("Invalid host address specified" );
	    return( DPNERR_INVALIDHOSTADDRESS );
	}

	if( FAILED( hResultCode = IDirectPlay8Address_GetSP( pHostAddr, &guidHost ) ) )
	{
	    DPFERR("No SP specified in host address" );
	    return( DPNERR_INVALIDHOSTADDRESS );
	}

	//
	//	Allow a NULL Device Address (we will copy the SP from the Host address
	//
	if( pDeviceInfo != NULL)
	{
		if ( !DNVALID_READPTR( pDeviceInfo, sizeof( IDirectPlay8Address * ) ) )
		{
			DPFERR("Invalid device address specified" );
			return( hResultCode );
		}

		if( FAILED( hResultCode = IDirectPlay8Address_GetSP( pDeviceInfo, &guidDevice ) ) )
		{
			DPFERR("No SP specified in device address" );
			return( DPNERR_INVALIDDEVICEADDRESS );
		}

		if (guidHost != guidDevice)
		{
			DPFERR( "Specified different SPs for device and connect" );
			return(DPNERR_INVALIDDEVICEADDRESS);
		}

		DWORD dwTmpPort;
		DWORD dwDataType;
		DWORD dwDataSize;

		dwDataType = DPNA_DATATYPE_DWORD;
		dwDataSize = sizeof( DWORD );

		// Check to ensure it's not using the default DPNSVR port
		if( SUCCEEDED( hResultCode = IDirectPlay8Address_GetComponentByName( pDeviceInfo, DPNA_KEY_PORT, &dwTmpPort, &dwDataSize, &dwDataType ) ) )
		{
			if( dwTmpPort == DPNA_DPNSVR_PORT )
			{
				DPFERR( "Cannot use the DPNSVR port in device addresses" );
				DPFERR( "This port is reserved for DPNSVR" );
				return( DPNERR_INVALIDDEVICEADDRESS );
			}
		}
	}

    if( FAILED( hResultCode = DN_ValidSecurityDesc(pdnSecurity) ) )
    {
        DPFERR(" Invalid reserved specified" );
        return( hResultCode );
    }

    if( FAILED( hResultCode = DN_ValidSecurityCredentials(pdnCredentials) ) )
    {
        DPFERR( "Invalid reserved2 specified" );
        return( hResultCode );
    }

    if( dwUserConnectDataSize > 0 &&
        (pvUserConnectData == NULL || !DNVALID_READPTR( pvUserConnectData, dwUserConnectDataSize ) ) )
    {
        DPFERR( "Invalid pointer specified for connect data" );
        return( DPNERR_INVALIDPOINTER );
    }

    if( pvUserConnectData != NULL && dwUserConnectDataSize == 0 )
    {
        DPFERR( "Non NULL connect data with datasize = 0 is invalid" );
        return( DPNERR_INVALIDPARAM );
    }

    if( phAsyncHandle != NULL &&
        !DNVALID_WRITEPTR( phAsyncHandle, sizeof(DPNHANDLE) ) )
    {
        DPFERR( "Invalid handle specified" );
        return( DPNERR_INVALIDPOINTER );
    }

    if( dwFlags & ~(DPNCONNECT_SYNC | DPNCONNECT_OKTOQUERYFORADDRESSING) )
    {
        DPFERR( "Invalid flags specified" );
        return( DPNERR_INVALIDFLAGS );
    }

    if( dwFlags & DPNCONNECT_SYNC )
    {
        if( phAsyncHandle != NULL )
        {
            DPFERR( "You cannot specify an async handle if op is synchronous" );
            return( DPNERR_INVALIDPARAM );
        }
    }
    else
    {
        if( phAsyncHandle == NULL )
        {
            DPFERR( "You MUST specify a valid async handle w/async ops" );
            return( DPNERR_INVALIDPARAM );
        }
    }
    return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateGetSendQueueInfo"

HRESULT DN_ValidateGetSendQueueInfo(PVOID pInterface,
									DWORD *const pdwNumMsgs,
									DWORD *const pdwNumBytes,
									const DWORD dwFlags)
{
	if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFERR("Invalid object specified " );
	    return( DPNERR_INVALIDOBJECT );
    }

	if( pdwNumMsgs != NULL &&
	    !DNVALID_WRITEPTR( pdwNumMsgs, sizeof( DWORD ) ) )
	{
	    DPFERR("Invalid num messages specified" );
	    return( DPNERR_INVALIDPOINTER );
	}

	if( pdwNumBytes != NULL &&
	    !DNVALID_WRITEPTR( pdwNumBytes, sizeof( DWORD ) ) )
	{
	    DPFERR("Invalid num bytes specified" );
	    return( DPNERR_INVALIDPOINTER );
	}

	if( pdwNumBytes == NULL && pdwNumMsgs == NULL )
	{
	    DPFERR("Must request at least one of num bytes and num messages" );
	    return( DPNERR_INVALIDPARAM );
	}

    if( dwFlags & ~(DPNGETSENDQUEUEINFO_PRIORITY_HIGH | DPNGETSENDQUEUEINFO_PRIORITY_LOW | DPNGETSENDQUEUEINFO_PRIORITY_NORMAL) )
    {
        DPFERR( "Invalid flags specified" );
        return( DPNERR_INVALIDFLAGS );
    }

    return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateGetApplicationDesc"

HRESULT DN_ValidateGetApplicationDesc(PVOID pInterface,
									  DPN_APPLICATION_DESC *const pAppDescBuffer,
									  DWORD *const pcbDataSize,
									  const DWORD dwFlags )
{
	if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFERR("Invalid object specified " );
	    return( DPNERR_INVALIDOBJECT );
    }

	if( pcbDataSize == NULL ||
	    !DNVALID_WRITEPTR( pcbDataSize, sizeof( DWORD ) ) )
	{
	    DPFERR("Invalid pointer specified for data size" );
	    return( DPNERR_INVALIDPOINTER );
	}

	if( *pcbDataSize > 0 &&
	    (pAppDescBuffer == NULL || !DNVALID_WRITEPTR( pAppDescBuffer, *pcbDataSize ) ) )
	{
	    DPFERR( "Invalid pointer specified for app description buffer" );
	    return( DPNERR_INVALIDPOINTER );
	}

	if( *pcbDataSize > 0 &&
	    pAppDescBuffer->dwSize != sizeof( DPN_APPLICATION_DESC ) )
	{
	    DPFERR("Invalid size specified" );
	    return(DPNERR_INVALIDPARAM);
	}

	if( dwFlags != 0 )
	{
	    DPFERR( "Invalid flags specified" );
	    return( DPNERR_INVALIDFLAGS );
	}
	
    return DPN_OK;

}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateSetApplicationDesc"

HRESULT DN_ValidateSetApplicationDesc(PVOID pInterface,
									  const DPN_APPLICATION_DESC *const pdnApplicationDesc,
									  const DWORD dwFlags)
{
    HRESULT hResultCode;

	if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFERR("Invalid object specified " );
	    return( DPNERR_INVALIDOBJECT );
    }

	if( FAILED( hResultCode = DN_ValidHostAppDesc(pdnApplicationDesc) ) )
	{
	    DPFX(DPFPREP, 0,"Invalid app desc specified hr=[0x%lx]", hResultCode );
	    return( hResultCode );
	}

	if( dwFlags != 0 )
	{
	    DPFERR( "Invalid flags specified" );
	    return( DPNERR_INVALIDFLAGS );
	}
	
    return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateSendParams"

HRESULT DN_ValidateSendParams(PVOID pv,
                              const DPN_BUFFER_DESC *const pBufferDesc,
							  const DWORD cBufferDesc,
                              const DWORD dwTimeOut,
							  void *const pvAsyncContext,
                              DPNHANDLE *const phAsyncHandle,
							  const DWORD dwFlags )
{
    HRESULT hResultCode;

	if( !IsValidDirectPlay8Object( pv ) )
    {
        DPFERR("Invalid object specified " );
	    return(DPNERR_INVALIDOBJECT);
    }

    if( FAILED( hResultCode = DN_ValidBufferDescs( pBufferDesc, cBufferDesc ) ) )
    {
        DPFERR( "Invalid buffer descs specified" );
        return( hResultCode );
    }

	if (pBufferDesc->dwBufferSize == 0)
	{
		DPFERR( "Cannot specify 0 data size" );
		return(DPNERR_INVALIDPARAM);
	}

    if( phAsyncHandle != NULL &&
        !DNVALID_WRITEPTR( phAsyncHandle, sizeof(DPNHANDLE) ) )
    {
        DPFERR("Invalid async handle specified" );
        return(DPNERR_INVALIDPOINTER);
    }

	if ((dwFlags & DPNSEND_NOCOPY) && (dwFlags & DPNSEND_NOCOMPLETE))
	{
	    DPFERR( "Cannot specify NOCOPY and NOCOMPLETE" );
		return(DPNERR_INVALIDFLAGS);
	}

	if ((dwFlags & DPNSEND_COMPLETEONPROCESS) && (dwFlags & DPNSEND_NOCOMPLETE))
	{
	    DPFERR("Cannot specify complete on process AND NOCOMPLETE" );
		return(DPNERR_INVALIDFLAGS);
	}

	if ((dwFlags & DPNSEND_COMPLETEONPROCESS) && !(dwFlags & DPNSEND_GUARANTEED))
	{
	    DPFERR("Cannot specify COMEPLETEONPROCESS without guaranteed" );
		return(DPNERR_INVALIDFLAGS);
	}

    // Guaranteed asyncs MUST get a complete
	if ((dwFlags & DPNSEND_GUARANTEED) && !(dwFlags & DPNSEND_SYNC) &&
	    (dwFlags & DPNSEND_NOCOMPLETE) )
	{
	    DPFERR("Async, guaranteed sends must get a completion" );
	    return(DPNERR_INVALIDFLAGS);
	}

	// Cannot specify high AND low priority
	if ((dwFlags & DPNSEND_PRIORITY_HIGH) && (dwFlags & DPNSEND_PRIORITY_LOW))
	{
		DPFERR("Cannot specify high AND low priority");
		return(DPNERR_INVALIDFLAGS);
	}

   	if( dwFlags & ~(DPNSEND_SYNC
					| DPNSEND_NOCOPY
					| DPNSEND_NOCOMPLETE
					| DPNSEND_COMPLETEONPROCESS
					| DPNSEND_GUARANTEED
					| DPNSEND_NONSEQUENTIAL
					| DPNSEND_NOLOOPBACK
					| DPNSEND_PRIORITY_LOW
					| DPNSEND_PRIORITY_HIGH) )
	{
	    DPFERR( "Invalid flags specified" );
	    DPF_RETURN( DPNERR_INVALIDFLAGS );
	}

    if( dwFlags & DPNSEND_SYNC )
    {
        if( phAsyncHandle != NULL )
        {
            DPFERR( "You cannot specify an async handle if op is synchronous" );
            return( DPNERR_INVALIDPARAM );
        }
    }
    else
    {
        if( phAsyncHandle == NULL )
        {
            DPFERR( "You MUST specify a valid async handle if op async and/or has a completion" );
            return( DPNERR_INVALIDPARAM );
        }
    }   	

   	return DPN_OK;

}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidBufferDescs"

HRESULT DN_ValidBufferDescs(const DPN_BUFFER_DESC * const pbBufferDesc,
							const DWORD cBufferDesc )
{
    if( cBufferDesc == 0 )
    {
        DPFERR( "You must specify at least one buffer desc" );
        return DPNERR_INVALIDPARAM;
    }

    if( cBufferDesc != 1 )
    {
        DPFERR( "Only one buffer at a time is currently supported" );
        return DPNERR_INVALIDPARAM;
    }

    if( pbBufferDesc == NULL ||
       !DNVALID_READPTR( pbBufferDesc, cBufferDesc*sizeof( DPN_BUFFER_DESC ) ) )
    {
        DPFX(DPFPREP,  0, "Invalid buffer for buffer description" );
        return DPNERR_INVALIDPOINTER;
    }

    if( pbBufferDesc->dwBufferSize > 0 &&
       (pbBufferDesc->pBufferData == NULL || !DNVALID_READPTR( pbBufferDesc->pBufferData, pbBufferDesc->dwBufferSize ) ) )
    {
        DPFX(DPFPREP,  0, "Invalid pBuffer Data" );
        return DPNERR_INVALIDPOINTER;
    }

    return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidConnectAppDesc"

HRESULT DN_ValidConnectAppDesc( const DPN_APPLICATION_DESC * const pdnAppDesc )
{
    if( pdnAppDesc == NULL ||
       !DNVALID_READPTR( pdnAppDesc, sizeof( DPN_APPLICATION_DESC ) ) )
    {
        DPFX(DPFPREP,  0, "Invalid pointer for app description" );
        return DPNERR_INVALIDPOINTER;
    }

    if( pdnAppDesc->dwSize != sizeof( DPN_APPLICATION_DESC ) )
    {
        DPFX(DPFPREP,  0, "Invalid size for app description" );
        return DPNERR_INVALIDPARAM;
    }

    if( pdnAppDesc->pwszSessionName != NULL &&
        !DNVALID_STRING_W( pdnAppDesc->pwszSessionName ) )
    {
        DPFX(DPFPREP,  0, "Invalid session name specified" );
        return DPNERR_INVALIDSTRING;
    }

    if( pdnAppDesc->pwszPassword != NULL &&
       !DNVALID_STRING_W( pdnAppDesc->pwszPassword ) )
    {
        DPFX(DPFPREP,  0, "Invalid session desc" );
        return DPNERR_INVALIDSTRING;
    }

    if( pdnAppDesc->dwReservedDataSize != 0 || pdnAppDesc->pvReservedData != NULL )
    {
        DPFX(DPFPREP,  0, "Invalid pointer for specified reserved data" );
        return DPNERR_INVALIDPARAM;
    }

	return DPN_OK;

}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidHostAppDesc"

HRESULT DN_ValidHostAppDesc( const DPN_APPLICATION_DESC * const pdnAppDesc )
{
    if( pdnAppDesc == NULL ||
       !DNVALID_READPTR( pdnAppDesc, sizeof( DPN_APPLICATION_DESC ) ) )
    {
        DPFX(DPFPREP,  0, "Invalid pointer for app description" );
        return DPNERR_INVALIDPOINTER;
    }

    if( pdnAppDesc->dwSize != sizeof( DPN_APPLICATION_DESC ) )
    {
        DPFX(DPFPREP,  0, "Invalid size for app description" );
        return DPNERR_INVALIDPARAM;
    }

    if( pdnAppDesc->dwFlags & ~(DPNSESSION_CLIENT_SERVER | DPNSESSION_MIGRATE_HOST | DPNSESSION_REQUIREPASSWORD | DPNSESSION_NODPNSVR) )
    {
        DPFX(DPFPREP,  0, "Invalid flag specified" );
        return DPNERR_INVALIDFLAGS;
    }

    if( (pdnAppDesc->dwFlags & DPNSESSION_CLIENT_SERVER) &&
       (pdnAppDesc->dwFlags & DPNSESSION_MIGRATE_HOST) )
    {
        DPFX(DPFPREP,  0, "Cannot have host migration with client/server" );
        return DPNERR_INVALIDPARAM;
    }

    if( pdnAppDesc->guidApplication == GUID_NULL )
    {
        DPFERR( "You must specify a valid GUID for your application GUID" );
        return DPNERR_INVALIDPARAM;
    }

    if( pdnAppDesc->pwszSessionName != NULL &&
       !DNVALID_STRING_W( pdnAppDesc->pwszSessionName ) )
    {
        DPFX(DPFPREP,  0, "Invalid session name" );
        return DPNERR_INVALIDSTRING;
    }

    if( pdnAppDesc->dwFlags & DPNSESSION_REQUIREPASSWORD )
    {
        if( pdnAppDesc->pwszPassword == NULL )
        {
            DPFERR( "Must specify a password w/the requirepassword flag." );
            return DPNERR_INVALIDPARAM;
        }

        if( !DNVALID_STRING_W( pdnAppDesc->pwszPassword ) )
        {
            DPFX(DPFPREP,  0, "Invalid password specified." );
            return DPNERR_INVALIDSTRING;
        }
    }
    else
    {
        if( pdnAppDesc->pwszPassword != NULL )
        {
            DPFERR( "Cannot specify a password without the requirepassword flag" );
            return DPNERR_INVALIDPARAM;
        }
    }



    if( pdnAppDesc->dwReservedDataSize != 0 || pdnAppDesc->pvReservedData != NULL )
    {
        DPFX(DPFPREP,  0, "Invalid pointer for specified reserved data" );
        return DPNERR_INVALIDPARAM;
    }

    if( pdnAppDesc->dwApplicationReservedDataSize != 0 &&
       !DNVALID_WRITEPTR( pdnAppDesc->pvApplicationReservedData, pdnAppDesc->dwApplicationReservedDataSize ) )
    {
        DPFX(DPFPREP,  0, "Invalid pointer for application reserved data" );
        return DPNERR_INVALIDPARAM;
    }

    return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidPlayerInfo"

HRESULT DN_ValidPlayerInfo(const DPN_PLAYER_INFO * const pdnPlayerInfo,
						   BOOL fSet )
{
   if( pdnPlayerInfo == NULL ||
       !DNVALID_READPTR( pdnPlayerInfo, sizeof( DPN_PLAYER_INFO ) ) )
    {
        DPFX(DPFPREP,  0, "Invalid pointer for player info" );
        return DPNERR_INVALIDPOINTER;
    }

    if( pdnPlayerInfo->dwSize != sizeof( DPN_PLAYER_INFO ) )
    {
        DPFX(DPFPREP,  0, "Invalid size for player info" );
        return DPNERR_INVALIDPARAM;
    }

    if( fSet )
    {
        if( pdnPlayerInfo->dwInfoFlags & ~(DPNINFO_NAME | DPNINFO_DATA) )
        {
            DPFERR("Invalid info flags specified" );
            return DPNERR_INVALIDFLAGS;
        }

        if( pdnPlayerInfo->dwInfoFlags & DPNINFO_NAME )
        {
            if( pdnPlayerInfo->pwszName != NULL && !DNVALID_STRING_W( pdnPlayerInfo->pwszName ) )
            {
                DPFERR("Invalid string specified for name" );
                return DPNERR_INVALIDSTRING;
            }
        }
        else
        {
            if( pdnPlayerInfo->pwszName != NULL )
            {
                DPFERR( "You must specify DPNINFO_NAME to set name" );
                return DPNERR_INVALIDSTRING;
            }
        }

        if( pdnPlayerInfo->dwInfoFlags & DPNINFO_DATA )
        {
            if( pdnPlayerInfo->dwDataSize > 0 &&
                (pdnPlayerInfo->pvData == NULL || !DNVALID_READPTR( pdnPlayerInfo->pvData, pdnPlayerInfo->dwDataSize )  ) )
            {
                DPFERR("Invalid pointer specified for data" );
                return DPNERR_INVALIDPOINTER;
            }
        }
        else
        {
            if( pdnPlayerInfo->pvData != NULL )
            {
                DPFERR("You must specify DPNINFO_DATA if you want to set data" );
                return DPNERR_INVALIDPARAM;
            }
        }

        if( pdnPlayerInfo->dwPlayerFlags != 0  )
        {
            DPFERR( "Invalid player flags specified" );
            return DPNERR_INVALIDFLAGS;
        }
    }

    return DPN_OK;

}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidGroupInfo"

HRESULT DN_ValidGroupInfo(const DPN_GROUP_INFO * const pdnGroupInfo,
						  BOOL fSet )
{
   if( pdnGroupInfo == NULL ||
       !DNVALID_READPTR( pdnGroupInfo, sizeof( DPN_GROUP_INFO ) ) )
    {
        DPFX(DPFPREP,  0, "Invalid pointer for group info" );
        return DPNERR_INVALIDPOINTER;
    }

    if( pdnGroupInfo->dwSize != sizeof( DPN_GROUP_INFO ) )
    {
        DPFX(DPFPREP,  0, "Invalid size for group info" );
        return DPNERR_INVALIDPARAM;
    }

    if( fSet )
    {
        if( pdnGroupInfo->dwInfoFlags & ~(DPNINFO_NAME | DPNINFO_DATA) )
        {
            DPFERR("Invalid info flags specified" );
            return DPNERR_INVALIDFLAGS;
        }

        if( pdnGroupInfo->dwInfoFlags & DPNINFO_NAME )
        {
            if( pdnGroupInfo->pwszName != NULL && !DNVALID_STRING_W( pdnGroupInfo->pwszName ) )
            {
                DPFERR("Invalid string specified for name" );
                return DPNERR_INVALIDSTRING;
            }
        }
        else
        {
            if( pdnGroupInfo->pwszName != NULL )
            {
                DPFERR( "You must specify DPNINFO_NAME to set name" );
                return DPNERR_INVALIDSTRING;
            }
        }

        if( pdnGroupInfo->dwInfoFlags & DPNINFO_DATA )
        {
            if( pdnGroupInfo->dwDataSize > 0 &&
                (pdnGroupInfo->pvData == NULL || !DNVALID_READPTR( pdnGroupInfo->pvData, pdnGroupInfo->dwDataSize )  ) )
            {
                DPFERR("Invalid pointer specified for data" );
                return DPNERR_INVALIDPOINTER;
            }
        }
        else
        {
            if( pdnGroupInfo->pvData != NULL )
            {
                DPFERR("You must specify DPNINFO_DATA if you want to set data" );
                return DPNERR_INVALIDPARAM;
            }
        }

        if( pdnGroupInfo->dwGroupFlags & ~(DPNGROUP_AUTODESTRUCT /* | DPNGROUP_MULTICAST */ ) )
        {
            DPFERR( "Invalid group flags specified" );
            return DPNERR_INVALIDFLAGS;
        }
    }

    return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidSecurityCredentials"

HRESULT DN_ValidSecurityCredentials( const DPN_SECURITY_CREDENTIALS * const pdnCredentials )
{
	if( pdnCredentials != NULL )
	{
		DPFERR( "Invalid value for reserved field" );
		return DPNERR_INVALIDPOINTER;
	}

    return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidSecurityDesc"

HRESULT DN_ValidSecurityDesc( const DPN_SECURITY_DESC * const pdnValidSecurityDesc )
{
	if( pdnValidSecurityDesc != NULL )
	{
		DPFERR( "Invalid value for reserved field" );
		return DPNERR_INVALIDPOINTER;
	}

    return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "IsValidDirectPlay8Object"

BOOL IsValidDirectPlay8Object( LPVOID lpvObject )
{
	INTERFACE_LIST *pIntList = (INTERFACE_LIST *) lpvObject;
	
	if( !DNVALID_READPTR( lpvObject, sizeof( INTERFACE_LIST ) ) )
	{
		DPFX(DPFPREP,  0, "Invalid object pointer" );
		return FALSE;
	}

	if( pIntList->lpVtbl != &DN_ClientVtbl &&
	   pIntList->lpVtbl != &DN_PeerVtbl &&
	   pIntList->lpVtbl != &DN_ServerVtbl &&
	   pIntList->lpVtbl != &DN_VoiceTbl &&
       pIntList->lpVtbl != &DN_ProtocolVtbl &&
       pIntList->lpVtbl != &SPMessagesVtbl
	   )
	{
		DPFX(DPFPREP,  0, "Invalid object - bad vtable" );
		return FALSE;
	}

	if( pIntList->iid != IID_IDirectPlay8Client &&
	   pIntList->iid != IID_IDirectPlay8Server &&
	   pIntList->iid != IID_IDirectPlay8Peer &&
       pIntList->iid != IID_IDirectPlay8Protocol &&
       pIntList->iid != IID_IDP8SPCallback )
	{
		DPFX(DPFPREP,  0, "Invalid object - bad iid" );
		return FALSE;
	}

	if( pIntList->pObject == NULL ||
	   !DNVALID_READPTR( pIntList->pObject, sizeof( OBJECT_DATA ) ) )
	{
		DPFX(DPFPREP,  0, "Invalid object" );
		return FALSE;
	}

	DIRECTNETOBJECT *pdn = (PDIRECTNETOBJECT) GET_OBJECT_FROM_INTERFACE( lpvObject );

	if( pdn == NULL ||
	   !DNVALID_READPTR( pdn, sizeof( DIRECTNETOBJECT ) ) )
	{
		DPFX(DPFPREP,  0, "Invalid object" );
		return FALSE;
	}

	return TRUE;

}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidSPCaps"

HRESULT DN_ValidSPCaps( const DPN_SP_CAPS * const pdnSPCaps )
{
    if( pdnSPCaps == NULL ||
       !DNVALID_READPTR( pdnSPCaps, sizeof( DPN_SP_CAPS ) ) )
    {
        DPFX(DPFPREP,  0, "Invalid pointer for SP caps" );
        return DPNERR_INVALIDPOINTER;
    }

    if( pdnSPCaps->dwSize != sizeof( DPN_SP_CAPS ) )
    {
        DPFX(DPFPREP,  0, "Invalid structure size" );
        return DPNERR_INVALIDPARAM;
    }

	if ( pdnSPCaps->dwNumThreads == 0 )
	{
		DPFX(DPFPREP,  0, "Invalid thread count!" );
		return DPNERR_INVALIDPARAM;
	}

	if ( pdnSPCaps->dwBuffersPerThread == 0 )
	{
		DPFX(DPFPREP,  0, "Invalid buffers per thread setting!" );
		return 	DPNERR_INVALIDPARAM;
	}

    return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidConnectionInfo"

HRESULT DN_ValidConnectionInfo( const DPN_CONNECTION_INFO * const pdnConnectionInfo )
{
    if( pdnConnectionInfo == NULL ||
       !DNVALID_READPTR( pdnConnectionInfo, sizeof( DPN_CONNECTION_INFO ) ) )
    {
        DPFX(DPFPREP,  0, "Invalid pointer for connection info" );
        return DPNERR_INVALIDPOINTER;
    }

    if( pdnConnectionInfo->dwSize != sizeof( DPN_CONNECTION_INFO ) &&
		pdnConnectionInfo->dwSize != sizeof( DPN_CONNECTION_INFO_INTERNAL ))
    {
        DPFX(DPFPREP,  0, "Invalid structure size" );
        return DPNERR_INVALIDPARAM;
    }

    return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidCaps"

HRESULT DN_ValidCaps( const DPN_CAPS * const pdnCaps )
{
    if( pdnCaps == NULL ||
       !DNVALID_READPTR( pdnCaps, sizeof( DPN_CAPS ) ) )
    {
        DPFX(DPFPREP,  0, "Invalid pointer for caps" );
        return DPNERR_INVALIDPOINTER;
    }

    if( pdnCaps->dwSize != sizeof( DPN_CAPS ) )
    {
        DPFX(DPFPREP,  0, "Invalid structure size" );
        return DPNERR_INVALIDPARAM;
    }

    return DPN_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\peer.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Peer.cpp
 *  Content:    DNET peer interface routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  07/21/99	mjn		Created
 *  12/23/99	mjn		Hand all NameTable update sends from Host to worker thread
 *	12/28/99	mjn		Disconnect handling happens when disconnect finishes instead of starts
 *	12/28/99	mjn		Moved Async Op stuff to Async.h
 *	01/04/00	mjn		Added code to allow outstanding ops to complete at host migration
 *	01/06/00	mjn		Moved NameTable stuff to NameTable.h
 *	01/11/00	mjn		Moved connect/disconnect stuff to Connect.h
 *	01/14/00	mjn		Added pvUserContext to Host API call
 *	01/16/00	mjn		Moved User callback stuff to User.h
 *	01/22/00	mjn		Implemented DestroyClient in API
 *	01/28/00	mjn		Implemented ReturnBuffer in API
 *	02/01/00	mjn		Implemented GetCaps and SetCaps in API
 *	02/01/00	mjn		Implement Player/Group context values
 *	02/15/00	mjn		Implement INFO flags in SetInfo and return context in GetInfo
 *	02/17/00	mjn		Implemented GetPlayerContext and GetGroupContext
 *  03/17/00    rmt     Added new caps functions
 *	04/04/00	mjn		Added TerminateSession to API
 *	04/05/00	mjn		Modified DestroyClient
 *	04/06/00	mjn		Added GetPeerAddress to API
 *				mjn		Added GetHostAddress to API
 *  04/17/00    rmt     Added more parameter validation
 *              rmt     Removed required for connection from Get/SetInfo / GetAddress
 *	04/19/00	mjn		SendTo API call accepts a range of DPN_BUFFER_DESCs and a count
 *	04/24/00	mjn		Updated Group and Info operations to use CAsyncOp's
 *	05/31/00	mjn		Added operation specific SYNC flags
 *	06/23/00	mjn		Removed dwPriority from SendTo() API call
 *	07/09/00	mjn		Cleaned up DN_SetPeerInfo()
 *  07/09/00	rmt		Bug #38323 - RegisterLobby needs a DPNHANDLE parameter.
 *  07/21/00    RichGr  IA64: Use %p format specifier for 32/64-bit pointers.
 *  08/03/00	rmt		Bug #41244 - Wrong return codes -- part 2
 *	09/13/00	mjn		Fixed return value from DN_GetPeerAddress() if peer not found
 *	10/11/00	mjn		Take locks for CNameTableEntry::PackInfo()
 *				mjn		Check deleted list in DN_GetPeerInfo()
 *	01/22/01	mjn		Check closing instead of disconnecting in DN_GetPeerInfo()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

typedef	STDMETHODIMP PeerQueryInterface( IDirectPlay8Peer *pInterface, REFIID riid, LPVOID *ppvObj );
typedef	STDMETHODIMP_(ULONG)	PeerAddRef( IDirectPlay8Peer *pInterface );
typedef	STDMETHODIMP_(ULONG)	PeerRelease( IDirectPlay8Peer *pInterface );
typedef	STDMETHODIMP PeerInitialize( IDirectPlay8Peer *pInterface, LPVOID const lpvUserContext, const PFNDPNMESSAGEHANDLER lpfn, const DWORD dwFlags );
typedef	STDMETHODIMP PeerEnumServiceProviders( IDirectPlay8Peer *pInterface,const GUID *const pguidServiceProvider,const GUID *const pguidApplication,DPN_SERVICE_PROVIDER_INFO *const pSPInfoBuffer,DWORD *const pcbEnumData,DWORD *const pcReturned,const DWORD dwFlags);
typedef	STDMETHODIMP PeerCancelAsyncOperation( IDirectPlay8Peer *pInterface,const DPNHANDLE hAsyncHandle, const DWORD dwFlags );
typedef STDMETHODIMP PeerConnect( IDirectPlay8Peer *pInterface,const DPN_APPLICATION_DESC *const pdnAppDesc,IDirectPlay8Address *const pHostAddr,IDirectPlay8Address *const pDeviceInfo,const DPN_SECURITY_DESC *const pdnSecurity,const DPN_SECURITY_CREDENTIALS *const pdnCredentials,const void *const pvUserConnectData,const DWORD dwUserConnectDataSize,void *const pvPlayerContext,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags);
typedef	STDMETHODIMP PeerGetSendQueueInfo( IDirectPlay8Peer *pInterface, const DPNID dpnid,DWORD *const lpdwNumMsgs, DWORD *const lpdwNumBytes, const DWORD dwFlags );
typedef	STDMETHODIMP PeerSendTo( IDirectPlay8Peer *pInterface, const DPNID dnid, const DPN_BUFFER_DESC *const prgBufferDesc,const DWORD cBufferDesc,const DWORD dwTimeOut, void *const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags);
typedef	STDMETHODIMP PeerGetApplicationDesc( IDirectPlay8Peer *pInterface,DPN_APPLICATION_DESC *const pAppDescBuffer,DWORD *const lpcbDataSize,const DWORD dwFlags );
typedef STDMETHODIMP PeerGetHostAddress( IDirectPlay8Peer *pInterface, IDirectPlay8Address **const prgpAddress, DWORD *const pcAddress,const DWORD dwFlags);
typedef	STDMETHODIMP PeerHost( IDirectPlay8Peer *pInterface,const DPN_APPLICATION_DESC *const pdnAppDesc,IDirectPlay8Address **const prgpDeviceInfo,const DWORD cDeviceInfo,const DPN_SECURITY_DESC *const pdnSecurity,const DPN_SECURITY_CREDENTIALS *const pdnCredentials,void *const pvPlayerContext,const DWORD dwFlags);
typedef	STDMETHODIMP PeerSetApplicationDesc( IDirectPlay8Peer *pInterface, const DPN_APPLICATION_DESC *const lpad, const DWORD dwFlags );
typedef	STDMETHODIMP PeerCreateGroup( IDirectPlay8Peer *pInterface, const DPN_GROUP_INFO *const pdpnGroupInfo,void *const pvGroupContext,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags);
typedef STDMETHODIMP PeerDestroyGroup( IDirectPlay8Peer *pInterface, const DPNID idGroup ,PVOID const pvUserContext,DPNHANDLE *const lpAsyncHandle,const DWORD dwFlags);
typedef STDMETHODIMP PeerAddClientToGroup( IDirectPlay8Peer *pInterface, const DPNID idGroup, const DPNID idClient ,PVOID const pvUserContext,DPNHANDLE *const lpAsyncHandle,const DWORD dwFlags);
typedef STDMETHODIMP PeerRemoveClientFromGroup( IDirectPlay8Peer *pInterface, const DPNID idGroup, const DPNID idClient,PVOID const pvUserContext,DPNHANDLE *const lpAsyncHandle,const DWORD dwFlags);
typedef STDMETHODIMP PeerSetGroupInfo(IDirectPlay8Peer *pInterface, const DPNID dpnid,DPN_GROUP_INFO *const pdpnGroupInfo,PVOID const pvAsyncContext,DPNHANDLE *const phAsyncHandle, const DWORD dwFlags);
typedef STDMETHODIMP PeerGetGroupInfo(IDirectPlay8Peer *pInterface, const DPNID dpnid,DPN_GROUP_INFO *const pdpnGroupInfo,DWORD *const pdwSize,const DWORD dwFlags);
typedef STDMETHODIMP PeerEnumClientsAndGroups( IDirectPlay8Peer *pInterface, DPNID *const lprgdnid, DWORD *const lpcdnid, const DWORD dwFlags );
typedef	STDMETHODIMP PeerEnumGroupMembers( IDirectPlay8Peer *pInterface, const DPNID dnid, DPNID *const lprgdnid, DWORD *const lpcdnid, const DWORD dwFlags );
typedef	STDMETHODIMP PeerClose( IDirectPlay8Peer *pInterface,const DWORD dwFlags);
typedef	STDMETHODIMP PeerEnumHosts( IDirectPlay8Peer *pInterface,PDPN_APPLICATION_DESC const pApplicationDesc,IDirectPlay8Address *const pAddrHost,IDirectPlay8Address *const pDeviceInfo,PVOID const pUserEnumData,const DWORD dwUserEnumDataSize,const DWORD dwRetryCount,const DWORD dwRetryInterval,const DWORD dwTimeOut,PVOID const pvUserContext,DPNHANDLE *const pAsyncHandle,const DWORD dwFlags);
typedef STDMETHODIMP PeerDestroyClient( IDirectPlay8Peer *pInterface,const DPNID dnid,const void *const pvDestroyData,const DWORD dwDestroyDataSize,const DWORD dwFlags);
typedef STDMETHODIMP PeerReturnBuffer( IDirectPlay8Peer *pInterface, const DPNHANDLE hBufferHandle,const DWORD dwFlags);
typedef STDMETHODIMP PeerGetCaps(IDirectPlay8Peer *pInterface,DPN_CAPS *const pdnCaps,const DWORD dwFlags);
typedef STDMETHODIMP PeerSetCaps(IDirectPlay8Peer *pInterface,const DPN_CAPS *const pdnCaps,const DWORD dwFlags);
typedef STDMETHODIMP PeerGetPlayerContext(IDirectPlay8Peer *pInterface,const DPNID dpnid,PVOID *const ppvPlayerContext,const DWORD dwFlags);
typedef STDMETHODIMP PeerGetGroupContext(IDirectPlay8Peer *pInterface,const DPNID dpnid,PVOID *const ppvGroupContext,const DWORD dwFlags);
typedef STDMETHODIMP PeerSetSPCaps(IDirectPlay8Peer *pInterface,const GUID * const pguidSP, const DPN_SP_CAPS *const pdpspCaps, const DWORD dwFlags );
typedef STDMETHODIMP PeerGetSPCaps(IDirectPlay8Peer *pInterface,const GUID * const pguidSP, DPN_SP_CAPS *const pdpspCaps,const DWORD dwFlags);
typedef STDMETHODIMP PeerGetConnectionInfo(IDirectPlay8Peer *pInterface,const DPNID dpnid, DPN_CONNECTION_INFO *const pdpConnectionInfo,const DWORD dwFlags);
typedef STDMETHODIMP PeerRegisterLobby(IDirectPlay8Peer *pInterface,const DPNHANDLE dpnHandle,IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags);
typedef STDMETHODIMP PeerTerminateSession(IDirectPlay8Peer *pInterface,void *const pvTerminateData,const DWORD dwTerminateDataSize,const DWORD dwFlags);
typedef STDMETHODIMP PeerDumpNameTable(IDirectPlay8Peer *pInterface,char *const Buffer);

IDirectPlay8PeerVtbl DN_PeerVtbl =
{
	(PeerQueryInterface*)			DN_QueryInterface,
	(PeerAddRef*)					DN_AddRef,
	(PeerRelease*)					DN_Release,
	(PeerInitialize*)				DN_Initialize,
	(PeerEnumServiceProviders*)		DN_EnumServiceProviders,
	(PeerCancelAsyncOperation*)		DN_CancelAsyncOperation,
	(PeerConnect*)					DN_Connect,
	(PeerSendTo*)					DN_SendTo,
	(PeerGetSendQueueInfo*)			DN_GetSendQueueInfo,
	(PeerHost*)						DN_Host,
	(PeerGetApplicationDesc*)		DN_GetApplicationDesc,
	(PeerSetApplicationDesc*)		DN_SetApplicationDesc,
	(PeerCreateGroup*)				DN_CreateGroup,
	(PeerDestroyGroup*)				DN_DestroyGroup,
	(PeerAddClientToGroup*)			DN_AddClientToGroup,
	(PeerRemoveClientFromGroup*)	DN_RemoveClientFromGroup,
	(PeerSetGroupInfo*)				DN_SetGroupInfo,
	(PeerGetGroupInfo*)				DN_GetGroupInfo,
	(PeerEnumClientsAndGroups*)		DN_EnumClientsAndGroups,
	(PeerEnumGroupMembers*)			DN_EnumGroupMembers,
									DN_SetPeerInfo,
									DN_GetPeerInfo,
									DN_GetPeerAddress,
	(PeerGetHostAddress*)			DN_GetHostAddress,
	(PeerClose*)					DN_Close,
	(PeerEnumHosts*)				DN_EnumHosts,
	(PeerDestroyClient*)			DN_DestroyPlayer,
	(PeerReturnBuffer*)				DN_ReturnBuffer,
	(PeerGetPlayerContext*)			DN_GetPlayerContext,
	(PeerGetGroupContext*)			DN_GetGroupContext,
	(PeerGetCaps*)					DN_GetCaps,
	(PeerSetCaps*)					DN_SetCaps,
    (PeerSetSPCaps*)                DN_SetSPCaps,
    (PeerGetSPCaps*)                DN_GetSPCaps,
    (PeerGetConnectionInfo*)        DN_GetConnectionInfo,
	(PeerRegisterLobby*)			DN_RegisterLobby,
	(PeerTerminateSession*)			DN_TerminateSession,
	(PeerDumpNameTable*)			DN_DumpNameTable
};

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//	DN_SetPeerInfo
//
//	Set the info for the local player (peer) and propagate to other players

#undef DPF_MODNAME
#define DPF_MODNAME "DN_SetPeerInfo"

STDMETHODIMP DN_SetPeerInfo( IDirectPlay8Peer *pInterface,
							  const DPN_PLAYER_INFO *const pdpnPlayerInfo,
							  PVOID const pvAsyncContext,
							  DPNHANDLE *const phAsyncHandle,
							  const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject;
	HRESULT				hResultCode;
	DPNHANDLE			hAsyncOp;
	PWSTR				pwszName;
	DWORD				dwNameSize;
	PVOID				pvData;
	DWORD				dwDataSize;
	CNameTableEntry		*pLocalPlayer;
	BOOL				fConnected;

	DPFX(DPFPREP, 2,"Parameters: pInterface [0x%p], pdpnPlayerInfo [0x%p], pvAsyncContext [0x%p], phAsyncHandle [%p], dwFlags [0x%lx]",
			pInterface,pdpnPlayerInfo,pvAsyncContext,phAsyncHandle,dwFlags);
    	
	TRY
	{
    	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
    	DNASSERT(pdnObject != NULL);

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    	{
        	if( FAILED( hResultCode = DN_ValidateSetPeerInfo( pInterface , pdpnPlayerInfo, pvAsyncContext, phAsyncHandle, dwFlags ) ) )
        	{
        	    DPFX(DPFPREP,  0, "Error validating get peer info hr=[0x%lx]", hResultCode );
        	    DPF_RETURN( hResultCode );
        	}
    	}

        // Check to ensure message handler registered
    	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    	{
    		DPFERR( "Object is not initialized" );
    		DPF_RETURN(DPNERR_UNINITIALIZED);
    	}	
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}

	pLocalPlayer = NULL;

	if ((pdpnPlayerInfo->dwInfoFlags & DPNINFO_NAME) && (pdpnPlayerInfo->pwszName))
	{
		pwszName = pdpnPlayerInfo->pwszName;
		dwNameSize = (wcslen(pwszName) + 1) * sizeof(WCHAR);
	}
	else
	{
		pwszName = NULL;
		dwNameSize = 0;
	}
	if ((pdpnPlayerInfo->dwInfoFlags & DPNINFO_DATA) && (pdpnPlayerInfo->pvData) && (pdpnPlayerInfo->dwDataSize))
	{
		pvData = pdpnPlayerInfo->pvData;
		dwDataSize = pdpnPlayerInfo->dwDataSize;
	}
	else
	{
		pvData = NULL;
		dwDataSize = 0;
	}

	//
	//	If we are connected, we will update our entry if we are the Host, or request the Host to update us.
	//	Otherwise, we will just update the DefaultPlayer.
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED)
	{
		fConnected = TRUE;
	}
	else
	{
		fConnected = FALSE;
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
	if (fConnected)
	{
		if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
		{
			DPFERR( "Could not get local player reference" );
			DisplayDNError(0,hResultCode);
			goto Failure;
		}

		if (pLocalPlayer->IsHost())
		{
			DPFX(DPFPREP, 3,"Host is updating peer info");

			hResultCode = DNHostUpdateInfo(	pdnObject,
											pLocalPlayer->GetDPNID(),
											pwszName,
											dwNameSize,
											pvData,
											dwDataSize,
											pdpnPlayerInfo->dwInfoFlags,
											pvAsyncContext,
											pLocalPlayer->GetDPNID(),
											0,
											&hAsyncOp,
											dwFlags );
			if ((hResultCode != DPN_OK) && (hResultCode != DPNERR_PENDING))
			{
				DPFERR("Could not request host to update group");
			}
			else
			{
				if (!(dwFlags & DPNSETPEERINFO_SYNC))
				{
					DPFX(DPFPREP, 3,"Async Handle [0x%lx]",hAsyncOp);
					*phAsyncHandle = hAsyncOp;

					//
					//	Release Async HANDLE since this operation has already completed (!)
					//
					pdnObject->HandleTable.Destroy( hAsyncOp );
					hAsyncOp = 0;
				}
			}
		}
		else
		{
			DPFX(DPFPREP, 3,"Request host to update group info");

			hResultCode = DNRequestUpdateInfo(	pdnObject,
												pLocalPlayer->GetDPNID(),
												pwszName,
												dwNameSize,
												pvData,
												dwDataSize,
												pdpnPlayerInfo->dwInfoFlags,
												pvAsyncContext,
												&hAsyncOp,
												dwFlags);
			if (hResultCode != DPN_OK && hResultCode != DPNERR_PENDING)
			{
				DPFERR("Could not request host to update group info");
			}
			else
			{
				if (!(dwFlags & DPNSETPEERINFO_SYNC))
				{
					DPFX(DPFPREP, 3,"Async Handle [0x%lx]",hAsyncOp);
					*phAsyncHandle = hAsyncOp;
				}
			}
		}

		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	else
	{
		DNASSERT(pdnObject->NameTable.GetDefaultPlayer() != NULL);

		// This function takes the lock internally
		pdnObject->NameTable.GetDefaultPlayer()->UpdateEntryInfo(pwszName,dwNameSize,pvData,dwDataSize,pdpnPlayerInfo->dwInfoFlags, FALSE);

		hResultCode = DPN_OK;
	}

Exit:
	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	goto Exit;
}


//	DN_GetPeerInfo
//
//	Retrieve peer info from the local nametable.

#undef DPF_MODNAME
#define DPF_MODNAME "DN_GetPeerInfo"

STDMETHODIMP DN_GetPeerInfo(IDirectPlay8Peer *pInterface,
							const DPNID dpnid,
							DPN_PLAYER_INFO *const pdpnPlayerInfo,
							DWORD *const pdwSize,
							const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject;
	CNameTableEntry		*pNTEntry;
	HRESULT				hResultCode;
	CPackedBuffer		packedBuffer;

	DPFX(DPFPREP, 2,"Parameters: dpnid [0x%lx], pdpnPlayerInfo [0x%p], dwFlags [0x%lx]",
			dpnid,pdpnPlayerInfo,dwFlags);

	TRY
	{
    	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
    	DNASSERT(pdnObject != NULL);

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    	{
        	if( FAILED( hResultCode = DN_ValidateGetPeerInfo( pInterface , dpnid, pdpnPlayerInfo, pdwSize, dwFlags ) ) )
        	{
        	    DPFX(DPFPREP,  0, "Error validating get peer info hr=[0x%lx]", hResultCode );
        	    DPF_RETURN( hResultCode );
        	}
    	}

        // Check to ensure message handler registered
    	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    	{
    		DPFERR( "Object is not initialized" );
    		DPF_RETURN(DPNERR_UNINITIALIZED);
    	}	

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    	{
    	    DPFERR("Object is connecting / starting to host" );
    	    DPF_RETURN(DPNERR_CONNECTING);
    	}

    	if ( !(pdnObject->dwFlags & (DN_OBJECT_FLAG_CONNECTED | DN_OBJECT_FLAG_CLOSING | DN_OBJECT_FLAG_DISCONNECTING) ) )
    	{
    	    DPFERR("You must be connected / disconnecting to use this function" );
    	    DPF_RETURN(DPNERR_NOCONNECTION);
    	}	    	
	
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}

	pNTEntry = NULL;

	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnid,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not retrieve name table entry");
		DisplayDNError(0,hResultCode);

		//
		//	Try deleted list
		//
		if ((hResultCode = pdnObject->NameTable.FindDeletedEntry(dpnid,&pNTEntry)) != DPN_OK)
		{
			DPFERR("Could not find player in deleted list either");
			DisplayDNError(0,hResultCode);
			hResultCode = DPNERR_INVALIDPLAYER;
			goto Failure;
		}
	}
	packedBuffer.Initialize(pdpnPlayerInfo,*pdwSize);

	pNTEntry->Lock();
	if (pNTEntry->IsGroup())
	{
	    DPFERR( "Specified ID is invalid" );
		pNTEntry->Unlock();
		hResultCode = DPNERR_INVALIDPLAYER;
		goto Failure;
	}

	hResultCode = pNTEntry->PackInfo(&packedBuffer);

	pNTEntry->Unlock();
	pNTEntry->Release();
	pNTEntry = NULL;

	if ((hResultCode == DPN_OK) || (hResultCode == DPNERR_BUFFERTOOSMALL))
	{
		*pdwSize = packedBuffer.GetSizeRequired();
	}

Exit:
	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_GetPeerAddress"

STDMETHODIMP DN_GetPeerAddress(IDirectPlay8Peer *pInterface,
							   const DPNID dpnid,
							   IDirectPlay8Address **const ppAddress,
							   const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject;
	CNameTableEntry		*pNTEntry;
	IDirectPlay8Address	*pAddress;
	HRESULT				hResultCode;

	DPFX(DPFPREP, 2,"Parameters : pInterface [0x%p], dpnid [0x%lx], ppAddress [0x%p], dwFlags [0x%lx]",
		pInterface,dpnid,ppAddress,dwFlags);

	TRY
	{
    	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
    	DNASSERT(pdnObject != NULL);

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    	{
        	if( FAILED( hResultCode = DN_ValidateGetPeerAddress( pInterface , dpnid, ppAddress, dwFlags ) ) )
        	{
        	    DPFX(DPFPREP,  0, "Error validating get peer address info hr=[0x%lx]", hResultCode );
        	    DPF_RETURN( hResultCode );
        	}
    	}

        // Check to ensure message handler registered
    	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    	{
    		DPFERR( "Object is not initialized" );
    		DPF_RETURN(DPNERR_UNINITIALIZED);
    	}	

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    	{
    	    DPFERR("Object is connecting / starting to host" );
    	    DPF_RETURN(DPNERR_CONNECTING);
    	}

    	if ( !(pdnObject->dwFlags & (DN_OBJECT_FLAG_CONNECTED | DN_OBJECT_FLAG_CLOSING | DN_OBJECT_FLAG_DISCONNECTING) ) )
    	{
    	    DPFERR("You must be connected / disconnecting to use this function" );
    	    DPF_RETURN(DPNERR_NOCONNECTION);
    	}	    	
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}

	pNTEntry = NULL;
	pAddress = NULL;

	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnid,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not find NameTableEntry");
		DisplayDNError(0,hResultCode);
		hResultCode = DPNERR_INVALIDPLAYER;
		goto Failure;
	}

	if ((pNTEntry->GetAddress() == NULL) || (pNTEntry->IsGroup()) || !pNTEntry->IsAvailable())
	{
	    DPFERR( "Invalid ID specified.  Not a player" );
		hResultCode = DPNERR_INVALIDPLAYER;
		goto Failure;
	}

	hResultCode = pNTEntry->GetAddress()->lpVtbl->Duplicate(pNTEntry->GetAddress(),ppAddress);

	pNTEntry->Release();
	pNTEntry = NULL;

Exit:
	DPF_RETURN(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}

	goto Exit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\paramval.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       paramval.h
 *  Content:    DirectPlat8 Parameter Validation helper routines
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  02/28/00    rmt     Created
 *  04/17/00    rmt     More param validation
 *	04/19/00	mjn		Changed DN_RemoveClientFromGroup to DN_ValidateRemoveClientFromGroup (wrong function name)
 *  08/03/00	rmt		Bug #41244 - Wrong return codes -- part 2  
 *	08/04/00	mjn		Added dwFlags to DN_ValidateGetConnectionInfoHelper()
 *
 ***************************************************************************/
#ifndef __PARAMVAL_H
#define __PARAMVAL_H

#define DN_CHECK_LOCALHOST( x ) (x->NameTable.GetLocalPlayer() == x->NameTable.GetHostPlayer())

extern BOOL IsValidDirectPlay8Object( LPVOID lpvObject );

extern HRESULT DN_ValidateDestroyPlayer(PVOID pInterface,
							  const DPNID dnid,
							  const void *const pvDestroyData,
							  const DWORD dwDestroyDataSize,
							  const DWORD dwFlags);

extern HRESULT DN_ValidateReturnBuffer(PVOID pInterface,
							 const DPNHANDLE hBufferHandle,
							 const DWORD dwFlags);

extern HRESULT DN_ValidateGetPlayerContext(PVOID pInterface,
								 const DPNID dpnid,
								 PVOID *const ppvPlayerContext,
								 const DWORD dwFlags);

extern HRESULT DN_ValidateGetGroupContext(PVOID pInterface,
								const DPNID dpnid,
								PVOID *const ppvGroupContext,
								const DWORD dwFlags);

extern HRESULT DN_ValidateRegisterLobby(PVOID pInterface,
							  const DPNHANDLE dpnhLobbyConnection, 	
							  IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,
							  const DWORD dwFlags);

extern HRESULT DN_ValidateTerminateSession(PVOID pInterface,
								 void *const pvTerminateData,
								 const DWORD dwTerminateDataSize,
								 const DWORD dwFlags);

extern HRESULT DN_ValidateGetHostAddress(PVOID pInterface,
							   IDirectPlay8Address **const prgpAddress,
							   DWORD *const pcAddress,
							   const DWORD dwFlags);


extern HRESULT DN_ValidateGetClientAddress(IDirectPlay8Server *pInterface,
								 const DPNID dpnid,
								 IDirectPlay8Address **const ppAddress,
								 const DWORD dwFlags);

extern HRESULT DN_ValidateGetClientInfo(IDirectPlay8Server *pInterface,
							  const DPNID dpnid,
							  DPN_PLAYER_INFO *const pdpnPlayerInfo,
							  DWORD *const pdwSize,
							  const DWORD dwFlags);

extern HRESULT DN_ValidateSetServerInfo(IDirectPlay8Server *pInterface,
							  const DPN_PLAYER_INFO *const pdpnPlayerInfo,
							  PVOID const pvAsyncContext,
							  DPNHANDLE *const phAsyncHandle,
							  const DWORD dwFlags);

extern HRESULT DN_ValidateSetPeerInfo( IDirectPlay8Peer *pInterface,
							  const DPN_PLAYER_INFO *const pdpnPlayerInfo,
							  PVOID const pvAsyncContext,
							  DPNHANDLE *const phAsyncHandle,
							  const DWORD dwFlags);

extern HRESULT DN_ValidateGetPeerInfo(IDirectPlay8Peer *pInterface,
							const DPNID dpnid,
							DPN_PLAYER_INFO *const pdpnPlayerInfo,
							DWORD *const pdwSize,
							const DWORD dwFlags);

extern HRESULT DN_ValidateGetPeerAddress(IDirectPlay8Peer *pInterface,
										 const DPNID dpnid,
										 IDirectPlay8Address **const ppAddress,
										 const DWORD dwFlags);

extern HRESULT DN_ValidateGetServerAddress(IDirectPlay8Client *pInterface,
										   IDirectPlay8Address **const ppAddress,
										   const DWORD dwFlags);

extern HRESULT DN_ValidateGetHostSendQueueInfo(IDirectPlay8Client *pInterface,
									 DWORD *const pdwNumMsgs,
									 DWORD *const pdwNumBytes,
									 const DWORD dwFlags );

extern HRESULT DN_ValidateGetServerInfo(IDirectPlay8Client *pInterface,
							  DPN_PLAYER_INFO *const pdpnPlayerInfo,
							  DWORD *const pdwSize,
							  const DWORD dwFlags);

extern HRESULT  DN_ValidateSetClientInfo(IDirectPlay8Client *pInterface,
							  const DPN_PLAYER_INFO *const pdpnPlayerInfo,
							  const PVOID pvAsyncContext,
							  DPNHANDLE *const phAsyncHandle,
							  const DWORD dwFlags);

extern HRESULT DN_ValidateGetConnectionInfoHelper(PVOID pv,
												  const DPNID dpnid,
												  DPN_CONNECTION_INFO *const pdpConnectionInfo,
												  BOOL fServerPlayer,
												  const DWORD dwFlags);

extern HRESULT DN_ValidateSetCaps(PVOID pv,
						const DPN_CAPS *const pdnCaps,
						const DWORD dwFlags);

extern HRESULT DN_ValidateGetCaps(PVOID pv,
								  DPN_CAPS *const pdnCaps,
								  const DWORD dwFlags);

extern HRESULT DN_ValidateGetSPCaps(PVOID pv,
									const GUID * const pguidSP,
									DPN_SP_CAPS *const pdnSPCaps,
									const DWORD dwFlags);

extern HRESULT DN_ValidateSetSPCaps(PVOID pv,
									const GUID * const pguidSP,
									const DPN_SP_CAPS *const pdnSPCaps,
									const DWORD dwFlags);

extern HRESULT DN_ValidateEnumHosts( PVOID pv,
						   DPN_APPLICATION_DESC *const pApplicationDesc,
                           IDirectPlay8Address *const pAddrHost,
						   IDirectPlay8Address *const pDeviceInfo,
						   PVOID const pUserEnumData,
						   const DWORD dwUserEnumDataSize,
						   const DWORD dwRetryCount,
						   const DWORD dwRetryInterval,
						   const DWORD dwTimeOut,
						   PVOID const pvAsyncContext,
						   DPNHANDLE *const pAsyncHandle,
						   const DWORD dwFlags );

HRESULT DN_ValidateRemoveClientFromGroup(PVOID pInterface,
									  const DPNID dpnidGroup,
									  const DPNID dpnidClient,
									  PVOID const pvAsyncContext,
									  DPNHANDLE *const phAsyncHandle,
									  const DWORD dwFlags);						

extern HRESULT DN_ValidateEnumGroupMembers(PVOID pInterface,
								 const DPNID dpnid,
								 DPNID *const prgdpnid,
								 DWORD *const pcdpnid,
								 const DWORD dwFlags);

extern HRESULT DN_ValidateEnumClientsAndGroups(PVOID pInterface,
									 DPNID *const prgdpnid,
									 DWORD *const pcdpnid,
									 const DWORD dwFlags);

extern HRESULT DN_ValidateGetGroupInfo(PVOID pv,
							 const DPNID dpnid,
							 DPN_GROUP_INFO *const pdpnGroupInfo,
							 DWORD *const pdwSize,
							 const DWORD dwFlags);

extern HRESULT DN_ValidateSetGroupInfo( PVOID pv,
							  const DPNID dpnid,
							  DPN_GROUP_INFO *const pdpnGroupInfo,
							  PVOID const pvAsyncContext,
							  DPNHANDLE *const phAsyncHandle,
							  const DWORD dwFlags);

extern HRESULT DN_ValidateAddClientToGroup(PVOID pInterface,
								 const DPNID dpnidGroup,
								 const DPNID dpnidClient,
								 PVOID const pvAsyncContext,
								 DPNHANDLE *const phAsyncHandle,
								 const DWORD dwFlags);

extern HRESULT DN_ValidateRemoveClientFromGroup(PVOID pInterface,
									  const DPNID dpnidGroup,
									  const DPNID dpnidClient,
									  PVOID const pvAsyncContext,
									  DPNHANDLE *const phAsyncHandle,
									  const DWORD dwFlags);

extern HRESULT DN_ValidateDestroyGroup(PVOID pInterface,
							 const DPNID dpnidGroup,
							 PVOID const pvAsyncContext,
							 DPNHANDLE *const phAsyncHandle,
							 const DWORD dwFlags);

extern HRESULT DN_ValidateCreateGroup(PVOID pInterface,
							const DPN_GROUP_INFO *const pdpnGroupInfo,
							void *const pvGroupContext,
							void *const pvAsyncContext,
							DPNHANDLE *const phAsyncHandle,
							const DWORD dwFlags);

extern HRESULT DN_ValidateHost( PVOID pInterface, const DPN_APPLICATION_DESC *const pdnAppDesc,
                        IDirectPlay8Address **const prgpDeviceInfo,const DWORD cDeviceInfo,
  					    const DPN_SECURITY_DESC *const pdnSecurity,
  					    const DPN_SECURITY_CREDENTIALS *const pdnCredentials,
					    void *const pvPlayerContext, const DWORD dwFlags);

extern HRESULT DN_ValidateEnumServiceProviders( PVOID pInterface,
									  const GUID *const pguidServiceProvider,
									  const GUID *const pguidApplication,
									  DPN_SERVICE_PROVIDER_INFO *const pSPInfoBuffer,
									  DWORD *const pcbEnumData,
									  DWORD *const pcReturned,
									  const DWORD dwFlags );

extern HRESULT DN_ValidateCancelAsyncOperation(PVOID pvInterface,
									 const DPNHANDLE hAsyncOp,
									 const DWORD dwFlags );

extern HRESULT DN_ValidateConnect( PVOID pInterface, const DPN_APPLICATION_DESC *const pdnAppDesc, IDirectPlay8Address *const pHostAddr,
            					   IDirectPlay8Address *const pDeviceInfo, const DPN_SECURITY_DESC *const pdnSecurity,
  						           const DPN_SECURITY_CREDENTIALS *const pdnCredentials, const void *const pvUserConnectData,
                                   const DWORD dwUserConnectDataSize, void *const pvPlayerContext,
          						   void *const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags);

extern HRESULT DN_ValidateGetSendQueueInfo(PVOID pInterface, DWORD *const pdwNumMsgs, DWORD *const pdwNumBytes,const DWORD dwFlags);

extern HRESULT DN_ValidateSetApplicationDesc( PVOID pInterface, const DPN_APPLICATION_DESC *const pdnApplicationDesc, const DWORD dwFlags);

extern HRESULT DN_ValidateGetApplicationDesc( PVOID pInterface, DPN_APPLICATION_DESC *const pAppDescBuffer, DWORD *const pcbDataSize, const DWORD dwFlags );

extern HRESULT DN_ValidateSendParams( PVOID pv, const DPN_BUFFER_DESC *const pBufferDesc, const DWORD cBufferDesc, const DWORD dwTimeOut,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags);

extern HRESULT DN_ValidBufferDescs( const DPN_BUFFER_DESC * const pbBufferDesc, const DWORD cBufferCount );

extern HRESULT DN_ValidConnectAppDesc( const DPN_APPLICATION_DESC * const pdnAppDesc );

extern HRESULT DN_ValidHostAppDesc( const DPN_APPLICATION_DESC * const pdnAppDesc );

extern HRESULT DN_ValidPlayerInfo( const DPN_PLAYER_INFO * const pdnPlayerInfo, BOOL fSet);

extern HRESULT DN_ValidGroupInfo( const DPN_GROUP_INFO * const pdnGroupInfo, BOOL fSet );

extern HRESULT DN_ValidSecurityCredentials( const DPN_SECURITY_CREDENTIALS * const pdnCredentials );

extern HRESULT DN_ValidSecurityDesc( const DPN_SECURITY_DESC * const pdnValidSecurityDesc );

extern HRESULT DN_ValidSPCaps( const DPN_SP_CAPS * const pdnSPCaps );

extern HRESULT DN_ValidConnectionInfo( const PDPN_CONNECTION_INFO * const pdnConnectionInfo );

extern HRESULT DN_ValidCaps( const DPN_CAPS * const pdnCaps );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\queuedmsg.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       QueuedMsg.cpp
 *  Content:    Queued Message Objects
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  07/31/00	mjn		Created
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************

#undef DPF_MODNAME
#define DPF_MODNAME "CQueuedMsg::SetAsyncOp"

void CQueuedMsg::SetAsyncOp(CAsyncOp *const pAsyncOp)
{
	if (pAsyncOp)
	{
		pAsyncOp->AddRef();
	}
	m_pAsyncOp = pAsyncOp;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\protocol.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Protocol.h
 *  Content:    Direct Net Protocol interface header file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/01/00	mjn		Created
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__PROTOCOL_H__
#define	__PROTOCOL_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//
// VTable for peer interface
//
extern IDirectPlay8ProtocolVtbl DN_ProtocolVtbl;

//**********************************************************************
// Function prototypes
//**********************************************************************

//
// DirectNet - IDirectPlay8Protocol
//
STDMETHODIMP DN_ProtocolInitialize(IDirectPlay8Protocol *pInterface,PDN_PROTOCOL_INTERFACE_VTBL pfVTbl);
STDMETHODIMP DN_ProtocolAddSP(IDirectPlay8Protocol *pInterface, IDP8ServiceProvider *const pISP);
STDMETHODIMP DN_ProtocolConnect(IDirectPlay8Protocol *pInterface, IDirectPlay8Address *const pLocal_Address, IDirectPlay8Address *const pRemote_Address, DWORD Timeout, ULONG Flags, PVOID Context, PHANDLE Handle);
STDMETHODIMP DN_ProtocolListen(IDirectPlay8Protocol *pInterface, IDirectPlay8Address *const pAddress, ULONG Flags, PVOID Context, PHANDLE Handle);
STDMETHODIMP DN_ProtocolSendData(IDirectPlay8Protocol *pInterface, HANDLE Dest, UINT BufCount, PBUFFERDESC Buffers, UINT Priority, UINT Timeout, ULONG Flags, PVOID Context, PHANDLE Handle);
STDMETHODIMP DN_ProtocolDisconnect(IDirectPlay8Protocol *pInterface, HANDLE hEndPoint, PVOID Context, PHANDLE Handle);
STDMETHODIMP DN_ProtocolAbort(IDirectPlay8Protocol *pInterface, HANDLE hEndPoint);
STDMETHODIMP DN_ProtocolCancel(IDirectPlay8Protocol *pInterface, HANDLE hHandle);
STDMETHODIMP DN_ProtocolTerminate(IDirectPlay8Protocol *pInterface);
STDMETHODIMP DN_ProtocolDebug(IDirectPlay8Protocol *pInterface, UINT Opcode, HANDLE hEndPoint, PVOID Buffer);
STDMETHODIMP DN_ProtocolEnumAdapters(IDirectPlay8Protocol *pInterface, PVOID pData);
STDMETHODIMP DN_ProtocolReleaseReceiveBuffer(IDirectPlay8Protocol *pInterface, HANDLE hBuffer);
STDMETHODIMP DN_ProtocolGetEPCaps(IDirectPlay8Protocol *pInterface, HANDLE hEndPoint, PVOID pBuffer);

#endif	// __PROTOCOL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\protocol.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Protocol.cpp
 *  Content:    DNET protocol interface routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/01/00	ejs		Created
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

typedef	STDMETHODIMP ProtocolQueryInterface( IDirectPlay8Protocol *pInterface, REFIID riid, LPVOID *ppvObj );
typedef	STDMETHODIMP_(ULONG)	ProtocolAddRef( IDirectPlay8Protocol *pInterface );
typedef	STDMETHODIMP_(ULONG)	ProtocolRelease( IDirectPlay8Protocol *pInterface );

//**********************************************************************
// Function definitions
//**********************************************************************


//	DN_ProtocolInitialize
//
//	Initialize protocol

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ProtocolInitialize"
STDMETHODIMP DN_ProtocolInitialize(IDirectPlay8Protocol *pInterface, PVOID pContext, PDN_PROTOCOL_INTERFACE_VTBL pfVTbl)
{
	DIRECTNETOBJECT		*pdnObject;

	DNASSERT(pInterface != NULL);
	pdnObject = (DIRECTNETOBJECT *)GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pdnObject != NULL);

	return DNPProtocolInitialize( pContext, pdnObject->pdnProtocolData, pfVTbl );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ProtocolShutdown"
STDMETHODIMP DN_ProtocolShutdown(IDirectPlay8Protocol *pInterface)
{
	DIRECTNETOBJECT		*pdnObject;

	DNASSERT(pInterface != NULL);
	pdnObject = (DIRECTNETOBJECT *)GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pdnObject != NULL);

	return DNPProtocolShutdown(pdnObject->pdnProtocolData);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ProtocolAddSP"
STDMETHODIMP DN_ProtocolAddSP(IDirectPlay8Protocol *pInterface, IDP8ServiceProvider * const pISP, HANDLE* pContext)
{
	DIRECTNETOBJECT		*pdnObject;

	DNASSERT(pInterface != NULL);
	pdnObject = (DIRECTNETOBJECT *)GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pdnObject != NULL);

	return DNPAddServiceProvider(pdnObject->pdnProtocolData, pISP, pContext);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ProtocolRemoveSP"
STDMETHODIMP DN_ProtocolRemoveSP(IDirectPlay8Protocol *pInterface, const HANDLE hSPHandle)
{
	DIRECTNETOBJECT		*pdnObject;

	DNASSERT(pInterface != NULL);
	pdnObject = (DIRECTNETOBJECT *)GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pdnObject != NULL);

	return DNPRemoveServiceProvider(pdnObject->pdnProtocolData, hSPHandle);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ProtocolConnect"
STDMETHODIMP DN_ProtocolConnect(IDirectPlay8Protocol *pInterface, IDirectPlay8Address *const pLocal_Address, IDirectPlay8Address *const pRemote_Address, const HANDLE hSPHandle, ULONG Flags, PVOID Context, PHANDLE pHandle)
{
	DIRECTNETOBJECT		*pdnObject;

	DNASSERT(pInterface != NULL);
	pdnObject = (DIRECTNETOBJECT *)GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pdnObject != NULL);

	return DNPConnect(pdnObject->pdnProtocolData, pLocal_Address, pRemote_Address, hSPHandle, Flags, Context, pHandle);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ProtocolListen"
STDMETHODIMP DN_ProtocolListen(IDirectPlay8Protocol *pInterface, IDirectPlay8Address *const pAddress, const HANDLE hSPHandle, ULONG Flags, PVOID Context, PHANDLE Handle)
{
	DIRECTNETOBJECT		*pdnObject;

	DNASSERT(pInterface != NULL);
	pdnObject = (DIRECTNETOBJECT *)GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pdnObject != NULL);

	return DNPListen(pdnObject->pdnProtocolData, pAddress, hSPHandle, Flags, Context, Handle);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ProtocolSendData"
STDMETHODIMP DN_ProtocolSendData(IDirectPlay8Protocol *pInterface, HANDLE Dest, UINT BufCount, PBUFFERDESC Buffers, UINT Timeout, ULONG Flags, PVOID Context, PHANDLE Handle)
{
	DIRECTNETOBJECT		*pdnObject;

	DNASSERT(pInterface != NULL);
	pdnObject = (DIRECTNETOBJECT *)GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pdnObject != NULL);

	return DNPSendData(pdnObject->pdnProtocolData, Dest, BufCount, Buffers, Timeout, Flags, Context, Handle);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ProtocolDisconnectEP"
STDMETHODIMP DN_ProtocolDisconnectEP(IDirectPlay8Protocol *pInterface, HANDLE hEndPoint, PVOID pContext, PHANDLE pHandle)
{
	DIRECTNETOBJECT		*pdnObject;

	DNASSERT(pInterface != NULL);
	pdnObject = (DIRECTNETOBJECT *)GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pdnObject != NULL);

	return DNPDisconnectEndPoint(pdnObject->pdnProtocolData, hEndPoint, pContext, pHandle);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ProtocolCancel"
STDMETHODIMP DN_ProtocolCancel(IDirectPlay8Protocol *pInterface, HANDLE hHandle)
{
	DIRECTNETOBJECT		*pdnObject;

	DNASSERT(pInterface != NULL);
	pdnObject = (DIRECTNETOBJECT *)GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pdnObject != NULL);

	return DNPCancelCommand(pdnObject->pdnProtocolData, hHandle);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ProtocolReleaseReceiveBuffer"
STDMETHODIMP DN_ProtocolReleaseReceiveBuffer(IDirectPlay8Protocol *pInterface, HANDLE hBuffer)
{
	return DNPReleaseReceiveBuffer(hBuffer);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ProtocolGetEPCaps"
STDMETHODIMP DN_ProtocolGetEPCaps(IDirectPlay8Protocol *pInterface, HANDLE hEndPoint, PVOID pBuffer)
{
	return DNPGetEPCaps(hEndPoint, (PDPN_CONNECTION_INFO) pBuffer);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ProtocolDebug"
STDMETHODIMP DN_ProtocolDebug(IDirectPlay8Protocol *pInterface, UINT Opcode, HANDLE hEndPoint, PVOID Buffer)
{
	DIRECTNETOBJECT		*pdnObject;

	DNASSERT(pInterface != NULL);
	pdnObject = (DIRECTNETOBJECT *)GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pdnObject != NULL);

	return DNP_Debug(pdnObject->pdnProtocolData, Opcode, hEndPoint, Buffer);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ProtocolGetCaps"
STDMETHODIMP DN_ProtocolGetCaps(IDirectPlay8Protocol *pInterface, PDPN_CAPS pCaps)
{
	DIRECTNETOBJECT		*pdnObject;

	DNASSERT(pInterface != NULL);
	pdnObject = (DIRECTNETOBJECT *)GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pdnObject != NULL);

	return DNPGetProtocolCaps(pdnObject->pdnProtocolData, pCaps);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ProtocolGetCaps"
STDMETHODIMP DN_ProtocolSetCaps(IDirectPlay8Protocol *pInterface, const PDPN_CAPS pCaps)
{
	DIRECTNETOBJECT		*pdnObject;

	DNASSERT(pInterface != NULL);
	pdnObject = (DIRECTNETOBJECT *)GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pdnObject != NULL);

	return DNPSetProtocolCaps(pdnObject->pdnProtocolData, pCaps);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ProtocolEnumQuery"
STDMETHODIMP DN_ProtocolEnumQuery(IDirectPlay8Protocol *pInterface, IDirectPlay8Address *const pHostAddress, IDirectPlay8Address *const pDeviceAddress, const HANDLE hSPHandle, BUFFERDESC *const pBuffers, const DWORD dwBufferCount, const DWORD dwRetryCount, const DWORD dwRetryInterval, const DWORD dwTimeout, const DWORD dwFlags, void *const pUserContext, HANDLE *const pCommandHandle)
{
	DIRECTNETOBJECT		*pdnObject;

	DNASSERT(pInterface != NULL);
	pdnObject = (DIRECTNETOBJECT *)GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pdnObject != NULL);

	return DNPEnumQuery( pdnObject->pdnProtocolData, pHostAddress, pDeviceAddress, hSPHandle, pBuffers, dwBufferCount, dwRetryCount, dwRetryInterval, dwTimeout, dwFlags, pUserContext, pCommandHandle );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ProtocolEnumRespond"
STDMETHODIMP DN_ProtocolEnumRespond(IDirectPlay8Protocol *pInterface, const HANDLE hSPHandle, const HANDLE hQueryHandle, BUFFERDESC *const pResponseBuffers, const DWORD dwResponseBufferCount, const DWORD dwFlags, void *const pUserContext, HANDLE *const pCommandHandle)
{
	DIRECTNETOBJECT		*pdnObject;

	DNASSERT(pInterface != NULL);
	pdnObject = (DIRECTNETOBJECT *)GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pdnObject != NULL);

	return DNPEnumRespond( pdnObject->pdnProtocolData, hSPHandle, hQueryHandle, pResponseBuffers, dwResponseBufferCount, dwFlags, pUserContext, pCommandHandle );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ProtocolCrackEPD"
STDMETHODIMP DN_ProtocolCrackEPD(IDirectPlay8Protocol *pInterface, HANDLE hEndPoint, long Flags, IDirectPlay8Address** ppAddr )
{
	DIRECTNETOBJECT		*pdnObject;

	DNASSERT(pInterface != NULL);
	pdnObject = (DIRECTNETOBJECT *)GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pdnObject != NULL);

	SPGETADDRESSINFODATA SPData;
	SPData.Flags = (SP_GET_ADDRESS_INFO_FLAGS)Flags;

	HRESULT hr = DNPCrackEndPointDescriptor( hEndPoint, &SPData );
	*ppAddr = SPData.pAddress;
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ProtocolGetListenAddressInfo"
STDMETHODIMP DN_ProtocolGetListenAddressInfo(IDirectPlay8Protocol *pInterface, HANDLE hCommand, long Flags, IDirectPlay8Address** ppAddr )
{
	DIRECTNETOBJECT		*pdnObject;

	DNASSERT(pInterface != NULL);
	pdnObject = (DIRECTNETOBJECT *)GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pdnObject != NULL);

	SPGETADDRESSINFODATA SPData;
	SPData.Flags = (SP_GET_ADDRESS_INFO_FLAGS)Flags;

	HRESULT hr = DNPGetListenAddressInfo( hCommand, &SPData );
	*ppAddr = SPData.pAddress;
	return hr;
}

IDirectPlay8ProtocolVtbl DN_ProtocolVtbl =
{
	(ProtocolQueryInterface*)		DN_QueryInterface,
	(ProtocolAddRef*)				DN_AddRef,
	(ProtocolRelease*)				DN_Release,
							DN_ProtocolInitialize,
							DN_ProtocolShutdown,
							DN_ProtocolAddSP,
							DN_ProtocolRemoveSP,
							DN_ProtocolConnect,
							DN_ProtocolListen,
							DN_ProtocolSendData,
							DN_ProtocolDisconnectEP,
							DN_ProtocolCancel,
							DN_ProtocolReleaseReceiveBuffer,
							DN_ProtocolGetEPCaps,
							DN_ProtocolGetCaps,
							DN_ProtocolSetCaps,
							DN_ProtocolEnumQuery,
							DN_ProtocolEnumRespond,
							DN_ProtocolCrackEPD,
							DN_ProtocolGetListenAddressInfo,
							DN_ProtocolDebug,
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\server.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Server.cpp
 *  Content:    DNET server interface routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  07/21/99	mjn		Created
 *  12/23/99	mjn		Hand all NameTable update sends from Host to worker thread
 *	12/28/99	mjn		Moved Async Op stuff to Async.h
 *	01/06/00	mjn		Moved NameTable stuff to NameTable.h
 *	01/14/00	mjn		Added pvUserContext to Host API call
 *	01/16/00	mjn		Moved User callback stuff to User.h
 *	01/22/00	mjn		Implemented DestroyClient in API
 *	01/28/00	mjn		Implemented ReturnBuffer in API
 *	02/01/00	mjn		Implemented GetCaps and SetCaps in API
 *	02/01/00	mjn		Implement Player/Group context values
 *	02/15/00	mjn		Use INFO flags in SetServerInfo and return context in GetClientInfo
 *	02/17/00	mjn		Implemented GetPlayerContext and GetGroupContext
 *  03/17/00    rmt     Added new caps functions
 *	04/04/00	mjn		Added TerminateSession to API
 *	04/05/00	mjn		Modified DestroyClient
 *	04/06/00	mjn		Added GetClientAddress to API
 *				mjn		Added GetHostAddress to API
 *  04/18/00    rmt     Added additional paramtere validation
 *	04/19/00	mjn		SendTo API call accepts a range of DPN_BUFFER_DESCs and a count
 *	04/24/00	mjn		Updated Group and Info operations to use CAsyncOp's
 *	05/31/00	mjn		Added operation specific SYNC flags
 *	06/23/00	mjn		Removed dwPriority from SendTo() API call
 *	07/09/00	mjn		Cleaned up DN_SetServerInfo()
 *  07/09/00	rmt		Bug #38323 - RegisterLobby needs a DPNHANDLE parameter.
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *	10/11/00	mjn		Take locks for CNameTableEntry::PackInfo()
 *				mjn		Check deleted list in DN_GetClientInfo()
 *	01/22/01	mjn		Check closing instead of disconnecting in DN_GetClientInfo()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

typedef	STDMETHODIMP ServerQueryInterface( IDirectPlay8Server *pInterface, REFIID riid, LPVOID *ppvObj );
typedef	STDMETHODIMP_(ULONG)	ServerAddRef( IDirectPlay8Server *pInterface );
typedef	STDMETHODIMP_(ULONG)	ServerRelease( IDirectPlay8Server *pInterface );
typedef	STDMETHODIMP ServerInitialize( IDirectPlay8Server *pInterface, LPVOID const lpvUserContext, const PFNDPNMESSAGEHANDLER lpfn, const DWORD dwFlags );
typedef	STDMETHODIMP ServerEnumServiceProviders( IDirectPlay8Server *pInterface,const GUID *const pguidServiceProvider,const GUID *const pguidApplication,DPN_SERVICE_PROVIDER_INFO *const pSPInfoBuffer,DWORD *const pcbEnumData,DWORD *const pcReturned,const DWORD dwFlags);
typedef	STDMETHODIMP ServerCancelAsyncOperation( IDirectPlay8Server *pInterface, const DPNHANDLE hAsyncHandle, const DWORD dwFlags );
typedef	STDMETHODIMP ServerGetSendQueueInfo( IDirectPlay8Server *pInterface, const DPNID dpnid,DWORD *const lpdwNumMsgs, DWORD *const lpdwNumBytes, const DWORD dwFlags );
typedef	STDMETHODIMP ServerGetApplicationDesc( IDirectPlay8Server *pInterface,DPN_APPLICATION_DESC *const pAppDescBuffer,DWORD *const lpcbDataSize,const DWORD dwFlags );
typedef	STDMETHODIMP ServerSetApplicationDesc( IDirectPlay8Server *pInterface, const DPN_APPLICATION_DESC *const lpad, const DWORD dwFlags );
typedef STDMETHODIMP ServerGetHostAddress( IDirectPlay8Server *pInterface, IDirectPlay8Address **const prgpAddress, DWORD *const pcAddress,const DWORD dwFlags);
typedef	STDMETHODIMP ServerHost( IDirectPlay8Server *pInterface,const DPN_APPLICATION_DESC *const pdnAppDesc,IDirectPlay8Address **const prgpDeviceInfo,const DWORD cDeviceInfo,const DPN_SECURITY_DESC *const pdnSecurity,const DPN_SECURITY_CREDENTIALS *const pdnCredentials,void *const pvPlayerContext,const DWORD dwFlags);
typedef	STDMETHODIMP ServerSendTo( IDirectPlay8Server *pInterface, const DPNID dnid, const DPN_BUFFER_DESC *const prgBufferDesc,const DWORD cBufferDesc,const DWORD dwTimeOut, void *const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags);
typedef	STDMETHODIMP ServerCreateGroup( IDirectPlay8Server *pInterface, const DPN_GROUP_INFO *const pdpnGroupInfo,void *const pvGroupContext,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags);
typedef STDMETHODIMP ServerDestroyGroup( IDirectPlay8Server *pInterface, const DPNID idGroup,PVOID const pvUserContext,DPNHANDLE *const lpAsyncHandle,const DWORD dwFlags);
typedef STDMETHODIMP ServerAddClientToGroup( IDirectPlay8Server *pInterface, const DPNID idGroup, const DPNID idClient,PVOID const pvUserContext,DPNHANDLE *const lpAsyncHandle,const DWORD dwFlags);
typedef STDMETHODIMP ServerRemoveClientFromGroup( IDirectPlay8Server *pInterface, const DPNID idGroup, const DPNID idClient,PVOID const pvUserContext,DPNHANDLE *const lpAsyncHandle,const DWORD dwFlags);
typedef STDMETHODIMP ServerSetGroupInfo(IDirectPlay8Server *pInterface, const DPNID dpnid,DPN_GROUP_INFO *const pdpnGroupInfo,PVOID const pvAsyncContext,DPNHANDLE *const phAsyncHandle, const DWORD dwFlags);
typedef STDMETHODIMP ServerGetGroupInfo(IDirectPlay8Server *pInterface, const DPNID dpnid,DPN_GROUP_INFO *const pdpnGroupInfo,DWORD *const pdwSize,const DWORD dwFlags);
typedef STDMETHODIMP ServerEnumClientsAndGroups( IDirectPlay8Server *pInterface, DPNID *const lprgdnid, DWORD *const lpcdnid, const DWORD dwFlags );
typedef	STDMETHODIMP ServerEnumGroupMembers( IDirectPlay8Server *pInterface, const DPNID dnid, DPNID *const lprgdnid, DWORD *const lpcdnid, const DWORD dwFlags );
typedef	STDMETHODIMP ServerClose( IDirectPlay8Server *pInterface,const DWORD dwFlags);
typedef STDMETHODIMP ServerDestroyClient( IDirectPlay8Server *pInterface,const DPNID dnid,const void *const pvDestroyData,const DWORD dwDestroyDataSize,const DWORD dwFlags);
typedef STDMETHODIMP ServerReturnBuffer( IDirectPlay8Server *pInterface, const DPNHANDLE hBufferHandle,const DWORD dwFlags);
typedef STDMETHODIMP ServerGetCaps(IDirectPlay8Server *pInterface,DPN_CAPS *const pdnCaps,const DWORD dwFlags);
typedef STDMETHODIMP ServerSetCaps(IDirectPlay8Server *pInterface,const DPN_CAPS *const pdnCaps,const DWORD dwFlags);
typedef STDMETHODIMP ServerGetPlayerContext(IDirectPlay8Server *pInterface,const DPNID dpnid,PVOID *const ppvPlayerContext,const DWORD dwFlags);
typedef STDMETHODIMP ServerGetGroupContext(IDirectPlay8Server *pInterface,const DPNID dpnid,PVOID *const ppvGroupContext,const DWORD dwFlags);
typedef STDMETHODIMP ServerSetSPCaps(IDirectPlay8Server *pInterface,const GUID * const pguidSP, const DPN_SP_CAPS *const pdpspCaps, const DWORD dwFlags );
typedef STDMETHODIMP ServerGetSPCaps(IDirectPlay8Server *pInterface,const GUID * const pguidSP, DPN_SP_CAPS *const pdpspCaps,const DWORD dwFlags);
typedef STDMETHODIMP ServerGetConnectionInfo(IDirectPlay8Server *pInterface,const DPNID dpnid, DPN_CONNECTION_INFO *const pdpConnectionInfo,const DWORD dwFlags);
typedef STDMETHODIMP ServerRegisterLobby(IDirectPlay8Server *pInterface,const DPNHANDLE dpnHandle,IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags);
typedef STDMETHODIMP ServerDumpNameTable(IDirectPlay8Server *pInterface,char *const Buffer);

//
// VTable for server interface
//
IDirectPlay8ServerVtbl DN_ServerVtbl =
{
	(ServerQueryInterface*)			DN_QueryInterface,
	(ServerAddRef*)					DN_AddRef,
	(ServerRelease*)				DN_Release,
	(ServerInitialize*)				DN_Initialize,
	(ServerEnumServiceProviders*)	DN_EnumServiceProviders,
	(ServerCancelAsyncOperation*)	DN_CancelAsyncOperation,
	(ServerGetSendQueueInfo*)		DN_GetSendQueueInfo,
	(ServerGetApplicationDesc*)		DN_GetApplicationDesc,
									DN_SetServerInfo,
									DN_GetClientInfo,
									DN_GetClientAddress,
	(ServerGetHostAddress*)			DN_GetHostAddress,
	(ServerSetApplicationDesc*)		DN_SetApplicationDesc,
	(ServerHost*)					DN_Host,
	(ServerSendTo*)					DN_SendTo,
	(ServerCreateGroup*)			DN_CreateGroup,
	(ServerDestroyGroup*)			DN_DestroyGroup,
	(ServerAddClientToGroup*)		DN_AddClientToGroup,
	(ServerRemoveClientFromGroup*)	DN_RemoveClientFromGroup,
	(ServerSetGroupInfo*)			DN_SetGroupInfo,
	(ServerGetGroupInfo*)			DN_GetGroupInfo,
	(ServerEnumClientsAndGroups*)	DN_EnumClientsAndGroups,
	(ServerEnumGroupMembers*)		DN_EnumGroupMembers,
	(ServerClose*)					DN_Close,
	(ServerDestroyClient*)			DN_DestroyPlayer,
	(ServerReturnBuffer*)			DN_ReturnBuffer,
	(ServerGetPlayerContext*)		DN_GetPlayerContext,
	(ServerGetGroupContext*)		DN_GetGroupContext,
	(ServerGetCaps*)				DN_GetCaps,
	(ServerSetCaps*)				DN_SetCaps,
    (ServerSetSPCaps*)              DN_SetSPCaps, 
    (ServerGetSPCaps*)              DN_GetSPCaps,
    (ServerGetConnectionInfo*)      DN_GetConnectionInfo,
	(ServerRegisterLobby*)			DN_RegisterLobby,
	(ServerDumpNameTable*)			DN_DumpNameTable
};

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************

//	DN_SetServerInfo
//
//	Set the info for the server and propagate to client players

#undef DPF_MODNAME
#define DPF_MODNAME "DN_SetServerInfo"

STDMETHODIMP DN_SetServerInfo(IDirectPlay8Server *pInterface,
							  const DPN_PLAYER_INFO *const pdpnPlayerInfo,
							  PVOID const pvAsyncContext,
							  DPNHANDLE *const phAsyncHandle,
							  const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject;
	HRESULT				hResultCode;
	DPNHANDLE			hAsyncOp;
	PWSTR				pwszName;
	DWORD				dwNameSize;
	PVOID				pvData;
	DWORD				dwDataSize;
	CNameTableEntry		*pLocalPlayer;
	BOOL				fConnected;

	DPFX(DPFPREP, 2,"Parameters: pInterface [0x%p], pdpnPlayerInfo [0x%p], pvAsyncContext [0x%p], phAsyncHandle [0x%p], dwFlags [0x%lx]",
			pInterface,pdpnPlayerInfo,pvAsyncContext,phAsyncHandle,dwFlags);

	TRY
	{
    	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
    	DNASSERT(pdnObject != NULL);

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    	{
        	if( FAILED( hResultCode = DN_ValidateSetServerInfo( pInterface , pdpnPlayerInfo, pvAsyncContext, phAsyncHandle, dwFlags ) ) )
        	{
        	    DPFX(DPFPREP,  0, "Error validating setserverinfo params hr=[0x%lx]", hResultCode );
        	    DPF_RETURN( hResultCode );
        	}
    	}

        // Check to ensure message handler registered
    	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    	{
    		DPFERR( "Object is not initialized" );
    		DPF_RETURN(DPNERR_UNINITIALIZED);
    	}	
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}
	
	pLocalPlayer = NULL;

	if ((pdpnPlayerInfo->dwInfoFlags & DPNINFO_NAME) && (pdpnPlayerInfo->pwszName))
	{
		pwszName = pdpnPlayerInfo->pwszName;
		dwNameSize = (wcslen(pwszName) + 1) * sizeof(WCHAR);
	}
	else
	{
		pwszName = NULL;
		dwNameSize = 0;
	}
	if ((pdpnPlayerInfo->dwInfoFlags & DPNINFO_DATA) && (pdpnPlayerInfo->pvData) && (pdpnPlayerInfo->dwDataSize))
	{
		pvData = pdpnPlayerInfo->pvData;
		dwDataSize = pdpnPlayerInfo->dwDataSize;
	}
	else
	{
		pvData = NULL;
		dwDataSize = 0;
	}

	//
	//	If we are connected, we will update our entry.
	//	Otherwise, we will just update the DefaultPlayer.
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED)
	{
		fConnected = TRUE;
	}
	else
	{
		fConnected = FALSE;
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
	if (fConnected)
	{
		if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
		{
			DPFERR( "Could not get local player reference" );
			DisplayDNError(0,hResultCode);
			goto Failure;
		}

		DPFX(DPFPREP, 3,"Host is updating server info");

		hResultCode = DNHostUpdateInfo(	pdnObject,
										pLocalPlayer->GetDPNID(),
										pwszName,
										dwNameSize,
										pvData,
										dwDataSize,
										pdpnPlayerInfo->dwInfoFlags,
										pvAsyncContext,
										pLocalPlayer->GetDPNID(),
										0,
										&hAsyncOp,
										dwFlags );
		if ((hResultCode != DPN_OK) && (hResultCode != DPNERR_PENDING))
		{
			DPFERR("Could not request host to update group");
		}
		else
		{
			if (!(dwFlags & DPNSETSERVERINFO_SYNC))
			{
				DPFX(DPFPREP, 3,"Async Handle [0x%lx]",hAsyncOp);
				*phAsyncHandle = hAsyncOp;

				//
				//	Release Async HANDLE since this operation has already completed (!)
				//
				pdnObject->HandleTable.Destroy( hAsyncOp );
				hAsyncOp = 0;
			}
		}

		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	else
	{
		DNASSERT(pdnObject->NameTable.GetDefaultPlayer() != NULL);

		// This function takes the lock internally
		pdnObject->NameTable.GetDefaultPlayer()->UpdateEntryInfo(pwszName,dwNameSize,pvData,dwDataSize,pdpnPlayerInfo->dwInfoFlags, FALSE);

		hResultCode = DPN_OK;
	}

Exit:
	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	goto Exit;
}


//	DN_GetClientInfo
//
//	Retrieve client info from the local nametable.

#undef DPF_MODNAME
#define DPF_MODNAME "DN_GetClientInfo"

STDMETHODIMP DN_GetClientInfo(IDirectPlay8Server *pInterface,
							  const DPNID dpnid,
							  DPN_PLAYER_INFO *const pdpnPlayerInfo,
							  DWORD *const pdwSize,
							  const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject;
	CNameTableEntry		*pNTEntry;
	CPackedBuffer		packedBuffer;
	HRESULT				hResultCode;

	DPFX(DPFPREP, 2,"Parameters: dpnid [0x%lx], pdpnPlayerInfo [0x%p], dwFlags [0x%lx]",
			dpnid,pdpnPlayerInfo,dwFlags);

	TRY
	{
    	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
    	DNASSERT(pdnObject != NULL);

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    	{
        	if( FAILED( hResultCode = DN_ValidateGetClientInfo( pInterface , dpnid, pdpnPlayerInfo, pdwSize, dwFlags ) ) )
        	{
        	    DPFX(DPFPREP,  0, "Error validating getclientinfo params hr=[0x%lx]", hResultCode );
        	    DPF_RETURN( hResultCode );
        	}
    	}

        // Check to ensure message handler registered
    	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    	{
    		DPFERR( "Object is not initialized" );
    		DPF_RETURN(DPNERR_UNINITIALIZED);
    	}	

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    	{
    	    DPFERR("Object is connecting / starting to host" );
    	    DPF_RETURN(DPNERR_CONNECTING);
    	}

    	if ( !(pdnObject->dwFlags & (DN_OBJECT_FLAG_CONNECTED | DN_OBJECT_FLAG_CLOSING | DN_OBJECT_FLAG_DISCONNECTING) ) )
    	{
    	    DPFERR("You must be connected / disconnecting to use this function" );
    	    DPF_RETURN(DPNERR_NOCONNECTION);
    	}	    	
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}

	pNTEntry = NULL;

	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnid,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not retrieve name table entry");
		DisplayDNError(0,hResultCode);

		//
		//	Try deleted list
		//
		if ((hResultCode = pdnObject->NameTable.FindDeletedEntry(dpnid,&pNTEntry)) != DPN_OK)
		{
			DPFERR("Could not find player in deleted list either");
			DisplayDNError(0,hResultCode);
			hResultCode = DPNERR_INVALIDPLAYER;
			goto Failure;
		}
	}
	packedBuffer.Initialize(pdpnPlayerInfo,*pdwSize);

	pNTEntry->Lock();
	if (pNTEntry->IsGroup() || pNTEntry->IsHost())
	{
	    DPFERR( "Specified ID is invalid" );
		pNTEntry->Unlock();
		hResultCode = DPNERR_INVALIDPLAYER;
		goto Failure;
	}

	hResultCode = pNTEntry->PackInfo(&packedBuffer);

	pNTEntry->Unlock();
	pNTEntry->Release();
	pNTEntry = NULL;

	if ((hResultCode == DPN_OK) || (hResultCode == DPNERR_BUFFERTOOSMALL))
	{
		*pdwSize = packedBuffer.GetSizeRequired();
	}

Exit:
	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_GetClientAddress"

STDMETHODIMP DN_GetClientAddress(IDirectPlay8Server *pInterface,
								 const DPNID dpnid,
								 IDirectPlay8Address **const ppAddress,
								 const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject;
	CNameTableEntry		*pNTEntry;
	IDirectPlay8Address	*pAddress;
	HRESULT				hResultCode;

	DPFX(DPFPREP, 2,"Parameters : pInterface [0x%p], dpnid [0x%lx], ppAddress [0x%p], dwFlags [0x%lx]",
		pInterface,dpnid,ppAddress,dwFlags);

	TRY
	{
    	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
    	DNASSERT(pdnObject != NULL);

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    	{
        	if( FAILED( hResultCode = DN_ValidateGetClientAddress( pInterface , dpnid, ppAddress, dwFlags ) ) )
        	{
        	    DPFX(DPFPREP,  0, "Error validating getclientaddress params hr=[0x%lx]", hResultCode );
        	    DPF_RETURN( hResultCode );
        	}
    	}

        // Check to ensure message handler registered
    	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    	{
    		DPFERR( "Object is not initialized" );
    		DPF_RETURN(DPNERR_UNINITIALIZED);
    	}	
  	
    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    	{
    	    DPFERR("Object is connecting / starting to host" );
    	    DPF_RETURN(DPNERR_CONNECTING);
    	}

    	if ( !(pdnObject->dwFlags & (DN_OBJECT_FLAG_CONNECTED | DN_OBJECT_FLAG_CLOSING | DN_OBJECT_FLAG_DISCONNECTING) ) )
    	{
    	    DPFERR("You must be connected / disconnecting to use this function" );
    	    DPF_RETURN(DPNERR_NOCONNECTION);
    	}	    	
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}

	pNTEntry = NULL;
	pAddress = NULL;

	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnid,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not find NameTableEntry");
		DisplayDNError(0,hResultCode);
		hResultCode = DPNERR_INVALIDPLAYER;
		goto Failure;
	}

	if ((pNTEntry->GetAddress() == NULL) || (pNTEntry->IsGroup()) || !pNTEntry->IsAvailable())
	{
	    DPFERR( "Specified player is not valid" );
		hResultCode = DPNERR_INVALIDPLAYER;
		goto Failure;
	}

	hResultCode = pNTEntry->GetAddress()->lpVtbl->Duplicate(pNTEntry->GetAddress(),ppAddress);

	pNTEntry->Release();
	pNTEntry = NULL;

Exit:
	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
    return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}

	goto Exit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\receive.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Receive.h
 *  Content:    DirectNet receive user data
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *	01/27/00	mjn		Created
 *	04/20/00	mjn		ReceiveBuffers use CAsyncOp
 *	08/02/00	mjn		Added dwFlags to DNReceiveUserData()
 *				mjn		Added DNSendUserProcessCompletion()
 *	03/30/01	mjn		Changes to prevent multiple loading/unloading of SP's
 *				mjn		Added service provider to DNReceiveUserData()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__RECEIVE_H__
#define	__RECEIVE_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

HRESULT	DNReceiveUserData(DIRECTNETOBJECT *const pdnObject,
						  const DPNID dpnidSender,
						  CServiceProvider *const pSP,
						  BYTE *const pBufferData,
						  const DWORD dwBufferSize,
						  const HANDLE hProtocol,
						  CRefCountBuffer *const pRefCountBuffer,
						  const DPNHANDLE hCompletionOp,
						  const DWORD dwFlags);

HRESULT DNSendUserProcessCompletion(DIRECTNETOBJECT *const pdnObject,
									CConnection *const pConnection,
									const DPNHANDLE hCompletionOp);

void DNFreeProtocolBuffer(void *const pv,void *const pvBuffer);

void DNCompleteReceiveBuffer(DIRECTNETOBJECT *const pdnObject,
							 CAsyncOp *const pAsyncOp);

//**********************************************************************
// Class prototypes
//**********************************************************************

#endif	// __RECEIVE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\queuedmsg.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       QueuedMsg.h
 *  Content:    Queued Message Object Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  07/31/00	mjn		Created
 *	09/12/00	mjn		Added m_OpType
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__QUEUED_MSG_H__
#define	__QUEUED_MSG_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	QUEUED_MSG_FLAG_VOICE		0x0001

//**********************************************************************
// Macro definitions
//**********************************************************************

#ifndef	OFFSETOF
#define OFFSETOF(s,m)				( ( INT_PTR ) ( ( PVOID ) &( ( (s*) 0 )->m ) ) )
#endif

#ifndef	CONTAINING_OBJECT
#define	CONTAINING_OBJECT(b,t,m)	(reinterpret_cast<t*>(&reinterpret_cast<BYTE*>(b)[-OFFSETOF(t,m)]))
#endif

//**********************************************************************
// Structure definitions
//**********************************************************************

class CQueuedMsg;
template< class CQueuedMsg > class CLockedContextClassFixedPool;

typedef enum
{
	UNKNOWN,
	RECEIVE,
	ADD_PLAYER_TO_GROUP,
	REMOVE_PLAYER_FROM_GROUP,
	UPDATE_INFO
} QUEUED_MSG_TYPE;

class CAsyncOp;

typedef struct _DIRECTNETOBJECT DIRECTNETOBJECT;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************

// class for Queued Messages

class CQueuedMsg
{
public:
	CQueuedMsg()				// Constructor
		{
			m_Sig[0] = 'Q';
			m_Sig[1] = 'M';
			m_Sig[2] = 'S';
			m_Sig[3] = 'G';
		};

	~CQueuedMsg() { };			// Destructor

	BOOL FPMAlloc(void *const pvContext)
		{
			m_pdnObject = static_cast<DIRECTNETOBJECT*>(pvContext);

			return(TRUE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CQueuedMsg::FPMInitialize"
	BOOL FPMInitialize(void *const pvContext)
		{
			DNASSERT(m_pdnObject == pvContext);

			m_OpType = UNKNOWN;
			m_dwFlags = 0;
			m_pBuffer = NULL;
			m_dwBufferSize = 0;
			m_hCompletionOp = 0;
			m_pAsyncOp = NULL;
			m_bilinkQueuedMsgs.Initialize();

			return(TRUE);
		};

	void FPMRelease(void *const pvContext) { };

	void FPMDealloc(void *const pvContext) { };

	void ReturnSelfToPool( void )
		{
			m_pdnObject->m_pFPOOLQueuedMsg->Release( this );
		};

	void SetOpType( const QUEUED_MSG_TYPE OpType )
		{
			m_OpType = OpType;
		};

	QUEUED_MSG_TYPE GetOpType( void )
		{
			return( m_OpType );
		};

	void MakeVoiceMessage( void )
		{
			m_dwFlags |= QUEUED_MSG_FLAG_VOICE;
		};

	BOOL IsVoiceMessage( void )
		{
			if (m_dwFlags & QUEUED_MSG_FLAG_VOICE)
			{
				return( TRUE );
			}
			return( FALSE );
		};

	void SetBuffer( BYTE *const pBuffer )
		{
			m_pBuffer = pBuffer;
		};

	BYTE *GetBuffer( void )
		{
			return( m_pBuffer );
		};

	void SetBufferSize( const DWORD dwBufferSize )
		{
			m_dwBufferSize = dwBufferSize;
		};

	DWORD GetBufferSize( void )
		{
			return( m_dwBufferSize );
		};

	void SetCompletionOp( const DPNHANDLE hCompletionOp)
		{
			m_hCompletionOp = hCompletionOp;
		};

	DPNHANDLE GetCompletionOp( void )
		{
			return( m_hCompletionOp );
		};

	void CQueuedMsg::SetAsyncOp( CAsyncOp *const pAsyncOp );

	CAsyncOp *GetAsyncOp( void )
		{
			return( m_pAsyncOp );
		};

	CBilink				m_bilinkQueuedMsgs;

private:
	BYTE				m_Sig[4];			// Signature
	QUEUED_MSG_TYPE		m_OpType;
	DWORD	volatile	m_dwFlags;

	BYTE				*m_pBuffer;
	DWORD				m_dwBufferSize;

	DPNHANDLE			m_hCompletionOp;

	CAsyncOp			*m_pAsyncOp;

	DIRECTNETOBJECT		*m_pdnObject;
};

#undef DPF_MODNAME

#endif	// __QUEUED_MSG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\request.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Request.cpp
 *  Content:    Requested operations
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/18/00	mjn		Created
 *	04/16/00	mjn		DNSendMessage uses CAsyncOp
 *	04/19/00	mjn		Update NameTable operations to use DN_WORKER_JOB_SEND_NAMETABLE_OPERATION
 *	04/24/00	mjn		Updated Group and Info operations to use CAsyncOp's
 *	05/03/00	mjn		Use GetHostPlayerRef() rather than GetHostPlayer()
 *	05/16/00	mjn		Better locking during User notifications
 *	05/31/00	mjn		Added operation specific SYNC flags
 *	06/26/00	mjn		Replaced DPNADDCLIENTTOGROUP_SYNC DPNADDPLAYERTOGROUP_SYNC
 *				mjn		Replaced DPNREMOVECLIENTFROMGROUP_SYNC with DPNREMOVEPLAYERFROMGROUP_SYNC
 *	07/26/00	mjn		Fixed locking problem with CAsyncOp::MakeChild()
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *	08/05/00	mjn		Added pParent to DNSendGroupMessage and DNSendMessage()
 *				mjn		Added DNProcessFailedRequest()
 *	08/06/00	mjn		Added CWorkerJob
 *	08/07/00	mjn		Added DNRequestIntegrityCheck(),DNHostCheckIntegrity(),DNProcessCheckIntegrity(),DNHostFixIntegrity()
 *	08/08/00	mjn		Mark groups created after CREATE_GROUP
 *	08/09/00	mjn		Made requests and host operations more robust for host migration
 *	08/15/00	mjn		Keep request operations if HostPlayer or connection is unavailable
 *	09/05/00	mjn		Removed dwIndex from CNameTable::InsertEntry()
 *	09/13/00	mjn		Perform queued operations after creating group in DNConnectToHost2()
 *	09/26/00	mjn		Removed locking from CNameTable::SetVersion() and CNameTable::GetNewVersion()
 *	10/10/00	mjn		Return DPN_OK from Host operations if unable to get reference on local player
 *	10/13/00	mjn		Update version if FindPlayer fails in DNProcessXXX() functions
 *	01/09/01	mjn		Prevent asynchronous group/info operations from being cancelled
 *	01/25/01	mjn		Fixed 64-bit alignment problem in received messages
 *	04/13/01	mjn		Remove requests from request list when operations received from host
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


#undef DPF_MODNAME
#define DPF_MODNAME "DNRequestCreateGroup"

HRESULT DNRequestCreateGroup(DIRECTNETOBJECT *const pdnObject,
							 const PWSTR pwszName,
							 const DWORD dwNameSize,
							 const PVOID pvData,
							 const DWORD dwDataSize,
							 const DWORD dwGroupFlags,
							 void *const pvGroupContext,
							 void *const pvUserContext,
							 DPNHANDLE *const phAsyncOp,
							 const DWORD dwFlags)
{
	HRESULT				hResultCode;
	CAsyncOp			*pRequest;
	CAsyncOp			*pHandleParent;
	CSyncEvent			*pSyncEvent;
	CRefCountBuffer		*pRefCountBuffer;
	CPackedBuffer		packedBuffer;
	CNameTableEntry		*pHostPlayer;
	CConnection			*pConnection;
	HRESULT	volatile	hrOperation;
	DN_INTERNAL_MESSAGE_REQ_CREATE_GROUP	*pMsg;

	DPFX(DPFPREP, 4,"Parameters: pwszName [%S], pvData [0x%p], dwDataSize [%ld], dwGroupFlags [0x%lx], pvUserContext [0x%p], dwFlags [0x%lx]",
		pwszName,pvData,dwDataSize,dwGroupFlags,pvUserContext,dwFlags);

	DNASSERT(pdnObject != NULL);

	pRequest = NULL;
	pHandleParent = NULL;
	pSyncEvent = NULL;
	pRefCountBuffer = NULL;
	pHostPlayer = NULL;
	pConnection = NULL;

	//
	//	Create REQUEST
	//

	// Create buffer
	if ((hResultCode = RefCountBufferNew(pdnObject,
			sizeof(DN_INTERNAL_MESSAGE_REQ_CREATE_GROUP) + dwNameSize + dwDataSize,&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not create new RefCountBuffer");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	packedBuffer.Initialize(pRefCountBuffer->GetBufferAddress(),pRefCountBuffer->GetBufferSize());
	pMsg = static_cast<DN_INTERNAL_MESSAGE_REQ_CREATE_GROUP*>(packedBuffer.GetHeadAddress());
	if ((hResultCode = packedBuffer.AddToFront(NULL,sizeof(DN_INTERNAL_MESSAGE_REQ_CREATE_GROUP))) != DPN_OK)
	{
		DPFERR("Could not reserve space at front of buffer");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

	// Flags
	pMsg->dwGroupFlags = dwGroupFlags;
	pMsg->dwInfoFlags = 0;

	// Add Name
	if (dwNameSize)
	{
		if ((hResultCode = packedBuffer.AddToBack(pwszName,dwNameSize)) != DPN_OK)
		{
			DPFERR("Could not add Name to packed buffer");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pMsg->dwNameOffset = packedBuffer.GetTailOffset();
		pMsg->dwNameSize = dwNameSize;
		pMsg->dwInfoFlags |= DPNINFO_NAME;
	}
	else
	{
		pMsg->dwNameOffset = 0;
		pMsg->dwNameSize = 0;
	}

	// Add Data
	if (dwDataSize)
	{
		if ((hResultCode = packedBuffer.AddToBack(pvData,dwDataSize)) != DPN_OK)
		{
			DPFERR("Could not add Data to packed buffer");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pMsg->dwDataOffset = packedBuffer.GetTailOffset();
		pMsg->dwDataSize = dwDataSize;
		pMsg->dwInfoFlags |= DPNINFO_DATA;
	}
	else
	{
		pMsg->dwDataOffset = 0;
		pMsg->dwDataSize = 0;
	}

	//
	//	Create synchronization event if necessary
	//
	if (dwFlags & DPNCREATEGROUP_SYNC)
	{
		if ((hResultCode = SyncEventNew(pdnObject,&pSyncEvent)) !=  DPN_OK)
		{
			DPFERR("Could not create synchronization event");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
	}
	else
	{
		if ((hResultCode = DNCreateUserHandle(pdnObject,&pHandleParent)) != DPN_OK)
		{
			DPFERR("Could not create user HANDLE");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
	}

	//
	//	Get host connection for request operation.
	//	We will procede even if we can't get it, just so that the operation will be re-tried at host migration
	//	or cancelled at close
	//
	if ((hResultCode = pdnObject->NameTable.GetHostPlayerRef( &pHostPlayer )) == DPN_OK)
	{
		if ((hResultCode = pHostPlayer->GetConnectionRef( &pConnection )) != DPN_OK)
		{
			DPFERR("Could not get host connection reference");
			DisplayDNError(0,hResultCode);
		}
		pHostPlayer->Release();
		pHostPlayer = NULL;
	}
	else
	{
		DPFERR("Could not find Host player");
		DisplayDNError(0,hResultCode);
	}

	//
	//	Send request
	//
	hResultCode = DNPerformRequest(	pdnObject,
									DN_MSG_INTERNAL_REQ_CREATE_GROUP,
									pRefCountBuffer->BufferDescAddress(),
									pConnection,
									pHandleParent,
									&pRequest );

	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}

	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

	//
	//	Wait for SyncEvent or create async user HANDLE
	//
	pRequest->SetContext( pvGroupContext );
	if (dwFlags & DPNCREATEGROUP_SYNC)
	{
		pRequest->SetSyncEvent( pSyncEvent );
		pRequest->SetResultPointer( &hrOperation );
		pRequest->Release();
		pRequest = NULL;

		pSyncEvent->WaitForEvent(INFINITE);
		pSyncEvent->ReturnSelfToPool();
		pSyncEvent = NULL;

		hResultCode = hrOperation;
	}
	else
	{
		pRequest->Release();
		pRequest = NULL;

		if (phAsyncOp)
		{
			*phAsyncOp = pHandleParent->GetHandle();
		}
		pHandleParent->SetCompletion( DNCompleteAsyncHandle );
		pHandleParent->SetContext( pvUserContext );
		pHandleParent->SetCannotCancel();
		pHandleParent->Release();
		pHandleParent = NULL;

		hResultCode = DPNERR_PENDING;
	}

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pHostPlayer)
	{
		pHostPlayer->Release();
		pHostPlayer = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	if (pRequest)
	{
		pRequest->Release();
		pRequest = NULL;
	}
	if (pHandleParent)
	{
		pHandleParent->Release();
		pHandleParent = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pSyncEvent)
	{
		pSyncEvent->ReturnSelfToPool();
		pSyncEvent = NULL;
	}
	goto Exit;
}



#undef DPF_MODNAME
#define DPF_MODNAME "DNRequestDestroyGroup"

HRESULT DNRequestDestroyGroup(DIRECTNETOBJECT *const pdnObject,
							  const DPNID dpnidGroup,
							  PVOID const pvUserContext,
							  DPNHANDLE *const phAsyncOp,
							  const DWORD dwFlags)
{
	HRESULT				hResultCode;
	CAsyncOp			*pRequest;
	CAsyncOp			*pHandleParent;
	CRefCountBuffer		*pRefCountBuffer;
	CSyncEvent			*pSyncEvent;
	CNameTableEntry		*pHostPlayer;
	CConnection			*pConnection;
	HRESULT	volatile	hrOperation;
	DN_INTERNAL_MESSAGE_REQ_DESTROY_GROUP	*pMsg;

	DPFX(DPFPREP, 4,"Parameters: dpnidGroup [0x%lx], pvUserContext [0x%p], phAsyncOp [0x%p], dwFlags [0x%lx]",
			dpnidGroup,pvUserContext,phAsyncOp,dwFlags);

	DNASSERT(pdnObject != NULL);
	DNASSERT(dpnidGroup != 0);

	pRequest = NULL;
	pHandleParent = NULL;
	pSyncEvent = NULL;
	pRefCountBuffer = NULL;
	pHostPlayer = NULL;
	pConnection = NULL;

	//
	//	Create REQUEST
	//
	if ((hResultCode = RefCountBufferNew(pdnObject,sizeof(DN_INTERNAL_MESSAGE_REQ_DESTROY_GROUP),
			&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not allocate count buffer (request destroy group)");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pMsg = reinterpret_cast<DN_INTERNAL_MESSAGE_REQ_DESTROY_GROUP*>(pRefCountBuffer->GetBufferAddress());
	pMsg->dpnidGroup = dpnidGroup;

	//
	//	Create synchronization event if necessary
	//
	if (dwFlags & DPNDESTROYGROUP_SYNC)
	{
		if ((hResultCode = SyncEventNew(pdnObject,&pSyncEvent)) !=  DPN_OK)
		{
			DPFERR("Could not create synchronization event");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
	}
	else
	{
		if ((hResultCode = DNCreateUserHandle(pdnObject,&pHandleParent)) != DPN_OK)
		{
			DPFERR("Could not create user HANDLE");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
	}

	//
	//	Get host connection for request operation.
	//	We will procede even if we can't get it, just so that the operation will be re-tried at host migration
	//	or cancelled at close
	//
	if ((hResultCode = pdnObject->NameTable.GetHostPlayerRef( &pHostPlayer )) == DPN_OK)
	{
		if ((hResultCode = pHostPlayer->GetConnectionRef( &pConnection )) != DPN_OK)
		{
			DPFERR("Could not get host connection reference");
			DisplayDNError(0,hResultCode);
		}
		pHostPlayer->Release();
		pHostPlayer = NULL;
	}
	else
	{
		DPFERR("Could not find Host player");
		DisplayDNError(0,hResultCode);
	}

	//
	//	Send request
	//
	hResultCode = DNPerformRequest(	pdnObject,
									DN_MSG_INTERNAL_REQ_DESTROY_GROUP,
									pRefCountBuffer->BufferDescAddress(),
									pConnection,
									pHandleParent,
									&pRequest );

	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}

	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

	//
	//	Wait for SyncEvent or create async user HANDLE
	//
	if (dwFlags & DPNDESTROYGROUP_SYNC)
	{
		pRequest->SetSyncEvent( pSyncEvent );
		pRequest->SetResultPointer( &hrOperation );
		pRequest->Release();
		pRequest = NULL;

		pSyncEvent->WaitForEvent(INFINITE);
		pSyncEvent->ReturnSelfToPool();
		pSyncEvent = NULL;

		hResultCode = hrOperation;
	}
	else
	{
		pRequest->Release();
		pRequest = NULL;

		if (phAsyncOp)
		{
			*phAsyncOp = pHandleParent->GetHandle();
		}
		pHandleParent->SetCompletion( DNCompleteAsyncHandle );
		pHandleParent->SetContext( pvUserContext );
		pHandleParent->SetCannotCancel();
		pHandleParent->Release();
		pHandleParent = NULL;

		hResultCode = DPNERR_PENDING;
	}

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pHostPlayer)
	{
		pHostPlayer->Release();
		pHostPlayer = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	if (pRequest)
	{
		pRequest->Release();
		pRequest = NULL;
	}
	if (pHandleParent)
	{
		pHandleParent->Release();
		pHandleParent = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pSyncEvent)
	{
		pSyncEvent->ReturnSelfToPool();
		pSyncEvent = NULL;
	}
	goto Exit;
}



#undef DPF_MODNAME
#define DPF_MODNAME "DNRequestAddPlayerToGroup"

HRESULT DNRequestAddPlayerToGroup(DIRECTNETOBJECT *const pdnObject,
								  const DPNID dpnidGroup,
								  const DPNID dpnidPlayer,
								  PVOID const pvUserContext,
								  DPNHANDLE *const phAsyncOp,
								  const DWORD dwFlags)
{
	HRESULT				hResultCode;
	CAsyncOp			*pRequest;
	CAsyncOp			*pHandleParent;
	CSyncEvent			*pSyncEvent;
	CRefCountBuffer		*pRefCountBuffer;
	CPackedBuffer		packedBuffer;
	CNameTableEntry		*pHostPlayer;
	CConnection			*pConnection;
	HRESULT	volatile	hrOperation;
	DN_INTERNAL_MESSAGE_REQ_ADD_PLAYER_TO_GROUP	*pMsg;

	DPFX(DPFPREP, 4,"Parameters: dpnidGroup [0x%lx], dpnidPlayer [0x%lx], pvUserContext [0x%p], phAsyncOp [0x%p], dwFlags [0x%lx]",
			dpnidGroup,dpnidPlayer,pvUserContext,phAsyncOp,dwFlags);

	DNASSERT(pdnObject != NULL);
	DNASSERT(dpnidGroup != 0);

	pRequest = NULL;
	pHandleParent = NULL;
	pSyncEvent = NULL;
	pRefCountBuffer = NULL;
	pHostPlayer = NULL;
	pConnection = NULL;

	//
	//	Create REQUEST
	//
	if ((hResultCode = RefCountBufferNew(pdnObject,sizeof(DN_INTERNAL_MESSAGE_REQ_ADD_PLAYER_TO_GROUP),
			&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not allocate count buffer (request destroy group)");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pMsg = reinterpret_cast<DN_INTERNAL_MESSAGE_REQ_ADD_PLAYER_TO_GROUP*>(pRefCountBuffer->GetBufferAddress());
	pMsg->dpnidGroup = dpnidGroup;
	pMsg->dpnidPlayer = dpnidPlayer;

	//
	//	Create synchronization event if necessary
	//
	if (dwFlags & DPNADDPLAYERTOGROUP_SYNC)
	{
		if ((hResultCode = SyncEventNew(pdnObject,&pSyncEvent)) !=  DPN_OK)
		{
			DPFERR("Could not create synchronization event");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
	}
	else
	{
		if ((hResultCode = DNCreateUserHandle(pdnObject,&pHandleParent)) != DPN_OK)
		{
			DPFERR("Could not create user HANDLE");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
	}

	//
	//	Get host connection for request operation.
	//	We will procede even if we can't get it, just so that the operation will be re-tried at host migration
	//	or cancelled at close
	//
	if ((hResultCode = pdnObject->NameTable.GetHostPlayerRef( &pHostPlayer )) == DPN_OK)
	{
		if ((hResultCode = pHostPlayer->GetConnectionRef( &pConnection )) != DPN_OK)
		{
			DPFERR("Could not get host connection reference");
			DisplayDNError(0,hResultCode);
		}
		pHostPlayer->Release();
		pHostPlayer = NULL;
	}
	else
	{
		DPFERR("Could not find Host player");
		DisplayDNError(0,hResultCode);
	}

	//
	//	Send request
	//
	hResultCode = DNPerformRequest(	pdnObject,
									DN_MSG_INTERNAL_REQ_ADD_PLAYER_TO_GROUP,
									pRefCountBuffer->BufferDescAddress(),
									pConnection,
									pHandleParent,
									&pRequest );

	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}

	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

	//
	//	Wait for SyncEvent or create async user HANDLE
	//
	if (dwFlags & DPNADDPLAYERTOGROUP_SYNC)
	{
		pRequest->SetSyncEvent( pSyncEvent );
		pRequest->SetResultPointer( &hrOperation );
		pRequest->Release();
		pRequest = NULL;

		pSyncEvent->WaitForEvent(INFINITE);
		pSyncEvent->ReturnSelfToPool();
		pSyncEvent = NULL;

		hResultCode = hrOperation;
	}
	else
	{
		pRequest->Release();
		pRequest = NULL;

		if (phAsyncOp)
		{
			*phAsyncOp = pHandleParent->GetHandle();
		}
		pHandleParent->SetCompletion( DNCompleteAsyncHandle );
		pHandleParent->SetContext( pvUserContext );
		pHandleParent->SetCannotCancel();
		pHandleParent->Release();
		pHandleParent = NULL;

		hResultCode = DPNERR_PENDING;
	}

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pHostPlayer)
	{
		pHostPlayer->Release();
		pHostPlayer = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	if (pRequest)
	{
		pRequest->Release();
		pRequest = NULL;
	}
	if (pHandleParent)
	{
		pHandleParent->Release();
		pHandleParent = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pSyncEvent)
	{
		pSyncEvent->ReturnSelfToPool();
		pSyncEvent = NULL;
	}
	goto Exit;
}



#undef DPF_MODNAME
#define DPF_MODNAME "DNRequestDeletePlayerFromGroup"

HRESULT DNRequestDeletePlayerFromGroup(DIRECTNETOBJECT *const pdnObject,
									   const DPNID dpnidGroup,
									   const DPNID dpnidPlayer,
									   PVOID const pvUserContext,
									   DPNHANDLE *const phAsyncOp,
									   const DWORD dwFlags)
{
	HRESULT				hResultCode;
	CAsyncOp			*pRequest;
	CAsyncOp			*pHandleParent;
	CSyncEvent			*pSyncEvent;
	CRefCountBuffer		*pRefCountBuffer;
	CPackedBuffer		packedBuffer;
	CNameTableEntry		*pHostPlayer;
	CConnection			*pConnection;
	HRESULT	volatile	hrOperation;
	DN_INTERNAL_MESSAGE_REQ_DELETE_PLAYER_FROM_GROUP	*pMsg;

	DPFX(DPFPREP, 4,"Parameters: dpnidGroup [0x%lx], dpnidPlayer [0x%lx], pvUserContext [0x%p], phAsyncOp [0x%p], dwFlags [0x%lx]",
			dpnidGroup,dpnidPlayer,pvUserContext,phAsyncOp,dwFlags);

	DNASSERT(pdnObject != NULL);
	DNASSERT(dpnidGroup != 0);

	pRequest = NULL;
	pHandleParent = NULL;
	pSyncEvent = NULL;
	pRefCountBuffer = NULL;
	pHostPlayer = NULL;
	pConnection = NULL;

	//
	//	Create REQUEST
	//
	if ((hResultCode = RefCountBufferNew(pdnObject,sizeof(DN_INTERNAL_MESSAGE_REQ_DELETE_PLAYER_FROM_GROUP),
			&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not allocate count buffer (request destroy group)");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		return(hResultCode);
	}
	pMsg = reinterpret_cast<DN_INTERNAL_MESSAGE_REQ_DELETE_PLAYER_FROM_GROUP*>(pRefCountBuffer->GetBufferAddress());
	pMsg->dpnidGroup = dpnidGroup;
	pMsg->dpnidPlayer = dpnidPlayer;

	//
	//	Create synchronization event if necessary
	//
	if (dwFlags & DPNREMOVEPLAYERFROMGROUP_SYNC)
	{
		if ((hResultCode = SyncEventNew(pdnObject,&pSyncEvent)) !=  DPN_OK)
		{
			DPFERR("Could not create synchronization event");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
	}
	else
	{
		if ((hResultCode = DNCreateUserHandle(pdnObject,&pHandleParent)) != DPN_OK)
		{
			DPFERR("Could not create user HANDLE");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
	}

	//
	//	Get host connection for request operation.
	//	We will procede even if we can't get it, just so that the operation will be re-tried at host migration
	//	or cancelled at close
	//
	if ((hResultCode = pdnObject->NameTable.GetHostPlayerRef( &pHostPlayer )) == DPN_OK)
	{
		if ((hResultCode = pHostPlayer->GetConnectionRef( &pConnection )) != DPN_OK)
		{
			DPFERR("Could not get host connection reference");
			DisplayDNError(0,hResultCode);
		}
		pHostPlayer->Release();
		pHostPlayer = NULL;
	}
	else
	{
		DPFERR("Could not find Host player");
		DisplayDNError(0,hResultCode);
	}

	//
	//	Send request
	//
	hResultCode = DNPerformRequest(	pdnObject,
									DN_MSG_INTERNAL_REQ_DELETE_PLAYER_FROM_GROUP,
									pRefCountBuffer->BufferDescAddress(),
									pConnection,
									pHandleParent,
									&pRequest );

	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}

	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

	//
	//	Wait for SyncEvent or create async user HANDLE
	//
	if (dwFlags & DPNREMOVEPLAYERFROMGROUP_SYNC)
	{
		pRequest->SetSyncEvent( pSyncEvent );
		pRequest->SetResultPointer( &hrOperation );
		pRequest->Release();
		pRequest = NULL;

		pSyncEvent->WaitForEvent(INFINITE);
		pSyncEvent->ReturnSelfToPool();
		pSyncEvent = NULL;

		hResultCode = hrOperation;
	}
	else
	{
		pRequest->Release();
		pRequest = NULL;

		if (phAsyncOp)
		{
			*phAsyncOp = pHandleParent->GetHandle();
		}
		pHandleParent->SetCompletion( DNCompleteAsyncHandle );
		pHandleParent->SetContext( pvUserContext );
		pHandleParent->SetCannotCancel();
		pHandleParent->Release();
		pHandleParent = NULL;

		hResultCode = DPNERR_PENDING;
	}

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pHostPlayer)
	{
		pHostPlayer->Release();
		pHostPlayer = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	if (pRequest)
	{
		pRequest->Release();
		pRequest = NULL;
	}
	if (pHandleParent)
	{
		pHandleParent->Release();
		pHandleParent = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pSyncEvent)
	{
		pSyncEvent->ReturnSelfToPool();
		pSyncEvent = NULL;
	}
	goto Exit;
}



#undef DPF_MODNAME
#define DPF_MODNAME "DNRequestUpdateInfo"

HRESULT DNRequestUpdateInfo(DIRECTNETOBJECT *const pdnObject,
							const DPNID dpnid,
							const PWSTR pwszName,
							const DWORD dwNameSize,
							const PVOID pvData,
							const DWORD dwDataSize,
							const DWORD dwInfoFlags,
							PVOID const pvUserContext,
							DPNHANDLE *const phAsyncOp,
							const DWORD dwFlags)
{
	HRESULT				hResultCode;
	CAsyncOp			*pRequest;
	CAsyncOp			*pHandleParent;
	CSyncEvent			*pSyncEvent;
	CRefCountBuffer		*pRefCountBuffer;
	CPackedBuffer		packedBuffer;
	CNameTableEntry		*pHostPlayer;
	CConnection			*pConnection;
	HRESULT	volatile	hrOperation;
	DN_INTERNAL_MESSAGE_REQ_UPDATE_INFO	*pMsg;

	DPFX(DPFPREP, 4,"Parameters: pwszName [0x%p], pvData [0x%p], dwInfoFlags [%ld], dwGroupFlags [0x%lx], pvUserContext [0x%p], dwFlags [0x%lx]",
		pwszName,pvData,dwDataSize,dwInfoFlags,pvUserContext,dwFlags);

	DNASSERT(pdnObject != NULL);

	pRequest = NULL;
	pHandleParent = NULL;
	pSyncEvent = NULL;
	pRefCountBuffer = NULL;
	pHostPlayer = NULL;
	pConnection = NULL;

	//
	//	Create REQUEST
	//
	// Create buffer
	if ((hResultCode = RefCountBufferNew(pdnObject,
			sizeof(DN_INTERNAL_MESSAGE_REQ_UPDATE_INFO) + dwNameSize + dwDataSize,&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not create new RefCountBuffer");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		return(hResultCode);
	}
	packedBuffer.Initialize(pRefCountBuffer->GetBufferAddress(),pRefCountBuffer->GetBufferSize());
	pMsg = static_cast<DN_INTERNAL_MESSAGE_REQ_UPDATE_INFO*>(packedBuffer.GetHeadAddress());
	if ((hResultCode = packedBuffer.AddToFront(NULL,sizeof(DN_INTERNAL_MESSAGE_REQ_UPDATE_INFO))) != DPN_OK)
	{
		DPFERR("Could not reserve space at front of buffer");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
		return(hResultCode);
	}

	// Add Name
	if ((dwInfoFlags & DPNINFO_NAME) && dwNameSize)
	{
		if ((hResultCode = packedBuffer.AddToBack(pwszName,dwNameSize)) != DPN_OK)
		{
			DPFERR("Could not add Name to packed buffer");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			pRefCountBuffer->Release();
			pRefCountBuffer = NULL;
			return(hResultCode);
		}
		pMsg->dwNameOffset = packedBuffer.GetTailOffset();
		pMsg->dwNameSize = dwNameSize;
	}
	else
	{
		pMsg->dwNameOffset = 0;
		pMsg->dwNameSize = 0;
	}

	// Add Data
	if ((dwInfoFlags & DPNINFO_DATA) && dwDataSize)
	{
		if ((hResultCode = packedBuffer.AddToBack(pvData,dwDataSize)) != DPN_OK)
		{
			DPFERR("Could not add Data to packed buffer");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			pRefCountBuffer->Release();
			pRefCountBuffer = NULL;
			return(hResultCode);
		}
		pMsg->dwDataOffset = packedBuffer.GetTailOffset();
		pMsg->dwDataSize = dwDataSize;
	}
	else
	{
		pMsg->dwDataOffset = 0;
		pMsg->dwDataSize = 0;
	}

	// Remaining fields
	pMsg->dpnid = dpnid;
	pMsg->dwInfoFlags = dwInfoFlags;

	//
	//	Create synchronization event if necessary
	//
	DBG_CASSERT( DPNSETGROUPINFO_SYNC == DPNSETCLIENTINFO_SYNC );
	DBG_CASSERT( DPNSETCLIENTINFO_SYNC == DPNSETSERVERINFO_SYNC );
	DBG_CASSERT( DPNSETSERVERINFO_SYNC == DPNSETPEERINFO_SYNC );
	if (dwFlags & (DPNSETGROUPINFO_SYNC | DPNSETCLIENTINFO_SYNC | DPNSETSERVERINFO_SYNC | DPNSETPEERINFO_SYNC))
	{
		if ((hResultCode = SyncEventNew(pdnObject,&pSyncEvent)) !=  DPN_OK)
		{
			DPFERR("Could not create synchronization event");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
	}
	else
	{
		if ((hResultCode = DNCreateUserHandle(pdnObject,&pHandleParent)) != DPN_OK)
		{
			DPFERR("Could not create user HANDLE");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
	}

	//
	//	Get host connection for request operation.
	//	We will procede even if we can't get it, just so that the operation will be re-tried at host migration
	//	or cancelled at close
	//
	if ((hResultCode = pdnObject->NameTable.GetHostPlayerRef( &pHostPlayer )) == DPN_OK)
	{
		if ((hResultCode = pHostPlayer->GetConnectionRef( &pConnection )) != DPN_OK)
		{
			DPFERR("Could not get host connection reference");
			DisplayDNError(0,hResultCode);
		}
		pHostPlayer->Release();
		pHostPlayer = NULL;
	}
	else
	{
		DPFERR("Could not find Host player");
		DisplayDNError(0,hResultCode);
	}

	//
	//	Send request
	//
	hResultCode = DNPerformRequest(	pdnObject,
									DN_MSG_INTERNAL_REQ_UPDATE_INFO,
									pRefCountBuffer->BufferDescAddress(),
									pConnection,
									pHandleParent,
									&pRequest );

	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}

	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

	//
	//	Wait for SyncEvent or create async user HANDLE
	//
	DBG_CASSERT( DPNSETGROUPINFO_SYNC == DPNSETCLIENTINFO_SYNC );
	DBG_CASSERT( DPNSETCLIENTINFO_SYNC == DPNSETSERVERINFO_SYNC );
	DBG_CASSERT( DPNSETSERVERINFO_SYNC == DPNSETPEERINFO_SYNC );
	if (dwFlags & (DPNSETGROUPINFO_SYNC | DPNSETCLIENTINFO_SYNC | DPNSETSERVERINFO_SYNC | DPNSETPEERINFO_SYNC))
	{
		pRequest->SetSyncEvent( pSyncEvent );
		pRequest->SetResultPointer( &hrOperation );
		pRequest->Release();
		pRequest = NULL;

		pSyncEvent->WaitForEvent(INFINITE);
		pSyncEvent->ReturnSelfToPool();
		pSyncEvent = NULL;

		hResultCode = hrOperation;
	}
	else
	{
		pRequest->Release();
		pRequest = NULL;

		if (phAsyncOp)
		{
			*phAsyncOp = pHandleParent->GetHandle();
		}
		pHandleParent->SetCompletion( DNCompleteAsyncHandle );
		pHandleParent->SetContext( pvUserContext );
		pHandleParent->SetCannotCancel();
		pHandleParent->Release();
		pHandleParent = NULL;

		hResultCode = DPNERR_PENDING;
	}

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pHostPlayer)
	{
		pHostPlayer->Release();
		pHostPlayer = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	if (pRequest)
	{
		pRequest->Release();
		pRequest = NULL;
	}
	if (pHandleParent)
	{
		pHandleParent->Release();
		pHandleParent = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pSyncEvent)
	{
		pSyncEvent->ReturnSelfToPool();
		pSyncEvent = NULL;
	}
	goto Exit;
}


//	DNRequestIntegrityCheck
//
//	In the case where a non-host player detects a disconnect from another non-host player,
//	the detecting player will request the host to perform an integrity check to prevent a
//	disjoint game from occurring.  The host will ping the disconnected player, and if a
//	response is received, the host will disconnect the detecting player.  If no response
//	is received, presumably the disconnected player is in fact dropping, and a DESTROY_PLAYER
//	message will be sent out.

#undef DPF_MODNAME
#define DPF_MODNAME "DNRequestIntegrityCheck"

HRESULT DNRequestIntegrityCheck(DIRECTNETOBJECT *const pdnObject,
								const DPNID dpnidTarget)
{
	HRESULT			hResultCode;
	CRefCountBuffer	*pRefCountBuffer;
	CNameTableEntry	*pHostPlayer;
	CNameTableEntry	*pNTEntry;
	CConnection		*pConnection;
	CAsyncOp		*pRequest;
	DN_INTERNAL_MESSAGE_REQ_INTEGRITY_CHECK	*pMsg;

	DPFX(DPFPREP, 6,"Parameters: dpnidTarget [0x%lx]",dpnidTarget);

	pRefCountBuffer = NULL;
	pHostPlayer = NULL;
	pNTEntry = NULL;
	pConnection = NULL;
	pRequest = NULL;

	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->dwFlags & (DN_OBJECT_FLAG_CLOSING | DN_OBJECT_FLAG_DISCONNECTING))
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		DPFERR("Closing - aborting");
		hResultCode = DPN_OK;
		goto Failure;
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	//
	//	Determine if player is still in NameTable - maybe the Host has already deleteed him
	//
	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnidTarget,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Target player not in NameTable");
		DisplayDNError(0,hResultCode);
		hResultCode = DPN_OK;
		goto Failure;
	}
	pNTEntry->Lock();
	if (!pNTEntry->IsAvailable())
	{
		pNTEntry->Unlock();
		hResultCode = DPN_OK;
		goto Failure;
	}
	pNTEntry->Unlock();
	pNTEntry->Release();
	pNTEntry = NULL;

	//
	//	Create request message
	//
	if ((hResultCode = RefCountBufferNew(pdnObject,sizeof(DN_INTERNAL_MESSAGE_REQ_INTEGRITY_CHECK),&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not create RefCountBuffer");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pMsg = reinterpret_cast<DN_INTERNAL_MESSAGE_REQ_INTEGRITY_CHECK*>(pRefCountBuffer->GetBufferAddress());
	pMsg->dpnidTarget = dpnidTarget;

	//
	//	Get host connection for request operation
	//
	if ((hResultCode = pdnObject->NameTable.GetHostPlayerRef( &pHostPlayer )) != DPN_OK)
	{
		DPFERR("Could not get host player reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	if ((hResultCode = pHostPlayer->GetConnectionRef( &pConnection )) != DPN_OK)
	{
		DPFERR("Could not get host connection reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pHostPlayer->Release();
	pHostPlayer = NULL;

	//
	//	Send request
	//
	if ((hResultCode = DNPerformRequest(pdnObject,
										DN_MSG_INTERNAL_REQ_INTEGRITY_CHECK,
										pRefCountBuffer->BufferDescAddress(),
										pConnection,
										NULL,
										&pRequest)) != DPNERR_PENDING)
	{
		DPFERR("Could not perform request (INTEGRITY_CHECK)");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pConnection->Release();
	pConnection = NULL;
	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

	pRequest->Release();
	pRequest = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pHostPlayer)
	{
		pHostPlayer->Release();
		pHostPlayer = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	if (pRequest)
	{
		pRequest->Release();
		pRequest = NULL;
	}
	goto Exit;
}


//	HOST OPERATIONS
//
//	The Host will perform an operation and if in PEER mode, will inform
//	other players of the operation.   These messages will contain the
//	DPNID of the player requesting the operation along with the HANDLE
//	supplied with the request.


#undef DPF_MODNAME
#define DPF_MODNAME "DNHostProcessRequest"

HRESULT DNHostProcessRequest(DIRECTNETOBJECT *const pdnObject,
							 const DWORD dwMsgId,
							 PVOID const pv,
							 const DPNID dpnidRequesting)
{
	HRESULT	hResultCode;
	UNALIGNED DN_INTERNAL_MESSAGE_REQ_PROCESS_COMPLETION			*pRequest;

	DPFX(DPFPREP, 6,"Parameters: dwMsgId [0x%lx], pv [0x%p], dpnidRequesting [0x%lx]",
			dwMsgId,pv,dpnidRequesting);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pv != NULL);
	DNASSERT(dpnidRequesting != 0);

	pRequest = static_cast<DN_INTERNAL_MESSAGE_REQ_PROCESS_COMPLETION*>(pv);

	switch(dwMsgId)
	{
	case DN_MSG_INTERNAL_REQ_CREATE_GROUP:
		{
			UNALIGNED DN_INTERNAL_MESSAGE_REQ_CREATE_GROUP	*pCreateGroup;
			PWSTR	pwszName;
			PVOID	pvData;

			DPFX(DPFPREP, 7,"DN_MSG_INTERNAL_REQ_CREATE_GROUP");

			pCreateGroup = reinterpret_cast<DN_INTERNAL_MESSAGE_REQ_CREATE_GROUP*>(pRequest + 1);
			if (pCreateGroup->dwNameSize)
			{
				pwszName = reinterpret_cast<WCHAR*>(reinterpret_cast<BYTE*>(pCreateGroup) + pCreateGroup->dwNameOffset);
			}
			else
			{
				pwszName = NULL;
			}
			if (pCreateGroup->dwDataSize)
			{
				pvData = static_cast<void*>(reinterpret_cast<BYTE*>(pCreateGroup) + pCreateGroup->dwDataOffset);
			}
			else
			{
				pvData = NULL;
			}
			DNHostCreateGroup(	pdnObject,
								pwszName,
								pCreateGroup->dwNameSize,
								pvData,
								pCreateGroup->dwDataSize,
								pCreateGroup->dwInfoFlags,
								pCreateGroup->dwGroupFlags,
								NULL,
								NULL,
								dpnidRequesting,
								pRequest->hCompletionOp,
								NULL,
								0 );

			break;
		}

	case DN_MSG_INTERNAL_REQ_DESTROY_GROUP:
		{
			UNALIGNED DN_INTERNAL_MESSAGE_REQ_DESTROY_GROUP	*pDestroyGroup;

			DPFX(DPFPREP, 7,"DN_MSG_INTERNAL_REQ_DESTROY_GROUP");

			pDestroyGroup = reinterpret_cast<DN_INTERNAL_MESSAGE_REQ_DESTROY_GROUP*>(pRequest + 1);

			DNHostDestroyGroup(	pdnObject,
								pDestroyGroup->dpnidGroup,
								NULL,
								dpnidRequesting,
								pRequest->hCompletionOp,
								NULL,
								0 );
								
			break;
		}

	case DN_MSG_INTERNAL_REQ_ADD_PLAYER_TO_GROUP:
		{
			UNALIGNED DN_INTERNAL_MESSAGE_REQ_ADD_PLAYER_TO_GROUP	*pAddPlayerToGroup;

			DPFX(DPFPREP, 7,"DN_MSG_INTERNAL_REQ_ADD_PLAYER_TO_GROUP");

			pAddPlayerToGroup = reinterpret_cast<DN_INTERNAL_MESSAGE_REQ_ADD_PLAYER_TO_GROUP*>(pRequest + 1);

			DNHostAddPlayerToGroup(	pdnObject,
									pAddPlayerToGroup->dpnidGroup,
									pAddPlayerToGroup->dpnidPlayer,
									NULL,
									dpnidRequesting,
									pRequest->hCompletionOp,
									NULL,
									0 );

			break;
		}

	case DN_MSG_INTERNAL_REQ_DELETE_PLAYER_FROM_GROUP:
		{
			UNALIGNED DN_INTERNAL_MESSAGE_REQ_DELETE_PLAYER_FROM_GROUP	*pDeletePlayerFromGroup;

			DPFX(DPFPREP, 7,"DN_MSG_INTERNAL_REQ_DELETE_PLAYER_FROM_GROUP");

			pDeletePlayerFromGroup = reinterpret_cast<DN_INTERNAL_MESSAGE_REQ_DELETE_PLAYER_FROM_GROUP*>(pRequest + 1);

			DNHostDeletePlayerFromGroup(pdnObject,
										pDeletePlayerFromGroup->dpnidGroup,
										pDeletePlayerFromGroup->dpnidPlayer,
										NULL,
										dpnidRequesting,
										pRequest->hCompletionOp,
										NULL,
										0);

			break;
		}

	case DN_MSG_INTERNAL_REQ_UPDATE_INFO:
		{
			UNALIGNED DN_INTERNAL_MESSAGE_REQ_UPDATE_INFO	*pUpdateInfo;
			PWSTR	pwszName;
			PVOID	pvData;

			DPFX(DPFPREP, 7,"DN_MSG_INTERNAL_REQ_UPDATE_INFO");

			pUpdateInfo = reinterpret_cast<DN_INTERNAL_MESSAGE_REQ_UPDATE_INFO*>(pRequest + 1);
			if (pUpdateInfo->dwNameSize)
			{
				pwszName = reinterpret_cast<WCHAR*>(reinterpret_cast<BYTE*>(pUpdateInfo) + pUpdateInfo->dwNameOffset);
			}
			else
			{
				pwszName = NULL;
			}
			if (pUpdateInfo->dwDataSize)
			{
				pvData = reinterpret_cast<void*>(reinterpret_cast<BYTE*>(pUpdateInfo) + pUpdateInfo->dwDataOffset);
			}
			else
			{
				pvData = NULL;
			}
			DNHostUpdateInfo(pdnObject,
							pUpdateInfo->dpnid,
							pwszName,
							pUpdateInfo->dwNameSize,
							pvData,
							pUpdateInfo->dwDataSize,
							pUpdateInfo->dwInfoFlags,
							NULL,
							dpnidRequesting,
							pRequest->hCompletionOp,
							NULL,
							0);

			break;
		}

	case DN_MSG_INTERNAL_REQ_INTEGRITY_CHECK:
		{
			UNALIGNED DN_INTERNAL_MESSAGE_REQ_INTEGRITY_CHECK	*pIntegrityCheck;
			CNameTableEntry	*pLocalPlayer;

			DPFX(DPFPREP, 7,"DN_MSG_INTERNAL_REQ_INTEGRITY_CHECK");

			pIntegrityCheck = reinterpret_cast<DN_INTERNAL_MESSAGE_REQ_INTEGRITY_CHECK*>(pRequest + 1);

			//
			//	If we submitted this request, this is being called during host migration,
			//	so remove it from the handle table since we will destroy the dropped player anyways.
			//	Otherwise, we will perform the integrity check
			//

			if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) == DPN_OK)
			{
				if (pLocalPlayer->GetDPNID() == dpnidRequesting)
				{
					pdnObject->HandleTable.Destroy( pRequest->hCompletionOp );
				}
				else
				{
					DNHostCheckIntegrity(pdnObject,pIntegrityCheck->dpnidTarget,dpnidRequesting);
				}
				pLocalPlayer->Release();
				pLocalPlayer = NULL;
			}
			break;
		}

	default:
		{
			DPFERR("How did we get here ?");
			DNASSERT(FALSE);
		}
	}

	DPFX(DPFPREP, 6,"Returning: DPN_OK");
	return(DPN_OK);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNHostFailRequest"

void DNHostFailRequest(DIRECTNETOBJECT *const pdnObject,
					   const DPNID dpnid,
					   const DPNHANDLE hCompletionOp,
					   const HRESULT hr)
{
	HRESULT			hResultCode;
	CNameTableEntry	*pNTEntry;
	CRefCountBuffer	*pRefCountBuffer;
	CConnection		*pConnection;
	DN_INTERNAL_MESSAGE_REQUEST_FAILED	*pMsg;

	DNASSERT(pdnObject != NULL);
	DNASSERT(dpnid != NULL);

	pNTEntry = NULL;
	pRefCountBuffer = NULL;
	pConnection = NULL;

	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnid,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not find NameTableEntry");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	if ((hResultCode = RefCountBufferNew(pdnObject,sizeof(DN_INTERNAL_MESSAGE_REQUEST_FAILED),&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not create new RefCountBuffer");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pMsg = reinterpret_cast<DN_INTERNAL_MESSAGE_REQUEST_FAILED*>(pRefCountBuffer->GetBufferAddress());
	pMsg->hCompletionOp = hCompletionOp;
	pMsg->hResultCode = hr;

	if ((hResultCode = pNTEntry->GetConnectionRef( &pConnection )) == DPN_OK)
	{
		hResultCode = DNSendMessage(pdnObject,
									pConnection,
									DN_MSG_INTERNAL_REQUEST_FAILED,
									dpnid,
									pRefCountBuffer->BufferDescAddress(),
									pRefCountBuffer,
									0,
									DN_SENDFLAGS_RELIABLE,
									NULL,
									NULL);

		pConnection->Release();
		pConnection = NULL;
	}

	pNTEntry->Release();
	pNTEntry = NULL;

	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

Exit:
	return;

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	goto Exit;
}



#undef DPF_MODNAME
#define DPF_MODNAME "DNHostCreateGroup"

HRESULT	DNHostCreateGroup(DIRECTNETOBJECT *const pdnObject,
						  PWSTR pwszName,
						  const DWORD dwNameSize,
						  void *const pvData,
						  const DWORD dwDataSize,
						  const DWORD dwInfoFlags,
						  const DWORD dwGroupFlags,
						  void *const pvGroupContext,
						  void *const pvUserContext,
						  const DPNID dpnidOwner,
						  const DPNHANDLE hCompletionOp,
						  DPNHANDLE *const phAsyncOp,
						  const DWORD dwFlags)
{
	HRESULT			hResultCode;
	HRESULT			hrOperation;
	void			*pvContext;
	BOOL			fHostRequested;
	CNameTableEntry	*pLocalPlayer;
	CNameTableEntry	*pNTEntry;
	CPackedBuffer	packedBuffer;
	CRefCountBuffer	*pRefCountBuffer;
	CAsyncOp		*pHandleParent;
	CAsyncOp		*pRequest;
	CWorkerJob		*pWorkerJob;
	DN_INTERNAL_MESSAGE_CREATE_GROUP	*pMsg;

	DPFX(DPFPREP, 4,"Parameters: pwszName [0x%p], dwNameSize [%ld], pvData [0x%p], dwDataSize [%ld], dwInfoFlags [0x%lx], dwGroupFlags [0x%lx], pvGroupContext [0x%p], pvUserContext [0x%p], dpnidOwner [0x%lx], hCompletionOp [0x%lx], phAsyncOp [0x%p], dwFlags [0x%lx]",
			pwszName,dwNameSize,pvData,dwDataSize,dwInfoFlags,dwGroupFlags,pvGroupContext,pvUserContext,dpnidOwner,hCompletionOp,phAsyncOp,dwFlags);

	DNASSERT(pdnObject != NULL);

	//
	//	If this is called from DN_CreateGroup(),
	//			hCompletion=0
	//			dpnidOwner = DPNID of Host
	//			pvGroupContext is valid
	//			pvUserContext is valid
	//
	//	If this is called by a REQUEST,
	//			hCompletion = REQUEST handle of requesting player
	//			dpnidOwner = DPNID of requesting player
	//			pvGroupContext is not valid
	//
	//	If this is called at HostMigration,
	//			hCompletion = REQUEST handle on THIS (now Host) player
	//			dpnidOwner = DPNID of THIS (now Host) player
	//			pvGroupContext is invalid
	//			pvUserContext is invalid
	//

	pLocalPlayer = NULL;
	pNTEntry = NULL;
	pRefCountBuffer = NULL;
	pWorkerJob = NULL;
	pHandleParent = NULL;
	pRequest = NULL;

	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		return(DPN_OK);	// Ignore and continue (!)
	}
	if (pLocalPlayer->GetDPNID() == dpnidOwner)
	{
		fHostRequested = TRUE;
	}
	else
	{
		fHostRequested = FALSE;
	}
	pLocalPlayer->Release();
	pLocalPlayer = NULL;

	//
	//	Get group context if this is a Host Migration re-try by finding REQUEST AsyncOp
	//
	if ((fHostRequested) && (hCompletionOp != 0))
	{
		if ((hResultCode = pdnObject->HandleTable.Find( hCompletionOp,&pRequest )) != DPN_OK)
		{
			DPFERR("Could not find REQUEST AsyncOp");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pvContext = pRequest->GetContext();
		pRequest->Release();
		pRequest = NULL;
	}
	else
	{
		pvContext = pvGroupContext;
	}

	//
	//	Create and fill in NameTableEntry
	//
	if ((hResultCode = NameTableEntryNew(pdnObject,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not create new NameTableEntry");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pNTEntry->MakeGroup();

	// This function takes the lock internally
	pNTEntry->UpdateEntryInfo(pwszName,dwNameSize,pvData,dwDataSize,dwInfoFlags, FALSE);

	pNTEntry->SetOwner( dpnidOwner );
	pNTEntry->SetContext( pvContext );

	if (dwGroupFlags & DPNGROUP_AUTODESTRUCT)
	{
		pNTEntry->MakeAutoDestructGroup();
	}

	//
	//	Add Group to NameTable
	//
#pragma TODO(minara,"Check to see if Autodestruct owner is still in NameTable")
#pragma TODO(minara,"This should happen after getting a NameTable version number - as DESTROY player will clean up")
#pragma TODO(minara,"We should send out a NOP in this case")

	hrOperation = pdnObject->NameTable.AddEntry(pNTEntry);
	if (hrOperation != DPN_OK)
	{
		DPFERR("Could not add NameTableEntry to NameTable");
		DisplayDNError(0,hResultCode);
		if (!fHostRequested)
		{
			DNHostFailRequest(pdnObject,dpnidOwner,hCompletionOp,hrOperation);
		}
	}
	else
	{
		BOOL	fNotify;

		fNotify = FALSE;
		pNTEntry->Lock();
		if (!pNTEntry->IsAvailable() && !pNTEntry->IsDisconnecting())
		{
			pNTEntry->MakeAvailable();
			pNTEntry->NotifyAddRef();
			pNTEntry->NotifyAddRef();
			pNTEntry->SetInUse();
			fNotify = TRUE;
		}
		pNTEntry->Unlock();

		if (fNotify)
		{
			DNUserCreateGroup(pdnObject,pNTEntry);

			pNTEntry->PerformQueuedOperations();

			pdnObject->NameTable.PopulateGroup( pNTEntry );
		}

		//
		//	Send CREATE_GROUP message
		//
		if (pdnObject->dwFlags & DN_OBJECT_FLAG_PEER)
		{
			// Determine size of message
			packedBuffer.Initialize(NULL,0);
			packedBuffer.AddToFront(NULL,sizeof(DN_INTERNAL_MESSAGE_CREATE_GROUP));
			pNTEntry->PackEntryInfo(&packedBuffer);

			// Create buffer
			if ((hResultCode = RefCountBufferNew(pdnObject,packedBuffer.GetSizeRequired(),&pRefCountBuffer)) != DPN_OK)
			{
				DPFERR("Could not create RefCountBuffer");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
				goto Failure;
			}
			packedBuffer.Initialize(pRefCountBuffer->GetBufferAddress(),pRefCountBuffer->GetBufferSize());
			pMsg = static_cast<DN_INTERNAL_MESSAGE_CREATE_GROUP*>(packedBuffer.GetHeadAddress());
			if ((hResultCode = packedBuffer.AddToFront(NULL,sizeof(DN_INTERNAL_MESSAGE_CREATE_GROUP))) != DPN_OK)
			{
				DPFERR("Could not reserve front of buffer");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
				goto Failure;
			}
			if ((hResultCode = pNTEntry->PackEntryInfo(&packedBuffer)) != DPN_OK)
			{
				DPFERR("Could not pack NameTableEntry");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
				goto Failure;
			}
			pMsg->dpnidRequesting = dpnidOwner;
			pMsg->hCompletionOp = hCompletionOp;

			//
			//	SEND CreateGroup messages via WorkerThread
			//
			if ((hResultCode = WorkerJobNew(pdnObject,&pWorkerJob)) != DPN_OK)
			{
				DPFERR("Could not create new WorkerJob");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
				goto Failure;
			}
			pWorkerJob->SetJobType( WORKER_JOB_SEND_NAMETABLE_OPERATION );
			pWorkerJob->SetSendNameTableOperationMsgId( DN_MSG_INTERNAL_CREATE_GROUP );
			pWorkerJob->SetSendNameTableOperationVersion( pNTEntry->GetVersion() );
			pWorkerJob->SetSendNameTableOperationDPNIDExclude( 0 );
			pWorkerJob->SetRefCountBuffer( pRefCountBuffer );

			DNQueueWorkerJob(pdnObject,pWorkerJob);
			pWorkerJob = NULL;

			pRefCountBuffer->Release();
			pRefCountBuffer = NULL;
		}
	}

	pNTEntry->Release();
	pNTEntry = NULL;

	//
	//	If this was called by the local (Host) player,
	//	Check to see if this was an original operation or a re-try from HostMigration
	//
	//	If this was an original operation,
	//		See if we need an Async HANDLE for the user
	//	Otherwise
	//		Clean up the outstanding operation
	//
	if (fHostRequested)
	{
		if (hCompletionOp == 0)		// Original
		{
			//
			//	If this fails, or is synchronous, return the operation result immediately
			//
			if (!(dwFlags & DPNCREATEGROUP_SYNC) && (hrOperation == DPN_OK))
			{
				if ((hResultCode = DNCreateUserHandle(pdnObject,&pHandleParent)) != DPN_OK)
				{
					DPFERR("Could not create Async HANDLE");
					DisplayDNError(0,hResultCode);
					DNASSERT(FALSE);
					goto Failure;
				}
				pHandleParent->SetCompletion( DNCompleteAsyncHandle );
				pHandleParent->SetContext( pvUserContext );
				pHandleParent->SetResult( hrOperation );
				pHandleParent->SetCannotCancel();
				*phAsyncOp = pHandleParent->GetHandle();
				pHandleParent->Release();
				pHandleParent = NULL;

				hResultCode = DPNERR_PENDING;
			}
			else
			{
				hResultCode = hrOperation;
			}
		}
		else						// Host Migration re-try
		{
			if ((hResultCode = pdnObject->HandleTable.Find( hCompletionOp, &pRequest )) == DPN_OK)
			{
				pRequest->SetResult( hrOperation );
				pRequest->Release();
				pRequest = NULL;
				pdnObject->HandleTable.Destroy( hCompletionOp );
			}

			hResultCode = DPN_OK;
		}
	}
	else
	{
		hResultCode = DPN_OK;
	}

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (!fHostRequested)
	{
		DNHostFailRequest(pdnObject,dpnidOwner,hCompletionOp,hrOperation);
	}
	else
	{
		//
		//	If a completion op was specified and this was requested by the Host, this is a
		//	retry of an operation during Host migration.  In this case, we want to set the
		//	result (failure code) of the completion op, and remove it from the HandleTable.
		//
		if (hCompletionOp)
		{
			CAsyncOp	*pHostCompletionOp;

			pHostCompletionOp = NULL;
			if (pdnObject->HandleTable.Find(hCompletionOp,&pHostCompletionOp) == DPN_OK)
			{
				pHostCompletionOp->SetResult( hResultCode );
				pHostCompletionOp->Release();
				pHostCompletionOp = NULL;
				pdnObject->HandleTable.Destroy( hCompletionOp );
			}

			DNASSERT(pHostCompletionOp == NULL);
		}
	}
	if (pHandleParent)
	{
		pHandleParent->Release();
		pHandleParent = NULL;
	}
	if (pRequest)
	{
		pRequest->Release();
		pRequest = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNHostDestroyGroup"

HRESULT	DNHostDestroyGroup(DIRECTNETOBJECT *const pdnObject,
						   const DPNID dpnid,
						   void *const pvUserContext,
						   const DPNID dpnidRequesting,
						   const DPNHANDLE hCompletionOp,
						   DPNHANDLE *const phAsyncOp,
						   const DWORD dwFlags)
{
	HRESULT			hResultCode;
	HRESULT			hrOperation;
	DWORD			dwVersion;
	BOOL			fHostRequested;
	CNameTableEntry	*pLocalPlayer;
	CRefCountBuffer	*pRefCountBuffer;
	CAsyncOp		*pHandleParent;
	CWorkerJob		*pWorkerJob;
	DN_INTERNAL_MESSAGE_DESTROY_GROUP	*pMsg;

	DPFX(DPFPREP, 4,"Parameters: dpnid [0x%lx], pvUserContext [0x%p], dpnidRequesting [0x%lx], hCompletionOp [0x%lx], phAsyncOp [0x%p], dwFlags [0x%lx]",
			dpnid,pvUserContext,dpnidRequesting,hCompletionOp,phAsyncOp,dwFlags);

	DNASSERT(pdnObject != NULL);
	DNASSERT(dpnid != 0);
	DNASSERT(dpnidRequesting != 0);

	//
	//	If this is called from DN_DestroyGroup(),
	//			hCompletion=0
	//			dpnidRequesting = DPNID of Host
	//			pvUserContext is valid
	//
	//	If this is called by a REQUEST,
	//			hCompletion = REQUEST handle of requesting player
	//			dpnidRequesting = DPNID of requesting player
	//			pvUserContext is not valid
	//
	//	If this is called at HostMigration,
	//			hCompletion = REQUEST handle on THIS (now Host) player
	//			dpnidRequesting = DPNID of THIS (now Host) player
	//			pvUserContext is invalid
	//

	pLocalPlayer = NULL;
	pRefCountBuffer = NULL;
	pHandleParent = NULL;
	pWorkerJob = NULL;

	//
	//	Determine if this is being requested by the Host
	//
	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		return(DPN_OK);	// Ignore and continue (!)
	}
	if (pLocalPlayer->GetDPNID() == dpnidRequesting)
	{
		fHostRequested = TRUE;
	}
	else
	{
		fHostRequested = FALSE;
	}
	pLocalPlayer->Release();
	pLocalPlayer = NULL;

	//
	//	Remove Group from NameTable
	//
	dwVersion = 0;
	hrOperation = pdnObject->NameTable.DeleteGroup(dpnid,&dwVersion);
	if (hrOperation != DPN_OK)
	{
		DPFERR("Could not delete group from NameTable");
		DisplayDNError(0,hResultCode);
		if (!fHostRequested)
		{
			DNHostFailRequest(pdnObject,dpnidRequesting,hCompletionOp,hrOperation);
		}
	}
	else
	{
		//
		//	Send DESTROY_GROUP message
		//
		if (pdnObject->dwFlags & DN_OBJECT_FLAG_PEER)
		{
			// Create buffer
			if ((hResultCode = RefCountBufferNew(pdnObject,sizeof(DN_INTERNAL_MESSAGE_DESTROY_GROUP),&pRefCountBuffer)) != DPN_OK)
			{
				DPFERR("Could not create RefCountBuffer");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
				goto Failure;
			}
			pMsg = reinterpret_cast<DN_INTERNAL_MESSAGE_DESTROY_GROUP*>(pRefCountBuffer->GetBufferAddress());
			pMsg->dpnidGroup = dpnid;
			pMsg->dwVersion = dwVersion;
			pMsg->dwVersionNotUsed = 0;
			pMsg->dpnidRequesting = dpnidRequesting;
			pMsg->hCompletionOp = hCompletionOp;

			//
			//	SEND DestroyGroup messages via WorkerThread
			//
			if ((hResultCode = WorkerJobNew(pdnObject,&pWorkerJob)) != DPN_OK)
			{
				DPFERR("Could not create new WorkerJob");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
				goto Failure;
			}
			pWorkerJob->SetJobType( WORKER_JOB_SEND_NAMETABLE_OPERATION );
			pWorkerJob->SetSendNameTableOperationMsgId( DN_MSG_INTERNAL_DESTROY_GROUP );
			pWorkerJob->SetSendNameTableOperationVersion( dwVersion );
			pWorkerJob->SetSendNameTableOperationDPNIDExclude( 0 );
			pWorkerJob->SetRefCountBuffer( pRefCountBuffer );

			DNQueueWorkerJob(pdnObject,pWorkerJob);
			pWorkerJob = NULL;

			pRefCountBuffer->Release();
			pRefCountBuffer = NULL;
		}
	}

	//
	//	If this was called by the local (Host) player,
	//	Check to see if this was an original operation or a re-try from HostMigration
	//
	//	If this was an original operation,
	//		See if we need an Async HANDLE for the user
	//	Otherwise
	//		Clean up the outstanding operation
	//
	if (fHostRequested)
	{
		if (hCompletionOp == 0)		// Original
		{
			//
			//	If this fails, or is synchronous, return the operation result immediately
			//
			if (!(dwFlags & DPNDESTROYGROUP_SYNC) && (hrOperation == DPN_OK))
			{
				if ((hResultCode = DNCreateUserHandle(pdnObject,&pHandleParent)) != DPN_OK)
				{
					DPFERR("Could not create Async HANDLE");
					DisplayDNError(0,hResultCode);
					DNASSERT(FALSE);
					goto Failure;
				}
				pHandleParent->SetCompletion( DNCompleteAsyncHandle );
				pHandleParent->SetContext( pvUserContext );
				pHandleParent->SetResult( hrOperation );
				pHandleParent->SetCannotCancel();
				*phAsyncOp = pHandleParent->GetHandle();
				pHandleParent->Release();
				pHandleParent = NULL;

				hResultCode = DPNERR_PENDING;
			}
			else
			{
				hResultCode = hrOperation;
			}
		}
		else						// Host Migration re-try
		{
			CAsyncOp	*pRequest;

			pRequest = NULL;

			if ((hResultCode = pdnObject->HandleTable.Find( hCompletionOp,&pRequest )) == DPN_OK)
			{
				pRequest->SetResult( hrOperation );
				pRequest->Release();
				pRequest = NULL;
				pdnObject->HandleTable.Destroy( hCompletionOp );
			}

			hResultCode = DPN_OK;
		}
	}
	else
	{
		hResultCode = DPN_OK;
	}

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (!fHostRequested)
	{
		DNHostFailRequest(pdnObject,dpnidRequesting,hCompletionOp,hrOperation);
	}
	else
	{
		//
		//	If a completion op was specified and this was requested by the Host, this is a
		//	retry of an operation during Host migration.  In this case, we want to set the
		//	result (failure code) of the completion op, and remove it from the HandleTable.
		//
		if (hCompletionOp)
		{
			CAsyncOp	*pHostCompletionOp;

			pHostCompletionOp = NULL;
			if (pdnObject->HandleTable.Find(hCompletionOp,&pHostCompletionOp) == DPN_OK)
			{
				pHostCompletionOp->SetResult( hResultCode );
				pHostCompletionOp->Release();
				pHostCompletionOp = NULL;
				pdnObject->HandleTable.Destroy( hCompletionOp );
			}

			DNASSERT(pHostCompletionOp == NULL);
		}
	}
	if (pHandleParent)
	{
		pHandleParent->Release();
		pHandleParent = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNHostAddPlayerToGroup"

HRESULT	DNHostAddPlayerToGroup(DIRECTNETOBJECT *const pdnObject,
							   const DPNID dpnidGroup,
							   const DPNID dpnidPlayer,
							   void *const pvUserContext,
							   const DPNID dpnidRequesting,
							   const DPNHANDLE hCompletionOp,
							   DPNHANDLE *const phAsyncOp,
							   const DWORD dwFlags)
{
	HRESULT			hResultCode;
	HRESULT			hrOperation;
	DWORD			dwVersion;
	BOOL			fHostRequested;
	CNameTableEntry	*pLocalPlayer;
	CNameTableEntry	*pPlayer;
	CNameTableEntry	*pGroup;
	CRefCountBuffer	*pRefCountBuffer;
	CAsyncOp		*pHandleParent;
	CWorkerJob		*pWorkerJob;
	DN_INTERNAL_MESSAGE_ADD_PLAYER_TO_GROUP	*pMsg;

	DPFX(DPFPREP, 4,"Parameters: dpnidGroup [0x%lx], dpnidPlayer [0x%lx], pvUserContext [0x%p], dpnidRequesting [0x%lx], hCompletionOp [0x%lx], phAsyncOp [0x%p], dwFlags [0x%lx]",
			dpnidGroup,dpnidPlayer,pvUserContext,dpnidRequesting,hCompletionOp,phAsyncOp,dwFlags);

	DNASSERT(pdnObject != NULL);
	DNASSERT(dpnidGroup != 0);
	DNASSERT(dpnidPlayer != 0);
	DNASSERT(dpnidRequesting != 0);

	//
	//	If this is called from DN_AddPlayerToGroup(),
	//			hCompletion=0
	//			dpnidRequesting = DPNID of Host
	//			pvUserContext is valid
	//
	//	If this is called by a REQUEST,
	//			hCompletion = REQUEST handle of requesting player
	//			dpnidRequesting = DPNID of requesting player
	//			pvUserContext is not valid
	//
	//	If this is called at HostMigration,
	//			hCompletion = REQUEST handle on THIS (now Host) player
	//			dpnidRequesting = DPNID of THIS (now Host) player
	//			pvUserContext is invalid
	//

	pLocalPlayer = NULL;
	pGroup = NULL;
	pPlayer = NULL;
	pRefCountBuffer = NULL;
	pHandleParent = NULL;
	pWorkerJob = NULL;

	//
	//	Determine if this is being requested by the Host
	//
	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		return(DPN_OK);	// Ignore and continue (!)
	}
	if (pLocalPlayer->GetDPNID() == dpnidRequesting)
	{
		fHostRequested = TRUE;
	}
	else
	{
		fHostRequested = FALSE;
	}
	pLocalPlayer->Release();
	pLocalPlayer = NULL;

	//
	//	See if the player and group are still in the NameTable
	//	(this has to happen after we set fHostRequested so we can gracefully handle errors)
	//
	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnidGroup,&pGroup)) != DPN_OK)
	{
		DPFERR("Could not find group");
		DisplayDNError(0,hResultCode);
		hResultCode = DPNERR_INVALIDGROUP;
		hrOperation = DPNERR_INVALIDGROUP;
		goto Failure;
	}
	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnidPlayer,&pPlayer)) != DPN_OK)
	{
		DPFERR("Could not find player");
		DisplayDNError(0,hResultCode);
		hResultCode = DPNERR_INVALIDPLAYER;
		hrOperation = DPNERR_INVALIDPLAYER;
		goto Failure;
	}

	//
	//	Add Player To Group
	//
	dwVersion = 0;
	hrOperation = pdnObject->NameTable.AddPlayerToGroup(pGroup,pPlayer,&dwVersion);

	pGroup->Release();
	pGroup = NULL;
	pPlayer->Release();
	pPlayer = NULL;

	if (hrOperation != DPN_OK)
	{
		DPFERR("Could not add player to group");
		DisplayDNError(0,hResultCode);
		if (!fHostRequested)
		{
			DNHostFailRequest(pdnObject,dpnidRequesting,hCompletionOp,hrOperation);
		}
	}
	else
	{
		//
		//	Send ADD_PLAYER_TO_GROUP message
		//
		if (pdnObject->dwFlags & DN_OBJECT_FLAG_PEER)
		{
			// Create buffer
			if ((hResultCode = RefCountBufferNew(pdnObject,sizeof(DN_INTERNAL_MESSAGE_ADD_PLAYER_TO_GROUP),&pRefCountBuffer)) != DPN_OK)
			{
				DPFERR("Could not create RefCountBuffer");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
				goto Failure;
			}
			pMsg = reinterpret_cast<DN_INTERNAL_MESSAGE_ADD_PLAYER_TO_GROUP*>(pRefCountBuffer->GetBufferAddress());
			pMsg->dpnidGroup = dpnidGroup;
			pMsg->dpnidPlayer = dpnidPlayer;
			pMsg->dwVersion = dwVersion;
			pMsg->dwVersionNotUsed = 0;
			pMsg->dpnidRequesting = dpnidRequesting;
			pMsg->hCompletionOp = hCompletionOp;

			//
			//	SEND AddPlayerToGroup messages via WorkerThread
			//
			if ((hResultCode = WorkerJobNew(pdnObject,&pWorkerJob)) != DPN_OK)
			{
				DPFERR("Could not create new WorkerJob");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
				goto Failure;
			}
			pWorkerJob->SetJobType( WORKER_JOB_SEND_NAMETABLE_OPERATION );
			pWorkerJob->SetSendNameTableOperationMsgId( DN_MSG_INTERNAL_ADD_PLAYER_TO_GROUP );
			pWorkerJob->SetSendNameTableOperationVersion( dwVersion );
			pWorkerJob->SetSendNameTableOperationDPNIDExclude( 0 );
			pWorkerJob->SetRefCountBuffer( pRefCountBuffer );

			DNQueueWorkerJob(pdnObject,pWorkerJob);
			pWorkerJob = NULL;

			pRefCountBuffer->Release();
			pRefCountBuffer = NULL;
		}
	}

	//
	//	If this was called by the local (Host) player,
	//	Check to see if this was an original operation or a re-try from HostMigration
	//
	//	If this was an original operation,
	//		See if we need an Async HANDLE for the user
	//	Otherwise
	//		Clean up the outstanding operation
	//
	if (fHostRequested)
	{
		if (hCompletionOp == 0)		// Original
		{
			//
			//	If this fails, or is synchronous, return the operation result immediately
			//
			if (!(dwFlags & DPNADDPLAYERTOGROUP_SYNC) && (hrOperation == DPN_OK))
			{
				if ((hResultCode = DNCreateUserHandle(pdnObject,&pHandleParent)) != DPN_OK)
				{
					DPFERR("Could not create Async HANDLE");
					DisplayDNError(0,hResultCode);
					DNASSERT(FALSE);
					goto Failure;
				}
				pHandleParent->SetCompletion( DNCompleteAsyncHandle );
				pHandleParent->SetContext( pvUserContext );
				pHandleParent->SetResult( hrOperation );
				pHandleParent->SetCannotCancel();
				*phAsyncOp = pHandleParent->GetHandle();
				pHandleParent->Release();
				pHandleParent = NULL;

				hResultCode = DPNERR_PENDING;
			}
			else
			{
				hResultCode = hrOperation;
			}
		}
		else						// Host Migration re-try
		{
			CAsyncOp	*pRequest;

			pRequest = NULL;

			if ((hResultCode = pdnObject->HandleTable.Find( hCompletionOp,&pRequest )) == DPN_OK)
			{
				pRequest->SetResult( hrOperation );
				pRequest->Release();
				pRequest = NULL;
				pdnObject->HandleTable.Destroy( hCompletionOp );
			}

			hResultCode = DPN_OK;
		}
	}
	else
	{
		hResultCode = DPN_OK;
	}

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (!fHostRequested)
	{
		DNHostFailRequest(pdnObject,dpnidRequesting,hCompletionOp,hrOperation);
	}
	else
	{
		//
		//	If a completion op was specified and this was requested by the Host, this is a
		//	retry of an operation during Host migration.  In this case, we want to set the
		//	result (failure code) of the completion op, and remove it from the HandleTable.
		//
		if (hCompletionOp)
		{
			CAsyncOp	*pHostCompletionOp;

			pHostCompletionOp = NULL;
			if (pdnObject->HandleTable.Find(hCompletionOp,&pHostCompletionOp) == DPN_OK)
			{
				pHostCompletionOp->SetResult( hResultCode );
				pHostCompletionOp->Release();
				pHostCompletionOp = NULL;
				pdnObject->HandleTable.Destroy( hCompletionOp );
			}

			DNASSERT(pHostCompletionOp == NULL);
		}
	}
	if (pHandleParent)
	{
		pHandleParent->Release();
		pHandleParent = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	if (pGroup)
	{
		pGroup->Release();
		pGroup = NULL;
	}
	if (pPlayer)
	{
		pPlayer->Release();
		pPlayer = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNHostDeletePlayerFromGroup"

HRESULT	DNHostDeletePlayerFromGroup(DIRECTNETOBJECT *const pdnObject,
									const DPNID dpnidGroup,
									const DPNID dpnidPlayer,
									void *const pvUserContext,
									const DPNID dpnidRequesting,
									const DPNHANDLE hCompletionOp,
									DPNHANDLE *const phAsyncOp,
									const DWORD dwFlags)
{
	HRESULT			hResultCode;
	HRESULT			hrOperation;
	DWORD			dwVersion;
	BOOL			fHostRequested;
	CNameTableEntry	*pLocalPlayer;
	CNameTableEntry	*pGroup;
	CNameTableEntry	*pPlayer;
	CRefCountBuffer	*pRefCountBuffer;
	CAsyncOp		*pHandleParent;
	CWorkerJob		*pWorkerJob;
	DN_INTERNAL_MESSAGE_DELETE_PLAYER_FROM_GROUP	*pMsg;

	DPFX(DPFPREP, 4,"Parameters: dpnidGroup [0x%lx], dpnidPlayer [0x%lx], pvUserContext [0x%p], dpnidRequesting [0x%lx], hCompletionOp [0x%lx], phAsyncOp [0x%p], dwFlags [0x%lx]",
			dpnidGroup,dpnidPlayer,pvUserContext,dpnidRequesting,hCompletionOp,phAsyncOp,dwFlags);

	DNASSERT(pdnObject != NULL);
	DNASSERT(dpnidGroup != 0);
	DNASSERT(dpnidPlayer != 0);
	DNASSERT(dpnidRequesting != 0);

	//
	//	If this is called from DN_DeletePlayerFromGroup(),
	//			hCompletion=0
	//			dpnidRequesting = DPNID of Host
	//			pvUserContext is valid
	//
	//	If this is called by a REQUEST,
	//			hCompletion = REQUEST handle of requesting player
	//			dpnidRequesting = DPNID of requesting player
	//			pvUserContext is not valid
	//
	//	If this is called at HostMigration,
	//			hCompletion = REQUEST handle on THIS (now Host) player
	//			dpnidRequesting = DPNID of THIS (now Host) player
	//			pvUserContext is invalid
	//

	pLocalPlayer = NULL;
	pGroup = NULL;
	pPlayer = NULL;
	pRefCountBuffer = NULL;
	pHandleParent = NULL;
	pWorkerJob = NULL;

	//
	//	Determine if this is being requested by the Host
	//
	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		return(DPN_OK);	// Ignore and continue (!)
	}

	if (pLocalPlayer->GetDPNID() == dpnidRequesting)
	{
		fHostRequested = TRUE;
	}
	else
	{
		fHostRequested = FALSE;
	}
	pLocalPlayer->Release();
	pLocalPlayer = NULL;

	//
	//	See if the player and group are still in the NameTable
	//	(this has to happen after we set fHostRequested so we can gracefully handle errors)
	//
	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnidGroup,&pGroup)) != DPN_OK)
	{
		DPFERR("Could not find group");
		DisplayDNError(0,hResultCode);
		hResultCode = DPNERR_INVALIDGROUP;
		hrOperation = DPNERR_INVALIDGROUP;
		goto Failure;
	}
	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnidPlayer,&pPlayer)) != DPN_OK)
	{
		DPFERR("Could not find player");
		DisplayDNError(0,hResultCode);
		hResultCode = DPNERR_INVALIDPLAYER;
		hrOperation = DPNERR_INVALIDPLAYER;
		goto Failure;
	}

	//
	//	Delete Player From Group
	//
	dwVersion = 0;
	hrOperation = pdnObject->NameTable.RemovePlayerFromGroup(pGroup,pPlayer,&dwVersion);
	if (hrOperation != DPN_OK)
	{
		DPFERR("Could not delete player from group");
		DisplayDNError(0,hrOperation);
		if (!fHostRequested)
		{
			DNHostFailRequest(pdnObject,dpnidRequesting,hCompletionOp,hrOperation);
		}
	}
	else
	{
		//
		//	Send DELETE_PLAYER_FROM_GROUP message if successful
		//
		if (pdnObject->dwFlags & DN_OBJECT_FLAG_PEER)
		{
			// Create buffer
			if ((hResultCode = RefCountBufferNew(pdnObject,sizeof(DN_INTERNAL_MESSAGE_DELETE_PLAYER_FROM_GROUP),&pRefCountBuffer)) != DPN_OK)
			{
				DPFERR("Could not create RefCountBuffer");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
				goto Failure;
			}
			pMsg = reinterpret_cast<DN_INTERNAL_MESSAGE_DELETE_PLAYER_FROM_GROUP*>(pRefCountBuffer->GetBufferAddress());
			pMsg->dpnidGroup = dpnidGroup;
			pMsg->dpnidPlayer = dpnidPlayer;
			pMsg->dwVersion = dwVersion;
			pMsg->dwVersionNotUsed = 0;
			pMsg->dpnidRequesting = dpnidRequesting;
			pMsg->hCompletionOp = hCompletionOp;

			//
			//	SEND DeletePlayerFromGroup messages via WorkerThread
			//
			if ((hResultCode = WorkerJobNew(pdnObject,&pWorkerJob)) != DPN_OK)
			{
				DPFERR("Could not create new WorkerJob");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
				goto Failure;
			}
			pWorkerJob->SetJobType( WORKER_JOB_SEND_NAMETABLE_OPERATION );
			pWorkerJob->SetSendNameTableOperationMsgId( DN_MSG_INTERNAL_DELETE_PLAYER_FROM_GROUP );
			pWorkerJob->SetSendNameTableOperationVersion( dwVersion );
			pWorkerJob->SetSendNameTableOperationDPNIDExclude( 0 );
			pWorkerJob->SetRefCountBuffer( pRefCountBuffer );

			DNQueueWorkerJob(pdnObject,pWorkerJob);
			pWorkerJob = NULL;

			pRefCountBuffer->Release();
			pRefCountBuffer = NULL;
		}
	}
	pGroup->Release();
	pGroup = NULL;
	pPlayer->Release();
	pPlayer = NULL;

	//
	//	If this was called by the local (Host) player,
	//	Check to see if this was an original operation or a re-try from HostMigration
	//
	//	If this was an original operation,
	//		See if we need an Async HANDLE for the user
	//	Otherwise
	//		Clean up the outstanding operation
	//
	if (fHostRequested)
	{
		if (hCompletionOp == 0)		// Original
		{
			//
			//	If this fails, or is synchronous, return the operation result immediately
			//
			if (!(dwFlags & DPNREMOVEPLAYERFROMGROUP_SYNC) && (hrOperation == DPN_OK))
			{
				if ((hResultCode = DNCreateUserHandle(pdnObject,&pHandleParent)) != DPN_OK)
				{
					DPFERR("Could not create Async HANDLE");
					DisplayDNError(0,hResultCode);
					DNASSERT(FALSE);
					goto Failure;
				}
				pHandleParent->SetCompletion( DNCompleteAsyncHandle );
				pHandleParent->SetContext( pvUserContext );
				pHandleParent->SetResult( hrOperation );
				pHandleParent->SetCannotCancel();
				*phAsyncOp = pHandleParent->GetHandle();
				pHandleParent->Release();
				pHandleParent = NULL;

				hResultCode = DPNERR_PENDING;
			}
			else
			{
				hResultCode = hrOperation;
			}
		}
		else						// Host Migration re-try
		{
			CAsyncOp	*pRequest;

			pRequest = NULL;

			if ((hResultCode = pdnObject->HandleTable.Find( hCompletionOp,&pRequest )) == DPN_OK)
			{
				pRequest->SetResult( hrOperation );
				pRequest->Release();
				pRequest = NULL;
				pdnObject->HandleTable.Destroy( hCompletionOp );
			}

			hResultCode = DPN_OK;
		}
	}
	else
	{
		hResultCode = DPN_OK;
	}

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (!fHostRequested)
	{
		DNHostFailRequest(pdnObject,dpnidRequesting,hCompletionOp,hrOperation);
	}
	else
	{
		//
		//	If a completion op was specified and this was requested by the Host, this is a
		//	retry of an operation during Host migration.  In this case, we want to set the
		//	result (failure code) of the completion op, and remove it from the HandleTable.
		//
		if (hCompletionOp)
		{
			CAsyncOp	*pHostCompletionOp;

			pHostCompletionOp = NULL;
			if (pdnObject->HandleTable.Find(hCompletionOp,&pHostCompletionOp) == DPN_OK)
			{
				pHostCompletionOp->SetResult( hResultCode );
				pHostCompletionOp->Release();
				pHostCompletionOp = NULL;
				pdnObject->HandleTable.Destroy( hCompletionOp );
			}

			DNASSERT(pHostCompletionOp == NULL);
		}
	}
	if (pHandleParent)
	{
		pHandleParent->Release();
		pHandleParent = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	if (pGroup)
	{
		pGroup->Release();
		pGroup = NULL;
	}
	if (pPlayer)
	{
		pPlayer->Release();
		pPlayer = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNHostUpdateInfo"

HRESULT	DNHostUpdateInfo(DIRECTNETOBJECT *const pdnObject,
						 const DPNID dpnid,
						 PWSTR pwszName,
						 const DWORD dwNameSize,
						 void *const pvData,
						 const DWORD dwDataSize,
						 const DWORD dwInfoFlags,
						 void *const pvUserContext,
						 const DPNID dpnidRequesting,
						 const DPNHANDLE hCompletionOp,
						 DPNHANDLE *const phAsyncOp,
						 const DWORD dwFlags)
{
	HRESULT			hResultCode;
	HRESULT			hrOperation;
	DWORD			dwSize;
	DWORD			dwVersion;
	BOOL			fHostRequested;
	CNameTableEntry	*pLocalPlayer;
	CNameTableEntry	*pNTEntry;
	CPackedBuffer	packedBuffer;
	CRefCountBuffer	*pRefCountBuffer;
	CAsyncOp		*pHandleParent;
	CWorkerJob		*pWorkerJob;
	DN_INTERNAL_MESSAGE_UPDATE_INFO	*pMsg;

	DPFX(DPFPREP, 4,"Parameters: dpnid [0x%lx], pwszName [0x%p], dwNameSize [%ld], pvData [0x%p], dwDataSize [%ld], dwInfoFlags [0x%lx], pvUserContext [0x%p], dpnidRequesting [0x%lx], hCompletionOp [0x%lx], phAsyncOp [0x%p], dwFlags [0x%lx]",
			dpnid,pwszName,dwNameSize,pvData,dwDataSize,dwInfoFlags,pvUserContext,dpnidRequesting,hCompletionOp,phAsyncOp,dwFlags);

	DNASSERT(pdnObject != NULL);
	DNASSERT(dpnid != 0);
	DNASSERT(dpnidRequesting != 0);

	pLocalPlayer = NULL;
	pNTEntry = NULL;
	pRefCountBuffer = NULL;
	pHandleParent = NULL;
	pWorkerJob = NULL;

	//
	//	Determine if this is being requested by the Host
	//
	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		return(DPN_OK);	// Ignore and continue (!)
	}
	if (pLocalPlayer->GetDPNID() == dpnidRequesting)
	{
		fHostRequested = TRUE;
	}
	else
	{
		fHostRequested = FALSE;
	}
	pLocalPlayer->Release();
	pLocalPlayer = NULL;

	//
	//	Update Info
	//
	hrOperation = pdnObject->NameTable.FindEntry(dpnid,&pNTEntry);
	if (hrOperation != DPN_OK)
	{
		DPFERR("Could not find entry");
		DisplayDNError(0,hResultCode);
		if (!fHostRequested)
		{
			DNHostFailRequest(pdnObject,dpnidRequesting,hCompletionOp,hrOperation);
		}
	}
	else
	{
		// This function takes the lock internally
		pNTEntry->UpdateEntryInfo(pwszName,dwNameSize,pvData,dwDataSize,dwInfoFlags, (pdnObject->dwFlags & (DN_OBJECT_FLAG_PEER)) ? TRUE : !fHostRequested);

		pdnObject->NameTable.WriteLock();
		pdnObject->NameTable.GetNewVersion( &dwVersion );
		pdnObject->NameTable.Unlock();

		//
		//	Send UPDATE_INFO message
		//
		if (pdnObject->dwFlags & (DN_OBJECT_FLAG_PEER) ||
			((pdnObject->dwFlags & DN_OBJECT_FLAG_SERVER))
		   )
		{
			// Create buffer
			dwSize = sizeof(DN_INTERNAL_MESSAGE_UPDATE_INFO) + dwNameSize + dwDataSize;
			if ((hResultCode = RefCountBufferNew(pdnObject,dwSize,&pRefCountBuffer)) != DPN_OK)
			{
				DPFERR("Could not create RefCountBuffer");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
				goto Failure;
			}
			packedBuffer.Initialize(pRefCountBuffer->GetBufferAddress(),pRefCountBuffer->GetBufferSize());
			pMsg = static_cast<DN_INTERNAL_MESSAGE_UPDATE_INFO*>(packedBuffer.GetHeadAddress());
			if ((hResultCode = packedBuffer.AddToFront(NULL,sizeof(DN_INTERNAL_MESSAGE_UPDATE_INFO))) != DPN_OK)
			{
				DPFERR("Could not reserve front of buffer");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
				goto Failure;
			}
			if ((dwInfoFlags & DPNINFO_NAME) && (pwszName) && (dwNameSize))
			{
				if ((hResultCode = packedBuffer.AddToBack(pwszName,dwNameSize)) != DPN_OK)
				{
					DPFERR("Could not add Name to back of buffer");
					DisplayDNError(0,hResultCode);
					DNASSERT(FALSE);
					goto Failure;
				}
				pMsg->dwNameOffset = packedBuffer.GetTailOffset();
				pMsg->dwNameSize = dwNameSize;
			}
			else
			{
				pMsg->dwNameOffset = 0;
				pMsg->dwNameSize = 0;
			}
			if ((dwInfoFlags & DPNINFO_DATA) && (pvData) && (dwDataSize))
			{
				if ((hResultCode = packedBuffer.AddToBack(pvData,dwDataSize)) != DPN_OK)
				{
					DPFERR("Could not add Data to back of buffer");
					DisplayDNError(0,hResultCode);
					DNASSERT(FALSE);
					goto Failure;
				}
				pMsg->dwDataOffset = packedBuffer.GetTailOffset();
				pMsg->dwDataSize = dwDataSize;
			}
			else
			{
				pMsg->dwDataOffset = 0;
				pMsg->dwDataSize = 0;
			}
			pMsg->dpnid = dpnid;
			pMsg->dwInfoFlags = dwInfoFlags;
			pMsg->dwVersion = dwVersion;
			pMsg->dwVersionNotUsed = 0;
			pMsg->dpnidRequesting = dpnidRequesting;
			pMsg->hCompletionOp = hCompletionOp;

			//
			//	SEND UpdateInfo messages via WorkerThread
			//
			if ((hResultCode = WorkerJobNew(pdnObject,&pWorkerJob)) != DPN_OK)
			{
				DPFERR("Could not create new WorkerJob");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
				goto Failure;
			}

			if (pdnObject->dwFlags & DN_OBJECT_FLAG_PEER)
			{
				pWorkerJob->SetJobType( WORKER_JOB_SEND_NAMETABLE_OPERATION );
				pWorkerJob->SetSendNameTableOperationDPNIDExclude( 0 );
			}
			else if ((pdnObject->dwFlags & DN_OBJECT_FLAG_SERVER) && fHostRequested)
			{
				// Send to everyone except the server
				pWorkerJob->SetJobType( WORKER_JOB_SEND_NAMETABLE_OPERATION );
				pWorkerJob->SetSendNameTableOperationDPNIDExclude( dpnidRequesting );
			}
			else
			{
				DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_SERVER);

				// This will be responding to a client that requested its
				// info updated via SetClientInfo

				// Use the Exclude DPNID as the address to send to
				pWorkerJob->SetJobType( WORKER_JOB_SEND_NAMETABLE_OPERATION_CLIENT );
				pWorkerJob->SetSendNameTableOperationDPNIDExclude( dpnidRequesting );
			}
			pWorkerJob->SetSendNameTableOperationMsgId( DN_MSG_INTERNAL_UPDATE_INFO );
			pWorkerJob->SetSendNameTableOperationVersion( dwVersion );
			pWorkerJob->SetRefCountBuffer( pRefCountBuffer );

			DNQueueWorkerJob(pdnObject,pWorkerJob);
			pWorkerJob = NULL;

			pRefCountBuffer->Release();
			pRefCountBuffer = NULL;
		}
	}
	pNTEntry->Release();
	pNTEntry = NULL;

	//
	//	If this was called by the local (Host) player,
	//	Check to see if this was an original operation or a re-try from HostMigration
	//
	//	If this was an original operation,
	//		See if we need an Async HANDLE for the user
	//	Otherwise
	//		Clean up the outstanding operation
	//
	if (fHostRequested)
	{
		if (hCompletionOp == 0)		// Original
		{
			DBG_CASSERT( DPNSETGROUPINFO_SYNC == DPNSETCLIENTINFO_SYNC );
			DBG_CASSERT( DPNSETCLIENTINFO_SYNC == DPNSETSERVERINFO_SYNC );
			DBG_CASSERT( DPNSETSERVERINFO_SYNC == DPNSETPEERINFO_SYNC );
			//
			//	If this fails, or is synchronous, return the operation result immediately
			//
			if (!(dwFlags & (DPNSETGROUPINFO_SYNC | DPNSETCLIENTINFO_SYNC | DPNSETSERVERINFO_SYNC | DPNSETPEERINFO_SYNC))
				 && (hrOperation == DPN_OK))
			{
				if ((hResultCode = DNCreateUserHandle(pdnObject,&pHandleParent)) != DPN_OK)
				{
					DPFERR("Could not create Async HANDLE");
					DisplayDNError(0,hResultCode);
					DNASSERT(FALSE);
					goto Failure;
				}
				pHandleParent->SetCompletion( DNCompleteAsyncHandle );
				pHandleParent->SetContext( pvUserContext );
				pHandleParent->SetResult( hrOperation );
				pHandleParent->SetCannotCancel();
				*phAsyncOp = pHandleParent->GetHandle();
				pHandleParent->Release();
				pHandleParent = NULL;

				hResultCode = DPNERR_PENDING;
			}
			else
			{
				hResultCode = hrOperation;
			}
		}
		else						// Host Migration re-try
		{
			CAsyncOp	*pRequest;

			pRequest = NULL;

			if ((hResultCode = pdnObject->HandleTable.Find( hCompletionOp,&pRequest )) == DPN_OK)
			{
				pRequest->SetResult( hrOperation );
				pRequest->Release();
				pRequest = NULL;
				pdnObject->HandleTable.Destroy( hCompletionOp );
			}

			hResultCode = DPN_OK;
		}
	}
	else
	{
		hResultCode = DPN_OK;
	}

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (!fHostRequested)
	{
		DNHostFailRequest(pdnObject,dpnidRequesting,hCompletionOp,hrOperation);
	}
	else
	{
		//
		//	If a completion op was specified and this was requested by the Host, this is a
		//	retry of an operation during Host migration.  In this case, we want to set the
		//	result (failure code) of the completion op, and remove it from the HandleTable.
		//
		if (hCompletionOp)
		{
			CAsyncOp	*pHostCompletionOp;

			pHostCompletionOp = NULL;
			if (pdnObject->HandleTable.Find(hCompletionOp,&pHostCompletionOp) == DPN_OK)
			{
				pHostCompletionOp->SetResult( hResultCode );
				pHostCompletionOp->Release();
				pHostCompletionOp = NULL;
				pdnObject->HandleTable.Destroy( hCompletionOp );
			}

			DNASSERT(pHostCompletionOp == NULL);
		}
	}
	if (pHandleParent)
	{
		pHandleParent->Release();
		pHandleParent = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	goto Exit;
}


//	DNHostCheckIntegrity
//
//	The host has been asked to perform an integrity check.  We will send a message to the
//	target player with the DPNID of the requesting player.  If this is returned to us, we
//	will destroy the requesting player.

#undef DPF_MODNAME
#define DPF_MODNAME "DNHostCheckIntegrity"

HRESULT	DNHostCheckIntegrity(DIRECTNETOBJECT *const pdnObject,
							 const DPNID dpnidTarget,
							 const DPNID dpnidRequesting)
{
	HRESULT			hResultCode;
	CNameTableEntry	*pNTEntry;
	CConnection		*pConnection;
	CRefCountBuffer	*pRefCountBuffer;
	DN_INTERNAL_MESSAGE_INTEGRITY_CHECK	*pMsg;

	DPFX(DPFPREP, 6,"Parameters: dpnidTarget [0x%lx], dpnidRequesting [0x%lx]",dpnidTarget,dpnidRequesting);

	pNTEntry = NULL;
	pConnection = NULL;
	pRefCountBuffer = NULL;

	//
	//	Ensure that the target player is still in the NameTable, as we might have deleted him already
	//
	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnidTarget,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not find integrity check target in NameTable - probably deleted already");
		DisplayDNError(0,hResultCode);
		hResultCode = DPN_OK;
		goto Failure;
	}
	if ((hResultCode = pNTEntry->GetConnectionRef( &pConnection )) != DPN_OK)
	{
		DPFERR("Could not get target player connection reference - probably deleted already");
		DisplayDNError(0,hResultCode);
		hResultCode = DPN_OK;
		goto Failure;
	}
	pNTEntry->Release();
	pNTEntry = NULL;

	//
	//	Create the message
	//
	if ((hResultCode = RefCountBufferNew(pdnObject,sizeof(DN_INTERNAL_MESSAGE_INTEGRITY_CHECK),&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not create RefCountBuffer");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pMsg = reinterpret_cast<DN_INTERNAL_MESSAGE_INTEGRITY_CHECK*>(pRefCountBuffer->GetBufferAddress());
	pMsg->dpnidRequesting = dpnidRequesting;

	//
	//	Send message
	//
	if ((hResultCode = DNSendMessage(	pdnObject,
										pConnection,
										DN_MSG_INTERNAL_INTEGRITY_CHECK,
										dpnidTarget,
										pRefCountBuffer->BufferDescAddress(),
										pRefCountBuffer,
										0,
										DN_SENDFLAGS_RELIABLE,
										NULL,
										NULL )) != DPNERR_PENDING)
	{
		DPFERR("Could not send message - probably deleted already");
		DisplayDNError(0,hResultCode);
		hResultCode = DPN_OK;
		goto Failure;
	}

	pConnection->Release();
	pConnection = NULL;
	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	goto Exit;
}


//	DNHostFixIntegrity
//
//	The host has received a response from a player whose session integrity was being checked.
//	The player who requested this check will be dropped.
							 
#undef DPF_MODNAME
#define DPF_MODNAME "DNHostFixIntegrity"

HRESULT	DNHostFixIntegrity(DIRECTNETOBJECT *const pdnObject,
						   void *const pvBuffer)
{
	HRESULT			hResultCode;
	CNameTableEntry	*pNTEntry;
	CConnection		*pConnection;
	CRefCountBuffer	*pRefCountBuffer;
	UNALIGNED DN_INTERNAL_MESSAGE_INTEGRITY_CHECK_RESPONSE	*pResponse;
	DN_INTERNAL_MESSAGE_TERMINATE_SESSION			*pMsg;

	DPFX(DPFPREP, 6,"Parameters: pvBuffer [0x%p]",pvBuffer);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pvBuffer != NULL);

	pNTEntry = NULL;
	pConnection = NULL;
	pRefCountBuffer = NULL;

	pResponse = static_cast<DN_INTERNAL_MESSAGE_INTEGRITY_CHECK_RESPONSE*>(pvBuffer);

	//
	//	Get requesting player's connection - they may have already dropped
	//
	if ((hResultCode = pdnObject->NameTable.FindEntry(pResponse->dpnidRequesting,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not find player in NameTable - may have dropped");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	if ((hResultCode = pNTEntry->GetConnectionRef( &pConnection )) != DPN_OK)
	{
		DPFERR("Could not get player connection reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pNTEntry->Release();
	pNTEntry = NULL;

	//
	//	Build terminate message
	//
	if ((hResultCode = RefCountBufferNew(pdnObject,sizeof(DN_INTERNAL_MESSAGE_TERMINATE_SESSION),&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not allocate RefCountBuffer");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pMsg = reinterpret_cast<DN_INTERNAL_MESSAGE_TERMINATE_SESSION*>(pRefCountBuffer->GetBufferAddress());
	pMsg->dwTerminateDataOffset = 0;
	pMsg->dwTerminateDataSize = 0;

	//
	//	Send message to player to exit
	//
	hResultCode = DNSendMessage(pdnObject,
								pConnection,
								DN_MSG_INTERNAL_TERMINATE_SESSION,
								pResponse->dpnidRequesting,
								pRefCountBuffer->BufferDescAddress(),
								pRefCountBuffer,
								0,
								DN_SENDFLAGS_RELIABLE,
								NULL,
								NULL);

	pConnection->Release();
	pConnection = NULL;
	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

	//
	//	Disconnect player
	//
	hResultCode = DNHostDisconnect(pdnObject,pResponse->dpnidRequesting,DPNDESTROYPLAYERREASON_HOSTDESTROYEDPLAYER);

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNProcessCreateGroup"

HRESULT	DNProcessCreateGroup(DIRECTNETOBJECT *const pdnObject,
							 void *const pvBuffer)
{
	HRESULT			hResultCode;
	CNameTableEntry	*pLocalPlayer;
	CNameTableEntry	*pNTEntry;
	CAsyncOp		*pRequest;
	UNALIGNED DN_NAMETABLE_ENTRY_INFO				*pInfo;
	UNALIGNED DN_INTERNAL_MESSAGE_CREATE_GROUP	*pMsg;
	BOOL			fNotify;

	DPFX(DPFPREP, 4,"Parameters: pvBuffer [0x%p]",pvBuffer);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pvBuffer != NULL);

	pRequest = NULL;
	pLocalPlayer = NULL;
	pNTEntry = NULL;

	pMsg = static_cast<DN_INTERNAL_MESSAGE_CREATE_GROUP*>(pvBuffer);
	pInfo = reinterpret_cast<DN_NAMETABLE_ENTRY_INFO*>(pMsg + 1);

	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	Create Group
	//
	if ((hResultCode = NameTableEntryNew(pdnObject,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not create new NameTableEntry");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	if ((hResultCode = pNTEntry->UnpackEntryInfo(pInfo,static_cast<BYTE*>(pvBuffer))) != DPN_OK)
	{
		DPFERR("Could not unpack NameTableEntry");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

	//
	//	Get async op if we requested this operation - it has the group context on it
	//
	if (pMsg->dpnidRequesting == pLocalPlayer->GetDPNID())
	{
		if ((hResultCode = pdnObject->HandleTable.Find( pMsg->hCompletionOp,&pRequest )) != DPN_OK)
		{
			DPFERR("Could not find REQUEST AsyncOp");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pNTEntry->SetContext( pRequest->GetContext() );
	}
	pLocalPlayer->Release();
	pLocalPlayer = NULL;

	//
	//	Add Group to NameTable
	//
	if ((hResultCode = pdnObject->NameTable.InsertEntry(pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not update NameTable");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pdnObject->NameTable.WriteLock();
	pdnObject->NameTable.SetVersion(pNTEntry->GetVersion());
	pdnObject->NameTable.Unlock();

	fNotify = FALSE;
	pNTEntry->Lock();
	if (!pNTEntry->IsAvailable() && !pNTEntry->IsDisconnecting())
	{
		pNTEntry->MakeAvailable();
		pNTEntry->NotifyAddRef();
		pNTEntry->NotifyAddRef();
		pNTEntry->SetInUse();
		fNotify = TRUE;
	}
	pNTEntry->Unlock();

	if (fNotify)
	{
		DNUserCreateGroup(pdnObject,pNTEntry);

		pNTEntry->PerformQueuedOperations();
	}

	pNTEntry->Release();
	pNTEntry = NULL;

	//
	//	If this is a completion, set result and remove it from the request list and handle table
	//
	if (pRequest)
	{
		DNEnterCriticalSection(&pdnObject->csActiveList);
		pRequest->m_bilinkActiveList.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csActiveList);

		pRequest->SetResult( DPN_OK );
		pRequest->Release();
		pRequest = NULL;

		pdnObject->HandleTable.Destroy( pMsg->hCompletionOp );
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pRequest)
	{
		pRequest->Release();
		pRequest = NULL;
	}
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNProcessDestroyGroup"

HRESULT	DNProcessDestroyGroup(DIRECTNETOBJECT *const pdnObject,
							  void *const pvBuffer)
{
	HRESULT			hResultCode;
	DWORD			dwVersion;
	CNameTableEntry	*pLocalPlayer;
	CAsyncOp		*pRequest;
	UNALIGNED DN_INTERNAL_MESSAGE_DESTROY_GROUP	*pMsg;

	DPFX(DPFPREP, 4,"Parameters: pvBuffer [0x%p]",pvBuffer);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pvBuffer != NULL);

	pLocalPlayer = NULL;
	pRequest = NULL;

	pMsg = static_cast<DN_INTERNAL_MESSAGE_DESTROY_GROUP*>(pvBuffer);

	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	Destroy Group
	//
	dwVersion = pMsg->dwVersion;
	if ((hResultCode = pdnObject->NameTable.DeleteGroup(pMsg->dpnidGroup,&dwVersion)) != DPN_OK)
	{
		DPFERR("Could not delete group from NameTable");
		DisplayDNError(0,hResultCode);

		//
		//	Update version in any event (to prevent NameTable hangs)
		//
		pdnObject->NameTable.WriteLock();
		pdnObject->NameTable.SetVersion( pMsg->dwVersion );
		pdnObject->NameTable.Unlock();

		goto Failure;
	}

	//
	//	If this is a completion, set the result and remove it from the request list and handle table
	//
	if (pMsg->dpnidRequesting == pLocalPlayer->GetDPNID())
	{
		if ((hResultCode = pdnObject->HandleTable.Find( pMsg->hCompletionOp,&pRequest )) != DPN_OK)
		{
			DPFERR("Could not find REQUEST AsyncOp");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		DNEnterCriticalSection(&pdnObject->csActiveList);
		pRequest->m_bilinkActiveList.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csActiveList);

		pRequest->SetResult( DPN_OK );
		pRequest->Release();
		pRequest = NULL;

		pdnObject->HandleTable.Destroy( pMsg->hCompletionOp );
	}
	pLocalPlayer->Release();
	pLocalPlayer = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pRequest)
	{
		pRequest->Release();
		pRequest = NULL;
	}
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNProcessAddPlayerToGroup"

HRESULT	DNProcessAddPlayerToGroup(DIRECTNETOBJECT *const pdnObject,
								  void *const pvBuffer)
{
	HRESULT			hResultCode;
	DWORD			dwVersion;
	CNameTableEntry	*pLocalPlayer;
	CNameTableEntry	*pGroup;
	CNameTableEntry	*pPlayer;
	CAsyncOp		*pRequest;
	UNALIGNED DN_INTERNAL_MESSAGE_ADD_PLAYER_TO_GROUP	*pMsg;

	DPFX(DPFPREP, 4,"Parameters: pvBuffer [0x%p]",pvBuffer);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pvBuffer != NULL);

	pLocalPlayer = NULL;
	pGroup = NULL;
	pPlayer = NULL;
	pRequest = NULL;

	pMsg = static_cast<DN_INTERNAL_MESSAGE_ADD_PLAYER_TO_GROUP*>(pvBuffer);

	//
	//	Get NameTable entries
	//
	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	if ((hResultCode = pdnObject->NameTable.FindEntry(pMsg->dpnidGroup,&pGroup)) != DPN_OK)
	{
		DPFERR("Could not find group");
		DisplayDNError(0,hResultCode);

		//
		//	Update version in any event (to prevent NameTable hangs)
		//
		pdnObject->NameTable.WriteLock();
		pdnObject->NameTable.SetVersion( pMsg->dwVersion );
		pdnObject->NameTable.Unlock();

		goto Failure;
	}
	if ((hResultCode = pdnObject->NameTable.FindEntry(pMsg->dpnidPlayer,&pPlayer)) != DPN_OK)
	{
		DPFERR("Could not find player");
		DisplayDNError(0,hResultCode);

		//
		//	Update version in any event (to prevent NameTable hangs)
		//
		pdnObject->NameTable.WriteLock();
		pdnObject->NameTable.SetVersion( pMsg->dwVersion );
		pdnObject->NameTable.Unlock();

		goto Failure;
	}


	//
	//	Add Player To Group
	//
	dwVersion = pMsg->dwVersion;
	if ((hResultCode = pdnObject->NameTable.AddPlayerToGroup(pGroup,pPlayer,&dwVersion)) != DPN_OK)
	{
		DPFERR("Could not add player to group");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pGroup->Release();
	pGroup = NULL;
	pPlayer->Release();
	pPlayer = NULL;

	//
	//	If this is a completion, set result and remove it from the request list and handle table
	//
	if (pMsg->dpnidRequesting == pLocalPlayer->GetDPNID())
	{
		if ((hResultCode = pdnObject->HandleTable.Find( pMsg->hCompletionOp,&pRequest )) != DPN_OK)
		{
			DPFERR("Could not find REQUEST AsyncOp");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		DNEnterCriticalSection(&pdnObject->csActiveList);
		pRequest->m_bilinkActiveList.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csActiveList);

		pRequest->SetResult( DPN_OK );
		pRequest->Release();
		pRequest = NULL;

		pdnObject->HandleTable.Destroy( pMsg->hCompletionOp );
	}
	pLocalPlayer->Release();
	pLocalPlayer = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pRequest)
	{
		pRequest->Release();
		pRequest = NULL;
	}
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	if (pGroup)
	{
		pGroup->Release();
		pGroup = NULL;
	}
	if (pPlayer)
	{
		pPlayer->Release();
		pPlayer = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNProcessDeletePlayerFromGroup"

HRESULT	DNProcessDeletePlayerFromGroup(DIRECTNETOBJECT *const pdnObject,
									   void *const pvBuffer)
{
	HRESULT			hResultCode;
	DWORD			dwVersion;
	CNameTableEntry	*pLocalPlayer;
	CNameTableEntry	*pGroup;
	CNameTableEntry	*pPlayer;
	CAsyncOp		*pRequest;
	UNALIGNED DN_INTERNAL_MESSAGE_DELETE_PLAYER_FROM_GROUP	*pMsg;

	DPFX(DPFPREP, 4,"Parameters: pvBuffer [0x%p]",pvBuffer);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pvBuffer != NULL);

	pLocalPlayer = NULL;
	pGroup = NULL;
	pPlayer = NULL;
	pRequest = NULL;

	pMsg = static_cast<DN_INTERNAL_MESSAGE_DELETE_PLAYER_FROM_GROUP*>(pvBuffer);

	//
	//	Get NameTable entries
	//
	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	if ((hResultCode = pdnObject->NameTable.FindEntry(pMsg->dpnidGroup,&pGroup)) != DPN_OK)
	{
		DPFERR("Could not find group");
		DisplayDNError(0,hResultCode);

		//
		//	Update version in any event (to prevent NameTable hangs)
		//
		pdnObject->NameTable.WriteLock();
		pdnObject->NameTable.SetVersion( pMsg->dwVersion );
		pdnObject->NameTable.Unlock();

		goto Failure;
	}
	if ((hResultCode = pdnObject->NameTable.FindEntry(pMsg->dpnidPlayer,&pPlayer)) != DPN_OK)
	{
		DPFERR("Could not find player");
		DisplayDNError(0,hResultCode);

		//
		//	Update version in any event (to prevent NameTable hangs)
		//
		pdnObject->NameTable.WriteLock();
		pdnObject->NameTable.SetVersion( pMsg->dwVersion );
		pdnObject->NameTable.Unlock();

		goto Failure;
	}

	//
	//	Delete Player From Group
	//
	dwVersion = pMsg->dwVersion;
	if ((hResultCode = pdnObject->NameTable.RemovePlayerFromGroup(pGroup,pPlayer,&dwVersion)) != DPN_OK)
	{
		DPFERR("Could not delete player from group");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pGroup->Release();
	pGroup = NULL;
	pPlayer->Release();
	pPlayer = NULL;

	//
	//	If this is a completion, set the result and remove it from the request list and handle table
	//
	if (pMsg->dpnidRequesting == pLocalPlayer->GetDPNID())
	{
		if ((hResultCode = pdnObject->HandleTable.Find( pMsg->hCompletionOp,&pRequest )) != DPN_OK)
		{
			DPFERR("Could not find REQUEST AsyncOp");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		DNEnterCriticalSection(&pdnObject->csActiveList);
		pRequest->m_bilinkActiveList.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csActiveList);

		pRequest->SetResult( DPN_OK );
		pRequest->Release();
		pRequest = NULL;

		pdnObject->HandleTable.Destroy( pMsg->hCompletionOp );
	}
	pLocalPlayer->Release();
	pLocalPlayer = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pRequest)
	{
		pRequest->Release();
		pRequest = NULL;
	}
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	if (pGroup)
	{
		pGroup->Release();
		pGroup = NULL;
	}
	if (pPlayer)
	{
		pPlayer->Release();
		pPlayer = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNProcessUpdateInfo"

HRESULT	DNProcessUpdateInfo(DIRECTNETOBJECT *const pdnObject,
							void *const pvBuffer)
{
	HRESULT			hResultCode;
	PWSTR			pwszName;
	PVOID			pvData;
	CNameTableEntry	*pLocalPlayer;
	CNameTableEntry	*pNTEntry;
	CAsyncOp		*pRequest;
	UNALIGNED DN_INTERNAL_MESSAGE_UPDATE_INFO	*pMsg;
	BOOL			fDoUpdate = TRUE;

	DPFX(DPFPREP, 4,"Parameters: pvBuffer [0x%p]",pvBuffer);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pvBuffer != NULL);

	pLocalPlayer = NULL;
	pNTEntry = NULL;
	pRequest = NULL;

	pMsg = static_cast<DN_INTERNAL_MESSAGE_UPDATE_INFO*>(pvBuffer);

	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PEER)
	{
		//
		//	Update Info
		//
		if ((hResultCode = pdnObject->NameTable.FindEntry(pMsg->dpnid,&pNTEntry)) != DPN_OK)
		{
			DPFERR("Could not find NameTableEntry");
			DisplayDNError(0,hResultCode);

			//
			//	Update version in any event (to prevent NameTable hangs)
			//
			pdnObject->NameTable.WriteLock();
			pdnObject->NameTable.SetVersion( pMsg->dwVersion );
			pdnObject->NameTable.Unlock();

			goto Failure;
		}
	}
	else 
	{
		DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_CLIENT);

		// We are either being told that the host info has changed by a call
		// on the Host to SetServerInfo, or we are being told that our own
		// request to the server to change this Client's info has completed.
		if ((hResultCode = pdnObject->NameTable.GetHostPlayerRef(&pNTEntry)) != DPN_OK)
		{
			DPFERR("Could not find Host NameTableEntry");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		if (pNTEntry->GetDPNID() == pMsg->dpnid)
		{
			DPFX(DPFPREP, 5,"Updating server info");
		}
		else if (pLocalPlayer->GetDPNID() == pMsg->dpnid)
		{
			fDoUpdate = FALSE;
			DPFX(DPFPREP, 5,"Completing updating client info");
		}
		else
		{
			DPFERR("Received UpdateInfo for bad DPNID");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
	}

	if (fDoUpdate)
	{
		if ((pMsg->dwInfoFlags & DPNINFO_NAME) && (pMsg->dwNameOffset))
		{
			pwszName = reinterpret_cast<WCHAR*>(static_cast<BYTE*>(pvBuffer) + pMsg->dwNameOffset);
		}
		else
		{
			pwszName = NULL;
		}
		if ((pMsg->dwInfoFlags & DPNINFO_DATA) && (pMsg->dwDataOffset))
		{
			pvData = static_cast<void*>(static_cast<BYTE*>(pvBuffer) + pMsg->dwDataOffset);
		}
		else
		{
			pvData = NULL;
		}

		// This function takes the lock internally
		pNTEntry->UpdateEntryInfo(pwszName,pMsg->dwNameSize,pvData,pMsg->dwDataSize,pMsg->dwInfoFlags, TRUE);
	}

	pNTEntry->Release();
	pNTEntry = NULL;

	//
	//	Set NameTable version
	//
	pdnObject->NameTable.WriteLock();
	pdnObject->NameTable.SetVersion(pMsg->dwVersion);
	pdnObject->NameTable.Unlock();

	//
	//	If this is a completion, set the result and remove it from the request list and handle table
	//
	if (pMsg->dpnidRequesting == pLocalPlayer->GetDPNID())
	{
		if ((hResultCode = pdnObject->HandleTable.Find( pMsg->hCompletionOp,&pRequest )) != DPN_OK)
		{
			DPFERR("Could not find REQUEST AsyncOp");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		DNEnterCriticalSection(&pdnObject->csActiveList);
		pRequest->m_bilinkActiveList.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csActiveList);

		pRequest->SetResult( DPN_OK );
		pRequest->Release();
		pRequest = NULL;

		pdnObject->HandleTable.Destroy( pMsg->hCompletionOp );
	}
	pLocalPlayer->Release();
	pLocalPlayer = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pRequest)
	{
		pRequest->Release();
		pRequest = NULL;
	}
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNProcessFailedRequest"

HRESULT DNProcessFailedRequest(DIRECTNETOBJECT *const pdnObject,
							   void *const pvBuffer)
{
	HRESULT		hResultCode;
	CAsyncOp	*pRequest;
	UNALIGNED DN_INTERNAL_MESSAGE_REQUEST_FAILED	*pMsg;

	DPFX(DPFPREP, 4,"Parameters: pvBuffer [0x%p]",pvBuffer);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pvBuffer != NULL);

	pRequest = NULL;

	pMsg = static_cast<DN_INTERNAL_MESSAGE_REQUEST_FAILED*>(pvBuffer);

	//
	//	Update request using handle to HRESULT passed back by Host, and remove request from request list and handle table
	//
	if ((hResultCode = pdnObject->HandleTable.Find( pMsg->hCompletionOp, &pRequest )) == DPN_OK)
	{
		DNASSERT( pMsg->hCompletionOp != 0 );

		DNEnterCriticalSection(&pdnObject->csActiveList);
		pRequest->m_bilinkActiveList.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csActiveList);

		pRequest->SetResult( pMsg->hResultCode );
		pRequest->Release();
		pRequest = NULL;

		pdnObject->HandleTable.Destroy( pMsg->hCompletionOp );
	}
	hResultCode = DPN_OK;

	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//	DNProcessCheckIntegrity
//
//	The host is performing an integrity check and is asking the local player (us) if we are still
//	in the session.  We will respond that we are, and the host will drop the requesting player.

#undef DPF_MODNAME
#define DPF_MODNAME "DNProcessCheckIntegrity"

HRESULT	DNProcessCheckIntegrity(DIRECTNETOBJECT *const pdnObject,
								void *const pvBuffer)
{
	HRESULT			hResultCode;
	CNameTableEntry	*pHostPlayer;
	CConnection		*pConnection;
	CRefCountBuffer	*pRefCountBuffer;
	UNALIGNED DN_INTERNAL_MESSAGE_INTEGRITY_CHECK				*pMsg;
	DN_INTERNAL_MESSAGE_INTEGRITY_CHECK_RESPONSE	*pResponse;

	DPFX(DPFPREP, 6,"Parameters: pvBuffer [0x%p]",pvBuffer);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pvBuffer != NULL);

	pHostPlayer = NULL;
	pConnection = NULL;
	pRefCountBuffer = NULL;

	//
	//	Get host player connection to respond to
	//
	if ((hResultCode = pdnObject->NameTable.GetHostPlayerRef( &pHostPlayer )) != DPN_OK)
	{
		DPFERR("Could not get host player reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	if ((hResultCode = pHostPlayer->GetConnectionRef( &pConnection )) != DPN_OK)
	{
		DPFERR("Could not get host player connection reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pHostPlayer->Release();
	pHostPlayer = NULL;

	//
	//	Create response
	//
	if ((hResultCode = RefCountBufferNew(pdnObject,sizeof(DN_INTERNAL_MESSAGE_INTEGRITY_CHECK_RESPONSE),&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not create RefCountBuffer");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pResponse = reinterpret_cast<DN_INTERNAL_MESSAGE_INTEGRITY_CHECK_RESPONSE*>(pRefCountBuffer->GetBufferAddress());
	pMsg = static_cast<DN_INTERNAL_MESSAGE_INTEGRITY_CHECK*>(pvBuffer);
	pResponse->dpnidRequesting = pMsg->dpnidRequesting;

	//
	//	Send response
	//
	if ((hResultCode = DNSendMessage(	pdnObject,
										pConnection,
										DN_MSG_INTERNAL_INTEGRITY_CHECK_RESPONSE,
										pConnection->GetDPNID(),
										pRefCountBuffer->BufferDescAddress(),
										pRefCountBuffer,
										0,
										DN_SENDFLAGS_RELIABLE,
										NULL,
										NULL )) != DPNERR_PENDING)
	{
		DPFERR("Could not send integrity check response");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	pConnection->Release();
	pConnection = NULL;
	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pHostPlayer)
	{
		pHostPlayer->Release();
		pHostPlayer = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	goto Exit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\request.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Request.h
 *  Content:    Request Operation Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/18/00	mjn		Created
 *	04/24/00	mjn		Updated Group and Info operations to use CAsyncOp's
 *	08/05/00	mjn		Added DNProcessFailedRequest()
 *	08/07/00	mjn		Added DNRequestIntegrityCheck(),DNHostCheckIntegrity(),DNProcessCheckIntegrity(),DNHostFixIntegrity()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__REQUEST_H__
#define	__REQUEST_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

HRESULT DNRequestCreateGroup(DIRECTNETOBJECT *const pdnObject,
							 const PWSTR pwszName,
							 const DWORD dwNameSize,
							 const PVOID pvData,
							 const DWORD dwDataSize,
							 const DWORD dwGroupFlags,
							 void *const pvGroupContext,
							 void *const pvUserContext,
							 DPNHANDLE *const phAsyncOp,
							 const DWORD dwFlags);

HRESULT DNRequestDestroyGroup(DIRECTNETOBJECT *const pdnObject,
							  const DPNID dpnidGroup,
							  PVOID const pvUserContext,
							  DPNHANDLE *const phAsyncOp,
							  const DWORD dwFlags);

HRESULT DNRequestAddPlayerToGroup(DIRECTNETOBJECT *const pdnObject,
								  const DPNID dpnidGroup,
								  const DPNID dpnidPlayer,
								  PVOID const pvUserContext,
								  DPNHANDLE *const phAsyncOp,
								  const DWORD dwFlags);

HRESULT DNRequestDeletePlayerFromGroup(DIRECTNETOBJECT *const pdnObject,
									   const DPNID dpnidGroup,
									   const DPNID dpnidPlayer,
									   PVOID const pvUserContext,
									   DPNHANDLE *const phAsyncOp,
									   const DWORD dwFlags);

HRESULT DNRequestUpdateInfo(DIRECTNETOBJECT *const pdnObject,
							const DPNID dpnid,
							const PWSTR pwszName,
							const DWORD dwNameSize,
							const PVOID pvData,
							const DWORD dwDataSize,
							const DWORD dwInfoFlags,
							PVOID const pvUserContext,
							DPNHANDLE *const phAsyncOp,
							const DWORD dwFlags);

HRESULT DNRequestIntegrityCheck(DIRECTNETOBJECT *const pdnObject,
								const DPNID dpnidTarget);

HRESULT DNHostProcessRequest(DIRECTNETOBJECT *const pdnObject,
							 const DWORD dwMsgId,
							 PVOID const pv,
							 const DPNID dpnidRequesting);

void DNHostFailRequest(DIRECTNETOBJECT *const pdnObject,
					   const DPNID dpnid,
					   const DPNHANDLE hCompletionOp,
					   const HRESULT hr);

HRESULT	DNHostCreateGroup(DIRECTNETOBJECT *const pdnObject,
						  PWSTR pwszName,
						  const DWORD dwNameSize,
						  void *const pvData,
						  const DWORD dwDataSize,
						  const DWORD dwInfoFlags,
						  const DWORD dwGroupFlags,
						  void *const pvGroupContext,
						  void *const pvUserContext,
						  const DPNID dpnidOwner,
						  const DPNHANDLE hCompletionOp,
						  DPNHANDLE *const phAsyncOp,
						  const DWORD dwFlags);

HRESULT	DNHostDestroyGroup(DIRECTNETOBJECT *const pdnObject,
						   const DPNID dpnid,
						   void *const pvUserContext,
						   const DPNID dpnidRequesting,
						   const DPNHANDLE hCompletionOp,
						   DPNHANDLE *const phAsyncOp,
						   const DWORD dwFlags);

HRESULT	DNHostAddPlayerToGroup(DIRECTNETOBJECT *const pdnObject,
							   const DPNID dpnidGroup,
							   const DPNID dpnidPlayer,
							   void *const pvUserContext,
							   const DPNID dpnidRequesting,
							   const DPNHANDLE hCompletionOp,
							   DPNHANDLE *const phAsyncOp,
							   const DWORD dwFlags);

HRESULT	DNHostDeletePlayerFromGroup(DIRECTNETOBJECT *const pdnObject,
									const DPNID dpnidGroup,
									const DPNID dpnidPlayer,
									void *const pvUserContext,
									const DPNID dpnidRequesting,
									const DPNHANDLE hCompletionOp,
									DPNHANDLE *const phAsyncOp,
									const DWORD dwFlags);

HRESULT	DNHostUpdateInfo(DIRECTNETOBJECT *const pdnObject,
						 const DPNID dpnid,
						 PWSTR pwszName,
						 const DWORD dwNameSize,
						 void *const pvData,
						 const DWORD dwDataSize,
						 const DWORD dwInfoFlags,
						 void *const pvUserContext,
						 const DPNID dpnidRequesting,
						 const DPNHANDLE hCompletionOp,
						 DPNHANDLE *const phAsyncOp,
						 const DWORD dwFlags);

HRESULT	DNHostCheckIntegrity(DIRECTNETOBJECT *const pdnObject,
							 const DPNID dpnidTarget,
							 const DPNID dpnidRequesting);

HRESULT	DNHostFixIntegrity(DIRECTNETOBJECT *const pdnObject,
						   void *const pvBuffer);

HRESULT	DNProcessCreateGroup(DIRECTNETOBJECT *const pdnObject,
							 void *const pvBuffer);

HRESULT	DNProcessDestroyGroup(DIRECTNETOBJECT *const pdnObject,
							  void *const pvBuffer);

HRESULT	DNProcessAddPlayerToGroup(DIRECTNETOBJECT *const pdnObject,
								  void *const pvBuffer);

HRESULT	DNProcessDeletePlayerFromGroup(DIRECTNETOBJECT *const pdnObject,
									   void *const pvBuffer);

HRESULT	DNProcessUpdateInfo(DIRECTNETOBJECT *const pdnObject,
							void *const pvBuffer);

HRESULT DNProcessFailedRequest(DIRECTNETOBJECT *const pdnObject,
							   void *const pvBuffer);

HRESULT	DNProcessCheckIntegrity(DIRECTNETOBJECT *const pdnObject,
								void *const pvBuffer);


//**********************************************************************
// Class prototypes
//**********************************************************************


#endif	// __REQUEST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\spmessages.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       SPMessages.cpp
 *  Content:    Direct SP callback interface .CPP file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   10/08/99	jtk		Created
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

static	STDMETHODIMP	SPQueryInterface(IDP8SPCallback *pInterface,REFIID riid,LPVOID *ppvObj);
static	STDMETHODIMP_(ULONG)	SPAddRef(IDP8SPCallback *pInterface);
static	STDMETHODIMP_(ULONG)	SPRelease(IDP8SPCallback *pInterface);
static	STDMETHODIMP	SPIndicateEvent(IDP8SPCallback *pInterface,SP_EVENT_TYPE dwEvent, LPVOID pParam);
static	STDMETHODIMP	SPCommandComplete(IDP8SPCallback *pInterface,HANDLE hCommand, HRESULT hResult, void *pContext);

//
// VTable for SPMessages interface
//
IDP8SPCallbackVtbl SPMessagesVtbl =
{
	SPQueryInterface,
	SPAddRef,
	SPRelease,
	SPIndicateEvent,
	SPCommandComplete
};

//**********************************************************************
// Function definitions
//**********************************************************************

#undef DPF_MODNAME
#define DPF_MODNAME "SPQueryInterface"
static	STDMETHODIMP	SPQueryInterface(IDP8SPCallback *pInterface,REFIID riid,LPVOID *ppvObj)
{
	DNASSERT(FALSE);

	return(DPN_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "SPAddRef"
static	STDMETHODIMP_(ULONG)	SPAddRef(IDP8SPCallback *pInterface)
{
//	DNASSERT(FALSE);

	return(0);
}

#undef DPF_MODNAME
#define DPF_MODNAME "SPRelease"
static	STDMETHODIMP_(ULONG)	SPRelease(IDP8SPCallback *pInterface)
{
//	DNASSERT(FALSE);

	return(0);
}

#undef DPF_MODNAME
#define DPF_MODNAME "SPIndicateEvent"
static	STDMETHODIMP	SPIndicateEvent(IDP8SPCallback *pInterface,SP_EVENT_TYPE dwEvent, LPVOID pParam)
{
	DNASSERT(FALSE);

	return(DPN_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "SPCommandComplete"
static	STDMETHODIMP	SPCommandComplete(IDP8SPCallback *pInterface,HANDLE hCommand, HRESULT hResult, void *pContext )
{
	DNASSERT(FALSE);

	return(DPN_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\spmessages.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       SPMessages.h
 *  Content:    Direct SP callback interface header file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   10/08/99	jtk		Created
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__SPMESSAGES_H__
#define	__SPMESSAGES_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// VTable for SPMessage callback functions
//
extern	IDP8SPCallbackVtbl SPMessagesVtbl;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

#endif	// __SPMESSAGES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\sources.inc ===
#
# The MAJORCOMP and MINORCOMP variables are defined
# so that $(MAJORCOMP)$(MINORCOMP)filename can be used in
# cross compiling to provide unique filenames in a flat namespace.
#

MAJORCOMP=windows
MINORCOMP=media

#
# The TARGETNAME variable is defined by the developer.  It is the name of
# the target (component) that is being built by this makefile.  It
# should NOT include any path or file extension information.
#

TARGETNAME=dpnet
DLLDEF=..\dnet.def
UMTYPE=windows

#
# The TARGETPATH and TARGETTYPE variables are defined by the developer.
# The first specifies where the target is to be build.  The second specifies
# the type of target (either PROGRAM, DYNLINK, LIBRARY, DRIVER, etc
# UMAPPL_NOLIB is used when you're only building user-mode
# apps and don't need to build a library.
#

TARGETPATH=obj
TARGETTYPE=DYNLINK

!if "$(DPLAY_PCH)" != "off"
PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\dncorei.h
PRECOMPILED_PCH=dncorei.pch
PRECOMPILED_OBJ=dncorei.obj
!endif


#
# The TARGETLIBS specifies additional libraries to link with you target
# image.  Each library path specification should contain an asterisk (*)
# where the machine specific subdirectory name should go.
#

#
# 04/10/2000 - allows for addition of BoundsChecker, etc
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
	   ..\..\guids\obj$(BUILD_ALT_DIR)\*\guids.lib \
	   ..\..\common\obj$(BUILD_ALT_DIR)\*\common.lib \
           ..\..\protocol\obj$(BUILD_ALT_DIR)\*\protocol.lib \
           ..\..\dpnsvr\dpnsvlib\obj$(BUILD_ALT_DIR)\*\dpnsvlib.lib \
	   $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
	   $(BASEDIR)\public\sdk\lib\*\user32.lib \
	   $(BASEDIR)\public\sdk\lib\*\gdi32.lib \
	   $(BASEDIR)\public\sdk\lib\*\winmm.lib \
	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
	   $(BASEDIR)\public\sdk\lib\*\ole32.lib  \
	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
	   $(BASEDIR)\public\sdk\lib\*\msvcrt.lib



!if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
C_DEFINES=$(C_DEFINES) /DDEBUG /D_DEBUG
!endif

#
# The INCLUDES variable specifies any include paths that are specific to
# this source directory.  Separate multiple directory paths with single
# semicolons.  Relative path specifications are okay.
#

INCLUDES=..\;..\..\..\dvoice\inc;$(DXROOT)\inc;..\..\inc;..\..\protocol;..\..\common;..\..\dpnsvr\dpnsvlib;..\..\dpnsvr\inc


#
# The SOURCES variable is defined by the developer.  It is a list of all the
# source files for this component.  Each source file should be on a separate
# line using the line continuation character.  This will minimize merge
# conflicts if two developers adding source files to the same component.
#

SOURCES= ..\dnet.rc \
	 ..\appdesc.cpp \
	 ..\async.cpp \
	 ..\asyncop.cpp \
	 ..\cancel.cpp \
	 ..\caps.cpp \
	 ..\client.cpp \
	 ..\common.cpp \
	 ..\connection.cpp \
	 ..\coreclassfac.cpp \
	 ..\coreconnect.cpp \
	 ..\corehandletable.cpp \
	 ..\corepools.cpp \
	 ..\corereceive.cpp \
	 ..\corevoice.cpp \
	 ..\disconnect.cpp \
	 ..\coredllmain.cpp \
	 ..\enum_sp.cpp \
	 ..\enumhosts.cpp \
	 ..\globals.cpp \
	 ..\groupcon.cpp \
	 ..\groupmem.cpp \
	 ..\memoryfpm.cpp \
	 ..\migration.cpp \
	 ..\msghandler.cpp \
	 ..\nametable.cpp \
	 ..\ntentry.cpp \
	 ..\ntoplist.cpp \
	 ..\paramval.cpp \
	 ..\peer.cpp \
	 ..\protocol.cpp \
	 ..\queuedmsg.cpp \
	 ..\request.cpp \
	 ..\server.cpp \
	 ..\servprov.cpp \
	 ..\spmessages.cpp \
	 ..\user.cpp \
	 ..\verify.cpp \
	 ..\worker.cpp

#
# Next specify options for the compiler.
#
# Note about CRT defines.  When linking with MSVCRT you must have both _MT and _DLL specified.
# Using the build environment's USE_MSVCRT=1 would do this for us, but because we define our
# own operator new this will cause a link error because the build environment will not properly
# pull in msvcrt.lib last as of 5/11/2001.  Therefore, we do it all manually specifying _DLL, _MT, 
# and msvcrt.lib and USE_NOLIBS=1 ourselves.  This also means that we must manually add msvcprt.lib 
# where STL is used.
#
C_DEFINES= $(C_DEFINES) /D_USRDLL /DWIN32 /D_MT /D_DLL /DCINTERFACE

USE_NOLIBS=1

DLLENTRY=_DllMainCRTStartup
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\servprov.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ServProv.cpp
 *  Content:    Service Provider Objects
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/17/00	mjn		Created
 *  04/04/00    rmt     Added set of SP caps from cache (if cache exists).
 *	04/10/00	mjn		Farm out RemoveSP to worker thread
 *	05/02/00	mjn		Fixed RefCount issue
 *  06/09/00    rmt     Updates to split CLSID and allow whistler compat 
 *	07/06/00	mjn		Fixes to support SP handle to Protocol
 *  08/03/00	rmt		Bug #41244 - Wrong return codes -- part 2  
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *	08/06/00	mjn		Added CWorkerJob
 *	08/20/00	mjn		Changed Initialize() to not add SP to DirectNet object bilink
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************

#undef DPF_MODNAME
#define DPF_MODNAME "CServiceProvider::Initialize"

HRESULT CServiceProvider::Initialize(DIRECTNETOBJECT *const pdnObject,
								const GUID *const pguid,
								const GUID *const pguidApplication)
{
	HRESULT			hResultCode;
	IDP8ServiceProvider	*pISP;
	SPISAPPLICATIONSUPPORTEDDATA	spAppSupData;
	BOOL		fAddedToProtocol;

	DNASSERT(pdnObject != NULL);
	DNASSERT(pguid != NULL);

	pISP = NULL;
	fAddedToProtocol = FALSE;

	m_pdnObject = pdnObject;

	//
	//	Instantiate SP
	//
	if ((hResultCode = COM_CoCreateInstance(*pguid,
										NULL,
										CLSCTX_INPROC_SERVER,
										IID_IDP8ServiceProvider,
										reinterpret_cast<void**>(&pISP))) != DPN_OK)
	{
		DPFX(DPFPREP,0,"Could not instantiate SP (err = 0x%lx)!",hResultCode);
		hResultCode = DPNERR_DOESNOTEXIST;
		DisplayDNError(0,hResultCode);
		goto Exit;
	}

	//
	//	Add SP to Protocol Layer
	//
	DNProtocolAddRef(pdnObject);
	if ((hResultCode = DNPAddServiceProvider(m_pdnObject->pdnProtocolData,pISP,&m_hProtocolSPHandle)) != DPN_OK)
	{
		DPFX(DPFPREP,1,"Could not add service provider to protocol");
		DisplayDNError(1,hResultCode);
		DNProtocolRelease(pdnObject);
		goto Failure;
	}

	fAddedToProtocol = TRUE;

	//
	//	If an application GUID was given, make sure the SP can be used by that app.
	//
	if (pguidApplication != NULL)	// app GUID given
	{
		spAppSupData.pApplicationGuid = pguidApplication;
		spAppSupData.dwFlags = 0;
		if ((hResultCode = pISP->lpVtbl->IsApplicationSupported(pISP,&spAppSupData)) != DPN_OK)	// SP doesn't support app
		{
			DPFX(DPFPREP,1,"Service provider does not support app (err = 0x%lx).", hResultCode);
			hResultCode = DPNERR_UNSUPPORTED;
			goto Failure;
		}
	}

	m_dwFlags |= DN_SERVICE_PROVIDER_FLAG_LOADED;

	pISP->lpVtbl->AddRef(pISP);
	m_pISP = pISP;
	pISP->lpVtbl->Release(pISP);
	pISP = NULL;

	m_guid = *pguid;
/*	REMOVE
	// Add to bilink
	AddRef();
	m_bilink.InsertBefore(&m_pdnObject->m_bilinkServiceProviders);
*/

	hResultCode = DPN_OK;

Exit:
	return(hResultCode);

Failure:

	if (fAddedToProtocol)
	{
		//
		// Ignore failure.
		//
		DNPRemoveServiceProvider(pdnObject->pdnProtocolData,m_hProtocolSPHandle);
		DNProtocolRelease(pdnObject);
	}

	if (pISP)
	{
		pISP->lpVtbl->Release(pISP);
		pISP = NULL;
	}
	goto Exit;
};


#undef DPF_MODNAME
#define DPF_MODNAME "CServiceProvider::Release"

void CServiceProvider::Release( void )
{
	HRESULT		hResultCode;
	LONG		lRefCount;

	lRefCount = InterlockedDecrement(&m_lRefCount);
	DPFX(DPFPREP, 9,"[0x%p] new RefCount [%ld]",this,lRefCount);
	DNASSERT(lRefCount >= 0);
	if (lRefCount == 0)
	{
		if (m_dwFlags & DN_SERVICE_PROVIDER_FLAG_LOADED)
		{
			CWorkerJob	*pWorkerJob;

			pWorkerJob = NULL;

			if ((hResultCode = WorkerJobNew(m_pdnObject,&pWorkerJob)) == DPN_OK)
			{
				pWorkerJob->SetJobType( WORKER_JOB_REMOVE_SERVICE_PROVIDER );
				pWorkerJob->SetRemoveServiceProviderHandle( m_hProtocolSPHandle );

				DNQueueWorkerJob(m_pdnObject,pWorkerJob);
				pWorkerJob = NULL;
			}
			else
			{
				DPFERR("Could not remove SP");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
			}
			if (m_pISP)
			{
				m_pISP->lpVtbl->Release(m_pISP);
				m_pISP = NULL;
			}
		}
		m_pdnObject = NULL;

		delete this;
	}
}


#undef DPF_MODNAME
#define DPF_MODNAME "CServiceProvider::GetInterfaceRef"

HRESULT CServiceProvider::GetInterfaceRef( IDP8ServiceProvider **ppIDP8SP )
{
	DNASSERT( ppIDP8SP != NULL );

	if (m_pISP == NULL)
	{
		return( DPNERR_GENERIC );
	}

	m_pISP->lpVtbl->AddRef( m_pISP );
	*ppIDP8SP = m_pISP;

	return( DPN_OK );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\server.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Server.h
 *  Content:    DirectNet Server interface header file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  07/21/99	mjn		Created
 *	10/08/99	jtk		Split from DNCore.h
 *	12/03/99	jtk		Moved COM interface definitions to DNet.h
 *	02/15/00	mjn		Use INFO flags in SetServerInfo and return context in GetClientInfo
 *	04/06/00	mjn		Added GetClientAddress to API
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__SERVER_H__
#define	__SERVER_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//
// VTable for server interface
//
extern IDirectPlay8ServerVtbl DN_ServerVtbl;

//**********************************************************************
// Function prototypes
//**********************************************************************

//
// DirectNet - IDirectPlay8Server
//
STDMETHODIMP DN_SetServerInfo(IDirectPlay8Server *pInterface,
							  const DPN_PLAYER_INFO *const pdpnPlayerInfo,
							  PVOID const pvAsyncContext,
							  DPNHANDLE *const phAsyncHandle,
							  const DWORD dwFlags);

STDMETHODIMP DN_GetClientInfo(IDirectPlay8Server *pInterface,
							  const DPNID dpnid,
							  DPN_PLAYER_INFO *const pdpnPlayerInfo,
							  DWORD *const pdwSize,
							  const DWORD dwFlags);

STDMETHODIMP DN_GetClientAddress(IDirectPlay8Server *pInterface,
								 const DPNID dpnid,
								 IDirectPlay8Address **const ppAddress,
								 const DWORD dwFlags);

#endif	// __SERVER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\syncevent.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       SyncEvent.cpp
 *  Content:    DNET Synchronization Events FPM
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/20/99	mjn		Created
 *	01/19/00	mjn		Replaced DN_SYNC_EVENT with CSyncEvent
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************

/*	REMOVE
//**********************************************************************
// ------------------------------
// CSyncEvent::Initialize
//
// Entry:		CFixedPool <SyncEvent> *pFPSyncEvent
//
// Exit:		Error Code:	DN_OK
//							DNERR_OUTOFMEMORY
// ------------------------------

HRESULT CSyncEvent::Initialize(CFixedPool <CSyncEvent> *pFPSyncEvent)
{
	if (m_hEvent == NULL)
	{
		m_pFPOOLSyncEvent = pFPSyncEvent;
		if ((m_hEvent = CreateEvent(NULL,TRUE,FALSE,NULL)) == NULL)
		{
			DNASSERT(FALSE);
			return(DNERR_OUTOFMEMORY);
		}
	}
	Reset();

	return(DN_OK);
}
//**********************************************************************

//**********************************************************************
// ------------------------------
// CSyncEvent::ReturnSelfToPool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------

void CSyncEvent::ReturnSelfToPool( void )
{
	m_pFPOOLSyncEvent->Release( this );
}
//**********************************************************************

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\servprov.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ServProv.h
 *  Content:    Service Provider Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/17/00	mjn		Created
 *	05/02/00	mjn		Fixed RefCount issue
 *	07/06/00	mjn		Fixes to support SP handle to Protocol
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *	08/20/00	mjn		Changed m_bilink to m_bilinkServiceProviders
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__SERV_PROV_H__
#define	__SERV_PROV_H__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_CORE

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	DN_SERVICE_PROVIDER_FLAG_LOADED		0x0001

//**********************************************************************
// Macro definitions
//**********************************************************************

#ifndef	OFFSETOF
#define OFFSETOF(s,m)				( ( INT_PTR ) ( ( PVOID ) &( ( (s*) 0 )->m ) ) )
#endif

#ifndef	CONTAINING_OBJECT
#define	CONTAINING_OBJECT(b,t,m)	(reinterpret_cast<t*>(&reinterpret_cast<BYTE*>(b)[-OFFSETOF(t,m)]))
#endif

//**********************************************************************
// Structure definitions
//**********************************************************************

typedef struct _DIRECTNETOBJECT DIRECTNETOBJECT;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************

// class for ServiceProvider objects

class CServiceProvider
{
public:
	CServiceProvider()		// Constructor
		{
			m_dwFlags = 0;
			m_pdnObject = NULL;
			m_lRefCount = 1;
			m_pISP = NULL;
			m_hProtocolSPHandle = NULL;

			m_bilinkServiceProviders.Initialize();
		};

	~CServiceProvider()		// Destructor
		{
		};

	HRESULT Initialize(DIRECTNETOBJECT *const pdnObject,
					const GUID *const pguid,
					const GUID *const pguidApplication);

#undef DPF_MODNAME
#define DPF_MODNAME "CServiceProvider::AddRef"

	void AddRef( void )
		{
			LONG	lRefCount;

			DNASSERT(m_lRefCount > 0);
			DNASSERT(m_pdnObject != NULL);

			lRefCount = InterlockedIncrement(&m_lRefCount);
			DPFX(DPFPREP, 9,"[0x%p] new RefCount [%ld]",this,lRefCount);
		};

	void Release( void );

	BOOL CheckGUID( const GUID *const pGUID )
		{
			if (m_guid == *pGUID)
				return(TRUE);

			return(FALSE);
		};

	HRESULT GetInterfaceRef( IDP8ServiceProvider **ppIDP8SP );

	HANDLE GetHandle( void )
		{
			return( m_hProtocolSPHandle );
		};

	CBilink		m_bilinkServiceProviders;

private:
	DWORD				m_dwFlags;
	GUID				m_guid;
	LONG				m_lRefCount;
	IDP8ServiceProvider	*m_pISP;
	HANDLE				m_hProtocolSPHandle;
	DIRECTNETOBJECT		*m_pdnObject;
};

#undef DPF_MODNAME

#endif	// __SERV_PROV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\voice.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       voice.h
 *  Content:    Direct Net Voice Transport Interface
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  01/17/00	rmt		Created
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__VOICE_H__
#define	__VOICE_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

typedef struct _DIRECTNETOBJECT DIRECTNETOBJECT, *PDIRECTNETOBJECT;

//**********************************************************************
// Variable definitions
//**********************************************************************

//
// VTable for peer interface
//
//extern IDirectPlayVoiceTransportVtbl DN_VoiceTbl;

HRESULT Voice_Notify( PDIRECTNETOBJECT pObject, DWORD dwMsgID, DWORD_PTR dwParam1, DWORD_PTR dwParam2, DWORD dwObjectType = DVTRANSPORT_OBJECTTYPE_BOTH );
HRESULT Voice_Receive(PDIRECTNETOBJECT pObject, DVID dvidFrom, DVID dvidTo, LPVOID lpvMessage, DWORD dwMessageLen );


//**********************************************************************
// Function prototypes
//**********************************************************************

#endif	// __VOICE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\syncevent.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       SyncEvent.h
 *  Content:    Synchronization Events FPM Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/20/99	mjn		Created
 *	01/19/00	mjn		Replaced DN_SYNC_EVENT with CSyncEvent
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__SYNC_EVENT_H__
#define	__SYNC_EVENT_H__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_CORE


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

template< class CSyncEvent > class CLockedContextClassFixedPool;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************

// class for RefCount buffer

class CSyncEvent
{
public:
	CSyncEvent()		// Constructor
		{
			m_hEvent = NULL;
			m_pFPOOLSyncEvent = NULL;
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CSyncEvent::~CSyncEvent"
	~CSyncEvent()		// Destructor
		{
			DNASSERT(m_hEvent == NULL);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CSyncEvent::FPMAlloc"
	BOOL FPMAlloc( void *const pvContext )
		{
			DNASSERT(m_hEvent == NULL);

			m_pFPOOLSyncEvent = static_cast<CLockedContextClassFixedPool<CSyncEvent>*>(pvContext);
			if ((m_hEvent = CreateEvent(NULL,TRUE,FALSE,NULL)) == NULL)
			{
				DNASSERT(FALSE);
				return(FALSE);
			}
			return(TRUE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CSyncEvent::FPMInitialize"
	BOOL FPMInitialize( void *const pvContext )
		{
			DNASSERT(pvContext != NULL);

			Reset();
			return(TRUE);
		};

	void FPMRelease( void *const pvContext )
		{
		};

	void FPMDealloc( void *const pvContext )
		{
			CloseHandle(m_hEvent);
			m_hEvent = NULL;
		};

	void ReturnSelfToPool( void )
		{
			m_pFPOOLSyncEvent->Release( this );
		};

	HRESULT Reset( void ) const
		{
			if (ResetEvent(m_hEvent) == 0)
			{
				return(DPNERR_GENERIC);
			}
			return(DPN_OK);
		}

	HRESULT Set( void ) const
		{
			if (SetEvent(m_hEvent) == 0)
			{
				return(DPNERR_GENERIC);
			}
			return(DPN_OK);
		}

	HRESULT WaitForEvent(const DWORD dwMilliSeconds) const
		{
			if (WaitForSingleObject(m_hEvent,dwMilliSeconds) != WAIT_OBJECT_0)
			{
				return(DPNERR_GENERIC);
			}
			return(DPN_OK);
		}

private:
	HANDLE						m_hEvent;
	CLockedContextClassFixedPool< CSyncEvent >	*m_pFPOOLSyncEvent;	// source FP of RefCountBuffers
};

#undef DPF_MODNAME

#endif	// __SYNC_EVENT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\user.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       User.cpp
 *  Content:    DNET user call-back routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  08/02/99	mjn		Created
 *	01/06/00	mjn		Moved NameTable stuff to NameTable.h
 *	01/07/00	mjn		Allow reply in DN_UserIndicateConnect
 *	01/08/00	mjn		DN_UserIndicateConnect provides failed buffer back to DN_UserConnectComplete
 *	01/10/00	mjn		Added DN_UserUpdateAppDesc
 *	01/16/00	mjn		Upgraded to new UserMessageHandler definition
 *	01/17/00	mjn		Added DN_UserHostMigrate
 *	01/17/00	mjn		Implemented send time
 *  01/18/00	rmt		Added calls into voice layer for events
 *	01/22/00	mjn		Added DN_UserHostDestroyPlayer
 *	01/27/00	mjn		Added support for retention of receive buffers
 *	01/28/00	mjn		Added DN_UserConnectionTerminated
 *	02/01/00	mjn		Implement Player/Group context values
 *	02/01/00	mjn		Implement Player/Group context values
 *	03/24/00	mjn		Set player context through INDICATE_CONNECT notification
 *	04/04/00	mjn		Added DN_UserTerminateSession()
 *	04/05/00	mjn		Updated DN_UserHostDestroyPlayer()
 *	04/18/00	mjn		Added DN_UserReturnBuffer
 *				mjn		Added ppvReplyContext to DN_UserIndicateConnect
 *	04/19/00	mjn		Removed hAsyncOp (unused) from DPNMSG_INDICATE_CONNECT
 *	06/26/00	mjn		Added reasons for DELETE_PLAYER and DESTROY_GROUP
 *	07/29/00	mjn		Added DNUserIndicatedConnectAborted()
 *				mjn		DNUserConnectionTerminated() supercedes DN_TerminateSession()
 *				mjn		Added HRESULT to DNUserReturnBuffer()
 *	07/30/00	mjn		Added pAddressDevice to DNUserIndicateConnect()
 *				mjn		Use DNUserTerminateSession() rather than DNUserConnectionTerminated()
 *	07/31/00	mjn		DN_UserDestroyGroup() -> DNUserDestroyGroup()
 *				mjn		DN_UserDeletePlayer() -> DNUserDestroyPlayer()
 *				mjn		Removed DN_UserHostDestroyPlayer()
 *				mjn		Renamed DPN_MSGID_ASYNC_OPERATION_COMPLETE to DPN_MSGID_ASYNC_OP_COMPLETE
 *	08/01/00	mjn		DN_UserReceive() -> DNUserReceive()
 *	08/02/00	mjn		DN_UserAddPlayer() -> DNUserCreatePlayer()
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *	08/08/00	mjn		DN_UserCreateGroup() -> DNUserCreateGroup()
 *	08/20/00	mjn		Added DNUserEnumQuery() and DNUserEnumResponse()
 *	09/17/00	mjn		Changed parameters list of DNUserCreateGroup(),DNUserCreatePlayer(),
 *						DNUserAddPlayerToGroup(),DNUserRemovePlayerFromGroup()
 *	02/05/01	mjn		Added CCallbackThread
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


// DNUserConnectComplete
//
//	Send a CONNECT_COMPLETE message to the user's message handler

#undef DPF_MODNAME
#define DPF_MODNAME "DNUserConnectComplete"

HRESULT DNUserConnectComplete(DIRECTNETOBJECT *const pdnObject,
							  const DPNHANDLE hAsyncOp,
							  PVOID const pvContext,
							  const HRESULT hr,
							  CRefCountBuffer *const pRefCountBuffer)
{
	CCallbackThread	CallbackThread;
	HRESULT			hResultCode;
	DPNMSG_CONNECT_COMPLETE	Msg;

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);

	DPFX(DPFPREP, 6,"Parameters: hAsyncOp [0x%lx], pvContext [0x%p], hr [0x%lx], pRefCountBuffer [0x%p]",
		hAsyncOp,pvContext,hr,pRefCountBuffer);

	Msg.dwSize = sizeof(DPNMSG_CONNECT_COMPLETE);
	Msg.pvUserContext = pvContext;
	Msg.hAsyncOp = hAsyncOp;
	Msg.hResultCode = hr;
	if (pRefCountBuffer)
	{
		Msg.pvApplicationReplyData = pRefCountBuffer->GetBufferAddress();
		Msg.dwApplicationReplyDataSize = pRefCountBuffer->GetBufferSize();
	}
	else
	{
		Msg.pvApplicationReplyData = NULL;
		Msg.dwApplicationReplyDataSize = 0;
	}

	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.m_bilinkCallbackThreads.InsertBefore(&pdnObject->m_bilinkCallbackThreads);
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
		DPN_MSGID_CONNECT_COMPLETE,reinterpret_cast<BYTE*>(&Msg));

	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.m_bilinkCallbackThreads.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


// DNUserIndicateConnect
//
//	Send an INDICATE_CONNECT message to the user's message handler

#undef DPF_MODNAME
#define DPF_MODNAME "DNUserIndicateConnect"

HRESULT DNUserIndicateConnect(DIRECTNETOBJECT *const pdnObject,
							  PVOID const pvConnectData,
							  const DWORD dwConnectDataSize,
							  void **const ppvReplyData,
							  DWORD *const pdwReplyDataSize,
							  void **const ppvReplyContext,
							  IDirectPlay8Address *const pAddressPlayer,
							  IDirectPlay8Address *const pAddressDevice,
							  void **const ppvPlayerContext)
{
	CCallbackThread	CallbackThread;
	HRESULT			hResultCode;
	DPNMSG_INDICATE_CONNECT	Msg;

	DPFX(DPFPREP, 6,"Parameters: pvConnectData [0x%p], dwConnectDataSize [%ld], ppvReplyData [0x%p], pdwReplyDataSize [0x%p]",
		pvConnectData,dwConnectDataSize,ppvReplyData,pdwReplyDataSize);

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);
	DNASSERT(ppvReplyData != NULL);
	DNASSERT(pdwReplyDataSize != NULL);

	Msg.dwSize = sizeof(DPNMSG_INDICATE_CONNECT);
	Msg.pvUserConnectData = pvConnectData;
	Msg.dwUserConnectDataSize = dwConnectDataSize;
	Msg.pvReplyData = NULL;
	Msg.dwReplyDataSize = 0;
	Msg.pvReplyContext = NULL;
	Msg.pvPlayerContext = NULL;
	Msg.pAddressPlayer = pAddressPlayer;
	Msg.pAddressDevice = pAddressDevice;

	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.m_bilinkCallbackThreads.InsertBefore(&pdnObject->m_bilinkCallbackThreads);
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
		DPN_MSGID_INDICATE_CONNECT,reinterpret_cast<BYTE*>(&Msg));

	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.m_bilinkCallbackThreads.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}

	*ppvReplyData = Msg.pvReplyData;
	*pdwReplyDataSize = Msg.dwReplyDataSize;
	*ppvReplyContext = Msg.pvReplyContext;
	*ppvPlayerContext = Msg.pvPlayerContext;

	if (hResultCode != DPN_OK)
	{
		hResultCode = DPNERR_HOSTREJECTEDCONNECTION;
	}

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


// DNUserIndicatedConnectAborted
//
//	Send an INDICATED_CONNECT_ABORTED message to the user's message handler

#undef DPF_MODNAME
#define DPF_MODNAME "DNUserIndicatedConnectAborted"

HRESULT DNUserIndicatedConnectAborted(DIRECTNETOBJECT *const pdnObject,
									  void *const pvPlayerContext)
{
	CCallbackThread	CallbackThread;
	HRESULT			hResultCode;
	DPNMSG_INDICATED_CONNECT_ABORTED	Msg;

	DPFX(DPFPREP, 6,"Parameters: pvPlayerContext [0x%p]",pvPlayerContext);

	DNASSERT(pdnObject != NULL);

	Msg.dwSize = sizeof(DPNMSG_INDICATED_CONNECT_ABORTED);
	Msg.pvPlayerContext = pvPlayerContext;

	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.m_bilinkCallbackThreads.InsertBefore(&pdnObject->m_bilinkCallbackThreads);
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
		DPN_MSGID_INDICATED_CONNECT_ABORTED,reinterpret_cast<BYTE*>(&Msg));

	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.m_bilinkCallbackThreads.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//	DNUserCreatePlayer
//
//	Send a CREATE_PLAYER message to the user's message handler

#undef DPF_MODNAME
#define DPF_MODNAME "DNUserCreatePlayer"

HRESULT DNUserCreatePlayer(DIRECTNETOBJECT *const pdnObject,
						   CNameTableEntry *const pNTEntry)
{
	CCallbackThread	CallbackThread;
	HRESULT				hResultCode;
	DPNMSG_CREATE_PLAYER	Msg;

	DPFX(DPFPREP, 6,"Parameters: pNTEntry [0x%p]",pNTEntry);

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);

	Voice_Notify( pdnObject, DVEVENT_ADDPLAYER, pNTEntry->GetDPNID(), 0 );

	Msg.dwSize = sizeof(DPNMSG_CREATE_PLAYER);
	Msg.dpnidPlayer = pNTEntry->GetDPNID();
	Msg.pvPlayerContext = pNTEntry->GetContext();

	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.m_bilinkCallbackThreads.InsertBefore(&pdnObject->m_bilinkCallbackThreads);
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
		DPN_MSGID_CREATE_PLAYER,reinterpret_cast<BYTE*>(&Msg));

	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.m_bilinkCallbackThreads.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}

	//
	//	Save context value on NameTableEntry
	//
	pNTEntry->Lock();
	pNTEntry->SetContext( Msg.pvPlayerContext );
	pNTEntry->SetCreated();
	pNTEntry->Unlock();

	pNTEntry->NotifyRelease();

	DPFX(DPFPREP, 7,"Set context [0x%p]",pNTEntry->GetContext());

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


// DNUserDestroyPlayer
//
//	Send a DESTROY_PLAYER message to the user's message handler

#undef DPF_MODNAME
#define DPF_MODNAME "DNUserDestroyPlayer"

HRESULT DNUserDestroyPlayer(DIRECTNETOBJECT *const pdnObject,
							CNameTableEntry *const pNTEntry)
{
	CCallbackThread	CallbackThread;
	HRESULT				hResultCode;
	DPNMSG_DESTROY_PLAYER	Msg;

	DPFX(DPFPREP, 6,"Parameters: pNTEntry [0x%p]",pNTEntry);

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);
	DNASSERT(pNTEntry != NULL);
	DNASSERT(pNTEntry->GetDPNID() != 0);
	DNASSERT(pNTEntry->GetDestroyReason() != 0);

	Voice_Notify( pdnObject, DVEVENT_REMOVEPLAYER, pNTEntry->GetDPNID(), 0 );

	Msg.dwSize = sizeof(DPNMSG_DESTROY_PLAYER);
	Msg.dpnidPlayer = pNTEntry->GetDPNID();
	Msg.pvPlayerContext = pNTEntry->GetContext();
	Msg.dwReason = pNTEntry->GetDestroyReason();

	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.m_bilinkCallbackThreads.InsertBefore(&pdnObject->m_bilinkCallbackThreads);
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
		DPN_MSGID_DESTROY_PLAYER,reinterpret_cast<BYTE*>(&Msg));

	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.m_bilinkCallbackThreads.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


// DNUserCreateGroup
//
//	Send an CREATE_GROUP message to the user's message handler

#undef DPF_MODNAME
#define DPF_MODNAME "DNUserCreateGroup"

HRESULT DNUserCreateGroup(DIRECTNETOBJECT *const pdnObject,
						  CNameTableEntry *const pNTEntry)
{
	CCallbackThread	CallbackThread;
	HRESULT				hResultCode;
	DPNMSG_CREATE_GROUP	Msg;

	DPFX(DPFPREP, 6,"Parameters: pNTEntry [0x%p]",pNTEntry);

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);

	Voice_Notify( pdnObject, DVEVENT_CREATEGROUP, pNTEntry->GetDPNID(), 0 );

	Msg.dwSize = sizeof(DPNMSG_CREATE_GROUP);
	Msg.dpnidGroup = pNTEntry->GetDPNID();
	if (pNTEntry->IsAutoDestructGroup())
	{
		Msg.dpnidOwner = pNTEntry->GetOwner();
	}
	else
	{
		Msg.dpnidOwner = 0;
	}
	Msg.pvGroupContext = pNTEntry->GetContext();

	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.m_bilinkCallbackThreads.InsertBefore(&pdnObject->m_bilinkCallbackThreads);
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
		DPN_MSGID_CREATE_GROUP,reinterpret_cast<BYTE*>(&Msg));

	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.m_bilinkCallbackThreads.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}

	//
	//	Save context value on NameTableEntry
	//
	pNTEntry->Lock();
	pNTEntry->SetContext( Msg.pvGroupContext );
	pNTEntry->SetCreated();
	pNTEntry->Unlock();

	pNTEntry->NotifyRelease();

	DPFX(DPFPREP, 7,"Set context [0x%p]",pNTEntry->GetContext());

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


// DNUserDestroyGroup
//
//	Send a DESTROY_GROUP message to the user's message handler

#undef DPF_MODNAME
#define DPF_MODNAME "DNUserDestroyGroup"

HRESULT DNUserDestroyGroup(DIRECTNETOBJECT *const pdnObject,
						   CNameTableEntry *const pNTEntry)
{
	CCallbackThread	CallbackThread;
	HRESULT				hResultCode;
	DPNMSG_DESTROY_GROUP	Msg;

	DPFX(DPFPREP, 6,"Parameters: pNTEntry [0x%p]",pNTEntry);

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);
	DNASSERT(pNTEntry != NULL);
	DNASSERT(pNTEntry->GetDPNID() != 0);
	DNASSERT(pNTEntry->GetDestroyReason() != 0);

	Voice_Notify( pdnObject, DVEVENT_DELETEGROUP, pNTEntry->GetDPNID(), 0 );

	Msg.dwSize = sizeof(DPNMSG_DESTROY_GROUP);
	Msg.dpnidGroup = pNTEntry->GetDPNID();
	Msg.pvGroupContext = pNTEntry->GetContext();
	Msg.dwReason = pNTEntry->GetDestroyReason();

	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.m_bilinkCallbackThreads.InsertBefore(&pdnObject->m_bilinkCallbackThreads);
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
		DPN_MSGID_DESTROY_GROUP,reinterpret_cast<BYTE*>(&Msg));

	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.m_bilinkCallbackThreads.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


// DNUserAddPlayerToGroup
//
//	Send an ADD_PLAYER_TO_GROUP message to the user's message handler

#undef DPF_MODNAME
#define DPF_MODNAME "DNUserAddPlayerToGroup"

HRESULT DNUserAddPlayerToGroup(DIRECTNETOBJECT *const pdnObject,
							   CNameTableEntry *const pGroup,
							   CNameTableEntry *const pPlayer)
{
	CCallbackThread	CallbackThread;
	HRESULT		hResultCode;
	DPNMSG_ADD_PLAYER_TO_GROUP	Msg;

	DPFX(DPFPREP, 6,"Parameters: pGroup [0x%p], pPlayer [0x%p]",pGroup,pPlayer);

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);
	DNASSERT(pGroup != NULL);
	DNASSERT(pPlayer != NULL);

	Voice_Notify( pdnObject, DVEVENT_ADDPLAYERTOGROUP, pGroup->GetDPNID(), pPlayer->GetDPNID() );

	Msg.dwSize = sizeof(DPNMSG_ADD_PLAYER_TO_GROUP);
	Msg.dpnidGroup = pGroup->GetDPNID();
	Msg.pvGroupContext = pGroup->GetContext();
	Msg.dpnidPlayer = pPlayer->GetDPNID();
	Msg.pvPlayerContext = pPlayer->GetContext();

	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.m_bilinkCallbackThreads.InsertBefore(&pdnObject->m_bilinkCallbackThreads);
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
		DPN_MSGID_ADD_PLAYER_TO_GROUP,reinterpret_cast<BYTE*>(&Msg));

	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.m_bilinkCallbackThreads.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


// DNUserRemovePlayerFromGroup
//
//	Send a REMOVE_PLAYER_FROM_GROUP message to the user's message handler

#undef DPF_MODNAME
#define DPF_MODNAME "DNUserRemovePlayerFromGroup"

HRESULT DNUserRemovePlayerFromGroup(DIRECTNETOBJECT *const pdnObject,
									CNameTableEntry *const pGroup,
									CNameTableEntry *const pPlayer)
{
	CCallbackThread	CallbackThread;
	HRESULT		hResultCode;
	DPNMSG_REMOVE_PLAYER_FROM_GROUP	Msg;

	DPFX(DPFPREP, 6,"Parameters: pGroup [0x%p], pPlayer [0x%p]",pGroup,pPlayer);

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);
	DNASSERT(pGroup != NULL);
	DNASSERT(pPlayer != NULL);

	Voice_Notify( pdnObject, DVEVENT_REMOVEPLAYERFROMGROUP, pGroup->GetDPNID(), pPlayer->GetDPNID());

	Msg.dwSize = sizeof(DPNMSG_REMOVE_PLAYER_FROM_GROUP);
	Msg.dpnidGroup = pGroup->GetDPNID();
	Msg.pvGroupContext = pGroup->GetContext();
	Msg.dpnidPlayer = pPlayer->GetDPNID();
	Msg.pvPlayerContext = pPlayer->GetContext();

	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.m_bilinkCallbackThreads.InsertBefore(&pdnObject->m_bilinkCallbackThreads);
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
		DPN_MSGID_REMOVE_PLAYER_FROM_GROUP,reinterpret_cast<BYTE*>(&Msg));

	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.m_bilinkCallbackThreads.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNUserUpdateGroupInfo"

HRESULT DNUserUpdateGroupInfo(DIRECTNETOBJECT *const pdnObject,
							  const DPNID dpnid,
							  const PVOID pvContext)
{
	CCallbackThread	CallbackThread;
	HRESULT				hResultCode;
	DPNMSG_GROUP_INFO	MsgGroupInfo;

	DPFX(DPFPREP, 6,"Parameters: dpnid [0x%lx], pvContext [0x%p]",dpnid,pvContext);

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);

	MsgGroupInfo.dwSize = sizeof(DPNMSG_GROUP_INFO);
	MsgGroupInfo.dpnidGroup = dpnid;
	MsgGroupInfo.pvGroupContext = pvContext;

	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.m_bilinkCallbackThreads.InsertBefore(&pdnObject->m_bilinkCallbackThreads);
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
		DPN_MSGID_GROUP_INFO,reinterpret_cast<BYTE*>(&MsgGroupInfo));

	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.m_bilinkCallbackThreads.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNUserUpdatePeerInfo"

HRESULT DNUserUpdatePeerInfo(DIRECTNETOBJECT *const pdnObject,
							 const DPNID dpnid,
							 const PVOID pvContext)
{
	CCallbackThread	CallbackThread;
	HRESULT				hResultCode;
	DPNMSG_PEER_INFO	MsgPeerInfo;

	DPFX(DPFPREP, 6,"Parameters: dpnid [0x%lx], pvContext [0x%p]",dpnid,pvContext);

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);

	MsgPeerInfo.dwSize = sizeof(DPNMSG_PEER_INFO);
	MsgPeerInfo.dpnidPeer = dpnid;
	MsgPeerInfo.pvPlayerContext = pvContext;

	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.m_bilinkCallbackThreads.InsertBefore(&pdnObject->m_bilinkCallbackThreads);
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
		DPN_MSGID_PEER_INFO,reinterpret_cast<BYTE*>(&MsgPeerInfo));

	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.m_bilinkCallbackThreads.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNUserUpdateClientInfo"

HRESULT DNUserUpdateClientInfo(DIRECTNETOBJECT *const pdnObject,
							   const DPNID dpnid,
							   const PVOID pvContext)
{
	CCallbackThread	CallbackThread;
	HRESULT				hResultCode;
	DPNMSG_CLIENT_INFO	MsgClientInfo;

	DPFX(DPFPREP, 6,"Parameters: dpnid [0x%lx], pvContext [0x%p]",dpnid,pvContext);

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);

	MsgClientInfo.dwSize = sizeof(DPNMSG_CLIENT_INFO);
	MsgClientInfo.dpnidClient = dpnid;
	MsgClientInfo.pvPlayerContext = pvContext;

	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.m_bilinkCallbackThreads.InsertBefore(&pdnObject->m_bilinkCallbackThreads);
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
		DPN_MSGID_CLIENT_INFO,reinterpret_cast<BYTE*>(&MsgClientInfo));

	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.m_bilinkCallbackThreads.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNUserUpdateServerInfo"

HRESULT DNUserUpdateServerInfo(DIRECTNETOBJECT *const pdnObject,
							   const DPNID dpnid,
							   const PVOID pvContext)
{
	CCallbackThread	CallbackThread;
	HRESULT				hResultCode;
	DPNMSG_SERVER_INFO	MsgServerInfo;

	DPFX(DPFPREP, 6,"Parameters: dpnid [0x%lx], pvContext [0x%p]",dpnid,pvContext);

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);

	MsgServerInfo.dwSize = sizeof(DPNMSG_SERVER_INFO);
	MsgServerInfo.dpnidServer = dpnid;
	MsgServerInfo.pvPlayerContext = pvContext;

	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.m_bilinkCallbackThreads.InsertBefore(&pdnObject->m_bilinkCallbackThreads);
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
		DPN_MSGID_SERVER_INFO,reinterpret_cast<BYTE*>(&MsgServerInfo));

	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.m_bilinkCallbackThreads.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


// DNUserAsyncComplete
//
//	Send a DN_MSGID_ASYNC_OPERATION_COMPLETE message to the user's message handler

#undef DPF_MODNAME
#define DPF_MODNAME "DNUserAsyncComplete"

HRESULT DNUserAsyncComplete(DIRECTNETOBJECT *const pdnObject,
							const DPNHANDLE hAsyncOp,
							PVOID const pvContext,
							const HRESULT hr)
{
	CCallbackThread	CallbackThread;
	HRESULT			hResultCode;
	DPNMSG_ASYNC_OP_COMPLETE	Msg;

	DPFX(DPFPREP, 6,"Parameters: hAsyncOp [0x%lx], pvContext [0x%p], hr [0x%lx]",hAsyncOp,pvContext,hr);

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);

	Msg.dwSize = sizeof(DPNMSG_ASYNC_OP_COMPLETE);
	Msg.hAsyncOp = hAsyncOp;
	Msg.pvUserContext = pvContext;
	Msg.hResultCode = hr;

	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.m_bilinkCallbackThreads.InsertBefore(&pdnObject->m_bilinkCallbackThreads);
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
		DPN_MSGID_ASYNC_OP_COMPLETE,reinterpret_cast<BYTE*>(&Msg));

	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.m_bilinkCallbackThreads.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


// DNUserSendComplete
//
//	Send a DN_MSGID_SEND_COMPLETE message to the user's message handler

#undef DPF_MODNAME
#define DPF_MODNAME "DNUserSendComplete"

HRESULT DNUserSendComplete(DIRECTNETOBJECT *const pdnObject,
						   const DPNHANDLE hAsyncOp,
						   PVOID const pvContext,
						   const DWORD dwStartTime,
						   const HRESULT hr)
{
	CCallbackThread	CallbackThread;
	HRESULT				hResultCode;
	DPNMSG_SEND_COMPLETE	Msg;
	DWORD				dwEndTime;

	DPFX(DPFPREP, 6,"Parameters: hAsyncOp [0x%lx], pvContext [0x%p], hr [0x%lx]",hAsyncOp,pvContext,hr);

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);

	Msg.dwSize = sizeof(DPNMSG_SEND_COMPLETE);
	Msg.hAsyncOp = hAsyncOp;
	Msg.pvUserContext = pvContext;
	Msg.hResultCode = hr;
	dwEndTime = GETTIMESTAMP();
	Msg.dwSendTime = dwEndTime - dwStartTime;

	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.m_bilinkCallbackThreads.InsertBefore(&pdnObject->m_bilinkCallbackThreads);
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
		DPN_MSGID_SEND_COMPLETE,reinterpret_cast<BYTE*>(&Msg));

	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.m_bilinkCallbackThreads.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


// DNUserUpdateAppDesc
//
//	Send a DN_MSGID_APPLICATION_DESC message to the user's message handler

#undef DPF_MODNAME
#define DPF_MODNAME "DNUserUpdateAppDesc"

HRESULT DNUserUpdateAppDesc(DIRECTNETOBJECT *const pdnObject)
{
	CCallbackThread	CallbackThread;
	HRESULT			hResultCode;

	DPFX(DPFPREP, 6,"Parameters: (none)");

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);

	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.m_bilinkCallbackThreads.InsertBefore(&pdnObject->m_bilinkCallbackThreads);
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
			DPN_MSGID_APPLICATION_DESC,NULL);

	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.m_bilinkCallbackThreads.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


// DN_UserReceive
//
//	Send a DN_MSGID_RECEIVE message to the user's message handler

#undef DPF_MODNAME
#define DPF_MODNAME "DN_UserReceive"

HRESULT DNUserReceive(DIRECTNETOBJECT *const pdnObject,
					  CNameTableEntry *const pNTEntry,
					  BYTE *const pBufferData,
					  const DWORD dwBufferSize,
					  const DPNHANDLE hBufferHandle)
{
	CCallbackThread	CallbackThread;
	HRESULT			hResultCode;
	DPNMSG_RECEIVE	Msg;

	DPFX(DPFPREP, 6,"Parameters: pNTEntry [0x%p], pBufferData [0x%p], dwBufferSize [%ld], hBufferHandle [0x%lx]",
			pNTEntry,pBufferData,dwBufferSize,hBufferHandle);

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);
	DNASSERT(pNTEntry != NULL);

	Msg.dwSize = sizeof(DPNMSG_RECEIVE);
	Msg.pReceiveData = pBufferData;
	Msg.dwReceiveDataSize = dwBufferSize;
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_CLIENT)
	{
		Msg.dpnidSender = 0;
	}
	else
	{
		Msg.dpnidSender = pNTEntry->GetDPNID();
	}
	Msg.pvPlayerContext = pNTEntry->GetContext();
	Msg.hBufferHandle = hBufferHandle;

	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.m_bilinkCallbackThreads.InsertBefore(&pdnObject->m_bilinkCallbackThreads);
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
			DPN_MSGID_RECEIVE,reinterpret_cast<BYTE*>(&Msg));

	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.m_bilinkCallbackThreads.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}

	if (hResultCode != DPNERR_PENDING)
	{
		hResultCode = DPN_OK;
	}

	pNTEntry->NotifyRelease();

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


// DN_UserHostMigrate
//
//	Send a DN_MSGID_HOST_MIGRATE message to the user's message handler

#undef DPF_MODNAME
#define DPF_MODNAME "DN_UserHostMigrate"

HRESULT DN_UserHostMigrate(DIRECTNETOBJECT *const pdnObject,
						   const DPNID dpnidNewHost,
						   const PVOID pvPlayerContext)
{
	CCallbackThread	CallbackThread;
	HRESULT				hResultCode;
	DPNMSG_HOST_MIGRATE	Msg;

	DPFX(DPFPREP, 6,"Parameters: (none)");

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);

	Voice_Notify( pdnObject, DVEVENT_MIGRATEHOST, dpnidNewHost, 0 );

	Msg.dwSize = sizeof(DPNMSG_HOST_MIGRATE);
	Msg.dpnidNewHost = dpnidNewHost;
	Msg.pvPlayerContext = pvPlayerContext;

	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.m_bilinkCallbackThreads.InsertBefore(&pdnObject->m_bilinkCallbackThreads);
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
			DPN_MSGID_HOST_MIGRATE,reinterpret_cast<BYTE*>(&Msg));

	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.m_bilinkCallbackThreads.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


// DNUserTerminateSession
//
//	Send a DN_MSGID_CONNECTION_TERMINATED message to the user's message handler

#undef DPF_MODNAME
#define DPF_MODNAME "DNUserTerminateSession"

HRESULT DNUserTerminateSession(DIRECTNETOBJECT *const pdnObject,
							   const HRESULT hr,
							   void *const pvTerminateData,
							   const DWORD dwTerminateDataSize)
{
	CCallbackThread	CallbackThread;
	HRESULT			hResultCode;
	DPNMSG_TERMINATE_SESSION	Msg;

	DPFX(DPFPREP, 6,"Parameters: hr [0x%lx],pvTerminateData [0x%p], dwTerminateDataSize [%ld]",
			hr,pvTerminateData,dwTerminateDataSize);

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);

	Msg.dwSize = sizeof(DPNMSG_TERMINATE_SESSION);
	Msg.hResultCode = hr;
	Msg.pvTerminateData = pvTerminateData;
	Msg.dwTerminateDataSize = dwTerminateDataSize;

	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.m_bilinkCallbackThreads.InsertBefore(&pdnObject->m_bilinkCallbackThreads);
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
			DPN_MSGID_TERMINATE_SESSION,reinterpret_cast<BYTE*>(&Msg));

	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.m_bilinkCallbackThreads.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


// DNUserReturnBuffer
//
//	Send a DPN_MSGID_RETURN_BUFFER message to the user's message handler

#undef DPF_MODNAME
#define DPF_MODNAME "DNUserReturnBuffer"

HRESULT DNUserReturnBuffer(DIRECTNETOBJECT *const pdnObject,
						   const HRESULT hr,
						   void *const pvBuffer,
						   void *const pvUserContext)
{
	CCallbackThread	CallbackThread;
	HRESULT					hResultCode;
	DPNMSG_RETURN_BUFFER	Msg;

	DPFX(DPFPREP, 6,"Parameters: hr [0x%lx], pvBuffer [0x%p], pvUserContext [0x%p]",hr,pvBuffer,pvUserContext);

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);

	Msg.dwSize = sizeof(DPNMSG_RETURN_BUFFER);
	Msg.hResultCode = hr;
	Msg.pvBuffer = pvBuffer;
	Msg.pvUserContext = pvUserContext;

	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.m_bilinkCallbackThreads.InsertBefore(&pdnObject->m_bilinkCallbackThreads);
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
			DPN_MSGID_RETURN_BUFFER,reinterpret_cast<BYTE*>(&Msg));

	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.m_bilinkCallbackThreads.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


// DNUserEnumQuery
//
//	Send a DPN_MSGID_ENUM_QUERY message to the user's message handler

#undef DPF_MODNAME
#define DPF_MODNAME "DNUserEnumQuery"

HRESULT DNUserEnumQuery(DIRECTNETOBJECT *const pdnObject,
						DPNMSG_ENUM_HOSTS_QUERY *const pMsg)
{
	CCallbackThread	CallbackThread;
	HRESULT		hResultCode;

	DPFX(DPFPREP, 6,"Parameters: pMsg [0x%p]",pMsg);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pMsg != NULL);

	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.m_bilinkCallbackThreads.InsertBefore(&pdnObject->m_bilinkCallbackThreads);
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
			DPN_MSGID_ENUM_HOSTS_QUERY,reinterpret_cast<BYTE*>(pMsg));

	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.m_bilinkCallbackThreads.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


// DNUserEnumResponse
//
//	Send a DPN_MSGID_ENUM_RESPONSE message to the user's message handler

#undef DPF_MODNAME
#define DPF_MODNAME "DNUserEnumResponse"

HRESULT DNUserEnumResponse(DIRECTNETOBJECT *const pdnObject,
						   DPNMSG_ENUM_HOSTS_RESPONSE *const pMsg)
{
	CCallbackThread	CallbackThread;
	HRESULT		hResultCode;

	DPFX(DPFPREP, 6,"Parameters: pMsg [0x%p]",pMsg);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pMsg != NULL);

	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.m_bilinkCallbackThreads.InsertBefore(&pdnObject->m_bilinkCallbackThreads);
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
			DPN_MSGID_ENUM_HOSTS_RESPONSE,reinterpret_cast<BYTE*>(pMsg));

	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.m_bilinkCallbackThreads.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\verify.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Verify.cpp
 *  Content:    On-wire message verification
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/05/00	mjn		Created
 *	05/11/01	mjn		Ensure buffers are valid (not NULL) instead of just ASSERTing
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyApplicationDescInfo"

HRESULT DNVerifyApplicationDescInfo(void *const pOpBuffer,
									const DWORD dwOpBufferSize,
									void *const pData)
{
	HRESULT		hResultCode;
	UNALIGNED DPN_APPLICATION_DESC_INFO	*pInfo;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld], pData [0x%p]",pOpBuffer,dwOpBufferSize,pData);

	DNASSERT(pData != NULL);

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	if (static_cast<BYTE*>(pData) + sizeof(DPN_APPLICATION_DESC_INFO) > static_cast<BYTE*>(pOpBuffer) + dwOpBufferSize)
	{
		DPFERR("Application Description buffer is too small");
		goto Failure;
	}

	pInfo = static_cast<DPN_APPLICATION_DESC_INFO*>(pData);

	if (pInfo->dwSessionNameOffset > dwOpBufferSize)
	{
		DPFERR("Invalid session name offset");
		goto Failure;
	}
	if (pInfo->dwSessionNameOffset + pInfo->dwSessionNameSize > dwOpBufferSize)
	{
		DPFERR("Invalid session name size");
		goto Failure;
	}

	if (pInfo->dwPasswordOffset > dwOpBufferSize)
	{
		DPFERR("Invalid password offset");
		goto Failure;
	}
	if (pInfo->dwPasswordOffset + pInfo->dwPasswordSize > dwOpBufferSize)
	{
		DPFERR("Invalid password size");
		goto Failure;
	}

	if (pInfo->dwReservedDataOffset > dwOpBufferSize)
	{
		DPFERR("Invalid reserved data offset");
		goto Failure;
	}
	if (pInfo->dwReservedDataOffset + pInfo->dwReservedDataSize > dwOpBufferSize)
	{
		DPFERR("Invalid reserved data size");
		goto Failure;
	}

	if (pInfo->dwApplicationReservedDataOffset > dwOpBufferSize)
	{
		DPFERR("Invalid application reserved data offset");
		goto Failure;
	}
	if (pInfo->dwApplicationReservedDataOffset + pInfo->dwApplicationReservedDataSize > dwOpBufferSize)
	{
		DPFERR("Invalid application reserved data size");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyNameTableEntryInfo"

HRESULT DNVerifyNameTableEntryInfo(void *const pOpBuffer,
								   const DWORD dwOpBufferSize,
								   void *const pData)
{
	HRESULT		hResultCode;
	UNALIGNED DN_NAMETABLE_ENTRY_INFO	*pInfo;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld], pData [0x%p]",pOpBuffer,dwOpBufferSize,pData);

	DNASSERT(pData != NULL);

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	if (static_cast<BYTE*>(pData) + sizeof(DN_NAMETABLE_ENTRY_INFO) > static_cast<BYTE*>(pOpBuffer) + dwOpBufferSize)
	{
		DPFERR("NameTable Entry buffer is too small");
		goto Failure;
	}
	
	pInfo = static_cast<DN_NAMETABLE_ENTRY_INFO*>(pData);

	if (pInfo->dwNameOffset > dwOpBufferSize)
	{
		DPFERR("Invalid name offset");
		goto Failure;
	}
	if (pInfo->dwNameOffset + pInfo->dwNameSize > dwOpBufferSize)
	{
		DPFERR("Invalid name size");
		goto Failure;
	}

	if (pInfo->dwDataOffset > dwOpBufferSize)
	{
		DPFERR("Invalid data offset");
		goto Failure;
	}
	if (pInfo->dwDataOffset + pInfo->dwDataSize > dwOpBufferSize)
	{
		DPFERR("Invalid data size");
		goto Failure;
	}

	if (pInfo->dwURLOffset > dwOpBufferSize)
	{
		DPFERR("Invalid URL offset");
		goto Failure;
	}
	if (pInfo->dwURLOffset + pInfo->dwURLSize > dwOpBufferSize)
	{
		DPFERR("Invalid URL size");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyNameTableInfo"

HRESULT DNVerifyNameTableInfo(void *const pOpBuffer,
							  const DWORD dwOpBufferSize,
							  void *const pData)
{
	HRESULT		hResultCode;
	DWORD		dw;
	UNALIGNED DN_NAMETABLE_INFO	*pInfo;
	UNALIGNED DN_NAMETABLE_ENTRY_INFO	*pNTEntryInfo;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld], pData [0x%p]",pOpBuffer,dwOpBufferSize,pData);

	DNASSERT(pOpBuffer != NULL);
	DNASSERT(pData != NULL);

	if (static_cast<BYTE*>(pData) + sizeof(DN_NAMETABLE_INFO) > static_cast<BYTE*>(pOpBuffer) + dwOpBufferSize)
	{
		DPFERR("NameTable buffer is too small");
		goto Failure;
	}
	
	pInfo = static_cast<DN_NAMETABLE_INFO*>(pData);

	if (	reinterpret_cast<BYTE*>(pInfo+1) +
			(pInfo->dwEntryCount * sizeof(DN_NAMETABLE_ENTRY_INFO)) +
			(pInfo->dwMembershipCount * sizeof(DN_NAMETABLE_MEMBERSHIP_INFO)) > static_cast<BYTE*>(pOpBuffer) + dwOpBufferSize)
	{
		DPFERR("NameTable buffer is too small");
		goto Failure;
	}

	pNTEntryInfo = reinterpret_cast<DN_NAMETABLE_ENTRY_INFO*>(pInfo+1);
	for (dw = 0 ; dw < pInfo->dwEntryCount ; dw++, pNTEntryInfo++)
	{
		if (DNVerifyNameTableEntryInfo(pOpBuffer,dwOpBufferSize,pNTEntryInfo) != DPN_OK)
		{
			DPFERR("Invalid NameTable Entry in NameTable");
			goto Failure;
		}
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyPlayerConnectInfo"

HRESULT DNVerifyPlayerConnectInfo(void *const pOpBuffer,
								  const DWORD dwOpBufferSize)
{
	HRESULT		hResultCode;
	UNALIGNED DN_INTERNAL_MESSAGE_PLAYER_CONNECT_INFO	*pInfo;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld]",pOpBuffer,dwOpBufferSize);

	if (dwOpBufferSize < sizeof(DN_INTERNAL_MESSAGE_PLAYER_CONNECT_INFO))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	pInfo = static_cast<DN_INTERNAL_MESSAGE_PLAYER_CONNECT_INFO*>(pOpBuffer);

	if (pInfo->dwNameOffset > dwOpBufferSize)
	{
		DPFERR("Invalid name offset");
		goto Failure;
	}
	if (pInfo->dwNameOffset + pInfo->dwNameSize > dwOpBufferSize)
	{
		DPFERR("Invalid name size");
		goto Failure;
	}

	if (pInfo->dwPasswordOffset > dwOpBufferSize)
	{
		DPFERR("Invalid password offset");
		goto Failure;
	}
	if (pInfo->dwPasswordOffset + pInfo->dwPasswordSize > dwOpBufferSize)
	{
		DPFERR("Invalid password size");
		goto Failure;
	}

	if (pInfo->dwDataOffset > dwOpBufferSize)
	{
		DPFERR("Invalid data offset");
		goto Failure;
	}
	if (pInfo->dwDataOffset + pInfo->dwDataSize > dwOpBufferSize)
	{
		DPFERR("Invalid data size");
		goto Failure;
	}

	if (pInfo->dwURLOffset > dwOpBufferSize)
	{
		DPFERR("Invalid URL offset");
		goto Failure;
	}
	if (pInfo->dwURLOffset + pInfo->dwURLSize > dwOpBufferSize)
	{
		DPFERR("Invalid URL size");
		goto Failure;
	}

	if (pInfo->dwConnectDataOffset > dwOpBufferSize)
	{
		DPFERR("Invalid connect data offset");
		goto Failure;
	}
	if (pInfo->dwConnectDataOffset + pInfo->dwConnectDataSize > dwOpBufferSize)
	{
		DPFERR("Invalid connect data size");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyConnectInfo"

HRESULT DNVerifyConnectInfo(void *const pOpBuffer,
							const DWORD dwOpBufferSize)
{
	HRESULT		hResultCode;
	UNALIGNED DN_INTERNAL_MESSAGE_CONNECT_INFO	*pInfo;
	UNALIGNED DPN_APPLICATION_DESC_INFO	*pdnAppDescInfo;
	UNALIGNED DN_NAMETABLE_INFO			*pdnNTInfo;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld]",pOpBuffer,dwOpBufferSize);

	if (dwOpBufferSize < (sizeof(DN_INTERNAL_MESSAGE_CONNECT_INFO) + sizeof(DPN_APPLICATION_DESC_INFO) + sizeof(DN_NAMETABLE_INFO)))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	pInfo = static_cast<DN_INTERNAL_MESSAGE_CONNECT_INFO*>(pOpBuffer);
	pdnAppDescInfo = reinterpret_cast<DPN_APPLICATION_DESC_INFO*>(pInfo + 1);
	pdnNTInfo = reinterpret_cast<DN_NAMETABLE_INFO*>(pdnAppDescInfo + 1);

	if (pInfo->dwReplyOffset > dwOpBufferSize)
	{
		DPFERR("Invalid reply offset");
		goto Failure;
	}
	if (pInfo->dwReplyOffset + pInfo->dwReplySize > dwOpBufferSize)
	{
		DPFERR("Invalid reply size");
	}

	if (DNVerifyApplicationDescInfo(pOpBuffer,dwOpBufferSize,pdnAppDescInfo) != DPN_OK)
	{
		DPFERR("Invalid application description");
		goto Failure;
	}

	if (DNVerifyNameTableInfo(pOpBuffer,dwOpBufferSize,pdnNTInfo) != DPN_OK)
	{
		DPFERR("Invalid nametable");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifySendPlayerDPNID"

HRESULT DNVerifySendPlayerDPNID(void *const pOpBuffer,
								const DWORD dwOpBufferSize)
{
	HRESULT		hResultCode;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld]",pOpBuffer,dwOpBufferSize);

	if (dwOpBufferSize < sizeof(DN_INTERNAL_MESSAGE_SEND_PLAYER_DPNID))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyConnectFailed"

HRESULT DNVerifyConnectFailed(void *const pOpBuffer,
							  const DWORD dwOpBufferSize)
{
	HRESULT		hResultCode;
	UNALIGNED DN_INTERNAL_MESSAGE_CONNECT_FAILED	*pInfo;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld]",pOpBuffer,dwOpBufferSize);

	if (dwOpBufferSize < sizeof(DN_INTERNAL_MESSAGE_CONNECT_FAILED))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	pInfo = static_cast<DN_INTERNAL_MESSAGE_CONNECT_FAILED*>(pOpBuffer);

	if (pInfo->dwReplyOffset > dwOpBufferSize)
	{
		DPFERR("Invalid reply offset");
		goto Failure;
	}
	if (pInfo->dwReplyOffset + pInfo->dwReplySize > dwOpBufferSize)
	{
		DPFERR("Invalid reply size");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyInstructConnect"

HRESULT DNVerifyInstructConnect(void *const pOpBuffer,
								const DWORD dwOpBufferSize)
{
	HRESULT		hResultCode;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld]",pOpBuffer,dwOpBufferSize);

	if (dwOpBufferSize < sizeof(DN_INTERNAL_MESSAGE_INSTRUCT_CONNECT))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyInstructedConnectFailed"

HRESULT DNVerifyInstructedConnectFailed(void *const pOpBuffer,
										const DWORD dwOpBufferSize)
{
	HRESULT		hResultCode;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld]",pOpBuffer,dwOpBufferSize);

	if (dwOpBufferSize < sizeof(DN_INTERNAL_MESSAGE_INSTRUCTED_CONNECT_FAILED))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyConnectAttemptFailed"

HRESULT DNVerifyConnectAttemptFailed(void *const pOpBuffer,
									 const DWORD dwOpBufferSize)
{
	HRESULT		hResultCode;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld]",pOpBuffer,dwOpBufferSize);

	if (dwOpBufferSize < sizeof(DN_INTERNAL_MESSAGE_CONNECT_ATTEMPT_FAILED))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyNameTableVersion"

HRESULT DNVerifyNameTableVersion(void *const pOpBuffer,
								 const DWORD dwOpBufferSize)
{
	HRESULT		hResultCode;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld]",pOpBuffer,dwOpBufferSize);

	if (dwOpBufferSize < sizeof(DN_INTERNAL_MESSAGE_NAMETABLE_VERSION))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyResyncVersion"

HRESULT DNVerifyResyncVersion(void *const pOpBuffer,
							  const DWORD dwOpBufferSize)
{
	HRESULT		hResultCode;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld]",pOpBuffer,dwOpBufferSize);

	if (dwOpBufferSize < sizeof(DN_INTERNAL_MESSAGE_RESYNC_VERSION))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyReqNameTableOp"

HRESULT DNVerifyReqNameTableOp(void *const pOpBuffer,
							   const DWORD dwOpBufferSize)
{
	HRESULT		hResultCode;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld]",pOpBuffer,dwOpBufferSize);

	if (dwOpBufferSize < sizeof(DN_INTERNAL_MESSAGE_REQ_NAMETABLE_OP))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyAckNameTableOp"

HRESULT DNVerifyAckNameTableOp(void *const pOpBuffer,
							   const DWORD dwOpBufferSize)
{
	HRESULT		hResultCode;
	DWORD		dw;
	UNALIGNED DN_INTERNAL_MESSAGE_ACK_NAMETABLE_OP	*pAck;
	UNALIGNED DN_NAMETABLE_OP_INFO	*pInfo;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld]",pOpBuffer,dwOpBufferSize);

	if (dwOpBufferSize < sizeof(DN_INTERNAL_MESSAGE_ACK_NAMETABLE_OP))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	pAck = static_cast<DN_INTERNAL_MESSAGE_ACK_NAMETABLE_OP*>(pOpBuffer);

	if (sizeof(DN_INTERNAL_MESSAGE_ACK_NAMETABLE_OP) + (pAck->dwNumEntries * sizeof(DN_NAMETABLE_OP_INFO)) > dwOpBufferSize)
	{
		DPFERR("NameTable operation buffer is too small");
		goto Failure;
	}

	pInfo = reinterpret_cast<DN_NAMETABLE_OP_INFO*>(pAck+1);
	for (dw = 0 ; dw < pAck->dwNumEntries ; dw++)
	{
		if (pInfo->dwOpOffset > dwOpBufferSize)
		{
			DPFERR("Invalid nametable operation offset");
			goto Failure;
		}
		if (pInfo->dwOpOffset + pInfo->dwOpSize > dwOpBufferSize)
		{
			DPFERR("Invalid nametable operation size");
			goto Failure;
		}

		switch(pInfo->dwMsgId)
		{
		case DN_MSG_INTERNAL_INSTRUCT_CONNECT:
			{
				if (DNVerifyInstructConnect(static_cast<BYTE*>(pOpBuffer)+pInfo->dwOpOffset,pInfo->dwOpSize) != DPN_OK)
				{
					DPFERR("Invalid NameTable operation");
					goto Failure;
				}
				break;
			}
		case DN_MSG_INTERNAL_ADD_PLAYER:
			{
				if (DNVerifyNameTableEntryInfo(	static_cast<BYTE*>(pOpBuffer)+pInfo->dwOpOffset,
												pInfo->dwOpSize,
												static_cast<BYTE*>(pOpBuffer)+pInfo->dwOpOffset) != DPN_OK)
				{
					DPFERR("Invalid NameTable operation");
					goto Failure;
				}
				break;
			}
		case DN_MSG_INTERNAL_DESTROY_PLAYER:
			{
				if (DNVerifyDestroyPlayer(static_cast<BYTE*>(pOpBuffer)+pInfo->dwOpOffset,pInfo->dwOpSize) != DPN_OK)
				{
					DPFERR("Invalid NameTable operation");
					goto Failure;
				}
				break;
			}
		case DN_MSG_INTERNAL_CREATE_GROUP:
			{
				if (DNVerifyCreateGroup(static_cast<BYTE*>(pOpBuffer)+pInfo->dwOpOffset,
										pInfo->dwOpSize,
										static_cast<BYTE*>(pOpBuffer)+pInfo->dwOpOffset) != DPN_OK)
				{
					DPFERR("Invalid NameTable operation");
					goto Failure;
				}
				break;
			}
		case DN_MSG_INTERNAL_DESTROY_GROUP:
			{
				if (DNVerifyDestroyGroup(static_cast<BYTE*>(pOpBuffer)+pInfo->dwOpOffset,pInfo->dwOpSize) != DPN_OK)
				{
					DPFERR("Invalid NameTable operation");
					goto Failure;
				}
				break;
			}
		case DN_MSG_INTERNAL_ADD_PLAYER_TO_GROUP:
			{
				if (DNVerifyAddPlayerToGroup(static_cast<BYTE*>(pOpBuffer)+pInfo->dwOpOffset,pInfo->dwOpSize) != DPN_OK)
				{
					DPFERR("Invalid NameTable operation");
					goto Failure;
				}
				break;
			}
		case DN_MSG_INTERNAL_DELETE_PLAYER_FROM_GROUP:
			{
				if (DNVerifyDeletePlayerFromGroup(static_cast<BYTE*>(pOpBuffer)+pInfo->dwOpOffset,pInfo->dwOpSize) != DPN_OK)
				{
					DPFERR("Invalid NameTable operation");
					goto Failure;
				}
				break;
			}
		case DN_MSG_INTERNAL_UPDATE_INFO:
			{
				if (DNVerifyUpdateInfo(	static_cast<BYTE*>(pOpBuffer)+pInfo->dwOpOffset,
										pInfo->dwOpSize,
										static_cast<BYTE*>(pOpBuffer)+pInfo->dwOpOffset) != DPN_OK)
				{
					DPFERR("Invalid NameTable operation");
					goto Failure;
				}
				break;
			}
		default:
			{
				DPFERR("Invalid NameTable op - ignore and continue");
				break;
			}
		}
		pInfo++;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyHostMigrate"

HRESULT DNVerifyHostMigrate(void *const pOpBuffer,
							const DWORD dwOpBufferSize)
{
	HRESULT		hResultCode;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld]",pOpBuffer,dwOpBufferSize);

	if (dwOpBufferSize < sizeof(DN_INTERNAL_MESSAGE_HOST_MIGRATE))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyDestroyPlayer"

HRESULT DNVerifyDestroyPlayer(void *const pOpBuffer,
							  const DWORD dwOpBufferSize)
{
	HRESULT		hResultCode;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld]",pOpBuffer,dwOpBufferSize);

	if (dwOpBufferSize < sizeof(DN_INTERNAL_MESSAGE_DESTROY_PLAYER))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyCreateGroup"

HRESULT DNVerifyCreateGroup(void *const pOpBuffer,
							const DWORD dwOpBufferSize,
							void *const pData)
{
	HRESULT		hResultCode;
	UNALIGNED DN_INTERNAL_MESSAGE_CREATE_GROUP	*pInfo;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld], pData [0x%p]",pOpBuffer,dwOpBufferSize,pData);

	if (dwOpBufferSize < sizeof(DN_INTERNAL_MESSAGE_CREATE_GROUP))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	if (static_cast<BYTE*>(pData) + sizeof(DN_INTERNAL_MESSAGE_CREATE_GROUP) > static_cast<BYTE*>(pOpBuffer) + dwOpBufferSize)
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	pInfo = static_cast<DN_INTERNAL_MESSAGE_CREATE_GROUP*>(pData);

	if (reinterpret_cast<BYTE*>(pInfo+1) + sizeof(DN_NAMETABLE_ENTRY_INFO) > static_cast<BYTE*>(pOpBuffer) + dwOpBufferSize)
	{
		DPFERR("NameTable entry info buffer is too small !");
		goto Failure;
	}

	if (DNVerifyNameTableEntryInfo(pOpBuffer,dwOpBufferSize,pInfo+1) != DPN_OK)
	{
		DPFERR("Invalid NameTable entry info");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyDestroyGroup"

HRESULT DNVerifyDestroyGroup(void *const pOpBuffer,
							 const DWORD dwOpBufferSize)
{
	HRESULT		hResultCode;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld]",pOpBuffer,dwOpBufferSize);

	if (dwOpBufferSize < sizeof(DN_INTERNAL_MESSAGE_DESTROY_GROUP))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyAddPlayerToGroup"

HRESULT DNVerifyAddPlayerToGroup(void *const pOpBuffer,
								 const DWORD dwOpBufferSize)
{
	HRESULT		hResultCode;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld]",pOpBuffer,dwOpBufferSize);

	if (dwOpBufferSize < sizeof(DN_INTERNAL_MESSAGE_ADD_PLAYER_TO_GROUP))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyDeletePlayerFromGroup"

HRESULT DNVerifyDeletePlayerFromGroup(void *const pOpBuffer,
									  const DWORD dwOpBufferSize)
{
	HRESULT		hResultCode;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld]",pOpBuffer,dwOpBufferSize);

	if (dwOpBufferSize < sizeof(DN_INTERNAL_MESSAGE_DELETE_PLAYER_FROM_GROUP))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyUpdateInfo"

HRESULT DNVerifyUpdateInfo(void *const pOpBuffer,
						   const DWORD dwOpBufferSize,
						   void *const pData)
{
	HRESULT		hResultCode;
	UNALIGNED DN_INTERNAL_MESSAGE_UPDATE_INFO	*pInfo;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld], pData [0x%p]",pOpBuffer,dwOpBufferSize,pData);

	if (dwOpBufferSize < sizeof(DN_INTERNAL_MESSAGE_UPDATE_INFO))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	if (static_cast<BYTE*>(pData) + sizeof(DN_INTERNAL_MESSAGE_UPDATE_INFO) > static_cast<BYTE*>(pOpBuffer) + dwOpBufferSize)
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	pInfo = static_cast<DN_INTERNAL_MESSAGE_UPDATE_INFO*>(pData);

	if (pInfo->dwNameOffset > dwOpBufferSize)
	{
		DPFERR("Invalid name offset");
		goto Failure;
	}
	if (pInfo->dwNameOffset + pInfo->dwNameSize > dwOpBufferSize)
	{
		DPFERR("Invalid name size");
		goto Failure;
	}

	if (pInfo->dwDataOffset > dwOpBufferSize)
	{
		DPFERR("Invalid data offset");
		goto Failure;
	}
	if (pInfo->dwDataOffset + pInfo->dwDataSize > dwOpBufferSize)
	{
		DPFERR("Invalid data size");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyReqCreateGroup"

HRESULT DNVerifyReqCreateGroup(void *const pOpBuffer,
							   const DWORD dwOpBufferSize,
							   void *const pData)
{
	HRESULT		hResultCode;
	UNALIGNED DN_INTERNAL_MESSAGE_REQ_CREATE_GROUP	*pInfo;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld], pData [0x%p]",pOpBuffer,dwOpBufferSize,pData);

	if (dwOpBufferSize < sizeof(DN_INTERNAL_MESSAGE_REQ_CREATE_GROUP))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	if (static_cast<BYTE*>(pData) + sizeof(DN_INTERNAL_MESSAGE_REQ_CREATE_GROUP) > static_cast<BYTE*>(pOpBuffer) + dwOpBufferSize)
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	pInfo = static_cast<DN_INTERNAL_MESSAGE_REQ_CREATE_GROUP*>(pData);

	if (pInfo->dwNameOffset > dwOpBufferSize)
	{
		DPFERR("Invalid name offset");
		goto Failure;
	}
	if (pInfo->dwNameOffset + pInfo->dwNameSize > dwOpBufferSize)
	{
		DPFERR("Invalid name size");
		goto Failure;
	}

	if (pInfo->dwDataOffset > dwOpBufferSize)
	{
		DPFERR("Invalid data offset");
		goto Failure;
	}
	if (pInfo->dwDataOffset + pInfo->dwDataSize > dwOpBufferSize)
	{
		DPFERR("Invalid data size");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyReqDestroyGroup"

HRESULT DNVerifyReqDestroyGroup(void *const pOpBuffer,
								const DWORD dwOpBufferSize)
{
	HRESULT		hResultCode;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld]",pOpBuffer,dwOpBufferSize);

	if (dwOpBufferSize < sizeof(DN_INTERNAL_MESSAGE_REQ_DESTROY_GROUP))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyReqAddPlayerToGroup"

HRESULT DNVerifyReqAddPlayerToGroup(void *const pOpBuffer,
									const DWORD dwOpBufferSize)
{
	HRESULT		hResultCode;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld]",pOpBuffer,dwOpBufferSize);

	if (dwOpBufferSize < sizeof(DN_INTERNAL_MESSAGE_REQ_ADD_PLAYER_TO_GROUP))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyReqDeletePlayerFromGroup"

HRESULT DNVerifyReqDeletePlayerFromGroup(void *const pOpBuffer,
										 const DWORD dwOpBufferSize)
{
	HRESULT		hResultCode;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld]",pOpBuffer,dwOpBufferSize);

	if (dwOpBufferSize < sizeof(DN_INTERNAL_MESSAGE_REQ_DELETE_PLAYER_FROM_GROUP))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyReqUpdateInfo"

HRESULT DNVerifyReqUpdateInfo(void *const pOpBuffer,
							  const DWORD dwOpBufferSize,
							  void *const pData)
{
	HRESULT		hResultCode;
	UNALIGNED DN_INTERNAL_MESSAGE_REQ_UPDATE_INFO	*pInfo;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld], pData [0x%p]",pOpBuffer,dwOpBufferSize,pData);

	if (dwOpBufferSize < sizeof(DN_INTERNAL_MESSAGE_REQ_UPDATE_INFO))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	if (static_cast<BYTE*>(pData) + sizeof(DN_INTERNAL_MESSAGE_REQ_UPDATE_INFO) > static_cast<BYTE*>(pOpBuffer) + dwOpBufferSize)
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	pInfo = static_cast<DN_INTERNAL_MESSAGE_REQ_UPDATE_INFO*>(pData);

	if (pInfo->dwNameOffset > dwOpBufferSize)
	{
		DPFERR("Invalid name offset");
		goto Failure;
	}
	if (pInfo->dwNameOffset + pInfo->dwNameSize > dwOpBufferSize)
	{
		DPFERR("Invalid name size");
		goto Failure;
	}

	if (pInfo->dwDataOffset > dwOpBufferSize)
	{
		DPFERR("Invalid data offset");
		goto Failure;
	}
	if (pInfo->dwDataOffset + pInfo->dwDataSize > dwOpBufferSize)
	{
		DPFERR("Invalid data size");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyRequestFailed"

HRESULT DNVerifyRequestFailed(void *const pOpBuffer,
							  const DWORD dwOpBufferSize)
{
	HRESULT		hResultCode;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld]",pOpBuffer,dwOpBufferSize);

	if (dwOpBufferSize < sizeof(DN_INTERNAL_MESSAGE_REQUEST_FAILED))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyTerminateSession"

HRESULT DNVerifyTerminateSession(void *const pOpBuffer,
								 const DWORD dwOpBufferSize)
{
	HRESULT		hResultCode;
	UNALIGNED DN_INTERNAL_MESSAGE_TERMINATE_SESSION	*pInfo;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld]",pOpBuffer,dwOpBufferSize);

	if (dwOpBufferSize < sizeof(DN_INTERNAL_MESSAGE_TERMINATE_SESSION))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	pInfo = static_cast<DN_INTERNAL_MESSAGE_TERMINATE_SESSION*>(pOpBuffer);

	if (pInfo->dwTerminateDataOffset > dwOpBufferSize)
	{
		DPFERR("Invalid terminate data offset");
		goto Failure;
	}
	if (pInfo->dwTerminateDataOffset + pInfo->dwTerminateDataSize > dwOpBufferSize)
	{
		DPFERR("Invalid terminate data size");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyReqProcessCompletion"

HRESULT DNVerifyReqProcessCompletion(void *const pOpBuffer,
									 const DWORD dwOpBufferSize)
{
	HRESULT		hResultCode;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld]",pOpBuffer,dwOpBufferSize);

	if (dwOpBufferSize < sizeof(DN_INTERNAL_MESSAGE_REQ_PROCESS_COMPLETION))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyProcessCompletion"

HRESULT DNVerifyProcessCompletion(void *const pOpBuffer,
								  const DWORD dwOpBufferSize)
{
	HRESULT		hResultCode;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld]",pOpBuffer,dwOpBufferSize);

	if (dwOpBufferSize < sizeof(DN_INTERNAL_MESSAGE_PROCESS_COMPLETION))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyReqIntegrityCheck"

HRESULT DNVerifyReqIntegrityCheck(void *const pOpBuffer,
								  const DWORD dwOpBufferSize)
{
	HRESULT		hResultCode;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld]",pOpBuffer,dwOpBufferSize);

	if (dwOpBufferSize < sizeof(DN_INTERNAL_MESSAGE_REQ_INTEGRITY_CHECK))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyIntegrityCheck"

HRESULT DNVerifyIntegrityCheck(void *const pOpBuffer,
							   const DWORD dwOpBufferSize)
{
	HRESULT		hResultCode;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld]",pOpBuffer,dwOpBufferSize);

	if (dwOpBufferSize < sizeof(DN_INTERNAL_MESSAGE_INTEGRITY_CHECK))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyIntegrityCheckResponse"

HRESULT DNVerifyIntegrityCheckResponse(void *const pOpBuffer,
									   const DWORD dwOpBufferSize)
{
	HRESULT		hResultCode;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld]",pOpBuffer,dwOpBufferSize);

	if (dwOpBufferSize < sizeof(DN_INTERNAL_MESSAGE_INTEGRITY_CHECK_RESPONSE))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\worker.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       worker.h
 *  Content:    DIRECT NET WORKER THREAD HEADER FILE
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  11/09/99	mjn		Created
 *  12/23/99	mjn		Hand all NameTable update sends from Host to worker thread
 *  12/23/99	mjn		Added SendHostMigration functionality
 *	01/09/00	mjn		Send Connect Info rather than just NameTable at connect
 *	01/10/00	mjn		Added support to update application descriptions
 *	01/15/00	mjn		Replaced DN_COUNT_BUFFER with CRefCountBuffer
 *	01/16/00	mjn		Removed user notification jobs
 *	01/23/00	mjn		Implemented TerminateSession
 *	01/24/00	mjn		Added support for NameTable operation list cleanup
 *	04/04/00	mjn		Added support for TerminateSession
 *	04/13/00	mjn		Added dwFlags for internal sends
 *	04/17/00	mjn		Replaced BUFFERDESC with DPN_BUFFER_DESC
 *	04/19/00	mjn		Added support to send NameTable operations directly
 *	06/21/00	mjn		Added support to install the NameTable (from Host)
 *	07/06/00	mjn		Use SP handle instead of interface
 *	07/30/00	mjn		Added DN_WORKER_JOB_TERMINATE_SESSION
 *	08/02/00	mjn		Added DN_WORKER_JOB_ALTERNATE_SEND
 *	08/08/00	mjn		Added DNWTPerformListen()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__WORKER_H__
#define	__WORKER_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

void DNQueueWorkerJob(DIRECTNETOBJECT *const pdnObject,
					  CWorkerJob *const pWorkerJob);

// DirectNet - Worker Thread Routines
DWORD WINAPI DNWorkerThreadProc(PVOID pvParam);

HRESULT DNWTTerminate(DIRECTNETOBJECT *const pdnObject);

HRESULT DNWTSendInternal(DIRECTNETOBJECT *const pdnObject,
						 DPN_BUFFER_DESC *prgBufferDesc,
						 CAsyncOp *const pAsyncOp);

HRESULT DNWTProcessSend(DIRECTNETOBJECT *const pdnObject,
						CWorkerJob *const pWorkerJob);

HRESULT	DNWTTerminateSession(DIRECTNETOBJECT *const pdnObject,
							 CWorkerJob *const pWorkerJob);

HRESULT DNWTSendNameTableVersion(DIRECTNETOBJECT *const pdnObject,
								 CWorkerJob *const pWorkerJob);

HRESULT DNWTRemoveServiceProvider(DIRECTNETOBJECT *const pdnObject,
								  CWorkerJob *const pWorkerJob);

void DNWTSendNameTableOperation(DIRECTNETOBJECT *const pdnObject,
								CWorkerJob *const pWorkerJob);
void DNWTSendNameTableOperationClient(DIRECTNETOBJECT *const pdnObject,
								CWorkerJob *const pWorkerJob);
void DNWTInstallNameTable(DIRECTNETOBJECT *const pdnObject,
						  CWorkerJob *const pWorkerJob);

void DNWTPerformListen(DIRECTNETOBJECT *const pdnObject,
					   CWorkerJob *const pWorkerJob);

//**********************************************************************
// Class prototypes
//**********************************************************************

#endif	// __WORKER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\worker.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       worker.cpp
 *  Content:    DNET worker thread routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  11/01/99	mjn		Created
 *  12/23/99	mjn		Hand all NameTable update sends from Host to worker thread
 *  12/23/99	mjn		Added SendHostMigration functionality
 *	12/28/99	mjn		Moved Async Op stuff to Async.h
 *	01/06/00	mjn		Moved NameTable stuff to NameTable.h
 *	01/09/00	mjn		Send Connect Info rather than just NameTable at connect
 *	01/10/00	mjn		Added SendUpdateApplicationDesc functionality
 *	01/15/00	mjn		Replaced DN_COUNT_BUFFER with CRefCountBuffer
 *	01/16/00	mjn		Removed user notification jobs
 *	01/23/00	mjn		Implemented TerminateSession
 *	01/24/00	mjn		Added support for NameTable operation list cleanup
 *	01/27/00	mjn		Added support for retention of receive buffers
 *	04/04/00	mjn		Added DNWTSendTerminateSession
 *	04/10/00	mjn		Added DNWTRemoveServiceProvider
 *	04/13/00	mjn		Internal sends use new Protocol Interface VTBL functions
 *				mjn		Internal sends contain dwFlags field
 *	04/16/00	mjn		DNSendMessage uses CAsyncOp
 *	04/17/00	mjn		Replaced BUFFERDESC with DPN_BUFFER_DESC
 *	04/19/00	mjn		Added support to send NameTable operations directly
 *	04/23/00	mjn		Added parameter to DNPerformChildSend()
 *	05/03/00	mjn		Use GetHostPlayerRef() rather than GetHostPlayer()
 *	05/05/00	mjn		Use GetConnectionRef() to send NameTable operations
 *	05/10/00	mjn		Ensure valid local player in DNWTProcessSend()
 *	06/07/00	mjn		Pull assert in send failure case (it was handled)
 *	06/21/00	mjn		Added support to install the NameTable (from Host)
 *	06/22/00	mjn		Fixed DNWTProcessSend() to properly handle voice messages
 *	07/06/00	mjn		Use SP handle instead of interface
 *	07/21/00	mjn		RefCount cleanup
 *	07/30/00	mjn		Added DN_WORKER_JOB_TERMINATE_SESSION
 *	08/02/00	mjn		Changed DNWTProcessSend() to pass voice messages to DNReceiveUserData()
 *				mjn		Added DN_WORKER_JOB_ALTERNATE_SEND
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *	08/05/00	mjn		Added pParent to DNSendGroupMessage and DNSendMessage()
 *				mjn		Added fInternal to DNPerformChildSend()
 *	08/06/00	mjn		Added CWorkerJob
 *				mjn		Added DNQueueWorkerJob()
 *				mjn		Made DNWTSendNameTableOperation() more robust
 *	08/07/00	mjn		Removed COM_CoInitialize() and COM_CoUninitialize() calls in DNWorkerThreadProc()
 *	08/08/00	mjn		Added WORKER_JOB_PERFORM_LISTEN,DNWTPerformListen()
 *	03/30/01	mjn		Changes to prevent multiple loading/unloading of SP's
 *	06/06/01	mjn		Added back in COM_CoInitialize() and COM_CoUninitialize() calls to DNWorkerThreadProc()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


#undef DPF_MODNAME
#define DPF_MODNAME "DNWorkerThreadProc"

DWORD WINAPI DNWorkerThreadProc(PVOID pvParam)
{
	DIRECTNETOBJECT		*pdnObject;
	CWorkerJob			*pWorkerJob;
	BOOL				fTerminate;
	HRESULT				hResultCode;

	DPFX(DPFPREP, 4,"Worker thread starting");

	DNASSERT(pvParam != NULL);
	pdnObject = static_cast<DIRECTNETOBJECT*>(pvParam);

	if ((hResultCode = COM_CoInitialize(NULL)) != S_OK)
	{
		DPFERR("COM_CoInitialize failed !");
		DisplayDNError(0,hResultCode);
		goto Exit;
	}

	fTerminate = FALSE;
	while (!fTerminate)
	{
		DPFX(DPFPREP, 5,"Worker thread waiting ...");
		if (WaitForSingleObject(pdnObject->hWorkerEvent,INFINITE) != WAIT_OBJECT_0)
			break;
		DPFX(DPFPREP, 5,"Worker thread signalled");

		// Reset Event
		DPFX(DPFPREP, 5,"Resetting worker thread job event");
		if (!ResetEvent(pdnObject->hWorkerEvent))
			break;

		//
		//	Process all jobs on queue
		//
		while (!fTerminate)
		{
			pWorkerJob = NULL;
			DNEnterCriticalSection(&pdnObject->csWorkerQueue);
			if (pdnObject->m_bilinkWorkerJobs.GetNext() != &pdnObject->m_bilinkWorkerJobs)
			{
				pWorkerJob = CONTAINING_OBJECT(pdnObject->m_bilinkWorkerJobs.GetNext(),CWorkerJob,m_bilinkWorkerJobs);
				pWorkerJob->m_bilinkWorkerJobs.RemoveFromList();
			}
			DNLeaveCriticalSection(&pdnObject->csWorkerQueue);

			if (pWorkerJob == NULL)
			{
				break;
			}

			DPFX(DPFPREP, 5,"Extracted job id [0x%lx]",pWorkerJob->GetJobType());
			switch(pWorkerJob->GetJobType())
			{
				case WORKER_JOB_INSTALL_NAMETABLE:
					{
						DPFX(DPFPREP, 5,"Job: WORKER_JOB_INSTALL_NAMETABLE");
						DNWTInstallNameTable(pdnObject,pWorkerJob);
						break;
					}
				case WORKER_JOB_INTERNAL_SEND:
					{
						DPFX(DPFPREP, 5,"Job: WORKER_JOB_INTERNAL_SEND");
						DNWTProcessSend(pdnObject,pWorkerJob);
						break;
					}
				case WORKER_JOB_PERFORM_LISTEN:
					{
						DPFX(DPFPREP, 5,"Job: WORKER_JOB_PERFORM_LISTEN");
						DNWTPerformListen(pdnObject,pWorkerJob);
						break;
					}
				case WORKER_JOB_REMOVE_SERVICE_PROVIDER:
					{
						DPFX(DPFPREP, 5,"Job: WORKER_JOB_REMOVE_SERVICE_PROVIDER");
						DNWTRemoveServiceProvider(pdnObject,pWorkerJob);
						break;
					}
				case WORKER_JOB_SEND_NAMETABLE_OPERATION:
					{
						DPFX(DPFPREP, 5,"Job: WORKER_JOB_SEND_NAMETABLE_OPERATION");
						DNWTSendNameTableOperation(pdnObject,pWorkerJob);
						break;
					}
				case WORKER_JOB_SEND_NAMETABLE_OPERATION_CLIENT:
					{
						DPFX(DPFPREP, 5,"Job: WORKER_JOB_SEND_NAMETABLE_OPERATION_CLIENT");
						DNWTSendNameTableOperationClient(pdnObject,pWorkerJob);
						break;
					}
				case WORKER_JOB_SEND_NAMETABLE_VERSION:
					{
						DPFX(DPFPREP, 5,"Job: WORKER_JOB_SEND_NAMETABLE_VERSION");
						DNWTSendNameTableVersion(pdnObject,pWorkerJob);
						break;
					}
				case WORKER_JOB_TERMINATE:
					{
						DPFX(DPFPREP, 5,"Job: WORKER_JOB_TERMINATE");
						fTerminate = TRUE;
						break;
					}
				case WORKER_JOB_TERMINATE_SESSION:
					{
						DPFX(DPFPREP, 5,"Job: WORKER_JOB_TERMINATE_SESSION");
						DNWTTerminateSession(pdnObject,pWorkerJob);
						break;
					}
				case WORKER_JOB_UNKNOWN:
				default:
					{
						DPFERR("Unknown Job !");
						DNASSERT(FALSE);
						break;
					}
			}

			//
			//	Return this job to the queue (clean up is automatic)
			//
			pWorkerJob->ReturnSelfToPool();
			pWorkerJob = NULL;
		}
		DPFX(DPFPREP, 5,"Processed all jobs on queue at this time");
	}

	COM_CoUninitialize();

Exit:
	DPFX(DPFPREP, 4,"Worker thread terminating");
	return(0);
}


//	DNQueueWorkerJob
//
//	Add a worker thread job to the end of the job queue, and signal the queue to run

#undef DPF_MODNAME
#define DPF_MODNAME "DNQueueWorkerJob"

void DNQueueWorkerJob(DIRECTNETOBJECT *const pdnObject,
					  CWorkerJob *const pWorkerJob)
{
	DPFX(DPFPREP, 6,"Parameters: pWorkerJob [0x%p]",pWorkerJob);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pWorkerJob != NULL);

	DPFX(DPFPREP, 7,"Adding job to worker job queue");
	DNEnterCriticalSection(&pdnObject->csWorkerQueue);
	pWorkerJob->m_bilinkWorkerJobs.InsertBefore(&pdnObject->m_bilinkWorkerJobs);
	DNLeaveCriticalSection(&pdnObject->csWorkerQueue);

	DPFX(DPFPREP, 7,"Signalling Worker Thread");
	SetEvent(pdnObject->hWorkerEvent);

	DPFX(DPFPREP, 6,"Returning");
}


//	DNWTTerminate
//
//	Request the worker thread to terminate by placing a terminate message on its job queue.

#undef DPF_MODNAME
#define DPF_MODNAME "DNWTTerminate"

HRESULT DNWTTerminate(DIRECTNETOBJECT *const pdnObject)
{
	HRESULT		hResultCode;
	CWorkerJob	*pWorkerJob;

	DPFX(DPFPREP, 6,"Adding Terminate to Job Queue");
	if ((hResultCode = WorkerJobNew(pdnObject,&pWorkerJob)) == DPN_OK)
	{
		pWorkerJob->SetJobType( WORKER_JOB_TERMINATE );

		DNQueueWorkerJob(pdnObject,pWorkerJob);
		pWorkerJob = NULL;
	}
	else
	{
		DPFERR("Could not create worker job - ignore and continue");
		DisplayDNError(0,hResultCode);
	}

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//	DNWTSendInternal
//
//	Send an internal message. This will copy the message buffer and place the operation on the
//	working thread job queue

#undef DPF_MODNAME
#define DPF_MODNAME "DNWTSendInternal"

HRESULT DNWTSendInternal(DIRECTNETOBJECT *const pdnObject,
						 DPN_BUFFER_DESC *prgBufferDesc,
						 CAsyncOp *const pAsyncOp)
{
	HRESULT				hResultCode;
	DWORD				dwJobBufferSize;
	DPN_BUFFER_DESC		*pHeaderBuffer;
	DPN_BUFFER_DESC		*pDataBuffer;
	CWorkerJob			*pWorkerJob;
	CRefCountBuffer		*pRefCountBuffer;
	DPN_BUFFER_DESC		*pdnBufferDesc;

	DPFX(DPFPREP, 6,"Parameters: prgBufferDesc [0x%p], pAsyncOp [0x%p]",prgBufferDesc,pAsyncOp);

	pRefCountBuffer = NULL;
	pWorkerJob = NULL;

	// Get buffers
	pHeaderBuffer = prgBufferDesc;
	pDataBuffer = prgBufferDesc + 1;

	// Create local buffer
	dwJobBufferSize = pHeaderBuffer->dwBufferSize + pDataBuffer->dwBufferSize;
	if ((hResultCode = RefCountBufferNew(pdnObject,dwJobBufferSize,&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not allocate space for local buffer");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	else
	{
		DPFX(DPFPREP, 7,"Allocated RefCount Buffer [0x%p] - [%ld] bytes",pRefCountBuffer,dwJobBufferSize);
		pdnBufferDesc = pRefCountBuffer->BufferDescAddress();
		memcpy(	pdnBufferDesc->pBufferData,
				pHeaderBuffer->pBufferData,
				pHeaderBuffer->dwBufferSize);
		memcpy(	pdnBufferDesc->pBufferData + pHeaderBuffer->dwBufferSize,
				pDataBuffer->pBufferData,
				pDataBuffer->dwBufferSize);

		//	TODO - user context value of send ?
		DPFX(DPFPREP, 7,"Adding Internal Send to Job Queue");
		if ((hResultCode = WorkerJobNew(pdnObject,&pWorkerJob)) == DPN_OK)
		{
			pWorkerJob->SetJobType( WORKER_JOB_INTERNAL_SEND );
			pWorkerJob->SetInternalSendFlags( pAsyncOp->GetOpFlags() );
			pWorkerJob->SetRefCountBuffer( pRefCountBuffer );

			DNQueueWorkerJob(pdnObject,pWorkerJob);
			pWorkerJob = NULL;

			//
			//	Invoke send completion handler
			//
			DNPICompleteSend(	pdnObject,
								static_cast<void*>(pAsyncOp),
								DPN_OK);
			
			hResultCode = DPNERR_PENDING;
		}
		else
		{
			DPFERR("Could not create worker job");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
	}

	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	goto Exit;
}


//	DNWTProcessSend
//
//	Process an internal send message.  This will indicate a received user message, or process a received internal one.

#undef DPF_MODNAME
#define DPF_MODNAME "DNWTProcessSend"

HRESULT DNWTProcessSend(DIRECTNETOBJECT *const pdnObject,
						CWorkerJob *const pWorkerJob)
{
	HRESULT		hResultCode;
	void		*pvData;
	DWORD		dwDataSize;
	void		*pvInternalData;
	DWORD		dwInternalDataSize;
	DWORD		*pdwMsgId;
	CNameTableEntry	*pLocalPlayer;
	CConnection		*pConnection;
	CRefCountBuffer	*pRefCountBuffer;

	DPFX(DPFPREP, 6,"Parameters: pWorkerJob [0x%p]",pWorkerJob);

	pLocalPlayer = NULL;
	pConnection = NULL;
	pRefCountBuffer = NULL;

	//
	//	Extract and clear RefCountBuffer from job
	//
	DNASSERT(pWorkerJob->GetRefCountBuffer() != NULL);
	pRefCountBuffer = pWorkerJob->GetRefCountBuffer();
	pWorkerJob->SetRefCountBuffer( NULL );

	//
	//	Get local player's connection (if still valid)
	//
	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Local player not in NameTable (shutting down ?)");
		DisplayDNError(0,hResultCode);
		hResultCode = DPN_OK;
		goto Failure;
	}
	if ((hResultCode = pLocalPlayer->GetConnectionRef( &pConnection )) != DPN_OK)
	{
		DPFERR("Local player connection is not valid (shutting down?)");
		DisplayDNError(0,hResultCode);
		hResultCode = DPN_OK;
		goto Failure;
	}
	pLocalPlayer->Release();
	pLocalPlayer = NULL;

	DNASSERT(pRefCountBuffer->GetBufferAddress() != NULL);
	pvData = pRefCountBuffer->GetBufferAddress();
	dwDataSize = pRefCountBuffer->GetBufferSize();

	if ((pWorkerJob->GetInternalSendFlags() & DN_SENDFLAGS_SET_USER_FLAG)
			&& !(pWorkerJob->GetInternalSendFlags() & DN_SENDFLAGS_SET_USER_FLAG_TWO))
	{
		//
		//	Internal message
		//
		DPFX(DPFPREP, 7,"Received INTERNAL message");

		// Extract internal message
		DNASSERT(dwDataSize >= sizeof(DWORD));
		pdwMsgId = static_cast<DWORD*>(pvData);
		dwInternalDataSize = dwDataSize - sizeof(DWORD);
		if (dwInternalDataSize > 0)
		{
			pvInternalData = static_cast<void*>(static_cast<BYTE*>(pvData) + sizeof(DWORD));
		}
		else
		{
			pvInternalData = NULL;
		}

		// Process internal message
		hResultCode = DNProcessInternalOperation(	pdnObject,
													*pdwMsgId,
													pvInternalData,
													dwInternalDataSize,
													pConnection,
													NULL,
													pRefCountBuffer);
	}
	else
	{
		//
		//	User or voice message
		//
		DPFX(DPFPREP, 7,"Received USER or Voice message");

		hResultCode = DNReceiveUserData(pdnObject,
										pConnection->GetDPNID(),
										pConnection->GetSP(),
										static_cast<BYTE*>(pvData),
										dwDataSize,
										NULL,
										pRefCountBuffer,
										0,
										pWorkerJob->GetInternalSendFlags());
	}

	//
	//	Clean up
	//
	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

	pConnection->Release();
	pConnection = NULL;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	goto Exit;
}


//	DNWTTerminateSession
//
//	Disconnect the Local player from the session

#undef DPF_MODNAME
#define DPF_MODNAME "DNWTTerminateSession"

HRESULT	DNWTTerminateSession(DIRECTNETOBJECT *const pdnObject,
							 CWorkerJob *const pWorkerJob)
{
	HRESULT		hResultCode;

	DPFX(DPFPREP, 6,"Parameters: pWorkerJob [0x%p]",pWorkerJob);

	// Terminate session
	hResultCode = DNTerminateSession(pdnObject,pWorkerJob->GetTerminateSessionReason());

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//	DNWTSendNameTableVersion
//
//	Send NAMETABLE_VERSION message to the host player

#undef DPF_MODNAME
#define DPF_MODNAME "DNWTSendNameTableVersion"

HRESULT DNWTSendNameTableVersion(DIRECTNETOBJECT *const pdnObject,
								 CWorkerJob *const pWorkerJob)
{
	HRESULT			hResultCode;
	CRefCountBuffer	*pRefCountBuffer;
	CNameTableEntry	*pHostPlayer;
	CConnection		*pConnection;

	DPFX(DPFPREP, 6,"Parameters: pWorkerJob [0x%p]",pWorkerJob);

	pRefCountBuffer = NULL;
	pHostPlayer = NULL;
	pConnection = NULL;

	//
	//	Extract and clear RefCountBuffer from job
	//
	DNASSERT(pWorkerJob->GetRefCountBuffer() != NULL);
	pRefCountBuffer = pWorkerJob->GetRefCountBuffer();
	pWorkerJob->SetRefCountBuffer( NULL );

	// Send message to host player
	if ((hResultCode = pdnObject->NameTable.GetHostPlayerRef( &pHostPlayer )) != DPN_OK)
	{
		DPFERR("Could not find Host player");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	if ((hResultCode = pHostPlayer->GetConnectionRef( &pConnection )) != DPN_OK)
	{
		DPFERR("Could not get Connection reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	hResultCode = DNSendMessage(pdnObject,
								pConnection,
								DN_MSG_INTERNAL_NAMETABLE_VERSION,
								pHostPlayer->GetDPNID(),
								pRefCountBuffer->BufferDescAddress(),
								pRefCountBuffer,
								0,
								DN_SENDFLAGS_RELIABLE,
								NULL,
								NULL);
	if (hResultCode != DPNERR_PENDING)
	{
		DPFERR("Could not send message to Host player");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pConnection->Release();
	pConnection = NULL;
	pHostPlayer->Release();
	pHostPlayer = NULL;
	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pHostPlayer)
	{
		pHostPlayer->Release();
		pHostPlayer = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	goto Exit;
}


//	DNWTRemoveServiceProvider
//
//	Remove a ServiceProvider from the Protocol

#undef DPF_MODNAME
#define DPF_MODNAME "DNWTRemoveServiceProvider"

HRESULT DNWTRemoveServiceProvider(DIRECTNETOBJECT *const pdnObject,
								  CWorkerJob *const pWorkerJob)
{
	HRESULT		hResultCode;

	DPFX(DPFPREP, 6,"Parameters: pWorkerJob [0x%p]",pWorkerJob);

	DNASSERT(pWorkerJob->GetRemoveServiceProviderHandle() != NULL);

	hResultCode = DNPRemoveServiceProvider(pdnObject->pdnProtocolData,pWorkerJob->GetRemoveServiceProviderHandle());

	DNProtocolRelease(pdnObject);

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//	DNWTSendNameTableOperation
//
//	Send a NameTable operation to each connected player
//	This is based on the version number supplied and an excluded DPNID

#undef DPF_MODNAME
#define DPF_MODNAME "DNWTSendNameTableOperation"

void DNWTSendNameTableOperation(DIRECTNETOBJECT *const pdnObject,
								CWorkerJob *const pWorkerJob)
{
	HRESULT		hResultCode;
	CAsyncOp	*pParent;
	CBilink		*pBilink;
	CNameTableEntry	*pNTEntry;
	DWORD		dwMsgId;
	DWORD		dwVersion;
	DPNID		dpnidExclude;
	DWORD		dwCount;
	DWORD		dwActual;
	DWORD		dw;
	CConnection **TargetList;

	DPFX(DPFPREP, 6,"Parameters: pWorkerJob [0x%p]",pWorkerJob);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pWorkerJob != NULL);

	pParent = NULL;
	pNTEntry = NULL;
	TargetList = NULL;

	dwMsgId = pWorkerJob->GetSendNameTableOperationMsgId();
	dwVersion = pWorkerJob->GetSendNameTableOperationVersion();
	dpnidExclude = pWorkerJob->GetSendNameTableOperationDPNIDExclude();

	hResultCode = DNCreateSendParent(	pdnObject,
										dwMsgId,
										pWorkerJob->GetRefCountBuffer()->BufferDescAddress(),
										DN_SENDFLAGS_RELIABLE | DN_SENDFLAGS_SET_USER_FLAG,
										&pParent);
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not create AsyncOp");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pParent->SetRefCountBuffer(pWorkerJob->GetRefCountBuffer());

	//
	//	Lock NameTable
	//
	pdnObject->NameTable.ReadLock();

	//
	//	Determine recipient list
	//
	dwCount = 0;
	dwActual = 0;
	pBilink = pdnObject->NameTable.m_bilinkPlayers.GetNext();
	while (pBilink != &pdnObject->NameTable.m_bilinkPlayers)
	{
		pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
		if (	   !pNTEntry->IsDisconnecting()
				&& !pNTEntry->IsLocal()
				&& ((dwVersion == 0) || (pNTEntry->GetVersion() < dwVersion))
				&& ((dpnidExclude == 0) || (pNTEntry->GetDPNID() != dpnidExclude))
			)
		{
			dwCount++;
		}
		pBilink = pBilink->GetNext();
	}
	DPFX(DPFPREP, 7,"Number of targets [%ld]",dwCount);

	//
	//	Create target list
	//
	if (dwCount > 0)
	{
		if ((TargetList = reinterpret_cast<CConnection**>(MemoryBlockAlloc(pdnObject,dwCount * sizeof(CConnection*)))) == NULL)
		{
			DPFERR("Could not create target list");
			DNASSERT(FALSE);
			goto Failure;
		}

		pBilink = pdnObject->NameTable.m_bilinkPlayers.GetNext();
		while (pBilink != &pdnObject->NameTable.m_bilinkPlayers)
		{
			pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
			if (	   !pNTEntry->IsDisconnecting()
					&& !pNTEntry->IsLocal()
					&& ((dwVersion == 0) || (pNTEntry->GetVersion() < dwVersion))
					&& ((dpnidExclude == 0) || (pNTEntry->GetDPNID() != dpnidExclude))
				)
			{
				DNASSERT(dwActual < dwCount);
				if ((hResultCode = pNTEntry->GetConnectionRef( &(TargetList[dwActual]) )) == DPN_OK)
				{
					dwActual++;
				}
			}
			pBilink = pBilink->GetNext();
		}
		DPFX(DPFPREP, 7,"Actual number of targets [%ld]",dwActual);
	}

	//
	//	Unlock NameTable
	//
	pdnObject->NameTable.Unlock();

	//
	//	Send to target list
	//
	if (TargetList)
	{
		for (dw = 0 ; dw < dwActual ; dw++)
		{
			DNASSERT(TargetList[dw] != NULL);

			hResultCode = DNPerformChildSend(	pdnObject,
												pParent,
												TargetList[dw],
												0,
												NULL,
												TRUE);
			if (hResultCode != DPNERR_PENDING)
			{
				DPFERR("Could not perform part of group send - ignore and continue");
				DisplayDNError(0,hResultCode);
			}
			TargetList[dw]->Release();
			TargetList[dw] = NULL;
		}

		MemoryBlockFree(pdnObject,TargetList);
		TargetList = NULL;
	}

	pParent->Release();
	pParent = NULL;

Exit:
	DPFX(DPFPREP, 6,"Returning");
	return;

Failure:
	if (pParent)
	{
		pParent->Release();
		pParent = NULL;
	}
	if (TargetList)
	{
		MemoryBlockFree(pdnObject,TargetList);
		TargetList = NULL;
	}
	goto Exit;
}

//	DNWTSendNameTableOperationClient
//
//	Send a NameTable operation to a single client
//	This is based on the version number supplied and a DPNID

#undef DPF_MODNAME
#define DPF_MODNAME "DNWTSendNameTableOperationClient"

void DNWTSendNameTableOperationClient(DIRECTNETOBJECT *const pdnObject,
									  CWorkerJob *const pWorkerJob)
{
	HRESULT		hResultCode;
	CAsyncOp	*pParent;
	CNameTableEntry	*pNTEntry;
	DWORD		dwMsgId;
	DWORD		dwVersion;
	DPNID		dpnid;
	CConnection *pConnection;

	DPFX(DPFPREP, 6,"Parameters: pWorkerJob [0x%p]",pWorkerJob);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pWorkerJob != NULL);

	pParent = NULL;
	pNTEntry = NULL;
	pConnection = NULL;

	dwMsgId = pWorkerJob->GetSendNameTableOperationMsgId();
	dwVersion = pWorkerJob->GetSendNameTableOperationVersion();
	dpnid = pWorkerJob->GetSendNameTableOperationDPNIDExclude();

	hResultCode = DNCreateSendParent(	pdnObject,
										dwMsgId,
										pWorkerJob->GetRefCountBuffer()->BufferDescAddress(),
										DN_SENDFLAGS_RELIABLE | DN_SENDFLAGS_SET_USER_FLAG,
										&pParent);
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not create AsyncOp");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pParent->SetRefCountBuffer(pWorkerJob->GetRefCountBuffer());

	//
	//	Lookup player
	//
	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnid,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not find player");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	if ((hResultCode = pNTEntry->GetConnectionRef( &pConnection )) != DPN_OK)
	{
		DPFERR("Could not get connection for player");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pNTEntry->Release();
	pNTEntry = NULL;

	hResultCode = DNPerformChildSend(	pdnObject,
										pParent,
										pConnection,
										0,
										NULL,
										TRUE);
	if (hResultCode != DPNERR_PENDING)
	{
		DPFERR("Could not perform send - ignore and continue");
		DisplayDNError(0,hResultCode);
	}
	pConnection->Release();
	pConnection = NULL;

	pParent->Release();
	pParent = NULL;

Exit:
	DPFX(DPFPREP, 6,"Returning");
	return;

Failure:
	if (pParent)
	{
		pParent->Release();
		pParent = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	goto Exit;
}

//	DNWTInstallNameTable
//
//	Install the Host sent NameTable and ApplicationDescription.  We will also be cracking open
//	LISTENs if required.  This has to be done on the worker thread due to the async->sync
//	behaviour of LISTEN.  We can't perform it on the SP's threads.

#undef DPF_MODNAME
#define DPF_MODNAME "DNWTInstallNameTable"

void DNWTInstallNameTable(DIRECTNETOBJECT *const pdnObject,
						  CWorkerJob *const pWorkerJob)
{
	DPFX(DPFPREP, 6,"Parameters: pWorkerJob [0x%p]",pWorkerJob);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pWorkerJob != NULL);

	DNASSERT(pWorkerJob->GetConnection() != NULL);
	DNASSERT(pWorkerJob->GetRefCountBuffer() != NULL);

	DNConnectToHost2(	pdnObject,
						pWorkerJob->GetRefCountBuffer()->GetBufferAddress(),
						pWorkerJob->GetConnection() );
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNWTPerformListen"

void DNWTPerformListen(DIRECTNETOBJECT *const pdnObject,
					   CWorkerJob *const pWorkerJob)
{
	HRESULT		hResultCode;

	DPFX(DPFPREP, 6,"Parameters: pWorkerJob [0x%p]",pWorkerJob);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pWorkerJob != NULL);

	DNASSERT(pWorkerJob->GetAddress() != NULL);
	DNASSERT(pWorkerJob->GetAsyncOp() != NULL);

	hResultCode = DNPerformListen(pdnObject,pWorkerJob->GetAddress(),pWorkerJob->GetAsyncOp());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\user.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       User.h
 *  Content:    DirectNet User Call Back Routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *	01/16/00	mjn		Created
 *	01/17/00	mjn		Added DN_UserHostMigrate
 *	01/17/00	mjn		Implemented send time
 *	01/22/00	mjn		Added DN_UserHostDestroyPlayer
 *	01/27/00	mjn		Added support for retention of receive buffers
 *	01/28/00	mjn		Added DN_UserConnectionTerminated
 *	03/24/00	mjn		Set player context through INDICATE_CONNECT notification
 *	04/04/00	mjn		Added DN_UserTerminateSession()
 *	04/05/00	mjn		Updated DN_UserHostDestroyPlayer()
 *	04/18/00	mjn		Added DN_UserReturnBuffer
 *				mjn		Added ppvReplyContext to DN_UserIndicateConnect
 *	07/29/00	mjn		Added DNUserIndicatedConnectAborted()
 *				mjn		DNUserConnectionTerminated() supercedes DN_TerminateSession()
 *				mjn		Added HRESULT to DNUserReturnBuffer()
 *	07/30/00	mjn		Added pAddressDevice to DNUserIndicateConnect()
 *				mjn		Replaced DNUserConnectionTerminated() with DNUserTerminateSession()
 *	07/31/00	mjn		Revised DNUserDestroyGroup()
 *				mjn		Removed DN_UserHostDestroyPlayer()
 *	08/01/00	mjn		DN_UserReceive() -> DNUserReceive()
 *	08/02/00	mjn		DN_UserAddPlayer() -> DNUserCreatePlayer()
 *	08/08/00	mjn		DN_UserCreateGroup() -> DNUserCreateGroup()
 *	08/20/00	mjn		Added DNUserEnumQuery() and DNUserEnumResponse()
 *	09/17/00	mjn		Changed parameters list of DNUserCreateGroup(),DNUserCreatePlayer(),
 *						DNUserAddPlayerToGroup(),DNRemovePlayerFromGroup()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__USER_H__
#define	__USER_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

HRESULT DNUserConnectComplete(DIRECTNETOBJECT *const pdnObject,
							  const DPNHANDLE hAsyncOp,
							  PVOID const pvContext,
							  const HRESULT hr,
							  CRefCountBuffer *const pRefCountBuffer);

HRESULT DNUserIndicateConnect(DIRECTNETOBJECT *const pdnObject,
							  PVOID const pvConnectData,
							  const DWORD dwConnectDataSize,
							  void **const ppvReplyData,
							  DWORD *const pdwReplyDataSize,
							  void **const ppvReplyContext,
							  IDirectPlay8Address *const pAddressPlayer,
							  IDirectPlay8Address *const pAddressDevice,
							  void **const ppvPlayerContext);

HRESULT DNUserIndicatedConnectAborted(DIRECTNETOBJECT *const pdnObject,
									  void *const pvPlayerContext);

HRESULT DNUserCreatePlayer(DIRECTNETOBJECT *const pdnObject,
						   CNameTableEntry *const pNTEntry);

HRESULT DNUserDestroyPlayer(DIRECTNETOBJECT *const pdnObject,
							CNameTableEntry *const pNTEntry);

HRESULT DNUserCreateGroup(DIRECTNETOBJECT *const pdnObject,
						  CNameTableEntry *const pNTEntry);

HRESULT DNUserDestroyGroup(DIRECTNETOBJECT *const pdnObject,
						   CNameTableEntry *const pNTEntry);

HRESULT DNUserAddPlayerToGroup(DIRECTNETOBJECT *const pdnObject,
							   CNameTableEntry *const pGroup,
							   CNameTableEntry *const pPlayer);

HRESULT DNUserRemovePlayerFromGroup(DIRECTNETOBJECT *const pdnObject,
									CNameTableEntry *const pGroup,
									CNameTableEntry *const pPlayer);

HRESULT DNUserUpdateGroupInfo(DIRECTNETOBJECT *const pdnObject,
							  const DPNID dpnid,
							  const PVOID pvContext);

HRESULT DNUserUpdatePeerInfo(DIRECTNETOBJECT *const pdnObject,
							 const DPNID dpnid,
							 const PVOID pvContext);

HRESULT DNUserUpdateClientInfo(DIRECTNETOBJECT *const pdnObject,
							   const DPNID dpnid,
							   const PVOID pvContext);

HRESULT DNUserUpdateServerInfo(DIRECTNETOBJECT *const pdnObject,
							   const DPNID dpnid,
							   const PVOID pvContext);

HRESULT DNUserAsyncComplete(DIRECTNETOBJECT *const pdnObject,
							const DPNHANDLE hAsyncOp,
							PVOID const pvContext,
							const HRESULT hr);

HRESULT DNUserSendComplete(DIRECTNETOBJECT *const pdnObject,
						   const DPNHANDLE hAsyncOp,
						   PVOID const pvContext,
						   const DWORD dwStartTime,
						   const HRESULT hr);

HRESULT DNUserUpdateAppDesc(DIRECTNETOBJECT *const pdnObject);

HRESULT DNUserReceive(DIRECTNETOBJECT *const pdnObject,
					  CNameTableEntry *const pNTEntry,
					  BYTE *const pBufferData,
					  const DWORD dwBufferSize,
					  const DPNHANDLE hBufferHandle);

HRESULT DN_UserHostMigrate(DIRECTNETOBJECT *const pdnObject,
						   const DPNID dpnidNewHost,
						   const PVOID pvPlayerContext);

HRESULT DNUserTerminateSession(DIRECTNETOBJECT *const pdnObject,
							   const HRESULT hr,
							   void *const pvTerminateData,
							   const DWORD dwTerminateDataSize);

HRESULT DNUserReturnBuffer(DIRECTNETOBJECT *const pdnObject,
						   const HRESULT hr,
						   void *const pvBuffer,
						   void *const pvUserContext);

HRESULT DNUserEnumQuery(DIRECTNETOBJECT *const pdnObject,
						DPNMSG_ENUM_HOSTS_QUERY *const pMsg);

HRESULT DNUserEnumResponse(DIRECTNETOBJECT *const pdnObject,
						   DPNMSG_ENUM_HOSTS_RESPONSE *const pMsg);

//**********************************************************************
// Class prototypes
//**********************************************************************

#endif	// __USER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\verify.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Verify.h
 *  Content:    On-wire message verification header
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *	12/05/00	mjn		Created
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__VERIFY_H__
#define	__VERIFY_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

HRESULT DNVerifyApplicationDescInfo(void *const pOpBuffer,
									const DWORD dwOpBufferSize,
									void *const pData);

HRESULT DNVerifyNameTableEntryInfo(void *const pOpBuffer,
								   const DWORD dwOpBufferSize,
								   void *const pData);

HRESULT DNVerifyNameTableInfo(void *const pOpBuffer,
							  const DWORD dwOpBufferSize,
							  void *const pData);

HRESULT DNVerifyPlayerConnectInfo(void *const pOpBuffer,
								  const DWORD dwOpBufferSize);

HRESULT DNVerifyConnectInfo(void *const pOpBuffer,
							const DWORD dwOpBufferSize);

HRESULT DNVerifySendPlayerDPNID(void *const pOpBuffer,
								const DWORD dwOpBufferSize);

HRESULT DNVerifyConnectFailed(void *const pOpBuffer,
							  const DWORD dwOpBufferSize);

HRESULT DNVerifyInstructConnect(void *const pOpBuffer,
								const DWORD dwOpBufferSize);

HRESULT DNVerifyInstructedConnectFailed(void *const pOpBuffer,
										const DWORD dwOpBufferSize);

HRESULT DNVerifyConnectAttemptFailed(void *const pOpBuffer,
									 const DWORD dwOpBufferSize);

HRESULT DNVerifyNameTableVersion(void *const pOpBuffer,
								 const DWORD dwOpBufferSize);

HRESULT DNVerifyResyncVersion(void *const pOpBuffer,
							  const DWORD dwOpBufferSize);

HRESULT DNVerifyReqNameTableOp(void *const pOpBuffer,
							   const DWORD dwOpBufferSize);

HRESULT DNVerifyAckNameTableOp(void *const pOpBuffer,
							   const DWORD dwOpBufferSize);

HRESULT DNVerifyHostMigrate(void *const pOpBuffer,
							const DWORD dwOpBufferSize);

HRESULT DNVerifyDestroyPlayer(void *const pOpBuffer,
							  const DWORD dwOpBufferSize);

HRESULT DNVerifyCreateGroup(void *const pOpBuffer,
							const DWORD dwOpBufferSize,
							void *const pData);

HRESULT DNVerifyDestroyGroup(void *const pOpBuffer,
							 const DWORD dwOpBufferSize);

HRESULT DNVerifyAddPlayerToGroup(void *const pOpBuffer,
								 const DWORD dwOpBufferSize);

HRESULT DNVerifyDeletePlayerFromGroup(void *const pOpBuffer,
									  const DWORD dwOpBufferSize);

HRESULT DNVerifyUpdateInfo(void *const pOpBuffer,
						   const DWORD dwOpBufferSize,
						   void *const pData);

HRESULT DNVerifyReqCreateGroup(void *const pOpBuffer,
							   const DWORD dwOpBufferSize,
							   void *const pData);

HRESULT DNVerifyReqDestroyGroup(void *const pOpBuffer,
								const DWORD dwOpBufferSize);

HRESULT DNVerifyReqAddPlayerToGroup(void *const pOpBuffer,
									const DWORD dwOpBufferSize);

HRESULT DNVerifyReqDeletePlayerFromGroup(void *const pOpBuffer,
										 const DWORD dwOpBufferSize);

HRESULT DNVerifyReqUpdateInfo(void *const pOpBuffer,
							  const DWORD dwOpBufferSize,
							  void *const pData);

HRESULT DNVerifyRequestFailed(void *const pOpBuffer,
							  const DWORD dwOpBufferSize);

HRESULT DNVerifyTerminateSession(void *const pOpBuffer,
								 const DWORD dwOpBufferSize);

HRESULT DNVerifyReqProcessCompletion(void *const pOpBuffer,
									 const DWORD dwOpBufferSize);

HRESULT DNVerifyProcessCompletion(void *const pOpBuffer,
								  const DWORD dwOpBufferSize);

HRESULT DNVerifyReqIntegrityCheck(void *const pOpBuffer,
								  const DWORD dwOpBufferSize);

HRESULT DNVerifyIntegrityCheck(void *const pOpBuffer,
							   const DWORD dwOpBufferSize);

HRESULT DNVerifyIntegrityCheckResponse(void *const pOpBuffer,
									   const DWORD dwOpBufferSize);

//**********************************************************************
// Class prototypes
//**********************************************************************


#endif	// __VERIFY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\dnaddress\addclassfac.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ClassFac.cpp
 *  Content:    DNET COM class factory
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  07/21/99	mjn		Created
 *  02/04/2000	rmt		Adjusted for use in DPAddress
 *  02/17/2000	rmt		Parameter validation work 
 *  02/20/2000	rmt		Added parameter validation for IUnknown funcs
 * 03/21/2000   rmt     Renamed all DirectPlayAddress8's to DirectPlay8Addresses 
 *   06/20/2000 rmt     Bugfix - QueryInterface had bug which was limiting interface list to 2 elements 
 *  07/09/2000	rmt		Added signature bytes to start of address objects
 *	07/13/2000	rmt		Added critical sections to protect FPMs
 *  08/05/2000  RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *  01/11/2001	rmt		MANBUG #48487 - DPLAY: Crashes if CoCreate() isn't called.   
 *  03/14/2001   rmt		WINBUG #342420 - Restore COM emulation layer to operation.  
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dnaddri.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

typedef	STDMETHODIMP IUnknownQueryInterface( IUnknown *pInterface, REFIID riid, LPVOID *ppvObj );
typedef	STDMETHODIMP_(ULONG)	IUnknownAddRef( IUnknown *pInterface );
typedef	STDMETHODIMP_(ULONG)	IUnknownRelease( IUnknown *pInterface );

//
// VTable for IUnknown interface
//
IUnknownVtbl  DP8A_UnknownVtbl =
{
	(IUnknownQueryInterface*)	DP8A_QueryInterface,
	(IUnknownAddRef*)			DP8A_AddRef,
	(IUnknownRelease*)			DP8A_Release
};


//
// VTable for Class Factory
//
IDirectPlay8AddressClassFactVtbl DP8ACF_Vtbl  =
{
	DP8ACF_QueryInterface,
	DP8ACF_AddRef,
	DP8ACF_Release,
	DP8ACF_CreateInstance,
	DP8ACF_LockServer
};

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

static	HRESULT DP8A_CreateInterface(LPOBJECT_DATA lpObject,REFIID riid, LPINTERFACE_LIST *const ppv);

//**********************************************************************
// Function definitions
//**********************************************************************

extern IDirectPlay8AddressClassFactVtbl DP8ACF_Vtbl;
extern IUnknownVtbl  DP8A_UnknownVtbl;

// Globals
extern	DWORD	GdwHLocks;
extern	DWORD	GdwHObjects;


#undef DPF_MODNAME
#define DPF_MODNAME "DP8ACF_QueryInterface"

STDMETHODIMP DP8ACF_QueryInterface(IDirectPlay8AddressClassFact *pInterface, REFIID riid,LPVOID *ppv)
{
	_LPIDirectPlay8AddressClassFact	lpcfObj;
	HRESULT				hResultCode = S_OK;

	DPFX(DPFPREP, 3,"Parameters: pInterface [%p], riid [%p], ppv [%p]",pInterface,riid,ppv);

	lpcfObj = (_LPIDirectPlay8AddressClassFact)pInterface;
	if (IsEqualIID(riid,IID_IUnknown))
	{
		DPFX(DPFPREP, 5,"riid = IID_IUnknown");
		*ppv = pInterface;
		lpcfObj->lpVtbl->AddRef( pInterface );
	}
	else if (IsEqualIID(riid,IID_IClassFactory))
	{
		DPFX(DPFPREP, 5,"riid = IID_IClassFactory");
		*ppv = pInterface;
		lpcfObj->lpVtbl->AddRef( pInterface );
	}
	else
	{
		DPFX(DPFPREP, 5,"riid not found !");
		*ppv = NULL;
		hResultCode = E_NOINTERFACE;
	}

	DPFX(DPFPREP, 3,"Returning: hResultCode = [%lx], *ppv = [%p]",hResultCode,*ppv);

	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DP8ACF_AddRef"

STDMETHODIMP_(ULONG) DP8ACF_AddRef(IDirectPlay8AddressClassFact *pInterface)
{
	_LPIDirectPlay8AddressClassFact	lpcfObj;

	DPFX(DPFPREP, 3,"Parameters: pInterface [%p]",pInterface);

	lpcfObj = (_LPIDirectPlay8AddressClassFact)pInterface;
	InterlockedIncrement( &lpcfObj->lRefCount );

	DPFX(DPFPREP, 3,"Returning: lpcfObj->lRefCount = [%lx]",lpcfObj->lRefCount);

	return(lpcfObj->lRefCount);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DP8ACF_Release"

STDMETHODIMP_(ULONG) DP8ACF_Release(IDirectPlay8AddressClassFact *pInterface)
{
	_LPIDirectPlay8AddressClassFact	lpcfObj;

	DPFX(DPFPREP, 3,"Parameters: pInterface [%p]",pInterface);

	lpcfObj = (_LPIDirectPlay8AddressClassFact)pInterface;
	DPFX(DPFPREP, 5,"Original : lpcfObj->lRefCount = %ld",lpcfObj->lRefCount);
	
	if( InterlockedDecrement( &lpcfObj->lRefCount )== 0 )
	{
		DPFX(DPFPREP, 5,"Freeing class factory object: lpcfObj [%p]",lpcfObj);
		fpmAddressClassFacs->Release(fpmAddressClassFacs, lpcfObj);

		GdwHObjects--;

		return(0);
	}
	DPFX(DPFPREP, 3,"Returning: lpcfObj->lRefCount = [%lx]",lpcfObj->lRefCount);

	return(lpcfObj->lRefCount);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DP8ACF_CreateObject"

HRESULT DP8ACF_CreateObject(LPVOID *lplpv,REFIID riid)
{
	HRESULT				hr = S_OK;
	DP8ADDRESSOBJECT	*pdnObject = NULL;

	DPFX(DPFPREP, 3,"Parameters: lplpv [%p]",lplpv);


	pdnObject = (DP8ADDRESSOBJECT *) fpmAddressObjects->Get(fpmAddressObjects);

	if (pdnObject == NULL)
	{
		DPFERR("FPM_Get() failed");
		return(E_OUTOFMEMORY);
	}
	
	DPFX(DPFPREP, 5,"pdnObject [%p]",pdnObject);

	hr = pdnObject->Init( );

	if( FAILED( hr ) )
	{
		fpmAddressObjects->Release( fpmAddressObjects, pdnObject );
		DPFX(DPFPREP, 0,"Failed to init hr=0x%x", hr );
		return hr;
	}
	
	*lplpv = pdnObject;

	DPFX(DPFPREP, 3,"Returning: hResultCode = [%lx], *lplpv = [%p]",hr,*lplpv);
	return(hr);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DirectPlay8AddressCreate"
HRESULT WINAPI DirectPlay8AddressCreate( const GUID * pcIID, void **ppvInterface, IUnknown *pUnknown)
{
    if( pcIID == NULL || 
        !DNVALID_READPTR( pcIID, sizeof( GUID ) ) )
    {
        DPFERR( "Invalid pointer specified for interface GUID" );
        return DPNERR_INVALIDPOINTER;
    }

    if( *pcIID != IID_IDirectPlay8Address && 
        *pcIID != IID_IDirectPlay8AddressIP )
    {
        DPFERR("Interface ID is not recognized" );
        return DPNERR_INVALIDPARAM;
    }

    if( ppvInterface == NULL || !DNVALID_WRITEPTR( ppvInterface, sizeof( void * ) ) )
    {
        DPFERR( "Invalid pointer specified to receive interface" );
        return DPNERR_INVALIDPOINTER;
    }

    if( pUnknown != NULL )
    {
        DPFERR( "Aggregation is not supported by this object yet" );
        return DPNERR_INVALIDPARAM;
    }

    return COM_CoCreateInstance( CLSID_DirectPlay8Address, NULL, CLSCTX_INPROC_SERVER, *pcIID, ppvInterface, TRUE );
}


#undef DPF_MODNAME
#define DPF_MODNAME "DP8ACF_FreeObject"

HRESULT DP8ACF_FreeObject(LPVOID lpv)
{
	HRESULT				hResultCode = S_OK;
	DP8ADDRESSOBJECT	*pdnObject = (DP8ADDRESSOBJECT *) lpv;

	DNASSERT(pdnObject != NULL);

	pdnObject->Cleanup();

	DPFX(DPFPREP, 5,"free pdnObject [%p]",pdnObject);

	// Release the object
	fpmAddressObjects->Release( fpmAddressObjects, pdnObject );

	DPFX(DPFPREP, 3,"Returning: hResultCode = [%lx]",hResultCode);

	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DP8ACF_CreateInstance"

STDMETHODIMP DP8ACF_CreateInstance(IDirectPlay8AddressClassFact *pInterface,LPUNKNOWN lpUnkOuter,REFIID riid,LPVOID *ppv)
{
	HRESULT					hResultCode = S_OK;
	LPINTERFACE_LIST		lpIntList = NULL;
	LPOBJECT_DATA			lpObjectData = NULL;

	DPFX(DPFPREP, 3,"Parameters: pInterface [%p], lpUnkOuter [%p], riid [%p], ppv [%p]",pInterface,lpUnkOuter,riid,ppv);

	if( ppv == NULL || !DNVALID_WRITEPTR( ppv, sizeof(LPVOID) ) )
	{
		DPFX(DPFPREP,  0, "Cannot pass NULL for new object param" );
		return E_INVALIDARG;
	}

	if (lpUnkOuter != NULL)
	{
		DPFX(DPFPREP,  0, "Aggregation is not supported, pUnkOuter must be NULL" );
		return(CLASS_E_NOAGGREGATION);
	}

	lpObjectData = (LPOBJECT_DATA) fpmAddressObjectDatas->Get(fpmAddressObjectDatas);
	if (lpObjectData == NULL)
	{
		DPFERR("FPM_Get() failed");
		return(E_OUTOFMEMORY);
	}
	DPFX(DPFPREP, 5,"lpObjectData [%p]",lpObjectData);

	lpObjectData->dwSignature = DPASIGNATURE_OD;

	// Object creation and initialization
	if ((hResultCode = DP8ACF_CreateObject(&lpObjectData->lpvData,riid)) != S_OK)
	{
		fpmAddressObjectDatas->Release(fpmAddressObjectDatas, lpObjectData);
		return(hResultCode);
	}
	DPFX(DPFPREP, 5,"Created and initialized object");

	// Get requested interface
	if ((hResultCode = DP8A_CreateInterface(lpObjectData,riid,&lpIntList)) != S_OK)
	{
		DP8ACF_FreeObject(lpObjectData->lpvData);
		fpmAddressObjectDatas->Release(fpmAddressObjectDatas, lpObjectData);
		return(hResultCode);
	}
	DPFX(DPFPREP, 5,"Found interface");

	lpObjectData->lpIntList = lpIntList;
	lpObjectData->lRefCount = 1;
	InterlockedIncrement( &lpIntList->lRefCount );
	GdwHObjects++;
	*ppv = lpIntList;

	DPFX(DPFPREP, 3,"Returning: hResultCode = [%lx], *ppv = [%p]",hResultCode,*ppv);

	return(S_OK);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DP8ACF_LockServer"

STDMETHODIMP DP8ACF_LockServer(IDirectPlay8AddressClassFact *pInterface,BOOL bLock)
{
	DPFX(DPFPREP, 3,"Parameters: lpv [%p], bLock [%lx]",pInterface,bLock);

	if (bLock)
	{
		GdwHLocks++;
	}
	else
	{
		GdwHLocks--;
	}

	return(S_OK);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_CreateInterface"

static	HRESULT DP8A_CreateInterface(LPOBJECT_DATA lpObject, REFIID riid, LPINTERFACE_LIST *const ppv)
{
	LPINTERFACE_LIST	lpIntNew;
	LPVOID				lpVtbl;

	DPFX(DPFPREP, 3,"Parameters: lpObject [%p], riid [%p], ppv [%p]",lpObject,riid,ppv);

	if (IsEqualIID(riid,IID_IUnknown))
	{
		DPFX(DPFPREP, 5,"riid = IID_IUnknown");
		lpVtbl = &DP8A_UnknownVtbl;
	}
	else if (IsEqualIID(riid,IID_IDirectPlay8Address))
	{
		DPFX(DPFPREP, 5,"riid = IID_IDirectPlay8Address");
		lpVtbl = &DP8A_BaseVtbl;
	}
	else if (IsEqualIID(riid,IID_IDirectPlay8AddressIP))
	{
		DPFX(DPFPREP, 5,"riid = IID_IDirectPlay8AddressIP");
		lpVtbl = &DP8A_IPVtbl;
	}
	else if (IsEqualIID(riid,IID_IDirectPlay8AddressInternal))
	{
		DPFX(DPFPREP, 5,"riid = IID_IDirectPlay8AddressInternal");
		lpVtbl = &DP8A_InternalVtbl;
	}
	else
	{
		DPFX(DPFPREP, 5,"riid not found !");
		return(E_NOINTERFACE);
	}

	lpIntNew = (LPINTERFACE_LIST) fpmAddressInterfaceLists->Get(fpmAddressInterfaceLists);
	if (lpIntNew == NULL)
	{
		DPFERR("FPM_Get() failed");
		return(E_OUTOFMEMORY);
	}
	lpIntNew->dwSignature = DPASIGNATURE_IL;
	lpIntNew->lpVtbl = lpVtbl;
	lpIntNew->lRefCount = 0;
	lpIntNew->lpIntNext = NULL;
	DBG_CASSERT( sizeof( lpIntNew->iid ) == sizeof( riid ) );
	memcpy( &(lpIntNew->iid), &riid, sizeof( lpIntNew->iid ) );
	lpIntNew->lpObject = lpObject;

	*ppv = lpIntNew;

	DPFX(DPFPREP, 3,"Returning: hResultCode = [S_OK], *ppv = [%p]",*ppv);

	return(S_OK);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_FindInterface"

LPINTERFACE_LIST DP8A_FindInterface(LPVOID lpv, REFIID riid)
{
	LPINTERFACE_LIST	lpIntList;

	DPFX(DPFPREP, 3,"Parameters: lpv [%p], riid [%p]",lpv,riid);

	lpIntList = ((LPINTERFACE_LIST)lpv)->lpObject->lpIntList;	// Find first interface

	while (lpIntList != NULL)
	{
		if (IsEqualIID(riid,lpIntList->iid))
			break;
		lpIntList = lpIntList->lpIntNext;
	}
	DPFX(DPFPREP, 3,"Returning: lpIntList = [%p]",lpIntList);

	return(lpIntList);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_QueryInterface"

STDMETHODIMP DP8A_QueryInterface(LPVOID lpv,REFIID riid,LPVOID *ppv)
{
	LPINTERFACE_LIST	lpIntList;
	LPINTERFACE_LIST	lpIntNew;
	HRESULT		hResultCode;

	DPFX(DPFPREP, 3,"Parameters: lpv [%p], riid [%p], ppv [%p]",lpv,riid,ppv);

	if( lpv == NULL || !DP8A_VALID(lpv) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid object" );
		return DPNERR_INVALIDOBJECT;
	}

	if( ppv == NULL || 
		!DNVALID_WRITEPTR(ppv, sizeof(LPVOID) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer for interface" );
		return DPNERR_INVALIDPOINTER;
	}

	if ((lpIntList = DP8A_FindInterface(lpv,riid)) == NULL)
	{	// Interface must be created
		lpIntList = ((LPINTERFACE_LIST)lpv)->lpObject->lpIntList;

		if ((hResultCode = DP8A_CreateInterface(lpIntList->lpObject,riid,&lpIntNew)) != S_OK)
		{
			return(hResultCode);
		}

		lpIntNew->lpIntNext = lpIntList;
		((LPINTERFACE_LIST)lpv)->lpObject->lpIntList = lpIntNew;
		lpIntList = lpIntNew;
	}

	// Interface is being created or was cached
	// Increment object count
	if( lpIntList->lRefCount == 0 )
	{
		InterlockedIncrement( &lpIntList->lpObject->lRefCount );
	}
	InterlockedIncrement( &lpIntList->lRefCount );
	*ppv = lpIntList;

	DPFX(DPFPREP, 3,"Returning: hResultCode = [S_OK], *ppv = [%p]",*ppv);

	return(S_OK);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_AddRef"

STDMETHODIMP_(ULONG) DP8A_AddRef(LPVOID lpv)
{
	LPINTERFACE_LIST	lpIntList;

	DPFX(DPFPREP, 3,"Parameters: lpv [%p]",lpv);

	if( lpv == NULL || !DP8A_VALID(lpv) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid object" );
		return DPNERR_INVALIDOBJECT;
	}

	lpIntList = (LPINTERFACE_LIST)lpv;
	InterlockedIncrement( &lpIntList->lRefCount );

	DPFX(DPFPREP, 3,"Returning: lpIntList->lRefCount = [%lx]",lpIntList->lRefCount);

	return(lpIntList->lRefCount);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_Release"

STDMETHODIMP_(ULONG) DP8A_Release(LPVOID lpv)
{
	LPINTERFACE_LIST	lpIntList;
	LPINTERFACE_LIST	lpIntCurrent;

	DPFX(DPFPREP, 3,"Parameters: lpv [%p]",lpv);

	if( lpv == NULL || !DP8A_VALID(lpv) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid object" );
		return DPNERR_INVALIDOBJECT;
	}
	

	lpIntList = (LPINTERFACE_LIST)lpv;

	DPFX(DPFPREP, 5,"Original : lpIntList->lRefCount = %ld",lpIntList->lRefCount);
	DPFX(DPFPREP, 5,"Original : lpIntList->lpObject->lRefCount = %ld",lpIntList->lpObject->lRefCount);

    if( InterlockedDecrement( &lpIntList->lRefCount ) == 0 )
	{	// Decrease interface count
		if( InterlockedDecrement( &lpIntList->lpObject->lRefCount ) == 0 )
		{	// Free object and all interfaces
			DPFX(DPFPREP, 5,"Free object");

			// Free object here
			DP8ACF_FreeObject(lpIntList->lpObject->lpvData);
			lpIntList = lpIntList->lpObject->lpIntList;	// Get head of interface list
			DPFX(DPFPREP, 5,"lpIntList->lpObject [%p]",lpIntList->lpObject);
			lpIntList->lpObject->dwSignature = DPASIGNATURE_OD_FREE;
			fpmAddressObjectDatas->Release(fpmAddressObjectDatas, lpIntList->lpObject);

			// Free Interfaces
			DPFX(DPFPREP, 5,"Free interfaces");
			while(lpIntList != NULL)
			{
				lpIntCurrent = lpIntList;
				lpIntList = lpIntList->lpIntNext;
				DPFX(DPFPREP, 5,"\tinterface [%p]",lpIntCurrent);
				lpIntCurrent->dwSignature = DPASIGNATURE_IL_FREE;
				fpmAddressInterfaceLists->Release(fpmAddressInterfaceLists, lpIntCurrent);
			}

			GdwHObjects--;
			DPFX(DPFPREP, 3,"Returning: 0");
			return(0);
		}
	}

	DPFX(DPFPREP, 3,"Returning: lpIntList->lRefCount = [%lx]",lpIntList->lRefCount);

	return(lpIntList->lRefCount);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\dnaddress\addbld.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       addbld.h
 *  Content:    DirectPlay8Address Internal datatypes / defines for addressing
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 * 02/07/2000	rmt		Created
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __ADDRBLD_H
#define __ADDRBLD_H

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\dnaddress\addcore.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       addtcp.cpp
 *  Content:    DirectPlay8Address core implementation file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *  ====       ==      ======
 * 02/04/2000	rmt		Created
 * 02/10/2000	rmt		Updated to use DPNA_ defines instead of URL_
 * 02/12/2000	rmt		Split Get into GetByName and GetByIndex
 * 02/17/2000	rmt		Parameter validation work
 * 02/18/2000	rmt		Added type validation to all pre-defined elements
 * 02/21/2000	rmt		Updated to make core Unicode and remove ANSI calls
 * 02/23/2000	rmt		Fixed length calculations in GetURL
 *				rmt		Buffer too small error debug messages -> Warning level
 * 03/21/2000   rmt     Renamed all DirectPlayAddress8's to DirectPlay8Addresses
 *                      Added support for the new ANSI type
 *	05/04/00	mjn		delete temp var at end of SetElement()
 *	05/05/00	mjn		Better error cleanup in SetElement()
 *  06/06/00    rmt     Bug #36455 failure when calling with ANSI string shortcut for SP
 *  06/09/00    rmt     Updates to split CLSID and allow whistler compat and support external create funcs
 *  06/21/2000	rmt		Bug #37392 - Leak if replacing allocated element with new item same size as GUID
 *  06/27/2000	rmt		Bug #37630 - Service provider shortcuts / element names were case sensitive
 *  07/06/2000	rmt		Bug #38714 - ADDRESSING: GetURL doesn't return the # of chars written
 *  07/09/2000	rmt		Added signature bytes to start of address objects
 *  07/12/2000	rmt		Fixed some critical section related bugs:
 *						- Added leave in an error path where it wasn't being called
 *						- Moved critical section init/delete to constructor / destructor
 *  07/13/2000	rmt		Bug #39274 - INT 3 during voice run
 *						- Fixed point where a critical section was being re-initialized
 *				rmt		Added critical sections to protect FPMs					
 * 07/21/2000	rmt		Fixed bug w/directplay 4 address parsing 
 * 07/31/2000	rmt		Bug #41125 - Addressing() GetUserData when none available should return doesnotexist
 * 08/03/2000	rmt		Missing LEAVELOCK() was causing lockups.
 * 11/29/2000   aarono	B#226079 prefix, fix memory leak in failure path of SetElement
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dnaddri.h"


const DWORD c_dwNumBaseStrings = 11;

const WCHAR * szBaseStrings[] =
{
	DPNA_KEY_PROVIDER,
	DPNA_KEY_DEVICE,
	DPNA_KEY_HOSTNAME,
	DPNA_KEY_PORT,
	DPNA_KEY_APPLICATION_INSTANCE,
	DPNA_KEY_BAUD,
	DPNA_KEY_FLOWCONTROL,
	DPNA_KEY_PARITY,
	DPNA_KEY_PHONENUMBER,
	DPNA_KEY_PROGRAM,
	DPNA_KEY_STOPBITS
};

const DWORD dwBaseRequiredTypes[] =
{
	DPNA_DATATYPE_GUID,
	DPNA_DATATYPE_GUID,
	DPNA_DATATYPE_STRING,
	DPNA_DATATYPE_DWORD,
	DPNA_DATATYPE_GUID,
	DPNA_DATATYPE_DWORD,
	DPNA_DATATYPE_STRING,
	DPNA_DATATYPE_STRING,
	DPNA_DATATYPE_STRING,
	DPNA_DATATYPE_GUID,
	DPNA_DATATYPE_STRING
};

#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_STRCACHE_Init"
HRESULT DP8A_STRCACHE_Init()
{
	HRESULT hr;
	PWSTR	pstrTmp;
	DWORD	dwIndex;

	DNASSERT( g_pcstrKeyCache == NULL );
	g_pcstrKeyCache = new CStringCache;
	if ( g_pcstrKeyCache == NULL )
	{
		DPFX(DPFPREP,  0, "Failed to create addressing string cache!" );
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	for( dwIndex = 0; dwIndex < c_dwNumBaseStrings; dwIndex++ )
	{
		hr = g_pcstrKeyCache->AddString( szBaseStrings[dwIndex], &pstrTmp );

		if( FAILED( hr ) )
		{
			DPFX(DPFPREP,  0, "Error adding base strings" );
			return hr;
		}
	}

Exit:
	return DPN_OK;

Failure:
	goto Exit;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_STRCACHE_Free"
// Nothing needs to be done.
void DP8A_STRCACHE_Free()
{
	if ( g_pcstrKeyCache != NULL )
	{
		delete	g_pcstrKeyCache;
		g_pcstrKeyCache = NULL;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "FPM_Element_BlockInit"
void DP8ADDRESSOBJECT::FPM_Element_BlockInit( void *pvItem )
{
	memset( pvItem, 0x00, sizeof( DP8ADDRESSELEMENT ) );
	((PDP8ADDRESSELEMENT) pvItem)->dwSignature = DPASIGNATURE_ELEMENT;
}

#undef DPF_MODNAME
#define DPF_MODNAME "FPM_Element_BlockRelease"
void DP8ADDRESSOBJECT::FPM_Element_BlockRelease( void *pvItem )
{
	((PDP8ADDRESSELEMENT) pvItem)->dwSignature = DPASIGNATURE_ELEMENT_FREE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "FPM_BlockCreate"
BOOL DP8ADDRESSOBJECT::FPM_BlockCreate( void *pvItem )
{
	return DNInitializeCriticalSection( &((PDP8ADDRESSOBJECT) pvItem)->m_csAddressLock );
}

#undef DPF_MODNAME
#define DPF_MODNAME "FPM_BlockInit"
void DP8ADDRESSOBJECT::FPM_BlockInit( void *pvItem )
{
	((PDP8ADDRESSOBJECT) pvItem)->m_dwSignature = DPASIGNATURE_ADDRESS;
}

#undef DPF_MODNAME
#define DPF_MODNAME "FPM_BlockRelease"
void DP8ADDRESSOBJECT::FPM_BlockRelease( void *pvItem )
{
	((PDP8ADDRESSOBJECT) pvItem)->m_dwSignature = DPASIGNATURE_ADDRESS_FREE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "FPM_BlockDestroy"
void DP8ADDRESSOBJECT::FPM_BlockDestroy( void *pvItem )
{
	DNDeleteCriticalSection( &((PDP8ADDRESSOBJECT) pvItem)->m_csAddressLock );
}

// InternalGetElement
//
// This function does the lookup for an element by index.
//
// Requires the object lock.
//
// Does not do parameter validation.
//
#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::InternalGetElement"
HRESULT DP8ADDRESSOBJECT::InternalGetElement( const DWORD dwIndex, PDP8ADDRESSELEMENT *ppaElement )
{
	CBilink *pblSearch;

	if( dwIndex >= m_dwElements )
		return DPNERR_DOESNOTEXIST;

	pblSearch = m_blAddressElements.GetNext();

	for( DWORD dwSearchIndex = 0; dwSearchIndex < dwIndex; dwSearchIndex++ )
	{
		pblSearch = pblSearch->GetNext();
	}
	
	*ppaElement = CONTAINING_RECORD(pblSearch, DP8ADDRESSELEMENT, blAddressElements);

	return DPN_OK;

}

// InternalGetElement
//
// This function does the lookup for an element by name.
//
// Requires the object lock.
//
// Does not do parameter validation.
//
#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::InternalGetElement"
HRESULT DP8ADDRESSOBJECT::InternalGetElement( const WCHAR * const pszTag, PDP8ADDRESSELEMENT *ppaElement )
{
	CBilink *pblSearch;
	PDP8ADDRESSELEMENT paddElement;

	pblSearch = m_blAddressElements.GetNext();

	while( pblSearch != &m_blAddressElements )
	{
		paddElement = CONTAINING_RECORD(pblSearch, DP8ADDRESSELEMENT, blAddressElements);

		if( _wcsicmp( pszTag, paddElement->pszTag ) == 0 )
		{
			*ppaElement = paddElement;
			return DPN_OK;
		}

		pblSearch = pblSearch->GetNext();
	}

	return DPNERR_DOESNOTEXIST;
}

// GetElement
//
// Implements retrieval of element by name
//
// Parameter validation must be performed BEFORE calling this function.
//
#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::GetElement"
HRESULT DP8ADDRESSOBJECT::GetElement( const WCHAR * const pszTag, void * pvDataBuffer, PDWORD pdwDataSize, PDWORD pdwDataType )
{
	PDP8ADDRESSELEMENT paddElement = NULL;
	HRESULT hr;

	ENTERLOCK();
	
	hr = InternalGetElement( pszTag, &paddElement );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  1, "Unable to find specified element hr=0x%x", hr );
		LEAVELOCK();		
		return hr;
	}

	DNASSERT( paddElement != NULL );

	*pdwDataType = paddElement->dwType;

	if( *pdwDataSize < paddElement->dwDataSize ||
	   pvDataBuffer == NULL )
	{
		*pdwDataSize = paddElement->dwDataSize;
		DPFX(DPFPREP,  DP8A_WARNINGLEVEL, "Specified buffers were too small hr=0x%x", hr );
		LEAVELOCK();		
		return DPNERR_BUFFERTOOSMALL;
	}

	*pdwDataSize = paddElement->dwDataSize;

	if( paddElement->dwFlags & DP8ADDRESS_ELEMENT_HEAP )
	{
		memcpy( pvDataBuffer, paddElement->uData.pvData, paddElement->dwDataSize );
	}
	else
	{
		memcpy( pvDataBuffer, &paddElement->uData, paddElement->dwDataSize );
	}

	LEAVELOCK();	

	return DPN_OK;	

}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::GetElementType"
HRESULT DP8ADDRESSOBJECT::GetElementType( const WCHAR * pszTag, PDWORD pdwType )
{
	PDP8ADDRESSELEMENT paddElement = NULL;
	HRESULT hr;

	ENTERLOCK();

	hr = InternalGetElement( pszTag, &paddElement );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Unable to find specified element hr=0x%x" );
		LEAVELOCK();
		return hr;
	}

	*pdwType = paddElement->dwType;

	LEAVELOCK();

	return DPN_OK;

}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::GetElement"
HRESULT DP8ADDRESSOBJECT::GetElement( const DWORD dwIndex, WCHAR * pszTag, PDWORD pdwTagSize, void * pvDataBuffer, PDWORD pdwDataSize, PDWORD pdwDataType )
{
	PDP8ADDRESSELEMENT paddElement = NULL;
	HRESULT hr;

	if( pdwTagSize == NULL || pdwDataSize == NULL || pdwDataType == NULL )
	{
		DPFX(DPFPREP,  0, "Invalid Poiinter" );
		return DPNERR_INVALIDPOINTER;
	}

	DWORD dwTmp2 = DPNA_INDEX_INVALID;

	ENTERLOCK();

	hr = InternalGetElement( dwIndex, &paddElement );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Unable to find specified element hr=0x%x", hr );
		LEAVELOCK();		
		return hr;
	}

	DNASSERT( paddElement != NULL );

	*pdwDataType = paddElement->dwType;

	if( *pdwTagSize < (wcslen( paddElement->pszTag )+1) ||
	   *pdwDataSize < paddElement->dwDataSize ||
	   pszTag == NULL ||
	   pvDataBuffer == NULL )
	{
		*pdwTagSize = paddElement->dwTagSize;
		*pdwDataSize = paddElement->dwDataSize;
		DPFX(DPFPREP,  DP8A_WARNINGLEVEL, "Specified buffers were too small hr=0x%x", hr );
		LEAVELOCK();		
		return DPNERR_BUFFERTOOSMALL;
	}

	*pdwTagSize = paddElement->dwTagSize;
	*pdwDataSize = paddElement->dwDataSize;

	wcscpy( pszTag, paddElement->pszTag );

	if( paddElement->dwFlags & DP8ADDRESS_ELEMENT_HEAP )
	{
		memcpy( pvDataBuffer, paddElement->uData.pvData, paddElement->dwDataSize );
	}
	else
	{
		memcpy( pvDataBuffer, &paddElement->uData, paddElement->dwDataSize );
	}

	LEAVELOCK();	

	return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::SetElement"
HRESULT DP8ADDRESSOBJECT::SetElement( const WCHAR * const pszTag, const void * const pvData, const DWORD dwDataSize, const DWORD dwDataType )
{
	PDP8ADDRESSELEMENT paddElement = NULL;
	HRESULT hr = DPN_OK;
	BOOL fReplace = FALSE;
	WCHAR *wszUnicodeString = NULL;
	DWORD dwUnicodeSize = 0;
	DWORD dwRealDataSize = dwDataSize;
	DWORD dwRealDataType = dwDataType;
	PVOID pvRealData = (void *) pvData;

	if( pvData == NULL )
		return DPNERR_INVALIDPOINTER;

	switch( dwRealDataType )
	{
	case DPNA_DATATYPE_DWORD:
		if( dwRealDataSize != sizeof( DWORD ) )
		{
			DPFX(DPFPREP,  0, "Size is wrong for element" );
			return DPNERR_INVALIDPARAM;
		}
		break;
	case DPNA_DATATYPE_GUID:
		if( dwRealDataSize != sizeof( GUID ) )
		{
			DPFX(DPFPREP,  0, "Size is wrong for GUID element" );
			return DPNERR_INVALIDPARAM;
		}
		break;
	case DPNA_DATATYPE_STRING_ANSI:
        wszUnicodeString = new WCHAR[dwRealDataSize];
        if( wszUnicodeString == NULL )
        {
            DPFX(DPFPREP,  0, "Error allocating memory for conversion" );
            return DPNERR_OUTOFMEMORY;
        }

		hr = STR_jkAnsiToWide( wszUnicodeString, (const char * const) pvData, dwRealDataSize );

		if( FAILED( hr ) )
		{
			delete [] wszUnicodeString;
		    DPFX(DPFPREP,  0, "Error unable to convert element ANSI->Unicode 0x%x", hr );
	            return DPNERR_CONVERSION;
		}
		pvRealData = wszUnicodeString;
	    dwRealDataSize = dwDataSize*sizeof(WCHAR);
		dwRealDataType = DPNA_DATATYPE_STRING;
	    break;
	case DPNA_DATATYPE_STRING:
	case DPNA_DATATYPE_BINARY:
		break;
	default:
		DPFX(DPFPREP,  0, "Invalid data type" );
		return DPNERR_INVALIDPARAM;
		
	}

	ENTERLOCK();

    // We need to treat provider key differently, it can also take one of the provider
    // shortcut values
    if( _wcsicmp( DPNA_KEY_PROVIDER, pszTag ) == 0 )
    {
        // If it's a GUID we're golden, otherwise..
        if( dwRealDataType != DPNA_DATATYPE_GUID )
        {
            if( dwRealDataType == DPNA_DATATYPE_STRING )
            {
                if( _wcsicmp( (const WCHAR * const) pvRealData, DPNA_VALUE_TCPIPPROVIDER ) == 0 )
                {
                    hr = SetSP( &CLSID_DP8SP_TCPIP );
                }
                else if( _wcsicmp( (const WCHAR * const) pvRealData, DPNA_VALUE_IPXPROVIDER ) == 0 )
                {
                    hr= SetSP( &CLSID_DP8SP_IPX );
                }
                else if( _wcsicmp( (const WCHAR * const) pvRealData, DPNA_VALUE_MODEMPROVIDER ) == 0 )
                {
                    hr = SetSP( &CLSID_DP8SP_MODEM );
                }
                else if( _wcsicmp( (const WCHAR * const) pvRealData, DPNA_VALUE_SERIALPROVIDER ) == 0 )
                {
                    hr = SetSP( &CLSID_DP8SP_SERIAL );
                }
                else
                {
                    DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Provider must be specified as a GUID or a valid shortcut string" );
					hr = DPNERR_INVALIDPARAM;
					goto APPEND_ERROR;
                }

                if( FAILED( hr ) )
                {
                    DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Failed setting provider with shortcut hr=0x%x", hr );
                    goto APPEND_ERROR;
                }

                goto APPEND_SUCCESS;

            }
            else
            {
                DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Specified values is not a supported datatype for the given key" );
				hr = DPNERR_INVALIDPARAM;
				goto APPEND_ERROR;
            }
        }
    }
    else
    {
	    // Ensure that datatype is correct in case the key is a reserved key
	    for( DWORD dwIndex = 0; dwIndex < c_dwNumBaseStrings; dwIndex++ )
	    {
		    if( _wcsicmp( szBaseStrings[dwIndex], pszTag ) == 0 )
		    {
			    if( dwRealDataType != dwBaseRequiredTypes[dwIndex] )
			    {
				    DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Specified key is reserved and specified datatype is not correct for key" );
					hr = DPNERR_INVALIDPARAM;
					goto APPEND_ERROR;
			    }
			    break;
		    }
	    }
    }

	if( IsLocked() )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Cannot set element, object read-only" );
		hr = DPNERR_NOTALLOWED;
		goto APPEND_ERROR;
	}

	hr = InternalGetElement( pszTag, &paddElement );

	// If the element is not already in the address we need to add an element
	if( FAILED( hr ) )
	{
		paddElement = (PDP8ADDRESSELEMENT) fpmAddressElements->Get( fpmAddressElements );

		if( paddElement == NULL )
		{
			DPFX(DPFPREP,  0, "Error getting new element" );
			hr = DPNERR_OUTOFMEMORY;
			goto APPEND_ERROR;
		}

		hr = g_pcstrKeyCache->AddString( pszTag, &paddElement->pszTag );

		if( FAILED( hr ) )
		{
			DPFX(DPFPREP,  0, "Unable to cache tag element hr=0x%x" );
			goto APPEND_ERROR;
		}

		// Set flag to 0 
		paddElement->dwFlags = 0;
	}
	// The element is already there.  Fill in the data.
	else
	{
		DNASSERT( paddElement != NULL );

		// If the one we're replacing was on the heap AND
		// The new one doesn't need the heap or is a different size..
		if( paddElement->dwFlags & DP8ADDRESS_ELEMENT_HEAP &&
		   (dwRealDataSize <= sizeof(GUID) || dwRealDataSize > paddElement->dwDataSize) )
		{
            DNFree(paddElement->uData.pvData);
			paddElement->uData.pvData = NULL;
			paddElement->dwDataSize = 0;
		}

		// Reduce the object's string size so object string size will be correct
		m_dwStringSize -= paddElement->dwStringSize;
		fReplace = TRUE;
	}

	paddElement->dwTagSize = wcslen( pszTag )+1;

	// Can fit in the internal buffer
	if( dwRealDataSize <= sizeof( paddElement->uData ) )
	{
		memcpy( &paddElement->uData, pvRealData, dwRealDataSize );

		// Turn off heap flag in this case
		paddElement->dwFlags &= ~(DP8ADDRESS_ELEMENT_HEAP);
	}
	else
	{
		if( !fReplace || !(paddElement->dwFlags & DP8ADDRESS_ELEMENT_HEAP) ||
		     paddElement->dwDataSize < dwRealDataSize )
		{
			paddElement->uData.pvData = DNMalloc(dwRealDataSize);

			if( paddElement->uData.pvData == NULL )
			{
				DPFX(DPFPREP,  0, "Error allocating memory" );
				goto APPEND_ERROR;
			}
		}

		memcpy( paddElement->uData.pvData, pvRealData, dwRealDataSize );

		paddElement->dwFlags |= DP8ADDRESS_ELEMENT_HEAP;
	}

	paddElement->dwType = dwRealDataType;
	paddElement->dwDataSize = dwRealDataSize;
	paddElement->dwStringSize = 0;

	hr = CalcComponentStringSize( paddElement, &paddElement->dwStringSize );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Failed to determine string length hr=0x%x", hr );
		goto APPEND_ERROR;
	}

	m_dwStringSize += paddElement->dwStringSize;

	// Create shortcuts if appropriate
	if( _wcsicmp( DPNA_KEY_PROVIDER, paddElement->pszTag ) == 0 )
	{
		m_pSP = paddElement;
	}
	else if( _wcsicmp( DPNA_KEY_DEVICE, paddElement->pszTag ) == 0 )
	{
		m_pAdapter = paddElement;
	}	

	if( !fReplace )
	{
		// We are adding the SP
		if( m_pSP == paddElement )
		{
			paddElement->blAddressElements.InsertAfter( &m_blAddressElements );
		}
		// We are adding the adapter
		else if( m_pAdapter == paddElement )
		{
			if( m_pSP != NULL )
			{
				paddElement->blAddressElements.InsertAfter( &m_pSP->blAddressElements);			
			}
			else
			{
				paddElement->blAddressElements.InsertAfter( &m_blAddressElements);			
			}
		}
		// Tack it onto the end
		else
		{
			paddElement->blAddressElements.InsertBefore( &m_blAddressElements );
		}

		// Add one char length for seperator w/previous element
		if( m_dwElements > 0 )
			m_dwStringSize ++;

		m_dwElements++;	

	}

APPEND_SUCCESS:
    
	LEAVELOCK();    
	//
	//	minara added this ...
	//
	if (wszUnicodeString)
	{
		delete [] wszUnicodeString;
		wszUnicodeString = NULL;
	}

	return DPN_OK;

APPEND_ERROR:

	if( paddElement != NULL )
	{
	    if( paddElement->dwFlags & DP8ADDRESS_ELEMENT_HEAP )
	    {
	        if( paddElement->uData.pvData )
			{
	            DNFree(paddElement->uData.pvData);
				paddElement->uData.pvData = NULL;
			}
	    }

		fpmAddressElements->Release( fpmAddressElements, paddElement );
	}

	if( wszUnicodeString != NULL )
	    delete [] wszUnicodeString;

	LEAVELOCK();

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::Init"
HRESULT DP8ADDRESSOBJECT::Init( )
{
	ENTERLOCK();

	m_dwElements = 0;
	m_pSP = NULL;
	m_pAdapter = NULL;
	m_pvUserData = NULL;
	m_dwUserDataSize = 0;
	m_dwStringSize = DNURL_LENGTH_HEADER;
	m_dwUserDataStringSize = 0;
	m_iLockCount  = 0;
	m_fValid = FALSE;
	m_blAddressElements.Initialize();

	LEAVELOCK();
	
	return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::IsValid"
BOOL DP8ADDRESSOBJECT::IsValid()
{
	/*if( m_dwElements < 1 )
		return FALSE;

	if( !m_pSP )
		return FALSE;*/

	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::Clear"
HRESULT DP8ADDRESSOBJECT::Clear( )
{
	HRESULT				hResultCode = S_OK;
	CBilink 				*pbl;
	PDP8ADDRESSELEMENT paddElement;

	ENTERLOCK();	

	if( IsLocked() )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Cannot set element, object read-only" );
		LEAVELOCK();
		return DPNERR_NOTALLOWED;
	}	

	pbl = m_blAddressElements.GetNext();

	// Destroy Address Members address members
	while( !m_blAddressElements.IsEmpty() )
	{
		paddElement = CONTAINING_RECORD(m_blAddressElements.GetNext(), DP8ADDRESSELEMENT, blAddressElements);

		if( paddElement->dwFlags & DP8ADDRESS_ELEMENT_HEAP )
		{
            DNFree(paddElement->uData.pvData);
			paddElement->uData.pvData = NULL;
		}		
		
		pbl->RemoveFromList();

		fpmAddressElements->Release( fpmAddressElements, paddElement );

		pbl = m_blAddressElements.GetNext();
	}

	if( m_pvUserData != NULL )
	{
		delete m_pvUserData;
		m_pvUserData = NULL;
		m_dwUserDataSize = 0;
	}

	m_fValid = FALSE;	

	LEAVELOCK();

	Init( );

	return DPN_OK;

}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::GetSP"
HRESULT DP8ADDRESSOBJECT::GetSP( GUID * pGuid )
{
	if( pGuid == NULL )
	{
		DPFX(DPFPREP,  0, "Invalid pointer" );
		return DPNERR_INVALIDPOINTER;
	}

	ENTERLOCK();

	if( m_pSP == NULL )
	{
		DPFX(DPFPREP,  0, "No SP has been specified" );
		LEAVELOCK();
		return DPNERR_DOESNOTEXIST;
	}

	if( m_pSP->dwType != DPNA_DATATYPE_GUID )
	{
		DPFX(DPFPREP,  0, "SP was specified, but is not a GUID" );
		LEAVELOCK();
		return DPNERR_INVALIDPARAM;
	}

	memcpy( pGuid, &m_pSP->uData.guidData, sizeof( GUID ) );

	LEAVELOCK();

	return DPN_OK;

}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::SetSP"
HRESULT DP8ADDRESSOBJECT::SetSP( LPCGUID const pGuid )
{
	HRESULT hr;
	
	if( pGuid == NULL )
	{
		DPFX(DPFPREP,  0, "Invalid pointer" );
		return DPNERR_INVALIDPOINTER;
	}

	hr = SetElement( DPNA_KEY_PROVIDER, pGuid, sizeof( GUID ), DPNA_DATATYPE_GUID );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Adding SP element failed hr=0x%x", hr );
	}

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::GetDevice"
HRESULT DP8ADDRESSOBJECT::GetDevice( GUID * pGuid )
{
	if( pGuid == NULL )
	{
		DPFX(DPFPREP,  0, "Invalid pointer" );
		return DPNERR_INVALIDPOINTER;
	}

	ENTERLOCK();

	if( m_pAdapter == NULL )
	{
		DPFX(DPFPREP,  1, "No SP has been specified" );
		LEAVELOCK();
		return DPNERR_DOESNOTEXIST;
	}

	if( m_pAdapter->dwType != DPNA_DATATYPE_GUID )
	{
		DPFX(DPFPREP,  0, "SP was specified, but is not a GUID" );
		LEAVELOCK();		
		return DPNERR_INVALIDPARAM;
	}

	memcpy( pGuid, &m_pAdapter->uData.guidData, sizeof( GUID ) );
	LEAVELOCK();	

	return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::SetDevice"
HRESULT DP8ADDRESSOBJECT::SetDevice( const GUID * const pGuid )
{
	HRESULT hr;
	
	if( pGuid == NULL )
	{
		DPFX(DPFPREP,  0, "Invalid pointer" );
		return DPNERR_INVALIDPOINTER;
	}

	hr = SetElement( DPNA_KEY_DEVICE, pGuid, sizeof( GUID ), DPNA_DATATYPE_GUID );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Adding SP element failed hr=0x%x", hr );
	}

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::SetUserData"
HRESULT DP8ADDRESSOBJECT::SetUserData( const void * const pvData, const DWORD dwDataSize )
{
	if( pvData == NULL && dwDataSize > 0 )
	{
		DPFX(DPFPREP,  0, "Invalid param" );
		return DPNERR_INVALIDPARAM;
	}

	ENTERLOCK();

	if( IsLocked() )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Cannot set element, object read-only" );
		LEAVELOCK();
		return DPNERR_NOTALLOWED;
	}	

	if( m_dwUserDataSize > 0 )
	{
		// Remove escaped user data
		m_dwStringSize -= m_dwUserDataStringSize;
	}
	
	if( dwDataSize == 0 )
	{
		m_dwUserDataSize = 0;
		if( m_pvUserData != NULL )
			delete m_pvUserData;
		m_pvUserData = NULL;
		LEAVELOCK();
		return DPN_OK;
	}

	PBYTE pNewDataBuffer;

	if( dwDataSize > m_dwUserDataSize )
	{
		pNewDataBuffer = new BYTE[dwDataSize];

		if( pNewDataBuffer == NULL )
		{
			DPFX(DPFPREP,  0, "Error allocating memory" );
			LEAVELOCK();			
			return DPNERR_OUTOFMEMORY;
		}

		if( m_pvUserData != NULL )
		{
			delete [] m_pvUserData;
		}

		m_pvUserData = pNewDataBuffer;
	}

	m_dwUserDataStringSize = CalcExpandedBinarySize( (PBYTE) pvData, dwDataSize );

	m_dwStringSize += m_dwUserDataStringSize;
	m_dwStringSize += DNURL_LENGTH_USERDATA_SEPERATOR;

	memcpy( m_pvUserData, pvData, dwDataSize );
	m_dwUserDataSize = dwDataSize;

	LEAVELOCK();	

	return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::GetUserData"
HRESULT DP8ADDRESSOBJECT::GetUserData( void * pvDataBuffer, PDWORD pdwDataSize )
{
	if( pdwDataSize == NULL )
	{
		DPFX(DPFPREP,  0, "Must specify a pointer for the size" );
		return DPNERR_INVALIDPOINTER;
	}

	ENTERLOCK();

	if( m_dwUserDataSize == 0 )
	{
		LEAVELOCK();
		DPFX(DPFPREP,  DP8A_WARNINGLEVEL, "No user data was specified for this address" );
		return DPNERR_DOESNOTEXIST;
	}

	if( *pdwDataSize < m_dwUserDataSize )
	{
		*pdwDataSize = m_dwUserDataSize;
		LEAVELOCK();		
		DPFX(DPFPREP,  DP8A_WARNINGLEVEL, "Buffer too small" );
		return DPNERR_BUFFERTOOSMALL;
	}

	memcpy( pvDataBuffer, m_pvUserData, m_dwUserDataSize );

	LEAVELOCK();	

	return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::Cleanup"
HRESULT DP8ADDRESSOBJECT::Cleanup()
{
	Clear();
	
	return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::CalcExpandedBinarySize"
DWORD DP8ADDRESSOBJECT::CalcExpandedBinarySize( PBYTE pbData, DWORD dwDataSize )
{
	PBYTE pbCurrentLocation = pbData;
	DWORD dwCount = 0;


	for( DWORD dwIndex = 0; dwIndex < dwDataSize; dwIndex++ )
	{
		if( IsEscapeChar( (WCHAR) *pbCurrentLocation ) )
		{
			if( ((WCHAR) *pbCurrentLocation) == DPNA_ESCAPECHAR )
				dwCount += 2;
			else
				dwCount+=3;
		}
		else
		{
			dwCount++;
		}

		pbCurrentLocation++;
	}

	return dwCount;

}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::CalcExpandedStringSize"
DWORD DP8ADDRESSOBJECT::CalcExpandedStringSize( WCHAR *szString )
{
	WCHAR *szCurrentLocation = szString;
	DWORD dwCount = 0;

	while( *szCurrentLocation )
	{
		if( IsEscapeChar( *szCurrentLocation ) )
		{
			if( *szCurrentLocation == DPNA_ESCAPECHAR )
				dwCount += 2;
			else
				dwCount+=3;
		}
		else
		{
			dwCount++;
		}

		szCurrentLocation++;
	}

	return dwCount;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::CalcComponentStringSize"
HRESULT DP8ADDRESSOBJECT::CalcComponentStringSize( PDP8ADDRESSELEMENT paddElement, PDWORD pdwSize )
{
	if( paddElement == NULL )
		return DPNERR_INVALIDPOINTER;

	if( paddElement->dwType == DPNA_DATATYPE_GUID )
	{
		*pdwSize = DNURL_LENGTH_GUID;
	}
	else if( paddElement->dwType == DPNA_DATATYPE_DWORD )
	{
		WCHAR tmpString[DNURL_LENGTH_DWORD+1];
		
		swprintf( tmpString, L"%d", paddElement->uData.dwData );		
		
		*pdwSize = wcslen(tmpString);	
	}
	// No WWCHARs need to be escaped
	else if( paddElement->dwType == DPNA_DATATYPE_STRING )
	{
		if( paddElement->dwFlags & DP8ADDRESS_ELEMENT_HEAP )
		{
			*pdwSize = CalcExpandedStringSize( (WCHAR *) paddElement->uData.pvData );
		}
		else
		{
			*pdwSize = CalcExpandedStringSize( paddElement->uData.szData );		
		}
	}
	// Every WWCHAR needs to be escaped
	else
	{
		if( paddElement->dwFlags & DP8ADDRESS_ELEMENT_HEAP )
		{
			*pdwSize = CalcExpandedBinarySize( (BYTE *) paddElement->uData.pvData, paddElement->dwDataSize );
		}
		else
		{
			*pdwSize = CalcExpandedBinarySize( (BYTE *) paddElement->uData.szData, paddElement->dwDataSize );		
		}	
	}

	// Add on the tag
	*pdwSize += paddElement->dwTagSize-1;

	// Add on the = and the ;
	(*pdwSize) ++;

	return DPN_OK;

}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::IsEscapeChar"
BOOL DP8ADDRESSOBJECT::IsEscapeChar( WCHAR ch )
{
	if( ch >= L'A' && ch <= L'Z' )
		return FALSE;

	if( ch >= L'a' && ch <= L'z' )
		return FALSE;

	if( ch >= L'0' && ch <= L'9' )
		return FALSE;

	if( ch == L'-' || ch == L'?' || ch == L'.' ||
		ch == L',' || ch == 'L+' || ch == L'_' )
		return FALSE;

	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::BuildURL_AddString"
void DP8ADDRESSOBJECT::BuildURL_AddString( WCHAR *szElements, WCHAR *szSource )
{
	WCHAR *szSourceLoc = szSource;
	WCHAR tmpEscape[4];
	DWORD dwIndex;

	while( *szSourceLoc )
	{
		if( IsEscapeChar( *szSourceLoc ) )
		{
			if( *szSourceLoc == DPNA_ESCAPECHAR )
			{
				wcscat( szElements, L"%%" );
			}
			else
			{
				swprintf( tmpEscape, L"%%%02.2X", (DWORD) *szSourceLoc );
				wcscat( szElements, tmpEscape );		
			}
		}
		else
		{
			dwIndex = wcslen(szElements);
			szElements[dwIndex] = *szSourceLoc;
			szElements[dwIndex+1] = 0;
		}

		szSourceLoc++;
	}

}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::BuildURL_AddElements"
HRESULT DP8ADDRESSOBJECT::BuildURL_AddElements( WCHAR *szElements )
{
	DP8ADDRESSELEMENT *pCurrentElement;
	CBilink *pblRunner;
	WCHAR tmpString[DNURL_LENGTH_GUID+2];
	BOOL fFirstElement = TRUE;
	DWORD dwTmpLength;

	pblRunner = m_blAddressElements.GetNext();

	while( pblRunner != &m_blAddressElements )
	{
		pCurrentElement = CONTAINING_RECORD(pblRunner, DP8ADDRESSELEMENT, blAddressElements);

		if( !fFirstElement )
		{
			dwTmpLength = wcslen(szElements);
			szElements[dwTmpLength] = DPNA_SEPARATOR_COMPONENT;
			szElements[dwTmpLength+1] = 0;
		}

		wcscat( szElements, pCurrentElement->pszTag );

		dwTmpLength = wcslen(szElements);
		szElements[dwTmpLength] = DPNA_SEPARATOR_KEYVALUE;
		szElements[dwTmpLength+1] = 0;
	
		if( pCurrentElement->dwType == DPNA_DATATYPE_STRING )
		{
			if( pCurrentElement->dwFlags & DP8ADDRESS_ELEMENT_HEAP )
			{
				BuildURL_AddString( szElements, (WCHAR *) pCurrentElement->uData.pvData );			
			}
			else
			{
				BuildURL_AddString( szElements, pCurrentElement->uData.szData );
			}
		}
		else if( pCurrentElement->dwType == DPNA_DATATYPE_GUID )
		{
			swprintf( tmpString, L"%%7B%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X%%7D",
    		       pCurrentElement->uData.guidData.Data1, pCurrentElement->uData.guidData.Data2, pCurrentElement->uData.guidData.Data3,
    		       pCurrentElement->uData.guidData.Data4[0], pCurrentElement->uData.guidData.Data4[1],
    		       pCurrentElement->uData.guidData.Data4[2], pCurrentElement->uData.guidData.Data4[3],
		           pCurrentElement->uData.guidData.Data4[4], pCurrentElement->uData.guidData.Data4[5],
		           pCurrentElement->uData.guidData.Data4[6], pCurrentElement->uData.guidData.Data4[7] );			
		    wcscat( szElements, tmpString );
		}
		else if( pCurrentElement->dwType == DPNA_DATATYPE_DWORD )
		{
			swprintf( tmpString, L"%d", pCurrentElement->uData.dwData );	
			wcscat( szElements, tmpString );
		}
		// Binary
		else
		{
			if( pCurrentElement->dwFlags & DP8ADDRESS_ELEMENT_HEAP )
			{
				BuildURL_AddBinaryData( szElements, (BYTE *) pCurrentElement->uData.pvData , pCurrentElement->dwDataSize );				
			}
			else
			{
				BuildURL_AddBinaryData( szElements, ((BYTE *) &pCurrentElement->uData), pCurrentElement->dwDataSize );
			}
		}

		fFirstElement = FALSE;
		
		pblRunner = pblRunner->GetNext();
	}

	return DPN_OK;
	
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::BuildURL_AddHeader"
HRESULT DP8ADDRESSOBJECT::BuildURL_AddHeader( WCHAR *szWorking )
{
	WCHAR *szReturn;

	wcscpy( szWorking, DPNA_HEADER );

	szReturn = szWorking + wcslen( DPNA_HEADER );

	return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::BuildURL_AddUserData"
HRESULT DP8ADDRESSOBJECT::BuildURL_AddUserData(WCHAR * szWorking)
{
	return BuildURL_AddBinaryData( szWorking, (BYTE *) m_pvUserData, m_dwUserDataSize );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::BuildURL_AddBinaryData"
HRESULT DP8ADDRESSOBJECT::BuildURL_AddBinaryData( WCHAR *szSource, BYTE *bData, DWORD dwDataLen )
{
	WCHAR *pwszCurrentDest = szSource + wcslen(szSource);
	BYTE *pbCurrentData = bData;
	DWORD dwDataRemaining = dwDataLen;


	dwDataRemaining = dwDataLen;
	while ( dwDataRemaining > 0 )
	{
		if( IsEscapeChar( (WCHAR) *pbCurrentData ) )
		{
			if( ((WCHAR) *pbCurrentData) == DPNA_ESCAPECHAR )
			{
				wcscpy(pwszCurrentDest, L"%%");
				pwszCurrentDest += 2;
			}
			else
			{
				pwszCurrentDest += swprintf( pwszCurrentDest, L"%%%02.2X", (DWORD) *pbCurrentData );
			}
		}
		else
		{
			*pwszCurrentDest = (WCHAR) *pbCurrentData;
			pwszCurrentDest++;
		}

		pbCurrentData++;
		dwDataRemaining--;
	}

	// Ensure the string is NULL terminated if we added anything.
	if ( dwDataLen > 0 )
	{
		*pwszCurrentDest = 0;
	}

	return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::BuildURL"
HRESULT DP8ADDRESSOBJECT::BuildURL( WCHAR * szURL, PDWORD pdwRequiredSize )
{
	if( pdwRequiredSize == NULL )
	{
		DPFX(DPFPREP,  0, "Must specify valid pointer for size" );
		return DPNERR_INVALIDPOINTER;
	}

	HRESULT hr;

	ENTERLOCK();

	// Address must be valid
	if( !IsValid() )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Address is not valid" );
		LEAVELOCK();
		return DPNERR_INVALIDURL;
	}

	if( *pdwRequiredSize < m_dwStringSize || szURL == NULL )
	{
		*pdwRequiredSize = m_dwStringSize;
		DPFX(DPFPREP,  DP8A_WARNINGLEVEL, "Buffer too small" );
		LEAVELOCK();
		return DPNERR_BUFFERTOOSMALL;
	}

	hr = BuildURL_AddHeader( szURL );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Error adding header hr=0x%x", hr );
		LEAVELOCK();		
		return hr;
	}

	hr = BuildURL_AddElements( szURL );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Error adding elements hr=0x%x", hr );
		LEAVELOCK();		
		return hr;
	}
	
	hr = BuildURL_AddUserData( szURL );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Error adding user data hr=0x%x", hr );
		LEAVELOCK();		
		return hr;
	}

	LEAVELOCK();

	*pdwRequiredSize = m_dwStringSize;

	return DPN_OK;

}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::SetURL"
HRESULT DP8ADDRESSOBJECT::SetURL( WCHAR * szURL )
{
	HRESULT hr;

	DP8ADDRESSPARSE dp8aParser;

	if( IsLocked() )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Cannot set element, object read-only" );
		return DPNERR_NOTALLOWED;
	}

	hr = Clear();

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Unable to clear existing address hr=0x%x", hr );
		return hr;
	}

	ENTERLOCK();	

	hr = dp8aParser.ParseURL(this, szURL);

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Error parsing the URL hr=0x%x", hr );
		LEAVELOCK();
		return hr;
	}

	LEAVELOCK();	

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::Lock"
HRESULT DP8ADDRESSOBJECT::	Lock(  )
{
	ENTERLOCK();	

	m_iLockCount++;

	LEAVELOCK();	

	return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::UnLock"
HRESULT DP8ADDRESSOBJECT::	UnLock(  )
{
	ENTERLOCK();	

	if( m_iLockCount == 0 )
	{
		DPFX(DPFPREP,  0, "Unlocking unlocked object is not allowed" );
		LEAVELOCK();
		return DPNERR_NOTALLOWED;
	}

	m_iLockCount--;

	LEAVELOCK();	

	return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::SetDirectPlay4Address"
HRESULT DP8ADDRESSOBJECT::SetDirectPlay4Address( void * pvDataBuffer, const DWORD dwDataSize )
{
    PBYTE pbCurrentLocation;
    PDPADDRESS pdpAddressChunk;
    LONG lRemaining;
    HRESULT hr = DPN_OK;
    DWORD dwCurrentChunkSize;
    DWORD dwNumElementsParsed = 0;

	if( IsLocked() )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Cannot set element, object read-only" );
		return DPNERR_NOTALLOWED;
	}

    // XBOX! This function will not be required on XBOX.  Have it return DPNERR_NOTSUPPORTED
    ENTERLOCK();

    hr = Clear();

    if( FAILED( hr ) )
    {
        DPFX(DPFPREP,  0, "Failed to clear old address data hr=[0x%lx]", hr );
        LEAVELOCK();
        return hr;
    }

    pbCurrentLocation = (PBYTE) pvDataBuffer;
    lRemaining = dwDataSize;

    while( lRemaining > 0 )
    {
        pdpAddressChunk = (PDPADDRESS) pbCurrentLocation;

        if( sizeof( DPADDRESS ) > lRemaining )
        {
            DPFX(DPFPREP,  0, "Error parsing address, unexpected end of address" );
			LEAVELOCK();
            return DPNERR_INVALIDADDRESSFORMAT;
        }

        dwCurrentChunkSize = sizeof( DPADDRESS ) + pdpAddressChunk->dwDataSize;

        if( ((LONG) dwCurrentChunkSize) > lRemaining )
        {
            DPFX(DPFPREP,  0, "Error parsing address, unexpected end during data" );
			LEAVELOCK();
            return DPNERR_INVALIDADDRESSFORMAT;
        }

        hr = AddDP4Element( pdpAddressChunk, this );

        if( FAILED( hr ) )
        {
            DPFX(DPFPREP,  0, "Error adding next element" );
            break;
        }

        lRemaining -= dwCurrentChunkSize;

        pbCurrentLocation += dwCurrentChunkSize;
    }

    LEAVELOCK();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\dnaddress\addbase.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       addtcp.cpp
 *  Content:    DirectPlay8Address TCP interace file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *  ====       ==      ======
 * 02/04/2000	rmt		Created
 * 02/12/2000	rmt		Split Get into GetByName and GetByIndex
 * 02/17/2000	rmt		Parameter validation work
 * 02/21/2000	rmt		Updated to make core Unicode and remove ANSI calls
 * 03/21/2000   rmt     Renamed all DirectPlayAddress8's to DirectPlay8Addresses
 *                      Added support for the new ANSI type
 *                      Added SetEqual function
 * 03/24/2000	rmt		Added IsEqual function
 * 04/21/2000   rmt     Bug #32952 - Does not run on Win95 GOLD pre-IE4
 * 05/01/2000   rmt     Bug #33074 - Debug accessing invalid memory
 * 05/17/2000   rmt     Bug #35051 - Incorrect function names in debug spew
 * 06/09/2000   rmt     Updates to split CLSID and allow whistler compat
 * 07/21/2000	rmt		Fixed bug w/directplay 4 address parsing
 * 02/07/2001	rmt		WINBUG #290631 - IA64: DirectPlay: Addressing BuildFromDPADDRESS should always return UNSUPPORTED
 *
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dnaddri.h"


typedef	STDMETHODIMP BaseQueryInterface( IDirectPlay8Address *pInterface, REFIID riid, LPVOID *ppvObj );
typedef	STDMETHODIMP_(ULONG)	BaseAddRef( IDirectPlay8Address *pInterface );
typedef	STDMETHODIMP_(ULONG)	BaseRelease( IDirectPlay8Address *pInterface );

//
// VTable for client interface
//
IDirectPlay8AddressVtbl DP8A_BaseVtbl =
{
	(BaseQueryInterface*)	DP8A_QueryInterface,
	(BaseAddRef*)			DP8A_AddRef,
	(BaseRelease*)			DP8A_Release,
							DP8A_BuildFromURLW,
							DP8A_BuildFromURLA,
							DP8A_Duplicate,
							DP8A_SetEqual,
							DP8A_IsEqual,
							DP8A_Clear,
							DP8A_GetURLW,
							DP8A_GetURLA,
							DP8A_GetSP,
							DP8A_GetUserData,
							DP8A_SetSP,
							DP8A_SetUserData,
							DP8A_GetNumComponents,
							DP8A_GetComponentByNameW,
							DP8A_GetComponentByIndexW,
							DP8A_AddComponentW,
							DP8A_GetDevice,
							DP8A_SetDevice,
                            DP8A_BuildFromDirectPlay4Address
};

//**********************************************************************
// Function prototypes
//**********************************************************************

#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_IsEqual"
STDMETHODIMP DP8A_IsEqual( IDirectPlay8Address *pInterface, PDIRECTPLAY8ADDRESS pdp8ExternalAddress )
{
	if( pInterface == NULL ||
	   !DP8A_VALID( pInterface ) )
	{
		DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Invalid object" );
		DP8A_RETURN( DPNERR_INVALIDOBJECT );
	}
	
	HRESULT hr;
	WCHAR *wszFirstURL = NULL,
		  *wszSecondURL = NULL;
	DWORD dwFirstBufferSize = 0,
	      dwSecondBuffersize = 0;

	DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Enter" );

	if( pdp8ExternalAddress == NULL )
    {
        DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer specified" );
        DP8A_RETURN( DPNERR_INVALIDPOINTER );
    }

	if( !DP8A_VALID( pdp8ExternalAddress ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid object" );
		DP8A_RETURN( DPNERR_INVALIDOBJECT );
	}

	hr = pInterface->lpVtbl->GetURLW( pInterface, wszFirstURL, &dwFirstBufferSize );

	if( hr != DPNERR_BUFFERTOOSMALL )
	{
		DPFX(DPFPREP,  0, "Could not get URL size for current object hr=[0x%lx]", hr );
		goto ISEQUAL_ERROR;
	}

	wszFirstURL = new WCHAR[dwFirstBufferSize];

	if( wszFirstURL == NULL )
	{
		DPFX(DPFPREP,  0, "Error allocating memory hr=[0x%lx]", hr );
		goto ISEQUAL_ERROR;
	}

	hr = pInterface->lpVtbl->GetURLW( pInterface, wszFirstURL, &dwFirstBufferSize );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Could not get URL for current object hr=[0x%lx]", hr );
		goto ISEQUAL_ERROR;
	}

	hr = pdp8ExternalAddress->lpVtbl->GetURLW( pdp8ExternalAddress, wszSecondURL, &dwSecondBuffersize );

	if( hr != DPNERR_BUFFERTOOSMALL )
	{
		DPFX(DPFPREP,  0, "Could not get URL size for exterior object hr=[0x%lx]", hr );
		goto ISEQUAL_ERROR;
	}

	wszSecondURL = new WCHAR[dwSecondBuffersize];

	if( wszSecondURL == NULL )
	{
		DPFX(DPFPREP,  0, "Error allocating memory hr=[0x%lx]", hr );
		goto ISEQUAL_ERROR;
	}

	hr = pdp8ExternalAddress->lpVtbl->GetURLW( pdp8ExternalAddress, wszSecondURL, &dwSecondBuffersize );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Could not get URL for exterior object hr=[0x%lx]", hr );
		goto ISEQUAL_ERROR;
	}

	if( _wcsicmp( wszFirstURL, wszSecondURL ) == 0 )
	{
		hr = DPNSUCCESS_EQUAL;
	}
	else
	{
		hr = DPNSUCCESS_NOTEQUAL;
	}

ISEQUAL_ERROR:

	if( wszFirstURL != NULL )
		delete [] wszFirstURL;

	if( wszSecondURL != NULL )
		delete [] wszSecondURL;

	DP8A_RETURN( hr );

}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_SetEqual"
STDMETHODIMP DP8A_SetEqual( IDirectPlay8Address *pInterface, PDIRECTPLAY8ADDRESS pdp8ExternalAddress )
{
	if( pInterface == NULL ||
	   !DP8A_VALID( pInterface ) )
	{
		DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Invalid object" );
		DP8A_RETURN( DPNERR_INVALIDOBJECT );
	}
	
	DP8ADDRESSOBJECT *pdp8Address = (DP8ADDRESSOBJECT *) GET_OBJECT_FROM_INTERFACE( pInterface );

	HRESULT hr;
	WCHAR *wszURLBuffer = NULL;
	DWORD dwBufferSize = 0;

	DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Enter" );

	if( pdp8ExternalAddress == NULL )
    {
        DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer specified" );
        DP8A_RETURN( DPNERR_INVALIDPOINTER );
    }

	if( !DP8A_VALID( pdp8ExternalAddress ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid object" );
		DP8A_RETURN( DPNERR_INVALIDOBJECT );
	}	

    // Get ourselves a reference for duration of the call
	pdp8ExternalAddress->lpVtbl->AddRef(pdp8ExternalAddress);

	hr = pdp8ExternalAddress->lpVtbl->GetURLW( pdp8ExternalAddress, wszURLBuffer, &dwBufferSize );

	if( hr != DPNERR_BUFFERTOOSMALL )
	{
	    DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Error getting contents of passed address hr=0x%x", hr );
        goto SETEQUAL_CLEANUP;
	}

	wszURLBuffer = new WCHAR[dwBufferSize];

	if( wszURLBuffer == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Error allocating memory" );
		goto SETEQUAL_CLEANUP;
	}

	hr = pdp8ExternalAddress->lpVtbl->GetURLW( pdp8ExternalAddress, wszURLBuffer, &dwBufferSize );

	if( FAILED( hr ) )
	{
	    DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Error getting contents of passed address w/buffer hr=0x%x", hr );
        goto SETEQUAL_CLEANUP;
	}

	hr = pdp8Address->SetURL( wszURLBuffer );

	if( FAILED( hr ) )
	{
	    DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Error setting address to match passed address hr=0x%x", hr );
        goto SETEQUAL_CLEANUP;
	}

SETEQUAL_CLEANUP:

    pdp8ExternalAddress->lpVtbl->Release(pdp8ExternalAddress);

    if( wszURLBuffer != NULL )
        delete [] wszURLBuffer;

    DP8A_RETURN( hr );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_BuildFromDirectPlay4Address"
STDMETHODIMP DP8A_BuildFromDirectPlay4Address( IDirectPlay8Address *pInterface, void * pvDataBuffer, DWORD dwDataSize )
{
    // XBOX! This function will not be required on XBOX.  Have it return DPNERR_NOTSUPPORTED
	if( pInterface == NULL ||
	   !DP8A_VALID( pInterface ) )
	{
		DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Invalid object" );
		DP8A_RETURN( DPNERR_INVALIDOBJECT );
	}

	#ifdef _WIN64
	DPFX(DPFPREP, DP8A_ERRORLEVEL, "BuildFromDirectPlay4Address() is not supported on Win64" );
	DP8A_RETURN( E_NOTIMPL );
	#else
	
	DP8ADDRESSOBJECT *pdp8Address = (DP8ADDRESSOBJECT *) GET_OBJECT_FROM_INTERFACE( pInterface );

	HRESULT hr;

	DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Enter" );	

    if( dwDataSize == 0 )
    {
    	DPFX(DPFPREP,  DP8A_ERRORLEVEL, "0 length addresses are not allowed" );
    	return DPNERR_INVALIDPARAM;
    }	

    if( pvDataBuffer == NULL ||
        !DNVALID_READPTR( pvDataBuffer, dwDataSize ) )
    {
        DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Specified buffer is invalid" );
        DP8A_RETURN( DPNERR_INVALIDPOINTER );
    }

    hr = pdp8Address->SetDirectPlay4Address( pvDataBuffer, dwDataSize );

    DP8A_RETURN( hr );
    #endif
}

// DP8A_BuildFromURLA
//
// Initializes this object with URL specified in ANSI
//
#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_BuildFromURLA"
STDMETHODIMP DP8A_BuildFromURLA( IDirectPlay8Address *pInterface, CHAR * pszAddress )
{
	if( pInterface == NULL ||
	   !DP8A_VALID( pInterface ) )
	{
		DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Invalid object" );
		DP8A_RETURN( DPNERR_INVALIDOBJECT );
	}
	
	DP8ADDRESSOBJECT *pdp8Address = (DP8ADDRESSOBJECT *) GET_OBJECT_FROM_INTERFACE( pInterface );

	HRESULT hr;

	DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Enter" );	

	if( pszAddress == NULL )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer to address.  An address must be specified" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );
	}

	if( !DNVALID_STRING_A( pszAddress ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid string specified for address" );
		DP8A_RETURN( DPNERR_INVALIDSTRING );
	}

	DPFX(DPFPREP,  DP8A_PARAMLEVEL, "pszAddress = %s", pszAddress );

	WCHAR *szShadowBuffer = NULL;

	DWORD dwStrSize = 0;

	if( pszAddress != NULL )
	{
		dwStrSize = strlen(pszAddress)+1;
		
		szShadowBuffer = new WCHAR[dwStrSize];

		if( szShadowBuffer == NULL )
		{
			DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Error allocating memory" );
			hr = DPNERR_OUTOFMEMORY;
			goto BUILDFROMURLW_RETURN;
		}

		if( FAILED( hr = STR_jkAnsiToWide( szShadowBuffer, pszAddress, dwStrSize ) )  )
		{
			DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Error converting URL to ANSI hr=0x%x", hr );
			hr = DPNERR_CONVERSION;
			goto BUILDFROMURLW_RETURN;
		}
	}

	hr = pdp8Address->SetURL( szShadowBuffer );

BUILDFROMURLW_RETURN:

	if( szShadowBuffer )
		delete [] szShadowBuffer;

	DP8A_RETURN( hr );	
}

// DP8A_BuildFromURLW
//
// Initializes this object with URL specified in Unicode
//
#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_BuildFromURLW"
STDMETHODIMP DP8A_BuildFromURLW( IDirectPlay8Address *pInterface, WCHAR * pwszAddress )

{
	if( pInterface == NULL ||
	   !DP8A_VALID( pInterface ) )
	{
		DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Invalid object" );
		DP8A_RETURN( DPNERR_INVALIDOBJECT );
	}
	
	DP8ADDRESSOBJECT *pdp8Address = (DP8ADDRESSOBJECT *) GET_OBJECT_FROM_INTERFACE( pInterface );

	HRESULT hr;

	DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Enter" );	

	if( pwszAddress == NULL )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer to address.  An address must be specified" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );
	}

	if( !DNVALID_STRING_W( pwszAddress ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid string specified for address" );
		DP8A_RETURN( DPNERR_INVALIDSTRING );
	}

	// 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPFX(DPFPREP,  DP8A_PARAMLEVEL, "pwszAddress = 0x%p", pwszAddress );

	hr = pdp8Address->SetURL( pwszAddress );

	DP8A_RETURN( hr );	
}

// DP8A_Duplicate
//
// Creates and initializes another address object as a duplicate to this one.
//
#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_Duplicate"
STDMETHODIMP DP8A_Duplicate( IDirectPlay8Address *pInterface, PDIRECTPLAY8ADDRESS *ppInterface )
{
	if( pInterface == NULL ||
	   !DP8A_VALID( pInterface ) )
	{
		DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Invalid object" );
		DP8A_RETURN( DPNERR_INVALIDOBJECT );
	}
	
	DP8ADDRESSOBJECT *pdp8Address = (DP8ADDRESSOBJECT *) GET_OBJECT_FROM_INTERFACE( pInterface );
	HRESULT hr;

	WCHAR *szTmpURL = NULL;
	DWORD dwURLSize = 0;
	LPDIRECTPLAY8ADDRESS lpdp8Address = NULL;

	DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Enter" );	

	if( ppInterface == NULL ||
	   !DNVALID_WRITEPTR( ppInterface, sizeof(LPVOID) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer to pointer specified in ppInterface" );
		hr = DPNERR_INVALIDPOINTER;
		goto DUPLICATE_FAIL;
	}

	// 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPFX(DPFPREP,  DP8A_PARAMLEVEL, "ppInterface = 0x%p", ppInterface );	

	hr = pdp8Address->BuildURL( szTmpURL, &dwURLSize );

	if( hr != DPNERR_BUFFERTOOSMALL )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "BuildURL from object failed hr=0x%x", hr );
		goto DUPLICATE_FAIL;
	}

	szTmpURL = new WCHAR[dwURLSize];

	if( szTmpURL == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Memory alloc failure" );
		goto DUPLICATE_FAIL;	
	}

	hr = pdp8Address->BuildURL( szTmpURL, &dwURLSize );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "BuildURL from object failed hr=0x%x", hr );
		goto DUPLICATE_FAIL;
	}
	
    hr = COM_CoCreateInstance( CLSID_DirectPlay8Address, NULL, CLSCTX_INPROC_SERVER  , IID_IDirectPlay8Address, (void **) &lpdp8Address );

	if( FAILED( hr ) )
    {
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "CoCreate failed hr=0x%x", hr );
		goto DUPLICATE_FAIL;
    }

    hr = lpdp8Address->lpVtbl->BuildFromURLW( lpdp8Address, szTmpURL );

    if( FAILED( hr ) )
    {
    	DPFX(DPFPREP,  DP8A_ERRORLEVEL, "BuildFailed hr=0x%x", hr );
    	goto DUPLICATE_FAIL;
    }

    *ppInterface = lpdp8Address;

	if( szTmpURL != NULL )
		delete [] szTmpURL;

    return DPN_OK;

DUPLICATE_FAIL:

	if( lpdp8Address != NULL )
		lpdp8Address->lpVtbl->Release(lpdp8Address);

	if( szTmpURL != NULL )
		delete [] szTmpURL;

	return hr;
	
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_GetURLA"
STDMETHODIMP DP8A_GetURLA( IDirectPlay8Address *pInterface, CHAR * pszAddress, PDWORD pdwAddressSize )

{
	if( pInterface == NULL ||
	   !DP8A_VALID( pInterface ) )
	{
		DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Invalid object" );
		DP8A_RETURN( DPNERR_INVALIDOBJECT );
	}
	
	DP8ADDRESSOBJECT *pdp8Address = (DP8ADDRESSOBJECT *) GET_OBJECT_FROM_INTERFACE( pInterface );

	HRESULT hr;

	DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Enter" );	

	if( pdwAddressSize == NULL ||
	   !DNVALID_WRITEPTR( pdwAddressSize, sizeof(DWORD) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer specified for address size" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );		
	}

	if( *pdwAddressSize > 0 &&
	   (pszAddress == NULL ||
	    !DNVALID_WRITEPTR( pszAddress, (*pdwAddressSize) ) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer specified for address" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );
	}

	// 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPFX(DPFPREP,  DP8A_PARAMLEVEL, "pwszAddress = 0x%p pdwAddressSize = 0x%p (%u)",
	     pszAddress , pdwAddressSize, *pdwAddressSize );

	WCHAR *szShadowBuffer = NULL;

	if( *pdwAddressSize  != 0 )
	{
		szShadowBuffer = new WCHAR[*pdwAddressSize];

		if( szShadowBuffer == NULL )
		{
			DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Error allocating memory" );
			hr = DPNERR_OUTOFMEMORY;
			goto GETURLW_RETURN;
		}
	}
	else
	{	
		szShadowBuffer= NULL;
	}

	hr = pdp8Address->BuildURL( szShadowBuffer, pdwAddressSize );

	if( hr == DPN_OK )
	{
		if( FAILED( hr = STR_jkWideToAnsi( pszAddress, szShadowBuffer, *pdwAddressSize ) ) )
		{
			DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Error converting ANSI->WIDE hr=0x%x", hr );
			hr = DPNERR_CONVERSION;
			goto GETURLW_RETURN;
		}
	}
	
GETURLW_RETURN:

	if( szShadowBuffer != NULL )
		delete [] szShadowBuffer;

	DP8A_RETURN( hr );
}

// DP8A_GetURLW
//
// Retrieves the URL represented by this object in Unicode format
//
#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_GetURLW"
STDMETHODIMP DP8A_GetURLW( IDirectPlay8Address *pInterface, WCHAR * pwszAddress, PDWORD pdwAddressSize )
{
	if( pInterface == NULL ||
	   !DP8A_VALID( pInterface ) )
	{
		DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Invalid object" );
		DP8A_RETURN( DPNERR_INVALIDOBJECT );
	}
	
	DP8ADDRESSOBJECT *pdp8Address = (DP8ADDRESSOBJECT *) GET_OBJECT_FROM_INTERFACE( pInterface );

	HRESULT hr;

	DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Enter" );	

	if( pdwAddressSize == NULL ||
	   !DNVALID_WRITEPTR( pdwAddressSize, sizeof(DWORD) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer specified for address size" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );		
	}

	if( *pdwAddressSize > 0 &&
	   (pwszAddress == NULL ||
	    !DNVALID_WRITEPTR( pwszAddress, (*pdwAddressSize)*sizeof(WCHAR) ) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer specified for address" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );
	}

	// 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPFX(DPFPREP,  DP8A_PARAMLEVEL, "pwszAddress = 0x%p pdwAddressSize = 0x%p (%u)",
	     pwszAddress, pdwAddressSize, *pdwAddressSize );

	hr = pdp8Address->BuildURL( pwszAddress, pdwAddressSize );

	DP8A_RETURN( hr );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_GetSP"
STDMETHODIMP DP8A_GetSP( IDirectPlay8Address *pInterface, GUID * pguidSP )
{
	if( pInterface == NULL ||
	   !DP8A_VALID( pInterface ) )
	{
		DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Invalid object" );
		DP8A_RETURN( DPNERR_INVALIDOBJECT );
	}
	
	DP8ADDRESSOBJECT *pdp8Address = (PDP8ADDRESSOBJECT) GET_OBJECT_FROM_INTERFACE( pInterface );
	HRESULT hr;

	DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Enter" );

	if( pguidSP == NULL ||
	   !DNVALID_WRITEPTR( pguidSP, sizeof( GUID ) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer specified for pguidSP" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );
	}

	// 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPFX(DPFPREP,  DP8A_PARAMLEVEL, "pguidSP = 0x%p ", pguidSP );

	hr = pdp8Address->GetSP( pguidSP );

	DP8A_RETURN( hr );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_GetUserData"
STDMETHODIMP DP8A_GetUserData( IDirectPlay8Address *pInterface, void * pBuffer, PDWORD pdwBufferSize )
{
	if( pInterface == NULL ||
	   !DP8A_VALID( pInterface ) )
	{
		DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Invalid object" );
		DP8A_RETURN( DPNERR_INVALIDOBJECT );
	}
	
	DP8ADDRESSOBJECT *pdp8Address = (PDP8ADDRESSOBJECT) GET_OBJECT_FROM_INTERFACE( pInterface );
	HRESULT hr;

	DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Enter" );	

	if( pdwBufferSize == NULL ||
	   !DNVALID_WRITEPTR( pdwBufferSize, sizeof( DWORD ) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer specified for pdwBufferSize" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );
	}	

	if( *pdwBufferSize > 0 &&
	   (pBuffer == NULL || !DNVALID_WRITEPTR( pBuffer, *pdwBufferSize ) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer specified for pBuffer" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );
	}

	// 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPFX(DPFPREP,  DP8A_PARAMLEVEL, "pBuffer = 0x%p pdwBufferSize = 0x%p(%u) ", pBuffer, pdwBufferSize, *pdwBufferSize );

	hr = pdp8Address->GetUserData( pBuffer, pdwBufferSize );

	DP8A_RETURN( hr );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_SetSP"
STDMETHODIMP DP8A_SetSP( IDirectPlay8Address *pInterface, const GUID * const pguidSP )
{
	if( pInterface == NULL ||
	   !DP8A_VALID( pInterface ) )
	{
		DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Invalid object" );
		DP8A_RETURN( DPNERR_INVALIDOBJECT );
	}
	
	DP8ADDRESSOBJECT *pdp8Address = (PDP8ADDRESSOBJECT) GET_OBJECT_FROM_INTERFACE( pInterface );
	HRESULT hr;

	DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Enter" );	

	if( pguidSP == NULL ||
	   !DNVALID_READPTR( pguidSP, sizeof( GUID ) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer specified for pguidSP" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );
	}

	// 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPFX(DPFPREP,  DP8A_PARAMLEVEL, "pguidSP = 0x%p", pguidSP );

	hr = pdp8Address->SetSP( pguidSP );

	DP8A_RETURN( hr );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_GetDevice"
STDMETHODIMP DP8A_GetDevice( IDirectPlay8Address *pInterface, GUID * pguidSP )
{
	if( pInterface == NULL ||
	   !DP8A_VALID( pInterface ) )
	{
		DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Invalid object" );
		DP8A_RETURN( DPNERR_INVALIDOBJECT );
	}
	
	DP8ADDRESSOBJECT *pdp8Address = (PDP8ADDRESSOBJECT) GET_OBJECT_FROM_INTERFACE( pInterface );
	HRESULT hr;

	DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Enter" );	

	if( pguidSP == NULL ||
	   !DNVALID_WRITEPTR( pguidSP, sizeof( GUID ) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer specified for pguidDevice" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );
	}	

	// 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPFX(DPFPREP,  DP8A_PARAMLEVEL, "pguidDevice = 0x%p", pguidSP );	

	hr = pdp8Address->GetDevice( pguidSP );

	DP8A_RETURN( hr );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_SetDevice"
STDMETHODIMP DP8A_SetDevice( IDirectPlay8Address *pInterface, const GUID * const pguidSP )
{
	if( pInterface == NULL ||
	   !DP8A_VALID( pInterface ) )
	{
		DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Invalid object" );
		DP8A_RETURN( DPNERR_INVALIDOBJECT );
	}
	
	DP8ADDRESSOBJECT *pdp8Address = (PDP8ADDRESSOBJECT) GET_OBJECT_FROM_INTERFACE( pInterface );
	HRESULT hr;

	DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Enter" );	

	if( pguidSP == NULL ||
	   !DNVALID_READPTR( pguidSP, sizeof( GUID ) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer specified for pguidDevice" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );
	}	

	// 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPFX(DPFPREP,  DP8A_PARAMLEVEL, "pguidDevice = 0x%p", pguidSP );		

	hr = pdp8Address->SetDevice( pguidSP );

	DP8A_RETURN( hr );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_SetUserData"
STDMETHODIMP DP8A_SetUserData( IDirectPlay8Address *pInterface, const void * const pBuffer, const DWORD dwBufferSize )
{
	if( pInterface == NULL ||
	   !DP8A_VALID( pInterface ) )
	{
		DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Invalid object" );
		DP8A_RETURN( DPNERR_INVALIDOBJECT );
	}
	
	DP8ADDRESSOBJECT *pdp8Address = (PDP8ADDRESSOBJECT) GET_OBJECT_FROM_INTERFACE( pInterface );
	HRESULT hr;

	DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Enter" );	

	if( dwBufferSize > 0 &&
	   (pBuffer == NULL || !DNVALID_READPTR( pBuffer, dwBufferSize ) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer specified for pBuffer" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );
	}

	// 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPFX(DPFPREP,  DP8A_PARAMLEVEL, "pBuffer = 0x%p dwBufferSize = %u", pBuffer, dwBufferSize );		

	hr = pdp8Address->SetUserData( pBuffer, dwBufferSize );

	DP8A_RETURN( hr );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_GetNumComponents"
STDMETHODIMP DP8A_GetNumComponents( IDirectPlay8Address *pInterface, PDWORD pdwNumComponents )
{
	if( pInterface == NULL ||
	   !DP8A_VALID( pInterface ) )
	{
		DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Invalid object" );
		DP8A_RETURN( DPNERR_INVALIDOBJECT );
	}
	
	DP8ADDRESSOBJECT *pdp8Address = (PDP8ADDRESSOBJECT) GET_OBJECT_FROM_INTERFACE( pInterface );

	DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Enter" );	

	if( pdwNumComponents == NULL ||
	   !DNVALID_WRITEPTR( pdwNumComponents, sizeof(DWORD) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid ptr for num of components" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );
	}

	*pdwNumComponents = pdp8Address->GetNumComponents();

	DP8A_RETURN( DPN_OK );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_GetComponentByNameW"
STDMETHODIMP DP8A_GetComponentByNameW( IDirectPlay8Address *pInterface, const WCHAR * const pwszTag, void * pComponentBuffer, PDWORD pdwComponentSize, PDWORD pdwDataType )
{
	if( pInterface == NULL ||
	   !DP8A_VALID( pInterface ) )
	{
		DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Invalid object" );
		DP8A_RETURN( DPNERR_INVALIDOBJECT );
	}
	
	DP8ADDRESSOBJECT *pdp8Address = (PDP8ADDRESSOBJECT) GET_OBJECT_FROM_INTERFACE( pInterface );
	HRESULT hr;

	DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Enter" );	

	if( pwszTag == NULL )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer to tag.  A name must be specified" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );		
	}

	if( pdwComponentSize == NULL ||
	   !DNVALID_WRITEPTR( pdwComponentSize, sizeof(DWORD)) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid Pointer to data size" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );		
	}

	if( pdwDataType == NULL ||
	   !DNVALID_READPTR( pdwDataType, sizeof(DWORD)) )	
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer to data type" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );		
	}
	
	if( *pdwComponentSize > 0 &&
	   (pComponentBuffer == NULL || !DNVALID_WRITEPTR( pComponentBuffer, *pdwComponentSize ) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer to component data" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );
	}	

	if( !DNVALID_STRING_W( pwszTag ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid string specified for tag" );
		DP8A_RETURN( DPNERR_INVALIDSTRING );				
	}	

	// 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPFX(DPFPREP,  DP8A_PARAMLEVEL, "pwszTag = 0x%p pComponentBuffer = 0x%p, pdwComponentSize = 0x%p, pdwDataType = 0x%p",
		(pwszTag==NULL) ? NULL : pwszTag, pComponentBuffer, pdwComponentSize, pdwDataType );

	hr = pdp8Address->GetElement( pwszTag, pComponentBuffer, pdwComponentSize, pdwDataType );

	DP8A_RETURN( hr );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_GetComponentByIndexW"
STDMETHODIMP DP8A_GetComponentByIndexW( IDirectPlay8Address *pInterface,
	const DWORD dwComponentID, WCHAR * pwszTag, PDWORD pdwNameLen,
	void * pComponentBuffer, PDWORD pdwComponentSize, PDWORD pdwDataType )
{
	if( pInterface == NULL ||
	   !DP8A_VALID( pInterface ) )
	{
		DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Invalid object" );
		DP8A_RETURN( DPNERR_INVALIDOBJECT );
	}
	
	DP8ADDRESSOBJECT *pdp8Address = (PDP8ADDRESSOBJECT) GET_OBJECT_FROM_INTERFACE( pInterface );
	HRESULT hr;

	DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Enter" );	
	
	if( pdwNameLen == NULL || !DNVALID_WRITEPTR( pdwNameLen, sizeof(DWORD) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer specified for pdwNameLen" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );
	}	

	if( *pdwNameLen != 0 &&
	   (pwszTag == NULL || !DNVALID_WRITEPTR( pwszTag, *pdwNameLen*sizeof(WCHAR) ) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer specified for pwszTag" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );
	}

	if( pdwComponentSize == NULL || !DNVALID_WRITEPTR( pdwComponentSize, sizeof(DWORD) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer specified for pdwComponentSize" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );
	}

	if( *pdwComponentSize != 0 &&
	   (pComponentBuffer == NULL || !DNVALID_WRITEPTR( pComponentBuffer, *pdwComponentSize ) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer specified for pwszTag" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );
	}	

	if( pdwDataType == NULL || !DNVALID_WRITEPTR( pdwDataType, sizeof(DWORD) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer specified for pdwDataType" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );
	}	

	// 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPFX(DPFPREP,  DP8A_PARAMLEVEL, "dwComponentID = %u pwszTag = 0x%p pdwNameLen = 0x%p (%u)  pComponentBuffer = 0x%p, pdwComponentSize = 0x%p (%u), pdwDataType = 0x%p",
		dwComponentID, pwszTag, pdwNameLen, *pdwNameLen, pComponentBuffer, pdwComponentSize, *pdwComponentSize, pdwDataType );

	hr = pdp8Address->GetElement( dwComponentID, pwszTag, pdwNameLen, pComponentBuffer, pdwComponentSize, pdwDataType );

	DP8A_RETURN( hr );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_AddComponentW"
STDMETHODIMP DP8A_AddComponentW( IDirectPlay8Address *pInterface, const WCHAR * const pwszTag, const void * const pComponentData, const DWORD dwComponentSize, const DWORD dwDataType )

{
	if( pInterface == NULL ||
	   !DP8A_VALID( pInterface ) )
	{
		DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Invalid object" );
		DP8A_RETURN( DPNERR_INVALIDOBJECT );
	}
	
	DP8ADDRESSOBJECT *pdp8Address = (PDP8ADDRESSOBJECT) GET_OBJECT_FROM_INTERFACE( pInterface );
	HRESULT hr;

	DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Enter" );	

	if( pwszTag == NULL )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer for tag string" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );
	}

	if( pComponentData == NULL ||
	   !DNVALID_READPTR( pComponentData, dwComponentSize ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer specified for component" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );
	}

	if( !DNVALID_STRING_W( pwszTag ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid string specified for tag" );
		DP8A_RETURN( DPNERR_INVALIDSTRING );
	}

	if( dwDataType != DPNA_DATATYPE_STRING &&
	   dwDataType != DPNA_DATATYPE_DWORD &&
	   dwDataType != DPNA_DATATYPE_GUID &&
	   dwDataType != DPNA_DATATYPE_BINARY &&
	   dwDataType != DPNA_DATATYPE_STRING_ANSI )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid datatype specified" );
		DP8A_RETURN( DPNERR_INVALIDPARAM );
	}

	if( dwDataType == DPNA_DATATYPE_STRING )
	{
		if( !DNVALID_STRING_W( (const WCHAR * const) pComponentData ) )
		{
			DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid string component specified" );
			DP8A_RETURN( DPNERR_INVALIDSTRING );
		}

		if( ((wcslen( (const WCHAR * const) pComponentData)+1)*sizeof(WCHAR)) != dwComponentSize )
		{
			DPFX(DPFPREP,  DP8A_ERRORLEVEL, "String size and component size don't match" );
			DP8A_RETURN( DPNERR_INVALIDPARAM );
		}
	}
	else if( dwDataType == DPNA_DATATYPE_STRING_ANSI )
	{
		if( !DNVALID_STRING_A( (const CHAR * const) pComponentData ) )
		{
			DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid string component specified" );
			DP8A_RETURN( DPNERR_INVALIDSTRING );
		}

		if( ((strlen( (const CHAR * const) pComponentData)+1)*sizeof(char)) != dwComponentSize )
		{
			DPFX(DPFPREP,  DP8A_ERRORLEVEL, "String size and component size don't match" );
			DP8A_RETURN( DPNERR_INVALIDPARAM );
		}
	}
	else if( dwDataType == DPNA_DATATYPE_DWORD )
	{
		if( dwComponentSize != sizeof( DWORD ) )
		{
			DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid size for DWORD component" );
			DP8A_RETURN( DPNERR_INVALIDPARAM );
		}
	}
	else if( dwDataType == DPNA_DATATYPE_GUID )
	{
		if( dwComponentSize != sizeof( GUID ) )
		{
			DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid size for GUID component" );
			DP8A_RETURN( DPNERR_INVALIDPARAM );
		}	
	}

	// 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPFX(DPFPREP,  DP8A_PARAMLEVEL, "pwszTag = 0x%p pComponentData = 0x%p dwComponentSize = %d dwDataType = %d",
	     pwszTag, pComponentData, dwComponentSize, dwDataType );

	hr = pdp8Address->SetElement( pwszTag, pComponentData, dwComponentSize, dwDataType );

	DP8A_RETURN( hr );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_Clear"
STDMETHODIMP DP8A_Clear( IDirectPlay8Address *pInterface )
{
	if( pInterface == NULL ||
	   !DP8A_VALID( pInterface ) )
	{
		DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Invalid object" );
		DP8A_RETURN( DPNERR_INVALIDOBJECT );
	}
	
	DP8ADDRESSOBJECT *pdp8Address = (PDP8ADDRESSOBJECT) GET_OBJECT_FROM_INTERFACE( pInterface );
	HRESULT hr;

	DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Enter" );	

	hr = pdp8Address->Clear(  );

	DP8A_RETURN( hr );
}

BOOL IsValidDP8AObject( LPVOID lpvObject )
{
	INTERFACE_LIST *pIntList = (INTERFACE_LIST *) lpvObject;
	
	if( !DNVALID_READPTR( lpvObject, sizeof( INTERFACE_LIST ) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid object pointer" );
		return FALSE;
	}

	if( pIntList->lpVtbl != &DP8A_BaseVtbl &&
	   pIntList->lpVtbl != &DP8A_IPVtbl &&
	   pIntList->lpVtbl != &DP8A_InternalVtbl &&
	   pIntList->lpVtbl != &DP8A_UnknownVtbl )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid object" );
		return FALSE;
	}

	if( pIntList->iid != IID_IDirectPlay8Address &&
	   pIntList->iid != IID_IDirectPlay8AddressIP &&
	   pIntList->iid != IID_IDirectPlay8AddressInternal &&
	   pIntList->iid != IID_IUnknown )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Unknown object" );
		return FALSE;
	}

	if( pIntList->lpObject == NULL ||
	   !DNVALID_READPTR( pIntList->lpObject, sizeof( OBJECT_DATA ) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid object" );
		return FALSE;
	}

	DP8ADDRESSOBJECT *pdp8Address = (PDP8ADDRESSOBJECT) GET_OBJECT_FROM_INTERFACE( lpvObject );

	if( pdp8Address == NULL ||
	   !DNVALID_READPTR( pdp8Address, sizeof( DP8ADDRESSOBJECT ) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid object" );
		return FALSE;
	}

	return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\dnaddress\addcore.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       addcore.h
 *  Content:    DIRECTPLAY8ADDRESS CORE HEADER FILE
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  02/04/2000	rmt		Created
 *  02/17/2000	rmt		Added new defines for 
 *  02/17/2000	rmt		Parameter validation work 
 *  02/21/2000	rmt		Updated to make core Unicode and remove ANSI calls 
 *  07/09/2000	rmt		Added signature bytes to start of address objects
 *  07/13/2000	rmt		Bug #39274 - INT 3 during voice run
 *  07/21/2000	rmt		Bug #39940 - Addressing library doesn't properly parse stopbits in URLs
 *   7/31/2000  RichGr  IA64: FPM_Release() overwrites first 8 bytes of chunk of memory on IA64.
 *                      Rearrange positions of members of affected structs so that's OK.  
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__ADDCORE_H
#define	__ADDCORE_H

class CStringCache;

// Length of a single byte of userdata 
#define DNURL_LENGTH_USERDATA_BYTE	1

// Header length (14 chars + null terminator)
#define DNURL_LENGTH_HEADER			15

// Includes escaped brackets
#define DNURL_LENGTH_GUID			42

// Just the number, in decimal
#define DNURL_LENGTH_DWORD			10

// The length of the seperator for user data
#define DNURL_LENGTH_USERDATA_SEPERATOR	1

// The right length for one byte of escaped data
#define DNURL_LENGTH_BINARY_BYTE	3


#define DP8A_ENTERLEVEL			2
#define DP8A_INFOLEVEL			7
#define DP8A_ERRORLEVEL			0
#define DP8A_WARNINGLEVEL		1
#define DP8A_PARAMLEVEL			3

extern const WCHAR *szBaseStrings[];
extern const DWORD dwBaseRequiredTypes[];
extern const DWORD c_dwNumBaseStrings;

#if defined(DEBUG) || defined(DBG)

extern BOOL IsValidDP8AObject( LPVOID lpvObject );

#define DP8A_VALID(a) 	IsValidDP8AObject( a )
#else
#define DP8A_VALID(a)  TRUE
#endif




#define DP8A_RETURN( x ) 	DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Function returning hr=0x%x", x ); \
							return x;

extern LPFPOOL fpmAddressClassFacs;
extern LPFPOOL fpmAddressObjects;
extern LPFPOOL fpmAddressElements;
extern LPFPOOL fpmAddressInterfaceLists;
extern LPFPOOL fpmAddressObjectDatas;

extern CStringCache *g_pcstrKeyCache;

#define DP8ADDRESS_ELEMENT_HEAP	0x00000001

#define DPASIGNATURE_ELEMENT		'LEAD'
#define DPASIGNATURE_ELEMENT_FREE	'LEA_'

#define DPASIGNATURE_ADDRESS		'BOAD'
#define DPASIGNATURE_ADDRESS_FREE	'BOA_'

// DP8ADDRESSELEMENT
//
// This structure contains all the information about a single element of the 
// address.  These address elements are allocated from a central, fixed
//
//  7/31/2000(RichGr) - IA64: FPM_Release() overwrites first 8 bytes.  Rearrange position of dwSignature so that's OK.  
typedef struct _DP8ADDRESSELEMENT
{
	DWORD dwTagSize;			// Size of the tag
	DWORD dwType;				// Element type DNADDRESS8_DATATYPE_XXXXXX
	DWORD dwDataSize;			// Size of the data
	DWORD dwStringSize;
	DWORD dwSignature;          // Element debug signature
	WCHAR *pszTag;	            // Tag for the element.  
	DWORD dwFlags;				// Flags DNADDRESSELEMENT_XXXX
	union {
		GUID guidData;
		DWORD dwData;
		WCHAR szData[sizeof(GUID)];
		PVOID pvData;
	} uData;					// Union 
	CBilink blAddressElements;	// Bilink of address elements
} DP8ADDRESSELEMENT, *PDP8ADDRESSELEMENT;

// DP8ADDRESSELEMENT
// 
// Data structure representing the address itself
class DP8ADDRESSOBJECT
{
public:

	HRESULT Cleanup();
	HRESULT Clear();
	HRESULT Init();
	HRESULT SetElement( const WCHAR * const pszTag, const void * const pvData, const DWORD dwDataSize, const DWORD dwDataType );
	HRESULT GetElement( DWORD dwIndex, WCHAR * pszTag, PDWORD pdwTagSize, void * pvDataBuffer, PDWORD pdwDataSize, PDWORD pdwDataType );
	HRESULT GetElement( const WCHAR * const pszTag, void * pvDataBuffer, PDWORD pdwDataSize, PDWORD pdwDataType );
	HRESULT GetSP( GUID * pGuid );
	HRESULT SetSP( LPCGUID const pGuid );
	HRESULT GetDevice( GUID * pGuid );
	HRESULT SetDevice( LPCGUID const pGuid );
	HRESULT SetUserData( const void * const pvData, const DWORD dwDataSize );
	HRESULT GetUserData( void * pvDataBuffer, PDWORD pdwDataSize );

	HRESULT BuildURL( WCHAR * szURL, PDWORD pdwRequiredSize )	;
	HRESULT SetURL( WCHAR * szURL );

	HRESULT GetElementType( const WCHAR * pszTag, PDWORD pdwType );

	HRESULT Lock();
	HRESULT UnLock();

    HRESULT SetDirectPlay4Address( void * pvDataBuffer, const DWORD dwDataSize );

	inline GetNumComponents() { return m_dwElements; };

	inline void ENTERLOCK() { DNEnterCriticalSection( &m_csAddressLock ); };
	inline void LEAVELOCK() { DNLeaveCriticalSection( &m_csAddressLock ); };

	static void FPM_Element_BlockInit( void *pvItem );
	static void FPM_Element_BlockRelease( void *pvItem );

	static BOOL FPM_BlockCreate( void *pvItem );
	static void FPM_BlockInit( void *pvItem );
	static void FPM_BlockRelease( void *pvItem );
	static void FPM_BlockDestroy( void *pvItem );
		
protected:

	inline BOOL IsLocked() { return (m_iLockCount>0); };

	HRESULT BuildURL_AddElements( WCHAR *szElements );
	HRESULT BuildURL_AddHeader( WCHAR *szWorking );
	HRESULT BuildURL_AddUserData( WCHAR *szWorking );
	void BuildURL_AddString( WCHAR *szElements, WCHAR *szSource );
	HRESULT BuildURL_AddBinaryData( WCHAR *szSource, BYTE *bData, DWORD dwDataLen );

	HRESULT InternalGetElement( const WCHAR * const pszTag, PDP8ADDRESSELEMENT *ppaElement );
	HRESULT InternalGetElement( const DWORD dwIndex, PDP8ADDRESSELEMENT *ppaElement );
	HRESULT CalcComponentStringSize( PDP8ADDRESSELEMENT paddElement, PDWORD pdwSize );
	DWORD CalcExpandedStringSize( WCHAR *szString );
	DWORD CalcExpandedBinarySize( PBYTE pbData, DWORD dwDataSize );
	BOOL IsEscapeChar( WCHAR ch );
	BOOL IsValid();

	DWORD m_dwSignature;
	DNCRITICAL_SECTION m_csAddressLock;
	DWORD m_dwStringSize;
	DWORD m_dwElements;
	PDP8ADDRESSELEMENT m_pSP;
	PDP8ADDRESSELEMENT m_pAdapter;
	PVOID m_pvUserData;
	DWORD m_dwUserDataSize;
	DWORD m_dwUserDataStringSize;
	int m_iLockCount;
	BOOL m_fValid;
	CBilink  m_blAddressElements;

};

typedef DP8ADDRESSOBJECT *PDP8ADDRESSOBJECT;

HRESULT DP8A_STRCACHE_Init();
void DP8A_STRCACHE_Free();
 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\dnaddress\addbase.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       addbase.h
 *  Content:    DirectPlay8Address Base interface header file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 * 02/04/2000	rmt		Created
 * 02/21/2000	rmt		Updated to make core Unicode and remove ANSI calls
 * 03/21/2000   rmt     Renamed all DirectPlayAddress8's to DirectPlay8Addresses 
 * 03/24/2000	rmt		Added IsEqual function
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__ADDBASE_H__
#define	__ADDBASE_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//
// VTable for client interface
//
extern IDirectPlay8AddressVtbl DP8A_BaseVtbl;

//**********************************************************************
// Function prototypes
//**********************************************************************

//
// 
//
STDMETHODIMP DP8A_BuildFromURLW( IDirectPlay8Address *pInterface, WCHAR * pwszAddress );
STDMETHODIMP DP8A_BuildFromURLA( IDirectPlay8Address *pInterface, CHAR * pszAddress );
STDMETHODIMP DP8A_Duplicate( IDirectPlay8Address *pInterface, PDIRECTPLAY8ADDRESS *ppInterface );
STDMETHODIMP DP8A_Clear( IDirectPlay8Address *pInterface );
STDMETHODIMP DP8A_GetURLW( IDirectPlay8Address *pInterface, WCHAR * pwszAddress, PDWORD pdwAddressSize );
STDMETHODIMP DP8A_GetURLA( IDirectPlay8Address *pInterface, CHAR * pszAddress, PDWORD pdwAddressSize );
STDMETHODIMP DP8A_GetSP( IDirectPlay8Address *pInterface, GUID * pguidSP );
STDMETHODIMP DP8A_GetDevice( IDirectPlay8Address *pInterface, GUID * pguidSP );
STDMETHODIMP DP8A_GetUserData( IDirectPlay8Address *pInterface, void * pvUserData, PDWORD pdwBufferSize );
STDMETHODIMP DP8A_SetDevice( IDirectPlay8Address *pInterface, const GUID * const pguidSP );
STDMETHODIMP DP8A_SetSP( IDirectPlay8Address *pInterface, const GUID * const pguidSP );
STDMETHODIMP DP8A_SetUserData( IDirectPlay8Address *pInterface, const void * const pBuffer, const DWORD dwBufferSize );
STDMETHODIMP DP8A_GetNumComponents( IDirectPlay8Address *pInterface, PDWORD pdwNumComponents );
STDMETHODIMP DP8A_GetComponentByIndexW( IDirectPlay8Address *pInterface, const DWORD dwComponentID, WCHAR * pwszTag, PDWORD pdwNameLen, void * pComponentBuffer, PDWORD pdwComponentSize, PDWORD pdwDataType );
STDMETHODIMP DP8A_GetComponentByNameW( IDirectPlay8Address *pInterface, const WCHAR * const pwszTag, void * pComponentBuffer, PDWORD pdwComponentSize, PDWORD pdwDataType );
STDMETHODIMP DP8A_AddComponentW( IDirectPlay8Address *pInterface, const WCHAR * const pwszTag, const void * const pComponentData, const DWORD dwComponentSize, const DWORD dwDataType );
STDMETHODIMP DP8A_BuildFromDirectPlay4Address( IDirectPlay8Address *pInterface, void * pvDataBuffer, DWORD dwDataSize );
STDMETHODIMP DP8A_SetEqual( IDirectPlay8Address *pInterface, PDIRECTPLAY8ADDRESS pdp8Address );
STDMETHODIMP DP8A_IsEqual( IDirectPlay8Address *pInterface, PDIRECTPLAY8ADDRESS pdp8Address );

#endif	// __CLIENT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\workerjob.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       WorkerJob.h
 *  Content:    Worker Job Object Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  08/06/00	mjn		Created
 *	08/08/00	mjn		Added m_pAddress,m_pAsyncOp,WORKER_JOB_PERFORM_LISTEN
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__WORKER_JOB_H__
#define	__WORKER_JOB_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

#ifndef	OFFSETOF
#define OFFSETOF(s,m)				( ( INT_PTR ) ( ( PVOID ) &( ( (s*) 0 )->m ) ) )
#endif

#ifndef	CONTAINING_OBJECT
#define	CONTAINING_OBJECT(b,t,m)	(reinterpret_cast<t*>(&reinterpret_cast<BYTE*>(b)[-OFFSETOF(t,m)]))
#endif

//**********************************************************************
// Structure definitions
//**********************************************************************

class CWorkerJob;
template< class CWorkerJob > class CLockedContextClassFixedPool;

class CAsyncOp;
class CConnection;
class CRefCountBuffer;

typedef struct IDirectPlay8Address	IDirectPlay8Address;

typedef struct _DIRECTNETOBJECT DIRECTNETOBJECT;

typedef enum
{
//	WORKER_JOB_ABORT_CONNECT,
	WORKER_JOB_INSTALL_NAMETABLE,
	WORKER_JOB_INTERNAL_SEND,
	WORKER_JOB_PERFORM_LISTEN,
	WORKER_JOB_REMOVE_SERVICE_PROVIDER,
	WORKER_JOB_SEND_NAMETABLE_OPERATION,
	WORKER_JOB_SEND_NAMETABLE_OPERATION_CLIENT,
	WORKER_JOB_SEND_NAMETABLE_VERSION,
	WORKER_JOB_TERMINATE,
	WORKER_JOB_TERMINATE_SESSION,
	WORKER_JOB_UNKNOWN
} WORKER_JOB_TYPE;

typedef struct
{
	DWORD				dwFlags;
} WORKER_JOB_INTERNAL_SEND_DATA;

typedef struct
{
	HANDLE		hProtocolSPHandle;
} WORKER_JOB_REMOVE_SERVICE_PROVIDER_DATA;

typedef struct
{
	DWORD			dwMsgId;
	DWORD			dwVersion;
	DPNID			dpnidExclude;
} WORKER_JOB_SEND_NAMETABLE_OPERATION_DATA;

typedef struct
{
	HRESULT		hrReason;
} WORKER_JOB_TERMINATE_SESSION_DATA;

typedef union
{
	WORKER_JOB_INTERNAL_SEND_DATA				InternalSend;
	WORKER_JOB_REMOVE_SERVICE_PROVIDER_DATA		RemoveServiceProvider;
	WORKER_JOB_SEND_NAMETABLE_OPERATION_DATA	SendNameTableOperation;
	WORKER_JOB_TERMINATE_SESSION_DATA			TerminateSession;
} WORKER_JOB_DATA;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************

// class for Worker Thread Jobs

class CWorkerJob
{
public:
	CWorkerJob()				// Constructor
		{
			m_Sig[0] = 'W';
			m_Sig[1] = 'J';
			m_Sig[2] = 'O';
			m_Sig[3] = 'B';
		};

	~CWorkerJob() { };			// Destructor

	BOOL FPMAlloc(void *const pvContext)
		{
			m_pdnObject = static_cast<DIRECTNETOBJECT*>(pvContext);

			return(TRUE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CWorkerJob::FPMInitialize"
	BOOL FPMInitialize(void *const pvContext)
		{
			DNASSERT(m_pdnObject == pvContext);

			m_JobType = WORKER_JOB_UNKNOWN;
			m_pAsyncOp = NULL;
			m_pConnection = NULL;
			m_pRefCountBuffer = NULL;
			m_pAddress = NULL;
			m_bilinkWorkerJobs.Initialize();

			return(TRUE);
		};

	void FPMRelease(void *const pvContext) { };

	void FPMDealloc(void *const pvContext) { };

	#undef DPF_MODNAME
	#define DPF_MODNAME "CWorkerJob::ReturnSelfToPool"
	void ReturnSelfToPool( void )
		{
			if (m_pAsyncOp)
			{
				m_pAsyncOp->Release();
				m_pAsyncOp = NULL;
			}
			if (m_pConnection)
			{
				m_pConnection->Release();
				m_pConnection = NULL;
			}
			if (m_pRefCountBuffer)
			{
				m_pRefCountBuffer->Release();
				m_pRefCountBuffer = NULL;
			}
			if (m_pAddress)
			{
				m_pAddress->lpVtbl->Release( m_pAddress );
				m_pAddress = NULL;
			}

			DNASSERT(m_pConnection == NULL);
			DNASSERT(m_pRefCountBuffer == NULL);

			m_pdnObject->m_pFPOOLWorkerJob->Release( this );
		};

	void SetJobType( const WORKER_JOB_TYPE JobType )
		{
			m_JobType = JobType;
		};

	WORKER_JOB_TYPE GetJobType( void )
		{
			return( m_JobType );
		};

	void SetConnection( CConnection *const pConnection )
		{
			if (pConnection)
			{
				pConnection->AddRef();
			}
			m_pConnection = pConnection;
		};

	CConnection *GetConnection( void )
		{
			return( m_pConnection );
		};

	void SetRefCountBuffer( CRefCountBuffer *const pRefCountBuffer )
		{
			if (pRefCountBuffer)
			{
				pRefCountBuffer->AddRef();
			}
			m_pRefCountBuffer = pRefCountBuffer;
		};

	CRefCountBuffer *GetRefCountBuffer( void )
		{
			return( m_pRefCountBuffer );
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CWorkerJob::SetInternalSendFlags"
	void SetInternalSendFlags( const DWORD dwFlags )
		{
			DNASSERT( m_JobType == WORKER_JOB_INTERNAL_SEND );

			m_JobData.InternalSend.dwFlags = dwFlags;
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CWorkerJob::GetInternalSendFlags"
	DWORD GetInternalSendFlags( void )
		{
			DNASSERT( m_JobType == WORKER_JOB_INTERNAL_SEND );

			return( m_JobData.InternalSend.dwFlags );
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CWorkerJob::SetRemoveServiceProviderHandle"
	void SetRemoveServiceProviderHandle( const HANDLE hProtocolSPHandle )
		{
			DNASSERT( m_JobType == WORKER_JOB_REMOVE_SERVICE_PROVIDER );

			m_JobData.RemoveServiceProvider.hProtocolSPHandle = hProtocolSPHandle;
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CWorkerJob::GetRemoveServiceProviderHandle"
	HANDLE GetRemoveServiceProviderHandle( void )
		{
			DNASSERT( m_JobType == WORKER_JOB_REMOVE_SERVICE_PROVIDER );

			return( m_JobData.RemoveServiceProvider.hProtocolSPHandle );
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CWorkerJob::SetSendNameTableOperationMsgId"
	void SetSendNameTableOperationMsgId( const DWORD dwMsgId )
		{
			DNASSERT( m_JobType == WORKER_JOB_SEND_NAMETABLE_OPERATION ||
					  m_JobType == WORKER_JOB_SEND_NAMETABLE_OPERATION_CLIENT);

			m_JobData.SendNameTableOperation.dwMsgId = dwMsgId;
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CWorkerJob::GetSendNameTableOperationMsgId"
	DWORD GetSendNameTableOperationMsgId( void )
		{
			DNASSERT( m_JobType == WORKER_JOB_SEND_NAMETABLE_OPERATION ||
					  m_JobType == WORKER_JOB_SEND_NAMETABLE_OPERATION_CLIENT);

			return( m_JobData.SendNameTableOperation.dwMsgId );
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CWorkerJob::SetSendNameTableOperationVersion"
	void SetSendNameTableOperationVersion( const DWORD dwVersion )
		{
			DNASSERT( m_JobType == WORKER_JOB_SEND_NAMETABLE_OPERATION ||
					  m_JobType == WORKER_JOB_SEND_NAMETABLE_OPERATION_CLIENT);

			m_JobData.SendNameTableOperation.dwVersion = dwVersion;
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CWorkerJob::GetSendNameTableOperationVersion"
	DWORD GetSendNameTableOperationVersion( void )
		{
			DNASSERT( m_JobType == WORKER_JOB_SEND_NAMETABLE_OPERATION ||
					  m_JobType == WORKER_JOB_SEND_NAMETABLE_OPERATION_CLIENT);

			return( m_JobData.SendNameTableOperation.dwVersion );
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CWorkerJob::SetSendNameTableOperationDPNIDExclude"
	void SetSendNameTableOperationDPNIDExclude( const DPNID dpnidExclude )
		{
			DNASSERT( m_JobType == WORKER_JOB_SEND_NAMETABLE_OPERATION ||
					  m_JobType == WORKER_JOB_SEND_NAMETABLE_OPERATION_CLIENT);

			m_JobData.SendNameTableOperation.dpnidExclude = dpnidExclude;
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CWorkerJob::GetSendNameTableOperationDPNIDExclude"
	DPNID GetSendNameTableOperationDPNIDExclude( void )
		{
			DNASSERT( m_JobType == WORKER_JOB_SEND_NAMETABLE_OPERATION ||
					  m_JobType == WORKER_JOB_SEND_NAMETABLE_OPERATION_CLIENT);

			return( m_JobData.SendNameTableOperation.dpnidExclude );
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CWorkerJob::SetTerminateSessionReason"
	void SetTerminateSessionReason( const HRESULT hrReason )
		{
			DNASSERT( m_JobType == WORKER_JOB_TERMINATE_SESSION );

			m_JobData.TerminateSession.hrReason = hrReason;
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CWorkerJob::GetTerminateSessionReason"
	HRESULT GetTerminateSessionReason( void )
		{
			DNASSERT( m_JobType == WORKER_JOB_TERMINATE_SESSION );

			return( m_JobData.TerminateSession.hrReason );
		};

	void SetAsyncOp( CAsyncOp *const pAsyncOp )
		{
			if (pAsyncOp)
			{
				pAsyncOp->AddRef();
			}
			m_pAsyncOp = pAsyncOp;
		};

	CAsyncOp *GetAsyncOp( void )
		{
			return( m_pAsyncOp );
		};

	void SetAddress( IDirectPlay8Address *const pAddress )
		{
			if (pAddress)
			{
				pAddress->lpVtbl->AddRef( pAddress );
			}
			m_pAddress = pAddress;
		};

	IDirectPlay8Address *GetAddress( void )
		{
			return( m_pAddress );
		};

	CBilink				m_bilinkWorkerJobs;

private:
	BYTE				m_Sig[4];			// Signature

	WORKER_JOB_TYPE		m_JobType;

	CAsyncOp			*m_pAsyncOp;
	CConnection			*m_pConnection;
	CRefCountBuffer		*m_pRefCountBuffer;
	IDirectPlay8Address	*m_pAddress;

	WORKER_JOB_DATA		m_JobData;

	DIRECTNETOBJECT		*m_pdnObject;
};

#undef DPF_MODNAME

#endif	// __WORKER_JOB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\dnaddress\adddllmain.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DllMain.cpp
 *  Content:    Defines the entry point for the DLL application.
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   07/21/99	mjn		Created
 *	07/13/2000	rmt		Added critical sections to protect FPMs
 *  07/21/2000  RichGr  IA64: Use %p format specifier for 32/64-bit pointers.
 *  01/04/2001	rodtoll	WinBug #94200 - Remove stray comments
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dnaddri.h"


// Globals
extern	DWORD	GdwHLocks;
extern	DWORD	GdwHObjects;

#undef DPF_MODNAME
#define DPF_MODNAME "DllRegisterServer"
HRESULT WINAPI DllRegisterServer()
{
	HRESULT hr = S_OK;
	BOOL fFailed = FALSE;

	if( !CRegistry::Register( L"DirectPlay8Address.Address.1", L"DirectPlay8Address Object", 
							  L"dpnaddr.dll", CLSID_DirectPlay8Address, L"DirectPlay8Address.Address") )
	{
		DPFERR( "Could not register address object" );
		fFailed = TRUE;
	}
	
	if( fFailed )
	{
		return E_FAIL;
	}
	else
	{
		return S_OK;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "DllUnregisterServer"
STDAPI DllUnregisterServer()
{
	HRESULT hr = S_OK;
	BOOL fFailed = FALSE;

	if( !CRegistry::UnRegister(CLSID_DirectPlay8Address) )
	{
		DPFX(DPFPREP,  0, "Failed to unregister server object" );
		fFailed = TRUE;
	}

	if( fFailed )
	{
		return E_FAIL;
	}
	else
	{
		return S_OK;
	}

}

#undef DPF_MODNAME
#define DPF_MODNAME "DllMain"

BOOL APIENTRY DllMain( HANDLE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
					 )
{
	_try
	{
		DPFX(DPFPREP, 3,"Parameters: hModule [%p], ul_reason_for_call [%lx], lpReserved [%p]",
			hModule,ul_reason_for_call,lpReserved);

		if (ul_reason_for_call == DLL_PROCESS_ATTACH)
		{
			WORD wVersionRequested = MAKEWORD(1,1);
			WSADATA wsaData;
			int nResult;

			nResult = WSAStartup( wVersionRequested, &wsaData );

			if( nResult )
			{
				DPFX(DPFPREP,  0, "Unable to load winsock.  Error" );
				return FALSE;
			}
			
			if (DNOSIndirectionInit() == FALSE)
			{
				DPFX(DPFPREP, 0,"Failed to initialize OS indirection layer");
				WSACleanup();
				return FALSE;
			}
			if (FAILED(COM_Init()))
			{
				DPFX(DPFPREP, 0,"Failed to initialize COM indirection layer");
				DNOSIndirectionDeinit();
				WSACleanup();
				return FALSE;
			}

			fpmAddressClassFacs = FPM_Create( sizeof( _IDirectPlay8AddressClassFact ), 
											 NULL, 
											 NULL, 
											 NULL, 
											 NULL );
			if (fpmAddressClassFacs == NULL)
			{
				DPFX(DPFPREP, 0,"Failed to allocate address class factory pool");
				COM_Free();
				DNOSIndirectionDeinit();
				WSACleanup();
				return FALSE;
			}
			fpmAddressObjects = FPM_Create( sizeof( DP8ADDRESSOBJECT ), 
											DP8ADDRESSOBJECT::FPM_BlockCreate, 
											DP8ADDRESSOBJECT::FPM_BlockInit, 
											DP8ADDRESSOBJECT::FPM_BlockRelease,
											DP8ADDRESSOBJECT::FPM_BlockDestroy );
			if (fpmAddressObjects == NULL)
			{
				DPFX(DPFPREP, 0,"Failed to allocate address object pool");
				fpmAddressClassFacs->Fini(fpmAddressClassFacs);
				fpmAddressClassFacs = NULL;
				COM_Free();
				DNOSIndirectionDeinit();
				WSACleanup();
				return FALSE;
			}
			fpmAddressElements = FPM_Create( sizeof( DP8ADDRESSELEMENT ), NULL, 
											 DP8ADDRESSOBJECT::FPM_Element_BlockInit, 
											 DP8ADDRESSOBJECT::FPM_Element_BlockRelease, NULL );
			if (fpmAddressElements == NULL)
			{
				DPFX(DPFPREP, 0,"Failed to allocate address element pool");
				fpmAddressObjects->Fini(fpmAddressObjects);
				fpmAddressObjects = NULL;
				fpmAddressClassFacs->Fini(fpmAddressClassFacs);
				fpmAddressClassFacs = NULL;
				COM_Free();
				DNOSIndirectionDeinit();
				WSACleanup();
				return FALSE;
			}
			fpmAddressInterfaceLists = FPM_Create( sizeof( INTERFACE_LIST ), 
											 NULL, 
											 NULL, 
											 NULL, 
											 NULL );
			if (fpmAddressInterfaceLists == NULL)
			{
				DPFX(DPFPREP, 0,"Failed to allocate address interface list pool");
				fpmAddressElements->Fini(fpmAddressElements);
				fpmAddressElements = NULL;
				fpmAddressObjects->Fini(fpmAddressObjects);
				fpmAddressObjects = NULL;
				fpmAddressClassFacs->Fini(fpmAddressClassFacs);
				fpmAddressClassFacs = NULL;
				COM_Free();
				DNOSIndirectionDeinit();
				WSACleanup();
				return FALSE;
			}
			fpmAddressObjectDatas = FPM_Create( sizeof( OBJECT_DATA ), 
											 NULL, 
											 NULL, 
											 NULL, 
											 NULL );
			if (fpmAddressObjectDatas == NULL)
			{
				DPFX(DPFPREP, 0,"Failed to allocate address object data pool");
				fpmAddressInterfaceLists->Fini(fpmAddressInterfaceLists);
				fpmAddressInterfaceLists = NULL;
				fpmAddressElements->Fini(fpmAddressElements);
				fpmAddressElements = NULL;
				fpmAddressObjects->Fini(fpmAddressObjects);
				fpmAddressObjects = NULL;
				fpmAddressClassFacs->Fini(fpmAddressClassFacs);
				fpmAddressClassFacs = NULL;
				COM_Free();
				DNOSIndirectionDeinit();
				WSACleanup();
				return FALSE;
			}
			DP8A_STRCACHE_Init();

		}
		else if( ul_reason_for_call == DLL_PROCESS_DETACH )
		{
			fpmAddressClassFacs->Fini(fpmAddressClassFacs);
			fpmAddressClassFacs = NULL;
			fpmAddressObjects->Fini(fpmAddressObjects);
			fpmAddressObjects = NULL;
			fpmAddressElements->Fini(fpmAddressElements);
			fpmAddressElements = NULL;
			fpmAddressInterfaceLists->Fini(fpmAddressInterfaceLists);
			fpmAddressInterfaceLists = NULL;
			fpmAddressObjectDatas->Fini(fpmAddressObjectDatas);
			fpmAddressObjectDatas = NULL;

			DP8A_STRCACHE_Free();
			COM_Free();

			DNOSIndirectionDeinit();
			WSACleanup();
		}

		return TRUE;
	}
	_except( EXCEPTION_EXECUTE_HANDLER )
	{
		DPFERR("THERE WAS AN ERROR IN DllMain()");
		return FALSE;
	}
}



#undef DPF_MODNAME
#define DPF_MODNAME "DllGetClassObject"

STDAPI DllGetClassObject(REFCLSID rclsid,REFIID riid,LPVOID *ppv)
{
	_LPIDirectPlay8AddressClassFact	lpcfObj;
	HRESULT				hResultCode = S_OK;

	DPFX(DPFPREP, 3,"Parameters: rclsid [%p], riid [%p], ppv [%p]",rclsid,riid,ppv);

	// Allocate Class Factory object
	lpcfObj = (_LPIDirectPlay8AddressClassFact)fpmAddressClassFacs->Get(fpmAddressClassFacs);
	if (lpcfObj == NULL)
	{
		DPFERR("FPM_Get() failed");
		*ppv = NULL;
		return(E_OUTOFMEMORY);
	}
	DPFX(DPFPREP, 5,"lpcfObj = [%p]",lpcfObj);
	lpcfObj->lpVtbl = &DP8ACF_Vtbl;
	lpcfObj->lRefCount = 0;

	// Query to find the interface
	if ((hResultCode = lpcfObj->lpVtbl->QueryInterface(reinterpret_cast<IDirectPlay8AddressClassFact*>( lpcfObj ),riid,ppv)) != S_OK)
	{
		fpmAddressClassFacs->Release(fpmAddressClassFacs, lpcfObj);
	}

	// One more thing to release !
	GdwHObjects++;

	DPFX(DPFPREP, 3,"Return: hResultCode = [%lx], *ppv = [%p]",hResultCode,*ppv);
	return(hResultCode);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DllCanUnloadNow"

STDAPI DllCanUnloadNow(void)
{
	DPFX(DPFPREP, 3,"Parameters: (none)");

	DPFX(DPFPREP, 5,"GdwHLocks = %ld\tGdwHObjects = %ld",GdwHLocks,GdwHObjects);
	if (GdwHLocks == 0 && GdwHObjects == 0)
		return(S_OK);
	else
		return(S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\dnaddress\addparse.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ClassFac.cpp
 *  Content:   Parsing engine
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date         By      Reason
 *   ====       ==      ======
 *  02/04/2000	 rmt	  Created
 *  02/21/2000	 rmt	Updated to make core Unicode and remove ANSI calls 
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#ifndef __ADDPARSE_H
#define __ADDPARSE_H

#include "Addcore.h"

class DP8ADDRESSPARSE
{
protected:

	typedef enum { 
		DP8AP_IDLE,
		DP8AP_KEY,
		DP8AP_VALUE,
		DP8AP_USERDATA
	} DP8AP_STATE;
	
public:

	DP8ADDRESSPARSE();
	~DP8ADDRESSPARSE();

	HRESULT ParseURL( DP8ADDRESSOBJECT *pdp8aObject, WCHAR *pstrURL );

protected:

	BOOL IsValidHex( WCHAR ch );
	BOOL IsValidKeyChar(WCHAR ch);
	BOOL IsValidKeyTerminator(WCHAR ch);
	BOOL IsValidValueChar(WCHAR ch);
	BOOL IsValidValueTerminator(WCHAR ch);
	BOOL IsValidNumber(WCHAR ch );

	WCHAR HexToChar( WCHAR *sz );

	HRESULT FSM_Key();
	HRESULT FSM_Value();
	HRESULT FSM_UserData();
	HRESULT FSM_CommitEntry(DP8ADDRESSOBJECT *pdp8aObject);

	WCHAR *m_pwszCurrentLocation;	// Current Location in string

	WCHAR *m_pwszCurrentKey;		// Key will be placed here as we build
	WCHAR *m_pwszCurrentValue;		// Value will be placed here as we build
	BYTE *m_pbUserData;
	DWORD m_dwUserDataSize;
	DP8AP_STATE m_dp8State;		// Current State 
	BOOL m_fNonNumeric;
	DWORD m_dwLenURL;
	DWORD m_dwValueLen;
	
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\dnaddress\addtcp.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       addtcp.cpp
 *  Content:    DirectPlay8Address TCP interface file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *  ====       ==      ======
 * 02/04/2000	rmt		Created
 * 02/12/2000	rmt		Completed first implementation
 * 02/17/2000	rmt		Parameter validation work
 * 02/20/2000	rmt		Changed ports to USHORTs
 * 02/21/2000	 rmt	Updated to make core Unicode and remove ANSI calls
 * 02/23/2000	rmt		Further parameter validation
 * 03/21/2000   rmt     Renamed all DirectPlayAddress8's to DirectPlay8Addresses
 * 03/24/2000	rmt		Added IsEqual function
 *	05/04/00	mjn		Fixed leak in DP8ATCP_GetSockAddress()
 *  06/09/00    rmt     Updates to split CLSID and allow whistler compat and support external create funcs
 * 08/03/2000 	rmt		Bug #41246 - Remove IP versions of Duplicate, SetEqual, IsEqual, BuildURL
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dnaddri.h"


typedef	STDMETHODIMP TCPQueryInterface( IDirectPlay8AddressIP *pInterface, REFIID riid, LPVOID *ppvObj );
typedef	STDMETHODIMP_(ULONG)	TCPAddRef( IDirectPlay8AddressIP *pInterface );
typedef	STDMETHODIMP_(ULONG)	TCPRelease( IDirectPlay8AddressIP *pInterface );
//
// VTable for client interface
//
IDirectPlay8AddressIPVtbl DP8A_IPVtbl =
{
	(TCPQueryInterface*)		DP8A_QueryInterface,
	(TCPAddRef*)				DP8A_AddRef,
	(TCPRelease*)				DP8A_Release,
								DP8ATCP_BuildFromSockAddr,
								DP8ATCP_BuildAddressW,
								DP8ATCP_BuildLocalAddress,
								DP8ATCP_GetSockAddress,
								DP8ATCP_GetLocalAddress,
								DP8ATCP_GetAddressW,
};

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ATCP_BuildLocalAddress"
STDMETHODIMP DP8ATCP_BuildLocalAddress( IDirectPlay8AddressIP *pInterface, const GUID * const pguidAdapter, const USHORT usPort )
{
	if( pInterface == NULL ||
	   !DP8A_VALID( pInterface ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid object" );
		DP8A_RETURN( DPNERR_INVALIDOBJECT );
	}

	DP8ADDRESSOBJECT *pdp8Address = (DP8ADDRESSOBJECT *) GET_OBJECT_FROM_INTERFACE( pInterface );
	
	HRESULT hr;

	DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Enter" );		
	// 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPFX(DPFPREP,  DP8A_PARAMLEVEL, "pguidAdapter: 0x%p usPort: %u", pguidAdapter, (DWORD)usPort );	

	if( pguidAdapter == NULL ||
	   !DNVALID_READPTR( pguidAdapter, sizeof( GUID ) ) )
	{
		DPFX(DPFPREP,  0, "Invalid pointer" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );	
	}

	hr = pdp8Address->Clear();

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Failed to clear current address hr=0x%x", hr );
		DP8A_RETURN( hr );	
	}

	hr = pdp8Address->SetSP( &CLSID_DP8SP_TCPIP );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Error setting service provider hr=0x%x", hr );
		DP8A_RETURN( hr );	
	}

	hr = pdp8Address->SetDevice( pguidAdapter );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Error setting device hr=0x%x", hr );
		DP8A_RETURN( hr );	
	}

	DWORD dwTmpPort = usPort;

	hr = pdp8Address->SetElement( DPNA_KEY_PORT, &dwTmpPort, sizeof( DWORD ), DPNA_DATATYPE_DWORD );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Adding SP element failed hr=0x%x", hr );
		DP8A_RETURN( hr );	
	}
	
	DP8A_RETURN( hr );	
}


#undef DPF_MODNAME
#define DPF_MODNAME "DP8ATCP_BuildFromSockAddr"
STDMETHODIMP DP8ATCP_BuildFromSockAddr( IDirectPlay8AddressIP *pInterface, const SOCKADDR * const pSockAddr )
{
	if( pInterface == NULL ||
	   !DP8A_VALID( pInterface ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid object" );
		DP8A_RETURN( DPNERR_INVALIDOBJECT );
	}
	
	DP8ADDRESSOBJECT *pdp8Address = (DP8ADDRESSOBJECT *) GET_OBJECT_FROM_INTERFACE( pInterface );
	
	HRESULT hr;
	DWORD dwTmpPort;
	LPSTR szHostName = NULL;
	WCHAR wszHostName[32]; // Should be xxx.xxx.xxx.xxx + null
	DWORD dwTmpLength;
	sockaddr_in *saIPAddress;

	DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Enter" );
	// 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPFX(DPFPREP,  DP8A_PARAMLEVEL, "pSockAddr: 0x%p", pSockAddr );	

	if( pSockAddr == NULL ||
	   !DNVALID_READPTR( pSockAddr, sizeof( SOCKADDR ) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer to sockaddr" );
		hr = DPNERR_INVALIDPOINTER;
		goto BUILDFROMSOCKADDR_ERROR;
	}

	if( pSockAddr->sa_family != AF_INET )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Only TCP addresses are supported" );
		hr = DPNERR_INVALIDPARAM;
		goto BUILDFROMSOCKADDR_ERROR;
	}

	saIPAddress = (sockaddr_in * ) pSockAddr;

	hr = pdp8Address->Clear();

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Failed clearing object hr=0x%x", hr );
		goto BUILDFROMSOCKADDR_ERROR;
	}

	hr = pdp8Address->SetSP( &CLSID_DP8SP_TCPIP );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Error setting service provider hr=0x%x", hr );
		DP8A_RETURN( hr );	
	}

	// Sockaddr is in network byte order, convert to host order
	dwTmpPort = ntohs(saIPAddress->sin_port);

	szHostName = inet_ntoa( saIPAddress->sin_addr );

	if( szHostName == NULL )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Error converting from address to string" );
		hr = DPNERR_INVALIDPARAM;
		goto BUILDFROMSOCKADDR_ERROR;
	}

	dwTmpLength = strlen(szHostName)+1;

	DNASSERT(dwTmpLength <= 31);

	if( FAILED( hr = STR_jkAnsiToWide(wszHostName,szHostName,dwTmpLength) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Error converting hostname 0x%x", hr );
		hr = DPNERR_CONVERSION;
		goto BUILDFROMSOCKADDR_ERROR;
	}

	hr = pdp8Address->SetElement( DPNA_KEY_HOSTNAME, wszHostName, dwTmpLength*sizeof(WCHAR), DPNA_DATATYPE_STRING );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Failed to set hostname hr=0x%x", hr );
		DP8A_RETURN( hr );
	}	

	hr = pdp8Address->SetElement( DPNA_KEY_PORT, &dwTmpPort, sizeof(DWORD), DPNA_DATATYPE_DWORD );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Failed setting port hr=0x%x", hr );
		DP8A_RETURN( hr );
	}

	DP8A_RETURN( DPN_OK );

BUILDFROMSOCKADDR_ERROR:

	DP8A_RETURN( hr );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ATCP_BuildAddressW"
STDMETHODIMP DP8ATCP_BuildAddressW( IDirectPlay8AddressIP *pInterface, const WCHAR * const pwszAddress, const USHORT usPort )
{
	if( pInterface == NULL ||
	   !DP8A_VALID( pInterface ) )
	{
		DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Invalid object" );
		DP8A_RETURN( DPNERR_INVALIDOBJECT );
	}

	DP8ADDRESSOBJECT *pdp8Address = (DP8ADDRESSOBJECT *) GET_OBJECT_FROM_INTERFACE( pInterface );
	
	HRESULT hr;

	DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Enter" );

	if( pwszAddress == NULL )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer to address" );
		DP8A_RETURN( E_POINTER );		
	}

	if( !DNVALID_STRING_W( pwszAddress ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid string for address" );
		DP8A_RETURN( DPNERR_INVALIDSTRING );
	}

	// 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPFX(DPFPREP,  DP8A_PARAMLEVEL, "pwszAddress: 0x%p, usPort = %u", pwszAddress, (DWORD)usPort );

	hr = pdp8Address->Clear();

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Error clearing current address hr=0x%x", hr );
		DP8A_RETURN( hr );		
	}

	hr = pdp8Address->SetSP( &CLSID_DP8SP_TCPIP );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Error setting service provider hr=0x%x", hr );
		DP8A_RETURN( hr );	
	}

	hr = pdp8Address->SetElement( DPNA_KEY_HOSTNAME, pwszAddress, (wcslen(pwszAddress)+1)*sizeof(WCHAR), DPNA_DATATYPE_STRING );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Adding SP element failed hr=0x%x", hr );
		DP8A_RETURN( hr );	
	}	

	DWORD dwTmpPort = usPort;
	
	hr = pdp8Address->SetElement( DPNA_KEY_PORT, &dwTmpPort, sizeof( DWORD ), DPNA_DATATYPE_DWORD );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Adding SP element failed hr=0x%x", hr );
		DP8A_RETURN( hr );	
	}
	
	DP8A_RETURN( hr );	
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ATCP_GetSockAddress"
STDMETHODIMP DP8ATCP_GetSockAddress( IDirectPlay8AddressIP *pInterface, SOCKADDR *pSockAddr, PDWORD pdwBufferSize )
{
	if( pInterface == NULL ||
	   !DP8A_VALID( pInterface ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid object" );
		DP8A_RETURN( DPNERR_INVALIDOBJECT );
	}

	HRESULT hr;
	WCHAR *swzAddress = NULL;		// Unicode version of hostname
	CHAR *szAddress = NULL; 		// ANSI version of hostname
	DWORD dwAddressSize = 0;
	USHORT usPort;
	LPHOSTENT lpHostEntry;
	in_addr iaTmp;
	in_addr *piaTmp;
	DWORD dwIndex;
	DWORD dwRequiredSize;
	DWORD dwNumElements;
	sockaddr_in *psinCurAddress;
	SOCKADDR *pCurLoc;

	dwAddressSize = 0;

	if( pdwBufferSize == NULL ||
	   !DNVALID_WRITEPTR( pdwBufferSize, sizeof( DWORD ) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer for pdwBufferSize" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );
	}

	if( *pdwBufferSize > 0 &&
	   (pSockAddr == NULL || !DNVALID_WRITEPTR( pSockAddr, *pdwBufferSize ) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer for sockaddress" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );
	}

	DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Enter" );
	// 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPFX(DPFPREP,  DP8A_PARAMLEVEL, "pSockAddr = 0x%p, pdwBufferSize = 0x%p (%d)", pSockAddr, pdwBufferSize, *pdwBufferSize );	

	hr = DP8ATCP_GetAddressW( pInterface, swzAddress, &dwAddressSize, &usPort );

	if( hr != DPNERR_BUFFERTOOSMALL )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Unable to retrieve size required hr=0x%x", hr );
		goto GETSOCKADDRESS_ERROR;
	}

	swzAddress = new WCHAR[dwAddressSize];

	if( swzAddress == NULL )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Error allocating memory hr=0x%x", hr );
		hr = DPNERR_OUTOFMEMORY;
		goto GETSOCKADDRESS_ERROR;
	}

	hr = DP8ATCP_GetAddressW( pInterface, swzAddress, &dwAddressSize, &usPort );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Unable to retrieve address hr=0x%x", hr );
		goto GETSOCKADDRESS_ERROR;
	}	

	szAddress = new CHAR[dwAddressSize];

	if( szAddress == NULL )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Error allocating memory hr=0x%x", hr );
		hr = DPNERR_OUTOFMEMORY;
		goto GETSOCKADDRESS_ERROR;	
	}

	if( FAILED( hr = STR_jkWideToAnsi( szAddress, swzAddress, dwAddressSize ) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Error converting address to ANSI hr=0x%x", hr );
		hr = DPNERR_CONVERSION;
		goto GETSOCKADDRESS_ERROR;
	}

	iaTmp.s_addr = inet_addr( szAddress );

    if( iaTmp.s_addr != INADDR_NONE || strcmp( szAddress, "255.255.255.255" ) == 0 )
    {
        dwRequiredSize = sizeof( SOCKADDR );

	    if( *pdwBufferSize < dwRequiredSize )
	    {
		    *pdwBufferSize = dwRequiredSize;
		    DPFX(DPFPREP,  DP8A_WARNINGLEVEL, "Buffer too small" );
		    hr = DPNERR_BUFFERTOOSMALL;
		    goto GETSOCKADDRESS_ERROR;
	    }

        memset( pSockAddr, 0x00, sizeof( SOCKADDR ) );

        psinCurAddress = (sockaddr_in *) pSockAddr;

   		psinCurAddress->sin_family = AF_INET;
		psinCurAddress->sin_port = htons(usPort);
		psinCurAddress->sin_addr = iaTmp;

		hr = DPN_OK;

		goto GETSOCKADDRESS_ERROR;
    }

	lpHostEntry = gethostbyname( szAddress );	

	if( lpHostEntry == NULL )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid host specified hr=0x%x" , hr );
		hr = DPNERR_INVALIDHOSTADDRESS;
		goto GETSOCKADDRESS_ERROR;
	}

	// Count addresses
	for( dwNumElements = 0; ; dwNumElements++ )
	{
		piaTmp = ((LPIN_ADDR)lpHostEntry->h_addr_list[dwNumElements]);

		if( piaTmp == NULL )
			break;
	}

	dwRequiredSize = dwNumElements * sizeof( SOCKADDR );

	if( *pdwBufferSize < dwRequiredSize )
	{
		*pdwBufferSize = dwRequiredSize;
		DPFX(DPFPREP,  DP8A_WARNINGLEVEL, "Buffer too small" );
		hr = DPNERR_BUFFERTOOSMALL;
		goto GETSOCKADDRESS_ERROR;
	}

	*pdwBufferSize = dwRequiredSize;

	pCurLoc = pSockAddr;

	memset( pCurLoc, 0x00, *pdwBufferSize );

	// Build addresses and copy them to the buffer
	for( dwIndex = 0; dwIndex < dwNumElements; dwIndex++ )
	{
		psinCurAddress = (sockaddr_in *) pCurLoc;
		psinCurAddress->sin_family = AF_INET;
		psinCurAddress->sin_port = htons(usPort);
		psinCurAddress->sin_addr = *((LPIN_ADDR)lpHostEntry->h_addr_list[dwIndex]);
		
		pCurLoc++;
	}

	delete [] swzAddress;
	delete [] szAddress;

	DP8A_RETURN( DPN_OK );

GETSOCKADDRESS_ERROR:

	if( swzAddress != NULL )
		delete [] swzAddress;

	if( szAddress != NULL )
		delete [] szAddress;

	DP8A_RETURN( hr );
	
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ATCP_GetLocalAddress"
STDMETHODIMP DP8ATCP_GetLocalAddress( IDirectPlay8AddressIP *pInterface, GUID * pguidAdapter, PUSHORT pusPort )
{
	if( pInterface == NULL ||
	   !DP8A_VALID( pInterface ) )
	{
		DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Invalid object" );
		DP8A_RETURN( DPNERR_INVALIDOBJECT );
	}

	DP8ADDRESSOBJECT *pdp8Address = (DP8ADDRESSOBJECT *) GET_OBJECT_FROM_INTERFACE( pInterface );
	
	HRESULT hr;

	DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Enter" );

	GUID guidDevice;
	DWORD dwPort;
	DWORD dwType;
	DWORD dwSize;	
	GUID guidSP;

	// 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPFX(DPFPREP,  DP8A_PARAMLEVEL, "pguidAdapter = 0x%p pusPort = 0x%p",
	     pguidAdapter, pusPort );

	if( pguidAdapter == NULL ||
	   !DNVALID_WRITEPTR( pguidAdapter, sizeof( GUID ) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer for adapter" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );
	}

	if( pusPort == NULL ||
	   !DNVALID_WRITEPTR( pusPort, sizeof( USHORT ) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer for port" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );
	}	

	hr = pdp8Address->GetSP( &guidSP );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "No provider SP specified hr=0x%x", hr );
		hr = DPNERR_INCOMPLETEADDRESS;		
		DP8A_RETURN( hr );		
	}

	if( guidSP != CLSID_DP8SP_TCPIP )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Not an IP address" );
		hr = DPNERR_INVALIDADDRESSFORMAT;
		DP8A_RETURN( hr );
	}

	hr = pdp8Address->GetElementType( DPNA_KEY_DEVICE, &dwType );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "This device element doesn't exist hr=0x%x", hr );
		hr = DPNERR_INCOMPLETEADDRESS;		
		DP8A_RETURN( hr );
	}

	if( dwType != DPNA_DATATYPE_GUID )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid Address: The device is not a GUID hr=0x%x", hr );
		hr = DPNERR_GENERIC;		
		DP8A_RETURN( hr );
	}

	hr = pdp8Address->GetElementType( DPNA_KEY_DEVICE, &dwType );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "This address does not have a device element hr=0x%x", hr );
		hr = DPNERR_INCOMPLETEADDRESS;
		DP8A_RETURN( hr );
	}

	if( dwType != DPNA_DATATYPE_GUID )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid Address: The device is not a GUID hr=0x%x", hr );
		hr = DPNERR_GENERIC;		
		DP8A_RETURN( hr );
	}

	hr = pdp8Address->GetElementType( DPNA_KEY_PORT, &dwType );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "This address does not have a port element hr=0x%x", hr );
		hr = DPNERR_INCOMPLETEADDRESS;
		DP8A_RETURN( hr );
	}

	if( dwType != DPNA_DATATYPE_DWORD )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid Address: The port is not a dword hr=0x%x", hr );
		hr = DPNERR_GENERIC;		
		DP8A_RETURN( hr );
	}

	dwSize = sizeof(DWORD);

	hr = pdp8Address->GetElement( DPNA_KEY_PORT, &dwPort, &dwSize, &dwType );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Unable to retrieve port element hr=0x%x", hr );
		hr = DPNERR_GENERIC;
		DP8A_RETURN( hr );
	}

	dwSize = sizeof(GUID);

	hr = pdp8Address->GetElement( DPNA_KEY_DEVICE, &guidDevice, &dwSize, &dwType );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Unable to retrieve device element hr=0x%x", hr );
		hr = DPNERR_GENERIC;		
		DP8A_RETURN( hr );
	}	

	*pguidAdapter = guidDevice;
	*pusPort = (USHORT) dwPort;

	DP8A_RETURN( DPN_OK );	
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ATCP_GetAddressW"
STDMETHODIMP DP8ATCP_GetAddressW( IDirectPlay8AddressIP *pInterface, WCHAR * pwszAddress, PDWORD pdwAddressLength, PUSHORT pusPort )
{
	if( pInterface == NULL ||
	   !DP8A_VALID( pInterface ) )
	{
		DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Invalid object" );
		DP8A_RETURN( DPNERR_INVALIDOBJECT );
	}

	DP8ADDRESSOBJECT *pdp8Address = (DP8ADDRESSOBJECT *) GET_OBJECT_FROM_INTERFACE( pInterface );
	
	HRESULT hr;
	DWORD dwPort;
	DWORD dwType;
	DWORD dwSize;
	GUID guidSP;

	DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Enter" );

	if( pdwAddressLength == NULL ||
	   !DNVALID_WRITEPTR( pdwAddressLength, sizeof( DWORD ) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer for pdwAddressLength" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );
	}

	if( *pdwAddressLength > 0 &&
	   (pwszAddress == NULL || !DNVALID_WRITEPTR( pwszAddress, (*pdwAddressLength)*sizeof(WCHAR) ) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer for pwszAddress" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );	
	}

	if( pusPort == NULL ||
	   !DNVALID_WRITEPTR( pusPort, sizeof( USHORT ) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer for port" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );
	}	

	// 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPFX(DPFPREP,  DP8A_PARAMLEVEL, "pwszAddress = 0x%p pdwAddressLength = 0x%p (%u) pusPort = 0x%p (%u)",
	     pwszAddress, pdwAddressLength, *pdwAddressLength, pusPort, (DWORD)*pusPort );

	hr = pdp8Address->GetSP( &guidSP );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "No provider SP specified hr=0x%x", hr );
		hr = DPNERR_INCOMPLETEADDRESS;
		DP8A_RETURN( hr );		
	}

	if( guidSP != CLSID_DP8SP_TCPIP )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Not an IP address" );
		hr = DPNERR_INVALIDADDRESSFORMAT;
		DP8A_RETURN( hr );
	}	

	hr = pdp8Address->GetElementType( DPNA_KEY_HOSTNAME, &dwType );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "This address does not have a hostname element hr=0x%x", hr );
		hr = DPNERR_INCOMPLETEADDRESS;				
		DP8A_RETURN( hr );
	}

	if( dwType != DPNA_DATATYPE_STRING )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid Address: The host name is not a string hr=0x%x", hr );
		hr = DPNERR_GENERIC;
		DP8A_RETURN( hr );
	}

	hr = pdp8Address->GetElementType( DPNA_KEY_PORT, &dwType );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "This address does not have a port element hr=0x%x", hr );
		hr = DPNERR_INCOMPLETEADDRESS;
		DP8A_RETURN( hr );
	}

	if( dwType != DPNA_DATATYPE_DWORD )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid Address: The port is not a dword hr=0x%x", hr );
		hr = DPNERR_GENERIC;		
		DP8A_RETURN( hr );
	}

	dwSize = sizeof(DWORD);

	hr = pdp8Address->GetElement( DPNA_KEY_PORT, &dwPort, &dwSize, &dwType );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Unable to retrieve port element hr=0x%x", hr );
		hr = DPNERR_GENERIC;
		DP8A_RETURN( hr );
	}

	*pdwAddressLength *= 2;

	hr = pdp8Address->GetElement( DPNA_KEY_HOSTNAME, pwszAddress, pdwAddressLength, &dwType );

	*pdwAddressLength /= 2;

	if( hr == DPNERR_BUFFERTOOSMALL )
	{
		DPFX(DPFPREP,  DP8A_WARNINGLEVEL, "Buffer too small hr=0x%x", hr );
		DP8A_RETURN( hr );
	}
	else if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Unable to retrieve hostname element hr=0x%x", hr );
 		hr = DPNERR_GENERIC;
		DP8A_RETURN( hr );
	}	

	*pusPort = (USHORT) dwPort;
	
	DP8A_RETURN( DPN_OK );		
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\dnaddress\addparse.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ClassFac.cpp
 *  Content:   Parsing engine
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date         By      Reason
 *   ====       ==      ======
 *  02/04/2000	 rmt	  Created
 * 02/17/2000	rmt		Parameter validation work
 * 02/21/2000	rmt		Updated to make core Unicode and remove ANSI calls
 * 03/21/2000   rmt     Renamed all DirectPlayAddress8's to DirectPlay8Addresses
 *  07/21/2000	rmt		Bug #39940 - Addressing library doesn't properly parse stopbits in URLs 
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dnaddri.h"


#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSPARSE::DP8ADDRESSPARSE"
DP8ADDRESSPARSE::DP8ADDRESSPARSE(
	):	m_pwszCurrentLocation(NULL),
		m_pwszCurrentKey(NULL),
		m_pwszCurrentValue(NULL),
		m_pbUserData(NULL),
		m_dwUserDataSize(0),
		m_dp8State(DP8AP_IDLE),
		m_dwLenURL(0)
{
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSPARSE::~DP8ADDRESSPARSE"
DP8ADDRESSPARSE::~DP8ADDRESSPARSE()
{
	if( m_pwszCurrentKey != NULL )
	{
		delete [] m_pwszCurrentKey;
	}

	if( m_pwszCurrentValue != NULL )
	{
		delete [] m_pwszCurrentValue;
	}

	if ( m_pbUserData != NULL )
	{
		delete [] m_pbUserData;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSPARSE::ParseURL"
HRESULT DP8ADDRESSPARSE::ParseURL( DP8ADDRESSOBJECT *dp8aObject, WCHAR *pstrURL )
{
	HRESULT hr;
	
	if( m_pwszCurrentKey != NULL )
	{
		delete [] m_pwszCurrentKey;
		m_pwszCurrentKey = NULL;
	}

	if( m_pwszCurrentValue != NULL )
	{
		delete [] m_pwszCurrentValue;
		m_pwszCurrentValue = NULL;
	}

	if( m_pbUserData != NULL )
	{
		delete [] m_pbUserData;
		m_pbUserData = NULL;
	}	

	m_dwUserDataSize = 0;

	m_pwszCurrentLocation = pstrURL;

	m_dwLenURL = wcslen(pstrURL);

	if( m_dwLenURL < wcslen( DPNA_HEADER ) )
	{
		DPFX(DPFPREP,  0, "Invalid URL" );
		return DPNERR_INVALIDURL;
	}

	if( wcsncmp( pstrURL, DPNA_HEADER, wcslen(DPNA_HEADER) ) != 0 )
	{
		DPFX(DPFPREP,  0, "No header, invalid URL" );
		return DPNERR_INVALIDURL;
	}

	m_pwszCurrentLocation += wcslen( DPNA_HEADER );

	m_pwszCurrentKey = new WCHAR[m_dwLenURL+1];
	if( !m_pwszCurrentKey )
	{
		DPFX(DPFPREP,  0, "Error allocating memory" );
		return DPNERR_OUTOFMEMORY;
	}
	m_pwszCurrentValue = new WCHAR[m_dwLenURL+1];
	if( !m_pwszCurrentValue )
	{
		delete [] m_pwszCurrentKey;
		m_pwszCurrentKey = NULL;
		DPFX(DPFPREP,  0, "Error allocating memory" );
		return DPNERR_OUTOFMEMORY;	
	}
	m_pbUserData = new BYTE[m_dwLenURL+1];
	if( !m_pbUserData )
	{
		delete [] m_pwszCurrentKey;
		delete [] m_pwszCurrentValue;
		m_pwszCurrentKey = NULL;
		m_pwszCurrentValue = NULL;
		DPFX(DPFPREP,  0, "Error allocating memory" );
		return DPNERR_OUTOFMEMORY;	
	}

	m_dp8State = DP8AP_IDLE;

	// Loop until the string is done
	while( *m_pwszCurrentLocation != L'\0' )
	{
		switch( m_dp8State )
		{
		case DP8AP_IDLE:
			if( *m_pwszCurrentLocation == DPNA_SEPARATOR_USERDATA )
			{
				m_dp8State = DP8AP_USERDATA;
				m_pwszCurrentLocation++;
			}
			else
			{
				m_dp8State = DP8AP_KEY;
			}
			break;
		case DP8AP_KEY:

			if( *m_pwszCurrentLocation == DPNA_SEPARATOR_USERDATA )
			{
				m_dp8State = DP8AP_USERDATA;
				m_pwszCurrentLocation++;
				break;
			}

			hr = FSM_Key();

			if( FAILED( hr ) )
			{
				DPFX(DPFPREP,  0, "Error parsing key hr = 0x%x", hr );
				return hr;	
			}

			// Parse ended with an equals
			if( *m_pwszCurrentLocation == DPNA_SEPARATOR_KEYVALUE )
			{
				m_dp8State = DP8AP_VALUE;
				m_pwszCurrentLocation++;
			}
			else
			{
				DPFX(DPFPREP,  0, "keyname without associated value hr=0x%x", hr );
				return DPNERR_INVALIDURL;
			}

			break;
		case DP8AP_VALUE:

			hr = FSM_Value();

			if( FAILED( hr ) )
			{
				DPFX(DPFPREP,  0, "Error parsing value hr=0x%x", hr );
				return hr;
			}

			// Parse ended with an equals
			if( *m_pwszCurrentLocation == DPNA_SEPARATOR_COMPONENT )
			{
				m_dp8State = DP8AP_KEY;
				m_pwszCurrentLocation++;
			}
			else if( *m_pwszCurrentLocation == DPNA_SEPARATOR_USERDATA )
			{
				m_dp8State = DP8AP_USERDATA;
				m_pwszCurrentLocation++;
			}
			else if( *m_pwszCurrentLocation == L'\0' )
			{
				m_dp8State = DP8AP_IDLE;
			}
			else
			{
				DPFX(DPFPREP,  0, "Error parsing next key" );
				hr = DPNERR_INVALIDURL;
				return hr;
			}

			hr = FSM_CommitEntry(dp8aObject);

			if( hr == DPNERR_INVALIDPARAM )
			{
				DPFX(DPFPREP,  0, "Invalid value specified in URL hr=0x%x", hr );
				hr = DPNERR_INVALIDURL;
				return hr;
			}
			else if( FAILED( hr ) )
			{
				DPFX(DPFPREP,  0, "Error commiting entry hr=0x%x", hr );
				return hr;
			}

			break;
			
		case DP8AP_USERDATA:

			hr = FSM_UserData();

			if( FAILED( hr ) )
			{
				DPFX(DPFPREP,  0, "Error parsing user data hr=0x%x", hr );
				return hr;
			}

			hr = dp8aObject->SetUserData( m_pbUserData, m_dwUserDataSize );

			if( FAILED( hr ) )
			{
				DPFX(DPFPREP,  0, "Error setting user data hr=0x%x", hr );
				return hr;
			}

			break;
		}
	}

	if( m_dp8State != DP8AP_IDLE &&
	    m_dp8State != DP8AP_USERDATA )
	{
		DPFX(DPFPREP,  0, "Parsing error hr=0x%x", hr );
		hr = DPNERR_INVALIDURL;
		return hr;
	}

	return DPN_OK;

}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSPARSE::IsValidKeyChar"
BOOL DP8ADDRESSPARSE::IsValidKeyChar( WCHAR ch )
{
	if( ch >= L'A' && ch <= L'Z' )
		return TRUE;

	if( ch >= L'a' && ch <= L'z' )
		return TRUE;

	if( ch >= L'0' && ch <= L'9' )
		return TRUE;

	if( ch == L'-' || ch == L'?' || ch == L'.' ||
		ch == L',' || ch == L'+' || ch == L'_' )
		return TRUE;

	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSPARSE::IsValidKeyTerminator"
BOOL DP8ADDRESSPARSE::IsValidKeyTerminator( WCHAR ch )
{
	if( ch == 0 )
		return TRUE;

	if( ch == DPNA_SEPARATOR_USERDATA )
		return TRUE;

	if( ch == DPNA_SEPARATOR_COMPONENT )
		return TRUE;

	if( ch == DPNA_SEPARATOR_KEYVALUE )
		return TRUE;

	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSPARSE::FSM_Key"
// FSM_Key
//
// Parse a keyname, or return an error on error
//
HRESULT DP8ADDRESSPARSE::FSM_Key()
{
	DWORD dwKeyLoc = 0;
	m_pwszCurrentKey[0] = 0;
	HRESULT hr = DPN_OK;

	while( 1 )
	{
		if( IsValidKeyChar(*m_pwszCurrentLocation) )
		{
			m_pwszCurrentKey[dwKeyLoc] = *m_pwszCurrentLocation;
		}
		else if( IsValidKeyTerminator(*m_pwszCurrentLocation) )
		{
			m_pwszCurrentKey[dwKeyLoc] = 0;
			break;
		}
		else
		{
			m_pwszCurrentKey[dwKeyLoc] = 0;
			hr = DPNERR_INVALIDURL;
			break;
		}

		dwKeyLoc++;
		m_pwszCurrentLocation++;
	}

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSPARSE::IsValidNumber"
BOOL DP8ADDRESSPARSE::IsValidNumber( WCHAR ch )
{
	if( ch < L'0' ||
	   ch > L'9' )
	{
		return FALSE;
	}
	else
	{
		return TRUE;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSPARSE::IsValidHex"
BOOL DP8ADDRESSPARSE::IsValidHex( WCHAR ch )
{
	if( IsValidNumber( ch ) )
		return TRUE;

	if( ch >= L'A' || ch <= L'F' )
		return TRUE;

	if( ch >= L'a' || ch <= L'f' )
		return TRUE;

	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSPARSE::HexToChar"
WCHAR DP8ADDRESSPARSE::HexToChar( WCHAR *sz )
{
	WCHAR chResult = sz[0];

	// First digit
	if( sz[0] >= L'0' && sz[0] <= L'9' )
		chResult = sz[0]-L'0';

	if( sz[0] >= L'A' && sz[0] <= L'F' )
		chResult = sz[0]-L'A'+10;

	if( sz[0] >= L'a' && sz[0] <= L'f' )
		chResult = sz[0]-L'a'+10;

	chResult <<= 4;

	// Second digit
	if( sz[1] >= L'0' && sz[1] <= L'9' )
		chResult += sz[1]-'0';

	if( sz[1] >= L'A' && sz[1] <= L'F' )
		chResult += sz[1]-L'A'+10;

	if( sz[1] >= L'a' && sz[1] <= L'f' )
		chResult += sz[1]-L'a'+10;	

	return chResult;
		
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSPARSE::FSM_Value"
HRESULT DP8ADDRESSPARSE::FSM_Value()
{
	m_fNonNumeric = FALSE;
	m_pwszCurrentValue[0] = 0;
	HRESULT hr = DPN_OK;

	m_dwValueLen = 0;

	while( 1 )
	{
		// Just add it
		if( IsValidKeyChar( *m_pwszCurrentLocation ) )
		{
			m_pwszCurrentValue[m_dwValueLen] = *m_pwszCurrentLocation;

			if( !IsValidNumber( *m_pwszCurrentLocation ) )
			{
				m_fNonNumeric = TRUE;
			}
		}
		// ESCAPE SEQUENCE
		else if( *m_pwszCurrentLocation == DPNA_ESCAPECHAR )
		{
			m_fNonNumeric = TRUE;

			if( *(m_pwszCurrentLocation+1) == DPNA_ESCAPECHAR )
			{
				m_pwszCurrentValue[m_dwValueLen] = DPNA_ESCAPECHAR;
				m_pwszCurrentLocation += 2;
			}
			
			if( wcslen( m_pwszCurrentLocation ) < 3 )
			{
				DPFX(DPFPREP,  0, "Unexpected end in escape sequence" );
				hr = DPNERR_INVALIDURL;
				break;
			}

			if( !IsValidHex( *(m_pwszCurrentLocation+1) ) ||
			   !IsValidHex( *(m_pwszCurrentLocation+2) ) )
			{
				DPFX(DPFPREP,  0, "Invalid escape sequence" );
				hr = DPNERR_INVALIDURL;
				break;
			}

			m_pwszCurrentLocation ++;			

			m_pwszCurrentValue[m_dwValueLen] = HexToChar(m_pwszCurrentLocation);

			m_pwszCurrentLocation ++;
		}
		else if( IsValidKeyTerminator(*m_pwszCurrentLocation) )
		{
			m_pwszCurrentValue[m_dwValueLen] = 0;
			break;
		}
		else
		{
			m_pwszCurrentValue[m_dwValueLen] = 0;
			DPFX(DPFPREP,  0, "Unexpected character in URL" );
			hr = DPNERR_INVALIDURL;
			break;
		}

		m_dwValueLen++;
		m_pwszCurrentLocation++;
	}

	if( m_dwValueLen < 1 )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "0 length value" );
		return DPNERR_INVALIDURL;
	}	

	return hr;
}
#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSPARSE::FSM_UserData"
HRESULT DP8ADDRESSPARSE::FSM_UserData()
{
	m_pwszCurrentValue[0] = 0;
	HRESULT hr = DPN_OK;
	DWORD dwValueLoc = 0;

	while( 1 )
	{
		// Just add it
		if( IsValidKeyChar( *m_pwszCurrentLocation ) )
		{
			m_pbUserData[dwValueLoc] = (CHAR) *m_pwszCurrentLocation;
		}
		// ESCAPE SEQUENCE
		else if( *m_pwszCurrentLocation == DPNA_ESCAPECHAR )
		{
			if( *(m_pwszCurrentLocation+1) == DPNA_ESCAPECHAR )
			{
				m_pbUserData[dwValueLoc] = DPNA_ESCAPECHAR;
				m_pwszCurrentLocation += 2;
			}
			
			if( wcslen( m_pwszCurrentLocation ) < 3 )
			{
				DPFX(DPFPREP,  0, "Unexpected end in escape sequence" );
				hr = DPNERR_INVALIDURL;
				break;
			}

			if( !IsValidHex( *(m_pwszCurrentLocation+1) ) ||
			   !IsValidHex( *(m_pwszCurrentLocation+2) ) )
			{
				DPFX(DPFPREP,  0, "Invalid escape sequence" );
				hr = DPNERR_INVALIDURL;
				break;
			}

			m_pwszCurrentLocation ++;			

			m_pbUserData[dwValueLoc] = (CHAR) HexToChar(m_pwszCurrentLocation);

			m_pwszCurrentLocation ++;
		}
		else if( IsValidKeyTerminator(*m_pwszCurrentLocation) )
		{
			m_pwszCurrentValue[dwValueLoc] = 0;
			break;
		}
		else
		{
			m_pwszCurrentValue[dwValueLoc] = 0;
			hr = DPNERR_INVALIDURL;
			break;
		}

		dwValueLoc++;
		m_pwszCurrentLocation++;
	}


	m_dwUserDataSize = dwValueLoc;

	return hr;

}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSPARSE::FSM_CommitEntry"
HRESULT DP8ADDRESSPARSE::FSM_CommitEntry(DP8ADDRESSOBJECT *pdp8aObject)
{
	DWORD dwDataType = 0xFFFFFFFF;
	
    // Ensure that datatype is correct in case the key is a reserved key
    for( DWORD dwIndex = 0; dwIndex < c_dwNumBaseStrings; dwIndex++ )
    {
	    if( _wcsicmp( szBaseStrings[dwIndex], m_pwszCurrentKey ) == 0 )
	    {
		    dwDataType = dwBaseRequiredTypes[dwIndex] ;
		    break;
	    }
    }

	// If it's numeric
	if( (dwDataType == DPNA_DATATYPE_DWORD || dwDataType == 0xFFFFFFFF) && !m_fNonNumeric && wcslen(m_pwszCurrentValue)<=10)
	{
		DWORD dwTmpValue;

		dwTmpValue = _wtol( m_pwszCurrentValue );

		return pdp8aObject->SetElement( m_pwszCurrentKey, &dwTmpValue, sizeof(DWORD), DPNA_DATATYPE_DWORD );
	}

    UINT aiTmp[11];

	// We've read a GUID
    if( (dwDataType == DPNA_DATATYPE_GUID || dwDataType == 0xFFFFFFFF) && wcslen( m_pwszCurrentValue ) == 38 && swscanf( m_pwszCurrentValue, L"{%8X-%4X-%4X-%2X%2X-%2X%2X%2X%2X%2X%2X}" ,
                    &aiTmp[0],
                    &aiTmp[1], &aiTmp[2],
                    &aiTmp[3], &aiTmp[4],
                    &aiTmp[5], &aiTmp[6],
                    &aiTmp[7], &aiTmp[8],
                    &aiTmp[9], &aiTmp[10]) == 11)
    {
    	GUID guidValue;

    	guidValue.Data1      = (ULONG) aiTmp[0];
        guidValue.Data2      = (USHORT) aiTmp[1];
		guidValue.Data3      = (USHORT) aiTmp[2];
        guidValue.Data4[0]    = (BYTE) aiTmp[3];
        guidValue.Data4[1]    = (BYTE) aiTmp[4];
        guidValue.Data4[2]    = (BYTE) aiTmp[5];
        guidValue.Data4[3]    = (BYTE) aiTmp[6];
        guidValue.Data4[4]    = (BYTE) aiTmp[7];
        guidValue.Data4[5]    = (BYTE) aiTmp[8];
        guidValue.Data4[6]    = (BYTE) aiTmp[9];
        guidValue.Data4[7]    = (BYTE) aiTmp[10];

		return pdp8aObject->SetElement( m_pwszCurrentKey, &guidValue, sizeof(GUID), DPNA_DATATYPE_GUID  );
     }

	 // If there are no NULLs it's probably a string
     if( (dwDataType == DPNA_DATATYPE_STRING || dwDataType == 0xFFFFFFFF || wcscmp(DPNA_KEY_PROVIDER,m_pwszCurrentKey)==0 ) && wcslen( m_pwszCurrentValue ) == m_dwValueLen )
     {
		 // Otherwise it's a string
    	 return pdp8aObject->SetElement( m_pwszCurrentKey, m_pwszCurrentValue, (wcslen(m_pwszCurrentValue)+1)*sizeof(WCHAR), DPNA_DATATYPE_STRING );
     }

	 // Otherwise it's a binary (although the bytes were extended into WORDs/WCHARs.
   	 return pdp8aObject->SetElement( m_pwszCurrentKey, m_pwszCurrentValue, (m_dwValueLen * sizeof(WCHAR)), DPNA_DATATYPE_BINARY );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\dnaddress\addglobals.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Globals.cpp
 *  Content:    Definition of global variables.
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   07/21/99	mjn		Created
 *	 07/13/2000	rmt		Added critical sections to protect FPMs
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dnaddri.h"


//
//	Global Variables
//

DWORD	GdwHLocks = 0;
DWORD	GdwHObjects = 0;

LPFPOOL fpmAddressClassFacs = NULL;
LPFPOOL fpmAddressObjects = NULL;
LPFPOOL fpmAddressElements = NULL;
LPFPOOL fpmAddressInterfaceLists = NULL;
LPFPOOL fpmAddressObjectDatas = NULL;

CStringCache *g_pcstrKeyCache = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\dnaddress\addint.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       addbase.h
 *  Content:    DirectPlay8Address Internal interface header file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *  ====       ==      ======
 * 02/04/2000	rmt		Created
 * 03/21/2000   rmt     Renamed all DirectPlayAddress8's to DirectPlay8Addresses 
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__ADDINT_H__
#define	__ADDINT_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//
// VTable for client interface
//
extern IDirectPlay8AddressInternalVtbl DP8A_InternalVtbl;

//**********************************************************************
// Function prototypes
//**********************************************************************

//
// DirectPlay8AddressTCP 
//
STDMETHODIMP DP8AINT_Lock( IDirectPlay8AddressInternal *pInterface );
STDMETHODIMP DP8AINT_UnLock( IDirectPlay8AddressInternal *pInterface );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\dnaddress\addint.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       addbase.cpp
 *  Content:    DirectPlay8Address Internal interace file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *  ====       ==      ======
 * 02/04/2000	rmt		Created
 * 02/17/2000	rmt		Parameter validation work 
 * 03/21/2000   rmt     Renamed all DirectPlayAddress8's to DirectPlay8Addresses 
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dnaddri.h"


typedef	STDMETHODIMP InternalQueryInterface( IDirectPlay8AddressInternal *pInterface, REFIID riid, LPVOID *ppvObj );
typedef	STDMETHODIMP_(ULONG)	InternalAddRef( IDirectPlay8AddressInternal *pInterface );
typedef	STDMETHODIMP_(ULONG)	InternalRelease( IDirectPlay8AddressInternal *pInterface );

//
// VTable for client interface
//
IDirectPlay8AddressInternalVtbl DP8A_InternalVtbl =
{
	(InternalQueryInterface*)		DP8A_QueryInterface,
	(InternalAddRef*)				DP8A_AddRef,
	(InternalRelease*)				DP8A_Release,
									DP8AINT_Lock,
									DP8AINT_UnLock
};

#undef DPF_MODNAME
#define DPF_MODNAME "DP8AINT_Lock"
STDMETHODIMP DP8AINT_Lock( IDirectPlay8AddressInternal *pInterface )
{
	DP8ADDRESSOBJECT *pdp8Address = (DP8ADDRESSOBJECT *) GET_OBJECT_FROM_INTERFACE( pInterface );

	return pdp8Address->Lock();
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8AINT_UnLock"
STDMETHODIMP DP8AINT_UnLock( IDirectPlay8AddressInternal *pInterface )
{
	DP8ADDRESSOBJECT *pdp8Address = (DP8ADDRESSOBJECT *) GET_OBJECT_FROM_INTERFACE( pInterface );

	return pdp8Address->UnLock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\dnaddress\addtcp.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       addbase.h
 *  Content:    DirectPlay8Address TCP interface header file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *  ====       ==      ======
 * 02/04/2000	rmt		Created
 * 02/17/2000	rmt		Parameter validation work 
 * 02/20/2000	rmt		Changed ports to USHORTs
 * 02/21/2000	 rmt	Updated to make core Unicode and remove ANSI calls  
 * 03/21/2000   rmt     Renamed all DirectPlayAddress8's to DirectPlay8Addresses 
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__ADDTCP_H__
#define	__ADDTCP_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//
// VTable for client interface
//
extern IDirectPlay8AddressIPVtbl DP8A_IPVtbl;

//**********************************************************************
// Function prototypes
//**********************************************************************

//
// DirectPlay8AddressTCP 
//
STDMETHODIMP DP8ATCP_BuildFromSockAddr( IDirectPlay8AddressIP *pInterface, const SOCKADDR * const pSockAddr );
STDMETHODIMP DP8ATCP_BuildAddressW( IDirectPlay8AddressIP *pInterface, const WCHAR * const pwszAddress, const USHORT usPort );
STDMETHODIMP DP8ATCP_GetSockAddress( IDirectPlay8AddressIP *pInterface, SOCKADDR *pSockAddr, PDWORD pdwBufferSize );
STDMETHODIMP DP8ATCP_GetLocalAddress( IDirectPlay8AddressIP *pInterface, GUID * pguidAdapter, USHORT *psPort );
STDMETHODIMP DP8ATCP_GetAddressW( IDirectPlay8AddressIP *pInterface, WCHAR * pwszAddress, PDWORD pdwAddressLength, USHORT *psPort );
STDMETHODIMP DP8ATCP_BuildLocalAddress( IDirectPlay8AddressIP *pInterface, const GUID * const pguidAdapter, const USHORT psPort );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\dnaddress\classfac.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ClassFac.h
 *  Content:    DirectNet class factory header file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *	 10/08/99	jtk		Created
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__CLASSFAC_H__
#define	__CLASSFAC_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// COM interface for class factory
//
#undef INTERFACE				// External COM Implementation
#define INTERFACE IDirectPlay8AddressClassFact
DECLARE_INTERFACE_(IDirectPlay8AddressClassFact,IUnknown)
{
	STDMETHOD(QueryInterface)	(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)	(THIS) PURE;
	STDMETHOD_(ULONG,Release)	(THIS) PURE;
	STDMETHOD(CreateInstance)	(THIS_ LPUNKNOWN lpUnkOuter, REFIID riid, LPVOID *ppvObj) PURE;
	STDMETHOD(LockServer)		(THIS_ BOOL bLock) PURE;
};


typedef struct _IDirectPlay8AddressClassFact {	// Internal Implementation (overlay's external imp.)
	IDirectPlay8AddressClassFactVtbl *lpVtbl;		// lpVtbl Must be first element (to match external imp.)
	LONG					lRefCount;
	DWORD					dwLocks;
} _IDirectPlay8AddressClassFact, *_LPIDirectPlay8AddressClassFact;

//**********************************************************************
// Variable definitions
//**********************************************************************

//
// VTable for class factory
//
extern IDirectPlay8AddressClassFactVtbl DP8ACF_Vtbl;

// 
// VTable for IUnknown
extern IUnknownVtbl  DP8A_UnknownVtbl;

//**********************************************************************
// Function prototypes
//**********************************************************************

//	DirectNet - IUnknown
STDMETHODIMP			DP8A_QueryInterface(LPVOID lpv, REFIID riid,LPVOID *ppvObj);
STDMETHODIMP_(ULONG)	DP8A_AddRef(LPVOID lphObj);
STDMETHODIMP_(ULONG)	DP8A_Release(LPVOID lphObj);

// Class Factory
STDMETHODIMP			DP8ACF_QueryInterface(IDirectPlay8AddressClassFact *pInterface,REFIID riid,LPVOID *ppvObj);
STDMETHODIMP_(ULONG)	DP8ACF_AddRef(IDirectPlay8AddressClassFact *pInterface);
STDMETHODIMP_(ULONG)	DP8ACF_Release(IDirectPlay8AddressClassFact *pInterface);
STDMETHODIMP			DP8ACF_CreateInstance(IDirectPlay8AddressClassFact *pInterface,LPUNKNOWN lpUnkOuter,REFIID riid,LPVOID *ppv);
STDMETHODIMP			DP8ACF_LockServer(IDirectPlay8AddressClassFact *pInterface,BOOL bLock);

// Class Factory - supporting

HRESULT		DP8ACF_CreateObject(LPVOID *lplpv,REFIID riid);
HRESULT		DP8ACF_FreeObject(LPVOID lpv);

#endif	// __CLASSFAC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\dnaddress\dplegacy.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplegacy.h
 *  Content:    Definitions for old DirectPlay's address type
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/21/2000	rmt		Created
 *  07/21/2000	rmt		Minor bug fixes to dplay4 address parsing.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
// XBOX! This module shouldn't be needed for XBOX

#include "dnaddri.h"


#define DPLEGACY_ELEMENTS           11      

DPLEGACYMAPGUIDTOSTRING dpLegacyMap [DPLEGACY_ELEMENTS] =
{
    DPLEGACYMAPGUIDTOSTRING( DPAID_ServiceProvider, DPNA_KEY_PROVIDER, DPNA_DATATYPE_GUID ),
    DPLEGACYMAPGUIDTOSTRING( DPAID_ComPort, DPNA_KEY_PORT, DPNA_DATATYPE_DPCOMPORTADDRESS ),
    DPLEGACYMAPGUIDTOSTRING( DPAID_INet, DPNA_KEY_HOSTNAME, DPNA_DATATYPE_STRING_ANSI ),
    DPLEGACYMAPGUIDTOSTRING( DPAID_INetW, DPNA_KEY_HOSTNAME, DPNA_DATATYPE_STRING ),
    DPLEGACYMAPGUIDTOSTRING( DPAID_INetPort, DPNA_KEY_PORT, DPNA_DATATYPE_DWORD ),
    DPLEGACYMAPGUIDTOSTRING( DPAID_LobbyProvider, L"lobbyprovider", DPNA_DATATYPE_GUID ),
    DPLEGACYMAPGUIDTOSTRING( DPAID_Modem, L"modemname", DPNA_DATATYPE_STRING_ANSI ),
    DPLEGACYMAPGUIDTOSTRING( DPAID_ModemW, L"modemname", DPNA_DATATYPE_STRING ),
    DPLEGACYMAPGUIDTOSTRING( DPAID_Phone, DPNA_KEY_PHONENUMBER, DPNA_DATATYPE_STRING_ANSI ),
    DPLEGACYMAPGUIDTOSTRING( DPAID_PhoneW, DPNA_KEY_PHONENUMBER, DPNA_DATATYPE_STRING ),
    DPLEGACYMAPGUIDTOSTRING( DPAID_TotalSize, DPNA_KEY_PORT, DPNA_DATATYPE_NOP )
};

#undef DPF_MODNAME
#define DPF_MODNAME "AddDP4Element"

HRESULT AddDP4Element( PDPADDRESS pdpAddressElement, PDP8ADDRESSOBJECT pdpAddress )
{
    DWORD dwIndex;
    HRESULT hr = DPN_OK;
    PDPCOMPORTADDRESS pPortAddress;
    WCHAR chPortBuffer[30];

    // Loop through entries
    for( dwIndex = 0 ; dwIndex < sizeof( dpLegacyMap ) / sizeof( DPLEGACYMAPGUIDTOSTRING ); dwIndex++ )
    {
        if( dpLegacyMap[dwIndex].m_guidType == pdpAddressElement->guidDataType )
        {
            switch( dpLegacyMap[dwIndex].m_dwDataType )
            {
            case DPNA_DATATYPE_STRING_ANSI:

                if( !DNVALID_STRING_A( (char *) &pdpAddressElement[1] ) )
                    hr = DPNERR_INVALIDADDRESSFORMAT;
                else
                    hr = pdpAddress->SetElement( dpLegacyMap[dwIndex].m_wszKeyName, (LPVOID) &pdpAddressElement[1], pdpAddressElement->dwDataSize, DPNA_DATATYPE_STRING_ANSI );

                break;

            case DPNA_DATATYPE_DPCOMPORTADDRESS:

                pPortAddress = (PDPCOMPORTADDRESS) &pdpAddressElement[1];

                swprintf( chPortBuffer, L"COM%u", pPortAddress->dwComPort );

                hr = pdpAddress->SetElement( DPNA_KEY_STOPBITS, chPortBuffer, (wcslen( chPortBuffer )+1)*sizeof(WCHAR), DPNA_DATATYPE_STRING );

                if( FAILED( hr ) )
                {
                    DPFX(DPFPREP,  0, "Unable to specify port element hr=[0x%lx]", hr );
                    break;
                }

                hr = pdpAddress->SetElement( DPNA_KEY_BAUD, &pPortAddress->dwBaudRate, sizeof( DWORD ), DPNA_DATATYPE_DWORD );

                if( FAILED( hr ) )
                {
                    DPFX(DPFPREP,  0, "Unable to specify baudrate element hr=[0x%lx]", hr );
                    break;
                }

                switch( pPortAddress->dwStopBits )
                {
                case ONESTOPBIT:
                    hr = pdpAddress->SetElement( DPNA_KEY_STOPBITS, &DPNA_STOP_BITS_ONE, (wcslen( DPNA_STOP_BITS_ONE )+1)*sizeof(WCHAR), DPNA_DATATYPE_STRING );
                    break;
                case ONE5STOPBITS:
                    hr = pdpAddress->SetElement( DPNA_KEY_STOPBITS, &DPNA_STOP_BITS_ONE_FIVE, (wcslen( DPNA_STOP_BITS_ONE_FIVE )+1)*sizeof(WCHAR), DPNA_DATATYPE_STRING );
                    break;
                case TWOSTOPBITS:
                    hr = pdpAddress->SetElement( DPNA_KEY_STOPBITS, &DPNA_STOP_BITS_TWO, (wcslen( DPNA_STOP_BITS_TWO )+1)*sizeof(WCHAR), DPNA_DATATYPE_STRING );
                    break;
                default:
                    hr = DPNERR_INVALIDADDRESSFORMAT;
                }

                if( FAILED( hr ) )
                {
                    DPFX(DPFPREP,  0, "Error converting stopbits element hr=[0x%lx]", hr );
                    break;
                }

                switch( pPortAddress->dwParity )
                {
                case NOPARITY:
                    hr = pdpAddress->SetElement( DPNA_KEY_PARITY, &DPNA_PARITY_NONE, (wcslen( DPNA_PARITY_NONE )+1)*sizeof(WCHAR), DPNA_DATATYPE_STRING );
                    break;
                case ODDPARITY:
                    hr = pdpAddress->SetElement( DPNA_KEY_PARITY, &DPNA_PARITY_ODD, (wcslen( DPNA_PARITY_ODD )+1)*sizeof(WCHAR), DPNA_DATATYPE_STRING );
                    break;
                case EVENPARITY:
                    hr = pdpAddress->SetElement( DPNA_KEY_PARITY, &DPNA_PARITY_EVEN, (wcslen( DPNA_PARITY_EVEN )+1)*sizeof(WCHAR), DPNA_DATATYPE_STRING );
                    break;
                case MARKPARITY:
                    hr = pdpAddress->SetElement( DPNA_KEY_PARITY, &DPNA_PARITY_MARK, (wcslen( DPNA_PARITY_MARK )+1)*sizeof(WCHAR), DPNA_DATATYPE_STRING );
                    break;
                default:
                    hr = DPNERR_INVALIDADDRESSFORMAT;
                }

                if( FAILED( hr ) )
                {
                    DPFX(DPFPREP,  0, "Error converting parity element hr=[0x%lx]", hr );
                    break;
                }

                switch( pPortAddress->dwFlowControl )
                {
                case DPCPA_NOFLOW:
                    hr = pdpAddress->SetElement( DPNA_KEY_FLOWCONTROL, &DPNA_FLOW_CONTROL_NONE, (wcslen( DPNA_KEY_FLOWCONTROL )+1)*sizeof(WCHAR), DPNA_DATATYPE_STRING );
                    break;
                case DPCPA_XONXOFFFLOW:
                    hr = pdpAddress->SetElement( DPNA_KEY_FLOWCONTROL, &DPNA_FLOW_CONTROL_XONXOFF, (wcslen( DPNA_FLOW_CONTROL_XONXOFF )+1)*sizeof(WCHAR), DPNA_DATATYPE_STRING );
                    break;
                case DPCPA_RTSFLOW:
                    hr = pdpAddress->SetElement( DPNA_KEY_FLOWCONTROL, &DPNA_FLOW_CONTROL_RTS, (wcslen( DPNA_FLOW_CONTROL_RTS )+1)*sizeof(WCHAR), DPNA_DATATYPE_STRING );
                    break;
                case DPCPA_DTRFLOW:
                    hr = pdpAddress->SetElement( DPNA_KEY_FLOWCONTROL, &DPNA_FLOW_CONTROL_DTR, (wcslen( DPNA_FLOW_CONTROL_DTR )+1)*sizeof(WCHAR), DPNA_DATATYPE_STRING );
                    break;
                case DPCPA_RTSDTRFLOW:
                    hr = pdpAddress->SetElement( DPNA_KEY_FLOWCONTROL, &DPNA_FLOW_CONTROL_RTSDTR, (wcslen( DPNA_FLOW_CONTROL_RTSDTR )+1)*sizeof(WCHAR), DPNA_DATATYPE_STRING );
                    break;
                default:
                    hr = DPNERR_INVALIDADDRESSFORMAT;
                }

                if( FAILED( hr ) )
                {
                    DPFX(DPFPREP,  0, "Error converting flow control element hr=[0x%lx]", hr );
                    break;
                }

                break;
            case DPNA_DATATYPE_DWORD:
                if( pdpAddressElement->dwDataSize != sizeof( DWORD ) )
                    hr = DPNERR_INVALIDADDRESSFORMAT;
                else
                    hr = pdpAddress->SetElement( dpLegacyMap[dwIndex].m_wszKeyName, (LPVOID) &pdpAddressElement[1], pdpAddressElement->dwDataSize, DPNA_DATATYPE_DWORD );
                break;
            case DPNA_DATATYPE_GUID:
                if( pdpAddressElement->dwDataSize != sizeof( GUID ) )
                    hr = DPNERR_INVALIDADDRESSFORMAT;
                else
                    hr = pdpAddress->SetElement( dpLegacyMap[dwIndex].m_wszKeyName, (LPVOID) &pdpAddressElement[1], pdpAddressElement->dwDataSize, DPNA_DATATYPE_GUID );
                break;
            case DPNA_DATATYPE_STRING:
                if( !DNVALID_STRING_W( (WCHAR *) &pdpAddressElement[1] ) )
                    hr = DPNERR_INVALIDADDRESSFORMAT;
                else
                    hr = pdpAddress->SetElement( dpLegacyMap[dwIndex].m_wszKeyName, (LPVOID) &pdpAddressElement[1], pdpAddressElement->dwDataSize, DPNA_DATATYPE_STRING );
                break;
            case DPNA_DATATYPE_NOP:
            	hr = DPN_OK;
            	break;
            default:
                hr = DPNERR_INVALIDADDRESSFORMAT;
                break;
            }
            break;
        }
    }

    if( dwIndex == DPLEGACY_ELEMENTS )
    {
        DPFX(DPFPREP,  0, "Address contains an element which cannot be mapped" );
        return DPNERR_INVALIDADDRESSFORMAT;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\dnaddress\dplegacy.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplegacy.h
 *  Content:    Definitions for old DirectPlay's address type
 *
 *              WARNING: This file duplicates definitions found in dplobby.h
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/21/2000	rmt		Created
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __DPLEGACY_H
#define __DPLEGACY_H

#include "dplegacyguid.h"

typedef struct _DPADDRESS
{
    GUID                guidDataType;
    DWORD               dwDataSize;
} DPADDRESS, *PDPADDRESS, *LPDPADDRESS;

typedef struct DPCOMPORTADDRESS{
    DWORD dwComPort;
    DWORD dwBaudRate;
    DWORD dwStopBits;
    DWORD dwParity;
    DWORD dwFlowControl;
} DPCOMPORTADDRESS, *PDPCOMPORTADDRESS;

#define DPCPA_NOFLOW        0           // no flow control
#define DPCPA_XONXOFFFLOW   1           // software flow control
#define DPCPA_RTSFLOW       2           // hardware flow control with RTS
#define DPCPA_DTRFLOW       3           // hardware flow control with DTR
#define DPCPA_RTSDTRFLOW    4           // hardware flow control with RTS and DTR

#define DPNA_DATATYPE_DPCOMPORTADDRESS      0x00002000
#define DPNA_DATATYPE_NOP                   0x00004000

class DPLEGACYMAPGUIDTOSTRING
{
public:
    DPLEGACYMAPGUIDTOSTRING( const GUID &guidType, const WCHAR *const wszKeyName, DWORD dwDataType
        ): m_guidType(guidType), m_wszKeyName(wszKeyName), m_dwDataType(dwDataType)
    {
    };

    GUID                m_guidType;
    const WCHAR * const m_wszKeyName;
    DWORD               m_dwDataType;
};

typedef DPLEGACYMAPGUIDTOSTRING *PDPLEGACYMAPGUIDTOSTRING;

HRESULT AddDP4Element( PDPADDRESS pdpAddressElement, PDP8ADDRESSOBJECT pdpAddress );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\dnaddress\sources.inc ===
#
# The MAJORCOMP and MINORCOMP variables are defined
# so that $(MAJORCOMP)$(MINORCOMP)filename can be used in
# cross compiling to provide unique filenames in a flat namespace.
#

MAJORCOMP=windows
MINORCOMP=media

#
# The TARGETNAME variable is defined by the developer.  It is the name of
# the target (component) that is being built by this makefile.  It
# should NOT include any path or file extension information.
#

TARGETNAME=dpnaddr
DLLDEF=..\dnadd.def
UMTYPE=windows

#
# The TARGETPATH and TARGETTYPE variables are defined by the developer.
# The first specifies where the target is to be build.  The second specifies
# the type of target (either PROGRAM, DYNLINK, LIBRARY, DRIVER, etc
# UMAPPL_NOLIB is used when you're only building user-mode
# apps and don't need to build a library.
#

TARGETPATH=obj
TARGETTYPE=DYNLINK

!if "$(DPLAY_PCH)" != "off"
PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\dnaddri.h
PRECOMPILED_PCH=dnaddri.pch
PRECOMPILED_OBJ=dnaddri.obj
!endif

#
# The TARGETLIBS specifies additional libraries to link with you target
# image.  Each library path specification should contain an asterisk (*)
# where the machine specific subdirectory name should go.
#

#
# 04/10/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
           ..\..\guids\obj$(BUILD_ALT_DIR)\*\guids.lib \
           ..\..\common\obj$(BUILD_ALT_DIR)\*\common.lib \
	   $(BASEDIR)\public\sdk\lib\*\wsock32.lib \
	   $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
	   $(BASEDIR)\public\sdk\lib\*\user32.lib \
	   $(BASEDIR)\public\sdk\lib\*\gdi32.lib \
	   $(BASEDIR)\public\sdk\lib\*\winmm.lib \
	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
	   $(BASEDIR)\public\sdk\lib\*\ole32.lib  \
	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
	   $(BASEDIR)\public\sdk\lib\*\msvcrt.lib


!if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
C_DEFINES=$(C_DEFINES) /DDEBUG /D_DEBUG
!endif

#
# The INCLUDES variable specifies any include paths that are specific to
# this source directory.  Separate multiple directory paths with single
# semicolons.  Relative path specifications are okay.
#

INCLUDES=..\;..\..\..\dvoice\inc;$(DXROOT)\inc;..\..\inc;..\..\common


#
# The SOURCES variable is defined by the developer.  It is a list of all the
# source files for this component.  Each source file should be on a separate
# line using the line continuation character.  This will minimize merge
# conflicts if two developers adding source files to the same component.
#

SOURCES= ..\addcore.cpp \
         ..\addclassfac.cpp \
         ..\adddllmain.cpp \
	 ..\addglobals.cpp \
	 ..\addint.cpp \
	 ..\addtcp.cpp \
	 ..\addbase.cpp \
	 ..\strcache.cpp \
	 ..\addparse.cpp \
         ..\dplegacy.cpp \
	 ..\dnadd.rc

#
# Next specify options for the compiler.
#
# Note about CRT defines.  When linking with MSVCRT you must have both _MT and _DLL specified.
# Using the build environment's USE_MSVCRT=1 would do this for us, but because we define our
# own operator new this will cause a link error because the build environment will not properly
# pull in msvcrt.lib last as of 5/11/2001.  Therefore, we do it all manually specifying _DLL, _MT, 
# and msvcrt.lib and USE_NOLIBS=1 ourselves.  This also means that we must manually add msvcprt.lib 
# where STL is used.
#
C_DEFINES= $(C_DEFINES) /D_USRDLL /DWIN32 /D_MT /D_DLL /DCINTERFACE

USE_NOLIBS=1

DLLENTRY=_DllMainCRTStartup
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\dnaddress\dnaddri.h ===
/***************************************************************************
 *
 *  Copyright (C) 1997-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dnaddri.h
 *  Content:    DirectPlay Address master internal header file.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/28/01    masonb  Created.
 *
 ***************************************************************************/

#ifndef __DNADDRI_H__
#define __DNADDRI_H__

// 
// Public includes
//
#include <windows.h>
#include <winsock.h>
#include <stdio.h>

// 
// DirectPlay public includes
//
#include "dplay8.h"
#include "dpaddr.h"
#include "dvoice.h"

// 
// DirectPlay private includes
//
#include "osind.h"
#include "classbilink.h"
#include "fpm.h"
#include "classfpm.h"
#include "dneterrors.h"
#include "dndbg.h"
#include "comutil.h"
#include "creg.h"
#include "strutils.h"

// 
// Addr private includes
//
#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_ADDR

#include "addbase.h"
#include "addbld.h"
#include "addcore.h"
#include "addint.h"
#include "addparse.h"
#include "addtcp.h"
#include "classfac.h"
#include "comstuff.h"
#include "dplegacy.h"
#include "strcache.h"

#endif // __DNADDRI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\dnaddress\comstuff.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       comstuff.h
 *  Content:    DNET COM class factory
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  ?			rmt		Adapted for use in addressing lib
 *  07/09/2000	rmt		Added signature bytes to start of objects
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef COMSTUFF_H
#define COMSTUFF_H

#define DPASIGNATURE_IL			'LIAD'
#define DPASIGNATURE_IL_FREE	'LIA_'

#define DPASIGNATURE_OD			'DOAD'
#define DPASIGNATURE_OD_FREE	'DOA_'

typedef struct INTERFACE_LIST {
	LPVOID					lpVtbl;
	DWORD					dwSignature;
	LONG					lRefCount;
	IID						iid;
	struct INTERFACE_LIST	*lpIntNext;
	struct OBJECT_DATA		*lpObject;
} INTERFACE_LIST, *LPINTERFACE_LIST;

typedef struct OBJECT_DATA {
	DWORD				dwSignature;
	LONG				lRefCount;
	LPVOID				lpvData;
	LPINTERFACE_LIST	lpIntList;
} OBJECT_DATA, *LPOBJECT_DATA;

#define GET_OBJECT_FROM_INTERFACE(a)	((LPINTERFACE_LIST) a)->lpObject->lpvData

#if !defined(__cplusplus) && !defined(CINTERFACE)

#ifdef THIS_
#undef THIS_
#define THIS_   LPVOID this,
#endif

#ifdef THIS
#undef THIS
#define THIS    LPVOID this
#endif

#endif


#endif // COMSTUFF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\dnaddress\dplegacyguid.h ===
// {F2F0CE00-E0AF-11cf-9C4E-00A0C905425E}
DEFINE_GUID(DPAID_ComPort, 
0xf2f0ce00, 0xe0af, 0x11cf, 0x9c, 0x4e, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

// {1318F560-912C-11d0-9DAA-00A0C90A43CB}
DEFINE_GUID(DPAID_TotalSize, 
0x1318f560, 0x912c, 0x11d0, 0x9d, 0xaa, 0x0, 0xa0, 0xc9, 0xa, 0x43, 0xcb);

// {07D916C0-E0AF-11cf-9C4E-00A0C905425E}
DEFINE_GUID(DPAID_ServiceProvider, 
0x7d916c0, 0xe0af, 0x11cf, 0x9c, 0x4e, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

// {59B95640-9667-11d0-A77D-0000F803ABFC}
DEFINE_GUID(DPAID_LobbyProvider, 
0x59b95640, 0x9667, 0x11d0, 0xa7, 0x7d, 0x0, 0x0, 0xf8, 0x3, 0xab, 0xfc);

// {78EC89A0-E0AF-11cf-9C4E-00A0C905425E}
DEFINE_GUID(DPAID_Phone, 
0x78ec89a0, 0xe0af, 0x11cf, 0x9c, 0x4e, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

// {BA5A7A70-9DBF-11d0-9CC1-00A0C905425E}
DEFINE_GUID(DPAID_PhoneW, 
0xba5a7a70, 0x9dbf, 0x11d0, 0x9c, 0xc1, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

// {F6DCC200-A2FE-11d0-9C4F-00A0C905425E}
DEFINE_GUID(DPAID_Modem, 
0xf6dcc200, 0xa2fe, 0x11d0, 0x9c, 0x4f, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

// {01FD92E0-A2FF-11d0-9C4F-00A0C905425E}
DEFINE_GUID(DPAID_ModemW, 
0x1fd92e0, 0xa2ff, 0x11d0, 0x9c, 0x4f, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

// {C4A54DA0-E0AF-11cf-9C4E-00A0C905425E}
DEFINE_GUID(DPAID_INet, 
0xc4a54da0, 0xe0af, 0x11cf, 0x9c, 0x4e, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

// {E63232A0-9DBF-11d0-9CC1-00A0C905425E}
DEFINE_GUID(DPAID_INetW, 
0xe63232a0, 0x9dbf, 0x11d0, 0x9c, 0xc1, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);


// {E4524541-8EA5-11d1-8A96-006097B01411}
DEFINE_GUID(DPAID_INetPort, 
0xe4524541, 0x8ea5, 0x11d1, 0x8a, 0x96, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\dnaddress\strcache.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       strcache.h
 *  Content:   Class for caching strings
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 * 02/04/2000	rmt		Created
 * 02/21/2000	 rmt	Updated to make core Unicode and remove ANSI calls  
 *@@END_MSINTERNAL
 *
 ***************************************************************************/


#ifndef __STRCACHE_H
#define __STRCACHE_H

class CStringCache
{
public:
	CStringCache();
	~CStringCache();

	HRESULT AddString( const WCHAR *pszString, WCHAR * *ppszSlot );
	
protected:
	HRESULT GetString( const WCHAR *pszString, WCHAR * *ppszSlot );
	HRESULT GrowCache( DWORD dwNewSize );

	WCHAR ** m_ppszStringCache;
	DWORD m_dwNumElements;
	DWORD m_dwNumSlots;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\dpnsvr\dpnsvlib\dnsvlibi.h ===
/***************************************************************************
 *
 *  Copyright (C) 1997-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dnSVLIBi.h
 *  Content:    DirectPlay DPNSvrLib master internal header file.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/28/01    masonb  Created.
 *
 ***************************************************************************/

#ifndef __DNSVLIBI_H__
#define __DNSVLIBI_H__

// 
// Public includes
//
#include <windows.h>
#include <mmsystem.h>
#include <tchar.h>

// 
// DirectPlay public includes
//
#include "dplay8.h"
#include "dpaddr.h"

// 
// DirectPlay private includes
//
#include "osind.h"
#include "dndbg.h"

//
// Dpnsvr includes
//
#include "dpnsdef.h"
#include "dpnsvmsg.h"

// 
// Dpnsvlib private includes
//
#include "dpnsvrq.h"
#include "dpnsvlib.h"


#endif // __DNSVLIBI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\dnaddress\strcache.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       strcache.cpp
 *  Content:   Class for caching strings
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 * 02/04/2000	rmt		Created
 * 02/17/2000	rmt		Parameter validation work 
 * 02/21/2000	 rmt	Updated to make core Unicode and remove ANSI calls  
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dnaddri.h"


// # of slots to grow the cache at each opportunity
#define STRINGCACHE_GROW_SLOTS				10

#undef DPF_MODNAME
#define DPF_MODNAME "CStringCache::CStringCache"

CStringCache::CStringCache(): m_ppszStringCache(NULL), m_dwNumElements(0), m_dwNumSlots(0)
{
}

#undef DPF_MODNAME
#define DPF_MODNAME "CStringCache::~CStringCache"

CStringCache::~CStringCache()
{
	for( DWORD dwIndex = 0; dwIndex < m_dwNumElements; dwIndex++ )
	{
		delete [] m_ppszStringCache[dwIndex];
	}

	delete [] m_ppszStringCache;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CStringCache::AddString"

HRESULT CStringCache::AddString( const WCHAR *pszString, WCHAR * *ppszSlot )
{
	HRESULT hr;
	PWSTR pszSlot;

	hr = GetString( pszString, &pszSlot );

	if( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Internal Error hr=0x%x", hr );
		return hr;
	}

	// Entry was found
	if( pszSlot != NULL )
	{
		*ppszSlot = pszSlot;
		return DPN_OK;
	}
	else
	{
		if( m_dwNumElements == m_dwNumSlots )
		{
			hr = GrowCache( m_dwNumSlots + STRINGCACHE_GROW_SLOTS );

			if( FAILED( hr ) )
			{
				DPFX(DPFPREP,  0, "Failed to grow string cache hr=0x%x", hr );
				return hr;
			}
		}

		m_ppszStringCache[m_dwNumElements] = new WCHAR[wcslen(pszString)+1];

		if( m_ppszStringCache[m_dwNumElements] == NULL )
		{
			DPFX(DPFPREP,  0, "Failed to alloc mem" );
			return DPNERR_OUTOFMEMORY;
		}

		wcscpy( m_ppszStringCache[m_dwNumElements], pszString );
		*ppszSlot = m_ppszStringCache[m_dwNumElements];

		m_dwNumElements++;

		return DPN_OK;
		
	}

}

#undef DPF_MODNAME
#define DPF_MODNAME "CStringCache::GetString"

HRESULT CStringCache::GetString( const WCHAR *pszString, WCHAR * *ppszSlot )
{
	*ppszSlot = NULL;
	
	for( DWORD dwIndex = 0; dwIndex < m_dwNumElements; dwIndex++ )
	{
		if( wcscmp( m_ppszStringCache[dwIndex], pszString ) == 0 )
		{
			*ppszSlot = m_ppszStringCache[dwIndex];
			return DPN_OK;
		}
	}

	return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CStringCache::GrowCache"

HRESULT CStringCache::GrowCache( DWORD dwNewSize )
{
	WCHAR **ppszNewCache;

	ppszNewCache = new WCHAR *[dwNewSize];

	if( ppszNewCache == NULL )
	{
		DPFX(DPFPREP,  0, "Error allocating memory" );
		return DPNERR_OUTOFMEMORY;
	}

	memcpy( ppszNewCache, m_ppszStringCache, sizeof( WCHAR * ) * m_dwNumElements );
	m_dwNumSlots = dwNewSize;

	if( m_ppszStringCache != NULL )
		delete [] m_ppszStringCache;	

	m_ppszStringCache = ppszNewCache;

	return DPN_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\dpnsvr\dpnsvr\dnsvri.h ===
/***************************************************************************
 *
 *  Copyright (C) 1997-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dnSVRi.h
 *  Content:    DirectPlay DPNSvr master internal header file.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/28/01    masonb  Created.
 *
 ***************************************************************************/

#ifndef __DNSVRI_H__
#define __DNSVRI_H__

// 
// Public includes
//
#include <windows.h>
#include <mmsystem.h>
#include <process.h>
#include <tchar.h>

// 
// DirectPlay public includes
//
#include "dplay8.h"
#include "dpaddr.h"
#include "dpsp8.h"

// 
// DirectPlay private includes
//
#include "osind.h"
#include "dndbg.h"
#include "classbilink.h"
#include "lockedcfpm.h"
#include "comutil.h"

// 
// Dpnsvlib private includes
//
#include "dpnsdef.h"
#include "dpnsvmsg.h"
#include "dpnsvrq.h"
#include "dpnsvlib.h"

//
// Dpnsvr private includes
//
#include "proctbl.h"
#include "dpsvr8.h"
#include "resource.h"

#endif // __DNSVRI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\dpnsvr\dpnsvlib\dpnsvlib.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       enumsvr.cpp
 *  Content:    DirectPlay8 <--> DPNSVR Utility functions
 *
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/24/00	rmt		Created
 *  03/25/00    rmt     Updated to handle new status/table format for n providers
 *	09/04/00	mjn		Changed DPNSVR_Register() and DPNSVR_UnRegister() to use guids directly (rather than ApplicationDesc)
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dnsvlibi.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_DPNSVR


#define DPNSVR_WAIT_STARTUP				30000


#undef DPF_MODNAME 
#define DPF_MODNAME "DPNSVR_WaitForStartup"
HRESULT DPNSVR_WaitForStartup( HANDLE hWaitHandle )
{
	LONG lWaitResult;

	DPFX(DPFPREP,  3, "Waiting for DPNSVR startup" );

	// Wait for startup.. just in case it's starting up.
	lWaitResult = WaitForSingleObject( hWaitHandle, DPNSVR_WAIT_STARTUP );

	if( lWaitResult == WAIT_TIMEOUT )
	{
		DPFX(DPFPREP,  0, "Timeout waiting for DPNSVR startup" );
		return DPNERR_TIMEDOUT;
	}
	else
	{
		DPFX(DPFPREP,  3, "Server has signalled it has started up" );
		return DPN_OK;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "DPNSVR_SendMessage"
HRESULT DPNSVR_SendMessage( LPVOID pvMessage, DWORD dwSize )
{
	CDPNSVRIPCQueue ipcQueue;
	HRESULT hr;

	// Attempt to open server queue
	hr = ipcQueue.Open( &GUID_DPNSVR_QUEUE, DPNSVR_MSGQ_SIZE, DPNSVR_MSGQ_OPEN_FLAG_NO_CREATE );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Error opening server queue hr=[0x%lx]", hr );
		return hr;
	}

	hr = ipcQueue.Send( (PBYTE) pvMessage, dwSize, 1000, DPNSVR_MSGQ_MSGFLAGS_USER1, 0 );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Send failed hr=[0x%lx]", hr );
	}

	ipcQueue.Close();

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DPNSVR_WaitForResult"
HRESULT DPNSVR_WaitForResult( CDPNSVRIPCQueue *pQueue )
{
    DPNSVR_MSGQ_HEADER dplMsgHeader;
    PDPNSVMSG_RESULT pdplMsgResult;
    HANDLE hWaitSemaphore = pQueue->GetReceiveSemaphoreHandle();
	HRESULT hr = DPN_OK;
	PBYTE pbBuffer = NULL;
	DWORD dwBufferSize = 0;

    if( WaitForSingleObject( hWaitSemaphore, 1000 ) == WAIT_TIMEOUT )
    {
        DPFX(DPFPREP,  0, "ERROR: Timeout waiting for response\n" );
        return DPNERR_TIMEDOUT;
    }

	while( 1 )
	{
		hr = pQueue->GetNextMessage( &dplMsgHeader, pbBuffer, &dwBufferSize );

		if( hr == DPNERR_BUFFERTOOSMALL )
		{
			pbBuffer = new BYTE[dwBufferSize];

			if( !pbBuffer )
			{
				hr = DPNERR_OUTOFMEMORY;
				goto EXIT_ERROR;
			}
		}
		else if( FAILED( hr ) )
		{
			goto EXIT_ERROR;
		}
		else
		{
			break;
		}
	}

    pdplMsgResult = (PDPNSVMSG_RESULT) pbBuffer;

    if( pdplMsgResult == NULL )
	{
		DPFX(DPFPREP,  0, "ERROR: Getting message failed\n");
		hr = DPNERR_GENERIC;
	}
    else
    {
        if( pdplMsgResult->dwType != DPNSVMSGID_RESULT )
        {
            DPFX(DPFPREP,  0, "ERROR: Invalid message type from server [%d]\n", pdplMsgResult->dwType );
			hr = DPNERR_GENERIC;
        }
        else
        {
			hr = pdplMsgResult->hrCommandResult;
        }
    }

EXIT_ERROR:

	if( pbBuffer )
		delete [] pbBuffer;  

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DPNSVR_StartDPNSVR"
HRESULT DPNSVR_StartDPNSVR( )
{
	HANDLE hStartupEvent = NULL;
	HANDLE hRunningHandle = NULL;

	HRESULT hr = DPN_OK;
    STARTUPINFO si;
    PROCESS_INFORMATION	pi;

	// Create / open startup event for the server
	if (DNGetOSType() == VER_PLATFORM_WIN32_NT)
	{
		hStartupEvent = CreateEvent( DNGetNullDacl(), TRUE, FALSE, _T("Global\\") STRING_GUID_DPNSVR_STARTUP );
	}
	else
	{
		hStartupEvent = CreateEvent( DNGetNullDacl(), TRUE, FALSE, STRING_GUID_DPNSVR_STARTUP );
	}

	if( hStartupEvent == NULL )
	{
		hr = GetLastError();

		DPFX(DPFPREP,  0, "Could not create startup event lastError=0x%x", hr );

		goto STARTDPNSVR_CLEANUP;
	}

	// Attempt to open the running event
	if (DNGetOSType() == VER_PLATFORM_WIN32_NT)
	{
		hRunningHandle = OpenEvent( SYNCHRONIZE, FALSE, _T("Global\\") STRING_GUID_DPNSVR_RUNNING );
	}
	else
	{
		hRunningHandle = OpenEvent( SYNCHRONIZE, FALSE, STRING_GUID_DPNSVR_RUNNING );
	}

	if( hRunningHandle != NULL )
	{
		hr = DPNSVR_WaitForStartup(hStartupEvent);
		goto STARTDPNSVR_CLEANUP;
	}

    si.cb = sizeof(STARTUPINFO);
    si.lpReserved = NULL;
    si.lpDesktop = NULL;
    si.lpTitle = NULL;
    si.dwFlags = 0;
    si.cbReserved2 = 0;
    si.lpReserved2 = NULL;

    DPFX(DPFPREP,  3, "Launching DPNSVR" );

    // Put quotes around .exe to prevent possible security problem.
    if( !CreateProcess(NULL, "\"dpnsvr.exe\"",  NULL, NULL, FALSE,
                       NORMAL_PRIORITY_CLASS,
                       NULL, NULL, &si, &pi) )
    {
		hr = GetLastError();

        DPFX(DPFPREP,  2, "Could not create dpnsvr.EXE hr=0x%x", hr );
		goto STARTDPNSVR_CLEANUP;
    }

    DPFX(DPFPREP,  3, "Helper Process created" );

	hr = DPNSVR_WaitForStartup(hStartupEvent);

STARTDPNSVR_CLEANUP:

	if( hStartupEvent != NULL )
		CloseHandle( hStartupEvent );

	if( hRunningHandle != NULL )
		CloseHandle( hRunningHandle );

	return hr;
}

// DPNSVR_Register
//
// This function asks the DPNSVR process to add the application specified to it's list of applications and forward
// enumeration requests from the main port to the specified addresses.
//
// If the DPNSVR process is not running, it will be started by this function.
//
#undef DPF_MODNAME 
#define DPF_MODNAME "DPNSVR_Register"
HRESULT DPNSVR_Register(GUID *const pguidApplication,
						GUID *const pguidInstance,
						IDirectPlay8Address *const prgpDeviceInfo)
{
	HRESULT hr;
	PBYTE pbSendBuffer = NULL;
	DWORD dwSendBufferSize = 0;
	PDPNSVMSG_OPENPORT pdpnOpenPort;
	CDPNSVRIPCQueue appQueue;
	DWORD dwURLSize = 0;
	GUID guidSP;

	hr = prgpDeviceInfo->lpVtbl->GetSP( prgpDeviceInfo, &guidSP );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Specified address does not have an SP specified hr=0x%x", hr );
		return hr;
	}

	hr = prgpDeviceInfo->lpVtbl->GetURLA( prgpDeviceInfo, (CHAR *) pbSendBuffer, &dwURLSize );

	if( hr != DPNERR_BUFFERTOOSMALL )
	{
		DPFX(DPFPREP,  0, "Unable to get URL size from address hr=0x%x", hr );
		return hr;
	}

	dwSendBufferSize = sizeof( DPNSVMSG_OPENPORT ) + dwURLSize;

	pbSendBuffer  = new BYTE[dwSendBufferSize];

	if( pbSendBuffer == NULL )
	{
		DPFX(DPFPREP,  0, "Failed to allocate send buffer for openport hr=0x%x", hr );
		goto CLEANUP;
	}

	// Attempt to launch DPNSVR if it has not yet been launched
	hr = DPNSVR_StartDPNSVR();

	if( FAILED(hr) )
	{
		DPFX(DPFPREP,  0, "Failed to launch DPNSVR hr=0x%x", hr );
		goto CLEANUP;
	}

    hr = appQueue.Open( pguidInstance, DPNSVR_MSGQ_SIZE, 0 );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Failed to open local queue hr=0x%x", hr );
		goto CLEANUP;
	}

	pdpnOpenPort = (PDPNSVMSG_OPENPORT) pbSendBuffer;

	pdpnOpenPort->dwType = DPNSVMSGID_OPENPORT;
	pdpnOpenPort->dwProcessID = GetCurrentProcessId();
	pdpnOpenPort->guidInstance = *pguidInstance;
	pdpnOpenPort->guidApplication = *pguidApplication;
	pdpnOpenPort->guidSP = guidSP;
	pdpnOpenPort->dwAddressSize = dwURLSize;

	hr = prgpDeviceInfo->lpVtbl->GetURLA( prgpDeviceInfo, (char *) &pdpnOpenPort[1], &dwURLSize );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Failed getting URL hr=0x%x", hr );
		goto CLEANUP;
	}

	hr = DPNSVR_SendMessage( pbSendBuffer, dwSendBufferSize );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Failed to send message to server process hr=0x%x", hr );
		goto CLEANUP;
	}

	hr = DPNSVR_WaitForResult( &appQueue );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Failed to wait for server result hr=0x%x", hr );
		goto CLEANUP;
	}

CLEANUP:

	if( pbSendBuffer != NULL )
		delete [] pbSendBuffer;

	appQueue.Close();

	return hr;
}

#undef DPF_MODNAME 
#define DPF_MODNAME "DPNSVR_UnRegister"
HRESULT DPNSVR_UnRegister(GUID *const pguidApplication,
						  GUID *const pguidInstance)
{
	if( !DPNSVR_IsRunning() )
	{
		DPFX(DPFPREP,  0, "DPNSVR is not running" );
		return DPNERR_INVALIDAPPLICATION;
	}

	DPNSVMSG_CLOSEPORT dpnClose;
	HRESULT hr;
	CDPNSVRIPCQueue appQueue;

    hr = appQueue.Open( pguidInstance, DPNSVR_MSGQ_SIZE, 0 );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Failed to open local queue hr=0x%x", hr );
		return hr;
	}

	dpnClose.dwType = DPNSVMSGID_CLOSEPORT;
	dpnClose.dwProcessID = GetCurrentProcessId();
	dpnClose.guidInstance = *pguidInstance;
	dpnClose.guidApplication = *pguidApplication;

	hr = DPNSVR_SendMessage( &dpnClose, sizeof( DPNSVMSG_CLOSEPORT ) );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Failed to send message to server process hr=0x%x", hr );
		goto CLEANUP;
	}

	hr = DPNSVR_WaitForResult( &appQueue );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Failed to wait for server result hr=0x%x", hr );
	}

CLEANUP:

	appQueue.Close();

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DPNSVR_IsRunning"
BOOL DPNSVR_IsRunning()
{
	HANDLE hRunningHandle;

	// Attempt to open the running event
	if (DNGetOSType() == VER_PLATFORM_WIN32_NT)
	{
		hRunningHandle = OpenEvent( SYNCHRONIZE, FALSE, _T("Global\\") STRING_GUID_DPNSVR_RUNNING );
	}
	else
	{
		hRunningHandle = OpenEvent( SYNCHRONIZE, FALSE, STRING_GUID_DPNSVR_RUNNING );
	}

	if( hRunningHandle != NULL )
	{
		CloseHandle(hRunningHandle);
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "DPNSVR_RequestTerminate"
HRESULT DPNSVR_RequestTerminate( GUID *pguidInstance )
{
	if( !DPNSVR_IsRunning() )
	{
		DPFX(DPFPREP,  0, "DPNSVR is not running" );
		return DPNERR_INVALIDAPPLICATION;
	}

	DPNSVMSG_COMMAND dpnCommand = {0};
	HRESULT hr;
	CDPNSVRIPCQueue appQueue;

    hr = appQueue.Open( pguidInstance, DPNSVR_MSGQ_SIZE, 0 );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Failed to open local queue hr=0x%x", hr );
		return hr;
	}

	dpnCommand.dwType = DPNSVMSGID_COMMAND;
	dpnCommand.dwCommand = DPNSVCOMMAND_KILL;
	dpnCommand.dwParam1 = 0;
	dpnCommand.dwParam2 = 0;
	dpnCommand.guidInstance = *pguidInstance;

	hr = DPNSVR_SendMessage( &dpnCommand, sizeof( DPNSVMSG_COMMAND ) );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Failed to send message to server process hr=0x%x", hr );
		goto CLEANUP;
	}

	hr = DPNSVR_WaitForResult( &appQueue );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Failed to wait for server result hr=0x%x", hr );
	}

CLEANUP:

	appQueue.Close();

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DPNSVR_RequestStatus"
HRESULT DPNSVR_RequestStatus( GUID *pguidInstance, PSTATUSHANDLER pStatusHandler, PVOID pvContext )
{
	if( !DPNSVR_IsRunning() )
	{
		DPFX(DPFPREP,  0, "DPNSVR is not running" );
		return DPNERR_INVALIDAPPLICATION;
	}

	DPNSVMSG_COMMAND dpnCommand;
	HRESULT hr;
	CDPNSVRIPCQueue appQueue;
	HANDLE hStatusSharedMemory = NULL;
	PSERVICESTATUS pServerStatus = NULL;
	LONG lRet;
	HANDLE hStatusMutex = NULL;
	BOOL fHaveMutex = FALSE;

    hr = appQueue.Open( pguidInstance, DPNSVR_MSGQ_SIZE, 0 );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Failed to open local queue hr=0x%x", hr );
		return hr;
	}

	dpnCommand.dwType = DPNSVMSGID_COMMAND;
	dpnCommand.dwCommand = DPNSVCOMMAND_STATUS;
	dpnCommand.dwParam1 = 0;
	dpnCommand.dwParam2 = 0;
	dpnCommand.guidInstance = *pguidInstance;

	hr = DPNSVR_SendMessage( &dpnCommand, sizeof( DPNSVMSG_COMMAND ) );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Failed to send message to server process hr=0x%x", hr );
		goto CLEANUP;
	}

	hr = DPNSVR_WaitForResult( &appQueue );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Failed to wait for server result hr=0x%x", hr );
		goto CLEANUP;
	}

	if (DNGetOSType() == VER_PLATFORM_WIN32_NT)
	{
		hStatusMutex = OpenMutex( MUTEX_ALL_ACCESS, FALSE, _T("Global\\") STRING_GUID_DPNSVR_STATUSSTORAGE );
	}
	else
	{
		hStatusMutex = OpenMutex( MUTEX_ALL_ACCESS, FALSE, STRING_GUID_DPNSVR_STATUSSTORAGE );
	}

	if( hStatusMutex == NULL )
	{
		DPFX(DPFPREP,  0, "Server exited before table was retrieved" );
		return DPNERR_INVALIDAPPLICATION;
	}

    WaitForSingleObject( hStatusMutex, INFINITE );
    fHaveMutex = TRUE;

    hStatusSharedMemory = OpenFileMapping(
		FILE_MAP_READ,
        FALSE,
        STRING_GUID_DPNSVR_STATUS_MEMORY
		);

	lRet = GetLastError();

	if (hStatusSharedMemory == NULL)
	{
        DPFX(DPFPREP,  0, "Unable to get server status info hr=[0x%lx] Process may not be running\n", lRet );
		hr = lRet;
		goto CLEANUP;
	}

	pServerStatus = (PSERVICESTATUS) MapViewOfFile(
		hStatusSharedMemory,
		FILE_MAP_READ,
		0,
		0,
		sizeof( SERVICESTATUS ) );

	lRet = GetLastError();

	if (pServerStatus == NULL)
	{
        DPFX(DPFPREP,  0, "Unable to read status hr=[0x%lx] Process may have exited\n", lRet );
		hr = lRet;
		goto CLEANUP;
	}

	(*pStatusHandler)(pServerStatus,pvContext);

CLEANUP:

    if( fHaveMutex )
        ReleaseMutex( hStatusMutex );

    if( hStatusMutex != NULL )
        CloseHandle( hStatusMutex );

	if( pServerStatus != NULL )
		UnmapViewOfFile(pServerStatus);

	if( hStatusSharedMemory != NULL )
	    CloseHandle(hStatusSharedMemory);

	appQueue.Close();

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DPNSVR_RequestTable"
HRESULT DPNSVR_RequestTable( GUID *pguidInstance, PTABLEHANDLER pTableHandler, PVOID pvContext )
{

	if( !DPNSVR_IsRunning() )
	{
		DPFX(DPFPREP,  0, "DPNSVR is not running" );
		return DPNERR_INVALIDAPPLICATION;
	}

	DPNSVMSG_COMMAND dpnCommand;
	HRESULT hr;
	CDPNSVRIPCQueue appQueue;
    PSERVERTABLEHEADER pTableHeader = NULL;
	HANDLE hTableHandle = NULL;
	HANDLE hTableMutex = NULL;
	LONG lRet;
	BOOL fHaveMutex = FALSE;

	if (DNGetOSType() == VER_PLATFORM_WIN32_NT)
	{
		hTableMutex = OpenMutex( MUTEX_ALL_ACCESS, FALSE, _T("Global\\") STRING_GUID_DPSVR_TABLESTORAGE );
	}
	else
	{
		hTableMutex = OpenMutex( MUTEX_ALL_ACCESS, FALSE, STRING_GUID_DPSVR_TABLESTORAGE );
	}

	if( hTableMutex == NULL )
	{
		DPFX(DPFPREP,  0, "Server exited before table was retrieved" );
		return DPNERR_INVALIDAPPLICATION;
	}

    hr = appQueue.Open( pguidInstance, DPNSVR_MSGQ_SIZE, 0 );

	if( FAILED( hr ) )
	{
		CloseHandle(hTableMutex);
		DPFX(DPFPREP,  0, "Failed to open local queue hr=0x%x", hr );
		return hr;
	}

	dpnCommand.dwType = DPNSVMSGID_COMMAND;
	dpnCommand.dwCommand = DPNSVCOMMAND_TABLE;
	dpnCommand.dwParam1 = 0;
	dpnCommand.dwParam2 = 0;
	dpnCommand.guidInstance = *pguidInstance;

	hr = DPNSVR_SendMessage( &dpnCommand, sizeof( DPNSVMSG_COMMAND ) );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Failed to send message to server process hr=0x%x", hr );
		goto CLEANUP;
	}

	hr = DPNSVR_WaitForResult( &appQueue );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Failed to wait for server result hr=0x%x", hr );
		goto CLEANUP;
	}

	// Wait for table mutex
    WaitForSingleObject( hTableMutex, INFINITE );
	fHaveMutex = TRUE;

	// Map the table memory
    hTableHandle = OpenFileMapping(
		FILE_MAP_READ,
        FALSE,
        STRING_GUID_DPNSVR_TABLE_MEMORY
		);

	lRet = GetLastError();

	if (hTableHandle == NULL)
	{
        DPFX(DPFPREP,  0, "Unable to get server status info hr=[0x%lx] Process may not be running\n", lRet );
		hr = lRet;
		goto CLEANUP;
	}

	pTableHeader = (PSERVERTABLEHEADER) MapViewOfFile(
		hTableHandle,
		FILE_MAP_READ,
		0,
		0,
		0 );

	lRet = GetLastError();

	if (pTableHeader == NULL)
	{
        DPFX(DPFPREP,  0, "ERROR: Unable to read table hr=[0x%lx] Process may have exited\n", lRet );
		hr = lRet;
		goto CLEANUP;
	}

	(*pTableHandler)(pTableHeader,pvContext);

CLEANUP:

	if( pTableHeader != NULL )
	{
		UnmapViewOfFile( pTableHeader );
	}

	if( hTableHandle != NULL )
	{
		CloseHandle( hTableHandle );
	}

	if( fHaveMutex )
		ReleaseMutex( hTableMutex );

	if( hTableMutex != NULL )
		CloseHandle( hTableMutex );

	appQueue.Close();

	return hr;


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\dpnsvr\dpnsvlib\dpnsvrq.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DPNSVRQ.h
 *  Content:    DirectPlay8 Server Queues Header
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   03/19/00	rmt		Modified from dplmsgq
 *   04/03/2001	RichGr	Bug #325752 - Improved Queue mutex so opens, updates and closes don't clash.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/


#ifndef	__DPNSVRQ_H__
#define	__DPNSVRQ_H__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_DPNSVR

#define	DPNSVR_MSGQ_SIGNATURE					'QMSD'

//**********************************************************************
// Constant definitions
//**********************************************************************

#define DPNSVR_MSGQ_OBJECT_IDCHAR_FILEMAP	'F'
#define DPNSVR_MSGQ_OBJECT_IDCHAR_MUTEX		'M'
#define DPNSVR_MSGQ_OBJECT_IDCHAR_EVENT		'E'
#define DPNSVR_MSGQ_OBJECT_IDCHAR_EVENT2	'V'
#define DPNSVR_MSGQ_OBJECT_IDCHAR_SEMAPHORE	'S'

//
//	Message Queue Flags
//
#define	DPNSVR_MSGQ_FLAG_AVAILABLE				0x00001
#define	DPNSVR_MSGQ_FLAG_RECEIVING				0x00010

#define DPNSVR_MSGQ_OPEN_FLAG_NO_CREATE		0x10000

//
//	Message Queue File Size
//
#define DPNSVR_MSGQ_SIZE						0x010000

//
//	Internal Message IDs
//
#define	DPNSVR_MSGQ_MSGID_SEND					0x0001
#define	DPNSVR_MSGQ_MSGID_TERMINATE				0x0003
#define DPNSVR_MSGQ_MSGID_IDLE					0x0004

#define DPNSVR_MSGQ_MSGFLAGS_QUEUESYSTEM		0x0001
#define DPNSVR_MSGQ_MSGFLAGS_USER1				0x0002
#define DPNSVR_MSGQ_MSGFLAGS_USER2				0x0004


//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

#pragma pack(push,4)
//
//	Message Queue File Map Info
//
typedef struct _DPNSVR_MSGQ_INFO
{
	DWORD	dwFlags;			// Queue usage flags
	DWORD	dwStartOffset;
	DWORD	dwEndOffset;
	DWORD	dwFreeBytes;
	DWORD	dwQueueSize;
	LONG	lRefCount;			// Number of connections
} DPNSVR_MSGQ_INFO, *PDPNSVR_MSGQ_INFO;


//
//	Message Queue Send Message
//
typedef	struct _DPNSVR_MSGQ_SEND
{
	DWORD		dwCurrentSize;		// Size of this frame (in BYTES)
	DWORD		dwTotalSize;		// Total size of message
	DWORD		dwMsgId;			// Message ID
	DPNHANDLE	hSender;
	DWORD		dwFlags;
	DWORD		dwCurrentOffset;	// Offset of this frame in message
} DPNSVR_MSGQ_HEADER, *PDPNSVR_MSGQ_HEADER;

//
//	Message Queue Terminate Message
//
typedef struct _DPNSVR_MSGQ_TERMINATE
{
	DWORD	dwMsgId;
} DPNSVR_MSGQ_TERMINATE, *PDPNSVR_MSGQ_TERMINATE;

#pragma pack(pop)


//
//	Message Handler Callback
//
typedef HRESULT (*PFNDPNSVRMSGQMESSAGEHANDLER)(DPNHANDLE,const PVOID,DWORD,BYTE *const,const DWORD);

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************

class CDPNSVRIPCQueue
{
public:
	CDPNSVRIPCQueue()
		{
			m_hFileMap = NULL;
			m_hEvent = NULL;
			m_hQueueGUIDMutex = NULL;
			m_hSemaphore = NULL;
			m_pFileMapAddress = NULL;
			m_pInfo = NULL;
			m_pData = NULL;
			m_hSender = NULL;
			m_pfnMessageHandler = NULL;
			m_pvSenderContext = NULL;
			m_hReceiveThreadRunningEvent = NULL;
		};

	~CDPNSVRIPCQueue() { };

	#undef DPF_MODNAME
	#define DPF_MODNAME "CDPNSVRIPCQueue::SetMessageHandler"
	void SetMessageHandler(DPNHANDLE hSender,PFNDPNSVRMSGQMESSAGEHANDLER pfn)
	{
			DNASSERT(pfn != NULL);

			m_hSender = hSender;
			m_pfnMessageHandler = pfn;
		};

	void SetSenderContext(PVOID pvSenderContext)
		{
			m_pvSenderContext = pvSenderContext;
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CDPNSVRIPCQueue::CallMessageHandler"
	HRESULT CallMessageHandler(const PVOID pvSenderContext,
											DWORD dwMessageFlags,
											  BYTE *const pBuffer,
											  const DWORD dwBufferSize)
		{
			DNASSERT(m_pfnMessageHandler != NULL);

			return((m_pfnMessageHandler)(m_hSender,pvSenderContext,dwMessageFlags,pBuffer,dwBufferSize));
		};

    HRESULT Open(const GUID * const pguidQueueName, const DWORD dwQueueSize, const DWORD dwFlags);

	void Close(void);
    void  CloseHandles(void);

	LONG GetRefCount(void)
		{
			DWORD	lRefCount;

			if (m_pInfo == NULL)
				return(0);

			Lock();
			lRefCount = m_pInfo->lRefCount;
			Unlock();

			return(lRefCount);
		};

	HRESULT AddData( BYTE *const pBuffer, const DWORD dwSize );

	HRESULT Send(BYTE *const pBuffer,
								const DWORD dwSize,
								const DWORD dwTimeOut,
								const DWORD dwMessageFlags,
								const DWORD dwFlags);

	#undef DPF_MODNAME
	#define DPF_MODNAME "CDPNSVRIPCQueue::Lock"
	void Lock(void)
		{
			DNASSERT(m_hQueueGUIDMutex != NULL);
			WaitForSingleObject(m_hQueueGUIDMutex,INFINITE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CDPNSVRIPCQueue::Unlock"
	void Unlock(void)
		{
			DNASSERT(m_hQueueGUIDMutex != NULL);
			ReleaseMutex(m_hQueueGUIDMutex);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CDPNSVRIPCQueue::WaitForMessages"
	void WaitForMessages(void)
		{
			DNASSERT(m_hSemaphore != NULL);
			WaitForSingleObject(m_hSemaphore,INFINITE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CDPNSVRIPCQueue::IndicateMessage"
	void IndicateMessage(void)
		{
			DNASSERT(m_hSemaphore != NULL);
			ReleaseSemaphore(m_hSemaphore,1,NULL);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CDPNSVRIPCQueue::WaitForConsumption"
	BOOL WaitForConsumption(const DWORD dwTimeOut)
		{
			DWORD	dwError;

			DNASSERT(m_hEvent != NULL);
			dwError = WaitForSingleObject(m_hEvent,dwTimeOut);
			if (dwError==WAIT_OBJECT_0)
			{
				return(TRUE);
			}
			return(FALSE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CDPNSVRIPCQueue::IndicateConsumption"
	void IndicateConsumption(void)
		{
			DNASSERT(m_hEvent != NULL);
			//SetEvent(m_hEvent);		// Will auto-reset (i.e. pulse)
			ReleaseSemaphore( m_hEvent, 1, NULL );
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CDPNSVRIPCQueue::MakeAvailable"
	void MakeAvailable(void)
		{
			DNASSERT(m_pInfo != NULL);

			Lock();

			m_pInfo->dwFlags |= DPNSVR_MSGQ_FLAG_AVAILABLE;

			Unlock();
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CDPNSVRIPCQueue::MakeUnavailable"
	HRESULT MakeUnavailable(void)
		{

			HRESULT		hResultCode;

			DNASSERT(m_pInfo != NULL);

			Lock();

			if (m_pInfo->dwFlags & DPNSVR_MSGQ_FLAG_AVAILABLE)
			{
				m_pInfo->dwFlags &= (~DPNSVR_MSGQ_FLAG_AVAILABLE);
				hResultCode = DPN_OK;
			}
			else
			{
				hResultCode = DPNERR_ALREADYCONNECTED;
			}

			Unlock();

			return(hResultCode);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CDPNSVRIPCQueue::MakeReceiving"
	void MakeReceiving(void)
		{
			DNASSERT(m_pInfo != NULL);

			Lock();
			m_pInfo->dwFlags |= DPNSVR_MSGQ_FLAG_RECEIVING;
			Unlock();
			SetEvent(m_hReceiveThreadRunningEvent);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CDPNSVRIPCQueue::MakeNotReceiving"
	void MakeNotReceiving(void)
		{
			DNASSERT(m_pInfo != NULL);

			ResetEvent(m_hReceiveThreadRunningEvent);
			Lock();
			m_pInfo->dwFlags &= (~DPNSVR_MSGQ_FLAG_RECEIVING);
			Unlock();
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CDPNSVRIPCQueue::WaitForReceiveThread"
	BOOL WaitForReceiveThread(const DWORD dwTimeOut)
		{
			DWORD	dwError;

			DNASSERT(m_hEvent != NULL);
			dwError = WaitForSingleObject(m_hReceiveThreadRunningEvent,dwTimeOut);
			if (dwError==WAIT_OBJECT_0)
			{
				return(TRUE);
			}
			return(FALSE);
		};

	BOOL IsOpen(void)
		{
			if (m_hFileMap!= NULL)	return(TRUE);
			else					return(FALSE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CDPNSVRIPCQueue::IsAvailable"
	BOOL IsAvailable(void)
		{
			DNASSERT(m_pInfo != NULL);

			if (m_pInfo->dwFlags & DPNSVR_MSGQ_FLAG_AVAILABLE)
				return(TRUE);
			else
				return(FALSE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CDPNSVRIPCQueue::IsReceiving"
	BOOL IsReceiving(void)
		{
			DNASSERT(m_pInfo != NULL);

			if (m_pInfo->dwFlags & DPNSVR_MSGQ_FLAG_RECEIVING)
				return(TRUE);
			else
				return(FALSE);
		};

	HRESULT GetNextMessage( PDPNSVR_MSGQ_HEADER pMsgHeader, PBYTE pbPayload, DWORD *pdwBufferSize );

	void Terminate(void);

    HANDLE GetReceiveSemaphoreHandle() { return m_hSemaphore; };


private:
	// GetData
	//
	// Get dwSize bytes from the queue.  If the queue is empty this function will return
	// DPNERR_DOESNOTEXIST.  Once this function returns the dwSize bytes will be consumed
	//
	// Needs LOCK()
	//
	HRESULT GetData( BYTE *pbData, DWORD dwSize );

	// Consume
	//
	// Marks dwSize bytes as consumed
	//
	// Needs LOCK()
	void Consume( const DWORD dwSize );

	DWORD	            m_dwSig;			// Signature (ensure initialized)
	PBYTE	            m_pFileMapAddress;	// File Mapping address
	DPNSVR_MSGQ_INFO   *m_pInfo;	        // Message queue file mapping info
	PBYTE			    m_pData;			// Message data starts here 
	HANDLE	            m_hReceiveThreadRunningEvent;

	//	Notes:
	//		Each message queue has four shared memory items: file map, mutex, event, semaphore.
	//		The file map is a circular queue of messages.
	//		The mutex controls access to the file map.
	//		The event signals when an item has been taken off the queue by the consumer.
	//		The semaphore indicates to the consumer that there are messages in the queue

	HANDLE	            m_hFileMap;			// File Mapping handle
	HANDLE	            m_hQueueGUIDMutex;	// Mutex handle
	HANDLE	            m_hEvent;			// Event handle
	HANDLE	            m_hSemaphore;		// Semaphore handle

	PFNDPNSVRMSGQMESSAGEHANDLER	 m_pfnMessageHandler;
	DPNHANDLE	        m_hSender;

	PVOID	            m_pvSenderContext;	// For all SEND messages
};

#undef DPF_MODNAME
#undef DPF_SUBCOMP

#endif	// __DPLMSGQ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\dpnsvr\dpnsvlib\dpnsvlib.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       enumsvr.h
 *  Content:    DirectPlay8 <--> DPNSVR Utility functions
 *
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/24/00	rmt		Created
 *  05/30/00    rmt     Bug #33622 DPNSVR does not shutdown when not in use
 *	09/04/00	mjn		Changed DPNSVR_Register() and DPNSVR_UnRegister() to use guids directly (rather than ApplicationDesc)
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __DPNSVLIB_H
#define __DPNSVLIB_H

#define DPNSVR_REGISTER_ATTEMPTS	3
#define DPNSVR_REGISTER_SLEEP		300

BOOL DPNSVR_IsRunning();

HRESULT DPNSVR_WaitForStartup( HANDLE hWaitHandle );
HRESULT DPNSVR_SendMessage( LPVOID pvMessage, DWORD dwSize );
HRESULT DPNSVR_WaitForResult( CDPNSVRIPCQueue *pQueue );
HRESULT DPNSVR_StartDPNSVR( );
HRESULT DPNSVR_Register(GUID *const pguidApplication,
						GUID *const pguidInstance,
						IDirectPlay8Address *const prgpDeviceInfo);
HRESULT DPNSVR_UnRegister(GUID *const pguidApplication,
						  GUID *const pguidInstance);
HRESULT DPNSVR_RequestTerminate( GUID *pguidInstance );
HRESULT DPNSVR_RequestStatus( GUID *pguidInstance, PSTATUSHANDLER pStatusHandler, PVOID pvContext );
HRESULT DPNSVR_RequestTable( GUID *pguidInstance, PTABLEHANDLER pTableHandler, PVOID pvContext );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\dpnsvr\dpnsvr\dpnsvr.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999, 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpnsvr.cpp
 *  Content:    Main file for DPNSVR.EXE
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 * 03/14/00     rodtoll Created it
 * 03/23/00     rodtoll Changed app to windows app + moved command-line help / status
 *                      to message boxes.
 * 03/24/00     rodtoll Updated to make all strings loaded from resource
 * 08/30/2000	rodtoll	Whistler Bug #170675 - PREFIX Bug 
 * 10/30/2000	rodtoll	Bug #46203 - DPNSVR does not call COM_Uninit
 ***************************************************************************/

#include "dnsvri.h"

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_DPNSVR

#undef DPF_MODNAME
#define DPF_MODNAME "WinMain"
int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPTSTR     lpCmdLine,
                     int       nCmdShow)

{
	HRESULT hr;
    CDirectPlayServer8 *pdp8Server = NULL ;
    BOOL fTestMode = FALSE;

    if (DNOSIndirectionInit() == FALSE)
	{
		DPFX(DPFPREP,  0, "Error initializing OS indirection layer");
		goto DPNSVR_ERROR_INIT;
	}

	hr = COM_Init();

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Error initializing COM layer hr=0x%x", hr );
		goto DPNSVR_ERROR_INIT;
	}

    hr = COM_CoInitialize(NULL);

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Error initializing COM hr=0x%x", hr );
		goto DPNSVR_ERROR_INIT;
	}

    if( lstrlen( lpCmdLine ) > 0 )
    {
		DWORD lcid = MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT);
		if (CSTR_EQUAL == CompareString(lcid, NORM_IGNORECASE, lpCmdLine, -1, TEXT("/KILL"), -1))
        {
            (void) CDirectPlayServer8::Request_KillServer();
        }
        else
        {
            goto DPNSVR_MAIN_EXIT;
        }
    }
    else
    {
		pdp8Server = new CDirectPlayServer8();

		if( pdp8Server == NULL )
		{
			DPFX(DPFPREP,  0, "Error out of memory!" );
			goto DPNSVR_ERROR_INIT;
		}

        hr = pdp8Server->Initialize();

        if( FAILED( hr ) )
        {
            DPFX(DPFPREP,  0, "Error initializing server hr=[0x%lx]", hr );
        }
        else
        {
            pdp8Server->WaitForShutdown();
        }
    }

DPNSVR_MAIN_EXIT:

	if( pdp8Server != NULL )
		delete pdp8Server;

DPNSVR_ERROR_INIT:

    COM_CoUninitialize();
	COM_Free();
	
    DNOSIndirectionDeinit();

   	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\dpnsvr\dpnsvlib\dpnsvrq.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DPNSVRQ.cpp
 *  Content:    DirectPlay8 Server Queues Header
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   03/19/00	rmt		Modified from dplmsgq
 *   06/28/2000	rmt		Prefix Bug #38044
 *  07/06/00	rmt		Bug #38111 - Fixed prefix bug
 *   07/21/2000	rmt		Removed assert that wasn't needed
 *   08/05/2000 RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *  08/31/2000	rmt		Prefix Bug #171825, 171828
 *  04/03/2001	RichGr	Bug #325752 - Improved Queue mutex so opens, updates and closes don't clash.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dnsvlibi.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_DPNSVR


//	DirectPlay8Server Message Queues
//
//	We will use shared memory circular message buffers to implement this.
//	Each MsgQ has a set of synchronization objects to control access to the MsgQs.
//	The head of the shared memory file contains state information about the MsgQ:
//		pStartAddress
//		dwTotalUsableSpace
//		dwFirstMsgOffset
//		dwNextFreeOffset
//		dwFreeSpaceAtEnd
//		dwTotalFreeSpace
//	Messages are DWORD aligned in the MsgQ.
//	Each message in the MsgQ has a header:
//		dwMsgId
//		dwCurrentOffset
//		dwCurrentSize
//		dwTotalSize
//	Messages which fit in one frame have dwCurrentSize = dwTotalSize and dwCurrentOffset = 0.
//	Messages over multiple frames have dwCurrentSize < dwTotalSize.


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************




//**********************************************************************
// ------------------------------
//	CDPNSVRIPCQueue::Open
//
//	Entry:	const DWORD		dwPID			Id associated with this queue (user supplied)
//			const CHAR		cSuffix			Suffix character associated with this Q (user supp.)
//			const DWORD		dwQueueSize		Size of file map to use when implementing msg queue
//			const DWORD		dwFlags			TBA
//
//	Exit:		HRESULT:	DPN_OK		If able to open an existing message queue,
//											or create a message queue if one didn't exist
//							DPNERR_OUTOFMEMORY
// ------------------------------

// String of GUID in length
#define QUEUE_NAME_LENGTH       64

#undef DPF_MODNAME
#define DPF_MODNAME "CDPNSVRIPCQueue::Open"

HRESULT CDPNSVRIPCQueue::Open(const GUID * const pguidQueueName,const DWORD dwQueueSize,const DWORD dwFlags)
{
	HRESULT		hResultCode;
    DWORD       dwRet = 0;
	BOOL		bQueueExists = FALSE;
	DWORD		dwFileMapSize;
    TCHAR       szObjectName[QUEUE_NAME_LENGTH];
	TCHAR*		pszCursor = szObjectName;

	DPFX(DPFPREP, 3,"Parameters: dwQueueSize [%d], dwFlags [0x%x]",
			dwQueueSize,dwFlags);

	if (DNGetOSType() == VER_PLATFORM_WIN32_NT)
	{
		_tcscpy(pszCursor, _T("Global\\"));
		pszCursor += _tcslen(_T("Global\\"));
	}

    // Build GUID string name 
    wsprintf( 
    	pszCursor, 
    	"{%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}", 
    	pguidQueueName->Data1, 
    	pguidQueueName->Data2, 
    	pguidQueueName->Data3, 
        pguidQueueName->Data4[0], 
        pguidQueueName->Data4[1], 
        pguidQueueName->Data4[2], 
        pguidQueueName->Data4[3],
        pguidQueueName->Data4[4], 
        pguidQueueName->Data4[5], 
        pguidQueueName->Data4[6], 
        pguidQueueName->Data4[7] );

	DPFX(DPFPREP, 5, "Shared object name [%s]", szObjectName);

    // If there is no mutex, it is created.  If it already exists, we get a handle to it.
	*pszCursor = DPNSVR_MSGQ_OBJECT_IDCHAR_MUTEX;
	m_hQueueGUIDMutex = CreateMutex(DNGetNullDacl(), FALSE, szObjectName);
    if (m_hQueueGUIDMutex == NULL)
    {
   	    DPFERR("CreateMutex() failed" );
		hResultCode = DPNERR_OUTOFMEMORY;
        goto Failure;
    }

    // Wait for the mutex.
    dwRet = WaitForSingleObject(m_hQueueGUIDMutex, INFINITE);

    if (dwRet != WAIT_ABANDONED && dwRet != WAIT_OBJECT_0)
    {
   	    DPFERR("WaitForSingleObject() failed" );
		hResultCode = DPNERR_GENERIC;
        goto Failure;
    }

	// Create Receive Thread Running Event
	//	This will be set by the receive thread once it has spun up.  We need it for synchronization
	m_hReceiveThreadRunningEvent = CreateEvent(NULL,TRUE,FALSE,NULL);
	if (m_hReceiveThreadRunningEvent == NULL)
	{
		DPFERR("Could not create receive thread");
		hResultCode = DPNERR_OUTOFMEMORY;
		goto Failure;
	}


	// Set the filemap size big enough that the largest message (text) will be dwQueueSize
	// so we add on the MsgQ info structure at the front and 1 Msg header
	dwFileMapSize = dwQueueSize + sizeof(DPNSVR_MSGQ_INFO) + sizeof(DPNSVR_MSGQ_HEADER);
	dwFileMapSize = (dwFileMapSize + 3) & 0xfffffffc;	// DWORD align

	// Create File Mapping Object
	*pszCursor = DPNSVR_MSGQ_OBJECT_IDCHAR_FILEMAP;
	m_hFileMap = CreateFileMapping((HANDLE)INVALID_HANDLE_VALUE,DNGetNullDacl(),
		PAGE_READWRITE,(DWORD)0,dwQueueSize,szObjectName);
	if (m_hFileMap == NULL)
	{
		DPFERR("CreateFileMapping() failed");
		hResultCode = DPNERR_GENERIC;
		goto Failure;
	}
	if (GetLastError() == ERROR_ALREADY_EXISTS)
		bQueueExists = TRUE;

	if ((dwFlags & DPNSVR_MSGQ_OPEN_FLAG_NO_CREATE) && !bQueueExists)
	{
		DPFERR("Open existing queue failed - does not exist");
		hResultCode = DPNERR_DOESNOTEXIST;
		goto Failure;
	}

	// Map file
	m_pFileMapAddress = reinterpret_cast<BYTE*>(MapViewOfFile(m_hFileMap,FILE_MAP_ALL_ACCESS,0,0,0));
	if (m_pFileMapAddress == NULL)
	{
		DPFERR("MapViewOfFile() failed");
		hResultCode = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	// Create semaphore object
	*pszCursor = DPNSVR_MSGQ_OBJECT_IDCHAR_SEMAPHORE;
	m_hSemaphore = CreateSemaphore(DNGetNullDacl(),0,
		(dwQueueSize/sizeof(DPNSVR_MSGQ_HEADER))+1,szObjectName);
	if (m_hSemaphore == NULL)
	{
		DPFERR("CreateSemaphore() failed");
		hResultCode = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	// Create another semaphore (was an event, but we want to make sure we don't miss any).
	*pszCursor = DPNSVR_MSGQ_OBJECT_IDCHAR_EVENT;
	m_hEvent = CreateSemaphore( DNGetNullDacl(), 0, (dwQueueSize/sizeof(DPNSVR_MSGQ_HEADER))+1, szObjectName );

	if( m_hEvent == NULL )
	{
		DPFERR( "CreateSemaphore() failed" );
		hResultCode = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	// Update structure elements
	m_pInfo = reinterpret_cast<DPNSVR_MSGQ_INFO*>(m_pFileMapAddress);

	// Initialize msg queue if it didn't exist
	if ( !bQueueExists)
	{
		m_pInfo->dwFlags = dwFlags & 0x0000ffff;	// Just last two bytes
		m_pInfo->dwStartOffset = 0;
		m_pInfo->dwEndOffset = 0;
		m_pInfo->dwQueueSize = dwQueueSize - sizeof(DPNSVR_MSGQ_INFO);
		m_pInfo->dwFreeBytes = m_pInfo->dwQueueSize;
		m_pInfo->lRefCount = 0;
	}

	m_pData = (BYTE *) &m_pInfo[1];
	m_dwSig = DPNSVR_MSGQ_SIGNATURE;

	// Increment user count
	m_pInfo->lRefCount++;

    ReleaseMutex(m_hQueueGUIDMutex);

	// If we made it this far, everything was okay
	hResultCode = DPN_OK;

Exit:

	DPFX(DPFPREP, 3, "Returning: [0x%lx]", hResultCode);
	return hResultCode;

Failure:

	// There was a problem - close handles
	DPFERR("Errors encountered - closing");

    CloseHandles();

    if (m_hQueueGUIDMutex)
    {    
        ReleaseMutex(m_hQueueGUIDMutex);
        CloseHandle(m_hQueueGUIDMutex);
        m_hQueueGUIDMutex = NULL;
    }


    goto Exit;
}


//**********************************************************************
// ------------------------------
//	CDPNSVRIPCQueue::Close
//
//	Entry:		Nothing
//
//	Exit:		Nothing
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "CDPNSVRIPCQueue::Close"

void CDPNSVRIPCQueue::Close(void)
{
    DWORD       dwRet = 0;


	DPFX(DPFPREP, 3,"Parameters: (none)");

    // Wait for mutex to be signalled.
    if (m_hQueueGUIDMutex)
    {    
        dwRet = WaitForSingleObject(m_hQueueGUIDMutex, INFINITE);

        if (dwRet != WAIT_ABANDONED && dwRet != WAIT_OBJECT_0)
        {
   	        DPFERR("WaitForSingleObject() failed" );
            return;
        }
    }

    CloseHandles();

    if (m_hQueueGUIDMutex)
    {    
        ReleaseMutex(m_hQueueGUIDMutex);
        CloseHandle(m_hQueueGUIDMutex);
        m_hQueueGUIDMutex = NULL;
    }

	DPFX(DPFPREP, 3,"Returning");
    return;
}


//**********************************************************************
// ------------------------------
//	CDPNSVRIPCQueue::CloseHandles
//
//	Entry:		Nothing
//
//	Exit:		Nothing
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "CDPNSVRIPCQueue::CloseHandles"

void  CDPNSVRIPCQueue::CloseHandles()
{

	DPFX(DPFPREP, 3, "Parameters: (none)");

	if( m_pInfo != NULL )
	{
		// Decrement user count
		m_pInfo->lRefCount--;
	
        // If the RefCount on the memory-mapped Queue object is 0, then no-one else
        // has it open and we can mark the signature and set the rest of the header info to zero. 
        if (m_pInfo->lRefCount == 0)
        {
		    DPFX(DPFPREP, 5, "Finished with memory-mapped Queue object - clear it");
		    m_pInfo->dwFlags = 0;
		    m_pInfo->dwStartOffset = 0;
		    m_pInfo->dwEndOffset = 0;
		    m_pInfo->dwQueueSize = 0;
		    m_pInfo->dwFreeBytes = 0;
        }
	}

	if (m_hEvent != NULL)
	{
		DPFX(DPFPREP, 5,"Close Event [0x%p]",m_hEvent);
		CloseHandle(m_hEvent);
		m_hEvent = NULL;
	}

	if (m_hSemaphore != NULL)
	{
		DPFX(DPFPREP, 5,"Close Semaphore [0x%p]",m_hSemaphore);
		CloseHandle(m_hSemaphore);
		m_hSemaphore = NULL;
	}

	if (m_pFileMapAddress != NULL)
	{
		DPFX(DPFPREP, 5,"UnMap View of File [0x%p]",m_pFileMapAddress);
		UnmapViewOfFile(m_pFileMapAddress);
		m_pFileMapAddress = NULL;
	}

	if (m_hFileMap != NULL)
	{
		DPFX(DPFPREP, 5,"Close FileMap [0x%p]",m_hFileMap);
		CloseHandle(m_hFileMap);
		m_hFileMap = NULL;
	}

	if (m_hReceiveThreadRunningEvent != NULL)
	{
		DPFX(DPFPREP, 5,"Close Event [0x%p]",m_hReceiveThreadRunningEvent);
		CloseHandle(m_hReceiveThreadRunningEvent);
		m_hReceiveThreadRunningEvent = NULL;
	}

	m_pInfo = NULL;

	DPFX(DPFPREP, 3, "Returning");

    return;
}


//**********************************************************************
// ------------------------------
//	CDPNSVRIPCQueue::Terminate
//
//	Entry:		Nothing
//
//	Exit:		Nothing
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "CDPNSVRIPCQueue::Terminate"

void CDPNSVRIPCQueue::Terminate(void)
{
	DWORD	dwMsgId = DPNSVR_MSGQ_MSGID_TERMINATE;
	BOOL	bDone = FALSE;

	DPFX(DPFPREP, 3,"Parameters: (none)");

	DNASSERT(m_pInfo != NULL);

	while (!bDone)
	{
		// Wait until there's enough space for the message
		while (sizeof(DWORD) > m_pInfo->dwFreeBytes)
			WaitForConsumption(INFINITE);

		Lock();

		// Ensure there is space once we get the lock
		// (someone else might have beaten us here)
		if (sizeof(DWORD) <= m_pInfo->dwFreeBytes)
		{
			AddData(reinterpret_cast<BYTE*>(&dwMsgId),sizeof(DWORD));
			bDone = TRUE;

			IndicateMessage();
		}

		Unlock();
	}

	DPFX(DPFPREP, 3,"Returning");
}


// GetNextMessage
//
// Attempts to retrieve the next message from the queue
//
// pMsgHeader must be large enough to hold a message header.
//
// If no message is present in the queue then this function fills pMsgHeader with an
// idle message header
//
HRESULT CDPNSVRIPCQueue::GetNextMessage( PDPNSVR_MSGQ_HEADER pMsgHeader, BYTE *pbPayload, DWORD *pdwBufferSize )
{
	HRESULT hr;

	Lock();

	hr = GetData( (BYTE *) pMsgHeader, sizeof( DPNSVR_MSGQ_HEADER ) );

	// If there is no header on the queue fill in the header with an 
	// idle message
	if( hr == DPNERR_DOESNOTEXIST )
	{
		pMsgHeader->dwCurrentSize = sizeof( DPNSVR_MSGQ_HEADER );
		pMsgHeader->dwTotalSize = sizeof( DPNSVR_MSGQ_HEADER );
		pMsgHeader->dwMsgId = DPNSVR_MSGQ_MSGID_IDLE;
		pMsgHeader->hSender = 0;
		pMsgHeader->dwFlags = DPNSVR_MSGQ_MSGFLAGS_QUEUESYSTEM;
		pMsgHeader->dwCurrentOffset = 0;

		Unlock();

		return DPN_OK;
	}
	//// DEBUG
	else if( FAILED( hr ) )
	{
		DNASSERT( FALSE );
	}
	else if( pMsgHeader->dwMsgId == 0xFFFFFFFF )
	{
		DNASSERT( FALSE );
	}

	DWORD dwPayloadSize = pMsgHeader->dwCurrentSize;

	// Otherwise it's a valid message of some kind
	if( *pdwBufferSize < dwPayloadSize || pbPayload == NULL )
	{
		*pdwBufferSize = dwPayloadSize;
		Unlock();
		return DPNERR_BUFFERTOOSMALL;
	}

	*pdwBufferSize = dwPayloadSize;

	Consume( sizeof(DPNSVR_MSGQ_HEADER) );

	// There is no payload, only a header.  Return here.
	if( dwPayloadSize == 0 )
	{
		Unlock();
		return DPN_OK;
	}

	hr = GetData( pbPayload, dwPayloadSize );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Error getting IPC queue message payload" );
		DNASSERT( FALSE );
		Unlock();
		return hr;
	}

	Consume( dwPayloadSize );
	
	Unlock();

	return DPN_OK;
}

// Consume
//
// Marks dwSize bytes as consumed
//
// Needs LOCK()
void CDPNSVRIPCQueue::Consume( const DWORD dwSize )
{
	DWORD dwAlignedSize = (dwSize + 3) & (~0x3);

	m_pInfo->dwStartOffset += dwAlignedSize;

	if( m_pInfo->dwStartOffset >= m_pInfo->dwQueueSize )
	{
		m_pInfo->dwStartOffset -= m_pInfo->dwQueueSize;
	}

	m_pInfo->dwFreeBytes += dwAlignedSize;

	DNASSERT( m_pInfo->dwFreeBytes <= m_pInfo->dwFreeBytes );

	IndicateConsumption();
}

// GetData
//
// Get dwSize bytes from the queue.  If the queue is empty this function will return
// DPNERR_DOESNOTEXIST.  Once this function returns the dwSize bytes will be consumed
//
// REQUIRES LOCK
//
HRESULT CDPNSVRIPCQueue::GetData( BYTE *pbData, DWORD dwSize )
{
	if( m_pInfo->dwQueueSize == m_pInfo->dwFreeBytes )
	{
		return DPNERR_DOESNOTEXIST;
	}

	if( pbData == NULL )
	{
		return DPNERR_BUFFERTOOSMALL;
	}

	// Calculate aligned size 
	DWORD dwAlignedSize = (dwSize + 3) & (~0x3);

	// Data block we want is wrapped
	if( m_pInfo->dwStartOffset+dwAlignedSize > m_pInfo->dwQueueSize )
	{
		DWORD cbBytesLeft = m_pInfo->dwQueueSize - m_pInfo->dwStartOffset;
		DWORD cbSecondBlockAligned = dwAlignedSize - (cbBytesLeft);
		DWORD cbSecondBlock = dwSize - (cbBytesLeft);

		DNASSERT( dwAlignedSize > cbBytesLeft);

		memcpy( pbData, m_pData + m_pInfo->dwStartOffset, cbBytesLeft);
		memcpy( pbData + cbBytesLeft, m_pData , cbSecondBlock );
	}
	// Data block is contiguous
	else
	{
		memcpy( pbData, m_pData + m_pInfo->dwStartOffset, dwSize );
	}		

	return DPN_OK;
}


//**********************************************************************
// ------------------------------
//	CMessageQueue::AddData
//
//	Entry:		BYTE *const pBuffer
//				const DWORD dwSize
//
//	Exit:		HRESULT
// ------------------------------
//
// REQUIRES LOCK!!
//
#undef DPF_MODNAME
#define DPF_MODNAME "CMessageQueue::AddData"

HRESULT CDPNSVRIPCQueue::AddData(BYTE *const pBuffer,
							   const DWORD dwSize)
{
	HRESULT		hResultCode;
	DWORD		dwAlignedSize;

	DPFX(DPFPREP, 3,"Parameters: pBuffer [0x%p], dwSize [%ld]",pBuffer,dwSize);

	dwAlignedSize = (dwSize + 3) & (~0x3);

	// Check to ensure there is space
	if( dwAlignedSize > m_pInfo->dwFreeBytes )
	{
		hResultCode = DPNERR_BUFFERTOOSMALL;
		goto Exit;
	}

	// We have a wrapping condition
	if( (m_pInfo->dwEndOffset+dwAlignedSize) > m_pInfo->dwQueueSize )
	{
		DWORD cbBytesLeft = m_pInfo->dwQueueSize - m_pInfo->dwEndOffset;
		DWORD cbSecondBlockAligned = dwAlignedSize - cbBytesLeft;
		DWORD cbSecondBlock = dwSize - cbBytesLeft;

		DNASSERT( dwAlignedSize > cbBytesLeft );

		memcpy( m_pData + m_pInfo->dwEndOffset, pBuffer, cbBytesLeft );
		memcpy( m_pData, pBuffer + cbBytesLeft, cbSecondBlock );

		m_pInfo->dwEndOffset = cbSecondBlockAligned;
	}
	// Queue is in the middle
	else
	{
		memcpy( m_pData + m_pInfo->dwEndOffset, pBuffer, dwSize );
		m_pInfo->dwEndOffset += dwAlignedSize;
	}

	m_pInfo->dwFreeBytes -= dwAlignedSize;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//**********************************************************************
// ------------------------------
//	CDPNSVRIPCQueue::Send
//
//	Entry:		BYTE *const pBuffer
//				const DWORD dwSize
//				const DWORD dwFlags
//
//	Exit:		HRESULT
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "CDPNSVRIPCQueue::Send"

HRESULT CDPNSVRIPCQueue::Send(BYTE *const pBuffer,
							const DWORD dwSize,
							const DWORD dwTimeOut,
							const DWORD dwMsgFlags,
							const DWORD dwFlags)
{
	HRESULT			hResultCode;
	DWORD			dwMsgSize;		// DWORD aligned
	DWORD			dwTotalMsgSize;	// Msg + Header - DWORD aligned
	DPNSVR_MSGQ_HEADER	Header;
	BOOL			bDone;
	DWORD			dwTimeRemaining;
	DWORD			dwTimeStart;
	DWORD			dwTimeFinish;

	DPFX(DPFPREP, 3,"Parameters: pBuffer [0x%p], dwSize [%ld], dwFlags [0x%lx]",pBuffer,dwSize,dwFlags);

	dwTimeRemaining = dwTimeOut;

	// Need DWORD aligned size
	dwMsgSize = (dwSize + 3) & 0xfffffffc;
	dwTotalMsgSize = dwMsgSize + sizeof(DPNSVR_MSGQ_HEADER);

	// Place the message into the MsgQ
	// Check to see if fragmentation is required
	// If we're at the end of the MsgQ and there isn't enough space for a Msg Header, REALIGN
	if (dwTotalMsgSize <= m_pInfo->dwQueueSize)
	{
		DPFX(DPFPREP, 5,"Message does not need to be fragmented");

		Header.dwMsgId = DPNSVR_MSGQ_MSGID_SEND;
		Header.dwCurrentOffset = 0;
		Header.dwCurrentSize = dwSize;
		Header.dwTotalSize = dwSize;
		Header.hSender = m_hSender;
		Header.dwFlags = dwMsgFlags;

		bDone = FALSE;

		while ( !bDone)
		{
			// Wait until there's enough space for the message
			while (dwTotalMsgSize > m_pInfo->dwFreeBytes)
			{
				if (dwTimeOut != INFINITE)
				{
					dwTimeStart = GETTIMESTAMP();
				}

				if (!WaitForConsumption(dwTimeRemaining))
				{
					return(DPNERR_TIMEDOUT);
				}

				if (dwTimeOut != INFINITE)
				{
					dwTimeFinish = GETTIMESTAMP();
					if ((dwTimeFinish - dwTimeStart) > dwTimeRemaining)
					{
						return(DPNERR_TIMEDOUT);
					}
					dwTimeRemaining -= (dwTimeFinish - dwTimeStart);
				}
			}

			Lock();

			// Ensure there is space once we get the lock
			// (someone else might have beaten us here)
			if (dwTotalMsgSize <= m_pInfo->dwFreeBytes)
			{
				AddData(reinterpret_cast<BYTE*>(&Header),sizeof(DPNSVR_MSGQ_HEADER));
				AddData(pBuffer,dwSize);
				bDone = TRUE;

				IndicateMessage();
			}

			Unlock();
			hResultCode = DPN_OK;
		}
	}
	else
	{
		DPFX(DPFPREP, 5,"Message needs to be fragmented");
		DNASSERT(FALSE);
#pragma TODO(a-minara,"Implement this")
		hResultCode = DPNERR_GENERIC;
	}


	DPFX(DPFPREP, 3,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\dpnsvr\dpnsvr\dpsvr8.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999, 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpsvr8.h
 *  Content:    DirectPlay8 Server Object
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 * 03/14/00     rodtoll Created it
 * 03/23/00     rodtoll Removed local requests, updated to use new data sturctures
 * 03/24/00		rodtoll	Removed printf
 * 03/25/00     rodtoll Updated so uses SP caps to determine which SPs to load
 *              rodtoll Now supports N SPs and only loads those supported
 * 05/09/00     rodtoll Bug #33622 DPNSVR.EXE does not shutdown when not in use
 * 06/28/2000	rmt		Prefix Bug #38044
 * 07/09/2000	rmt		Added guard bytes
 * 09/01/2000	masonb	Modified ServerThread to call _endthread to clean up thread handle
 * 01/22/2001	rodtoll	WINBUG #290103 - Crash due to initialization error.  
 * 04/04/2001	RichGr	Bug #349042 - Clean up properly if EnumerateAndBuildServiceList() fails.
 *
 ***************************************************************************/

#include "dnsvri.h"

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_DPNSVR

#define DPNSVR_TIMEOUT_SHUTDOWN     600000


#undef DPF_MODNAME
#define DPF_MODNAME "CDirectPlayServer8::CDirectPlayServer8"
CDirectPlayServer8::CDirectPlayServer8(
    ):  m_dwSignature( DPNSVRSIGNATURE_SERVEROBJECT ),
		m_pMappedServerStatus(NULL),
        m_hMappedFile(NULL),
        m_hShutdown(NULL),
        m_hTableMutex(NULL),
        m_hStatusMutex(NULL),
        m_dwTableSize(0),
        m_hTableMappedFile(NULL),
        m_pMappedTable(NULL),
        m_fInitialized(FALSE),
        m_hCanBeOnlyOne(NULL),
		m_fShutdownSignal(FALSE),
		m_hWaitStartup(NULL),
		m_dwNumServices(0),m_dwSizeStatusBlock(0)
{
    m_dwStartTicks = GetTickCount();
	ResetActivity();
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectPlayServer8::~CDirectPlayServer8"
CDirectPlayServer8::~CDirectPlayServer8()
{
    CBilink *pblSearch;
    CProcessAppList *pAppList;

    // Close our handle to the can be only one event
    // This allows quick startup of next instance
    if( m_hCanBeOnlyOne != NULL )
        CloseHandle( m_hCanBeOnlyOne );

	if( m_hWaitStartup != NULL )
		CloseHandle( m_hWaitStartup);

	if( m_fInitialized )
	{
		// Destroy running services
		pblSearch = m_blServices.GetNext();
		while( pblSearch != &m_blServices )
		{
			pAppList = CONTAINING_RECORD( pblSearch, CProcessAppList, m_blServices );
			pblSearch->RemoveFromList();
			delete pAppList;
			pblSearch = m_blServices.GetNext();
		}

		if( m_fInitialized )
		{
			m_qServer.Close();
			m_pProcessAppEntryPool.Deinitialize();
		}
	}

	if( m_pMappedServerStatusHeader != NULL )
		UnmapViewOfFile( m_pMappedServerStatusHeader );


    if( m_pMappedTable != NULL )
        UnmapViewOfFile( m_pMappedTable );

    if( m_hMappedFile != NULL )
        CloseHandle( m_hMappedFile );

    if( m_hTableMappedFile != NULL )
        CloseHandle( m_hTableMappedFile );

    if( m_hShutdown != NULL )
        CloseHandle( m_hShutdown );

    if( m_hTableMutex != NULL )
        CloseHandle( m_hTableMutex );

    if( m_hStatusMutex != NULL )
        CloseHandle( m_hStatusMutex );

	m_dwSignature = DPNSVRSIGNATURE_SERVEROBJECT_FREE;

}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectPlayServer8::Request_KillServer"
HRESULT CDirectPlayServer8::Request_KillServer( )
{
	HRESULT hr;
	GUID guidTmp;

	hr = CoCreateGuid( &guidTmp );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Error generating GUID hr=0x%x", hr );
		return hr;
	}

    return DPNSVR_RequestTerminate( &guidTmp );
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectPlayServer8::Command_Status"
HRESULT CDirectPlayServer8::Command_Status()
{
    CBilink *pblSearch;
    CProcessAppList *pProcAppList;

    DPFX(DPFPREP,  5, "Building status info in memory..." );
    DPFX(DPFPREP,  5, "Waiting for guard.." );

    // Grab the table mutex
    WaitForSingleObject( m_hStatusMutex, INFINITE );

    pblSearch = m_blServices.GetNext();

    for( DWORD dwProvider = 0; dwProvider < m_dwNumServices; dwProvider++ )
    {
        pProcAppList = CONTAINING_RECORD( pblSearch, CProcessAppList, m_blServices );

        m_pMappedServerStatus[dwProvider].guidSP = *(pProcAppList->GetSPGuid());
        m_pMappedServerStatus[dwProvider].dwNumNodes = pProcAppList->GetNumNodes();
        m_pMappedServerStatus[dwProvider].dwEnumRequests = pProcAppList->GetNumEnumRequests();
        m_pMappedServerStatus[dwProvider].dwConnectRequests = pProcAppList->GetNumConnectRequests();
        m_pMappedServerStatus[dwProvider].dwDisconnectRequests = pProcAppList->GetNumDisconnectRequests();
        m_pMappedServerStatus[dwProvider].dwDataRequests = pProcAppList->GetNumDataRequests();
        m_pMappedServerStatus[dwProvider].dwEnumReplies = pProcAppList->GetNumEnumReplies();
        m_pMappedServerStatus[dwProvider].dwEnumRequestBytes = pProcAppList->GetNumEnumRequestBytes();

        pblSearch = pblSearch->GetNext();
    }

    ReleaseMutex( m_hStatusMutex );

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectPlayServer8::Command_Table"
HRESULT CDirectPlayServer8::Command_Table()
{
    DWORD dwBytesRequired = 0;
    PBYTE pbCurrentLocation = NULL;
    DWORD dwLastError;
    HRESULT hr;
    CProcessAppList *pProcAppList;
    CBilink *pblSearch;

    DPFX(DPFPREP,  5, "Building table in memory..." );
    DPFX(DPFPREP,  5, "Waiting for guard.." );

    // Grab the table mutex
    WaitForSingleObject( m_hTableMutex, INFINITE );

    pblSearch = m_blServices.GetNext();

    dwBytesRequired = sizeof( DWORD );

    // Determine required size.
    while( pblSearch != &m_blServices )
    {
        pProcAppList = CONTAINING_RECORD( pblSearch, CProcessAppList, m_blServices );

        pProcAppList->Lock();
        dwBytesRequired += pProcAppList->GetTableSizeBytes();

        pblSearch = pblSearch->GetNext();
    }

    // Current buffer is not large enough
    //
    // Allocate a new global buffer for the table
    if( dwBytesRequired > m_dwTableSize )
    {
        if( m_pMappedTable != NULL )
        {
            UnmapViewOfFile( m_pMappedTable );
            m_pMappedTable = NULL;
        }

        if( m_hTableMappedFile != NULL )
        {
            CloseHandle( m_hTableMappedFile );
            m_hTableMappedFile = NULL;
        }

		if (DNGetOSType() == VER_PLATFORM_WIN32_NT)
		{
			m_hTableMappedFile = CreateFileMapping( INVALID_HANDLE_VALUE, DNGetNullDacl(), PAGE_READWRITE,
											   0, dwBytesRequired, _T("Global\\") STRING_GUID_DPNSVR_TABLE_MEMORY );
		}
		else
		{
			m_hTableMappedFile = CreateFileMapping( INVALID_HANDLE_VALUE, DNGetNullDacl(), PAGE_READWRITE,
											   0, dwBytesRequired, STRING_GUID_DPNSVR_TABLE_MEMORY );
		}

        if( m_hTableMappedFile == NULL )
        {
            dwLastError = GetLastError();

            DPFX(DPFPREP,  0, "Error initializing table memory block lasterr=[0x%lx]", dwLastError );

            hr = dwLastError;

            goto COMMANDTABLE_ERROR;
        }

        m_pMappedTable = (PBYTE) MapViewOfFile( m_hTableMappedFile, FILE_MAP_READ | FILE_MAP_WRITE,
                                                               0, 0, dwBytesRequired );

        dwLastError = GetLastError();

        if( m_pMappedTable == NULL )
        {
            DPFX(DPFPREP,  0, "Error initializing table mem blockview lasterr=[0x%lx]", dwLastError );

            hr = dwLastError;

            goto COMMANDTABLE_ERROR;
        }

        m_dwTableSize = dwBytesRequired;
    }

    pbCurrentLocation = m_pMappedTable;
    *((DWORD *) pbCurrentLocation) = m_dwNumServices;
    pbCurrentLocation += sizeof(DWORD);

    pblSearch = m_blServices.GetNext();

    // Determine required size.
    while( pblSearch != &m_blServices )
    {
        pProcAppList = CONTAINING_RECORD( pblSearch, CProcessAppList, m_blServices );

        pProcAppList->CopyTable( pbCurrentLocation );
        pbCurrentLocation += pProcAppList->GetTableSizeBytes();
        pProcAppList->UnLock();

        pblSearch = pblSearch->GetNext();
    }

    ReleaseMutex( m_hTableMutex );

    DPFX(DPFPREP,  5, "Wrote table\n" );

    return DPN_OK;

COMMANDTABLE_ERROR:

    if( m_pMappedTable != NULL )
    {
        UnmapViewOfFile( m_pMappedTable );
        m_pMappedTable = NULL;
    }

    if( m_hTableMappedFile != NULL )
    {
        CloseHandle( m_hTableMappedFile );
        m_hTableMappedFile = NULL;
    }

    pblSearch = m_blServices.GetNext();

    // Determine required size.
    while( pblSearch != &m_blServices )
    {
        pProcAppList = CONTAINING_RECORD( pblSearch, CProcessAppList, m_blServices );

        pProcAppList->UnLock();

        pblSearch = pblSearch->GetNext();
    }

    ReleaseMutex( m_hTableMutex );

    DPFX(DPFPREP,  0, "Wrote table\n" );

    return hr;
}

HRESULT WINAPI CDirectPlayServer8::DummyMessageHandler( PVOID pvContext, DWORD dwMessageType, PVOID pvMessage )
{
	return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CDirectPlayServer8::EnumerateAndBuildServiceList"
HRESULT  CDirectPlayServer8::EnumerateAndBuildServiceList()
{
    PDIRECTPLAY8PEER            pdp8Peer = NULL;
    HRESULT                     hr = DPN_OK;
    PDPN_SERVICE_PROVIDER_INFO  pSPInfo = NULL;
    DPN_SP_CAPS                 dpspCaps = {0};
    DWORD                       dwSPInfoSize = 0;
    DWORD                       dwSPCount = 0;
	DWORD                       dwProvider = 0;
    PBYTE                       pbEnumBuffer = NULL;
	BOOL                        fInited = FALSE;
    CProcessAppList            *pAppEntry = NULL;
    CBilink                    *pblSearch = NULL;


    m_dwNumServices = 0;
    // This should be empty.
    DNASSERT(m_blServices.IsEmpty());
    
	hr = COM_CoCreateInstance( CLSID_DirectPlay8Peer, NULL, CLSCTX_INPROC_SERVER, IID_IDirectPlay8Peer, (void **) &pdp8Peer );

	if( FAILED( hr ) || pdp8Peer == NULL )
	{
	    DPFX(DPFPREP,  0, "Could not create a DPlay8 object to get Service Provider list hr=0x%x", hr );
	    goto Failure;
	}

	hr = pdp8Peer->Initialize( NULL, DummyMessageHandler, 0 );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Could not initialize DPlay8 hr=0x%x", hr );
		goto Failure;
	}

	fInited = TRUE;

	hr = pdp8Peer->EnumServiceProviders( NULL, NULL, pSPInfo, &dwSPInfoSize, &dwSPCount, 0 );

	if ( hr != DPNERR_BUFFERTOOSMALL || dwSPInfoSize == 0 )
	{
	    DPFX(DPFPREP,  0, "Could not enumerate Service Providers hr=0x%x", hr );
	    goto Failure;
	}

	pbEnumBuffer = new BYTE[dwSPInfoSize];

	if ( pbEnumBuffer == NULL )
	{
	    DPFX(DPFPREP,  0, "Failed to alloc the enum buffer" );
	    hr = DPNERR_OUTOFMEMORY;
	    goto Failure;
	}

    memset( pbEnumBuffer, 0, dwSPInfoSize );
	dwSPCount = 0;
	pSPInfo = (PDPN_SERVICE_PROVIDER_INFO) pbEnumBuffer;

	hr = pdp8Peer->EnumServiceProviders( NULL, NULL, pSPInfo, &dwSPInfoSize, &dwSPCount, 0 );

	if( FAILED( hr ) )
	{
	    DPFX(DPFPREP,  0, "Error enumerating Service Providers hr=0x%x", hr );
	    goto Failure;
	}

    for( dwProvider = 0; dwProvider < dwSPCount; dwProvider++ )
    {
        memset( &dpspCaps, 0x00, sizeof( DPN_SP_CAPS ) );
        dpspCaps.dwSize = sizeof( DPN_SP_CAPS );

        hr = pdp8Peer->GetSPCaps(  &pSPInfo[dwProvider].guid, &dpspCaps, 0 );

        if( FAILED( hr ) )
        {
            DPFX(DPFPREP,  0, "Error! Failed to get an SP's caps hr=0x%x", hr );
            continue;
        }

        if( !(dpspCaps.dwFlags & DPNSPCAPS_SUPPORTSDPNSRV) )
        {
            DPFX(DPFPREP,  1, "This SP does not support DPNSVR.  Skipping." );
            continue;
        }

        pAppEntry = new CProcessAppList;

        if( pAppEntry == NULL )
        {
            DPFX(DPFPREP,  0, "Failed allocating memory" );
    	    hr = DPNERR_OUTOFMEMORY;
    	    goto Failure;
        }

        hr = pAppEntry->Initialize( &pSPInfo[dwProvider].guid, &m_pProcessAppEntryPool );

        if( FAILED( hr ) )
        {
            DPFX(DPFPREP,  0, "Provider specified it supported us, but failed init hr=0x%x", hr );
            delete pAppEntry;
            pAppEntry = NULL;
            continue;
        }

        pAppEntry->m_blServices.InsertAfter( &m_blServices );
        pAppEntry = NULL;

        m_dwNumServices++;
    }

	pdp8Peer->Close(0);
    delete [] pbEnumBuffer;
    pdp8Peer->Release();
    hr = DPN_OK;

Exit:
    return hr;

Failure:

	// Remove Service Providers from our list
	pblSearch = m_blServices.GetNext();

	while ( pblSearch != &m_blServices )
	{
		pAppEntry = CONTAINING_RECORD( pblSearch, CProcessAppList, m_blServices );
		pblSearch->RemoveFromList();
		delete pAppEntry;
        pAppEntry = NULL;
		pblSearch = m_blServices.GetNext();
	}

    if ( pAppEntry != NULL )
        delete pAppEntry;

    if ( pbEnumBuffer != NULL )
        delete [] pbEnumBuffer;

    if ( pdp8Peer != NULL )
	{
		if ( fInited )
			pdp8Peer->Close(0);

        pdp8Peer->Release();
	}

    goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CDirectPlayServer8::InitializeStatusMemory"
HRESULT CDirectPlayServer8::InitializeStatusMemory()
{
    HRESULT hr = DPN_OK;
    DWORD dwLastError;

	m_dwSizeStatusBlock = sizeof( SERVICESTATUSHEADER )+(m_dwNumServices*sizeof(SERVICESTATUS));

	if (DNGetOSType() == VER_PLATFORM_WIN32_NT)
	{
		m_hMappedFile = CreateFileMapping( INVALID_HANDLE_VALUE, DNGetNullDacl(), PAGE_READWRITE, 0,
										m_dwSizeStatusBlock,
										_T("Global\\") STRING_GUID_DPNSVR_STATUS_MEMORY );
	}
	else
	{
		m_hMappedFile = CreateFileMapping( INVALID_HANDLE_VALUE, DNGetNullDacl(), PAGE_READWRITE, 0,
										m_dwSizeStatusBlock,
										STRING_GUID_DPNSVR_STATUS_MEMORY );
	}

    if( m_hMappedFile == NULL )
    {
        dwLastError = GetLastError();

        DPFX(DPFPREP,  0, "Error initializing shared memory block lasterr=[0x%lx]", dwLastError );

        hr = dwLastError;

		goto Exit;
    }

    m_pMappedServerStatusHeader = (PSERVICESTATUSHEADER) MapViewOfFile( m_hMappedFile, FILE_MAP_READ | FILE_MAP_WRITE,
                                                           0, 0, m_dwSizeStatusBlock );

    dwLastError = GetLastError();

    if( m_pMappedServerStatusHeader == NULL )
    {
        DPFX(DPFPREP,  0, "Error initializing shared mem blockview lasterr=[0x%lx]", dwLastError );

        hr = dwLastError;

		goto Exit;
    }

    m_pMappedServerStatus = (PSERVICESTATUS) &m_pMappedServerStatusHeader[1];

    WaitForSingleObject( m_hStatusMutex, INFINITE );

    // Write initial state to the mapped server status
    memset( m_pMappedServerStatusHeader, 0x00, m_dwSizeStatusBlock );

    m_pMappedServerStatusHeader->dwNumServices = m_dwNumServices;
    m_pMappedServerStatusHeader->dwTimeStart = m_dwStartTicks;

    ReleaseMutex( m_hStatusMutex );

Exit:
    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectPlayServer8::Initialize"
HRESULT CDirectPlayServer8::Initialize()
{
    HRESULT     hr;
	BOOL		fPoolInit = FALSE;
	HANDLE		hThread;
	DWORD		dw = 0;

    m_blServices.Initialize();

	if (DNGetOSType() == VER_PLATFORM_WIN32_NT)
	{
	    m_hCanBeOnlyOne = CreateEvent( DNGetNullDacl(), TRUE, FALSE, _T("Global\\") STRING_GUID_DPNSVR_RUNNING );
	}
	else
	{
	    m_hCanBeOnlyOne = CreateEvent( DNGetNullDacl(), TRUE, FALSE, STRING_GUID_DPNSVR_RUNNING );
	}
    if(m_hCanBeOnlyOne == NULL)
    {
        DPFX(DPFPREP,  0, "Out of memory allocating event" );
        return DPNERR_OUTOFMEMORY;
    }
        

    if( GetLastError() == ERROR_ALREADY_EXISTS )
    {
        DPFX(DPFPREP,  0, "Can only run one instance of server" );
        return DPNERR_DUPLICATECOMMAND;
    }

	m_fInitialized = FALSE;

	if (DNGetOSType() == VER_PLATFORM_WIN32_NT)
	{
	    m_hWaitStartup = CreateEvent( DNGetNullDacl(), TRUE, FALSE, _T("Global\\") STRING_GUID_DPNSVR_STARTUP );
	}
	else
	{
	    m_hWaitStartup = CreateEvent( DNGetNullDacl(), TRUE, FALSE, STRING_GUID_DPNSVR_STARTUP );
	}
    if(m_hWaitStartup == NULL)
    {
        CloseHandle(m_hCanBeOnlyOne);
        DPFX(DPFPREP,  0, "Out of memory allocating event" );
        return DPNERR_OUTOFMEMORY;
    }

    hr = m_qServer.Open( &GUID_DPNSVR_QUEUE, DPNSVR_MSGQ_SIZE, 0 );

    if( FAILED( hr ) )
    {
        DPFX(DPFPREP,  0, "Error opening server instruction queue hr=[0x%lx]", hr );
        goto INITIALIZE_ERROR;
    }

	m_blServices.Initialize();

    if( !m_pProcessAppEntryPool.Initialize() )
    {
        DPFX(DPFPREP,  0, "Error initializing mem pool" );
        hr =  DPNERR_OUTOFMEMORY;
		goto INITIALIZE_ERROR;
    }

	fPoolInit = TRUE;

    // Create the semaphores
    m_hShutdown = CreateEvent( NULL, FALSE, FALSE, NULL );
    if (m_hShutdown == NULL)
    {
        DPFX(DPFPREP,  0, "Out of memory allocating event" );
        hr =  DPNERR_OUTOFMEMORY;
        goto INITIALIZE_ERROR;
    }
	if (DNGetOSType() == VER_PLATFORM_WIN32_NT)
	{
	    m_hTableMutex = CreateMutex( DNGetNullDacl(), FALSE, _T("Global\\") STRING_GUID_DPSVR_TABLESTORAGE );
	}
	else
	{
	    m_hTableMutex = CreateMutex( DNGetNullDacl(), FALSE, STRING_GUID_DPSVR_TABLESTORAGE );
	}
    if( m_hTableMutex == NULL )
    {
        DPFX(DPFPREP,  0, "ERROR: Server is already running.  Only one instance can be running" );
        hr = DPNERR_NOTALLOWED;
        goto INITIALIZE_ERROR;
    }

	if (DNGetOSType() == VER_PLATFORM_WIN32_NT)
	{
	    m_hStatusMutex = CreateMutex( DNGetNullDacl(), FALSE, _T("Global\\") STRING_GUID_DPNSVR_STATUSSTORAGE );
	}
	else
	{
	    m_hStatusMutex = CreateMutex( DNGetNullDacl(), FALSE, STRING_GUID_DPNSVR_STATUSSTORAGE );
	}
    if( m_hStatusMutex == NULL )
    {
        DPFX(DPFPREP,  0, "ERROR: Server is already running.  Only one instance can be running" );
        hr = DPNERR_NOTALLOWED;
        goto INITIALIZE_ERROR;
    }

    hr = EnumerateAndBuildServiceList();

    if( FAILED( hr ) )
    {
        DPFX(DPFPREP,  0, "ERROR occured while building and initializing SP list" );
        goto INITIALIZE_ERROR;
    }

    m_dwStartTicks = GetTickCount();

    hr = InitializeStatusMemory();

    if( FAILED( hr ) )
    {
        DPFX(DPFPREP,  0, "ERROR occured building shared status block" );
        goto INITIALIZE_ERROR;
    }

    m_fInitialized = TRUE;

	hThread = CreateThread(NULL, 0, ServerThread, this, 0, &dw);
    if( hThread == NULL )
    {
        DPFX(DPFPREP,  0, "Unable to start thread!" );
        hr = DPNERR_GENERIC;
        goto INITIALIZE_ERROR;
    }
	CloseHandle(hThread);

	// Set the event so that someone waiting for startup knows when
	// to make their request
	SetEvent( m_hCanBeOnlyOne );
	SetEvent( m_hWaitStartup );

    return DPN_OK;

INITIALIZE_ERROR:

	m_fInitialized = FALSE;

    if( m_pMappedServerStatus != NULL )
    {
        UnmapViewOfFile( m_pMappedServerStatus );
        m_pMappedServerStatus = NULL;
    }

    if( m_hTableMutex != NULL )
    {
        CloseHandle( m_hTableMutex );
        m_hTableMutex = NULL;
    }

    if( m_hStatusMutex != NULL )
    {
        CloseHandle( m_hStatusMutex );
        m_hStatusMutex = NULL;
    }

	if( m_hWaitStartup != NULL )
	{
		CloseHandle( m_hWaitStartup );
		m_hWaitStartup = NULL;
	}

    m_qServer.Close();

    if( fPoolInit )
    {
		m_pProcessAppEntryPool.Deinitialize();
    }

    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectPlayServer8::ResetActivity"
void CDirectPlayServer8::ResetActivity()
{
    m_dwLastActivity = GetTickCount();
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectPlayServer8::Shutdown_Check"
BOOL CDirectPlayServer8::Shutdown_Check( )
{
    HRESULT hr = DPN_OK;
    CBilink *pblSearch;
    CProcessAppList *pProcAppList;
    DWORD dwAppCount = 0;

    pblSearch = m_blServices.GetNext();

    while( pblSearch != &m_blServices )
    {
        pProcAppList = CONTAINING_RECORD( pblSearch, CProcessAppList, m_blServices );

        dwAppCount += pProcAppList->GetNumNodes();

        pblSearch = pblSearch->GetNext();
    }

    if( dwAppCount > 0 )
    {
        ResetActivity();
        return FALSE;
    }

    if( (GetTickCount() - m_dwLastActivity) > DPNSVR_TIMEOUT_SHUTDOWN )
    {
        DPFERR( "Shutting down -- inactive" );
        return TRUE;
    }

    return FALSE;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CDirectPlayServer8::Zombie_Check"
HRESULT CDirectPlayServer8::Zombie_Check( )
{
    HRESULT hr = DPN_OK;
    CBilink *pblSearch;
    CProcessAppList *pProcAppList;

    pblSearch = m_blServices.GetNext();

    while( pblSearch != &m_blServices )
    {
        pProcAppList = CONTAINING_RECORD( pblSearch, CProcessAppList, m_blServices );

        hr = pProcAppList->ZombieCheckAndRemove();

        pblSearch = pblSearch->GetNext();
    }

    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectPlayServer8::ServerThread"
DWORD WINAPI CDirectPlayServer8::ServerThread( LPVOID lpvParam )
{
    CDirectPlayServer8 *This = (CDirectPlayServer8 *) lpvParam;

    LONG lWaitResult;
    HRESULT hr = DPN_OK;
    DPNSVR_MSGQ_HEADER dpHeader;
	PBYTE pbBuffer = NULL;
	DWORD dwBufferSize = 0;
	DWORD dwSize;
	HANDLE hEvent;

    hr = COM_CoInitialize(NULL);

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Could not initialize COM hr = 0x%x", hr );
		goto EXIT_THREAD;
	}

    DPFX(DPFPREP,  5, "ServerThread Started" );

	hEvent = This->m_qServer.GetReceiveSemaphoreHandle();

    while( !This->m_fShutdownSignal )
    {
        lWaitResult = WaitForSingleObject( hEvent, DPLAYSERVER8_TIMEOUT_ZOMBIECHECK );

        if( lWaitResult == WAIT_TIMEOUT )
        {
            if( This->Shutdown_Check() )
            {
                DPFERR( "Shutdown check detected shutdown required" );
                break;
            }

            DPFX(DPFPREP,  8, "Request = [ZOMBIE CHECK]" );
            hr = This->Zombie_Check();
            DPFX(DPFPREP,  8, "Result = [0x%lx]", hr );

            continue;
        }
		else if( lWaitResult == WAIT_ABANDONED || lWaitResult == WAIT_ABANDONED+1 )
		{
			DPFX(DPFPREP,  0, "Error: Wait abandoned" );
		}

        DPFX(DPFPREP,  5, "Waking up.. looking for instructions" );

        DPFX(DPFPREP,  5, "Request = [APP REQUEST]" );

		while( 1 ) 
		{
			dwSize = dwBufferSize;

			hr = This->m_qServer.GetNextMessage( &dpHeader, pbBuffer, &dwSize );

			if( hr == DPNERR_BUFFERTOOSMALL )
			{
				if( pbBuffer )
					delete [] pbBuffer;
				
				pbBuffer = new BYTE[dwSize];

				if( pbBuffer == NULL )
				{
					DPFX(DPFPREP,  0, "Error allocating memory" );
					goto EXIT_THREAD;
				}

				dwBufferSize = dwSize;
			}
			else if( FAILED( hr ) )
			{
				DPFX(DPFPREP,  0, "Error getting next message hr=0x%x", hr );
				goto EXIT_THREAD;
			}
			else if( dwSize == 0 )
			{
				continue;
			}
			else
			{
				break;
			}
		}

        hr = This->Command_ProcessMessage( pbBuffer );

        DPFX(DPFPREP,  5, "Result = [0x%lx]", hr );
    }

EXIT_THREAD:

	if( pbBuffer )
	{
		delete[] pbBuffer;
	}

    DPFX(DPFPREP,  5, "ServerThread Exiting" );

    SetEvent( This->m_hShutdown );

    COM_CoUninitialize();

    return 0;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectPlayServer8::WaitForShutdown"
HRESULT CDirectPlayServer8::WaitForShutdown()
{
    WaitForSingleObject( m_hShutdown, INFINITE );
    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectPlayServer8::HandleOpenPort"
HRESULT CDirectPlayServer8::HandleOpenPort( PDPNSVMSG_OPENPORT pmsgOpenPort )
{
    CBilink *pblSearch;
    CProcessAppList *pProcAppList;

    pblSearch = m_blServices.GetNext();

    // Determine required size.
    while( pblSearch != &m_blServices )
    {
        pProcAppList = CONTAINING_RECORD( pblSearch, CProcessAppList, m_blServices );

        if( pmsgOpenPort->guidSP == *(pProcAppList->GetSPGuid()) )
        {
            return pProcAppList->AddApplication( pmsgOpenPort );
        }

        pblSearch = pblSearch->GetNext();
    }

    DPFX(DPFPREP,  0, "ERROR!  Could not find SP in server to handle addport request" );

    DPFX(DPFPREP,  0, "Specified SP was not found" );

    return DPNERR_GENERIC;

}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectPlayServer8::HandleClosePort"
HRESULT CDirectPlayServer8::HandleClosePort( PDPNSVMSG_CLOSEPORT pmsgClosePort )
{
    CBilink *pblSearch;
    CProcessAppList *pProcAppList;

    pblSearch = m_blServices.GetNext();

    // Determine required size.
    while( pblSearch != &m_blServices )
    {
        pProcAppList = CONTAINING_RECORD( pblSearch, CProcessAppList, m_blServices );

        pProcAppList->RemoveApplication( pmsgClosePort );

        pblSearch = pblSearch->GetNext();
    }

	return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectPlayServer8::HandleCommand"
HRESULT CDirectPlayServer8::HandleCommand( PDPNSVMSG_COMMAND pmsgCommand )
{
	HRESULT hr;

	switch( pmsgCommand->dwCommand )
	{
	case DPNSVCOMMAND_STATUS:
		hr = Command_Status();
		break;
	case DPNSVCOMMAND_KILL:
		hr = Command_Kill();
		break;
	case DPNSVCOMMAND_TABLE:
		hr = Command_Table();
		break;
	default:
		return DPNERR_INVALIDPARAM;
	}

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectPlayServer8::HandleCommand"
HRESULT CDirectPlayServer8::Command_Kill()
{
	m_fShutdownSignal = TRUE;
	return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectPlayServer8::RespondToRequest"
HRESULT CDirectPlayServer8::RespondToRequest( GUID *pguidInstance, HRESULT hrResult, DWORD dwContext )
{
    CDPNSVRIPCQueue queue;
    DPNSVMSG_RESULT dpnMsgResult;

    HRESULT hr;

    hr = queue.Open( pguidInstance, DPNSVR_MSGQ_SIZE, DPNSVR_MSGQ_OPEN_FLAG_NO_CREATE );

    if( FAILED( hr ) )
    {
        DPFX(DPFPREP,  0, "Unable to open queue to respond.  Process Exited? hr=[0x%lx]", hr );
        return hr;
    }

    dpnMsgResult.dwType = DPNSVMSGID_RESULT;
    dpnMsgResult.dwCommandContext = dwContext;
    dpnMsgResult.hrCommandResult = hrResult;

    hr = queue.Send( (PBYTE) &dpnMsgResult, sizeof( DPNSVMSG_RESULT ), DPLAYSERVER8_TIMEOUT_RESULT, DPNSVR_MSGQ_MSGFLAGS_USER1, 0 );

    if( FAILED( hr ) )
    {
        DPFX(DPFPREP,  0, "Failed to send response hr=[0x%lx]", hr );
        return hr;
    }

    queue.Close();

    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectPlayServer8::Command_ProcessMessage"
HRESULT CDirectPlayServer8::Command_ProcessMessage( LPVOID pvMessage )
{
    PDPNSVMSG_GENERIC       pMsgGeneric;
    PDPNSVMSG_OPENPORT      pMsgOpenPort;
    PDPNSVMSG_CLOSEPORT     pMsgClosePort;
	PDPNSVMSG_COMMAND		pMsgCommand;
    HRESULT                 hr, hrRespond;

    DPFX(DPFPREP,  5, "Message received" );

    pMsgGeneric = (PDPNSVMSG_GENERIC) pvMessage;
    hrRespond = DPN_OK;

    DPFX(DPFPREP,  5, "Message Type [%d]", pMsgGeneric->dwType );

    switch( pMsgGeneric->dwType )
    {
    case DPNSVMSGID_OPENPORT:

        ResetActivity();

        pMsgOpenPort = (PDPNSVMSG_OPENPORT) pMsgGeneric;

        hr = HandleOpenPort( pMsgOpenPort );

        hrRespond = RespondToRequest( &pMsgOpenPort->guidInstance, hr, pMsgOpenPort->dwCommandContext );

        break;

    case DPNSVMSGID_CLOSEPORT:

        ResetActivity();

        pMsgClosePort = (PDPNSVMSG_CLOSEPORT) pMsgGeneric;

        hr = HandleClosePort( pMsgClosePort );

        hrRespond = RespondToRequest( &pMsgClosePort->guidInstance, hr, pMsgClosePort->dwCommandContext );

        break;

	case DPNSVMSGID_COMMAND:

        ResetActivity();
	
		pMsgCommand = (PDPNSVMSG_COMMAND) pMsgGeneric;

		hr = HandleCommand( pMsgCommand );

        hrRespond = RespondToRequest( &pMsgCommand->guidInstance, hr, pMsgCommand->dwCommandContext );

		break;

    default:
        DPFX(DPFPREP,  0, "Unknown message type [%d]", pMsgGeneric->dwType );
        hr = DPNERR_GENERIC;
        return hr;
    }

    if (hr != DPN_OK)
        return hr;
    else
        return hrRespond;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\dpnsvr\dpnsvr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDS_PROGRAM_NAME        1
#define IDS_SHUTDOWN_SUCCESS    2
#define IDS_SHUTDOWN_ERROR      3
#define IDS_COMMANDLINE_HELP	4
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1067
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\dpnsvr\dpnsvr\dpsvr8.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999, 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpsvr8.h
 *  Content:    DirectPlay8 Server Object
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 * 03/14/00     rodtoll Created it
 * 03/23/00     rodtoll Removed local requests, updated to use new data sturctures
 * 03/25/00     rodtoll Updated so uses SP caps to determine which SPs to load
 *              rodtoll Now supports N SPs and only loads those supported
 * 05/09/00     rodtoll Bug #33622 DPNSVR.EXE does not shutdown when not in use 
 * 07/09/2000	rodtoll	Added guard bytes
 ***************************************************************************/
#ifndef __DP8SVR_H
#define __DP8SVR_H

#include "dpnsdef.h"
#include "proctbl.h"
#include "dpnsvmsg.h"
#include "dpnsvrq.h"

#define DPNSVRSIGNATURE_SERVEROBJECT		'BOSD'
#define DPNSVRSIGNATURE_SERVEROBJECT_FREE	'BOS_'

class CDirectPlayServer8
{
public:
    CDirectPlayServer8();
    ~CDirectPlayServer8();

    HRESULT Initialize();
    HRESULT WaitForShutdown();
    HRESULT EnumerateAndBuildServiceList();
    HRESULT InitializeStatusMemory();
    
public: // Server side command handling
    HRESULT Command_Status();
    HRESULT Command_Table();
	HRESULT Command_Kill();
    HRESULT Command_ProcessMessage( LPVOID pvMessage );
    HRESULT RespondToRequest( GUID *pguidInstance, HRESULT hrResult, DWORD dwContext );

public: // Client Side Request functions
    static HRESULT Request_KillServer();

	static HRESULT WINAPI DummyMessageHandler( PVOID pvContext, DWORD dwMessageType, PVOID pvMessage );

protected: // Message Handlers
	
    HRESULT HandleOpenPort( PDPNSVMSG_OPENPORT pmsgOpenPort );
    HRESULT HandleClosePort( PDPNSVMSG_CLOSEPORT pmsgClosePort );
	HRESULT HandleCommand( PDPNSVMSG_COMMAND pmsgCommand );

protected: // Internal Helper Functions
    HRESULT Zombie_Check();
    void ResetActivity();
    BOOL Shutdown_Check();

public: // Thread function
    static DWORD WINAPI ServerThread( LPVOID lpvParam );

protected:

	DWORD				m_dwSignature;
    PSERVICESTATUSHEADER m_pMappedServerStatusHeader;
    PSERVICESTATUS      m_pMappedServerStatus;
    HANDLE              m_hMappedFile;
    HANDLE              m_hShutdown;
    HANDLE              m_hTableMutex;
    HANDLE              m_hStatusMutex;
    HANDLE              m_hReceivedCommand;
    HANDLE              m_hCanBeOnlyOne;
	HANDLE			    m_hWaitStartup;
    DWORD               m_dwStartTicks;
    DWORD               m_dwTableSize;
    HANDLE              m_hTableMappedFile;
    PBYTE               m_pMappedTable;
    CDPNSVRIPCQueue     m_qServer;
    BOOL                m_fInitialized;
	BOOL			    m_fShutdownSignal;
	CBilink              m_blServices;
	DWORD               m_dwNumServices;
	DWORD               m_dwSizeStatusBlock;
	DWORD_PTR           m_dwLastActivity;
    CLockedFixedPool<CProcessAppEntry> m_pProcessAppEntryPool;


};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\dpnsvr\dpnsvr\proctbl.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999, 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       proctbl.h
 *  Content:    Process/App Table for DPLAY8 Server
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 * 03/14/00     rodtoll Created it
 * 03/25/00     rodtoll Updated table so it can be member of CBilink
 * 07/09/2000	rmt		Added guard bytes
 * 08/23/2000	rodtoll	Bug #43003- DPNSVR: Session cannot be enumerated if hosting on adapter didn't exist when DPNSVR started 
 * 09/28/2000	rodtoll	Bug #45913 - DPLAY8: DPNSVR leaks memory when dialup connection drops
 * 01/11/2001	rodtoll WINBUG #365176 - DPNSVR: Holds lock across calls to external components 
 ***************************************************************************/

#ifndef __PROCTBL_H
#define __PROCTBL_H

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_DPNSVR

#define DPNSVRSIGNATURE_PROCAPPLIST			'LPSD'
#define DPNSVRSIGNATURE_PROCAPPLIST_FREE	'LPS_'

#define DPNSVRSIGNATURE_PROCAPPENTRY		'EPSD'
#define DPNSVRSIGNATURE_PROCAPPENTRY_FREE	'EPS_'

class CProcessAppEntry;
class CProcessAppList;
class LISTEN_INFO;

typedef struct _PROCESSAPPLISTCOMINTERFACE
{
    LPVOID          m_lpvVTable;
    CProcessAppList *m_pProcessTable;
} PROCESSAPPLISTCOMINTERFACE, *PPROCESSAPPLISTCOMINTERFACE;

#define DPNSVR_NUM_INITIAL_SLOTS		1
#define DPNSVR_NUM_EXTEND_SLOTS			3

class CProcessAppList
{

public: // COM interface for SP-->Server Callbacks

    static HRESULT QueryInterface( IDP8SPCallback *pSP, REFIID riid, LPVOID * ppvObj );
    static ULONG AddRef( IDP8SPCallback *pSP );
    static ULONG Release( IDP8SPCallback *pSP );
    static HRESULT IndicateEvent( IDP8SPCallback *pSP, SP_EVENT_TYPE spetEvent,LPVOID pvData );
    static HRESULT CommandComplete( IDP8SPCallback *pSP,HANDLE hCommand,HRESULT hrResult,LPVOID pvData );

public:

	friend class LISTEN_INFO;
	
    CProcessAppList();
    ~CProcessAppList();

    HRESULT Initialize( const GUID * const pguidSP, CLockedFixedPool<CProcessAppEntry> *pProcessEntryPool );
    HRESULT AddApplication( PDPNSVMSG_OPENPORT pmsgOpenPort );
    HRESULT RemoveApplication( PDPNSVMSG_CLOSEPORT pmsgClosePort );
    HRESULT ZombieCheckAndRemove();
	HRESULT StartListens();
	HRESULT ShutdownListens();		
	HRESULT StartListen( GUID &guidAdapter );
	BOOL IsListenRunningOnDevice( GUID &guidDevice );
	HRESULT CheckEntryForNewDevice( CProcessAppEntry *pProcessAppEntry );

    inline BOOL IsAvailable()
    {
        return m_fInitialized;
    };

    inline void Return( CProcessAppEntry *pEntry )
    {
        m_pProcessAppEntryPool->Release( pEntry );

        Lock();
        m_dwNumNodes--;
        UnLock();
    };

    inline CProcessAppEntry *Get()
    {
         Lock();

        m_dwNumNodes++;

        UnLock();

        return m_pProcessAppEntryPool->Get();
    }

    inline void Lock()
    {
        DNEnterCriticalSection( &m_csLock );
    };

    inline void UnLock()
    {
        DNLeaveCriticalSection( &m_csLock );
    };

    inline GUID *GetSPGuid()
    {
        return &m_guidSP;
    };

    // AddRef's the SP before returning it
    inline IDP8ServiceProvider *GetSP()
    {
        Lock();
        if( m_pdp8SP != NULL )
            m_pdp8SP->AddRef();
        UnLock();

        return m_pdp8SP;
    }

    DWORD GetTableSizeBytes();
    HRESULT CopyTable( PBYTE pbWriteLoc );

    inline DWORD GetNumNodes() { return m_dwNumNodes; };
    inline DWORD GetNumEnumRequests() { return m_dwEnumRequests; };
    inline DWORD GetNumConnectRequests() { return m_dwConnectRequests; };
    inline DWORD GetNumDisconnectRequests() { return m_dwDisconnectRequests; };
    inline DWORD GetNumDataRequests() { return m_dwDataRequests; };
    inline DWORD GetNumEnumReplies() { return m_dwEnumReplies; };
    inline DWORD GetNumEnumRequestBytes() { return m_dwEnumRequestBytes; };

	DWORD	m_dwSignature;
    CBilink  m_blServices;

protected: // Internal helper funcs
    HRESULT FindAppEntry( DWORD dwProcessID, GUID &guidInstance, CProcessAppEntry **ppProcessAppEntry );

    HRESULT Debug_DisplayAddressFromHandle( HANDLE hEndPoint );
    HRESULT Debug_DisplayAddress( PDIRECTPLAY8ADDRESS pdp8Address );

protected: // Handlers for events

    HRESULT Handle_EnumRequest( PSPIE_QUERY pEnumRequest );
    HRESULT Handle_Connect( PSPIE_CONNECT pConnect );
    HRESULT Handle_Disconnect( PSPIE_DISCONNECT pDisconnect );
    HRESULT Handle_Data( PSPIE_DATA pData );
    HRESULT Handle_EnumResponse( PSPIE_QUERYRESPONSE pEnumResponse );
    HRESULT Handle_ListenStatus( PSPIE_LISTENSTATUS pListenStatus );

protected: // Data

	LONG								m_lNumListensOutstanding;
	CBilink								m_blListens;
    CBilink                              m_blProcessApps;
    IDP8ServiceProvider                 *m_pdp8SP;
    HANDLE                              m_hListenCompleteEvent;
    BOOL                                m_fInitialized;
	BOOL								m_fOpened;
    GUID                                m_guidSP;
    PROCESSAPPLISTCOMINTERFACE          m_vtbl;
    HRESULT                             m_hrListenResult;
    DNCRITICAL_SECTION                  m_csLock;    
    CLockedFixedPool<CProcessAppEntry>  *m_pProcessAppEntryPool;  
	BOOL								m_fCritSecInited;

protected: // Stats

    volatile DWORD                      m_dwNumNodes;
    volatile DWORD                      m_dwEnumRequests;
    volatile DWORD                      m_dwConnectRequests;
    volatile DWORD                      m_dwDisconnectRequests;
    volatile DWORD                      m_dwDataRequests;
    volatile DWORD                      m_dwEnumReplies;
    volatile DWORD                      m_dwEnumRequestBytes;
};

typedef CProcessAppList PROCESSAPPLIST, *PPROCESSAPPLIST;

class LISTEN_INFO
{
public:
	LISTEN_INFO( 
		CProcessAppList *pAppList 
		):	pOwner(pAppList),
			hListen(NULL),
			dwListenDescriptor(0),
			lRefCount(1)
	{
		blListens.Initialize();
		pOwner->Lock();
		blListens.InsertAfter( &pOwner->m_blListens ); 		
		pOwner->UnLock();
	};

	~LISTEN_INFO()
	{
		
	};

	void AddRef()
	{
		InterlockedIncrement( &lRefCount );
	};

	#undef DPF_MODNAME
	#define DPF_MODNAME "LISTEN_INFO::Release"
	void Release()
	{
		DNASSERT( lRefCount > 0 );
		if( InterlockedDecrement( &lRefCount ) == 0 )
		{
			pOwner->Lock();	
			blListens.RemoveFromList();
			pOwner->UnLock();
			delete this;
		}
	};

	LONG					lRefCount;
	CBilink					blListens;
	GUID					guidDevice;
	HANDLE					hListen;
	DWORD					dwListenDescriptor;
	CProcessAppList			*pOwner;
};

typedef LISTEN_INFO *PLISTEN_INFO;

// CProcessAppEntry
//
// This class represents a single process that is making use of the DPNSVR
//
class CProcessAppEntry
{
public:
    CProcessAppEntry(): m_dwAddressSize(0), m_dwSignature(DPNSVRSIGNATURE_PROCAPPENTRY) {};
    ~CProcessAppEntry() { m_dwSignature = DPNSVRSIGNATURE_PROCAPPENTRY_FREE; } ;


    HRESULT Initialize( PDPNSVMSG_OPENPORT pmsgOpenPort, CProcessAppList *pOwner );
	HRESULT AddAddress( PDPNSVMSG_OPENPORT pmsgOpenPort );

    // Forward the enumeration
    HRESULT ForwardEnum( PSPIE_QUERY psieQuery  );

    inline BOOL CheckRunning()
    {
        HANDLE hProcess;

        hProcess = OpenProcess( PROCESS_QUERY_INFORMATION, FALSE, m_dwProcessID );

        if( hProcess == NULL )
        {
			if (GetLastError() == ERROR_ACCESS_DENIED)
			{
				// The process is still running, we just don't have permission to open it.
				return TRUE;
			}
			else
			{
				return FALSE;
			}
        }
        else
        {
            CloseHandle( hProcess );
            return TRUE;
        }
    };

    void DeInitialize();

    inline void AddRef()
    {
        InterlockedIncrement( &m_lRefCount );
    };

    inline void Release()
    {
        if( InterlockedDecrement( &m_lRefCount ) == 0 )
        {
            DeInitialize();
        }
    };

    inline void Lock()
    {
        DNEnterCriticalSection( &m_csLock );
    };

    inline void UnLock()
    {
        DNLeaveCriticalSection( &m_csLock );
    };

    inline GUID *GetApplicationGUID()
    {
        return &m_guidApplication;
    };

    inline GUID *GetInstanceGUID()
    {
        return &m_guidInstance;
    }

    inline DWORD GetProcessID()
    {
        return m_dwProcessID;
    }

    void Debug_DisplayInfo();

    inline LONG GetRefCount()
    {
        return m_lRefCount;
    }

    DWORD GetNumAddresses()
    {
        return m_dwNumAddresses;
    }

    DWORD GetNumAddressSlots()
    {
        return m_dwAddressSize;
    }

    PDIRECTPLAY8ADDRESS GetAddress( DWORD dwIndex )
    {
        return m_pdpAddresses[dwIndex];
    }

	DWORD				m_dwSignature;
    CBilink              m_blProcessApps;

protected:

    DWORD               m_dwProcessID;
    LONG                m_lRefCount;
    DNCRITICAL_SECTION  m_csLock;
    CProcessAppList     *m_pOwner;
    GUID                m_guidApplication;
    GUID                m_guidInstance;
    PDIRECTPLAY8ADDRESS *m_pdpAddresses;          // Array of addresses
    DWORD               m_dwAddressSize;
    DWORD               m_dwNumAddresses;

};

typedef CProcessAppEntry PROCESSAPPENTRY, *PPROCESSAPPENTRY;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\guids\guids.cpp ===
#include <initguid.h>
#include "dplay8.h"
#include "dpaddr.h"
#include "dplobby8.h"
#include "dpsp8.h"
#include "dvoice.h"
#include "dpprot.h"
#include "dpnsdef.h"
#include "dplegacyguid.h"
#include "dpnathlp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\dpnsvr\inc\dpnsvmsg.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999, 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpnsvmsg.h
 *  Content:    DirectPlay8 Server Object Messages 
 *              Definitions of DPNSVR <--> DirectPlay8 Applications
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 * 03/20/00     rodtoll Created it
 * 03/23/00     rodtoll Removed port entries -- no longer needed
 * 03/24/00		rodtoll	Updated, only sending one entry per message
 *				rodtoll	Removed SP field, can be extracted from URL
 ***************************************************************************/

#ifndef __DPNSVMSG_H
#define __DPNSVMSG_H

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_DPNSVR

// DirectPlay8 Server Message IDs
#define DPNSVMSGID_OPENPORT                 0x00000001
#define DPNSVMSGID_CLOSEPORT                0x00000002
#define DPNSVMSGID_RESULT                   0x00000003
#define DPNSVMSGID_COMMAND					0x00000004

#define DPNSVCOMMAND_STATUS					0x00000001
#define DPNSVCOMMAND_KILL					0x00000002
#define DPNSVCOMMAND_TABLE					0x00000003

typedef struct _DPNSVMSG_GENERIC
{
    DWORD       dwType;
} DPNSVMSG_GENERIC, *PDPNSVMSG_GENERIC;

// DirectPlay8 Server Message Structures
typedef struct _DPNSVMSG_OPENPORT
{
    DWORD       dwType;             // = DPNSVMSGID_OPENPORT
    DWORD       dwProcessID;          // Process ID of requesting process
	GUID		guidSP;
    GUID        guidApplication;    // Application GUID of app requesting open
    GUID        guidInstance;       // Instance GUID of app requesting open
    DWORD       dwCommandContext;   // Context value to be returned w/result
    DWORD       dwAddressSize;      // # of addresses after this header in the message
} DPNSVMSG_OPENPORT, *PDPNSVMSG_OPENPORT;

typedef struct _DPNSVMSG_CLOSEPORT
{
    DWORD       dwType;             // = DPNSVMSGID_CLOSEPORT
    DWORD       dwProcessID;          // Process ID of requesting process
	GUID		guidSP;
    GUID        guidApplication;    // Application GUID of app requesting close
    GUID        guidInstance;       // Instance GUID of app requesting close
    DWORD       dwCommandContext;   // Context value to be returned w/result
} DPNSVMSG_CLOSEPORT, *PDPNSVMSG_CLOSEPORT;

typedef struct _DPNSVRMSG_COMMAND
{
	DWORD		dwType;				// = DPNSVMSGID_COMMAND
	DWORD		dwCommand;			// = DPNSVCOMMAND_XXXXXXXX
	GUID		guidInstance;
	DWORD		dwParam1;
	DWORD		dwParam2;
	DWORD		dwCommandContext;
} DPNSVMSG_COMMAND, *PDPNSVMSG_COMMAND;

typedef struct _DPNSVMSG_RESULT
{
    DWORD       dwType;             // = DPNSVMSGID_RESULT
    DWORD       dwCommandContext;   // User supplied context
    HRESULT     hrCommandResult;    // Result of command
} DPNSVMSG_RESULT, *PDPNSVMSG_RESULT;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\dpnsvr\dpnsvr\proctbl.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999, 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       proctbl.cpp
 *  Content:    Process/App Table for DPLAY8 Server
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 * 03/14/00     rodtoll Created it
 * 05/17/2000   rodtoll Bug #35177 - DPNSVR may hang on shutdown (added lock release)
 * 07/09/2000	rodtoll		Added guard bytes
 * 08/05/2000   RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 * 08/18/2000	rodtoll Bug #42848 - DPNSVR: Crash after running for a few hours.
 * 08/23/2000	rodtoll	Bug #43003- DPNSVR: Session cannot be enumerated if hosting on adapter didn't exist when DPNSVR started
 * 09/14/2000	rodtoll	Bug #44625 - DPLAY8: CORE: More debug spew for Bug #44625
 * 09/28/2000	rodtoll	Bug #45913 - DPLAY8: DPNSVR leaks memory when dialup connection drops
 * 12/01/2000	rodtoll Bug #48372 - DPNSVR: m_hrListenResult used prior to initialization
 * 01/11/2001	rodtoll WINBUG #365176 - DPNSVR: Holds lock across calls to external components
 * 02/06/2001	rodtoll	WINBUG #304614 - DPNSVR: Does not remeber devices it has already listened for.  
 ***************************************************************************/

#include "dnsvri.h"

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_DPNSVR


LPVOID dnspInterface[] =
{
    (LPVOID)CProcessAppList::QueryInterface,
    (LPVOID)CProcessAppList::AddRef,
    (LPVOID)CProcessAppList::Release,
	(LPVOID)CProcessAppList::IndicateEvent,
	(LPVOID)CProcessAppList::CommandComplete
};

#undef DPF_MODNAME
#define DPF_MODNAME "CProcessAppList::CProcessAppList"
CProcessAppList::CProcessAppList(
    ):  m_dwSignature(DPNSVRSIGNATURE_PROCAPPLIST),
		m_fInitialized(FALSE),
        m_pdp8SP(NULL),
        m_pProcessAppEntryPool(NULL),
        m_dwNumNodes(0),
        m_dwEnumRequests(0),
        m_dwConnectRequests(0),
        m_dwDisconnectRequests(0),
        m_dwDataRequests(0),
        m_dwEnumReplies(0),
        m_dwEnumRequestBytes(0),
        m_lNumListensOutstanding(0),
		m_fOpened(FALSE),
		m_fCritSecInited(FALSE),
		m_hListenCompleteEvent(0)
{
    m_vtbl.m_lpvVTable = &dnspInterface;
    m_vtbl.m_pProcessTable = this;

    m_blProcessApps.Initialize();
}

#undef DPF_MODNAME
#define DPF_MODNAME "CProcessAppList::~CProcessAppList"
CProcessAppList::~CProcessAppList()
{
    CBilink *pblSearch;
    PPROCESSAPPENTRY pProcessAppEntry;

    Lock();

    pblSearch = m_blProcessApps.GetNext();

    while( pblSearch != &m_blProcessApps )
    {
        pProcessAppEntry = CONTAINING_RECORD( pblSearch, PROCESSAPPENTRY, m_blProcessApps );

        // Release the list's entry
        pProcessAppEntry->Release();

        pblSearch = m_blProcessApps.GetNext();
    }

    UnLock();

    ShutdownListens();

	if( m_pdp8SP )
	{
		if( m_fOpened )
			m_pdp8SP->Close();

        m_pdp8SP->Release();
		m_pdp8SP = NULL;
    }

	// Close of SP should destroy and cleanup all listens.  
	DNASSERT( m_blListens.IsEmpty() );

    if (m_fCritSecInited)
	{
		DNDeleteCriticalSection( &m_csLock );
	}
    CloseHandle( m_hListenCompleteEvent );

	m_dwSignature = DPNSVRSIGNATURE_PROCAPPLIST_FREE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CProcessAppList::ShutdownListens"
//
// Assumptions:
// Listens have all started or failed.
// Listen doesn't stop once it has started until we cancel it.
// 
HRESULT CProcessAppList::ShutdownListens()
{

	CBilink *pLocation = NULL;
	BOOL fFound = FALSE;
	PLISTEN_INFO pListenInfo = NULL;
	HRESULT hr = DPN_OK; 
	DWORD dwCount = 0;
	PLISTEN_INFO *ppListenInfoList = NULL;
	DWORD dwIndex = 0;

	// Loop until we've killed all listens.  The killing of the listens will invoke
	// the command complete which will clean up and remove the entries.  
	Lock();

	// Count the # of entries
	pLocation = m_blListens.GetNext();
	while( pLocation != &m_blListens )
	{
		pListenInfo = CONTAINING_RECORD( pLocation, LISTEN_INFO, blListens );
		dwCount++;
		pLocation = pLocation->GetNext();
	}

	if( dwCount > 0 )
	{
		// Allocate an array 
		ppListenInfoList = new PLISTEN_INFO[dwCount];

		// Memory allocation failure
		if( ppListenInfoList == NULL )
		{
			UnLock();
			DPFERR( "Out of memory!" );
			DNASSERT( FALSE );
			return DPNERR_OUTOFMEMORY;
		}

		// Run the list and copy the pointers 
		pLocation = m_blListens.GetNext();

		while( pLocation != &m_blListens )
		{
			DNASSERT( dwIndex < dwCount );
			pListenInfo = CONTAINING_RECORD( pLocation, LISTEN_INFO, blListens );
			ppListenInfoList[dwIndex++] = pListenInfo;

			// Add a reference because this array has a reference
			pLocation = pLocation->GetNext();
		}
	}

	UnLock();

	for( dwIndex = 0; dwIndex < dwCount; dwIndex++ )
	{
		DNASSERT( ppListenInfoList[dwIndex] );		

		hr = m_pdp8SP->CancelCommand( ppListenInfoList[dwIndex]->hListen, ppListenInfoList[dwIndex]->dwListenDescriptor );

		if( FAILED( hr ) )
		{
			DPFX(DPFPREP,  0, "Could not shutdown a listen hr=0x%x", hr );
		}			
	}

	if( ppListenInfoList )
		delete [] ppListenInfoList;

	return DPN_OK;
	
}

#undef DPF_MODNAME
#define DPF_MODNAME "CProcessAppList::StartListen"
HRESULT CProcessAppList::StartListen( GUID &guidAdapter )
{
	HRESULT 				hr = DPN_OK;
    PDIRECTPLAY8ADDRESS		pdp8Address = NULL;
    PLISTEN_INFO			pListenInfo = NULL;  
    SPLISTENDATA 			dpspListenData;	  
	DWORD					dwPort = DPNA_DPNSVR_PORT;
	
	// Build up basic listen address
	hr = COM_CoCreateInstance( CLSID_DirectPlay8Address, NULL, CLSCTX_INPROC_SERVER, IID_IDirectPlay8Address, (void **) &pdp8Address );

	if( FAILED( hr ) )
	{
	    DPFX(DPFPREP,  0, "Unable to create address for listen hr=0x%x", hr );
	    return hr;
	}

    hr = pdp8Address->SetSP( &m_guidSP );

    if( FAILED( hr ) )
    {
		DPFX(DPFPREP,  0, "Error setting SP hr=0x%x", hr );
		hr = DPNERR_GENERIC;
		goto EXIT_FUNCTION;
	}
	
	hr = pdp8Address->SetDevice( &guidAdapter );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Skipping device because cannot setup address hr=0x%x", hr );
		hr = DPNERR_GENERIC;
		goto EXIT_FUNCTION;
	}

	hr = pdp8Address->AddComponent( DPNA_KEY_PORT, &dwPort, sizeof( DWORD ), DPNA_DATATYPE_DWORD );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Skipping device because cannot setup address 2 hr=0x%x", hr );
		hr = DPNERR_GENERIC;
		goto EXIT_FUNCTION;
	}

	pListenInfo = new LISTEN_INFO( this );

	if( !pListenInfo )
	{
		DPFX(DPFPREP,  0, "Error allocating memory" );
		hr = DPNERR_OUTOFMEMORY;
		goto EXIT_FUNCTION;
	}

	pListenInfo->guidDevice = guidAdapter;

   // Setup the listen request
    dpspListenData.dwFlags = DPNSPF_BINDLISTENTOGATEWAY;
    dpspListenData.pAddressDeviceInfo = pdp8Address;
    dpspListenData.pvContext = pListenInfo;
    dpspListenData.hCommand = NULL;
    dpspListenData.dwCommandDescriptor = 0;

	InterlockedIncrement( &m_lNumListensOutstanding );    

	// Add a reference for the listen request
	pListenInfo->AddRef();

    hr = m_pdp8SP->Listen( &dpspListenData );

    if( hr != DPNERR_PENDING && hr != DPN_OK )
    {
    	// Release app reference, will not be tracked
    	pListenInfo->Release();
        DPFX(DPFPREP,  0, "PORT: SP failed on Listen request port %d hr=0x%x", DPNA_DPNSVR_PORT, hr );
		goto EXIT_FUNCTION;
    }

    pListenInfo->hListen = dpspListenData.hCommand;
    pListenInfo->dwListenDescriptor = dpspListenData.dwCommandDescriptor;

EXIT_FUNCTION:

	if(pdp8Address){
	    pdp8Address->Release();
    }	

	if(pListenInfo){
		pListenInfo->Release();
	}	

    return hr;
	
}

#undef DPF_MODNAME
#define DPF_MODNAME "CProcessAppList::StartListens"
HRESULT CProcessAppList::StartListens()
{
    SPENUMADAPTERSDATA 		dpspEnumData;
    PBYTE				 	pbDataBuffer = NULL;
    DWORD					dwDataBufferSize = 0;
	HRESULT 				hr = DPN_OK;
	DWORD					dwAdapterIndex = 0;
    PDIRECTPLAY8ADDRESS		pdp8Address = NULL;
    PLISTEN_INFO			pListenInfo = NULL;
    DWORD					dwPort = DPNA_DPNSVR_PORT;
	
	m_lNumListensOutstanding = 0;

	dpspEnumData.dwFlags = 0;
    dpspEnumData.dwAdapterCount = 0;
    dpspEnumData.dwAdapterDataSize = 0;
    dpspEnumData.pAdapterData = NULL;

    hr = m_pdp8SP->EnumAdapters( &dpspEnumData );

    if( hr != DPNERR_BUFFERTOOSMALL )
    {
    	DPFX(DPFPREP,  0, "Error enumerating adapters hr=0x%x", hr );
    	goto STARTLISTEN_ERROR;
    }

    pbDataBuffer = new BYTE[dpspEnumData.dwAdapterDataSize];

    if( pbDataBuffer == NULL )
    {
    	hr = DPNERR_OUTOFMEMORY;
    	goto STARTLISTEN_ERROR;
    }

	dpspEnumData.pAdapterData = (DPN_SERVICE_PROVIDER_INFO *) pbDataBuffer;

    hr = m_pdp8SP->EnumAdapters( &dpspEnumData );

    if( FAILED( hr ) )
    {
    	DPFX(DPFPREP,  0, "Error enumerating adapters hr=0x%x", hr );
    	goto STARTLISTEN_ERROR;
    }

	// So we prevent listens from being completed before they are all started.
    Lock();

    for( dwAdapterIndex = 0; dwAdapterIndex < dpspEnumData.dwAdapterCount; dwAdapterIndex ++ )
    {
    	hr = StartListen( dpspEnumData.pAdapterData[dwAdapterIndex].guid );

    	if( FAILED( hr ) )
    	{
			DPFX(DPFPREP,  0, "Failed starting a listen on an adapter hr=0x%x", hr  );
    	}
    }

    UnLock();

    WaitForSingleObject( m_hListenCompleteEvent, INFINITE );

    m_fInitialized = TRUE;

    hr = DPN_OK;

STARTLISTEN_EXIT:

	if( pdp8Address )
		pdp8Address->Release();

	if( pbDataBuffer )
		delete [] pbDataBuffer;

	return hr;

STARTLISTEN_ERROR:

	goto STARTLISTEN_EXIT;
	
}

#undef DPF_MODNAME
#define DPF_MODNAME "CProcessAppList::Handle_ListenStatus"
HRESULT CProcessAppList::Handle_ListenStatus( PSPIE_LISTENSTATUS pListenStatus )
{
	BOOL fFound = FALSE;
	
    DPFX(DPFPREP,  5, "EVENT = LISTENSTATUS: " );

    InterlockedDecrement( &m_lNumListensOutstanding );

/*
	// We need the lock to protect the listen list
	Lock();

	// One less listen to worry about...
    m_dwNumListensOutstanding--;

	pListenInfo = (PLISTEN_INFO) pListenStatus->pUserContext;

	DNASSERT( pListenInfo );

	// If we failed, drop the count and remove the record
    if( FAILED( pListenStatus->hResult ) )
    {
    	DPFX(DPFPREP,  0, "Listen failed hr=0x%x", pListenStatus->hResult );
    	m_dwNumListens--;
		pListenInfo->blListens.RemoveFromList();
		delete pListenInfo;
		goto HANDLELISTENSTATUS_DONE;
    }

    pListenInfo->hrListenResult = pListenStatus->hResult; 

HANDLELISTENSTATUS_DONE: */

	// Signal that all the listens have completed
    if( m_lNumListensOutstanding == 0 )
	    SetEvent( m_hListenCompleteEvent );    

//	UnLock();

    DPFX(DPFPREP,  5, "RESULT = [0x%lx]", pListenStatus->hResult );
    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CProcessAppList::QueryInterface"
HRESULT CProcessAppList::QueryInterface( IDP8SPCallback *pSP, REFIID riid, LPVOID * ppvObj )
{
    *ppvObj = pSP;
    return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CProcessAppList::AddRef"
ULONG CProcessAppList::AddRef( IDP8SPCallback *pSP )
{
    return 1;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CProcessAppList::Release"
ULONG CProcessAppList::Release( IDP8SPCallback *pSP )
{
    return 1;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CProcessAppList::Debug_DisplayAddressFromHandle"
HRESULT CProcessAppList::Debug_DisplayAddressFromHandle( HANDLE hEndPoint )
{
    SPGETADDRESSINFODATA    dnEndPointData;
    HRESULT                 hr = DPN_OK;

    dnEndPointData.hEndpoint = hEndPoint;
    dnEndPointData.pAddress = NULL;
    dnEndPointData.Flags = SP_GET_ADDRESS_INFO_REMOTE_HOST;

    hr = m_pdp8SP->GetAddressInfo( &dnEndPointData );
    
    if( FAILED( hr ) )
    {
        DPFX(DPFPREP,  0, "Unable to get remote address of endpoint hr=[0x%lx]", hr );
        goto DISPLAYADDRESSFROMHANDLE_RETURN;
    }

	hr = Debug_DisplayAddress(dnEndPointData.pAddress);
	
    if( FAILED( hr ) )
    {
        DPFX(DPFPREP,  0, "Unable to display remote address of endpoint hr=[0x%lx]", hr );
        dnEndPointData.pAddress->Release();
        goto DISPLAYADDRESSFROMHANDLE_RETURN;
    }
 
    dnEndPointData.pAddress->Release();
    dnEndPointData.pAddress = NULL;

 	dnEndPointData.Flags = SP_GET_ADDRESS_INFO_LOCAL_ADAPTER;

    hr = m_pdp8SP->GetAddressInfo( &dnEndPointData );

    if( FAILED( hr ) )
    {
        DPFX(DPFPREP,  0, "Unable to get local address of endpoint hr=[0x%lx]", hr );
        goto DISPLAYADDRESSFROMHANDLE_RETURN;
    }

	hr = Debug_DisplayAddress(dnEndPointData.pAddress);
	
    if( FAILED( hr ) )
    {
        DPFX(DPFPREP,  0, "Unable to display local address of endpoint hr=[0x%lx]", hr );
		dnEndPointData.pAddress->Release();
        goto DISPLAYADDRESSFROMHANDLE_RETURN;
    }

DISPLAYADDRESSFROMHANDLE_RETURN:

 	if( dnEndPointData.pAddress != NULL )
	    dnEndPointData.pAddress->Release();
	
    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CProcessAppList::Debug_DisplayAddress"
HRESULT CProcessAppList::Debug_DisplayAddress ( PDIRECTPLAY8ADDRESS pdp8Address )
{
    CHAR                    *pcAddressBuffer = NULL;
    DWORD                   dwSize = 0;
    HRESULT                 hr = DPN_OK;

    pdp8Address->AddRef();

    hr = pdp8Address->GetURLA( pcAddressBuffer, &dwSize );

    if( hr != DPNERR_BUFFERTOOSMALL )
    {
        DPFX(DPFPREP,  0, "Unable to get URL for address hr=[0x%lx]", hr );
        goto DISPLAYADDRESS_RETURN;
    }

    pcAddressBuffer = new CHAR[dwSize];

    if( pcAddressBuffer == NULL )
    {
        DPFX(DPFPREP,  0, "Error allocating memory!" );
        goto DISPLAYADDRESS_RETURN;
    }

    hr = pdp8Address->GetURLA( pcAddressBuffer, &dwSize );

    if( FAILED( hr ) )
    {
        DPFX(DPFPREP,  0, "Unable to get URL (w/Buffer) for address hr=[0x%lx]", hr );
        goto DISPLAYADDRESS_RETURN;
    }

    DPFX(DPFPREP,  5, "Address: %s", pcAddressBuffer );

DISPLAYADDRESS_RETURN:

    if( pdp8Address != NULL )
        pdp8Address->Release();

    if( pcAddressBuffer != NULL )
        delete [] pcAddressBuffer;

    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CProcessAppList::IndicateEvent"
HRESULT CProcessAppList::IndicateEvent( IDP8SPCallback *pSP, SP_EVENT_TYPE spetEvent,LPVOID pvData )
{
    PPROCESSAPPLIST This = ((PPROCESSAPPLISTCOMINTERFACE) pSP)->m_pProcessTable;

    HRESULT                 hr;

	DPFX(DPFPREP,  5, "Incoming Event = %d", spetEvent );

    switch( spetEvent )
    {
    case SPEV_CONNECT:
        DPFX(DPFPREP,  5, "Event = CONNECT" );
        hr = This->Handle_Connect( (PSPIE_CONNECT) pvData );
        DPFX(DPFPREP,  5, "Result = [0x%lx]", hr );
        return hr;

    case SPEV_DISCONNECT:
        DPFX(DPFPREP,  5, "Event = DISCONNECT" );
        hr = This->Handle_Disconnect( (PSPIE_DISCONNECT) pvData );
        DPFX(DPFPREP,  5, "Result = [0x%lx]", hr );
        return hr;

    case SPEV_LISTENSTATUS:
        DPFX(DPFPREP,  5, "Event = LISTENSTATUS" );
        hr = This->Handle_ListenStatus( (PSPIE_LISTENSTATUS) pvData );
        DPFX(DPFPREP,  5, "Result = [0x%lx]", hr );
        return hr;

    case SPEV_ENUMQUERY:
        DPFX(DPFPREP,  5, "Event = ENUMQUERY" );
        hr = This->Handle_EnumRequest( (PSPIE_QUERY) pvData );
        DPFX(DPFPREP,  5, "Result = [0x%lx]", hr );
        return hr;

    case SPEV_QUERYRESPONSE:
        DPFX(DPFPREP,  5, "Event = ENUMRESPONSE" );
        hr = This->Handle_EnumResponse( (PSPIE_QUERYRESPONSE) pvData );
        DPFX(DPFPREP,  5, "Result = [0x%lx]", hr );
        return hr;

    case SPEV_DATA:
        DPFX(DPFPREP,  5, "Event = DATA" );
        hr = This->Handle_Data( (PSPIE_DATA) pvData );
        DPFX(DPFPREP,  5, "Result = [0x%lx]", hr );
        return hr;

    case SPEV_UNKNOWN:
        DPFX(DPFPREP,  5, "Event = UNKNOWN" );
        DPFX(DPFPREP,  5, "Response = Ignore" );
        DPFX(DPFPREP,  5, "Result = DPN_OK" );

        return DPN_OK;
    }

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CProcessAppList::CommandComplete"
HRESULT CProcessAppList::CommandComplete( IDP8SPCallback *pSP,HANDLE hCommand,HRESULT hrResult,LPVOID pvData )
{
    DPFX(DPFPREP,  5, "CommandComplete Received.  Handle: [0x%p]  Result: [0x%lx]", hCommand, hrResult );

	// The only command that will have data associated with it will be a listen
    if( pvData )
    {
		PLISTEN_INFO pListenInfo = (PLISTEN_INFO) pvData;    

		// This should be last reference, but not neccessarily 
		pListenInfo->Release();
    }
   
    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CProcessAppList::Initialize"
HRESULT CProcessAppList::Initialize( const GUID * const pguidSP, CLockedFixedPool<CProcessAppEntry> *pProcessEntryPool )
{
    HRESULT hr;
    PDIRECTPLAY8ADDRESS pdp8Address = NULL;
    SPINITIALIZEDATA spInit;
    DWORD dwPort = DPNA_DPNSVR_PORT;

    m_hListenCompleteEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
    if (m_hListenCompleteEvent == NULL)
	{
	    DPFX(DPFPREP,  0, "Out of memory allocating event");
		return DPNERR_OUTOFMEMORY;
	}

    if (!DNInitializeCriticalSection( &m_csLock ) )
	{
	    DPFX(DPFPREP,  0, "Failed to create critical section");
		return DPNERR_OUTOFMEMORY;
	}
	m_fCritSecInited = TRUE;

    m_blListens.Initialize();
    m_pProcessAppEntryPool = pProcessEntryPool;
    m_guidSP = *pguidSP;

	hr = COM_CoCreateInstance( *pguidSP, NULL, CLSCTX_INPROC_SERVER, IID_IDP8ServiceProvider, (void **) &m_pdp8SP );

	if( FAILED( hr ) )
	{
	    DPFX(DPFPREP,  0, "Unable to load SP hr=0x%x", hr );
	    return hr;
	}

	spInit.pIDP = (IDP8SPCallback *) &m_vtbl;
	spInit.dwFlags = 0;

	hr = m_pdp8SP->Initialize(&spInit);

    if( FAILED( hr ) )
    {
        DPFX(DPFPREP,  0, "Error initializing service provider hr=0x%x", hr );
        goto INITIALIZE_FAILED;
    }

    m_fOpened = TRUE;

	m_hrListenResult = StartListens();

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Error starting listens hr=0x%x", hr );
		goto INITIALIZE_FAILED;
	}

    return m_hrListenResult;

INITIALIZE_FAILED:

    if( m_pdp8SP )
    {
        if( m_fOpened )
            m_pdp8SP->Close();

        m_pdp8SP->Release();
        m_pdp8SP = NULL;
    }

    if( pdp8Address != NULL )
    {
        pdp8Address->Release();
    }

    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CProcessAppList::IsListenRunningOnDevice"
BOOL CProcessAppList::IsListenRunningOnDevice( GUID &guidDevice )
{
	CBilink *pLocation;
	BOOL fFound = FALSE;
	PLISTEN_INFO pListenInfo;

	Lock();
	
	// Search for the corresponding record in our list
	pLocation = m_blListens.GetNext();

	while( pLocation != &m_blListens )
	{
		pListenInfo = CONTAINING_RECORD( pLocation, LISTEN_INFO, blListens );

		DNASSERT( pListenInfo );		

		if( pListenInfo->guidDevice == guidDevice )
		{
			fFound = TRUE;
			break;
		}			
		
		pLocation = pLocation->GetNext();
	}

	UnLock();

	return fFound;
	
}

#undef DPF_MODNAME
#define DPF_MODNAME "CProcessAppList::CheckEntryForNewDevice"
//
// This function checks the list of devices we have listens on and if the devices specified in this entry
// contain a device we're not listening on, we'll start a new listen.
//
// Handles the case where you've dialed up after DPNSVR has started.
//
// We only need to check the latest address because this is called after every address is added.
//  
HRESULT CProcessAppList::CheckEntryForNewDevice( CProcessAppEntry *pProcessAppEntry )
{
	DWORD dwNumAddresses = 0; 
	DWORD dwAddressIndex = 0;
	PDIRECTPLAY8ADDRESS pdpAddressToCheck = NULL;
	HRESULT hr = DPN_OK;
	GUID guidTmpDevice;

	DPFX(DPFPREP,  DVF_INFOLEVEL, "Checking for new device" );   	

	pProcessAppEntry->Lock();

	dwNumAddresses = pProcessAppEntry->GetNumAddresses();

	if( dwNumAddresses == 0 )
	{
		pProcessAppEntry->UnLock();
		DPFX(DPFPREP,  0, "Error, invalid entry found!" );
		DNASSERT( FALSE );
		return DPNERR_GENERIC;
	}

	pdpAddressToCheck = pProcessAppEntry->GetAddress( dwNumAddresses-1 );

	DNASSERT( pdpAddressToCheck );

	pdpAddressToCheck->AddRef();

	pProcessAppEntry->UnLock();

	hr = pdpAddressToCheck->GetDevice( &guidTmpDevice );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  1, "Error finding device element for entry hr=0x%x", hr );
		DNASSERT( FALSE );			
		goto CHECKENTRYFORNEWDEVICE_EXIT;
	}

	DPFX(DPFPREP,  DVF_INFOLEVEL, "Checking for existing listen" );   	

	// We lock here so that we don't end up with a situation
	// where two seperate registrations attempt to 
	// crack a new listen
	Lock();

	if( !IsListenRunningOnDevice( guidTmpDevice ) )
	{
		DPFX(DPFPREP,  DVF_INFOLEVEL, "Detected we needed to start new listen" );   		
		
		hr = StartListen( guidTmpDevice );

		if( FAILED( hr ) )
		{
			DPFX(DPFPREP,  1, "Error starting listen on this device, in-use? hr=0x%x", hr );
			DNASSERT( FALSE );
			goto CHECKENTRYFORNEWDEVICE_EXIT;
		}
	}

	UnLock();

	DPFX(DPFPREP,  DVF_INFOLEVEL, "Done" );   	

CHECKENTRYFORNEWDEVICE_EXIT:

	if( pdpAddressToCheck )
	{
		pdpAddressToCheck->Release();
	}

	return hr;

}

#undef DPF_MODNAME
#define DPF_MODNAME "CProcessAppList::AddApplication"
HRESULT CProcessAppList::AddApplication( PDPNSVMSG_OPENPORT pmsgOpenPort )
{
    HRESULT hr;
    PPROCESSAPPENTRY pProcessAppEntry;

    DPFX(DPFPREP,  DVF_INFOLEVEL, "AddApplication Begin" );

    hr = FindAppEntry( pmsgOpenPort->dwProcessID, pmsgOpenPort->guidInstance, &pProcessAppEntry );

    DPFX(DPFPREP,  DVF_INFOLEVEL, "Search for Entry() hr=0x%x", hr );    

    if( FAILED( hr ) )
    {
        pProcessAppEntry = Get();

        if( pProcessAppEntry == NULL )
        {
            DPFX(DPFPREP,  0, "Error allocating new entry!" );
            return DPNERR_OUTOFMEMORY;
        }

        hr = pProcessAppEntry->Initialize( pmsgOpenPort, this );

	    DPFX(DPFPREP,  DVF_INFOLEVEL, "Initializing new Entry() hr=0x%x", hr );          

        if( FAILED( hr ) )
        {
            DPFX(DPFPREP,  0, "Error initializing new entry hr=0x%lx", hr );
            pProcessAppEntry->Release();
            return hr;
        }

        // Insert the new element into the list
        Lock();

        pProcessAppEntry->m_blProcessApps.InsertBefore( &m_blProcessApps );

        UnLock();

	    DPFX(DPFPREP,  DVF_INFOLEVEL, "Checking for device config change" );            

		// Check for devices in this new entry that we're not yet listening on
		// (Used to detect when new device comes on-line)
		CheckEntryForNewDevice( pProcessAppEntry );        

        return DPN_OK;
    }
    else
    {
	    DPFX(DPFPREP,  DVF_INFOLEVEL, "Found existing entry" );  
    	
		hr = pProcessAppEntry->AddAddress( pmsgOpenPort );

	    DPFX(DPFPREP,  DVF_INFOLEVEL, "Adding additional listen hr=0x%x", hr );  

	    DPFX(DPFPREP,  DVF_INFOLEVEL, "Checking for device config change" );   	    

		// Check for devices in this new entry that we're not yet listening on
		// (Used to detect when new device comes on-line)
		CheckEntryForNewDevice( pProcessAppEntry );

		// Release the reference from the Find

        pProcessAppEntry->Release();

        return hr;
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "CProcessAppList::RemoveApplication"
HRESULT CProcessAppList::RemoveApplication( PDPNSVMSG_CLOSEPORT pmsgClosePort )
{
    HRESULT hr;
    PPROCESSAPPENTRY pProcessAppEntry;

    hr = FindAppEntry( pmsgClosePort->dwProcessID, pmsgClosePort->guidInstance, &pProcessAppEntry );

    if( FAILED( hr ) )
    {
        DPFX(DPFPREP,  0, "Unable to retrieve specified element hr=0x%x", hr );
        return hr;
    }

    // We need to remove it from the list.  Remove our reference.
    Lock();

    // Remove find ref count
    pProcessAppEntry->Release();

    // Remove out global ref count
    pProcessAppEntry->Release();

    UnLock();

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CProcessAppList::FindAppEntry"
HRESULT CProcessAppList::FindAppEntry( DWORD dwProcessID, GUID &guidInstance, CProcessAppEntry **ppProcessAppEntry )
{
    CBilink *pblSearch;
    PPROCESSAPPENTRY pProcessAppEntry;

    Lock();

    pblSearch = m_blProcessApps.GetNext();

    while( pblSearch != &m_blProcessApps )
    {
        pProcessAppEntry = CONTAINING_RECORD( pblSearch, PROCESSAPPENTRY, m_blProcessApps );
        pblSearch = pblSearch->GetNext();

        pProcessAppEntry->AddRef();

        if( guidInstance == *(pProcessAppEntry->GetInstanceGUID()) &&
            dwProcessID == pProcessAppEntry->GetProcessID() )
        {
            *ppProcessAppEntry = pProcessAppEntry;
            UnLock();
            return DPN_OK;
        }

        pProcessAppEntry->Release();
    }

    UnLock();

    return DPNERR_DOESNOTEXIST;
}

// ZombieCheckAndRemove
//
// This function displays
#undef DPF_MODNAME
#define DPF_MODNAME "CProcessAppList::ZombieCheckAndRemove"
HRESULT CProcessAppList::ZombieCheckAndRemove()
{
    CBilink *pblSearch;
    PPROCESSAPPENTRY pProcessAppEntry;

    Lock();

    pblSearch = m_blProcessApps.GetNext();

    while( pblSearch != &m_blProcessApps )
    {
        pProcessAppEntry = CONTAINING_RECORD( pblSearch, PROCESSAPPENTRY, m_blProcessApps );
        pblSearch = pblSearch->GetNext();

        pProcessAppEntry->AddRef();

        if( !pProcessAppEntry->CheckRunning( ) )
        {
            DPFX(DPFPREP,  5, "Process has exited:\n" );
            pProcessAppEntry->Debug_DisplayInfo();
            // Remove global ref count
            pProcessAppEntry->Release();
        }

        pProcessAppEntry->Release();
    }

    UnLock();

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CProcessAppList::Handle_EnumRequest"
HRESULT CProcessAppList::Handle_EnumRequest( PSPIE_QUERY pEnumRequest )
{
    DPFX(DPFPREP,  5, "EVENT = ENUMREQUEST - Source Address and Device:" );
    Debug_DisplayAddress( pEnumRequest->pAddressSender );
	Debug_DisplayAddress( pEnumRequest->pAddressDevice );

    CBilink *pblSearch;
    PPROCESSAPPENTRY pProcessAppEntry;
    HRESULT hr;

    Lock();

    // Increment statistics
    m_dwEnumRequests++;
    m_dwEnumRequestBytes += pEnumRequest->pReceivedData->BufferDesc.dwBufferSize;

    pblSearch = m_blProcessApps.GetNext();

    while( pblSearch != &m_blProcessApps )
    {
        pProcessAppEntry = CONTAINING_RECORD( pblSearch, PROCESSAPPENTRY, m_blProcessApps );

        pProcessAppEntry->AddRef();

        DPFX(DPFPREP,  5, "Forwarding request to:" );
        pProcessAppEntry->Debug_DisplayInfo();

        hr = pProcessAppEntry->ForwardEnum( pEnumRequest );

        if( FAILED( hr ) )
        {
            DPFX(DPFPREP,  0, "Error forwarding request hr=[0x%lx]", hr );
        }

        pblSearch = pblSearch->GetNext();

        pProcessAppEntry->Release();
    }

	UnLock();    

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CProcessAppList::Handle_EnumResponse"
HRESULT CProcessAppList::Handle_EnumResponse( PSPIE_QUERYRESPONSE pEnumResponse )
{
    DPFX(DPFPREP,  5, "EVENT = ENUMRESPONSE - Source Address and Device: " );
    Debug_DisplayAddress( pEnumResponse->pAddressSender );
	Debug_DisplayAddress( pEnumResponse->pAddressDevice );

    m_dwEnumReplies++;

    DPFX(DPFPREP,  5, "Response = IGNORE" );
    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CProcessAppList::Handle_Connect"
HRESULT CProcessAppList::Handle_Connect( PSPIE_CONNECT pConnect )
{
    DPFX(DPFPREP,  5, "EVENT = CONNECT - Source Address: " );
    Debug_DisplayAddressFromHandle( pConnect->hEndpoint );

    m_dwConnectRequests++;

    DPFX(DPFPREP,  5, "Response = DENY" );

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CProcessAppList::Handle_Disconnect"
HRESULT CProcessAppList::Handle_Disconnect( PSPIE_DISCONNECT pDisconnect )
{
    DPFX(DPFPREP,  5, "EVENT = DISCONNECT - Source Address: " );
    Debug_DisplayAddressFromHandle( pDisconnect->hEndpoint );

    m_dwDisconnectRequests++;

    DPFX(DPFPREP,  5, "Response = IGNORE" );
    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CProcessAppList::Handle_Data"
HRESULT CProcessAppList::Handle_Data( PSPIE_DATA pData )
{
    DPFX(DPFPREP,  5, "EVENT = DATA - Source Address: " );
    Debug_DisplayAddressFromHandle( pData->hEndpoint );

    m_dwDataRequests++;

    DPFX(DPFPREP,  5, "Response = IGNORE" );
    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CProcessAppEntry::Debug_DisplayInfo"
void CProcessAppEntry::Debug_DisplayInfo()
{
    TCHAR szInstanceGuidString[50];
    TCHAR szAppGuidString[50];
    char *szURL = NULL;
    DWORD dwURLSize = 0;
    HRESULT hr;

    wsprintf( szInstanceGuidString, _T("{%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}"),
    	        m_guidInstance.Data1, m_guidInstance.Data2, m_guidInstance.Data3, m_guidInstance.Data4[0],
                m_guidInstance.Data4[1], m_guidInstance.Data4[2], m_guidInstance.Data4[3], m_guidInstance.Data4[4],
                m_guidInstance.Data4[5], m_guidInstance.Data4[6], m_guidInstance.Data4[7] );

    wsprintf( szAppGuidString, _T("{%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}"),
    	        m_guidApplication.Data1, m_guidApplication.Data2, m_guidApplication.Data3, m_guidApplication.Data4[0],
                m_guidApplication.Data4[1], m_guidApplication.Data4[2], m_guidApplication.Data4[3], m_guidApplication.Data4[4],
                m_guidApplication.Data4[5], m_guidApplication.Data4[6], m_guidApplication.Data4[7] );

    DPFX(DPFPREP,  5, "PROCESS = [%d] INSTANCE = [%s] APPLICATION = [%s] TARGETNUM = [%d] TARGETS=",
         m_dwProcessID, szInstanceGuidString, szAppGuidString, m_dwNumAddresses );

    for( DWORD dwIndex = 0; dwIndex < m_dwNumAddresses; dwIndex++ )
    {
        if( m_pdpAddresses[dwIndex] != NULL )
        {
			dwURLSize = 0;

            hr = m_pdpAddresses[dwIndex]->GetURLA( szURL, &dwURLSize );

            if( hr == DPNERR_BUFFERTOOSMALL )
            {
                szURL = new char[dwURLSize];

                if( szURL != NULL )
                {
                    szURL[0] = 0;
                    hr = m_pdpAddresses[dwIndex]->GetURLA( szURL, &dwURLSize );
                }
                else
                {
                    DPFX(DPFPREP,  0, "Error allocating memory" );
                }
            }
            else
            {
                DPFX(DPFPREP,  0, "Error retrieving address hr=0x%lx", hr );
            }

            DPFX(DPFPREP,  5, "%d: %s", dwIndex, szURL );

            if( szURL != NULL )
            {
                delete [] szURL;
                szURL = NULL;
            }
        }
    }


};

// CAUTION: This function requires you have the lock on the table
#undef DPF_MODNAME
#define DPF_MODNAME "CProcessAppEntry::GetTableSizeBytes"
DWORD CProcessAppList::GetTableSizeBytes()
{
    DWORD dwSizeRequired = 0;
    CBilink *pblSearch;
    PPROCESSAPPENTRY pProcessAppEntry;
    HRESULT hr;
    DWORD dwURLSize;
    PDIRECTPLAY8ADDRESS pdpAddress;
    DWORD dwAddressIndex;

    // We need a header
    dwSizeRequired += sizeof( SERVERTABLEHEADER );

    pblSearch = m_blProcessApps.GetNext();

    while( pblSearch != &m_blProcessApps )
    {
        pProcessAppEntry = CONTAINING_RECORD( pblSearch, PROCESSAPPENTRY, m_blProcessApps );

        pProcessAppEntry->AddRef();

        // Add size of data structure
        dwSizeRequired += sizeof( SERVERTABLEENTRY );

        for( dwAddressIndex = 0; dwAddressIndex < pProcessAppEntry->GetNumAddressSlots(); dwAddressIndex++ )
        {
            pdpAddress = pProcessAppEntry->GetAddress(dwAddressIndex);

            if( pdpAddress != NULL )
            {
                // Add size for URL
                dwURLSize = 0;
                hr = pdpAddress->GetURLA( NULL, &dwURLSize );
                if( hr != DPNERR_BUFFERTOOSMALL )
                {
                    DPFX(DPFPREP,  1, "Could not retrieve address!" );
                }
                dwSizeRequired += dwURLSize;
            }
        }

        pProcessAppEntry->Release();

        pblSearch = pblSearch->GetNext();
    }

    return dwSizeRequired;
}

// CAUTION: This function requires you have the lock on the table
#undef DPF_MODNAME
#define DPF_MODNAME "CProcessAppEntry::CopyTable"
HRESULT CProcessAppList::CopyTable( PBYTE pbWriteLoc )
{
    DWORD dwSizeRequired = 0;
    CBilink *pblSearch;
    PPROCESSAPPENTRY pProcessAppEntry;
    HRESULT hr;
    DWORD dwURLSize;
    PDIRECTPLAY8ADDRESS pdpAddress;
    PBYTE pbCurrentLocation = pbWriteLoc;
    PSERVERTABLEHEADER pTableHeader;
    PSERVERTABLEENTRY pTableEntry;
    DWORD dwAddressIndex;
    DWORD dwTotalAddressSize = 0;

    pTableHeader = (PSERVERTABLEHEADER) pbWriteLoc;

    pTableHeader->guidSP = m_guidSP;
    pTableHeader->dwNumEntries = 0;
    pTableHeader->dwDataBlockSize = 0;

    pbWriteLoc += sizeof( SERVERTABLEHEADER );

    pblSearch = m_blProcessApps.GetNext();

    while( pblSearch != &m_blProcessApps )
    {
        pProcessAppEntry = CONTAINING_RECORD( pblSearch, PROCESSAPPENTRY, m_blProcessApps );

        pProcessAppEntry->AddRef();

        pTableHeader->dwNumEntries++;

        pTableEntry = (PSERVERTABLEENTRY) pbWriteLoc;
        pTableEntry->dwProcessID = pProcessAppEntry->GetProcessID();
        pTableEntry->guidApplication = *(pProcessAppEntry->GetApplicationGUID());
        pTableEntry->guidInstance = *(pProcessAppEntry->GetInstanceGUID());
        pTableEntry->lRefCount = pProcessAppEntry->GetRefCount();
        pTableEntry->dwNumAddresses = pProcessAppEntry->GetNumAddresses();

        pbWriteLoc += sizeof( SERVERTABLEENTRY );
        pTableHeader->dwDataBlockSize += sizeof( SERVERTABLEENTRY );

        dwTotalAddressSize = 0;

        for( dwAddressIndex = 0; dwAddressIndex < pProcessAppEntry->GetNumAddresses(); dwAddressIndex++ )
        {
            // Add size for URL
            pdpAddress = pProcessAppEntry->GetAddress(dwAddressIndex);

            dwURLSize = 0;
            hr = pdpAddress->GetURLA( NULL, &dwURLSize );

            if( hr != DPNERR_BUFFERTOOSMALL )
            {
                DPFX(DPFPREP,  1, "Could not retrieve address!" );
            }

            hr = pdpAddress->GetURLA( (char *) pbWriteLoc, &dwURLSize );

            if( FAILED( hr ) )
            {
                dwURLSize = 0;
            }

            pbWriteLoc += dwURLSize;
            pTableHeader->dwDataBlockSize += dwURLSize;
            dwTotalAddressSize += dwURLSize;
        }

        pTableEntry->dwStringSize = dwTotalAddressSize;

        // Increment datablock size
        pTableHeader->dwDataBlockSize += dwTotalAddressSize + sizeof( SERVERTABLEENTRY );

        pProcessAppEntry->Release();

        pblSearch = pblSearch->GetNext();
    }

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CProcessAppEntry::Initialize"
HRESULT CProcessAppEntry::Initialize( PDPNSVMSG_OPENPORT pmsgOpenPort, CProcessAppList *pOwner )
{
    HRESULT hr;

	DPFX(DPFPREP,  DVF_INFOLEVEL, "Creating new entry" );   		        

    m_dwProcessID = pmsgOpenPort->dwProcessID;
    m_pOwner = pOwner;
    m_lRefCount = 1;
    m_dwNumAddresses = 0;
	m_dwAddressSize = DPNSVR_NUM_INITIAL_SLOTS;
	m_pdpAddresses = new PDIRECTPLAY8ADDRESS[m_dwAddressSize];

	if( !m_pdpAddresses )
	{
		DPFX(DPFPREP,  0, "Error allocating memory for app entry" );
		return DPNERR_OUTOFMEMORY;
	}

    m_guidApplication = pmsgOpenPort->guidApplication;
    m_guidInstance = pmsgOpenPort->guidInstance;
    m_blProcessApps.Initialize();
    memset( m_pdpAddresses, 0x00, sizeof(PDIRECTPLAY8ADDRESS)*m_dwAddressSize );

    if (DNInitializeCriticalSection( &m_csLock ) == FALSE)
	{
		DPFX(DPFPREP,  0, "Error initalizing App Entry CS" );
		delete m_pdpAddresses;
		return DPNERR_OUTOFMEMORY;
	}

	// Also run the first add
	hr = AddAddress( pmsgOpenPort );

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CProcessAppEntry::AddAddress"
HRESULT CProcessAppEntry::AddAddress( PDPNSVMSG_OPENPORT pmsgOpenPort )
{
    BYTE *pbCurrentLocation;
    CHAR *pbCurrentString;
	HRESULT hr;

	DPFX(DPFPREP,  DVF_INFOLEVEL, "Adding address to object" );   		        	

	Lock();

	// We need to extend the addresss array
	if( m_dwNumAddresses == m_dwAddressSize )
	{
		DPFX(DPFPREP,  DVF_INFOLEVEL, "Growing address list" );   		        			
		
		PDIRECTPLAY8ADDRESS *pdpNewArray;

		pdpNewArray = new PDIRECTPLAY8ADDRESS[m_dwNumAddresses+DPNSVR_NUM_EXTEND_SLOTS];

		if( pdpNewArray == NULL )
		{
			DPFX(DPFPREP,  0, "Error allocating space for a new address" );
			UnLock();
			return DPNERR_OUTOFMEMORY;
		}

		memcpy( pdpNewArray, m_pdpAddresses, sizeof( PDIRECTPLAY8ADDRESS )*m_dwNumAddresses );

		for( DWORD dwIndex = m_dwNumAddresses; dwIndex < m_dwNumAddresses+DPNSVR_NUM_EXTEND_SLOTS; dwIndex++ )
		{
			pdpNewArray[dwIndex] = NULL;
		}

		if( m_pdpAddresses != NULL )
		    delete [] m_pdpAddresses;

		m_pdpAddresses = pdpNewArray;

		m_dwAddressSize += DPNSVR_NUM_EXTEND_SLOTS;
	}

    pbCurrentLocation = (PBYTE) &pmsgOpenPort[1];
    pbCurrentString = (CHAR *) pbCurrentLocation;

	hr = COM_CoCreateInstance( CLSID_DirectPlay8Address, NULL, CLSCTX_INPROC_SERVER, IID_IDirectPlay8Address, (void **) &m_pdpAddresses[m_dwNumAddresses] );

	if( FAILED( hr ) )
	{
	    DPFX(DPFPREP,  0, "Unable to create address object hr=[0x%x]", hr );
	    UnLock();
        return hr;
	}

	DPFX(DPFPREP,  DVF_INFOLEVEL, "Created new address" );   		        				

    hr = m_pdpAddresses[m_dwNumAddresses]->BuildFromURLA( pbCurrentString );

	DPFX(DPFPREP,  DVF_INFOLEVEL, "Conversion result hr=0x%x", hr );   		        				    

    if( FAILED( hr ) )
    {
        DPFX(DPFPREP,  0, "Unable to create address for URL=[%s]", pbCurrentString );
		goto ADDADDRESS_ERROR;
    }
	else
	{
		DPFX(DPFPREP,  DVF_INFOLEVEL, "Chcking for duplicate entry.." );   		        				    
	
		for( DWORD dwIndex = 0; dwIndex < m_dwNumAddresses; dwIndex++ )
		{
			if( m_pdpAddresses[dwIndex]->IsEqual( m_pdpAddresses[m_dwNumAddresses] ) == DPNSUCCESS_EQUAL )
			{
				DPFX(DPFPREP,  1, "WARNING: Asking for duplicate listen for %s", pbCurrentString );
				goto ADDADDRESS_ERROR;
			}
		}

		m_dwNumAddresses++;

		DPFX(DPFPREP,  DVF_INFOLEVEL, "No duplicate entry found count=%d..", m_dwNumAddresses );   		        				    
		
	}

ADDADDRESS_DONE:

	UnLock();

    return DPN_OK;

ADDADDRESS_ERROR:

	m_pdpAddresses[m_dwNumAddresses]->Release();
	m_pdpAddresses[m_dwNumAddresses] = NULL;

	goto ADDADDRESS_DONE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CProcessAppEntry::DeInitialize"
void CProcessAppEntry::DeInitialize()
{
    m_pOwner->Lock();
    m_blProcessApps.RemoveFromList();
    m_pOwner->UnLock();

    Lock();

    // Destroy the address list
    for( DWORD dwIndex = 0; dwIndex < m_dwNumAddresses; dwIndex++ )
    {
		if( m_pdpAddresses[dwIndex] != NULL )
		{
			m_pdpAddresses[dwIndex]->Release();
			m_pdpAddresses[dwIndex] = NULL;
		}
    }

    if( m_pdpAddresses != NULL )
        delete [] m_pdpAddresses;

    UnLock();

    m_dwAddressSize = 0;

    DNDeleteCriticalSection( &m_csLock );

    m_pOwner->Lock();
    m_pOwner->Return(this);
    m_pOwner->UnLock();
}

    // Forward the enumeration
#undef DPF_MODNAME
#define DPF_MODNAME "CProcessAppEntry::ForwardEnum"
HRESULT CProcessAppEntry::ForwardEnum( PSPIE_QUERY psieQuery  )
{
    SPPROXYENUMQUERYDATA spEnumProxy;
    IDP8ServiceProvider *pSP;
    HRESULT hr;
    GUID guidDevice;
    GUID guidTargetDevice;


    hr = psieQuery->pAddressDevice->GetDevice( &guidTargetDevice );

    if( FAILED( hr ) )
    {
    	DPFX(DPFPREP,  0, "Query device address from SP does not contain a device element, ignoring hr=0x%x", hr );
    	return DPN_OK;
    }

    // Get the SP we want to forward to.  This incremements SP ref count
    pSP = m_pOwner->GetSP();

    spEnumProxy.dwFlags = 0;
    spEnumProxy.pIncomingQueryData = psieQuery;

    // Forward to the address listen
    for( DWORD dwIndex = 0; dwIndex < m_dwNumAddresses; dwIndex++ )
    {
        // Lock briefly to get address
        Lock();

		// Get the device, make sure we want to forward to this address
        hr = m_pdpAddresses[dwIndex]->GetDevice( &guidDevice );

        if( FAILED( hr ) )
        {
        	UnLock();
        	continue;
        }

        if( guidDevice != guidTargetDevice )
        {
        	UnLock();
        	DPFX(DPFPREP, 7, "Device GUID doesn't match that of the listen registered at index %u.", dwIndex );
        	continue;
        }

        spEnumProxy.pDestinationAdapter = m_pdpAddresses[dwIndex];

		if( m_pdpAddresses[dwIndex] == NULL )
		{
		    UnLock();
		    continue;
		}
		
   	    spEnumProxy.pDestinationAdapter->AddRef();
        UnLock();

        DPFX(DPFPREP,  5, "Forwarding enum to: " );
        Debug_DisplayInfo();

	    hr = pSP->ProxyEnumQuery( &spEnumProxy );

	    if( FAILED( hr ) )
	    {
	        DPFX(DPFPREP,  0, "Proxy forward of enumeration failed hr=0x%x", hr );
		    // Release the address
		    spEnumProxy.pDestinationAdapter->Release();
		    break;
		}

	    spEnumProxy.pDestinationAdapter->Release();
    }

    // Release our SP reference
    pSP->Release();

    return hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\dpnsvr\inc\dpnsdef.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999, 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpnsdef.cpp
 *  Content:    DirectPlay8 Server Definitions
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 * 03/14/00     rodtoll Created it
 * 03/23/00     rodtoll Updated to match new data structure and add new GUID
 * 03/25/00     rodtoll Changed status format to support N provider
 *              rodtoll New GUID for mutex guarding status
 ***************************************************************************/

#ifndef __DPNSDEF_H
#define __DPNSDEF_H


// STRING_GUID_DPNSVR - Name of Event used to signal Server to exit
//
#define STRING_GUID_DPNSVR_KILL _T("{29A0C4D1-E9C9-4ad0-B7F3-8E28FB0DD5E0}")

DEFINE_GUID(GUID_DPNSVR_KILL, 
0x29a0c4d1, 0xe9c9, 0x4ad0, 0xb7, 0xf3, 0x8e, 0x28, 0xfb, 0xd, 0xd5, 0xe0);

// STRING_GUID_DPNSVR_STATUS_MEMORY - Name of shared memory location used to 
// write data on current status to.  
#define STRING_GUID_DPNSVR_STATUS_MEMORY _T("{A7B81E49-A7DD-4066-A970-E07C67D8DFB1}")

DEFINE_GUID(GUID_DPNSVR_STATUS_MEMORY, 
0xa7b81e49, 0xa7dd, 0x4066, 0xa9, 0x70, 0xe0, 0x7c, 0x67, 0xd8, 0xdf, 0xb1);

// STRING_GUID_DPNSVR_TABLE_MEMBORY - Name of shared memory location used to
// write table to.
//
#define STRING_GUID_DPNSVR_TABLE_MEMORY _T("{733A46D6-B5DB-47e7-AE67-464577CD687C}")

DEFINE_GUID(GUID_DPNSVR_TABLE_MEMORY, 
0x733a46d6, 0xb5db, 0x47e7, 0xae, 0x67, 0x46, 0x45, 0x77, 0xcd, 0x68, 0x7c);

// STRING_GUID_DPNSVR_STATUSSTORAGE
//
// Mutex protecting status storage
//
#define STRING_GUID_DPNSVR_STATUSSTORAGE _T("{9F84FFA4-680E-48d8-9DBA-4AA8591AB8E3}")

DEFINE_GUID(GUID_DPNSVR_STATUSSTORAGE, 
0x9f84ffa4, 0x680e, 0x48d8, 0x9d, 0xba, 0x4a, 0xa8, 0x59, 0x1a, 0xb8, 0xe3);


// STRING_GUID_DPSVR_TABLESTORAGE -
//
// Mutex protecting table storage
#define STRING_GUID_DPSVR_TABLESTORAGE _T("{23AD69B4-E81C-4292-ABD4-2EAF9A262E91}")

DEFINE_GUID(GUID_DPSVR_TABLESTORAGE, 
0x23ad69b4, 0xe81c, 0x4292, 0xab, 0xd4, 0x2e, 0xaf, 0x9a, 0x26, 0x2e, 0x91);

// STRING_GUID_DPNSVR_QUEUE -
//
// Queue name for IPC server queue
#define STRING_GUID_DPNSVR_QUEUE    _T("{CCD83B99-7091-43df-A062-7EC62A66207A}")

DEFINE_GUID(GUID_DPNSVR_QUEUE, 
0xccd83b99, 0x7091, 0x43df, 0xa0, 0x62, 0x7e, 0xc6, 0x2a, 0x66, 0x20, 0x7a);

// STRING_GUID_DPNSVR_RUNNING
//
// Used for name of event that determines if it's running
#define STRING_GUID_DPNSVR_RUNNING  _T("{D8CF6BF0-3CFA-4e4c-BA39-40A1E7AFBCD7}")

DEFINE_GUID(GUID_DPNSVR_RUNNING, 
0xd8cf6bf0, 0x3cfa, 0x4e4c, 0xba, 0x39, 0x40, 0xa1, 0xe7, 0xaf, 0xbc, 0xd7);

// STRING_GUID_DPNSVR_STARTUP
//
// Name of manual reset event that is signalled once server has started;
//
#define STRING_GUID_DPNSVR_STARTUP _T("{0CBA5850-FD98-4cf8-AC49-FC3ED287ACF1}")

DEFINE_GUID(GUID_DPNSVR_STARTUP, 
0xcba5850, 0xfd98, 0x4cf8, 0xac, 0x49, 0xfc, 0x3e, 0xd2, 0x87, 0xac, 0xf1);

typedef UNALIGNED struct _SERVICESTATUS_HEADER
{
    DWORD       dwNumServices;
    DWORD       dwTimeStart;
} SERVICESTATUSHEADER, *PSERVICESTATUSHEADER;

typedef UNALIGNED struct _SERVICESTATUS
{
    GUID        guidSP;
    DWORD       dwNumNodes;
    DWORD       dwEnumRequests;
    DWORD       dwConnectRequests;
    DWORD       dwDisconnectRequests;
    DWORD       dwDataRequests;
    DWORD       dwEnumReplies;
    DWORD       dwEnumRequestBytes;
} SERVICESTATUS, *PSERVICESTATUS;

// SERVERTABLE
//
// The following structures are used for dumping the current contents of
// the port / application structure table.
//
// The table format in memory is as follows:
// [SERVERTABLEHEADERIP] [SERVERTABLENTRY1] [SERVERTABLENTRY2] ... [SERVERTABLEENTRY1's URL] [ SERVERTABLEENTRY2's URL]
// [SERVERTABLEHEADERIPX] [SERVERTABLENTRY1] [SERVERTABLENTRY2] ... [SERVERTABLEENTRY1's URL] [ SERVERTABLEENTRY2's URL]
//
typedef UNALIGNED struct _SERVERTABLEHEADER
{
    GUID        guidSP;
    DWORD       dwNumEntries;               // # of entries in the table
    DWORD       dwDataBlockSize;            // Size of this table in memory (not including header)
} SERVERTABLEHEADER, *PSERVERTABLEHEADER;

// SERVERTABLENTRY
//
// Single entry in the table
//
typedef UNALIGNED struct _SERVERTABLEENTRY
{
    DWORD       dwProcessID;
    GUID        guidApplication;
    GUID        guidInstance;
    LONG        lRefCount;
    DWORD       dwStringSize;
    DWORD       dwNumAddresses;
} SERVERTABLEENTRY, *PSERVERTABLEENTRY;

#define DPLAYSERVER8_TIMEOUT_ZOMBIECHECK        1000
#define DPLAYSERVER8_TIMEOUT_RESULT             1000
#define DPLAYSERVER8_ENTRY_ADDRESSSLOTS_DEFAULT 3
#define DPLAYSERVER8_ENTRY_ADDRESSSLOTS_INC     3

typedef void (*PSTATUSHANDLER)(PVOID pvData,PVOID pvUserContext);
typedef void (*PTABLEHANDLER)(PVOID pvData,PVOID pvUserContext);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\dpnsvr\dpnsvr\sources.inc ===
#
# The MAJORCOMP and MINORCOMP variables are defined
# so that $(MAJORCOMP)$(MINORCOMP)filename can be used in
# cross compiling to provide unique filenames in a flat namespace.
#

MAJORCOMP=windows
MINORCOMP=media

#
# The TARGETNAME variable is defined by the developer.  It is the name of
# the target (component) that is being built by this makefile.  It
# should NOT include any path or file extension information.
#

TARGETNAME=dpnsvr


#
# The TARGETPATH and TARGETTYPE variables are defined by the developer.
# The first specifies where the target is to be build.  The second specifies
# the type of target (either PROGRAM, DYNLINK, LIBRARY, DRIVER, etc
# UMAPPL_NOLIB is used when you're only building user-mode
# apps and don't need to build a library.
#

TARGETPATH=obj
TARGETTYPE=PROGRAM
UMENTRY=winmain
UMTYPE=windows

!if "$(DPLAY_PCH)" != "off"
PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\dnsvri.h
PRECOMPILED_PCH=dnsvri.pch
PRECOMPILED_OBJ=dnsvri.obj
!endif

#
# The TARGETLIBS specifies additional libraries to link with you target
# image.  Each library path specification should contain an asterisk (*)
# where the machine specific subdirectory name should go.
#

#
# 04/10/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
           ..\..\..\guids\obj$(BUILD_ALT_DIR)\*\guids.lib \
           ..\..\..\common\obj$(BUILD_ALT_DIR)\*\common.lib \
	   ..\..\dpnsvlib\obj$(BUILD_ALT_DIR)\*\dpnsvlib.lib \
	   $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
	   $(BASEDIR)\public\sdk\lib\*\user32.lib \
	   $(BASEDIR)\public\sdk\lib\*\gdi32.lib \
	   $(BASEDIR)\public\sdk\lib\*\winmm.lib \
	   $(BASEDIR)\public\sdk\lib\*\dsound.lib \
	   $(BASEDIR)\public\sdk\lib\*\msacm32.lib \
	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
	   $(BASEDIR)\public\sdk\lib\*\ole32.lib  \
	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
	   $(BASEDIR)\public\sdk\lib\*\msvcrt.lib

!if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
C_DEFINES=$(C_DEFINES) /DDEBUG /D_DEBUG
!endif

#
# The INCLUDES variable specifies any include paths that are specific to
# this source directory.  Separate multiple directory paths with single
# semicolons.  Relative path specifications are okay.
#

INCLUDES=..\;..\..\..\inc;..\..\inc;..\..\..\common;..\..\dpnsvlib;$(DXROOT)\inc


#
# The SOURCES variable is defined by the developer.  It is a list of all the
# source files for this component.  Each source file should be on a separate
# line using the line continuation character.  This will minimize merge
# conflicts if two developers adding source files to the same component.
#

SOURCES=..\dpnsvr.cpp ..\dpsvr8.cpp ..\dpnsvr.rc ..\proctbl.cpp


#
# Next specify options for the compiler.
#
# Note about CRT defines.  When linking with MSVCRT you must have both _MT and _DLL specified.
# Using the build environment's USE_MSVCRT=1 would do this for us, but because we define our
# own operator new this will cause a link error because the build environment will not properly
# pull in msvcrt.lib last as of 5/11/2001.  Therefore, we do it all manually specifying _DLL, _MT, 
# and msvcrt.lib and USE_NOLIBS=1 ourselves.  This also means that we must manually add msvcprt.lib 
# where STL is used.
#
C_DEFINES= $(C_DEFINES) /D_WINDOWS /DWIN32 /D_MT /D_DLL

USE_NOLIBS=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\inc\dpaddr.h ===
/*==========================================================================;
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpaddr.h
 *  Content:   DirectPlayAddress include file
//@@BEGIN_MSINTERNAL
 *  History:
 *	Date		By		Reason
 *	==========================
 *	01/31/2000	rmt		created
 *  02/12/2000  rmt		Split Get into GetByIndex and GetByName
 *  02/14/2000  vpo		Hid remaining references to Internal
 *  02/17/2000	rmt		Added dnet header def and removed error codes (see dplay8.h for error codes for them)
 *  02/21/2000	rmt		Cleared out redundant interfaces, added defines, added new macros
 *  03/22/2000  rmt     Updated to add SetEqual, BuildFromDPAddress and new ANSI data type
 *  03/24/2000	rmt		Added IsEqual function
 *  05/04/2000  rmt     Bug #34155 - Incorrect defines
 *  06/09/00    rmt     Updates to split CLSID and allow whistler compat and support external create funcs
 *  08/03/2000 	rmt		Bug #41246 - Remove IP versions of Duplicate, SetEqual, IsEqual, BuildURL
 *  08/07/2000  rmt     Bug #41185 - Header Cleanup
 *  03/17/2001	rmt		WINBUG #342420 - Commented out create functions 
//@@END_MSINTERNAL
 ***************************************************************************/

#ifndef __DIRECTPLAYADDRESS__
#define __DIRECTPLAYADDRESS__

#include <ole2.h>			// for DECLARE_INTERFACE and HRESULT

#ifdef __cplusplus
extern "C" {
#endif

#include "dplay8.h"

/****************************************************************************
 *
 * DirectPlay8Address CLSIDs
 *
 ****************************************************************************/

// {934A9523-A3CA-4bc5-ADA0-D6D95D979421}
DEFINE_GUID(CLSID_DirectPlay8Address,
0x934a9523, 0xa3ca, 0x4bc5, 0xad, 0xa0, 0xd6, 0xd9, 0x5d, 0x97, 0x94, 0x21);

/****************************************************************************
 *
 * DirectPlay8Address Interface IIDs
 *
 ****************************************************************************/

//@@BEGIN_MSINTERNAL
// {B483A30A-C8A9-4d76-9BC9-37558080C608}
DEFINE_GUID(IID_IDirectPlay8AddressInternal,
0xb483a30a, 0xc8a9, 0x4d76, 0x9b, 0xc9, 0x37, 0x55, 0x80, 0x80, 0xc6, 0x8);
//@@END_MSINTERNAL

// {83783300-4063-4c8a-9DB3-82830A7FEB31}
DEFINE_GUID(IID_IDirectPlay8Address,
0x83783300, 0x4063, 0x4c8a, 0x9d, 0xb3, 0x82, 0x83, 0xa, 0x7f, 0xeb, 0x31);

// {E5A0E990-2BAD-430b-87DA-A142CF75DE58}
DEFINE_GUID(IID_IDirectPlay8AddressIP,
0xe5a0e990, 0x2bad, 0x430b, 0x87, 0xda, 0xa1, 0x42, 0xcf, 0x75, 0xde, 0x58);


/****************************************************************************
 *
 * DirectPlay8Address Interface Pointer definitions
 *
 ****************************************************************************/

//@@BEGIN_MSINTERNAL
typedef struct IDirectPlay8AddressInternal	 *PDIRECTPLAY8ADDRESSINTERNAL, *LPDIRECTPLAY8ADDRESSINTERNAL;
//@@END_MSINTERNAL

typedef struct IDirectPlay8Address			*PDIRECTPLAY8ADDRESS, *LPDIRECTPLAY8ADDRESS;
typedef struct IDirectPlay8AddressIP		*PDIRECTPLAY8ADDRESSIP, *LPDIRECTPLAY8ADDRESSIP;

/****************************************************************************
 *
 * DirectPlay8Address Forward Declarations For External Types
 *
 ****************************************************************************/

typedef struct sockaddr SOCKADDR;

/****************************************************************************
 *
 * DirectPlay8Address Constants
 *
 ****************************************************************************/
//
// Asynchronous operation flags
//
#define DPNA_DATATYPE_STRING				0x00000001
#define DPNA_DATATYPE_DWORD					0x00000002
#define DPNA_DATATYPE_GUID					0x00000003
#define DPNA_DATATYPE_BINARY				0x00000004
#define DPNA_DATATYPE_STRING_ANSI           0x00000005

#define DPNA_DPNSVR_PORT					6073

#define DPNA_INDEX_INVALID					0xFFFFFFFF

/****************************************************************************
 *
 * DirectPlay8Address Address Elements
 *
 ****************************************************************************/

#define DPNA_SEPARATOR_KEYVALUE				L'='
#define DPNA_SEPARATOR_USERDATA				L'#'
#define DPNA_SEPARATOR_COMPONENT			L';'
#define DPNA_ESCAPECHAR						L'%'

// Header
#define DPNA_HEADER		                    L"x-directplay:/"

// key names for address components
#define DPNA_KEY_APPLICATION_INSTANCE		L"applicationinstance"
#define DPNA_KEY_BAUD						L"baud"
#define DPNA_KEY_DEVICE						L"device"
#define DPNA_KEY_FLOWCONTROL				L"flowcontrol"
#define DPNA_KEY_HOSTNAME					L"hostname"
#define DPNA_KEY_PARITY						L"parity"
#define DPNA_KEY_PHONENUMBER				L"phonenumber"
#define DPNA_KEY_PORT						L"port"
#define DPNA_KEY_PROGRAM					L"program"
#define DPNA_KEY_PROVIDER					L"provider"
#define DPNA_KEY_STOPBITS					L"stopbits"

// values for baud rate
#define DPNA_BAUD_RATE_9600					9600
#define DPNA_BAUD_RATE_14400				14400
#define DPNA_BAUD_RATE_19200				19200
#define DPNA_BAUD_RATE_38400				38400
#define DPNA_BAUD_RATE_56000				56000
#define DPNA_BAUD_RATE_57600				57600
#define DPNA_BAUD_RATE_115200				115200

// values for stop bits
#define DPNA_STOP_BITS_ONE					L"1"
#define DPNA_STOP_BITS_ONE_FIVE				L"1.5"
#define DPNA_STOP_BITS_TWO					L"2"

// values for parity
#define DPNA_PARITY_NONE					L"NONE"
#define DPNA_PARITY_EVEN					L"EVEN"
#define DPNA_PARITY_ODD						L"ODD"
#define DPNA_PARITY_MARK					L"MARK"
#define DPNA_PARITY_SPACE					L"SPACE"

// values for flow control
#define DPNA_FLOW_CONTROL_NONE				L"NONE"
#define DPNA_FLOW_CONTROL_XONXOFF			L"XONXOFF"
#define DPNA_FLOW_CONTROL_RTS				L"RTS"
#define DPNA_FLOW_CONTROL_DTR				L"DTR"
#define DPNA_FLOW_CONTROL_RTSDTR			L"RTSDTR"

// Shortcut values
//
// These can be used instead of the corresponding CLSID_DP8SP_XXXX guids
//
#define DPNA_VALUE_TCPIPPROVIDER            L"IP"
#define DPNA_VALUE_IPXPROVIDER              L"IPX"
#define DPNA_VALUE_MODEMPROVIDER            L"MODEM"
#define DPNA_VALUE_SERIALPROVIDER           L"SERIAL"


//// ANSI DEFINITIONS

// Header
#define DPNA_HEADER_A						"x-directplay:/"
#define DPNA_SEPARATOR_KEYVALUE_A			'='
#define DPNA_SEPARATOR_USERDATA_A			'#'
#define DPNA_SEPARATOR_COMPONENT_A			';'
#define DPNA_ESCAPECHAR_A					'%'

// key names for address components
#define DPNA_KEY_APPLICATION_INSTANCE_A		"applicationinstance"
#define DPNA_KEY_BAUD_A						"baud"
#define DPNA_KEY_DEVICE_A					"device"
#define DPNA_KEY_FLOWCONTROL_A				"flowcontrol"
#define DPNA_KEY_HOSTNAME_A					"hostname"
#define DPNA_KEY_PARITY_A					"parity"
#define DPNA_KEY_PHONENUMBER_A				"phonenumber"
#define DPNA_KEY_PORT_A						"port"
#define DPNA_KEY_PROGRAM_A					"program"
#define DPNA_KEY_PROVIDER_A					"provider"
#define DPNA_KEY_STOPBITS_A					"stopbits"

// values for stop bits
#define DPNA_STOP_BITS_ONE_A				"1"
#define DPNA_STOP_BITS_ONE_FIVE_A			"1.5"
#define DPNA_STOP_BITS_TWO_A				"2"

// values for parity
#define DPNA_PARITY_NONE_A					"NONE"
#define DPNA_PARITY_EVEN_A					"EVEN"
#define DPNA_PARITY_ODD_A					"ODD"
#define DPNA_PARITY_MARK_A					"MARK"
#define DPNA_PARITY_SPACE_A					"SPACE"

// values for flow control
#define DPNA_FLOW_CONTROL_NONE_A			"NONE"
#define DPNA_FLOW_CONTROL_XONXOFF_A 		"XONXOFF"
#define DPNA_FLOW_CONTROL_RTS_A				"RTS"
#define DPNA_FLOW_CONTROL_DTR_A				"DTR"
#define DPNA_FLOW_CONTROL_RTSDTR_A			"RTSDTR"

// Shortcut values
//
// These can be used instead of the corresponding CLSID_DP8SP_XXXX guids
//
#define DPNA_VALUE_TCPIPPROVIDER_A          "IP"
#define DPNA_VALUE_IPXPROVIDER_A            "IPX"
#define DPNA_VALUE_MODEMPROVIDER_A          "MODEM"
#define DPNA_VALUE_SERIALPROVIDER_A         "SERIAL"

/****************************************************************************
 *
 * DirectPlay8Address Functions
 *
 ****************************************************************************/

/*
 * 
 * This function is no longer supported.  It is recommended that CoCreateInstance be used to create 
 * DirectPlay8 address objects. 
 *
 * HRESULT WINAPI DirectPlay8AddressCreate( const GUID * pcIID, void **ppvInterface, IUnknown *pUnknown);
 *
 */

/****************************************************************************
 *
 * DirectPlay8Address Application Interfaces
 *
 ****************************************************************************/

//
// COM definition for IDirectPlay8Address Generic Interface
//
#undef INTERFACE				// External COM Implementation
#define INTERFACE IDirectPlay8Address
DECLARE_INTERFACE_(IDirectPlay8Address,IUnknown)
{
    /*** IUnknown methods ***/
	STDMETHOD(QueryInterface)			(THIS_ REFIID, LPVOID *) PURE;
	STDMETHOD_(ULONG,AddRef)			(THIS) PURE;
	STDMETHOD_(ULONG,Release)			(THIS) PURE;
    /*** IDirectPlay8Address methods ***/

    STDMETHOD(BuildFromURLW)(THIS_ WCHAR *pwszSourceURL ) PURE;
    STDMETHOD(BuildFromURLA)(THIS_ CHAR *pszSourceURL ) PURE;
    STDMETHOD(Duplicate)(THIS_ PDIRECTPLAY8ADDRESS *ppdpaNewAddress ) PURE;
    STDMETHOD(SetEqual)(THIS_ PDIRECTPLAY8ADDRESS pdpaAddress ) PURE;
	STDMETHOD(IsEqual)(THIS_ PDIRECTPLAY8ADDRESS pdpaAddress ) PURE;
    STDMETHOD(Clear)(THIS ) PURE;
    STDMETHOD(GetURLW)(THIS_ WCHAR *pwszURL, PDWORD pdwNumChars ) PURE;
    STDMETHOD(GetURLA)(THIS_ CHAR *pszURL, PDWORD pdwNumChars) PURE;
    STDMETHOD(GetSP)(THIS_ GUID *pguidSP ) PURE;
    STDMETHOD(GetUserData)(THIS_ void *pvUserData, PDWORD pdwBufferSize) PURE;
    STDMETHOD(SetSP)(THIS_ const GUID * const pguidSP ) PURE;
    STDMETHOD(SetUserData)(THIS_ const void * const pvUserData, const DWORD dwDataSize) PURE;
    STDMETHOD(GetNumComponents)(THIS_ PDWORD pdwNumComponents ) PURE;
    STDMETHOD(GetComponentByName)(THIS_ const WCHAR * const pwszName, void *pvBuffer, PDWORD pdwBufferSize, PDWORD pdwDataType ) PURE;
    STDMETHOD(GetComponentByIndex)(THIS_ const DWORD dwComponentID, WCHAR * pwszName, PDWORD pdwNameLen, void *pvBuffer, PDWORD pdwBufferSize, PDWORD pdwDataType ) PURE;
    STDMETHOD(AddComponent)(THIS_ const WCHAR * const pwszName, const void * const lpvData, const DWORD dwDataSize, const DWORD dwDataType ) PURE;	
    STDMETHOD(GetDevice)(THIS_  GUID * ) PURE;
    STDMETHOD(SetDevice)(THIS_  const GUID * const) PURE;
    STDMETHOD(BuildFromDPADDRESS)( THIS_ LPVOID pvAddress, DWORD dwDataSize ) PURE;
};

//
// COM definition for IDirectPlay8AddressIP Generic Interface
//
#undef INTERFACE				// External COM Implementation
#define INTERFACE IDirectPlay8AddressIP
DECLARE_INTERFACE_(IDirectPlay8AddressIP,IUnknown)
{
    /*** IUnknown methods ***/
	STDMETHOD(QueryInterface)			(THIS_ REFIID, PVOID *) PURE;
	STDMETHOD_(ULONG,AddRef)			(THIS) PURE;
	STDMETHOD_(ULONG,Release)			(THIS) PURE;

	/*** IDirectPlay8AddressIP methods ***/

	// Constructs a IDirectPlay8 TCP Address from a SOCKADDR structure
	STDMETHOD(BuildFromSockAddr)(THIS_ const SOCKADDR * const ) PURE;

	// Constructs a TCP Address from a string (hostname) and port
	STDMETHOD(BuildAddress)(THIS_ const WCHAR * const wszAddress, const USHORT usPort ) PURE;

	// Builds a local TCP Address
	STDMETHOD(BuildLocalAddress)(THIS_ const GUID * const pguidAdapter, const USHORT usPort ) PURE;

	// Gets the address from the structure in SOCKADR format
	STDMETHOD(GetSockAddress)(THIS_ SOCKADDR *, PDWORD ) PURE;

	// Gets the local afddress
	STDMETHOD(GetLocalAddress)(THIS_ GUID *pguidAdapter, USHORT *pusPort ) PURE;

	// Gets the remote address
	STDMETHOD(GetAddress)(THIS_ WCHAR *wszAddress, PDWORD pdwAddressLength, USHORT *psPort ) PURE;

};


//@@BEGIN_MSINTERNAL
//
// COM definition for IDirectPlay8AddressInternal interface
//
// This interface is used so that the SP and DNet can pass references to their internal
// copies of an address and not worry about the user modifying it.
//
#undef INTERFACE				// External COM Implementation
#define INTERFACE IDirectPlay8AddressInternal
DECLARE_INTERFACE_(IDirectPlay8AddressInternal,IUnknown)
{
    /*** IUnknown methods ***/
	STDMETHOD(QueryInterface)			(THIS_ REFIID, PVOID *) PURE;
	STDMETHOD_(ULONG,AddRef)			(THIS) PURE;
	STDMETHOD_(ULONG,Release)			(THIS) PURE;
    /*** IDirectPlay8Address methods ***/

	// Used by SP or DNet to mark this object read-only.  Only GetXXX funcs will work
    STDMETHOD(Lock)(THIS ) PURE;

    // Used by SP or DNet to mark this object read-write.  All funcs will work.
    STDMETHOD(UnLock)(THIS ) PURE;

};
//@@END_MSINTERNAL


/****************************************************************************
 *
 * IDirectPlay8 application interface macros
 *
 ****************************************************************************/

#if !defined(__cplusplus) || defined(CINTERFACE)

#define IDirectPlay8Address_QueryInterface(p,a,b)		    (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlay8Address_AddRef(p)          			    (p)->lpVtbl->AddRef(p)
#define IDirectPlay8Address_Release(p)         			    (p)->lpVtbl->Release(p)
#define IDirectPlay8Address_BuildFromURLW(p,a)			    (p)->lpVtbl->BuildFromURLW(p,a)
#define IDirectPlay8Address_BuildFromURLA(p,a)			    (p)->lpVtbl->BuildFromURLA(p,a)
#define IDirectPlay8Address_Duplicate(p,a)				    (p)->lpVtbl->Duplicate(p,a)
#define IDirectPlay8Address_SetEqual(p,a)                   (p)->lpVtbl->SetEqual(p,a)
#define IDirectPlay8Address_IsEqual(p,a)			        (p)->lpVtbl->IsEqual(p,a)
#define IDirectPlay8Address_Clear(p)					    (p)->lpVtbl->Clear(p)
#define IDirectPlay8Address_GetURLW(p,a,b)				    (p)->lpVtbl->GetURLW(p,a,b)
#define IDirectPlay8Address_GetURLA(p,a,b)				    (p)->lpVtbl->GetURLA(p,a,b)
#define IDirectPlay8Address_GetSP(p,a)					    (p)->lpVtbl->GetSP(p,a)
#define IDirectPlay8Address_GetUserData(p,a,b)			    (p)->lpVtbl->GetUserData(p,a,b)
#define IDirectPlay8Address_SetSP(p,a)					    (p)->lpVtbl->SetSP(p,a)
#define IDirectPlay8Address_SetUserData(p,a,b)			    (p)->lpVtbl->SetUserData(p,a,b)
#define IDirectPlay8Address_GetNumComponents(p,a)		    (p)->lpVtbl->GetNumComponents(p,a)
#define IDirectPlay8Address_GetComponentByName(p,a,b,c,d)	(p)->lpVtbl->GetComponentByName(p,a,b,c,d)
#define IDirectPlay8Address_GetComponentByIndex(p,a,b,c,d,e,f)	(p)->lpVtbl->GetComponentByIndex(p,a,b,c,d,e,f)
#define IDirectPlay8Address_AddComponent(p,a,b,c,d)		    (p)->lpVtbl->AddComponent(p,a,b,c,d)
#define IDirectPlay8Address_SetDevice(p,a)				    (p)->lpVtbl->SetDevice(p,a)
#define IDirectPlay8Address_GetDevice(p,a)				    (p)->lpVtbl->GetDevice(p,a)
#define IDirectPlay8Address_BuildFromDirectPlay4Address(p,a,b)  (p)->lpVtbl->BuildFromDirectPlay4Address(p,a,b)

#define IDirectPlay8AddressIP_QueryInterface(p,a,b)		    (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlay8AddressIP_AddRef(p)          		    (p)->lpVtbl->AddRef(p)
#define IDirectPlay8AddressIP_Release(p)         		    (p)->lpVtbl->Release(p)
#define IDirectPlay8AddressIP_BuildFromSockAddr(p,a)	    (p)->lpVtbl->BuildFromSockAddr(p,a)
#define IDirectPlay8AddressIP_BuildAddress(p,a,b)		    (p)->lpVtbl->BuildAddress(p,a,b)
#define IDirectPlay8AddressIP_BuildLocalAddress(p,a,b)	    (p)->lpVtbl->BuildLocalAddress(p,a,b)
#define IDirectPlay8AddressIP_GetSockAddress(p,a,b)		    (p)->lpVtbl->GetSockAddress(p,a,b)
#define IDirectPlay8AddressIP_GetLocalAddress(p,a,b)	    (p)->lpVtbl->GetLocalAddress(p,a,b)
#define IDirectPlay8AddressIP_GetAddress(p,a,b,c)		    (p)->lpVtbl->GetAddress(p,a,b,c)

//@@BEGIN_MSINTERNAL
#define IDirectPlay8AddressInternal_QueryInterface(p,a,b)   (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlay8AddressInternal_AddRef(p)   		    (p)->lpVtbl->AddRef(p)
#define IDirectPlay8AddressInternal_Release(p)         	    (p)->lpVtbl->Release(p)
#define IDirectPlay8AddressInternal_Lock(p)				    (p)->lpVtbl->Lock(p)
#define IDirectPlay8AddressInternal_UnLock(p)			    (p)->lpVtbl->UnLock(p)
//@@END_MSINTERNAL

#else /* C++ */

#define IDirectPlay8Address_QueryInterface(p,a,b)		    (p)->QueryInterface(a,b)
#define IDirectPlay8Address_AddRef(p)          			    (p)->AddRef()
#define IDirectPlay8Address_Release(p)         			    (p)->Release()
#define IDirectPlay8Address_BuildFromURLW(p,a)			    (p)->BuildFromURLW(a)
#define IDirectPlay8Address_BuildFromURLA(p,a)			    (p)->BuildFromURLA(a)
#define IDirectPlay8Address_Duplicate(p,a)				    (p)->Duplicate(a)
#define IDirectPlay8Address_SetEqual(p,a)                   (p)->SetEqual(a)
#define IDirectPlay8Address_IsEqual(p,a)			        (p)->IsEqual(a)
#define IDirectPlay8Address_Clear(p)					    (p)->Clear()
#define IDirectPlay8Address_GetURLW(p,a,b)				    (p)->GetURLW(a,b)
#define IDirectPlay8Address_GetURLA(p,a,b)				    (p)->GetURLA(a,b)
#define IDirectPlay8Address_GetSP(p,a)					    (p)->GetSP(a)
#define IDirectPlay8Address_GetUserData(p,a,b)			    (p)->GetUserData(a,b)
#define IDirectPlay8Address_SetSP(p,a)					    (p)->SetSP(a)
#define IDirectPlay8Address_SetUserData(p,a,b)			    (p)->SetUserData(a,b)
#define IDirectPlay8Address_GetNumComponents(p,a)		    (p)->GetNumComponents(a)
#define IDirectPlay8Address_GetComponentByName(p,a,b,c,d)	(p)->GetComponentByName(a,b,c,d)
#define IDirectPlay8Address_GetComponentByIndex(p,a,b,c,d,e,f)	(p)->GetComponentByIndex(a,b,c,d,e,f)
#define IDirectPlay8Address_AddComponent(p,a,b,c,d)		    (p)->AddComponent(a,b,c,d)
#define IDirectPlay8Address_SetDevice(p,a)				    (p)->SetDevice(a)
#define IDirectPlay8Address_GetDevice(p,a)				    (p)->GetDevice(a)
#define IDirectPlay8Address_BuildFromDirectPlay4Address(p,a,b)  (p)->BuildFromDirectPlay4Address(a,b)

#define IDirectPlay8AddressIP_QueryInterface(p,a,b)		    (p)->QueryInterface(a,b)
#define IDirectPlay8AddressIP_AddRef(p)          		    (p)->AddRef()
#define IDirectPlay8AddressIP_Release(p)         		    (p)->Release()
#define IDirectPlay8AddressIP_BuildFromSockAddr(p,a)	    (p)->BuildFromSockAddr(a)
#define IDirectPlay8AddressIP_BuildAddress(p,a,b)		    (p)->BuildAddress(a,b)
#define IDirectPlay8AddressIP_BuildLocalAddress(p,a,b)	    (p)->BuildLocalAddress(a,b)
#define IDirectPlay8AddressIP_GetSockAddress(p,a,b)		    (p)->GetSockAddress(a,b)
#define IDirectPlay8AddressIP_GetLocalAddress(p,a,b)	    (p)->GetLocalAddress(a,b)
#define IDirectPlay8AddressIP_GetAddress(p,a,b,c)		    (p)->GetAddress(a,b,c)

//@@BEGIN_MSINTERNAL
#define IDirectPlay8AddressInternal_QueryInterface(p,a,b)   (p)->QueryInterface(a,b)
#define IDirectPlay8AddressInternal_AddRef(p)   		    (p)->AddRef()
#define IDirectPlay8AddressInternal_Release(p)         	    (p)->Release()
#define IDirectPlay8AddressInternal_Lock(p)				    (p)->Lock()
#define IDirectPlay8AddressInternal_UnLock(p)			    (p)->UnLock()
//@@END_MSINTERNAL

#endif


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\inc\dplay8.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		DPlay8.h
 *  Content:	DirectPlay8 include file
//@@BEGIN_MSINTERNAL
 *  History:
 *	Date		By		Reason
 *	==========================
 *	10/12/98	jwo		created
 *	11/06/98	ejs		removed BUFFERELEMENT, reversed fields in BUFFERDESC, defined new ERRORs
 *	11/10/98	ejs		started adding upper-edge COM interface for DirectPlay8
 *	07/20/99	mjn		added interface GUIDs for DirectPlay8 peer,client and server
 *	07/29/99	mjn		changed DPNID typedef from HANDLE to DWORD
 *	08/09/99	mjn		added DPN_SERVICE_PROVIDER_INFO structure for SP and adapter enumeration
 *	12/03/99	jtk		Replaced IID_IDirectPlay8 with the Client, Server, and Peer interfaces
 *	01/08/00	mjn		Added DPNERR's and fixed DPN_APPLICATION_DESC
 *	01/09/00	mjn		Added dwSize to DPN_APPLICATION_DESC
 *	01/14/00	mjn		Added pvUserContext to Host API call
 *	01/16/00	mjn		New DPlay8 MessageHandler and associated structures
 *	01/18/00	mjn		Added DPNGROUP_AUTODESTRUCT flag
 *	01/22/00	mjn		Added ability for Host to destroy a player
 *	01/24/00	mjn		Reordered error codes and DPN_MSGID's
 *	01/24/00	mjn		Added DPNERR_NOHOSTPLAYER error
 *	01/27/00	vpo		Removed all remaing traces of LP pointers.
 *	01/28/00	mjn		Implemented ReturnBuffer in API and DPN_MSGID_CONNECTION_TERMINATED
 *	02/01/00	mjn		Added GetCaps and SetCaps to APIs and player context values to messages
 *	02/13/00	jtk		Renamed to DPlay8.h
 *	02/15/00	mjn		Added INFO flags and MS_INTERNAL stuff
 *  02/17/00	rmt		Added additional error codes for address library
 *	02/17/00	mjn		Implemented GetPlayerContext and GetGroupContext
 *	02/17/00	mjn		Reordered parameters in EnumServiceProviders,EnumHosts,Connect,Host
 *  03/17/00    rmt     Added Get/SetSPCaps, GetConnectionInfo and supporting structures
 *              rmt     Updated Caps structure.
 *              rmt     Updated Security structures to add dwSize member
 *	03/22/00	mjn		changed dpid's to dpnid's
 *				mjn		removed DPNGROUP_ALLPLAYERS and added DPNID_ALL_PLAYERS_GROUP
 *				mjn		added dwPriority to Send and SendTo
 *				mjn		removed pDpnid from CreateGroup
 *				mjn		replaced HANDLE with DPNHANDLE
 *				mjn		Added dpnid to GetSendQueueInfo for Server and Peer interfaces
 *				mjn		Changed RegisterMessageHandler to Initialize
 *	03/23/00	mjn		Added pvGroupContext to CreateGroup
 *				mjn		Added pvPlayerContext to Host and Connect
 *				mjn		Added RegisterLobby API Call
 *	03/24/00	rmt		Added IsEqual function return codes
 *				mjn		Added pvPlayerContext to INDICATE_CONNECT and renamed pvUserContext to pvReplyContext
 *	03/25/00	rmt     Added new fields to caps
 *	04/04/00	rmt		Added new flag to enable/disable param validation on Initialize call
 *				rmt		Added new flag to enable/disable DPNSVR functionality in session.
 *	04/04/00	mjn		Added DPNERR_INVALIDVERSION
 *	04/05/00	mjn		Added TerminateSession() API Call
 *  04/04/00    aarono  made security structures internal, since not yet supported
 *	04/05/00	mjn		Modified DPNMSG_HOST_DESTROY_PLAYER structure
 *				mjn		Modified DestroyClient to take void* instead of BYTE* for data
 *				mjn		Added typedefs for security structures
 *	04/06/00	mjn		Added Address to INDICATE_CONNECT message
 *				mjn		Added GetClientAddress, GetServerAddress, GetPeerAddress to API
 *				mjn		Added GetHostAddress to API
 *	04/17/00	mjn		Removed DPNPLAYER_SERVER
 *				mjn		Replaced BUFFERDESC with DPN_BUFFER_DESC in API
 *	04/18/00	mjn		Added ResponseData to DPNMSG_ENUM_HOSTS_QUERY
 *				mjn		Added DPN_MSGID_RETURN_BUFFER and DPNMSG_RETURN_BUFFER
 *				mjn		Removed TerminateSession from Server interface.
 *	04/19/00	mjn		SendTo and Send API calls accept a range of DPN_BUFFER_DESCs and a count
 *				mjn		Removed DPN_BUFFER_DESC from DPNMSG_ENUM_HOSTS_QUERY and DPNMSG_ENUM_HOSTS_RESPONSE structs
 *				mjn		Removed hAsyncOp (unused) from DPNMSG_INDICATE_CONNECT
 *	05/02/00	mjn		Removed DPN_ACCEPTED and DPN_REJECTED #define's
 *	05/03/00	mjn		Added DPNENUMSERVICEPROVIDERS_ALL flag
 *  05/04/00    rmt     Bug #34156 - No PDPNID or PDPNHANDLE defined
 *	05/31/00	mjn		Added SYNC flags for EACH API call which supports synchronous operation
 *	06/05/00	mjn		Added short-cut interface macros and converted errors to HEX
 *  06/09/00    rmt     Updates to split CLSID and allow whistler compat and support external create funcs
 *	06/12/00	mjn		MSINTERNAL'd out DPNSEND_ENCRYPTED,DPNSEND_SIGNED,DPNGROUP_MULTICAST and DPNENUM_GROUP_MULTICAST flags
 *  06/15/00    rmt     Bug #36380 - Removing old CLSID
 *	06/23/00	mjn		Added DPNSEND_PRIORITY_HIGH and DPNSEND_PRIORITY_LOW flags
 *				mjn		Removed dwPriority from Send() and SendTo() API calls
 *	06/26/00	mjn		Added dwReason to DPNMSG_DESTROY_PLAYER and DPNMSG_DESTROY_GROUP structures and added reason constants
 *				mjn		MAJOR API/FLAGS/CONSTANTS/STRUCTURES RENAME
 *	06/27/00	mjn		Added DPNGETSENDQUEUEINFO_PRIORITY_HIGH and DPNGETSENDQUEUEINFO_PRIORITY_LOW flags
 *				mjn		Dropped pvPlayerContext from IDirectPlay8Client::Connect()
 *				mjn		Added DPNENUMHOSTS_DONTSENDADDRESS,DPNSEND_NONSEQUENTIAL and DPNGETSENDQUEUEINFO_PRIORITY_NORMAL flags
 *				mjn		Renumbered SEND flags
 *  07/09/00	rmt		Bug #38323 When registering lobby object w/DP8 object must be able to specify connection to update
 *	07/29/00	mjn		Added DPN_MSGID_INDICATED_CONNECT_ABORTED and DPNMSG_INDICATED_CONNECT_ABORTED structure
 *				mjn		Added pvTerminateData and dwTerminateDataSize to DPNMSG_CONNECTION_TERMINATED structure
 *				mjn		Added hResultCode to DPNMSG_RETURN_BUFFER structure
 *				mjn		Added hResultCode to DPNMSG_TERMINATE_SESSION structure
 *				mjn		Added dwMaxResponseDataSize to DPNMSG_ENUM_HOSTS_QUERY structure
 *				mjn		Changed dwRetryCount to dwEnumCount in EnumHosts API call (no impact - just name change)
 *				mjn		Added DPNERR_ENUMQUERYTOOLARGE,DPNERR_ENUMRESPONSETOOLARGE,DPNERR_HOSTTERMINATEDSESSION
 *				mjn		Reordered DPN_MSGID's alphabetically
 *	07/30/00	mjn		Added pAddressDevice to DPNMSG_INDICATE_CONNECT
 *	07/31/00	mjn		Added DPNDESTROYPLAYERREASON_SESSIONTERMINATED,DPNDESTROYPLAYERREASON_HOSTDESTROYEDPLAYER,DPNDESTROYGROUPREASON_SESSIONTERMINATED
 *				mjn		Added DPNERR_PLAYERNOTREACHABLE
 *				mjn		Renamed pAddress to pAddressPlayer in DPNMSG_INDICATE_CONNECT
 *				mjn		Renamed DPN_MSGID_ASYNC_OPERATION_COMPLETE to DPN_MSGID_ASYNC_OP_COMPLETE
 *				mjn		Renamed dwDefaultEnumRetryCount to dwDefaultEnumCount in DPN_SP_CAPS
 *				mjn		Removed DPNENUM_ALL
 *				mjn		Removed DPN_MSGID_HOST_DESTROY_PLAYER
 *				mjn		Removed DPN_MSGID_CONNECTION_TERMINATED
 *				mjn		Removed ALL_ADAPTERS_GUID
 * 08/03/2000 	rmt		Bug #41246 - Registering lobby in wrong state returns ambiguous return codes
 *	08/03/00	mjn		Added dwFlags to GetPeerAddress(),GetServerAddress(),GetClientAddress(),GetLocalHostAddresses(),
 *						Close(),ReturnBuffer(),GetPlayerContext(),GetGroupContext(),GetCaps(),GetSPCaps(),GetConnectionInfo()
 *				mjn		Removed DPNMSG_CONNECTION_TERMINATED,DPNMSG_HOST_DESTROY_PLAYER
 *				mjn		Added dwRoundTripTime to DPNMSG_ENUM_HOSTS_RESPONSE
 *				mjn		Changed GUID *pGuid to GUID guid in DPN_SERVICE_PROVIDER_INFO and added pvReserved,dwReserved
 * 08/06/2000	rmt		Bug #41185 - Cleanup dplay8.h header file.
 * 08/08/2000	rmt		Bug #41724 - Users should only have to include one header
 *				rmt		Bug #41705 - DPNERR_PENDING should be defined as STATUS_PENDING
 * 09/26/2000	masonb		Removed Private Protocol Testing interface, placed in core as private header dpprot.h
 *	10/04/00	mjn		Added DPNERR_DATATOOLARGE
 *  03/17/2001	rmt		WINBUG #342420 - Commented out create functions
 * 03/22/2001	masonb	Added internal connect info structure for performance tuning
//@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __DIRECTPLAY8_H__
#define __DIRECTPLAY8_H__

#include <ole2.h>			// for DECLARE_INTERFACE and HRESULT

#include "dpaddr.h"

#ifdef __cplusplus
extern "C" {
#endif


/****************************************************************************
 *
 * DirectPlay8 CLSIDs
 *
 ****************************************************************************/

// {743F1DC6-5ABA-429f-8BDF-C54D03253DC2}
DEFINE_GUID(CLSID_DirectPlay8Client,
0x743f1dc6, 0x5aba, 0x429f, 0x8b, 0xdf, 0xc5, 0x4d, 0x3, 0x25, 0x3d, 0xc2);

// {286F484D-375E-4458-A272-B138E2F80A6A}
DEFINE_GUID(CLSID_DirectPlay8Peer,
0x286f484d, 0x375e, 0x4458, 0xa2, 0x72, 0xb1, 0x38, 0xe2, 0xf8, 0xa, 0x6a);

// {DA825E1B-6830-43d7-835D-0B5AD82956A2}
DEFINE_GUID(CLSID_DirectPlay8Server,
0xda825e1b, 0x6830, 0x43d7, 0x83, 0x5d, 0xb, 0x5a, 0xd8, 0x29, 0x56, 0xa2);


/****************************************************************************
 *
 * DirectPlay8 Interface IIDs
 *
 ****************************************************************************/

// {5102DACD-241B-11d3-AEA7-006097B01411}
DEFINE_GUID(IID_IDirectPlay8Client,
0x5102dacd, 0x241b, 0x11d3, 0xae, 0xa7, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);

// {5102DACF-241B-11d3-AEA7-006097B01411}
DEFINE_GUID(IID_IDirectPlay8Peer,
0x5102dacf, 0x241b, 0x11d3, 0xae, 0xa7, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);

// {5102DACE-241B-11d3-AEA7-006097B01411}
DEFINE_GUID(IID_IDirectPlay8Server,
0x5102dace, 0x241b, 0x11d3, 0xae, 0xa7, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);

/****************************************************************************
 *
 * DirectPlay8 Service Provider GUIDs
 *
 ****************************************************************************/

// {53934290-628D-11D2-AE0F-006097B01411}
DEFINE_GUID(CLSID_DP8SP_IPX, 0x53934290, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);

// {6D4A3650-628D-11D2-AE0F-006097B01411}
DEFINE_GUID(CLSID_DP8SP_MODEM, 0x6d4a3650, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);

// {743B5D60-628D-11D2-AE0F-006097B01411}
DEFINE_GUID(CLSID_DP8SP_SERIAL, 0x743b5d60, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);

// {EBFE7BA0-628D-11D2-AE0F-006097B01411}
DEFINE_GUID(CLSID_DP8SP_TCPIP, 0xebfe7ba0, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);

/****************************************************************************
 *
 * DirectPlay8 Interface Pointer definitions
 *
 ****************************************************************************/

typedef	struct IDirectPlay8Peer     *PDIRECTPLAY8PEER;
typedef	struct IDirectPlay8Server	*PDIRECTPLAY8SERVER;
typedef	struct IDirectPlay8Client	*PDIRECTPLAY8CLIENT;

/****************************************************************************
 *
 * DirectPlay8 Forward Declarations For External Types
 *
 ****************************************************************************/

typedef struct IDirectPlay8LobbiedApplication	*PDNLOBBIEDAPPLICATION;
typedef struct IDirectPlay8Address              IDirectPlay8Address;

/****************************************************************************
 *
 * DirectPlay8 Callback Functions
 *
 ****************************************************************************/

//
// Callback Function Type Definition
//
typedef HRESULT (WINAPI *PFNDPNMESSAGEHANDLER)(PVOID,DWORD,PVOID);

/****************************************************************************
 *
 * DirectPlay8 Datatypes (Non-Structure / Non-Message)
 *
 ****************************************************************************/

//
// Player IDs.  Used to uniquely identify a player in a session
//
typedef DWORD	DPNID,      *PDPNID;

//
// Used as identifiers for operations
//
typedef	DWORD	DPNHANDLE, *PDPNHANDLE;

/****************************************************************************
 *
 * DirectPlay8 Message Identifiers
 *
 ****************************************************************************/

#define	DPN_MSGID_OFFSET					0xFFFF0000
#define DPN_MSGID_ADD_PLAYER_TO_GROUP		( DPN_MSGID_OFFSET | 0x0001 )
#define DPN_MSGID_APPLICATION_DESC			( DPN_MSGID_OFFSET | 0x0002 )
#define DPN_MSGID_ASYNC_OP_COMPLETE			( DPN_MSGID_OFFSET | 0x0003 )
#define DPN_MSGID_CLIENT_INFO				( DPN_MSGID_OFFSET | 0x0004 )
#define DPN_MSGID_CONNECT_COMPLETE			( DPN_MSGID_OFFSET | 0x0005 )
#define DPN_MSGID_CREATE_GROUP				( DPN_MSGID_OFFSET | 0x0006 )
#define DPN_MSGID_CREATE_PLAYER				( DPN_MSGID_OFFSET | 0x0007 )
#define DPN_MSGID_DESTROY_GROUP				( DPN_MSGID_OFFSET | 0x0008 )
#define DPN_MSGID_DESTROY_PLAYER			( DPN_MSGID_OFFSET | 0x0009 )
#define DPN_MSGID_ENUM_HOSTS_QUERY			( DPN_MSGID_OFFSET | 0x000a )
#define DPN_MSGID_ENUM_HOSTS_RESPONSE		( DPN_MSGID_OFFSET | 0x000b )
#define DPN_MSGID_GROUP_INFO				( DPN_MSGID_OFFSET | 0x000c )
#define DPN_MSGID_HOST_MIGRATE				( DPN_MSGID_OFFSET | 0x000d )
#define DPN_MSGID_INDICATE_CONNECT			( DPN_MSGID_OFFSET | 0x000e )
#define DPN_MSGID_INDICATED_CONNECT_ABORTED	( DPN_MSGID_OFFSET | 0x000f )
#define DPN_MSGID_PEER_INFO					( DPN_MSGID_OFFSET | 0x0010 )
#define DPN_MSGID_RECEIVE					( DPN_MSGID_OFFSET | 0x0011 )
#define DPN_MSGID_REMOVE_PLAYER_FROM_GROUP	( DPN_MSGID_OFFSET | 0x0012 )
#define	DPN_MSGID_RETURN_BUFFER				( DPN_MSGID_OFFSET | 0x0013 )
#define DPN_MSGID_SEND_COMPLETE				( DPN_MSGID_OFFSET | 0x0014 )
#define DPN_MSGID_SERVER_INFO				( DPN_MSGID_OFFSET | 0x0015 )
#define	DPN_MSGID_TERMINATE_SESSION			( DPN_MSGID_OFFSET | 0x0016 )

/****************************************************************************
 *
 * DirectPlay8 Constants
 *
 ****************************************************************************/

#define	DPNID_ALL_PLAYERS_GROUP				0

//
// DESTROY_GROUP reasons
//
#define	DPNDESTROYGROUPREASON_NORMAL				0x0001
#define DPNDESTROYGROUPREASON_AUTODESTRUCTED		0x0002
#define	DPNDESTROYGROUPREASON_SESSIONTERMINATED		0x0003

//
// DESTROY_PLAYER reasons
//
#define DPNDESTROYPLAYERREASON_NORMAL				0x0001
#define DPNDESTROYPLAYERREASON_CONNECTIONLOST		0x0002
#define	DPNDESTROYPLAYERREASON_SESSIONTERMINATED	0x0003
#define	DPNDESTROYPLAYERREASON_HOSTDESTROYEDPLAYER	0x0004

/****************************************************************************
 *
 * DirectPlay8 Flags
 *
 ****************************************************************************/

//
// Asynchronous operation flags (For Async Ops)
//
#define DPNOP_SYNC							0x80000000

//
// Add player to group flags (For AddPlayerToGroup)
//
#define DPNADDPLAYERTOGROUP_SYNC			DPNOP_SYNC

//
// Cancel flags
//
#define	DPNCANCEL_CONNECT					0x0001
#define	DPNCANCEL_ENUM						0x0002
#define	DPNCANCEL_SEND						0x0004
#define	DPNCANCEL_ALL_OPERATIONS			0x8000

//
// Connect flags (For Connect)
//
#define	DPNCONNECT_SYNC						DPNOP_SYNC
#define	DPNCONNECT_OKTOQUERYFORADDRESSING	0x0001

//
// Create group flags (For CreateGroup)
//
#define	DPNCREATEGROUP_SYNC					DPNOP_SYNC

//
// Destroy group flags (For DestroyGroup)
//
#define	DPNDESTROYGROUP_SYNC				DPNOP_SYNC

//
// Enumerate clients and groups flags (For EnumPlayersAndGroups)
//
#define DPNENUM_PLAYERS						0x0001
#define DPNENUM_GROUPS						0x0010

//
// Enum hosts flags (For EnumHosts)
//
#define	DPNENUMHOSTS_SYNC					DPNOP_SYNC
#define	DPNENUMHOSTS_OKTOQUERYFORADDRESSING	0x0001
#define	DPNENUMHOSTS_NOBROADCASTFALLBACK	0x0002
//@@BEGIN_MSINTERNAL
#define	DPNENUMHOSTS_DONTSENDADDRESS		0x0004
//@@END_MSINTERNAL

//
// Enum service provider flags (For EnumSP)
//
#define DPNENUMSERVICEPROVIDERS_ALL			0x0001

//
// Get send queue info flags (For GetSendQueueInfo)
//
#define	DPNGETSENDQUEUEINFO_PRIORITY_NORMAL	0x0001
#define	DPNGETSENDQUEUEINFO_PRIORITY_HIGH	0x0002
#define	DPNGETSENDQUEUEINFO_PRIORITY_LOW	0x0004

//
// Group information flags (For Group Info)
//
#define DPNGROUP_AUTODESTRUCT				0x0001

//
// Host flags (For Host)
//
#define	DPNHOST_OKTOQUERYFORADDRESSING		0x0001

//
// Set info
//
#define	DPNINFO_NAME						0x0001
#define	DPNINFO_DATA						0x0002

//
// Initialize flags (For Initialize)
//
#define DPNINITIALIZE_DISABLEPARAMVAL		0x0001

//
// Register Lobby flags
//
#define	DPNLOBBY_REGISTER					0x0001
#define DPNLOBBY_UNREGISTER					0x0002

//
// Player information flags (For Player Info / Player Messages)
//
#define	DPNPLAYER_LOCAL						0x0002
#define	DPNPLAYER_HOST						0x0004

//
// Remove player from group flags (For RemovePlayerFromGroup)
//
#define	DPNREMOVEPLAYERFROMGROUP_SYNC		DPNOP_SYNC

//
// Send flags (For Send/SendTo)
//
#define DPNSEND_SYNC						DPNOP_SYNC
#define DPNSEND_NOCOPY						0x0001
#define DPNSEND_NOCOMPLETE					0x0002
#define DPNSEND_COMPLETEONPROCESS			0x0004
#define DPNSEND_GUARANTEED					0x0008
#define	DPNSEND_NONSEQUENTIAL				0x0010
#define DPNSEND_NOLOOPBACK					0x0020
#define	DPNSEND_PRIORITY_LOW				0x0040
#define	DPNSEND_PRIORITY_HIGH				0x0080

//
// Session Flags (for DPN_APPLICATION_DESC)
//
#define DPNSESSION_CLIENT_SERVER			0x0001
#define DPNSESSION_MIGRATE_HOST				0x0004
#define DPNSESSION_NODPNSVR					0x0040
#define DPNSESSION_REQUIREPASSWORD          0x0080

//
// Set client info flags (For SetClientInfo)
//
#define DPNSETCLIENTINFO_SYNC				DPNOP_SYNC

//
// Set group info flags (For SetGroupInfo)
//
#define DPNSETGROUPINFO_SYNC				DPNOP_SYNC

//
// Set peer info flags (For SetPeerInfo)
//
#define DPNSETPEERINFO_SYNC					DPNOP_SYNC

//
// Set server info flags (For SetServerInfo)
//
#define DPNSETSERVERINFO_SYNC				DPNOP_SYNC

//
// SP capabilities flags
//
#define	DPNSPCAPS_SUPPORTSDPNSRV			0x0001
#define	DPNSPCAPS_SUPPORTSBROADCAST			0x0002
#define	DPNSPCAPS_SUPPORTSALLADAPTERS		0x0004

/****************************************************************************
 *
 * DirectPlay8 Structures (Non-Message)
 *
 ****************************************************************************/

//
// Application description
//
typedef struct	_DPN_APPLICATION_DESC
{
	DWORD	dwSize;							// Size of this structure
	DWORD	dwFlags;						// Flags (DPNSESSION_...)
	GUID	guidInstance;					// Instance GUID
	GUID	guidApplication;				// Application GUID
	DWORD	dwMaxPlayers;					// Maximum # of players allowed (0=no limit)
	DWORD	dwCurrentPlayers;				// Current # of players allowed
	WCHAR	*pwszSessionName;				// Name of the session
	WCHAR	*pwszPassword;					// Password for the session
	PVOID	pvReservedData;					
	DWORD	dwReservedDataSize;
	PVOID	pvApplicationReservedData;
	DWORD	dwApplicationReservedDataSize;
} DPN_APPLICATION_DESC, *PDPN_APPLICATION_DESC;

//
// Generic Buffer Description
//
typedef struct	_BUFFERDESC
{
	DWORD	dwBufferSize;		
	BYTE * 	pBufferData;		
} BUFFERDESC, DPN_BUFFER_DESC, *PDPN_BUFFER_DESC;

typedef BUFFERDESC	FAR * PBUFFERDESC;

//
// DirectPlay8 capabilities
//
typedef struct	_DPN_CAPS
{
    DWORD   dwSize;							// Size of this structure
	DWORD	dwFlags;						// Flags
    DWORD   dwConnectTimeout;				// ms before a connect request times out
    DWORD   dwConnectRetries;				// # of times to attempt the connection
    DWORD   dwTimeoutUntilKeepAlive;		// ms of inactivity before a keep alive is sent
} DPN_CAPS, *PDPN_CAPS;

// Connection Statistics information

typedef struct _DPN_CONNECTION_INFO
{
    DWORD   dwSize;
    DWORD   dwRoundTripLatencyMS;
    DWORD   dwThroughputBPS;
    DWORD	dwPeakThroughputBPS;

	DWORD	dwBytesSentGuaranteed;
	DWORD	dwPacketsSentGuaranteed;
	DWORD	dwBytesSentNonGuaranteed;
	DWORD	dwPacketsSentNonGuaranteed;

	DWORD	dwBytesRetried;		// Guaranteed only
	DWORD	dwPacketsRetried;	// Guaranteed only
	DWORD	dwBytesDropped;		// Non Guaranteed only
	DWORD	dwPacketsDropped;	// Non Guaranteed only

	DWORD	dwMessagesTransmittedHighPriority;
	DWORD	dwMessagesTimedOutHighPriority;
	DWORD	dwMessagesTransmittedNormalPriority;
	DWORD	dwMessagesTimedOutNormalPriority;
	DWORD	dwMessagesTransmittedLowPriority;
	DWORD	dwMessagesTimedOutLowPriority;

	DWORD	dwBytesReceivedGuaranteed;
	DWORD	dwPacketsReceivedGuaranteed;
	DWORD	dwBytesReceivedNonGuaranteed;
	DWORD	dwPacketsReceivedNonGuaranteed;
	DWORD	dwMessagesReceived;

} DPN_CONNECTION_INFO, *PDPN_CONNECTION_INFO;

//@@BEGIN_MSINTERNAL

typedef struct _DPN_CONNECTION_INFO_INTERNAL
{
    DWORD   dwSize;
    DWORD   dwRoundTripLatencyMS;
    DWORD   dwThroughputBPS;
    DWORD	dwPeakThroughputBPS;

	DWORD	dwBytesSentGuaranteed;
	DWORD	dwPacketsSentGuaranteed;
	DWORD	dwBytesSentNonGuaranteed;
	DWORD	dwPacketsSentNonGuaranteed;

	DWORD	dwBytesRetried;		// Guaranteed only
	DWORD	dwPacketsRetried;	// Guaranteed only
	DWORD	dwBytesDropped;		// Non Guaranteed only
	DWORD	dwPacketsDropped;	// Non Guaranteed only

	DWORD	dwMessagesTransmittedHighPriority;
	DWORD	dwMessagesTimedOutHighPriority;
	DWORD	dwMessagesTransmittedNormalPriority;
	DWORD	dwMessagesTimedOutNormalPriority;
	DWORD	dwMessagesTransmittedLowPriority;
	DWORD	dwMessagesTimedOutLowPriority;

	DWORD	dwBytesReceivedGuaranteed;
	DWORD	dwPacketsReceivedGuaranteed;
	DWORD	dwBytesReceivedNonGuaranteed;
	DWORD	dwPacketsReceivedNonGuaranteed;
	DWORD	dwMessagesReceived;

	// Members not in DPN_CONNECTION_INFO ///////////////////////////////////////////////////

	// Adaptive Algorithm Parameters
	UINT	uiDropCount;		// localized packet drop count (recent drops)
	UINT	uiThrottleEvents;	// count of temporary backoffs for all reasons
	UINT	uiAdaptAlgCount;	// Acknowledge count remaining before running adaptive algorithm
	UINT	uiWindowFilled;		// Count of times we fill the send window
	UINT	uiPeriodAcksBytes;	// frames acked since change in tuning
	UINT	uiPeriodXmitTime;	// time link has been transmitting since change in tuning
	DWORD	dwLastThroughputBPS;// the calculated throughput from the last period
	UINT	uiLastBytesAcked;	// the number of bytes acked in the last period

	// Current Transmit Parameters:
	UINT	uiWindowF;			// window size (frames)
	UINT	uiWindowB;			// window size (bytes)
	UINT	uiUnackedFrames;		// outstanding frame count
	UINT	uiUnackedBytes;		// outstanding byte count
	UINT	uiBurstGap;			// number of ms to wait between bursts
	INT		iBurstCredit;		// Either credit or deficit from previous Transmit Burst
	UINT	uiRetryTimeout;		// The time until we consider a frame lost and in need of retransmission

	// Last Known Good Transmit Parameters --  Values which we believe are safe...
	UINT	uiGoodWindowF;
	UINT	uiGoodWindowB;
	UINT	uiGoodBurstGap;
	UINT	uiGoodRTT;

	// Restore Parameters - We will restore to these when we un-throttle if we are throttled
	UINT	uiRestoreWindowF;
	UINT	uiRestoreWindowB;
	UINT	uiRestoreBurstGap;

	// Link State Parameters
	BYTE	bNextSend;			// Next serial number to assign to a frame
	BYTE	bNextReceive;		// Next frame serial we expect to receive
	ULONG	ulReceiveMask;		// mask representing first 32 frames in our rcv window
	ULONG	ulReceiveMask2;		// second 32 frames in our window
	ULONG	ulSendMask;			// mask representing unreliable send frames that have timed out and need
	ULONG	ulSendMask2;		// to be reported to receiver as missing.

	// Informational Parameters
	DWORD	uiQueuedMessageCount;// Number of messages waiting on all three send queues
	UINT	uiCompleteMsgCount;	// Count of messages on the CompleteList
	ULONG	ulEPFlags;			// End Point Flags

} DPN_CONNECTION_INFO_INTERNAL, *PDPN_CONNECTION_INFO_INTERNAL;

//@@END_MSINTERNAL

//
// Group information strucutre
//
typedef struct	_DPN_GROUP_INFO
{
	DWORD	dwSize;				// size of this structure
	DWORD	dwInfoFlags;		// information contained
	PWSTR	pwszName;			// Unicode Name
	PVOID	pvData;				// data block
	DWORD	dwDataSize;			// size in BYTES of data block
	DWORD	dwGroupFlags;		// group flags (DPNGROUP_...)
} DPN_GROUP_INFO, *PDPN_GROUP_INFO;

//
// Player information structure
//
typedef struct	_DPN_PLAYER_INFO
{
	DWORD	dwSize;				// size of this structure
	DWORD	dwInfoFlags;		// information contained
	PWSTR	pwszName;			// Unicode Name
	PVOID	pvData;				// data block
	DWORD	dwDataSize;			// size in BYTES of data block
	DWORD	dwPlayerFlags;		// player flags (DPNPLAYER_...)
} DPN_PLAYER_INFO, *PDPN_PLAYER_INFO;

typedef struct _DPN_SECURITY_CREDENTIALS	DPN_SECURITY_CREDENTIALS, *PDPN_SECURITY_CREDENTIALS;
typedef struct _DPN_SECURITY_DESC			DPN_SECURITY_DESC, *PDPN_SECURITY_DESC;

//
// Service provider & adapter enumeration structure
//
typedef struct _DPN_SERVICE_PROVIDER_INFO
{
	DWORD		dwFlags;
	GUID		guid;		// SP Guid
	WCHAR		*pwszName;	// Friendly Name
	PVOID		pvReserved;	
	DWORD		dwReserved;
} DPN_SERVICE_PROVIDER_INFO, *PDPN_SERVICE_PROVIDER_INFO;

//
// Service provider caps structure
//
typedef struct _DPN_SP_CAPS
{
	DWORD   dwSize;							// Size of this structure
	DWORD   dwFlags;						// Flags ((DPNSPCAPS_...)
	DWORD   dwNumThreads;					// # of worker threads to use
	DWORD	dwDefaultEnumCount;				// default # of enum requests
	DWORD	dwDefaultEnumRetryInterval;		// default ms between enum requests
	DWORD	dwDefaultEnumTimeout;			// default enum timeout
	DWORD	dwMaxEnumPayloadSize;			// maximum size in bytes for enum payload data
	DWORD	dwBuffersPerThread;				// number of receive buffers per thread
	DWORD	dwSystemBufferSize;				// amount of buffering to do in addition to posted receive buffers
} DPN_SP_CAPS, *PDPN_SP_CAPS;

//@@BEGIN_MSINTERNAL

//
// Security credentials
//
typedef struct	_DPN_SECURITY_CREDENTIALS
{
    DWORD   dwSize;
	DWORD	dwFlags;
} DPN_SECURITY_CREDENTIALS, *PDPN_SECURITY_CREDENTIALS;

//
// Security description
//
typedef struct	_DPN_SECURITY_DESC
{
    DWORD   dwSize;
	DWORD	dwFlags;
} DPN_SECURITY_DESC, *PDPN_SECURITY_DESC;

//@@END_MSINTERNAL


/****************************************************************************
 *
 * IDirectPlay8 message handler call back structures
 *
 ****************************************************************************/

//
// Add player to group strucutre for message handler
// (DPN_MSGID_ADD_PLAYER_TO_GROUP)
//
typedef struct	_DPNMSG_ADD_PLAYER_TO_GROUP
{
	DWORD	dwSize;				// Size of this structure
	DPNID	dpnidGroup;			// DPNID of group
	PVOID	pvGroupContext;		// Group context value
	DPNID	dpnidPlayer;		// DPNID of added player
	PVOID	pvPlayerContext;	// Player context value
} DPNMSG_ADD_PLAYER_TO_GROUP, *PDPNMSG_ADD_PLAYER_TO_GROUP;

//
// Async operation completion structure for message handler
// (DPN_MSGID_ASYNC_OP_COMPLETE)
//
typedef struct	_DPNMSG_ASYNC_OP_COMPLETE
{
	DWORD		dwSize;			// Size of this structure
	DPNHANDLE	hAsyncOp;		// DirectPlay8 async operation handle
	PVOID		pvUserContext;	// User context supplied
	HRESULT		hResultCode;	// HRESULT of operation
} DPNMSG_ASYNC_OP_COMPLETE, *PDPNMSG_ASYNC_OP_COMPLETE;

//
// Client info structure for message handler
// (DPN_MSGID_CLIENT_INFO)
//
typedef struct	_DPNMSG_CLIENT_INFO
{
	DWORD	dwSize;				// Size of this structure
	DPNID	dpnidClient;		// DPNID of client
	PVOID	pvPlayerContext;	// Player context value
} DPNMSG_CLIENT_INFO, *PDPNMSG_CLIENT_INFO;

//
// Connect complete structure for message handler
// (DPN_MSGID_CONNECT_COMPLETE)
//
typedef struct	_DPNMSG_CONNECT_COMPLETE
{
	DWORD		dwSize;						// Size of this structure
	DPNHANDLE	hAsyncOp;					// DirectPlay8 Async operation handle
	PVOID		pvUserContext;				// User context supplied at Connect
	HRESULT		hResultCode;				// HRESULT of connection attempt
	PVOID		pvApplicationReplyData;		// Connection reply data from Host/Server
	DWORD		dwApplicationReplyDataSize;	// Size (in bytes) of pvApplicationReplyData
} DPNMSG_CONNECT_COMPLETE, *PDPNMSG_CONNECT_COMPLETE;

//
// Create group structure for message handler
// (DPN_MSGID_CREATE_GROUP)
//
typedef struct	_DPNMSG_CREATE_GROUP
{
	DWORD	dwSize;				// Size of this structure
	DPNID	dpnidGroup;			// DPNID of new group
	DPNID	dpnidOwner;			// Owner of newgroup
	PVOID	pvGroupContext;		// Group context value
} DPNMSG_CREATE_GROUP, *PDPNMSG_CREATE_GROUP;

//
// Create player structure for message handler
// (DPN_MSGID_CREATE_PLAYER)
//
typedef struct	_DPNMSG_CREATE_PLAYER
{
	DWORD	dwSize;				// Size of this structure
	DPNID	dpnidPlayer;		// DPNID of new player
	PVOID	pvPlayerContext;	// Player context value
} DPNMSG_CREATE_PLAYER, *PDPNMSG_CREATE_PLAYER;

//
// Destroy group structure for message handler
// (DPN_MSGID_DESTROY_GROUP)
//
typedef struct	_DPNMSG_DESTROY_GROUP
{
	DWORD	dwSize;				// Size of this structure
	DPNID	dpnidGroup;			// DPNID of destroyed group
	PVOID	pvGroupContext;		// Group context value
	DWORD	dwReason;			// Information only
} DPNMSG_DESTROY_GROUP, *PDPNMSG_DESTROY_GROUP;

//
// Destroy player structure for message handler
// (DPN_MSGID_DESTROY_PLAYER)
//
typedef struct	_DPNMSG_DESTROY_PLAYER
{
	DWORD	dwSize;				// Size of this structure
	DPNID	dpnidPlayer;		// DPNID of leaving player
	PVOID	pvPlayerContext;	// Player context value
	DWORD	dwReason;			// Information only
} DPNMSG_DESTROY_PLAYER, *PDPNMSG_DESTROY_PLAYER;

//
// Enumeration request received structure for message handler
// (DPN_MSGID_ENUM_HOSTS_QUERY)
//
typedef	struct	_DPNMSG_ENUM_HOSTS_QUERY
{
	DWORD				dwSize;                 // Size of this structure.
	IDirectPlay8Address *pAddressSender;        // Address of client who sent the request
	IDirectPlay8Address	*pAddressDevice;        // Address of device request was received on
	PVOID				pvReceivedData;         // Request data (set on client)
	DWORD				dwReceivedDataSize;     // Request data size (set on client)
	DWORD				dwMaxResponseDataSize;	// Max allowable size of enum response
	PVOID				pvResponseData;		    // Optional query repsonse (user set)
	DWORD				dwResponseDataSize;	    // Optional query response size (user set)
	PVOID				pvResponseContext;	    // Optional query response context (user set)
} DPNMSG_ENUM_HOSTS_QUERY, *PDPNMSG_ENUM_HOSTS_QUERY;

//
// Enumeration response received structure for message handler
// (DPN_MSGID_ENUM_HOSTS_RESPONSE)
//
typedef	struct	_DPNMSG_ENUM_HOSTS_RESPONSE
{
	DWORD						dwSize;                     // Size of this structure
	IDirectPlay8Address			*pAddressSender;            // Address of host who responded
	IDirectPlay8Address			*pAddressDevice;            // Device response was received on
	const DPN_APPLICATION_DESC	*pApplicationDescription;   // Application description for the session
	PVOID						pvResponseData;             // Optional response data (set on host)
	DWORD						dwResponseDataSize;         // Optional response data size (set on host)
	PVOID						pvUserContext;              // Context value supplied for enumeration
    DWORD						dwRoundTripLatencyMS;       // Round trip latency in MS
} DPNMSG_ENUM_HOSTS_RESPONSE, *PDPNMSG_ENUM_HOSTS_RESPONSE;

//
// Group info structure for message handler
// (DPN_MSGID_GROUP_INFO)
//
typedef struct	_DPNMSG_GROUP_INFO
{
	DWORD	dwSize;				    // Size of this structure
	DPNID	dpnidGroup;			    // DPNID of group
	PVOID	pvGroupContext;		    // Group context value
} DPNMSG_GROUP_INFO, *PDPNMSG_GROUP_INFO;

//
// Migrate host structure for message handler
// (DPN_MSGID_HOST_MIGRATE)
//
typedef struct	_DPNMSG_HOST_MIGRATE
{
	DWORD	dwSize;				    // Size of this structure
	DPNID	dpnidNewHost;		    // DPNID of new Host player
	PVOID	pvPlayerContext;	    // Player context value
} DPNMSG_HOST_MIGRATE, *PDPNMSG_HOST_MIGRATE;

//
// Indicate connect structure for message handler
// (DPN_MSGID_INDICATE_CONNECT)
//
typedef struct	_DPNMSG_INDICATE_CONNECT
{
	DWORD		dwSize;					// Size of this structure
	PVOID		pvUserConnectData;		// Connecting player data
	DWORD		dwUserConnectDataSize;	// Size (in bytes) of pvUserConnectData
	PVOID		pvReplyData;			// Connection reply data
	DWORD		dwReplyDataSize;		// Size (in bytes) of pvReplyData
	PVOID		pvReplyContext;			// Buffer context for pvReplyData
	PVOID		pvPlayerContext;		// Player context preset
	IDirectPlay8Address	*pAddressPlayer;// Address of connecting player
	IDirectPlay8Address	*pAddressDevice;// Address of device receiving connect attempt
} DPNMSG_INDICATE_CONNECT, *PDPNMSG_INDICATE_CONNECT;

//
// Indicated connect aborted structure for message handler
// (DPN_MSGID_INDICATED_CONNECT_ABORTED)
//
typedef struct	_DPNMSG_INDICATED_CONNECT_ABORTED
{
	DWORD		dwSize;				// Size of this structure
	PVOID		pvPlayerContext;	// Player context preset from DPNMSG_INDICATE_CONNECT
} DPNMSG_INDICATED_CONNECT_ABORTED, *PDPNMSG_INDICATED_CONNECT_ABORTED;

//
// Peer info structure for message handler
// (DPN_MSGID_PEER_INFO)
//
typedef struct	_DPNMSG_PEER_INFO
{
	DWORD	dwSize;				    // Size of this structure
	DPNID	dpnidPeer;			    // DPNID of peer
	PVOID	pvPlayerContext;	    // Player context value
} DPNMSG_PEER_INFO, *PDPNMSG_PEER_INFO;

//
// Receive structure for message handler
// (DPN_MSGID_RECEIVE)
//
typedef struct	_DPNMSG_RECEIVE
{
	DWORD		dwSize;				// Size of this structure
	DPNID		dpnidSender;		// DPNID of sending player
	PVOID		pvPlayerContext;	// Player context value of sending player
	PBYTE		pReceiveData;		// Received data
	DWORD		dwReceiveDataSize;	// Size (in bytes) of pReceiveData
	DPNHANDLE	hBufferHandle;		// Buffer handle for pReceiveData
} DPNMSG_RECEIVE, *PDPNMSG_RECEIVE;

//
// Remove player from group structure for message handler
// (DPN_MSGID_REMOVE_PLAYER_FROM_GROUP)
//
typedef struct	_DPNMSG_REMOVE_PLAYER_FROM_GROUP
{
	DWORD	dwSize;				    // Size of this structure
	DPNID	dpnidGroup;			    // DPNID of group
	PVOID	pvGroupContext;		    // Group context value
	DPNID	dpnidPlayer;		    // DPNID of deleted player
	PVOID	pvPlayerContext;    	// Player context value
} DPNMSG_REMOVE_PLAYER_FROM_GROUP, *PDPNMSG_REMOVE_PLAYER_FROM_GROUP;

//
// Returned buffer structure for message handler
// (DPN_MSGID_RETURN_BUFFER)
//
typedef struct	_DPNMSG_RETURN_BUFFER
{
	DWORD		dwSize;				// Size of this structure
	HRESULT		hResultCode;		// Return value of operation
	PVOID		pvBuffer;			// Buffer being returned
	PVOID		pvUserContext;		// Context associated with buffer
} DPNMSG_RETURN_BUFFER, *PDPNMSG_RETURN_BUFFER;

//
// Send complete structure for message handler
// (DPN_MSGID_SEND_COMPLETE)
//
typedef struct	_DPNMSG_SEND_COMPLETE
{
	DWORD		dwSize;				// Size of this structure
	DPNHANDLE	hAsyncOp;			// DirectPlay8 Async operation handle
	PVOID		pvUserContext;		// User context supplied at Send/SendTo
	HRESULT		hResultCode;		// HRESULT of send
	DWORD		dwSendTime;			// Send time in ms
} DPNMSG_SEND_COMPLETE, *PDPNMSG_SEND_COMPLETE;

//
// Server info structure for message handler
// (DPN_MSGID_SERVER_INFO)
//
typedef struct	_DPNMSG_SERVER_INFO
{
	DWORD	dwSize;				    // Size of this structure
	DPNID	dpnidServer;		    // DPNID of server
	PVOID	pvPlayerContext;	    // Player context value
} DPNMSG_SERVER_INFO, *PDPNMSG_SERVER_INFO;

//
// Terminated session structure for message handler
// (DPN_MSGID_TERMINATE_SESSION)
//
typedef struct	_DPNMSG_TERMINATE_SESSION
{
	DWORD		dwSize;				// Size of this structure
	HRESULT		hResultCode;		// Reason
	PVOID		pvTerminateData;	// Data passed from Host/Server
	DWORD		dwTerminateDataSize;// Size (in bytes) of pvTerminateData
} DPNMSG_TERMINATE_SESSION, *PDPNMSG_TERMINATE_SESSION;


/****************************************************************************
 *
 * DirectPlay8 Functions
 *
 ****************************************************************************/

/*
 * This function is no longer supported.  It is recommended that CoCreateInstance be used to create 
 * DirectPlay8 objects.
 *
 * extern HRESULT WINAPI DirectPlay8Create( const GUID * pcIID, void **ppvInterface, IUnknown *pUnknown);
 * 
 */

/****************************************************************************
 *
 * DirectPlay8 Application Interfaces
 *
 ****************************************************************************/

//
// COM definition for DirectPlay8 Client interface
//
#undef INTERFACE				// External COM Implementation
#define INTERFACE IDirectPlay8Client
DECLARE_INTERFACE_(IDirectPlay8Client,IUnknown)
{
	/*** IUnknown methods ***/
	STDMETHOD(QueryInterface)			(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)			(THIS) PURE;
	STDMETHOD_(ULONG,Release)			(THIS) PURE;
	/*** IDirectPlay8Client methods ***/
	STDMETHOD(Initialize)				(THIS_ PVOID const pvUserContext, const PFNDPNMESSAGEHANDLER pfn, const DWORD dwFlags) PURE;
	STDMETHOD(EnumServiceProviders)		(THIS_ const GUID *const pguidServiceProvider, const GUID *const pguidApplication, DPN_SERVICE_PROVIDER_INFO *const pSPInfoBuffer, PDWORD const pcbEnumData, PDWORD const pcReturned, const DWORD dwFlags) PURE;
	STDMETHOD(EnumHosts)				(THIS_ PDPN_APPLICATION_DESC const pApplicationDesc,IDirectPlay8Address *const pAddrHost,IDirectPlay8Address *const pDeviceInfo,PVOID const pUserEnumData,const DWORD dwUserEnumDataSize,const DWORD dwEnumCount,const DWORD dwRetryInterval,const DWORD dwTimeOut,PVOID const pvUserContext,DPNHANDLE *const pAsyncHandle,const DWORD dwFlags) PURE;
	STDMETHOD(CancelAsyncOperation)		(THIS_ const DPNHANDLE hAsyncHandle, const DWORD dwFlags) PURE;
	STDMETHOD(Connect)					(THIS_ const DPN_APPLICATION_DESC *const pdnAppDesc,IDirectPlay8Address *const pHostAddr,IDirectPlay8Address *const pDeviceInfo,const DPN_SECURITY_DESC *const pdnSecurity,const DPN_SECURITY_CREDENTIALS *const pdnCredentials,const void *const pvUserConnectData,const DWORD dwUserConnectDataSize,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags) PURE;
	STDMETHOD(Send)						(THIS_ const DPN_BUFFER_DESC *const prgBufferDesc,const DWORD cBufferDesc,const DWORD dwTimeOut,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags) PURE;
	STDMETHOD(GetSendQueueInfo)			(THIS_ DWORD *const pdwNumMsgs, DWORD *const pdwNumBytes, const DWORD dwFlags) PURE;
	STDMETHOD(GetApplicationDesc)		(THIS_ DPN_APPLICATION_DESC *const pAppDescBuffer, DWORD *const pcbDataSize, const DWORD dwFlags) PURE;
	STDMETHOD(SetClientInfo)			(THIS_ const DPN_PLAYER_INFO *const pdpnPlayerInfo,PVOID const pvAsyncContext,DPNHANDLE *const phAsyncHandle, const DWORD dwFlags) PURE;
	STDMETHOD(GetServerInfo)			(THIS_ DPN_PLAYER_INFO *const pdpnPlayerInfo,DWORD *const pdwSize,const DWORD dwFlags) PURE;
	STDMETHOD(GetServerAddress)			(THIS_ IDirectPlay8Address **const pAddress,const DWORD dwFlags) PURE;
	STDMETHOD(Close)					(THIS_ const DWORD dwFlags) PURE;
	STDMETHOD(ReturnBuffer)				(THIS_ const DPNHANDLE hBufferHandle,const DWORD dwFlags) PURE;
	STDMETHOD(GetCaps)					(THIS_ DPN_CAPS *const pdpCaps,const DWORD dwFlags) PURE;
	STDMETHOD(SetCaps)					(THIS_ const DPN_CAPS *const pdpCaps, const DWORD dwFlags) PURE;
    STDMETHOD(SetSPCaps)                (THIS_ const GUID * const pguidSP, const DPN_SP_CAPS *const pdpspCaps, const DWORD dwFlags ) PURE;
    STDMETHOD(GetSPCaps)                (THIS_ const GUID * const pguidSP,DPN_SP_CAPS *const pdpspCaps,const DWORD dwFlags) PURE;
    STDMETHOD(GetConnectionInfo)        (THIS_ DPN_CONNECTION_INFO *const pdpConnectionInfo,const DWORD dwFlags) PURE;
	STDMETHOD(RegisterLobby)			(THIS_ const DPNHANDLE dpnHandle, struct IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags) PURE;
};

//
// COM definition for DirectPlay8 Server interface
//
#undef INTERFACE				// External COM Implementation
#define INTERFACE IDirectPlay8Server
DECLARE_INTERFACE_(IDirectPlay8Server,IUnknown)
{
	/*** IUnknown methods ***/
	STDMETHOD(QueryInterface)			(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)			(THIS) PURE;
	STDMETHOD_(ULONG,Release)			(THIS) PURE;
	/*** IDirectPlay8Server methods ***/
	STDMETHOD(Initialize)				(THIS_ PVOID const pvUserContext, const PFNDPNMESSAGEHANDLER pfn, const DWORD dwFlags) PURE;
	STDMETHOD(EnumServiceProviders)		(THIS_ const GUID *const pguidServiceProvider,const GUID *const pguidApplication,DPN_SERVICE_PROVIDER_INFO *const pSPInfoBuffer,PDWORD const pcbEnumData,PDWORD const pcReturned,const DWORD dwFlags) PURE;
	STDMETHOD(CancelAsyncOperation)		(THIS_ const DPNHANDLE hAsyncHandle,const DWORD dwFlags) PURE;
	STDMETHOD(GetSendQueueInfo)			(THIS_ const DPNID dpnid,DWORD *const pdwNumMsgs, DWORD *const pdwNumBytes, const DWORD dwFlags) PURE;
	STDMETHOD(GetApplicationDesc)		(THIS_ DPN_APPLICATION_DESC *const pAppDescBuffer, DWORD *const pcbDataSize, const DWORD dwFlags) PURE;
	STDMETHOD(SetServerInfo)			(THIS_ const DPN_PLAYER_INFO *const pdpnPlayerInfo,PVOID const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags) PURE;
	STDMETHOD(GetClientInfo)			(THIS_ const DPNID dpnid,DPN_PLAYER_INFO *const pdpnPlayerInfo,DWORD *const pdwSize,const DWORD dwFlags) PURE;
	STDMETHOD(GetClientAddress)			(THIS_ const DPNID dpnid,IDirectPlay8Address **const pAddress,const DWORD dwFlags) PURE;
	STDMETHOD(GetLocalHostAddresses)	(THIS_ IDirectPlay8Address **const prgpAddress,DWORD *const pcAddress,const DWORD dwFlags) PURE;
	STDMETHOD(SetApplicationDesc)		(THIS_ const DPN_APPLICATION_DESC *const pad, const DWORD dwFlags) PURE;
	STDMETHOD(Host)						(THIS_ const DPN_APPLICATION_DESC *const pdnAppDesc,IDirectPlay8Address **const prgpDeviceInfo,const DWORD cDeviceInfo,const DPN_SECURITY_DESC *const pdnSecurity,const DPN_SECURITY_CREDENTIALS *const pdnCredentials,void *const pvPlayerContext,const DWORD dwFlags) PURE;
	STDMETHOD(SendTo)					(THIS_ const DPNID dpnid,const DPN_BUFFER_DESC *const prgBufferDesc,const DWORD cBufferDesc,const DWORD dwTimeOut,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags) PURE;
	STDMETHOD(CreateGroup)				(THIS_ const DPN_GROUP_INFO *const pdpnGroupInfo,void *const pvGroupContext,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags) PURE;
	STDMETHOD(DestroyGroup)				(THIS_ const DPNID idGroup, PVOID const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags) PURE;
	STDMETHOD(AddPlayerToGroup)			(THIS_ const DPNID idGroup, const DPNID idClient, PVOID const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags) PURE;
	STDMETHOD(RemovePlayerFromGroup)	(THIS_ const DPNID idGroup, const DPNID idClient, PVOID const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags) PURE;
	STDMETHOD(SetGroupInfo)				(THIS_ const DPNID dpnid,DPN_GROUP_INFO *const pdpnGroupInfo,PVOID const pvAsyncContext,DPNHANDLE *const phAsyncHandle, const DWORD dwFlags) PURE;
	STDMETHOD(GetGroupInfo)				(THIS_ const DPNID dpnid,DPN_GROUP_INFO *const pdpnGroupInfo,DWORD *const pdwSize,const DWORD dwFlags) PURE;
	STDMETHOD(EnumPlayersAndGroups)		(THIS_ DPNID *const prgdpnid, DWORD *const pcdpnid, const DWORD dwFlags) PURE;
	STDMETHOD(EnumGroupMembers)			(THIS_ const DPNID dpnid, DPNID *const prgdpnid, DWORD *const pcdpnid, const DWORD dwFlags) PURE;
	STDMETHOD(Close)					(THIS_ const DWORD dwFlags) PURE;
	STDMETHOD(DestroyClient)			(THIS_ const DPNID dpnidClient, const void *const pvDestroyData, const DWORD dwDestroyDataSize, const DWORD dwFlags) PURE;
	STDMETHOD(ReturnBuffer)				(THIS_ const DPNHANDLE hBufferHandle,const DWORD dwFlags) PURE;
	STDMETHOD(GetPlayerContext)			(THIS_ const DPNID dpnid,PVOID *const ppvPlayerContext,const DWORD dwFlags) PURE;
	STDMETHOD(GetGroupContext)			(THIS_ const DPNID dpnid,PVOID *const ppvGroupContext,const DWORD dwFlags) PURE;
	STDMETHOD(GetCaps)					(THIS_ DPN_CAPS *const pdpCaps,const DWORD dwFlags) PURE;
	STDMETHOD(SetCaps)					(THIS_ const DPN_CAPS *const pdpCaps, const DWORD dwFlags) PURE;
    STDMETHOD(SetSPCaps)                (THIS_ const GUID * const pguidSP, const DPN_SP_CAPS *const pdpspCaps, const DWORD dwFlags ) PURE;
    STDMETHOD(GetSPCaps)                (THIS_ const GUID * const pguidSP, DPN_SP_CAPS *const pdpspCaps,const DWORD dwFlags) PURE;
    STDMETHOD(GetConnectionInfo)        (THIS_ const DPNID dpnid, DPN_CONNECTION_INFO *const pdpConnectionInfo,const DWORD dwFlags) PURE;
	STDMETHOD(RegisterLobby)			(THIS_ const DPNHANDLE dpnHandle, struct IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags) PURE;
//@@BEGIN_MSINTERNAL
	STDMETHOD(DumpNameTable)			(THIS_ char *const Buffer) PURE;
//@@END_MSINTERNAL
};

//
// COM definition for DirectPlay8 Peer interface
//
#undef INTERFACE				// External COM Implementation
#define INTERFACE IDirectPlay8Peer
DECLARE_INTERFACE_(IDirectPlay8Peer,IUnknown)
{
	/*** IUnknown methods ***/
	STDMETHOD(QueryInterface)			(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)			(THIS) PURE;
	STDMETHOD_(ULONG,Release)			(THIS) PURE;
	/*** IDirectPlay8Peer methods ***/
	STDMETHOD(Initialize)				(THIS_ PVOID const pvUserContext, const PFNDPNMESSAGEHANDLER pfn, const DWORD dwFlags) PURE;
	STDMETHOD(EnumServiceProviders)		(THIS_ const GUID *const pguidServiceProvider, const GUID *const pguidApplication, DPN_SERVICE_PROVIDER_INFO *const pSPInfoBuffer, DWORD *const pcbEnumData, DWORD *const pcReturned, const DWORD dwFlags) PURE;
	STDMETHOD(CancelAsyncOperation)		(THIS_ const DPNHANDLE hAsyncHandle, const DWORD dwFlags) PURE;
	STDMETHOD(Connect)					(THIS_ const DPN_APPLICATION_DESC *const pdnAppDesc,IDirectPlay8Address *const pHostAddr,IDirectPlay8Address *const pDeviceInfo,const DPN_SECURITY_DESC *const pdnSecurity,const DPN_SECURITY_CREDENTIALS *const pdnCredentials,const void *const pvUserConnectData,const DWORD dwUserConnectDataSize,void *const pvPlayerContext,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags) PURE;
	STDMETHOD(SendTo)					(THIS_ const DPNID dpnid,const DPN_BUFFER_DESC *const prgBufferDesc,const DWORD cBufferDesc,const DWORD dwTimeOut,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags) PURE;
	STDMETHOD(GetSendQueueInfo)			(THIS_ const DPNID dpnid, DWORD *const pdwNumMsgs, DWORD *const pdwNumBytes, const DWORD dwFlags) PURE;
	STDMETHOD(Host)						(THIS_ const DPN_APPLICATION_DESC *const pdnAppDesc,IDirectPlay8Address **const prgpDeviceInfo,const DWORD cDeviceInfo,const DPN_SECURITY_DESC *const pdnSecurity,const DPN_SECURITY_CREDENTIALS *const pdnCredentials,void *const pvPlayerContext,const DWORD dwFlags) PURE;
	STDMETHOD(GetApplicationDesc)		(THIS_ DPN_APPLICATION_DESC *const pAppDescBuffer, DWORD *const pcbDataSize, const DWORD dwFlags) PURE;
	STDMETHOD(SetApplicationDesc)		(THIS_ const DPN_APPLICATION_DESC *const pad, const DWORD dwFlags) PURE;
	STDMETHOD(CreateGroup)				(THIS_ const DPN_GROUP_INFO *const pdpnGroupInfo,void *const pvGroupContext,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags) PURE;
	STDMETHOD(DestroyGroup)				(THIS_ const DPNID idGroup, PVOID const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags) PURE;
	STDMETHOD(AddPlayerToGroup)			(THIS_ const DPNID idGroup, const DPNID idClient, PVOID const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags) PURE;
	STDMETHOD(RemovePlayerFromGroup)	(THIS_ const DPNID idGroup, const DPNID idClient, PVOID const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags) PURE;
	STDMETHOD(SetGroupInfo)				(THIS_ const DPNID dpnid,DPN_GROUP_INFO *const pdpnGroupInfo,PVOID const pvAsyncContext,DPNHANDLE *const phAsyncHandle, const DWORD dwFlags) PURE;
	STDMETHOD(GetGroupInfo)				(THIS_ const DPNID dpnid,DPN_GROUP_INFO *const pdpnGroupInfo,DWORD *const pdwSize,const DWORD dwFlags) PURE;
	STDMETHOD(EnumPlayersAndGroups)		(THIS_ DPNID *const prgdpnid, DWORD *const pcdpnid, const DWORD dwFlags) PURE;
	STDMETHOD(EnumGroupMembers)			(THIS_ const DPNID dpnid, DPNID *const prgdpnid, DWORD *const pcdpnid, const DWORD dwFlags) PURE;
	STDMETHOD(SetPeerInfo)				(THIS_ const DPN_PLAYER_INFO *const pdpnPlayerInfo,PVOID const pvAsyncContext,DPNHANDLE *const phAsyncHandle, const DWORD dwFlags) PURE;
	STDMETHOD(GetPeerInfo)				(THIS_ const DPNID dpnid,DPN_PLAYER_INFO *const pdpnPlayerInfo,DWORD *const pdwSize,const DWORD dwFlags) PURE;
	STDMETHOD(GetPeerAddress)			(THIS_ const DPNID dpnid,IDirectPlay8Address **const pAddress,const DWORD dwFlags) PURE;
	STDMETHOD(GetLocalHostAddresses)	(THIS_ IDirectPlay8Address **const prgpAddress,DWORD *const pcAddress,const DWORD dwFlags) PURE;
	STDMETHOD(Close)					(THIS_ const DWORD dwFlags) PURE;
	STDMETHOD(EnumHosts)				(THIS_ PDPN_APPLICATION_DESC const pApplicationDesc,IDirectPlay8Address *const pAddrHost,IDirectPlay8Address *const pDeviceInfo,PVOID const pUserEnumData,const DWORD dwUserEnumDataSize,const DWORD dwEnumCount,const DWORD dwRetryInterval,const DWORD dwTimeOut,PVOID const pvUserContext,DPNHANDLE *const pAsyncHandle,const DWORD dwFlags) PURE;
	STDMETHOD(DestroyPeer)				(THIS_ const DPNID dpnidClient, const void *const pvDestroyData, const DWORD dwDestroyDataSize, const DWORD dwFlags) PURE;
	STDMETHOD(ReturnBuffer)				(THIS_ const DPNHANDLE hBufferHandle,const DWORD dwFlags) PURE;
	STDMETHOD(GetPlayerContext)			(THIS_ const DPNID dpnid,PVOID *const ppvPlayerContext,const DWORD dwFlags) PURE;
	STDMETHOD(GetGroupContext)			(THIS_ const DPNID dpnid,PVOID *const ppvGroupContext,const DWORD dwFlags) PURE;
	STDMETHOD(GetCaps)					(THIS_ DPN_CAPS *const pdpCaps,const DWORD dwFlags) PURE;
	STDMETHOD(SetCaps)					(THIS_ const DPN_CAPS *const pdpCaps, const DWORD dwFlags) PURE;
    STDMETHOD(SetSPCaps)                (THIS_ const GUID * const pguidSP, const DPN_SP_CAPS *const pdpspCaps, const DWORD dwFlags ) PURE;
    STDMETHOD(GetSPCaps)                (THIS_ const GUID * const pguidSP, DPN_SP_CAPS *const pdpspCaps,const DWORD dwFlags) PURE;
    STDMETHOD(GetConnectionInfo)        (THIS_ const DPNID dpnid, DPN_CONNECTION_INFO *const pdpConnectionInfo,const DWORD dwFlags) PURE;
	STDMETHOD(RegisterLobby)			(THIS_ const DPNHANDLE dpnHandle, struct IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags) PURE;
	STDMETHOD(TerminateSession)			(THIS_ void *const pvTerminateData,const DWORD dwTerminateDataSize,const DWORD dwFlags) PURE;
//@@BEGIN_MSINTERNAL
	STDMETHOD(DumpNameTable)			(THIS_ char *const Buffer) PURE;
//@@END_MSINTERNAL
};


/****************************************************************************
 *
 * IDirectPlay8 application interface macros
 *
 ****************************************************************************/

#if !defined(__cplusplus) || defined(CINTERFACE)

#define	IDirectPlay8Client_QueryInterface(p,a,b)				(p)->lpVtbl->QueryInterface(p,a,b)
#define	IDirectPlay8Client_AddRef(p)							(p)->lpVtbl->AddRef(p)
#define	IDirectPlay8Client_Release(p)							(p)->lpVtbl->Release(p)
#define	IDirectPlay8Client_Initialize(p,a,b,c)					(p)->lpVtbl->Initialize(p,a,b,c)
#define	IDirectPlay8Client_EnumServiceProviders(p,a,b,c,d,e,f)	(p)->lpVtbl->EnumServiceProviders(p,a,b,c,d,e,f)
#define	IDirectPlay8Client_EnumHosts(p,a,b,c,d,e,f,g,h,i,j,k)	(p)->lpVtbl->EnumHosts(p,a,b,c,d,e,f,g,h,i,j,k)
#define	IDirectPlay8Client_CancelAsyncOperation(p,a,b)			(p)->lpVtbl->CancelAsyncOperation(p,a,b)
#define	IDirectPlay8Client_Connect(p,a,b,c,d,e,f,g,h,i,j)		(p)->lpVtbl->Connect(p,a,b,c,d,e,f,g,h,i,j)
#define	IDirectPlay8Client_Send(p,a,b,c,d,e,f)					(p)->lpVtbl->Send(p,a,b,c,d,e,f)
#define	IDirectPlay8Client_GetSendQueueInfo(p,a,b,c)			(p)->lpVtbl->GetSendQueueInfo(p,a,b,c)
#define	IDirectPlay8Client_GetApplicationDesc(p,a,b,c)			(p)->lpVtbl->GetApplicationDesc(p,a,b,c)
#define	IDirectPlay8Client_SetClientInfo(p,a,b,c,d)				(p)->lpVtbl->SetClientInfo(p,a,b,c,d)
#define	IDirectPlay8Client_GetServerInfo(p,a,b,c)				(p)->lpVtbl->GetServerInfo(p,a,b,c)
#define	IDirectPlay8Client_GetServerAddress(p,a,b)				(p)->lpVtbl->GetServerAddress(p,a,b)
#define	IDirectPlay8Client_Close(p,a)							(p)->lpVtbl->Close(p,a)
#define	IDirectPlay8Client_ReturnBuffer(p,a,b)					(p)->lpVtbl->ReturnBuffer(p,a,b)
#define	IDirectPlay8Client_GetCaps(p,a,b)						(p)->lpVtbl->GetCaps(p,a,b)
#define	IDirectPlay8Client_SetCaps(p,a,b)						(p)->lpVtbl->SetCaps(p,a,b)
#define	IDirectPlay8Client_SetSPCaps(p,a,b,c)					(p)->lpVtbl->SetSPCaps(p,a,b,c)
#define	IDirectPlay8Client_GetSPCaps(p,a,b,c)					(p)->lpVtbl->GetSPCaps(p,a,b,c)
#define	IDirectPlay8Client_GetConnectionInfo(p,a,b)				(p)->lpVtbl->GetConnectionInfo(p,a,b)
#define	IDirectPlay8Client_RegisterLobby(p,a,b,c)				(p)->lpVtbl->RegisterLobby(p,a,b,c)

#define	IDirectPlay8Server_QueryInterface(p,a,b)				(p)->lpVtbl->QueryInterface(p,a,b)
#define	IDirectPlay8Server_AddRef(p)							(p)->lpVtbl->AddRef(p)
#define	IDirectPlay8Server_Release(p)							(p)->lpVtbl->Release(p)
#define	IDirectPlay8Server_Initialize(p,a,b,c)					(p)->lpVtbl->Initialize(p,a,b,c)
#define	IDirectPlay8Server_EnumServiceProviders(p,a,b,c,d,e,f)	(p)->lpVtbl->EnumServiceProviders(p,a,b,c,d,e,f)
#define	IDirectPlay8Server_CancelAsyncOperation(p,a,b)			(p)->lpVtbl->CancelAsyncOperation(p,a,b)
#define	IDirectPlay8Server_GetSendQueueInfo(p,a,b,c,d)			(p)->lpVtbl->GetSendQueueInfo(p,a,b,c,d)
#define	IDirectPlay8Server_GetApplicationDesc(p,a,b,c)			(p)->lpVtbl->GetApplicationDesc(p,a,b,c)
#define	IDirectPlay8Server_SetServerInfo(p,a,b,c,d)				(p)->lpVtbl->SetServerInfo(p,a,b,c,d)
#define	IDirectPlay8Server_GetClientInfo(p,a,b,c,d)				(p)->lpVtbl->GetClientInfo(p,a,b,c,d)
#define	IDirectPlay8Server_GetClientAddress(p,a,b,c)			(p)->lpVtbl->GetClientAddress(p,a,b,c)
#define	IDirectPlay8Server_GetLocalHostAddresses(p,a,b,c)		(p)->lpVtbl->GetLocalHostAddresses(p,a,b,c)
#define	IDirectPlay8Server_SetApplicationDesc(p,a,b)			(p)->lpVtbl->SetApplicationDesc(p,a,b)
#define	IDirectPlay8Server_Host(p,a,b,c,d,e,f,g)				(p)->lpVtbl->Host(p,a,b,c,d,e,f,g)
#define	IDirectPlay8Server_SendTo(p,a,b,c,d,e,f,g)				(p)->lpVtbl->SendTo(p,a,b,c,d,e,f,g)
#define	IDirectPlay8Server_CreateGroup(p,a,b,c,d,e)				(p)->lpVtbl->CreateGroup(p,a,b,c,d,e)
#define	IDirectPlay8Server_DestroyGroup(p,a,b,c,d)				(p)->lpVtbl->DestroyGroup(p,a,b,c,d)
#define	IDirectPlay8Server_AddPlayerToGroup(p,a,b,c,d,e)		(p)->lpVtbl->AddPlayerToGroup(p,a,b,c,d,e)
#define	IDirectPlay8Server_RemovePlayerFromGroup(p,a,b,c,d,e)	(p)->lpVtbl->RemovePlayerFromGroup(p,a,b,c,d,e)
#define	IDirectPlay8Server_SetGroupInfo(p,a,b,c,d,e)			(p)->lpVtbl->SetGroupInfo(p,a,b,c,d,e)
#define	IDirectPlay8Server_GetGroupInfo(p,a,b,c,d)				(p)->lpVtbl->GetGroupInfo(p,a,b,c,d)
#define	IDirectPlay8Server_EnumPlayersAndGroups(p,a,b,c)		(p)->lpVtbl->EnumPlayersAndGroups(p,a,b,c)
#define	IDirectPlay8Server_EnumGroupMembers(p,a,b,c,d)			(p)->lpVtbl->EnumGroupMembers(p,a,b,c,d)
#define	IDirectPlay8Server_Close(p,a)							(p)->lpVtbl->Close(p,a)
#define	IDirectPlay8Server_DestroyClient(p,a,b,c,d)				(p)->lpVtbl->DestroyClient(p,a,b,c,d)
#define	IDirectPlay8Server_ReturnBuffer(p,a,b)					(p)->lpVtbl->ReturnBuffer(p,a,b)
#define	IDirectPlay8Server_GetPlayerContext(p,a,b,c)			(p)->lpVtbl->GetPlayerContext(p,a,b,c)
#define	IDirectPlay8Server_GetGroupContext(p,a,b,c)				(p)->lpVtbl->GetGroupContext(p,a,b,c)
#define	IDirectPlay8Server_GetCaps(p,a,b)						(p)->lpVtbl->GetCaps(p,a,b)
#define	IDirectPlay8Server_SetCaps(p,a,b)						(p)->lpVtbl->SetCaps(p,a,b)
#define	IDirectPlay8Server_SetSPCaps(p,a,b,c)					(p)->lpVtbl->SetSPCaps(p,a,b,c)
#define	IDirectPlay8Server_GetSPCaps(p,a,b,c)					(p)->lpVtbl->GetSPCaps(p,a,b,c)
#define	IDirectPlay8Server_GetConnectionInfo(p,a,b,c)			(p)->lpVtbl->GetConnectionInfo(p,a,b,c)
#define	IDirectPlay8Server_RegisterLobby(p,a,b,c)				(p)->lpVtbl->RegisterLobby(p,a,b,c)

#define	IDirectPlay8Peer_QueryInterface(p,a,b)					(p)->lpVtbl->QueryInterface(p,a,b)
#define	IDirectPlay8Peer_AddRef(p)								(p)->lpVtbl->AddRef(p)
#define	IDirectPlay8Peer_Release(p)								(p)->lpVtbl->Release(p)
#define	IDirectPlay8Peer_Initialize(p,a,b,c)					(p)->lpVtbl->Initialize(p,a,b,c)
#define	IDirectPlay8Peer_EnumServiceProviders(p,a,b,c,d,e,f)	(p)->lpVtbl->EnumServiceProviders(p,a,b,c,d,e,f)
#define	IDirectPlay8Peer_EnumHosts(p,a,b,c,d,e,f,g,h,i,j,k)		(p)->lpVtbl->EnumHosts(p,a,b,c,d,e,f,g,h,i,j,k)

#define	IDirectPlay8Peer_CancelAsyncOperation(p,a,b)			(p)->lpVtbl->CancelAsyncOperation(p,a,b)
#define	IDirectPlay8Peer_Connect(p,a,b,c,d,e,f,g,h,i,j,k)		(p)->lpVtbl->Connect(p,a,b,c,d,e,f,g,h,i,j,k)
#define	IDirectPlay8Peer_SendTo(p,a,b,c,d,e,f,g)				(p)->lpVtbl->SendTo(p,a,b,c,d,e,f,g)
#define	IDirectPlay8Peer_GetSendQueueInfo(p,a,b,c,d)			(p)->lpVtbl->GetSendQueueInfo(p,a,b,c,d)
#define	IDirectPlay8Peer_Host(p,a,b,c,d,e,f,g)					(p)->lpVtbl->Host(p,a,b,c,d,e,f,g)
#define	IDirectPlay8Peer_GetApplicationDesc(p,a,b,c)			(p)->lpVtbl->GetApplicationDesc(p,a,b,c)
#define	IDirectPlay8Peer_SetApplicationDesc(p,a,b)				(p)->lpVtbl->SetApplicationDesc(p,a,b)
#define	IDirectPlay8Peer_CreateGroup(p,a,b,c,d,e)				(p)->lpVtbl->CreateGroup(p,a,b,c,d,e)
#define	IDirectPlay8Peer_DestroyGroup(p,a,b,c,d)				(p)->lpVtbl->DestroyGroup(p,a,b,c,d)
#define	IDirectPlay8Peer_AddPlayerToGroup(p,a,b,c,d,e)			(p)->lpVtbl->AddPlayerToGroup(p,a,b,c,d,e)
#define	IDirectPlay8Peer_RemovePlayerFromGroup(p,a,b,c,d,e)		(p)->lpVtbl->RemovePlayerFromGroup(p,a,b,c,d,e)
#define	IDirectPlay8Peer_SetGroupInfo(p,a,b,c,d,e)				(p)->lpVtbl->SetGroupInfo(p,a,b,c,d,e)
#define	IDirectPlay8Peer_GetGroupInfo(p,a,b,c,d)				(p)->lpVtbl->GetGroupInfo(p,a,b,c,d)
#define	IDirectPlay8Peer_EnumPlayersAndGroups(p,a,b,c)			(p)->lpVtbl->EnumPlayersAndGroups(p,a,b,c)
#define	IDirectPlay8Peer_EnumGroupMembers(p,a,b,c,d)			(p)->lpVtbl->EnumGroupMembers(p,a,b,c,d)
#define	IDirectPlay8Peer_SetPeerInfo(p,a,b,c,d)					(p)->lpVtbl->SetPeerInfo(p,a,b,c,d)
#define	IDirectPlay8Peer_GetPeerInfo(p,a,b,c,d)					(p)->lpVtbl->GetPeerInfo(p,a,b,c,d)
#define	IDirectPlay8Peer_GetPeerAddress(p,a,b,c)				(p)->lpVtbl->GetPeerAddress(p,a,b,c)
#define	IDirectPlay8Peer_GetLocalHostAddresses(p,a,b,c)			(p)->lpVtbl->GetLocalHostAddresses(p,a,b,c)
#define	IDirectPlay8Peer_Close(p,a)								(p)->lpVtbl->Close(p,a)
#define	IDirectPlay8Peer_EnumHosts(p,a,b,c,d,e,f,g,h,i,j,k)	    (p)->lpVtbl->EnumHosts(p,a,b,c,d,e,f,g,h,i,j,k)
#define	IDirectPlay8Peer_DestroyPeer(p,a,b,c,d)					(p)->lpVtbl->DestroyPeer(p,a,b,c,d)
#define	IDirectPlay8Peer_ReturnBuffer(p,a,b)					(p)->lpVtbl->ReturnBuffer(p,a,b)
#define	IDirectPlay8Peer_GetPlayerContext(p,a,b,c)				(p)->lpVtbl->GetPlayerContext(p,a,b,c)
#define	IDirectPlay8Peer_GetGroupContext(p,a,b,c)				(p)->lpVtbl->GetGroupContext(p,a,b,c)
#define	IDirectPlay8Peer_GetCaps(p,a,b)							(p)->lpVtbl->GetCaps(p,a,b)
#define	IDirectPlay8Peer_SetCaps(p,a,b)							(p)->lpVtbl->SetCaps(p,a,b)
#define	IDirectPlay8Peer_SetSPCaps(p,a,b,c)						(p)->lpVtbl->SetSPCaps(p,a,b,c)
#define	IDirectPlay8Peer_GetSPCaps(p,a,b,c)						(p)->lpVtbl->GetSPCaps(p,a,b,c)
#define	IDirectPlay8Peer_GetConnectionInfo(p,a,b,c)				(p)->lpVtbl->GetConnectionInfo(p,a,b,c)
#define	IDirectPlay8Peer_RegisterLobby(p,a,b,c)				    (p)->lpVtbl->RegisterLobby(p,a,b,c)
#define	IDirectPlay8Peer_TerminateSession(p,a,b,c)				(p)->lpVtbl->TerminateSession(p,a,b,c)

#else /* C++ */

#define	IDirectPlay8Client_QueryInterface(p,a,b)				(p)->QueryInterface(a,b)
#define	IDirectPlay8Client_AddRef(p)							(p)->AddRef()
#define	IDirectPlay8Client_Release(p)							(p)->Release()
#define	IDirectPlay8Client_Initialize(p,a,b,c)					(p)->Initialize(a,b,c)
#define	IDirectPlay8Client_EnumServiceProviders(p,a,b,c,d,e,f)	(p)->EnumServiceProviders(a,b,c,d,e,f)
#define	IDirectPlay8Client_EnumHosts(p,a,b,c,d,e,f,g,h,i,j,k)	(p)->EnumHosts(a,b,c,d,e,f,g,h,i,j,k)
#define	IDirectPlay8Client_CancelAsyncOperation(p,a,b)			(p)->CancelAsyncOperation(a,b)
#define	IDirectPlay8Client_Connect(p,a,b,c,d,e,f,g,h,i,j)		(p)->Connect(a,b,c,d,e,f,g,h,i,j)
#define	IDirectPlay8Client_Send(p,a,b,c,d,e,f)					(p)->Send(a,b,c,d,e,f)
#define	IDirectPlay8Client_GetSendQueueInfo(p,a,b,c)			(p)->GetSendQueueInfo(a,b,c)
#define	IDirectPlay8Client_GetApplicationDesc(p,a,b,c)			(p)->GetApplicationDesc(a,b,c)
#define	IDirectPlay8Client_SetClientInfo(p,a,b,c,d)				(p)->SetClientInfo(a,b,c,d)
#define	IDirectPlay8Client_GetServerInfo(p,a,b,c)				(p)->GetServerInfo(a,b,c)
#define	IDirectPlay8Client_GetServerAddress(p,a,b)				(p)->GetServerAddress(a,b)
#define	IDirectPlay8Client_Close(p,a)							(p)->Close(a)
#define	IDirectPlay8Client_ReturnBuffer(p,a,b)					(p)->ReturnBuffer(a,b)
#define	IDirectPlay8Client_GetCaps(p,a,b)						(p)->GetCaps(a,b)
#define	IDirectPlay8Client_SetCaps(p,a,b)						(p)->SetCaps(a,b)
#define	IDirectPlay8Client_SetSPCaps(p,a,b,c)					(p)->SetSPCaps(a,b,c)
#define	IDirectPlay8Client_GetSPCaps(p,a,b,c)					(p)->GetSPCaps(a,b,c)
#define	IDirectPlay8Client_GetConnectionInfo(p,a,b)				(p)->GetConnectionInfo(a,b)
#define	IDirectPlay8Client_RegisterLobby(p,a,b,c)				(p)->RegisterLobby(a,b,c)

#define	IDirectPlay8Server_QueryInterface(p,a,b)				(p)->QueryInterface(a,b)
#define	IDirectPlay8Server_AddRef(p)							(p)->AddRef()
#define	IDirectPlay8Server_Release(p)							(p)->Release()
#define	IDirectPlay8Server_Initialize(p,a,b,c)					(p)->Initialize(a,b,c)
#define	IDirectPlay8Server_EnumServiceProviders(p,a,b,c,d,e,f)	(p)->EnumServiceProviders(a,b,c,d,e,f)
#define	IDirectPlay8Server_CancelAsyncOperation(p,a,b)			(p)->CancelAsyncOperation(a,b)
#define	IDirectPlay8Server_GetSendQueueInfo(p,a,b,c,d)			(p)->GetSendQueueInfo(a,b,c,d)
#define	IDirectPlay8Server_GetApplicationDesc(p,a,b,c)			(p)->GetApplicationDesc(a,b,c)
#define	IDirectPlay8Server_SetServerInfo(p,a,b,c,d)				(p)->SetServerInfo(a,b,c,d)
#define	IDirectPlay8Server_GetClientInfo(p,a,b,c,d)				(p)->GetClientInfo(a,b,c,d)
#define	IDirectPlay8Server_GetClientAddress(p,a,b,c)			(p)->GetClientAddress(a,b,c)
#define	IDirectPlay8Server_GetLocalHostAddresses(p,a,b,c)		(p)->GetLocalHostAddresses(a,b,c)
#define	IDirectPlay8Server_SetApplicationDesc(p,a,b)			(p)->SetApplicationDesc(a,b)
#define	IDirectPlay8Server_Host(p,a,b,c,d,e,f,g)				(p)->Host(a,b,c,d,e,f,g)
#define	IDirectPlay8Server_SendTo(p,a,b,c,d,e,f,g)				(p)->SendTo(a,b,c,d,e,f,g)
#define	IDirectPlay8Server_CreateGroup(p,a,b,c,d,e)				(p)->CreateGroup(a,b,c,d,e)
#define	IDirectPlay8Server_DestroyGroup(p,a,b,c,d)				(p)->DestroyGroup(a,b,c,d)
#define	IDirectPlay8Server_AddPlayerToGroup(p,a,b,c,d,e)		(p)->AddPlayerToGroup(a,b,c,d,e)
#define	IDirectPlay8Server_RemovePlayerFromGroup(p,a,b,c,d,e)	(p)->RemovePlayerFromGroup(a,b,c,d,e)
#define	IDirectPlay8Server_SetGroupInfo(p,a,b,c,d,e)			(p)->SetGroupInfo(a,b,c,d,e)
#define	IDirectPlay8Server_GetGroupInfo(p,a,b,c,d)				(p)->GetGroupInfo(a,b,c,d)
#define	IDirectPlay8Server_EnumPlayersAndGroups(p,a,b,c)		(p)->EnumPlayersAndGroups(a,b,c)
#define	IDirectPlay8Server_EnumGroupMembers(p,a,b,c,d)			(p)->EnumGroupMembers(a,b,c,d)
#define	IDirectPlay8Server_Close(p,a)							(p)->Close(a)
#define	IDirectPlay8Server_DestroyClient(p,a,b,c,d)				(p)->DestroyClient(a,b,c,d)
#define	IDirectPlay8Server_ReturnBuffer(p,a,b)					(p)->ReturnBuffer(a,b)
#define	IDirectPlay8Server_GetPlayerContext(p,a,b,c)			(p)->GetPlayerContext(a,b,c)
#define	IDirectPlay8Server_GetGroupContext(p,a,b,c)				(p)->GetGroupContext(a,b,c)
#define	IDirectPlay8Server_GetCaps(p,a,b)						(p)->GetCaps(a,b)
#define	IDirectPlay8Server_SetCaps(p,a,b)						(p)->SetCaps(a,b)
#define	IDirectPlay8Server_SetSPCaps(p,a,b,c)					(p)->SetSPCaps(a,b,c)
#define	IDirectPlay8Server_GetSPCaps(p,a,b,c)					(p)->GetSPCaps(a,b,c)
#define	IDirectPlay8Server_GetConnectionInfo(p,a,b,c)			(p)->GetConnectionInfo(a,b,c)
#define	IDirectPlay8Server_RegisterLobby(p,a,b,c)				(p)->RegisterLobby(a,b,c)

#define	IDirectPlay8Peer_QueryInterface(p,a,b)					(p)->QueryInterface(a,b)
#define	IDirectPlay8Peer_AddRef(p)								(p)->AddRef()
#define	IDirectPlay8Peer_Release(p)								(p)->Release()
#define	IDirectPlay8Peer_Initialize(p,a,b,c)					(p)->Initialize(a,b,c)
#define	IDirectPlay8Peer_EnumServiceProviders(p,a,b,c,d,e,f)	(p)->EnumServiceProviders(a,b,c,d,e,f)
#define	IDirectPlay8Peer_EnumHosts(p,a,b,c,d,e,f,g,h,i,j,k)		(p)->EnumHosts(a,b,c,d,e,f,g,h,i,j,k)
#define	IDirectPlay8Peer_CancelAsyncOperation(p,a,b)			(p)->CancelAsyncOperation(a,b)
#define	IDirectPlay8Peer_Connect(p,a,b,c,d,e,f,g,h,i,j,k)		(p)->Connect(a,b,c,d,e,f,g,h,i,j,k)
#define	IDirectPlay8Peer_SendTo(p,a,b,c,d,e,f,g)				(p)->SendTo(a,b,c,d,e,f,g)
#define	IDirectPlay8Peer_GetSendQueueInfo(p,a,b,c,d)			(p)->GetSendQueueInfo(a,b,c,d)
#define	IDirectPlay8Peer_Host(p,a,b,c,d,e,f,g)					(p)->Host(a,b,c,d,e,f,g)
#define	IDirectPlay8Peer_GetApplicationDesc(p,a,b,c)			(p)->GetApplicationDesc(a,b,c)
#define	IDirectPlay8Peer_SetApplicationDesc(p,a,b)				(p)->SetApplicationDesc(a,b)
#define	IDirectPlay8Peer_CreateGroup(p,a,b,c,d,e)				(p)->CreateGroup(a,b,c,d,e)
#define	IDirectPlay8Peer_DestroyGroup(p,a,b,c,d)				(p)->DestroyGroup(a,b,c,d)
#define	IDirectPlay8Peer_AddPlayerToGroup(p,a,b,c,d,e)			(p)->AddPlayerToGroup(a,b,c,d,e)
#define	IDirectPlay8Peer_RemovePlayerFromGroup(p,a,b,c,d,e)		(p)->RemovePlayerFromGroup(a,b,c,d,e)
#define	IDirectPlay8Peer_SetGroupInfo(p,a,b,c,d,e)				(p)->SetGroupInfo(a,b,c,d,e)
#define	IDirectPlay8Peer_GetGroupInfo(p,a,b,c,d)				(p)->GetGroupInfo(a,b,c,d)
#define	IDirectPlay8Peer_EnumPlayersAndGroups(p,a,b,c)			(p)->EnumPlayersAndGroups(a,b,c)
#define	IDirectPlay8Peer_EnumGroupMembers(p,a,b,c,d)			(p)->EnumGroupMembers(a,b,c,d)
#define	IDirectPlay8Peer_SetPeerInfo(p,a,b,c,d)					(p)->SetPeerInfo(a,b,c,d)
#define	IDirectPlay8Peer_GetPeerInfo(p,a,b,c,d)					(p)->GetPeerInfo(a,b,c,d)
#define	IDirectPlay8Peer_GetPeerAddress(p,a,b,c)				(p)->GetPeerAddress(a,b,c)
#define	IDirectPlay8Peer_GetLocalHostAddresses(p,a,b,c)			(p)->GetLocalHostAddresses(a,b,c)
#define	IDirectPlay8Peer_Close(p,a)								(p)->Close(a)
#define	IDirectPlay8Peer_EnumHosts(p,a,b,c,d,e,f,g,h,i,j,k)	    (p)->EnumHosts(a,b,c,d,e,f,g,h,i,j,k)
#define	IDirectPlay8Peer_DestroyPeer(p,a,b,c,d)					(p)->DestroyPeer(a,b,c,d)
#define	IDirectPlay8Peer_ReturnBuffer(p,a,b)					(p)->ReturnBuffer(a,b)
#define	IDirectPlay8Peer_GetPlayerContext(p,a,b,c)				(p)->GetPlayerContext(a,b,c)
#define	IDirectPlay8Peer_GetGroupContext(p,a,b,c)				(p)->GetGroupContext(a,b,c)
#define	IDirectPlay8Peer_GetCaps(p,a,b)							(p)->GetCaps(a,b)
#define	IDirectPlay8Peer_SetCaps(p,a,b)							(p)->SetCaps(a,b)
#define	IDirectPlay8Peer_SetSPCaps(p,a,b,c)						(p)->SetSPCaps(a,b,c)
#define	IDirectPlay8Peer_GetSPCaps(p,a,b,c)						(p)->GetSPCaps(a,b,c)
#define	IDirectPlay8Peer_GetConnectionInfo(p,a,b,c)				(p)->GetConnectionInfo(a,b,c)
#define	IDirectPlay8Peer_RegisterLobby(p,a,b,c)					(p)->RegisterLobby(a,b,c)
#define	IDirectPlay8Peer_TerminateSession(p,a,b,c)				(p)->TerminateSession(a,b,c)

#endif

/****************************************************************************
 *
 * DIRECTPLAY8 ERRORS
 *
 * Errors are represented by negative values and cannot be combined.
 *
 ****************************************************************************/

#define _DPN_FACILITY_CODE	0x015
#define _DPNHRESULT_BASE		0x8000
#define MAKE_DPNHRESULT( code )			MAKE_HRESULT( 1, _DPN_FACILITY_CODE, ( code + _DPNHRESULT_BASE ) )

#define DPN_OK							S_OK

#define DPNSUCCESS_EQUAL                MAKE_HRESULT( 0, _DPN_FACILITY_CODE, ( 0x5 + _DPNHRESULT_BASE ) )
#define DPNSUCCESS_NOTEQUAL             MAKE_HRESULT( 0, _DPN_FACILITY_CODE, (0x0A + _DPNHRESULT_BASE ) )
#define DPNSUCCESS_PENDING				MAKE_HRESULT( 0, _DPN_FACILITY_CODE, (0x0e + _DPNHRESULT_BASE ) )

#define DPNERR_ABORTED					MAKE_DPNHRESULT(  0x30 )
#define DPNERR_ADDRESSING				MAKE_DPNHRESULT(  0x40 )
#define	DPNERR_ALREADYCLOSING			MAKE_DPNHRESULT(  0x50 )
#define DPNERR_ALREADYCONNECTED			MAKE_DPNHRESULT(  0x60 )
#define DPNERR_ALREADYDISCONNECTING		MAKE_DPNHRESULT(  0x70 )
#define DPNERR_ALREADYINITIALIZED		MAKE_DPNHRESULT(  0x80 )
#define DPNERR_ALREADYREGISTERED		MAKE_DPNHRESULT(  0x90 )
#define DPNERR_BUFFERTOOSMALL			MAKE_DPNHRESULT( 0x100 )
#define DPNERR_CANNOTCANCEL				MAKE_DPNHRESULT( 0x110 )
#define DPNERR_CANTCREATEGROUP			MAKE_DPNHRESULT( 0x120 )
#define DPNERR_CANTCREATEPLAYER			MAKE_DPNHRESULT( 0x130 )
#define DPNERR_CANTLAUNCHAPPLICATION	MAKE_DPNHRESULT( 0x140 )
#define DPNERR_CONNECTING				MAKE_DPNHRESULT( 0x150 )
#define DPNERR_CONNECTIONLOST			MAKE_DPNHRESULT( 0x160 )
#define DPNERR_CONVERSION				MAKE_DPNHRESULT( 0x170 )
#define	DPNERR_DATATOOLARGE				MAKE_DPNHRESULT( 0x175 )
#define DPNERR_DOESNOTEXIST				MAKE_DPNHRESULT( 0x180 )
#define DPNERR_DUPLICATECOMMAND			MAKE_DPNHRESULT( 0x190 )
#define DPNERR_ENDPOINTNOTRECEIVING		MAKE_DPNHRESULT( 0x200 )
#define	DPNERR_ENUMQUERYTOOLARGE		MAKE_DPNHRESULT( 0x210 )
#define	DPNERR_ENUMRESPONSETOOLARGE		MAKE_DPNHRESULT( 0x220 )
#define DPNERR_EXCEPTION				MAKE_DPNHRESULT( 0x230 )
#define DPNERR_GENERIC					E_FAIL
#define DPNERR_GROUPNOTEMPTY			MAKE_DPNHRESULT( 0x240 )
#define DPNERR_HOSTING                  MAKE_DPNHRESULT( 0x250 )
#define DPNERR_HOSTREJECTEDCONNECTION	MAKE_DPNHRESULT( 0x260 )
#define DPNERR_HOSTTERMINATEDSESSION	MAKE_DPNHRESULT( 0x270 )
#define DPNERR_INCOMPLETEADDRESS		MAKE_DPNHRESULT( 0x280 )
#define DPNERR_INVALIDADDRESSFORMAT		MAKE_DPNHRESULT( 0x290 )
#define DPNERR_INVALIDAPPLICATION		MAKE_DPNHRESULT( 0x300 )
#define DPNERR_INVALIDCOMMAND			MAKE_DPNHRESULT( 0x310 )
#define DPNERR_INVALIDDEVICEADDRESS		MAKE_DPNHRESULT( 0x320 )
#define DPNERR_INVALIDENDPOINT			MAKE_DPNHRESULT( 0x330 )
#define DPNERR_INVALIDFLAGS				MAKE_DPNHRESULT( 0x340 )
#define DPNERR_INVALIDGROUP			 	MAKE_DPNHRESULT( 0x350 )
#define DPNERR_INVALIDHANDLE			MAKE_DPNHRESULT( 0x360 )
#define DPNERR_INVALIDHOSTADDRESS		MAKE_DPNHRESULT( 0x370 )
#define DPNERR_INVALIDINSTANCE			MAKE_DPNHRESULT( 0x380 )
#define DPNERR_INVALIDINTERFACE			MAKE_DPNHRESULT( 0x390 )
#define DPNERR_INVALIDOBJECT			MAKE_DPNHRESULT( 0x400 )
#define DPNERR_INVALIDPARAM				E_INVALIDARG
#define DPNERR_INVALIDPASSWORD			MAKE_DPNHRESULT( 0x410 )
#define DPNERR_INVALIDPLAYER			MAKE_DPNHRESULT( 0x420 )
#define DPNERR_INVALIDPOINTER			E_POINTER
#define DPNERR_INVALIDPRIORITY			MAKE_DPNHRESULT( 0x430 )
#define DPNERR_INVALIDSTRING			MAKE_DPNHRESULT( 0x440 )
#define DPNERR_INVALIDURL				MAKE_DPNHRESULT( 0x450 )
#define	DPNERR_INVALIDVERSION			MAKE_DPNHRESULT( 0x460 )
#define DPNERR_NOCAPS					MAKE_DPNHRESULT( 0x470 )
#define DPNERR_NOCONNECTION				MAKE_DPNHRESULT( 0x480 )
#define DPNERR_NOHOSTPLAYER				MAKE_DPNHRESULT( 0x490 )
#define DPNERR_NOINTERFACE				E_NOINTERFACE
#define DPNERR_NOMOREADDRESSCOMPONENTS	MAKE_DPNHRESULT( 0x500 )
#define DPNERR_NORESPONSE				MAKE_DPNHRESULT( 0x510 )
#define DPNERR_NOTALLOWED				MAKE_DPNHRESULT( 0x520 )
#define DPNERR_NOTHOST					MAKE_DPNHRESULT( 0x530 )
#define DPNERR_NOTREADY					MAKE_DPNHRESULT( 0x540 )
#define DPNERR_NOTREGISTERED			MAKE_DPNHRESULT( 0x550 )
#define DPNERR_OUTOFMEMORY				E_OUTOFMEMORY
#define DPNERR_PENDING					DPNSUCCESS_PENDING
#define DPNERR_PLAYERALREADYINGROUP     MAKE_DPNHRESULT( 0x560 )
#define DPNERR_PLAYERLOST				MAKE_DPNHRESULT( 0x570 )
#define DPNERR_PLAYERNOTINGROUP         MAKE_DPNHRESULT( 0x580 )
#define	DPNERR_PLAYERNOTREACHABLE		MAKE_DPNHRESULT( 0x590 )
#define DPNERR_SENDTOOLARGE				MAKE_DPNHRESULT( 0x600 )
#define DPNERR_SESSIONFULL				MAKE_DPNHRESULT( 0x610 )
#define DPNERR_TABLEFULL				MAKE_DPNHRESULT( 0x620 )
#define DPNERR_TIMEDOUT					MAKE_DPNHRESULT( 0x630 )
#define DPNERR_UNINITIALIZED			MAKE_DPNHRESULT( 0x640 )
#define DPNERR_UNSUPPORTED				E_NOTIMPL
#define DPNERR_USERCANCEL				MAKE_DPNHRESULT( 0x650 )

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\inc\dplobby8.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DPLobby.h
 *  Content:    DirectPlay8 Lobby Include File
 *@@BEGIN_MSINTERNAL
 *  History:
 *  Date        By      Reason
 *  ====        ==      ======
 *  02/21/00	mjn		Created
 *	03/22/2000	jtk		Changed interface names
 *  04/25/2000  rmt     Bug #s 33138, 33145, 33150
 *	04/26/00	mjn		Removed dwTimeOut from Send() API call
 *  05/03/00    rmt     Bug #33879 -- Status messsage missing from field
 *  05/04/00    rmt     Bug #34146 - No PDIRECTPLAY8LOBBIEDAPPLICATION defined.
 *  05/08/00    rmt     Bug #34301 - Addd flag to SetAppAvailable to allow user to specify multiple client connects.
 *              rmt     Bug #34492 - Added hrReason field to disconnect message
 *  06/07/00	rmt		Bug #36382 - Splitting CLSID to fix whistler issues (CoCreate changed behaviour)
 *  06/09/00    rmt     Updates to split CLSID and allow whistler compat and support external create funcs 
 *  06/15/2000  rmt     Bug #33617 - Must provide method for providing automatic launch of DirectPlay instances
 *  07/08/2000	rmt		Bug #38725 - Need to provide method to detect if app was lobby launched
 *				rmt		Bug #38757 - Callback messages for connections may return AFTER WaitForConnection returns
 *				rmt		Bug #38755 - No way to specify player name in Connection Settings
 *				rmt		Bug #38758 - DPLOBBY8.H has incorrect comments
 *				rmt		Bug #38783 - pvUserApplicationContext is only partially implemented
 *				rmt		Added DPLHANDLE_ALLCONNECTIONS and dwFlags (reserved field to couple of funcs).
 *  03/17/2001	rmt		WINBUG #342420 - Commented out create functions 
 *  
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__DPLOBBY_H__
#define	__DPLOBBY_H__

#include <ole2.h>

#ifdef __cplusplus
extern "C" {
#endif

/****************************************************************************
 *
 * DirectPlay8Lobby CLSIDs
 *
 ****************************************************************************/

// {667955AD-6B3B-43ca-B949-BC69B5BAFF7F}
DEFINE_GUID(CLSID_DirectPlay8LobbiedApplication, 
0x667955ad, 0x6b3b, 0x43ca, 0xb9, 0x49, 0xbc, 0x69, 0xb5, 0xba, 0xff, 0x7f);

// {3B2B6775-70B6-45af-8DEA-A209C69559F3}
DEFINE_GUID(CLSID_DirectPlay8LobbyClient, 
0x3b2b6775, 0x70b6, 0x45af, 0x8d, 0xea, 0xa2, 0x9, 0xc6, 0x95, 0x59, 0xf3);

/****************************************************************************
 *
 * DirectPlay8Lobby Interface IIDs
 *
 ****************************************************************************/

// {819074A3-016C-11d3-AE14-006097B01411}
DEFINE_GUID(IID_IDirectPlay8LobbiedApplication,
0x819074a3, 0x16c, 0x11d3, 0xae, 0x14, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);

// {819074A2-016C-11d3-AE14-006097B01411}
DEFINE_GUID(IID_IDirectPlay8LobbyClient,
0x819074a2, 0x16c, 0x11d3, 0xae, 0x14, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);

/****************************************************************************
 *
 * DirectPlay8Lobby Interface Pointer 
 *
 ****************************************************************************/

typedef struct IDirectPlay8LobbiedApplication	*PDIRECTPLAY8LOBBIEDAPPLICATION;
typedef struct IDirectPlay8LobbyClient		    *PDIRECTPLAY8LOBBYCLIENT;

/****************************************************************************
 *
 * DirectPlay8 Lobby Message IDs
 *
 ****************************************************************************/

#define	DPL_MSGID_LOBBY						0x8000
#define	DPL_MSGID_RECEIVE					(0x0001 | DPL_MSGID_LOBBY)
#define	DPL_MSGID_CONNECT					(0x0002 | DPL_MSGID_LOBBY)
#define DPL_MSGID_DISCONNECT				(0x0003 | DPL_MSGID_LOBBY)
#define	DPL_MSGID_SESSION_STATUS			(0x0004 | DPL_MSGID_LOBBY)
#define DPL_MSGID_CONNECTION_SETTINGS       (0x0005 | DPL_MSGID_LOBBY)

/****************************************************************************
 *
 * DirectPlay8Lobby Constants
 *
 ****************************************************************************/

//
// Specifies that operation should be performed on all open connections
//
#define DPLHANDLE_ALLCONNECTIONS			0xFFFFFFFF

// 
// The associated game session has suceeded in connecting / hosting
//
#define	DPLSESSION_CONNECTED				0x0001

// The associated game session failed connecting / hosting
//
#define	DPLSESSION_COULDNOTCONNECT			0x0002

//
// The associated game session has disconnected
//
#define	DPLSESSION_DISCONNECTED				0x0003

//
// The associated game session has terminated 
//
#define	DPLSESSION_TERMINATED				0x0004

// 
// The associated game session's host has migrated 
//
#define DPLSESSION_HOSTMIGRATED				0x0005

//
// The associated game session's host has migrated to the local client
//
#define DPLSESSION_HOSTMIGRATEDHERE			0x0006


/****************************************************************************
 *
 * DirectPlay8 Lobby Flags
 *
 ****************************************************************************/

//
// Do not automatically make the lobby app unavailable when a connection is established
//
#define DPLAVAILABLE_ALLOWMULTIPLECONNECT   0x0001

//
// Launch a new instance of the application to connect to
// 
#define	DPLCONNECT_LAUNCHNEW				0x0001

// 
// Launch a new instance of the application if one is not waiting
//
#define	DPLCONNECT_LAUNCHNOTFOUND			0x0002

//
// When starting the associated game session, start it as a host
//
#define DPLCONNECTSETTINGS_HOST             0x0001

// 
// Disable parameter validation
//
#define DPLINITIALIZE_DISABLEPARAMVAL		0x0001

/****************************************************************************
 *
 * DirectPlay8Lobby Structures (Non-Message)
 *
 ****************************************************************************/

// 
// Information on a registered game
//
typedef struct _DPL_APPLICATION_INFO {
	GUID	guidApplication;            // GUID of the application
	PWSTR	pwszApplicationName;        // Name of the application
	DWORD	dwNumRunning;               // # of instances of this application running
	DWORD	dwNumWaiting;               // # of instances of this application waiting 
	DWORD	dwFlags;                    // Flags
} DPL_APPLICATION_INFO,  *PDPL_APPLICATION_INFO;

//
// Settings to be used for connecting / hosting a game session
//
typedef struct _DPL_CONNECTION_SETTINGS {
    DWORD                   dwSize;                 // Size of this structure
    DWORD                   dwFlags;                // Connection settings flags (DPLCONNECTSETTINGS_...)
    DPN_APPLICATION_DESC    dpnAppDesc;             // Application desc for the associated DirectPlay session
    IDirectPlay8Address     *pdp8HostAddress;       // Address of host to connect to
    IDirectPlay8Address     **ppdp8DeviceAddresses; // Address of device to connect from / host on
    DWORD                   cNumDeviceAddresses;    // # of addresses specified in ppdp8DeviceAddresses
	PWSTR					pwszPlayerName;         // Name to give the player
} DPL_CONNECTION_SETTINGS, *PDPL_CONNECTION_SETTINGS;

//
// Information for performing a lobby connect
// (ConnectApplication)
//
typedef struct _DPL_CONNECT_INFO {
	DWORD	                    dwSize;             // Size of this structure
	DWORD	                    dwFlags;            // Flags (DPLCONNECT_...)
	GUID	                    guidApplication;    // GUID of application to launch
    PDPL_CONNECTION_SETTINGS	pdplConnectionSettings;
                                                    // Settings application should use
	PVOID	                    pvLobbyConnectData; // User defined data block
	DWORD	                    dwLobbyConnectDataSize;
                                                    // Size of user defined data block
} DPL_CONNECT_INFO,  *PDPL_CONNECT_INFO;

//
// Information for registering an application
// (RegisterApplication)
//
typedef struct  _DPL_PROGRAM_DESC {
	DWORD	dwSize;
	DWORD	dwFlags;
	GUID	guidApplication;		                // Application GUID
	PWSTR	pwszApplicationName;	                // Unicode application name
	PWSTR	pwszCommandLine;		                // Unicode command line arguments
	PWSTR	pwszCurrentDirectory;               	// Unicode current directory
	PWSTR	pwszDescription;		                // Unicode application description
	PWSTR	pwszExecutableFilename;	                // Unicode filename of application executable
	PWSTR	pwszExecutablePath;		                // Unicode path of application executable
	PWSTR	pwszLauncherFilename;	                // Unicode filename of launcher executable
	PWSTR	pwszLauncherPath;		                // Unicode path of launcher executable
} DPL_PROGRAM_DESC, *PDPL_PROGRAM_DESC;

/****************************************************************************
 *
 * DirectPlay8 Lobby Message Structures
 *
 ****************************************************************************/

//
// A connection was established 
// (DPL_MSGID_CONNECT)
//
typedef struct _DPL_MESSAGE_CONNECT
{
	DWORD		                dwSize;                     // Size of this structure
	DPNHANDLE	                hConnectId;                 // Handle of new connection
    PDPL_CONNECTION_SETTINGS	pdplConnectionSettings;	    // Connection settings for this connection
	PVOID		                pvLobbyConnectData;         // User defined lobby data block
	DWORD		                dwLobbyConnectDataSize;     // Size of user defined lobby data block
	PVOID						pvConnectionContext;        // Context value for this connection (user set)
} DPL_MESSAGE_CONNECT, *PDPL_MESSAGE_CONNECT;

// 
// Connection settings have been updated
// (DPL_MSGID_CONNECTION_SETTINGS)
//
typedef struct _DPL_MESSAGE_CONNECTION_SETTINGS
{
    DWORD                       dwSize;                     // Size of this structure
    DPNHANDLE                   hSender;                    // Handle of the connection for these settings
    PDPL_CONNECTION_SETTINGS    pdplConnectionSettings;     // Connection settings
	PVOID					    pvConnectionContext;        // Context value for this connection
} DPL_MESSAGE_CONNECTION_SETTINGS, *PDPL_MESSAGE_CONNECTION_SETTINGS;

//
// A connection has been disconnected
// (DPL_MSGID_DISCONNECT)
//
typedef struct _DPL_MESSAGE_DISCONNECT
{
	DWORD		dwSize;                                     // Size of this structure
	DPNHANDLE	hDisconnectId;                              // Handle of the connection that was terminated
	HRESULT     hrReason;                                   // Reason the connection was broken
	PVOID		pvConnectionContext;                        // Context value for this connection
} DPL_MESSAGE_DISCONNECT, *PDPL_MESSAGE_DISCONNECT;

//
// Data was received through a connection
// (DPL_MSGID_RECEIVE)
//
typedef struct _DPL_MESSAGE_RECEIVE
{
	DWORD		dwSize;                                     // Size of this structure
	DPNHANDLE	hSender;                                    // Handle of the connection that is from
	BYTE		*pBuffer;                                   // Contents of the message
	DWORD		dwBufferSize;                               // Size of the message context 
	PVOID		pvConnectionContext;                        // Context value for this connection
} DPL_MESSAGE_RECEIVE, *PDPL_MESSAGE_RECEIVE;

//
// Current status of the associated connection
// (DPL_MSGID_SESSION_STATUS)
//
typedef struct _DPL_MESSAGE_SESSION_STATUS
{
	DWORD		dwSize;                                     // Size of this structure
	DPNHANDLE	hSender;                                    // Handle of the connection that this is from
	DWORD		dwStatus;                                   // Status (DPLSESSION_...)
	PVOID		pvConnectionContext;                        // Context value for this connection
} DPL_MESSAGE_SESSION_STATUS, *PDPL_MESSAGE_SESSION_STATUS;

/****************************************************************************
 *
 * DirectPlay8Lobby Create
 *
 ****************************************************************************/
 
/*
 * This function is no longer supported.  It is recommended that CoCreateInstance be used to create 
 * DirectPlay8 lobby objects. 
 *
 * extern HRESULT WINAPI DirectPlay8LobbyCreate( const GUID * pcIID, void **ppvInterface, IUnknown *pUnknown);
 *
 */

/****************************************************************************
 *
 * DirectPlay8 Functions
 *
 ****************************************************************************/

//
// COM definition for DirectPlayLobbyClient
//
#undef INTERFACE				// External COM Implementation
#define INTERFACE IDirectPlay8LobbyClient
DECLARE_INTERFACE_(IDirectPlay8LobbyClient,IUnknown)
{
    // IUnknown methods
	STDMETHOD(QueryInterface)			(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)			(THIS) PURE;
	STDMETHOD_(ULONG,Release)			(THIS) PURE;
    // IDirectPlayLobbyClient methods
	STDMETHOD(Initialize)	            (THIS_ const PVOID pvUserContext,const PFNDPNMESSAGEHANDLER pfn,const DWORD dwFlags) PURE;
	STDMETHOD(EnumLocalPrograms)		(THIS_ GUID *const pGuidApplication,BYTE *const pEnumData,DWORD *const pdwEnumData,DWORD *const pdwItems, const DWORD dwFlags) PURE;
	STDMETHOD(ConnectApplication)		(THIS_ DPL_CONNECT_INFO *const pdplConnectionInfo,const PVOID pvConnectionContext,DPNHANDLE *const hApplication,const DWORD dwTimeOut,const DWORD dwFlags) PURE;
	STDMETHOD(Send)						(THIS_ const DPNHANDLE hConnection,BYTE *const pBuffer,const DWORD pBufferSize,const DWORD dwFlags) PURE;
	STDMETHOD(ReleaseApplication)		(THIS_ const DPNHANDLE hConnection, const DWORD dwFlags ) PURE;
	STDMETHOD(Close)    				(THIS_ const DWORD dwFlags ) PURE;
	STDMETHOD(GetConnectionSettings)    (THIS_ const DPNHANDLE hConnection, DPL_CONNECTION_SETTINGS * const pdplSessionInfo, DWORD *pdwInfoSize, const DWORD dwFlags ) PURE;	
	STDMETHOD(SetConnectionSettings)    (THIS_ const DPNHANDLE hConnection, const DPL_CONNECTION_SETTINGS * const pdplSessionInfo, const DWORD dwFlags ) PURE;
};


//
// COM definition for DirectPlayLobbiedApplication
//
#undef INTERFACE				// External COM Implementation
#define INTERFACE IDirectPlay8LobbiedApplication
DECLARE_INTERFACE_(IDirectPlay8LobbiedApplication,IUnknown)
{
    // IUnknown methods
	STDMETHOD(QueryInterface)			(THIS_ REFIID riid,LPVOID *ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)			(THIS) PURE;
	STDMETHOD_(ULONG,Release)			(THIS) PURE;
    // IDirectPlayLobbiedApplication methods
	STDMETHOD(Initialize)	            (THIS_ const PVOID pvUserContext,const PFNDPNMESSAGEHANDLER pfn,DPNHANDLE * const pdpnhConnection, const DWORD dwFlags) PURE;
	STDMETHOD(RegisterProgram)			(THIS_ PDPL_PROGRAM_DESC pdplProgramDesc,const DWORD dwFlags) PURE;
	STDMETHOD(UnRegisterProgram)		(THIS_ GUID *pguidApplication,const DWORD dwFlags) PURE;
	STDMETHOD(Send)						(THIS_ const DPNHANDLE hConnection,BYTE *const pBuffer,const DWORD pBufferSize,const DWORD dwFlags) PURE;
	STDMETHOD(SetAppAvailable)			(THIS_ const BOOL fAvailable, const DWORD dwFlags ) PURE;
	STDMETHOD(UpdateStatus)				(THIS_ const DPNHANDLE hConnection, const DWORD dwStatus, const DWORD dwFlags ) PURE;
	STDMETHOD(Close)				    (THIS_ const DWORD dwFlags ) PURE;
	STDMETHOD(GetConnectionSettings)    (THIS_ const DPNHANDLE hConnection, DPL_CONNECTION_SETTINGS * const pdplSessionInfo, DWORD *pdwInfoSize, const DWORD dwFlags ) PURE;
	STDMETHOD(SetConnectionSettings)    (THIS_ const DPNHANDLE hConnection, const DPL_CONNECTION_SETTINGS * const pdplSessionInfo, const DWORD dwFlags ) PURE;
};


/****************************************************************************
 *
 * DirectPlayLobby Interface Macros
 *
 ****************************************************************************/

#if !defined(__cplusplus) || defined(CINTERFACE)

#define IDirectPlay8LobbyClient_QueryInterface(p,a,b)    		        (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlay8LobbyClient_AddRef(p)                		        (p)->lpVtbl->AddRef(p)
#define IDirectPlay8LobbyClient_Release(p)						        (p)->lpVtbl->Release(p)
#define IDirectPlay8LobbyClient_Initialize(p,a,b,c)	                    (p)->lpVtbl->Initialize(p,a,b,c)
#define IDirectPlay8LobbyClient_EnumLocalPrograms(p,a,b,c,d,e)	        (p)->lpVtbl->EnumLocalPrograms(p,a,b,c,d,e)
#define IDirectPlay8LobbyClient_ConnectApplication(p,a,b,c,d,e)	        (p)->lpVtbl->ConnectApplication(p,a,b,c,d,e)
#define IDirectPlay8LobbyClient_Send(p,a,b,c,d)					        (p)->lpVtbl->Send(p,a,b,c,d)
#define IDirectPlay8LobbyClient_ReleaseApplication(p,a,b)		        (p)->lpVtbl->ReleaseApplication(p,a,b)
#define IDirectPlay8LobbyClient_Close(p,a)						        (p)->lpVtbl->Close(p,a)
#define IDirectPlay8LobbyClient_GetConnectionSettings(p,a,b,c,d)        (p)->lpVtbl->GetConnectionSettings(p,a,b,c,d)
#define IDirectPlay8LobbyClient_SetConnectionSettings(p,a,b,c)          (p)->lpVtbl->SetConnectionSettings(p,a,b,c)

#define IDirectPlay8LobbiedApplication_QueryInterface(p,a,b)			(p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlay8LobbiedApplication_AddRef(p)						(p)->lpVtbl->AddRef(p)
#define IDirectPlay8LobbiedApplication_Release(p)						(p)->lpVtbl->Release(p)
#define IDirectPlay8LobbiedApplication_Initialize(p,a,b,c,d)            (p)->lpVtbl->Initialize(p,a,b,c,d)
#define IDirectPlay8LobbiedApplication_RegisterProgram(p,a,b)			(p)->lpVtbl->RegisterProgram(p,a,b)
#define IDirectPlay8LobbiedApplication_UnRegisterProgram(p,a,b)			(p)->lpVtbl->UnRegisterProgram(p,a,b)
#define IDirectPlay8LobbiedApplication_Send(p,a,b,c,d)					(p)->lpVtbl->Send(p,a,b,c,d)
#define IDirectPlay8LobbiedApplication_SetAppAvailable(p,a,b)			(p)->lpVtbl->SetAppAvailable(p,a,b)
#define IDirectPlay8LobbiedApplication_UpdateStatus(p,a,b,c)			(p)->lpVtbl->UpdateStatus(p,a,b,c)
#define IDirectPlay8LobbiedApplication_Close(p,a)						(p)->lpVtbl->Close(p,a)
#define IDirectPlay8LobbiedApplication_GetConnectionSettings(p,a,b,c,d) (p)->lpVtbl->GetConnectionSettings(p,a,b,c,d)
#define IDirectPlay8LobbiedApplication_SetConnectionSettings(p,a,b,c)   (p)->lpVtbl->SetConnectionSettings(p,a,b,c)

#else	/* C++ */

#define IDirectPlay8LobbyClient_QueryInterface(p,a,b)    		        (p)->QueryInterface(a,b)
#define IDirectPlay8LobbyClient_AddRef(p)                		        (p)->AddRef()
#define IDirectPlay8LobbyClient_Release(p)						        (p)->Release()
#define IDirectPlay8LobbyClient_Initialize(p,a,b,c)	                    (p)->Initialize(a,b,c)
#define IDirectPlay8LobbyClient_EnumLocalPrograms(p,a,b,c,d,e)	        (p)->EnumLocalPrograms(a,b,c,d,e)
#define IDirectPlay8LobbyClient_ConnectApplication(p,a,b,c,d,e)	        (p)->ConnectApplication(a,b,c,d,e)
#define IDirectPlay8LobbyClient_Send(p,a,b,c,d)					        (p)->Send(a,b,c,d)
#define IDirectPlay8LobbyClient_ReleaseApplication(p,a,b)		        (p)->ReleaseApplication(a,b)
#define IDirectPlay8LobbyClient_Close(p,a)						        (p)->Close(a)
#define IDirectPlay8LobbyClient_GetConnectionSettings(p,a,b,c,d)        (p)->GetConnectionSettings(a,b,c,d)
#define IDirectPlay8LobbyClient_SetConnectionSettings(p,a,b,c)          (p)->SetConnectionSettings(a,b,c)

#define IDirectPlay8LobbiedApplication_QueryInterface(p,a,b)			(p)->QueryInterface(a,b)
#define IDirectPlay8LobbiedApplication_AddRef(p)						(p)->AddRef()
#define IDirectPlay8LobbiedApplication_Release(p)						(p)->Release()
#define IDirectPlay8LobbiedApplication_Initialize(p,a,b,c,d)            (p)->Initialize(a,b,c,d)
#define IDirectPlay8LobbiedApplication_RegisterProgram(p,a,b)			(p)->RegisterProgram(a,b)
#define IDirectPlay8LobbiedApplication_UnRegisterProgram(p,a,b)			(p)->UnRegisterProgram(a,b)
#define IDirectPlay8LobbiedApplication_Send(p,a,b,c,d)					(p)->Send(a,b,c,d)
#define IDirectPlay8LobbiedApplication_SetAppAvailable(p,a,b)			(p)->SetAppAvailable(a,b)
#define IDirectPlay8LobbiedApplication_UpdateStatus(p,a,b,c)			(p)->UpdateStatus(a,b,c)
#define IDirectPlay8LobbiedApplication_Close(p,a)						(p)->Close(a)
#define IDirectPlay8LobbiedApplication_GetConnectionSettings(p,a,b,c,d) (p)->GetConnectionSettings(a,b,c,d)
#define IDirectPlay8LobbiedApplication_SetConnectionSettings(p,a,b,c)   (p)->SetConnectionSettings(a,b,c)

#endif

#ifdef __cplusplus
}
#endif

#endif	// __DPLOBBY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\lobby\comstuff.h ===
// comstuff.h
//
//	Interface and object definitions

#ifndef COMSTUFF_H
#define COMSTUFF_H

typedef struct _INTERFACE_LIST {
	LPVOID					lpVtbl;
	LONG					lRefCount;
	IID						iid;
	struct _INTERFACE_LIST	*lpIntNext;
	struct _OBJECT_DATA		*lpObject;
} INTERFACE_LIST, *LPINTERFACE_LIST;

typedef struct _OBJECT_DATA {
	LONG				lRefCount;
	LPVOID				lpvData;
	LPINTERFACE_LIST	lpIntList;
} OBJECT_DATA, *LPOBJECT_DATA;

#define GET_OBJECT_FROM_INTERFACE(a)	((LPINTERFACE_LIST) a)->lpObject->lpvData

#if !defined(__cplusplus) && !defined(CINTERFACE)

#ifdef THIS_
#undef THIS_
#define THIS_   LPVOID this,
#endif

#ifdef THIS
#undef THIS
#define THIS    LPVOID this
#endif

#endif


#endif // COMSTUFF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\lobby\dnlobbyi.h ===
/***************************************************************************
 *
 *  Copyright (C) 1997-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DNLOBBYI.h
 *  Content:    DirectPlay Lobby master internal header file.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/28/01    masonb  Created.
 *  04/12/01	VanceO	Moved granting registry permissions into common.
 *
 ***************************************************************************/

#ifndef __DNLOBBYI_H__
#define __DNLOBBYI_H__

// 
// Public includes
//
#include <windows.h>
#include <mmsystem.h>
#include <tlhelp32.h>
#include <stdio.h>

// 
// DirectPlay public includes
//
#include "dplay8.h"
#include "dplobby8.h"
#include "dpaddr.h"

// 
// DirectPlay private includes
//
#include "osind.h"
#include "dneterrors.h"
#include "dndbg.h"
#include "comutil.h"
#include "packbuff.h"
#include "strutils.h"
#include "creg.h"

// 
// DirectPlay Core includes
//
#include "..\..\dnet\core\message.h"

// 
// Lobby private includes
//
#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_LOBBY

#include "classfac.h"
#include "comstuff.h"
#include "handles.h"
#include "verinfo.h"	//	For TIME BOMB

#include "DPLApp.h"
#include "DPLClient.h"
#include "DPLCommon.h"
#include "DPLConnect.h"
#include "DPLConset.h"
#include "DPLMsgQ.h"
#include "DPLobby8Int.h"
#include "DPLParam.h"
#include "DPLProc.h"
#include "DPLProt.h"
#include "DPLReg.h"


#endif // __DNLOBBYI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\lobby\dplapp.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DPLApp.cpp
 *  Content:    DirectPlay Lobbied Application Functions
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  02/21/00	mjn		Created
 *  03/22/2000	jtk		Changed interface names
 *  04/18/2000	rmt     Added additional parameter validation
 *  04/25/2000	rmt     Bug #s 33138, 33145, 33150 
 *	04/26/00	mjn		Removed dwTimeOut from Send() API call
 *  05/03/00    rmt     DPL_UnRegister was not implemented!!
 *  05/08/00    rmt     Bug #34301 - Add flag to SetAppAvail to allow for multiple connects
 *   06/15/00   rmt     Bug #33617 - Must provide method for providing automatic launch of DirectPlay instances  
 *  07/08/2000	rmt		Bug #38725 - Need to provide method to detect if app was lobby launched
 *				rmt		Bug #38757 - Callback messages for connections may return AFTER WaitForConnection returns
 *				rmt		Bug #38755 - No way to specify player name in Connection Settings
 *				rmt		Bug #38758 - DPLOBBY8.H has incorrect comments
 *				rmt		Bug #38783 - pvUserApplicationContext is only partially implemented
 *				rmt		Added DPLHANDLE_ALLCONNECTIONS and dwFlags (reserved field to couple of funcs).
 *  07/14/2000	rmt		Bug #39257 - LobbyClient::ReleaseApp returns E_OUTOFMEMORY when called when no one connected
 *				rmt		Bug #39487 - Remove WaitForConnect
 *  08/05/2000  RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *  08/15/2000	rmt		Bug #42273 - DPLAY8: Samples sometimes get a DPNERR_ALREADYREGISTERED error.  (Double connections)
 *  08/18/2000	rmt		Bug #42751 - DPLOBBY8: Prohibit more than one lobby client or lobby app per process
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dnlobbyi.h"


//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************



typedef STDMETHODIMP AppQueryInterface(IDirectPlay8LobbiedApplication *pInterface,REFIID ridd,PVOID *ppvObj);
typedef STDMETHODIMP_(ULONG)	AppAddRef(IDirectPlay8LobbiedApplication *pInterface);
typedef STDMETHODIMP_(ULONG)	AppRelease(IDirectPlay8LobbiedApplication *pInterface);
typedef STDMETHODIMP AppRegisterMessageHandler(IDirectPlay8LobbiedApplication *pInterface,const PVOID pvUserContext,const PFNDPNMESSAGEHANDLER pfn,	DPNHANDLE * const pdpnhConnection, const DWORD dwFlags);
typedef	STDMETHODIMP AppSend(IDirectPlay8LobbiedApplication *pInterface,const DPNHANDLE hTarget,BYTE *const pBuffer,const DWORD pBufferSize,const DWORD dwFlags);
typedef STDMETHODIMP AppClose(IDirectPlay8LobbiedApplication *pInterface, const DWORD dwFlags);
typedef STDMETHODIMP AppGetConnectionSettings(IDirectPlay8LobbiedApplication *pInterface, const DPNHANDLE hLobbyClient, DPL_CONNECTION_SETTINGS * const pdplSessionInfo, DWORD *pdwInfoSize, const DWORD dwFlags );	
typedef STDMETHODIMP AppSetConnectionSettings(IDirectPlay8LobbiedApplication *pInterface, const DPNHANDLE hTarget, const DPL_CONNECTION_SETTINGS * const pdplSessionInfo, const DWORD dwFlags );

IDirectPlay8LobbiedApplicationVtbl DPL_8LobbiedApplicationVtbl =
{
	(AppQueryInterface*)			DPL_QueryInterface,
	(AppAddRef*)					DPL_AddRef,
	(AppRelease*)					DPL_Release,
	(AppRegisterMessageHandler*)	DPL_RegisterMessageHandler,
									DPL_RegisterProgram,
									DPL_UnRegisterProgram,
	(AppSend*)						DPL_Send,
									DPL_SetAppAvailable,
									DPL_UpdateStatus,
	(AppClose*)						DPL_Close,
	(AppGetConnectionSettings*)     DPL_GetConnectionSettings,
	(AppSetConnectionSettings*)     DPL_SetConnectionSettings	
};


//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************

#undef DPF_MODNAME
#define DPF_MODNAME "DPL_RegisterProgram"

STDMETHODIMP DPL_RegisterProgram(IDirectPlay8LobbiedApplication *pInterface,
								 DPL_PROGRAM_DESC *const pdplProgramDesc,
								 const DWORD dwFlags)
{
	HRESULT		hResultCode;

	DIRECTPLAYLOBBYOBJECT	*pdpLobbyObject;	

	DPFX(DPFPREP, 3,"Parameters: pInterface [0x%p], pdplProgramDesc [0x%p], dwFlags [0x%lx]",
			pInterface,pdplProgramDesc,dwFlags);

	TRY
	{
    	pdpLobbyObject = static_cast<DIRECTPLAYLOBBYOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
	    
    	if( pdpLobbyObject->dwFlags & DPL_OBJECT_FLAG_PARAMVALIDATION )
    	{
        	if( FAILED( hResultCode = DPL_ValidateRegisterProgram( pInterface , pdplProgramDesc, dwFlags ) ) )
        	{
        	    DPFX(DPFPREP,  0, "Error validating register params hr=[0x%lx]", hResultCode );
        	    DPF_RETURN( hResultCode );
        	}
    	}
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}	

	hResultCode = DPLWriteProgramDesc(pdplProgramDesc);

	DPF_RETURN(hResultCode);
}



#undef DPF_MODNAME
#define DPF_MODNAME "DPL_UnRegisterProgram"

STDMETHODIMP DPL_UnRegisterProgram(IDirectPlay8LobbiedApplication *pInterface,
								   GUID *const pGuidApplication,
								   const DWORD dwFlags)
{
	HRESULT		hResultCode;

	DIRECTPLAYLOBBYOBJECT	*pdpLobbyObject;		

	DPFX(DPFPREP, 3,"Parameters: pInterface [0x%p], pGuidApplication [0x%p], dwFlags [0x%lx]",
			pInterface,pGuidApplication,dwFlags);

	TRY
	{
    	pdpLobbyObject = static_cast<DIRECTPLAYLOBBYOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
	    
    	if( pdpLobbyObject->dwFlags & DPL_OBJECT_FLAG_PARAMVALIDATION )
    	{
        	if( FAILED( hResultCode = DPL_ValidateUnRegisterProgram( pInterface , pGuidApplication, dwFlags ) ) )
        	{
        	    DPFX(DPFPREP,  0, "Error validating unregister params hr=[0x%lx]", hResultCode );
        	    DPF_RETURN( hResultCode );
        	}
    	}
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}		

	hResultCode = DPLDeleteProgramDesc( pGuidApplication );

	DPF_RETURN(hResultCode);
}



#undef DPF_MODNAME
#define DPF_MODNAME "DPL_SetAppAvailable"
STDMETHODIMP DPL_SetAppAvailable(IDirectPlay8LobbiedApplication *pInterface, const BOOL fAvailable, const DWORD dwFlags )
{
	DIRECTPLAYLOBBYOBJECT	*pdpLobbyObject;
	HRESULT					hResultCode;

	DPFX(DPFPREP, 3,"Parameters: (none)");

	TRY
	{
    	pdpLobbyObject = static_cast<DIRECTPLAYLOBBYOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
	    
    	if( pdpLobbyObject->dwFlags & DPL_OBJECT_FLAG_PARAMVALIDATION )
    	{
        	if( FAILED( hResultCode = DPL_ValidateSetAppAvailable( pInterface, fAvailable, dwFlags ) ) )
        	{
        	    DPFX(DPFPREP,  0, "Error validating makeappavail params hr=[0x%lx]", hResultCode );
        	    DPF_RETURN( hResultCode );
        	}
    	}

    	// Ensure we've been initialized
    	if (pdpLobbyObject->pReceiveQueue == NULL)
    	{
    		DPFERR("Not initialized");
    		DPF_RETURN(DPNERR_UNINITIALIZED);
    	}    	
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}	

    if( fAvailable )
    {
    	// Indicate that we are waiting
    	pdpLobbyObject->pReceiveQueue->MakeAvailable();

    	if( dwFlags & DPLAVAILABLE_ALLOWMULTIPLECONNECT )
    	{
    	    pdpLobbyObject->dwFlags |= DPL_OBJECT_FLAG_MULTICONNECT;
    	}
    	else
    	{
    	    pdpLobbyObject->dwFlags &= ~(DPL_OBJECT_FLAG_MULTICONNECT);
    	}
    }
    else
    {
        pdpLobbyObject->pReceiveQueue->MakeUnavailable();
    }

	hResultCode = DPN_OK;

	DPF_RETURN(hResultCode);
}



//	DPL_UpdateStatus
//
//	Send session status information to the lobby client.  This should be called whenever
//	the lobbied application connects to the game, fails to connect, disconnects, or is
//	terminated (booted).

#undef DPF_MODNAME
#define DPF_MODNAME "DPL_UpdateStatus"

STDMETHODIMP DPL_UpdateStatus(IDirectPlay8LobbiedApplication *pInterface,
							  const DPNHANDLE hLobbyClient,
							  const DWORD dwStatus, const DWORD dwFlags )
{
	HRESULT								hResultCode;
	DIRECTPLAYLOBBYOBJECT				*pdpLobbyObject;
	DPL_CONNECTION						*pdplConnection;
	DPL_INTERNAL_MESSAGE_UPDATE_STATUS	Msg;
	DPNHANDLE							*hTargets = NULL;
	DWORD								dwNumTargets = 0;
	DWORD								dwTargetIndex = 0;


	DPFX(DPFPREP, 3,"Parameters: pInterface [0x%p], hLobbyClient [0x%lx], dwStatus [0x%lx]",
			pInterface,hLobbyClient,dwStatus);

	TRY
	{
    	pdpLobbyObject = static_cast<DIRECTPLAYLOBBYOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
	    
    	if( pdpLobbyObject->dwFlags & DPL_OBJECT_FLAG_PARAMVALIDATION )
    	{
        	if( FAILED( hResultCode = DPL_ValidateUpdateStatus( pInterface, hLobbyClient, dwStatus, dwFlags ) ) )
        	{
        	    DPFX(DPFPREP,  0, "Error validating updatestatus params hr=[0x%lx]", hResultCode );
        	    DPF_RETURN( hResultCode );
        	}
    	}

    	// Ensure we've been initialized
    	if (pdpLobbyObject->pReceiveQueue == NULL)
    	{
    		DPFERR("Not initialized");
    		DPF_RETURN(DPNERR_UNINITIALIZED);
    	}    	
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}	

	Msg.dwMsgId = DPL_MSGID_INTERNAL_UPDATE_STATUS;
	Msg.dwStatus = dwStatus;

	if( hLobbyClient == DPLHANDLE_ALLCONNECTIONS )
	{
		dwNumTargets = 0;

		// We need loop so if someone adds a connection during our run
		// it gets added to our list
		//
		while( 1 )
		{
			hResultCode = DPLConnectionEnum( pdpLobbyObject, hTargets, &dwNumTargets );

			if( hResultCode == DPNERR_BUFFERTOOSMALL )
			{
				if( hTargets )
				{
					delete [] hTargets;
				}

				hTargets = new DPNHANDLE[dwNumTargets];

				if( hTargets == NULL )
				{
					DPFERR("Error allocating memory" );
					hResultCode = DPNERR_OUTOFMEMORY;
					dwNumTargets = 0;
					goto EXIT_AND_CLEANUP;
				}

				memset( hTargets, 0x00, sizeof(DPNHANDLE)*dwNumTargets);

				continue;
			}
			else if( FAILED( hResultCode ) )
			{
				DPFX(DPFPREP,  0, "Error getting list of connections hr=0x%x", hResultCode );
				break;
			}
			else
			{
				break;
			}
		}

		// Failed getting connection information
		if( FAILED( hResultCode ) )
		{
			if( hTargets )
			{
				delete [] hTargets;
				hTargets = NULL;
			}
			dwNumTargets = 0;
			goto EXIT_AND_CLEANUP;
		}

	}
	else
	{
		hTargets = new DPNHANDLE[1]; // We use array delete below so we need array new

		if( hTargets == NULL )
		{
			DPFERR("Error allocating memory" );
			hResultCode = DPNERR_OUTOFMEMORY;
			dwNumTargets = 0;
			goto EXIT_AND_CLEANUP;
		}

		dwNumTargets = 1;
		hTargets[0] = hLobbyClient;
	}
		
	for( dwTargetIndex = 0; dwTargetIndex < dwNumTargets; dwTargetIndex++ )
	{
		if ((hResultCode = DPLConnectionFind(pdpLobbyObject,hTargets[dwTargetIndex],&pdplConnection,TRUE)) != DPN_OK)
		{
			DPFERR("Invalid send target");
			DisplayDNError(0,hResultCode);
			hResultCode = DPNERR_INVALIDHANDLE;
			goto EXIT_AND_CLEANUP;
		}

		DNASSERT(pdplConnection->pSendQueue != NULL);

		if (!pdplConnection->pSendQueue->IsReceiving())
		{
			DPFERR("Other side is not listening");
			hResultCode = DPNERR_INVALIDHANDLE;
			goto EXIT_AND_CLEANUP;
		}

		hResultCode = pdplConnection->pSendQueue->Send(reinterpret_cast<BYTE*>(&Msg),
												   sizeof(DPL_INTERNAL_MESSAGE_UPDATE_STATUS),
												   INFINITE,
												   DPL_MSGQ_MSGFLAGS_USER1,
												   0);

		if( FAILED( hResultCode ) )
		{
			DPFX(DPFPREP,  0, "Error sending to connection 0x%x hr=0x%x", hTargets[dwTargetIndex], hResultCode );
		}
	}

EXIT_AND_CLEANUP:

	for( dwTargetIndex = 0; dwTargetIndex < dwNumTargets; dwTargetIndex++ )
	{
		if( hTargets[dwTargetIndex] )
			DPLConnectionRelease(pdpLobbyObject,hTargets[dwTargetIndex]);
	}

	if( hTargets )
		delete [] hTargets;

	DPF_RETURN(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DPLAttemptLobbyConnection"

HRESULT DPLAttemptLobbyConnection(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject)
{
	PSTR	pszCommandLine;
	char	*c;
	DWORD	dwCommandLineSize;
	CHAR	pszObjectName[(sizeof(DWORD)*2)*2 + 1 + 1];
	HANDLE	hSyncEvent;
	HRESULT	hResultCode;
	HANDLE	hFileMap;
	DPL_SHARED_CONNECT_BLOCK	*pSharedBlock;
	DWORD	dwError;
	DWORD	dwReturnValue;

	DPFX(DPFPREP, 3,"Parameters: (none)");

	// Need a copy of the command line
	dwCommandLineSize = strlen(GetCommandLineA()) + 1;
	if ((pszCommandLine = static_cast<PSTR>(DNMalloc(dwCommandLineSize))) == NULL)
	{
		return(DPNERR_NORESPONSE);
	}
	strcpy(pszCommandLine,GetCommandLineA());
	DPFX(DPFPREP, 5,"Got command line [%s]",pszCommandLine);

	// Try to find Lobby Launch ID string
	c = strstr(pszCommandLine,DPL_ID_STR_A);
	if (c == NULL)
	{
		DNFree(pszCommandLine);
		return(DPNERR_NORESPONSE);
	}
	c += strlen(DPL_ID_STR_A);
	c--;
	strncpy(pszObjectName,c,(sizeof(DWORD)*2)*2 + 1);
	pszObjectName[(sizeof(DWORD)*2)*2 + 1] = '\0';		// Ensure null terminated
	DPFX(DPFPREP, 5,"Got object name [%s]",pszObjectName);
	DNFree(pszCommandLine);

	// Try to open shared memory
	*pszObjectName = DPL_MSGQ_OBJECT_IDCHAR_FILEMAP;
	hFileMap = CreateFileMappingA(INVALID_HANDLE_VALUE,(LPSECURITY_ATTRIBUTES) NULL,
		PAGE_READWRITE,(DWORD)0,sizeof(DPL_SHARED_CONNECT_BLOCK),pszObjectName);
	if (hFileMap == NULL)
	{
		DPFERR("CreateFileMapping() failed");
		dwError = GetLastError();
		DNASSERT(FALSE);
		return(DPNERR_NORESPONSE);
	}

	// Ensure it existed already
	dwError = GetLastError();
	if (dwError != ERROR_ALREADY_EXISTS)
	{
		DPFERR("File mapping did not already exist");
		DNASSERT(FALSE);
		CloseHandle(hFileMap);
		return(DPNERR_NORESPONSE);
	}

	// Map file
	pSharedBlock = reinterpret_cast<DPL_SHARED_CONNECT_BLOCK*>(MapViewOfFile(hFileMap,FILE_MAP_ALL_ACCESS,0,0,0));
	if (pSharedBlock == NULL)
	{
		DPFERR("MapViewOfFile() failed");
		dwError = GetLastError();
		DNASSERT(FALSE);
		CloseHandle(hFileMap);
		return(DPNERR_NORESPONSE);
	}


	// Try to open connection event
	*pszObjectName = DPL_MSGQ_OBJECT_IDCHAR_EVENT;
	hSyncEvent = OpenEventA(EVENT_MODIFY_STATE,FALSE,pszObjectName);
	if (hSyncEvent == NULL)
	{
		DPFERR("OpenEvent() failed");
		dwError = GetLastError();
		DNASSERT(FALSE);
		UnmapViewOfFile(pSharedBlock);
		CloseHandle(hFileMap);
		return(DPNERR_NORESPONSE);
	}
	DPFX(DPFPREP, 5,"Opened sync event");

	ResetEvent(pdpLobbyObject->hConnectEvent);

	// Look for lobby launch -- set lobby launch value if connection is received
	pdpLobbyObject->dwFlags |= DPL_OBJECT_FLAG_LOOKINGFORLOBBYLAUNCH;

	// Make application available for connection by lobby client
	DNASSERT(pdpLobbyObject->pReceiveQueue != NULL);

	// Signal lobby client
	pSharedBlock->dwPID = pdpLobbyObject->dwPID;
	SetEvent(hSyncEvent);

	dwReturnValue = WaitForSingleObject(pdpLobbyObject->hConnectEvent,DPL_LOBBYLAUNCHED_CONNECT_TIMEOUT);

	// Turn off the looking for lobby launch flag
	pdpLobbyObject->dwFlags &= ~(DPL_OBJECT_FLAG_LOOKINGFORLOBBYLAUNCH);

	if (dwReturnValue == WAIT_OBJECT_0)
		hResultCode = DPN_OK;
	else
		hResultCode = DPNERR_TIMEDOUT;

	// Clean up
	CloseHandle(hSyncEvent);
	UnmapViewOfFile(pSharedBlock);
	CloseHandle(hFileMap);

	DPFX(DPFPREP, 3,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}



//------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\inc\dpsp8.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1998-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		DPSP8.h
 *  Content:	Service provider include file
//@@BEGIN_MSINTERNAL
 *  History:
 *	Date   By  Reason
 *	============
 *	10/12/98	jwo		created
 *	03/22/2000	jtk		Changed interface names
 *	05/16/2000	jtk		Derived from DNSP.h
 *	07/17/2001	vanceo	MSINTERNAL cleanup so header can be released
//@@END_MSINTERNAL
 ***************************************************************************/

#ifndef __DIRECTPLAY_SERVICE_PROVIDER_8__
#define __DIRECTPLAY_SERVICE_PROVIDER_8__

#include <ole2.h>	   // for DECLARE_INTERFACE and HRESULT

#ifdef __cplusplus
extern "C" {
#endif



/****************************************************************************
 *
 * DirectPlay8 Interface IIDs
 *
 ****************************************************************************/

//
// GUIDS used by DP8ServiceProvider objects
//
// {85F1A470-61D5-11D2-AE0F-006097B01411}
DEFINE_GUID(IID_IDP8ServiceProvider, 0x85f1a470, 0x61d5, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);

// {85F1A472-61D5-11D2-AE0F-006097B01411}
DEFINE_GUID(IID_IDP8SPCallback, 0x85f1a472, 0x61d5, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);


/****************************************************************************
 *
 * DirectPlay8 Interface Pointer definitions
 *
 ****************************************************************************/

typedef struct IDP8SPCallback		FAR *PDP8SPCALLBACK;
typedef struct IDP8ServiceProvider	IDP8ServiceProvider;


//**************************************************************************
// Constant definitions
//**************************************************************************

//
// Registry key under HKLM where the service provider info lives
//
#define DPN_REG_LOCAL_SP_ROOT				L"Software\\Microsoft\\DirectPlay8"
#define DPN_REG_LOCAL_SP_SUB				L"\\Service Providers"
#define DPN_REG_LOCAL_SP_SUBKEY				DPN_REG_LOCAL_SP_ROOT DPN_REG_LOCAL_SP_SUB

//
// Registry values used by DirectPlay
//
#define DPN_REG_KEYNAME_FRIENDLY_NAME			L"Friendly Name"
#define DPN_REG_KEYNAME_GUID					L"GUID"


//
// Enumerated values for service provider events
//
typedef	enum _SP_EVENT_TYPE
{
	SPEV_UNKNOWN = 0,
	SPEV_DATA,
	SPEV_CONNECT,
	SPEV_DISCONNECT,
	SPEV_ENUMQUERY,
	SPEV_QUERYRESPONSE,
	SPEV_LISTENSTATUS,
	SPEV_LISTENADDRESSINFO,
	SPEV_ENUMADDRESSINFO,
	SPEV_CONNECTADDRESSINFO

} SP_EVENT_TYPE;

/* Flags */

//@@BEGIN_MSINTERNAL
//#define DPNSPF_OKTOSHOWSTATUS				0x00000001		// unused
//@@END_MSINTERNAL
#define DPNSPF_OKTOQUERY					0x00000002		// OK for SP to ask the user for clarification on addresses
//@@BEGIN_MSINTERNAL
//#define DPNSPF_RELIABLE					0x00000004		// unused
//#define DPNSPF_UNRELIABLE					0x00000008		// unused
//@@END_MSINTERNAL
#define DPNSPF_NOBROADCASTFALLBACK			0x00000010		// don't allow SP to fallback to broadcast with insufficient information
															// (only if the SP supports broadcast)
#define DPNSPF_BINDLISTENTOGATEWAY			0x00000020		// when performing a 'listen' attempt create a mapping between the local
															// 'port' to the same 'port' on the network 'gateway'.
#define DPNSPF_ADDITIONALMULTIPLEXADAPTERS	0x00000040		// there will be more adapters for this connect operation

//
// flags for getting address information
//
typedef	enum
{
	SP_GET_ADDRESS_INFO_LOCAL_ADAPTER = 0x00000001,			// local adapter address
	SP_GET_ADDRESS_INFO_LISTEN_HOST_ADDRESSES,				// local adapter address (in 'host' form to be passed to connect/enum)
	SP_GET_ADDRESS_INFO_LOCAL_HOST_PUBLIC_ADDRESS,			// local adapter address as mapped on the 'gateway' (in 'host' form for connect/enum)
	SP_GET_ADDRESS_INFO_REMOTE_HOST							// address of other end of an endpoint (in 'host' form to be passed to connect/enum)
} SP_GET_ADDRESS_INFO_FLAGS;


//**************************************************************************
// Structure definitions
//**************************************************************************

//
// data received from the SP
//
typedef	struct	_SPRECEIVEDBUFFER
{
	struct _SPRECEIVEDBUFFER	*pNext;						// link to next item in list
	DWORD						dwProtocolData;				// reserved for protocol
	PVOID						pServiceProviderDescriptor;	// reserved for protocol
	BUFFERDESC					BufferDesc;					// received buffer description

} SPRECEIVEDBUFFER, *PSPRECEIVEDBUFFER;

//
// connect indication
//
typedef struct	_SPIE_CONNECT
{	
	HANDLE	hEndpoint;			// handle of the new endpoint
	void	*pEndpointContext;	// user context associated with this endpoint
	void	*pCommandContext;	// user context for associated command

} SPIE_CONNECT, *PSPIE_CONNECT;

//
// disconnect indication
//
typedef	struct	_SPIE_DISCONNECT
{
	HANDLE	hEndpoint;			// handle of endpoint being disconnected
	void	*pEndpointContext;	// user context associated with this endpoint

} SPIE_DISCONNECT, *PSPIE_DISCONNECT;

//
// user data indication
//
typedef struct _SPIE_DATA
{
	HANDLE				hEndpoint;			// EP from which this data was received
	void				*pEndpointContext;	// user context associated with this endpoint
	SPRECEIVEDBUFFER	*pReceivedData;		// pointer to received data

} SPIE_DATA, *PSPIE_DATA;

//
// enum data indication
//
typedef struct _SPIE_QUERY
{
	IDirectPlay8Address	*pAddressSender;		// address from which the query came (may be NULL)
	IDirectPlay8Address	*pAddressDevice;		// address of device on which query was received
	SPRECEIVEDBUFFER	*pReceivedData;			// pointer to received data
	void				*pUserContext;			// user context passed into listen command

} SPIE_QUERY, *PSPIE_QUERY;

//
// enum response data indication
//
typedef	struct	_SPIE_QUERYRESPONSE
{
	IDirectPlay8Address		*pAddressSender;		// address from which the query came (may be NULL)
	IDirectPlay8Address		*pAddressDevice;		// address of device on which query response was received
	SPRECEIVEDBUFFER		*pReceivedData;			// pointer to received data
	DWORD					dwRoundTripTime;		// round trip time for enum (milliseconds)
	void					*pUserContext;			// user context passed into enum command
} SPIE_QUERYRESPONSE, *PSPIE_QUERYRESPONSE;


//
// event sent to indicate status of 'listen' on an adapter
//
typedef	struct	_SPIE_LISTENSTATUS
{
	GUID		ListenAdapter;		// adapter GUID
	HRESULT		hResult;			// result of listen
	HANDLE		hCommand;			// handle of associated command
	void		*pUserContext;		// user context passed into command
	HANDLE		hEndpoint;			// handle of endpoint associated with this listen
} SPIE_LISTENSTATUS, *PSPIE_LISTENSTATUS;


//
// event sent to indicate address info for 'listen' on an adapter
//
typedef	struct	_SPIE_LISTENADDRESSINFO
{
	IDirectPlay8Address		*pDeviceAddress;		// device address used to complete this command
	HRESULT					hCommandStatus;			// command status
	void					*pCommandContext;		// command context
} SPIE_LISTENADDRESSINFO, *PSPIE_LISTENADDRESSINFO;


//
// event sent to indicate address info for 'enum' on an adapter
//
typedef	struct	_SPIE_ENUMADDRESSINFO
{
	IDirectPlay8Address		*pHostAddress;			// host address used to complete this command
	IDirectPlay8Address		*pDeviceAddress;		// device address used to complete this command
	HRESULT					hCommandStatus;			// command status
	void					*pCommandContext;		// command context
} SPIE_ENUMADDRESSINFO, *PSPIE_ENUMADDRESSINFO;


//
// event sent to indicate status of 'connect' on an adapter
//
typedef	struct	_SPIE_CONNECTADDRESSINFO
{
	IDirectPlay8Address		*pHostAddress;			// host address used to complete this command
	IDirectPlay8Address		*pDeviceAddress;		// device address used to complete this command
	HRESULT					hCommandStatus;			// command status
	void					*pCommandContext;		// command context
} SPIE_CONNECTADDRESSINFO, *PSPIE_CONNECTADDRESSINFO;

//
// data passed through the service provider interface
//
typedef struct IDP8SPCallback	FAR *PDP8SPCALLBACK;
typedef struct IDP8SPCallback	IDP8SPCallback;

// Love to use SPINITDATA, but the old DPlay already took it, and compilers
// don't like namespace collisions for some strange reason.
typedef struct	_SPINITIALIZEDATA
{
	IDP8SPCallback	*pIDP;		// pointer to callback interface
	DWORD			dwFlags;	// flags

} SPINITIALIZEDATA, *PSPINITIALIZEDATA;


typedef	struct	_SPGETCAPSDATA
{
	DWORD		dwSize;							// size of this structure

	HANDLE		hEndpoint;						// Handle of endpoint to check.  If this parameter
												// is NULL, the best-case capabilities of the SP are
												// returned.

	DWORD		dwUserFrameSize;				// Maximum data payload allowed in an outgoing
												// message from this SP.  It is the SP's responsibility
												// to account for any extra header information it's
												// going to attach when sending a message, and for any
												// underlying protocol overhead (IP packet headers).

	DWORD		dwEnumFrameSize;				// maximum payload for an enum query (NOT ENUM RESPONSE!)

	DWORD		dwLocalLinkSpeed;				// speed of link in bits per second

	DWORD		dwIOThreadCount;				// count of threads in operation by this SP

	DWORD		dwDefaultEnumRetryCount;		// default retry count

	DWORD		dwDefaultEnumRetryInterval;		// default retry interval

	DWORD		dwDefaultEnumTimeout;			// default timeout

	DWORD		dwFlags;						// SP flags

	DWORD		dwBuffersPerThread;				// buffers per thread
	
	DWORD		dwSystemBufferSize;				// system buffer size

} SPGETCAPSDATA, *PSPGETCAPSDATA;


typedef	struct	_SPSETCAPSDATA
{
	DWORD	dwSize;					// size of this structure

	DWORD	dwIOThreadCount;		// number of threads in operation by this SP
	DWORD	dwBuffersPerThread;		// buffers per thread
	DWORD	dwSystemBufferSize;		// system buffer size

} SPSETCAPSDATA, *PSPSETCAPSDATA;


typedef	struct	_SPGETADDRESSINFODATA
{
	HANDLE				hEndpoint;		// handle of endpoint to check
	IDirectPlay8Address	*pAddress;		// pointer to output address
	SP_GET_ADDRESS_INFO_FLAGS	Flags;	// flags

} SPGETADDRESSINFODATA, *PSPGETADDRESSINFODATA;


typedef struct	_SPENUMQUERYDATA
{
	IDirectPlay8Address	*pAddressHost;			// address to which to send
	IDirectPlay8Address	*pAddressDeviceInfo;	// device to enumerate on
	BUFFERDESC			*pBuffers;				// pointer to buffers to send
	DWORD				dwBufferCount;			// count of buffers to send
	DWORD				dwTimeout;				// how long to wait for replies (0 means infinite)
	DWORD				dwRetryCount;			// how many times to send it (0 means infinite)
	DWORD				dwRetryInterval;		// how long to wait between retries
	DWORD				dwFlags;
	void				*pvContext;				// caller's toy, returned in the completion indication
	HANDLE				hCommand;				// Returned
	DWORD				dwCommandDescriptor;	// Returned

} SPENUMQUERYDATA, *PSPENUMQUERYDATA;


typedef struct	_SPENUMRESPONDDATA
{
	SPIE_QUERY		*pQuery;				// pointer to the query indication to which you're responding
	BUFFERDESC		*pBuffers;
	DWORD			dwBufferCount;
	DWORD			dwFlags;				// must be zero!
	void			*pvContext;				// caller's toy, returned in the completion indication
	HANDLE			hCommand;				// Returned
	DWORD			dwCommandDescriptor;	// Returned

} SPENUMRESPONDDATA, *PSPENUMRESPONDDATA;


typedef struct	_SPCONNECTDATA
{
	IDirectPlay8Address	*pAddressHost;			// address to which to connect
	IDirectPlay8Address	*pAddressDeviceInfo;	// address to which to connect
	DWORD				dwReserved;				// unused, must be zero
	DWORD				dwFlags;
	void				*pvContext;				// caller's toy, returned in the completion indication
	HANDLE				hCommand;				// Returned
	DWORD				dwCommandDescriptor;	// Returned

} SPCONNECTDATA, *PSPCONNECTDATA;


typedef struct	_SPDISCONNECTDATA
{
	HANDLE			hEndpoint;				// handle to the endpoint to disconnect
	DWORD			dwFlags;				// must be zero!
	void			*pvContext;				// caller's toy, returned in the completion indication
	HANDLE			hCommand;				// Returned
	DWORD			dwCommandDescriptor;	// Returned

} SPDISCONNECTDATA, *PSPDISCONNECTDATA;


typedef struct	_SPLISTENDATA
{
	IDirectPlay8Address	*pAddressDeviceInfo;	// address to listen on
	DWORD				dwFlags;
	void				*pvContext;				// caller's toy, returned in the completion indication
	HANDLE				hCommand;				// Returned
	DWORD				dwCommandDescriptor;	// Returned

} SPLISTENDATA, *PSPLISTENDATA;


typedef struct	_SPSENDDATA
{
	HANDLE			hEndpoint;				// handle of endpoint on which to send the data
	BUFFERDESC		*pBuffers;				// data to send
	DWORD			dwBufferCount;			// count of buffers to send
	DWORD			dwFlags;				// send flags
	void			*pvContext;				// caller's toy, returned in the completion indication
	HANDLE			hCommand;				// Returned
	DWORD			dwCommandDescriptor;	// Returned

} SPSENDDATA, *PSPSENDDATA;


typedef struct	_SPCREATEGROUPDATA	SPCREATEGROUPDATA, *PSPCREATEGROUPDATA;

typedef	struct	_SPADDTOGROUPDATA	SPADDTOGROUPDATA, *PSPADDTOGROUPDATA;

typedef struct	_SPREMOVEFROMGROUPDATA	SPREMOVEFROMGROUPDATA, *PSPREMOVEFROMGROUPDATA;

typedef struct	_SPDELETEGROUPDATA	SPDELETEGROUPDATA, *PSPDELETEGROUPDATA;


typedef struct	_SPISAPPLICATIONSUPPORTEDDATA
{
	const GUID	*pApplicationGuid;
	DWORD		dwFlags;

} SPISAPPLICATIONSUPPORTEDDATA, *PSPISAPPLICATIONSUPPORTEDDATA;


typedef struct	_SPENUMADAPTERSDATA
{
	DPN_SERVICE_PROVIDER_INFO	*pAdapterData;
	DWORD	dwAdapterDataSize;
	DWORD	dwAdapterCount;
	DWORD	dwFlags;

} SPENUMADAPTERSDATA, *PSPENUMADAPTERSDATA;


typedef struct	_SPPROXYENUMQUERYDATA
{
	DWORD				dwFlags;
	SPIE_QUERY			*pIncomingQueryData;
	IDirectPlay8Address	*pDestinationAdapter;

} SPPROXYENUMQUERYDATA, *PSPPROXYENUMQUERYDATA;


//**************************************************************************
// Variable definitions
//**************************************************************************

//**************************************************************************
// Function prototypes
//**************************************************************************

//**************************************************************************
// Function definitions
//**************************************************************************


/***************************************************************************
 * IDP8SPCallback interface
 ***************************************************************************/

#undef INTERFACE
#define INTERFACE IDP8SPCallback
DECLARE_INTERFACE_( IDP8SPCallback, IUnknown )
{
	/*** IUnknown methods ***/
	STDMETHOD(QueryInterface)		(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)		(THIS) PURE;
	STDMETHOD_(ULONG,Release)		(THIS) PURE;
	/*** IDP8SPCallback methods ***/
	STDMETHOD(IndicateEvent) 		(THIS_ SP_EVENT_TYPE,LPVOID) PURE;
	STDMETHOD(CommandComplete) 		(THIS_ HANDLE,HRESULT,LPVOID) PURE;
};


/***************************************************************************
 * IDP8SPCallback interface macros
 ***************************************************************************/

#if !defined(__cplusplus) || defined(CINTERFACE)

#define IDP8SPCallback_QueryInterface(p,a,b)		(p)->lpVtbl->QueryInterface(p,a,b)
#define IDP8SPCallback_AddRef(p)					(p)->lpVtbl->AddRef(p)
#define IDP8SPCallback_Release(p)			   		(p)->lpVtbl->Release(p)
#define IDP8SPCallback_IndicateEvent(p,a,b)	  		(p)->lpVtbl->IndicateEvent(p,a,b)
#define IDP8SPCallback_CommandComplete(p,a,b,c)		(p)->lpVtbl->CommandComplete(p,a,b,c)

#else /* C++ */

#define IDP8SPCallback_QueryInterface(p,a,b)		(p)->QueryInterface(a,b)
#define IDP8SPCallback_AddRef(p)					(p)->AddRef()
#define IDP8SPCallback_Release(p)			   		(p)->Release()
#define IDP8SPCallback_IndicateEvent(p,a,b)			(p)->IndicateEvent(a,b)
#define IDP8SPCallback_CommandComplete(p,a,b,c)		(p)->CommandComplete(a,b,c)

#endif


/***************************************************************************
 * IDP8ServiceProvider interface
 ***************************************************************************/

#undef INTERFACE
#define INTERFACE IDP8ServiceProvider
DECLARE_INTERFACE_( IDP8ServiceProvider, IUnknown )
{
	/*** IUnknown methods ***/
	STDMETHOD(QueryInterface)	   		(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)			(THIS) PURE;
	STDMETHOD_(ULONG,Release)	   		(THIS) PURE;
	/*** IDP8ServiceProvider methods ***/
	STDMETHOD(Initialize)				(THIS_ PSPINITIALIZEDATA) PURE;
	STDMETHOD(Close)  					(THIS) PURE;
	STDMETHOD(Connect)		  			(THIS_ PSPCONNECTDATA) PURE;
	STDMETHOD(Disconnect)		  		(THIS_ PSPDISCONNECTDATA) PURE;
	STDMETHOD(Listen)					(THIS_ PSPLISTENDATA) PURE;
	STDMETHOD(SendData)					(THIS_ PSPSENDDATA) PURE;
	STDMETHOD(EnumQuery)				(THIS_ PSPENUMQUERYDATA) PURE;
	STDMETHOD(EnumRespond)				(THIS_ PSPENUMRESPONDDATA) PURE;
	STDMETHOD(CancelCommand)			(THIS_ HANDLE, DWORD) PURE;
	STDMETHOD(CreateGroup)		  		(THIS_ PSPCREATEGROUPDATA) PURE;
	STDMETHOD(DeleteGroup)		  		(THIS_ PSPDELETEGROUPDATA) PURE;
	STDMETHOD(AddToGroup)				(THIS_ PSPADDTOGROUPDATA) PURE;
	STDMETHOD(RemoveFromGroup)			(THIS_ PSPREMOVEFROMGROUPDATA) PURE;
	STDMETHOD(GetCaps)					(THIS_ PSPGETCAPSDATA) PURE;
	STDMETHOD(SetCaps)					(THIS_ PSPSETCAPSDATA) PURE;
	STDMETHOD(ReturnReceiveBuffers)		(THIS_ PSPRECEIVEDBUFFER) PURE;
	STDMETHOD(GetAddressInfo)			(THIS_ PSPGETADDRESSINFODATA) PURE;
	STDMETHOD(IsApplicationSupported)	(THIS_ PSPISAPPLICATIONSUPPORTEDDATA) PURE;
	STDMETHOD(EnumAdapters)				(THIS_ PSPENUMADAPTERSDATA) PURE;
	STDMETHOD(ProxyEnumQuery)			(THIS_ PSPPROXYENUMQUERYDATA) PURE;
};

/***************************************************************************
 * IDP8ServiceProvider interface macros
 ***************************************************************************/

#if !defined(__cplusplus) || defined(CINTERFACE)

#define IDP8ServiceProvider_QueryInterface(p,a,b)		(p)->lpVtbl->QueryInterface(p,a,b)
#define IDP8ServiceProvider_AddRef(p)					(p)->lpVtbl->AddRef(p)
#define IDP8ServiceProvider_Release(p)					(p)->lpVtbl->Release(p)
#define IDP8ServiceProvider_Initialize(p,a)				(p)->lpVtbl->Initialize(p,a)
#define IDP8ServiceProvider_Connect(p,a)				(p)->lpVtbl->Connect(p,a)
#define IDP8ServiceProvider_Disconnect(p,a)		  		(p)->lpVtbl->Disconnect(p,a)
#define IDP8ServiceProvider_Listen(p,a)					(p)->lpVtbl->Listen(p,a)
#define IDP8ServiceProvider_SendData(p,a)				(p)->lpVtbl->SendData(p,a)
#define IDP8ServiceProvider_EnumQuery(p,a)				(p)->lpVtbl->EnumQuery(p,a)
#define IDP8ServiceProvider_EnumRespond(p,a)			(p)->lpVtbl->EnumRespond(p,a)
#define IDP8ServiceProvider_CancelCommand(p,a,b)		(p)->lpVtbl->CancelCommand(p,a,b)
#define IDP8ServiceProvider_Close(p)					(p)->lpVtbl->Close(p)
#define IDP8ServiceProvider_CreateGroup(p,a)			(p)->lpVtbl->CreateGroup(p,a)
#define IDP8ServiceProvider_DeleteGroup(p,a)			(p)->lpVtbl->DeleteGroup(p,a)
#define IDP8ServiceProvider_AddToGroup(p,a)				(p)->lpVtbl->AddToGroup(p,a)
#define IDP8ServiceProvider_RemoveFromGroup(p,a)		(p)->lpVtbl->RemoveFromGroup(p,a)
#define	IDP8ServiceProvider_GetCaps(p,a)				(p)->lpVtbl->GetCaps(p,a)
#define	IDP8ServiceProvider_SetCaps(p,a)				(p)->lpVtbl->SetCaps(p,a)
#define IDP8ServiceProvider_ReturnReceiveBuffers(p,a)	(p)->lpVtbl->ReturnReceiveBuffers(p,a)
#define IDP8ServiceProvider_GetAddressInfo(p,a)			(p)->lpVtbl->GetAddressInfo(p,a)
#define IDP8ServiceProvider_IsApplicationSupported(p,a)	(p)->lpVtbl->IsApplicationSupported(p,a)
#define IDP8ServiceProvider_EnumAdapters(p,a)			(p)->lpVtbl->EnumAdapters(p,a)
#define	IDP8ServiceProvider_ProxyEnumQuery(p,a)			(p)->lpVtbl->ProxyEnumQuery(p,a)

#else /* C++ */

#define IDP8ServiceProvider_QueryInterface(p,a,b)		(p)->QueryInterface(a,b)
#define IDP8ServiceProvider_AddRef(p)					(p)->AddRef()
#define IDP8ServiceProvider_Release(p)					(p)->Release()
#define IDP8ServiceProvider_Initialize(p,a)				(p)->Initialize(a)
#define IDP8ServiceProvider_Connect(p,a)				(p)->Connect(a)
#define IDP8ServiceProvider_Disconnect(p,a)				(p)->Disconnect(a)
#define IDP8ServiceProvider_Listen(p,a)					(p)->Listen(a)
#define IDP8ServiceProvider_SendData(p,a)				(p)->SendData(a)
#define IDP8ServiceProvider_EnumQuery(p,a)				(p)->EnumQuery(a)
#define IDP8ServiceProvider_EnumRespond(p,a)			(p)->EnumRespond(a)
#define IDP8ServiceProvider_CancelCommand(p,a,b)		(p)->CancelCommand(a,b)
#define IDP8ServiceProvider_Close(p)					(p)->Close()
#define IDP8ServiceProvider_CreateGroup(p,a)			(p)->CreateGroup(a)
#define IDP8ServiceProvider_DeleteGroup(p,a)			(p)->DeleteGroup(a)
#define IDP8ServiceProvider_AddToGroup(p,a)				(p)->AddToGroup(a)
#define IDP8ServiceProvider_RemoveFromGroup(p,a)		(p)->RemoveFromGroup(a)
#define	IDP8ServiceProvider_GetCaps(p,a)				(p)->GetCaps(a)
#define	IDP8ServiceProvider_SetCaps(p,a)				(p)->SetCaps(a)
#define IDP8ServiceProvider_GetAddressInfo(p,a)			(p)->GetAddressInfo(a)
#define IDP8ServiceProvider_IsApplicationSupported(p,a)	(p)->IsApplicationSupported(a)
#define IDP8ServiceProvider_EnumAdapters(p,a)			(p)->EnumAdapters(a)
#define	IDP8ServiceProvider_ProxyEnumQuery(p,a)			(p)->ProxyEnumQuery(a)

#endif	// C++

#ifdef __cplusplus
};
#endif

#endif	// __DIRECTPLAY_SERVICE_PROVIDER_8__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\lobby\dplapp.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DPLApp.h
 *  Content:    DirectPlay Lobbied Application Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   02/21/00	mjn		Created
 *   03/22/2000	jtk		Changed interface names
 *   04/25/2000 rmt     Bug #s 33138, 33145, 33150 
  *  05/08/00   rmt     Bug #34301 - Add flag to SetAppAvail to allow for multiple connects
 *   06/15/00   rmt     Bug #33617 - Must provide method for providing automatic launch of DirectPlay instances   
 *   07/08/2000	rmt		Bug #38725 - Need to provide method to detect if app was lobby launched
 *				rmt		Bug #38757 - Callback messages for connections may return AFTER WaitForConnection returns
 *				rmt		Bug #38755 - No way to specify player name in Connection Settings
 *				rmt		Bug #38758 - DPLOBBY8.H has incorrect comments
 *				rmt		Bug #38783 - pvUserApplicationContext is only partially implemented
 *				rmt		Added DPLHANDLE_ALLCONNECTIONS and dwFlags (reserved field to couple of funcs).
 *@@END_MSINTERNAL
 *
 ***************************************************************************/


#ifndef	__DPLAPP_H__
#define	__DPLAPP_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

typedef struct _DIRECTPLAYLOBBYOBJECT DIRECTPLAYLOBBYOBJECT;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	DPL_LOBBYLAUNCHED_CONNECT_TIMEOUT	4000

//
// VTable for lobbied application interface
//
extern IDirectPlay8LobbiedApplicationVtbl DPL_8LobbiedApplicationVtbl;

//**********************************************************************
// Function prototypes
//**********************************************************************

STDMETHODIMP DPL_RegisterProgram(IDirectPlay8LobbiedApplication *pInterface,
							 PDPL_PROGRAM_DESC pdplProgramDesc,
							 const DWORD dwFlags);

STDMETHODIMP DPL_UnRegisterProgram(IDirectPlay8LobbiedApplication *pInterface,
							   GUID *pguidApplication,
							   const DWORD dwFlags);

STDMETHODIMP DPL_SetAppAvailable(IDirectPlay8LobbiedApplication *pInterface, const BOOL fAvailable, const DWORD dwFlags );

STDMETHODIMP DPL_WaitForConnection(IDirectPlay8LobbiedApplication *pInterface,
								   const DWORD dwMilliseconds, 
								   const DWORD dwFlags );

STDMETHODIMP DPL_UpdateStatus(IDirectPlay8LobbiedApplication *pInterface,
							  const DPNHANDLE hLobby,
							  const DWORD dwStatus,
							  const DWORD dwFlags );

HRESULT DPLAttemptLobbyConnection(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject);

#endif	// __DPLAPP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\lobby\classfac.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ClassFac.h
 *  Content:    DirectPlay Lobby class factory header file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   02/21/00	mjn		Created
 *   06/07/00	rodtoll	Bug #34383 Must provide CLSID for each IID to fix issues with Whistler
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__CLASSFAC_H__
#define	__CLASSFAC_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

typedef struct _INTERFACE_LIST	INTERFACE_LIST;
typedef struct _OBJECT_DATA		OBJECT_DATA;

//
// COM interface for class factory
//
#undef INTERFACE				// External COM Implementation
#define INTERFACE IDirectPlayLobbyClassFact
DECLARE_INTERFACE_(IDirectPlayLobbyClassFact,IUnknown)
{
	STDMETHOD(QueryInterface)	(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)	(THIS) PURE;
	STDMETHOD_(ULONG,Release)	(THIS) PURE;
	STDMETHOD(CreateInstance)	(THIS_ LPUNKNOWN lpUnkOuter, REFIID riid, LPVOID *ppvObj) PURE;
	STDMETHOD(LockServer)		(THIS_ BOOL bLock) PURE;
};


typedef struct _IDirectPlayLobbyClassFact {	// Internal Implementation (overlay's external imp.)
	IDirectPlayLobbyClassFactVtbl	*lpVtbl;		// lpVtbl Must be first element (to match external imp.)
	LONG							lRefCount;
	DWORD							dwLocks;
	CLSID							clsid;
} _IDirectPlayLobbyClassFact, *_PIDirectPlayLobbyClassFact;

//**********************************************************************
// Variable definitions
//**********************************************************************

//
// VTable for class factory
//
extern IDirectPlayLobbyClassFactVtbl DPLCF_Vtbl;

//**********************************************************************
// Function prototypes
//**********************************************************************

//	DirectPlay - IUnknown
STDMETHODIMP			DPL_QueryInterface(LPVOID lpv, REFIID riid,LPVOID *ppvObj);
STDMETHODIMP_(ULONG)	DPL_AddRef(LPVOID lphObj);
STDMETHODIMP_(ULONG)	DPL_Release(LPVOID lphObj);

// Class Factory
STDMETHODIMP			DPLCF_QueryInterface(IDirectPlayLobbyClassFact *pInterface,REFIID riid,LPVOID *ppvObj);
STDMETHODIMP_(ULONG)	DPLCF_AddRef(IDirectPlayLobbyClassFact *pInterface);
STDMETHODIMP_(ULONG)	DPLCF_Release(IDirectPlayLobbyClassFact *pInterface);
STDMETHODIMP			DPLCF_CreateInstance(IDirectPlayLobbyClassFact *pInterface,LPUNKNOWN lpUnkOuter,REFIID riid,LPVOID *ppv);
STDMETHODIMP			DPLCF_LockServer(IDirectPlayLobbyClassFact *pInterface,BOOL bLock);

// Class Factory - supporting

HRESULT	DPLCF_CreateObject(LPVOID *lplpv,REFIID riid);
HRESULT	DPLCF_FreeObject(LPVOID lpv);

HRESULT	DPL_CreateInterface(OBJECT_DATA* lpObject,REFIID riid,INTERFACE_LIST** const ppv);
INTERFACE_LIST*	DPL_FindInterface(LPVOID lpv, REFIID riid);

#endif	// __CLASSFAC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\lobby\dplclassfac.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ClassFac.cpp
 *  Content:    DirectPlay Lobby COM Class Factory
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   02/21/00	mjn		Created
 *   03/22/2000	jtk		Changed interface names
 *   04/18/2000 rmt     Updated object create to set param validation flag
 *   05/09/2000 rmt     Bug #34306 QueryInterface on lobbyclient for lobbiedapp works (and shouldn't).
 *   06/07/2000	rmt		Bug #34383 Must provide CLSID for each IID to fix issues with Whistler
 *   06/20/2000 rmt     Bugfix - QueryInterface had bug which was limiting interface list to 2 elements
 *   07/08/2000	rmt		Added guard bytes
 *   08/05/2000 RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *   08/08/2000	rmt		Removed assert which wasn't needed
 *   01/11/2001	rmt		MANBUG #48487 - DPLAY: Crashes if CoCreate() isn't called.   
 *   03/14/2001 rmt		WINBUG #342420 - Restore COM emulation layer to operation. 
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dnlobbyi.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

typedef	STDMETHODIMP IUnknownQueryInterface( IUnknown *pInterface, REFIID riid, LPVOID *ppvObj );
typedef	STDMETHODIMP_(ULONG)	IUnknownAddRef( IUnknown *pInterface );
typedef	STDMETHODIMP_(ULONG)	IUnknownRelease( IUnknown *pInterface );

//
// VTable for IUnknown interface
//
IUnknownVtbl  DN_UnknownVtbl =
{
	(IUnknownQueryInterface*)	DPL_QueryInterface,
	(IUnknownAddRef*)			DPL_AddRef,
	(IUnknownRelease*)			DPL_Release
};


//
// VTable for Class Factory
//
IDirectPlayLobbyClassFactVtbl DPLCF_Vtbl  =
{
	DPLCF_QueryInterface,
	DPLCF_AddRef,
	DPLCF_Release,
	DPLCF_CreateInstance,
	DPLCF_LockServer
};

//**********************************************************************
// Variable definitions
//**********************************************************************

//
// Globals
//
extern	DWORD	GdwHLocks;
extern	DWORD	GdwHObjects;

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


#undef DPF_MODNAME
#define DPF_MODNAME "DPLCF_QueryInterface"

STDMETHODIMP DPLCF_QueryInterface(IDirectPlayLobbyClassFact *pInterface,
								  REFIID riid,
								  LPVOID *ppv)
{
	_PIDirectPlayLobbyClassFact	lpcfObj;
	HRESULT				hResultCode = S_OK;

	DPFX(DPFPREP, 3,"Parameters: pInterface [0x%p], riid [0x%p], ppv [0x%p]",pInterface,riid,ppv);

	lpcfObj = (_PIDirectPlayLobbyClassFact)pInterface;
	if (IsEqualIID(riid,IID_IUnknown))
	{
		DPFX(DPFPREP, 5,"riid = IID_IUnknown");
		*ppv = pInterface;
		lpcfObj->lpVtbl->AddRef( pInterface );
	}
	else if (IsEqualIID(riid,IID_IClassFactory))
	{
		DPFX(DPFPREP, 5,"riid = IID_IClassFactory");
		*ppv = pInterface;
		lpcfObj->lpVtbl->AddRef( pInterface );
	}
	else
	{
		DPFX(DPFPREP, 5,"riid not found !");
		*ppv = NULL;
		hResultCode = E_NOINTERFACE;
	}

	DPFX(DPFPREP, 3,"Returning: hResultCode = [%lx], *ppv = [%p]",hResultCode,*ppv);

	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DPLCF_AddRef"

STDMETHODIMP_(ULONG) DPLCF_AddRef(IDirectPlayLobbyClassFact *pInterface)
{
	_PIDirectPlayLobbyClassFact	lpcfObj;

	DPFX(DPFPREP, 3,"Parameters: pInterface [%p]",pInterface);

	lpcfObj = (_PIDirectPlayLobbyClassFact)pInterface;
	InterlockedIncrement( &lpcfObj->lRefCount );

	DPFX(DPFPREP, 3,"Returning: lpcfObj->lRefCount = [%lx]",lpcfObj->lRefCount);

	return(lpcfObj->lRefCount);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DPLCF_Release"

STDMETHODIMP_(ULONG) DPLCF_Release(IDirectPlayLobbyClassFact *pInterface)
{
	_PIDirectPlayLobbyClassFact	lpcfObj;

	DPFX(DPFPREP, 3,"Parameters: pInterface [%p]",pInterface);

	lpcfObj = (_PIDirectPlayLobbyClassFact)pInterface;
	DPFX(DPFPREP, 5,"Original : lpcfObj->lRefCount = %ld",lpcfObj->lRefCount);
	if( InterlockedDecrement( &lpcfObj->lRefCount ) == 0 )
	{
		DPFX(DPFPREP, 5,"Freeing class factory object: lpcfObj [%p]",lpcfObj);
		DNFree(lpcfObj);

		GdwHObjects--;

		return(0);
	}
	DPFX(DPFPREP, 3,"Returning: lpcfObj->lRefCount = [%lx]",lpcfObj->lRefCount);

	return(lpcfObj->lRefCount);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DPLCF_CreateObject"

HRESULT DPLCF_CreateObject(IDirectPlayLobbyClassFact *pInterface, 
                           LPVOID *lplpv,
						   REFIID riid)
{

	HRESULT					hResultCode = S_OK;
	OSVERSIONINFOA			ver;
	PDIRECTPLAYLOBBYOBJECT	pdpLobbyObject = NULL;
	_PIDirectPlayLobbyClassFact	lpcfObj = (_PIDirectPlayLobbyClassFact)pInterface;


	DPFX(DPFPREP, 3,"Parameters: lplpv [%p]",lplpv);

	/*
	*
	*	TIME BOMB
	*
	*/

#ifndef DX_FINAL_RELEASE
{
#pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")
	SYSTEMTIME st;
	GetSystemTime(&st);

	if ( st.wYear > DX_EXPIRE_YEAR || ((st.wYear == DX_EXPIRE_YEAR) && (MAKELONG(st.wDay, st.wMonth) > MAKELONG(DX_EXPIRE_DAY, DX_EXPIRE_MONTH))) )
	{
		MessageBox(0, DX_EXPIRE_TEXT,TEXT("Microsoft Direct Play"), MB_OK);
//		return E_FAIL;
	}
}
#endif

	if ((pdpLobbyObject = (PDIRECTPLAYLOBBYOBJECT)DNMalloc(sizeof(DIRECTPLAYLOBBYOBJECT))) == NULL)
	{
		return(E_OUTOFMEMORY);
	}
	DPFX(DPFPREP, 5,"pdpLobbyObject [%p]",pdpLobbyObject);

	// Set allocatable elements to NULL to simplify free'ing later on
	pdpLobbyObject->dwSignature = DPLSIGNATURE_LOBBYOBJECT;
	pdpLobbyObject->hReceiveThread = NULL;
	pdpLobbyObject->dwFlags = 0;
	pdpLobbyObject->hConnectEvent = NULL;
	pdpLobbyObject->pfnMessageHandler = NULL;
	pdpLobbyObject->pvUserContext = NULL;
	pdpLobbyObject->lLaunchCount = 0;
	pdpLobbyObject->dpnhLaunchedConnection = NULL;

	pdpLobbyObject->pReceiveQueue = NULL;

	pdpLobbyObject->dwPID = GetCurrentProcessId();

	if ((hResultCode = H_Initialize(&pdpLobbyObject->hsHandles,
			DPL_NUM_APP_HANDLES)) != DPN_OK)
	{
		DPLCF_FreeObject(pdpLobbyObject);
		return(hResultCode);
	}
	if ((pdpLobbyObject->hConnectEvent = CreateEvent(NULL,TRUE,FALSE,NULL)) == NULL)
	{
		DPLCF_FreeObject(pdpLobbyObject);
		hResultCode = DPNERR_OUTOFMEMORY;
		return(hResultCode);
	}

	if ((pdpLobbyObject->hLobbyLaunchConnectEvent = CreateEvent(NULL,TRUE,FALSE,NULL)) == NULL )
	{
		DPLCF_FreeObject(pdpLobbyObject);
		hResultCode = DPNERR_OUTOFMEMORY;
		return(hResultCode);
	}

	pdpLobbyObject->phHandleBuffer = NULL;
	pdpLobbyObject->dwHandleBufferSize = 0;
	    
	DPFX(DPFPREP, 5,"InitializeHandles() succeeded");

	if (IsEqualIID(riid,IID_IDirectPlay8LobbyClient) || 
		(riid == IID_IUnknown && lpcfObj->clsid == CLSID_DirectPlay8LobbyClient ) )
	{
		DPFX(DPFPREP, 5,"DirectPlay Lobby Client");
		pdpLobbyObject->dwFlags |= DPL_OBJECT_FLAG_LOBBYCLIENT;
	}
	else if (IsEqualIID(riid,IID_IDirectPlay8LobbiedApplication) || 
		     (riid == IID_IUnknown && lpcfObj->clsid == CLSID_DirectPlay8LobbiedApplication ) )
	{
		DPFX(DPFPREP, 5,"DirectPlay Lobbied Application");
		pdpLobbyObject->dwFlags |= DPL_OBJECT_FLAG_LOBBIEDAPPLICATION;
	}
	else
	{
		DPFX(DPFPREP, 5,"Invalid DirectPlay Lobby Interface");
		DPLCF_FreeObject(pdpLobbyObject);
		return(E_NOTIMPL);
	}
	
	pdpLobbyObject->dwFlags |= DPL_OBJECT_FLAG_PARAMVALIDATION;

	// Determine platform
	// Just always call the ANSI function
	ver.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
	if(!GetVersionExA(&ver))
	{
		DPFX(DPFPREP,  0, "Unable to determinte platform -- setting flag to ANSI");
		pdpLobbyObject->bIsUnicodePlatform = FALSE;
	}
	else
	{
		switch(ver.dwPlatformId)
		{
			case VER_PLATFORM_WIN32_WINDOWS:
				DPFX(DPFPREP, 1, "Platform detected as non-NT -- setting flag to ANSI");
				pdpLobbyObject->bIsUnicodePlatform = FALSE;
				break;

			case VER_PLATFORM_WIN32_NT:
				DPFX(DPFPREP, 1, "Platform detected as NT -- setting flag to Unicode");
				pdpLobbyObject->bIsUnicodePlatform = TRUE;
				break;

			default:
				DPFX(DPFPREP, 0, "Unable to determine platform -- setting flag to ANSI");
				pdpLobbyObject->bIsUnicodePlatform = FALSE;
				break;
		}
	}

	*lplpv = pdpLobbyObject;

	DPFX(DPFPREP, 3,"Returning: hResultCode = [%lx], *lplpv = [%p]",hResultCode,*lplpv);
	return(hResultCode);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DirectPlay8LobbyCreate"
HRESULT WINAPI DirectPlay8LobbyCreate( const GUID * pcIID, void **ppvInterface, IUnknown *pUnknown) 
{
    GUID clsid;
    
    if( pcIID == NULL || 
        !DNVALID_READPTR( pcIID, sizeof( GUID ) ) )
    {
        DPFERR( "Invalid pointer specified for interface GUID" );
        return DPNERR_INVALIDPOINTER;
    }

    if( *pcIID != IID_IDirectPlay8LobbyClient && 
        *pcIID != IID_IDirectPlay8LobbiedApplication )
    {
        DPFERR("Interface ID is not recognized" );
        return DPNERR_INVALIDPARAM;
    }

    if( ppvInterface == NULL || !DNVALID_WRITEPTR( ppvInterface, sizeof( void * ) ) )
    {
        DPFERR( "Invalid pointer specified to receive interface" );
        return DPNERR_INVALIDPOINTER;
    }

    if( pUnknown != NULL )
    {
        DPFERR( "Aggregation is not supported by this object yet" );
        return DPNERR_INVALIDPARAM;
    }

    if( *pcIID == IID_IDirectPlay8LobbyClient )
    {
    	clsid = CLSID_DirectPlay8LobbyClient;
    }
    else if( *pcIID == IID_IDirectPlay8LobbiedApplication )
    {
    	clsid = CLSID_DirectPlay8LobbiedApplication;
    }
    else 
    {
    	DPFERR( "Invalid IID specified" );
    	return DPNERR_INVALIDINTERFACE;
    }    

    return COM_CoCreateInstance( clsid, NULL, CLSCTX_INPROC_SERVER, *pcIID, ppvInterface, TRUE );      
    
}



#undef DPF_MODNAME
#define DPF_MODNAME "DPLCF_FreeObject"

HRESULT DPLCF_FreeObject(LPVOID lpv)
{
	HRESULT					hResultCode = S_OK;
	PDIRECTPLAYLOBBYOBJECT	pdpLobbyObject = NULL;

	if (lpv != NULL)
	{
		pdpLobbyObject = (PDIRECTPLAYLOBBYOBJECT)lpv;

        if( pdpLobbyObject->phHandleBuffer )
            delete [] pdpLobbyObject->phHandleBuffer;

		if (pdpLobbyObject->pReceiveQueue)
			delete pdpLobbyObject->pReceiveQueue;

		if (pdpLobbyObject->hLobbyLaunchConnectEvent)
			CloseHandle(pdpLobbyObject->hLobbyLaunchConnectEvent);

		if (pdpLobbyObject->hConnectEvent)
			CloseHandle(pdpLobbyObject->hConnectEvent);

		// Free application handles
		H_Terminate(&pdpLobbyObject->hsHandles);

		pdpLobbyObject->dwSignature = DPLSIGNATURE_LOBBYOBJECT_FREE;

		DPFX(DPFPREP, 5,"free pdpLobbyObject [%p]",pdpLobbyObject);
		DNFree(pdpLobbyObject);
	}
	DPFX(DPFPREP, 3,"Returning: hResultCode = [%lx]",hResultCode);

	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DPLCF_CreateInstance"

STDMETHODIMP DPLCF_CreateInstance(IDirectPlayLobbyClassFact *pInterface,
								  LPUNKNOWN lpUnkOuter,
								  REFIID riid,
								  LPVOID *ppv)
{
	HRESULT					hResultCode = S_OK;
	LPINTERFACE_LIST		lpIntList = NULL;
	LPOBJECT_DATA			lpObjectData = NULL;

	DPFX(DPFPREP, 3,"Parameters: pInterface [0x%p], lpUnkOuter [0x%p], riid [0x%p], ppv [0x%p]",pInterface,lpUnkOuter,riid,ppv);

	if (lpUnkOuter != NULL)
		return(CLASS_E_NOAGGREGATION);

	if ((lpObjectData = (LPOBJECT_DATA)DNMalloc(sizeof(OBJECT_DATA))) == NULL)
	{
		DPFERR("DNMalloc() failed");
		return(E_OUTOFMEMORY);
	}
	DPFX(DPFPREP, 5,"lpObjectData [%p]",lpObjectData);

	// Object creation and initialization
	if ((hResultCode = DPLCF_CreateObject(pInterface,&lpObjectData->lpvData,riid)) != S_OK)
	{
		DNFree(lpObjectData);
		return(hResultCode);
	}
	DPFX(DPFPREP, 5,"Created and initialized object");

	// Get requested interface
	if ((hResultCode = DPL_CreateInterface(lpObjectData,riid,&lpIntList)) != S_OK)
	{
		DPLCF_FreeObject(lpObjectData->lpvData);
		DNFree(lpObjectData);
		return(hResultCode);
	}
	DPFX(DPFPREP, 5,"Found interface");

	lpObjectData->lpIntList = lpIntList;
	lpObjectData->lRefCount = 1;
	InterlockedIncrement( &lpIntList->lRefCount );
	GdwHObjects++;
	*ppv = lpIntList;

	DPFX(DPFPREP, 3,"Returning: hResultCode = [%lx], *ppv = [%p]",hResultCode,*ppv);

	return(S_OK);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DPLCF_LockServer"

STDMETHODIMP DPLCF_LockServer(IDirectPlayLobbyClassFact *pInterface,
							  BOOL bLock)
{
	DPFX(DPFPREP, 3,"Parameters: lpv [%p], bLock [%lx]",pInterface,bLock);

	if (bLock)
	{
		GdwHLocks++;
	}
	else
	{
		GdwHLocks--;
	}

	return(S_OK);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DPL_CreateInterface"

static	HRESULT DPL_CreateInterface(LPOBJECT_DATA lpObject,
									REFIID riid,
									LPINTERFACE_LIST *const ppv)
{
	LPINTERFACE_LIST	lpIntNew;
	LPVOID				lpVtbl;

	DPFX(DPFPREP, 3,"Parameters: lpObject [%p], riid [%p], ppv [%p]",lpObject,riid,ppv);

	if (IsEqualIID(riid,IID_IUnknown))
	{
		DPFX(DPFPREP, 5,"riid = IID_IUnknown");
		lpVtbl = &DN_UnknownVtbl;
	}
	else if (IsEqualIID(riid,IID_IDirectPlay8LobbyClient))
	{
		DPFX(DPFPREP, 5,"riid = IID_IDirectPlay8LobbyClient");
		lpVtbl = &DPL_Lobby8ClientVtbl;
	}
	else if (IsEqualIID(riid,IID_IDirectPlay8LobbiedApplication))
	{
		DPFX(DPFPREP, 5,"riid = IID_IDirectPlay8LobbiedApplication");
		lpVtbl = &DPL_8LobbiedApplicationVtbl;
	}
	else
	{
		DPFX(DPFPREP, 5,"riid not found !");
		return(E_NOINTERFACE);
	}

	if ((lpIntNew = (LPINTERFACE_LIST)DNMalloc(sizeof(INTERFACE_LIST))) == NULL)
	{
		DPFERR("DNMalloc() failed");
		return(E_OUTOFMEMORY);
	}
	lpIntNew->lpVtbl = lpVtbl;
	lpIntNew->lRefCount = 0;
	lpIntNew->lpIntNext = NULL;
	DBG_CASSERT( sizeof( lpIntNew->iid ) == sizeof( riid ) );
	memcpy( &(lpIntNew->iid), &riid, sizeof( lpIntNew->iid ) );
	lpIntNew->lpObject = lpObject;

	*ppv = lpIntNew;

	DPFX(DPFPREP, 3,"Returning: hResultCode = [S_OK], *ppv = [%p]",*ppv);

	return(S_OK);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DPL_FindInterface"

LPINTERFACE_LIST DPL_FindInterface(LPVOID lpv, REFIID riid)
{
	LPINTERFACE_LIST	lpIntList;

	DPFX(DPFPREP, 3,"Parameters: lpv [%p], riid [%p]",lpv,riid);

	lpIntList = ((LPINTERFACE_LIST)lpv)->lpObject->lpIntList;	// Find first interface

	while (lpIntList != NULL)
	{
		if (IsEqualIID(riid,lpIntList->iid))
			break;
		lpIntList = lpIntList->lpIntNext;
	}
	DPFX(DPFPREP, 3,"Returning: lpIntList = [%p]",lpIntList);

	return(lpIntList);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DPL_QueryInterface"

STDMETHODIMP DPL_QueryInterface(LPVOID lpv,REFIID riid,LPVOID *ppv)
{
	LPINTERFACE_LIST	lpIntList;
	LPINTERFACE_LIST	lpIntNew;
	HRESULT		hResultCode;
    PDIRECTPLAYLOBBYOBJECT pdpLobbyObject;		

	DPFX(DPFPREP, 3,"Parameters: lpv [0x%p], riid [0x%p], ppv [0x%p]",lpv,riid,ppv);

	TRY
	{
    	pdpLobbyObject = static_cast<DIRECTPLAYLOBBYOBJECT*>(GET_OBJECT_FROM_INTERFACE(lpv));
   		lpIntList = (LPINTERFACE_LIST)lpv;
	    
    	if( FAILED( hResultCode = DPL_ValidateQueryInterface( lpv,riid,ppv ) ) )
    	{
    	    DPFX(DPFPREP,  0, "Error validating QueryInterface params hr=[0x%lx]", hResultCode );
    	    DPF_RETURN(hResultCode);
    	}

    	if( pdpLobbyObject->dwFlags & DPL_OBJECT_FLAG_LOBBIEDAPPLICATION && 
    	    riid == IID_IDirectPlay8LobbyClient )
    	{
    	    DPFERR( "Cannot request lobbyclient interface from lobbyapp object" );
    	    return DPNERR_NOINTERFACE;
    	}
    	
    	if( pdpLobbyObject->dwFlags & DPL_OBJECT_FLAG_LOBBYCLIENT &&
    	    riid == IID_IDirectPlay8LobbiedApplication )
    	{
    	    DPFERR( "Cannot request lobbied application interface from lobbyclient object" );
    	    return DPNERR_NOINTERFACE;
    	}    	
    	
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
    	DPF_RETURN(DPNERR_INVALIDOBJECT);
	}		

    if ((lpIntList = DPL_FindInterface(lpv,riid)) == NULL)
	{	// Interface must be created
		lpIntList = ((LPINTERFACE_LIST)lpv)->lpObject->lpIntList;
		if ((hResultCode = DPL_CreateInterface(lpIntList->lpObject,riid,&lpIntNew)) != S_OK)
		{
			DPF_RETURN(hResultCode);
		}
		lpIntNew->lpIntNext = lpIntList;
		((LPINTERFACE_LIST)lpv)->lpObject->lpIntList = lpIntNew;
		lpIntList = lpIntNew;
	}
	if (lpIntList->lRefCount == 0)		// New interface exposed
	{
		InterlockedIncrement( &lpIntList->lpObject->lRefCount );
	}
	InterlockedIncrement( &lpIntList->lRefCount );
	*ppv = lpIntList;

	DPF_RETURN(S_OK);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DPL_AddRef"

STDMETHODIMP_(ULONG) DPL_AddRef(LPVOID lpv)
{
	LPINTERFACE_LIST	lpIntList;
    PDIRECTPLAYLOBBYOBJECT pdpLobbyObject;	
    HRESULT hResultCode;

	DPFX(DPFPREP, 3,"Parameters: lpv [%p]",lpv);

	TRY
	{
    	pdpLobbyObject = static_cast<DIRECTPLAYLOBBYOBJECT*>(GET_OBJECT_FROM_INTERFACE(lpv));
   		lpIntList = (LPINTERFACE_LIST)lpv;
	    
    	if( FAILED( hResultCode = DPL_ValidateAddRef( lpv ) ) )
    	{
    	    DPFX(DPFPREP,  0, "Error validating AddRef params hr=[0x%lx]", hResultCode );
    	    DPF_RETURN(0);
    	}
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
    	DPF_RETURN(0);
	}		

	InterlockedIncrement( &lpIntList->lRefCount );

	DPF_RETURN(lpIntList->lRefCount);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DPL_Release"

STDMETHODIMP_(ULONG) DPL_Release(LPVOID lpv)
{
	LPINTERFACE_LIST	lpIntList;
	LPINTERFACE_LIST	lpIntCurrent;
    PDIRECTPLAYLOBBYOBJECT pdpLobbyObject;
    HRESULT hResultCode;

	DPFX(DPFPREP, 3,"Parameters: lpv [%p]",lpv);

	TRY
	{
    	pdpLobbyObject = static_cast<DIRECTPLAYLOBBYOBJECT*>(GET_OBJECT_FROM_INTERFACE(lpv));
   		lpIntList = (LPINTERFACE_LIST)lpv;
	    
    	if( FAILED( hResultCode = DPL_ValidateRelease( lpv ) ) )
    	{
    	    DPFX(DPFPREP,  0, "Error validating release params hr=[0x%lx]", hResultCode );
        	DPF_RETURN(0);
    	}
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
    	DPF_RETURN(0);
	}	

	DPFX(DPFPREP, 5,"Original : lpIntList->lRefCount = %ld",lpIntList->lRefCount);
	DPFX(DPFPREP, 5,"Original : lpIntList->lpObject->lRefCount = %ld",lpIntList->lpObject->lRefCount);

	if( InterlockedDecrement( &lpIntList->lRefCount ) == 0 )
	{	// Decrease interface count
		if( InterlockedDecrement( &lpIntList->lpObject->lRefCount ) == 0 )
		{	// Free object and all interfaces
			DPFX(DPFPREP, 5,"Free object");

			if( pdpLobbyObject->pReceiveQueue )
			{
			    DPFX(DPFPREP,  0, "*******************************************************************" );
			    DPFX(DPFPREP,  0, "ERROR: Releasing object without calling close!" );
			    DPFX(DPFPREP,  0, "You MUST call Close before destroying the object" );
			    DPFX(DPFPREP,  0, "*******************************************************************" );
			    
			    DPL_Close( lpv, 0 );
			}

			// Free object here
			DPLCF_FreeObject(lpIntList->lpObject->lpvData);
			lpIntList = lpIntList->lpObject->lpIntList;	// Get head of interface list
			DPFX(DPFPREP, 5,"lpIntList->lpObject [%p]",lpIntList->lpObject);
			DNFree(lpIntList->lpObject);

			// Free Interfaces
			DPFX(DPFPREP, 5,"Free interfaces");
			while(lpIntList != NULL)
			{
				lpIntCurrent = lpIntList;
				lpIntList = lpIntList->lpIntNext;
				DPFX(DPFPREP, 5,"\tinterface [%p]",lpIntCurrent);
				DNFree(lpIntCurrent);
			}

			GdwHObjects--;
			DPFX(DPFPREP, 3,"Returning: 0");
			return(0);
		}
	}

	DPFX(DPFPREP, 3,"Returning: lpIntList->lRefCount = [%lx]",lpIntList->lRefCount);

	DPF_RETURN(lpIntList->lRefCount);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\lobby\dplclient.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DNLClient.cpp
 *  Content:    DirectNet Lobby Client Functions
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  02/21/00	mjn		Created
 *  03/22/2000	jtk		Changed interface names
 *	04/05/2000	jtk		Changed GetValueSize to GetValueLength
 *  04/13/00	rmt     First pass param validation 
 *  04/25/2000	rmt     Bug #s 33138, 33145, 33150 
 *	04/26/00	mjn		Removed dwTimeOut from Send() API call
 *  05/01/2000  rmt     Bug #33678 
 *  05/03/00    rmt     Bug #33879 -- Status messsage missing from field 
 *  05/30/00    rmt     Bug #35618 -- ConnectApp with ShortTimeout returns DPN_OK
 *  06/07/00    rmt     Bug #36452 -- Calling ConnectApplication twice could result in disconnection
 *  06/15/00    rmt     Bug #33617 - Must provide method for providing automatic launch of DirectPlay instances  
 *  07/06/00	rmt		Updated for new registry parameters
 *  07/08/2000	rmt		Bug #38725 - Need to provide method to detect if app was lobby launched
 *				rmt		Bug #38757 - Callback messages for connections may return AFTER WaitForConnection returns
 *				rmt		Bug #38755 - No way to specify player name in Connection Settings
 *				rmt		Bug #38758 - DPLOBBY8.H has incorrect comments
 *				rmt		Bug #38783 - pvUserApplicationContext is only partially implemented
 *				rmt		Added DPLHANDLE_ALLCONNECTIONS and dwFlags (reserved field to couple of funcs).
 *  07/14/2000	rmt		Bug #39257 - LobbyClient::ReleaseApp returns E_OUTOFMEMORY when called when no one connected
 *  07/21/2000	rmt		Bug #39578 - LobbyClient sample errors and quits -- memory corruption due to length vs. size problem
 *  08/05/2000  RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *  12/15/2000	rmt		Bug #48445 - Specifying empty launcher name results in error
 * 	04/19/2001	simonpow	Bug #369842 - Altered CreateProcess calls to take app name and cmd
 *							line as 2 separate arguments rather than one.
 *  06/16/2001	rodtoll	WINBUG #416983 -  RC1: World has full control to HKLM\Software\Microsoft\DirectPlay\Applications on Personal
 *						Implementing mirror of keys into HKCU.  Algorithm is now:
 *						- Read of entries tries HKCU first, then HKLM
 *						- Enum of entires is combination of HKCU and HKLM entries with duplicates removed.  HKCU takes priority.
 *						- Write of entries is HKLM and HKCU.  (HKLM may fail, but is ignored).
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dnlobbyi.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

typedef STDMETHODIMP ClientQueryInterface(IDirectPlay8LobbyClient *pInterface,REFIID ridd,PVOID *ppvObj);
typedef STDMETHODIMP_(ULONG)	ClientAddRef(IDirectPlay8LobbyClient *pInterface);
typedef STDMETHODIMP_(ULONG)	ClientRelease(IDirectPlay8LobbyClient *pInterface);
typedef STDMETHODIMP ClientRegisterMessageHandler(IDirectPlay8LobbyClient *pInterface,const PVOID pvUserContext,const PFNDPNMESSAGEHANDLER pfn,const DWORD dwFlags);
typedef	STDMETHODIMP ClientSend(IDirectPlay8LobbyClient *pInterface,const DPNHANDLE hTarget,BYTE *const pBuffer,const DWORD pBufferSize,const DWORD dwFlags);
typedef STDMETHODIMP ClientClose(IDirectPlay8LobbyClient *pInterface,const DWORD dwFlags);
typedef STDMETHODIMP ClientGetConnectionSettings(IDirectPlay8LobbyClient *pInterface, const DPNHANDLE hLobbyClient, DPL_CONNECTION_SETTINGS * const pdplSessionInfo, DWORD *pdwInfoSize, const DWORD dwFlags );	
typedef STDMETHODIMP ClientSetConnectionSettings(IDirectPlay8LobbyClient *pInterface, const DPNHANDLE hTarget, const DPL_CONNECTION_SETTINGS * const pdplSessionInfo, const DWORD dwFlags );

IDirectPlay8LobbyClientVtbl DPL_Lobby8ClientVtbl =
{
	(ClientQueryInterface*)			DPL_QueryInterface,
	(ClientAddRef*)					DPL_AddRef,
	(ClientRelease*)				DPL_Release,
	(ClientRegisterMessageHandler*)	DPL_RegisterMessageHandlerClient,
									DPL_EnumLocalPrograms,
									DPL_ConnectApplication,
	(ClientSend*)					DPL_Send,
									DPL_ReleaseApplication,
	(ClientClose*)					DPL_Close,
	(ClientGetConnectionSettings*)  DPL_GetConnectionSettings,
	(ClientSetConnectionSettings*)  DPL_SetConnectionSettings
};


//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************

#define DPL_ENUM_APPGUID_BUFFER_INITIAL			8
#define DPL_ENUM_APPGUID_BUFFER_GROWBY			4	

#undef DPF_MODNAME
#define DPF_MODNAME "DPL_EnumLocalPrograms"

STDMETHODIMP DPL_EnumLocalPrograms(IDirectPlay8LobbyClient *pInterface,
								   GUID *const pGuidApplication,
								   BYTE *const pEnumData,
								   DWORD *const pdwEnumDataSize,
								   DWORD *const pdwEnumDataItems,
								   const DWORD dwFlags )
{
	HRESULT			hResultCode;
	CMessageQueue	MessageQueue;
	CPackedBuffer	PackedBuffer;
	CRegistry		RegistryEntry;
	CRegistry		SubEntry;
	DWORD			dwSizeRequired;
	DWORD			dwMaxKeyLen;
	PWSTR			pwszKeyName = NULL;

	// Application name variables
	PWSTR			pwszApplicationName = NULL;
	DWORD			dwMaxApplicationNameLength;		// Includes null terminator
	DWORD			dwApplicationNameLength;		// Includes null terminator

	// Executable name variables
	PWSTR			pwszExecutableFilename = NULL;
	DWORD			dwMaxExecutableFilenameLength; // Includes null terminator
	DWORD			dwExecutableFilenameLength;	   // Includes null terminator

	DWORD			*pdwPID;
	DWORD			dwMaxPID;
	DWORD			dwNumPID;
	DWORD			dwEnumIndex;
	DWORD			dwEnumCount;
	DWORD			dwKeyLen;
	DWORD			dw;
	DPL_APPLICATION_INFO	dplAppInfo;
	DIRECTPLAYLOBBYOBJECT	*pdpLobbyObject;
	GUID			*pAppLoadedList = NULL;			// List of GUIDs of app's we've enumerated
	DWORD			dwSizeAppLoadedList = 0;		// size of list pAppLoadedList
	DWORD			dwLengthAppLoadedList = 0;		// # of elements in list

	HKEY			hkCurrentBranch = HKEY_LOCAL_MACHINE;

	DPFX(DPFPREP, 3,"Parameters: pInterface [0x%p], pGuidApplication [0x%p], pEnumData [0x%p], pdwEnumDataSize [0x%p], pdwEnumDataItems [0x%p], dwFlags [0x%lx]",
			pInterface,pGuidApplication,pEnumData,pdwEnumDataSize,pdwEnumDataItems,dwFlags);

	TRY
	{
    	pdpLobbyObject = static_cast<DIRECTPLAYLOBBYOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
	    
    	if( pdpLobbyObject->dwFlags & DPL_OBJECT_FLAG_PARAMVALIDATION )
    	{
        	if( FAILED( hResultCode = DPL_ValidateEnumLocalPrograms( pInterface, pGuidApplication, pEnumData, pdwEnumDataSize, pdwEnumDataItems, dwFlags ) ) )
        	{
        	    DPFX(DPFPREP,  0, "Error validating enum local programs params hr=[0x%lx]", hResultCode );
        	    DPF_RETURN( hResultCode );
        	}
    	}

    	// Ensure we've been initialized
    	if (pdpLobbyObject->pReceiveQueue == NULL)
    	{
    		DPFERR("Not initialized");
    		DPF_RETURN(DPNERR_UNINITIALIZED);
    	}    	
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}		

	dwSizeRequired = *pdwEnumDataSize;
	PackedBuffer.Initialize(pEnumData,dwSizeRequired);
	pwszApplicationName = NULL;
	pwszExecutableFilename = NULL;
	pdwPID = NULL;
	dwMaxPID = 0;

	dwLengthAppLoadedList = 0;
	dwSizeAppLoadedList = DPL_ENUM_APPGUID_BUFFER_INITIAL;
	pAppLoadedList = static_cast<GUID*>(DNMalloc(sizeof(GUID)*dwSizeAppLoadedList));

	if( !pAppLoadedList )
	{
	    DPFERR("Failed allocating memory" );	
	    hResultCode = DPNERR_OUTOFMEMORY;
		goto EXIT_DPL_EnumLocalPrograms;
	}

	dwEnumCount = 0;

	for( DWORD dwIndex = 0; dwIndex < 2; dwIndex++ )
	{
		if( dwIndex == 0 )
		{
			hkCurrentBranch = HKEY_CURRENT_USER;
		}
		else
		{
			hkCurrentBranch = HKEY_LOCAL_MACHINE;
		}
		
		if (!RegistryEntry.Open(hkCurrentBranch,DPL_REG_LOCAL_APPL_SUBKEY,TRUE,FALSE,TRUE,DPL_REGISTRY_READ_ACCESS))
		{
			DPFX(DPFPREP,1,"On pass %i could not find app key", dwIndex);
			continue;
		}

		// Set up to enumerate
		if (!RegistryEntry.GetMaxKeyLen(dwMaxKeyLen))
		{
			DPFERR("RegistryEntry.GetMaxKeyLen() failed");
			hResultCode = DPNERR_GENERIC;
			goto EXIT_DPL_EnumLocalPrograms;
		}
		dwMaxKeyLen++;	// Null terminator
		DPFX(DPFPREP, 7,"dwMaxKeyLen = %ld",dwMaxKeyLen);
		if ((pwszKeyName = static_cast<WCHAR*>(DNMalloc(dwMaxKeyLen*sizeof(WCHAR)))) == NULL)
		{
			DPFERR("DNMalloc() failed");
			hResultCode = DPNERR_OUTOFMEMORY;
			goto EXIT_DPL_EnumLocalPrograms;
		}
		dwMaxApplicationNameLength = dwMaxKeyLen * sizeof(WCHAR);
		dwMaxExecutableFilenameLength = dwMaxApplicationNameLength;		

		if ((pwszApplicationName = static_cast<WCHAR*>(DNMalloc(dwMaxApplicationNameLength*sizeof(WCHAR)))) == NULL)	// Seed Application name size
		{
			DPFERR("DNMalloc() failed");
			hResultCode = DPNERR_OUTOFMEMORY;
			goto EXIT_DPL_EnumLocalPrograms;
		}
		if ((pwszExecutableFilename = static_cast<WCHAR*>(DNMalloc(dwMaxExecutableFilenameLength*sizeof(WCHAR)))) == NULL)
		{
			DPFERR("DNMalloc() failed");
			hResultCode = DPNERR_OUTOFMEMORY;
			goto EXIT_DPL_EnumLocalPrograms;
		}
		dwEnumIndex = 0;
		dwKeyLen = dwMaxKeyLen;

		// Enumerate !
		while (RegistryEntry.EnumKeys(pwszKeyName,&dwKeyLen,dwEnumIndex))
		{
			DPFX(DPFPREP, 7,"%ld - %S (%ld)",dwEnumIndex,pwszKeyName,dwKeyLen);

			// Get Application name and GUID from each sub key
			if (!SubEntry.Open(RegistryEntry,pwszKeyName,TRUE,FALSE))
			{
				DPFX(DPFPREP, 7,"skipping %S",pwszKeyName);
				goto LOOP_END;
			}

			//
			// Minara, double-check size vs. length for names
			//
			if (!SubEntry.GetValueLength(DPL_REG_KEYNAME_APPLICATIONNAME,&dwApplicationNameLength))
			{
				DPFX(DPFPREP, 7,"Could not get ApplicationName size.  Skipping [%S]",pwszKeyName);
				goto LOOP_END;
			}

			// To include null terminator
			dwApplicationNameLength++;

			if (dwApplicationNameLength > dwMaxApplicationNameLength)
			{
				// grow buffer (taking into account that the reg functions always return WCHAR) and try again
				DPFX(DPFPREP, 7,"Need to grow pwszApplicationName from %ld to %ld",dwMaxApplicationNameLength,dwApplicationNameLength);
				if (pwszApplicationName != NULL)
				{
					DNFree(pwszApplicationName);
					pwszApplicationName = NULL;
				}
				if ((pwszApplicationName = static_cast<WCHAR*>(DNMalloc(dwApplicationNameLength*sizeof(WCHAR)))) == NULL)
				{
					DPFERR("DNMalloc() failed");
					hResultCode = DPNERR_OUTOFMEMORY;
					goto EXIT_DPL_EnumLocalPrograms;
				}
				dwMaxApplicationNameLength = dwApplicationNameLength;
			}

			if (!SubEntry.ReadString(DPL_REG_KEYNAME_APPLICATIONNAME,pwszApplicationName,&dwApplicationNameLength))
			{
				DPFX(DPFPREP, 7,"Could not read ApplicationName.  Skipping [%S]",pwszKeyName);
				goto LOOP_END;
			}

			DPFX(DPFPREP, 7,"ApplicationName = %S (%ld WCHARs)",pwszApplicationName,dwApplicationNameLength);

			if (!SubEntry.ReadGUID(DPL_REG_KEYNAME_GUID,dplAppInfo.guidApplication))
			{
				DPFERR("SubEntry.ReadGUID failed - skipping entry");
				goto LOOP_END;
			}

			for( DWORD dwGuidSearchIndex = 0; dwGuidSearchIndex < dwLengthAppLoadedList; dwGuidSearchIndex++ )
			{
				if( pAppLoadedList[dwGuidSearchIndex] == dplAppInfo.guidApplication )
				{
					DPFX(DPFPREP, 1, "Ignoring local machine entry for current user version of entry [%S]", pwszApplicationName );
					goto LOOP_END;
				}
			}

			if ((pGuidApplication == NULL) || (*pGuidApplication == dplAppInfo.guidApplication))
			{
				// Get process count - need executable filename
				
				//
				// Minara, check size vs. length
				//
				if (!SubEntry.GetValueLength(DPL_REG_KEYNAME_EXECUTABLEFILENAME,&dwExecutableFilenameLength))
				{
					DPFX(DPFPREP, 7,"Could not get ExecutableFilename size.  Skipping [%S]",pwszKeyName);
					goto LOOP_END;
				}

				// So we include null terminator
				dwExecutableFilenameLength++;

				if (dwExecutableFilenameLength > dwMaxExecutableFilenameLength)
				{
					// grow buffer (noting that all strings from the registry are WCHAR) and try again
					DPFX(DPFPREP, 7,"Need to grow pwszExecutableFilename from %ld to %ld",dwMaxExecutableFilenameLength,dwExecutableFilenameLength);
					if (pwszExecutableFilename != NULL)
					{
						DNFree(pwszExecutableFilename);
						pwszExecutableFilename = NULL;
					}
					if ((pwszExecutableFilename = static_cast<WCHAR*>(DNMalloc(dwExecutableFilenameLength*sizeof(WCHAR)))) == NULL)
					{
						DPFERR("DNMalloc() failed");
						hResultCode = DPNERR_OUTOFMEMORY;
						goto EXIT_DPL_EnumLocalPrograms;
					}
					dwMaxExecutableFilenameLength = dwExecutableFilenameLength;
				}
				if (!SubEntry.ReadString(DPL_REG_KEYNAME_EXECUTABLEFILENAME,pwszExecutableFilename,&dwExecutableFilenameLength))
				{
					DPFX(DPFPREP, 7,"Could not read ExecutableFilename.  Skipping [%S]",pwszKeyName);
					goto LOOP_END;
				}
				DPFX(DPFPREP, 7,"ExecutableFilename [%S]",pwszExecutableFilename);

				// Count running apps
				dwNumPID = dwMaxPID;
				while ((hResultCode = DPLGetProcessList(pwszExecutableFilename,pdwPID,&dwNumPID,
						pdpLobbyObject->bIsUnicodePlatform)) == DPNERR_BUFFERTOOSMALL)
				{
					if (pdwPID)
					{
						DNFree(pdwPID);
						pdwPID = NULL;
					}
					dwMaxPID = dwNumPID;
					if ((pdwPID = static_cast<DWORD*>(DNMalloc(dwNumPID*sizeof(DWORD)))) == NULL)
					{
						DPFERR("DNMalloc() failed");
						hResultCode = DPNERR_OUTOFMEMORY;
						goto EXIT_DPL_EnumLocalPrograms;
					}
				}
				if (hResultCode != DPN_OK)
				{
					DPFERR("DPLGetProcessList() failed");
					DisplayDNError(0,hResultCode);
					hResultCode = DPNERR_GENERIC;
					goto EXIT_DPL_EnumLocalPrograms;
				}

				// Count waiting apps
				dplAppInfo.dwNumWaiting = 0;
				for (dw = 0 ; dw < dwNumPID ; dw++)
				{
					if ((hResultCode = MessageQueue.Open(	pdwPID[dw],
															DPL_MSGQ_OBJECT_SUFFIX_APPLICATION,
															DPL_MSGQ_SIZE,
															DPL_MSGQ_OPEN_FLAG_NO_CREATE, INFINITE)) == DPN_OK)
					{
						if (MessageQueue.IsAvailable())
						{
							dplAppInfo.dwNumWaiting++;
						}
						MessageQueue.Close();
					}
				}

				hResultCode = PackedBuffer.AddWCHARStringToBack(pwszApplicationName);
				dplAppInfo.pwszApplicationName = (PWSTR)(PackedBuffer.GetTailAddress());
				dplAppInfo.dwFlags = 0;
				dplAppInfo.dwNumRunning = dwNumPID;
				hResultCode = PackedBuffer.AddToFront(&dplAppInfo,sizeof(DPL_APPLICATION_INFO));

				if( dwLengthAppLoadedList+1 > dwSizeAppLoadedList )
				{
					GUID *pTmpArray = NULL;
					
					pTmpArray  = static_cast<GUID*>(DNMalloc(sizeof(GUID)*(dwSizeAppLoadedList+DPL_ENUM_APPGUID_BUFFER_GROWBY)));

					if( !pTmpArray )
					{
						DPFERR("DNMalloc() failed");
						hResultCode = DPNERR_OUTOFMEMORY;
						goto EXIT_DPL_EnumLocalPrograms;					
					}

					memcpy( pTmpArray, pAppLoadedList, sizeof(GUID)*dwLengthAppLoadedList);

					dwSizeAppLoadedList += DPL_ENUM_APPGUID_BUFFER_GROWBY;				
					
					DNFree(pAppLoadedList);
					pAppLoadedList = pTmpArray;
				}

				pAppLoadedList[dwLengthAppLoadedList] = dplAppInfo.guidApplication;
				dwLengthAppLoadedList++;

	    		dwEnumCount++;
			}

		LOOP_END:
			SubEntry.Close();
			dwEnumIndex++;
			dwKeyLen = dwMaxKeyLen;
		}

		RegistryEntry.Close();

		if( pwszKeyName )
		{
			DNFree(pwszKeyName);
			pwszKeyName= NULL;
		}

		if( pwszApplicationName )
		{
			DNFree(pwszApplicationName);
			pwszApplicationName = NULL;
		}

		if( pwszExecutableFilename )
		{
			DNFree(pwszExecutableFilename);
			pwszExecutableFilename = NULL;
		}
	}

	dwSizeRequired = PackedBuffer.GetSizeRequired();
	if (dwSizeRequired > *pdwEnumDataSize)
	{
		DPFX(DPFPREP, 7,"Buffer too small");
		*pdwEnumDataSize = dwSizeRequired;
		hResultCode = DPNERR_BUFFERTOOSMALL;
	}
	else
	{
		*pdwEnumDataItems = dwEnumCount;
	}

	if( pGuidApplication != NULL && dwEnumCount == 0 )
	{
	    DPFX(DPFPREP,  0, "Specified application was not registered" );
        hResultCode = DPNERR_DOESNOTEXIST;
	}

EXIT_DPL_EnumLocalPrograms:

	if (pwszKeyName != NULL)
		DNFree(pwszKeyName);
	if (pwszApplicationName != NULL)
		DNFree(pwszApplicationName);
	if (pwszExecutableFilename != NULL)
		DNFree(pwszExecutableFilename);
	if (pdwPID != NULL)
		DNFree(pdwPID);
	if( pAppLoadedList )
		DNFree(pAppLoadedList);

	DPF_RETURN(hResultCode);
}



//	DPL_ConnectApplication
//
//	Try to connect to a lobbied application.  Based on DPL_CONNECT_INFO flags,
//	we may have to launch an application.
//
//	If we have to launch an application, we will need to handshake the PID of the
//	application (as it may be ripple launched).  We will pass the LobbyClient's PID on the
//	command line to the application launcher and expect it to be passed down to the
//	application.  The application will open a named shared memory block using the PID and
//	write its PID there, and then signal a named event (using the LobbyClient's PID again).
//	When the waiting LobbyClient is signaled by this event, it continues its connection
//	process as if this was an existing running and available application.

#undef DPF_MODNAME
#define DPF_MODNAME "DPL_ConnectApplication"

STDMETHODIMP DPL_ConnectApplication(IDirectPlay8LobbyClient *pInterface,
									DPL_CONNECT_INFO *const pdplConnectInfo,
									void *pvConnectionContext,
									DPNHANDLE *const hApplication,
									const DWORD dwTimeOut,
									const DWORD dwFlags)
{
	HRESULT			hResultCode = DPN_OK;
	DWORD			dwSize = 0;
	BYTE			*pBuffer = NULL;
	DPL_PROGRAM_DESC	*pdplProgramDesc;
	DWORD			*pdwProcessList = NULL;
	DWORD			dwNumProcesses = 0;
	DWORD			dwPID = 0;
	DWORD			dw = 0;
	DPNHANDLE		handle = NULL;
	DPL_CONNECTION	*pdplConnection = NULL;
	DIRECTPLAYLOBBYOBJECT	*pdpLobbyObject = NULL;

	DPFX(DPFPREP, 3,"Parameters: pdplConnectInfo [0x%p], pvUserAppContext [0x%p], hApplication [0x%lx], dwFlags [0x%lx]",
			pdplConnectInfo,pvConnectionContext,hApplication,dwFlags);

	TRY
	{
    	pdpLobbyObject = static_cast<DIRECTPLAYLOBBYOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
	    
    	if( pdpLobbyObject->dwFlags & DPL_OBJECT_FLAG_PARAMVALIDATION )
    	{
        	if( FAILED( hResultCode = DPL_ValidateConnectApplication( pInterface, pdplConnectInfo, pvConnectionContext, hApplication, dwTimeOut, dwFlags ) ) )
        	{
        	    DPFX(DPFPREP,  0, "Error validating connect application params hr=[0x%lx]", hResultCode );
        	    DPF_RETURN( hResultCode );
        	}
    	}

    	// Ensure we've been initialized
    	if (pdpLobbyObject->pReceiveQueue == NULL)
    	{
    		DPFERR("Not initialized");
    		DPF_RETURN(DPNERR_UNINITIALIZED);
    	}    	
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}		

	// Get program description
	dwSize = 0;
	pBuffer = NULL;
	hResultCode = DPLGetProgramDesc(&pdplConnectInfo->guidApplication,pBuffer,&dwSize);
	if (hResultCode != DPNERR_BUFFERTOOSMALL)
	{
		DPFERR("Could not get Program Description");
		goto EXIT_DPL_ConnectApplication;
	}
	if ((pBuffer = static_cast<BYTE*>(DNMalloc(dwSize))) == NULL)
	{
		DPFERR("Could not allocate space for buffer");
		hResultCode = DPNERR_OUTOFMEMORY;
		goto EXIT_DPL_ConnectApplication;
	}
	if ((hResultCode = DPLGetProgramDesc(&pdplConnectInfo->guidApplication,pBuffer,&dwSize)) != DPN_OK)
	{
		DPFERR("Could not get Program Description");
		DisplayDNError(0,hResultCode);
		goto EXIT_DPL_ConnectApplication;
	}

	pdplProgramDesc = reinterpret_cast<DPL_PROGRAM_DESC*>(pBuffer);
	dwPID = 0;
	dwNumProcesses = 0;
	pdwProcessList = NULL;

	if (!(pdplConnectInfo->dwFlags & DPLCONNECT_LAUNCHNEW))	// Only if not forcing launch
	{
		// Get process list
		hResultCode = DPLGetProcessList(pdplProgramDesc->pwszExecutableFilename,NULL,&dwNumProcesses,
				pdpLobbyObject->bIsUnicodePlatform);
		if (hResultCode != DPN_OK && hResultCode != DPNERR_BUFFERTOOSMALL)
		{
			DPFERR("Could not retrieve process list");
			DisplayDNError(0,hResultCode);
			goto EXIT_DPL_ConnectApplication;			
		}
		if (hResultCode == DPNERR_BUFFERTOOSMALL)
		{
			if ((pdwProcessList = static_cast<DWORD*>(DNMalloc(dwNumProcesses*sizeof(DWORD)))) == NULL)
			{
				DPFERR("Could not create process list buffer");
				hResultCode = DPNERR_OUTOFMEMORY;
    			goto EXIT_DPL_ConnectApplication;				
			}
			if ((hResultCode = DPLGetProcessList(pdplProgramDesc->pwszExecutableFilename,pdwProcessList,
					&dwNumProcesses,pdpLobbyObject->bIsUnicodePlatform)) != DPN_OK)
			{
				DPFERR("Could not get process list");
				DisplayDNError(0,hResultCode);
    			goto EXIT_DPL_ConnectApplication;				
			}

		}

		// Try to connect to an already running application
		for (dw = 0 ; dw < dwNumProcesses ; dw++)
		{
			if ((hResultCode = DPLMakeApplicationUnavailable(pdwProcessList[dw])) == DPN_OK)
			{
				DPFX(DPFPREP, 1, "Found Existing Process=%d", pdwProcessList[dw] );				
				dwPID = pdwProcessList[dw];
				break;
			}
		}

		if (pdwProcessList)
		{
			DNFree(pdwProcessList);
			pdwProcessList = NULL;
		}
	}

	// Launch application if none are ready to connect
	if ((dwPID == 0) && (pdplConnectInfo->dwFlags & (DPLCONNECT_LAUNCHNEW | DPLCONNECT_LAUNCHNOTFOUND)))
	{
		if ((hResultCode = DPLLaunchApplication(pdpLobbyObject,pdplProgramDesc,&dwPID,dwTimeOut)) != DPN_OK)
		{
			DPFERR("Could not launch application");
			DisplayDNError(0,hResultCode);
			goto EXIT_DPL_ConnectApplication;
		}
		else
		{
			DPFX(DPFPREP, 1, "Launched process dwID=%d", dwPID );
		}
	}

	if (dwPID  == 0)	// Could not make any connection
	{
		DPFERR("Could not connect to an existing application or launch a new one");
		hResultCode = DPNERR_NOCONNECTION;
		DisplayDNError( 0, hResultCode );
		goto EXIT_DPL_ConnectApplication;
	}

	handle = NULL;

	// Create connection
	if ((hResultCode = DPLConnectionNew(pdpLobbyObject,&handle,&pdplConnection)) != DPN_OK)
	{
		DPFERR("Could not create connection entry");
		DisplayDNError(0,hResultCode);
		goto EXIT_DPL_ConnectApplication;
	}

	pdplConnection->dwTargetPID = dwPID;

	DPFX(DPFPREP,  0, "PID=%d", dwPID );

	// Set the context for this connection
	if ((hResultCode = DPLConnectionSetContext( pdpLobbyObject, handle, pvConnectionContext )) != DPN_OK )
	{
		DPFERR( "Could not set contect for connection" );
		DisplayDNError(0,hResultCode);
		goto EXIT_DPL_ConnectApplication;
	}

	// Connect to selected application instance
	if ((hResultCode = DPLConnectionConnect(pdpLobbyObject,handle,dwPID,TRUE)) != DPN_OK)
	{
		DPFERR("Could not connect to application");
		DisplayDNError(0,hResultCode);
		goto EXIT_DPL_ConnectApplication;
	}

	ResetEvent(pdplConnection->hConnectEvent);

	// Pass lobby client info to application

	if ((hResultCode = DPLConnectionSendREQ(pdpLobbyObject,handle,pdpLobbyObject->dwPID,
			pdplConnectInfo)) != DPN_OK)
	{
		DPFERR("Could not send connection request");
		DisplayDNError(0,hResultCode);
		goto EXIT_DPL_ConnectApplication;
	}

	if (WaitForSingleObject(pdplConnection->hConnectEvent,INFINITE) != WAIT_OBJECT_0)
	{
		DPFERR("Wait for connection terminated");
		hResultCode = DPNERR_GENERIC;
		goto EXIT_DPL_ConnectApplication;
	}

	*hApplication = handle;

	hResultCode = DPN_OK;	

EXIT_DPL_ConnectApplication:

    if( FAILED(hResultCode) && handle )
    {
		DPLConnectionDisconnect(pdpLobbyObject,handle);
		DPLConnectionRelease(pdpLobbyObject,handle);
    }

	if (pBuffer)
		DNFree(pBuffer);

	if (pdwProcessList)
		DNFree(pdwProcessList);	

	DPF_RETURN(hResultCode);
}



#undef DPF_MODNAME
#define DPF_MODNAME "DPL_ReleaseApplication"

STDMETHODIMP DPL_ReleaseApplication(IDirectPlay8LobbyClient *pInterface,
									const DPNHANDLE hApplication, 
									const DWORD dwFlags )
{
	HRESULT		hResultCode;
	DIRECTPLAYLOBBYOBJECT	*pdpLobbyObject;
	DPNHANDLE				*hTargets = NULL;
	DWORD					dwNumTargets = 0;
	DWORD					dwTargetIndex = 0;

	DPFX(DPFPREP, 3,"Parameters: hApplication [0x%lx]",hApplication);

	TRY
	{
    	pdpLobbyObject = static_cast<DIRECTPLAYLOBBYOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
	    
    	if( pdpLobbyObject->dwFlags & DPL_OBJECT_FLAG_PARAMVALIDATION )
    	{
        	if( FAILED( hResultCode = DPL_ValidateReleaseApplication( pInterface, hApplication, dwFlags ) ) )
        	{
        	    DPFX(DPFPREP,  0, "Error validating release application params hr=[0x%lx]", hResultCode );
        	    DPF_RETURN( hResultCode );
        	}
    	}

    	// Ensure we've been initialized
    	if (pdpLobbyObject->pReceiveQueue == NULL)
    	{
    		DPFERR("Not initialized");
    		DPF_RETURN(DPNERR_UNINITIALIZED);
    	}    	
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}	

	if( hApplication == DPLHANDLE_ALLCONNECTIONS )
	{
		dwNumTargets = 0;

		// We need loop so if someone adds a connection during our run
		// it gets added to our list
		//
		while( 1 )
		{
			hResultCode = DPLConnectionEnum( pdpLobbyObject, hTargets, &dwNumTargets );

			if( hResultCode == DPNERR_BUFFERTOOSMALL )
			{
				if( hTargets )
				{
					delete [] hTargets;
				}

				hTargets = new DPNHANDLE[dwNumTargets];

				if( hTargets == NULL )
				{
					DPFERR("Error allocating memory" );
					hResultCode = DPNERR_OUTOFMEMORY;
					dwNumTargets = 0;
					goto EXIT_AND_CLEANUP;
				}

				memset( hTargets, 0x00, sizeof(DPNHANDLE)*dwNumTargets);

				continue;
			}
			else if( FAILED( hResultCode ) )
			{
				DPFX(DPFPREP,  0, "Error getting list of connections hr=0x%x", hResultCode );
				break;
			}
			else
			{
				break;
			}
		}

		// Failed getting connection information
		if( FAILED( hResultCode ) )
		{
			if( hTargets )
			{
				delete [] hTargets;
				hTargets = NULL;
			}
			dwNumTargets = 0;
			goto EXIT_AND_CLEANUP;
		}

	}
	else
	{
		hTargets = new DPNHANDLE[1]; // We use array delete below so we need array new

		if( hTargets == NULL )
		{
			DPFERR("Error allocating memory" );
			hResultCode = DPNERR_OUTOFMEMORY;
			dwNumTargets = 0;
			goto EXIT_AND_CLEANUP;
		}

		dwNumTargets = 1;
		hTargets[0] = hApplication;
	}
		
	for( dwTargetIndex = 0; dwTargetIndex < dwNumTargets; dwTargetIndex++ )
	{
		hResultCode = DPLConnectionDisconnect(pdpLobbyObject,hTargets[dwTargetIndex]);

		if( FAILED( hResultCode ) )
		{
			DPFX(DPFPREP,  0, "Error disconnecting connection 0x%x hr=0x%x", hTargets[dwTargetIndex], hResultCode );
		}
	}

EXIT_AND_CLEANUP:

	if( hTargets )
		delete [] hTargets;

	DPF_RETURN(hResultCode);
}


//	DPLLaunchApplication
//
//	Launch the application with a command-line argument of:
//		DPLID=PIDn	PID=Lobby Client PID, n=launch counter (each launch increases it)
//	Wait for the application to signal the event (or die)

#undef DPF_MODNAME
#define DPF_MODNAME "DPLLaunchApplication"

HRESULT	DPLLaunchApplication(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
							 DPL_PROGRAM_DESC *const pdplProgramDesc,
							 DWORD *const pdwPID,
							 const DWORD dwTimeOut)
{
	HRESULT			hResultCode;
	DWORD			dwAppNameLen=0;		//Length of the application full name (path+exe)
	PWSTR			pwszAppName=NULL;	//Unicode version of application full name
	DWORD			dwCmdLineLen=0;		//Length of the command line string
	PWSTR			pwszCmdLine=NULL;	//Unicode version of command line to supply 	
	CHAR *			pszAppName=NULL;	//Ascii version of application full name
	CHAR *			pszCmdLine=NULL;		//Acii version of command line string
	LONG			lc;
	STARTUPINFOW	siW;			// Unicode startup info (place holder)
	STARTUPINFOA    siA;
	PROCESS_INFORMATION pi;
	DWORD			dwError;
	HANDLE			hSyncEvents[2] = { NULL, NULL };
	WCHAR			pwszObjectName[(sizeof(DWORD)*2)*2 + 1];
	CHAR			pszObjectName[(sizeof(DWORD)*2)*2 + 1 + 1];
	DPL_SHARED_CONNECT_BLOCK	*pSharedBlock = NULL;
	HANDLE			hFileMap = NULL;
	DWORD			dwPID;
	CHAR            *pszDefaultDir = NULL;
	WCHAR			*wszToLaunchPath = NULL;
	WCHAR			*wszToLaunchExecutable = NULL;
	DWORD			dwToLaunchPathLen;


	// Are we launching the launcher or the executable?
	if( !pdplProgramDesc->pwszLauncherFilename || wcslen(pdplProgramDesc->pwszLauncherFilename) == 0 )
	{
		wszToLaunchPath = pdplProgramDesc->pwszExecutablePath; 
		wszToLaunchExecutable = pdplProgramDesc->pwszExecutableFilename;
	}
	else
	{ 
		wszToLaunchPath = pdplProgramDesc->pwszLauncherPath; 
		wszToLaunchExecutable = pdplProgramDesc->pwszLauncherFilename;		
	}

	DPFX(DPFPREP, 3,"Parameters: pdplProgramDesc [0x%p]",pdplProgramDesc);

	DNASSERT(pdplProgramDesc != NULL);

	// Increment launch count
	lc = InterlockedIncrement(&pdpLobbyObject->lLaunchCount);

	// Synchronization event and shared memory names
	swprintf(pwszObjectName,L"%lx%lx",pdpLobbyObject->dwPID,lc);
	sprintf(pszObjectName,"-%lx%lx",pdpLobbyObject->dwPID,lc);

	// Compute the size of the full application name string (combination of path and exe name)
	if (wszToLaunchPath)
		dwAppNameLen += (wcslen(wszToLaunchPath) + 1);
	if (wszToLaunchExecutable)
		dwAppNameLen += (wcslen(wszToLaunchExecutable) + 1);

	// Compute the size of the command line string
	dwCmdLineLen=dwAppNameLen+1;
	if (pdplProgramDesc->pwszCommandLine)
		dwCmdLineLen += wcslen(pdplProgramDesc->pwszCommandLine);
	dwCmdLineLen += (1 + wcslen(DPL_ID_STR_W) + (sizeof(DWORD)*2*2) + 1);

	DPFX(DPFPREP, 5,"Application full name string length [%ld] WCHARs", dwAppNameLen);
	DPFX(DPFPREP, 5,"Command Line string length [%ld] WCHARs", dwCmdLineLen);

	// Allocate memory to hold the full app name and command line + check allocation was OK
	pwszAppName=static_cast<WCHAR *>(DNMalloc(dwAppNameLen * sizeof(WCHAR)));
	pwszCmdLine=static_cast<WCHAR *>(DNMalloc(dwCmdLineLen * sizeof(WCHAR)));
	if (pwszAppName==NULL || pwszCmdLine==NULL)
	{
		DPFERR("Could not allocate strings for app name and command line");
		hResultCode = DPNERR_OUTOFMEMORY;
		goto CLEANUP_DPLLaunch;		
	}

	// Build the application full name by combining launch path with exe name
	*pwszAppName = L'\0';
	if (wszToLaunchPath)
	{
		dwToLaunchPathLen = wcslen(wszToLaunchPath);
		if (dwToLaunchPathLen > 0)
		{
			wcscat(pwszAppName,wszToLaunchPath);
			if (wszToLaunchPath[dwToLaunchPathLen - 1] != L'\\')
	 		{
				wcscat(pwszAppName,L"\\");
			}
		}
	}
	if (wszToLaunchExecutable)
	{
		wcscat(pwszAppName,wszToLaunchExecutable);
	}

	//Build the command line from app name, program description and the lobby related parameters
	wcscpy(pwszCmdLine, pwszAppName);
	wcscat(pwszCmdLine,L" ");
	if (pdplProgramDesc->pwszCommandLine)
	{
		wcscat(pwszCmdLine,pdplProgramDesc->pwszCommandLine);
		wcscat(pwszCmdLine,L" ");
	}
	wcscat(pwszCmdLine,DPL_ID_STR_W);
	wcscat(pwszCmdLine,pwszObjectName);

	DPFX(DPFPREP, 5,"Application full name string [%S]",pwszAppName);
	DPFX(DPFPREP, 5,"Command Line string [%S]",pwszCmdLine);


	// Create shared connect block to receive Application's PID
	*pszObjectName = DPL_MSGQ_OBJECT_IDCHAR_FILEMAP;
	hFileMap = CreateFileMappingA(INVALID_HANDLE_VALUE,(LPSECURITY_ATTRIBUTES) NULL,
		PAGE_READWRITE,(DWORD)0,sizeof(DPL_SHARED_CONNECT_BLOCK),pszObjectName);
	if (hFileMap == NULL)
	{
		dwError = GetLastError();
		DPFX(DPFPREP, 0, "CreateFileMapping() failed dwLastError [0x%lx]", dwError );
		hResultCode = DPNERR_CANTLAUNCHAPPLICATION;
		goto CLEANUP_DPLLaunch;		
	}

	// Map file
	pSharedBlock = reinterpret_cast<DPL_SHARED_CONNECT_BLOCK*>(MapViewOfFile(hFileMap,FILE_MAP_ALL_ACCESS,0,0,0));
	if (pSharedBlock == NULL)
	{
		dwError = GetLastError();	    
		DPFX(DPFPREP, 0,"MapViewOfFile() failed dwLastError [0x%lx]", dwError);
		hResultCode = DPNERR_CANTLAUNCHAPPLICATION;
		goto CLEANUP_DPLLaunch;
	}

	// Create synchronization event
	*pszObjectName = DPL_MSGQ_OBJECT_IDCHAR_EVENT;
	if ((hSyncEvents[0] = CreateEventA(NULL,TRUE,FALSE,pszObjectName)) == NULL)
	{
		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Create Event Failed dwLastError [0x%lx]", dwError );
		hResultCode = DPNERR_CANTLAUNCHAPPLICATION;
        goto CLEANUP_DPLLaunch;
	}

	if( DNGetOSType() == VER_PLATFORM_WIN32_NT )
	{
        	// More setup
        	siW.cb = sizeof(STARTUPINFO);
        	siW.lpReserved = NULL;
        	siW.lpDesktop = NULL;
        	siW.lpTitle = NULL;
        	siW.dwFlags = 0;
        	siW.cbReserved2 = 0;
        	siW.lpReserved2 = NULL;	    
        	
        	// Launch !
        	if (CreateProcessW(pwszAppName, pwszCmdLine, NULL,NULL,FALSE,NORMAL_PRIORITY_CLASS,NULL,
        			pdplProgramDesc->pwszCurrentDirectory,&siW,&pi) == 0)
        	{
        		dwError = GetLastError();
        		DPFX(DPFPREP,  0, "CreateProcess Failed dwLastError [0x%lx]", dwError );
        		hResultCode = DPNERR_CANTLAUNCHAPPLICATION;
        		goto CLEANUP_DPLLaunch;
        	}
	}
	else
	{
        	// More setup
        	siA.cb = sizeof(STARTUPINFO);
        	siA.lpReserved = NULL;
        	siA.lpDesktop = NULL;
        	siA.lpTitle = NULL;
        	siA.dwFlags = 0;
        	siA.cbReserved2 = 0;
        	siA.lpReserved2 = NULL;	    

        	DPFX(DPFPREP,  1, "Detected 9x, Doing Ansi launch" );

		//Convert full app name, command line and default dir from unicode to ascii format
        	if( FAILED( hResultCode = STR_AllocAndConvertToANSI( &pszAppName, pwszAppName ) ) )
        	{
        	    dwError = GetLastError();
        	    DPFX(DPFPREP,  0, "String conversion failed dwError = [0x%lx]", dwError );
        	    hResultCode = DPNERR_CONVERSION;
        	    goto CLEANUP_DPLLaunch;
        	}
		if( FAILED( hResultCode = STR_AllocAndConvertToANSI( &pszCmdLine, pwszCmdLine ) ) )
        	{
        	    dwError = GetLastError();
        	    DPFX(DPFPREP,  0, "String conversion failed dwError = [0x%lx]", dwError );
        	    hResultCode = DPNERR_CONVERSION;
        	    goto CLEANUP_DPLLaunch;
        	}
        	if( FAILED( hResultCode = STR_AllocAndConvertToANSI( &pszDefaultDir, pdplProgramDesc->pwszCurrentDirectory ) ) )
        	{
        	    dwError = GetLastError();
        	    DPFX(DPFPREP,  0, "String conversion failed dwError = [0x%lx]", dwError );
        	    hResultCode = DPNERR_CONVERSION;
        	    goto CLEANUP_DPLLaunch;
        	}

        	// Launch !
        	if (CreateProcessA(pszAppName,pszCmdLine,NULL,NULL,FALSE,NORMAL_PRIORITY_CLASS,NULL,
        			pszDefaultDir,&siA,&pi) == 0)
        	{
        		dwError = GetLastError();
        		DPFX(DPFPREP,  0, "CreateProcess Failed dwLastError [0x%lx]", dwError );
        		hResultCode = DPNERR_CANTLAUNCHAPPLICATION;
        		goto CLEANUP_DPLLaunch;
        	}	    
	}
	
	hSyncEvents[1] = pi.hProcess;

	// Wait for connection or application termination
	dwError = WaitForMultipleObjects(2,hSyncEvents,FALSE,dwTimeOut);

	// Immediately clean up
	dwPID = pSharedBlock->dwPID;
/*	CloseHandle(hSyncEvents[0]);
	UnmapViewOfFile(pSharedBlock);
	CloseHandle(hFileMap); */

	// Ensure we can continue
	if (dwError - WAIT_OBJECT_0 > 1)
	{
		if (dwError == WAIT_TIMEOUT)
		{
			DPFERR("Wait for application connection timed out");
			hResultCode = DPNERR_TIMEDOUT;
            goto CLEANUP_DPLLaunch;			
		}
		else
		{
			DPFERR("Wait for application connection terminated mysteriously");
			hResultCode = DPNERR_CANTLAUNCHAPPLICATION;
            goto CLEANUP_DPLLaunch;			
		}
	}

	// Check if application terminated
	if (dwError == 1)
	{
		DPFERR("Application was terminated");
		hResultCode = DPNERR_CANTLAUNCHAPPLICATION;
        goto CLEANUP_DPLLaunch;
	}

	*pdwPID = dwPID;

	hResultCode = DPN_OK;

CLEANUP_DPLLaunch:

    if( hSyncEvents[0] != NULL )
        CloseHandle( hSyncEvents[0] );

    if( pSharedBlock != NULL )
    	UnmapViewOfFile(pSharedBlock);

    if( hFileMap != NULL )
        CloseHandle( hFileMap );

    if( pwszAppName != NULL )
        DNFree( pwszAppName );

    if (pwszCmdLine!=NULL)
        DNFree( pwszCmdLine );

    if( pszAppName != NULL )
        delete[] pszAppName;

    if (pszCmdLine!=NULL)
        delete[] pszCmdLine;

    if( pszDefaultDir != NULL )
        delete [] pszDefaultDir;

    DPF_RETURN(hResultCode);
}

HRESULT DPLUpdateAppStatus(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
                           const DPNHANDLE hSender, 
						   BYTE *const pBuffer)
{
	HRESULT		hResultCode;
	DPL_INTERNAL_MESSAGE_UPDATE_STATUS	*pStatus;
	DPL_MESSAGE_SESSION_STATUS			MsgStatus;

	DPFX(DPFPREP, 3,"Parameters: pBuffer [0x%p]",pBuffer);

	DNASSERT(pdpLobbyObject != NULL);
	DNASSERT(pBuffer != NULL);

	pStatus = reinterpret_cast<DPL_INTERNAL_MESSAGE_UPDATE_STATUS*>(pBuffer);

	MsgStatus.dwSize = sizeof(DPL_MESSAGE_SESSION_STATUS);
	MsgStatus.dwStatus = pStatus->dwStatus;
	MsgStatus.hSender = hSender;

	// Return code is irrelevant, at this point we're going to indicate regardless
	hResultCode = DPLConnectionGetContext( pdpLobbyObject, hSender, &MsgStatus.pvConnectionContext );

	if( FAILED( hResultCode ) )
	{
		DPFX(DPFPREP,  0, "Error getting connection context for 0x%x hr=0x%x", hSender, hResultCode );
	}

	hResultCode = (pdpLobbyObject->pfnMessageHandler)(pdpLobbyObject->pvUserContext,
													  DPL_MSGID_SESSION_STATUS,
													  reinterpret_cast<BYTE*>(&MsgStatus));

	DPFX(DPFPREP, 3,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}

// ----------------------------------------------------------------------------
#if 0

//	HRESULT	DNL_RegisterLcMessageHandler
//		LPVOID					lpv			Interface pointer
//		LPFNDNLCMESSAGEHANDLER	lpfn		Pointer to user supplied lobby client message handler function
//		DWORD					dwFlags		Not Used
//
//	Returns
//		DPN_OK					If the message handler was registered without incident
//		DPNERR_INVALIDPARAM		If there was an invalid parameter
//		DPNERR_GENERIC			If there were any problems
//
//	Notes
//		This function registers a user supplied lobby client message handler function.  This function should
//		only be called once, when the lobby client is launched.
//
//		This will set up the required message queues, and spawn the lobby client's receive message queue thread.



//	HRESULT	DNL_EnumLocalPrograms
//		LPVOID		lpv					Interface pointer
//		LPGUID		lpGuidApplication	GUID of application to enumerate (optional)
//		LPVOID		lpvEnumData			Buffer to be filled with DNAPPINFO structs and Unicode strings
//		LPDWORD		lpdwEnumData		Size of lpvEnumData and number of bytes needed on return
//		LPDWORD		lpdwItems			Number of DNAPPINFO structs in lpvEnumData
//
//	Returns
//		DPN_OK					If the key was added successfully
//		DPNERR_INVALIDPARAM		If there was a problem with a parameter
//		DPNERR_OUTOFMEMORY		If it could not allocate memory
//		DPNERR_DOESNOTEXIST		If there was a problem opening reading a registry key
//
//	Notes
//		- This is ugly because of the need to support both WinNT and Win9x at runtime.
//		WinNT registry is kept in Unicode, whereas Win9x is in ANSI.  Application root key
//		names should be ANSI compatible (or their GUIDs are used instead) i.e. Will be stored
//		in Unicode under WinNT, but only if convertable to ANSI
//		- Strings are placed in the buffer, starting at the end of the buffer and working
//		backwards.
//		- In most cases, errors will cause the current app being enumerated to be ignored
//		and not included in the enumeration buffer.



//	HRESULT	DNL_ConnectApplication
//		LPVOID				lpv							Interface pointer
//		LPDNCONNECTINFO		lpdnConnectionInfo			Pointer to connection info structure
//		LPVOID				lpvUserApplicationContext	User supplied application context value
//		LPDWORD				lpdwAppId					Pointer to receive application ID (handle) in
//		DWORD				dwFlags						Flags
//
//	Returns
//		DPN_OK					If the application was connected to without incident
//		DPNERR_INVALIDPARAM		If there was an invalid parameter
//		DPNERR_OUTOFMEMORY		If there were any memory allocation problems
//		DPNERR_GENERIC			If there were any problems
//
//	Notes
//		This function connects the lobby client to a user specified application.  If successfull, the
//		DNLobby assigned application ID will be returned in lpdwAppId.

#undef DPF_MODNAME
#define DPF_MODNAME "DNL_ConnectApplication"

STDMETHODIMP DNL_ConnectApplication(LPVOID lpv,LPDNCONNECTINFO lpdnConnectionInfo,
					LPVOID lpvUserApplicationContext,LPDWORD lpdwAppId, DWORD dwFlags)
{
	LPDIRECTPLAYLOBBYOBJECT	lpdnLobbyObject;
	HRESULT			hResultCode = DPN_OK;
	DNPROGRAMDESC	dnProgramDesc;					// Program descriptor for launching applications
	DWORD			dwNumApps;						// Number of applications currently running
	LPDWORD			lpdwProcessList = NULL;			// Pointer to process list
	DWORD			dwProcessId;					// Process ID of target applications
	DWORD			dw;								// Counter
	DWORD			dwStrLen;						// Various string lengths
	LPWSTR			lpwszCommandLine = NULL;		// Expanded Unicode command line
	LPWSTR			lpwszCurrentDirectory = NULL;	// Expanded Unicode current directory
	LPSTR			lpszCommandLine = NULL;			// Expanded ANSI command line
	LPSTR			lpszCurrentDirectory = NULL;	// Expanded ANSI current directory
	LPWSTR			lpwszUnexpanded = NULL;			// Unexpanded command line
	LPSTR			lpszUnexpanded = NULL;			// Unexpanded ANSI strings converted from Unicode
	STARTUPINFOA	siA;							// ANSI startup info (place holder)
	STARTUPINFOW	siW;							// Unicode startup info (place holder)
	PROCESS_INFORMATION pi;
	UUID			uuid;
	RPC_STATUS		rpcStatus;
	DWORD			dwHandle;
	LPDN_APP_HANDLE_ENTRY lpdnAppHandleEntry;
	LPDN_MESSAGE_STRUCT	lpdnMsg = NULL;

	DPFX(DPFPREP, 9,"Parameters: lpv [%p], lpdnConnectionInfo [%p], lpvUserApplicationContext [%p], lpdwAppId [%p], dwFlags [%lx]",
		lpv,lpdnConnectionInfo,lpvUserApplicationContext,lpdwAppId,dwFlags);

	// Parameter validation
	TRY
	{
		if (lpv == NULL || lpdnConnectionInfo == NULL || lpdwAppId == NULL)
			return(DPNERR_INVALIDPARAM);
	}
	EXCEPT (EXCEPTION_EXECUTE_HANDLER)
	{
		DPFERR("Exception encountered validating parameters");
		return(DPNERR_INVALIDPARAM);
	}

	lpdnLobbyObject = (LPDIRECTPLAYLOBBYOBJECT) GET_OBJECT_FROM_INTERFACE(lpv);

	//	Get program description from registry
	if ((hResultCode = DnGetProgramDesc(lpdnConnectionInfo->lpGuidApplication,&dnProgramDesc))
			!= DPN_OK)
	{
		goto EXIT_DNL_ConnectApplication;
	}

	hResultCode = DnGetProcessListW(dnProgramDesc.lpwszFilename,NULL,&dwNumApps);	// Num apps
	if (hResultCode != DPN_OK && hResultCode != DPNERR_BUFFERTOOSMALL)
	{
		DnFreeProgramDesc(&dnProgramDesc);
		goto EXIT_DNL_ConnectApplication;
	}
	while (hResultCode == DPNERR_BUFFERTOOSMALL)	// New processes may get launched !
	{
		if (lpdwProcessList != NULL)
			GlobalFree(lpdwProcessList);

		if ((lpdwProcessList = (LPDWORD)GLOBALALLOC(dwNumApps*sizeof(DWORD))) == NULL)
		{
			hResultCode = DPNERR_OUTOFMEMORY;
			DnFreeProgramDesc(&dnProgramDesc);
			goto EXIT_DNL_ConnectApplication;
		}
		hResultCode = DnGetProcessListW(dnProgramDesc.lpwszFilename,lpdwProcessList,&dwNumApps);
	}

	if (hResultCode != DPN_OK)	// Some sort of error occurred
	{
		DnFreeProgramDesc(&dnProgramDesc);
		goto EXIT_DNL_ConnectApplication;
	}

	dwProcessId = 0;
	for (dw = 0; dw < dwNumApps ; dw++)
	{
		if (DnCheckMsgQueueWaiting(lpdwProcessList[dw]))
		{
			if (DnSetMsgQueueWaiting(lpdwProcessList[dw],FALSE,TRUE) == DPN_OK)
			{
				// This is the process ID of the existing app to connect to !
				dwProcessId = lpdwProcessList[dw];
				break;
			}
		}
	}

	if (dwProcessId == 0)	// Could not find an app to connect to - launch a new one
	{
		dwStrLen = wcslen(dnProgramDesc.lpwszPath) + 1
				+ wcslen(dnProgramDesc.lpwszApplicationLauncher) + 1
				+ wcslen(dnProgramDesc.lpwszCommandLine) + 1 + DN_LC_ID_STR_LEN + DN_GUID_STR_LEN + 1;
		if ((lpwszUnexpanded = (LPWSTR)GLOBALALLOC(dwStrLen*sizeof(WCHAR))) == NULL)
		{
			DnFreeProgramDesc(&dnProgramDesc);
			hResultCode = DPNERR_OUTOFMEMORY;
			goto EXIT_DNL_ConnectApplication;
		}

		*lpwszUnexpanded = L'\0';
		if (wcslen(dnProgramDesc.lpwszPath) > 0)
		{
			wcscpy(lpwszUnexpanded,dnProgramDesc.lpwszPath);
			wcscat(lpwszUnexpanded,L"\\");
		}
		wcscat(lpwszUnexpanded,dnProgramDesc.lpwszApplicationLauncher);
		wcscat(lpwszUnexpanded,L" ");
		wcscat(lpwszUnexpanded,dnProgramDesc.lpwszCommandLine);
		wcscat(lpwszUnexpanded,L" ");
		wcscat(lpwszUnexpanded,DN_LC_ID_WSTR);
		rpcStatus = CoCreateGuid(&uuid);
		if (rpcStatus != RPC_S_OK && rpcStatus != RPC_S_UUID_LOCAL_ONLY)
		{
			DnFreeProgramDesc(&dnProgramDesc);
			hResultCode = DPNERR_GENERIC;
			goto EXIT_DNL_ConnectApplication;
		}
		StringFromGUID(&uuid,lpwszUnexpanded+wcslen(lpwszUnexpanded),DN_GUID_STR_LEN+1);

		if (DN_RUNNING_NT)	// Unicode on WinNT
		{
			// Expand environment strings
			if ((hResultCode = DnExpandEnvStringW(lpwszUnexpanded,&lpwszCommandLine)) != DPN_OK)
			{
				DPFX(DPFPREP, 0,"DnExpandEnvStringW() failed [%lX]",hResultCode);
				DnFreeProgramDesc(&dnProgramDesc);
				goto EXIT_DNL_ConnectApplication;
			}
			if ((hResultCode = DnExpandEnvStringW(dnProgramDesc.lpwszCurrentDirectory,
					&lpwszCurrentDirectory)) != DPN_OK)
			{
				DPFX(DPFPREP, 0,"DnExpandEnvStringW() failed [%lX]",hResultCode);
				DnFreeProgramDesc(&dnProgramDesc);
				goto EXIT_DNL_ConnectApplication;
			}

			// Set up to Launch application
			siW.cb = sizeof(STARTUPINFO);
			siW.lpReserved = NULL;
			siW.lpDesktop = NULL;
			siW.lpTitle = NULL;
			siW.dwFlags = (DWORD)NULL;
			siW.cbReserved2 = (BYTE)NULL;
			siW.lpReserved2 = NULL;

			// Launch application (finally !)
			if (CreateProcessW(NULL,lpwszCommandLine,NULL,NULL,FALSE,NORMAL_PRIORITY_CLASS,NULL,
					lpwszCurrentDirectory,&siW,&pi) == 0)
			{
				hResultCode = DPNERR_CANTLAUNCHAPPLICATION;
				DnFreeProgramDesc(&dnProgramDesc);
				goto EXIT_DNL_ConnectApplication;
			}
		}
		else	// ANSI on Win9x
		{
			// Convert command line from Unicode to ANSI
			if ((lpszUnexpanded = (LPSTR)GLOBALALLOC(dwStrLen)) == NULL)
			{
				DnFreeProgramDesc(&dnProgramDesc);
				hResultCode = DPNERR_OUTOFMEMORY;
				goto EXIT_DNL_ConnectApplication;
			}
			WideToAnsi(lpszUnexpanded,lpwszUnexpanded,dwStrLen);
			DPFX(DPFPREP, 7,"Unexpanded Command Line [%s]",lpszUnexpanded);

			// Expand command line environment strings
			if ((hResultCode = DnExpandEnvStringA(lpszUnexpanded,&lpszCommandLine)) != DPN_OK)
			{
				DPFX(DPFPREP, 0,"DnExpandEnvStringA() failed [%lX]",hResultCode);
				DnFreeProgramDesc(&dnProgramDesc);
				goto EXIT_DNL_ConnectApplication;
			}
			DPFX(DPFPREP, 7,"Expanded Command Line [%s]",lpszCommandLine);

			// Convert current directory from Unicode to ANSI
			GlobalFree(lpszUnexpanded);
			lpszUnexpanded = NULL;
			dwStrLen = wcslen(dnProgramDesc.lpwszCurrentDirectory);
			if ((lpszUnexpanded = (LPSTR)GLOBALALLOC(dwStrLen+1)) == NULL)
			{
				DnFreeProgramDesc(&dnProgramDesc);
				hResultCode = DPNERR_OUTOFMEMORY;
				goto EXIT_DNL_ConnectApplication;
			}
			WideToAnsi(lpszUnexpanded,dnProgramDesc.lpwszCurrentDirectory,dwStrLen+1);
			DPFX(DPFPREP, 7,"Unexpanded Current Directory [%s]",lpszUnexpanded);

			// Expand current directory environment strings
			if ((hResultCode = DnExpandEnvStringA(lpszUnexpanded,&lpszCurrentDirectory)) != DPN_OK)
			{
				DPFX(DPFPREP, 0,"DnExpandEnvStringA() failed [%lX]",hResultCode);
				DnFreeProgramDesc(&dnProgramDesc);
				goto EXIT_DNL_ConnectApplication;
			}
			DPFX(DPFPREP, 7,"Expanded Current Directory [%s]",lpszCurrentDirectory);

			// Set up to Launch application
			siA.cb = sizeof(STARTUPINFO);
			siA.lpReserved = NULL;
			siA.lpDesktop = NULL;
			siA.lpTitle = NULL;
			siA.dwFlags = (DWORD)NULL;
			siA.cbReserved2 = (BYTE)NULL;
			siA.lpReserved2 = NULL;

			// Launch application (finally !)
			if (CreateProcessA(NULL,lpszCommandLine,NULL,NULL,FALSE,NORMAL_PRIORITY_CLASS,NULL,
					lpszCurrentDirectory,&siA,&pi) == 0)
			{
				DPFERR("CreateProcess() failed !");
				hResultCode = DPNERR_CANTLAUNCHAPPLICATION;
				DnFreeProgramDesc(&dnProgramDesc);
				goto EXIT_DNL_ConnectApplication;
			}
		}
		// Get Application Process ID
		if ((hResultCode = DnHandShakeAppPid(TRUE,&uuid,&dwProcessId)) != DPN_OK)
		{
			DPFERR("Hand shake to retrieve App PID failed !");
			DnFreeProgramDesc(&dnProgramDesc);
			goto EXIT_DNL_ConnectApplication;
		}
		DPFX(DPFPREP, 0,"Application PID = [0x%08lX]",dwProcessId);
	}
	DnFreeProgramDesc(&dnProgramDesc);

	// Create application handle
	if ((lpdnAppHandleEntry = (LPDN_APP_HANDLE_ENTRY)GLOBALALLOC(
			sizeof(DN_APP_HANDLE_ENTRY))) == NULL)
	{
		hResultCode = DPNERR_OUTOFMEMORY;
		goto EXIT_DNL_ConnectApplication;
	}
	lpdnAppHandleEntry->dwAppProcessId = dwProcessId;

	if ((lpdnAppHandleEntry->lpmqSendMsgQueue =
			(DN_MSG_QUEUE_STRUCT *)GLOBALALLOC(sizeof(DN_MSG_QUEUE_STRUCT))) == NULL)
	{
		hResultCode = DPNERR_OUTOFMEMORY;
		goto EXIT_DNL_ConnectApplication;
	}
	if ((hResultCode = CreateHandle(lpdnLobbyObject->lphsApplicationHandles,&dwHandle,lpdnAppHandleEntry)) != DPN_OK)
	{
		goto EXIT_DNL_ConnectApplication;
	}
	lpdnAppHandleEntry->dwHandle = dwHandle;
	lpdnAppHandleEntry->lpvUserApplicationContext = lpvUserApplicationContext;
	*lpdwAppId = dwHandle;

	// Connect to Application's receive message queue
	if ((hResultCode = DnOpenMsgQueue(lpdnAppHandleEntry->lpmqSendMsgQueue,dwProcessId,
			DN_MSG_OBJECT_SUFFIX_APPLICATION,DN_MSG_QUEUE_SIZE,(DWORD)NULL)) != DPN_OK)
	{
		goto EXIT_DNL_ConnectApplication;
	}

	// Pass lobby client connection info to application
	if ((hResultCode = DnSendLcInfo(lpdnAppHandleEntry->lpmqSendMsgQueue,dwHandle,
			GetCurrentProcessId())) != DPN_OK)
	{
		goto EXIT_DNL_ConnectApplication;
	}

	// Pass connection info - TODO check if valid
	DPFX(DPFPREP, 9,"Sending Connection Info ...");

		// Get string lengths
	dwStrLen = ((wcslen(lpdnConnectionInfo->lpwszPlayerName)+ 1 ) * sizeof(WCHAR))
		+ strlen(lpdnConnectionInfo->lpszDNAddressLocalSettings) + 1
		+ strlen(lpdnConnectionInfo->lpszDNAddressRemote) + 1
		+ sizeof(GUID);
	dw = sizeof(DN_MESSAGE_STRUCT) + dwStrLen;

		// Create message
	if ((lpdnMsg = (LPDN_MESSAGE_STRUCT)GLOBALALLOC(dw)) == NULL)
	{
		hResultCode = DPNERR_OUTOFMEMORY;
		goto EXIT_DNL_ConnectApplication;
	}

	lpdnMsg->dwMessageType = DN_MSGTYPE_CONNECTION_SETTINGS;
	lpdnMsg->dwParam1 = 0;
	lpdnMsg->dwParam2 = (wcslen(lpdnConnectionInfo->lpwszPlayerName) + 1) * sizeof(WCHAR);
	lpdnMsg->dwParam3 = lpdnMsg->dwParam2 + strlen(lpdnConnectionInfo->lpszDNAddressRemote) + 1;
	lpdnMsg->dwParam4 = lpdnMsg->dwParam3 + strlen(lpdnConnectionInfo->lpszDNAddressLocalSettings) + 1;
	lpdnMsg->dwTagLen = dwStrLen;

	memcpy(&lpdnMsg->cTags + lpdnMsg->dwParam1,lpdnConnectionInfo->lpwszPlayerName,
		lpdnMsg->dwParam2);
	memcpy(&lpdnMsg->cTags + lpdnMsg->dwParam2,lpdnConnectionInfo->lpszDNAddressRemote,
		lpdnMsg->dwParam3-lpdnMsg->dwParam2);
	memcpy(&lpdnMsg->cTags + lpdnMsg->dwParam3,lpdnConnectionInfo->lpszDNAddressLocalSettings,
		lpdnMsg->dwParam4-lpdnMsg->dwParam3);
	memcpy(&lpdnMsg->cTags + lpdnMsg->dwParam4,lpdnConnectionInfo->lpGuidApplication,
		dwStrLen-lpdnMsg->dwParam4);

	if ((hResultCode = DnSendMsg(lpdnAppHandleEntry->lpmqSendMsgQueue,lpdnMsg,dw,FALSE,
			0)) != DPN_OK)
	{
		GlobalFree(lpdnMsg);
		goto EXIT_DNL_ConnectApplication;
	}

	GlobalFree(lpdnMsg);

EXIT_DNL_ConnectApplication:

	if (lpwszUnexpanded != NULL)
		GlobalFree(lpwszUnexpanded);
	if (lpwszCommandLine != NULL)
		GlobalFree(lpwszCommandLine);
	if (lpwszCurrentDirectory != NULL)
		GlobalFree(lpwszCurrentDirectory);
	if (lpszUnexpanded != NULL)
		GlobalFree(lpszUnexpanded);
	if (lpszCommandLine != NULL)
		GlobalFree(lpszCommandLine);
	if (lpszCurrentDirectory != NULL)
		GlobalFree(lpszCurrentDirectory);
	if (lpdwProcessList != NULL)
		GlobalFree(lpdwProcessList);

	return(hResultCode);
}


//	HRESULT	DnProcessLcMessage
//		LPDIRECTNETLOBBYOBJECT	lpdnLobbyObject		Pointer to lobby object
//		LPVOID					lpvUserHandler		Pointer to user message handler routine
//		LPVOID					lpvMsgBuff			Pointer to message buffer
//		DWORD					dwMsgLen			Length of message buffer
//		DWORD					dwId				Application ID which sent the message
//		LPVOID					lpvContext			User context value associated with the app ID
//
//	Returns
//		DPN_OK					If the message was processed without incident
//		DPNERR_GENERIC			If there were any problems from the user supplied handler
//
//	Notes
//		This function processes messages received by the lobby client from the applications it is connected to.
//		One Lobby Client may be connected to one or more applications.  Internal messages are processed here,
//		and all others are passed to the user supplied message handler.

#undef DPF_MODNAME
#define DPF_MODNAME "DnProcessLcMessage"

HRESULT DnProcessLcMessage(LPDIRECTNETLOBBYOBJECT lpdnLobbyObject,LPVOID lpvUserHandler,
						   LPVOID lpvMsgBuff, DWORD dwMsgLen,DWORD dwId,LPVOID lpvContext)
{
	HRESULT				hResultCode = DPN_OK;
	LPDN_MESSAGE_STRUCT lpdnMsg;

	DPFX(DPFPREP, 9,"Parameters: lpdnLobbyObject [0x%p], lpvUserHandler [0x%p], lpvMsgBuff [0x%p], dwMsgLen [%lx], dwId [%lx], lpvContext [0x%p]",
		lpdnLobbyObject,lpvUserHandler,lpvMsgBuff,dwMsgLen,dwId,lpvContext);

	lpdnMsg = (LPDN_MESSAGE_STRUCT)lpvMsgBuff;

	switch(lpdnMsg->dwMessageType)
	{
	case DN_MSGTYPE_TERMINATE:
		DPFX(DPFPREP, 9,"Received Terminate");
		ExitThread(0);
		break;

	default:		// Pass message to user message handler
		DPFX(DPFPREP, 9,"User Message ...");
		hResultCode = ((LPFNDNLCMESSAGEHANDLER)lpvUserHandler)(dwId,lpvContext,lpdnMsg->dwMessageType,lpdnMsg->dwUserToken,
			lpdnMsg->dwParam1,lpdnMsg->dwParam2,lpdnMsg->dwParam3,lpdnMsg->dwParam4,
			lpdnMsg->dwTagLen,&(lpdnMsg->cTags));
		break;
	}

	return(hResultCode);
}


//	HRESULT	DNL_SendToApplication
//		LPVOID		lpv				Interface pointer
//		DWORD		dwAppId			Application ID to send message to
//		DWORD		dwMessageId		Message ID code
//		DWORD		dwUserToken		User supplied token
//		DWORD		dwParam1		
//		DWORD		dwParam2
//		DWORD		dwParam3
//		DWORD		dwParam4
//		DWORD		dwFlags
//		DWORD		dwTagLen		Length of tags field (in bytes)
//		LPVOID		lpvTags			Tag field
//
//	Returns
//		DPN_OK					If the message was sent without incident
//		DPNERR_INVALIDPARAM		If there was an invalid parameter
//		DPNERR_OUTOFMEMORY		If there were any memory allocation problems
//		DPNERR_GENERIC			If there were any problems
//
//	Notes
//		This function sends messages from the lobby client to a specified application.

#undef DPF_MODNAME
#define DPF_MODNAME "DNL_SendToApplication"

STDMETHODIMP DNL_SendToApplication(LPVOID lpv,DWORD dwAppId,DWORD dwMessageId,DWORD dwUserToken,
							DWORD dwParam1,DWORD dwParam2,DWORD dwParam3,DWORD dwParam4,
							DWORD dwFlags,DWORD dwTagLen,LPVOID lpvTags)
{
	LPDIRECTNETLOBBYOBJECT	lpdnLobbyObject;
	HRESULT					hResultCode = DPN_OK;
	LPDN_APP_HANDLE_ENTRY	lpdnAppHandleEntry;
	LPDN_MESSAGE_STRUCT		lpdnMessage;
	DN_MESSAGE_STRUCT		dnMessage;
	DWORD					dwMsgLen;

	DPFX(DPFPREP, 9,"Parameters: lpv [%p], dwAppId [%lx], dwMessageId [%lx], dwUserToken [%lx], dwParams [%lx], [%lx], [%lx], [%lx], dwFlags [%lx], dwTagLen [%lx], lpvTags [%p]",
		lpv,dwAppId,dwMessageId,dwUserToken,dwParam1,dwParam2,dwParam3,dwParam4,dwFlags,dwTagLen,lpvTags);

	// Parameter validation
	TRY
	{
		if (lpv == NULL || dwAppId == 0)
			return(DPNERR_INVALIDPARAM);
		if (dwFlags != 0)
			return(DPNERR_INVALIDFLAGS);
	}
	EXCEPT (EXCEPTION_EXECUTE_HANDLER)
	{
		DPFERR("Exception encountered validating parameters");
		return(DPNERR_INVALIDPARAM);
	}

	lpdnLobbyObject = (LPDIRECTNETLOBBYOBJECT) GET_OBJECT_FROM_INTERFACE(lpv);

	// Ensure app ID is valid, and then retrieve connection (message queue) information for it
	if (!IsHandleValid(lpdnLobbyObject->lphsApplicationHandles,dwAppId))
	{
		hResultCode = DPNERR_INVALIDPARAM;
		goto EXIT_DNL_SendToApplication;
	}
	if ((hResultCode = RetrieveHandleData(lpdnLobbyObject->lphsApplicationHandles,dwAppId,
			(LPVOID *)&lpdnAppHandleEntry)) != DPN_OK)
	{
		goto EXIT_DNL_SendToApplication;
	}

	dwMsgLen = sizeof(DN_MESSAGE_STRUCT);
	if (dwTagLen > 0)	// Create buffer if there are tags
	{
		dwMsgLen += dwTagLen;
		if ((lpdnMessage = (LPDN_MESSAGE_STRUCT)GLOBALALLOC(dwMsgLen)) == NULL)
		{
			hResultCode = DPNERR_OUTOFMEMORY;
			goto EXIT_DNL_SendToApplication;
		}
	}
	else		// Use default static buffer (avoid malloc call)
	{
		lpdnMessage = &dnMessage;
	}
	lpdnMessage->dwMessageType = dwMessageId;
	lpdnMessage->dwUserToken = dwUserToken;
	lpdnMessage->dwParam1 = dwParam1;
	lpdnMessage->dwParam2 = dwParam2;
	lpdnMessage->dwParam3 = dwParam3;
	lpdnMessage->dwParam4 = dwParam4;
	lpdnMessage->dwTagLen = dwTagLen;
	if (dwTagLen > 0)
	{
		memcpy(&(lpdnMessage->cTags),lpvTags,dwTagLen);
	}
	else
	{
		lpdnMessage->cTags = '\0';
	}

	// Send message
	hResultCode = DnSendMsg(lpdnAppHandleEntry->lpmqSendMsgQueue,lpdnMessage,dwMsgLen,FALSE,
		(DWORD)NULL);

	// Free buffer if it was malloc'd
	if (dwTagLen > 0)
		GlobalFree(lpdnMessage);

EXIT_DNL_SendToApplication:

	return(hResultCode);
}


//	HRESULT	DNL_ReleaseApplication
//		LPVOID		lpv				Interface pointer
//		DWORD		dwAppId			Application ID to release
//
//	Returns
//		DPN_OK					If the message was sent without incident
//		DPNERR_INVALIDPARAM		If there was an invalid parameter
//		DPNERR_INVALIDHANDLE		If the application ID is not valid
//		DPNERR_GENERIC			If there were any problems
//
//	Notes
//		This function causes the lobby client to terminate it's association with a lobbied
//		application (whether the lobby client launched the application or not).  This allows the
//		application to either terminate gracefully (if still running) and then be made available
//		for re-connection to another (or the same) lobby client later.  This should be called
//		whenever a lobby client is finished with a lobbied application.

#undef DPF_MODNAME
#define DPF_MODNAME "DNL_ReleaseApplication"

STDMETHODIMP DNL_ReleaseApplication(LPVOID lpv,DWORD dwAppId)
{
	LPDIRECTNETLOBBYOBJECT	lpdnLobbyObject;
	HRESULT					hResultCode = DPN_OK;
	LPDN_APP_HANDLE_ENTRY	lph;

	DPFX(DPFPREP, 9,"Parameters: lpv [%lx], dwAppId [%lx]", lpv,dwAppId);

	// Parameter validation
	TRY
	{
		if (lpv == NULL || dwAppId == 0)
			return(DPNERR_INVALIDPARAM);
	}
	EXCEPT (EXCEPTION_EXECUTE_HANDLER)
	{
		DPFERR("Exception encountered validating parameters");
		return(DPNERR_INVALIDPARAM);
	}

	lpdnLobbyObject = (LPDIRECTNETLOBBYOBJECT) GET_OBJECT_FROM_INTERFACE(lpv);

	// TODO - wait for messages to be processed

	if ((hResultCode = RetrieveHandleData(lpdnLobbyObject->lphsApplicationHandles,dwAppId,&lph)) == DPN_OK)
	{
		if ((hResultCode = DnCloseMsgQueue(lph->lpmqSendMsgQueue)) == DPN_OK)
		{
			if ((hResultCode = DestroyHandle(lpdnLobbyObject->lphsApplicationHandles,dwAppId)) == DPN_OK)
			{
			}
		}
		GlobalFree(lph);
	}

//EXIT_DNL_ReleaseApplication:

	return(hResultCode);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\lobby\dplconset.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DPLConset.cpp
 *  Content:    DirectPlay Lobby Connection Settings Utility Functions
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   06/13/00   rmt		Created
 *   07/07/00	rmt		Bug #38755 - No way to specify player name in connection settings
 *   07/08/2000	rmt		Bug #38725 - Need to provide method to detect if app was lobby launched
 *				rmt		Bug #38757 - Callback messages for connections may return AFTER WaitForConnection returns
 *				rmt		Bug #38755 - No way to specify player name in Connection Settings
 *				rmt		Bug #38758 - DPLOBBY8.H has incorrect comments
 *				rmt		Bug #38783 - pvUserApplicationContext is only partially implemented
 *				rmt		Added DPLHANDLE_ALLCONNECTIONS and dwFlags (reserved field to couple of funcs).
 *	 07/12/2000	rmt		Removed improper assert
 *  02/06/2001	rodtoll	WINBUG #293871: DPLOBBY8: [IA64] Lobby launching a 64-bit 
 * 						app from 64-bit lobby launcher crashes with unaligned memory error. 
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dnlobbyi.h"


#undef DPF_MODNAME
#define DPF_MODNAME "CConnectionSettings::CConnectionSettings"
CConnectionSettings::CConnectionSettings(): m_dwSignature(DPLSIGNATURE_LOBBYCONSET), m_fManaged(FALSE), m_pdplConnectionSettings(NULL), m_fCritSecInited(FALSE)
{
}

CConnectionSettings::~CConnectionSettings()
{
	if( !m_fManaged && m_pdplConnectionSettings )
	{
		FreeConnectionSettings( m_pdplConnectionSettings );
		m_pdplConnectionSettings = NULL;
	}
	
	if (m_fCritSecInited)
	{
		DNDeleteCriticalSection( &m_csLock );
	}
	m_dwSignature = DPLSIGNATURE_LOBBYCONSET_FREE;
	
}

#undef DPF_MODNAME
#define DPF_MODNAME "CConnectionSettings::FreeConnectionSettings"
// CConnectionSettings::FreeConnectionSettings
//
// This function frees the memory associated with the specified connection
void CConnectionSettings::FreeConnectionSettings( DPL_CONNECTION_SETTINGS *pConnectionSettings )
{
	if( pConnectionSettings ) 
	{
		if( pConnectionSettings->pwszPlayerName )
		{
			delete [] pConnectionSettings->pwszPlayerName;
			pConnectionSettings->pwszPlayerName = NULL;
		}

		if( pConnectionSettings->dpnAppDesc.pwszSessionName )
		{
			delete [] pConnectionSettings->dpnAppDesc.pwszSessionName;
			pConnectionSettings->dpnAppDesc.pwszSessionName = NULL;
		}

		if( pConnectionSettings->dpnAppDesc.pwszPassword )
		{
			delete [] pConnectionSettings->dpnAppDesc.pwszPassword;
			pConnectionSettings->dpnAppDesc.pwszPassword = NULL;
		}

		if( pConnectionSettings->dpnAppDesc.pvReservedData )
		{
			delete [] pConnectionSettings->dpnAppDesc.pvReservedData;
			pConnectionSettings->dpnAppDesc.pvReservedData = NULL;
		}

		if( pConnectionSettings->dpnAppDesc.pvApplicationReservedData )
		{
			delete [] pConnectionSettings->dpnAppDesc.pvApplicationReservedData;
			pConnectionSettings->dpnAppDesc.pvApplicationReservedData = NULL;
		}

		if( pConnectionSettings->pdp8HostAddress )
		{
			pConnectionSettings->pdp8HostAddress->lpVtbl->Release( pConnectionSettings->pdp8HostAddress );
			pConnectionSettings->pdp8HostAddress = NULL;
		}

		if( pConnectionSettings->ppdp8DeviceAddresses )
		{
			for( DWORD dwIndex = 0; dwIndex < pConnectionSettings->cNumDeviceAddresses; dwIndex++ )
			{
				pConnectionSettings->ppdp8DeviceAddresses[dwIndex]->lpVtbl->Release( pConnectionSettings->ppdp8DeviceAddresses[dwIndex] );
			}

			delete [] pConnectionSettings->ppdp8DeviceAddresses;
			pConnectionSettings->ppdp8DeviceAddresses = NULL;
			
		}
	
		delete pConnectionSettings;
	}	
}

#undef DPF_MODNAME
#define DPF_MODNAME "CConnectionSettings::Initialize"
// Initialize (DPL_CONNECTION_SETTINGS version)
//
// This function tells this class to take the specified connection settings and 
// work with it.  
//
HRESULT CConnectionSettings::Initialize( DPL_CONNECTION_SETTINGS * pdplSettings )
{
	if (!DNInitializeCriticalSection( &m_csLock ) )
	{
		DPFX(DPFPREP, 0, "Failed to create critical section");
		return DPNERR_OUTOFMEMORY;
	}
	m_fCritSecInited = TRUE;

	m_pdplConnectionSettings = pdplSettings;
	m_fManaged = FALSE;

	return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CConnectionSettings::Initialize"
// Initialize (Wire Version)
//
// THis function initializes this object to contain a connection settings structure
// that mirrors the values of the wire message.  
HRESULT CConnectionSettings::Initialize( UNALIGNED DPL_INTERNAL_CONNECTION_SETTINGS *pdplSettingsMsg,  UNALIGNED BYTE * pbBufferStart )
{
	DNASSERT( pdplSettingsMsg );
	
	HRESULT hr = DPN_OK;
	DPL_CONNECTION_SETTINGS *pdplConnectionSettings = NULL;
	UNALIGNED BYTE *pBasePointer = pbBufferStart;
	PDIRECTPLAY8ADDRESS pdp8Address = NULL; 
	WCHAR *wszTmpAlignedBuffer = NULL;  
	DWORD dwTmpOffset = 0;
	DWORD dwTmpLength = 0;
	UNALIGNED DWORD *pdwOffsets = NULL;
	UNALIGNED DWORD *pdwLengths = NULL;

	if (!DNInitializeCriticalSection( &m_csLock ) )
	{
		DPFX(DPFPREP, 0, "Failed to create critical section");
		return DPNERR_OUTOFMEMORY;
	}
	m_fCritSecInited = TRUE;

	pdplConnectionSettings = new DPL_CONNECTION_SETTINGS;

	if( !pdplConnectionSettings )
	{
		hr = DPNERR_OUTOFMEMORY;
		goto INITIALIZE_FAILED;
	}

	// Zero out the memory
	ZeroMemory( pdplConnectionSettings, sizeof( DPL_CONNECTION_SETTINGS ) );

	pdplConnectionSettings->dwSize = sizeof( DPL_CONNECTION_SETTINGS );
	pdplConnectionSettings->dwFlags = pdplSettingsMsg->dwFlags;

	//
	// PLAYER NAME COPY
	//
	if( pdplSettingsMsg->dwPlayerNameLength )
	{
		pdplConnectionSettings->pwszPlayerName = new WCHAR[pdplSettingsMsg->dwPlayerNameLength >> 1];

		if( !pdplConnectionSettings->pwszPlayerName )
		{
			hr = DPNERR_OUTOFMEMORY;
			goto INITIALIZE_FAILED;
		}

		memcpy( pdplConnectionSettings->pwszPlayerName, pBasePointer + pdplSettingsMsg->dwPlayerNameOffset, 
		        pdplSettingsMsg->dwPlayerNameLength );
	}

	//
	// HOST ADDRESS COPY
	//
	if( pdplSettingsMsg->dwHostAddressLength )
	{
		// We need to create a buffer for string that we know is aligned.   - Ick - 
		wszTmpAlignedBuffer = new WCHAR[pdplSettingsMsg->dwHostAddressLength >> 1];

		if( !wszTmpAlignedBuffer )
		{
			hr = DPNERR_OUTOFMEMORY;
			goto INITIALIZE_FAILED;
		}

		// Copy the potentially unaligned data to the aligned data string.
		memcpy( wszTmpAlignedBuffer, pBasePointer + pdplSettingsMsg->dwHostAddressOffset,pdplSettingsMsg->dwHostAddressLength );
		
        hr = COM_CoCreateInstance( CLSID_DirectPlay8Address, NULL, CLSCTX_INPROC_SERVER, IID_IDirectPlay8Address, (void **) &pdp8Address );

        if( FAILED( hr ) )
        {
            DPFX(DPFPREP,  0, "Error creating address hr=0x%x", hr );
			goto INITIALIZE_FAILED;
        }

        // Convert the host address (if there is one)
        hr = pdp8Address->lpVtbl->BuildFromURLW( pdp8Address, wszTmpAlignedBuffer );

        if( FAILED( hr ) )
        {
            DPFX(DPFPREP,  0, "Error building URL from address hr=0x%x", hr );
			goto INITIALIZE_FAILED;
        }

        pdplConnectionSettings->pdp8HostAddress = pdp8Address;

        pdp8Address = NULL;

		if( wszTmpAlignedBuffer )
		{
			delete [] wszTmpAlignedBuffer;
			wszTmpAlignedBuffer = NULL;
		}
    }

	if( pdplSettingsMsg->dwNumDeviceAddresses )
	{
		pdplConnectionSettings->cNumDeviceAddresses = pdplSettingsMsg->dwNumDeviceAddresses;
    	//
    	// DEVICE ADDRESS COPY
    	//

    	pdplConnectionSettings->ppdp8DeviceAddresses = new PDIRECTPLAY8ADDRESS[pdplSettingsMsg->dwNumDeviceAddresses];

    	if( !pdplConnectionSettings->ppdp8DeviceAddresses )
    	{
    		hr = DPNERR_OUTOFMEMORY;
    		goto INITIALIZE_FAILED;
    	}
    	
    	// Give us an unaligned dword pointer to the device addresses offset
    	pdwOffsets = (UNALIGNED DWORD *) (pBasePointer + pdplSettingsMsg->dwDeviceAddressOffset);	
    	pdwLengths = (UNALIGNED DWORD *) (pBasePointer + pdplSettingsMsg->dwDeviceAddressLengthOffset);

        for( DWORD dwIndex = 0; dwIndex < pdplSettingsMsg->dwNumDeviceAddresses; dwIndex++ )
        {
        	dwTmpOffset = pdwOffsets[dwIndex];
        	dwTmpLength = pdwLengths[dwIndex];
        	    		
    		// We need to create a buffer for string that we know is aligned.   - Ick - 
    		wszTmpAlignedBuffer = new WCHAR[dwTmpLength >> 1];

    		if( !wszTmpAlignedBuffer )
    		{
    			hr = DPNERR_OUTOFMEMORY;
    			goto INITIALIZE_FAILED;
    		}

    		memcpy( wszTmpAlignedBuffer, pBasePointer + dwTmpOffset, dwTmpLength );
    		
            hr = COM_CoCreateInstance( CLSID_DirectPlay8Address, NULL, CLSCTX_INPROC_SERVER, IID_IDirectPlay8Address, (void **) &pdp8Address );

            if( FAILED( hr ) )
            {
                DPFX(DPFPREP,  0, "Error creating address hr=0x%x", hr );
                return hr;
            }

            // Convert the host address (if there is one)
            hr = pdp8Address->lpVtbl->BuildFromURLW( pdp8Address, wszTmpAlignedBuffer );

            if( FAILED( hr ) )
            {
                DPFX(DPFPREP,  0, "Error building URL from address hr=0x%x", hr );
                DNASSERT( FALSE );
                return hr;
            }

            pdplConnectionSettings->ppdp8DeviceAddresses[dwIndex] = pdp8Address;

            pdp8Address = NULL;

			if( wszTmpAlignedBuffer )
			{
				delete [] wszTmpAlignedBuffer;
				wszTmpAlignedBuffer = NULL;
			}

        }	
	}
	else
	{
	    pdplConnectionSettings->ppdp8DeviceAddresses = NULL;
	}

    // 
	// APPLICATION DESCRIPTION COPY
	//

	pdplConnectionSettings->dpnAppDesc.dwSize = sizeof( DPN_APPLICATION_DESC );
    pdplConnectionSettings->dpnAppDesc.dwFlags = pdplSettingsMsg->dpnApplicationDesc.dwFlags;
    pdplConnectionSettings->dpnAppDesc.guidInstance = pdplSettingsMsg->dpnApplicationDesc.guidInstance;
    pdplConnectionSettings->dpnAppDesc.guidApplication = pdplSettingsMsg->dpnApplicationDesc.guidApplication;
    pdplConnectionSettings->dpnAppDesc.dwMaxPlayers = pdplSettingsMsg->dpnApplicationDesc.dwMaxPlayers;
    pdplConnectionSettings->dpnAppDesc.dwCurrentPlayers = pdplSettingsMsg->dpnApplicationDesc.dwCurrentPlayers;

    if( pdplSettingsMsg->dpnApplicationDesc.dwSessionNameSize )
    {
    	pdplConnectionSettings->dpnAppDesc.pwszSessionName = new WCHAR[pdplSettingsMsg->dpnApplicationDesc.dwSessionNameSize >> 1];

    	if( !pdplConnectionSettings->dpnAppDesc.pwszSessionName )
    	{
    		hr = DPNERR_OUTOFMEMORY;
    		goto INITIALIZE_FAILED;
    	}

    	memcpy( pdplConnectionSettings->dpnAppDesc.pwszSessionName, 
    		    pBasePointer + pdplSettingsMsg->dpnApplicationDesc.dwSessionNameOffset, 
    		    pdplSettingsMsg->dpnApplicationDesc.dwSessionNameSize );
    }

    if( pdplSettingsMsg->dpnApplicationDesc.dwPasswordSize )
    {
    	pdplConnectionSettings->dpnAppDesc.pwszPassword = new WCHAR[pdplSettingsMsg->dpnApplicationDesc.dwPasswordSize >> 1];

    	if( !pdplConnectionSettings->dpnAppDesc.pwszPassword )
    	{
    		hr = DPNERR_OUTOFMEMORY;
    		goto INITIALIZE_FAILED;
    	}

    	memcpy( pdplConnectionSettings->dpnAppDesc.pwszPassword, 
    		    pBasePointer + pdplSettingsMsg->dpnApplicationDesc.dwPasswordOffset, 
    		    pdplSettingsMsg->dpnApplicationDesc.dwPasswordSize );
    }    

    if( pdplSettingsMsg->dpnApplicationDesc.dwReservedDataSize )
    {
    	pdplConnectionSettings->dpnAppDesc.pvReservedData = new BYTE[pdplSettingsMsg->dpnApplicationDesc.dwReservedDataSize];

    	if( !pdplConnectionSettings->dpnAppDesc.pvReservedData )
    	{
    		hr = DPNERR_OUTOFMEMORY;
    		goto INITIALIZE_FAILED;
    	}

    	memcpy( pdplConnectionSettings->dpnAppDesc.pvReservedData, 
    		    pBasePointer + pdplSettingsMsg->dpnApplicationDesc.dwReservedDataOffset, 
    		    pdplSettingsMsg->dpnApplicationDesc.dwReservedDataSize );

		pdplConnectionSettings->dpnAppDesc.dwReservedDataSize = pdplSettingsMsg->dpnApplicationDesc.dwReservedDataSize;
    } 

    if( pdplSettingsMsg->dpnApplicationDesc.dwApplicationReservedDataSize )
    {
    	pdplConnectionSettings->dpnAppDesc.pvApplicationReservedData = new BYTE[pdplSettingsMsg->dpnApplicationDesc.dwApplicationReservedDataSize];

    	if( !pdplConnectionSettings->dpnAppDesc.pvApplicationReservedData )
    	{
    		hr = DPNERR_OUTOFMEMORY;
    		goto INITIALIZE_FAILED;
    	}

    	memcpy( pdplConnectionSettings->dpnAppDesc.pvApplicationReservedData, 
    		    pBasePointer + pdplSettingsMsg->dpnApplicationDesc.dwApplicationReservedDataOffset, 
    		    pdplSettingsMsg->dpnApplicationDesc.dwApplicationReservedDataSize );

		pdplConnectionSettings->dpnAppDesc.dwApplicationReservedDataSize = pdplSettingsMsg->dpnApplicationDesc.dwApplicationReservedDataSize;
    }     

		
	// Free the old structure if one exists.  
	if( m_fManaged )
	{
		m_fManaged = FALSE;		
	} 
	else if( m_pdplConnectionSettings )
	{
		FreeConnectionSettings( m_pdplConnectionSettings );		
	}

    m_pdplConnectionSettings = pdplConnectionSettings;

	if( wszTmpAlignedBuffer ) 
		delete [] wszTmpAlignedBuffer;   

    return DPN_OK;
    
INITIALIZE_FAILED:

	FreeConnectionSettings( pdplConnectionSettings );

	if( wszTmpAlignedBuffer ) 
		delete [] wszTmpAlignedBuffer;

	if( pdp8Address )
		pdp8Address->lpVtbl->Release( pdp8Address );

	return hr;

}

#undef DPF_MODNAME
#define DPF_MODNAME "CConnectionSettings::InitializeAndCopy"
// InitializeAndCopy
//
// This function initializes this class to contain a copy of the specified 
// connection settings structure.
//
HRESULT CConnectionSettings::InitializeAndCopy( const DPL_CONNECTION_SETTINGS * const pdplSettings )
{
	DNASSERT( pdplSettings );
	
	HRESULT hr = DPN_OK;
	DPL_CONNECTION_SETTINGS *pdplConnectionSettings = NULL;

	if (!DNInitializeCriticalSection( &m_csLock ) )
	{
		DPFX(DPFPREP, 0, "Failed to create critical section");
		return DPNERR_OUTOFMEMORY;
	}
	m_fCritSecInited = TRUE;

	pdplConnectionSettings = new DPL_CONNECTION_SETTINGS;

	if( !pdplConnectionSettings )
	{
		hr = DPNERR_OUTOFMEMORY;
		goto INITIALIZE_FAILED;
	}

	// Copy over.  This is a little dangerous as we copy pointer values.  Pointers 
	// should be set in our local structure to NULL so that proper cleanup can occur
	// on error.  (Otherwise we'll free other structure's memory!!)
	memcpy( pdplConnectionSettings, pdplSettings, sizeof( DPL_CONNECTION_SETTINGS ) );

	// Reset pointers as mentioned above.  
	pdplConnectionSettings->pdp8HostAddress = NULL;
	pdplConnectionSettings->ppdp8DeviceAddresses = NULL;	
	pdplConnectionSettings->pwszPlayerName = NULL;
	pdplConnectionSettings->dpnAppDesc.pwszSessionName = NULL;	
	pdplConnectionSettings->dpnAppDesc.pwszPassword = NULL;	
	pdplConnectionSettings->dpnAppDesc.pvReservedData = NULL;		
	pdplConnectionSettings->dpnAppDesc.pvApplicationReservedData = NULL;	

	if( pdplSettings->pdp8HostAddress )
	{
		hr = pdplSettings->pdp8HostAddress->lpVtbl->Duplicate( pdplSettings->pdp8HostAddress, &pdplConnectionSettings->pdp8HostAddress );

		if( FAILED( hr ) )
		{
            DPFX(DPFPREP,  0, "Error duplicating host address hr [0x%x]", hr );
            goto INITIALIZE_FAILED;
		}
	}

	if( pdplSettings->ppdp8DeviceAddresses )
	{
		pdplConnectionSettings->ppdp8DeviceAddresses = new PDIRECTPLAY8ADDRESS[pdplSettings->cNumDeviceAddresses];

		if( !pdplConnectionSettings->ppdp8DeviceAddresses )
		{
			hr = DPNERR_OUTOFMEMORY;
			DPFX(DPFPREP,  0, "Failed allocating memory" );			
			goto INITIALIZE_FAILED;
		}

		for( DWORD dwIndex = 0; dwIndex < pdplSettings->cNumDeviceAddresses; dwIndex++ )
		{
			hr = pdplSettings->ppdp8DeviceAddresses[dwIndex]->lpVtbl->Duplicate( pdplSettings->ppdp8DeviceAddresses[dwIndex], &pdplConnectionSettings->ppdp8DeviceAddresses[dwIndex] );

			if( FAILED( hr ) )
			{
	            DPFX(DPFPREP,  0, "Error duplicating host address hr [0x%x]", hr );
	            goto INITIALIZE_FAILED;
			}			
		}
	}
	
	if( pdplSettings->pwszPlayerName )
	{
		pdplConnectionSettings->pwszPlayerName = new WCHAR[wcslen(pdplSettings->pwszPlayerName)+1];

		if( !pdplConnectionSettings->pwszPlayerName )
		{
            DPFX(DPFPREP,  0, "Failed allocating memory" );						
			hr = DPNERR_OUTOFMEMORY;
			goto INITIALIZE_FAILED;
		}

		wcscpy( pdplConnectionSettings->pwszPlayerName, pdplSettings->pwszPlayerName  );
	}

	if( pdplSettings->dpnAppDesc.pwszSessionName )
	{
		pdplConnectionSettings->dpnAppDesc.pwszSessionName = new WCHAR[wcslen(pdplSettings->dpnAppDesc.pwszSessionName)+1];

		if( !pdplConnectionSettings->dpnAppDesc.pwszSessionName )
		{
            DPFX(DPFPREP,  0, "Failed allocating memory" );						
			hr = DPNERR_OUTOFMEMORY;
			goto INITIALIZE_FAILED;
		}

		wcscpy( pdplConnectionSettings->dpnAppDesc.pwszSessionName, pdplSettings->dpnAppDesc.pwszSessionName  );
	}

	if( pdplSettings->dpnAppDesc.pwszPassword )
	{
		pdplConnectionSettings->dpnAppDesc.pwszPassword = new WCHAR[wcslen(pdplSettings->dpnAppDesc.pwszPassword)+1];

		if( !pdplConnectionSettings->dpnAppDesc.pwszPassword )
		{
            DPFX(DPFPREP,  0, "Failed allocating memory" );						
			hr = DPNERR_OUTOFMEMORY;
			goto INITIALIZE_FAILED;
		}

		wcscpy( pdplConnectionSettings->dpnAppDesc.pwszPassword, pdplSettings->dpnAppDesc.pwszPassword  );
	}	

	if( pdplSettings->dpnAppDesc.pvReservedData )
	{
		pdplConnectionSettings->dpnAppDesc.pvReservedData = new BYTE[pdplSettings->dpnAppDesc.dwReservedDataSize];

		if( !pdplConnectionSettings->dpnAppDesc.pvReservedData )
		{
            DPFX(DPFPREP,  0, "Failed allocating memory" );			
			hr = DPNERR_OUTOFMEMORY;
			goto INITIALIZE_FAILED;
		}

		memcpy( pdplConnectionSettings->dpnAppDesc.pvReservedData, 
			    pdplSettings->dpnAppDesc.pvReservedData,
			    pdplSettings->dpnAppDesc.dwReservedDataSize );
	}		

	if( pdplSettings->dpnAppDesc.pvApplicationReservedData )
	{
		pdplConnectionSettings->dpnAppDesc.pvApplicationReservedData = new BYTE[pdplSettings->dpnAppDesc.dwApplicationReservedDataSize];

		if( !pdplConnectionSettings->dpnAppDesc.pvApplicationReservedData )
		{
            DPFX(DPFPREP,  0, "Failed allocating memory" );			
			hr = DPNERR_OUTOFMEMORY;
			goto INITIALIZE_FAILED;
		}

		memcpy( pdplConnectionSettings->dpnAppDesc.pvApplicationReservedData, 
			    pdplSettings->dpnAppDesc.pvApplicationReservedData,
			    pdplSettings->dpnAppDesc.dwApplicationReservedDataSize );
	}			

	// Free the old structure if one exists.  
	if( m_fManaged )
	{
		m_fManaged = FALSE;		
	} 
	else if( m_pdplConnectionSettings )
	{
		FreeConnectionSettings( m_pdplConnectionSettings );		
	}

    m_pdplConnectionSettings = pdplConnectionSettings;

    return DPN_OK;	
	
INITIALIZE_FAILED:

	FreeConnectionSettings( pdplConnectionSettings );

	return hr;	
}

#undef DPF_MODNAME
#define DPF_MODNAME "CConnectionSettings::BuildWireStruct"
// BuildWireStruct
//
// This function fills the packed buffer with the wire representation of the
// connection settings structure.  
HRESULT CConnectionSettings::BuildWireStruct( CPackedBuffer *const pPackedBuffer )
{
	HRESULT hr = DPN_OK;
	DPL_INTERNAL_CONNECTION_SETTINGS *pdplConnectSettings = NULL;  
	WCHAR *wszTmpAddress = NULL;
	DWORD dwTmpStringSize = 0;
	UNALIGNED DWORD *pdwTmpOffsets = NULL;
	UNALIGNED DWORD *pdwTmpLengths = NULL;
 
	pdplConnectSettings = (DPL_INTERNAL_CONNECTION_SETTINGS *) pPackedBuffer->GetHeadAddress();	

	hr = pPackedBuffer->AddToFront( NULL, sizeof( DPL_INTERNAL_CONNECTION_SETTINGS ) );

	if( hr == DPN_OK )
	{
	    ZeroMemory( pdplConnectSettings, sizeof( DPL_INTERNAL_CONNECTION_SETTINGS ) );
	        
		//
		// COPY CORE FIXED VALUES
		//
		pdplConnectSettings->dwFlags = m_pdplConnectionSettings->dwFlags;
		pdplConnectSettings->dwNumDeviceAddresses = m_pdplConnectionSettings->cNumDeviceAddresses;

		//
		// COPY APPDESC FIXED VALUES
		//
		pdplConnectSettings->dpnApplicationDesc.dwSize = sizeof( DPN_APPLICATION_DESC_INFO );
		pdplConnectSettings->dpnApplicationDesc.dwFlags = m_pdplConnectionSettings->dpnAppDesc.dwFlags;
		pdplConnectSettings->dpnApplicationDesc.dwMaxPlayers = m_pdplConnectionSettings->dpnAppDesc.dwMaxPlayers;
		pdplConnectSettings->dpnApplicationDesc.dwCurrentPlayers = m_pdplConnectionSettings->dpnAppDesc.dwCurrentPlayers;
		pdplConnectSettings->dpnApplicationDesc.guidInstance = m_pdplConnectionSettings->dpnAppDesc.guidInstance;
		pdplConnectSettings->dpnApplicationDesc.guidApplication = m_pdplConnectionSettings->dpnAppDesc.guidApplication;		
	}

	// 
	// COPY VARIABLE CORE VALUES
	// 

	if( m_pdplConnectionSettings->pwszPlayerName )
	{
		hr = pPackedBuffer->AddWCHARStringToBack( m_pdplConnectionSettings->pwszPlayerName );

		if( hr == DPN_OK && pdplConnectSettings )
		{
			pdplConnectSettings->dwPlayerNameOffset = pPackedBuffer->GetTailOffset();
			pdplConnectSettings->dwPlayerNameLength = 
				(wcslen( m_pdplConnectionSettings->pwszPlayerName )+1) * sizeof( WCHAR );
		}		
	}

	if( m_pdplConnectionSettings->pdp8HostAddress )
	{
		hr = m_pdplConnectionSettings->pdp8HostAddress->lpVtbl->GetURLW( m_pdplConnectionSettings->pdp8HostAddress, NULL, &dwTmpStringSize );

		if( hr != DPNERR_BUFFERTOOSMALL )
		{
            DPFX(DPFPREP,  0, "Failed converting address hr [0x%x]", hr );				
            goto BUILDWIRESTRUCT_FAILURE;
		}

		wszTmpAddress = new WCHAR[dwTmpStringSize];

		if( !wszTmpAddress )
		{
			hr = DPNERR_OUTOFMEMORY;
            DPFX(DPFPREP,  0, "Failed allocating memory" );				
            goto BUILDWIRESTRUCT_FAILURE;			
		}

		hr = m_pdplConnectionSettings->pdp8HostAddress->lpVtbl->GetURLW( m_pdplConnectionSettings->pdp8HostAddress, wszTmpAddress, &dwTmpStringSize );

		if( FAILED( hr ) )
		{
            DPFX(DPFPREP,  0, "Failed converting address hr [0x%x]", hr );				
            goto BUILDWIRESTRUCT_FAILURE;
		}
		
		hr = pPackedBuffer->AddWCHARStringToBack( wszTmpAddress );

		if( hr == DPN_OK && pdplConnectSettings )
		{
			pdplConnectSettings->dwHostAddressOffset = pPackedBuffer->GetTailOffset();
			pdplConnectSettings->dwHostAddressLength = 
				(wcslen( wszTmpAddress )+1) * sizeof( WCHAR );
		}	

		delete [] wszTmpAddress;
		wszTmpAddress = NULL;		
			
	}

	hr = pPackedBuffer->AddToBack( NULL, sizeof( DWORD ) * m_pdplConnectionSettings->cNumDeviceAddresses );

	if( hr == DPN_OK && pdplConnectSettings )
	{
		pdwTmpOffsets = (DWORD *) pPackedBuffer->GetTailAddress();
		pdplConnectSettings->dwDeviceAddressOffset = pPackedBuffer->GetTailOffset();
	}

	hr = pPackedBuffer->AddToBack( NULL, sizeof( DWORD ) * m_pdplConnectionSettings->cNumDeviceAddresses );

	if( hr == DPN_OK && pdplConnectSettings )
	{
		pdwTmpLengths = (DWORD *) pPackedBuffer->GetTailAddress();
		pdplConnectSettings->dwDeviceAddressLengthOffset = pPackedBuffer->GetTailOffset();		
	}	

	for( DWORD dwIndex = 0; dwIndex < m_pdplConnectionSettings->cNumDeviceAddresses; dwIndex++ )
	{
		dwTmpStringSize = 0;
		
		hr = m_pdplConnectionSettings->ppdp8DeviceAddresses[dwIndex]->lpVtbl->GetURLW( 
				m_pdplConnectionSettings->ppdp8DeviceAddresses[dwIndex], 
				NULL, &dwTmpStringSize );

		if( hr != DPNERR_BUFFERTOOSMALL )
		{
            DPFX(DPFPREP,  0, "Failed converting address hr [0x%x]", hr );				
            goto BUILDWIRESTRUCT_FAILURE;
		}

		wszTmpAddress = new WCHAR[dwTmpStringSize];

		if( !wszTmpAddress )
		{
			hr = DPNERR_OUTOFMEMORY;
            DPFX(DPFPREP,  0, "Failed allocating memory" );				
            goto BUILDWIRESTRUCT_FAILURE;			
		}

		hr = m_pdplConnectionSettings->ppdp8DeviceAddresses[dwIndex]->lpVtbl->GetURLW( 
				m_pdplConnectionSettings->ppdp8DeviceAddresses[dwIndex], 
				wszTmpAddress, &dwTmpStringSize );

		if( FAILED( hr ) )
		{
            DPFX(DPFPREP,  0, "Failed converting address hr [0x%x]", hr );				
            goto BUILDWIRESTRUCT_FAILURE;
		}
		
		hr = pPackedBuffer->AddWCHARStringToBack( wszTmpAddress );

		if( hr == DPN_OK && pdplConnectSettings && pdwTmpLengths )
		{
			pdwTmpOffsets[dwIndex] = pPackedBuffer->GetTailOffset();
			pdwTmpLengths[dwIndex] = (wcslen( wszTmpAddress )+1) * sizeof( WCHAR );
		}	

		delete [] wszTmpAddress;
		wszTmpAddress = NULL;		
	}

	//
	// COPY APP DESC VARIABLE MEMBERS
	//
	
	if( m_pdplConnectionSettings->dpnAppDesc.pwszPassword )
	{
		hr = pPackedBuffer->AddWCHARStringToBack( m_pdplConnectionSettings->dpnAppDesc.pwszPassword );

		if( hr == DPN_OK && pdplConnectSettings )
		{
			pdplConnectSettings->dpnApplicationDesc.dwPasswordOffset = pPackedBuffer->GetTailOffset();
			pdplConnectSettings->dpnApplicationDesc.dwPasswordSize = 
				(wcslen( m_pdplConnectionSettings->dpnAppDesc.pwszPassword )+1) * sizeof( WCHAR );
		}
	}

	if( m_pdplConnectionSettings->dpnAppDesc.pwszSessionName)
	{
		hr = pPackedBuffer->AddWCHARStringToBack( m_pdplConnectionSettings->dpnAppDesc.pwszSessionName );

		if( hr == DPN_OK && pdplConnectSettings )
		{
			pdplConnectSettings->dpnApplicationDesc.dwSessionNameOffset = pPackedBuffer->GetTailOffset();
			pdplConnectSettings->dpnApplicationDesc.dwSessionNameSize = 
				(wcslen( m_pdplConnectionSettings->dpnAppDesc.pwszSessionName )+1) * sizeof( WCHAR );
		}
	}	

	if( m_pdplConnectionSettings->dpnAppDesc.pvReservedData )
	{
		hr = pPackedBuffer->AddToBack( m_pdplConnectionSettings->dpnAppDesc.pvReservedData, 
									   m_pdplConnectionSettings->dpnAppDesc.dwReservedDataSize );

		if( hr == DPN_OK && pdplConnectSettings )
		{
			pdplConnectSettings->dpnApplicationDesc.dwReservedDataOffset = pPackedBuffer->GetTailOffset();
			pdplConnectSettings->dpnApplicationDesc.dwReservedDataSize = m_pdplConnectionSettings->dpnAppDesc.dwReservedDataSize;
		}
	}		

	if( m_pdplConnectionSettings->dpnAppDesc.pvApplicationReservedData)
	{
		hr = pPackedBuffer->AddToBack( m_pdplConnectionSettings->dpnAppDesc.pvApplicationReservedData, 
									   m_pdplConnectionSettings->dpnAppDesc.dwApplicationReservedDataSize);

		if( hr == DPN_OK && pdplConnectSettings )
		{
			pdplConnectSettings->dpnApplicationDesc.dwApplicationReservedDataOffset = pPackedBuffer->GetTailOffset();
			pdplConnectSettings->dpnApplicationDesc.dwApplicationReservedDataSize = m_pdplConnectionSettings->dpnAppDesc.dwApplicationReservedDataSize;
		}
	}			

BUILDWIRESTRUCT_FAILURE:

	if( wszTmpAddress )
		delete [] wszTmpAddress;

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CConnectionSettings::SetEqual"
// SetEqual 
//
// This function provides a deep copy of the specified class into this object
HRESULT CConnectionSettings::SetEqual( CConnectionSettings * pdplSettings )
{
	PDPL_CONNECTION_SETTINGS pConnectSettings = pdplSettings->GetConnectionSettings();

	if( pConnectSettings == NULL )
	{
	    DPFX(DPFPREP,  0, "Error getting settings -- no settings available!" );
	    return DPNERR_DOESNOTEXIST;
	}

	return Initialize( pConnectSettings );
}

#undef DPF_MODNAME
#define DPF_MODNAME "CConnectionSettings::CopyToBuffer( BYTE *pbBuffer, DWORD *pdwBufferSize )"
HRESULT CConnectionSettings::CopyToBuffer( BYTE *pbBuffer, DWORD *pdwBufferSize )
{
    if( m_pdplConnectionSettings == NULL )
    {
        *pdwBufferSize = 0;
        return DPNERR_DOESNOTEXIST;
    }

    CPackedBuffer packBuff;
    HRESULT hr = DPN_OK;
    DPL_CONNECTION_SETTINGS *pConnectionSettings = NULL;

    packBuff.Initialize( pbBuffer, *pdwBufferSize, TRUE );

   	pConnectionSettings = (DPL_CONNECTION_SETTINGS *) packBuff.GetHeadAddress();

    hr = packBuff.AddToFront( m_pdplConnectionSettings, sizeof( DPL_CONNECTION_SETTINGS ), TRUE );

    if( FAILED( hr ) )
    {
    	pConnectionSettings = NULL;	
    }

    // Add app desc's session name if there is one
    if( m_pdplConnectionSettings->dpnAppDesc.pwszSessionName != NULL )
    {
        hr = packBuff.AddWCHARStringToBack( m_pdplConnectionSettings->dpnAppDesc.pwszSessionName, TRUE );
        
        if( pConnectionSettings )
			pConnectionSettings->dpnAppDesc.pwszSessionName = (WCHAR *) packBuff.GetTailAddress();
    }

    // Copy player name
    if( m_pdplConnectionSettings->pwszPlayerName != NULL )
    {
        hr = packBuff.AddWCHARStringToBack( m_pdplConnectionSettings->pwszPlayerName, TRUE );
        
        if( pConnectionSettings )
			pConnectionSettings->pwszPlayerName = (WCHAR *) packBuff.GetTailAddress();
    }

    // Copy password
    if( m_pdplConnectionSettings->dpnAppDesc.pwszPassword )
    {
        hr = packBuff.AddWCHARStringToBack( m_pdplConnectionSettings->dpnAppDesc.pwszPassword, TRUE );

        if( pConnectionSettings )
			pConnectionSettings->dpnAppDesc.pwszPassword = (WCHAR *) packBuff.GetTailAddress();
    }

    if( m_pdplConnectionSettings->dpnAppDesc.dwReservedDataSize )
    {
        hr = packBuff.AddToBack( m_pdplConnectionSettings->dpnAppDesc.pvReservedData, m_pdplConnectionSettings->dpnAppDesc.dwReservedDataSize, TRUE );
		if( pConnectionSettings )
			pConnectionSettings->dpnAppDesc.pvReservedData = (WCHAR *)  packBuff.GetTailAddress();
    }

    if( m_pdplConnectionSettings->dpnAppDesc.dwApplicationReservedDataSize )
    {
        hr = packBuff.AddToBack( m_pdplConnectionSettings->dpnAppDesc.pvApplicationReservedData, m_pdplConnectionSettings->dpnAppDesc.dwApplicationReservedDataSize, TRUE );

        if( pConnectionSettings )
			pConnectionSettings->dpnAppDesc.pvApplicationReservedData = (WCHAR *)  packBuff.GetTailAddress();
    }

    hr = packBuff.AddToBack( m_pdplConnectionSettings->ppdp8DeviceAddresses, sizeof( IDirectPlay8Address * )*m_pdplConnectionSettings->cNumDeviceAddresses, TRUE );
    
    if( pConnectionSettings )
	    pConnectionSettings->ppdp8DeviceAddresses = (IDirectPlay8Address **) packBuff.GetTailAddress();

	if( pConnectionSettings )
	{
	    if( m_pdplConnectionSettings->pdp8HostAddress != NULL )
		{
			hr = m_pdplConnectionSettings->pdp8HostAddress->lpVtbl->Duplicate( m_pdplConnectionSettings->pdp8HostAddress, &pConnectionSettings->pdp8HostAddress );

			if( FAILED( hr ) )
			{
				DPFX(DPFPREP,  0, "Error duplicating host address hr [0x%x]", hr );
				goto INITIALIZE_COMPLETE;
			}			
		}

	    for( DWORD dwIndex = 0; dwIndex < m_pdplConnectionSettings->cNumDeviceAddresses; dwIndex++ )
	    {
			hr = m_pdplConnectionSettings->ppdp8DeviceAddresses[dwIndex]->lpVtbl->Duplicate( m_pdplConnectionSettings->ppdp8DeviceAddresses[dwIndex], &pConnectionSettings->ppdp8DeviceAddresses[dwIndex] );

			if( FAILED( hr ) )
			{
				DPFX(DPFPREP,  0, "Error duplicating device address hr [0x%x]", hr );
				goto INITIALIZE_COMPLETE;
			}						
	    }
	}

INITIALIZE_COMPLETE:

	*pdwBufferSize = packBuff.GetSizeRequired();
	
    return hr;
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\lobby\dplcommon.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DPLCommon.cpp
 *  Content:    DirectPlay Lobby Common Functions
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  02/21/00	mjn		Created
 *  04/13/00	rmt     First pass param validation
 *	04/26/00	mjn		Removed dwTimeOut from Send() API call
 *  05/01/00    rmt     Bug #33108 -- Initialize returns DPNERR_NORESPONSE when not lobbied
 *  05/03/00    rmt     Updated initialize so if lobby launched automatically establishes a 
 *                      connection and makes self unavailable.  (Also waits for connection).
 *  05/16/00	rmt		Bug #34734 -- Init Client, Init App, Close App hangs -- 
 *						both client and app were using 'C' prefix, should have been 'C' for 
 *						client and 'A' for app.
 *  06/14/00	rmt		Fixed build break with new compiler (added ')''s).
 *  06/15/00    rmt     Bug #33617 - Must provide method for providing automatic launch of DirectPlay instances   
 *  06/28/00	rmt		Prefix Bug #38082
 *  07/06/00	rmt		Bug #38717 ASSERTION when sending data
 *  07/08/2000	rmt		Bug #38725 - Need to provide method to detect if app was lobby launched
 *				rmt		Bug #38757 - Callback messages for connections may return AFTER WaitForConnection returns
 *				rmt		Bug #38755 - No way to specify player name in Connection Settings
 *				rmt		Bug #38758 - DPLOBBY8.H has incorrect comments
 *				rmt		Bug #38783 - pvUserApplicationContext is only partially implemented
 *				rmt		Added DPLHANDLE_ALLCONNECTIONS and dwFlags (reserved field to couple of funcs).
 *  07/13/2000	rmt		Fixed memory leak
 *  07/14/2000	rmt		Bug #39257 - LobbyClient::ReleaseApp returns E_OUTOFMEMORY when called when no one connected
 *  07/21/2000	rmt		Removed assert which wasn't needed
 *  08/03/2000	rmt		Removed assert which wasn't needed
 *  08/05/2000  RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *  08/18/2000	rmt		Bug #42751 - DPLOBBY8: Prohibit more than one lobby client or lobby app per process 
 *  08/24/2000	rmt		Bug #43317 - DP8LOBBY: Occasionally when closing Lobby App right after releasing handles, causes assertion.
 *  02/06/2001	rodtoll	WINBUG #293871: DPLOBBY8: [IA64] Lobby launching a 64-bit 
 * 						app from 64-bit lobby launcher crashes with unaligned memory error. 
 *
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dnlobbyi.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

BOOL g_fAppStarted = FALSE;
BOOL g_fClientStarted = FALSE;
DNCRITICAL_SECTION g_csSingleTon;

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************

// DPL_GetConnectionSettings
//
// Retrieves the pdplSessionInfo (if any) associated with the specified connection.  This method
// is shared between the client and app interfaces.
//
#undef DPF_MODNAME
#define DPF_MODNAME "DPL_GetConnectionSettings"
STDMETHODIMP DPL_GetConnectionSettings(LPVOID lpv,const DPNHANDLE hLobbyClient, DPL_CONNECTION_SETTINGS * const pdplSessionInfo, DWORD *pdwInfoSize, const DWORD dwFlags )
{
	HRESULT			hResultCode;
	DPL_CONNECTION	*pdplConnection;
	DIRECTPLAYLOBBYOBJECT	*pdpLobbyObject;

	DPFX(DPFPREP, 3,"Parameters: hTarget [0x%lx], pdplSessionInfo [0x%p], pdwInfoSize [%p], dwFlags [0x%lx]",
			hLobbyClient,pdplSessionInfo,pdwInfoSize,dwFlags);

	TRY
	{
    	pdpLobbyObject = static_cast<DIRECTPLAYLOBBYOBJECT*>(GET_OBJECT_FROM_INTERFACE(lpv));
	    
    	if( pdpLobbyObject->dwFlags & DPL_OBJECT_FLAG_PARAMVALIDATION )
    	{
        	if( FAILED( hResultCode = DPL_ValidateGetConnectionSettings( lpv, hLobbyClient, pdplSessionInfo, pdwInfoSize, dwFlags ) ) )
        	{
        	    DPFX(DPFPREP,  0, "Error validating getconnectsettings params hr=[0x%lx]", hResultCode );
        	    DPF_RETURN( hResultCode );
        	}
    	}

    	// Ensure we've been initialized
    	if (pdpLobbyObject->pReceiveQueue == NULL)
    	{
    		DPFERR("Not initialized");
    		DPF_RETURN(DPNERR_UNINITIALIZED);
    	}    	
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}	

    // Attempt to retrieve connection settings.
	hResultCode = DPLConnectionGetConnectSettings( pdpLobbyObject, hLobbyClient, pdplSessionInfo, pdwInfoSize );

    DPF_RETURN( hResultCode );
}

// DPL_SetConnectionSettings
//
// Sets the pdplSessionInfo structure associated with the specified connection.  This method 
// is shared between the client and app interfaces.
//
// This function will generate a DPL_MSGID_CONNECTION_SETTINGS message to be sent to the specified
// connection.
//
#undef DPF_MODNAME
#define DPF_MODNAME "DPL_SetConnectionSettings"
STDMETHODIMP DPL_SetConnectionSettings(LPVOID lpv,const DPNHANDLE hLobbyClient, const DPL_CONNECTION_SETTINGS * const pdplSessionInfo, const DWORD dwFlags )
{
	HRESULT			hResultCode;
	DPL_CONNECTION	*pdplConnection;
	DIRECTPLAYLOBBYOBJECT	*pdpLobbyObject;
	DPNHANDLE		*hTargets = NULL;
	DWORD			dwNumTargets = 0;
	DWORD			dwTargetIndex = 0;
	CConnectionSettings *pConnectionSettings = NULL;

	DPFX(DPFPREP, 3,"Parameters: hLobbyClient [0x%lx], pBuffer [0x%p], dwFlags [0x%lx]",
			hLobbyClient,pdplSessionInfo,dwFlags);

	TRY
	{
    	pdpLobbyObject = static_cast<DIRECTPLAYLOBBYOBJECT*>(GET_OBJECT_FROM_INTERFACE(lpv));
	    
    	if( pdpLobbyObject->dwFlags & DPL_OBJECT_FLAG_PARAMVALIDATION )
    	{
        	if( FAILED( hResultCode = DPL_ValidateSetConnectionSettings( lpv, hLobbyClient, pdplSessionInfo, dwFlags ) ) )
        	{
        	    DPFX(DPFPREP,  0, "Error validating setconnectsettings params hr=[0x%lx]", hResultCode );
        	    DPF_RETURN( hResultCode );
        	}
    	}

    	// Ensure we've been initialized
    	if (pdpLobbyObject->pReceiveQueue == NULL)
    	{
    		DPFERR("Not initialized");
    		DPF_RETURN(DPNERR_UNINITIALIZED);
    	}    	
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}	

	if( hLobbyClient == DPLHANDLE_ALLCONNECTIONS )
	{
		dwNumTargets = 0;

		// We need loop so if someone adds a connection during our run
		// it gets added to our list
		//
		while( 1 )
		{
			hResultCode = DPLConnectionEnum( pdpLobbyObject, hTargets, &dwNumTargets );

			if( hResultCode == DPNERR_BUFFERTOOSMALL )
			{
				if( hTargets )
				{
					delete [] hTargets;
				}

				hTargets = new DPNHANDLE[dwNumTargets];

				if( hTargets == NULL )
				{
					DPFERR("Error allocating memory" );
					dwNumTargets = 0;
					hResultCode = DPNERR_OUTOFMEMORY;
					goto SETCONNECT_EXIT;
				}


				continue;
			}
			else if( FAILED( hResultCode ) )
			{
				DPFX(DPFPREP,  0, "Error getting list of connections hr=0x%x", hResultCode );
				break;
			}
			else
			{
				break;
			}
		}

		// Failed getting connection information
		if( FAILED( hResultCode ) )
		{
			if( hTargets )
			{
				delete [] hTargets;
				hTargets = NULL;
			}
			dwNumTargets = 0;
			goto SETCONNECT_EXIT;
		}

	}
	else
	{
		hTargets = new DPNHANDLE[1]; // We use array delete below so we need array new

		if( hTargets == NULL )
		{
			DPFERR("Error allocating memory" );
			dwNumTargets = 0;
			hResultCode = DPNERR_OUTOFMEMORY;
			goto SETCONNECT_EXIT;
		}

		dwNumTargets = 1;
		hTargets[0] = hLobbyClient;
	}
		
	for( dwTargetIndex = 0; dwTargetIndex < dwNumTargets; dwTargetIndex++ )
	{
		if ((hResultCode = DPLConnectionFind(pdpLobbyObject,hTargets[dwTargetIndex],&pdplConnection,TRUE)) != DPN_OK)
		{
			DPFERR("Invalid send target");
			DisplayDNError(0,hResultCode);
			continue;
		}

		if( pdplSessionInfo )
		{
			pConnectionSettings = new CConnectionSettings();

			if( !pConnectionSettings )
			{
				DPFERR("Error allocating memory" );
				hResultCode = DPNERR_OUTOFMEMORY;
				goto SETCONNECT_EXIT;
			}

			hResultCode = pConnectionSettings->InitializeAndCopy( pdplSessionInfo );

			if( FAILED( hResultCode ) )
			{
				DPFX( DPFPREP, 0, "Error setting up connection settings hr [0x%x]", hResultCode );
				goto SETCONNECT_EXIT;
			}
		}

		// Attempt to set connection settings.
		hResultCode = DPLConnectionSetConnectSettings( pdpLobbyObject, hTargets[dwTargetIndex], pConnectionSettings );

		if( FAILED( hResultCode ) )
		{
			DPFX(DPFPREP,  0, "Error setting connct settings for 0x%x hr=0x%x", hTargets[dwTargetIndex], hResultCode );
			delete pConnectionSettings;
		}

		hResultCode = DPLSendConnectionSettings( pdpLobbyObject, hTargets[dwTargetIndex] );

		if( FAILED( hResultCode ) )
		{
			DPFX(DPFPREP,  0, "Error sending connection settings to client 0x%x hr=0x%x", hTargets[dwTargetIndex], hResultCode );
		}

		pConnectionSettings = NULL;
	}

SETCONNECT_EXIT:

	for( dwTargetIndex = 0; dwTargetIndex < dwNumTargets; dwTargetIndex++ )
	{
		if( hTargets[dwTargetIndex] )
			DPLConnectionRelease(pdpLobbyObject,hTargets[dwTargetIndex]);
	}

	if( hTargets )
		delete [] hTargets;

	DPF_RETURN(hResultCode);
}


#undef DPF_MODNAME 
#define DPF_MODNAME "DPL_RegisterMessageHandlerClient"
STDMETHODIMP DPL_RegisterMessageHandlerClient(PVOID pv,
										const PVOID pvUserContext,
										const PFNDPNMESSAGEHANDLER pfn,
										const DWORD dwFlags)
{
	return DPL_RegisterMessageHandler( pv, pvUserContext, pfn, NULL, dwFlags );
}

//	HRESULT	DPL_RegisterMessageHandler
//		PVOID					pv				Interface pointer
//		PVOID					pvUserContext	User context
//		PFNDPNMESSAGEHANDLER	pfn				User supplied message handler
//		DWORD					dwFlags			Not Used
//
//	Returns
//		DPN_OK					If the message handler was registered without incident
//		DPNERR_INVALIDPARAM		If there was an invalid parameter
//		DPNERR_GENERIC			If there were any problems
//
//	Notes
//		This function registers a user supplied message handler function.  This function should
//		only be called once, even in cases where a game is being re-connected (i.e. after ending)
//
//		This will set up the required message queues, handshake the lobby client's PID (if supplied on the
//		command line) and spawn the application's receive message queue thread.

#undef DPF_MODNAME
#define DPF_MODNAME "DPL_RegisterMessageHandler"

STDMETHODIMP DPL_RegisterMessageHandler(PVOID pv,
										const PVOID pvUserContext,
										const PFNDPNMESSAGEHANDLER pfn,
										DPNHANDLE * const pdpnhConnection, 
										const DWORD dwFlags)
{
	HRESULT					hResultCode = DPN_OK;
	DWORD					dwCurrentPid;
	DWORD					dwThreadId;
	PDIRECTPLAYLOBBYOBJECT	pdpLobbyObject;
	char					cSuffix;

	DPFX(DPFPREP, 3,"Parameters: pv [0x%p], pfn [0x%p], dwFlags [%lx]",pv,pfn,dwFlags);

	TRY
	{
    	pdpLobbyObject = static_cast<DIRECTPLAYLOBBYOBJECT*>(GET_OBJECT_FROM_INTERFACE(pv));
	    
    	if( FAILED( hResultCode = DPL_ValidateRegisterMessageHandler( pv, pvUserContext, pfn, pdpnhConnection, dwFlags ) ) )
    	{
    	    DPFX(DPFPREP,  0, "Error validating register message handler params hr=[0x%lx]", hResultCode );
    	    DPF_RETURN( hResultCode );
    	}

    	// Ensure we've been initialized
    	if (pdpLobbyObject->pReceiveQueue != NULL)
    	{
    		DPFERR("Already initialized");
    		DPF_RETURN(DPNERR_ALREADYINITIALIZED);
    	}    	

		DNEnterCriticalSection( &g_csSingleTon );

		if (pdpLobbyObject->dwFlags & DPL_OBJECT_FLAG_LOBBIEDAPPLICATION )
		{
			if( g_fAppStarted )
			{
				DPFERR( "You can only start one lobbied application per process!" );
				DNLeaveCriticalSection( &g_csSingleTon );				
				DPF_RETURN( DPNERR_NOTALLOWED );
			}
			g_fAppStarted = TRUE;
		}
		else if( pdpLobbyObject->dwFlags & DPL_OBJECT_FLAG_LOBBYCLIENT )
		{
			if( g_fClientStarted )
			{
				DPFERR( "You can only start one lobby client per process!" );
				DNLeaveCriticalSection( &g_csSingleTon );				
				DPF_RETURN( DPNERR_NOTALLOWED );
			}
			g_fClientStarted = TRUE;
		}

		DNLeaveCriticalSection( &g_csSingleTon );
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}	

	// Disable parameter validation flag if DPNINITIALIZE_DISABLEPARAMVAL 
	// is specified 
	if( dwFlags & DPLINITIALIZE_DISABLEPARAMVAL )
	{
		pdpLobbyObject->dwFlags &= ~(DPL_OBJECT_FLAG_PARAMVALIDATION);
   	}

	pdpLobbyObject->pfnMessageHandler = pfn;
	pdpLobbyObject->pvUserContext = pvUserContext;

	pdpLobbyObject->pReceiveQueue = new CMessageQueue;


	if( pdpLobbyObject->pReceiveQueue == NULL )
	{
		DPFX(DPFPREP,  0, "Error allocating receive queue" );
		hResultCode = DPNERR_OUTOFMEMORY;
		goto ERROR_DPL_RegisterMessageHandler;		
	}

	pdpLobbyObject->pReceiveQueue->SetMessageHandler(static_cast<PVOID>(pdpLobbyObject),DPLMessageHandler);

	if (pdpLobbyObject->dwFlags & DPL_OBJECT_FLAG_LOBBIEDAPPLICATION)
	{
		cSuffix = DPL_MSGQ_OBJECT_SUFFIX_APPLICATION;
	}
	else
	{
		cSuffix = DPL_MSGQ_OBJECT_SUFFIX_CLIENT;
	}

	// Open application receive message queue
	dwCurrentPid = GetCurrentProcessId();
	if ((hResultCode = pdpLobbyObject->pReceiveQueue->Open(dwCurrentPid,
			cSuffix,DPL_MSGQ_SIZE,DPL_MSGQ_TIMEOUT_IDLE,0)) != DPN_OK)
	{
		DPFERR("Could not open App Rec Q");
		goto ERROR_DPL_RegisterMessageHandler;
	}

	if ((pdpLobbyObject->hReceiveThread =
			CreateThread(NULL,(DWORD)NULL,(LPTHREAD_START_ROUTINE)DPLProcessMessageQueue,
			static_cast<void*>(pdpLobbyObject->pReceiveQueue),(DWORD)NULL,&dwThreadId)) == NULL)
	{
		DPFERR("CreateThread() failed");
		hResultCode = DPNERR_GENERIC;
		pdpLobbyObject->pReceiveQueue->Close();
		goto ERROR_DPL_RegisterMessageHandler;
	}

	pdpLobbyObject->pReceiveQueue->WaitForReceiveThread(INFINITE);

	if (pdpLobbyObject->dwFlags & DPL_OBJECT_FLAG_LOBBIEDAPPLICATION)
	{
		DPFX(DPFPREP, 5,"Attempt lobby connection");

		hResultCode = DPLAttemptLobbyConnection(pdpLobbyObject);

		if ( hResultCode == DPN_OK)
		{
			if( pdpnhConnection )
				*pdpnhConnection = pdpLobbyObject->dpnhLaunchedConnection;

			DPFX(DPFPREP, 5,"Application was lobby launched");
			DPFX(DPFPREP, 5,"Waiting for true connect notification" );

			DWORD dwReturnValue = WaitForSingleObject( pdpLobbyObject->hConnectEvent, DPL_LOBBYLAUNCHED_CONNECT_TIMEOUT );

			DNASSERT( dwReturnValue == WAIT_OBJECT_0 );
		}
		else if( hResultCode != DPNERR_TIMEDOUT )
		{
			DPFX(DPFPREP, 5,"Application was not lobby launched");

			if( pdpnhConnection )
				*pdpnhConnection = NULL;

			// Need to reset return code to OK.. this is not an error
			hResultCode = DPN_OK;
		}
		else
		{
			DPFERR( "App was lobby launched but timed out establishing a connection" );
			if( pdpnhConnection )
				*pdpnhConnection = NULL;
		}
	}

EXIT_DPL_RegisterMessageHandler:

	DPF_RETURN(hResultCode);

ERROR_DPL_RegisterMessageHandler:

	DNEnterCriticalSection( &g_csSingleTon );

	if (pdpLobbyObject->dwFlags & DPL_OBJECT_FLAG_LOBBIEDAPPLICATION )
	{
		g_fAppStarted = FALSE;
	}
	else if( pdpLobbyObject->dwFlags & DPL_OBJECT_FLAG_LOBBYCLIENT )
	{
		g_fClientStarted = FALSE;
	}

	DNLeaveCriticalSection( &g_csSingleTon );

	goto EXIT_DPL_RegisterMessageHandler;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DPL_Close"

HRESULT DPL_Close(PVOID pv, const DWORD dwFlags )
{
	HRESULT					hResultCode;
	DWORD					dwNumHandles;
	DPNHANDLE				*prgHandles;
	DWORD					dw;
	DIRECTPLAYLOBBYOBJECT	*pdpLobbyObject;
	DPL_CONNECTION			*pConnection;

	DPFX(DPFPREP, 3,"Parameters: (none)");

	TRY
	{
    	pdpLobbyObject = static_cast<DIRECTPLAYLOBBYOBJECT*>(GET_OBJECT_FROM_INTERFACE(pv));
	    
    	if( FAILED( hResultCode = DPL_ValidateClose( pv, dwFlags  ) ) )
    	{
    	    DPFX(DPFPREP,  0, "Error validating close params hr=[0x%lx]", hResultCode );
    	    return hResultCode;
    	}

    	// Ensure we've been initialized
    	if (pdpLobbyObject->pReceiveQueue == NULL)
    	{
    		DPFERR("Already closed");
    	    return DPNERR_UNINITIALIZED;
    	}    	
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
    	return DPNERR_INVALIDOBJECT;
	}	

	// Shutdown the queue first to ensure that we don't end up shutting down a connection
	// twice!  (E.g. disconnect comes in as we are disconnecting it).
	if (pdpLobbyObject->pReceiveQueue)
	{
		if (pdpLobbyObject->pReceiveQueue->IsOpen())
		{

			// Ask receive thread to terminate
			DPFX(DPFPREP, 5,"Terminate Receive Msg Thread");
			pdpLobbyObject->pReceiveQueue->Terminate();

			// Wait for termination to occur
			if (WaitForSingleObject(pdpLobbyObject->hReceiveThread,INFINITE) != WAIT_OBJECT_0)
			{
				hResultCode = DPNERR_GENERIC;
				DPFERR("WaitForSingleObject failed");
			}
			pdpLobbyObject->pReceiveQueue->Close();

    		if (pdpLobbyObject->pReceiveQueue)
    		{
    			delete pdpLobbyObject->pReceiveQueue;			
    			pdpLobbyObject->pReceiveQueue = NULL;
    		}

			CloseHandle(pdpLobbyObject->hReceiveThread);
			pdpLobbyObject->hReceiveThread = NULL;
			
			CloseHandle(pdpLobbyObject->hConnectEvent);
			pdpLobbyObject->hConnectEvent = NULL;

			CloseHandle(pdpLobbyObject->hLobbyLaunchConnectEvent);
			pdpLobbyObject->hLobbyLaunchConnectEvent = NULL;
		}
	}

	// Enumerate handles outstanding 
	dwNumHandles = 0;		
	prgHandles = NULL;
	hResultCode = DPLConnectionEnum(pdpLobbyObject,prgHandles,&dwNumHandles);
	while (hResultCode == DPNERR_BUFFERTOOSMALL)
	{
		if (prgHandles)
			DNFree(prgHandles);

		if ((prgHandles = static_cast<DPNHANDLE*>(DNMalloc(dwNumHandles*sizeof(DPNHANDLE)))) != NULL)
		{
			hResultCode = DPLConnectionEnum(pdpLobbyObject,prgHandles,&dwNumHandles);
		}
		else
		{
			DPFERR("Could not allocate space for handle array");
			hResultCode = DPNERR_OUTOFMEMORY;
			break;
		}
	}

	// Send DISCONNECTs to all attached msg queues, for which there are handles
	if (hResultCode == DPN_OK)
	{
		for (dw = 0 ; dw < dwNumHandles ; dw++)
		{
			hResultCode = DPLConnectionFind(pdpLobbyObject,prgHandles[dw],&pConnection,TRUE );

			if( SUCCEEDED( hResultCode ) )
			{

				hResultCode = DPLConnectionDisconnect(pdpLobbyObject,prgHandles[dw]);

				if( FAILED( hResultCode ) )
				{
					DPFX(DPFPREP,  0, "Error disconnecting connection 0x%x", hResultCode );
				}

				DPLConnectionRelease( pdpLobbyObject,prgHandles[dw]);
			}
		}

		// Errors above are irrelevant, it's quite possible after building the list of outstanding 
		// connections that before we attempt to close the list one has gone away.
		// 
		hResultCode = DPN_OK;			
	}	

	if (prgHandles)
	{
		DNFree(prgHandles);
        prgHandles = NULL;
	}

	DNEnterCriticalSection( &g_csSingleTon );

	if (pdpLobbyObject->dwFlags & DPL_OBJECT_FLAG_LOBBIEDAPPLICATION )
	{
		g_fAppStarted = FALSE;
	}
	else if( pdpLobbyObject->dwFlags & DPL_OBJECT_FLAG_LOBBYCLIENT )
	{
		g_fClientStarted = FALSE;
	}

	DNLeaveCriticalSection( &g_csSingleTon );	

	DPF_RETURN( hResultCode );
}


#undef DPF_MODNAME
#define DPF_MODNAME "DPL_Send"

STDMETHODIMP DPL_Send(PVOID pv,
					  const DPNHANDLE hTarget,
					  BYTE *const pBuffer,
					  const DWORD dwBufferSize,
					  const DWORD dwFlags)
{
	HRESULT			hResultCode;
	DPL_CONNECTION	*pdplConnection;
	DIRECTPLAYLOBBYOBJECT	*pdpLobbyObject;
	DPNHANDLE		*hTargets = NULL;
	DWORD			dwNumTargets = 0;
	DWORD			dwTargetIndex = 0;

	DPFX(DPFPREP, 3,"Parameters: hTarget [0x%lx], pBuffer [0x%p], dwBufferSize [%ld], dwFlags [0x%lx]",
			hTarget,pBuffer,dwBufferSize,dwFlags);

	TRY
	{
    	pdpLobbyObject = static_cast<DIRECTPLAYLOBBYOBJECT*>(GET_OBJECT_FROM_INTERFACE(pv));
	    
    	if( pdpLobbyObject->dwFlags & DPL_OBJECT_FLAG_PARAMVALIDATION )
    	{
        	if( FAILED( hResultCode = DPL_ValidateSend( pv, hTarget, pBuffer, dwBufferSize, dwFlags ) ) )
        	{
        	    DPFX(DPFPREP,  0, "Error validating send params hr=[0x%lx]", hResultCode );
        	    DPF_RETURN( hResultCode );
        	}
    	}

    	// Ensure we've been initialized
    	if (pdpLobbyObject->pReceiveQueue == NULL)
    	{
    		DPFERR("Not initialized");
    		DPF_RETURN(DPNERR_UNINITIALIZED);
    	}    	
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}
	
	if( hTarget == DPLHANDLE_ALLCONNECTIONS )
	{
		dwNumTargets = 0;

		// We need loop so if someone adds a connection during our run
		// it gets added to our list
		//
		while( 1 )
		{
			hResultCode = DPLConnectionEnum( pdpLobbyObject, hTargets, &dwNumTargets );

			if( hResultCode == DPNERR_BUFFERTOOSMALL )
			{
				if( hTargets )
				{
					delete [] hTargets;
				}

				hTargets = new DPNHANDLE[dwNumTargets];

				if( hTargets == NULL )
				{
					DPFERR("Error allocating memory" );
					dwNumTargets = 0;
					hResultCode = DPNERR_OUTOFMEMORY;
					goto EXIT_AND_CLEANUP;
				}

				memset( hTargets, 0x00, sizeof(DPNHANDLE)*dwNumTargets);

				continue;
			}
			else if( FAILED( hResultCode ) )
			{
				DPFX(DPFPREP,  0, "Error getting list of connections hr=0x%x", hResultCode );
				break;
			}
			else
			{
				break;
			}
		}

		// Failed getting connection information
		if( FAILED( hResultCode ) )
		{
			if( hTargets )
			{
				delete [] hTargets;
				hTargets = NULL;
			}
			dwNumTargets = 0;
			goto EXIT_AND_CLEANUP;
		}

	}
	else
	{
		hTargets = new DPNHANDLE[1]; // We use array delete below so we need array new

		if( hTargets == NULL )
		{
			DPFERR("Error allocating memory" );
			dwNumTargets = 0;
			hResultCode = DPNERR_OUTOFMEMORY;
			goto EXIT_AND_CLEANUP;
		}

		dwNumTargets = 1;
		hTargets[0] = hTarget;
	}
		
	for( dwTargetIndex = 0; dwTargetIndex < dwNumTargets; dwTargetIndex++ )
	{
		if ((hResultCode = DPLConnectionFind(pdpLobbyObject,hTargets[dwTargetIndex],&pdplConnection,TRUE)) != DPN_OK)
		{
			DPFERR("Invalid send target");
			DisplayDNError(0,hResultCode);
			hResultCode = DPNERR_INVALIDHANDLE;
			goto EXIT_AND_CLEANUP;
		}

		DNASSERT(pdplConnection->pSendQueue != NULL);

		if (!pdplConnection->pSendQueue->IsReceiving())
		{
			DPFERR("Other side is not listening");
			DPLConnectionRelease(pdpLobbyObject,hTarget);
			hResultCode = DPNERR_INVALIDHANDLE;
			goto EXIT_AND_CLEANUP;
		}

		hResultCode = pdplConnection->pSendQueue->Send(pBuffer,dwBufferSize,INFINITE,DPL_MSGQ_MSGFLAGS_USER2,0);

		if( FAILED( hResultCode ) )
		{
			DPFX(DPFPREP,  0, "Error sending to connection 0x%x hr=0x%x", hTargets[dwTargetIndex], hResultCode );
		}
	}

EXIT_AND_CLEANUP:

	for( dwTargetIndex = 0; dwTargetIndex < dwNumTargets; dwTargetIndex++ )
	{
		if( hTargets[dwTargetIndex] )
			DPLConnectionRelease(pdpLobbyObject,hTargets[dwTargetIndex]);
	}

	if( hTargets )
		delete [] hTargets;

	DPF_RETURN(hResultCode);

}

#undef DPF_MODNAME
#define DPF_MODNAME "DPLReceiveIdleTimeout"
HRESULT DPLReceiveIdleTimeout(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
							  const DPNHANDLE hSender)
{
    HRESULT hResultCode = DPNERR_BUFFERTOOSMALL;
    DWORD dwHandleIndex;
    DPL_CONNECTION *pConnection;
    HANDLE hProcess;

    DPFX(DPFPREP,  6, "Enumerating processes, checking for exit" );

    while( 1 )
    {
        hResultCode = H_Enum( &pdpLobbyObject->hsHandles, &pdpLobbyObject->dwHandleBufferSize, 
                              pdpLobbyObject->phHandleBuffer );

        if( hResultCode == E_POINTER )
        {
            if( pdpLobbyObject->phHandleBuffer )
                delete [] pdpLobbyObject->phHandleBuffer;

            pdpLobbyObject->phHandleBuffer = new DPNHANDLE[pdpLobbyObject->dwHandleBufferSize];

            if( pdpLobbyObject->phHandleBuffer == NULL )
            {
                DPFERR( "Out of memory" );
                return DPNERR_OUTOFMEMORY;
            }
           
            hResultCode = H_Enum( &pdpLobbyObject->hsHandles, &pdpLobbyObject->dwHandleBufferSize, 
                              pdpLobbyObject->phHandleBuffer );
        }
        else if( FAILED( hResultCode ) )
        {
            DPFERR( "Error getting handle list" );
            return hResultCode;
        }
        else
        {
            break;
        }
    }

    for( dwHandleIndex = 0; dwHandleIndex < pdpLobbyObject->dwHandleBufferSize; dwHandleIndex++ )
    {
        hResultCode = DPLConnectionFind( pdpLobbyObject, pdpLobbyObject->phHandleBuffer[dwHandleIndex], 
                                         &pConnection, TRUE );

        if( hResultCode == DPN_OK )
        {
            hProcess = OpenProcess( PROCESS_DUP_HANDLE, FALSE,  pConnection->dwTargetPID );

            // We can close this handle.. after we're only just checking for existance.
			if( hProcess )
				CloseHandle( hProcess );

            // Process has exited..
            if( hProcess == NULL )
            {
                DPFX(DPFPREP,  6, "Process %d has exited", pConnection->dwTargetPID );
                DPLConnectionReceiveDisconnect( pdpLobbyObject, pdpLobbyObject->phHandleBuffer[dwHandleIndex], NULL, DPNERR_CONNECTIONLOST );
            }
            
            DPLConnectionRelease( pdpLobbyObject, pdpLobbyObject->phHandleBuffer[dwHandleIndex] );
        }
    }

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DPLReceiveUserMessage"

HRESULT DPLReceiveUserMessage(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
							  const DPNHANDLE hSender,
							  BYTE *const pBuffer,
							  const DWORD dwBufferSize)
{
	HRESULT			hResultCode;
	DPL_MESSAGE_RECEIVE	Msg;

	Msg.dwSize = sizeof(DPL_MESSAGE_RECEIVE);
	Msg.pBuffer = pBuffer;
	Msg.dwBufferSize = dwBufferSize;
	Msg.hSender = hSender;

	hResultCode = DPLConnectionGetContext( pdpLobbyObject, hSender, &Msg.pvConnectionContext );

	// Failed to get the connection's context -- strange, but we're going to indicate anyhow.  
	//
	if( FAILED( hResultCode ) )
	{
		DPFX(DPFPREP,  0, "Failed getting connection context hResultCode = 0x%x", hResultCode );
	}

	hResultCode = (pdpLobbyObject->pfnMessageHandler)(pdpLobbyObject->pvUserContext,
													  DPL_MSGID_RECEIVE,
													  reinterpret_cast<BYTE*>(&Msg));

	DPFX(DPFPREP, 3,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DPLMessageHandler"

HRESULT DPLMessageHandler(PVOID pvContext,
						  const DPNHANDLE hSender,
						  DWORD dwMessageFlags, 
						  BYTE *const pBuffer,
						  const DWORD dwBufferSize)
{
	DIRECTPLAYLOBBYOBJECT	*pdpLobbyObject;
	HRESULT		hResultCode;
	DWORD		*pdwMsgId;

    //  7/17/2000(RichGr) - IA64: Use %p format specifier for 32/64-bit pointers and handles.
	DPFX(DPFPREP, 3,"Parameters: hSender [0x%x], pBuffer [0x%p], dwBufferSize [%ld]",
			hSender,pBuffer,dwBufferSize);

	DNASSERT(pBuffer != NULL);

	/*if (dwBufferSize < sizeof(DWORD))
	{
		DPFERR("Invalid message");
		return(DPNERR_GENERIC);
	}*/

	pdpLobbyObject = static_cast<DIRECTPLAYLOBBYOBJECT*>(pvContext);
	pdwMsgId = reinterpret_cast<DWORD*>(pBuffer);

	if( dwMessageFlags & DPL_MSGQ_MSGFLAGS_USER1 )
	{
		DPFX(DPFPREP, 5,"Received INTERNAL message");
		switch(*pdwMsgId)
		{
		case DPL_MSGID_INTERNAL_IDLE_TIMEOUT:
		    {
		        DPFX(DPFPREP, 5,"Received: DPL_MSGID_INTERNAL_IDLE_TIMEOUT" );
		        DPLReceiveIdleTimeout(pdpLobbyObject,hSender);
		        break;
		    }
		case DPL_MSGID_INTERNAL_DISCONNECT:
			{
				DPFX(DPFPREP, 5,"Received: DPL_MSGID_INTERNAL_DISCONNECT");
				DPLConnectionReceiveDisconnect(pdpLobbyObject,hSender,pBuffer,DPN_OK);
				break;
			}

		case DPL_MSGID_INTERNAL_CONNECT_REQ:
			{
				DPFX(DPFPREP, 5,"Received: DPL_MSGID_INTERNAL_CONNECT_REQ");
				DPLConnectionReceiveREQ(pdpLobbyObject,pBuffer);
				break;
			}

		case DPL_MSGID_INTERNAL_CONNECT_ACK:
			{
				DPFX(DPFPREP, 5,"Received: DPL_MSGID_INTERNAL_CONNECT_ACK");
				DPLConnectionReceiveACK(pdpLobbyObject,hSender,pBuffer);
				break;
			}

		case DPL_MSGID_INTERNAL_UPDATE_STATUS:
			{
				DPFX(DPFPREP, 5,"Received: DPL_MSGID_INTERNAL_UPDATE_STATUS");
				DPLUpdateAppStatus(pdpLobbyObject,hSender,pBuffer);
				break;
			}

		case DPL_MSGID_INTERNAL_CONNECTION_SETTINGS:
		    {
		        DPFX(DPFPREP, 5,"Received: DPL_MSGID_INTERNAL_CONNECTION_SETTINGS");
		        DPLUpdateConnectionSettings(pdpLobbyObject,hSender,pBuffer);
		        break;
		    }

		default:
			{
				DPFX(DPFPREP, 5,"Received: Unknown message [0x%lx]",*pdwMsgId);
				DNASSERT(FALSE);
				break;
			}
		}
	}
	else if( dwMessageFlags & DPL_MSGQ_MSGFLAGS_USER2 )
	{
		DNASSERT( !(dwMessageFlags & DPL_MSGQ_MSGFLAGS_QUEUESYSTEM) );
		DPFX(DPFPREP, 5,"Received USER message");
		DPLReceiveUserMessage(pdpLobbyObject,hSender,pBuffer,dwBufferSize);
	}

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 3,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}

// DPLSendConnectionSettings
//
// This function is used to send a connection settings update message
#undef DPF_MODNAME
#define DPF_MODNAME "DPLSendConnectionSettings"
HRESULT DPLSendConnectionSettings( DIRECTPLAYLOBBYOBJECT * const pdpLobbyObject, 
								   const DPNHANDLE hConnection )
{
	BYTE *pbTransmitBuffer = NULL;
	DWORD dwTransmitBufferSize = 0;
	DPL_INTERNAL_CONNECTION_SETTINGS_UPDATE *pdplMsgSettings = NULL;
	DPL_CONNECTION *pdplConnection = NULL;
	CPackedBuffer PackBuffer;

	HRESULT			hResultCode = DPN_OK;

    hResultCode = DPLConnectionFind(pdpLobbyObject, hConnection, &pdplConnection, TRUE );

    if( FAILED( hResultCode ) )
    {
        DPFERR( "Unable to find specified connection" );
        return hResultCode;
    }

    // Grab lock to prevent other people from interfering
    DNEnterCriticalSection( &pdplConnection->csLock );

    PackBuffer.Initialize( NULL, 0 );

    PackBuffer.AddToFront( NULL, sizeof( DPL_INTERNAL_CONNECTION_SETTINGS_UPDATE_HEADER ) );

    if( pdplConnection->pConnectionSettings )
    {
    	pdplConnection->pConnectionSettings->BuildWireStruct( &PackBuffer );
    }

    dwTransmitBufferSize = PackBuffer.GetSizeRequired();

    pbTransmitBuffer = new BYTE[ dwTransmitBufferSize ];

    if( !pbTransmitBuffer )
    {
    	DPFX( DPFPREP, 0, "Error allocating memory" );
    	hResultCode = DPNERR_OUTOFMEMORY;
    	goto DPLSENDCONNECTSETTINGS_DONE;
    }

    pdplMsgSettings = (DPL_INTERNAL_CONNECTION_SETTINGS_UPDATE *) pbTransmitBuffer;

    PackBuffer.Initialize( pbTransmitBuffer, dwTransmitBufferSize );

    DNASSERT( pdplMsgSettings );

    hResultCode = PackBuffer.AddToFront( NULL, sizeof( DPL_INTERNAL_CONNECTION_SETTINGS_UPDATE_HEADER ) );

	if( FAILED( hResultCode ) ) 
	{
		DPFX( DPFPREP, 0, "Error adding main struct hr [0x%x]", hResultCode );
		goto DPLSENDCONNECTSETTINGS_DONE;
	}

	if( pdplConnection->pConnectionSettings )
	{
		hResultCode = pdplConnection->pConnectionSettings->BuildWireStruct( &PackBuffer );

		if( FAILED( hResultCode ) )
		{
			DPFX( DPFPREP, 0, "Error adding connect struct hr [0x%x]", hResultCode );
			goto DPLSENDCONNECTSETTINGS_DONE;			
		}
		
    	pdplMsgSettings->dwConnectionSettingsSize = 1;		
	}
	else
	{
    	pdplMsgSettings->dwConnectionSettingsSize = 0;		
	}

   	pdplMsgSettings->dwMsgId = DPL_MSGID_INTERNAL_CONNECTION_SETTINGS;

	if (!pdplConnection->pSendQueue->IsReceiving())
	{
		DPFERR("Other side is not receiving");
		goto DPLSENDCONNECTSETTINGS_DONE;
	}

	hResultCode = pdplConnection->pSendQueue->Send(reinterpret_cast<BYTE*>(pdplMsgSettings),
												   PackBuffer.GetSizeRequired(),
												   INFINITE,
												   DPL_MSGQ_MSGFLAGS_USER1, 
												   0);
	if ( FAILED( hResultCode ) )
	{
		DPFX(DPFPREP, 0, "Could not send connect settings hr [0x%x]", hResultCode );
		goto DPLSENDCONNECTSETTINGS_DONE;
	}

    hResultCode = DPN_OK;

DPLSENDCONNECTSETTINGS_DONE:

	if( pbTransmitBuffer )
		delete [] pbTransmitBuffer;

    DNLeaveCriticalSection( &pdplConnection->csLock );	

    DPLConnectionRelease(pdpLobbyObject,hConnection);

    return hResultCode;

}


	

// DPLUpdateConnectionSettings
//
// This function is called when a connection settings update message has been received.
//
#undef DPF_MODNAME
#define DPF_MODNAME "DPLUpdateConnectionSettings"
HRESULT DPLUpdateConnectionSettings(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
                           const DPNHANDLE hSender,
						   BYTE *const pBuffer )
{
	HRESULT		hr;
	DPL_MESSAGE_CONNECTION_SETTINGS 			MsgConnectionSettings;
	DPL_CONNECTION_SETTINGS                     *pSettingsBuffer = NULL;
	DWORD                                       dwSettingsBufferSize = 0;
	BOOL										fAddressReferences = FALSE;
	CConnectionSettings							*pConnectionSettings = NULL;
	DPL_INTERNAL_CONNECTION_SETTINGS_UPDATE		*pConnectionSettingsMsg = NULL;

	DPFX(DPFPREP, 3,"Parameters: pBuffer [0x%p]",pBuffer);

	DNASSERT(pdpLobbyObject != NULL);
	DNASSERT(pBuffer != NULL);

	pConnectionSettingsMsg = (DPL_INTERNAL_CONNECTION_SETTINGS_UPDATE *) pBuffer;

	if( pConnectionSettingsMsg->dwConnectionSettingsSize )
	{
		pConnectionSettings = new CConnectionSettings();

		if( !pConnectionSettings )
		{
			DPFX( DPFPREP, 0, "Error allocating connection settings" );
			hr = DPNERR_OUTOFMEMORY;
			goto UPDATESETTINGS_FAILURE;
		}

		hr = pConnectionSettings->Initialize( &pConnectionSettingsMsg->dplConnectionSettings, (UNALIGNED BYTE *) pConnectionSettingsMsg ); 

		if( FAILED( hr ) )
		{
			DPFX( DPFPREP, 0, "Error building structure from wire struct hr [0x%x]", hr );
			goto UPDATESETTINGS_FAILURE;  
		}
	}

	// Set the connection settings on the object
	hr = DPLConnectionSetConnectSettings( pdpLobbyObject, hSender, pConnectionSettings );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Error setting connection settings hr = 0x%x", hr );
		goto UPDATESETTINGS_FAILURE;
	}	

	// Setup message to indicate to user
	MsgConnectionSettings.dwSize = sizeof(DPL_MESSAGE_CONNECTION_SETTINGS);
	MsgConnectionSettings.hSender = hSender;

	if( pConnectionSettings )
		MsgConnectionSettings.pdplConnectionSettings = pConnectionSettings->GetConnectionSettings();
	else
		MsgConnectionSettings.pdplConnectionSettings = NULL;

	hr = DPLConnectionGetContext( pdpLobbyObject, hSender, &MsgConnectionSettings.pvConnectionContext );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Error getting connection's context value" );
		goto UPDATESETTINGS_FAILURE;
	}	

	hr = (pdpLobbyObject->pfnMessageHandler)(pdpLobbyObject->pvUserContext,
										     DPL_MSGID_CONNECTION_SETTINGS,
											 reinterpret_cast<BYTE*>(&MsgConnectionSettings));	

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP, 1, "Error returned from user callback -- ignored hr [0x%x]", hr );
	}


	return DPN_OK;

UPDATESETTINGS_FAILURE:	

	if( pConnectionSettings )
		delete pConnectionSettings;

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\lobby\dplclient.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DPLClient.h
 *  Content:    DirectPlay Lobby Client Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   02/21/00	mjn		Created
 *   03/22/2000	jtk		Changed interface names
 *   04/25/2000 rmt     Bug #s 33138, 33145, 33150 
 *   05/03/00   rmt     Bug #33879 -- Status messsage missing from field 
 *   06/15/00   rmt     Bug #33617 - Must provide method for providing automatic launch of DirectPlay instances  
 *   07/08/2000	rmt		Bug #38725 - Need to provide method to detect if app was lobby launched
 *				rmt		Bug #38757 - Callback messages for connections may return AFTER WaitForConnection returns
 *				rmt		Bug #38755 - No way to specify player name in Connection Settings
 *				rmt		Bug #38758 - DPLOBBY8.H has incorrect comments
 *				rmt		Bug #38783 - pvUserApplicationContext is only partially implemented
 *				rmt		Added DPLHANDLE_ALLCONNECTIONS and dwFlags (reserved field to couple of funcs).
 *@@END_MSINTERNAL
 *
 ***************************************************************************/


#ifndef	__DPLCLIENT_H__
#define	__DPLCLIENT_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

class CMessageQueue;

//**********************************************************************
// Variable definitions
//**********************************************************************

//
// VTable for lobbied application interface
//
extern IDirectPlay8LobbyClientVtbl DPL_Lobby8ClientVtbl;

//**********************************************************************
// Function prototypes
//**********************************************************************

STDMETHODIMP DPL_EnumLocalPrograms(IDirectPlay8LobbyClient *pInterface,
							  GUID *const pGuidApplication,
							  BYTE *const pEnumData,
							  DWORD *const pdwEnumDataSize,
							  DWORD *const pdwEnumDataItems,
							  const DWORD dwFlags );

STDMETHODIMP DPL_ConnectApplication(IDirectPlay8LobbyClient *pInterface,
							   DPL_CONNECT_INFO *const pdplConnectionInfo,
							   const PVOID pvUserApplicationContext,
							   DPNHANDLE *const hApplication,
							   const DWORD dwTimeOut,
							   const DWORD dwFlags);

STDMETHODIMP DPL_ReleaseApplication(IDirectPlay8LobbyClient *pInterface,
									const DPNHANDLE hApplication, 
									const DWORD dwFlags );

HRESULT DPLSendLobbyClientInfo(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
							   CMessageQueue *const pMessageQueue);

HRESULT	DPLLaunchApplication(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
							 DPL_PROGRAM_DESC *const pdplProgramDesc,
							 DWORD *const pdwPID,
							 const DWORD dwTimeOut);

HRESULT DPLUpdateAppStatus(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
                           const DPNHANDLE hSender,
						   BYTE *const pBuffer);

HRESULT DPLUpdateConnectionSettings(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
                           const DPNHANDLE hSender,
						   BYTE *const pBuffer );

#endif	// __DNLCLIENT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\lobby\dplconnect.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DPLConnect.cpp
 *  Content:    DirectPlay Lobby Connection Functions
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   02/21/00	mjn		Created
 *   05/08/00   rmt     Bug #33616 -- Does not run on Win9X 
 *   05/30/00	rmt		Bug #35700 - ConnectApp(h), Release(h), Release(h) returns OK
 *                      Added an additional release, handles were never getting destroyed
 *  06/15/00    rmt     Bug #33617 - Must provide method for providing automatic launch of DirectPlay instances   
 *  06/28/00	rmt		Prefix Bug #38082
 *  07/08/2000	rmt		Bug #38725 - Need to provide method to detect if app was lobby launched
 *				rmt		Bug #38757 - Callback messages for connections may return AFTER WaitForConnection returns
 *				rmt		Bug #38755 - No way to specify player name in Connection Settings
 *				rmt		Bug #38758 - DPLOBBY8.H has incorrect comments
 *				rmt		Bug #38783 - pvUserApplicationContext is only partially implemented
 *				rmt		Added DPLHANDLE_ALLCONNECTIONS and dwFlags (reserved field to couple of funcs).
 *  08/05/2000  RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *  08/18/2000	rmt		Bug #42751 - DPLOBBY8: Prohibit more than one lobby client or lobby app per process 
 *  08/30/2000	rmt		Bug #171827 - Prefix Bug 
 *  01/04/2001	rodtoll	WinBug #94200 - Remove BUGBUGs from Code.   
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dnlobbyi.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


#undef DPF_MODNAME
#define DPF_MODNAME "DPLConnectionNew"

HRESULT	DPLConnectionNew(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
						 DPNHANDLE *const phConnect,
						 DPL_CONNECTION **const ppdplConnection)
{
	HRESULT			hResultCode;
	DPL_CONNECTION	*pdplConnection;
	DPNHANDLE		handle;

	DPFX(DPFPREP, 3,"Parameters: phConnect [0x%p], ppdplConnection [0x%p]",phConnect,ppdplConnection);

	if( ppdplConnection == NULL )
	{
		DPFERR( "ppdplConnection param is NULL -- this should not happen" );
		DNASSERT( FALSE );
		return DPNERR_GENERIC;
	}

	// Create connection entry
	if ((pdplConnection = static_cast<DPL_CONNECTION*>(DNMalloc(sizeof(DPL_CONNECTION)))) == NULL)
	{
		DPFERR("Could not allocate Connection entry");
		return(DPNERR_OUTOFMEMORY);
	}

	// Create connection handle
	if ((hResultCode = H_Create(&pdpLobbyObject->hsHandles,
			static_cast<void*>(pdplConnection),&handle)) != DPN_OK)
	{
		DPFERR("Could not create Connection handle");
		DisplayDNError(0,hResultCode);
		DNFree(pdplConnection);
		return(hResultCode);
	}

	// Create connect event
	pdplConnection->hConnectEvent = CreateEvent(NULL,TRUE,FALSE,NULL);
	if (pdplConnection->hConnectEvent == NULL)
	{
		DPFERR("Could not create connection connect event");
		H_Destroy(&pdpLobbyObject->hsHandles,handle);
		DNFree(pdplConnection);
		return(DPNERR_OUTOFMEMORY);
	}

	// Initialize entry
	pdplConnection->hConnect = handle;
	pdplConnection->dwTargetPID = 0;
	pdplConnection->pSendQueue = NULL;
	pdplConnection->lRefCount = 1;
	pdplConnection->pConnectionSettings = NULL;
	pdplConnection->pvConnectContext = NULL;

    if (DNInitializeCriticalSection( &pdplConnection->csLock ) == FALSE)
	{
		DPFERR("Could not initialize connection CS");
		CloseHandle(pdplConnection->hConnectEvent);
		H_Destroy(&pdpLobbyObject->hsHandles,handle);
		DNFree(pdplConnection);
		return(DPNERR_OUTOFMEMORY);
	}

	*phConnect = handle;
	if (ppdplConnection != NULL)
		*ppdplConnection = pdplConnection;

	DPFX(DPFPREP, 3,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DPLConnectionFind"

HRESULT DPLConnectionFind(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
						  const DPNHANDLE hConnect,
						  DPL_CONNECTION **const ppdplConnection,
						  const BOOL bAddRef)
{
	HRESULT			hResultCode;
	DPL_CONNECTION	*pdplConnection;

	DPFX(DPFPREP, 3,"Parameters: hConnect [0x%lx], ppdplConnection [0x%p], bAddRef [%ld]",
			hConnect,ppdplConnection,bAddRef);

	DNASSERT(pdpLobbyObject != NULL);
	DNASSERT(hConnect != NULL);
	DNASSERT(ppdplConnection != NULL);

	if ((hResultCode = H_Retrieve(&pdpLobbyObject->hsHandles,hConnect,
			reinterpret_cast<void**>(&pdplConnection))) != DPN_OK)
	{
		DPFERR("Could not retrieve handle");
		return(hResultCode);
	}

	if (bAddRef)
	{
		InterlockedIncrement(&pdplConnection->lRefCount);
	}

	*ppdplConnection = pdplConnection;

	DPFX(DPFPREP, 3,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}

// DPLConnectionGetConnectSettings
//
// This function gets the connection settings attached to the specified connection.
//
#undef DPF_MODNAME
#define DPF_MODNAME "DPLConnectionGetConnectSettings"
HRESULT DPLConnectionGetConnectSettings( DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
						 DPNHANDLE const hConnect, 
						 DPL_CONNECTION_SETTINGS * const pdplConnectSettings,
						 DWORD * const pdwDataSize )	
{
	HRESULT			hResultCode;
	DPL_CONNECTION	*pdplConnection;

    hResultCode = DPLConnectionFind(pdpLobbyObject, hConnect, &pdplConnection, TRUE );

    if( FAILED( hResultCode ) )
    {
        DPFERR( "Unable to find specified connection" );
        return hResultCode;
    }

    // Grab lock to keep people from interfering.
    DNEnterCriticalSection( &pdplConnection->csLock );

    if( !pdplConnection->pConnectionSettings )
    {
    	*pdwDataSize = 0;
    	hResultCode = DPNERR_DOESNOTEXIST;
    	goto GETCONNECTIONSETTINGS_EXIT;
    }

    hResultCode = pdplConnection->pConnectionSettings->CopyToBuffer( (BYTE *) pdplConnectSettings, pdwDataSize );

GETCONNECTIONSETTINGS_EXIT:
  
    DNLeaveCriticalSection( &pdplConnection->csLock );        

    // Release this function's reference
    DPLConnectionRelease( pdpLobbyObject, hConnect );            

    return hResultCode;
    
}


// DPLConnectionSetConnectSettings
//
// This function sets the connection settings attached to the specified connection.
//
#undef DPF_MODNAME
#define DPF_MODNAME "DPLConnectionSetConnectSettings"
HRESULT DPLConnectionSetConnectSettings( 
                    DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
					const DPNHANDLE hConnect, 
					CConnectionSettings * pConnectionSettings )
{
	HRESULT			hResultCode;
	DPL_CONNECTION	*pdplConnection;

    hResultCode = DPLConnectionFind(pdpLobbyObject, hConnect, &pdplConnection, TRUE );

    if( FAILED( hResultCode ) )
    {
        DPFERR( "Unable to find specified connection" );
        return hResultCode;
    }

    // Grab lock to prevent other people from interfering
    DNEnterCriticalSection( &pdplConnection->csLock );

	// Free old one if there is one
	if( pdplConnection->pConnectionSettings )
	{
		delete pdplConnection->pConnectionSettings;
		pdplConnection->pConnectionSettings = NULL;
	}

	pdplConnection->pConnectionSettings = pConnectionSettings;

    hResultCode = DPN_OK;

    DNLeaveCriticalSection( &pdplConnection->csLock );

    DPLConnectionRelease( pdpLobbyObject, hConnect );

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DPLConnectionGetContext"
HRESULT DPLConnectionGetContext(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
								const DPNHANDLE hConnection, 
								PVOID *ppvConnectContext )
{
	HRESULT			hResultCode;
	DPL_CONNECTION	*pdplConnection;

    hResultCode = DPLConnectionFind(pdpLobbyObject, hConnection, &pdplConnection, TRUE );

    if( FAILED( hResultCode ) )
    {
		*ppvConnectContext = NULL;
        DPFERR( "Unable to find specified connection" );
        return hResultCode;
    }

	// Set connection context for the found handle
	DNEnterCriticalSection( &pdplConnection->csLock );
	*ppvConnectContext = pdplConnection->pvConnectContext;
    DNLeaveCriticalSection( &pdplConnection->csLock );

	// Release our reference to the connection 
    DPLConnectionRelease( pdpLobbyObject, hConnection );

	return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DPLConnectionSetContext"
HRESULT DPLConnectionSetContext(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
								const DPNHANDLE hConnection, 
								PVOID pvConnectContext )
{
	HRESULT			hResultCode;
	DPL_CONNECTION	*pdplConnection;

    hResultCode = DPLConnectionFind(pdpLobbyObject, hConnection, &pdplConnection, TRUE );

    if( FAILED( hResultCode ) )
    {
        DPFERR( "Unable to find specified connection" );
        return hResultCode;
    }

	// Set connection context for the found handle
	DNEnterCriticalSection( &pdplConnection->csLock );
	pdplConnection->pvConnectContext = pvConnectContext;
    DNLeaveCriticalSection( &pdplConnection->csLock );

	// Release our reference to the connection 
    DPLConnectionRelease( pdpLobbyObject, hConnection );

	return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DPLConnectionRelease"

HRESULT DPLConnectionRelease(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
							 const DPNHANDLE hConnect)
{
	HRESULT			hResultCode;
	DPL_CONNECTION	*pdplConnection;
	LONG			lRefCount;

	DPFX(DPFPREP, 3,"Parameters: hConnect [0x%lx]",hConnect);

	if ((hResultCode = H_Retrieve(&pdpLobbyObject->hsHandles,hConnect,
		reinterpret_cast<void**>(&pdplConnection))) != DPN_OK)
	{
		DPFERR("Could not retrieve connection");
		DisplayDNError(0,hResultCode);
    	return(hResultCode);
	}

	if (InterlockedDecrement(&pdplConnection->lRefCount) == 0)
	{
		H_Destroy(&pdpLobbyObject->hsHandles,hConnect);
		
		DPFX(DPFPREP, 5,"Freeing object");
		if (pdplConnection->pSendQueue)
		{
			pdplConnection->pSendQueue->Close();
			delete pdplConnection->pSendQueue;
			pdplConnection->pSendQueue = NULL;

            delete pdplConnection->pConnectionSettings;
			pdplConnection->pConnectionSettings = NULL;
			DNDeleteCriticalSection( &pdplConnection->csLock );
		}

		CloseHandle(pdplConnection->hConnectEvent);

    	DNFree(pdplConnection);
	}
	
	DPFX(DPFPREP, 3,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DPLConnectionConnect"

HRESULT DPLConnectionConnect(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
							 const DPNHANDLE hConnect,
							 const DWORD dwProcessId, 
							 const BOOL fApplication )
{
	HRESULT			hResultCode;
	DPL_CONNECTION	*pdplConnection;

	DPFX(DPFPREP, 3,"Parameters: hConnect [0x%lx], dwProcessId [0x%lx]",
			hConnect,dwProcessId);

	DNASSERT(pdpLobbyObject != NULL);
	DNASSERT(hConnect != NULL);
	DNASSERT(dwProcessId != 0);

	if ((hResultCode = DPLConnectionFind(pdpLobbyObject,hConnect,&pdplConnection,TRUE)) != DPN_OK)
	{
		DPFERR("Could not find connection");
		DisplayDNError(0,hResultCode);
		return(hResultCode);
	}

	pdplConnection->pSendQueue = new CMessageQueue;

	if( !pdplConnection->pSendQueue )
	{
		DPFERR("Could not allocate queue out of memory");
		DPLConnectionRelease(pdpLobbyObject,hConnect);
		hResultCode = DPNERR_OUTOFMEMORY;
		return(hResultCode);
	}

	hResultCode = pdplConnection->pSendQueue->Open(dwProcessId,
												   (fApplication) ? DPL_MSGQ_OBJECT_SUFFIX_APPLICATION : DPL_MSGQ_OBJECT_SUFFIX_CLIENT,
												   DPL_MSGQ_SIZE,
												   0, INFINITE);
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not open message queue");
		DisplayDNError(0,hResultCode);
		delete pdplConnection->pSendQueue;
		pdplConnection->pSendQueue = NULL;
		DPLConnectionRelease(pdpLobbyObject,hConnect);
		return(hResultCode);
	}

	// Ensure other side is still connected to MsgQ
	if (!pdplConnection->pSendQueue->IsReceiving())
	{
		DPFERR("Application is not receiving");
		pdplConnection->pSendQueue->Close();
		delete pdplConnection->pSendQueue;
		pdplConnection->pSendQueue = NULL;
		DPLConnectionRelease(pdpLobbyObject,hConnect);
		return(DPNERR_DOESNOTEXIST);
	}

	DPLConnectionRelease(pdpLobbyObject,hConnect);

	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DPLConnectionDisconnect"

HRESULT DPLConnectionDisconnect(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
								const DPNHANDLE hConnect )
{
	HRESULT			hResultCode;
	DPL_CONNECTION	*pdplConnection;
	DPL_INTERNAL_MESSAGE_DISCONNECT	Msg;

	DPFX(DPFPREP, 3,"Parameters: hConnect [0x%lx]",hConnect);

	DNASSERT(pdpLobbyObject != NULL);
	DNASSERT(hConnect != NULL);

	if ((hResultCode = DPLConnectionFind(pdpLobbyObject,hConnect,&pdplConnection,TRUE)) != DPN_OK)
	{
		DPFERR("Could not find connection");
		DisplayDNError(0,hResultCode);
		return(hResultCode);
	}

	Msg.dwMsgId = DPL_MSGID_INTERNAL_DISCONNECT;
	Msg.dwPID = pdpLobbyObject->dwPID;

	hResultCode = pdplConnection->pSendQueue->Send(reinterpret_cast<BYTE*>(&Msg),
			sizeof(DPL_INTERNAL_MESSAGE_DISCONNECT),INFINITE,DPL_MSGQ_MSGFLAGS_USER1,0);

	// Release the reference for the Find above
	DPLConnectionRelease(pdpLobbyObject,hConnect);

	// Release the interface's reference
	DPLConnectionRelease(pdpLobbyObject,hConnect);

	DPFX(DPFPREP, 3,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//	DPLConnectionEnum
//
//	Enumerate outstanding connections

#undef DPF_MODNAME
#define DPF_MODNAME "DPLConnectionEnum"

HRESULT DPLConnectionEnum(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
						  DPNHANDLE *const prghConnect,
						  DWORD *const pdwNum)
{
	HRESULT		hResultCode;
	HRESULT		hr;

	DPFX(DPFPREP, 3,"Parameters: prghConnect [0x%p], pdwNum [0x%p]",prghConnect,pdwNum);

	hr = H_Enum(&pdpLobbyObject->hsHandles,pdwNum,prghConnect);
	if (hr == S_OK)
	{
		hResultCode = DPN_OK;
	}
	else if (hr == E_POINTER)
	{
		hResultCode = DPNERR_BUFFERTOOSMALL;
	}
	else
	{
		hResultCode = DPNERR_GENERIC;
	}

	DPFX(DPFPREP, 3,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//	DPLConnectionSendREQ
//
//	Send a request to connect to another process.
//	We will provide the handle of the current Connection to the other side
//		to send back as the SenderContext with messages to the local process
//		so that we can easily lookup info.
//	We will also provide the local PID so the other side can connect to us

#undef DPF_MODNAME
#define DPF_MODNAME "DPLConnectionSendREQ"

HRESULT DPLConnectionSendREQ(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
							 const DPNHANDLE hConnect,
							 const DWORD dwPID,
							 DPL_CONNECT_INFO *const pInfo)
{
	HRESULT			hResultCode;
	DPL_CONNECTION	*pdplConnection;
	DPL_INTERNAL_MESSAGE_CONNECT_REQ	*pMsg = NULL;
	DWORD			dwSize;
	CPackedBuffer	PackedBuffer;
	DWORD           dwConnectSettingsSize;
	CConnectionSettings *pConnectSettings = NULL;
	PBYTE			pbTmpBuffer = NULL;

	DPFX(DPFPREP, 3,"Parameters: hConnect [0x%lx]",hConnect);

	DNASSERT(pdpLobbyObject != NULL);
	DNASSERT(hConnect != NULL);

	if ((hResultCode = DPLConnectionFind(pdpLobbyObject,hConnect,&pdplConnection,TRUE)) != DPN_OK)
	{
		DPFERR("Could not find connection");
		DisplayDNError(0,hResultCode);
		return(hResultCode);
	}

	if (!pdplConnection->pSendQueue->IsReceiving())
	{
		DPFERR("Other side is not receiving");
		DPLConnectionRelease(pdpLobbyObject,hConnect);
		return(DPNERR_DOESNOTEXIST);
	}

	DNEnterCriticalSection( &pdplConnection->csLock );

	if( pInfo->pdplConnectionSettings )
	{
		pConnectSettings = new CConnectionSettings();

		if( !pConnectSettings )
		{
			DPFERR("Error allocating memory");
			hResultCode = DPNERR_OUTOFMEMORY;
			goto CONNECTREQ_EXIT;
		}

		hResultCode = pConnectSettings->InitializeAndCopy( pInfo->pdplConnectionSettings );

		if( FAILED( hResultCode ) )
		{
			DPFX(DPFPREP, 0, "Error copying settings hr [0x%x]", hResultCode );
			goto CONNECTREQ_EXIT;
		}
	}

	PackedBuffer.Initialize( NULL, 0 );	

	// Determine size of message to send.
	PackedBuffer.AddToFront(NULL,sizeof(DPL_INTERNAL_MESSAGE_CONNECT_REQ_HEADER));

	// Add connect settings if they exist
	if( pInfo->pdplConnectionSettings )
		pConnectSettings->BuildWireStruct(&PackedBuffer);

	// Add lobby connect data
	PackedBuffer.AddToBack(NULL,pInfo->dwLobbyConnectDataSize);

	pbTmpBuffer = new BYTE[PackedBuffer.GetSizeRequired()];

	if( !pbTmpBuffer )
	{
		DPFERR("Error allocating memory" );
		hResultCode = DPNERR_OUTOFMEMORY;
		goto CONNECTREQ_EXIT;
	}

	pMsg = (DPL_INTERNAL_MESSAGE_CONNECT_REQ *) pbTmpBuffer;

	PackedBuffer.Initialize( pMsg, PackedBuffer.GetSizeRequired() );

	hResultCode = PackedBuffer.AddToFront( pMsg, sizeof( DPL_INTERNAL_MESSAGE_CONNECT_REQ_HEADER ) );

	if( FAILED( hResultCode ) )
	{
		DPFX( DPFPREP, 0, "Internal error! hr [0x%x]", hResultCode );
		goto CONNECTREQ_EXIT;
	}

	pMsg->dwMsgId = DPL_MSGID_INTERNAL_CONNECT_REQ;
	pMsg->hSender = hConnect;
	pMsg->dwSenderPID = dwPID;	

	if( pInfo->pdplConnectionSettings )
	{
		hResultCode = pConnectSettings->BuildWireStruct(&PackedBuffer);

		if( FAILED( hResultCode ) )
		{
			DPFX( DPFPREP, 0, "Error building wire struct for settings hr [0x%x]", hResultCode );
			goto CONNECTREQ_EXIT;
		}
		
		pMsg->dwConnectionSettingsSize = 1;		
	}
	else
	{
		pMsg->dwConnectionSettingsSize = 0;
	}

	hResultCode = PackedBuffer.AddToBack(pInfo->pvLobbyConnectData, pInfo->dwLobbyConnectDataSize, FALSE);

	if( FAILED( hResultCode ) )
	{
		DPFX( DPFPREP, 0, "Error adding connect data hr [0x%x]", hResultCode );
		goto CONNECTREQ_EXIT;
	}

	pMsg->dwLobbyConnectDataOffset = PackedBuffer.GetTailOffset();
	pMsg->dwLobbyConnectDataSize = pInfo->dwLobbyConnectDataSize;

	hResultCode = DPLConnectionSetConnectSettings( pdpLobbyObject, hConnect,pConnectSettings );

	if( FAILED( hResultCode ) )
	{
	    DPFERR( "Could not set local copy of connection settings" );
	    goto CONNECTREQ_EXIT;
	}

	hResultCode = pdplConnection->pSendQueue->Send(reinterpret_cast<BYTE*>(pMsg),
												   PackedBuffer.GetSizeRequired(),
												   INFINITE,
												   DPL_MSGQ_MSGFLAGS_USER1,
												   0);
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not send connect info");
		goto CONNECTREQ_EXIT;
	}

CONNECTREQ_EXIT:	

	DNLeaveCriticalSection( &pdplConnection->csLock );	

    if( pbTmpBuffer )
    	delete [] pbTmpBuffer;

	DPLConnectionRelease(pdpLobbyObject,hConnect);

	DPFX(DPFPREP, 3,"Returning: [0x%lx]",hResultCode);

	if( FAILED( hResultCode ) )
	{
		if( pConnectSettings )
			delete pConnectSettings;
	}
	
	return(hResultCode);
}


//	DPLConnectionReceiveREQ
//
//	Receive a request to connect.
//	Attempt to connect to the requesting process using the PID supplied.
//	Keep the supplied SenderContext for future sends directed at that process.
//	Send a connect acknowledge

#undef DPF_MODNAME
#define DPF_MODNAME "DPLConnectionReceiveREQ"

HRESULT DPLConnectionReceiveREQ(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
								BYTE *const pBuffer)
{
	HRESULT			hResultCode;
	DPNHANDLE		handle;
	DPL_CONNECTION	*pdplConnection;
	DPL_INTERNAL_MESSAGE_CONNECT_REQ	*pMsg;
	DPL_MESSAGE_CONNECT		MsgConnect;
	DPL_CONNECTION_SETTINGS *pSettingsBuffer = NULL;
	DWORD                   dwSettingsBufferSize = 0;
	BOOL			fLobbyLaunching = FALSE;
	CConnectionSettings *pConnectSettings = NULL;
	BYTE *pbTmpBuffer = NULL; 


	DPFX(DPFPREP, 3,"Parameters: pBuffer [0x%p]",pBuffer);

	DNASSERT(pdpLobbyObject != NULL);
	DNASSERT(pBuffer != NULL);

	pMsg = reinterpret_cast<DPL_INTERNAL_MESSAGE_CONNECT_REQ*>(pBuffer);

	if ((hResultCode = DPLConnectionNew(pdpLobbyObject,&handle,&pdplConnection)) != DPN_OK)
	{
		DPFERR("Could not create new connection");
		DisplayDNError(0,hResultCode);
		return(hResultCode);
	}

	if ((hResultCode = DPLConnectionConnect(pdpLobbyObject,handle,pMsg->dwSenderPID,FALSE)) != DPN_OK)
	{
		DPFERR("Could not perform requested connection");
		goto CONNECTRECVREQ_ERROR;
	}

	pdplConnection->pSendQueue->SetSenderHandle(pMsg->hSender);
	pdplConnection->dwTargetPID = pMsg->dwSenderPID;

	if ((hResultCode = DPLConnectionSendACK(pdpLobbyObject,handle)) != DPN_OK)
	{
		DPFERR("Could not send connection acknowledge");
		goto CONNECTRECVREQ_ERROR;
	}

    if( pdpLobbyObject->dwFlags & DPL_OBJECT_FLAG_MULTICONNECT)
    {
        DPFX(DPFPREP,  1, "Multiconnect flag specified, returning app to available status" );
        pdpLobbyObject->pReceiveQueue->MakeAvailable();
    }

    if( pMsg->dwConnectionSettingsSize )
    {
	 	pConnectSettings = new CConnectionSettings();

	 	if( !pConnectSettings )
	 	{
			DPFERR("Error allocating structure");
			hResultCode = DPNERR_OUTOFMEMORY;
			goto CONNECTRECVREQ_ERROR;
	 	}

	 	hResultCode = pConnectSettings->Initialize( &pMsg->dplConnectionSettings, (UNALIGNED BYTE *) pMsg );

	 	if( FAILED( hResultCode ) )
	 	{
	 		DPFX( DPFPREP, 0, "Error copying connection settings from wire hr=[0x%x]", hResultCode );
			goto CONNECTRECVREQ_ERROR;
	 	}
    }

    // Update the local connection settings
    hResultCode = DPLConnectionSetConnectSettings( pdpLobbyObject, handle, pConnectSettings );

 	if( FAILED( hResultCode ) )
 	{
 		DPFX( DPFPREP, 0, "Error setting connection settings from wire hr=[0x%x]", hResultCode );
		goto CONNECTRECVREQ_ERROR;
	}	

	// Indicate connection to application
	MsgConnect.dwSize = sizeof(DPL_MESSAGE_CONNECT);
	MsgConnect.hConnectId = handle;

 	if( pMsg->dwLobbyConnectDataSize )
 	{
		// Got to copy the connect data locally to an aligned buffer to ensure alignment -- ack
	 	pbTmpBuffer = new BYTE[pMsg->dwLobbyConnectDataSize];

		if( !pbTmpBuffer )
	 	{
			DPFERR("Error allocating structure");
			hResultCode = DPNERR_OUTOFMEMORY;
			goto CONNECTRECVREQ_ERROR;
	 	}

		memcpy( pbTmpBuffer, pBuffer + pMsg->dwLobbyConnectDataOffset, pMsg->dwLobbyConnectDataSize );
		MsgConnect.pvLobbyConnectData = pbTmpBuffer;
		MsgConnect.dwLobbyConnectDataSize = pMsg->dwLobbyConnectDataSize;
 	}
 	else
 	{
 		MsgConnect.pvLobbyConnectData = NULL;
 		MsgConnect.dwLobbyConnectDataSize = 0;
 	}

	MsgConnect.pvConnectionContext = NULL;

	if( pConnectSettings )
	{
		MsgConnect.pdplConnectionSettings = pConnectSettings->GetConnectionSettings();
	}
	else
	{
		MsgConnect.pdplConnectionSettings = NULL;		
	}

	// If we're lobby launching set the connect event before calling the message handler
	// otherwise we may encounter deadlock then timeout if user blocks in callback
	if( pdpLobbyObject->dwFlags & DPL_OBJECT_FLAG_LOOKINGFORLOBBYLAUNCH ) 
	{
		fLobbyLaunching = TRUE;
		pdpLobbyObject->dpnhLaunchedConnection = handle;
	}

	hResultCode = (pdpLobbyObject->pfnMessageHandler)(pdpLobbyObject->pvUserContext,
													  DPL_MSGID_CONNECT,
													  reinterpret_cast<BYTE*>(&MsgConnect));

	if( FAILED( hResultCode ) )
	{
		DPFX( DPFPREP, 0, "Error returned from user's callback -- ignoring hr [0x%x]", hResultCode );
	}

	// Set the context for this connection
	DPLConnectionSetContext( pdpLobbyObject, handle, MsgConnect.pvConnectionContext );

	if( pbTmpBuffer )
		delete [] pbTmpBuffer;

	// If we're looking for a lobby launch, set the dpnhLaunchedConnection to cache the connection handle
	SetEvent(pdpLobbyObject->hConnectEvent);

	DPFX(DPFPREP, 3,"Returning: [0x%lx]",DPN_OK);
	return(DPN_OK);

CONNECTRECVREQ_ERROR:

	if( pbTmpBuffer )
		delete [] pbTmpBuffer;

	if( pConnectSettings )
 		delete pConnectSettings;
	
	DPLConnectionDisconnect(pdpLobbyObject,handle);
	DPLConnectionRelease(pdpLobbyObject,handle);

	DPFX(DPFPREP, 3,"Returning: [0x%lx]",hResultCode);	
	
	return(hResultCode); 		
	
}

//	DPLConnectionSendACK
//
//	Send a connect acknowledge.
//	Provide the local handle for the connection to the other side for future
//		sends to the local process

#undef DPF_MODNAME
#define DPF_MODNAME "DPLConnectionSendACK"

HRESULT DPLConnectionSendACK(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
							 const DPNHANDLE hConnect)
{
	HRESULT			hResultCode;
	DPL_CONNECTION	*pdplConnection;
	DPL_INTERNAL_MESSAGE_CONNECT_ACK	Msg;

	DPFX(DPFPREP, 3,"Parameters: hConnect [0x%lx]",hConnect);

	DNASSERT(pdpLobbyObject != NULL);
	DNASSERT(hConnect != NULL);

	if ((hResultCode = DPLConnectionFind(pdpLobbyObject,hConnect,&pdplConnection,TRUE)) != DPN_OK)
	{
		DPFERR("Could not find connection");
		DisplayDNError(0,hResultCode);
		return(hResultCode);
	}

	Msg.dwMsgId = DPL_MSGID_INTERNAL_CONNECT_ACK;
	Msg.hSender = hConnect;

	hResultCode = pdplConnection->pSendQueue->Send(reinterpret_cast<BYTE*>(&Msg),
												   sizeof(DPL_INTERNAL_MESSAGE_CONNECT_ACK),
												   INFINITE,
												   DPL_MSGQ_MSGFLAGS_USER1, 
												   0);
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not send connection acknowledge");
		DisplayDNError(0,hResultCode);
		DPLConnectionRelease(pdpLobbyObject,hConnect);
		return(hResultCode);
	}

	DPLConnectionRelease(pdpLobbyObject,hConnect);

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 3,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//	DPLConnectionReceiveACK
//
//	Receive a connect acknowledge
//	Keep the supplied SenderContext for future sends directed at that process.

#undef DPF_MODNAME
#define DPF_MODNAME "DPLConnectionReceiveACK"

HRESULT DPLConnectionReceiveACK(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
								const DPNHANDLE hSender,
								BYTE *const pBuffer)
{
	HRESULT			hResultCode;
	DPL_CONNECTION	*pdplConnection;
	DPL_INTERNAL_MESSAGE_CONNECT_ACK	*pMsg;

	DPFX(DPFPREP, 3,"Parameters: hSender [0x%lx], pBuffer [0x%p]",hSender,pBuffer);

	DNASSERT(pdpLobbyObject != NULL);
	DNASSERT(pBuffer != NULL);

	pMsg = reinterpret_cast<DPL_INTERNAL_MESSAGE_CONNECT_ACK*>(pBuffer);

	if ((hResultCode = DPLConnectionFind(pdpLobbyObject,hSender,&pdplConnection,TRUE)) != DPN_OK)
	{
		DPFERR("Could not find sender's connection");
		DisplayDNError(0,hResultCode);
		return(hResultCode);
	}

	pdplConnection->pSendQueue->SetSenderHandle(pMsg->hSender);

	SetEvent(pdplConnection->hConnectEvent);

	DPLConnectionRelease(pdpLobbyObject,hSender);

	// Indicate that a connection was made by setting event
	SetEvent(pdpLobbyObject->hConnectEvent);

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 3,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}



//	DPLConnectionReceiveDisconnect
//
//	Receive a disconnect
//	Terminate the connection

#undef DPF_MODNAME
#define DPF_MODNAME "DPLConnectionReceiveDisconnect"

HRESULT DPLConnectionReceiveDisconnect(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
									   const DPNHANDLE hSender,
									   BYTE *const pBuffer,
									   const HRESULT hrDisconnectReason )
{
	HRESULT			hResultCode;
	DPL_CONNECTION	*pdplConnection;
	DPL_MESSAGE_DISCONNECT	MsgDisconnect;

	DPFX(DPFPREP, 3,"Parameters: hSender [0x%lx]",hSender);

	DNASSERT(pdpLobbyObject != NULL);

	if ((hResultCode = DPLConnectionFind(pdpLobbyObject,hSender,&pdplConnection,TRUE)) != DPN_OK)
	{
		DPFERR("Could not find sender's connection");
		DisplayDNError(0,hResultCode);
		return(hResultCode);
	}

	// Indicate disconnect to user
	MsgDisconnect.dwSize = sizeof(DPL_MESSAGE_DISCONNECT);
	MsgDisconnect.hDisconnectId = hSender;
	MsgDisconnect.hrReason = hrDisconnectReason;

	// Return code is irrelevant, at this point we're going to indicate regardless
	hResultCode = DPLConnectionGetContext( pdpLobbyObject, hSender, &MsgDisconnect.pvConnectionContext );

	if( FAILED( hResultCode ) )
	{
		DPFX(DPFPREP,  0, "Error getting connection context for 0x%x hr=0x%x", hSender, hResultCode );
	}
	 
	hResultCode = (pdpLobbyObject->pfnMessageHandler)(pdpLobbyObject->pvUserContext,
													  DPL_MSGID_DISCONNECT,
													  reinterpret_cast<BYTE*>(&MsgDisconnect));

//  Fixed memory leak, DPLConnectionRelease will free the send queue
//	pdplConnection->pSendQueue->Close();
//	pdplConnection->pSendQueue = NULL;

	DPLConnectionRelease(pdpLobbyObject,hSender);

	DPLConnectionRelease(pdpLobbyObject,hSender);

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 3,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\lobby\dplconnect.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DPLConnect.h
 *  Content:    DirectPlay Lobby Connections Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   02/21/00	mjn		Created
 *  06/15/00    rmt     Bug #33617 - Must provide method for providing automatic launch of DirectPlay instances   
 *  07/08/2000	rmt		Bug #38725 - Need to provide method to detect if app was lobby launched
 *				rmt		Bug #38757 - Callback messages for connections may return AFTER WaitForConnection returns
 *				rmt		Bug #38755 - No way to specify player name in Connection Settings
 *				rmt		Bug #38758 - DPLOBBY8.H has incorrect comments
 *				rmt		Bug #38783 - pvUserApplicationContext is only partially implemented
 *				rmt		Added DPLHANDLE_ALLCONNECTIONS and dwFlags (reserved field to couple of funcs).
 *  02/06/2001	rodtoll	WINBUG #293871: DPLOBBY8: [IA64] Lobby launching a 64-bit 
 * 						app from 64-bit lobby launcher crashes with unaligned memory error. 
 *@@END_MSINTERNAL
 *
 ***************************************************************************/


#ifndef	__DPLCONNECT_H__
#define	__DPLCONNECT_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

class CMessageQueue;
class CConnectionSettings;

typedef struct _DPL_CONNECTION {
	DPNHANDLE		hConnect;
	DWORD			dwTargetPID;
	HANDLE			hConnectEvent;
	LONG			lRefCount;
	CMessageQueue	*pSendQueue;
	CConnectionSettings *pConnectionSettings;
	DNCRITICAL_SECTION csLock;
	PVOID			pvConnectContext;
} DPL_CONNECTION,  *PDPL_CONNECTION;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

HRESULT	DPLConnectionNew(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
						 DPNHANDLE *const phConnect,
						 DPL_CONNECTION **const ppdnConnection);

HRESULT DPLConnectionSetConnectSettings( DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
						 DPNHANDLE const phConnect, 
						 CConnectionSettings * pdplConnectSettings );

HRESULT DPLConnectionGetConnectSettings( DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
						 DPNHANDLE const phConnect, 
						 DPL_CONNECTION_SETTINGS * const pdplConnectSettings,
						 DWORD * const pdwDataSize );						 

HRESULT DPLConnectionRelease(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
							 const DPNHANDLE hConnect);

HRESULT DPLConnectionFind(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
						  const DPNHANDLE hConnect,
						  DPL_CONNECTION **const ppdnConnection,
						  const BOOL bAddRef);

HRESULT DPLConnectionConnect(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
							 const DPNHANDLE hConnect,
							 const DWORD dwProcessId,
							 const BOOL fApplication );

HRESULT DPLConnectionDisconnect(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
								const DPNHANDLE hConnect );

HRESULT DPLConnectionEnum(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
						  DPNHANDLE *const prghConnect,
						  DWORD *const pdwNum);

HRESULT DPLConnectionSendREQ(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
							 const DPNHANDLE hConnect,
							 const DWORD dwPID,
							 DPL_CONNECT_INFO *const pInfo);

HRESULT DPLConnectionReceiveREQ(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
								BYTE *const pBuffer);

HRESULT DPLConnectionSendACK(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
							 const DPNHANDLE hConnect);

HRESULT DPLConnectionReceiveACK(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
								const DPNHANDLE hSender,
								BYTE *const pBuffer);

HRESULT DPLConnectionReceiveDisconnect(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
									   const DPNHANDLE hSender,
									   BYTE *const pBuffer,
									   const HRESULT hrDisconnectReason );

HRESULT DPLConnectionSetContext(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
								const DPNHANDLE hConnection, 
								PVOID pvConnectContext );

HRESULT DPLConnectionGetContext(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
								const DPNHANDLE hConnection, 
								PVOID *ppvConnectContext );


#endif	// __DPLCONNECT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\lobby\dpldllmain.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DllMain.cpp
 *  Content:    Defines the entry point for the DLL application.
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   02/21/2000	mjn		Created
 *   06/07/2000	rmt		Bug #34383 Must provide CLSID for each IID to fix issues with Whistler
 *   06/15/2000	rmt     Bug #33617 - Must provide method for providing automatic launch of DirectPlay instances 
 *   07/21/2000	RichGr  IA64: Use %p format specifier for 32/64-bit pointers.
 *   08/18/2000	rmt		Bug #42751 - DPLOBBY8: Prohibit more than one lobby client or lobby app per process 
 *   08/30/2000	rmt		Whistler Bug #171824 - PREFIX Bug
 *   04/12/2001	VanceO	Moved granting registry permissions into common.
 *   06/16/2001	rodtoll	WINBUG #416983 -  RC1: World has full control to HKLM\Software\Microsoft\DirectPlay\Applications on Personal
 *						Implementing mirror of keys into HKCU.  Algorithm is now:
 *						- Read of entries tries HKCU first, then HKLM
 *						- Enum of entires is combination of HKCU and HKLM entries with duplicates removed.  HKCU takes priority.
 *						- Write of entries is HKLM and HKCU.  (HKLM may fail, but is ignored).
 *						- Removed permission modifications from lobby self-registration -- no longer needed.  
 *   06/19/2001 RichGr  DX8.0 added special security rights for "everyone" - remove them if they exist.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dnlobbyi.h"


extern BOOL g_fAppStarted;
extern BOOL g_fClientStarted; 
extern DNCRITICAL_SECTION g_csSingleTon;

// Globals
extern	DWORD	GdwHLocks;
extern	DWORD	GdwHObjects;

extern IDirectPlayLobbyClassFactVtbl DPLCF_Vtbl;



#undef DPF_MODNAME
#define DPF_MODNAME "RegisterDefaultSettings"
//
// RegisterDefaultSettings
//
// This function registers the default settings for this module.  
//
// For DPVOICE.DLL this is making sure the compression provider sub-key is created.
//
HRESULT RegisterDefaultSettings()
{
	CRegistry creg;

	if( !creg.Open( HKEY_LOCAL_MACHINE, DPL_REG_LOCAL_APPL_ROOT DPL_REG_LOCAL_APPL_SUB, FALSE, TRUE ) )
	{
		DPFERR( "Cannot create app subkey" );
		return DPNERR_GENERIC;
	}
	// Adjust security permissions of the given key
	else
	{
		// 6/19/01: DX8.0 added special security rights for "everyone" - remove them.
		if( DNGetOSType() == VER_PLATFORM_WIN32_NT )
		{
			if( !creg.RemoveAllAccessSecurityPermissions() )
			{
				DPFX(DPFPREP,  0, "Error removing security permissions for app key" );
			}
		} 

		return DPN_OK;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "UnRegisterDefaultSettings"
//
// UnRegisterDefaultSettings
//
// This function registers the default settings for this module.  
//
// For DPVOICE.DLL this is making sure the compression provider sub-key is created.
//
HRESULT UnRegisterDefaultSettings()
{
	CRegistry creg;

	if( !creg.Open( HKEY_LOCAL_MACHINE, DPL_REG_LOCAL_APPL_ROOT, FALSE, TRUE ) )
	{
		DPFERR( "Cannot remove app, does not exist" );
	}
	else
	{
		if( !creg.DeleteSubKey( &(DPL_REG_LOCAL_APPL_SUB)[1] ) )
		{
			DPFERR( "Cannot remove cp sub-key, could have elements" );
		}
	}

	return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DllRegisterServer"
HRESULT WINAPI DllRegisterServer()
{
	HRESULT hr = S_OK;
	BOOL fFailed = FALSE;

	if( !CRegistry::Register( L"DirectPlay8Lobby.LobbyClient.1", L"DirectPlay8LobbyClient Object", 
							  L"dpnlobby.dll", CLSID_DirectPlay8LobbyClient, L"DirectPlay8Lobby.LobbyClient") )
	{
		DPFERR( "Could not register lobby client object" );
		fFailed = TRUE;
	}

	if( !CRegistry::Register( L"DirectPlay8Lobby.LobbiedApplication.1", L"DirectPlay8LobbiedApplication Object", 
							  L"dpnlobby.dll", CLSID_DirectPlay8LobbiedApplication, L"DirectPlay8Lobby.LobbiedApplication") )
	{
		DPFERR( "Could not register lobby client object" );
		fFailed = TRUE;
	}

	if( FAILED( hr = RegisterDefaultSettings() ) )
	{
		DPFX(DPFPREP,  0, "Could not register default settings hr = 0x%x", hr );
		fFailed = TRUE;
	}
	
	if( fFailed )
	{
		return E_FAIL;
	}
	else
	{
		return S_OK;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "DllUnregisterServer"
STDAPI DllUnregisterServer()
{
	HRESULT hr = S_OK;
	BOOL fFailed = FALSE;

	if( !CRegistry::UnRegister(CLSID_DirectPlay8LobbyClient) )
	{
		DPFX(DPFPREP,  0, "Failed to unregister client object" );
		fFailed = TRUE;
	}

	if( !CRegistry::UnRegister(CLSID_DirectPlay8LobbiedApplication) )
	{
		DPFX(DPFPREP,  0, "Failed to unregister app object" );
		fFailed = TRUE;
	}

	if( FAILED( hr = UnRegisterDefaultSettings() ) )
	{
		DPFX(DPFPREP,  0, "Failed to remove default settings hr=0x%x", hr );
	}

	if( fFailed )
	{
		return E_FAIL;
	}
	else
	{
		return S_OK;
	}

}

#undef DPF_MODNAME
#define DPF_MODNAME "DllMain"

BOOL APIENTRY DllMain( HANDLE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
					 )
{
	TRY
	{
		DPFX(DPFPREP, 3,"Parameters: hModule [%p], ul_reason_for_call [%lx], lpReserved [%p]",
			hModule,ul_reason_for_call,lpReserved);

		switch ( ul_reason_for_call )
		{
			case DLL_PROCESS_ATTACH:
			{
				if (DNOSIndirectionInit() == FALSE)
				{
					DPFX(DPFPREP, 0,"Failed to initialize OS indirection layer");
					return FALSE;
				}
				if (FAILED(COM_Init()))
				{
					DPFX(DPFPREP, 0,"Failed to initialize COM indirection layer");
					DNOSIndirectionDeinit();
					return FALSE;
				}
				if (DNInitializeCriticalSection( &g_csSingleTon ) == FALSE)
				{
					DPFX(DPFPREP, 0,"Failed to initialize singleton CS");
					COM_Free();
					DNOSIndirectionDeinit();
					return FALSE;
				}
				break;
			}

			case DLL_PROCESS_DETACH:
			{
				COM_Free();
				DNDeleteCriticalSection( &g_csSingleTon );				
				DNOSIndirectionDeinit();
				break;
			}
		}

		return TRUE;
	}
	EXCEPT( EXCEPTION_EXECUTE_HANDLER )
	{
		DPFERR("THERE WAS AN ERROR IN DllMain()");
		return FALSE;
	}
}



#undef DPF_MODNAME
#define DPF_MODNAME "DllGetClassObject"

STDAPI DllGetClassObject(REFCLSID rclsid,REFIID riid,LPVOID *ppv)
{
	_PIDirectPlayLobbyClassFact	lpcfObj;
	HRESULT				hResultCode = S_OK;

	DPFX(DPFPREP, 3,"Parameters: rclsid [%p], riid [%p], ppv [%p]",rclsid,riid,ppv);

	// Allocate Class Factory object
	if ((lpcfObj = (_PIDirectPlayLobbyClassFact)DNMalloc(sizeof(_IDirectPlayLobbyClassFact))) == NULL)
	{
		*ppv = NULL;
		return(E_OUTOFMEMORY);
	}
	DPFX(DPFPREP, 5,"lpcfObj = [%p]",lpcfObj);
	lpcfObj->lpVtbl = &DPLCF_Vtbl;
	lpcfObj->lRefCount = 0;
	lpcfObj->clsid = rclsid;

	// Query to find the interface
	if ((hResultCode = lpcfObj->lpVtbl->QueryInterface(reinterpret_cast<IDirectPlayLobbyClassFact*>(lpcfObj),riid,ppv)) != S_OK)
	{
		DNFree(lpcfObj);
	}

	// One more thing to release !
	GdwHObjects++;

	DPFX(DPFPREP, 3,"Return: hResultCode = [%lx], *ppv = [%p]",hResultCode,*ppv);
	return(hResultCode);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DllCanUnloadNow"

STDAPI DllCanUnloadNow(void)
{
	DPFX(DPFPREP, 3,"Parameters: (none)");

	DPFX(DPFPREP, 5,"GdwHLocks = %ld\tGdwHObjects = %ld",GdwHLocks,GdwHObjects);
	if (GdwHLocks == 0 && GdwHObjects == 0)
		return(S_OK);
	else
		return(S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\lobby\dplcommon.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DPLCommon.h
 *  Content:    DirectPlay Lobby Common Functions Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  02/21/00	mjn		Created
 *	04/26/00	mjn		Removed dwTimeOut from Send() API call
 *  06/15/00    rmt     Bug #33617 - Must provide method for providing automatic launch of DirectPlay instances   
 *  02/06/2001	rodtoll	WINBUG #293871: DPLOBBY8: [IA64] Lobby launching a 64-bit 
 * 						app from 64-bit lobby launcher crashes with unaligned memory error. 
 *@@END_MSINTERNAL
 *
 ***************************************************************************/


#ifndef	__DPLCOMMON_H__
#define	__DPLCOMMON_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

HRESULT DPLSendConnectionSettings( DIRECTPLAYLOBBYOBJECT * const pdpLobbyObject, 
								   DPNHANDLE hConnection ); 

STDMETHODIMP DPL_GetConnectionSettings(LPVOID lpv,const DPNHANDLE hLobbyClient, DPL_CONNECTION_SETTINGS * const pdplSessionInfo, DWORD *pdwInfoSize, const DWORD dwFlags );
STDMETHODIMP DPL_SetConnectionSettings(LPVOID lpv,const DPNHANDLE hLobbyClient, const DPL_CONNECTION_SETTINGS * const pdplSessionInfo, const DWORD dwFlags );

STDMETHODIMP DPL_RegisterMessageHandler(PVOID pv,
										const PVOID pvUserContext,
										const PFNDPNMESSAGEHANDLER pfn,
										DPNHANDLE * const pdpnhConnection, 
										const DWORD dwFlags);

STDMETHODIMP DPL_RegisterMessageHandlerClient(PVOID pv,
										void * const pvUserContext,
										const PFNDPNMESSAGEHANDLER pfn,
										const DWORD dwFlags);

STDMETHODIMP DPL_Close(PVOID pv, const DWORD dwFlags );

STDMETHODIMP DPL_Send(PVOID pv,
					  const DPNHANDLE hTarget,
					  BYTE *const pBuffer,
					  const DWORD pBufferSize,
					  const DWORD dwFlags);

HRESULT DPLReceiveUserMessage(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
							  const DPNHANDLE hSender,
							  BYTE *const pBuffer,
							  const DWORD dwBufferSize);

HRESULT DPLMessageHandler(PVOID pvContext,
						  const DPNHANDLE hSender,
						  DWORD dwMessageFlags, 
						  BYTE *const pBuffer,
						  const DWORD dwBufferSize);


#endif	// __DPLCOMMON_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\lobby\dplconset.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DPLConset.h
 *  Content:    DirectPlay Lobby Connection Settings Utility Functions
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   06/13/00   rmt		Created
 *  02/06/2001	rodtoll	WINBUG #293871: DPLOBBY8: [IA64] Lobby launching a 64-bit 
 * 						app from 64-bit lobby launcher crashes with unaligned memory error. 
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__DPLCONSET_H__
#define	__DPLCONSET_H__

typedef UNALIGNED struct _DPL_INTERNAL_CONNECTION_SETTINGS DPL_INTERNAL_CONNECTION_SETTINGS;


#define DPLSIGNATURE_LOBBYCONSET			'BSCL'
#define DPLSIGNATURE_LOBBYCONSET_FREE		'BSC_'

// CConnectionSettings
//
// This class is responsible for managing connection settings data.  
//
class CConnectionSettings
{
public:
	CConnectionSettings( );
	~CConnectionSettings();

	// Initialize (DPL_CONNECTION_SETTINGS version)
	//
	// This function tells this class to take the specified connection settings and 
	// work with it.  
	//
	HRESULT Initialize( DPL_CONNECTION_SETTINGS * pdplSettings );

	// Initialize (Wire Version)
	//
	// THis function initializes this object to contain a connection settings structure
	// that mirrors the values of the wire message.  
	HRESULT Initialize( UNALIGNED DPL_INTERNAL_CONNECTION_SETTINGS *pdplSettingsMsg, UNALIGNED BYTE * pbBufferStart );

	// InitializeAndCopy
	//
	// This function initializes this class to contain a copy of the specified 
	// connection settings structure.
	HRESULT InitializeAndCopy( const DPL_CONNECTION_SETTINGS * const pdplSettings );

	// SetEqual 
	//
	// This function provides a deep copy of the specified class into this object
	HRESULT SetEqual( CConnectionSettings * pdplSettings );	

	// CopyToBuffer
	//
	// This function copies the contents of the connection settings to the specified
	// buffer (if it fits).
	// 
	HRESULT CopyToBuffer( BYTE *pbBuffer, DWORD *pdwBufferSize ); 
	
	// BuildWireStruct
	//
	// This function fills the packed buffer with the wire representation of the
	// connection settings structure.  
	HRESULT BuildWireStruct( CPackedBuffer * pPackedBuffer );

	PDPL_CONNECTION_SETTINGS GetConnectionSettings() { return m_pdplConnectionSettings; };

protected:

	HRESULT Lock() { DNEnterCriticalSection( &m_csLock ); };
	HRESULT UnLock() { DNLeaveCriticalSection( &m_csLock ); };

	static void FreeConnectionSettings( DPL_CONNECTION_SETTINGS *pConnectionSettings );

	DWORD m_dwSignature;
	DNCRITICAL_SECTION m_csLock;
	BOOL m_fManaged;  
	DPL_CONNECTION_SETTINGS *m_pdplConnectionSettings;
	BOOL m_fCritSecInited;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\lobby\dplglobals.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 20000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Globals.cpp
 *  Content:    DirectNet Lobby Global Variables.
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   02/21/00	mjn		Created
 *  06/15/00    rmt     Bug #33617 - Must provide method for providing automatic launch of DirectPlay instances   
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dnlobbyi.h"

//
//	Global Variables
//

DWORD	GdwHLocks = 0;
DWORD	GdwHObjects = 0;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\lobby\dplobby8int.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DPLobbyInt.h
 *  Content:    DirectPlay Lobby Internal Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   02/21/00	mjn		Created
 *   04/18/2000 rmt     Added object param validation flag
 *   07/08/2000	rmt		Bug #38725 - Need to provide method to detect if app was lobby launched
 *				rmt		Bug #38757 - Callback messages for connections may return AFTER WaitForConnection returns
 *				rmt		Bug #38755 - No way to specify player name in Connection Settings
 *				rmt		Bug #38758 - DPLOBBY8.H has incorrect comments
 *				rmt		Bug #38783 - pvUserApplicationContext is only partially implemented
 *				rmt		Added DPLHANDLE_ALLCONNECTIONS and dwFlags (reserved field to couple of funcs).
 *				rmt		Added signature bytes
 *   02/06/2001	rodtoll	WINBUG #293871: DPLOBBY8: [IA64] Lobby launching a 64-bit 
 * 						app from 64-bit lobby launcher crashes with unaligned memory error. 
 *   06/16/2001	rodtoll	WINBUG #416983 -  RC1: World has full control to HKLM\Software\Microsoft\DirectPlay\Applications on Personal
 *						Implementing mirror of keys into HKCU.  Algorithm is now:
 *						- Read of entries tries HKCU first, then HKLM
 *						- Enum of entires is combination of HKCU and HKLM entries with duplicates removed.  HKCU takes priority.
 *						- Write of entries is HKLM and HKCU.  (HKLM may fail, but is ignored). 
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__DPLOBBYINT_H__
#define	__DPLOBBYINT_H__


//**********************************************************************
// Constant definitions
//**********************************************************************

#define TRY 			_try
#define EXCEPT(a)		_except( a )
#define	BREAKPOINT		_asm	{ int 3 }

#define DPL_MSGQ_TIMEOUT_IDLE                   1000

#define	DPL_OBJECT_FLAG_LOBBIEDAPPLICATION		0x0001
#define	DPL_OBJECT_FLAG_LOBBYCLIENT				0x0002
#define DPL_OBJECT_FLAG_PARAMVALIDATION         0x0004
#define DPL_OBJECT_FLAG_MULTICONNECT            0x0008
#define DPL_OBJECT_FLAG_LOOKINGFORLOBBYLAUNCH	0x0010

#define DPL_ID_STR_W							L"DPLID="
#define	DPL_ID_STR_A							"DPLID="

#define DPL_NUM_APP_HANDLES						16

#define DPL_REGISTRY_READ_ACCESS 				(READ_CONTROL | KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS)

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

// Forward declarations

class CMessageQueue;

#define DPLSIGNATURE_LOBBYOBJECT			'BOLL'
#define DPLSIGNATURE_LOBBYOBJECT_FREE		'BOL_'

typedef struct _DIRECTPLAYLOBBYOBJECT
{
	DWORD					dwSignature;			// Signature
	PVOID					pvUserContext;
	DWORD					dwFlags;
	DWORD					dwPID;					// PID of this process
	CMessageQueue			*pReceiveQueue;
	HANDLESTRUCT			hsHandles;				// Handles
	PFNDPNMESSAGEHANDLER	pfnMessageHandler;
	HANDLE					hReceiveThread;			// Handle to receive Msg Handler thread
	HANDLE					hConnectEvent;			// Connection Event
	HANDLE					hLobbyLaunchConnectEvent; // Set if a lobby launch connection was succesful
	LONG					lLaunchCount;			// Number of application launches
	BOOL					bIsUnicodePlatform;		// Unicode (WinNT) or not (Win9x)
	DPNHANDLE               *phHandleBuffer;        // Buffer of handles for idle process exit check
	DWORD                   dwHandleBufferSize;
	DPNHANDLE				dpnhLaunchedConnection;	// Launched connection
} DIRECTPLAYLOBBYOBJECT, *PDIRECTPLAYLOBBYOBJECT;


typedef struct _DPL_SHARED_CONNECT_BLOCK
{
	DWORD	dwPID;
} DPL_SHARED_CONNECT_BLOCK, *PDPL_SHARED_CONNECT_BLOCK;


//**********************************************************************
// Variable definitions
//**********************************************************************


//extern DWORD	DnOsPlatformId;


//**********************************************************************
// Function prototypes
//**********************************************************************


#endif  // __DPLOBBYINT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\lobby\dplparam.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplparam.cpp
 *  Content:    DirectPlayLobby8 Parameter Validation helper routines
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  04/18/00    rmt     Created
 *  04/25/00    rmt     Bug #s 33138, 33145, 33150  
 *	04/26/00	mjn		Removed dwTimeOut from Send() API call
 *  06/15/00    rmt     Bug #33617 - Must provide method for providing automatic launch of DirectPlay instances   
 *  07/08/2000	rmt		Bug #38725 - Need to provide method to detect if app was lobby launched
 *				rmt		Bug #38757 - Callback messages for connections may return AFTER WaitForConnection returns
 *				rmt		Bug #38755 - No way to specify player name in Connection Settings
 *				rmt		Bug #38758 - DPLOBBY8.H has incorrect comments
 *				rmt		Bug #38783 - pvUserApplicationContext is only partially implemented
 *				rmt		Added DPLHANDLE_ALLCONNECTIONS and dwFlags (reserved field to couple of funcs).
 *
 ***************************************************************************/

#include "dnlobbyi.h"


extern IUnknownVtbl  DN_UnknownVtbl;

#undef DPF_MODNAME
#define DPF_MODNAME "DPL_ValidateGetConnectionSettings"
HRESULT DPL_ValidateGetConnectionSettings(LPVOID lpv,const DPNHANDLE hLobbyClient, DPL_CONNECTION_SETTINGS * const pdplSessionInfo, DWORD *pdwInfoSize, const DWORD dwFlags )
{
    if( !IsValidDirectPlayLobby8Object( lpv ) )
    {
        DPFERR( "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( hLobbyClient == DPLHANDLE_ALLCONNECTIONS )
    {
        DPFERR( "Cannot specify ALLCONNECTIONS for GetConnectionSettings" );
        return DPNERR_INVALIDHANDLE;
    }

	if( hLobbyClient == 0 )
	{
		DPFERR( "Invalid connection ID" );
		return DPNERR_INVALIDHANDLE;
	}

    if( pdwInfoSize == NULL || !DNVALID_WRITEPTR( pdwInfoSize, sizeof( DWORD ) ) )
    {
        DPFERR( "Invalid pointer specified for infosize" );
        return DPNERR_INVALIDPOINTER;
    }

    if( *pdwInfoSize > 0 && 
        (pdplSessionInfo == NULL || !DNVALID_WRITEPTR( pdplSessionInfo, *pdwInfoSize ) ) )
    {
        DPFERR( "Invalid pointer specified for session info pointer" );
        return DPNERR_INVALIDPOINTER;
    }

    if( dwFlags != 0 )
    {
        DPFERR( "Invalid flags specified" );
        return DPNERR_INVALIDFLAGS;
    }
    
    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DPL_ValidateSetConnectionSettings"
HRESULT DPL_ValidateSetConnectionSettings(LPVOID lpv,const DPNHANDLE hLobbyClient, const DPL_CONNECTION_SETTINGS * const pdplSessionInfo, const DWORD dwFlags )
{
    HRESULT hr;

    if( !IsValidDirectPlayLobby8Object( lpv ) )
    {
        DPFERR( "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( hLobbyClient == 0 )
    {
        DPFERR( "Invalid handle" );
        return DPNERR_INVALIDHANDLE;
    }

    if( pdplSessionInfo != NULL )
    {
        hr = DPL_ValidConnectionSettings( pdplSessionInfo );

        if( FAILED( hr ) )
        {
            DPFERR( "Error validating connectsettings struct" );
            return hr;
        }
    }
    
    if( dwFlags != 0 )
    {
        DPFERR( "Invalid flags specified" );
        return DPNERR_INVALIDFLAGS;
    }
    
    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DPL_ValidateConnectionSettings"
HRESULT DPL_ValidConnectionSettings( const DPL_CONNECTION_SETTINGS * const pdplConnectSettings )
{
    if( pdplConnectSettings == NULL || !DNVALID_READPTR( pdplConnectSettings, sizeof( DPL_CONNECTION_SETTINGS ) ) )
    {
        DPFERR( "Invalid pointer specified for connection settings field" );
        return DPNERR_INVALIDPOINTER;
    }

    if( pdplConnectSettings->dwSize != sizeof( DPL_CONNECTION_SETTINGS ) )
    {
        DPFERR( "Invalid size specified for dplconnectsettings struct" );
        return DPNERR_INVALIDPARAM;
    }

    if( pdplConnectSettings->dwFlags & ~( DPLCONNECTSETTINGS_HOST ) )
    {
        DPFERR( "Invalid flags specified in connectsettings struct" );
        return DPNERR_INVALIDFLAGS;
    }

    if( pdplConnectSettings->dpnAppDesc.dwSize != sizeof( DPN_APPLICATION_DESC ) )
    {
        DPFERR( "Invalid size specified on app desc" );
        return DPNERR_INVALIDPOINTER;
    }

    if( pdplConnectSettings->dpnAppDesc.pwszSessionName != NULL && 
        !DNVALID_STRING_W( pdplConnectSettings->dpnAppDesc.pwszSessionName ) )
    {
        DPFERR( "Invalid session name specified on app desc" );
        return DPNERR_INVALIDSTRING;
    }

    if( pdplConnectSettings->dpnAppDesc.pwszPassword != NULL && 
        !DNVALID_STRING_W( pdplConnectSettings->dpnAppDesc.pwszPassword ) )
    {
        DPFERR( "Invalid password specified on app desc" );
        return DPNERR_INVALIDSTRING;
    }        

    if( pdplConnectSettings->dpnAppDesc.dwReservedDataSize != 0 && 
        !DNVALID_READPTR( pdplConnectSettings->dpnAppDesc.pvReservedData, pdplConnectSettings->dpnAppDesc.dwReservedDataSize ) )
    {
        DPFERR( "Invalid reserved data specified on app desc" );
        return DPNERR_INVALIDPOINTER;
    }

    if( pdplConnectSettings->dpnAppDesc.dwApplicationReservedDataSize != 0 && 
        !DNVALID_READPTR( pdplConnectSettings->dpnAppDesc.pvApplicationReservedData, 
                          pdplConnectSettings->dpnAppDesc.dwApplicationReservedDataSize ) )
    {
        DPFERR( "Invalid application reserved data specified on app desc" );
        return DPNERR_INVALIDPOINTER;
    }

    if( pdplConnectSettings->dwFlags & DPLCONNECTSETTINGS_HOST )
	{
        if( pdplConnectSettings->pdp8HostAddress != NULL )
	    {
			DPFERR( "Host address must be NULL if description is for host" );
			return DPNERR_INVALIDPARAM;
		}
	}
    else
    {
        if( pdplConnectSettings->pdp8HostAddress == NULL ||
            !DNVALID_READPTR( pdplConnectSettings->pdp8HostAddress, sizeof( IDirectPlay8Address * ) ) )
        {
            DPFERR( "Invalid host address specified" );
            return DPNERR_INVALIDHOSTADDRESS;
        }
    }

    if( pdplConnectSettings->ppdp8DeviceAddresses == NULL ||
        !DNVALID_READPTR( pdplConnectSettings->ppdp8DeviceAddresses, pdplConnectSettings->cNumDeviceAddresses * sizeof( IDirectPlay8Address * ) ) )
    {
        DPFERR( "Invalid device addresses specified" );
        return DPNERR_INVALIDDEVICEADDRESS;
    }

    if( pdplConnectSettings->cNumDeviceAddresses == 0 )
    {
        DPFERR( "You must specify at least one device address" );
        return DPNERR_INVALIDPARAM;
    }

    return DPN_OK;    
}


#undef DPF_MODNAME
#define DPF_MODNAME "DPL_ValidateQueryInterface"
HRESULT DPL_ValidateQueryInterface( LPVOID lpv,REFIID riid,LPVOID *ppv )
{
    if( !IsValidDirectPlayLobby8Object( lpv ) )
    {
        DPFERR( "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( ppv == NULL || !DNVALID_WRITEPTR( ppv, sizeof( void * ) ) )
    {
        DPFERR( "Invalid pointer specified for target of queryinterface" );
        return DPNERR_INVALIDPOINTER;
    }

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DPL_ValidateRelease"
HRESULT DPL_ValidateRelease( PVOID pv )
{
    if( !IsValidDirectPlayLobby8Object( pv ) )
    {
        DPFERR( "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DPL_ValidateAddRef"
HRESULT DPL_ValidateAddRef( PVOID pv )
{
    if( !IsValidDirectPlayLobby8Object( pv ) )
    {
        DPFERR( "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DPL_ValidateRegisterMessageHandler"
HRESULT DPL_ValidateRegisterMessageHandler(PVOID pv,
										const PVOID pvUserContext,
										const PFNDPNMESSAGEHANDLER pfn,
										DPNHANDLE * const pdpnhConnection, 
										const DWORD dwFlags)
{
    if( !IsValidDirectPlayLobby8Object( pv ) )
    {
        DPFERR( "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( pfn == NULL )
    {
        DPFERR( "Invalid  pointer for message handler " );
        return DPNERR_INVALIDPOINTER;
    }

	if( pdpnhConnection )
	{
		if( !DNVALID_WRITEPTR( pdpnhConnection, sizeof( DPNHANDLE ) ) )
		{
			DPFERR( "Invalid pointer specified for connection handle" );
			return DPNERR_INVALIDPOINTER;
		}
	}

    if( dwFlags & ~(DPLINITIALIZE_DISABLEPARAMVAL) )
    {
        DPFERR( "Invalid flags specified" );
        return DPNERR_INVALIDFLAGS;
    }

    return DPN_OK;    
}

#undef DPF_MODNAME
#define DPF_MODNAME "DPL_ValidateClose"
HRESULT DPL_ValidateClose(PVOID pv, const DWORD dwFlags )
{
    if( !IsValidDirectPlayLobby8Object( pv ) )
    {
        DPFERR( "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    } 

	if( dwFlags != 0 )
	{
		DPFERR( "Invalid flags specified" );
		return DPNERR_INVALIDFLAGS;
	}

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DPL_ValidateSend"
HRESULT DPL_ValidateSend(PVOID pv,
					  const DPNHANDLE hTarget,
					  BYTE *const pBuffer,
					  const DWORD dwBufferSize,
					  const DWORD dwFlags)
{
    if( !IsValidDirectPlayLobby8Object( pv ) )
    {
        DPFERR( "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    } 

	if( hTarget == 0 )
	{
		DPFERR( "Invalid handle" );
		return DPNERR_INVALIDHANDLE;
	}

    if( pBuffer == NULL || 
        !DNVALID_READPTR( pBuffer, dwBufferSize ) )
    {
        DPFERR( "Invalid pointer specified for buffer" );
        return DPNERR_INVALIDPOINTER;
    }

    if( dwBufferSize == 0 )
    {
        DPFERR( "Invalid buffer size specified" );
        return DPNERR_INVALIDPARAM;
    }

	if( dwBufferSize > 0x10000 )
	{
		DPFERR( "Queue does not support sends > 0x10000 in size" );
		return DPNERR_SENDTOOLARGE;
	}
        
    if( dwFlags != 0 )
    {
        DPFERR( "Invalid flags specified" );
        return DPNERR_INVALIDFLAGS;
    }

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DPL_ValidateEnumLocalPrograms"
HRESULT DPL_ValidateEnumLocalPrograms(IDirectPlay8LobbyClient *pInterface,
							  GUID *const pGuidApplication,
							  BYTE *const pEnumData,
							  DWORD *const pdwEnumDataSize,
							  DWORD *const pdwEnumDataItems,
							  const DWORD dwFlags )
{
    if( !IsValidDirectPlayLobby8Object( pInterface ) )
    {
        DPFERR( "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    } 

    if( pGuidApplication != NULL && !DNVALID_READPTR( pGuidApplication, sizeof( GUID ) ) )
    {
        DPFERR( "Invalid pointer specified for application guid" );
        return DPNERR_INVALIDPOINTER;
    }

    if( pdwEnumDataSize == NULL || !DNVALID_WRITEPTR( pdwEnumDataSize, sizeof( DWORD ) ) )
    {
        DPFERR( "Invalid pointer specified for enum data size" );
        return DPNERR_INVALIDPOINTER;
    }

    if( pdwEnumDataItems == NULL || !DNVALID_WRITEPTR( pdwEnumDataItems, sizeof( DWORD ) ) ) 
    {
        DPFERR( "Invalid pointer specified for enum data count" );
        return DPNERR_INVALIDPOINTER;
    }

    if( *pdwEnumDataSize > 0 &&
        (pEnumData == NULL || !DNVALID_WRITEPTR( pEnumData, *pdwEnumDataSize ) ) )
    {
        DPFERR( "Invalid enum data pointer specified" );
        return DPNERR_INVALIDPOINTER;
    }

    if( dwFlags != 0 )
    {
        DPFERR( "Invalid flags specified" );
        return DPNERR_INVALIDFLAGS;
    }

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DPL_ValidateConnectApplication"
HRESULT DPL_ValidateConnectApplication(IDirectPlay8LobbyClient *pInterface,
							   DPL_CONNECT_INFO *const pdplConnectionInfo,
							   const PVOID pvUserApplicationContext,
							   DPNHANDLE *const hApplication,
							   const DWORD dwTimeOut,
							   const DWORD dwFlags)
{
    HRESULT hResultCode;
    
    if( !IsValidDirectPlayLobby8Object( pInterface ) )
    {
        DPFERR( "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    } 

    if( FAILED( hResultCode = DPL_ValidConnectInfo( pdplConnectionInfo ) ) )
    {
        DPFX(DPFPREP,  0, "Error validating connect info hr=0x%x", hResultCode );
        return hResultCode;
    }

    if( hApplication == NULL || 
        !DNVALID_WRITEPTR( hApplication, sizeof( DPNHANDLE ) ) )
    {
        DPFERR( "Invalid pointer specified for application handle" );
        return DPNERR_INVALIDPOINTER;
    }

    if( dwFlags != 0 )
    {
        DPFERR( "Invalid flags" );
        return DPNERR_INVALIDFLAGS;
    }

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DPL_ValidateReleaseApplication"
HRESULT DPL_ValidateReleaseApplication(IDirectPlay8LobbyClient *pInterface,
									const DPNHANDLE hApplication, const DWORD dwFlags )
{

    if( !IsValidDirectPlayLobby8Object( pInterface ) )
    {
        DPFERR( "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    } 

	if( hApplication == 0 )
	{
		DPFERR( "Invalid handle" );
		return DPNERR_INVALIDHANDLE;
	}

	if( dwFlags != 0 )
	{
		DPFERR( "Invalid flags" );
		return DPNERR_INVALIDFLAGS;
	}

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DPL_ValidateUnRegisterProgram"
HRESULT DPL_ValidateUnRegisterProgram(IDirectPlay8LobbiedApplication *pInterface,
							   GUID *pguidApplication,
							   const DWORD dwFlags)
{
    if( !IsValidDirectPlayLobby8Object( pInterface ) )
    {
        DPFERR( "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }    

    if( pguidApplication == NULL || 
        !DNVALID_READPTR( pguidApplication, sizeof( GUID ) ) )
    {
        DPFERR( "Invalid pointer to application GUID specified" );
        return DPNERR_INVALIDPOINTER;
    }

    if( dwFlags != 0 )
    {
        DPFERR( "Invalid flags specified" );
        return DPNERR_INVALIDFLAGS;
    }

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DPL_ValidateSetAppAvailable"
HRESULT DPL_ValidateSetAppAvailable(IDirectPlay8LobbiedApplication *pInterface, const BOOL fAvailable, const DWORD dwFlags )
{
    if( !IsValidDirectPlayLobby8Object( pInterface ) )
    {
        DPFERR( "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }    

    if( dwFlags & ~(DPLAVAILABLE_ALLOWMULTIPLECONNECT) )
    {
        DPFERR( "Invalid flags specified" );
        return DPNERR_INVALIDFLAGS;
    }

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DPL_ValidateWaitForConnection"
HRESULT DPL_ValidateWaitForConnection(IDirectPlay8LobbiedApplication *pInterface,
								   const DWORD dwMilliseconds, const DWORD dwFlags )
{
    if( !IsValidDirectPlayLobby8Object( pInterface ) )
    {
        DPFERR( "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }    

	if( dwFlags != 0 )
	{
		DPFERR( "Invalid flags specified" );
		return DPNERR_INVALIDFLAGS;
	}

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DPL_ValidateUpdateStatus"
HRESULT DPL_ValidateUpdateStatus(IDirectPlay8LobbiedApplication *pInterface,
							  const DPNHANDLE hLobby,
							  const DWORD dwStatus, 
							  const DWORD dwFlags )
{
    if( !IsValidDirectPlayLobby8Object( pInterface ) )
    {
        DPFERR( "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }    

	if( hLobby == 0 )
	{
		DPFERR( "Invalid handle" );
		return DPNERR_INVALIDHANDLE;
	}

    if( dwStatus != DPLSESSION_CONNECTED && 
        dwStatus != DPLSESSION_COULDNOTCONNECT && 
        dwStatus != DPLSESSION_DISCONNECTED && 
        dwStatus != DPLSESSION_TERMINATED && 
		dwStatus != DPLSESSION_HOSTMIGRATED && 
		dwStatus != DPLSESSION_HOSTMIGRATEDHERE )
    {
        DPFERR( "Invalid status specified" );
        return DPNERR_INVALIDPARAM;
    }

	if( dwFlags != 0 )
	{
		DPFERR( "Invalid flags specified" );
		return DPNERR_INVALIDFLAGS;
	}

    return DPN_OK;
}
#undef DPF_MODNAME
#define DPF_MODNAME "DPL_ValidateRegisterProgram"
HRESULT DPL_ValidateRegisterProgram(IDirectPlay8LobbiedApplication *pInterface,
								 DPL_PROGRAM_DESC *const pdplProgramDesc,
								 const DWORD dwFlags)
{
    HRESULT hResultCode;
    
    if( !IsValidDirectPlayLobby8Object( pInterface ) )
    {
        DPFERR( "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( FAILED( hResultCode = DPL_ValidProgramDesc(pdplProgramDesc) ) )
    {
        DPFX(DPFPREP,  0, "Error validating program desc structure hr=0x%x", hResultCode );
        return hResultCode;
    }

    if( dwFlags != 0 )
    {
        DPFERR( "Invalid flags specified" );
        return DPNERR_INVALIDFLAGS;
    }

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DPL_ValidConnectInfo"
HRESULT DPL_ValidConnectInfo( const DPL_CONNECT_INFO * const pdplConnectInfo )
{
    if( pdplConnectInfo == NULL )
    {
        DPFERR( "Invalid pointer specified for connect info" );
        return DPNERR_INVALIDPOINTER;
    }

    if( pdplConnectInfo->dwSize != sizeof( DPL_CONNECT_INFO ) )
    {
        DPFERR( "Wrong size specified for connect info struct" );
        return DPNERR_INVALIDPARAM;
    }

    if( !DNVALID_READPTR( pdplConnectInfo, pdplConnectInfo->dwSize ) )
    {
        DPFERR( "Invalid pointer specified for connect info" );
        return DPNERR_INVALIDPOINTER;
    }

    if( pdplConnectInfo->dwFlags & ~(DPLCONNECT_LAUNCHNEW | DPLCONNECT_LAUNCHNOTFOUND) )
    {
        DPFERR("Invalid flags specified" );
        return DPNERR_INVALIDFLAGS;
    }

    if( pdplConnectInfo->dwFlags & DPLCONNECT_LAUNCHNEW && 
        pdplConnectInfo->dwFlags & DPLCONNECT_LAUNCHNOTFOUND )
    {
        DPFERR( "You cannot specify both launchnew and launchnotfound" );
        return DPNERR_INVALIDPARAM;
    }

    GUID guidTmp;

    memset( &guidTmp, 0x00, sizeof( GUID ) );

    if( pdplConnectInfo->guidApplication == guidTmp )
    {
        DPFERR( "Cannot specify GUID_NULL for the application GUID" );
        return DPNERR_INVALIDPARAM;
    }

	if( pdplConnectInfo->pdplConnectionSettings != NULL )
	{
		HRESULT hr = DPL_ValidConnectionSettings( pdplConnectInfo->pdplConnectionSettings );

		if( FAILED( hr ) )
		{
			DPFX(DPFPREP,  0, "Error validating connection settings field of connect info hr=0x%x", hr );
			return hr;
		}
	}

    if( pdplConnectInfo->dwLobbyConnectDataSize > 0 && 
        (pdplConnectInfo->pvLobbyConnectData == NULL || !DNVALID_READPTR( pdplConnectInfo->pvLobbyConnectData, pdplConnectInfo->dwLobbyConnectDataSize ) ) )
    {
        DPFERR( "Invalid pointer specified for lobby connect data" );
        return DPNERR_INVALIDPOINTER;
    }

    return DPN_OK;    
}

#undef DPF_MODNAME
#define DPF_MODNAME "DPL_ValidProgramDesc"
HRESULT DPL_ValidProgramDesc( const DPL_PROGRAM_DESC * const pdplProgramInfo )
{
    if( pdplProgramInfo == NULL )
    {
        DPFERR( "Invalid pointer specified for program info" );
        return DPNERR_INVALIDPOINTER;
    }

    if( pdplProgramInfo->dwSize != sizeof( DPL_PROGRAM_DESC ) )
    {
        DPFERR( "Wrong size specified for program info struct" );
        return DPNERR_INVALIDPARAM;
    }

    if( !DNVALID_READPTR( pdplProgramInfo, pdplProgramInfo->dwSize ) )
    {
        DPFERR( "Invalid pointer specified for app info" );
        return DPNERR_INVALIDPOINTER;
    }

    if( pdplProgramInfo->dwFlags != 0  )
    {
        DPFERR("Invalid flags specified" );
        return DPNERR_INVALIDFLAGS;
    }

    GUID guidTmp;

    memset( &guidTmp, 0x00, sizeof( GUID ) );

    if( pdplProgramInfo->guidApplication == guidTmp )
    {
        DPFERR( "Cannot specify GUID_NULL for the application GUID" );
        return DPNERR_INVALIDPARAM;
    }

    if( pdplProgramInfo->pwszApplicationName == NULL )
    {
        DPFERR( "You must specify an application name" );
        return DPNERR_INVALIDPARAM;
    }

    if( !DNVALID_STRING_W( pdplProgramInfo->pwszApplicationName ) )
    {
        DPFERR( "Invalid string specified for application name" );
        return DPNERR_INVALIDSTRING;
    }
    
    if( pdplProgramInfo->pwszCommandLine != NULL && 
        !DNVALID_STRING_W( pdplProgramInfo->pwszCommandLine ) )
    {
        DPFERR( "Invalid command-line string specified" );
        return DPNERR_INVALIDSTRING;
    }

    if( pdplProgramInfo->pwszCurrentDirectory != NULL && 
        !DNVALID_STRING_W( pdplProgramInfo->pwszCurrentDirectory ) )
    {
        DPFERR( "Invalid current directory string specified" );
        return DPNERR_INVALIDSTRING;
    }

    if( pdplProgramInfo->pwszDescription != NULL && 
        !DNVALID_STRING_W( pdplProgramInfo->pwszDescription ) )
    {
        DPFERR( "Invalid description string specified" );
        return DPNERR_INVALIDSTRING;
    }    
    
    if( pdplProgramInfo->pwszExecutableFilename == NULL )
    {
        DPFERR( "You must specify an executable name" );
        return DPNERR_INVALIDPARAM;
    }

    if( !DNVALID_STRING_W( pdplProgramInfo->pwszExecutableFilename ) )
    {
        DPFERR( "Invalid string specified for executable name" );
        return DPNERR_INVALIDSTRING;
    }    

    if( pdplProgramInfo->pwszExecutablePath != NULL && 
        !DNVALID_STRING_W( pdplProgramInfo->pwszExecutablePath ) )
    {
        DPFERR( "Invalid executable path string specified" );
        return DPNERR_INVALIDSTRING;
    }

    if( pdplProgramInfo->pwszLauncherFilename != NULL && 
        !DNVALID_STRING_W( pdplProgramInfo->pwszLauncherFilename ) )
    {
        DPFERR( "Invalid launcher filename string specified" );
        return DPNERR_INVALIDSTRING;
    }

    if( pdplProgramInfo->pwszLauncherPath != NULL && 
        !DNVALID_STRING_W( pdplProgramInfo->pwszLauncherPath ) )
    {
        DPFERR( "Invalid launcher path string specified" );
        return DPNERR_INVALIDSTRING;
    }    

    return DPN_OK;      
}

#undef DPF_MODNAME
#define DPF_MODNAME "IsValidDirectPlayLobby8Object"
BOOL IsValidDirectPlayLobby8Object( LPVOID lpvObject )
{
	INTERFACE_LIST *pIntList = (INTERFACE_LIST *) lpvObject;
	
	if( !DNVALID_READPTR( lpvObject, sizeof( INTERFACE_LIST ) ) )
	{
		DPFX(DPFPREP,  0, "Invalid object pointer" );
		return FALSE;
	}

	if( pIntList->lpVtbl != &DPL_Lobby8ClientVtbl &&
	   pIntList->lpVtbl != &DPL_8LobbiedApplicationVtbl && 
	   pIntList->lpVtbl != &DN_UnknownVtbl
	   )
	{
		DPFX(DPFPREP,  0, "Invalid object - bad vtable" );
		return FALSE;
	}

	if( pIntList->iid != IID_IDirectPlay8LobbyClient &&
	   pIntList->iid != IID_IDirectPlay8LobbiedApplication && 
	   pIntList->iid != IID_IUnknown )
	{
		DPFX(DPFPREP,  0, "Invalid object - bad iid" );
		return FALSE;
	}

	if( pIntList->lpObject == NULL || 
	   !DNVALID_READPTR( pIntList->lpObject, sizeof( OBJECT_DATA ) ) )
	{
		DPFX(DPFPREP,  0, "Invalid object" );
		return FALSE;
	}

	DIRECTPLAYLOBBYOBJECT *pdpl = (DIRECTPLAYLOBBYOBJECT *) GET_OBJECT_FROM_INTERFACE( lpvObject );

	if( pdpl == NULL || 
	   !DNVALID_READPTR( pdpl, sizeof( DIRECTPLAYLOBBYOBJECT ) ) )
	{
		DPFX(DPFPREP,  0, "Invalid object" );
		return FALSE;
	}

	return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\lobby\dplmsgq.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DPLMsgQ.h
 *  Content:    DirectPlay Lobby Message Queues Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  02/21/00	mjn		Created
 *	04/26/00	mjn		Fixed AddData() to return HRESULT
 *  07/07/2000	rmt		
 *@@END_MSINTERNAL
 *
 ***************************************************************************/


#ifndef	__DPLMSGQ_H__
#define	__DPLMSGQ_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//
//	Message Queue Object IDs
//
#define DPL_MSGQ_OBJECT_IDCHAR_FILEMAP		'F'
#define DPL_MSGQ_OBJECT_IDCHAR_MUTEX		'M'
#define DPL_MSGQ_OBJECT_IDCHAR_EVENT		'E'
#define DPL_MSGQ_OBJECT_IDCHAR_EVENT2		'V'
#define DPL_MSGQ_OBJECT_IDCHAR_SEMAPHORE	'S'

//
//	Message Queue Object Suffixes
//
#define	DPL_MSGQ_OBJECT_SUFFIX_CLIENT		'C'
#define	DPL_MSGQ_OBJECT_SUFFIX_APPLICATION	'A'

//
//	Message Queue Flags
//
#define	DPL_MSGQ_FLAG_AVAILABLE				0x00001
#define	DPL_MSGQ_FLAG_RECEIVING				0x00010

#define DPL_MSGQ_OPEN_FLAG_NO_CREATE		0x10000

//
//	Message Queue File Size
//
// Increased so user can send a 64K message
#define DPL_MSGQ_SIZE						0x010030

//
//	Internal Message IDs
//
#define	DPL_MSGQ_MSGID_SEND					0x0001
#define	DPL_MSGQ_MSGID_TERMINATE			0x0003
#define DPL_MSGQ_MSGID_IDLE                 0x0004

#define DPL_MSGQ_MSGFLAGS_QUEUESYSTEM		0x0001
#define DPL_MSGQ_MSGFLAGS_USER1				0x0002
#define DPL_MSGQ_MSGFLAGS_USER2				0x0004

#define	DPL_MSGQ_SIGNATURE					'QMLD'

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_LOBBY

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

#pragma pack(push,4)
//
//	Message Queue File Map Info
//
typedef struct _DPL_MSGQ_INFO
{
	DWORD	dwFlags;			// Queue usage flags
	DWORD	dwStartOffset;
	DWORD	dwEndOffset;
	DWORD	dwFreeBytes;
	DWORD	dwQueueSize;
	LONG	lRefCount;			// Number of connections
} DPL_MSGQ_INFO, *PDPL_MSGQ_INFO;


//
//	Message Queue Send Message
//
typedef	struct _DPL_MSGQ_SEND
{
	DWORD		dwCurrentSize;		// Size of this frame (in BYTES)
	DWORD		dwTotalSize;		// Total size of message
	DWORD		dwMsgId;			// Message ID
	DPNHANDLE	hSender;
	DWORD		dwFlags;
	DWORD		dwCurrentOffset;	// Offset of this frame in message
} DPL_MSGQ_HEADER, *PDPL_MSGQ_HEADER;

//
//	Message Queue Terminate Message
//
typedef struct _DPL_MSGQ_TERMINATE
{
	DWORD	dwMsgId;
} DPL_MSGQ_TERMINATE, *PDPL_MSGQ_TERMINATE;

#pragma pack(pop)

//
//	Message Handler Callback
//
typedef HRESULT (*PFNDPLMSGQMESSAGEHANDLER)(PVOID,const DPNHANDLE,DWORD, BYTE *const,const DWORD);

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

BOOL	DPLIsApplicationAvailable(const DWORD dwPid);
HRESULT	DPLMakeApplicationUnavailable(const DWORD dwPid);
DWORD WINAPI DPLProcessMessageQueue(PVOID pvReceiveQueue);

//**********************************************************************
// Class prototypes
//**********************************************************************

class CMessageQueue
{
public:
	CMessageQueue()
		{
			m_dwPID = 0;
			m_hFileMap = NULL;
			m_hEvent = NULL;
			m_hMutex = NULL;
			m_hSemaphore = NULL;
			m_pFileMapAddress = NULL;
			m_pInfo = NULL;
			m_pvContext = NULL;
			m_pfnMessageHandler = NULL;
			m_hSender = 0xFFFFFFFF;
			m_hReceiveThreadRunningEvent = NULL;
			m_dwIdleTimeout = INFINITE;
		};

	~CMessageQueue() { };

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMessageQueue::SetMessageHandler"
	void CMessageQueue::SetMessageHandler(PVOID pvContext,PFNDPLMSGQMESSAGEHANDLER pfn )
		{
			DNASSERT(pfn != NULL);

			m_pvContext = pvContext;
			m_pfnMessageHandler = pfn;
		};

	void CMessageQueue::SetSenderHandle(DPNHANDLE hSender)
		{
			m_hSender = hSender;
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMessageQueue::CallMessageHandler"
	HRESULT CMessageQueue::CallMessageHandler(const DPNHANDLE hSender,
											  DWORD dwMessageFlags, 
											  BYTE *const pBuffer,
											  const DWORD dwBufferSize)
		{
			DNASSERT(m_pfnMessageHandler != NULL);

			return((m_pfnMessageHandler)(m_pvContext,hSender,dwMessageFlags,pBuffer,dwBufferSize));
		};

	HRESULT CMessageQueue::Open(const DWORD dwPID,
								const CHAR cSuffix,
								const DWORD dwQueueSize,
								const DWORD dwIdleTimeout,
								const DWORD dwFlags
                                 );

	void CMessageQueue::Close(void);

	LONG CMessageQueue::GetRefCount(void)
		{
			DWORD	lRefCount;

			if (m_pInfo == NULL)
				return(0);

			Lock();
			lRefCount = m_pInfo->lRefCount;
			Unlock();

			return(lRefCount);
		};

	HRESULT CMessageQueue::AddData(BYTE *const pBuffer,
								   const DWORD dwSize);


	HRESULT CMessageQueue::Send(BYTE *const pBuffer,
								const DWORD dwSize,
								const DWORD dwTimeOut,
								const DWORD dwMessageFlags,
								const DWORD dwFlags);

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMessageQueue::Lock"
	void CMessageQueue::Lock(void)
		{
			DNASSERT(m_hMutex != NULL);
			WaitForSingleObject(m_hMutex,INFINITE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMessageQueue::Unlock"
	void CMessageQueue::Unlock(void)
		{
			DNASSERT(m_hMutex != NULL);
			ReleaseMutex(m_hMutex);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMessageQueue::WaitForMessages"
	DWORD CMessageQueue::WaitForMessages(void)
		{
			DNASSERT(m_hSemaphore != NULL);
			return WaitForSingleObject(m_hSemaphore,m_dwIdleTimeout);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMessageQueue::IndicateMessage"
	void CMessageQueue::IndicateMessage(void)
		{
			DNASSERT(m_hSemaphore != NULL);
			ReleaseSemaphore(m_hSemaphore,1,NULL);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMessageQueue::WaitForConsumption"
	BOOL CMessageQueue::WaitForConsumption(const DWORD dwTimeOut)
		{
			DWORD	dwError;

			DNASSERT(m_hEvent != NULL);
			dwError = WaitForSingleObject(m_hEvent,dwTimeOut);
			if (dwError==WAIT_OBJECT_0)
			{
				return(TRUE);
			}
			return(FALSE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMessageQueue::IndicateConsumption"
	void CMessageQueue::IndicateConsumption(void)
		{
			DNASSERT(m_hEvent != NULL);
			//SetEvent(m_hEvent);		// Will auto-reset (i.e. pulse)

			ReleaseSemaphore( m_hEvent, 1, NULL );
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMessageQueue::MakeAvailable"
	void CMessageQueue::MakeAvailable(void)
		{
			DNASSERT(m_pInfo != NULL);

			Lock();

			m_pInfo->dwFlags |= DPL_MSGQ_FLAG_AVAILABLE;

			Unlock();
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMessageQueue::MakeUnavailable"
	HRESULT CMessageQueue::MakeUnavailable(void)
		{

			HRESULT		hResultCode;

			DNASSERT(m_pInfo != NULL);

			Lock();

			if (m_pInfo->dwFlags & DPL_MSGQ_FLAG_AVAILABLE)
			{
				m_pInfo->dwFlags &= (~DPL_MSGQ_FLAG_AVAILABLE);
				hResultCode = DPN_OK;
			}
			else
			{
				hResultCode = DPNERR_ALREADYCONNECTED;
			}

			Unlock();

			return(hResultCode);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMessageQueue::MakeReceiving"
	void CMessageQueue::MakeReceiving(void)
		{
			DNASSERT(m_pInfo != NULL);

			Lock();
			m_pInfo->dwFlags |= DPL_MSGQ_FLAG_RECEIVING;
			Unlock();
			SetEvent(m_hReceiveThreadRunningEvent);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMessageQueue::MakeNotReceiving"
	void CMessageQueue::MakeNotReceiving(void)
		{
			DNASSERT(m_pInfo != NULL);

			ResetEvent(m_hReceiveThreadRunningEvent);
			Lock();
			m_pInfo->dwFlags &= (~DPL_MSGQ_FLAG_RECEIVING);
			Unlock();
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMessageQueue::WaitForReceiveThread"
	BOOL CMessageQueue::WaitForReceiveThread(const DWORD dwTimeOut)
		{
			DWORD	dwError;

			DNASSERT(m_hEvent != NULL);
			dwError = WaitForSingleObject(m_hReceiveThreadRunningEvent,dwTimeOut);
			if (dwError==WAIT_OBJECT_0)
			{
				return(TRUE);
			}
			return(FALSE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMessageQueue::IsOpen"
	BOOL CMessageQueue::IsOpen(void)
		{
			if (m_hFileMap!= NULL)	return(TRUE);
			else					return(FALSE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMessageQueue::IsAvailable"
	BOOL CMessageQueue::IsAvailable(void)
		{
			DNASSERT(m_pInfo != NULL);

			if (m_pInfo->dwFlags & DPL_MSGQ_FLAG_AVAILABLE)
				return(TRUE);
			else
				return(FALSE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMessageQueue::IsReceiving"
	BOOL CMessageQueue::IsReceiving(void)
		{
			DNASSERT(m_pInfo != NULL);

			if (m_pInfo->dwFlags & DPL_MSGQ_FLAG_RECEIVING)
				return(TRUE);
			else
				return(FALSE);
		};

	HRESULT GetNextMessage( PDPL_MSGQ_HEADER pMsgHeader, PBYTE pbPayload, DWORD *pdwBufferSize );
	
/*
	#undef DPF_MODNAME
	#define DPF_MODNAME "CMessageQueue::Realign"
	void CMessageQueue::Realign(void)
		{
			DNASSERT(m_pInfo != NULL);

			m_pInfo->dwFirstMsgOffset = 0;
			m_pInfo->dwFreeSpaceAtEnd = m_pInfo->dwTotalUsableSpace
					- (m_pInfo->dwNextFreeOffset - m_pInfo->dwFirstMsgOffset);
			m_pInfo->dwTotalFreeSpace = m_pInfo->dwFreeSpaceAtEnd;

		};*/

	void CMessageQueue::Terminate(void); 


private:

	// GetData
	//
	// Get dwSize bytes from the queue.  If the queue is empty this function will return
	// DPNERR_DOESNOTEXIST.  Once this function returns the dwSize bytes will be consumed
	//
	// Needs LOCK()
	//
	HRESULT GetData( BYTE *pbData, DWORD dwSize );

	// Consume
	//
	// Marks dwSize bytes as consumed
	//
	// Needs LOCK()
	void Consume( const DWORD dwSize );

	DWORD			m_dwSig;			// Signature (ensure initialized)
	DWORD			m_dwPID;			// Queue PID
	PBYTE			m_pFileMapAddress;	// File Mapping address
	DPL_MSGQ_INFO	*m_pInfo;			// Message queue file mapping info
	PBYTE			m_pData;			// Message data starts here 

	HANDLE	m_hReceiveThreadRunningEvent;

	//	Notes:
	//		Each message queue has four shared memory items: file map, mutex, event, semaphore.
	//		The file map is a circular queue of messages.
	//		The mutex controls access to the file map.
	//		The event signals when an item has been taken off the queue by the consumer.
	//		The semaphore indicates to the consumer that there are messages in the queue

	HANDLE	m_hFileMap;			// File Mapping handle
	HANDLE	m_hMutex;			// Mutex handle
	HANDLE	m_hEvent;			// Event handle
	HANDLE	m_hSemaphore;		// Semaphore handle

	PFNDPLMSGQMESSAGEHANDLER	m_pfnMessageHandler;
	PVOID						m_pvContext;

	DPNHANDLE	m_hSender;	// For all SEND messages

	DWORD   m_dwIdleTimeout;   // Amount of time between idle messages
};

#undef DPF_MODNAME

#endif	// __DPLMSGQ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\lobby\dplhandles.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Handles.cpp
 *  Content:    Handle manager
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  08/19/99	mjn		Created
 *	03/23/00	mjn		Revised to ensure 64-bit compliance
 *	03/24/00	mjn		Added H_Enum
 *  07/09/00	rmt		Added signature bytes
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *  08/31/00	rmt		Whistler Prefix Bug 171826
 *
 ***************************************************************************/

#include "dnlobbyi.h"


#define	INC_SERIAL_COUNT(a)		if (++((a)->dwSerial) == 0)	((a)->dwSerial)++
#define	INDEX_MASK				0x000fffff
#define	SERIAL_MASK				0xfff00000
#define SERIAL_SHIFT				20
#define	GET_INDEX(h)			(h & INDEX_MASK)
#define	GET_SERIAL(h)			((h & SERIAL_MASK) >> SERIAL_SHIFT)
#define	MAKE_HANDLE(i,s)		((i & INDEX_MASK) | ((s << SERIAL_SHIFT) & SERIAL_MASK))
#define	VERIFY_HANDLE(p,h)		(((h & INDEX_MASK) < (p)->dwNumHandles) && ((p)->HandleArray[(h & INDEX_MASK)].dwSerial) && ((h & SERIAL_MASK) == ((p)->HandleArray[(h & INDEX_MASK)].dwSerial << SERIAL_SHIFT)))


#undef DPF_MODNAME
#define DPF_MODNAME "H_Grow"

HRESULT H_Grow(HANDLESTRUCT *const phs,
			   const DWORD dwIncSize)
{
	HRESULT		hResultCode = S_OK;
	DWORD		dw;

	DPFX(DPFPREP, 9,"Parameters: phs [0x%p], dwIncSize [%ld]",phs,dwIncSize);

	if (dwIncSize == 0)
	{
		DPFERR("Must grow handles by at least 1");
		return(E_INVALIDARG);
	}

	// Grab CS
	DNEnterCriticalSection(&phs->dncs);

	if (phs->HandleArray == NULL || phs->dwNumHandles == 0)
	{
		if ((phs->HandleArray = static_cast<HANDLEELEMENT*>(DNMalloc((dwIncSize + phs->dwNumHandles) * sizeof(HANDLEELEMENT)))) == NULL)
		{
			DPFERR("Could not create handle array");
			hResultCode = E_OUTOFMEMORY;
			goto EXIT_H_Grow;
		}
	}
	else
	{
		if ((phs->HandleArray = static_cast<HANDLEELEMENT*>(DNRealloc(phs->HandleArray,(dwIncSize + phs->dwNumHandles) * sizeof(HANDLEELEMENT)))) == NULL)
		{
			DPFERR("Could not grow handle array");
			hResultCode = E_OUTOFMEMORY;
			goto EXIT_H_Grow;
		}
	}

	// Update Handle Structure
	phs->dwFirstFreeHandle = phs->dwNumHandles;
	phs->dwLastFreeHandle = phs->dwNumHandles + dwIncSize - 1;
	phs->dwNumFreeHandles = dwIncSize;
	phs->dwNumHandles += dwIncSize;

	// Setup free Handle Elements
	for (dw = 0 ; dw < dwIncSize - 1 ; dw++)
	{
		phs->HandleArray[phs->dwFirstFreeHandle + dw].dwSerial = 0;
		phs->HandleArray[phs->dwFirstFreeHandle + dw].Entry.dwIndex = phs->dwFirstFreeHandle + dw + 1;
	}
	phs->HandleArray[phs->dwFirstFreeHandle + dw].dwSerial = 0;
	phs->HandleArray[phs->dwFirstFreeHandle + dw].Entry.pvData = NULL;

EXIT_H_Grow:

	// Release CS
	DNLeaveCriticalSection(&phs->dncs);

	DPFX(DPFPREP, 9,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "H_Initialize"

HRESULT	H_Initialize(HANDLESTRUCT *const phs,
					 const DWORD dwInitialNum)
{
	HRESULT		hResultCode = S_OK;

	DPFX(DPFPREP, 9,"Parameters: phs [0x%p], dwInitialNum [%ld]",phs,dwInitialNum);

	if (dwInitialNum == 0)
	{
		DPFERR("Must initialize handles with at least 1");
		return(E_INVALIDARG);
	}

	if (!DNInitializeCriticalSection(&phs->dncs))
	{
		DPFERR("DNInitializeCriticalSection() failed");
		return(E_OUTOFMEMORY);
	}

	// Lock
	DNEnterCriticalSection(&phs->dncs);

	phs->dwSignature = DPLSIGNATURE_HANDLESTRUCT;
	phs->HandleArray = NULL;
	phs->dwNumHandles = 0;
	phs->dwNumFreeHandles = 0;
	phs->dwFirstFreeHandle = 0;
	phs->dwLastFreeHandle = 0;
	phs->dwSerial = 1;

	if ((hResultCode = H_Grow(phs,dwInitialNum)) != S_OK)
	{
		DPFERR("H_Grow() failed");
		goto EXIT_H_Initialize;
	}

EXIT_H_Initialize:

	// Unlock
	DNLeaveCriticalSection(&phs->dncs);

	DPFX(DPFPREP, 9,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "H_Terminate"

void H_Terminate(HANDLESTRUCT *const phs)
{
	DPFX(DPFPREP, 9,"Parameters: phs [0x%p]",phs);

	if (phs->HandleArray != NULL)
		DNFree(phs->HandleArray);

	phs->dwNumHandles = 0;
	phs->dwSignature = DPLSIGNATURE_HANDLESTRUCT_FREE;

	DNDeleteCriticalSection(&phs->dncs);

	DPFX(DPFPREP, 9,"Returning");
}


#undef DPF_MODNAME
#define DPF_MODNAME "H_Create"

HRESULT H_Create(HANDLESTRUCT *const phs,
				 void *const pvData,
				 DWORD *const pHandle)
{
	DWORD	dwIndex;
	HRESULT	hResultCode = S_OK;

	DPFX(DPFPREP, 9,"Parameters: phs [0x%p], pvData [0x%p], pHandle [0x%p]",phs,pvData,pHandle);

	if (pHandle == NULL)
	{
		DPFERR("Invalid handle pointer");
		return(E_INVALIDARG);
	}

	// Lock
	DNEnterCriticalSection(&phs->dncs);

	// If there are no free handles, double the handle array
	if (phs->dwNumFreeHandles == 0)
	{
		if ((hResultCode = H_Grow(phs,phs->dwNumHandles)) != S_OK)	// Double the size
		{
			DPFERR("H_Grow() failed");
			goto EXIT_H_Create;
		}
	}

	// Update internal handle pointers
	dwIndex = phs->dwFirstFreeHandle;
	phs->dwFirstFreeHandle = phs->HandleArray[dwIndex].Entry.dwIndex;
	phs->dwNumFreeHandles--;

	do
	{
		// Update handle information
		INC_SERIAL_COUNT(phs);
		phs->HandleArray[dwIndex].dwSerial = phs->dwSerial;
		phs->HandleArray[dwIndex].Entry.pvData = pvData;

		// Create user's handle
		*pHandle = MAKE_HANDLE(dwIndex,phs->dwSerial);
	} while (*pHandle == 0);		// Don't want 0 handle

	DPFX(DPFPREP, 9,"Returning: *pHandle = [0x%lx]",*pHandle);

EXIT_H_Create:

	// Unlock
	DNLeaveCriticalSection(&phs->dncs);

	DPFX(DPFPREP, 9,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "H_Destroy"

HRESULT	H_Destroy(HANDLESTRUCT *const phs,
				  const DWORD handle)
{
	DWORD	dwIndex;
	DWORD	dwSerial;
	HRESULT	hResultCode = S_OK;

	DPFX(DPFPREP, 9,"Parameters: phs [0x%p], handle [0x%lx]",phs,handle);

	// Lock
	DNEnterCriticalSection(&phs->dncs);

	// Ensure valid handle supplied
	if (!VERIFY_HANDLE(phs,handle))
	{
		DPFERR("Invalid handle");
		hResultCode = E_INVALIDARG;
		goto EXIT_H_Destroy;
	}

	dwIndex = GET_INDEX(handle);
	dwSerial = GET_SERIAL(handle);

	// Add handle to end of free list
	if (phs->dwNumFreeHandles == 0)		// Only free handle
	{
		phs->dwFirstFreeHandle = phs->dwLastFreeHandle = dwIndex;
	}
	else									// Other handles, so add to end of list
	{
		phs->HandleArray[phs->dwLastFreeHandle].Entry.dwIndex = dwIndex;
		phs->dwLastFreeHandle = dwIndex;
	}

	// Clear out returned handle
	phs->HandleArray[dwIndex].dwSerial = 0;
	phs->HandleArray[dwIndex].Entry.pvData = NULL;

	// Update handle structure
	INC_SERIAL_COUNT(phs);
	phs->dwNumFreeHandles++;

EXIT_H_Destroy:

	// Unlock
	DNLeaveCriticalSection(&phs->dncs);

	DPFX(DPFPREP, 9,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "H_Retrieve"

HRESULT H_Retrieve(HANDLESTRUCT *const phs,
				   const DWORD handle,
				   void **const ppvData)
{
	DWORD		dwIndex;
	DWORD		dwSerial;
	HRESULT		hResultCode = S_OK;

	DPFX(DPFPREP, 9,"Parameters: phs [0x%p], handle [0x%lx], ppvData [0x%p]",phs,handle,ppvData);

	// Lock
	DNEnterCriticalSection(&phs->dncs);

	// Ensure valid handle supplied
	if (!VERIFY_HANDLE(phs,handle))
	{
		DPFERR("Invalid handle");
		hResultCode = DPNERR_INVALIDHANDLE;
		goto EXIT_H_Retrieve;
	}

	if (ppvData == NULL)
	{
		DPFERR("Invalid data return pointer");
		hResultCode = DPNERR_INVALIDHANDLE;
		goto EXIT_H_Retrieve;
	}

	dwIndex = GET_INDEX(handle);
	dwSerial = GET_SERIAL(handle);

	*ppvData = phs->HandleArray[GET_INDEX(handle)].Entry.pvData;
	DPFX(DPFPREP, 9,"Returning: *ppvData = [0x%p]",*ppvData);

EXIT_H_Retrieve:

	// Unlock
	DNLeaveCriticalSection(&phs->dncs);

	DPFX(DPFPREP, 9,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "H_Enum"

HRESULT H_Enum(HANDLESTRUCT *const phs,
			   DWORD *const pdwNumHandles,
			   DWORD *const rgHandles)
{
	HRESULT		hResultCode;
	DWORD		dw;
	DWORD		dwNumHandles;
	DWORD		*pHandle;

	DPFX(DPFPREP, 3,"Parameters: phs [0x%p], pdwNumHandles [0x%p], rgHandles [0x%p]",
			phs,pdwNumHandles,rgHandles);

	DNASSERT(phs != NULL);
	DNASSERT(pdwNumHandles != NULL);
	DNASSERT(rgHandles != NULL || *pdwNumHandles == 0);

	hResultCode = S_OK;
	dwNumHandles = 0;
	DNEnterCriticalSection(&phs->dncs);
	for (dw = 0 ; dw < phs->dwNumHandles ; dw++)
	{
		if (phs->HandleArray[dw].dwSerial != NULL)
		{
			DPFX(DPFPREP, 5,"Found handle data at [%ld]",dw);
			dwNumHandles++;
		}
	}

	if (dwNumHandles)
	{
		if( rgHandles == NULL )
		{
			DPFX(DPFPREP,  1, "Buffer too small!" );
			*pdwNumHandles = dwNumHandles;
			DNLeaveCriticalSection(&phs->dncs);		
			return E_POINTER;
		}
		
		if (dwNumHandles <= *pdwNumHandles)
		{
			pHandle = rgHandles;
			for (dw = 0 ; dw < phs->dwNumHandles ; dw++)
			{
				if (phs->HandleArray[dw].dwSerial != NULL)
				{
					*pHandle++ = MAKE_HANDLE(dw,phs->HandleArray[dw].dwSerial);
				}
			}
		}
		else
		{
			hResultCode = E_POINTER;
		}
	}
	*pdwNumHandles = dwNumHandles;

	DNLeaveCriticalSection(&phs->dncs);

	DPFX(DPFPREP, 3,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\lobby\dplmsgq.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DPLMsgQ.cpp
 *  Content:    DirectPlay Lobby Message Queues
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  02/21/00	mjn		Created
 *	04/26/00	mjn		Fixed AddData() to return HRESULT
 *  07/06/00	rmt		Bug #38111 - Fixed prefix bug
 *  07/08/2000	rmt		Bug #38725 - Need to provide method to detect if app was lobby launched
 *				rmt		Bug #38757 - Callback messages for connections may return AFTER WaitForConnection returns
 *				rmt		Bug #38755 - No way to specify player name in Connection Settings
 *				rmt		Bug #38758 - DPLOBBY8.H has incorrect comments
 *				rmt		Bug #38783 - pvUserApplicationContext is only partially implemented
 *				rmt		Added DPLHANDLE_ALLCONNECTIONS and dwFlags (reserved field to couple of funcs).
 *	07/21/2000	rmt		Removed assert which wasn't needed
 *  08/05/2000  RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *  08/31/2000	rmt		Bug #171831, 131832 (Prefix Bugs)
 *  01/31/2001	rmt		WINBUG #295562 IDirectPlay8LobbyClient: SetConnectionSettings not sending DPL_CONNECTION_SETTINGS message to App
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dnlobbyi.h"


//	DirectPlay Lobby Message Queues
//
//	We will use shared memory circular message buffers to implement this.
//	Each MsgQ has a set of synchronization objects to control access to the MsgQs.
//	The head of the shared memory file contains state information about the MsgQ:
//		pStartAddress
//		dwTotalUsableSpace
//		dwFirstMsgOffset
//		dwNextFreeOffset
//		dwFreeSpaceAtEnd
//		dwTotalFreeSpace
//	Messages are DWORD aligned in the MsgQ.
//	Each message in the MsgQ has a header:
//		dwMsgId
//		dwCurrentOffset
//		dwCurrentSize
//		dwTotalSize
//	Messages which fit in one frame have dwCurrentSize = dwTotalSize and dwCurrentOffset = 0.
//	Messages over multiple frames have dwCurrentSize < dwTotalSize.


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
//	CMessageQueue::Open
//
//	Entry:	const DWORD		dwPID			Id associated with this queue (user supplied)
//			const CHAR		cSuffix			Suffix character associated with this Q (user supp.)
//			const DWORD		dwQueueSize		Size of file map to use when implementing msg queue
//          const DWORD     dwIdleTimeout   Amount of time between idle messages == INFINITE to disable idle
//			const DWORD		dwFlags			TBA
//      
//
//	Exit:		HRESULT:	DPN_OK		If able to open an existing message queue,
//											or create a message queue if one didn't exist
//							DPNERR_OUTOFMEMORY
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "CMessageQueue::Open"

HRESULT CMessageQueue::Open(const DWORD dwPID,
							const CHAR cSuffix,
							const DWORD dwQueueSize,
							const DWORD dwIdleTimeout,
							const DWORD dwFlags)
{
	HRESULT		hResultCode;
	PSTR		pszObjectName = NULL;
	BOOL		bQueueExists = FALSE;
	DWORD		dwFileMapSize;

	DPFX(DPFPREP, 3,"Parameters: dwPID [0x%lx], cSuffix [%c], dwQueueSize [%ld], dwFlags [0x%lx]",
			dwPID,cSuffix,dwQueueSize,dwFlags);

	// Create Receive Thread Running Event
	//	This will be set by the receive thread once it has spun up.  We need it for synchronization
	m_hReceiveThreadRunningEvent = CreateEventA(NULL,TRUE,FALSE,NULL);
	if (m_hReceiveThreadRunningEvent == NULL)
	{
		DPFERR("Could not create recevie thread");
		hResultCode = DPNERR_OUTOFMEMORY;
		goto EXIT_Initialize;
	}

	// Create shared object name
	// pszObjectName : {SharedObjectChar}PID{cSuffix}{\0}
	if ((pszObjectName = (PSTR)DNMalloc(1 + (sizeof(DWORD)*2) + 1 + 1)) == NULL)
	{
		DPFERR("Could not allocate space for lpszObjectName");
		hResultCode = DPNERR_OUTOFMEMORY;
		goto EXIT_Initialize;
	}
	wsprintfA(pszObjectName,"-%08X%c",dwPID,cSuffix);// save first char for object differentiation
	DPFX(DPFPREP, 5,"Shared object name [%s]",pszObjectName);

	// Set the filemap size big enough that the largest message (text) will be dwQueueSize
	// so we add on the MsgQ info structure at the front and 1 Msg header
	dwFileMapSize = dwQueueSize + sizeof(DPL_MSGQ_INFO) + sizeof(DPL_MSGQ_HEADER);
	dwFileMapSize = (dwFileMapSize + 3) & (~0x3);	// DWORD align

	m_dwIdleTimeout = dwIdleTimeout;

	// Create File Mapping Object
	*pszObjectName = DPL_MSGQ_OBJECT_IDCHAR_FILEMAP;
	m_hFileMap = CreateFileMappingA(INVALID_HANDLE_VALUE,DNGetNullDacl(),
		PAGE_READWRITE,(DWORD)0,dwQueueSize,pszObjectName);
	if (m_hFileMap == NULL)
	{
		DPFERR("CreateFileMapping() failed");
		hResultCode = DPNERR_GENERIC;
		goto EXIT_Initialize;
	}
	if (GetLastError() == ERROR_ALREADY_EXISTS)
		bQueueExists = TRUE;

	if ((dwFlags & DPL_MSGQ_OPEN_FLAG_NO_CREATE) && !bQueueExists)
	{
		DPFERR("Open existing queue failed - does not exist");
		hResultCode = DPNERR_DOESNOTEXIST;
		goto EXIT_Initialize;
	}

	// Map file
	m_pFileMapAddress = reinterpret_cast<BYTE*>(MapViewOfFile(m_hFileMap,FILE_MAP_ALL_ACCESS,0,0,0));
	if (m_pFileMapAddress == NULL)
	{
		DPFERR("MapViewOfFile() failed");
		hResultCode = DPNERR_OUTOFMEMORY;
		goto EXIT_Initialize;
	}

	// Create semaphore object
	*pszObjectName = DPL_MSGQ_OBJECT_IDCHAR_SEMAPHORE;
	m_hSemaphore = CreateSemaphoreA(DNGetNullDacl(),0,
		(dwQueueSize/sizeof(DPL_MSGQ_HEADER))+1,pszObjectName);
	if (m_hSemaphore == NULL)
	{
		DPFERR("CreateSemaphore() failed");
		hResultCode = DPNERR_OUTOFMEMORY;
		goto EXIT_Initialize;
	}

	// Create event object
	*pszObjectName = DPL_MSGQ_OBJECT_IDCHAR_EVENT;

	// Changed to a semaphore to ensure that we never miss an event signal
	m_hEvent = CreateSemaphoreA(DNGetNullDacl(), 0, (dwQueueSize/sizeof(DPL_MSGQ_HEADER))+1, pszObjectName );

	if( m_hEvent == NULL )
	{
		DPFERR( "CreateSemaphore() failed" );
		hResultCode = DPNERR_OUTOFMEMORY;
		goto EXIT_Initialize;
	}

	// Create mutex object
	*pszObjectName = DPL_MSGQ_OBJECT_IDCHAR_MUTEX;
	m_hMutex = CreateMutexA(DNGetNullDacl(),FALSE,pszObjectName);
	if (m_hMutex == NULL)
	{
		DPFERR("CreateMutex() failed");
		hResultCode = DPNERR_OUTOFMEMORY;
		goto EXIT_Initialize;
	}

	// Update structure elements
	m_dwPID = dwPID;
	m_pInfo = reinterpret_cast<DPL_MSGQ_INFO*>(m_pFileMapAddress);

	// Initialize msg queue if it didn't exist
	if (!bQueueExists)
	{
		m_pInfo->dwFlags = dwFlags & 0x0000ffff;	// Just last two bytes
		m_pInfo->dwStartOffset = 0;
		m_pInfo->dwEndOffset = 0;
		m_pInfo->dwQueueSize = dwQueueSize - sizeof(DPL_MSGQ_INFO);
		m_pInfo->dwFreeBytes = m_pInfo->dwQueueSize;
		m_pInfo->lRefCount = 0;
	}

	m_pData = (BYTE *) &m_pInfo[1];
	m_dwSig = DPL_MSGQ_SIGNATURE;

	// Increment user count
	Lock();
	m_pInfo->lRefCount++;
	Unlock();

	// If we made it this far, everything was okay
	hResultCode = DPN_OK;

EXIT_Initialize:

	// Free object name string
	if (pszObjectName != NULL)
		DNFree(pszObjectName);

	// If there was a problem - close handles
	if (hResultCode != DPN_OK)
	{
		DPFERR("Errors encountered - closing");
		Close();
	}

	DPFX(DPFPREP, 3,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}



//**********************************************************************
// ------------------------------
//	CMessageQueue::Close
//
//	Entry:		Nothing
//
//	Exit:		Nothing
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "CMessageQueue::Close"

void CMessageQueue::Close(void)
{
	DPFX(DPFPREP, 3,"Parameters: (none)");

	if (m_hMutex != NULL)
	{
		// Decrement user count
		Lock();
		if( m_pInfo != NULL )
		{
			m_pInfo->lRefCount--;
		}
		Unlock();

		DPFX(DPFPREP, 5,"Close Mutex [0x%p]",m_hMutex);
		CloseHandle(m_hMutex);
		m_hMutex = NULL;
	}
	if (m_hEvent != NULL)
	{
		DPFX(DPFPREP, 5,"Close Event [0x%p]",m_hEvent);
		CloseHandle(m_hEvent);
		m_hEvent = NULL;
	}
	if (m_hSemaphore != NULL)
	{
		DPFX(DPFPREP, 5,"Close Semaphore [0x%p]",m_hSemaphore);
		CloseHandle(m_hSemaphore);
		m_hSemaphore = NULL;
	}
	if (m_pFileMapAddress != NULL)
	{
		DPFX(DPFPREP, 5,"UnMap View of File [0x%p]",m_pFileMapAddress);
		UnmapViewOfFile(m_pFileMapAddress);
		m_pFileMapAddress = NULL;
	}
	if (m_hFileMap != NULL)
	{
		DPFX(DPFPREP, 5,"Close FileMap [0x%p]",m_hFileMap);
		CloseHandle(m_hFileMap);
		m_hFileMap = NULL;
	}
	if (m_hReceiveThreadRunningEvent != NULL)
	{
		DPFX(DPFPREP, 5,"Close Event [0x%p]",m_hReceiveThreadRunningEvent);
		CloseHandle(m_hReceiveThreadRunningEvent);
		m_hReceiveThreadRunningEvent = NULL;
	}

	m_pInfo = NULL;

	DPFX(DPFPREP, 3,"Returning");
}


//**********************************************************************
// ------------------------------
//	CMessageQueue::Terminate
//
//	Entry:		Nothing
//
//	Exit:		Nothing
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "CMessageQueue::Terminate"

void CMessageQueue::Terminate(void)
{

	BOOL	bDone = FALSE;

	DPL_MSGQ_HEADER	Header;

	Header.dwCurrentSize = 0;
	Header.dwTotalSize = 0;
	Header.dwMsgId = DPL_MSGQ_MSGID_TERMINATE;
	Header.hSender = 0xFFFFFFFF;
	Header.dwFlags = DPL_MSGQ_MSGFLAGS_QUEUESYSTEM;
	Header.dwCurrentOffset = 0;

	DPFX(DPFPREP, 3,"Parameters: (none)");

	DNASSERT(m_pInfo != NULL);

	while (!bDone)
	{
		// Wait until there's enough space for the message
		while (sizeof(DWORD) > m_pInfo->dwFreeBytes)
			WaitForConsumption(INFINITE);

		Lock();

		// Ensure there is space once we get the lock
		// (someone else might have beaten us here)
		if (sizeof(DWORD) <= m_pInfo->dwFreeBytes)
		{
			AddData(reinterpret_cast<BYTE*>(&Header),sizeof(DPL_MSGQ_HEADER));
			bDone = TRUE;

			IndicateMessage();
		}

		Unlock();
	}

	DPFX(DPFPREP, 3,"Returning");
}

// GetNextMessage
//
// Attempts to retrieve the next message from the queue
//
// pMsgHeader must be large enough to hold a message header.
//
// If no message is present in the queue then this function fills pMsgHeader with an
// idle message header
//
HRESULT CMessageQueue::GetNextMessage( PDPL_MSGQ_HEADER pMsgHeader, BYTE *pbPayload, DWORD *pdwBufferSize )
{
	HRESULT hr;

	Lock();

	hr = GetData( (BYTE *) pMsgHeader, sizeof( DPL_MSGQ_HEADER ) );

	// If there is no header on the queue fill in the header with an 
	// idle message
	if( hr == DPNERR_DOESNOTEXIST )
	{
		pMsgHeader->dwCurrentSize = sizeof( DPL_MSGQ_HEADER );
		pMsgHeader->dwTotalSize = sizeof( DPL_MSGQ_HEADER );
		pMsgHeader->dwMsgId = DPL_MSGQ_MSGID_IDLE;
		pMsgHeader->hSender = 0;
		pMsgHeader->dwFlags = DPL_MSGQ_MSGFLAGS_QUEUESYSTEM;
		pMsgHeader->dwCurrentOffset = 0;
		Unlock();

		return DPN_OK;
	}
	//// DEBUG
	else if( FAILED( hr ) )
	{
		DNASSERT( FALSE );
	}
	else if( pMsgHeader->dwMsgId == 0xFFFFFFFF )
	{
		DNASSERT( FALSE );
	}

	DWORD dwPayloadSize = pMsgHeader->dwCurrentSize;

	// Otherwise it's a valid message of some kind
	if( *pdwBufferSize < dwPayloadSize || pbPayload == NULL )
	{
		*pdwBufferSize = dwPayloadSize;
		Unlock();
		return DPNERR_BUFFERTOOSMALL;
	}

	*pdwBufferSize = dwPayloadSize;

	Consume( sizeof(DPL_MSGQ_HEADER) );

	// There is no payload, only a header.  Return here.
	if( dwPayloadSize == 0 )
	{
		Unlock();
		return DPN_OK;
	}

	hr = GetData( pbPayload, dwPayloadSize );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Error getting IPC queue message payload" );
		DNASSERT( FALSE );
		Unlock();
		return hr;
	}

	Consume( dwPayloadSize );
	
	Unlock();

	return DPN_OK;
}

// Consume
//
// Marks dwSize bytes as consumed
//
// Needs LOCK()
void CMessageQueue::Consume( const DWORD dwSize )
{
	DWORD dwAlignedSize = (dwSize + 3) & (~0x3);

	m_pInfo->dwStartOffset += dwAlignedSize;

	if( m_pInfo->dwStartOffset >= m_pInfo->dwQueueSize )
	{
		m_pInfo->dwStartOffset -= m_pInfo->dwQueueSize;
	}

	m_pInfo->dwFreeBytes += dwAlignedSize;

	DNASSERT( m_pInfo->dwFreeBytes <= m_pInfo->dwFreeBytes );

	IndicateConsumption();
}

// GetData
//
// Get dwSize bytes from the queue.  If the queue is empty this function will return
// DPNERR_DOESNOTEXIST.  Once this function returns the dwSize bytes will be consumed
//
// REQUIRES LOCK
//
HRESULT CMessageQueue::GetData( BYTE *pbData, DWORD dwSize )
{
	if( m_pInfo->dwQueueSize == m_pInfo->dwFreeBytes )
	{
		return DPNERR_DOESNOTEXIST;
	}

	if( pbData == NULL )
	{
		return DPNERR_BUFFERTOOSMALL;
	}	

	// Calculate aligned size 
	DWORD dwAlignedSize = (dwSize + 3) & (~0x3);

	// Data block we want is wrapped
	if( m_pInfo->dwStartOffset+dwAlignedSize > m_pInfo->dwQueueSize )
	{
		DWORD cbBytesLeft = m_pInfo->dwQueueSize - m_pInfo->dwStartOffset;
		DWORD cbSecondBlockAligned = dwAlignedSize - (cbBytesLeft);
		DWORD cbSecondBlock = dwSize - (cbBytesLeft);

		DNASSERT( dwAlignedSize > cbBytesLeft);

		memcpy( pbData, m_pData + m_pInfo->dwStartOffset, cbBytesLeft);
		memcpy( pbData + cbBytesLeft, m_pData , cbSecondBlock );
	}
	// Data block is contiguous
	else
	{
		memcpy( pbData, m_pData + m_pInfo->dwStartOffset, dwSize );
	}		

	return DPN_OK;
}


//**********************************************************************
// ------------------------------
//	CMessageQueue::AddData
//
//	Entry:		BYTE *const pBuffer
//				const DWORD dwSize
//
//	Exit:		HRESULT
// ------------------------------
//
// REQUIRES LOCK!!
//
#undef DPF_MODNAME
#define DPF_MODNAME "CMessageQueue::AddData"

HRESULT CMessageQueue::AddData(BYTE *const pBuffer,
							   const DWORD dwSize)
{
	HRESULT		hResultCode;
	DWORD		dwAlignedSize;

	DPFX(DPFPREP, 3,"Parameters: pBuffer [0x%p], dwSize [%ld]",pBuffer,dwSize);

	dwAlignedSize = (dwSize + 3) & (~0x3);

	// Check to ensure there is space
	if( dwAlignedSize > m_pInfo->dwFreeBytes )
	{
		hResultCode = DPNERR_BUFFERTOOSMALL;
		goto Exit;
	}

	// We have a wrapping condition
	if( (m_pInfo->dwEndOffset+dwAlignedSize) > m_pInfo->dwQueueSize )
	{
		DWORD cbBytesLeft = m_pInfo->dwQueueSize - m_pInfo->dwEndOffset;
		DWORD cbSecondBlockAligned = dwAlignedSize - cbBytesLeft;
		DWORD cbSecondBlock = dwSize - cbBytesLeft;

		DNASSERT( dwAlignedSize > cbBytesLeft );

		memcpy( m_pData + m_pInfo->dwEndOffset, pBuffer, cbBytesLeft );
		memcpy( m_pData, pBuffer + cbBytesLeft, cbSecondBlock );

		m_pInfo->dwEndOffset = cbSecondBlockAligned;
	}
	// Queue is in the middle
	else
	{
		memcpy( m_pData + m_pInfo->dwEndOffset, pBuffer, dwSize );
		m_pInfo->dwEndOffset += dwAlignedSize;
	}

	m_pInfo->dwFreeBytes -= dwAlignedSize;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//**********************************************************************
// ------------------------------
//	CMessageQueue::Send
//
//	Entry:		BYTE *const pBuffer
//				const DWORD dwSize
//				const DWORD dwFlags
//
//	Exit:		HRESULT
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "CMessageQueue::Send"

HRESULT CMessageQueue::Send(BYTE *const pBuffer,
							const DWORD dwSize,
							const DWORD dwTimeOut,
							const DWORD dwMsgFlags,
							const DWORD dwFlags)
{
	HRESULT			hResultCode;
	DWORD			dwMsgSize;		// DWORD aligned
	DWORD			dwTotalMsgSize;	// Msg + Header - DWORD aligned
	DPL_MSGQ_HEADER	Header;
	DPL_MSGQ_HEADER	*pHeader;
	BOOL			bDone;
	DWORD			dwTimeRemaining;
	DWORD			dwTimeStart;
	DWORD			dwTimeFinish;

	DPFX(DPFPREP, 3,"Parameters: pBuffer [0x%p], dwSize [%ld], dwFlags [0x%lx]",pBuffer,dwSize,dwFlags);

	DNASSERT( pBuffer != NULL );
	DNASSERT( dwSize <= m_pInfo->dwQueueSize );

	dwTimeRemaining = dwTimeOut;

	// Need DWORD aligned size
	dwMsgSize = (dwSize + 3) & (~0x3);
	dwTotalMsgSize = dwMsgSize + sizeof(DPL_MSGQ_HEADER);

	// Place the message into the MsgQ
	// Check to see if fragmentation is required
	// If we're at the end of the MsgQ and there isn't enough space for a Msg Header, REALIGN
	if (dwTotalMsgSize <= m_pInfo->dwQueueSize)
	{
		DPFX(DPFPREP, 5,"Message does not need to be fragmented");

		Header.dwMsgId = DPL_MSGQ_MSGID_SEND;
		Header.dwCurrentOffset = 0;
		Header.dwCurrentSize = dwSize;
		Header.dwTotalSize = dwSize;
		Header.hSender = m_hSender;
		Header.dwFlags = dwMsgFlags; // Mark this as a user message

		//// DEBUG
		if( Header.dwMsgId == 0xFFFFFFFF )
		{
			DNASSERT( FALSE );
		}

		bDone = FALSE;
		while (!bDone)
		{
			// Wait until there's enough space for the message
			while (dwTotalMsgSize > m_pInfo->dwFreeBytes)
			{
				if (dwTimeOut != INFINITE)
				{
					dwTimeStart = GETTIMESTAMP();
				}

				if (!WaitForConsumption(dwTimeRemaining))
				{
					return(DPNERR_TIMEDOUT);
				}

				if (dwTimeOut != INFINITE)
				{
					dwTimeFinish = GETTIMESTAMP();
					if ((dwTimeFinish - dwTimeStart) > dwTimeRemaining)
					{
						return(DPNERR_TIMEDOUT);
					}
					dwTimeRemaining -= (dwTimeFinish - dwTimeStart);
				}
			}

			Lock();

			// Ensure there is space once we get the lock
			// (someone else might have beaten us here)
			if (dwTotalMsgSize <= m_pInfo->dwFreeBytes)
			{
				//// DEBUG
				if( Header.dwMsgId == 0xFFFFFFFF )
				{
					DNASSERT( FALSE );
				}

				hResultCode = AddData(reinterpret_cast<BYTE*>(&Header),sizeof(DPL_MSGQ_HEADER));
				DNASSERT(hResultCode == DPN_OK);
				hResultCode = AddData(pBuffer,dwSize);
				DNASSERT(hResultCode == DPN_OK);
				bDone = TRUE;

				IndicateMessage();
			}

			Unlock();
			hResultCode = DPN_OK;
		}
	}
	else
	{
		DPFX(DPFPREP, 5,"Message needs to be fragmented");
		DNASSERT(FALSE);
		hResultCode = DPNERR_GENERIC;
#pragma TODO(a-minara,"Implement this")
	}


	DPFX(DPFPREP, 3,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}



//**********************************************************************
// ------------------------------
//	DPLIsApplicationAvailable
//
//	Entry:		const DWORD		dwPID		PID to check
//
//	Exit:		BOOL	TRUE	If the application's queue's flags were retrieved successfully
//									and the application is waiting for a connection
//						FALSE	Otherwise
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "DPLIsApplicationAvailable"

BOOL DPLIsApplicationAvailable(const DWORD dwPID)
{
	BOOL			bReturnCode;
	CMessageQueue	MessageQueue;

	DPFX(DPFPREP, 3,"Parameters: dwPID [%lx]",dwPID);

	if (MessageQueue.Open(dwPID,DPL_MSGQ_OBJECT_SUFFIX_APPLICATION,DPL_MSGQ_SIZE,
			INFINITE, DPL_MSGQ_OPEN_FLAG_NO_CREATE) != DPN_OK)
	{
		DPFERR("Could not open Msg Queue");
		return(FALSE);
	}

	bReturnCode = MessageQueue.IsAvailable();

	MessageQueue.Close();

	DPFX(DPFPREP, 3,"Returning: [%ld]",bReturnCode);
	return(bReturnCode);
}


//**********************************************************************
// ------------------------------
//	DPLMakeApplicationUnavailable
//
//	Entry:		const DWORD		dwPID		PID to check
//
//	Exit:		HRESULT	DPN_OK	If the application was waiting for a connection
//									and made unavailable
//						DPNERR_INVALIDAPPLICATION
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "DPLMakeApplicationUnavailable"

HRESULT DPLMakeApplicationUnavailable(const DWORD dwPID)
{
	HRESULT			hResultCode;
	CMessageQueue	MessageQueue;

	DPFX(DPFPREP, 3,"Parameters: dwPID [%lx]",dwPID);

	if (MessageQueue.Open(dwPID,DPL_MSGQ_OBJECT_SUFFIX_APPLICATION,DPL_MSGQ_SIZE,
			DPL_MSGQ_OPEN_FLAG_NO_CREATE,INFINITE) != DPN_OK)
	{
		DPFERR("Could not open Msg Queue");
		return(DPNERR_INVALIDAPPLICATION);
	}

	if ((hResultCode = MessageQueue.MakeUnavailable()) != DPN_OK)
	{
		DPFERR("Could not make application unavailable");
		hResultCode = DPNERR_INVALIDAPPLICATION;
	}

	MessageQueue.Close();

	DPFX(DPFPREP, 3,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//**********************************************************************
// ------------------------------
//	DPLProcessMessageQueue
//
//	Entry:
//
//	Exit:		HRESULT	DPN_OK	If the application was waiting for a connection
//									and made unavailable
//						DPNERR_INVALIDAPPLICATION
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "DPLProcessMessageQueue"

DWORD WINAPI DPLProcessMessageQueue(PVOID pvReceiveQueue)
{
	HRESULT			hResultCode;
	DPL_MSGQ_HEADER	dplMsgHeader;
	BYTE			*pData;
	BYTE			*pBuffer = NULL;
	DWORD			dwBufferSize = 0;
	DWORD			dwSize;
	CMessageQueue	*pReceiveQueue;
	BYTE			*pMsg;
	DWORD           dwWaitResult;

	DPFX(DPFPREP, 3,"Parameters: (none)");

	COM_CoInitialize(NULL);

	pReceiveQueue = static_cast<CMessageQueue*>(pvReceiveQueue);

	// Indicate we are running
	pReceiveQueue->MakeReceiving();

	while(1)
	{
		dwWaitResult = pReceiveQueue->WaitForMessages();

		while( 1 ) 
		{
			dwSize = dwBufferSize;
    		hResultCode = pReceiveQueue->GetNextMessage(&dplMsgHeader, pBuffer, &dwSize);

			if( hResultCode == DPNERR_BUFFERTOOSMALL )
			{
				if( pBuffer )
					delete [] pBuffer;

				pBuffer = new BYTE[dwSize];
				
				if( pBuffer == NULL )
				{
					DPFX(DPFPREP,  0, "Error allocating memory" );
					DNASSERT( FALSE );
					goto EXIT_DPLProcessMessageQueue;
				}

				dwBufferSize = dwSize;
			}
			else if( FAILED( hResultCode ) )
			{
				DPFX(DPFPREP,  0, "Error while getting messages from the queue" );
				DNASSERT( FALSE );
				goto EXIT_DPLProcessMessageQueue;
			}
			else
			{
				break;
			}
		}

		DPFX(DPFPREP, 5,"dwMsgId [0x%lx] dwTotalSize [0x%lx] dwCurrentSize [0x%lx] dwCurrentOffset [0x%lx] ",
			dplMsgHeader.dwMsgId, dplMsgHeader.dwTotalSize, dplMsgHeader.dwCurrentSize, 
			dplMsgHeader.dwCurrentOffset );

		switch(dplMsgHeader.dwMsgId)
		{
		case DPL_MSGQ_MSGID_IDLE:
		    {
		        DPFX(DPFPREP, 6,"Idle message fired" );
		        DWORD dwMsgId = DPL_MSGID_INTERNAL_IDLE_TIMEOUT;
                //  7/17/2000(RichGr) - IA64: Change last parm from sizeof(DWORD) to sizeof(BYTE*).
				hResultCode = pReceiveQueue->CallMessageHandler(NULL,DPL_MSGQ_MSGFLAGS_USER1,(BYTE *) &dwMsgId,sizeof(BYTE*));
		    }
		    break;
		case DPL_MSGQ_MSGID_SEND:
			{
				DPFX(DPFPREP, 5,"DPL_MSGQ_MSGID_SEND");
				hResultCode = pReceiveQueue->CallMessageHandler(dplMsgHeader.hSender,dplMsgHeader.dwFlags,pBuffer,dwSize);
				break;
			}

		case DPL_MSGQ_MSGID_TERMINATE:
			{
				DPFX(DPFPREP, 5,"DPL_MSGQ_MSGID_TERMINATE");
				hResultCode = DPN_OK;
				goto EXIT_DPLProcessMessageQueue;
				break;
			}

		default:
			{
				DPFX(DPFPREP, 5,"UNKNOWN - should never get here");
				DNASSERT(FALSE);
				hResultCode = DPNERR_GENERIC;
				goto EXIT_DPLProcessMessageQueue;
				break;
			}
		}
	}

EXIT_DPLProcessMessageQueue:

	if( pBuffer )
		delete [] pBuffer;

	// Indicate we are no longer running
	pReceiveQueue->MakeNotReceiving();

	COM_CoUninitialize();

	DPFX(DPFPREP, 3,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\lobby\dplparam.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplparam.h
 *  Content:    DirectPlayLobby8 Parameter Validation helper routines
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  04/18/00    rmt     Created
 *  04/25/00    rmt     Bug #s 33138, 33145, 33150 
 *	04/26/00	mjn		Removed dwTimeOut from Send() API call
 *  06/15/00    rmt     Bug #33617 - Must provide method for providing automatic launch of DirectPlay instances   
 *  07/08/2000	rmt		Bug #38725 - Need to provide method to detect if app was lobby launched
 *				rmt		Bug #38757 - Callback messages for connections may return AFTER WaitForConnection returns
 *				rmt		Bug #38755 - No way to specify player name in Connection Settings
 *				rmt		Bug #38758 - DPLOBBY8.H has incorrect comments
 *				rmt		Bug #38783 - pvUserApplicationContext is only partially implemented
 *				rmt		Added DPLHANDLE_ALLCONNECTIONS and dwFlags (reserved field to couple of funcs).
 *
 ***************************************************************************/
#ifndef __DPLPARAM_H
#define __DPLPARAM_H

extern BOOL IsValidDirectPlayLobby8Object( LPVOID lpvObject );

extern HRESULT DPL_ValidateGetConnectionSettings(LPVOID lpv,const DPNHANDLE hLobbyClient, DPL_CONNECTION_SETTINGS * const pdplSessionInfo, DWORD *pdwInfoSize, const DWORD dwFlags );
extern HRESULT DPL_ValidateSetConnectionSettings(LPVOID lpv,const DPNHANDLE hLobbyClient, const DPL_CONNECTION_SETTINGS * const pdplSessionInfo, const DWORD dwFlags );
extern HRESULT DPL_ValidConnectionSettings( const DPL_CONNECTION_SETTINGS * const pdplConnectSettings );
extern HRESULT DPL_ValidateQueryInterface( LPVOID lpv,REFIID riid,LPVOID *ppv ); 
extern HRESULT DPL_ValidateRelease( PVOID pv );
extern HRESULT DPL_ValidateAddRef( PVOID pv );
extern HRESULT DPL_ValidConnectInfo( const DPL_CONNECT_INFO * const dplConnectInfo );
extern HRESULT DPL_ValidProgramDesc( const DPL_PROGRAM_DESC * const dplProgramInfo );

extern HRESULT DPL_ValidateRegisterProgram(IDirectPlay8LobbiedApplication *pInterface,
								 DPL_PROGRAM_DESC *const pdplProgramDesc,
								 const DWORD dwFlags);

extern HRESULT DPL_ValidateUnRegisterProgram(IDirectPlay8LobbiedApplication *pInterface,
							   GUID *pguidApplication,
							   const DWORD dwFlags);

extern HRESULT DPL_ValidateSetAppAvailable(IDirectPlay8LobbiedApplication *pInterface,  const BOOL fAvailable, const DWORD dwFlags);

extern HRESULT DPL_ValidateWaitForConnection(IDirectPlay8LobbiedApplication *pInterface,
								   const DWORD dwMilliseconds, const DWORD dwFlags );

extern HRESULT DPL_ValidateUpdateStatus(IDirectPlay8LobbiedApplication *pInterface,
							  const DPNHANDLE hLobby,
							  const DWORD dwStatus, const DWORD dwFlags );

extern HRESULT DPL_ValidateEnumLocalPrograms(IDirectPlay8LobbyClient *pInterface,
							  GUID *const pGuidApplication,
							  BYTE *const pEnumData,
							  DWORD *const pdwEnumDataSize,
							  DWORD *const pdwEnumDataItems,
							  const DWORD dwFlags );

extern HRESULT DPL_ValidateConnectApplication(IDirectPlay8LobbyClient *pInterface,
							   DPL_CONNECT_INFO *const pdplConnectionInfo,
							   const PVOID pvUserApplicationContext,
							   DPNHANDLE *const hApplication,
							   const DWORD dwTimeOut,
							   const DWORD dwFlags);

extern HRESULT DPL_ValidateReleaseApplication(IDirectPlay8LobbyClient *pInterface,
									const DPNHANDLE hApplication, const DWORD dwFlags );							  


extern HRESULT DPL_ValidateRegisterMessageHandler(PVOID pv,
										const PVOID pvUserContext,
										const PFNDPNMESSAGEHANDLER pfn,
										DPNHANDLE * const pdpnhConnection, 
										const DWORD dwFlags);

extern HRESULT DPL_ValidateClose(PVOID pv, const DWORD dwFlags );

extern HRESULT DPL_ValidateSend(PVOID pv,
					  const DPNHANDLE hTarget,
					  BYTE *const pBuffer,
					  const DWORD pBufferSize,
					  const DWORD dwFlags);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\lobby\dplproc.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DNLProc.cpp
 *  Content:    DirectPlay Lobby Process Functions
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   02/21/00	mjn		Created
 *   05/08/00   rmt     Bug #33616 -- Does not run on Win9X
 *   06/28/00	rmt		Prefix Bug #38082
 *   07/12/00	rmt		Fixed lobby launch so only compares first 15 chars (ToolHelp limitation).
 *   08/05/00   RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dnlobbyi.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************

#define PROCLIST_MAX_PATH		15

#undef DPF_MODNAME
#define DPF_MODNAME "DPLCompareFilenames"

BOOL DPLCompareFilenames(WCHAR *const pwszFilename1,
						 WCHAR *const pwszFilename2)
{
	WCHAR	*p1;
	WCHAR	*p2;
	DWORD	dwLen;

	DNASSERT(pwszFilename1 != NULL);
	DNASSERT(pwszFilename2 != NULL);

	// Skip path
	if ((p1 = wcsrchr(pwszFilename1,L'\\')) == NULL)
		p1 = pwszFilename1;
	else
		p1++;

	if ((p2 = wcsrchr(pwszFilename2,L'\\')) == NULL)
		p2 = pwszFilename2;
	else
		p2++;

//	if (wcsnicmp(p1,p2,dwLen)==0)
//		return(TRUE);
//	return(FALSE);

	/*dwLen = wcslen(p1);

	if (dwLen == 0 || dwLen != wcslen(p2) )
		return(FALSE);

	while(dwLen)
	{
		if (towupper(*p1) != towupper(*p2))
			return(FALSE);

		p1++;
		p2++;
		dwLen--;
	}*/

	return (_wcsnicmp(p1,p2,PROCLIST_MAX_PATH) == 0);
}




// ToolHelp Function Pointers.
typedef BOOL (WINAPI *PFNPROCESS32FIRSTW)(HANDLE,LPPROCESSENTRY32W);
typedef BOOL (WINAPI *PFNPROCESS32NEXTW)(HANDLE,LPPROCESSENTRY32W);

#undef DPF_MODNAME
#define DPF_MODNAME "DPLGetProcessList"

HRESULT DPLGetProcessList(WCHAR *const pwszProcess,
						  DWORD *const prgdwPid,
						  DWORD *const pdwNumProcesses,
						  const BOOL bIsUnicodePlatform)
{
	HRESULT			hResultCode;
	BOOL			bReturnCode;
	HANDLE			hSnapshot = NULL;	// System snapshot
	PROCESSENTRY32	processEntryA;
	PROCESSENTRY32W	processEntryW;	
	DWORD			dwNumProcesses;
	PWSTR			pwszExeFile = NULL;
	DWORD			dwExeFileLen;
	HMODULE         hKernelDLL = NULL;
	PFNPROCESS32FIRSTW pfProcess32FirstW;
	PFNPROCESS32NEXTW pfProcess32NextW;

	DPFX(DPFPREP, 3,"Parameters: pwszProcess [0x%p], prgdwPid [0x%p], pdwNumProcesses [0x%p]",
			pwszProcess,prgdwPid,pdwNumProcesses);

    // If we're unicode we have to dynamically load the kernel32 and get the unicode
    // entry points.  If we're 9X we can link.  -Sigh-
	if( bIsUnicodePlatform )
	{
    	hKernelDLL = LoadLibraryA( "Kernel32.DLL" );
    	if(hKernelDLL == NULL)
	    {
    		DPFERR("Unable to load Kernel32.DLL");
    		hResultCode = DPNERR_OUTOFMEMORY;
            goto CLEANUP_GETPROCESS;
    	}

    	pfProcess32FirstW=(PFNPROCESS32FIRSTW) GetProcAddress( hKernelDLL, "Process32FirstW" );
    	pfProcess32NextW=(PFNPROCESS32NEXTW) GetProcAddress( hKernelDLL, "Process32NextW" );

    	if( pfProcess32FirstW == NULL || pfProcess32NextW == NULL )
    	{
    	    DPFERR( "Error loading unicode entry points" );
    	    hResultCode = DPNERR_GENERIC;
    	    goto CLEANUP_GETPROCESS;
    	}
	}

	// Set up to run through process list
	hResultCode = DPN_OK;
	dwNumProcesses = 0;
	hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS|TH32CS_SNAPTHREAD,0);
	if (hSnapshot < 0)
	{
		DPFERR("Could not create Snapshot");
    	hResultCode = DPNERR_OUTOFMEMORY;
    	goto CLEANUP_GETPROCESS; 		
	}

	// Search SnapShot for process list
	dwExeFileLen = 0;
	pwszExeFile = NULL;

	if (bIsUnicodePlatform)
	{
    	processEntryW.dwSize = sizeof(PROCESSENTRY32W);
    	bReturnCode = (*pfProcess32FirstW)(hSnapshot,&processEntryW);
	}
	else
	{
    	processEntryA.dwSize = sizeof(PROCESSENTRY32);	
    	bReturnCode = Process32First(hSnapshot,&processEntryA);	
	}
	DPFX(DPFPREP, 7,"  dwSize  cntUsg       PID  cntThrds      PPID       PCB    Flags  Process");
	while (bReturnCode)
	{
		if (bIsUnicodePlatform)
		{
			pwszExeFile = processEntryW.szExeFile;
		}
		else
		{
			// Grow ANSI string as required
			if (strlen(reinterpret_cast<CHAR*>(processEntryA.szExeFile)) + 1 > dwExeFileLen)
			{
				if (pwszExeFile)
					DNFree(pwszExeFile);

				dwExeFileLen = strlen(reinterpret_cast<CHAR*>(processEntryA.szExeFile)) + 1;
				if ((pwszExeFile = static_cast<WCHAR*>
						(DNMalloc(dwExeFileLen * sizeof(WCHAR)))) == NULL)
				{
					DPFERR("Could not allocate filename conversion buffer");
					hResultCode = DPNERR_OUTOFMEMORY;
					goto CLEANUP_GETPROCESS;
				}
			}

            if( FAILED( STR_jkAnsiToWide( pwszExeFile, processEntryA.szExeFile, dwExeFileLen ) ) )
            {
                DPFERR( "Error converting ANSI filename to Unicode" );
                hResultCode = DPNERR_CONVERSION;
                goto CLEANUP_GETPROCESS;
            }

		}

		// Valid process ?
		if (DPLCompareFilenames(pwszProcess,pwszExeFile))
		{
			// Update lpdwProcessIdList array
			if (prgdwPid != NULL && dwNumProcesses < *pdwNumProcesses)
			{
    			if( bIsUnicodePlatform )
    			{
    				prgdwPid[dwNumProcesses] = processEntryW.th32ProcessID;
    			}
    			else
    			{
    				prgdwPid[dwNumProcesses] = processEntryA.th32ProcessID;    			
    			}
			}
			else
			{
				hResultCode = DPNERR_BUFFERTOOSMALL;
			}

			// Increase valid process count
			dwNumProcesses++;

			if( bIsUnicodePlatform )
			{
    			DPFX(DPFPREP, 7,"%8lx    %4lx  %8lx      %4lx  %8lx  %8lx  %8lx  %s",
    				processEntryW.dwSize,processEntryW.cntUsage,processEntryW.th32ProcessID,
    				processEntryW.cntThreads,processEntryW.th32ParentProcessID,
    				processEntryW.pcPriClassBase,processEntryW.dwFlags,processEntryW.szExeFile);
			}
			else
			{
    			DPFX(DPFPREP, 7,"%8lx    %4lx  %8lx      %4lx  %8lx  %8lx  %8lx  %s",
    				processEntryA.dwSize,processEntryA.cntUsage,processEntryA.th32ProcessID,
    				processEntryA.cntThreads,processEntryA.th32ParentProcessID,
    				processEntryA.pcPriClassBase,processEntryA.dwFlags,processEntryA.szExeFile);			
			}
		}
		// Get next process

    	if (bIsUnicodePlatform)
    	{
        	bReturnCode = (*pfProcess32NextW)(hSnapshot,&processEntryW);
    	}
    	else
    	{
        	bReturnCode = Process32Next(hSnapshot,&processEntryA);	
    	}		
	}

	if( *pdwNumProcesses < dwNumProcesses )
	{
		hResultCode = DPNERR_BUFFERTOOSMALL;
	}
	else
	{
		hResultCode = DPN_OK;
	}
	
	*pdwNumProcesses = dwNumProcesses;

CLEANUP_GETPROCESS:

    if( hSnapshot != NULL )
        CloseHandle( hSnapshot );

    if( hKernelDLL != NULL )
        FreeLibrary( hKernelDLL );

	if (!bIsUnicodePlatform && pwszExeFile)
	{
		DNFree(pwszExeFile);
	}

	return hResultCode;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\lobby\dplproc.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DPLProc.h
 *  Content:    DirectPlay Lobby Process Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   02/21/00	mjn		Created
 *@@END_MSINTERNAL
 *
 ***************************************************************************/


#ifndef	__DPLPROC_H__
#define	__DPLPROC_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

BOOL DPLCompareFilenames(WCHAR *const pwszFilename1,
						 WCHAR *const pwszFilename2);

HRESULT DPLGetProcessList(WCHAR *const pwszProcess,
						  DWORD *const prgdwPid,
						  DWORD *const pdwNumProcesses,
						  const BOOL bIsUnicodePlatform);


#endif	// __DPLPROC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\lobby\dplprot.h ===
/*==========================================================================
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplprot.h
 *  Content:    DirectPlay8 Inter-Memory Packet format
 *
 ***************************************************************************/
#ifndef __DPLPROT_H
#define __DPLPROT_H

#define	DPL_MSGID_INTERNAL_MASK					0xffff0000
#define	DPL_MSGID_INTERNAL						0xb00b0000
#define	DPL_MSGID_INTERNAL_DISCONNECT			(0x0001 | DPL_MSGID_INTERNAL)
#define	DPL_MSGID_INTERNAL_CONNECT_REQ			(0x0002 | DPL_MSGID_INTERNAL)
#define	DPL_MSGID_INTERNAL_CONNECT_ACK			(0x0003 | DPL_MSGID_INTERNAL)
#define	DPL_MSGID_INTERNAL_UPDATE_STATUS		(0x0004 | DPL_MSGID_INTERNAL)
#define DPL_MSGID_INTERNAL_IDLE_TIMEOUT         (0x0005 | DPL_MSGID_INTERNAL)
#define DPL_MSGID_INTERNAL_CONNECTION_SETTINGS  (0x0006 | DPL_MSGID_INTERNAL)

#pragma pack(push,1)

// DPL_INTERNAL_CONNECTION_SETTINGS
//
// This structure is used to pass connection settings on the IPC wire.  It is used
// be several message types.
// 
typedef UNALIGNED struct _DPL_INTERNAL_CONNECTION_SETTINGS 
{
	DWORD						dwFlags;
	DWORD						dwHostAddressOffset;
	DWORD						dwHostAddressLength;  
	DWORD						dwDeviceAddressOffset;
	DWORD						dwDeviceAddressLengthOffset;
	DWORD						dwNumDeviceAddresses;
	DWORD						dwPlayerNameOffset;
	DWORD						dwPlayerNameLength;
	DPN_APPLICATION_DESC_INFO	dpnApplicationDesc;
} DPL_INTERNAL_CONNECTION_SETTINGS, *PDPL_INTERNAL_CONNECTION_SETTINGS;

// DPL_INTERNAL_CONNECTION_SETTINGS_UPDATE_HEADER
//
// Lobby Client <--> Lobbied Application
//
// This structure is the header portion of the connection_settings_update message
typedef UNALIGNED struct _DPL_INTERNAL_CONNECTION_SETTINGS_UPDATE_HEADER
{

	DWORD						dwMsgId;					// = DPL_MSGID_INTERNAL_CONNECTION_SETTINGS
	DWORD						dwConnectionSettingsSize;   // 0 = no settings, 1 = settings
} DPL_INTERNAL_CONNECTION_SETTINGS_UPDATE_HEADER, *PDPL_INTERNAL_CONNECTION_SETTINGS_UPDATE_HEADER;

// DPL_INTERNAL_CONNECTION_SETTINGS_UPDATE
//
// Lobby Client <--> Lobbied Application
//
// This structure is sent to update the connection settings for a specified connection.
typedef UNALIGNED struct _DPL_INTERNAL_CONNECTION_SETTINGS_UPDATE : DPL_INTERNAL_CONNECTION_SETTINGS_UPDATE_HEADER
{
	DPL_INTERNAL_CONNECTION_SETTINGS dplConnectionSettings;
} DPL_INTERNAL_CONNECTION_SETTINGS_UPDATE, *PDPL_INTERNAL_CONNECTION_SETTINGS_UPDATE;

// DPL_INTERNAL_MESSAGE_CONNECT_ACK
//
// Lobby Client <-- Lobbied Application
// 
// This message is sent to acknowledge a connection request.    
typedef UNALIGNED struct _DPL_INTERNAL_MESSAGE_CONNECT_ACK {
	DWORD						dwMsgId;					// = DPL_MSGID_INTERNAL_CONNECT_ACK
	DPNHANDLE 					hSender;
} DPL_INTERNAL_MESSAGE_CONNECT_ACK, *PDPL_INTERNAL_MESSAGE_CONNECT_ACK;

// DPL_INTERNAL_MESSAGE_CONNECT_REQ_HEADER
//
// Lobby Client --> Lobbied Application
// 
// This is the header for the connect_req message.
typedef UNALIGNED struct _DPL_INTERNAL_MESSAGE_CONNECT_REQ_HEADER
{
	DWORD						dwMsgId;					// = DPL_MSGID_INTERNAL_CONNECT_REQ
	DPNHANDLE					hSender; 
	DWORD						dwSenderPID;
	DWORD						dwLobbyConnectDataOffset;
	DWORD						dwLobbyConnectDataSize;
	DWORD						dwConnectionSettingsSize;
} DPL_INTERNAL_MESSAGE_CONNECT_REQ_HEADER, *PDPL_INTERNAL_MESSAGE_CONNECT_REQ_HEADER;

// DPL_INTERNAL_MESSAGE_CONNECT_REQ
//
// Lobby Client --> Lobbied Application
// 
// This message is sent to request a connection be established.
typedef UNALIGNED struct _DPL_INTERNAL_MESSAGE_CONNECT_REQ : DPL_INTERNAL_MESSAGE_CONNECT_REQ_HEADER
{
	DPL_INTERNAL_CONNECTION_SETTINGS dplConnectionSettings;
} DPL_INTERNAL_MESSAGE_CONNECT_REQ, *PDPL_INTERNAL_MESSAGE_CONNECT_REQ;

// DPL_INTERNAL_MESSAGE_DISCONNECT
//
// Lobby Client <--> Lobbied Application
// 
// This message is sent to issue a disconnect.
typedef UNALIGNED struct _DPL_INTERNAL_MESSAGE_DISCONNECT 
{
	DWORD						dwMsgId;					// = DPL_MSGID_INTERNAL_DISCONNECT
	DWORD						dwPID;
} DPL_INTERNAL_MESSAGE_DISCONNECT, *PDPL_INTERNAL_MESSAGE_DISCONNECT;

// DPL_INTERNAL_MESSAGE_DISCONNECT
//
// Lobby Client <-- Lobbied Application
// 
// This message is sent to update the client of the application's status.  
typedef UNALIGNED struct _DPL_INTERNAL_MESSAGE_UPDATE_STATUS {
	DWORD						dwMsgId;					// = DPL_MSGID_INTERNAL_DISCONNECT
	DWORD						dwStatus;
} DPL_INTERNAL_MESSAGE_UPDATE_STATUS, *PDPL_INTERNAL_MESSAGE_UPDATE_STATUS;

#pragma pack(pop)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\lobby\dplreg.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DPLReg.h
 *  Content:    DirectPlay Lobby Registry Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   02/21/00	mjn		Created
 *   05/03/00	rmt		UnRegister was not implemented!  Implementing! 
 *@@END_MSINTERNAL
 *
 ***************************************************************************/


#ifndef	__DPLREG_H__
#define	__DPLREG_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

#define DPL_REG_LOCAL_APPL_ROOT				L"Software\\Microsoft\\DirectPlay8"
#define DPL_REG_LOCAL_APPL_SUB				L"\\Applications"
#define	DPL_REG_LOCAL_APPL_SUBKEY			DPL_REG_LOCAL_APPL_ROOT DPL_REG_LOCAL_APPL_SUB
#define	DPL_REG_KEYNAME_APPLICATIONNAME		L"ApplicationName"
#define	DPL_REG_KEYNAME_COMMANDLINE			L"CommandLine"
#define	DPL_REG_KEYNAME_CURRENTDIRECTORY	L"CurrentDirectory"
#define	DPL_REG_KEYNAME_DESCRIPTION			L"Description"
#define	DPL_REG_KEYNAME_EXECUTABLEFILENAME	L"ExecutableFilename"
#define	DPL_REG_KEYNAME_EXECUTABLEPATH		L"ExecutablePath"
#define	DPL_REG_KEYNAME_GUID				L"GUID"
#define	DPL_REG_KEYNAME_LAUNCHERFILENAME	L"LauncherFilename"
#define	DPL_REG_KEYNAME_LAUNCHERPATH		L"LauncherPath"

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

HRESULT DPLWriteProgramDesc(DPL_PROGRAM_DESC *const pdplProgramDesc);

HRESULT DPLDeleteProgramDesc( const GUID * const pGuidApplication );

HRESULT DPLGetProgramDesc(GUID *const pGuidApplication,
						  BYTE *const pBuffer,
						  DWORD *const pdwBufferSize);


#endif	// __DPLREG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\lobby\dplreg.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DNLReg.cpp
 *  Content:    DirectPlay Lobby Registry Functions
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   02/21/00	mjn		Created
 *   04/25/00   rmt     Bug #s 33138, 33145, 33150  
 *   05/03/00	rmt		UnRegister was not implemented!  Implementing!
 *   08/05/00   RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *   06/16/2001	rodtoll	WINBUG #416983 -  RC1: World has full control to HKLM\Software\Microsoft\DirectPlay\Applications on Personal
 *						Implementing mirror of keys into HKCU.  Algorithm is now:
 *						- Read of entries tries HKCU first, then HKLM
 *						- Enum of entires is combination of HKCU and HKLM entries with duplicates removed.  HKCU takes priority.
 *						- Write of entries is HKLM and HKCU.  (HKLM may fail, but is ignored). 
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dnlobbyi.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************

#undef DPF_MODNAME 
#define DPF_MODNAME "DPLDeleteProgramDesc"
HRESULT DPLDeleteProgramDesc( const GUID * const pGuidApplication )
{
    HRESULT hResultCode = DPN_OK;
	CRegistry	RegistryEntry;
	CRegistry   SubEntry;
	DWORD       dwLastError;
	HKEY		hkCurrentHive;
	BOOL		fFound = FALSE;
	BOOL		fRemoved = FALSE;
	
	DPFX(DPFPREP, 3, "Removing program desc" );

	for( DWORD dwIndex = 0; dwIndex < 2; dwIndex++ )
	{
		if( dwIndex == 0 )
		{
			hkCurrentHive = HKEY_CURRENT_USER;
		}
		else
		{
			hkCurrentHive = HKEY_LOCAL_MACHINE;
		}

		if( !RegistryEntry.Open( hkCurrentHive,DPL_REG_LOCAL_APPL_SUBKEY,FALSE,FALSE,TRUE,DPN_KEY_ALL_ACCESS )  )
		{
			DPFX(DPFPREP, 1, "Failed to open key for remove in pass %i", dwIndex );
			continue;
		}

		// This should be down below the next if block, but 8.0 shipped with a bug
		// which resulted in this function returning DPNERR_NOTALLOWED in cases where
		// the next if block failed.  Need to remain compatible
		fFound = TRUE;

		if( !SubEntry.Open( RegistryEntry, pGuidApplication, FALSE, FALSE,TRUE,DPN_KEY_ALL_ACCESS ) )
		{
			DPFX(DPFPREP, 1, "Failed to open subkey for remove in pass %i", dwIndex );			
			continue;
		}

		SubEntry.Close();

		if( !RegistryEntry.DeleteSubKey( pGuidApplication ) )
		{
			DPFX(DPFPREP, 1, "Failed to delete subkey for remove in pass %i", dwIndex );						
			continue;
		}

		fRemoved = TRUE;

		RegistryEntry.Close();
	}
	
	if( !fFound )
	{
		DPFX(DPFPREP,  0, "Could not find entry" );
		hResultCode = DPNERR_DOESNOTEXIST;
	}
	else if( !fRemoved )
	{
		dwLastError = GetLastError();
		DPFX(DPFPREP,  0, "Error deleting registry sub-key lastError [0x%lx]", dwLastError );
		hResultCode = DPNERR_NOTALLOWED;
	}

	DPFX(DPFPREP, 3, "Removing program desc [0x%x]", hResultCode );	

    return hResultCode;
    
}

//**********************************************************************
// ------------------------------
//	DPLWriteProgramDesc
//
//	Entry:		Nothing
//
//	Exit:		DPN_OK
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "DPLWriteProgramDesc"

HRESULT DPLWriteProgramDesc(DPL_PROGRAM_DESC *const pdplProgramDesc)
{
	HRESULT		hResultCode;
	CRegistry	RegistryEntry;
	CRegistry	SubEntry;
	WCHAR		*pwsz;
	WCHAR		pwszDefault[] = L"\0";
	HKEY		hkCurrentHive = NULL;
	BOOL		fWritten = FALSE;

	DPFX(DPFPREP, 3,"Parameters: pdplProgramDesc [0x%p]",pdplProgramDesc);

	for( DWORD dwIndex = 0; dwIndex < 2; dwIndex++ )
	{
		if( dwIndex == 0 )
		{
			hkCurrentHive = HKEY_LOCAL_MACHINE;
		}
		else
		{
			hkCurrentHive = HKEY_CURRENT_USER;
		}

		if (!RegistryEntry.Open(hkCurrentHive,DPL_REG_LOCAL_APPL_SUBKEY,FALSE,TRUE,TRUE,DPN_KEY_ALL_ACCESS))
		{
			DPFX( DPFPREP, 1, "Entry not found in user hive on pass %i", dwIndex );
			continue;
		}

		// Get Application name and GUID from each sub key
		if (!SubEntry.Open(RegistryEntry,&pdplProgramDesc->guidApplication,FALSE,TRUE,TRUE,DPN_KEY_ALL_ACCESS))
		{
			DPFX( DPFPREP, 1, "Entry not found in user hive on pass %i", dwIndex );			
			continue;
		}

		if (!SubEntry.WriteString(DPL_REG_KEYNAME_APPLICATIONNAME,pdplProgramDesc->pwszApplicationName))
		{
			DPFX( DPFPREP, 1, "Could not write ApplicationName on pass %i", dwIndex);
			goto LOOP_END;
		}

		if (pdplProgramDesc->pwszCommandLine != NULL)
		{
			pwsz = pdplProgramDesc->pwszCommandLine;
		}
		else
		{
			pwsz = pwszDefault;
		}
		if (!SubEntry.WriteString(DPL_REG_KEYNAME_COMMANDLINE,pwsz))
		{
			DPFX( DPFPREP, 1, "Could not write CommandLine on pass %i", dwIndex);
			goto LOOP_END;
		}

		if (pdplProgramDesc->pwszCurrentDirectory != NULL)
		{
			pwsz = pdplProgramDesc->pwszCurrentDirectory;
		}
		else
		{
			pwsz = pwszDefault;
		}
		if (!SubEntry.WriteString(DPL_REG_KEYNAME_CURRENTDIRECTORY,pwsz))
		{
			DPFX( DPFPREP, 1, "Could not write CurrentDirectory on pass %i", dwIndex);
			goto LOOP_END;
		}

		if (pdplProgramDesc->pwszDescription != NULL)
		{
			pwsz = pdplProgramDesc->pwszDescription;
		}
		else
		{
			pwsz = pwszDefault;
		}
		if (!SubEntry.WriteString(DPL_REG_KEYNAME_DESCRIPTION,pwsz))
		{
			DPFX( DPFPREP, 1, "Could not write Description on pass %i", dwIndex );
			goto LOOP_END;
		}

		if (pdplProgramDesc->pwszExecutableFilename != NULL)
		{
			pwsz = pdplProgramDesc->pwszExecutableFilename;
		}
		else
		{
			pwsz = pwszDefault;
		}
		if (!SubEntry.WriteString(DPL_REG_KEYNAME_EXECUTABLEFILENAME,pwsz))
		{
			DPFX( DPFPREP, 1, "Could not write ExecutableFilename on pass %i", dwIndex );
			goto LOOP_END;
		}

		if (pdplProgramDesc->pwszExecutablePath != NULL)
		{
			pwsz = pdplProgramDesc->pwszExecutablePath;
		}
		else
		{
			pwsz = pwszDefault;
		}
		
		if (!SubEntry.WriteString(DPL_REG_KEYNAME_EXECUTABLEPATH,pwsz))
		{
			DPFX( DPFPREP, 1, "Could not write ExecutablePath on pass %i", dwIndex);
			goto LOOP_END;
		}

		if (pdplProgramDesc->pwszLauncherFilename != NULL)
		{
			pwsz = pdplProgramDesc->pwszLauncherFilename;
		}
		else
		{
			pwsz = pwszDefault;
		}
		if (!SubEntry.WriteString(DPL_REG_KEYNAME_LAUNCHERFILENAME,pwsz))
		{
			DPFX( DPFPREP, 1, "Could not write LauncherFilename on pass %i", dwIndex);
			goto LOOP_END;
		}

		if (pdplProgramDesc->pwszLauncherPath != NULL)
		{
			pwsz = pdplProgramDesc->pwszLauncherPath;
		}
		else
		{
			pwsz = pwszDefault;
		}
		if (!SubEntry.WriteString(DPL_REG_KEYNAME_LAUNCHERPATH,pwsz))
		{
			DPFX( DPFPREP, 1, "Could not write LauncherPath on pass %i", dwIndex);
			goto LOOP_END;
		}

		if (!SubEntry.WriteGUID(DPL_REG_KEYNAME_GUID,pdplProgramDesc->guidApplication))
		{
			DPFX( DPFPREP, 1, "Could not write GUID on pass %i", dwIndex);
			goto LOOP_END;
		}

		fWritten = TRUE;

LOOP_END:

		SubEntry.Close();
		RegistryEntry.Close();
	}

	if( !fWritten )
	{
		DPFERR("Entry could not be written");
		hResultCode = DPNERR_GENERIC;
	}
	else
	{
		hResultCode = DPN_OK;
	}

	DPFX(DPFPREP, 3,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//**********************************************************************
// ------------------------------
//	DPLGetProgramDesc
//
//	Entry:		Nothing
//
//	Exit:		DPN_OK
//				DPNERR_BUFFERTOOSMALL
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "DPLGetProgramDesc"

HRESULT DPLGetProgramDesc(GUID *const pGuidApplication,
						  BYTE *const pBuffer,
						  DWORD *const pdwBufferSize)
{
	HRESULT			hResultCode;
	CRegistry		RegistryEntry;
	CRegistry		SubEntry;
	CPackedBuffer	PackedBuffer;
	DWORD			dwEntrySize;
	DWORD           dwRegValueLengths;
    DPL_PROGRAM_DESC	*pdnProgramDesc;
    DWORD           dwValueSize;
	HKEY			hkCurrentHive = NULL;
	BOOL			fFound = FALSE;

	DPFX(DPFPREP, 3,"Parameters: pGuidApplication [0x%p], pBuffer [0x%p], pdwBufferSize [0x%p]",
			pGuidApplication,pBuffer,pdwBufferSize);
	
	for( DWORD dwIndex = 0; dwIndex < 2; dwIndex++ )
	{
		if( dwIndex == 0 )
		{
			hkCurrentHive = HKEY_CURRENT_USER;
		}
		else
		{
			hkCurrentHive = HKEY_LOCAL_MACHINE;
		}

		if (!RegistryEntry.Open(hkCurrentHive,DPL_REG_LOCAL_APPL_SUBKEY,TRUE,FALSE,TRUE,DPL_REGISTRY_READ_ACCESS))
		{
			DPFX( DPFPREP, 1, "Entry not found in user hive on pass %i", dwIndex );
			continue;
		}

		// Get Application name and GUID from each sub key
		if (!SubEntry.Open(RegistryEntry,pGuidApplication,TRUE,FALSE,TRUE,DPL_REGISTRY_READ_ACCESS))
		{
			DPFX( DPFPREP, 1, "Entry not found in user hive on pass %i", dwIndex );			
			continue;
		}

		fFound = TRUE;
		break;

	}

	if( !fFound )
	{
		DPFERR("Entry not found");
		hResultCode = DPNERR_DOESNOTEXIST;
		goto EXIT_DPLGetProgramDesc;
	}

	// Calculate total entry size (structure + data)
	dwEntrySize = sizeof(DPL_PROGRAM_DESC);
	dwRegValueLengths = 0;
	if (SubEntry.GetValueLength(DPL_REG_KEYNAME_APPLICATIONNAME,&dwValueSize))
	{
		dwRegValueLengths += dwValueSize;
	}
	if (SubEntry.GetValueLength(DPL_REG_KEYNAME_COMMANDLINE,&dwValueSize))
	{
		dwRegValueLengths += dwValueSize;
	}
	if (SubEntry.GetValueLength(DPL_REG_KEYNAME_CURRENTDIRECTORY,&dwValueSize))
	{
		dwRegValueLengths += dwValueSize;
	}
	if (SubEntry.GetValueLength(DPL_REG_KEYNAME_DESCRIPTION,&dwValueSize))
	{
		dwRegValueLengths += dwValueSize;
	}
	if (SubEntry.GetValueLength(DPL_REG_KEYNAME_EXECUTABLEFILENAME,&dwValueSize))
	{
		dwRegValueLengths += dwValueSize;
	}
	if (SubEntry.GetValueLength(DPL_REG_KEYNAME_EXECUTABLEPATH,&dwValueSize))
	{
		dwRegValueLengths += dwValueSize;
	}
	if (SubEntry.GetValueLength(DPL_REG_KEYNAME_LAUNCHERFILENAME,&dwValueSize))
	{
		dwRegValueLengths += dwValueSize;
	}
	if (SubEntry.GetValueLength(DPL_REG_KEYNAME_LAUNCHERPATH,&dwValueSize))
	{
		dwRegValueLengths += dwValueSize;
	}
			
	dwEntrySize += dwRegValueLengths * sizeof( WCHAR );
	DPFX(DPFPREP, 7,"dwEntrySize [%ld]",dwEntrySize);

	// If supplied buffer sufficient, use it
	if (dwEntrySize <= *pdwBufferSize)
	{
		PackedBuffer.Initialize(pBuffer,*pdwBufferSize);

		pdnProgramDesc = static_cast<DPL_PROGRAM_DESC*>(PackedBuffer.GetHeadAddress());
		PackedBuffer.AddToFront(NULL,sizeof(DPL_PROGRAM_DESC));

		dwValueSize = PackedBuffer.GetSpaceRemaining();
		pdnProgramDesc->pwszApplicationName = static_cast<WCHAR*>(PackedBuffer.GetHeadAddress());
		if (!SubEntry.ReadString(DPL_REG_KEYNAME_APPLICATIONNAME,
				pdnProgramDesc->pwszApplicationName,&dwValueSize))
		{
		    DPFERR( "Unable to get application name for entry" );		    
			hResultCode = DPNERR_GENERIC;
            goto EXIT_DPLGetProgramDesc;
		}
		if (dwValueSize > 1)
		{
			PackedBuffer.AddToFront(NULL,dwValueSize * sizeof(WCHAR));
		}
		else
		{
			pdnProgramDesc->pwszApplicationName = NULL;
		}
		
		dwValueSize = PackedBuffer.GetSpaceRemaining();
		pdnProgramDesc->pwszCommandLine = static_cast<WCHAR*>(PackedBuffer.GetHeadAddress());
		if (!SubEntry.ReadString(DPL_REG_KEYNAME_COMMANDLINE,
				pdnProgramDesc->pwszCommandLine,&dwValueSize))
		{
		    DPFERR( "Unable to get commandline for entry" );		    
			hResultCode = DPNERR_GENERIC;
            goto EXIT_DPLGetProgramDesc;
		}
		if (dwValueSize > 1)
		{
			PackedBuffer.AddToFront(NULL,dwValueSize * sizeof(WCHAR));
		}
		else
		{
			pdnProgramDesc->pwszCommandLine = NULL;
		}

		dwValueSize = PackedBuffer.GetSpaceRemaining();
		pdnProgramDesc->pwszCurrentDirectory = static_cast<WCHAR*>(PackedBuffer.GetHeadAddress());
		if (!SubEntry.ReadString(DPL_REG_KEYNAME_CURRENTDIRECTORY,
				pdnProgramDesc->pwszCurrentDirectory,&dwValueSize))
		{
		    DPFERR( "Unable to get current directory filename for entry" );		    
			hResultCode = DPNERR_GENERIC;
            goto EXIT_DPLGetProgramDesc;
		}
		if (dwValueSize > 1)
		{
			PackedBuffer.AddToFront(NULL,dwValueSize * sizeof(WCHAR));
		}
		else
		{
			pdnProgramDesc->pwszCurrentDirectory = NULL;
		}

		dwValueSize = PackedBuffer.GetSpaceRemaining();
		pdnProgramDesc->pwszDescription = static_cast<WCHAR*>(PackedBuffer.GetHeadAddress());
		if (!SubEntry.ReadString(DPL_REG_KEYNAME_DESCRIPTION,
				pdnProgramDesc->pwszDescription,&dwValueSize))
		{
		    DPFERR( "Unable to get description for entry" );		    
			hResultCode = DPNERR_GENERIC;
            goto EXIT_DPLGetProgramDesc;
		}
		if (dwValueSize > 1)
		{
			PackedBuffer.AddToFront(NULL,dwValueSize * sizeof(WCHAR));
		}
		else
		{
			pdnProgramDesc->pwszDescription = NULL;
		}

		dwValueSize = PackedBuffer.GetSpaceRemaining();
		pdnProgramDesc->pwszExecutableFilename = static_cast<WCHAR*>(PackedBuffer.GetHeadAddress());
		if (!SubEntry.ReadString(DPL_REG_KEYNAME_EXECUTABLEFILENAME,
				pdnProgramDesc->pwszExecutableFilename,&dwValueSize))
		{
		    DPFERR( "Unable to get executable filename for entry" );		    
			hResultCode = DPNERR_GENERIC;
            goto EXIT_DPLGetProgramDesc;
		}
		if (dwValueSize > 1)
		{
			PackedBuffer.AddToFront(NULL,dwValueSize * sizeof(WCHAR));
		}
		else
		{
			pdnProgramDesc->pwszExecutableFilename = NULL;
		}

		dwValueSize = PackedBuffer.GetSpaceRemaining();
		pdnProgramDesc->pwszExecutablePath = static_cast<WCHAR*>(PackedBuffer.GetHeadAddress());
		if (!SubEntry.ReadString(DPL_REG_KEYNAME_EXECUTABLEPATH,
				pdnProgramDesc->pwszExecutablePath,&dwValueSize))
		{
		    DPFERR( "Unable to get executable path for entry" );		    
			hResultCode = DPNERR_GENERIC;
            goto EXIT_DPLGetProgramDesc;		    
		}
		if (dwValueSize > 1)
		{
			PackedBuffer.AddToFront(NULL,dwValueSize * sizeof(WCHAR));
		}
		else
		{
			pdnProgramDesc->pwszExecutablePath = NULL;
		}

		dwValueSize = PackedBuffer.GetSpaceRemaining();
		pdnProgramDesc->pwszLauncherFilename = static_cast<WCHAR*>(PackedBuffer.GetHeadAddress());
		if (!SubEntry.ReadString(DPL_REG_KEYNAME_LAUNCHERFILENAME,
				pdnProgramDesc->pwszLauncherFilename,&dwValueSize))
		{
		    DPFERR( "Unable to get launcher filename for entry" );		    
			hResultCode = DPNERR_GENERIC;
            goto EXIT_DPLGetProgramDesc;
		}
		if (dwValueSize > 1)
		{
			PackedBuffer.AddToFront(NULL,dwValueSize * sizeof(WCHAR));
		}
		else
		{
			pdnProgramDesc->pwszLauncherFilename = NULL;
		}

		dwValueSize = PackedBuffer.GetSpaceRemaining();
		pdnProgramDesc->pwszLauncherPath = static_cast<WCHAR*>(PackedBuffer.GetHeadAddress());
		if (!SubEntry.ReadString(DPL_REG_KEYNAME_LAUNCHERPATH,
				pdnProgramDesc->pwszLauncherPath,&dwValueSize))
		{
		    DPFERR( "Unable to get launcher path for entry" );
			hResultCode = DPNERR_GENERIC;
            goto EXIT_DPLGetProgramDesc;
		}
		if (dwValueSize > 1)
		{
			PackedBuffer.AddToFront(NULL,dwValueSize * sizeof(WCHAR));
		}
		else
		{
			pdnProgramDesc->pwszLauncherPath = NULL;
		}

		pdnProgramDesc->dwSize = sizeof(DPL_PROGRAM_DESC);
		pdnProgramDesc->dwFlags = 0;
		pdnProgramDesc->guidApplication = *pGuidApplication;

		hResultCode = DPN_OK;
	}
	else
	{
	    hResultCode = DPNERR_BUFFERTOOSMALL;
	}

    SubEntry.Close();
	RegistryEntry.Close();

	if (hResultCode == DPN_OK || hResultCode == DPNERR_BUFFERTOOSMALL)
	{
		*pdwBufferSize = dwEntrySize;
	}

EXIT_DPLGetProgramDesc:

	DPFX(DPFPREP, 3,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}



// ------------------------------------------------------------------------------

#if 0

//	HRESULT	DnAddRegKey
//		HKEY	hBase			Open key from which to start
//		LPSTR	lpszLocation	Key path in Subkey1/Subkey2... format (ANSI string)
//		LPSTR	lpszName		Name of key (ANSI string)
//		LPWSTR	lpwszValue		Value of key (Unicode string)
//
//	Returns
//		DPN_OK					If the key was added successfully
//		DPNERR_GENERIC			If there was a problem opening/creating/adding
//		DPNERR_OUTOFMEMORY		If it could not allocate memory
//
//	Notes
//		The key path and name are in ANSI CHAR format, and the key value to add is in
//		Unicode WCHAR format.  This function recursively calls itself to descend the
//		registry tree staring from the open key, hBase, creating keys as required.
//
//		Key names are limited to ANSI, whereas key values are in Unicode

#undef DPF_MODNAME
#define DPF_MODNAME "DnAddRegKey"

HRESULT DnAddRegKey(HKEY hBase, LPSTR lpszLocation, LPSTR lpszName, LPWSTR lpwszValue)
{
	LPSTR	lpc;
	LPSTR	lpszCopy = NULL;
	LPSTR	lpszAnsiValue = NULL;
	LPWSTR	lpwszUnicodeName = NULL;
	DWORD	dwLen,dwDisposition;
	int		iLen;
	HKEY	h;
	HRESULT	hResultCode = DPN_OK;
	LONG	tmp;

	DPFX(DPFPREP, 3,"Parameters: hBase [%p], lpszLocation [%p], lpszName [%p], lpwszValue [%p]",
		hBase,lpszLocation,lpszName,lpwszValue);

	if (strlen(lpszLocation) == 0)
	{
		DPFX(DPFPREP, 7,"RegSetValue");
		// Add key here
		iLen = wcslen(lpwszValue) + 1;
		if (DN_RUNNING_NT)
		{
			// For WindowsNT, just place the Unicode key value into the key
			DPFX(DPFPREP, 5,"WinNT - Use Unicode");
			// Convert key name from ANSI to Unicode
			if ((lpwszUnicodeName = (LPWSTR)GLOBALALLOC((strlen(lpszName)+1)*sizeof(WCHAR))) == NULL)
			{
				hResultCode = DPNERR_OUTOFMEMORY;
				goto EXIT_DnAddRegKey;
			}
			AnsiToWide(lpwszUnicodeName,lpszName,strlen(lpszName)+1);
			// Set key value
			if (RegSetValueExW(hBase,lpwszUnicodeName,0,REG_EXPAND_SZ,(CONST BYTE *)lpwszValue,
				iLen*sizeof(WCHAR)) != ERROR_SUCCESS)
			{
				hResultCode = DPNERR_GENERIC;
				goto EXIT_DnAddRegKey;
			}
		}
		else
		{
			// For Windows9x, convert Unicode key value to ANSI before placing in key
			DPFX(DPFPREP, 5,"Win9x - Use ANSI");
			// Convert key value from Unicode to ANSI first
			if ((lpszAnsiValue = (LPSTR)GLOBALALLOC(iLen)) == NULL)
			{
				hResultCode = DPNERR_OUTOFMEMORY;
				goto EXIT_DnAddRegKey;
			}
			WideToAnsi(lpszAnsiValue,lpwszValue,iLen);
			// Set key value
			if (RegSetValueExA(hBase,lpszName,0,REG_EXPAND_SZ,(CONST BYTE *)lpszAnsiValue,
				iLen) != ERROR_SUCCESS)
			{
				hResultCode = DPNERR_GENERIC;
				goto EXIT_DnAddRegKey;
			}
		}
	}
	else
	{
		for(lpc = lpszLocation ; *lpc != '/' && *lpc != '\0' ; lpc++)
			;
		dwLen = lpc-lpszLocation+1;
		if ((lpszCopy = (LPSTR)GLOBALALLOC(dwLen)) == NULL)
		{
			hResultCode = DPNERR_OUTOFMEMORY;
			goto EXIT_DnAddRegKey;
		}
		memcpy((void *)lpszCopy,(void *)lpszLocation,dwLen);
		*((LPSTR)(lpszCopy+dwLen-1)) = '\0';
		DPFX(DPFPREP, 5,"Calling RegCreateKeyExA() to create %s",lpszCopy);
		if ((tmp = RegCreateKeyExA(hBase,lpszCopy,0,"None",REG_OPTION_NON_VOLATILE,
			KEY_ALL_ACCESS,NULL,&h,&dwDisposition)) != ERROR_SUCCESS)
		{
			hResultCode = DPNERR_GENERIC;
			goto EXIT_DnAddRegKey;
		}
		if (*lpc == '/')
			lpc++;
		hResultCode = DnAddRegKey(h,lpc,lpszName,lpwszValue);
		RegCloseKey(h);
	}

EXIT_DnAddRegKey:	// Clean up

	DPFX(DPFPREP, 3, "hResultCode = %ld",hResultCode);

	if (lpszCopy != NULL)
		GlobalFree(lpszCopy);
	if (lpszAnsiValue != NULL)
		GlobalFree(lpszAnsiValue);
	if (lpwszUnicodeName != NULL)
		GlobalFree(lpwszUnicodeName);

	return(hResultCode);
}


//	HRESULT	DnOpenRegKey
//		HKEY	hBase			Open key from which to start
//		LPSTR	lpszLocation	Key path in Subkey1/Subkey2... format (ANSI string)
//		HKEY *	lpHkey			Pointer to key handle
//
//	Returns
//		DPN_OK					If the key was opened successfully
//		DPNERR_DOESNOTEXIST		If a key could not be opened
//		DPNERR_OUTOFMEMORY		If it could not allocate memory
//		DPNERR_INVALIDPARAM		If there was an invalid key pay (end in / or is NULL)
//
//	Notes
//		The key path is in ANSI CHAR format.

#undef DPF_MODNAME
#define DPF_MODNAME "DnOpenRegKey"

HRESULT DnOpenRegKey(HKEY hBase, LPSTR lpszLocation, HKEY *lpHkey)
{
	LPSTR		lpc;
	LPSTR		lpszCopy = NULL;
	DWORD		dwLen;
	HKEY		h;
	HRESULT		hResultCode = DPN_OK;

	DPFX(DPFPREP, 3,"Parameters: hBase [%p], lpszLocation [%p], lpHkey [%p]",
		hBase,lpszLocation,lpHkey);

	if (strlen(lpszLocation) == 0)
	{
		hResultCode = DPNERR_INVALIDPARAM;
		goto EXIT_DnOpenRegKey;
	}
	else
	{
		for (lpc = lpszLocation ; *lpc != '/' && *lpc != '\0' ; lpc++)
			;
		dwLen = lpc-lpszLocation;
		if ((lpszCopy = (LPSTR)GLOBALALLOC(dwLen+1)) == NULL)
		{
			hResultCode = DPNERR_OUTOFMEMORY;
			goto EXIT_DnOpenRegKey;
		}
		memcpy(lpszCopy,lpszLocation,dwLen);
		*(lpszCopy+dwLen) = '\0';
		if (RegOpenKeyExA(hBase,lpszCopy,0,KEY_READ,&h) != ERROR_SUCCESS)
		{
			hResultCode = DPNERR_DOESNOTEXIST;
			goto EXIT_DnOpenRegKey;
		}
		if (*lpc == '/')	// More keys - open next sub key
		{
			lpc++;
			hResultCode = DnOpenRegKey(h,lpc,lpHkey);
			RegCloseKey(h);
		}
		else	// Last key - set handle
		{
			*lpHkey = h;
			goto EXIT_DnOpenRegKey;
		}
	}
EXIT_DnOpenRegKey:

	if (lpszCopy != NULL)
		GlobalFree(lpszCopy);

	DPFX(DPFPREP, 3,"Returning: hResultCode = [%lx]",hResultCode);
	return(hResultCode);
}


//	HRESULT	DnGetRegKeyValue
//		HKEY	hKey			Open key from which to start
//		LPSTR	lpszKeyName		Key name (ANSI string) to retrieve
//		LPWSTR *lplpwszKeyValue	Pointer to the address pointer to a Unicode string
//
//	Returns
//		DPN_OK					If successfull
//		DPNERR_DOESNOTEXIST		If there was a problem opening/reading the key
//		DPNERR_OUTOFMEMORY		If it could not allocate memory
//
//	Notes
//		The key name is an Ansi string.  The function gets the length of the key value,
//		allocates a buffer for it, and then reads the key into the buffer.

#undef DPF_MODNAME
#define DPF_MODNAME "DnGetRegKeyValue"

HRESULT DnGetRegKeyValue(HKEY hKey, LPSTR lpszKeyName, LPWSTR *lplpwszKeyValue)
{
	HRESULT hResultCode = DPN_OK;
	LPSTR	lpszValue = NULL;
	LPWSTR	lpwszValue = NULL;
	DWORD	dwValueLen;
	LONG	lReturnValue;

	DPFX(DPFPREP, 3,"Parameters: hKey [%p], lpszKeyName[%p], lplpwszKeyValue [%p]",
		hKey,lpszKeyName,lplpwszKeyValue);

	dwValueLen = 0;
	lReturnValue = RegQueryValueExA(hKey,lpszKeyName,NULL,NULL,NULL,&dwValueLen);
	if (lReturnValue == ERROR_SUCCESS)
	{
		if ((lpszValue = (LPSTR)GLOBALALLOC(dwValueLen)) == NULL)
		{
			hResultCode = DPNERR_OUTOFMEMORY;
			goto EXIT_DnGetRegKeyValue;
		}
		if (RegQueryValueExA(hKey,lpszKeyName,NULL,NULL,(LPBYTE)lpszValue,&dwValueLen) != ERROR_SUCCESS)
		{
			hResultCode = DPNERR_DOESNOTEXIST;
			goto EXIT_DnGetRegKeyValue;
		}
	}
	else
	{
		hResultCode = DPNERR_DOESNOTEXIST;
		goto EXIT_DnGetRegKeyValue;
	}
	dwValueLen++;	// \0 char
	if ((lpwszValue = (LPWSTR)GLOBALALLOC(dwValueLen*sizeof(WCHAR))) == NULL)
	{
		hResultCode = DPNERR_OUTOFMEMORY;
		goto EXIT_DnGetRegKeyValue;
	}
	AnsiToWide(lpwszValue,lpszValue,dwValueLen);
	*lplpwszKeyValue = lpwszValue;

EXIT_DnGetRegKeyValue:

	if (lpszValue != NULL)
		GlobalFree(lpszValue);

	DPFX(DPFPREP, 3,"Returning: hResultCode = [%lx]",hResultCode);
	return(hResultCode);
}


//	void	DnFreeProgramDesc
//		LPDNPROGRAMDESC	lpdnProgramDesc		Pointer to a program description structure
//
//	Returns
//		nothing
//
//	Notes
//		This function should be called to free program descriptions which were created
//		using DnRegRegProgramDesc() or DnGetProgramDesc().

#undef DPF_MODNAME
#define DPF_MODNAME "DnFreeProgramDesc"

void DnFreeProgramDesc(LPDNPROGRAMDESC lpdnProgramDesc)
{
	DPFX(DPFPREP, 3,"Parameters: lpdnProgramDesc [%p]",lpdnProgramDesc);

	if (lpdnProgramDesc->lpwszApplicationName != NULL)
		GlobalFree(lpdnProgramDesc->lpwszApplicationName);
	if (lpdnProgramDesc->lpwszApplicationLauncher != NULL)
		GlobalFree(lpdnProgramDesc->lpwszApplicationLauncher);
	if (lpdnProgramDesc->lpwszCommandLine != NULL)
		GlobalFree(lpdnProgramDesc->lpwszCommandLine);
	if (lpdnProgramDesc->lpwszCurrentDirectory != NULL)
		GlobalFree(lpdnProgramDesc->lpwszCurrentDirectory);
	if (lpdnProgramDesc->lpwszDescription != NULL)
		GlobalFree(lpdnProgramDesc->lpwszDescription);
	if (lpdnProgramDesc->lpwszFilename != NULL)
		GlobalFree(lpdnProgramDesc->lpwszFilename);
	if (lpdnProgramDesc->lpwszPath != NULL)
		GlobalFree(lpdnProgramDesc->lpwszPath);
}

//	HRESULT	DnReadRegProgramDesc
//		HKEY			hKey				Handle to open key containing program description
//		LPDNPROGRAMDESC	lpdnProgramDesc		Pointer to a program description structure
//
//	Returns
//		DPN_OK					If successfull
//		DPNERR_DOESNOTEXIST		If there was a problem opening/reading the entry
//		DPNERR_OUTOFMEMORY		If it could not allocate memory
//
//	Notes
//		This function reads the program description entry from the registry at hKey into the
//		supplied structure.  The function will call DnGetRegKeyValue, which allocates
//		space for strings as needed.  Use DnFreeProgramDesc() to free the program
//		description structure.

#undef DPF_MODNAME
#define DPF_MODNAME "DnReadRegProgramDesc"

HRESULT DnReadRegProgramDesc(HKEY hKey, LPDNPROGRAMDESC lpdnProgramDesc)
{
	HRESULT	hResultCode = DPN_OK;

	DPFX(DPFPREP, 3,"Parameters: hKey [%p], lpdnProgramDesc [%p]",hKey,lpdnProgramDesc);

	if ((hResultCode = DnGetRegKeyValue(hKey,DN_REG_KEYNAME_APPLICATIONLAUNCHER,
			&(lpdnProgramDesc->lpwszApplicationLauncher))) != DPN_OK)
	{
		DnFreeProgramDesc(lpdnProgramDesc);
		goto EXIT_DnReadRegProgramDesc;
	}

	if ((hResultCode = DnGetRegKeyValue(hKey,DN_REG_KEYNAME_APPLICATIONNAME,
			&(lpdnProgramDesc->lpwszApplicationName))) != DPN_OK)
	{
		DnFreeProgramDesc(lpdnProgramDesc);
		goto EXIT_DnReadRegProgramDesc;
	}

	if ((hResultCode = DnGetRegKeyValue(hKey,DN_REG_KEYNAME_COMMANDLINE,
			&(lpdnProgramDesc->lpwszCommandLine))) != DPN_OK)
	{
		DnFreeProgramDesc(lpdnProgramDesc);
		goto EXIT_DnReadRegProgramDesc;
	}

	if ((hResultCode = DnGetRegKeyValue(hKey,DN_REG_KEYNAME_CURRENTDIRECTORY,
			&(lpdnProgramDesc->lpwszCurrentDirectory))) != DPN_OK)
	{
		DnFreeProgramDesc(lpdnProgramDesc);
		goto EXIT_DnReadRegProgramDesc;
	}

	if ((hResultCode = DnGetRegKeyValue(hKey,DN_REG_KEYNAME_DESCRIPTION,
			&(lpdnProgramDesc->lpwszDescription))) != DPN_OK)
	{
		DnFreeProgramDesc(lpdnProgramDesc);
		goto EXIT_DnReadRegProgramDesc;
	}

	if ((hResultCode = DnGetRegKeyValue(hKey,DN_REG_KEYNAME_FILENAME,
			&(lpdnProgramDesc->lpwszFilename))) != DPN_OK)
	{
		DnFreeProgramDesc(lpdnProgramDesc);
		goto EXIT_DnReadRegProgramDesc;
	}

	if ((hResultCode = DnGetRegKeyValue(hKey,DN_REG_KEYNAME_PATH,
			&(lpdnProgramDesc->lpwszPath))) != DPN_OK)
	{
		DnFreeProgramDesc(lpdnProgramDesc);
		goto EXIT_DnReadRegProgramDesc;
	}

EXIT_DnReadRegProgramDesc:

	DPFX(DPFPREP, 3,"Returning: hResultCode = [%lx]",hResultCode);
	return(hResultCode);
}


//	HRESULT	DnDelAppKey
//		lpGuid			lpGuid				Pointer to GUID of program desired
//
//	Returns
//		DPN_OK					If successfull
//		DPNERR_OUTOFMEMORY		If it could not allocate memory
//		DPNERR_DOESNOTEXIST		If the entry does not exist, or there was a problem opening/reading a key
//		DPNERR_GENERIC			If the application key could not be deleted
//
//	Notes
//		This function deletes a GUID specified application registry entry.

#undef DPF_MODNAME
#define DPF_MODNAME "DnDelAppKey"

HRESULT DnDelAppKey(LPGUID lpGuid)
{
	HRESULT	hResultCode = DPN_OK;
	HKEY	hBaseKey = NULL;
	HKEY	hSubKey;
	DWORD	dwEnumIndex = 0;
	BOOL	bFound = FALSE;
	DWORD	dwMaxSubKeyLen;
	LPSTR	lpszSubKey = NULL;
	DWORD	dwSubKeyLen;
	CHAR	lpszGuid[DN_GUID_STR_LEN+1];
	DWORD	dwKeyValueLen;
	GUID	guidApplication;

	DPFX(DPFPREP, 3,"Parameters: lpGuid [%p]",lpGuid);

	// Open base key
	if (DnOpenRegKey(HKEY_LOCAL_MACHINE,DN_REG_LOCAL_APPL_SUBKEY,&hBaseKey) != DPN_OK)
	{
		hResultCode = DPNERR_DOESNOTEXIST;
		goto EXIT_DnDelAppKey;
	}

	// Create buffer to read each subkey (application) name into
	if (RegQueryInfoKeyA(hBaseKey,NULL,NULL,NULL,NULL,&dwMaxSubKeyLen,NULL,NULL,NULL,NULL,NULL,NULL)
		!= ERROR_SUCCESS)
	{
		DPFX(DPFPREP, 9,"RegQueryInfoKey() failed");
		hResultCode = DPNERR_DOESNOTEXIST;
		goto EXIT_DnDelAppKey;
	}
	dwMaxSubKeyLen++;	// Space for null terminator
	if ((lpszSubKey = (LPSTR)GLOBALALLOC(dwMaxSubKeyLen)) == NULL)
	{
		DPFX(DPFPREP, 9,"lpszSubKey = GLOBALALLOC(%d) failed",dwMaxSubKeyLen);
		hResultCode = DPNERR_OUTOFMEMORY;
		goto EXIT_DnDelAppKey;
	}

	// For each subkey (application) get guid and check against lpGuid
	dwEnumIndex = 0;
	dwSubKeyLen = dwMaxSubKeyLen;
	while (RegEnumKeyExA(hBaseKey,dwEnumIndex++,lpszSubKey,&dwSubKeyLen,NULL,NULL,NULL,NULL) == ERROR_SUCCESS)
	{
		if (DnOpenRegKey(hBaseKey,lpszSubKey,&hSubKey) != DPN_OK)
		{
			hResultCode = DPNERR_DOESNOTEXIST;
			goto EXIT_DnDelAppKey;
		}
		dwKeyValueLen = DN_GUID_STR_LEN+1;
		if (RegQueryValueExA(hSubKey,DN_REG_KEYNAME_GUIDAPPLICATION,NULL,NULL,(LPBYTE)lpszGuid,&dwKeyValueLen) != DPN_OK)
		{
			RegCloseKey(hSubKey);
			dwSubKeyLen = dwMaxSubKeyLen;
			continue;
		}
		if (GUIDFromStringA(lpszGuid,&guidApplication) != DPN_OK)
		{
			RegCloseKey(hSubKey);
			dwSubKeyLen = dwMaxSubKeyLen;
			continue;
		}
		if (IsEqualGuid(lpGuid,&guidApplication))
		{	// Found it !
			if (RegDeleteKey(hBaseKey,lpszSubKey) != ERROR_SUCCESS)
			{
				hResultCode = DPNERR_GENERIC;
			}
			RegCloseKey(hSubKey);
			bFound = TRUE;
			break;
		}

		RegCloseKey(hSubKey);
		dwSubKeyLen = dwMaxSubKeyLen;
	}

	if (!bFound)
		hResultCode = DPNERR_DOESNOTEXIST;

EXIT_DnDelAppKey:

	if (hBaseKey != NULL)
		RegCloseKey(hBaseKey);
	if (lpszSubKey != NULL)
		GlobalFree(lpszSubKey);

	DPFX(DPFPREP, 3,"Returning: hResultCode = [%lx]",hResultCode);
	return(hResultCode);
}


//	HRESULT	DnGetProgramDesc
//		lpGuid			lpGuid				Pointer to GUID of program desired
//		LPDNPROGRAMDESC	lpdnProgramDesc		Pointer to a program description structure
//
//	Returns
//		DPN_OK					If successfull
//		DPNERR_OUTOFMEMORY		If it could not allocate memory
//		DPNERR_DOESNOTEXIST		If the entry does not exist, or there was a problem opening/reading a key
//
//	Notes
//		This function gets the program description for a GUID specified program.  The
//		function will search for the program description entry in the registry, and the
//		LPDNPROGRAMDESC structure will then be filled in.  Any strings required will be
//		allocated.  When done with the structure, DnFreeProgramDesc() should be used to
//		release it.  The program description structure should be empty (string pointers
//		invalid) when passed into this function.

#undef DPF_MODNAME
#define DPF_MODNAME "DnGetProgramDesc"

HRESULT DnGetProgramDesc(LPGUID lpGuid, LPDNPROGRAMDESC lpdnProgramDesc)
{
	HRESULT	hResultCode = DPN_OK;
	HKEY	hBaseKey = NULL;
	HKEY	hSubKey;
	DWORD	dwEnumIndex = 0;
	BOOL	bFound = FALSE;
	DWORD	dwMaxSubKeyLen;
	LPSTR	lpszSubKey = NULL;
	DWORD	dwSubKeyLen;
	CHAR	lpszGuid[DN_GUID_STR_LEN+1];
	DWORD	dwKeyValueLen;
	GUID	guidApplication;

	DPFX(DPFPREP, 3,"Parameters: lpGuid [%p], lpdnProgramDesc [%p]",lpGuid,lpdnProgramDesc);

	// Clean up structure
	lpdnProgramDesc->lpwszApplicationLauncher = NULL;
	lpdnProgramDesc->lpwszApplicationName = NULL;
	lpdnProgramDesc->lpwszCommandLine = NULL;
	lpdnProgramDesc->lpwszCurrentDirectory = NULL;
	lpdnProgramDesc->lpwszDescription = NULL;
	lpdnProgramDesc->lpwszFilename = NULL;
	lpdnProgramDesc->lpwszPath = NULL;

	// Open base key
	if (DnOpenRegKey(HKEY_LOCAL_MACHINE,DN_REG_LOCAL_APPL_SUBKEY,&hBaseKey) != DPN_OK)
	{
		hResultCode = DPNERR_DOESNOTEXIST;
		goto EXIT_DnGetProgramDesc;
	}

	// Create buffer to read each subkey (application) name into
	if (RegQueryInfoKeyA(hBaseKey,NULL,NULL,NULL,NULL,&dwMaxSubKeyLen,NULL,NULL,NULL,NULL,NULL,NULL)
		!= ERROR_SUCCESS)
	{
		DPFX(DPFPREP, 9,"RegQueryInfoKey() failed");
		hResultCode = DPNERR_DOESNOTEXIST;
		goto EXIT_DnGetProgramDesc;
	}
	dwMaxSubKeyLen++;	// Space for null terminator
	if ((lpszSubKey = (LPSTR)GLOBALALLOC(dwMaxSubKeyLen)) == NULL)
	{
		DPFX(DPFPREP, 9,"lpszSubKey = GLOBALALLOC(%d) failed",dwMaxSubKeyLen);
		hResultCode = DPNERR_OUTOFMEMORY;
		goto EXIT_DnGetProgramDesc;
	}

	// For each subkey (application) get guid and check against lpGuid
	dwEnumIndex = 0;
	dwSubKeyLen = dwMaxSubKeyLen;
	while (RegEnumKeyExA(hBaseKey,dwEnumIndex++,lpszSubKey,&dwSubKeyLen,NULL,NULL,NULL,NULL) == ERROR_SUCCESS)
	{
		if (DnOpenRegKey(hBaseKey,lpszSubKey,&hSubKey) != DPN_OK)
		{
			hResultCode = DPNERR_DOESNOTEXIST;
			goto EXIT_DnGetProgramDesc;
		}
		dwKeyValueLen = DN_GUID_STR_LEN+1;
		if (RegQueryValueExA(hSubKey,DN_REG_KEYNAME_GUIDAPPLICATION,NULL,NULL,(LPBYTE)lpszGuid,&dwKeyValueLen) != DPN_OK)
		{
			RegCloseKey(hSubKey);
			dwSubKeyLen = dwMaxSubKeyLen;
			continue;
		}
		if (GUIDFromStringA(lpszGuid,&guidApplication) != DPN_OK)
		{
			RegCloseKey(hSubKey);
			dwSubKeyLen = dwMaxSubKeyLen;
			continue;
		}
		if (IsEqualGuid(lpGuid,&guidApplication))
		{	// Found it !
			CopyGuid(&(lpdnProgramDesc->guidApplication),&guidApplication);
			hResultCode = DnReadRegProgramDesc(hSubKey,lpdnProgramDesc);
			RegCloseKey(hSubKey);
			bFound = TRUE;
			break;
		}

		RegCloseKey(hSubKey);
		dwSubKeyLen = dwMaxSubKeyLen;
	}

	if (!bFound)
		hResultCode = DPNERR_DOESNOTEXIST;

EXIT_DnGetProgramDesc:

	if (hBaseKey != NULL)
		RegCloseKey(hBaseKey);
	if (lpszSubKey != NULL)
		GlobalFree(lpszSubKey);

	DPFX(DPFPREP, 3,"Returning: hResultCode = [%lx]",hResultCode);
	return(hResultCode);
}


//	HRESULT	DnExpandEnvStringA
//		LPSTR	lpszOrig		Orginal string, including environment variables
//		LPSTR	*lplpszResult	Resulting string, after expanding environemnt variables
//
//	Returns
//		DPN_OK					If successfull
//		DPNERR_OUTOFMEMORY		If it could not allocate memory
//
//	Notes
//		This function expands embedded environment strings.  It calculates the expected size of the
//		required expanded string, allocates it, expands environment variables and returns a pointer
//		to the new string to the caller.

#undef DPF_MODNAME
#define DPF_MODNAME "DnExpandEnvStringA"

HRESULT DnExpandEnvStringA(LPSTR lpszOrig, LPSTR *lplpszResult)
{
	HRESULT	hResultCode = DPN_OK;
	LPSTR	lpszResult;
	DWORD	dwStrLen;

	DPFX(DPFPREP, 3,"Parameters: lpszOrig [%p], lplpszRestul [%p]",lpszOrig,lplpszResult);

	// Expand environment strings
	if ((dwStrLen = ExpandEnvironmentStringsA(lpszOrig,NULL,0)) == 0)
	{
		hResultCode = DPNERR_OUTOFMEMORY;
		goto EXIT_DnExpandEnvStringA;
	}
	if ((lpszResult = (LPSTR)GLOBALALLOC(dwStrLen)) == NULL)
	{
		hResultCode = DPNERR_OUTOFMEMORY;
		goto EXIT_DnExpandEnvStringA;
	}
	if (ExpandEnvironmentStringsA(lpszOrig,lpszResult,dwStrLen) == 0)
	{
		GlobalFree(lpszResult);
		hResultCode = DPNERR_OUTOFMEMORY;
		goto EXIT_DnExpandEnvStringA;
	}

	*lplpszResult = lpszResult;

EXIT_DnExpandEnvStringA:

	DPFX(DPFPREP, 3,"Returning: hResultCode = [%lx]",hResultCode);
	return(hResultCode);
}


//	HRESULT	DnExpandEnvStringW
//		LPWSTR	lpwszOrig		Orginal string, including environment variables
//		LPWSTR	*lplpwszResult	Resulting string, after expanding environemnt variables
//
//	Returns
//		DPN_OK					If successfull
//		DPNERR_OUTOFMEMORY		If it could not allocate memory
//
//	Notes
//		This function expands embedded environment strings.  It calculates the expected size of the
//		required expanded string, allocates it, expands environment variables and returns a pointer
//		to the new string to the caller.

#undef DPF_MODNAME
#define DPF_MODNAME "DnExpandEnvStringW"

HRESULT DnExpandEnvStringW(LPWSTR lpwszOrig, LPWSTR *lplpwszResult)
{
	HRESULT	hResultCode = DPN_OK;
	LPWSTR	lpwszResult;
	DWORD	dwStrLen;

	DPFX(DPFPREP, 3,"Parameters: lpwszOrig [%p], lplpwszRestul [%p]",lpwszOrig,lplpwszResult);

	// Expand environment strings
	if ((dwStrLen = ExpandEnvironmentStringsW(lpwszOrig,NULL,0)) == 0)
	{
		hResultCode = DPNERR_OUTOFMEMORY;
		goto EXIT_DnExpandEnvStringW;
	}
	if ((lpwszResult = (LPWSTR)GLOBALALLOC(dwStrLen*sizeof(WCHAR))) == NULL)
	{
		hResultCode = DPNERR_OUTOFMEMORY;
		goto EXIT_DnExpandEnvStringW;
	}
	if (ExpandEnvironmentStringsW(lpwszOrig,lpwszResult,dwStrLen) == 0)
	{
		GlobalFree(lpwszResult);
		hResultCode = DPNERR_OUTOFMEMORY;
		goto EXIT_DnExpandEnvStringW;
	}

	*lplpwszResult = lpwszResult;

EXIT_DnExpandEnvStringW:

	DPFX(DPFPREP, 3,"Returning: hResultCode = [%lx]",hResultCode);
	return(hResultCode);
}


//	HRESULT	DnGetOsPlatformId
//
//	Returns
//		DPN_OK				If successfull
//		DPNERR_GENERIC		If not
//
//	Notes
//		This function determines the version of the operating system being run

#undef DPF_MODNAME
#define DPF_MODNAME "DnGetOsPlatformId"

HRESULT DnGetOsPlatformId(void)
{
	OSVERSIONINFO	osv;

	DPFX(DPFPREP, 3,"Parameters: (none)");

	// Set Global
	osv.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	if (GetVersionEx(&osv) == FALSE)
		return(DPNERR_GENERIC);

	DnOsPlatformId = osv.dwPlatformId;
	return(DPN_OK);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\lobby\sources.inc ===
#
# The MAJORCOMP and MINORCOMP variables are defined
# so that $(MAJORCOMP)$(MINORCOMP)filename can be used in
# cross compiling to provide unique filenames in a flat namespace.
#

MAJORCOMP=windows
MINORCOMP=media

#
# The TARGETNAME variable is defined by the developer.  It is the name of
# the target (component) that is being built by this makefile.  It
# should NOT include any path or file extension information.
#

TARGETNAME=dpnlobby
DLLDEF=..\dplobby.def
UMTYPE=windows

#
# The TARGETPATH and TARGETTYPE variables are defined by the developer.
# The first specifies where the target is to be build.  The second specifies
# the type of target (either PROGRAM, DYNLINK, LIBRARY, DRIVER, etc
# UMAPPL_NOLIB is used when you're only building user-mode
# apps and don't need to build a library.
#

TARGETPATH=obj
TARGETTYPE=DYNLINK

!if "$(DPLAY_PCH)" != "off"
PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\dnlobbyi.h
PRECOMPILED_PCH=dnlobbyi.pch
PRECOMPILED_OBJ=dnlobbyi.obj
!endif

#
# The TARGETLIBS specifies additional libraries to link with you target
# image.  Each library path specification should contain an asterisk (*)
# where the machine specific subdirectory name should go.
#

#
# 04/10/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
           ..\..\guids\obj$(BUILD_ALT_DIR)\*\guids.lib \
           ..\..\common\obj$(BUILD_ALT_DIR)\*\common.lib \
	   $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
	   $(BASEDIR)\public\sdk\lib\*\user32.lib \
	   $(BASEDIR)\public\sdk\lib\*\gdi32.lib \
	   $(BASEDIR)\public\sdk\lib\*\winmm.lib \
	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
	   $(BASEDIR)\public\sdk\lib\*\ole32.lib  \
	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
	   $(BASEDIR)\public\sdk\lib\*\msvcrt.lib


!if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
C_DEFINES=$(C_DEFINES) /DDEBUG /D_DEBUG
!endif

#
# The INCLUDES variable specifies any include paths that are specific to
# this source directory.  Separate multiple directory paths with single
# semicolons.  Relative path specifications are okay.
#

INCLUDES=..\;$(DXROOT)\inc;..\..\inc;..\..\common


#
# The SOURCES variable is defined by the developer.  It is a list of all the
# source files for this component.  Each source file should be on a separate
# line using the line continuation character.  This will minimize merge
# conflicts if two developers adding source files to the same component.
#

SOURCES= ..\dplclassfac.cpp \
	 ..\dpldllmain.cpp \
	 ..\dplapp.cpp \
	 ..\dplclient.cpp \
	 ..\dplcommon.cpp \
         ..\dplconnect.cpp \
	 ..\dplmsgq.cpp \
	 ..\dplobby.rc \
	 ..\dplproc.cpp \
	 ..\dplreg.cpp \
         ..\dplglobals.cpp \
         ..\dplhandles.cpp \
	 ..\dplconset.cpp \
         ..\dplparam.cpp 

#
# Next specify options for the compiler.
#
# Note about CRT defines.  When linking with MSVCRT you must have both _MT and _DLL specified.
# Using the build environment's USE_MSVCRT=1 would do this for us, but because we define our
# own operator new this will cause a link error because the build environment will not properly
# pull in msvcrt.lib last as of 5/11/2001.  Therefore, we do it all manually specifying _DLL, _MT, 
# and msvcrt.lib and USE_NOLIBS=1 ourselves.  This also means that we must manually add msvcprt.lib 
# where STL is used.
#
C_DEFINES= $(C_DEFINES) /D_USRDLL /DWIN32 /D_MT /D_DLL /DCINTERFACE

USE_NOLIBS=1

DLLENTRY=_DllMainCRTStartup
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\protocol\backend.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		Backend.cpp
 *  Content:	This file contains the backend (mostly timer- and captive thread-based
 *				processing for the send pipeline.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  11/06/98    ejs     Created
 *  07/01/2000  masonb  Assumed Ownership
 *
 ****************************************************************************/

/*
**		NOTE ABOUT CRITICAL SECTIONS
**
**		It is legal to enter multiple critical sections concurrently,  but to avoid
**	deadlocks,  they must be entered in the correct order.
**
**		MSD CommandLocks should be entered first. That is,  do not attempt to take
**	a command lock with the EPD EPLock held because you may deadlock the protocol.
**
**		ORDER OF PRECEDENCE -  Never take a low # lock while holding a higher # lock
**	
**		1 - CommandLock		// guards an MSD
**		2 - EPLock			// guards EPD queues (and retry timer stuff)
**		3 - SPLock			// guards SP send queue (and Listen command)
**
**		ANOTHER NOTE ABOUT CRIT SECs
**
**		It is also legal in WIN32 for a thread to take a CritSec multiple times, but in
**	this implementation we will NEVER do that.  The debug code will ASSERT that a thread
**	never re-enters a locked critsec even though the OS would allow it.
*/

#include "dnproti.h"


PFMD	CopyFMD(PFMD, PEPD);

#undef DPF_MODNAME
#define DPF_MODNAME "LockEPD"

#ifdef DEBUG
BOOL LockEPD(PEPD pEPD, PCHAR Buf)
{
#else
BOOL LockEPD(PEPD pEPD)
{
#endif

	if (INTER_INC(pEPD) == 0)
	{
		INTER_DEC(pEPD);
		return FALSE;
	}
	else
	{
		DPFX(DPFPREP,DPF_EP_REFCNT_LVL, "(%p) %s, RefCnt: %d", pEPD, Buf, pEPD->lRefCnt);
		return TRUE;
	}
}

/*
*	Called with EPLock held, returns with EPLock released
*/
#undef DPF_MODNAME
#define DPF_MODNAME "ReleaseEPD"

#ifdef DEBUG
VOID ReleaseEPD(PEPD pEPD, PCHAR Buf)
{
#else
VOID ReleaseEPD(PEPD pEPD)
{
#endif

	AssertCriticalSectionIsTakenByThisThread(&pEPD->EPLock, TRUE);
	ASSERT(pEPD->lRefCnt >= 0); 

	// Someone else can come along and call LOCK_EPD or DECREMENT_EPD while we are here
	// so the decrement has to be interlocked even though we own the EPLock.
	LONG lRefCnt = INTER_DEC(pEPD);

	if (lRefCnt == 0 && !(pEPD->ulEPFlags & EPFLAGS_SP_DISCONNECTED))
	{
		// Make sure no one else does this again
		pEPD->ulEPFlags |= EPFLAGS_SP_DISCONNECTED;

		SPDISCONNECTDATA	Block;
		Block.hEndpoint = pEPD->hEndPt;
		Block.dwFlags = 0;
		Block.pvContext = NULL;

		ASSERT(pEPD->hEndPt != INVALID_HANDLE_VALUE);
		pEPD->hEndPt = INVALID_HANDLE_VALUE; 

		Unlock(&pEPD->EPLock);

		DPFX(DPFPREP,DPF_CALLOUT_LVL, "(%p) Calling SP->Disconnect - hEndpoint[%x], pSPD[%p]", pEPD, Block.hEndpoint, pEPD->pSPD);
		(void) IDP8ServiceProvider_Disconnect(pEPD->pSPD->IISPIntf, &Block);
	}
	else if (lRefCnt < 0)
	{
		Unlock(&pEPD->EPLock);

		Lock(&pEPD->pSPD->SPLock);
		pEPD->blActiveLinkage.RemoveFromList();
		Unlock(&pEPD->pSPD->SPLock);

		EPDPool->Release(EPDPool, pEPD);
	}
	else
	{
		Unlock(&pEPD->EPLock);
	}

	DPFX(DPFPREP,DPF_EP_REFCNT_LVL, "(%p) %s, RefCnt: %d", pEPD, Buf, lRefCnt);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DecrementEPD"

#ifdef DEBUG
VOID DecrementEPD(PEPD pEPD, PCHAR Buf)
{
#else
VOID DecrementEPD(PEPD pEPD)
{
#endif

	ASSERT(pEPD->lRefCnt > 0); 

	INTER_DEC(pEPD);
	
	DPFX(DPFPREP,DPF_EP_REFCNT_LVL, "(%p) %s, RefCnt: %d", pEPD, Buf, pEPD->lRefCnt);
}

#undef DPF_MODNAME
#define DPF_MODNAME "LockMSD"

#ifdef DEBUG
VOID LockMSD(PMSD pMSD, PCHAR Buf)
{
#else
VOID LockMSD(PMSD pMSD)
{
#endif

	if(INTER_INC(pMSD) == 0) 
	{ 
		ASSERT(0); 
	}

	DPFX(DPFPREP,DPF_REFCNT_LVL, "(%p) %s, RefCnt: %d", pMSD, Buf, pMSD->lRefCnt);
}

#undef DPF_MODNAME
#define DPF_MODNAME "ReleaseMSD"

#ifdef DEBUG
VOID ReleaseMSD(PMSD pMSD, PCHAR Buf)
{
#else
VOID ReleaseMSD(PMSD pMSD)
{
#endif

	AssertCriticalSectionIsTakenByThisThread(&pMSD->CommandLock, TRUE);
	ASSERT(pMSD->lRefCnt >= 0); 
	
	if(INTER_DEC(pMSD) < 0)
	{ 
		MSDPool->Release(MSDPool, pMSD); 
		DPFX(DPFPREP,DPF_REFCNT_LVL, "(%p) %s, RefCnt: %d", pMSD, Buf, -1);
	}
	else 
	{ 
		Unlock(&pMSD->CommandLock); 
		DPFX(DPFPREP,DPF_REFCNT_LVL, "(%p) %s, RefCnt: %d", pMSD, Buf, pMSD->lRefCnt);
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "DecrementMSD"

#ifdef DEBUG
VOID DecrementMSD(PMSD pMSD, PCHAR Buf)
{
#else
VOID DecrementMSD(PMSD pMSD)
{
#endif

	ASSERT(pMSD->lRefCnt > 0); 

	INTER_DEC(pMSD);
	
	DPFX(DPFPREP,DPF_REFCNT_LVL, "(%p) %s, RefCnt: %d", pMSD, Buf, pMSD->lRefCnt);
}

#undef DPF_MODNAME
#define DPF_MODNAME "LockFMD"

#ifdef DEBUG
VOID LockFMD(PFMD pFMD, PCHAR Buf)
{
#else
VOID LockFMD(PFMD pFMD)
{
#endif

	ASSERT(pFMD->lRefCnt > 0); // FMD_Get is the only function that should make this 1 

	INTER_INC(pFMD);
		
	DPFX(DPFPREP,DPF_REFCNT_LVL, "(%p) %s, RefCnt: %d", pFMD, Buf, pFMD->lRefCnt);
}

#undef DPF_MODNAME
#define DPF_MODNAME "ReleaseFMD"

#ifdef DEBUG
VOID ReleaseFMD(PFMD pFMD, PCHAR Buf)
{
#else
VOID ReleaseFMD(PFMD pFMD)
{
#endif

	ASSERT(pFMD->lRefCnt > 0); 

	if( INTER_DEC(pFMD) == 0) 
	{ 
		FMDPool->Release(FMDPool, pFMD); 
		DPFX(DPFPREP,DPF_REFCNT_LVL, "(%p) %s, RefCnt: %d", pFMD, Buf, 0);
	}
	else
	{
		DPFX(DPFPREP,DPF_REFCNT_LVL, "(%p) %s, RefCnt: %d", pFMD, Buf, pFMD->lRefCnt);
	}
}

/*
**		DNSP Command Complete
**
**		Service Provider calls us here to indicate completion of an asynchronous
**	command.  This may be called before the actual command returns,  so we must
**	make sure that our Context value is valid and accessible before calling SP.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "DNSP_CommandComplete"

HRESULT WINAPI DNSP_CommandComplete(IDP8SPCallback *pIDNSP, HANDLE Handle, HRESULT hr, PVOID Context)
{
	PSPD		pSPD = (PSPD) pIDNSP;
	PFMD		pFMD = (PFMD) Context;
	PEPD		pEPD;
	PMSD		pMSD;

	ASSERT_SPD(pSPD);

	DPFX(DPFPREP,9, "COMMAND COMPLETE  (%p)", Context);

	// If we did not specify a context,  then we are not waiting for completion.
	if(Context != NULL)
	{		
		switch(pFMD->CommandID)
		{
			case COMMAND_ID_SEND_DATAGRAM:
			{
				ASSERT_FMD(pFMD);
				ASSERT(pFMD->bSubmitted);
				ASSERT( pFMD->SendDataBlock.hCommand == Handle || pFMD->SendDataBlock.hCommand == NULL);

				pEPD = pFMD->pEPD;
				ASSERT_EPD(pEPD);

				DPFX(DPFPREP,DPF_CALLIN_LVL, "CommandComplete called for COMMAND_ID_SEND_DATAGRAM, pEPD[%p], pFMD[%p], Handle[%p], hCommand[%p], hr[%x]", pEPD, pFMD, Handle, pFMD->SendDataBlock.hCommand, hr);
				
				Lock(&pSPD->SPLock);
				pFMD->blQLinkage.RemoveFromList();				// Unlink from SPD Pending Queue
				pFMD->bSubmitted = FALSE;						// bSubmitted flag is protected bp SP->SPLock
				Unlock(&pSPD->SPLock);

				pMSD = pFMD->pMSD;
				ASSERT_MSD(pMSD);
				ASSERT(pMSD->lRefCnt != -1);
				
				Lock(&pMSD->CommandLock);
				Lock(&pEPD->EPLock);

				pMSD->uiFrameCount--;
				pFMD->blMSDLinkage.RemoveFromList();			// Unlink from message
				RELEASE_FMD(pFMD, "MSD Frame List");			// release reference from frame list

				if(pMSD->uiFrameCount == 0)
				{
					// There is a race condition while abort is between its two holdings of the lock.  If we are completing, 
					// then we need to let AbortSends know that by clearing this flag.
					pMSD->ulMsgFlags2 &= ~(MFLAGS_TWO_ABORT_WILL_COMPLETE);

					DPFX(DPFPREP, DPF_FRAMECNT_LVL, "Completing NG, pMSD[%p], framecount[%u]", pMSD, pMSD->uiFrameCount);

					Unlock(&pEPD->EPLock);
					CompleteDatagramSend(pSPD, pMSD, hr);		// Datagram completes when SP says its xmited, releases MSDLock
					Lock(&pEPD->EPLock);
				}
				else 
				{
					ASSERT(!pMSD->blFrameList.IsEmpty());
					Unlock(&pMSD->CommandLock);
				}

				RELEASE_EPD(pEPD, "UNLOCK (DG Frame Complete)"); // This releases the EPLock

				RELEASE_FMD(pFMD, "SP Submit");								// Release reference on frame from SP submission

				break;
			}

			case COMMAND_ID_SEND_RELIABLE:
			case COMMAND_ID_COPIED_RETRY:
			{
				ASSERT_FMD(pFMD);
				ASSERT(pFMD->bSubmitted);
				ASSERT( pFMD->SendDataBlock.hCommand == Handle || pFMD->SendDataBlock.hCommand == NULL);

				pEPD = pFMD->pEPD;
				ASSERT_EPD(pEPD);

				if (pFMD->CommandID == COMMAND_ID_SEND_RELIABLE)
				{
					DPFX(DPFPREP,DPF_CALLIN_LVL, "CommandComplete called for COMMAND_ID_SEND_RELIABLE, pEPD[%p], pFMD[%p], Handle[%p], hCommand[%p], hr[%x]", pEPD, pFMD, Handle, pFMD->SendDataBlock.hCommand, hr);
				}
				else
				{
					DPFX(DPFPREP,DPF_CALLIN_LVL, "CommandComplete called for COMMAND_ID_COPIED_RETRY, pEPD[%p], pFMD[%p], Handle[%p], hCommand[%p], hr[%x]", pFMD->pEPD, pFMD, Handle, pFMD->SendDataBlock.hCommand, hr);
				}

				Lock(&pSPD->SPLock);
				pFMD->blQLinkage.RemoveFromList();				// but they dont wait on the PENDING queue
				pFMD->bSubmitted = FALSE;						// bSubmitted flag is protected bp SP->SPLock
				Unlock(&pSPD->SPLock);

				pMSD = pFMD->pMSD;
				ASSERT_MSD(pMSD);

				Lock(&pMSD->CommandLock);
				Lock(&pEPD->EPLock);

				// We wait for the Frame count to go to zero on reliables before completing them to the Core so that we know we are done
				// with the user's buffers.
				pMSD->uiFrameCount--; // Protected by EPLock
				DPFX(DPFPREP, DPF_FRAMECNT_LVL, "Frame count decremented on complete, pMSD[%p], framecount[%u]", pMSD, pMSD->uiFrameCount);

				if ((pMSD->CommandID == COMMAND_ID_DISCONNECT || pMSD->CommandID == COMMAND_ID_DISC_RESPONSE) && 
					(pMSD->ulMsgFlags2 & MFLAGS_TWO_ABORT) &&
					(pMSD->uiFrameCount == 0))	// Protected by EPLock
				{
					// There is a race condition while abort is between its two holdings of the lock.  If we are completing, 
					// then we need to let AbortSends know that by clearing this flag.
					pMSD->ulMsgFlags2 &= ~(MFLAGS_TWO_ABORT_WILL_COMPLETE);

					DPFX(DPFPREP, DPF_FRAMECNT_LVL, "Completing disconnect, pMSD[%p], framecount[%u]", pMSD, pMSD->uiFrameCount);

					Unlock(&pEPD->EPLock);
					CompleteDisconnect(pMSD, pSPD, pEPD); // This releases the CommandLock
					Lock(&pEPD->EPLock);
				}
				else if ((pMSD->ulMsgFlags2 & (MFLAGS_TWO_SEND_COMPLETE|MFLAGS_TWO_ABORT)) && (pMSD->uiFrameCount == 0))	// Protected by EPLock
				{
					// Remove the MSD from the CompleteSends list
					pMSD->blQLinkage.RemoveFromList();
					
					// There is a race condition while abort is between its two holdings of the lock.  If we are completing, 
					// then we need to let AbortSends know that by clearing this flag.
					pMSD->ulMsgFlags2 &= ~(MFLAGS_TWO_ABORT_WILL_COMPLETE);

					DPFX(DPFPREP, DPF_FRAMECNT_LVL, "Completing, pMSD[%p], framecount[%u]", pMSD, pMSD->uiFrameCount);

					// See what error code we need to return
					if(pMSD->ulMsgFlags2 & MFLAGS_TWO_SEND_COMPLETE)
					{
						Unlock(&pEPD->EPLock);
						CompleteReliableSend(pEPD->pSPD, pMSD, DPN_OK); // This releases the CommandLock
						Lock(&pEPD->EPLock);
					}
					else
					{
						Unlock(&pEPD->EPLock);
						CompleteReliableSend(pEPD->pSPD, pMSD, DPNERR_CONNECTIONLOST); // This releases the CommandLock
						Lock(&pEPD->EPLock);
					}
				}
				else
				{
					DPFX(DPFPREP, DPF_FRAMECNT_LVL, "Message not yet complete or frames still out, pMSD[%p], framecount[%u]", pMSD, pMSD->uiFrameCount);
					Unlock(&pMSD->CommandLock);
				}

				if (pFMD->CommandID == COMMAND_ID_COPIED_RETRY)
				{
					DECREMENT_EPD(pFMD->pEPD, "UNLOCK (Rely Frame Complete (Copy))");
				}

				RELEASE_EPD(pFMD->pEPD, "UNLOCK (Rely Frame Complete)"); // This releases the EPLock

				RELEASE_FMD(pFMD, "Final Release on Complete");			 // Dec ref count

				break;
			}
			case COMMAND_ID_CONNECT:
			{
				pMSD = (PMSD) Context;

				ASSERT_MSD(pMSD);
				ASSERT( pMSD->hCommand == Handle || pMSD->hCommand == NULL); // Command can complete before hCommmand is set up
				ASSERT(pMSD->ulMsgFlags1 & MFLAGS_ONE_IN_SERVICE_PROVIDER);

				DPFX(DPFPREP,DPF_CALLIN_LVL, "(%p) CommandComplete called for COMMAND_ID_CONNECT, pMSD[%p], pSPD[%p], Handle[%p], hCommand[%p], hr[%x]", pMSD->pEPD, pMSD, pSPD, Handle, pMSD->hCommand, hr);

				Lock(&pMSD->CommandLock);						// must do this before clearing IN_SP flag

				pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_IN_SERVICE_PROVIDER);	// clear InSP flag
				DECREMENT_MSD(pMSD, "SP Ref");							// Dec ref count w/o release lock

				CompleteSPConnect((PMSD) Context, pSPD, hr);

				break;		
			}
			case COMMAND_ID_CFRAME:
			{
				ASSERT_FMD(pFMD);
				ASSERT(pFMD->bSubmitted);
				ASSERT( pFMD->SendDataBlock.hCommand == Handle || pFMD->SendDataBlock.hCommand == NULL);

				pEPD = pFMD->pEPD;
				ASSERT_EPD(pEPD);

				DPFX(DPFPREP,DPF_CALLIN_LVL, "CommandComplete called for COMMAND_ID_CFRAME, pEPD[%p], pFMD[%p], Handle[%p], hCommand[%p], hr[%x]", pFMD->pEPD, pFMD, Handle, pFMD->SendDataBlock.hCommand, hr);
				
				Lock(&pSPD->SPLock);
				pFMD->blQLinkage.RemoveFromList();				// Take the frame off of the pending queue
				pFMD->bSubmitted = FALSE;						// bSubmitted flag is protected bp SP->SPLock
				Unlock(&pSPD->SPLock);

				Lock(&pEPD->EPLock);
				if (pFMD->ulFFlags & FFLAGS_FINAL_ACK)
				{
					pEPD->ulEPFlags |= EPFLAGS_ACKED_DISCONNECT;

					if (pEPD->ulEPFlags & EPFLAGS_DISCONNECT_ACKED)
					{
						DPFX(DPFPREP,7, "(%p) Final ACK completed and our EOS ACK'd, dropping link", pEPD);
						DropLink(pEPD); // Drops EPLock
						Lock(&pEPD->EPLock);
					}
					else
					{
						DPFX(DPFPREP,7, "(%p) Final ACK completed, still awaiting ACK on our EOS", pEPD);
					}
				}

				RELEASE_EPD(pEPD, "UNLOCK (CFrame Cmd Complete)");	// Release EndPoint before releasing frame, releases EPLock
				RELEASE_FMD(pFMD, "Final Release on Complete");								// Release Frame

				break;
			}
			case COMMAND_ID_LISTEN:
			{
				pMSD = (PMSD) Context;

				ASSERT_MSD(pMSD);
				ASSERT( pMSD->hCommand == Handle || pMSD->hCommand == NULL); // Command can complete before hCommmand is set up
				ASSERT(pMSD->ulMsgFlags1 & MFLAGS_ONE_IN_SERVICE_PROVIDER);

				DPFX(DPFPREP,DPF_CALLIN_LVL, "CommandComplete called for COMMAND_ID_LISTEN, pMSD[%p], pSPD[%p], Handle[%p], hCommand[%p], hr[%x]", pMSD, pSPD, Handle, pMSD->hCommand, hr);

				Lock(&pMSD->CommandLock);

				pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_IN_SERVICE_PROVIDER);	// clear InSP flag

#ifdef DEBUG
				Lock(&pSPD->SPLock);
				if(pMSD->ulMsgFlags1 & MFLAGS_ONE_ON_GLOBAL_LIST)
				{
					pMSD->blSPLinkage.RemoveFromList();
					pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_ON_GLOBAL_LIST);
				}
				Unlock(&pSPD->SPLock);

				ASSERT(!(pMSD->ulMsgFlags1 & MFLAGS_ONE_COMPLETED_TO_CORE));
				pMSD->ulMsgFlags1 |= MFLAGS_ONE_COMPLETED_TO_CORE;
				pMSD->CallStackCoreCompletion.NoteCurrentCallStack();
#endif
				// Leave lock while calling into higher layer
				Unlock( &pMSD->CommandLock );

				DPFX(DPFPREP,DPF_CALLOUT_LVL, "(%p) Calling Core->CompleteListenTerminate, hr[%x], Core Context[%p]", pMSD, hr, pMSD->Context);
				pSPD->pPData->pfVtbl->CompleteListenTerminate(pSPD->pPData->Parent, pMSD->Context, hr);
				
				// Release the final reference on the MSD AFTER indicating to the Core
				Lock(&pMSD->CommandLock);
				RELEASE_MSD(pMSD, "SP Ref");

				// Base ref will be released when DoCancel completes
				break;
			}
			case COMMAND_ID_ENUM:
			{
				pMSD = static_cast<PMSD>( Context );

				ASSERT_MSD( pMSD );
				ASSERT( pMSD->hCommand == Handle || pMSD->hCommand == NULL);
				ASSERT( pMSD->ulMsgFlags1 & MFLAGS_ONE_IN_SERVICE_PROVIDER );

				DPFX(DPFPREP,DPF_CALLIN_LVL, "CommandComplete called for COMMAND_ID_ENUM, pMSD[%p], pSPD[%p], Handle[%p], hCommand[%p], hr[%x]", pMSD, pSPD, Handle, pMSD->hCommand, hr);
				
				Lock( &pMSD->CommandLock );

				pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_IN_SERVICE_PROVIDER);

#ifdef DEBUG
				Lock( &pSPD->SPLock );
				if ( ( pMSD->ulMsgFlags1 & MFLAGS_ONE_ON_GLOBAL_LIST ) != 0 )
				{
					pMSD->blSPLinkage.RemoveFromList();
					pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_ON_GLOBAL_LIST);
				}
				Unlock( &pSPD->SPLock );

				ASSERT(!(pMSD->ulMsgFlags1 & MFLAGS_ONE_COMPLETED_TO_CORE));
				pMSD->ulMsgFlags1 |= MFLAGS_ONE_COMPLETED_TO_CORE;
				pMSD->CallStackCoreCompletion.NoteCurrentCallStack();
#endif

				// Leave lock while calling into higher layer
				Unlock( &pMSD->CommandLock );

				DPFX(DPFPREP,DPF_CALLOUT_LVL, "(%p) Calling Core->CompleteEnumQuery, hr[%x], Core Context[%p]", pMSD, hr, pMSD->Context);
				pSPD->pPData->pfVtbl->CompleteEnumQuery(pSPD->pPData->Parent, pMSD->Context, hr);

				// Release the final reference on the MSD AFTER indicating to the Core
				Lock( &pMSD->CommandLock );
				DECREMENT_MSD( pMSD, "SP Ref");				// SP is done
				RELEASE_MSD( pMSD, "Release On Complete" );	// Base Reference

				break;
			}

			case COMMAND_ID_ENUMRESP:
			{
				pMSD = static_cast<PMSD>( Context );

				ASSERT_MSD( pMSD );
				ASSERT( pMSD->hCommand == Handle || pMSD->hCommand == NULL );
				ASSERT( pMSD->ulMsgFlags1 & MFLAGS_ONE_IN_SERVICE_PROVIDER );

				DPFX(DPFPREP,DPF_CALLIN_LVL, "CommandComplete called for COMMAND_ID_ENUMRESP, pMSD[%p], pSPD[%p], Handle[%p], hCommand[%p], hr[%x]", pMSD, pSPD, Handle, pMSD->hCommand, hr);

				Lock( &pMSD->CommandLock );

				pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_IN_SERVICE_PROVIDER);

#ifdef DEBUG
				Lock( &pSPD->SPLock );
				if ( ( pMSD->ulMsgFlags1 & MFLAGS_ONE_ON_GLOBAL_LIST ) != 0 )
				{
					pMSD->blSPLinkage.RemoveFromList();
					pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_ON_GLOBAL_LIST);
				}
				Unlock( &pSPD->SPLock );

				ASSERT(!(pMSD->ulMsgFlags1 & MFLAGS_ONE_COMPLETED_TO_CORE));
				pMSD->ulMsgFlags1 |= MFLAGS_ONE_COMPLETED_TO_CORE;
				pMSD->CallStackCoreCompletion.NoteCurrentCallStack();
#endif

				// Leave lock while calling into higher layer
				Unlock( &pMSD->CommandLock );

				DPFX(DPFPREP,DPF_CALLOUT_LVL, "(%p) Calling Core->CompleteEnumResponse, hr[%x], Core Context[%p], hr[%x]", pMSD, hr, pMSD->Context, hr);
				pSPD->pPData->pfVtbl->CompleteEnumResponse(pSPD->pPData->Parent, pMSD->Context, hr);

				// Release the final reference on the MSD AFTER indicating to the Core
				Lock( &pMSD->CommandLock );
				DECREMENT_MSD( pMSD, "SP Ref" );			// SP is done
				RELEASE_MSD( pMSD, "Release On Complete" );	// Base Reference

				break;
			}

			default:
			{
				DPFX(DPFPREP,0, "CommandComplete called with unknown CommandID");
				ASSERT(0);
				break;
			}
		} // SWITCH
	} // IF NOT NULL CONTEXT	
	else 
	{
		DPFX(DPFPREP,0, "CommandComplete called with NULL Context");
		ASSERT(0);
	}

	return DPN_OK;
}

/*
**		Update Xmit State
**
**		There are two elements to the remote rcv state delivered in each frame.  There is
**	the NSeq number which acknowledges ALL frames with smaller sequence numbers,
**	and there is the bitmask which acknowledges specific frames starting with NSeq+1.
**
**		Frames prior to NSeq can be removed from the SendWindow.  Frames acked by bits
**	should be marked as acknowledged,  but left in the window until covered by NSeq
**	(because a protocol can renege on bit-acked frames).
**
**		We will walk through the send window queue,  starting with the oldest frame,
**	and remove each frame that has been acknowledged by NSeq.  As we hit EOM frames,
**	we will indicate SendComplete for the message.  If the bitmask is non-zero we may
**	trigger retransmission of the missing frames.  I say 'may' because we dont want
**	to send too many retranmissions of the same frame...
**
**	SOME MILD INSANITY:  Doing the DropLink code now.  There are several places where
**	we release the EPD Locks in the code below,  and any time we arent holding the locks
**	someone can start terminating the link.  Therefore,  whenever we retake either EPD lock
**	(State or SendQ) after yielding them,  we must re-verify that EPFLAGS_CONNECTED is still
**	set and be prepared to abort if it is not.  Happily,  the whole EPD wont go away on us
**	because we have a RefCnt on it,  but once CONNECTED has been cleared we dont want to go
**	setting any more timers or submitting frames to the SP.
**
**	RE_WRITE TIME:  We can be re-entered while User Sends are being completed.  This is okay
**	except for the chance that the second thread would blow through here and hit the rest
**	of CrackSequential before us.  CrackSeq would think it got an out of order frame (it had)
**	and would issue a NACK before we could stop him.  Easiest solution is to delay the callback
**	of complete sends until the end of the whole receive operation (when we indicate receives
**	for instance).  Incoming data should have priority over completing sends anyhow...
**
**	** ENTERED AND EXITS WITH EPD->EPLOCK HELD **
*/

#undef DPF_MODNAME
#define DPF_MODNAME "UpdateXmitState"

VOID
UpdateXmitState(PEPD pEPD, BYTE bNRcv, ULONG RcvMaskLow, ULONG RcvMaskHigh, DWORD tNow)
{
	PSPD	pSPD = pEPD->pSPD;
	PFMD	pFMD;
	PMSD	pMSD;
	CBilink	*pLink;
	UINT	tDelay;
	UINT	uiRTT;
	UINT	delta;
	BOOL	ack = FALSE;
	BOOL	retransmit = FALSE;
	BOOL	logged_drop = FALSE;

	ASSERT_SPD(pSPD);

	AssertCriticalSectionIsTakenByThisThread(&pEPD->EPLock, TRUE);

	if(RcvMaskLow | RcvMaskHigh)
	{
		DPFX(DPFPREP,7, "(%p) *NACK RCVD* NRcv=%x, MaskL=%x, MaskH=%x", pEPD, bNRcv, RcvMaskLow, RcvMaskHigh);
	}

	// The caller should have checked this
	ASSERT( pEPD->ulEPFlags & EPFLAGS_STATE_CONNECTED );

#ifdef	DEBUG			
	// There should always be a timer running on the first frame in window
	if(!pEPD->blSendWindow.IsEmpty())
	{
		pFMD = CONTAINING_RECORD(pEPD->blSendWindow.GetNext(), FMD, blWindowLinkage);
		ASSERT_FMD(pFMD);
		ASSERT(pFMD->ulFFlags & FFLAGS_RETRY_TIMER_SET);
	}
	pFMD = NULL;
#endif
	
	// The send window contains a sorted list of frames that we have sent, but have not received ACKs
	// for. pEPD->uiUnackedFrames contains the count of items in this list.
	while(!pEPD->blSendWindow.IsEmpty())
	{
		// Grab the first item in the list
		pFMD = CONTAINING_RECORD((pLink = pEPD->blSendWindow.GetNext()), FMD, blWindowLinkage);
		ASSERT_FMD(pFMD);

		// Let's try taking one sample from every group of acknowledgements
		// ALWAYS SAMPLE THE HIGHEST NUMBERED FRAME COVERED BY THIS ACK
		if(((PDFRAME) pFMD->ImmediateData)->bSeq == (bNRcv - 1))
		{	
			// Don't take sample if frame was retry because we don't know
			if(pFMD->uiRetry == 0)
			{									
				uiRTT = tNow - pFMD->tTimestamp[0];					// which instance to correlate the response with
				if(uiRTT & 0x80000000)
				{
					DPFX(DPFPREP,7, "(%p) We calced a negative RTT", pEPD);
					uiRTT = 1;
				}
				UpdateEndPoint(pEPD, uiRTT, pFMD->uiFrameLength, -1, tNow);
			}
		}		

		// If bNRcv for the other side is higher than this frame's bSeq, we know the other side has 
		// seen this frame, so it is ACK'd and we will remove it from the Send Window.
		if( (BYTE)  ((bNRcv) - (((PDFRAME) pFMD->ImmediateData)->bSeq + 1)) < (BYTE) pEPD->uiUnackedFrames) 
		{
			ASSERT(pFMD->ulFFlags & FFLAGS_IN_SEND_WINDOW);

			DPFX(DPFPREP,7, "(%p) Removing Frame %x from send window", pEPD, ((PDFRAME) pFMD->ImmediateData)->bSeq);
			pFMD->blWindowLinkage.RemoveFromList();				// Remove frame from send window
			pFMD->ulFFlags &= ~(FFLAGS_IN_SEND_WINDOW);			// Clear flag

			if(pFMD->ulFFlags & FFLAGS_RETRY_TIMER_SET)
			{
				ASSERT(ack == FALSE);
				ASSERT(pEPD->RetryTimer != 0);
				DPFX(DPFPREP,7, "(%p) Cancelling Retry Timer", pEPD);
				if(CancelMyTimer(pEPD->RetryTimer, pEPD->RetryTimerUnique) == DPN_OK)
				{
					DECREMENT_EPD(pEPD, "UNLOCK (cancel retry timer)"); // SPLock not already held
				}
				else
				{
					DPFX(DPFPREP,7, "(%p) Cancelling Retry Timer Failed", pEPD);
				}
				pEPD->RetryTimer = 0;							// This will cause event to be ignored if it runs
				pFMD->ulFFlags &= ~(FFLAGS_RETRY_TIMER_SET);
			}

			pEPD->uiUnackedFrames--;							// track size of window
			ASSERT(pEPD->uiUnackedFrames <= MAX_RECEIVE_RANGE);
			pEPD->uiUnackedBytes -= pFMD->uiFrameLength;
			ASSERT(pEPD->uiUnackedBytes <= MAX_RECEIVE_RANGE * pSPD->uiFrameLength);

			pEPD->uiBytesAcked += pFMD->uiFrameLength;

			// If the frame has been queued for a retry, pull it off
			// NOTE: Copied retries of this frame may still be on the retry queue, inefficient to send them out, but okay
			if (pFMD->ulFFlags & FFLAGS_RETRY_QUEUED)
			{
				pFMD->blQLinkage.RemoveFromList();
				pFMD->ulFFlags &= ~(FFLAGS_RETRY_QUEUED);				// No longer on the retry queue

				ASSERT_MSD(pFMD->pMSD);
				pFMD->pMSD->uiFrameCount--; // Protected by EPLock, retries count against outstanding frame count
				DPFX(DPFPREP, DPF_FRAMECNT_LVL, "Retry frame reference decremented on ACK, pMSD[%p], framecount[%u]", pFMD->pMSD, pFMD->pMSD->uiFrameCount);

				DECREMENT_EPD(pEPD, "UNLOCK (Releasing Retry Frame)"); // SPLock not already held
				if (pFMD->CommandID == COMMAND_ID_COPIED_RETRY)
				{
					DECREMENT_EPD(pEPD, "UNLOCK (Copy Complete)"); // SPLock not already held
				}
				RELEASE_FMD(pFMD, "SP Submit");
				if (pEPD->blRetryQueue.IsEmpty())
				{
					pEPD->ulEPFlags &= ~(EPFLAGS_RETRIES_QUEUED);
				}
			}

			// One more send complete
			// We will come down this path for Reliables, KeepAlives, and Disconnects
			// Datagrams are completed upon send completion and do not wait for an ACK
			if((pFMD->CommandID != COMMAND_ID_SEND_DATAGRAM) && (pFMD->ulFFlags & (FFLAGS_END_OF_MESSAGE | FFLAGS_END_OF_STREAM)))
			{	
				pMSD = pFMD->pMSD;
				ASSERT_MSD(pMSD);

				DPFX(DPFPREP, DPF_FRAMECNT_LVL, "Flagging Complete, pMSD[%p], framecount[%u]", pMSD, pMSD->uiFrameCount);
				pMSD->ulMsgFlags2 |= MFLAGS_TWO_SEND_COMPLETE;	// Mark this complete

				if (pMSD->uiFrameCount == 0)					// Protected by EPLock
				{
					pEPD->ulEPFlags |= EPFLAGS_COMPLETE_SENDS;
				}
			}
			
			RELEASE_FMD(pFMD, "Send Window");					// Release reference for send window
			ack = TRUE;
		}
		else 
		{
			break;												// First unacked frame,  we can stop checking list
		}
	}					// WHILE (send window not empty)

	// At this point we have completed all of the frames ack'd by NRcv.  We would now like to re-transmit
	// any frames NACK'd by bitmask (and mark the ones ACK'd by bitmask). Now remember,  the first frame in
	// the window is automatically missing by the implied first zero-bit.
	//
	//	We will retransmit ALL frames that appear to be missing.  There may be a timer running on
	//	the first frame,  but only if we did not ACK any frames in the code above (ack == 0).
	//
	//	Hmmm,  if the partner has a fat pipeline we could see this bitmap lots of times.  We need to make
	//	sure we don't trigger a retransmission here a quarter-zillion times during the Ack latency period.
	//	To solve this we will only re-xmit the first time we see this bit.  After that,  we will have to
	//	wait around for the next RetryTimeout.  I think that's just the way its going to have to be.
	//
	//	OTHER THINGS WE KNOW:
	//
	//	There must be at least two frames remaining in the SendWindow. At minimum, first frame missing (always)
	//  and then at least one SACK'd frame after.
	//
	//	pLink = first queue element in SendWindow
	//	pFMD = first frame in SendWindow
	//
	//	We are still Holding EPD->EPLock.  It is okay to take SPD->SPLock while holding it.
	//
	//  One More Problem:  Since SP has changed its receive buffer logic mis-ordering of frames has become
	// quite commonplace.  This means that our assumptions about the state of the SendWindow are not necessarily true.
	// This means that frames NACKed by bitmask may have been acknowleged by a racing frame.  This means that the
	// SendWindow may not be in sync with the mask at all.  This means we need to synchronize the bitmask with the
	// actual send window.  This is done by right-shifting the mask for each frame that's been acknowleged since the
	// bitmask was minted before beginning the Selective Ack process.

	// NOTE: If everything was removed from the Send Window above, then pLink and pFMD will
	// be garbage.  In that case we would expect the mask to be NULL after adjusting below.

	if((RcvMaskLow | RcvMaskHigh)&&(pEPD->uiUnackedFrames > 1))
	{
		if(bNRcv != ((PDFRAME) pFMD->ImmediateData)->bSeq)
		{
			// This SACK frame must have been delivered late behind a frame ACKing more stuff.  We must get the mask in synch
			// with the current send window,  and then see if there is still anything this mask is NACKing

			// CODEWORK
			// MASONB: If this is a late frame, then the newer frame will be a superset of all the info in this one, and this one is
			// not useful and can be discarded.  

			DPFX(DPFPREP,7, "(%p) SACK frame out of sync with local state. (frame)bNRcv=%x, (local)nSeq=%x, ML=%x, MH=%x", pEPD, bNRcv, ((PDFRAME) pFMD->ImmediateData)->bSeq, RcvMaskLow, RcvMaskHigh);
		
			while((RcvMaskLow | RcvMaskHigh) && (bNRcv != ((PDFRAME) pFMD->ImmediateData)->bSeq) )
			{
				RIGHT_SHIFT_64(RcvMaskHigh, RcvMaskLow);		// 64 bit logical shift right
				bNRcv++;										// shift once for each frame prior to the window
			}

			DPFX(DPFPREP,7, "(%p) After adjusting, NRCV=%x, ML=%x, MH=%x", pEPD, bNRcv, RcvMaskLow, RcvMaskHigh);
		}
		
		if(ack == 0)
		{											
			// If we did NOT Ack a frame,  then retry timer is still running
			ASSERT(pFMD->ulFFlags & FFLAGS_RETRY_TIMER_SET);

			// We will reset the retry timer since we are retrying now

			DPFX(DPFPREP,7, "(%p) Resetting Retry Timer for %dms", pEPD, pEPD->uiRetryTimeout);
			if(CancelMyTimer(pEPD->RetryTimer, pEPD->RetryTimerUnique) != DPN_OK)
			{
				LOCK_EPD(pEPD, "LOCK (cant cancel retry)");		// Could not cancel- therefore we must balance RefCnt
			}
			SetMyTimer(pEPD->uiRetryTimeout, 100, RetryTimeout, (PVOID) pEPD, &pEPD->RetryTimer, &pEPD->RetryTimerUnique );
		}

		ASSERT(!(RcvMaskLow | RcvMaskHigh) || (pLink == pEPD->blSendWindow.GetNext()));

		// If pLink gets to the end of the list, the receive mask contained more bits than there were
		// items in the send window even after it was adjusted.  This means the packet was bogus, and
		// we have probably hosed our state already, but we will go ahead and attempt to safeguard
		// against having an AV by not entering the loop with a bad pFMD from hitting the end of the list.
		while((RcvMaskLow | RcvMaskHigh) && pLink != &pEPD->blSendWindow)
		{
			pFMD = CONTAINING_RECORD(pLink, FMD, blWindowLinkage);
			ASSERT_FMD(pFMD);

			if((pFMD->ulFFlags & (FFLAGS_NACK_RETRANSMIT_SENT | FFLAGS_RETRY_QUEUED)) == 0)
			{
				// Check time since last retry was sent
				// Don't retry if we *just* sent one...
				if(((tNow - pFMD->tTimestamp[pFMD->uiRetry]) > 0)&&(pFMD->uiRetry < (MAX_RETRIES - 1)))
				{	
					((PDFRAME) pFMD->ImmediateData)->bNRcv = pEPD->bNextReceive;	// Use up-to-date ACK info

					pFMD->uiRetry++;
					pFMD->ulFFlags |= FFLAGS_NACK_RETRANSMIT_SENT;
					pFMD->tTimestamp[pFMD->uiRetry] = tNow;
					
					// Unreliable frame!
					if(pFMD->CommandID == COMMAND_ID_SEND_DATAGRAM)
					{
						// When an unreliable frame is NACKed we will not retransmit the data.  We will instead send
						// a cancel mask telling the receiver to ignore this sequence number.

						DPFX(DPFPREP,7, "(%p) SELECTIVE RETRY REQUESTED for UNRELIABLE FRAME Seq=%x", pEPD, ((PDFRAME) pFMD->ImmediateData)->bSeq);

						pEPD->uiUnackedBytes -= pFMD->uiFrameLength;

						if(pFMD->uiRetry == 1)
						{
							pEPD->uiDatagramFramesDropped++;	// Only count a datagram drop on the first occurance
							pEPD->uiDatagramBytesDropped += (pFMD->uiFrameLength - pFMD->uiImmediateLength); // Only user bytes
							EndPointDroppedFrame(pEPD, tNow);
						}

						delta = (BYTE) (pEPD->bNextSend - ((PDFRAME) pFMD->ImmediateData)->bSeq); // Diff between next send and this send.

						ASSERT(delta != 0);
						ASSERT(delta < (MAX_RECEIVE_RANGE + 1));

						if(delta < 33)
						{
							pEPD->ulSendMask |= (1 << (delta - 1));
						}
						else
						{
							pEPD->ulSendMask2 |= (1 << (delta - 33));
						}

						pFMD->uiFrameLength = 0;			// Frame has been credited to the send window, don't want to credit again on ACK

						if((pEPD->ulEPFlags & EPFLAGS_DELAYED_SENDMASK)==0)
						{
							pEPD->ulEPFlags |= EPFLAGS_DELAYED_SENDMASK;

							if(pEPD->DelayedMaskTimer == 0)
							{
								DPFX(DPFPREP,7, "(%p) Setting Delayed Ack Timer", pEPD);
								SetMyTimer(DELAYED_SEND_TIMEOUT, 0, DelayedAckTimeout, (PVOID) pEPD, &pEPD->DelayedMaskTimer, &pEPD->DelayedMaskTimerUnique);
								LOCK_EPD(pEPD, "LOCK (Delayed Mask Timer)");
							}
						}
					}

					// Reliable Frame -- Issue a retry of frame
					else 
					{		
						retransmit = TRUE;
						
						pEPD->uiGuaranteedFramesDropped++;													// Keep count of lost frames
						pEPD->uiGuaranteedBytesDropped += (pFMD->uiFrameLength - pFMD->uiImmediateLength);	// Keep count of lost frames
				
						if(pFMD->bSubmitted)
						{
							// In the heat of battle,  its possible that this FMD has not completed from the last
							// send.  In this case,  we will make a temporary copy of the FMD and submit the clone.
							// We will mark the clone as a RETRY_COPY which will be immediately freed upon completion,
							// and we will leave the retry timestamp in the original FMD.

							DPFX(DPFPREP,7, "(%p) SELECTIVE RETRY while FMD busy; Seq=0x%x", pEPD, ((PDFRAME) pFMD->ImmediateData)->bSeq);
							pFMD = CopyFMD(pFMD, pEPD);
						}
						else 
						{
							DPFX(DPFPREP,7, "(%p) SELECTIVE RETRY Seq=0x%x,  FMD=0x%p", pEPD, ((PDFRAME) pFMD->ImmediateData)->bSeq, pFMD);
							LOCK_FMD(pFMD, "SP Submit");						// Make sure this frame survives until transmitted
						}

						// Only call this once per NACK received
						if(logged_drop == FALSE)
						{					
							EndPointDroppedFrame(pEPD, tNow);
							logged_drop = TRUE;
						}

						//	EPD->EPLock is already held so we can slam frame right into rexmit queue

						// If CopyFMD failed we won't have an FMD here
						if(pFMD)
						{								
							DPFX(DPFPREP,7, "(%p) Queueing frame on retry queue FMD[%p]", pEPD, pFMD);
							LOCK_EPD(pEPD, "LOCK (selective retry frame)");
							pEPD->ulEPFlags |= EPFLAGS_RETRIES_QUEUED;
							pFMD->ulFFlags |= FFLAGS_RETRY_QUEUED;
							ASSERT_MSD(pFMD->pMSD);
							pFMD->pMSD->uiFrameCount++; // Protected by EPLock, retries prevent completion until they complete
							DPFX(DPFPREP, DPF_FRAMECNT_LVL, "Frame count incremented on NACK retry, pMSD[%p], framecount[%u]", pFMD->pMSD, pFMD->pMSD->uiFrameCount);
							ASSERT(pFMD->blQLinkage.IsEmpty());
							pFMD->blQLinkage.InsertBefore( &pEPD->blRetryQueue);		// Place frame on Send queue
						}
					}
				}
				else 
				{
					// Last retry was less then 1 ms past -- we will ignore this for now
					DPFX(DPFPREP,7, "(%p) ***BLOWING OFF NACK***", pEPD);

					// CODEWORK: OR retries exhausted.  We should either let only RetryTimeout do all of this work, or make
					// this code drop the link in this case.
				}
			}

			pLink = pLink->GetNext();							// Advance pLink to next frame in SendWindow

			// Move through bitmask and SendWindow until find missing frame
			while(RcvMaskLow & 1)
			{								
				pLink = pLink->GetNext();
				RIGHT_SHIFT_64(RcvMaskHigh, RcvMaskLow);		// 64 bit logical shift right
			}
			RIGHT_SHIFT_64(RcvMaskHigh, RcvMaskLow);			// 64 bit logical shift right, skip the zero
		}					// END WHILE (WORK MASKS NON-ZERO)


		if(retransmit)
		{
			pEPD->ulEPFlags &= ~(EPFLAGS_DELAY_ACKNOWLEDGE);	// No longer waiting to send Ack info

			// Stop delayed ack timer
			if(pEPD->DelayedAckTimer != 0)
			{						
				DPFX(DPFPREP,7, "(%p) Cancelling Delayed Ack Timer", pEPD);
				if(CancelMyTimer(pEPD->DelayedAckTimer, pEPD->DelayedAckTimerUnique) == DPN_OK)
				{
					DECREMENT_EPD(pEPD, "UNLOCK (cancel DelayAckTimer)"); // SPLock not already held
					pEPD->DelayedAckTimer = 0;
				}
				else
				{
					DPFX(DPFPREP,7, "(%p) Cancelling Delayed Ack Timer Failed", pEPD);
				}
			}

			if((pEPD->ulEPFlags & EPFLAGS_IN_PIPELINE)==0)
			{
				DPFX(DPFPREP,7, "(%p) Scheduling Send", pEPD);
				pEPD->ulEPFlags |= EPFLAGS_IN_PIPELINE;
				LOCK_EPD(pEPD, "LOCK (pipeline)");
				ScheduleTimerThread(ScheduledSend, pEPD, &pEPD->SendTimer, &pEPD->SendTimerUnique);
			}
		}
	}


	// If we acked a frame above and there is more data outstanding then we may need to start a new Retry timer.
	//
	// Of course,  we want to set the timer on whatever frame is the first in the SendWindow.

	if( (pEPD->uiUnackedFrames > 0) && (pEPD->RetryTimer == 0)) 
	{
		pFMD = CONTAINING_RECORD(pEPD->blSendWindow.GetNext(), FMD, blWindowLinkage);
		ASSERT_FMD(pFMD);		

		tDelay = tNow - pFMD->tTimestamp[pFMD->uiRetry];	// How long has this frame been enroute?
		tDelay = (tDelay > pEPD->uiRetryTimeout) ? 0 : pEPD->uiRetryTimeout - tDelay; // Calc time remaining for frame

		DPFX(DPFPREP,7, "(%p) Setting Retry Timer for %dms on Seq=[%x], FMD=[%p]", pEPD, tDelay, ((PDFRAME) pFMD->ImmediateData)->bSeq, pFMD);
		ASSERT(ack);
		LOCK_EPD(pEPD, "LOCK (retry timer)");						// bump RefCnt for timer
		SetMyTimer(tDelay, 0, RetryTimeout, (PVOID) pEPD, &pEPD->RetryTimer, &pEPD->RetryTimerUnique );
		pFMD->ulFFlags |= FFLAGS_RETRY_TIMER_SET;
	}

	// See if we need to unblock this session

	if((pEPD->uiUnackedFrames < pEPD->uiWindowF) && (pEPD->uiUnackedBytes < pEPD->uiWindowB))
	{
		pEPD->ulEPFlags |= EPFLAGS_STREAM_UNBLOCKED;
		if((pEPD->ulEPFlags & EPFLAGS_SDATA_READY) && ((pEPD->ulEPFlags & EPFLAGS_IN_PIPELINE)==0))
		{
			DPFX(DPFPREP,7, "(%p) UpdateXmit: ReEntering Pipeline", pEPD);

			pEPD->ulEPFlags |= EPFLAGS_IN_PIPELINE;
			LOCK_EPD(pEPD, "LOCK (pipeline)");
			ScheduleTimerThread(ScheduledSend, pEPD, &pEPD->SendTimer, &pEPD->SendTimerUnique);
		}
	}
}


/*
**		Complete Datagram Frame
**
**		A datagram frame has been successfully transmitted.  Free the descriptor and
**	see if the entire send is ready to complete.  Reliable sends are not freed until
**	they are acknowledged,  so they must be handled elsewhere.
**
**		**  This is called with the CommandLock in MSD held, returns with it released **
*/

#undef DPF_MODNAME
#define DPF_MODNAME "CompleteDatagramSend"

VOID CompleteDatagramSend(PSPD pSPD, PMSD pMSD, HRESULT hr)
{
	PEPD	pEPD = pMSD->pEPD;
	ASSERT_EPD(pEPD);
	
	ASSERT(pMSD->blFrameList.IsEmpty());				// Was this the last frame in the message?
	ASSERT(pMSD->uiFrameCount == 0);
	ASSERT((pMSD->ulMsgFlags2 & MFLAGS_TWO_ENQUEUED)==0);
	AssertCriticalSectionIsTakenByThisThread(&pMSD->CommandLock, TRUE);

	Lock(&pEPD->EPLock); // Need EPLock to change MFLAGS_TWO

	DPFX(DPFPREP,7, "(%p) DG MESSAGE COMPLETE pMSD=%p", pEPD, pMSD);
	
	pMSD->ulMsgFlags2 |= MFLAGS_TWO_SEND_COMPLETE;				// Mark this complete
	
	if(pMSD->TimeoutTimer != NULL)
	{
		DPFX(DPFPREP,7, "(%p) Cancelling Timeout Timer", pEPD);
		if(CancelMyTimer(pMSD->TimeoutTimer, pMSD->TimeoutTimerUnique) == DPN_OK)
		{
			DECREMENT_MSD(pMSD, "Send Timeout Timer");
		}
		else
		{
			DPFX(DPFPREP,7, "(%p) Cancelling Timeout Timer Failed", pEPD);
		}
		pMSD->TimeoutTimer = NULL;
	}

#ifdef DEBUG
	Lock(&pSPD->SPLock);
	if(pMSD->ulMsgFlags1 & MFLAGS_ONE_ON_GLOBAL_LIST)
	{
		pMSD->blSPLinkage.RemoveFromList();						// Remove MSD from master command list
		pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_ON_GLOBAL_LIST);			
	}
	Unlock(&pSPD->SPLock);

	ASSERT(!(pMSD->ulMsgFlags1 & MFLAGS_ONE_COMPLETED_TO_CORE));
	pMSD->ulMsgFlags1 |= MFLAGS_ONE_COMPLETED_TO_CORE;
	pMSD->CallStackCoreCompletion.NoteCurrentCallStack();
#endif

	if(hr == DPNERR_USERCANCEL)
	{
		if(pMSD->ulMsgFlags1 & MFLAGS_ONE_TIMEDOUT)
		{
			hr = DPNERR_TIMEDOUT;
		}
	}

	pMSD->blQLinkage.RemoveFromList();							// Remove from CompleteSendQueue

	Unlock(&pEPD->EPLock);

	Unlock(&pMSD->CommandLock); // Leave the lock before calling into another layer

	DPFX(DPFPREP,DPF_CALLOUT_LVL, "(%p) Calling Core->CompleteSend for NG, hr[%x], pMSD[%p], Core Context[%p]", pEPD, hr, pMSD, pMSD->Context);
	pSPD->pPData->pfVtbl->CompleteSend(pSPD->pPData->Parent, pMSD->Context, hr);

	// Release the final reference on the MSD AFTER indicating to the Core
	Lock(&pMSD->CommandLock);

	// Cancels are allowed to come in until the Completion has returned and they will expect a valid pMSD->pEPD
	Lock(&pEPD->EPLock);
	pMSD->pEPD = NULL;   // We shouldn't be using this after this
	RELEASE_EPD(pEPD, "UNLOCK (Complete Send Cmd - DG)");	// Every send command bumps the refcnt, releases EPLock

	RELEASE_MSD(pMSD, "Release On Complete");			// Return resources,  including all frames, release MSDLock
}

/*
**		Complete Reliable Send
**
**		A reliable send has completed processing.  Indicate this
**	to the user and free the resources.  This will either take
**	place on a cancel,  error,  or when ALL of the message's frames
**	have been acknowledged.
**
**		**  This is called with CommandLock in MSD held, and exits with it released  **
*/

#undef DPF_MODNAME
#define DPF_MODNAME "CompleteReliableSend"

VOID
CompleteReliableSend(PSPD pSPD, PMSD pMSD, HRESULT hr)
{
	PEPD	pEPD = pMSD->pEPD;
	ASSERT_EPD(pEPD);
	AssertCriticalSectionIsTakenByThisThread(&pMSD->CommandLock, TRUE);

	ASSERT(pMSD->uiFrameCount == 0);

	// NORMAL SEND COMPLETES
	if(pMSD->CommandID == COMMAND_ID_SEND_RELIABLE)
	{	
		DPFX(DPFPREP,7, "(%p) Reliable Send Complete pMSD=%p", pEPD, pMSD);

		ASSERT((pMSD->ulMsgFlags2 & MFLAGS_TWO_ENQUEUED)==0);

		if(pMSD->TimeoutTimer != NULL)
		{
			DPFX(DPFPREP,7, "(%p) Cancelling Timeout Timer, pMSD[%p]", pEPD, pMSD);
			if(CancelMyTimer(pMSD->TimeoutTimer, pMSD->TimeoutTimerUnique) == DPN_OK)
			{
				DECREMENT_MSD(pMSD, "Send Timeout Timer");
			}
			else
			{
				DPFX(DPFPREP,7, "(%p) Cancelling Timeout Timer Failed, pMSD[%p]", pEPD, pMSD);
			}
			pMSD->TimeoutTimer = NULL;
		}

		// ACK code in UpdateXmitState flags this as COMPLETE when the last of the message is received.

#ifdef DEBUG
		Lock(&pSPD->SPLock);
		if(pMSD->ulMsgFlags1 & MFLAGS_ONE_ON_GLOBAL_LIST)
		{
			pMSD->blSPLinkage.RemoveFromList();					// Remove MSD from master command list
			pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_ON_GLOBAL_LIST);			
		}
		Unlock(&pSPD->SPLock);

		ASSERT(!(pMSD->ulMsgFlags1 & MFLAGS_ONE_COMPLETED_TO_CORE));
		pMSD->ulMsgFlags1 |= MFLAGS_ONE_COMPLETED_TO_CORE;
		pMSD->CallStackCoreCompletion.NoteCurrentCallStack();
#endif

		Unlock(&pMSD->CommandLock); // Leave the lock before calling into another layer

		DPFX(DPFPREP,DPF_CALLOUT_LVL, "(%p) Calling Core->CompleteSend for G, hr[%x], pMSD[%p], Core Context[%p]", pEPD, hr, pMSD, pMSD->Context);
		pSPD->pPData->pfVtbl->CompleteSend(pSPD->pPData->Parent, pMSD->Context, hr);

		// Release the final reference on the MSD AFTER indicating to the Core
		Lock(&pMSD->CommandLock);

		// Cancels are allowed to come in until the Completion has returned and they will expect a valid pMSD->pEPD
		Lock(&pEPD->EPLock);
		pMSD->pEPD = NULL;   // We shouldn't be using this after this
		RELEASE_EPD(pEPD, "UNLOCK (Complete Send Cmd - Rely)");	// release hold on EPD for this send, releases EPLock

		RELEASE_MSD(pMSD, "Release On Complete");				// Return resources,  including all frames
	}

	// END OF STREAM -OR- KEEPALIVE COMPLETES
	else 
	{												
		// Partner has just ACKed our End Of Stream frame.  Doesn't necessarily mean we are done.
		// Both sides need to send (and have acknowledged) EOS frames before the link can be
		// dropped.  Therefore,  we check to see if we have seen our partner's DISC before
		// releasing the RefCnt on EPD allowing the link to drop.  If partner was idle, his EOS
		// might be the same frame which just ack'd us.  Luckily,  this code will run first so we
		// will not have noticed his EOS yet,  and we will not drop right here.

		ASSERT(pMSD->ulMsgFlags2 & (MFLAGS_TWO_END_OF_STREAM | MFLAGS_TWO_KEEPALIVE));

		Lock(&pEPD->EPLock);
		
		if(pMSD->ulMsgFlags2 & MFLAGS_TWO_KEEPALIVE)
		{
			DPFX(DPFPREP,7, "(%p) Keepalive Complete, pMSD[%p]", pEPD, pMSD);
			
			pEPD->ulEPFlags &= ~(EPFLAGS_KEEPALIVE_RUNNING);
			ASSERT(!(pMSD->ulMsgFlags1 & MFLAGS_ONE_ON_GLOBAL_LIST));
			
			pMSD->pEPD = NULL;   // We shouldn't be using this after this
			RELEASE_EPD(pEPD, "UNLOCK (rel KeepAlive)");	// Release ref for this MSD, releases EPLock
			RELEASE_MSD(pMSD, "Release On Complete");		// Done with this message
		}
		else 
		{
			DPFX(DPFPREP,7, "(%p) EndOfStream Complete, pMSD[%p]", pEPD, pMSD);

			pEPD->ulEPFlags |= EPFLAGS_DISCONNECT_ACKED;

			if(pEPD->ulEPFlags & EPFLAGS_ACKED_DISCONNECT)
			{
				DPFX(DPFPREP,7, "(%p) EOS has been ACK'd and we've ACK'd partner's EOS, dropping link", pEPD);

				// We are clear to blow this thing down
				Unlock(&pMSD->CommandLock);

				// This will set our state to terminating
				DropLink(pEPD); // This unlocks the EPLock
			}
			else 
			{
				// Our Disconnect frame has been acknowledged but we must wait until we see his DISC before
				// completing this command and dropping the connection. 
				//
				//	We will use the pCommand pointer to track this disconnect command until we see partner's DISC frame
				//
				//	ALSO,  since our engine has now shutdown,  we might wait forever now for the final DISC from partner
				// if he crashes before transmitting it.  One final safeguard here is to set a timer which will make sure
				// this doesnt happen. * NOTE * no timer is actually being set here, we're depending on the keepalive
				// timeout, see EndPointBackgroundProcess.

				DPFX(DPFPREP,7, "(%p) EOS has been ACK'd, but we're still ACK'ing partner's disconnect", pEPD);
				
				ASSERT(pEPD->blHighPriSendQ.IsEmpty());
				ASSERT(pEPD->blNormPriSendQ.IsEmpty());
				ASSERT(pEPD->blLowPriSendQ.IsEmpty());

				// It is possible that something was already in the process of timing out when the disconnect
				// operation starts such that AbortSends gets called and clears this.
				ASSERT(pEPD->pCommand == NULL || pEPD->pCommand == pMSD);
					
				Unlock(&pEPD->EPLock);

				Unlock(&pMSD->CommandLock);
			}
		}
	}
}


/*
**		Build Data Frame
**
**		Setup the actual network packet header for transmission with our current link state info (Seq, NRcv).
**
**	** ENTERED AND EXITS WITH EPD->EPLOCK HELD **
*/

#undef DPF_MODNAME
#define DPF_MODNAME "BuildDataFrame"

VOID	BuildDataFrame(PEPD pEPD, PFMD pFMD, DWORD tNow)
{
	PDFBIG		pFrame;
	UINT		index = 0;

	AssertCriticalSectionIsTakenByThisThread(&pEPD->EPLock, TRUE);

	pFrame = (PDFBIG) pFMD->ImmediateData;
	pFMD->SendDataBlock.hEndpoint = pEPD->hEndPt;
	pFMD->uiRetry = 0;

	pFrame->bCommand = pFMD->bPacketFlags;
	pFrame->bControl = 0;	// this sets retry count to zero as well as clearing flags
	
	if (pFMD->ulFFlags & FFLAGS_END_OF_STREAM) 
	{
		pFrame->bControl |= (PACKET_CONTROL_END_STREAM | PACKET_CONTROL_CORRELATE);
	}

	//  See if we are desiring an immediate response

	if(pFMD->ulFFlags & FFLAGS_CHECKPOINT)
	{
		pFrame->bCommand |= PACKET_COMMAND_POLL;
	}

	pFrame->bSeq = pEPD->bNextSend++;
	pFrame->bNRcv = pEPD->bNextReceive;		// Acknowledges all previous frames

	DPFX(DPFPREP,7, "(%p) N(S) incremented to %x", pEPD, pEPD->bNextSend);

	//	Piggyback NACK notes
	//
	//		Since the SP is now frequently mis-ordering frames we are enforcing a back-off period before transmitting a NACK after
	// a packet is received out of order. Therefore we have the Delayed Mask Timer which stalls the dedicated NACK.  Now we must
	// also make sure that the new NACK info doesn't get piggybacked too soon.  Therefore we will test the tReceiveMaskDelta timestamp
	// before including piggyback NACK info here,  and make sure that the mask is at least 5ms old.

	if(pEPD->ulEPFlags & EPFLAGS_DELAYED_NACK)
	{
		if((tNow - pEPD->tReceiveMaskDelta) > 4)
		{
			DPFX(DPFPREP,7, "(%p) Installing NACK in DFRAME Seq=%x, NRcv=%x Low=%x High=%x", pEPD, pFrame->bSeq, pFrame->bNRcv, pEPD->ulReceiveMask, pEPD->ulReceiveMask2);
			if(pEPD->ulReceiveMask)
			{
				pFrame->rgMask[index++] = pEPD->ulReceiveMask;
				pFrame->bControl |= PACKET_CONTROL_SACK_MASK1;
			}
			if(pEPD->ulReceiveMask2)
			{
				pFrame->rgMask[index++] = pEPD->ulReceiveMask2;
				pFrame->bControl |= PACKET_CONTROL_SACK_MASK2;
			}

			pEPD->ulEPFlags &= ~(EPFLAGS_DELAYED_NACK);
		}
		else
		{
			DPFX(DPFPREP,7, "(%p) DECLINING TO PIGGYBACK NACK WITH SMALL TIME DELTA", pEPD);
		}
	}
	if(pEPD->ulEPFlags & EPFLAGS_DELAYED_SENDMASK)
	{
		DPFX(DPFPREP,7, "(%p) Installing SENDMASK in DFRAME Seq=%x, Low=%x High=%x", pEPD, pFrame->bSeq, pEPD->ulSendMask, pEPD->ulSendMask2);
		if(pEPD->ulSendMask)
		{
			pFrame->rgMask[index++] = pEPD->ulSendMask;
			pFrame->bControl |= PACKET_CONTROL_SEND_MASK1;
			pEPD->ulSendMask = 0;
		}
		if(pEPD->ulSendMask2)
		{
			pFrame->rgMask[index++] = pEPD->ulSendMask2;
			pFrame->bControl |= PACKET_CONTROL_SEND_MASK2;
			pEPD->ulSendMask2 = 0;
		}
		pEPD->ulEPFlags &= ~(EPFLAGS_DELAYED_SENDMASK);
	}
	
	pFMD->uiImmediateLength = sizeof(DFRAME) + (index * sizeof(ULONG));
	
	pFMD->tTimestamp[0] = tNow;

	pEPD->ulEPFlags &= ~(EPFLAGS_DELAY_ACKNOWLEDGE);	// No longer waiting to send Ack info

	// Stop delayed mask timer
	if((pEPD->DelayedMaskTimer != 0)&&((pEPD->ulEPFlags & EPFLAGS_DELAYED_NACK)==0))
	{
		DPFX(DPFPREP,7, "(%p) Cancelling Delayed Mask Timer", pEPD);
		if(CancelMyTimer(pEPD->DelayedMaskTimer, pEPD->DelayedMaskTimerUnique) == DPN_OK)
		{
			DECREMENT_EPD(pEPD, "UNLOCK (cancel DelayedMaskTimer)"); // SPLock not already held
			pEPD->DelayedMaskTimer = 0;
		}
		else
		{
			DPFX(DPFPREP,7, "(%p) Cancelling Delayed Mask Timer Failed", pEPD);
		}
	}
	
	// Stop delayed ack timer
	if(pEPD->DelayedAckTimer != 0)
	{					
		DPFX(DPFPREP,7, "(%p) Cancelling Delayed Ack Timer", pEPD);
		if(CancelMyTimer(pEPD->DelayedAckTimer, pEPD->DelayedAckTimerUnique) == DPN_OK)
		{
			DECREMENT_EPD(pEPD, "UNLOCK (cancel DelayedAckTimer)"); // SPLock not already held
			pEPD->DelayedAckTimer = 0;
		}
		else
		{
			DPFX(DPFPREP,7, "(%p) Cancelling Delayed Ack Timer Failed", pEPD);
		}
	}
	
	pFMD->uiFrameLength += pFMD->uiImmediateLength;
}

/*
**		Build Retry Frame
**
**		Reinitialize those fields in the packet header that need to be recalculated for a retransmission.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "BuildRetryFrame"

VOID
BuildRetryFrame(PEPD pEPD, PFMD pFMD)
{
	PDFMASKS	pMasks;
	UINT		index = 0;

	AssertCriticalSectionIsTakenByThisThread(&pEPD->EPLock, TRUE);

	((PDFRAME) pFMD->ImmediateData)->bNRcv = pEPD->bNextReceive;		// Use up-to-date ACK info
	
	((PDFRAME) pFMD->ImmediateData)->bControl &= PACKET_CONTROL_END_STREAM;	// Preserve EOS bit from original
	((PDFRAME) pFMD->ImmediateData)->bControl |= PACKET_CONTROL_RETRY;		// clamp retry value at size of field in packet

	pMasks = (PDFMASKS) (pFMD->ImmediateData + sizeof(DFRAME));			// pointer to mask space after protocol header

	if(pEPD->ulEPFlags & EPFLAGS_DELAYED_NACK)
	{
		if(pEPD->ulReceiveMask)
		{
			pMasks->rgMask[index++] = pEPD->ulReceiveMask;
			((PDFRAME) pFMD->ImmediateData)->bControl |= PACKET_CONTROL_SACK_MASK1;
		}
		if(pEPD->ulReceiveMask2)
		{
			pMasks->rgMask[index++] = pEPD->ulReceiveMask2;
			((PDFRAME) pFMD->ImmediateData)->bControl |= PACKET_CONTROL_SACK_MASK2;
		}

		pEPD->ulEPFlags &= ~(EPFLAGS_DELAYED_NACK);
	}

	//	MUST NOT transmit the SendMasks with a retry because they are based on the CURRENT bNextSend value which is not
	// the N(S) that appears in this frame.  We could theoretically shift the mask to agree with this frame's sequence
	// number,  but that might shift relevent bits out of the mask.  Best thing to do is to let the next in-order send carry
	// the bit-mask or else wait for the timer to fire and send a dedicated packet.
	
	//	PLEASE NOTE -- Although we may change the size of the immediate data below we did not update the FMD->uiFrameLength
	// field.  This field is used to credit the send window when the frame is acknowledged,  and we would be wise to credit
	// the same value that we debited back when this frame was first sent.  We could adjust the debt now to reflect the new
	// size of the frame, but seriously, why bother?
	
	pFMD->uiImmediateLength = sizeof(DFRAME) + (index * 4);
	
	pEPD->ulEPFlags &= ~(EPFLAGS_DELAY_ACKNOWLEDGE);	// No longer waiting to send Ack info

	// Stop delayed ack timer
	if(pEPD->DelayedAckTimer != 0)
	{						
		DPFX(DPFPREP,7, "(%p) Cancelling Delayed Ack Timer", pEPD);
		if(CancelMyTimer(pEPD->DelayedAckTimer, pEPD->DelayedAckTimerUnique) == DPN_OK)
		{
			DECREMENT_EPD(pEPD, "UNLOCK (cancel DelayedAckTimer)");
			pEPD->DelayedAckTimer = 0;
		}
		else
		{
			DPFX(DPFPREP,7, "(%p) Cancelling Delayed Ack Timer Failed", pEPD);
		}
	}
	// Stop delayed mask timer
	if(((pEPD->ulEPFlags & EPFLAGS_DELAYED_SENDMASK)==0)&&(pEPD->DelayedMaskTimer != 0))
	{	
		DPFX(DPFPREP,7, "(%p) Cancelling Delayed Mask Timer", pEPD);
		if(CancelMyTimer(pEPD->DelayedMaskTimer, pEPD->DelayedMaskTimerUnique) == DPN_OK)
		{
			DECREMENT_EPD(pEPD, "UNLOCK (cancel DelayedMaskTimer)"); // SPLock not already held
			pEPD->DelayedMaskTimer = 0;
		}
		else
		{
			DPFX(DPFPREP,7, "(%p) Cancelling Delayed Mask Timer Failed", pEPD);
		}
	}
}

/*
**			Service Command Traffic
**
**		Presently this transmits all CFrames and Datagrams queued to the specific
**	Service Provider.  We may want to split out the datagrams from this so that
**	C frames can be given increased send priority but not datagrams.  With this
**	implementation DGs will get inserted into reliable streams along with Cframes.
**	This may or may not be what we want to do...
**
**	WE ENTER AND EXIT WITH SPD->SENDLOCK HELD,  although we release it during actual
**	calls to the SP.
*/


#undef DPF_MODNAME
#define DPF_MODNAME "ServiceCmdTraffic"

VOID ServiceCmdTraffic(PSPD pSPD)
{
	CBilink	*pFLink;
	PFMD	pFMD;
	HRESULT	hr;

	AssertCriticalSectionIsTakenByThisThread(&pSPD->SPLock, TRUE);

	// WHILE there are frames ready to send
	while((pFLink = pSPD->blSendQueue.GetNext()) != &pSPD->blSendQueue)
	{	
		pFLink->RemoveFromList();												// Remove frame from queue

		pFMD = CONTAINING_RECORD(pFLink,  FMD,  blQLinkage);		// get ptr to frame structure

		ASSERT_FMD(pFMD);

		// Place frame on pending queue before making call in case it completes really fast

		ASSERT(!pFMD->bSubmitted);
		pFMD->bSubmitted = TRUE;
		ASSERT(pFMD->blQLinkage.IsEmpty());
		pFMD->blQLinkage.InsertBefore( &pSPD->blPendingQueue);		// Place frame on pending queue
		Unlock(&pSPD->SPLock);

		DPFX(DPFPREP,DPF_CALLOUT_LVL, "(%p) Calling SP->SendData for FMD[%p], pSPD[%p]", pFMD->pEPD, pFMD, pSPD);
/*send*/if((hr = IDP8ServiceProvider_SendData(pSPD->IISPIntf, &pFMD->SendDataBlock)) != DPNERR_PENDING)
		{
			DPFX(DPFPREP,DPF_CALLOUT_LVL, "(%p) Calling our own CommandComplete since SP did not return DPNERR_PENDING - hr[%x], pSPD[%p]", pFMD->pEPD, hr, pSPD);
			(void) DNSP_CommandComplete((IDP8SPCallback *) pSPD, NULL, hr, (PVOID) pFMD);
		}

		Lock(&pSPD->SPLock);
	}	// While SENDs are on QUEUE
}

/*
**		Run Send Thread
**
**		There is work for this SP's send thread.  Keep running until
**	there is no more work to do.
**
**		Who gets first priority, DG or Seq traffic?  I will  say DG b/c its
**	advertised as lowest overhead...
**
**		Datagram packets get Queued on the SP when they are ready to ship.
**	Reliable packets are queued on the EPD.  Therefore,  we will queue the
**	actual EPD on the SPD when they have reliable traffic to send,  and then
**	we will service individual EPDs from this loop.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "RunSendThread"

VOID RunSendThread(PVOID uID, UINT Unique, PVOID pvUser)
{
	PSPD	pSPD = (PSPD) pvUser;
	ASSERT_SPD(pSPD);

	DPFX(DPFPREP,7, "Send Thread Runs pSPD[%p]", pSPD);

	Lock(&pSPD->SPLock);

	if(!pSPD->blSendQueue.IsEmpty())
	{
		ServiceCmdTraffic(pSPD);
	}

	pSPD->ulSPFlags &= ~(SPFLAGS_SEND_THREAD_SCHEDULED);
	pSPD->SendHandle = NULL;

	Unlock(&pSPD->SPLock);
}

/*
**		Scheduled Send
**
**		If this EPD is still unentitled to send, start draining frames.  Otherwise transition
**	link to IDLE state.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "ScheduledSend"

VOID CALLBACK
ScheduledSend(PVOID uID, UINT Unique, PVOID dwUser)
{
	PEPD	pEPD = (PEPD) dwUser;
	PSPD	pSPD = pEPD->pSPD;

	ASSERT_EPD(pEPD);
	ASSERT_SPD(pSPD);

	Lock(&pEPD->EPLock);
	
	pEPD->SendTimer = 0;

	DPFX(DPFPREP,7, "(%p) Scheduled Send Fires", pEPD);

	ASSERT(pEPD->ulEPFlags & EPFLAGS_IN_PIPELINE);

	// Test that all three flags are set before starting to transmit

	if( (pEPD->ulEPFlags & EPFLAGS_STATE_CONNECTED) && (
			((pEPD->ulEPFlags & (EPFLAGS_STREAM_UNBLOCKED | EPFLAGS_SDATA_READY)) == (EPFLAGS_STREAM_UNBLOCKED | EPFLAGS_SDATA_READY))
			|| (pEPD->ulEPFlags & EPFLAGS_RETRIES_QUEUED))) 
	{
		ServiceEPD(pEPD->pSPD, pEPD); // releases EPLock
	}
	else
	{
		DPFX(DPFPREP,7, "(%p) Session leaving pipeline", pEPD);
		
		pEPD->ulEPFlags &= ~(EPFLAGS_IN_PIPELINE);
		
		RELEASE_EPD(pEPD, "UNLOCK (leaving pipeline, SchedSend done)"); // releases EPLock
	}
}

/*
**		Service EndPointDescriptor
**
**		This includes reliable,  datagram,  and re-transmit
**	frames.  Retransmissions are ALWAYS transmitted first,  regardless of the orginal message's
**	priority.  After that datagrams and reliable messages are taken in priority order, in FIFO
**	order within a priority class.
**
**		The number of frames drained depends upon the measured link speed.  If the burst gap is
**	larger then 10ms we will only send one frame,  and then scale down the burst gap according
**	to the fraction of the available byte-window that was used.
**
**	CODEWORK->  if they send < 1/8th of the burst allowance,  maybe let them send another frame
**
**		If the burst gap is small (<10ms) then we will routinely allow multiple sends per burst.
**	If the burst is not filled precisely we can remember the difference and either credit or debit
**	the next burst accordingly.  Now, we dont want to credit too much or we start to mess up the
**	throttle concept of spreading out the load.  But we can still debit for overloads.  Here is
**	what we'd like to do:  If we have almost filled the burst,  do not send another max size frame
**	and create a really big debit.  Instead,  credit the leftover and maybe an extra will fit next time.
**	Otherwise,  allow us to send into debt (say up to 25% over).
**
**
**		If the pipeline goes idle or the stream gets blocked will we still schedule the next
**	send.  This way if we unblock or un-idle before the gap has expired we will not get to cheat
**	and defeat the gap.  The shell routine above us (ScheduledSend) will take care of removing us
**	from the pipeline if the next burst gets scheduled and we are still not ready to send.
**
**
**	** CALLED WITH EPD->EPLock HELD;  Returns with EPLock RELEASED **
*/

#undef DPF_MODNAME
#define DPF_MODNAME "ServiceEPD"

VOID ServiceEPD(PSPD pSPD, PEPD pEPD)
{
	PMSD		pMSD;
	PFMD		pFMD;
	CBilink		*pLink, *pFLink;
	INT			iBurstAvail;
	INT			iBurstSent = 0;
	INT			iDelta;
	INT			iHalf, iQuarter, iEighth;
	UINT		uiFramesSent = 0;
	UINT		uiUseBurstGap;
	HRESULT		hr;
	DWORD		tNow = GETTIMESTAMP();


	/*
	** 		Now we will drain reliable traffic from EPDs on the pipeline list
	*/

	// The caller should have checked this
	ASSERT( pEPD->ulEPFlags & EPFLAGS_STATE_CONNECTED );

	// Burst Credit can either be positive or negative depending upon how much of our last transmit slice we used

	if(pEPD->uiBurstGap == 0)
	{
		iBurstAvail = 0x7FFFFFFF;							// If no packet gap enforced,  allow unlimited transmission
		uiUseBurstGap = 0;
		DPFX(DPFPREP,7, "(%p) BEGIN UNLIMITED BURST", pEPD);
	}
	else
	{
		iBurstAvail = pSPD->uiFrameLength + pEPD->iBurstCredit;
		uiUseBurstGap = pEPD->uiBurstGap;
		DPFX(DPFPREP,7, "(%p) BEGIN CONTROLLED BURST: Gap(%d) %d bytes avail (%d Size; %d credit)", pEPD, uiUseBurstGap, iBurstAvail, pSPD->uiFrameLength, pEPD->iBurstCredit);
	}

	//	 Transmit a burst from this EPD,  as long as its unblocked and has data ready.  We do not re-init
	// burst counter since any retries sent count against our burst limit
	//
	//	This has become more complex now that we are interleaving datagrams and reliable frames.  There are two
	// sets of priority-based send queues.  The first is combined DG and Reliable and the second is datagram only.
	// when the reliable stream is blocked we will feed from the DG only queues,  otherwise we will take from the
	// interleaved queue.
	//	This is further complicated by the possibility that a reliable frame can be partially transmitted at any time.
	// So before looking at the interleaved queues we must check for a partially completed reliable send (EPD.pCurrentSend).
	//
	//	** pEPD->EPLock is held **

	while( 		(((pEPD->ulEPFlags & EPFLAGS_STREAM_UNBLOCKED) && (pEPD->ulEPFlags & EPFLAGS_SDATA_READY)) 
				|| (pEPD->ulEPFlags & EPFLAGS_RETRIES_QUEUED))
				&& (iBurstSent < iBurstAvail))
	{
		// When burstsize is large we will decrease the next burst gap instead of sending additional
		// frames to fill the burst.

		if((pEPD->uiBurstGap > 10) && (uiFramesSent > 0))
		{
			DPFX(DPFPREP,7, "(%p) Burst Gap is large", pEPD);
			// BurstGap is large enough that we can subdivide it to credit the balance of this burst
			break;
		}

		// Always give preference to shipping retries before new data

		if(pEPD->ulEPFlags & EPFLAGS_RETRIES_QUEUED)
		{
			pFMD = CONTAINING_RECORD(pEPD->blRetryQueue.GetNext(), FMD, blQLinkage);
			ASSERT_FMD(pFMD);
			pFMD->blQLinkage.RemoveFromList();
			pFMD->ulFFlags &= ~(FFLAGS_RETRY_QUEUED);				// No longer on the retry queue
			if(pEPD->blRetryQueue.IsEmpty())
			{
				pEPD->ulEPFlags &= ~(EPFLAGS_RETRIES_QUEUED);
			}

			// pMSD->uiFrameCount will be decremented when this completes

			BuildRetryFrame(pEPD, pFMD);							// Place currect state information in retry frame

			DPFX(DPFPREP,7, "(%p) Shipping RETRY frame: Seq=%x, FMD=%p Size=%d", pEPD, ((PDFRAME) pFMD->ImmediateData)->bSeq, pFMD, pFMD->uiFrameLength);

			iBurstSent += pFMD->uiFrameLength;
			uiFramesSent++;
		}
		else 
		{
			if((pMSD = pEPD->pCurrentSend) != NULL)
			{
				ASSERT_MSD(pMSD);
				pFMD = pEPD->pCurrentFrame;						// Get the next frame due to send
				ASSERT_FMD(pFMD);
				ASSERT((pFMD->ulFFlags & FFLAGS_TRANSMITTED)==0);
			}
			else 
			{
				if( (pLink = pEPD->blHighPriSendQ.GetNext()) == &pEPD->blHighPriSendQ)
				{
					if( (pLink = pEPD->blNormPriSendQ.GetNext()) == &pEPD->blNormPriSendQ)
					{
						if( (pLink = pEPD->blLowPriSendQ.GetNext()) == &pEPD->blLowPriSendQ)
						{
							break;								// All finished sending for now
						}
					}
				}
				pMSD = CONTAINING_RECORD(pLink, MSD, blQLinkage);
				ASSERT_MSD(pMSD);

#ifdef DEBUG
				ASSERT(pMSD->ulMsgFlags2 & MFLAGS_TWO_ENQUEUED);
				pMSD->ulMsgFlags2 &= ~(MFLAGS_TWO_ENQUEUED);
#endif

				pMSD->blQLinkage.RemoveFromList();
				ASSERT(pEPD->uiQueuedMessageCount > 0);
				--pEPD->uiQueuedMessageCount;						// keep count of MSDs on all send queues
				
				pMSD->ulMsgFlags2 |= MFLAGS_TWO_TRANSMITTING;		// We have begun to transmit frames from this Msg

				pEPD->pCurrentSend = pMSD;
				pFMD = pEPD->pCurrentFrame = CONTAINING_RECORD(pMSD->blFrameList.GetNext(), FMD, blMSDLinkage);
				ASSERT_FMD(pFMD);
				ASSERT((pFMD->ulFFlags & FFLAGS_TRANSMITTED)==0);
				pFMD->bPacketFlags |= PACKET_COMMAND_NEW_MSG;
				pMSD->blQLinkage.InsertBefore( &pEPD->blCompleteSendList);	// Place this on PendingList now so we can keep track of it
			}

			BuildDataFrame(pEPD, pFMD, tNow);								// place current state info in frame
			
			pFMD->blWindowLinkage.InsertBefore( &pEPD->blSendWindow); // Place at trailing end of send window
			pFMD->ulFFlags |= FFLAGS_IN_SEND_WINDOW;
			LOCK_FMD(pFMD, "Send Window");							// Add reference for send window

			pEPD->uiUnackedBytes += pFMD->uiFrameLength;				// Track the unacknowleged bytes in the pipeline

			// We can always go over the limit, but will be blocked until we drop below the limit again.
			if(pEPD->uiUnackedBytes >= pEPD->uiWindowB)
			{				
				pEPD->ulEPFlags &= ~(EPFLAGS_STREAM_UNBLOCKED);	
				pEPD->ulEPFlags |= EPFLAGS_FILLED_WINDOW_BYTE;		// Tells us to increase window if all is well
				
	  			((PDFRAME) pFMD->ImmediateData)->bCommand |= PACKET_COMMAND_POLL; // Request immediate reply
			}
			
			// Count frames in the send window
			if((++pEPD->uiUnackedFrames) >= pEPD->uiWindowF)
			{			
				pEPD->ulEPFlags &= ~(EPFLAGS_STREAM_UNBLOCKED);
				((PDFRAME) pFMD->ImmediateData)->bCommand |= PACKET_COMMAND_POLL; // Request immediate reply
				pEPD->ulEPFlags |= EPFLAGS_FILLED_WINDOW_FRAME;		// Tells us to increase window if all is well
			}
			
			// We will only run one retry timer for each EndPt.  If we already have one running then do nothing.

			// If there was already a frame in the pipeline it should already have a clock running
			if(pEPD->uiUnackedFrames == 1)
			{
				ASSERT(pEPD->RetryTimer == 0);
				pFMD->ulFFlags |= FFLAGS_RETRY_TIMER_SET;			// This one is being measured
				LOCK_EPD(pEPD, "LOCK (set retry timer)");										// bump RefCnt for timer
				DPFX(DPFPREP,7, "(%p) Setting Retry Timer on Seq=0x%x, FMD=%p", pEPD, ((PDFRAME) pFMD->ImmediateData)->bSeq, pFMD);
				SetMyTimer(pEPD->uiRetryTimeout, 0, RetryTimeout, (PVOID) pEPD, &pEPD->RetryTimer, &pEPD->RetryTimerUnique);
			}
			else
			{
				ASSERT(pEPD->RetryTimer != 0);
			}
			LOCK_EPD(pEPD, "LOCK (Send Data Frame)");				// Keep EPD around while xmitting frame

			pFLink = pFMD->blMSDLinkage.GetNext();					// Get next frame in Msg

			// Was this the last frame in Msg?
			if(pFLink == &pMSD->blFrameList)
			{						
				// Last frame in message has been sent.
				//
				// We used to setup the next frame now,  but with the multi-priority queues it makes more sense to look for the
				// highest priority send when we are ready to send it.
				
				pEPD->pCurrentSend = NULL;
				pEPD->pCurrentFrame = NULL;

				// When completing a send,  set the POLL flag if there are no more sends on the queue

				// Request immediate reply if no more data to send
				if(pEPD->uiQueuedMessageCount == 0)
				{					
					((PDFRAME) pFMD->ImmediateData)->bCommand |= PACKET_COMMAND_POLL; 
				}
			}
			else 
			{
				pEPD->pCurrentFrame = CONTAINING_RECORD(pFLink, FMD, blMSDLinkage);
				ASSERT_FMD(pEPD->pCurrentFrame);
			}
			DPFX(DPFPREP,7, "(%p) Shipping Dataframe: Seq=%x, NRcv=%x FMD=%p", pEPD, ((PDFRAME) pFMD->ImmediateData)->bSeq, ((PDFRAME) pFMD->ImmediateData)->bNRcv, pFMD);
			
			uiFramesSent++;											// Count frames sent this burst
			iBurstSent += pFMD->uiFrameLength;

			// KEEPING DETAILED STATS REQUIRES EXTRA CONDITIONAL

			if(pFMD->ulFFlags & FFLAGS_RELIABLE)
			{
				pEPD->uiGuaranteedFramesSent++;
				pEPD->uiGuaranteedBytesSent += (pFMD->uiFrameLength - pFMD->uiImmediateLength);
			}
			else 
			{
				pEPD->uiDatagramFramesSent++;
				pEPD->uiDatagramBytesSent += (pFMD->uiFrameLength - pFMD->uiImmediateLength);
			}
			LOCK_FMD(pFMD, "SP Submit");							// Bump RefCnt when submitting Rely Sends
		}

		// PROCEED WITH TRANSMISSION...

		Lock(&pSPD->SPLock);
		ASSERT(!pFMD->bSubmitted);
		pFMD->ulFFlags |= FFLAGS_TRANSMITTED;					// Frame will be owned by SP
		pFMD->bSubmitted = TRUE;
		ASSERT(pFMD->blQLinkage.IsEmpty());
		pFMD->blQLinkage.InsertBefore( &pSPD->blPendingQueue);	// Place frame on pending queue
		Unlock(&pSPD->SPLock);

		// bSubmitted must not be set to true for a data frame without the EPLock being held, because
		// the retry logic will be checking bSubmitted with only the EPLock held.
		Unlock(&pEPD->EPLock); 

		DPFX(DPFPREP,DPF_CALLOUT_LVL, "(%p) Calling SP->SendData for FMD[%p]", pEPD, pFMD);
/*send*/if((hr = IDP8ServiceProvider_SendData(pSPD->IISPIntf, &pFMD->SendDataBlock)) != DPNERR_PENDING)
		{
			DPFX(DPFPREP,DPF_CALLOUT_LVL, "(%p) Calling our own CommandComplete since SP did not return DPNERR_PENDING", pEPD);
			(void) DNSP_CommandComplete((IDP8SPCallback *) pSPD, NULL, hr, (PVOID) pFMD);
		}

		Lock(&pEPD->EPLock);
		
	}	// WHILE (unblocked, undrained, & bandwidth credit avail)

	if((pEPD->ulEPFlags & EPFLAGS_STREAM_UNBLOCKED)==0)
	{
		pEPD->uiWindowFilled++;								// Count the times we filled the window
	}

	// Clear data-ready flag if everything is sent
	if((pEPD->uiQueuedMessageCount == 0) && (pEPD->pCurrentSend == NULL))
	{	
		pEPD->ulEPFlags &= ~(EPFLAGS_SDATA_READY);
	}

	// Determine how much of our transmit allowance we used and either credit or debit our next cycle.
	// However,  if we are only crediting one send/burst then we can modify the Gap instead

	iDelta = iBurstAvail - iBurstSent;							// Did we send too much or too little

	if(pEPD->uiBurstGap > 10)
	{
		if(iDelta > 0)
		{
			// We did not use our full burst credit to transmit.  Therefore we will schedule our next burst early.
			// We will aproximate this with quarters...

			iHalf = iBurstAvail >> 1;							// One half allocation
			iQuarter = iBurstAvail >> 2;						// One quarter of our allocation
			iEighth = iBurstAvail >> 4;							// One Eighth allocation

			// binary search to find which (octile or quartile) our send load falls into
			if(iBurstSent > (iHalf))
			{
				// used over 50% of credit
				if(iBurstSent > (iQuarter + iHalf))
				{
					// used 75 - 100%
					if(iBurstSent > (iBurstAvail - iEighth))
					{
						// Use Full Gap:  over 88% used
					}
					else
					{
						uiUseBurstGap -= (uiUseBurstGap >> 3);	// subtract 12% from gap
					}
				}
				else 
				{
					// used 50 - 75%
					if(iBurstSent > (iHalf + iEighth))
					{
						uiUseBurstGap -= (uiUseBurstGap >> 2);	// subtract 25% from gap
					}
					else
					{
						uiUseBurstGap -= ((uiUseBurstGap >> 2) + (uiUseBurstGap >> 3)); // subtract 33% from gap
					}
				}
			}
			else 
			{
				// used less then 50% of send credit
				if(iBurstSent > (iQuarter))
				{
					if(iBurstSent > (iQuarter + iEighth))
					{
						// used 25 - 50%
						uiUseBurstGap >>= 1;					// subrtact 50% from gap
					}
					else
					{
						uiUseBurstGap -= ((uiUseBurstGap >> 1) + (uiUseBurstGap >> 3));	// subtract 62%
					}
				}
				else 
				{
					// used 1 - 25%
					if(iBurstSent > iEighth)
					{
						uiUseBurstGap >>= 2;					// subtract 75% from gap
					}
					else
					{
						uiUseBurstGap >>= 3;					// subtract 88% from gap
					}
				}
			}

			pEPD->iBurstCredit = 0;
			DPFX(DPFPREP,7, "(%p) Short Burst Completed (%d bytes); Reducing gap from %d to %d", pEPD, iBurstSent, pEPD->uiBurstGap, uiUseBurstGap);
		}
		else if (iDelta < 0)
		{
			DPFX(DPFPREP,7, "(%p) Burst completed with debt of %d bytes", pEPD, iDelta);
			pEPD->iBurstCredit = iDelta;						// For large bursts,  simply carry extra forward to next cycle
		}
	}
	else if (iDelta < 0)
	{
		DPFX(DPFPREP,7, "(%p) Incurring debt of %d bytes against next burst", pEPD, iDelta);
		
		pEPD->iBurstCredit = iDelta;						// For large bursts,  simply carry extra forward to next cycle
	}
	else
	{
		DPFX(DPFPREP,7, "(%p) Short burst interval, dropping left-over burst credit", pEPD);
		// We will drop left-over credit when we are using short burst intervals...
		pEPD->iBurstCredit = 0;								// For large bursts,  simply carry extra forward to next cycle
	}
	
	// As commented in procedure-header above,  we will remain on the pipeline for one timer-cycle
	// so that if we unblock or un-idle we will not send until the gap is fullfilled.

	if((pEPD->ulEPFlags & (EPFLAGS_SDATA_READY | EPFLAGS_STREAM_UNBLOCKED)) ==
							(EPFLAGS_SDATA_READY | EPFLAGS_STREAM_UNBLOCKED))
	{		// IF BOTH flags are set
		DPFX(DPFPREP,7, "(%p) %d frame BURST COMPLETED - Sched next send in %dms, N(Seq)=%x", pEPD, uiFramesSent, uiUseBurstGap, pEPD->bNextSend);
	}
	else if((pEPD->ulEPFlags & EPFLAGS_SDATA_READY)==0)
	{
		DPFX(DPFPREP,7, "(%p) %d frame BURST COMPLETED  (%d / %d)- LINK IS IDLE N(Seq)=%x", pEPD, uiFramesSent, pEPD->uiUnackedFrames, pEPD->uiWindowF, pEPD->bNextSend);
	}
	else
	{
		ASSERT((pEPD->ulEPFlags & EPFLAGS_STREAM_UNBLOCKED)==0);
		DPFX(DPFPREP,7, "(%p) %d frame BURST COMPLETED (%d / %d) - STREAM BLOCKED N(Seq)=%x", pEPD, uiFramesSent, pEPD->uiUnackedFrames, pEPD->uiWindowF, pEPD->bNextSend);
	}

	ASSERT(pEPD->SendTimer == 0);

	if(pEPD->uiBurstGap != 0)
	{
		DPFX(DPFPREP,7, "(%p) Setting Scheduled Send Timer for %d ms", pEPD, uiUseBurstGap);
		SetMyTimer(uiUseBurstGap, 4, ScheduledSend, (PVOID) pEPD, &pEPD->SendTimer, &pEPD->SendTimerUnique);
		Unlock(&pEPD->EPLock);
	}
	else 
	{
		DPFX(DPFPREP,7, "(%p) Session leaving pipeline", pEPD);
		pEPD->ulEPFlags &= ~(EPFLAGS_IN_PIPELINE);

		RELEASE_EPD(pEPD, "UNLOCK (leaving pipeline)"); // releases EPLock
	}
}	

/*
**			Retry Timeout
**
**		Retry timer fires when we have not seen an acknowledgement for a packet
**	we sent in more then twice (actually 1.25 X) our measured RTT.  Actually,  that is
**	just our base calculation.  We will also measure empirical ACK times and adjust our timeout
**	to some multiple of that.  Remember that our partner may be delaying his Acks to wait for back-traffic.
**
**  Or we can measure avg deviation of Tack and base retry timer on that.
**
**		In any case,  its time to re-transmit the base frame in our send window...
**
**		Important note:  Since we can generate retries via bitmask in return traffic,  it is possible that
**	we have just retried when the timer fires.
**
**		Note on Locks:  Since the retry timer is directly associated with an entry on the EPD SendQueue,
**	we always protect retry-related operations with the EPD->SPLock.   We only hold the EPD->StateLock
**	when we mess with link state variables (NRcv,  DelayedAckTimer).
*/

#undef DPF_MODNAME
#define DPF_MODNAME "RetryTimeout"

#ifdef DEBUG
LONG g_RetryCount[MAX_RETRIES+1]={0,0,0,0,0,0,0,0,0,0,0};
#endif

VOID CALLBACK
RetryTimeout(PVOID uID, UINT Unique, PVOID dwUser)
{
	PEPD	pEPD = (PEPD) dwUser;
	PFMD	pFMD;
	DWORD	tNow = GETTIMESTAMP(), tDelta;
	UINT	delta;

	ASSERT_EPD(pEPD);

	Lock(&pEPD->EPLock);

	DPFX(DPFPREP,7, "(%p) Retry Timeout fires", pEPD);

	// Make sure link is still active
	if(!(pEPD->ulEPFlags & EPFLAGS_STATE_CONNECTED))
	{				
		DPFX(DPFPREP,7, "(%p) Not connected, exiting", pEPD);
		pEPD->RetryTimer = 0;

		RELEASE_EPD(pEPD, "UNLOCK (retry timer not-CONN)");		// Decrement RefCnt for timer, releases EPLock
		return;
	}

	// Its possible when we schedule a new retry timer that the previous timer cannot be cancelled. In this
	// case the timer Handle &| Unique field will be different,  and we do not want to run the event.

	// Make sure this isn't a leftover event
	if((pEPD->RetryTimer != uID) || (pEPD->RetryTimerUnique != Unique))
	{	
		DPFX(DPFPREP,7, "(%p) Stale retry timer, exiting", pEPD);

		RELEASE_EPD(pEPD, "UNLOCK (stale retry timer)"); // releases EPLock
		return;
	}

	pEPD->RetryTimer = 0;

	// Make sure that we still have transmits in progress

	if(pEPD->uiUnackedFrames > 0) 
	{
		ASSERT(!pEPD->blSendWindow.IsEmpty());
		pFMD = CONTAINING_RECORD(pEPD->blSendWindow.GetNext(), FMD, blWindowLinkage);	// Top frame in window

		ASSERT_FMD(pFMD);
		ASSERT(pFMD->ulFFlags & FFLAGS_RETRY_TIMER_SET);

		//	First we must make sure that the TO'd packet is still hanging around.  Since the first packet
		// in the window might have changed while the TO was being scheduled,  the easiest thing to do is
		// just recalculate the top packets expiration time and make sure its really stale.

		tDelta = tNow - pFMD->tTimestamp[pFMD->uiRetry];		// When did we last send this frame?

		if(tDelta > pEPD->uiRetryTimeout)
		{
			// Its a genuine timeout.  Lets retransmit the frame!

			DPFX(DPFPREP,7, "(%p) RETRY TIMEOUT %d on Seq=%x, pFMD=0x%p", pEPD, (pFMD->uiRetry + 1), ((PDFRAME) pFMD->ImmediateData)->bSeq, pFMD);

			// Count a retry
			if(++pFMD->uiRetry > MAX_RETRIES)
			{					
				// BOOM!  No more retries.  We are finished.  Link is going DOWN!
				DPFX(DPFPREP,1, "(%p) DROPPING LINK, retries exhausted", pEPD);

				DECREMENT_EPD(pEPD, "UNLOCK (retry timer drop)");// Release reference for this timer

				DropLink(pEPD);		// releases EPLock

				return;
			}

#ifdef DEBUG
			InterlockedIncrement(&g_RetryCount[pFMD->uiRetry]); 
#endif

			// calculate timeout for next retry
			if(pFMD->uiRetry == 1)
			{
				// do a retry at the same timeout - this is games after all.
				tDelta = pEPD->uiRetryTimeout;
			} 
			else if (pFMD->uiRetry <= 3) 
			{
				// do a couple of linear backoffs - this is a game after all
				tDelta = pEPD->uiRetryTimeout * pFMD->uiRetry;
			}
			else if (pFMD->uiRetry < 8)
			{
				// doh, bad link, bad bad link, do exponential backoffs
				tDelta = pEPD->uiRetryTimeout * (1 << pFMD->uiRetry);
			} 
			else 
			{
				// don't give up too quickly.
				tDelta = MAX_RETRY_INTERVAL;
			}
			
			if(tDelta >= MAX_RETRY_INTERVAL)
			{
				// CAP TOTAL DROP TIME AT 50 seconds unless the RTT is huge
				tDelta = MAX(MAX_RETRY_INTERVAL, pEPD->uiRTT);
			}

			// Unreliable frame!
			if(pFMD->CommandID == COMMAND_ID_SEND_DATAGRAM)
			{		
				// When an unreliable frame is NACKed we will not retransmit the data.  We will instead send
				// a mask so that the other side knows to cancel it.

				DPFX(DPFPREP,7, "(%p) RETRY TIMEOUT for UNRELIABLE FRAME", pEPD);

				// We get to credit the frame as out of the window.
				pEPD->uiUnackedBytes -= pFMD->uiFrameLength;

				// Only count a datagram drop on the first occurance
				if(pFMD->uiRetry == 1)
				{
					pEPD->uiDatagramFramesDropped++;	
					pEPD->uiDatagramBytesDropped += (pFMD->uiFrameLength - pFMD->uiImmediateLength);
					EndPointDroppedFrame(pEPD, tNow);
				}

				// Diff between next send and this send.
				delta = (pEPD->bNextSend - ((PDFRAME) pFMD->ImmediateData)->bSeq) & 0xFF ; 

				ASSERT(delta != 0);
				ASSERT(delta < (MAX_RECEIVE_RANGE + 1));

				if(delta < 33)
				{
					pEPD->ulSendMask |= (1 << (delta - 1));
				}
				else
				{
					pEPD->ulSendMask2 |= (1 << (delta - 33));
				}

				pFMD->uiFrameLength = 0;
				pEPD->ulEPFlags |= EPFLAGS_DELAYED_SENDMASK;
				
				if(pEPD->DelayedMaskTimer == 0)
				{
					DPFX(DPFPREP,7, "(%p) Setting Delayed Mask Timer", pEPD);
					LOCK_EPD(pEPD, "LOCK (delayed mask timer - send retry)");
					SetMyTimer(DELAYED_SEND_TIMEOUT, 0, DelayedAckTimeout, (PVOID) pEPD, &pEPD->DelayedMaskTimer, &pEPD->DelayedMaskTimerUnique);
				}
			}

			// RELIABLE FRAME -- Send a retry	
			else 
			{		
				pEPD->uiGuaranteedFramesDropped++;							// Keep count of lost frames
				pEPD->uiGuaranteedBytesDropped += (pFMD->uiFrameLength - pFMD->uiImmediateLength);	// Keep count of lost frames
				pFMD->tTimestamp[pFMD->uiRetry] = tNow;

				pEPD->ulEPFlags &= ~(EPFLAGS_DELAY_ACKNOWLEDGE);		// No longer waiting to send Ack info

				// Stop delayed ack timer
				if(pEPD->DelayedAckTimer != 0)
				{
					DPFX(DPFPREP,7, "(%p) Cancelling Delayed Ack Timer", pEPD);
					if(CancelMyTimer(pEPD->DelayedAckTimer, pEPD->DelayedAckTimerUnique) == DPN_OK)
					{
						DECREMENT_EPD(pEPD, "UNLOCK (cancel DelayedAck)"); // SPLock not already held
					}
					else
					{
						DPFX(DPFPREP,7, "(%p) Cancelling Delayed Ack Timer Failed", pEPD);
					}
					pEPD->DelayedAckTimer = 0;
				}

				EndPointDroppedFrame(pEPD, tNow);

				if(pFMD->ulFFlags & FFLAGS_RETRY_QUEUED)
				{
					// It's still on the Retry Queue.  This should not happen when everything is working
					// properly.  Timeouts should be greater then RTT and the BurstGap should be less then RTT.

					DPFX(DPFPREP,1, "(%p) RETRY FIRES WHILE FMD IS STILL IN RETRY QUEUE pFMD=%p", pEPD, pFMD);

					pFMD = NULL;
				}
				else if(pFMD->bSubmitted)
				{
					// Woe on us.  We would like to retry a frame that has not been completed by the SP!
					//
					//		This will most typically happen when we are debugging which delays processing
					//	of the Complete,  but it could also happen if the SP is getting hammered.  We need
					//	to copy the FMD into a temporary descriptor which can be discarded upon completion...

					DPFX(DPFPREP,1,"(%p) RETRYING %p but its still busy. Substituting new FMD", pEPD, pFMD);
					pFMD = CopyFMD(pFMD, pEPD);							// We will substitute new FMD in rest of procedure
				}
				else 
				{
					DPFX(DPFPREP,7, "(%p) Sending Retry of N(S)=%x, pFMD=0x%p", pEPD, ((PDFRAME) pFMD->ImmediateData)->bSeq, pFMD);
					LOCK_FMD(pFMD, "SP Submit");
				}

				if(pFMD)
				{
					LOCK_EPD(pEPD, "LOCK (retry rely frame)");
					pEPD->ulEPFlags |= EPFLAGS_RETRIES_QUEUED;
					pFMD->ulFFlags |= FFLAGS_RETRY_QUEUED;
					ASSERT_MSD(pFMD->pMSD);
					pFMD->pMSD->uiFrameCount++; // Protected by EPLock, retries prevent completion until they complete
					DPFX(DPFPREP, DPF_FRAMECNT_LVL, "(%p) Frame count incremented on retry timeout, pMSD[%p], framecount[%u]", pEPD, pFMD->pMSD, pFMD->pMSD->uiFrameCount);
					ASSERT(pFMD->blQLinkage.IsEmpty());
					pFMD->blQLinkage.InsertBefore( &pEPD->blRetryQueue);		// Place frame on Send queue

					if((pEPD->ulEPFlags & EPFLAGS_IN_PIPELINE)==0)
					{
						DPFX(DPFPREP,7, "(%p) Scheduling Send", pEPD);
						pEPD->ulEPFlags |= EPFLAGS_IN_PIPELINE;
						LOCK_EPD(pEPD, "LOCK (pipeline)");
						ScheduleTimerThread(ScheduledSend, pEPD, &pEPD->SendTimer, &pEPD->SendTimerUnique);
					}
				}
			}	// ENDIF RETRY
		}
		else 
		{
			tDelta = pEPD->uiRetryTimeout - tDelta;
		}

		DPFX(DPFPREP,7, "(%p) Setting Retry Timer for %d ms", pEPD, tDelta); 
		//	Dont LOCK_EPD here because we never released the lock from the timer which scheduled us here
		SetMyTimer(tDelta, 20, RetryTimeout, (PVOID) pEPD, &pEPD->RetryTimer, &pEPD->RetryTimerUnique);

		Unlock(&pEPD->EPLock);
	}
	else 
	{
		RELEASE_EPD(pEPD, "UNLOCK (RetryTimer no frames out)");	// drop RefCnt since we dont restart timer, releases EPLock
	}
}

/*
**		Copy FMD
**
**			This routine allocates a new Frame Descriptor and copies all fields from the provided
**		FMD into it.  All fields except CommandID,  RefCnt,  and Flags.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "CopyFMD"

PFMD CopyFMD(PFMD pFMD, PEPD pEPD)
{
	PFMD	pNewFMD;

	if((pNewFMD = static_cast<PFMD>( FMDPool->Get(FMDPool) )) == NULL)
	{
		DPFX(DPFPREP,0, "Failed to allocate new FMD");
		return NULL;
	}

	LOCK_EPD(pEPD, "LOCK (CopyFMD)");

	memcpy(pNewFMD, pFMD, sizeof(FMD));

	// Undo the copying of these members
	pNewFMD->blMSDLinkage.Initialize();
	pNewFMD->blQLinkage.Initialize();
	pNewFMD->blWindowLinkage.Initialize();

	pNewFMD->CommandID = COMMAND_ID_COPIED_RETRY;
	pNewFMD->lRefCnt = 1;
	pNewFMD->ulFFlags = 0;
	pNewFMD->bSubmitted = FALSE;

	pNewFMD->lpImmediatePointer = (LPVOID) pNewFMD->ImmediateData;
	pNewFMD->SendDataBlock.pBuffers = (PBUFFERDESC) &pNewFMD->uiImmediateLength;
	pNewFMD->SendDataBlock.pvContext = pNewFMD;
	pNewFMD->SendDataBlock.hCommand = 0;
	ASSERT(	pNewFMD->pEPD == pEPD );

	DPFX(DPFPREP,7, "COPYFMD -- replacing FMD %p with copy %p", pFMD, pNewFMD);

	return pNewFMD;
}

/*			
**			Send Command Frame
**
**		Build a CFrame addressed to the specified EndPoint, and Queue it on the SPD
**	to be sent.
**
**	** THIS FUNCTION CALLED AND RETURNS WITH EPD->EPLOCK HELD **
*/

#undef DPF_MODNAME
#define DPF_MODNAME "SendCommandFrame"

HRESULT	SendCommandFrame(PEPD pEPD, BYTE ExtOpcode, BYTE RspID)
{
	PSPD		pSPD = pEPD->pSPD;
	PFMD		pFMD;
	PCFRAME		pCFrame;
	PCHKPT		pChkPt;
	DWORD		tNow = GETTIMESTAMP();

	AssertCriticalSectionIsTakenByThisThread(&pEPD->EPLock, TRUE);

	// Frame already initialized to 1 buffer
	if((pFMD = static_cast<PFMD>( FMDPool->Get(FMDPool) )) == NULL)
	{				
		DPFX(DPFPREP,0, "(%p) Failed to allocate new FMD", pEPD);
		return DPNERR_OUTOFMEMORY;
	}

	pFMD->pEPD = pEPD;										// Track EPD for RefCnt
	LOCK_EPD(pEPD, "LOCK (Prep Cmd Frame)");				// Bump RefCnt on EPD until send is completed
	pFMD->CommandID = COMMAND_ID_CFRAME;
	pFMD->pMSD = NULL;										// this will indicate a NON-Data frame
	pFMD->uiImmediateLength = sizeof(CFRAME);				// standard size for C Frames
	pFMD->SendDataBlock.hEndpoint = pEPD->hEndPt;			// Place address in frame
	pFMD->uiFrameLength = sizeof(CFRAME);					// Never have user data in Cframe

	pCFrame = (PCFRAME) pFMD->ImmediateData;

	pCFrame->bCommand = PACKET_COMMAND_CFRAME;
	pCFrame->bExtOpcode = ExtOpcode;
	pCFrame->dwVersion = DNET_VERSION_NUMBER;
	pCFrame->bRspID = RspID;
	pCFrame->dwSessID = pEPD->dwSessID;
	pCFrame->tTimestamp = tNow;

	// If this frame requires a response (or if we are specifically asked to) we will build
	// a Checkpoint structure which will be stored to correlate the eventual response with
	// the original frame.

	if(	(pEPD->ulEPFlags & EPFLAGS_CHECKPOINT_INIT)||
		(ExtOpcode == FRAME_EXOPCODE_CONNECT)) 
	{
		if((pChkPt = static_cast<PCHKPT>( ChkPtPool->Get(ChkPtPool) )) != NULL)
		{
			pChkPt->bMsgID = pEPD->bNextMsgID;				// Note next ID in CP structure
			pCFrame->bCommand |= PACKET_COMMAND_POLL;		// make this frame a CP
			pEPD->ulEPFlags &= ~EPFLAGS_CHECKPOINT_INIT;
			pChkPt->tTimestamp = tNow;
			pChkPt->blLinkage.InsertBefore( &pEPD->blChkPtQueue);
		}
		else
		{
			DPFX(DPFPREP,0, "(%p) Failed to allocate new CHKPT", pEPD);
			ASSERT(0);
		}
	}
	pCFrame->bMsgID = pEPD->bNextMsgID++;					// include MsgID in frame

	Lock(&pSPD->SPLock);							// Place SACK frame on send queue
	ASSERT(pFMD->blQLinkage.IsEmpty());
	pFMD->blQLinkage.InsertBefore( &pSPD->blSendQueue);
	if((pSPD->ulSPFlags & SPFLAGS_SEND_THREAD_SCHEDULED)==0)
	{
		DPFX(DPFPREP,7, "(%p) Scheduling Send Thread", pEPD);
		pSPD->ulSPFlags |= SPFLAGS_SEND_THREAD_SCHEDULED;
		ScheduleTimerThread(RunSendThread, pSPD, &pSPD->SendHandle, &pSPD->SendHandleUnique);	
	}
	Unlock(&pSPD->SPLock);

	return DPN_OK;
}


/*
**		Send Ack Frame
**
**		This routine is called to immediately transmit our current receive
**	state to the indicated EndPoint.  This is equivalent to acknowledging
**	all received frames.  We may want to change this routine so that it
**	will attempt to piggyback the ack if there is data waiting to be sent.
**
**		THIS ROUTINE IS CALLED WITH EDP->EPLOCK HELD, BUT RELEASES IT IF DirectFlag IS SET
*/

#undef DPF_MODNAME
#define DPF_MODNAME "SendAckFrame"

VOID SendAckFrame(PEPD pEPD, BOOL DirectFlag, BOOL fFinalAck/* = FALSE*/)
{
	PSPD		pSPD = pEPD->pSPD;
	PFMD		pFMD;
	UINT		index = 0;
	PSFBIG8		pSackFrame;
	ASSERT_SPD(pSPD);

	AssertCriticalSectionIsTakenByThisThread(&pEPD->EPLock, TRUE);

	// Frame already initialized to 1 buffer
	if((pFMD = static_cast<PFMD>( FMDPool->Get(FMDPool) )) == NULL)
	{		
		DPFX(DPFPREP,0, "(%p) Failed to allocate new FMD", pEPD);
		return;
	}

	// We can stop all delayed Ack timers since we are sending full status here.
	if(pEPD->DelayedAckTimer != 0)
	{
		DPFX(DPFPREP,7, "(%p) Cancelling Delayed Ack Timer", pEPD);
		if(CancelMyTimer(pEPD->DelayedAckTimer, pEPD->DelayedAckTimerUnique) == DPN_OK)
		{
			DECREMENT_EPD(pEPD, "UNLOCK (cancel DelayedAck timer)");
		}
		else
		{
			DPFX(DPFPREP,7, "(%p) Cancelling Delayed Ack Timer Failed", pEPD);
		}
		pEPD->DelayedAckTimer = 0;
	}
	if(pEPD->DelayedMaskTimer != 0)
	{
		DPFX(DPFPREP,7, "(%p) Cancelling Delayed Mask Timer", pEPD);
		if(CancelMyTimer(pEPD->DelayedMaskTimer, pEPD->DelayedMaskTimerUnique) == DPN_OK)
		{
			DECREMENT_EPD(pEPD, "UNLOCK (cancel DelayedMask timer)");
		}
		else
		{
			DPFX(DPFPREP,7, "(%p) Cancelling Delayed Mask Timer Failed", pEPD);
		}
		pEPD->DelayedMaskTimer = 0;
	}

	if (fFinalAck)
	{
		pFMD->ulFFlags |= FFLAGS_FINAL_ACK;
	}

	pFMD->pEPD = pEPD;								// Track EPD for RefCnt
	LOCK_EPD(pEPD, "LOCK (SendAckFrame)");			// Bump RefCnt on EPD until send is completed

	pFMD->CommandID = COMMAND_ID_CFRAME;
	pFMD->pMSD = NULL;								// this will indicate a NON-Data frame
	pFMD->SendDataBlock.hEndpoint = pEPD->hEndPt;

	// Now that DG and S have been merged,  there are no longer 3 flavors of ACK frame.  We are back to only
	// one flavor that may or may not have detailed response info on one frame.  Actually,  I think we can
	// always include response info on the last ack'd frame.

	pSackFrame = (PSFBIG8) pFMD->ImmediateData;

	pSackFrame->bCommand = PACKET_COMMAND_CFRAME;
	pSackFrame->bExtOpcode = FRAME_EXOPCODE_SACK;
	pSackFrame->bNSeq = pEPD->bNextSend;
	pSackFrame->bNRcv = pEPD->bNextReceive;
	pSackFrame->bFlags = 0;
	pSackFrame->bReserved1 = 0;
	pSackFrame->bReserved2 = 0;
	pSackFrame->tTimestamp = pEPD->tLastDataFrame;

	if(pEPD->ulEPFlags & EPFLAGS_DELAYED_NACK)
	{
		DPFX(DPFPREP,7, "(%p) SENDING SACK WITH *NACK* N(R)=%x Low=%x High=%x", pEPD, pEPD->bNextReceive, pEPD->ulReceiveMask, pEPD->ulReceiveMask2);
		if(pEPD->ulReceiveMask)
		{
			pSackFrame->rgMask[index++] = pEPD->ulReceiveMask;
			pSackFrame->bFlags |= SACK_FLAGS_SACK_MASK1;
		}
		if(pEPD->ulReceiveMask2)
		{
			pSackFrame->rgMask[index++] = pEPD->ulReceiveMask2;
			pSackFrame->bFlags |= SACK_FLAGS_SACK_MASK2;
		}

		pEPD->ulEPFlags &= ~(EPFLAGS_DELAYED_NACK);
	}
	if(pEPD->ulEPFlags & EPFLAGS_DELAYED_SENDMASK)
	{
		DPFX(DPFPREP,7, "(%p) SENDING SACK WITH SEND MASK N(S)=%x Low=%x High=%x", pEPD, pEPD->bNextSend, pEPD->ulSendMask, pEPD->ulSendMask2);
		if(pEPD->ulSendMask)
		{
			pSackFrame->rgMask[index++] = pEPD->ulSendMask;
			pSackFrame->bFlags |= SACK_FLAGS_SEND_MASK1;
			pEPD->ulSendMask = 0;
		}
		if(pEPD->ulSendMask2)
		{
			pSackFrame->rgMask[index++] = pEPD->ulSendMask2;
			pSackFrame->bFlags |= SACK_FLAGS_SEND_MASK2;
			pEPD->ulSendMask2 = 0;
		}
		pEPD->ulEPFlags &= ~(EPFLAGS_DELAYED_SENDMASK);
	}
	
	pFMD->uiImmediateLength = sizeof(SACKFRAME8) + (index * sizeof(ULONG));
	pFMD->uiFrameLength = pFMD->uiImmediateLength;
	
	pSackFrame->bFlags |= SACK_FLAGS_RESPONSE;			// time fields are always valid now

	ASSERT(pEPD->bLastDataSeq == (BYTE) (pEPD->bNextReceive - 1));

	pSackFrame->bRetry = pEPD->bLastDataRetry;
	
	DPFX(DPFPREP,7, "(%p) SEND SACK FRAME N(Rcv)=%x, EPD->LDRetry=%d, pFrame->Retry=%d pFMD=%p", pEPD, pEPD->bNextReceive, pEPD->bLastDataRetry, pSackFrame->bRetry, pFMD);
		
	pEPD->ulEPFlags &= ~(EPFLAGS_DELAY_ACKNOWLEDGE);

	// We can either schedule a worker thread to do the send or else we can do the work ourselves.  
	// The DirectFlag tells us whether we are in a time-crit section,  like processing
	// receive data, or whether we are free to call the SP ourselves.

	Lock(&pSPD->SPLock);								// Place SACK frame on send queue
	ASSERT(pFMD->blQLinkage.IsEmpty());
	pFMD->blQLinkage.InsertBefore( &pSPD->blSendQueue);
	
	if(DirectFlag)
	{
		// ServiceCmdTraffic will call into the SP so we must not hold the EPD lock
		Unlock(&pEPD->EPLock);
		ServiceCmdTraffic(pSPD); // Called with SPLock held
	}
	else 
	{
		if((pSPD->ulSPFlags & SPFLAGS_SEND_THREAD_SCHEDULED)==0)
		{
			DPFX(DPFPREP,7, "(%p) Scheduling Send Thread", pEPD);
			pSPD->ulSPFlags |= SPFLAGS_SEND_THREAD_SCHEDULED;
			ScheduleTimerThread(RunSendThread, pSPD, &pSPD->SendHandle, &pSPD->SendHandleUnique);	
		}
	}
	Unlock(&pSPD->SPLock);
}

/*
**		Delayed Ack Timeout
**
**			We are waiting for a chance to piggyback a reliable frame acknowledgement,
**		but the sands have run out.  Its time to send a dedicated Ack now.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "DelayedAckTimeout"

VOID CALLBACK DelayedAckTimeout(PVOID uID, UINT uMsg, PVOID dwUser)
{
	PEPD	pEPD = (PEPD) dwUser;

	ASSERT_EPD(pEPD);

	Lock(&pEPD->EPLock);

	DPFX(DPFPREP,7, "(%p) Delayed Ack Timer fires", pEPD);
	if((pEPD->DelayedAckTimer == uID)&&(pEPD->DelayedAckTimerUnique == uMsg))
	{
		pEPD->DelayedAckTimer = 0;
	}
	else if((pEPD->DelayedMaskTimer == uID)&&(pEPD->DelayedMaskTimerUnique == uMsg))
	{
		pEPD->DelayedMaskTimer = 0;
	}
	else
	{
		// Stale timer, ignore
		DPFX(DPFPREP,7, "(%p) Stale Delayed Ack Timer, ignoring", pEPD);
		RELEASE_EPD(pEPD, "UNLOCK (DelayedAck complete)");	// release reference for timer, releases EPLock
		return;
	}

	if( (pEPD->ulEPFlags & EPFLAGS_STATE_CONNECTED) && (pEPD->ulEPFlags & (EPFLAGS_DELAY_ACKNOWLEDGE | EPFLAGS_DELAYED_NACK | EPFLAGS_DELAYED_SENDMASK)))
	{
		SendAckFrame(pEPD, 0); 
	}	

	RELEASE_EPD(pEPD, "UNLOCK (DelayedAck complete)");	// release reference for timer, releases EPLock
}


/*
**		Send Keep Alive
**
**		When we have not received anything from an endpoint in a long time (default 60 sec)
**	will will initiate a checkpoint to make sure that the partner is still connected.  We do
**	this by inserting a zero-data frame into the reliable pipeline.  Thereby,  the standard
**	timeout & retry mechanisms will either confirm or drop the link as appropriate.  Logic above
**	this routine will have already verified that we are not already sending reliable traffic, which
**	would eliminate the need for a keep alive frame.
**
**	*** EPD->EPLock is held on Entry and return
*/

#undef DPF_MODNAME
#define DPF_MODNAME "SendKeepAlive"

VOID
SendKeepAlive(PEPD pEPD)
{
	PFMD	pFMD;
	PMSD	pMSD;

	AssertCriticalSectionIsTakenByThisThread(&pEPD->EPLock, TRUE);

	if(pEPD->ulEPFlags & EPFLAGS_KEEPALIVE_RUNNING)
	{
		DPFX(DPFPREP,7, "Ignoring duplicate KeepAlive");
		return;
	}

	pEPD->ulEPFlags |= EPFLAGS_KEEPALIVE_RUNNING;

	if( (pMSD = static_cast<PMSD>( MSDPool->Get(MSDPool) )) == NULL)
	{
		DPFX(DPFPREP,0, "(%p) Failed to allocate new MSD");
		pEPD->ulEPFlags &= ~(EPFLAGS_KEEPALIVE_RUNNING);
		return;
	}

	pMSD->uiFrameCount = 1;
	DPFX(DPFPREP, DPF_FRAMECNT_LVL, "Initialize Frame count, pMSD[%p], framecount[%u]", pMSD, pMSD->uiFrameCount);
	pMSD->ulMsgFlags2 |= MFLAGS_TWO_KEEPALIVE;

	if((pFMD = static_cast<PFMD>( FMDPool->Get(FMDPool) )) == NULL)
	{
		DPFX(DPFPREP,0, "(%p) Failed to allocate new FMD");
		Lock(&pMSD->CommandLock);								// An MSD must be locked to be released
		RELEASE_MSD(pMSD, "Release On FMD Get Failed");
		pEPD->ulEPFlags &= ~(EPFLAGS_KEEPALIVE_RUNNING);
		return;
	}
	
	pMSD->pEPD = pEPD;
	pMSD->pSPD = pEPD->pSPD;
	LOCK_EPD(pEPD, "LOCK (SendKeepAlive)");						// Add a reference for this checkpoint

	pFMD->ulFFlags |= FFLAGS_CHECKPOINT | FFLAGS_END_OF_MESSAGE;
	pFMD->bPacketFlags = PACKET_COMMAND_DATA | PACKET_COMMAND_RELIABLE | PACKET_COMMAND_SEQUENTIAL | PACKET_COMMAND_END_MSG;
	pFMD->uiFrameLength = 0;									// No user data in this frame
	pFMD->blMSDLinkage.InsertAfter( &pMSD->blFrameList);		// Attach frame to MSD
	pFMD->pMSD = pMSD;											// Link frame back to message
	pFMD->pEPD = pEPD;
	pFMD->CommandID = COMMAND_ID_SEND_RELIABLE;
	pMSD->CommandID = COMMAND_ID_KEEPALIVE;	// Mark MSD for completion handling
	pMSD->ulSendFlags = DN_SENDFLAGS_RELIABLE | DN_SENDFLAGS_LOW_PRIORITY; // Priority is LOW so all previously submitted traffic will be sent
	
	DPFX(DPFPREP,7,"(%p) Sending KEEPALIVE", pEPD);
	
	EnqueueMessage(pMSD, pEPD);									// Insert this message into the stream
}

/*
**			Perform Checkpoint
**
**		We would like to take a measurement of Round-Trip latency using the
**	reliable pipeline.  We either need to mark the next outgoing frame in our
**	SendQ with a POLL bit OR we need to create a special purpose frame if
**	the pipeline is idle.
**
**		We have a routine (above) which will insert a special frame,  so THIS
**	procedure will check for an idle link and either call out or mark the
**	next frame.
**
**		** CALLED AND RETURNS WITH EPD->EPLOCK HELD
*/


#undef DPF_MODNAME
#define DPF_MODNAME "PerformCheckpoint"

VOID
PerformCheckpoint(PEPD pEPD)
{
	DPFX(DPFPREP,7,"(%p) Performing Checkpoint", pEPD);
	
	AssertCriticalSectionIsTakenByThisThread(&pEPD->EPLock, TRUE);

	if(pEPD->ulEPFlags & EPFLAGS_SDATA_READY)
	{
		ASSERT(pEPD->pCurrentFrame != NULL);					// DATA_READY flag means pCurrentFrame is valid
		pEPD->pCurrentFrame->ulFFlags |= FFLAGS_CHECKPOINT;
	}
	else
	{														// We do not have data in our pipeline
		SendKeepAlive(pEPD);									// Keepalive doubles as a checkpoint
	}
}


/*
**		Endpoint Background Process
**
**		This routine is run for each active endpoint every minute or so.  This will initiate
**	a KeepAlive exchange if the link has been idle since the last run of the procedure.  We
**	will also look for expired timeouts and perhaps this will be an epoch delimiter for links
**	in a STABLE state of being.
**
*/

#undef DPF_MODNAME
#define DPF_MODNAME "EndPointBackgroundProcess"

VOID CALLBACK
EndPointBackgroundProcess(PVOID uID, UINT Unique, PVOID dwUser)
{
	PEPD	pEPD = (PEPD) dwUser;
	DWORD	tNow = GETTIMESTAMP();
	DWORD	dwIdleInterval;

	DPFX(DPFPREP,7, "(%p) BACKGROUND PROCESS for EPD; RefCnt=%d; WindowF=%d; WindowB=%d", 
										pEPD, pEPD->lRefCnt, pEPD->uiWindowF, pEPD->uiWindowBIndex);

	Lock(&pEPD->EPLock);

	if(!(pEPD->ulEPFlags & EPFLAGS_STATE_CONNECTED))
	{
		DPFX(DPFPREP,7, "Killing Background Process, endpoint is not connected. Flags = 0x%x", pEPD->ulEPFlags);
		pEPD->BGTimer = 0;

		RELEASE_EPD(pEPD, "UNLOCK (release BG timer)");	// release reference for this timer, releases EPLock
		return;
	}

	dwIdleInterval = pEPD->pSPD->pPData->tIdleThreshhold;

	// Do we need to start a KeepAlive cycle?

	if(	((pEPD->ulEPFlags & (EPFLAGS_SDATA_READY | EPFLAGS_KEEPALIVE_RUNNING))==0) &&
		((tNow - pEPD->tLastPacket) > dwIdleInterval)) 
	{
		// We are not sending data and we havent heard from our partner in a long time.
		// We will send a keep alive packet which he must respond to.  We will insert a
		// NULL data packet into the reliable stream so ack/retry mechanisms will either
		// clear the keep-alive or else timeout the link.
		//
		// There's also the special case where we've started a graceful disconnect and
		// our request has been acknowledged, but somehow our partner's got lost.
		// There currently is no timer set for that, so if we detect the link in that
		// condition, our keepalive will almost certainly fail; the other side knows
		// we're shutting down, so has probably already dropped the link and wouldn't
		// respond.  So to prevent the person from having to wait for the entire idle
		// timeout _plus_ reliable message timeout, just drop the link now.
		if (pEPD->ulEPFlags & EPFLAGS_DISCONNECT_ACKED)
		{
			// If all three parts happened, why is the link still up!?
			ASSERT(! (pEPD->ulEPFlags & EPFLAGS_ACKED_DISCONNECT));


			DPFX(DPFPREP,1, "(%p) EPD has been waiting for partner disconnect for %u ms (idle threshold = %u ms), dropping link.",
					pEPD, (tNow - pEPD->tLastPacket), dwIdleInterval);
			
			// We don't need to reschedule a timer, so clear it.  This also prevents
			// drop link from trying to cancel the one we're in now.  That error is
			// ignored, but no point in doing it.
			pEPD->BGTimer = 0;

			DECREMENT_EPD(pEPD, "UNLOCK (release BGTimer)");

			// Since we're just hanging out waiting for partner to send his disconnect,
			// he's probably gone now.  Drop the link.
			DropLink(pEPD);									// releases EPLock

			return;
		}
		else if (!(pEPD->ulEPFlags & EPFLAGS_SENT_DISCONNECT))
		{
			DPFX(DPFPREP,5, "(%p) Sending KEEPALIVE...", pEPD);
			SendKeepAlive(pEPD);	
		}
		else
		{
			// The EndOfStream message will either get ACK'd or timeout, we allow no further sends, even KeepAlives
			DPFX(DPFPREP,5, "(%p) KeepAlive timeout fired, but we have already sent an EndOfStream, ignoring", pEPD);
		}
	}

	// Reschedule next interval

	// Cap the background process interval at this value.
	if (dwIdleInterval > ENDPOINT_BACKGROUND_INTERVAL)
		dwIdleInterval = ENDPOINT_BACKGROUND_INTERVAL;

	DPFX(DPFPREP,7, "(%p) Setting Endpoint Background Timer for %u ms", pEPD, dwIdleInterval);
	SetMyTimer(dwIdleInterval, 1000, EndPointBackgroundProcess, (PVOID) pEPD, &pEPD->BGTimer, &pEPD->BGTimerUnique);

	Unlock(&pEPD->EPLock);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\protocol\command.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		Command.cpp
 *  Content:	This file contains code which implements assorted APIs for the
 *				DirectPlay protocol.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  11/06/98    ejs     Created
 *  07/01/2000  masonb  Assumed Ownership
 *
 ****************************************************************************/

#include "dnproti.h"


VOID		AbortDatagramSend(PMSD, HRESULT);

/*
**		Cancel Command
**
**			This procedure is passed a HANDLE returned from a previous asynchronous
**	DPLAY command.  At the moment,  the handle is a pointer to an internal data
**	structure.  Problem with this is that due to FPM's (fixed pool manager) design
**	they will get recycled very quickly and frequently.  We might want to map them
**	into an external handle table which will force them to recycle much more slowly.
**	Perhaps,  I will let the upper DN layer do this mapping...
**
**		Anyway,  the only check I can do right now is that the HANDLE is currently
**	allocated to something.
**
**		We do not expect cancels to happen very often.  Therefore,  I do not feel
**	bad about walking the global command list to find the Handle.  Of course,  if
**	we do go to a handle mapped system then we should not need to do this walk.
**
**	I THINK - That any cancellable command will be on either MessageList or TimeoutList!
**
**		Things we can cancel and their possible states:
**
**		SEND Datagram
**			On SPD Send Queue
**			On EPD Send Queue
**			In SP call
**			
**		SEND Reliable
**			We can only cancel if it has not started transmitting.  Once its started, the
**				user program must Abort the link to cancel the send.
**
**		CONNECT
**			In SP call
**			On PD list
**
**		LISTEN
**			In SP call
**			On PD list
**
**		Remember,  if we cancel a command in SP then the CommandComplete is supposed to
**	occur.  This means that we should not have to explicitly free the MSD, etc in these
**	cases.
*/


#undef DPF_MODNAME
#define DPF_MODNAME "DNPCancelCommand"

HRESULT
DNPCancelCommand(PProtocolData pPData,  HANDLE hCommand)
{
	PMSD	pMSD = (PMSD) hCommand;
	HRESULT	hr;

	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: pPData[%p], hCommand[%x]", pPData, hCommand);

	if(pMSD->Sign != MSD_SIGN)
	{
		DPFX(DPFPREP,0, "Cancel called with invalid handle");
		return DPNERR_INVALIDHANDLE;
	}

	Lock(&pMSD->CommandLock);								// Take this early to freeze state of command
	
	// validate instance of MSD
	if(pMSD->lRefCnt == -1)
	{	
		DPFX(DPFPREP,0, "Cancel called with invalid handle");
		Unlock(&pMSD->CommandLock);
		return DPNERR_INVALIDHANDLE;
	}

	hr = DoCancel(pMSD, DPNERR_USERCANCEL); // Releases CommandLock

	return hr;
}


/*
**		Do Cancel
**
**		This function implements the meat of the cancel asynch operation.  It gets called from
**	two places.  Either from the User cancel API right above,  or from the global timeout handler.
**
**	***This code requires the MSD->CommandLock to be help upon entry, unlocks upon return
*/

#undef DPF_MODNAME
#define DPF_MODNAME "DoCancel"

HRESULT
DoCancel(PMSD pMSD, HRESULT CompletionCode)
{
	PEPD	pEPD;
	HRESULT	hr = DPN_OK;

	DPFX(DPFPREP,7, "Cancelling pMSD=%p", pMSD);

	AssertCriticalSectionIsTakenByThisThread(&pMSD->CommandLock, TRUE);

	if (!(pMSD->ulMsgFlags1 & MFLAGS_ONE_IN_USE))
	{
		DPFX(DPFPREP,0, "(%p) MSD is in Pool, returning DPNERR_CANNOTCANCEL, pMSD[%p]", pMSD->pEPD, pMSD);
		ASSERT(0);
		Unlock(&pMSD->CommandLock);
		return DPNERR_CANNOTCANCEL;
	}

	if(pMSD->ulMsgFlags1 & (MFLAGS_ONE_CANCELLED | MFLAGS_ONE_COMPLETE))
	{
		DPFX(DPFPREP,7, "(%p) MSD is Cancelled or Complete, returning DPNERR_CANNOTCANCEL, pMSD[%p]", pMSD->pEPD, pMSD);
		Unlock(&pMSD->CommandLock);
		return DPNERR_CANNOTCANCEL;
	}

	pMSD->ulMsgFlags1 |= MFLAGS_ONE_CANCELLED;
	
	switch(pMSD->CommandID)
	{
		case COMMAND_ID_SEND_DATAGRAM:

			pEPD = pMSD->pEPD;
			ASSERT_EPD(pEPD);

			Lock(&pEPD->EPLock);
			
			if(pMSD->ulMsgFlags2 & (MFLAGS_TWO_ABORT | MFLAGS_TWO_TRANSMITTING | MFLAGS_TWO_SEND_COMPLETE))
			{				
				DPFX(DPFPREP,7, "(%p) MSD is Aborted, Transmitting, or Complete, returning DPNERR_CANNOTCANCEL, pMSD[%p]", pEPD, pMSD);
				Unlock(&pEPD->EPLock);					// Link is dropping or DNET is terminating
				hr = DPNERR_CANNOTCANCEL;						// To cancel an xmitting reliable send you
				break;											// must Abort the connection.
			}
			
			pMSD->blQLinkage.RemoveFromList();							// Remove from SendQueue (whichever one)

			ASSERT(pEPD->uiQueuedMessageCount > 0);
			--pEPD->uiQueuedMessageCount;								// keep count of MSDs on all send queues

			// Clear data-ready flag if everything is sent
			if((pEPD->uiQueuedMessageCount == 0) && (pEPD->pCurrentSend == NULL))
			{	
				pEPD->ulEPFlags &= ~(EPFLAGS_SDATA_READY);
			}

#ifdef DEBUG
			ASSERT(pMSD->ulMsgFlags2 & MFLAGS_TWO_ENQUEUED);
			pMSD->ulMsgFlags2 &= ~(MFLAGS_TWO_ENQUEUED);
#endif

			Unlock(&pEPD->EPLock);						// release lock on queue

			DPFX(DPFPREP,7, "(%p) Aborting Datagram send, pMSD[%p]", pEPD, pMSD);

			AbortDatagramSend(pMSD, CompletionCode); // Releases CommandLock
			return hr;
			
		case COMMAND_ID_SEND_RELIABLE:
		
			pEPD = pMSD->pEPD;
			ASSERT_EPD(pEPD);
			
			Lock(&pEPD->EPLock);
			
			if(pMSD->ulMsgFlags2 & (MFLAGS_TWO_ABORT | MFLAGS_TWO_TRANSMITTING | MFLAGS_TWO_SEND_COMPLETE))
			{				
				DPFX(DPFPREP,7, "(%p) MSD is Aborted, Transmitting, or Complete, returning DPNERR_CANNOTCANCEL, pMSD[%p]", pEPD, pMSD);
				Unlock(&pEPD->EPLock);					// Link is dropping or DNET is terminating
				hr = DPNERR_CANNOTCANCEL;						// To cancel an xmitting reliable send you
				break;											// must Abort the connection.
			}
			
			if(pMSD->TimeoutTimer != NULL)
			{
				DPFX(DPFPREP,7, "(%p) Cancelling Timeout Timer", pEPD);
				if(CancelMyTimer(pMSD->TimeoutTimer, pMSD->TimeoutTimerUnique) == DPN_OK)
				{
					DECREMENT_MSD(pMSD, "Send Timeout Timer");
				}
				else
				{
					DPFX(DPFPREP,7, "(%p) Cancelling Timeout Timer Failed", pEPD);
				}
				pMSD->TimeoutTimer = NULL;
			}
			
			pMSD->blQLinkage.RemoveFromList();							// Remove cmd from queue

			ASSERT(pEPD->uiQueuedMessageCount > 0);
			--pEPD->uiQueuedMessageCount;								// keep count of MSDs on all send queues

			// Clear data-ready flag if everything is sent
			if((pEPD->uiQueuedMessageCount == 0) && (pEPD->pCurrentSend == NULL))
			{	
				pEPD->ulEPFlags &= ~(EPFLAGS_SDATA_READY);
			}

#ifdef DEBUG
			ASSERT(pMSD->ulMsgFlags2 & MFLAGS_TWO_ENQUEUED);
			pMSD->ulMsgFlags2 &= ~(MFLAGS_TWO_ENQUEUED);
#endif

			// This only gets complex if the cancelled send was the "on deck" send for the endpoint.
			//
			// New Logic!  With advent of priority sending,  we can no longer prepare the On Deck send before we are
			// ready to transmit since the arrival of a higher priority send should be checked for before starting to
			// send a new message. This means that pCurrentSend != pMSD unless the MFLAGS_TRANSMITTING flag has also
			// been set,  rendering the message impossible to cancel.

			ASSERT(pEPD->pCurrentSend != pMSD);
			pMSD->uiFrameCount = 0;
			DPFX(DPFPREP, DPF_FRAMECNT_LVL, "Send cancelled before sending, pMSD[%p], framecount[%u]", pMSD, pMSD->uiFrameCount);

			
			Unlock(&pEPD->EPLock);

			DPFX(DPFPREP,7, "(%p) Completing Reliable Send", pEPD);
			CompleteReliableSend(pMSD->pSPD, pMSD, CompletionCode);
			
			return hr;
			
		case COMMAND_ID_CONNECT:
			
			if(pMSD->ulMsgFlags1 & MFLAGS_ONE_IN_SERVICE_PROVIDER)
			{
				// SP owns the command - issue a cancel and let CompletionEvent clean up command
				
				Unlock(&pMSD->CommandLock);				// We could deadlock if we cancel with lock held

				DPFX(DPFPREP,DPF_CALLOUT_LVL, "Calling SP->CancelCommand on Connect, pMSD[%p], hCommand[%x], pSPD[%p]", pMSD, pMSD->hCommand, pMSD->pSPD);
				(void) IDP8ServiceProvider_CancelCommand(pMSD->pSPD->IISPIntf, pMSD->hCommand, pMSD->dwCommandDesc);
				
				// If the SP Cancel fails it should not matter.  It would usually mean we are
				// in a race with the command completing,  in which case the cancel flag will
				// nip it in the bud.

				return DPN_OK;
			}

			// We will only get here once because the entry to this function checks CANCEL and COMPLETE and sets
			// CANCEL.  CompleteConnect will set COMPLETE as well.

			pEPD = pMSD->pEPD;
			ASSERT_EPD(pEPD);

			Lock(&pEPD->EPLock);
			
			// Unlink the MSD from the EPD
			ASSERT(pEPD->pCommand == pMSD);
			pEPD->pCommand = NULL;
			DECREMENT_MSD(pMSD, "EPD Ref");

			DropLink(pEPD); // This unlocks the EPLock

			// MSD lock still held
			DPFX(DPFPREP,5, "(%p) Connect cancelled, completing Connect, pMSD[%p]", pEPD, pMSD);
			CompleteConnect(pMSD, pMSD->pSPD, NULL, DPNERR_USERCANCEL); // releases command lock

			return DPN_OK;
			
		case COMMAND_ID_LISTEN:

			/*
			**		Cancel Listen
			**
			**		SP will own parts of the MSD until the SPCommandComplete function is called.  We will
			**	defer much of our cancel processing to this handler.
			*/

			// Stop listening in SP -- This will prevent new connections from popping up while we are
			// closing down any left in progress.  Only problem is we need to release command lock to
			// do it.

			Unlock(&pMSD->CommandLock);								// We can deadlock if we hold across this call

			DPFX(DPFPREP,DPF_CALLOUT_LVL, "Calling SP->CancelCommand on Listen, pMSD[%p], hCommand[%x], pSPD[%p]", pMSD, pMSD->hCommand, pMSD->pSPD);
			(void) IDP8ServiceProvider_CancelCommand(pMSD->pSPD->IISPIntf, pMSD->hCommand, pMSD->dwCommandDesc);

			Lock(&pMSD->CommandLock);								// Lock this down again.
			
			// Are there any connections in progress?
			// For a Listen command, connecting endpoints are held on the blFrameList
			while(!pMSD->blFrameList.IsEmpty())
			{				
				pEPD = CONTAINING_RECORD(pMSD->blFrameList.GetNext(), EPD, blSPLinkage);
				ASSERT_EPD(pEPD);

				DPFX(DPFPREP,1, "FOUND CONNECT IN PROGRESS ON CANCELLED LISTEN, EPD=%p", pEPD);

				Lock(&pEPD->EPLock);

				// Ensure we don't stay in this loop forever
				pEPD->ulEPFlags &= ~(EPFLAGS_LINKED_TO_LISTEN);
				pEPD->blSPLinkage.RemoveFromList();				// Unlink EPD from Listen Queue

				// It is possible that RejectInvalidPacket is happening at the same time as this, so guard against us
				// both doing the same clean up and removing the same reference from the MSD.
				if (!(pEPD->ulEPFlags & EPFLAGS_STATE_TERMINATING))
				{
					// We know this only happens once because anyone who does it either transitions us to the
					// CONNECTED or TERMINATING state, and also removes us from the Listen list above.

					// Unlink MSD from EPD
					ASSERT(pEPD->pCommand == pMSD);					// This should be pointing back to this listen
					pEPD->pCommand = NULL;
					DECREMENT_MSD(pMSD, "EPD Ref");					// Unlink from EPD and release associated reference

					DropLink(pEPD); // releases EPLock
				}
				else
				{
					Unlock(&pEPD->EPLock);
				}
			}	// for each connection in progress
			
			RELEASE_MSD(pMSD, "(Base Ref) Release On Cancel");	// release base reference
			
			return DPN_OK;
	
		case COMMAND_ID_ENUM:
		{
			Unlock(&pMSD->CommandLock);

			DPFX(DPFPREP,DPF_CALLOUT_LVL, "Calling SP->CancelCommand on Enum, pMSD[%p], hCommand[%x], pSPD[%p]", pMSD, pMSD->hCommand, pMSD->pSPD);
			return IDP8ServiceProvider_CancelCommand(pMSD->pSPD->IISPIntf, pMSD->hCommand, pMSD->dwCommandDesc);
			
			// We will pass HRESULT from SP directly to user
		}
		case COMMAND_ID_ENUMRESP:			
		{
			Unlock(&pMSD->CommandLock);

			DPFX(DPFPREP,DPF_CALLOUT_LVL, "Calling SP->CancelCommand on EnumResp, pMSD[%p], hCommand[%x], pSPD[%p]", pMSD, pMSD->hCommand, pMSD->pSPD);
			return IDP8ServiceProvider_CancelCommand(pMSD->pSPD->IISPIntf, pMSD->hCommand, pMSD->dwCommandDesc);
			
			// We will pass HRESULT from SP directly to user
		}

		case COMMAND_ID_DISCONNECT:
		case COMMAND_ID_COPIED_RETRY:		// This should be on FMD's only
		case COMMAND_ID_CFRAME:				// This should be on FMD's only
		case COMMAND_ID_DISC_RESPONSE:		// These are never placed on the global list and aren't cancellable
		case COMMAND_ID_KEEPALIVE:			// These are never placed on the global list and aren't cancellable
		default:
			ASSERT(0);		// Should never get here
			hr = DPNERR_CANNOTCANCEL;
			break;
	}

	Unlock(&pMSD->CommandLock);
	
	return hr;
}


/*
**		Get Listen Info
**
**		Return a buffer full of interesting and provokative tidbits about a particular Listen command.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "DNPGetListenAddressInfo"

HRESULT
DNPGetListenAddressInfo(HANDLE hCommand, PSPGETADDRESSINFODATA pSPData)
{
	PMSD	pMSD = (PMSD) hCommand;
	HRESULT	hr = DPNERR_INVALIDHANDLE;

	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: hCommand[%x], pSPData[%p]", hCommand, pSPData);

	ASSERT(pMSD != NULL);
	ASSERT_MSD(pMSD);

	if((pMSD->CommandID == COMMAND_ID_LISTEN) && (pMSD->ulMsgFlags1 & MFLAGS_ONE_IN_SERVICE_PROVIDER))
	{
		pSPData->hEndpoint = pMSD->hListenEndpoint;

		DPFX(DPFPREP,DPF_CALLOUT_LVL, "Calling SP->GetAddressInfo, pMSD[%p], hEndpoint[%x], pSPD[%p]", pMSD, pMSD->hListenEndpoint, pMSD->pSPD);
		hr = IDP8ServiceProvider_GetAddressInfo(pMSD->pSPD->IISPIntf, pSPData);
	}

	return hr;
}

/*
**		Validate End Point
**
**		This routine checks standard flags,  validates the Service
**	Provider,  and bumps the reference count on an end point descriptor
**	which is passed in.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "ValidateEndPoint"

HRESULT
ValidateEndPoint(PEPD pEPD)
{
	if(pEPD == NULL)
	{
		DPFX(DPFPREP,1, "Validate EndPoint Fails on NULL EPD", pEPD);
		return DPNERR_INVALIDENDPOINT;
	}
		
	if (pEPD->Sign != EPD_SIGN)
	{
		DPFX(DPFPREP,1, "Validate EndPoint Fails on EPD with bad sign (%p)", pEPD);
		return DPNERR_INVALIDENDPOINT;
	}	
	// Bump reference count on this baby
	if(!LOCK_EPD(pEPD, "LOCK (ValidateEndPoint - DISC)"))
	{
		// When LOCK_EPD returns FALSE, there is no ref placed on the endpoint, so we don't need to release
		DPFX(DPFPREP,1, "Validate EndPoint Fails on unreferenced EPD (%p)", pEPD);
		return DPNERR_INVALIDENDPOINT;
	}

	return DPN_OK;
}

/*
**		Disconnect End Point
**
**		This function is called when the client no longer wishes
**	to communicate with the specified end point.  We will initiate
**	the disconnect protocol with the endpoint,  and when it is
**	acknowleged,  we will disconnect the SP and release the handle.
**
**		Disconnect is defined in Direct Net to allow all previously
**	submitted sends to complete,  but no additional sends to be submitted.
**	Also, any sends the partner has in progress will be delivered,  but
**	no additional sends will be accepted following the indication that
**	a disconnect is in progress on the remote end.
**
**		This implies that two indications will be generated on the remote
**	machine,  Disconnect Initiated and Disconnect Complete.  Only the
**	Complete will be indicated on the issueing side.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "DNPDisconnectEndPoint"

HRESULT
DNPDisconnectEndPoint(PProtocolData pPData,  HANDLE hEndPoint, PVOID pvContext, PHANDLE phCommand)
{
	PEPD	pEPD;
	PMSD	pMSD;
	HRESULT	hr;

	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: pPData[%p], hEndPoint[%x], pvContext[%p], phCommand[%p]", pPData, hEndPoint, pvContext, phCommand);

	pEPD = (PEPD) hEndPoint;

	// This bumps REFCNT if it returns DPN_OK
	if((hr = ValidateEndPoint(pEPD)) != DPN_OK)
	{
		DPFX(DPFPREP,0, "Attempt to disconnect invalid endpoint");
		return hr;
	}

	Lock(&pEPD->EPLock);

	// If we aren't connected, or we have already initiated a disconnect, don't allow a new disconnect
	if(!(pEPD->ulEPFlags & EPFLAGS_STATE_CONNECTED) || (pEPD->ulEPFlags & (EPFLAGS_SENT_DISCONNECT | EPFLAGS_RECEIVED_DISCONNECT)))
	{
		RELEASE_EPD(pEPD, "UNLOCK (Validate EP)"); // Releases EPLock

		DPFX(DPFPREP,1, "Attempt to disconnect already disconnecting endpoint");
		return DPNERR_ALREADYDISCONNECTING;
	}

	pEPD->ulEPFlags |= EPFLAGS_SENT_DISCONNECT; 	// Accept no more sends, but don't scrap link yet

	if((pMSD = BuildDisconnectFrame(pEPD)) == NULL)
	{
		RELEASE_EPD(pEPD, "UNLOCK (Validate EP)"); // Releases EPLock

		DPFX(DPFPREP,0, "Failed to build disconnect frame");
		return DPNERR_OUTOFMEMORY;								// The educated user will next try an Abort command
	}
	
	pMSD->CommandID = COMMAND_ID_DISCONNECT;
	pMSD->Context = pvContext;									// retain user's context value
	*phCommand = pMSD;											// pass back command handle

	// We borrow the reference placed above by ValidateEP for this.  It will be released
	// on completion of the Disconnect.
	ASSERT(pEPD->pCommand == NULL);
	pEPD->pCommand = pMSD;										// Store the disconnect command on the endpoint until it is complete

#ifdef DEBUG
	Lock(&pMSD->pSPD->SPLock);
	pMSD->blSPLinkage.InsertBefore( &pMSD->pSPD->blMessageList);
	pMSD->ulMsgFlags1 |= MFLAGS_ONE_ON_GLOBAL_LIST;
	Unlock(&pMSD->pSPD->SPLock);
#endif

	DPFX(DPFPREP,5, "(%p) Queueing DISCONNECT message", pEPD);
	EnqueueMessage(pMSD, pEPD);									// Enqueue Disc frame on SendQ

	Unlock(&pEPD->EPLock);
	
	return DPNERR_PENDING;
}

/*
**		Get/Set Protocol Caps
**
**		Return or Set information about the entire protocol.
**
*/

#undef DPF_MODNAME
#define DPF_MODNAME "DNPGetProtocolCaps"

HRESULT
DNPGetProtocolCaps(PProtocolData pPData, PDPN_CAPS pData)
{
	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: pPData[%p], pData[%p]", pPData, pData);
	
	ASSERT(pData->dwSize == sizeof(DPN_CAPS));
	ASSERT(pData->dwFlags == 0);

	pData->dwConnectTimeout = pPData->dwConnectTimeout;
	pData->dwConnectRetries = pPData->dwConnectRetries;
	pData->dwTimeoutUntilKeepAlive = pPData->tIdleThreshhold;
	
	return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DNPSetProtocolCaps"

HRESULT
DNPSetProtocolCaps(PProtocolData pPData, const DPN_CAPS * const pData)
{
	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: pPData[%p], pData[%p]", pPData, pData);

	ASSERT(pData->dwSize == sizeof(DPN_CAPS));
	ASSERT(pData->dwFlags == 0);
	
	pPData->dwConnectTimeout = pData->dwConnectTimeout;
	pPData->dwConnectRetries = pData->dwConnectRetries;
	pPData->tIdleThreshhold = pData->dwTimeoutUntilKeepAlive;

	return DPN_OK;
}

/*
**		Get Endpoint Caps
**
**		Return information and statistics about a particular endpoint.
**
*/

#undef DPF_MODNAME
#define DPF_MODNAME "DNPGetEPCaps"

HRESULT
DNPGetEPCaps(HANDLE hEndpoint, PDPN_CONNECTION_INFO pBuffer)
{
	PEPD	pEPD;

	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: hEndpoint[%x], pBuffer[%p]", hEndpoint, pBuffer);

	pEPD = (PEPD) hEndpoint;
	
	if(pEPD == NULL || !(pEPD->ulEPFlags & EPFLAGS_STATE_CONNECTED))
	{
		DPFX(DPFPREP,0, "Returning DPNERR_INVALIDENDPOINT - hEndpoint is NULL or Enpoint is not connected");
		return DPNERR_INVALIDENDPOINT;
	}
	if(pBuffer == NULL)
	{
		DPFX(DPFPREP,0, "Returning DPNERR_INVALIDPARAM - pBuffer is NULL");
		return DPNERR_INVALIDPARAM;
	}
	
	ASSERT_EPD(pEPD);
	ASSERT(pBuffer->dwSize == sizeof(DPN_CONNECTION_INFO) ||
		   pBuffer->dwSize == sizeof(DPN_CONNECTION_INFO_INTERNAL));

    pBuffer->dwRoundTripLatencyMS = pEPD->uiRTT;
    pBuffer->dwThroughputBPS = pEPD->uiPeriodRateB * 4;				// Convert to apx of bytes/second (really bytes/1024 ms)
    pBuffer->dwPeakThroughputBPS = pEPD->uiPeakRateB * 4;

	pBuffer->dwBytesSentGuaranteed = pEPD->uiGuaranteedBytesSent;
	pBuffer->dwPacketsSentGuaranteed = pEPD->uiGuaranteedFramesSent;
	pBuffer->dwBytesSentNonGuaranteed = pEPD->uiDatagramBytesSent;
	pBuffer->dwPacketsSentNonGuaranteed = pEPD->uiDatagramFramesSent;

	pBuffer->dwBytesRetried = pEPD->uiGuaranteedBytesDropped;
	pBuffer->dwPacketsRetried = pEPD->uiGuaranteedFramesDropped;
	pBuffer->dwBytesDropped = pEPD->uiDatagramBytesDropped;
	pBuffer->dwPacketsDropped = pEPD->uiDatagramFramesDropped;

	pBuffer->dwMessagesTransmittedHighPriority = pEPD->uiMsgSentHigh;
	pBuffer->dwMessagesTimedOutHighPriority = pEPD->uiMsgTOHigh;
	pBuffer->dwMessagesTransmittedNormalPriority = pEPD->uiMsgSentNorm;
	pBuffer->dwMessagesTimedOutNormalPriority = pEPD->uiMsgTONorm;
	pBuffer->dwMessagesTransmittedLowPriority = pEPD->uiMsgSentLow;
	pBuffer->dwMessagesTimedOutLowPriority = pEPD->uiMsgTOLow;

	pBuffer->dwBytesReceivedGuaranteed = pEPD->uiGuaranteedBytesReceived;
	pBuffer->dwPacketsReceivedGuaranteed = pEPD->uiGuaranteedFramesReceived;
	pBuffer->dwBytesReceivedNonGuaranteed = pEPD->uiDatagramBytesReceived;
	pBuffer->dwPacketsReceivedNonGuaranteed = pEPD->uiDatagramFramesReceived;
		
	pBuffer->dwMessagesReceived = pEPD->uiMessagesReceived;

	if (pBuffer->dwSize == sizeof(DPN_CONNECTION_INFO_INTERNAL))
	{
		DPFX(DPFPREP,DPF_CALLIN_LVL, "(%p) Test App requesting extended internal parameters", pEPD);

		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->uiDropCount = pEPD->uiDropCount;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->uiThrottleEvents = pEPD->uiThrottleEvents;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->uiAdaptAlgCount = pEPD->uiAdaptAlgCount;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->uiWindowFilled = pEPD->uiWindowFilled;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->uiPeriodAcksBytes = pEPD->uiPeriodAcksBytes;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->uiPeriodXmitTime = pEPD->uiPeriodXmitTime;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->dwLastThroughputBPS = pEPD->uiLastRateB * 4;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->uiLastBytesAcked = pEPD->uiLastBytesAcked;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->uiQueuedMessageCount = pEPD->uiQueuedMessageCount;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->uiWindowF = pEPD->uiWindowF;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->uiWindowB = pEPD->uiWindowB;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->uiUnackedFrames = pEPD->uiUnackedFrames;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->uiUnackedBytes = pEPD->uiUnackedBytes;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->uiBurstGap = pEPD->uiBurstGap;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->iBurstCredit = pEPD->iBurstCredit;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->uiGoodWindowF = pEPD->uiGoodWindowF;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->uiGoodWindowB = pEPD->uiGoodWindowBI * pEPD->pSPD->uiFrameLength;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->uiGoodBurstGap = pEPD->uiGoodBurstGap;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->uiGoodRTT = pEPD->uiGoodRTT;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->uiRestoreWindowF = pEPD->uiRestoreWindowF;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->uiRestoreWindowB = pEPD->uiRestoreWindowBI * pEPD->pSPD->uiFrameLength;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->uiRestoreBurstGap = pEPD->uiRestoreBurstGap;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->bNextSend = pEPD->bNextSend;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->bNextReceive = pEPD->bNextReceive;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->ulReceiveMask = pEPD->ulReceiveMask;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->ulReceiveMask2 = pEPD->ulReceiveMask2;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->ulSendMask = pEPD->ulSendMask;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->ulSendMask2 = pEPD->ulSendMask2;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->uiCompleteMsgCount = pEPD->uiCompleteMsgCount;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->uiRetryTimeout = pEPD->uiRetryTimeout;
		((PDPN_CONNECTION_INFO_INTERNAL)pBuffer)->ulEPFlags = pEPD->ulEPFlags;
	}

	return DPN_OK;
}

/*		
**		Build Disconnect Frame
**
**		Build a DISC frame, a Message actually, because we return an MSD which can be inserted into
**	our reliable stream and will trigger one-side of the disconnect protocol when it is received
**	by a partner.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "BuildDisconnectFrame"

PMSD
BuildDisconnectFrame(PEPD pEPD)
{
	PFMD	pFMD;
	PMSD	pMSD;

	// Allocate and fill out a Message Descriptor for this operation
	
	if( (pMSD = static_cast<PMSD>( MSDPool->Get(MSDPool) )) == NULL)
	{
		DPFX(DPFPREP,0, "Failed to allocate MSD");
		return NULL;
	}

	pMSD->uiFrameCount = 1;
	DPFX(DPFPREP, DPF_FRAMECNT_LVL, "Initialize Frame count, pMSD[%p], framecount[%u]", pMSD, pMSD->uiFrameCount);
	pMSD->ulMsgFlags2 |= MFLAGS_TWO_END_OF_STREAM;
	pMSD->ulSendFlags = DN_SENDFLAGS_RELIABLE | DN_SENDFLAGS_LOW_PRIORITY; // Priority is LOW so all previously submitted traffic will be sent
	pMSD->pSPD = pEPD->pSPD;
	
	if((pFMD = static_cast<PFMD>( FMDPool->Get(FMDPool) )) == NULL)
	{
		DPFX(DPFPREP,0, "Failed to allocate FMD");
		Lock(&pMSD->CommandLock);
		RELEASE_MSD(pMSD, "Release On FMD Get Failed");
		return NULL;
	}

	pMSD->pEPD = pEPD;

	pFMD->CommandID = COMMAND_ID_SEND_RELIABLE;
	pFMD->ulFFlags |= FFLAGS_END_OF_STREAM;								// Mark this frame as Disconnect
	pFMD->bPacketFlags = PACKET_COMMAND_DATA | PACKET_COMMAND_RELIABLE | PACKET_COMMAND_SEQUENTIAL | PACKET_COMMAND_END_MSG;
	pFMD->uiFrameLength = 0;											// No user data in this frame
	pFMD->blMSDLinkage.InsertAfter( &pMSD->blFrameList);				// Attach frame to MSD
	pFMD->pMSD = pMSD;													// Link frame back to message
	pFMD->pEPD = pEPD;

	return pMSD;
}

/*
**		Abort Sends on Connection
**
**		Walk the EPD's send queues and cancel all sends awaiting service.  We might add
**	code to issue Cancel commands to the SP for frames still owned by SP.  On one hand,
**	we are not expecting a big backlog to develop in SP,  but on the other hand it still
**	might happen.  Esp, if we dont fix behavior I have observed with SP being really pokey
**	about completing transmitted sends.
**
**	**  CALLED WITH EPD->EPLock HELD;  RETURNS WITH LOCK RELEASED  **
*/

#undef DPF_MODNAME
#define DPF_MODNAME "AbortSendsOnConnection"

VOID
AbortSendsOnConnection(PEPD pEPD)
{
	PSPD	pSPD = pEPD->pSPD;
	PFMD	pFMD;
	PMSD	pMSD;
	CBilink	*pLink;
	CBilink	TempList;

	ASSERT_SPD(pSPD);
	AssertCriticalSectionIsTakenByThisThread(&pEPD->EPLock, TRUE);

	TempList.Initialize();										// We will empty all send queues onto this temporary list

	do 
	{
		if( (pLink = pEPD->blHighPriSendQ.GetNext()) == &pEPD->blHighPriSendQ)
		{
			if( (pLink = pEPD->blNormPriSendQ.GetNext()) == &pEPD->blNormPriSendQ)
			{
				if( (pLink = pEPD->blLowPriSendQ.GetNext()) == &pEPD->blLowPriSendQ)
				{
					if( (pLink = pEPD->blCompleteSendList.GetNext()) == &pEPD->blCompleteSendList)
					{
						break;										// ALL DONE - No more sends
					}
				}
			}
		}

		// We have found another send on one of our send queues.

		pLink->RemoveFromList();											// Remove it from the queue
		pMSD = CONTAINING_RECORD(pLink, MSD, blQLinkage);
		ASSERT_MSD(pMSD);
		pMSD->ulMsgFlags2 |= (MFLAGS_TWO_ABORT | MFLAGS_TWO_ABORT_WILL_COMPLETE);	// Do no further processing

#ifdef DEBUG
		pMSD->ulMsgFlags2 &= ~(MFLAGS_TWO_ENQUEUED);
#endif

		// If this MSD is a Disconnect, it will be caught by the code below that checks
		// pEPD->pCommand.  We don't want to end up putting it on the TempList twice.
		if (pMSD->CommandID != COMMAND_ID_DISCONNECT && pMSD->CommandID != COMMAND_ID_DISC_RESPONSE)
		{
			DPFX(DPFPREP,5, "(%p) ABORT SENDS.  Found (%p)", pEPD, pMSD);

			LOCK_MSD(pMSD, "AbortSends Temp Ref");
			pMSD->blQLinkage.InsertBefore( &TempList);				// Place on the temporary list
		}
	} 
	while (1);

	pEPD->uiQueuedMessageCount = 0;								// keep count of MSDs on all send queues

	if((pMSD = pEPD->pCommand) != NULL)
	{
		// There may be a DISCONNECT command waiting on this special pointer for the final DISC frame
		// from partner to arrive.

		pMSD->ulMsgFlags2 |= (MFLAGS_TWO_ABORT | MFLAGS_TWO_ABORT_WILL_COMPLETE);	// Do no further processing

		if(pMSD->CommandID == COMMAND_ID_DISCONNECT || pMSD->CommandID == COMMAND_ID_DISC_RESPONSE)
		{
			pEPD->pCommand = NULL;

			LOCK_MSD(pMSD, "AbortSends Temp Ref");
			pMSD->blQLinkage.InsertBefore( &TempList);

			// We will be indicating below, so make sure no one else does once we
			// leave the EPLock.
			ASSERT(!(pEPD->ulEPFlags & EPFLAGS_INDICATED_DISCONNECT));

			pEPD->ulEPFlags |= EPFLAGS_INDICATED_DISCONNECT;
		}
		else
		{
			DPFX(DPFPREP,0,"(%p) Any Connect or Listen on pCommand should have already been cleaned up", pEPD);
			ASSERT(!"Any Connect or Listen on pCommand should have already been cleaned up");
		}
	}

	//	If we clear out our SendWindow before we cancel the sends,  then we dont need to differentiate
	//	between sends that have or have not been transmitted.

	while(!pEPD->blSendWindow.IsEmpty())
	{
		pFMD = CONTAINING_RECORD(pEPD->blSendWindow.GetNext(), FMD, blWindowLinkage);
		ASSERT_FMD(pFMD);
		pFMD->ulFFlags &= ~(FFLAGS_IN_SEND_WINDOW);
		pFMD->blWindowLinkage.RemoveFromList();						// Eliminate each frame from the Send Window
		RELEASE_FMD(pFMD, "Send Window");
		DPFX(DPFPREP,5, "(%p) ABORT CONN:  Release frame from Window: pFMD=0x%p", pEPD, pFMD);
	}
	
	pEPD->pCurrentSend = NULL;
	pEPD->pCurrentFrame = NULL;

	while(!pEPD->blRetryQueue.IsEmpty())
	{
		pFMD = CONTAINING_RECORD(pEPD->blRetryQueue.GetNext(), FMD, blQLinkage);
		ASSERT_FMD(pFMD);
		pFMD->blQLinkage.RemoveFromList();
		pFMD->ulFFlags &= ~(FFLAGS_RETRY_QUEUED);				// No longer on the retry queue
		ASSERT_MSD(pFMD->pMSD);
		pFMD->pMSD->uiFrameCount--; // Protected by EPLock, retries count against outstanding frame count
		DPFX(DPFPREP, DPF_FRAMECNT_LVL, "Retry frame reference decremented on abort, pMSD[%p], framecount[%u]", pFMD->pMSD, pFMD->pMSD->uiFrameCount);
		DECREMENT_EPD(pEPD, "UNLOCK (Releasing Retry Frame)"); // SPLock not already held
		if (pFMD->CommandID == COMMAND_ID_COPIED_RETRY)
		{
			DECREMENT_EPD(pEPD, "UNLOCK (Copy Complete)"); // SPLock not already held
		}
		RELEASE_FMD(pFMD, "SP Submit");
	}
	pEPD->ulEPFlags &= ~(EPFLAGS_RETRIES_QUEUED);
		
	//	Now that we have emptied the EPD's queues we will release the EPLock so we can lock each
	//	MSD before we complete it.
	
	Unlock(&pEPD->EPLock);

	while(!TempList.IsEmpty())
	{
		pMSD = CONTAINING_RECORD(TempList.GetNext(), MSD, blQLinkage);
		ASSERT_MSD(pMSD);
		pMSD->blQLinkage.RemoveFromList();					// remove this send from temporary queue

		Lock(&pMSD->CommandLock);							// Complete call will Unlock MSD

		ASSERT(pMSD->ulMsgFlags1 & MFLAGS_ONE_IN_USE);

		switch(pMSD->CommandID)
		{
		case COMMAND_ID_SEND_RELIABLE:
		case COMMAND_ID_KEEPALIVE:
			{
				Lock(&pEPD->EPLock);

				pLink = pMSD->blFrameList.GetNext();
				while (pLink != &pMSD->blFrameList)
				{
					pFMD = CONTAINING_RECORD(pLink, FMD, blMSDLinkage);
					ASSERT_FMD(pFMD);

					// We don't allow a send to complete to the Core until uiFrameCount goes to zero indicating that all frames
					// of the message are out of the SP.  We need to remove references from uiFrameCount for any frames that 
					// never were transmitted.  Frames and retries that were transmitted will have their references removed in 
					// DNSP_CommandComplete when the SP completes them.
					if (!(pFMD->ulFFlags & FFLAGS_TRANSMITTED))
					{
						pMSD->uiFrameCount--; // Protected by EPLock
						DPFX(DPFPREP, DPF_FRAMECNT_LVL, "Frame count decremented on abort for non-transmitted frame, pMSD[%p], framecount[%u]", pMSD, pMSD->uiFrameCount);
					}

					pLink = pLink->GetNext();
				}
				if (pMSD->uiFrameCount == 0) // Protected by EPLock
				{
					if (pMSD->ulMsgFlags2 & MFLAGS_TWO_ABORT_WILL_COMPLETE)
					{
						DPFX(DPFPREP, DPF_FRAMECNT_LVL, "Completing, pMSD[%p], framecount[%u]", pMSD, pMSD->uiFrameCount);

						DECREMENT_MSD(pMSD, "AbortSends Temp Ref");

						// See what error code we need to return
						if(pMSD->ulMsgFlags2 & MFLAGS_TWO_SEND_COMPLETE)
						{
							Unlock(&pEPD->EPLock);
							CompleteReliableSend(pSPD, pMSD, DPN_OK); // This releases the CommandLock
						}
						else
						{
							Unlock(&pEPD->EPLock);
							CompleteReliableSend(pSPD, pMSD, DPNERR_CONNECTIONLOST); // This releases the CommandLock
						}
					}
					else
					{
						DPFX(DPFPREP, DPF_FRAMECNT_LVL, "SP Completion has already completed MSD to the Core, pMSD[%p], framecount[%u]", pMSD, pMSD->uiFrameCount);
						Unlock(&pEPD->EPLock);
						RELEASE_MSD(pMSD, "AbortSends Temp Ref"); // Releases CommandLock
					}
				}
				else
				{
					DPFX(DPFPREP, DPF_FRAMECNT_LVL, "Frames still out, pMSD[%p], framecount[%u]", pMSD, pMSD->uiFrameCount);
					Unlock(&pEPD->EPLock);
					RELEASE_MSD(pMSD, "AbortSends Temp Ref"); // Releases CommandLock
				}
			}
			break;
		case COMMAND_ID_SEND_DATAGRAM:
			{
				Lock(&pEPD->EPLock);
				if (pMSD->ulMsgFlags2 & MFLAGS_TWO_ABORT_WILL_COMPLETE)
				{
					DPFX(DPFPREP, DPF_FRAMECNT_LVL, "Completing NG, pMSD[%p], framecount[%u]", pMSD, pMSD->uiFrameCount);

					DECREMENT_MSD(pMSD, "AbortSends Temp Ref");

					Unlock(&pEPD->EPLock);
					AbortDatagramSend(pMSD, DPNERR_CONNECTIONLOST); // Releases CommandLock
				}
				else
				{
					DPFX(DPFPREP, DPF_FRAMECNT_LVL, "SP Completion has already completed NG MSD to the Core, pMSD[%p], framecount[%u]", pMSD, pMSD->uiFrameCount);
					Unlock(&pEPD->EPLock);
					RELEASE_MSD(pMSD, "AbortSends Temp Ref"); // Releases CommandLock
				}
			}
			break;
		case COMMAND_ID_DISCONNECT:
		case COMMAND_ID_DISC_RESPONSE:
			{
				Lock(&pEPD->EPLock);

				pLink = pMSD->blFrameList.GetNext();
				while (pLink != &pMSD->blFrameList)
				{
					pFMD = CONTAINING_RECORD(pLink, FMD, blMSDLinkage);
					ASSERT_FMD(pFMD);

					// We don't allow a send to complete to the Core until uiFrameCount goes to zero indicating that all frames
					// of the message are out of the SP.  We need to remove references from uiFrameCount for any frames that 
					// never were transmitted.  Frames and retries that were transmitted will have their references removed in 
					// DNSP_CommandComplete when the SP completes them.
					if (!(pFMD->ulFFlags & FFLAGS_TRANSMITTED))
					{
						pMSD->uiFrameCount--; // Protected by EPLock
						DPFX(DPFPREP, DPF_FRAMECNT_LVL, "Frame count decremented on abort for non-transmitted frame, pMSD[%p], framecount[%u]", pMSD, pMSD->uiFrameCount);
					}

					pLink = pLink->GetNext();
				}
				if (pMSD->uiFrameCount == 0)
				{
					if (pMSD->ulMsgFlags2 & MFLAGS_TWO_ABORT_WILL_COMPLETE)
					{
						DPFX(DPFPREP, DPF_FRAMECNT_LVL, "Completing disconnect, pMSD[%p], framecount[%u]", pMSD, pMSD->uiFrameCount);
						Unlock(&pEPD->EPLock);
						DECREMENT_MSD(pMSD, "AbortSends Temp Ref");

						CompleteDisconnect(pMSD, pSPD, pEPD); // Releases CommandLock
					}
					else
					{
						DPFX(DPFPREP, DPF_FRAMECNT_LVL, "SP Completion has already completed MSD to the Core, pMSD[%p], framecount[%u]", pMSD, pMSD->uiFrameCount);
						Unlock(&pEPD->EPLock);
						RELEASE_MSD(pMSD, "AbortSends Temp Ref"); // Releases CommandLock
					}
				}
				else
				{
					DPFX(DPFPREP, DPF_FRAMECNT_LVL, "Frames still out, pMSD[%p], framecount[%u]", pMSD, pMSD->uiFrameCount);
					Unlock(&pEPD->EPLock);
					RELEASE_MSD(pMSD, "AbortSends Temp Ref"); // Releases CommandLock
				}
			}
			break;
		default:
			{
				DPFX(DPFPREP,0, "UNKNOWN COMMAND FOUND ON SEND Q");	
				ASSERT(0);
				RELEASE_MSD(pMSD, "AbortSends Temp Ref"); // Releases CommandLock
			}
			break;
		}
	}
}

/*
**		Abort Datagram Send
**
**
**	THIS IS ENTERED WITH MSD->COMMANDLOCK HELD, EXITS WITH IT RELEASED
*/

#undef DPF_MODNAME
#define DPF_MODNAME "AbortDatagramSend"

VOID
AbortDatagramSend(PMSD pMSD, HRESULT CompletionCode)
{
	PFMD	pFMD;
	CBilink	*pLink;

	AssertCriticalSectionIsTakenByThisThread(&pMSD->CommandLock, TRUE);

	if(pMSD->TimeoutTimer != NULL)
	{
		DPFX(DPFPREP,7, "Cancelling Timeout Timer");
		if(CancelMyTimer(pMSD->TimeoutTimer, pMSD->TimeoutTimerUnique) == DPN_OK)
		{
			DECREMENT_MSD(pMSD, "Timeout Timer");
		}
		else
		{
			DPFX(DPFPREP,7, "Cancelling Timeout Timer Failed");
		}
		pMSD->TimeoutTimer = NULL;
	}
					
	pLink = pMSD->blFrameList.GetNext();

	while(pLink != &pMSD->blFrameList)
	{
		pFMD = CONTAINING_RECORD(pLink, FMD, blMSDLinkage);
		ASSERT_FMD(pFMD);
		pLink = pLink->GetNext();
		if((pFMD->ulFFlags & FFLAGS_TRANSMITTED)==0)
		{
			pFMD->blMSDLinkage.RemoveFromList();
			RELEASE_FMD(pFMD, "MSD Frame List");
			pMSD->uiFrameCount--;
		}
	}

	if(pMSD->blFrameList.IsEmpty())
	{
		CompleteDatagramSend(pMSD->pSPD, pMSD, CompletionCode);
	}
	else
	{
		Unlock(&pMSD->CommandLock);
	}
}


#undef DPF_MODNAME
#define DPF_MODNAME "SetLinkParms"

VOID SetLinkParms(PEPD pEPD, PINT Data)
{
	if(Data[0])
	{
		pEPD->uiGoodWindowF = pEPD->uiWindowF = Data[0];
		pEPD->uiGoodWindowBI = pEPD->uiWindowBIndex = Data[0];
		
		pEPD->uiWindowB = pEPD->uiWindowBIndex * pEPD->pSPD->uiFrameLength;
		DPFX(DPFPREP,7, "** ADJUSTING WINDOW TO %d FRAMES", Data[0]);
	}
	if(Data[1])
	{
	}
	if(Data[2])
	{
		pEPD->uiGoodBurstGap = pEPD->uiBurstGap = Data[2];
		DPFX(DPFPREP,7, "** ADJUSTING GAP TO %d ms", Data[2]);
	}

	pEPD->uiPeriodAcksBytes = 0;
	pEPD->uiPeriodXmitTime = 0;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNP_Debug"

HRESULT WINAPI DNP_Debug(PProtocolData pPData, UINT OpCode, HANDLE EndPoint, PVOID Data)
{
	PEPD	pEPD = (PEPD) EndPoint;

	switch(OpCode)
	{
		case	1:
			/* Toggle link frozen state */
			pEPD->ulEPFlags ^= EPFLAGS_LINK_FROZEN;
			break;

		case	2:
			/* Toggle whether KeepAlives are on or off */
			pEPD->ulEPFlags ^= EPFLAGS_KEEPALIVE_RUNNING;
			break;

		case	5:
			/* Manually set link parameters */
			SetLinkParms(pEPD, (int *) Data);
			break;

		case	6:
			/* Toggle Dynamic/Static Link control */
			pEPD->ulEPFlags ^= EPFLAGS_LINK_STABLE;
			break;

		default:
			return DPNERR_GENERIC;
	}

	return DPN_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\lobby\handles.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       handles.h
 *  Content:    Handle manager header file
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  08/19/99	mjn		Created
 *	03/23/00	mjn		Revised to ensure 64-bit compliance 
 *  07/09/00	rmt		Added signature bytes
 *
 ***************************************************************************/

#ifndef __HANDLES_H__
#define __HANDLES_H__

typedef struct
{
	DWORD	dwSerial;
	union
	{
		void	*pvData;
		DWORD	dwIndex;
	} Entry;
} HANDLEELEMENT;

#define DPLSIGNATURE_HANDLESTRUCT		'THLL'
#define DPLSIGNATURE_HANDLESTRUCT_FREE	'LHL_'

typedef struct _HANDLESTRUCT
{
	DWORD				dwSignature;
	DWORD				dwNumHandles;
	DWORD				dwFirstFreeHandle;
	DWORD				dwLastFreeHandle;
	DWORD				dwNumFreeHandles;
	DWORD				dwSerial;
	DNCRITICAL_SECTION	dncs;
	HANDLEELEMENT		*HandleArray;
} HANDLESTRUCT;

HRESULT H_Grow(HANDLESTRUCT *const phs,
			   const DWORD dwIncSize);

HRESULT	H_Initialize(HANDLESTRUCT *const phs,
					 const DWORD dwInitialNum);

void H_Terminate(HANDLESTRUCT *const phs);

HRESULT H_Create(HANDLESTRUCT *const phs,
				 void *const pvData,
				 DWORD *const pHandle);

HRESULT	H_Destroy(HANDLESTRUCT *const phs,
				  const DWORD handle);

HRESULT H_Retrieve(HANDLESTRUCT *const phs,
				   const DWORD handle,
				   void **const ppvData);

HRESULT H_Enum(HANDLESTRUCT *const phs,
			   DWORD *const pdwNumHandles,
			   DWORD *const rgHandles);

#endif	// __HANDLES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\protocol\dnproti.h ===
/***************************************************************************
 *
 *  Copyright (C) 1997-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dnproti.h
 *  Content:    DirectPlay Protocol master internal header file.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/28/01    masonb  Created.
 *	06/06/01	minara	include comutil.h for COM usage
 *
 ***************************************************************************/

#ifndef __DNPROTI_H__
#define __DNPROTI_H__

// 
// Public includes
//
#include <windows.h>
#include <mmsystem.h>

// 
// DirectPlay public includes
//
#include "dplay8.h"
#include "dpsp8.h"

// 
// DirectPlay private includes
//
#include "osind.h"
#include "classbilink.h"
#include "fpm.h"
#include "dneterrors.h"
#include "dndbg.h"
#include "comutil.h"

// 
// Protocol private includes
//
#include "dnprot.h"
#include "internal.h"
#include "dnpextern.h"
#include "mytimer.h"
#include "frames.h"

#endif // __DNPROTI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\protocol\dnprot.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		DnProt.h
 *  Content:	This file contains structure definitions for the Direct Net protocol
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  11/06/98	ejs		Created
 *  07/01/2000  masonb  Assumed Ownership
 *
 ****************************************************************************/

#ifndef	_DNPROT_INCLUDED_
#define	_DNPROT_INCLUDED_


#define	VOL		volatile
/*
**		Internal Constants
*/

#define		DNP_MAX_HEADER_SIZE				36
#define		MAX_BUFFERS_IN_FRAME			12			// This is somewhat arbitrary. If someone wants more we can deal
#define		MAX_RETRIES						10
#define		MAX_RETRY_INTERVAL				5000		// clamp each single retry iteration at 5 seconds

#define		SMALL_BUFFER_SIZE				(1024 * 2)
#define		MEDIUM_BUFFER_SIZE				(1024 * 4)
#define		LARGE_BUFFER_SIZE				(1024 * 16)

/*
**		Signatures for data structures
*/

#define		PD_SIGN			' SDP'					// Protocol Data
#define		SPD_SIGN		' DPS'					// Service Provider Descriptor
#define		EPD_SIGN		' DPE'					// End Point Descriptor
#define		MSD_SIGN		' DSM'					// Message Descriptor
#define		FMD_SIGN		' DMF'					// Frame Descriptor
#define		RCD_SIGN		' DCR'					// Receive Descriptor

/*
**		Internal Data Structures
**
*/

typedef	struct	protocoldata	ProtocolData, *PProtocolData;
typedef struct	spdesc			SPD, *PSPD;
typedef	struct	endpointdesc 	EPD, *PEPD;
typedef struct	checkptdata		CHKPT, *PCHKPT;
typedef struct	messagedesc 	MSD, *PMSD;
typedef struct	framedesc		FMD, *PFMD;
typedef struct	recvdesc		RCD, *PRCD;

typedef struct _DN_PROTOCOL_INTERFACE_VTBL DN_PROTOCOL_INTERFACE_VTBL, *PDN_PROTOCOL_INTERFACE_VTBL;

/*	
**	Protocol Data
**
**		This structure contains all of the global state information for the
**	operating protocol.  It is grouped into a structure for (in)convenience
**	against the unlikely possibility that we ever need to run multiple instances
**	out of the same code.
*/


#define		PFLAGS_PROTOCOL_INITIALIZED			0x00000001

struct protocoldata 
{
	ULONG				ulProtocolFlags;	// State info about DN protocol
	PVOID				Parent;				// Direct Play Object
	DWORD				Sign;
	LONG				lSPActiveCount;	// Number of SPs currently bound to protocol

	DWORD				dwNextSessID;		// ID to assign to next session request

	DWORD				tIdleThreshhold;	// How long will we allow a link to be idle before Checkpointing
	
	DWORD				dwConnectTimeout;	// These two parameter control new connection commands
	DWORD				dwConnectRetries;
	
	PDN_PROTOCOL_INTERFACE_VTBL		pfVtbl;	//  Table of indication entry points in CORE

#ifdef DEBUG
	// For Debugging we will track the total number of receives outstanding in the higher layers
	// at all times.
	long ThreadsInReceive;
	long BuffersInReceive;
#endif
};

/*
**	Service Provider Descriptor
**
**		This structure describes a Service Provider that we are bound to.  It
**	contains at a minimum the vector table to call the SP,  and the SPID that
**	is combined with player IDs to make external DPIDs.  The SPID should also
**	be the index in the SPTable where this descriptor lives.
**
**		We will have one send thread per service provider,  so the thread handle
**	and its wait-event will live in this structure too.
**
**		Lower Edge Protocol Object
**
**		We will also use the SPD as the COM Object given to SP for our lower edge
**	interface.  This means that our Lower Vector Table must be the first field in
**	this structure,  and ref count must be second.
*/

#define	SPFLAGS_SEND_THREAD_SCHEDULED	0x0001	// SP has scheduled a thread to service command frames
#define	SPFLAGS_TERMINATING				0x4000	// SP is being removed

struct spdesc 
{
	IDP8SPCallbackVtbl	*LowerEdgeVtable;	// table used by this SP to call into us, MUST BE FIRST!!!
	UINT				Sign;
	ULONG				ulSPFlags;			// Flags describing this service provider
	IDP8ServiceProvider	*IISPIntf;			// ptr to SP Object
	PProtocolData		pPData;				// Ptr to owning protocol object
	UINT				uiFrameLength;		// Frame size available to us
	UINT				uiUserFrameLength;	// Frame size available to application
	UINT				uiLinkSpeed;		// Local link speed in BPS

	CBilink				blSendQueue;		// List of wire-ready packets to transmit over this SP
	CBilink				blPendingQueue;		// List of packets owned by SP - Shares Lock w/SendQ
	CBilink				blEPDActiveList;	// List of in use End Point Descriptors for this SP
	PVOID				SendHandle;			// Handle of send thread
	UINT				SendHandleUnique;	// Same

	DNCRITICAL_SECTION	SPLock;			// Guard access to sendQ

#ifdef DEBUG
	CBilink				blMessageList;		// List of in use Message Descriptors
#endif
};

/*
**	End Point Descriptor
**
**		An 'EPD' describes a Direct Network instance that we can communicate with.
**	This structure includes all session related information, statistics,  queues,  etc.
**	It will manage any of the three types of service simultaneously.
*/

#define	EPFLAGS_END_POINT_IN_USE		0x0001	// This EndPoint is allocated

// We are always in exactly one of these 4 states
#define	EPFLAGS_STATE_DORMANT			0x0002	// Connection protocol has not yet run
#define	EPFLAGS_STATE_CONNECTING		0x0004	// Attempting to establish reliable link
#define	EPFLAGS_STATE_CONNECTED			0x0008	// Reliable link established
#define	EPFLAGS_STATE_TERMINATING		0x0010	// This end point is being closed down

#define	EPFLAGS_SP_DISCONNECTED			0x0020  // Set when the SP has called ProcessSPDisconnect

#define	EPFLAGS_IN_RECEIVE_COMPLETE		0x0040	// A thread is running in ReceiveComplete routine
#define	EPFLAGS_LINKED_TO_LISTEN		0x0080	// During CONNECT this EPD is linked into the Listen MSD's queue

#define	EPFLAGS_LINK_STABLE				0x0100	// We think we have found the best current transmit parameters
#define	EPFLAGS_STREAM_UNBLOCKED		0x0200	// Reliable traffic is stopped (window or throttle)
#define	EPFLAGS_SDATA_READY				0x0400	// Reliable traffic in the pipe
#define	EPFLAGS_IN_PIPELINE				0x0800	// Indicates that EPD is in the SPD pipeline queue

#define	EPFLAGS_CHECKPOINT_INIT			0x1000	// Need to send a check point packet
#define	EPFLAGS_DELAYED_SENDMASK		0x2000	// unacked check point on wire
#define	EPFLAGS_DELAYED_NACK			0x4000	// Need to send masks for missing receives
#define	EPFLAGS_DELAY_ACKNOWLEDGE		0x8000	// We are waiting for back-traffic before sending ACK frame

#define	EPFLAGS_KEEPALIVE_RUNNING	0x00010000	// Checkpoint is running
#define	EPFLAGS_SENT_DISCONNECT		0x00020000	// We have sent a DISCONNECT and are waiting for confirm
#define	EPFLAGS_RECEIVED_DISCONNECT	0x00040000	// We have received a DISCONNECT and will send confirm when done sending
#define	EPFLAGS_DISCONNECT_ACKED	0x00080000	// We sent a DISCONNECT and it has been confirmed

#define	EPFLAGS_COMPLETE_SENDS		0x00100000	// There are Reliable MSDs waiting to be called back
#define	EPFLAGS_FILLED_WINDOW_BYTE	0x00200000	// Filled Byte-Based send window
#define	EPFLAGS_FILLED_WINDOW_FRAME	0x00400000	// We have filled the frame-based SendWindow at least once during last period
#define EPFLAGS_USE_POLL_DELAY		0x00800000	// We have two-way traffic,  so wait 5ms before responding to POLL frame

#define	EPFLAGS_ACKED_DISCONNECT		0x01000000	// Partner sent a DISCONNECT and we have confirmed it
#define	EPFLAGS_RETRIES_QUEUED		0x02000000	// Frames are waiting for retransmission
#define	EPFLAGS_THROTTLED_BACK		0x04000000	// temporary throttle is engaged to relieve congestion
#define	EPFLAGS_LINK_FROZEN				0x08000000	// DEBUG FLAG -- Do not run dynamic algorithm on this link

#define	EPFLAGS_INDICATED_DISCONNECT	0x10000000	// Ensure that we onlly call CORE once to indicate disconnection
#define	EPFLAGS_TESTING_GROWTH			0x20000000	// We are currently taking a growth sample
#define	EPFLAGS_PROCESSING_DISCONNECT	0x40000000	// Prevents multiple threads from completing a disconnect
#define	EPFLAGS_KILLED					0x80000000	// Someone has removed the 'base' reference to make this go away
													// We dont want to let this happen twice...

#define	MAX_RECEIVE_RANGE			64		// largest # of frames we will retain past a missing frame
#define MAX_FRAME_OFFSET			(MAX_RECEIVE_RANGE - 1)

#define	INITIAL_STATIC_PERIOD		(10 * 1000)		// How long does link remain static after finding set-point.
													// This value will double every time link finds the same set-point.

struct endpointdesc 
{
	HANDLE				hEndPt;				// Together with SP index uniquely defines an End Point we can reach
	LONG 				lRefCnt;			// Reference count
	UINT				Sign;				// Signature to validate data structure
	PSPD				pSPD;				// specifies the SP on which this remote instance lives
	ULONG VOL			ulEPFlags;			// End Point Flags
	PVOID				Context;			// Context value returned with all indications
	PMSD				pCommand;			// Connect or Listen command with which this end point was created or Disconnect cmd
	CBilink				blActiveLinkage;	// linkage for SPD list of active EndPoints
	CBilink				blSPLinkage;		// linkage to listen command during connect
	CBilink				blChkPtQueue;		// linkage for active CheckPoints

	UINT				uiUserFrameLength;	// Largest frame we can transmit

	UINT				uiRTT;				// Current RTT --  Integer portion
	UINT				fpRTT;				// Fixed Point 16.16 RTT
	
	UINT				uiDropCount;		// localized packet drop count (recent drops)
	DWORD				tThrottleTime;		// Timestamp when last Checking occured
	UINT				uiThrottleEvents;	// count of temporary backoffs for all reasons
	
	UINT				uiAdaptAlgCount;	// Acknowledge count remaining before running adaptive algorithm
	DWORD				tLastPacket;		// Timestamp when last packet arrived
	
	UINT				uiWindowFilled;		// Count of times we fill the send window
	
	UINT				uiPeriodAcksBytes;	// frames acked since change in tuning
	UINT				uiPeriodXmitTime;	// time link has been transmitting since change in tuning
	UINT				uiPeriodRateB;
	UINT				uiPeakRateB;		// Largest sample we ever measure
	
	// While we are in DYNAMIC state we want to remember stats from our previous xmit parameters,  at this
	// point that means RTT and AvgSendRate.  This lets us compare the measurements at our new rate so we can
	// ensure that thruput increases with sendrate,  and that RTT is not growing out of proportion.
	//
	//   If either thru-put stops improving or RTT grows unreasonably then we can plateau our xmit parameters
	// and transition to STABLE state.

	UINT				uiLastRateB;
	UINT				uiLastBytesAcked;
	DWORD				tLastThruPutSample;

	// Connection State		-	 State of reliable connection
	//
	//	Send Queuing is getting somewhat complex.  Let me spell it out in Anglish.
	//
	//	blXPriSendQ		is the list of MSDs awaiting shipment (and being shipped)
	//	CurrentSend		pts to the MSD we are currently pulling frames out of.
	//  CurrentFrame 	pts to the next FMD that we will put on the wire.
	//	blSendWindow	is a bilinked list of transmitted but unacknowledged frames.  This list may span multi MSDs
	//
	//	WindowF			is our current MAX window size expressed in frames
	//	WindowB			is our current MAX window size expressed in bytes
	//
	//	UnAckedFrames	is the count of unacknowledged frames on the wire (actual window size)
	//	UnAckedBytes	is the count of unacknowledged bytes on the wire

	DWORD				uiQueuedMessageCount;	// How many MSDs are waiting on all three send queues

	CBilink				blHighPriSendQ;		// These are now mixed Reliable and Datagram traffic
	CBilink				blNormPriSendQ;
	CBilink				blLowPriSendQ;
	CBilink				blCompleteSendList;	// Reliable messages completed and awaiting indication to user

	DWORD				dwSessID;			// Session ID so we can detect re-started links
	PMSD				pCurrentSend;		// Head of queue is lead edge of window.  window can span multiple frames.
	PFMD				pCurrentFrame;		// frame currently transmitting. this will be trailing edge of window
	CBilink				blSendWindow;
	CBilink				blRetryQueue;		// Packets waiting for re-transmission

	//		Lost Packet Lists
	//
	//		When we need to retry a packet and we discover that it is not reliable,  then we need to inform partner
	//	that he can stop waiting for the data.  We will piggyback this info on another frame if possible

	//		Current Transmit Parameters:
	
	UINT				uiWindowF;			// window size (frames)
	UINT				uiWindowB;			// window size (bytes)
	UINT				uiWindowBIndex;		// index (scaler) for byte-based window
	UINT				uiUnackedFrames;	// outstanding frame count
	UINT				uiUnackedBytes;		// outstanding byte count

	UINT				uiBurstGap;			// number of ms to wait between bursts
	INT					iBurstCredit;		// Either credit or deficit from previous Transmit Burst

	// 		Last Known Good Transmit Parameters --  Values which we believe are safe...

	UINT				uiGoodWindowF;
	UINT				uiGoodWindowBI;
	UINT				uiGoodBurstGap;
	UINT				uiGoodRTT;
	
	UINT				uiRestoreWindowF;
	UINT				uiRestoreWindowBI;
	UINT				uiRestoreBurstGap;
	DWORD				tLastDelta;			// Timestamp when we last modified xmit parms

	// 		Reliable Link State

	BYTE VOL			bNextSend;			// Next serial number to assign
	BYTE VOL			bNextReceive;		// Next frame serial we expect to receive

	// Group BYTE members for good packing
	BYTE VOL			bNextMsgID;			// Next ID for datagram frames ! NOW USED FOR CFRAMES ONLY
	BYTE				bLastDataRetry;		// Retry count on frame N(R) - 1

	//	The following fields are all for tracking reliable receives

	//  The next two fields allow us to return more state with every ACK packet.  Since each ack explicitly
	// names one frame,  the highest in-sequenced packet received so far,  we want to remember the arrival time
	// and the Retry count of this packet so we can report it in each ACK.  It will be the transmitter's
	// responsibility to ensure that a single data-point never gets processed more then once,  skewing our calcs.
	
	DWORD				tLastDataFrame;		// Timestamp from the arrival of N(R) - 1

	ULONG				ulReceiveMask;		// mask representing first 32 frames in our rcv window
	ULONG				ulReceiveMask2;		// second 32 frames in our window
	DWORD				tReceiveMaskDelta;	// timestamp when a new bit was last set in ReceiveMask (full 64-bit mask)

	ULONG				ulSendMask;			// mask representing unreliable send frames that have timed out and need
	ULONG				ulSendMask2;		// to be reported to receiver as missing.

	PRCD				pNewMessage;		// singly linked list of message elements
	PRCD				pNewTail;			// tail pointer for singly linked list of msg elements
	CBilink				blOddFrameList;		// Out Of Order frames
	CBilink				blCompleteList;		// List of MESSAGES ready to be indicated
	UINT				uiCompleteMsgCount;	// Count of messages on the CompleteList

	PVOID				SendTimer;			// Timer for next send-burst opportunity
	UINT				SendTimerUnique;

	UINT				uiRetryCount;		// This count is used during CONNECT processing
	UINT				uiRetryTimeout;		// Current T1 timer value
	
	PVOID				ConnectTimer;		// We used to share RetryTimer for connecting but we hit some race conditions when timers
	UINT				ConnectTimerUnique;	// would fire as connections completed.  This will close these windows at cost of 8 bytes/EPD
	
	PVOID				RetryTimer;			// window to receive Ack
	UINT				RetryTimerUnique;	
	
	PVOID				DelayedAckTimer;	// wait for piggyback opportunity before sending Ack
	UINT				DelayedAckTimerUnique;

	PVOID				DelayedMaskTimer;	// wait for piggyback opportunity before sending
	UINT				DelayedMaskTimerUnique;
	
	PVOID				BGTimer;			// Periodic background timer
	UINT				BGTimerUnique;		// serial for background timer

	UINT				uiBytesAcked;
	
	//	Link statistics
	//
	//	All of the following stuff is calculated and stored here for the purpose of reporting in the ConnectionInfo structure
	
	UINT 				uiMsgSentHigh;
	UINT 				uiMsgSentNorm;
	UINT 				uiMsgSentLow;
	UINT 				uiMsgTOHigh;
	UINT 				uiMsgTONorm;
	UINT 				uiMsgTOLow;
	
	UINT 				uiMessagesReceived;

	UINT				uiGuaranteedFramesSent;
	UINT				uiGuaranteedBytesSent;
	UINT				uiDatagramFramesSent;
	UINT				uiDatagramBytesSent;

	UINT				uiGuaranteedFramesReceived;
	UINT				uiGuaranteedBytesReceived;
	UINT				uiDatagramFramesReceived;
	UINT				uiDatagramBytesReceived;

	UINT				uiDatagramFramesDropped;	// datagram frame we failed to  deliver
	UINT				uiDatagramBytesDropped;		// datagram bytes we didnt deliver
	UINT				uiGuaranteedFramesDropped;
	UINT				uiGuaranteedBytesDropped;

	DNCRITICAL_SECTION	EPLock;				// Serialize all access to Endpoint

#ifdef DEBUG
	UINT				uiTotalThrottleEvents;
	BYTE				bLastDataSeq;		// for DEBUG porpoises
	CHAR				LastPacket[32]; 	// record last packet received on EPD
#endif	
};

/*
**		Check Point Data
**
**		Keeps track of local-end info about a checkpoint in-progress.
*/

struct checkptdata 
{
	CBilink			blLinkage;				// Linkage for list of CPs on an EndPoint
	DWORD			tTimestamp;				// Local time at start of checkpoint
	UCHAR			bMsgID;					// Msg ID expected in CP response
};

/*
**	Descriptor IDs
**
**		Any Descriptor that may be submitted to an SP as a context must have
**	a field which allows us to determine which structure is returned in a
**	completion call.  This field must obviously be in a uniform place in all
**	structures,  and could be expanded to be a command specifier as well.
**	Done!  Lets call it a command ID.
*/

typedef enum CommandID 
{
	COMMAND_ID_NONE,
	COMMAND_ID_SEND_RELIABLE,
	COMMAND_ID_SEND_DATAGRAM,
	COMMAND_ID_CONNECT,
	COMMAND_ID_LISTEN,
	COMMAND_ID_ENUM,
	COMMAND_ID_ENUMRESP,
	COMMAND_ID_DISCONNECT,
	COMMAND_ID_DISC_RESPONSE,
	COMMAND_ID_CFRAME,
	COMMAND_ID_KEEPALIVE,
	COMMAND_ID_COPIED_RETRY,
} COMMANDID;


/*	Message Descriptor
**
**		An 'MSD' describes a message being sent or received by the protocol.  It keeps track
**	of the message elements, tracking which have been sent/received/acknowledged.
*/

//	Flags ONE field is protected by the MSD->CommandLock

#define		MFLAGS_ONE_IN_USE				0x0001
#define		MFLAGS_ONE_IN_SERVICE_PROVIDER	0x0002	// This MSD is inside an SP call
#define		MFLAGS_ONE_CANCELLED			0x0004	// command was cancelled while owned by SP
#define		MFLAGS_ONE_TIMEDOUT				0x0008	// sends only: timed out while event was scheduled
#define		MFLAGS_ONE_COMPLETE				0x0010	// connect only: operation is complete and indicated to Core

#ifdef DEBUG
#define		MFLAGS_ONE_COMPLETED_TO_CORE	0x4000
#define		MFLAGS_ONE_ON_GLOBAL_LIST		0x8000
#endif

// Flags TWO field is protected by the EPD->EPLock

#define		MFLAGS_TWO_TRANSMITTING			0x0001
#define		MFLAGS_TWO_SEND_COMPLETE		0x0002	// send command completed
#define		MFLAGS_TWO_ABORT				0x0004	// Send/Disconnect has been aborted. Do no further processing
#define		MFLAGS_TWO_END_OF_STREAM		0x0008	// This MSD is an EOS frame. Could be a user cmd or a response
#define		MFLAGS_TWO_KEEPALIVE			0x0010	// This MSD is an empty frame to exercise the reliable engine
#define		MFLAGS_TWO_ABORT_WILL_COMPLETE	0x0020	// AbortSendsOnConnection intends to complete this to the core, other functions can clear it

#ifdef DEBUG
#define		MFLAGS_TWO_ENQUEUED				0x1000	// This MSD is on one of the EPD SendQs
#endif

struct messagedesc 
{
	COMMANDID			CommandID;				// THIS MUST BE FIRST FIELD
	LONG				lRefCnt;				// Reference count
	UINT				Sign;					// Signature
	ULONG VOL			ulMsgFlags1;			// State info serialized by MSD->CommandLock
	ULONG VOL			ulMsgFlags2;			// State info serialized by EPD->EPLock
	PEPD				pEPD;					// Destination End Point
	PSPD				pSPD;					// SP fielding this command
	PVOID				Context;				// User provided context value
	ULONG VOL			ulSendFlags;			// Flags submitted by User in send call
	INT					iMsgLength;				// Total length of user data
	UINT VOL			uiFrameCount;			// Number of frames needed to xmit data, protected by EPLock for reliables
	CBilink				blFrameList;			// List of frames to transport this message, or for a Listen, endpoints that are connecting
	CBilink				blQLinkage;				// linkage for various sendQs
	CBilink				blSPLinkage;			// linkage for SP command list, protected by SP->SPLock

	HANDLE				hCommand;				// handle when submitted to SP (used for connect & listen)
	DWORD				dwCommandDesc;			// Descriptor associated with hCommand
	HANDLE				hListenEndpoint;
	
	PVOID				TimeoutTimer;
	UINT				TimeoutTimerUnique;

	DNCRITICAL_SECTION	CommandLock;

#ifdef DEBUG
	CCallStack<10>		CallStackCoreCompletion;
#endif
};

/*
**		Frame Descriptor
**
**		There are two non-obvious things about the FMD structure.  First is that the built-in Buffer Descriptor array
**	has two elements defined in front of it.  The first element,  Reserved1 and Reserved2 are present to allow the Service
**	Provider to pre-pend a header buffer,  and the second element,  ImmediateLength and ImmediatePointer are for this
**	protocol to prepend its header.  The ImmediatePointer is initialized to point to the ImmediateData field.
**
**		The second thing is that the ulFFlags field is serialized with the ENDPOINTLOCK of the EPD which this frame is linked to.
**	This is good because every time the FFlags fields is modified we have already taken the EPLock already.  The exception to this
**	rule is when we are initializing the FMD.  In this case the FMD has not been loosed on the world yet so there cannot be any
**	contention for it.  We have seperated out the one flag,  FRAME_SUBMITTED, into its own BOOL variable because this one is
**	protected by the SP's SPLock,  and like the EPLock above,  it is already claimed when this flag gets modified.
*/

//#define		FFLAGS_IN_USE				0x0001
#define		FFLAGS_TRANSMITTED			0x0002
#define		FFLAGS_END_OF_MESSAGE		0x0004
#define		FFLAGS_END_OF_STREAM		0x0008

//#define		FFLAGS_FRAME_SUBMITTED		0x0010	// SP Currently owns this frame
#define		FFLAGS_RETRY_TIMER_SET		0x0020	// Just what it sounds like
#define		FFLAGS_NACK_RETRANSMIT_SENT	0x0040	// We sent a NACK initiated retry.
#define		FFLAGS_IN_SEND_WINDOW		0x0080	// This reliable frame has been transmitted and is waiting for Ack

#define		FFLAGS_CHECKPOINT			0x0100	// We are asking for a response
//#define		FFLAGS_KEEPALIVE			0x0200
//#define		FFLAGS_ACKED_BY_MASK		0x0400	// This has been acked out-of-order so its still in the SendWindow
#define		FFLAGS_RETRY_QUEUED			0x0800	// Frame currently sitting on the retry queue


//#define		FFLAGS_NEW_MESSAGE			0x10000
#define		FFLAGS_RELIABLE				0x20000
//#define		FFLAGS_SEQUENTIAL			0x40000
#define		FFLAGS_FINAL_ACK			0x80000

struct framedesc 
{
	UINT			CommandID;					// THIS MUST BE FIRST FIELD to match MSD
	LONG			lRefCnt;					// Reference count
	UINT			Sign;
	UINT			uiFrameLength;
	ULONG VOL		ulFFlags;
	BOOL VOL		bSubmitted;					// Pull out this one flag for protection
	PMSD			pMSD;						// owning message
	PEPD			pEPD;						// owning link;  ONLY VALID ON COMMAND FRAMES!
	BYTE			bPacketFlags;
	CBilink			blMSDLinkage;
	CBilink			blQLinkage;
	CBilink			blWindowLinkage;	
	
	UINT			uiRetry;					// number of times this frame has been transmitted
	DWORD			tTimestamp[MAX_RETRIES+1];	// timestamp of frame's transmission
	
	SPSENDDATA		SendDataBlock;				// Block to submit frame to SP
	CHAR			ImmediateData[DNP_MAX_HEADER_SIZE];

	// DO NOT MODIFY LAST FIVE FIELDS IN FRAME STRUCTURE

	UINT			uiReserved1;		// two resv fields are buf..
	LPVOID			lpReserved2;		// ..desc for SP to add header
	UINT			uiImmediateLength;			// These two lines constitute buffer descriptor
	LPVOID			lpImmediatePointer;			// for immediate data (our protocol headers)
	BUFFERDESC	 	rgBufferList[MAX_BUFFERS_IN_FRAME];	// KEEP THIS FIELD AT END SO WE CAN ADD BUFFERS DYNAMICALLY
};


/*
**		Receive Descriptor
**
**		This data structure tracks a  single buffer received from the network.
**	It may or may not constitute an entire message.
*/

typedef	enum 
{
	RBT_SERVICE_PROVIDER_BUFFER,
	RBT_PROTOCOL_BUFFER,
	RBT_DYNAMIC_BUFFER
}	BUFFER_TYPE;

//#define		RFLAGS_FRAME_OUT_OF_ORDER		0x0001	// This buffer was received out-of-order
#define		RFLAGS_FRAME_INDICATED_NONSEQ	0x0002	// This buffer was indicated out of order, but is still in Out of Order list
//#define		RFLAGS_ON_OUT_OF_ORDER_LIST		0x0004	//
//#define		RFLAGS_IN_COMPLETE_PROCESS		0x0008
#define		RFLAGS_FRAME_LOST				0x0010	// This RCD represents and Unreliable frame that has been lost

struct recvdesc 
{
	DWORD				tTimestamp;					// timestamp upon packets arrival
	LONG				lRefCnt;
	UINT				Sign;						// Signature to identify data structure
	UINT				uiDataSize;					// data in this frame
	UINT				uiFrameCount;				// frames in message
	UINT				uiMsgSize;					// total byte count of message
	BYTE				bSeq;						// Sequence number of this frame
	BYTE				bFrameFlags;				// Flag field from actual frame
	BYTE				bFrameControl;
	PBYTE				pbData;						// pointer to actual data
	UINT				ulRFlags;					// Receive flags
	CBilink				blOddFrameLinkage;			// BILINKage for queues
	CBilink				blCompleteLinkage;			// 2nd Bilink so RCD can remain in Out Of Order Queue after indication
	PRCD				pMsgLink;					// Single link for frame in message
	PSPRECEIVEDBUFFER	pRcvBuff;					// ptr to SP's receive data structure
};

typedef	struct buf		BUF, *PBUF;
typedef struct medbuf	MEDBUF, *PMEDBUF;
typedef	struct bigbuf	BIGBUF, *PBIGBUF;
typedef	struct dynbuf	DYNBUF, *PDYNBUF;

struct buf 
{
	LPFPOOL			Owner;							// ptr back to owning pool
	BUFFER_TYPE		Type;							// Identifies this as our buffer or SPs buffer
	BYTE			data[SMALL_BUFFER_SIZE];		// 2K small buffer for combining multi-frame sends
};

struct medbuf 
{
	LPFPOOL			Owner;							// ptr back to owning pool
	BUFFER_TYPE		Type;							// Identifies this as our buffer or SPs buffer
	BYTE			data[MEDIUM_BUFFER_SIZE];		// 4K mid size buffer
};

struct bigbuf 
{
	LPFPOOL			Owner;							// ptr back to owning pool
	BUFFER_TYPE		Type;							// Identifies this as our buffer or SPs buffer
	BYTE			data[LARGE_BUFFER_SIZE];		// ARBITRARY SIZE OF MAX SEND (16K)
};

struct dynbuf 
{
	LPFPOOL			Owner;							// ptr back to owning pool
	BUFFER_TYPE		Type;							// Identifies this as our buffer or SPs buffer
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\protocol\dnpextern.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dnpextern.h
 *  Content:    This header exposes protocol entry points to the rest of Direct Network
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  11/06/98    ejs     Created
 *  07/01/2000  masonb  Assumed Ownership
 *
 ***************************************************************************/


#ifdef	__cplusplus
extern	"C"
{
#endif	// __cplusplus

//	FOLLOWING FLAGS GO INTO PUBLIC HEADER FILE

#define	DN_CONNECTFLAGS_OKTOQUERYFORADDRESSING			0x00000001
#define	DN_CONNECTFLAGS_ADDITIONALMULTIPLEXADAPTERS		0x00000002	// there will be more adapters for this connect operation

#define	DN_LISTENFLAGS_OKTOQUERYFORADDRESSING			0x00000001

#define	DN_ENUMQUERYFLAGS_OKTOQUERYFORADDRESSING		0x00000001
#define	DN_ENUMQUERYFLAGS_NOBROADCASTFALLBACK			0x00000002
#define	DN_ENUMQUERYFLAGS_ADDITIONALMULTIPLEXADAPTERS	0x00000004	// there will be more adapters for this enum operation



#define	DN_SENDFLAGS_RELIABLE			0x00000001			// Deliver Reliably
#define	DN_SENDFLAGS_NON_SEQUENTIAL		0x00000002			// Deliver Upon Arrival
#define	DN_SENDFLAGS_HIGH_PRIORITY		0x00000004
#define	DN_SENDFLAGS_LOW_PRIORITY		0x00000008
#define	DN_SENDFLAGS_SET_USER_FLAG		0x00000040			// Protocol will deliver these two...
#define	DN_SENDFLAGS_SET_USER_FLAG_TWO	0x00000080			// ...flags to receiver

//	END OF PUBLIC FLAGS

typedef struct _DN_PROTOCOL_INTERFACE_VTBL DN_PROTOCOL_INTERFACE_VTBL, *PDN_PROTOCOL_INTERFACE_VTBL;

//
// structure used to pass enum data from the protocol to DPlay
//
typedef	struct	_PROTOCOL_ENUM_DATA
{
	IDirectPlay8Address	*pSenderAddress;		//
	IDirectPlay8Address	*pDeviceAddress;		//
	BUFFERDESC			ReceivedData;			//
	HANDLE				hEnumQuery;				// handle of this query, returned in enum response

} PROTOCOL_ENUM_DATA;


typedef	struct	_PROTOCOL_ENUM_RESPONSE_DATA
{
	IDirectPlay8Address	*pSenderAddress;
	IDirectPlay8Address	*pDeviceAddress;
	BUFFERDESC			ReceivedData;
	DWORD				dwRoundTripTime;

} PROTOCOL_ENUM_RESPONSE_DATA;

// Protocol data
typedef	struct	protocoldata	ProtocolData, *PProtocolData;
// Protocol endpoint descriptor
typedef	struct	endpointdesc 	EPD, *PEPD;

// Service Provider interface
typedef struct IDP8ServiceProvider       IDP8ServiceProvider;
// Service Provider info data strucure
typedef	struct	_SPGETADDRESSINFODATA SPGETADDRESSINFODATA, *PSPGETADDRESSINFODATA;
// Service Provider event type
typedef enum _SP_EVENT_TYPE SP_EVENT_TYPE;

// Init/Term calls

extern BOOL  DNPPoolsInit();
extern void  DNPPoolsDeinit();

extern HRESULT DNPProtocolInitialize(PVOID, PProtocolData, PDN_PROTOCOL_INTERFACE_VTBL);
extern HRESULT DNPAddServiceProvider(PProtocolData, IDP8ServiceProvider*, HANDLE *);
extern HRESULT DNPRemoveServiceProvider(PProtocolData, HANDLE);
extern HRESULT DNPProtocolShutdown(PProtocolData);

// Data Transfer

extern HRESULT DNPConnect(PProtocolData, IDirectPlay8Address *const, IDirectPlay8Address *const, const HANDLE, const ULONG, PVOID, PHANDLE);
extern HRESULT DNPListen(PProtocolData, IDirectPlay8Address *const, const HANDLE, ULONG, PVOID, PHANDLE);
extern HRESULT DNPSendData(PProtocolData, HANDLE, UINT, PBUFFERDESC, UINT, ULONG, PVOID, PHANDLE);
extern HRESULT DNPDisconnectEndPoint(PProtocolData, HANDLE, PVOID, PHANDLE);

// Misc Commands

extern HRESULT DNPCrackEndPointDescriptor(HANDLE, PSPGETADDRESSINFODATA);
extern HRESULT DNPCancelCommand(PProtocolData, HANDLE);

extern HRESULT DNPEnumQuery( PProtocolData pPData,
							 IDirectPlay8Address *const pHostAddress,
							 IDirectPlay8Address *const pDeviceAddress,
							 const HANDLE,
							 BUFFERDESC *const pBuffers,
							 const DWORD dwBufferCount,
							 const DWORD dwRetryCount,
							 const DWORD dwRetryInterval,
							 const DWORD dwTimeout,
							 const DWORD dwFlags,
							 void *const pUserContext,
							 HANDLE *const pCommandHandle );

extern HRESULT DNPEnumRespond( PProtocolData pPData,
						       const HANDLE hSPHandle,
							   const HANDLE hQueryHandle,				// handle of enum query being responded to
							   BUFFERDESC *const pResponseBuffers,	
							   const DWORD dwResponseBufferCount,
							   const DWORD dwFlags,
							   void *const pUserContext,
							   HANDLE *const pCommandHandle );

extern HRESULT DNPReleaseReceiveBuffer(HANDLE);

extern HRESULT DNPGetListenAddressInfo(HANDLE hCommand, PSPGETADDRESSINFODATA pSPData);
extern HRESULT DNPGetEPCaps(HANDLE, PDPN_CONNECTION_INFO);
extern HRESULT DNPSetProtocolCaps(PProtocolData pPData, const DPN_CAPS * const pData);
extern HRESULT DNPGetProtocolCaps(PProtocolData pPData, PDPN_CAPS pData);

extern HRESULT WINAPI DNP_Debug(ProtocolData *, UINT OpCode, HANDLE EndPoint, PVOID Data);

//	Lower Edge Entries

extern HRESULT WINAPI DNSP_IndicateEvent(IDP8SPCallback *, SP_EVENT_TYPE, PVOID);
extern HRESULT WINAPI DNSP_CommandComplete(IDP8SPCallback *, HANDLE, HRESULT, PVOID);

// V-TABLE FOR CALLS INTO CORE LAYER

typedef HRESULT (*PFN_PINT_INDICATE_ENUM_QUERY)
	(void *const pvUserContext,
	void *const pvEndPtContext,
	const HANDLE hCommand,
	void *const pvEnumQueryData,
	const DWORD dwEnumQueryDataSize);
typedef HRESULT (*PFN_PINT_INDICATE_ENUM_RESPONSE)
	(void *const pvUserContext,
	const HANDLE hCommand,
	void *const pvCommandContext,
	void *const pvEnumResponseData,
	const DWORD dwEnumResponseDataSize);
typedef HRESULT (*PFN_PINT_INDICATE_CONNECT)
	(void *const pvUserContext,
	void *const pvListenContext,
	const HANDLE hEndPt,
	void **const ppvEndPtContext);
typedef HRESULT (*PFN_PINT_INDICATE_DISCONNECT)
	(void *const pvUserContext,
	void *const pvEndPtContext);
typedef HRESULT (*PFN_PINT_INDICATE_CONNECTION_TERMINATED)
	(void *const pvUserContext,
	void *const pvEndPtContext,
	const HRESULT hr);
typedef HRESULT (*PFN_PINT_INDICATE_RECEIVE)
	(void *const pvUserContext,
	void *const pvEndPtContext,
	void *const pvData,
	const DWORD dwDataSize,
	const HANDLE hBuffer,
	const DWORD dwFlags);
typedef HRESULT (*PFN_PINT_COMPLETE_LISTEN)
	(void *const pvUserContext,
	void **const ppvCommandContext,
	const HRESULT hr,
	const HANDLE hEndPt);
typedef HRESULT (*PFN_PINT_COMPLETE_LISTEN_TERMINATE)
	(void *const pvUserContext,
	void *const pvCommandContext,
	const HRESULT hr);
typedef HRESULT (*PFN_PINT_COMPLETE_ENUM_QUERY)
	(void *const pvUserContext,
	void *const pvCommandContext,
	const HRESULT hr);
typedef HRESULT (*PFN_PINT_COMPLETE_ENUM_RESPONSE)
	(void *const pvUserContext,
	void *const pvCommandContext,
	const HRESULT hr);
typedef HRESULT (*PFN_PINT_COMPLETE_CONNECT)
	(void *const pvUserContext,
	void *const pvCommandContext,
	const HRESULT hr,
	const HANDLE hEndPt,
	void **const ppvEndPtContext);
typedef HRESULT (*PFN_PINT_COMPLETE_DISCONNECT)
	(void *const pvUserContext,
	void *const pvCommandContext,
	const HRESULT hr);
typedef HRESULT (*PFN_PINT_COMPLETE_SEND)
	(void *const pvUserContext,
	void *const pvCommandContext,
	const HRESULT hr);
typedef	HRESULT	(*PFN_PINT_ADDRESS_INFO_CONNECT)
	(void *const pvUserContext,
	 void *const pvCommandContext,
	 const HRESULT hr,
	 IDirectPlay8Address *const pHostAddress,
	 IDirectPlay8Address *const pDeviceAddress );
typedef	HRESULT	(*PFN_PINT_ADDRESS_INFO_ENUM)
	(void *const pvUserContext,
	 void *const pvCommandContext,
	 const HRESULT hr,
	 IDirectPlay8Address *const pHostAddress,
	 IDirectPlay8Address *const pDeviceAddress );
typedef	HRESULT	(*PFN_PINT_ADDRESS_INFO_LISTEN)
	(void *const pvUserContext,
	 void *const pvCommandContext,
	 const HRESULT hr,
	 IDirectPlay8Address *const pDeviceAddress );

struct _DN_PROTOCOL_INTERFACE_VTBL
{
	PFN_PINT_INDICATE_ENUM_QUERY			IndicateEnumQuery;
	PFN_PINT_INDICATE_ENUM_RESPONSE			IndicateEnumResponse;
	PFN_PINT_INDICATE_CONNECT				IndicateConnect;
	PFN_PINT_INDICATE_DISCONNECT			IndicateDisconnect;
	PFN_PINT_INDICATE_CONNECTION_TERMINATED	IndicateConnectionTerminated;
	PFN_PINT_INDICATE_RECEIVE				IndicateReceive;
	PFN_PINT_COMPLETE_LISTEN				CompleteListen;
	PFN_PINT_COMPLETE_LISTEN_TERMINATE		CompleteListenTerminate;
	PFN_PINT_COMPLETE_ENUM_QUERY			CompleteEnumQuery;
	PFN_PINT_COMPLETE_ENUM_RESPONSE			CompleteEnumResponse;
	PFN_PINT_COMPLETE_CONNECT				CompleteConnect;
	PFN_PINT_COMPLETE_DISCONNECT			CompleteDisconnect;
	PFN_PINT_COMPLETE_SEND					CompleteSend;
	PFN_PINT_ADDRESS_INFO_CONNECT			AddressInfoConnect;
	PFN_PINT_ADDRESS_INFO_ENUM				AddressInfoEnum;
	PFN_PINT_ADDRESS_INFO_LISTEN			AddressInfoListen;
};

#ifdef	__cplusplus
}
#endif	// __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\protocol\connect.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		Connect.cpp
 *  Content:	This file contains support for the CONNECT/DISCONNECT protocol in DirectNet.
 *				It is organized with FrontEnd routines first (Connect, Listen),
 *				and Backend handlers (timeouts,  frame crackers) after.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  11/11/98	ejs		Created
 *  07/01/2000  masonb  Assumed Ownership
 *
 ****************************************************************************/

#include "dnproti.h"


/***  FRONT END  ***/

/*
**		Connect
**
**			This function attempts to make a connection to a specified address.
**		The function establishes the existance of a DirectNet entity and maps
**		an EndPoint handle.  Then we exchange CONNECT packets which allows each
**		side to establish a baseline RTT.
**
*/

#undef DPF_MODNAME
#define DPF_MODNAME "DNPConnect"

HRESULT DNPConnect(	PProtocolData pPData,
							IDirectPlay8Address *const lpaLocal,
							IDirectPlay8Address *const lpaRemote,
							const HANDLE hSPHandle,
							const ULONG ulFlags,
							void *const Context,
							PHANDLE phHandle)
{
	PSPD			pSPD;						// Service Provider to handle this connect
	PMSD			pMSD;
	SPCONNECTDATA	ConnData;					// Parameter Block
	HRESULT			hr;

	// Determine which SP will take this call
	//

	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: pPData[%p], paLocal[%p], paRemote[%p], hSPHandle[%x], ulFlags[%x], Context[%p], phHandle[%p]", pPData, lpaLocal, lpaRemote, hSPHandle, ulFlags, Context, phHandle);

	pSPD = (PSPD) hSPHandle;
	ASSERT_SPD(pSPD);

	// Core should not call any Protocol APIs after calling DNPRemoveServiceProvider
	ASSERT(!(pSPD->ulSPFlags & SPFLAGS_TERMINATING));

	// We use an MSD to describe this op even though it isn't technically a message
	if((pMSD = static_cast<PMSD>( MSDPool->Get(MSDPool) )) == NULL)
	{	
		DPFX(DPFPREP,0, "Returning DPNERR_OUTOFMEMORY - failed to create new MSD");
		return DPNERR_OUTOFMEMORY;	
	}

	pMSD->CommandID = COMMAND_ID_CONNECT;
	pMSD->pSPD = pSPD;
	pMSD->Context = Context;

	ASSERT(pMSD->pEPD == NULL); // MSD_Get/Release ensures this, and IndicateConnect requires it.

	// Prepare to call SP to map the endpoint.
	ConnData.pAddressDeviceInfo = lpaLocal;
	ConnData.pAddressHost = lpaRemote;
	ConnData.dwReserved = 0;  // Never used

	DNASSERT( ( ulFlags & ~( DN_CONNECTFLAGS_OKTOQUERYFORADDRESSING | DN_CONNECTFLAGS_ADDITIONALMULTIPLEXADAPTERS ) ) == 0 );
	ConnData.dwFlags = 0;
	if ( ( ulFlags & DN_CONNECTFLAGS_OKTOQUERYFORADDRESSING ) != 0 )
	{
		ConnData.dwFlags |= DPNSPF_OKTOQUERY;
	}

	if ( ( ulFlags & DN_CONNECTFLAGS_ADDITIONALMULTIPLEXADAPTERS ) != 0 )
	{
		ConnData.dwFlags |= DPNSPF_ADDITIONALMULTIPLEXADAPTERS;
	}

	ConnData.pvContext = pMSD;
	ConnData.hCommand = 0;

	pMSD->ulMsgFlags1 |= MFLAGS_ONE_IN_SERVICE_PROVIDER;

#ifdef DEBUG
	// Hook up MSD before calling into SP
	Lock(&pSPD->SPLock);
	pMSD->blSPLinkage.InsertBefore( &pSPD->blMessageList);	// Put this on cmd list
	pMSD->ulMsgFlags1 |= MFLAGS_ONE_ON_GLOBAL_LIST;
	Unlock(&pSPD->SPLock);
#endif

	*phHandle = pMSD;

	// SP Connect call is guaranteed to return immediately

	LOCK_MSD(pMSD, "SP Ref");												// Add reference for call into SP
	LOCK_MSD(pMSD, "Temp Ref");

	DPFX(DPFPREP,DPF_CALLOUT_LVL, "Calling SP->Connect, pSPD[%p], pMSD[%p]", pSPD, pMSD);
/**/hr = IDP8ServiceProvider_Connect(pSPD->IISPIntf, &ConnData);		/** CALL SP **/

	if(hr != DPNERR_PENDING)
	{
		// SP Connect should always be asynchronous so if it isnt PENDING then it must have failed
		DPFX(DPFPREP,1, "SP->Connect did not return DPNERR_PENDING, assuming failure, hr[%x]", hr);

		ASSERT(hr != DPN_OK);

		Lock(&pMSD->CommandLock);								// This will be unlocked by final RELEASE_MSD

		pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_IN_SERVICE_PROVIDER);		// clear InSP flag

#ifdef DEBUG
		Lock(&pSPD->SPLock);
		pMSD->blSPLinkage.RemoveFromList();								// knock this off the pending list
		pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_ON_GLOBAL_LIST);
		Unlock(&pSPD->SPLock);
#endif

		DECREMENT_MSD(pMSD, "Temp Ref");
		DECREMENT_MSD(pMSD, "SP Ref");									// Remove one ref for SP call
		RELEASE_MSD(pMSD, "Release On Fail");							// Remove one ref to free resource

		DPFX(DPFPREP,1, "Returning hr[%x]", hr);
		return hr;
	}

	Lock(&pMSD->CommandLock);

	pMSD->hCommand = ConnData.hCommand;							// retain SP command handle
	pMSD->dwCommandDesc = ConnData.dwCommandDescriptor;

	RELEASE_MSD(pMSD, "Temp Ref"); // Unlocks CommandLock

	DPFX(DPFPREP,DPF_CALLIN_LVL, "Returning DPNERR_PENDING, pMSD[%p]", pMSD);
	return DPNERR_PENDING;
}

/*
**		Listen
**
**		This command tells DN that it should start to accept connection requests.
**	This command will return pending,  and will continue to indicate connections
**	until it is explicitly cancelled.  It may be desireable to establish a limit
**	mechanism of some sort,  but for the time being this will do.
**
**		Now it is desirable to Listen on multiple ports on a single adapter.  This
**	means that we need to accept multiple concurrent Listen commands on each adapter.
**	Another fact of life is that we need to crack the Target address far enough to
**	determine which SP to submit the Listen on.
*/



#undef DPF_MODNAME
#define DPF_MODNAME "DNPListen"

HRESULT DNPListen(	PProtocolData pPData,
							IDirectPlay8Address *const lpaTarget,
							// IDP8ServiceProvider* pISP,
							const HANDLE hSPHandle,
							ULONG ulFlags,
							PVOID Context,
							PHANDLE phHandle)
{
	PSPD			pSPD;
	PMSD			pMSD;
	SPLISTENDATA	ListenData;
	HRESULT			hr;

	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: pPData[%p], paTarget[%p], hSPHandle[%x], ulFlags[%x], Context[%p], phHandle[%p]", pPData, lpaTarget, hSPHandle, ulFlags, Context, phHandle);

	pSPD = (PSPD) hSPHandle;
	ASSERT_SPD(pSPD);

	// Core should not call any Protocol APIs after calling DNPRemoveServiceProvider
	ASSERT(!(pSPD->ulSPFlags & SPFLAGS_TERMINATING));

	// We use an MSD to describe this op even though it isn't technically a message
	if((pMSD = static_cast<PMSD>( MSDPool->Get(MSDPool) )) == NULL)
	{	
		DPFX(DPFPREP,0, "Returning DPNERR_OUTOFMEMORY - failed to create new MSD");
		return DPNERR_OUTOFMEMORY;	
	}

	pMSD->CommandID = COMMAND_ID_LISTEN;
	pMSD->pSPD = pSPD;
	pMSD->Context = Context;

	ListenData.pAddressDeviceInfo = lpaTarget;
	DNASSERT( ( ulFlags & ~( DN_LISTENFLAGS_OKTOQUERYFORADDRESSING ) ) == 0 );
	ListenData.dwFlags = 0;
	if ( ( ulFlags & DN_LISTENFLAGS_OKTOQUERYFORADDRESSING ) != 0 )
	{
		ListenData.dwFlags |= DPNSPF_OKTOQUERY;
	}
	ListenData.pvContext = pMSD;
	ListenData.hCommand = 0;

	*phHandle = pMSD;

	// SP Listen call is guarenteed to return immediately
	pMSD->ulMsgFlags1 |= MFLAGS_ONE_IN_SERVICE_PROVIDER;

#ifdef DEBUG
	Lock(&pSPD->SPLock);
	pMSD->blSPLinkage.InsertBefore( &pSPD->blMessageList);		// Dont support timeouts for Listen
	pMSD->ulMsgFlags1 |= MFLAGS_ONE_ON_GLOBAL_LIST;
	Unlock(&pSPD->SPLock);
#endif

	LOCK_MSD(pMSD, "SP Ref");											// AddRef for SP
	LOCK_MSD(pMSD, "Temp Ref");

	DPFX(DPFPREP,DPF_CALLOUT_LVL, "Calling SP->Listen, pSPD[%p], pMSD[%p]", pSPD, pMSD);
/**/hr = IDP8ServiceProvider_Listen(pSPD->IISPIntf, &ListenData);		/** CALL SP **/

	if(hr != DPNERR_PENDING)
	{
		// SP Listen should always be asynchronous so if it isnt PENDING then it must have failed
		DPFX(DPFPREP,1, "SP->Listen did not return DPNERR_PENDING, assuming failure, hr[%x]", hr);

		ASSERT(hr != DPN_OK);

		Lock(&pMSD->CommandLock);

		pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_IN_SERVICE_PROVIDER);

#ifdef DEBUG
		Lock(&pSPD->SPLock);
		pMSD->blSPLinkage.RemoveFromList();					// knock this off the pending list
		pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_ON_GLOBAL_LIST);
		Unlock(&pSPD->SPLock);
#endif

		DECREMENT_MSD(pMSD, "Temp Ref");
		DECREMENT_MSD(pMSD, "SP Ref");						// release once for SP
		RELEASE_MSD(pMSD, "Release On Fail");				// release again to return resource

		DPFX(DPFPREP,1, "Returning hr[%x]", hr);
		return hr;
	}

	Lock(&pMSD->CommandLock);

	pMSD->hCommand = ListenData.hCommand;			// retail SP command handle
	pMSD->dwCommandDesc = ListenData.dwCommandDescriptor;

	RELEASE_MSD(pMSD, "Temp Ref"); // Unlocks CommandLock

	DPFX(DPFPREP,DPF_CALLIN_LVL, "Returning DPNERR_PENDING, pMSD[%p]", pMSD);
	return DPNERR_PENDING;
}

/***  BACKEND ROUTINES  ***/

/*
**		Complete Connect
**
**		The user's Connect operation has completed.  Clean everything up
**	and signal the user.
**
**		THIS IS ALWAYS CALLED WITH THE COMMAND LOCK HELD IN MSD
*/

#undef DPF_MODNAME
#define DPF_MODNAME "CompleteConnect"

VOID CompleteConnect(PMSD pMSD, PSPD pSPD, PEPD pEPD, HRESULT hr)
{
	AssertCriticalSectionIsTakenByThisThread(&pMSD->CommandLock, TRUE);

	// We expect to never get here twice
	ASSERT(!(pMSD->ulMsgFlags1 & MFLAGS_ONE_COMPLETE));
	pMSD->ulMsgFlags1 |= MFLAGS_ONE_COMPLETE;

	// Connects cannot have timeout timers
	ASSERT(pMSD->TimeoutTimer == NULL);

#ifdef DEBUG
	Lock(&pSPD->SPLock);
	if(pMSD->ulMsgFlags1 & MFLAGS_ONE_ON_GLOBAL_LIST)
	{
		pMSD->blSPLinkage.RemoveFromList();							// Remove MSD from master command list
		pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_ON_GLOBAL_LIST);
	}
	Unlock(&pSPD->SPLock);

	ASSERT(!(pMSD->ulMsgFlags1 & MFLAGS_ONE_COMPLETED_TO_CORE));
	pMSD->ulMsgFlags1 |= MFLAGS_ONE_COMPLETED_TO_CORE;
	pMSD->CallStackCoreCompletion.NoteCurrentCallStack();
#endif

	pMSD->pEPD = NULL;
	Unlock(&pMSD->CommandLock);

	if(pEPD)
	{
		ASSERT(hr == DPN_OK);
		DPFX(DPFPREP,DPF_CALLOUT_LVL, "(%p) Calling Core->CompleteConnect, pMSD[%p], Core Context[%p], hr[%x], pEPD[%p]", pEPD, pMSD, pMSD->Context, hr, pEPD);
		pSPD->pPData->pfVtbl->CompleteConnect(pSPD->pPData->Parent, pMSD->Context, hr, (PHANDLE) pEPD, &pEPD->Context);

		Lock(&pEPD->EPLock);
		ReceiveComplete(pEPD);		// Complete any, releases EPLock
	}
	else
	{
		ASSERT(hr != DPN_OK);
		DPFX(DPFPREP,DPF_CALLOUT_LVL, "Calling Core->CompleteConnect with NULL EPD, pMSD[%p], Core Context[%p], hr[%x]", pMSD, pMSD->Context, hr);
		pSPD->pPData->pfVtbl->CompleteConnect(pSPD->pPData->Parent, pMSD->Context, hr, NULL, NULL);
	}

	// Release the final reference on the MSD AFTER indicating to the Core
	Lock(&pMSD->CommandLock);
	RELEASE_MSD(pMSD, "Final Release On Complete");		// Finished with this one, releases CommandLock
}

/*
**		Complete Disconnect
**
**		THIS IS ALWAYS CALLED WITH THE COMMAND LOCK HELD IN MSD
*/

#undef DPF_MODNAME
#define DPF_MODNAME "CompleteDisconnect"

VOID CompleteDisconnect(PMSD pMSD, PSPD pSPD, PEPD pEPD)
{
	AssertCriticalSectionIsTakenByThisThread(&pMSD->CommandLock, TRUE);

	// We expect to never get here twice
	ASSERT(!(pMSD->ulMsgFlags1 & MFLAGS_ONE_COMPLETE));
	pMSD->ulMsgFlags1 |= MFLAGS_ONE_COMPLETE;

	// Disconnects cannot have timeout timers
	ASSERT(pMSD->TimeoutTimer == NULL);

#ifdef DEBUG
	Lock(&pSPD->SPLock);
	if(pMSD->ulMsgFlags1 & MFLAGS_ONE_ON_GLOBAL_LIST)
	{
		pMSD->blSPLinkage.RemoveFromList();							// Remove MSD from master command list
		pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_ON_GLOBAL_LIST);
	}
	Unlock(&pSPD->SPLock);

	ASSERT(!(pMSD->ulMsgFlags1 & MFLAGS_ONE_COMPLETED_TO_CORE));
	pMSD->ulMsgFlags1 |= MFLAGS_ONE_COMPLETED_TO_CORE;
	pMSD->CallStackCoreCompletion.NoteCurrentCallStack();
#endif

	// No one else should use this
	pMSD->pEPD = NULL;

	if(pMSD->CommandID == COMMAND_ID_DISCONNECT)
	{
		Unlock(&pMSD->CommandLock);

		DPFX(DPFPREP,DPF_CALLOUT_LVL, "(%p) Calling Core->CompleteDisconnect, DPN_OK, pMSD[%p], Core Context[%p]", pEPD, pMSD, pMSD->Context);
		pSPD->pPData->pfVtbl->CompleteDisconnect(pSPD->pPData->Parent, pMSD->Context, DPN_OK);
	}
	else
	{
		Unlock(&pMSD->CommandLock);

		ASSERT(pMSD->CommandID == COMMAND_ID_DISC_RESPONSE);

		DPFX(DPFPREP,DPF_CALLOUT_LVL, "(%p) Calling Core->IndicateConnectionTerminated, DPN_OK, Core Context[%p]", pEPD, pEPD->Context);
		pSPD->pPData->pfVtbl->IndicateConnectionTerminated(pSPD->pPData->Parent, pEPD->Context, DPN_OK);
	}

	Lock(&pMSD->CommandLock);
	Lock(&pEPD->EPLock);
	RELEASE_EPD(pEPD, "UNLOCK (DISC COMMAND)");	// release hold on EPD, releases EPLock
	RELEASE_MSD(pMSD, "Final Release On Complete");		// Finished with this one, releases CommandLock
}

/*
**		Complete SP Connect
**
**		A Connect Command has completed in the Service Provider.  This does not mean our
**	work is done...  this means we now have a mapped EndPoint so we can exchange packets
**	with this partner.  We will now ping this partner to get an initial RTT and make sure
**	there really is a protocol over there that will talk to us.
**
**		Of course,  if SP does not return success then we can nip this whole thing in
**	the proverbial bud.
**
**		**  COMMAND LOCK is held on entry  **
*/


#undef DPF_MODNAME
#define DPF_MODNAME "CompleteSPConnect"

VOID CompleteSPConnect(PMSD pMSD, PSPD pSPD, HRESULT hr)
{
	PEPD		pEPD;

	DPFX(DPFPREP,5, "SP Completes Connect, pMSD[%p])", pMSD);

	AssertCriticalSectionIsTakenByThisThread(&pMSD->CommandLock, TRUE);

	pEPD = pMSD->pEPD;

	ASSERT(!(pMSD->ulMsgFlags1 & MFLAGS_ONE_COMPLETE));

	if(hr != DPN_OK)
	{
		// This will only happen once since DoCancel will not have done it because the IN_SP flag was set, and
		// ConnectRetryTimeout has never yet been set.
		if (pEPD)
		{
			ASSERT_EPD(pEPD);
			Lock(&pEPD->EPLock);

			// Unlink EPD from MSD
			ASSERT(pEPD->pCommand == pMSD);
			pEPD->pCommand = NULL;
			DECREMENT_MSD(pMSD, "EPD Ref");						// Release Reference from EPD

			DropLink(pEPD); // This releases the EPLock
		}
		DPFX(DPFPREP,5, "SP failed Connect, completing Connect, pMSD[%p], hr[%x]", pMSD, hr);
		CompleteConnect(pMSD, pSPD, NULL, hr);				// SP failed the connect call
		return;
	}

	// After a successful connect, we should have an endpoint
	pEPD = pMSD->pEPD;
	ASSERT_EPD(pEPD);

	Lock(&pEPD->EPLock);

	// The endpoint should have already been linked to this MSD
	ASSERT(pEPD->pCommand == pMSD);

	if(pMSD->ulMsgFlags1 & MFLAGS_ONE_CANCELLED)
	{
		// We get here when someone called DoCancel while we were still in the SP.  As above:
		// This will only happen once since DoCancel will not have done it because the IN_SP flag was set, and
		// ConnectRetryTimeout has never yet been set.

		// Unlink EPD from MSD
		ASSERT(pEPD->pCommand == pMSD);
		pEPD->pCommand = NULL;
		DECREMENT_MSD(pMSD, "EPD Ref");						// Release Reference from EPD

		DropLink(pEPD); // This releases the EPLock
		
		DPFX(DPFPREP,5, "(%p) Command is cancelled or timed out, Complete Connect, pMSD[%p]", pEPD, pMSD);
		CompleteConnect(pMSD, pSPD, NULL, DPNERR_USERCANCEL);
		return;
	}

	// Set up End Point Data /////////////////////////////////////////////////////////////////

	// Transition state
	ASSERT(pEPD->ulEPFlags & EPFLAGS_STATE_DORMANT);
	pEPD->ulEPFlags &= ~(EPFLAGS_STATE_DORMANT);
	pEPD->ulEPFlags |= EPFLAGS_STATE_CONNECTING;

	// Send CONNECT

	pEPD->dwSessID = pSPD->pPData->dwNextSessID++;

	DPFX(DPFPREP,5, "(%p) Sending CONNECT Frame", pEPD);
	(void) SendCommandFrame(pEPD, FRAME_EXOPCODE_CONNECT, 0);

	// Set timer for reply,  then wait for reply or TO. 
	pEPD->uiRetryTimeout = pSPD->pPData->dwConnectTimeout;
	pEPD->uiRetryCount = pSPD->pPData->dwConnectRetries;	

	LOCK_EPD(pEPD, "LOCK (CONN Retry Timer)");						// Create reference for timer
	DPFX(DPFPREP,5, "(%p) Setting Connect Retry Timer", pEPD);
	SetMyTimer(pEPD->uiRetryTimeout, 100, ConnectRetryTimeout, (PVOID) pEPD, &pEPD->ConnectTimer, &pEPD->ConnectTimerUnique);

	Unlock(&pEPD->EPLock);
	Unlock(&pMSD->CommandLock);
}

/*
**		Connect Retry Timeout
**
**		Retry timer has expired on a Connect operation.  This one function
**	is shared by Calling and Listening partners.  Complexity is due to the
**	fact that cancel code cannot always ensure that this handler will not
**	run,  so there are flags to signal various edge conditions (cancel, abort,
**	completion, high-level timeout).
*/

#undef DPF_MODNAME
#define DPF_MODNAME "ConnectRetryTimeout"

VOID CALLBACK
ConnectRetryTimeout(PVOID pvHandle, UINT uiUnique, PVOID pvUser)
{
	PMSD	pMSD;
	PEPD	pEPD = (PEPD) pvUser;

	DPFX(DPFPREP,5, "ENTER Connect Retry Timeout pEPD=%p", pEPD);

	ASSERT_EPD(pEPD);

	Lock(&pEPD->EPLock);

	if((pEPD->ConnectTimer != pvHandle)||(pEPD->ConnectTimerUnique != uiUnique))
	{
		// Timer been reset!  This is a spurious fire and should be ignored.
		RELEASE_EPD(pEPD, "UNLOCK: (Spurious (ie late) firing of CONNECT timer)"); // releases EPLock
		DPFX(DPFPREP,7, "(%p) Ignoring late CONNECT timer", pEPD);
		return;
	}
	
	pMSD = pEPD->pCommand;

	if(pMSD == NULL)
	{
		pEPD->ConnectTimer = 0;
		RELEASE_EPD(pEPD, "UNLOCK: (Conn retry timer - after completion)"); // releases EPLock
		return;
	}
	
	ASSERT_MSD(pMSD);

	// Make sure this doesn't go away when we leave the lock
	LOCK_MSD(pMSD, "Hold For Lock");
	Unlock(&pEPD->EPLock); // Release before taking higher level lock

	// Take both locks in the proper order
	Lock(&pMSD->CommandLock);
	Lock(&pEPD->EPLock);

	pEPD->ConnectTimer = 0;

	// This timer should only be running in a CONNECTING state
	if(	(pMSD->ulMsgFlags1 & (MFLAGS_ONE_CANCELLED | MFLAGS_ONE_COMPLETE)) || 
		(!(pEPD->ulEPFlags & EPFLAGS_STATE_CONNECTING)))
	{
		RELEASE_MSD(pMSD, "Hold for lock");						// Remove temporary reference and release lock
		RELEASE_EPD(pEPD, "UNLOCK (Conn Retry Timer)");			// Remove reference for timer, releases EPLock
		return;													// and thats all for now
	}

	// IF more retries are allowed and command is still active, send another CONNECT frame

	if(pEPD->uiRetryCount-- > 0)
	{	
		pEPD->uiRetryTimeout = min(pEPD->uiRetryTimeout * 2, 5000);	// exp backoff to a max of 5000ms until we establish our first RTT

		if(pMSD->CommandID == COMMAND_ID_CONNECT)
		{
			DPFX(DPFPREP,5, "(%p) Sending CONNECT Frame", pEPD);
			(void) SendCommandFrame(pEPD, FRAME_EXOPCODE_CONNECT, 0);
		}
		// Listen -- retry CONNECTED frame
		else 
		{
			pEPD->ulEPFlags |= EPFLAGS_CHECKPOINT_INIT;	// We will expect a reply to this frame
			DPFX(DPFPREP,5, "(%p) Sending CONNECTED Frame", pEPD);
			(void) SendCommandFrame(pEPD, FRAME_EXOPCODE_CONNECTED, 0);
		}

		// Send the next ping
		DPFX(DPFPREP,7, "(%p) Setting Connect Retry Timer", pEPD);
		SetMyTimer(pEPD->uiRetryTimeout, 100, ConnectRetryTimeout, (PVOID) pEPD, &pEPD->ConnectTimer, &pEPD->ConnectTimerUnique);

		Unlock(&pEPD->EPLock);
		RELEASE_MSD(pMSD, "Hold for lock");						// Remove temporary reference and release lock

		// Since we have re-started timer, we don't adjust refcount
	}
	else
	{
		// We got no response and timed out.

		if(pMSD->CommandID == COMMAND_ID_CONNECT)
		{
			DECREMENT_EPD(pEPD, "UNLOCK: (Connect Timer (Failure Path))");// Dec Ref for this timer, releases EPLock

			// This will only happen once since we know DoCancel has not been called due to our CANCELLED check above,
			// and if it is now called it will see our CANCELLED flag set below.  We also know that the success case hasn't
			// happened or COMPLETE above would have been set.  We also have not had two timers get here because of the
			// CANCELLED check above and set here.
			pMSD->ulMsgFlags1 |= MFLAGS_ONE_CANCELLED;

			// Unlink EPD from MSD
			ASSERT(pEPD->pCommand == pMSD);
			pEPD->pCommand = NULL;
			DECREMENT_MSD(pMSD, "EPD Ref");					// Release Reference from EPD

			DropLink(pEPD);// Releases EPLock
			
			DECREMENT_MSD(pMSD, "Hold for lock");					// Remove temporary reference

			DPFX(DPFPREP,1, "(%p) Connect retries exhausted, completing Connect, pMSD[%p]", pEPD, pMSD);
			CompleteConnect(pMSD, pMSD->pSPD, NULL, DPNERR_NORESPONSE);			// releases CommandLock
		}

		// Listen - clean up associated state info,  then blow away end point
		else 
		{
			DPFX(DPFPREP,1, "(%p) Connect retries exhausted on Listen, Kill Connection, pMSD[%p]", pEPD, pMSD);

			if(pEPD->ulEPFlags & EPFLAGS_LINKED_TO_LISTEN)
			{
				pEPD->ulEPFlags &= ~(EPFLAGS_LINKED_TO_LISTEN);
				pEPD->blSPLinkage.RemoveFromList();					// Unlink EPD from Listen Queue
			}

			ASSERT(pEPD->pCommand != NULL);
			pEPD->pCommand = NULL;									// Unlink listen from EPD
			DECREMENT_MSD(pMSD, "EPD Ref");							// release reference for link to EPD
			RELEASE_MSD(pMSD, "Hold for lock");						// Remove temporary reference and release lock

			DECREMENT_EPD(pEPD, "UNLOCK: (Connect Timer (Failure Path))");// Dec Ref for this timer, SPLock not already held
			DropLink(pEPD);
		}
	}
}

/*
**		Process Connection Request
**
**		Somebody wants to connect to us.  If we have a listen posted we will
**	fill out a checkpoint structure to correlate his response and we will fire
**	off a CONNECTED frame ourselves
**
**		Since our connection will not be up until we receive a CONNECTED response
**	to our response we will need to set up a retry timer ourselves.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "ProcessConnectRequest"

VOID ProcessConnectRequest(PSPD pSPD, PEPD pEPD, PCFRAME pCFrame)
{
	PMSD	pMSD = NULL;

	DPFX(DPFPREP,DPF_CALLIN_LVL, "CONNECT REQUEST RECEIVED; EPD=%p SessID=%x", pEPD, pCFrame->dwSessID);

	Lock(&pEPD->EPLock);

	if((pMSD = pEPD->pCommand) == NULL)
	{
		// There are two cases: we are a connecting endpoint or we are a listening endpoint.  In the connecting
		// case we will fail in the following 'if' because we do not allow connections on non-listening endpoints.
		// In the listening case, the fact that pMSD is NULL means that we have received the other side's 
		// CONNECTED packet, which also tells us that they have seen our CONNECTED packet.  The only reason we
		// would now be seeing a CONNECT is if a) there was a stale, late-delivered packet on the wire, or b)
		// some malicious user is spoofing packets to us.  In both cases, ignoring the packet is the right 
		// thing to do.
		// There is a third possibility for the listening endpoint case, and that is that the other side went down
		// and we didn't realize it, and they are now attempting to reconnect.  The best we can do is wait the full
		// timeout until the link is torn down on our side, and let their retries make the connection for them at 
		// that time.  If we cut the timeout short, we have no way to know that a malicious user can't force 
		// legitimate connections closed by spoofing CONNECT packets.
		DPFX(DPFPREP,1, "(%p) CONNECT Frame received on CONNECTED link, ignoring", pEPD);
		DNASSERTX(FALSE, 3);

		Unlock(&pEPD->EPLock);
		return;
	}

	ASSERT_MSD(pMSD);
	LOCK_MSD(pMSD, "LOCK: Hold For Lock");		// Place reference on Cmd until we can lock it
	Unlock(&pEPD->EPLock);

	Lock(&pMSD->CommandLock);
	Lock(&pEPD->EPLock);											// Serialize access to EPD (this may not really be new sess)

	// Make sure this endpoint was listening for connections
	// This could be a Connect in which case this is a malicious packet.  It could also be a Disonnect or Disconnect Response
	// if the endpoint is being disconnected.  In any case we just need to ignore the connect packet.
	if(pMSD->CommandID != COMMAND_ID_LISTEN)
	{
		DPFX(DPFPREP,1, "(%p) PROTOCOL RECEIVED CONNECT REQUEST ON A NON-LISTENING ENDPOINT, IGNORING, pMSD[%p]", pEPD, pMSD);
		DNASSERTX(FALSE, 3);
		Unlock(&pEPD->EPLock);
		RELEASE_MSD(pMSD, "UNLOCK: Hold For Lock");
		return;
	}

	// Make sure we can work with this version
	if((pCFrame->dwVersion >> 16) != (DNET_VERSION_NUMBER >> 16))
	{
		DPFX(DPFPREP,1, "(%p) PROTOCOL RECEIVED CONNECT REQUEST FROM AN INCOMPATIBLE VERSION(theirs %x, ours %x), DROPPING LINK", pEPD, pCFrame->dwVersion, DNET_VERSION_NUMBER);
		DNASSERTX(FALSE, 2);
		RELEASE_MSD(pMSD, "UNLOCK: Hold For Lock");
		RejectInvalidPacket(pEPD, TRUE); // This releases the EPLock
		return;
	}

	// Make sure the listen command is still valid
	if(pMSD->ulMsgFlags1 & MFLAGS_ONE_CANCELLED)
	{
		DPFX(DPFPREP,1, "(%p) PROTOCOL RECEIVED CONNECT REQUEST ON A LISTEN THAT IS CANCELLED, DROPPING LINK, pMSD[%p]", pEPD, pMSD);
		RELEASE_MSD(pMSD, "UNLOCK: Hold For Lock");
		RejectInvalidPacket(pEPD, TRUE); // This releases the EPLock
		return;												
	}

	// We shouldn't use the pMSD past here since this will unlock it
	RELEASE_MSD(pMSD, "UNLOCK: Hold For Lock");

	// Are we already connected?
	if(pEPD->ulEPFlags & (EPFLAGS_STATE_CONNECTED | EPFLAGS_STATE_TERMINATING)) 
	{						
		DPFX(DPFPREP,1, "(%p) CONNECT Frame received on Connected or Terminating link, ignoring", pEPD);

		// If connection has been completed then we don't need to do more work

		// This can happen if we failed to cancel the connect timer in ProcessConnectedResponse and a CONNECT packet
		// comes in.
		Unlock(&pEPD->EPLock);
		return;
	}

	// If we are already in a CONNECTING state then this is not the first CONNECT frame we have seen.  If the SessID's
	// match, then the partner probably didn't hear our first response, so we will resend it.  If the SessID's don't
	// match, then either the partner aborted and is starting with a new SessID, or a malicious party is spoofing the
	// partner's address, and sending a bogus packet.  In either of these cases we will ignore the connect.  A partner 
	// aborting a connect mid-way probably crashed anyway, and waiting for us to timeout the first connect attempt 
	// will be the least of their worries.

	if(pEPD->ulEPFlags & EPFLAGS_STATE_CONNECTING) 
	{						
		if(pCFrame->dwSessID != pEPD->dwSessID)
		{
			DPFX(DPFPREP,1, "(%p) Received non-matching SessionID, ignoring CONNECT", pEPD);
			Unlock(&pEPD->EPLock);
			return;
		}

		// Unexpected CONNECT Frame has same Session ID.  Partner probably lost our response.  We will
		// respond again to this one.
		
		DPFX(DPFPREP,1, "(%p) Received duplicate CONNECT request. Sending another response...", pEPD);

		// Listen side must set this before sending CONNECTED
		pEPD->ulEPFlags |= EPFLAGS_CHECKPOINT_INIT;					// We will expect a reply to this frame

		// If this fails they will be sending another CONNECT anyway, so we do nothing
		(void) SendCommandFrame(pEPD, FRAME_EXOPCODE_CONNECTED, pCFrame->bMsgID);

		Unlock(&pEPD->EPLock);
		return;
	}

	// Transition state
	ASSERT(pEPD->ulEPFlags & EPFLAGS_STATE_DORMANT);
	pEPD->ulEPFlags &= ~(EPFLAGS_STATE_DORMANT);
	pEPD->ulEPFlags |= EPFLAGS_STATE_CONNECTING;

	pEPD->dwSessID = pCFrame->dwSessID;							// Use this SessID in all C-traffic
	pEPD->ulEPFlags |= EPFLAGS_CHECKPOINT_INIT;					// We will expect a reply to this frame

	DPFX(DPFPREP,5, "(%p) Sending CONNECTED Frame", pEPD);
	(void) SendCommandFrame(pEPD, FRAME_EXOPCODE_CONNECTED, pCFrame->bMsgID);

	pEPD->uiRetryTimeout = pSPD->pPData->dwConnectTimeout;		// Got to start somewhere
	pEPD->uiRetryCount = pSPD->pPData->dwConnectRetries;		// w/exponential wait

	LOCK_EPD(pEPD, "LOCK: (CONNECT RETRY TIMER)");				// Create reference for timer
	DPFX(DPFPREP,5, "(%p) Setting Connect Timer", pEPD);
	SetMyTimer(pEPD->uiRetryTimeout, 100, ConnectRetryTimeout, (PVOID) pEPD, &pEPD->ConnectTimer, &pEPD->ConnectTimerUnique);
	if (pEPD->ConnectTimer == 0)
	{
		DPFX(DPFPREP,1, "(%p) Setting Connect Retry Timer failed", pEPD);

		// If we can't even set timers due to low memory, then the best we can do is
		// abandon this new connection and hope to give good service to our existing
		// connections.
		DECREMENT_EPD(pEPD, "UNLOCK: (CONNECT RETRY TIMER)");

		pEPD->ulEPFlags &= ~(EPFLAGS_LINKED_TO_LISTEN);
		pEPD->blSPLinkage.RemoveFromList();						// Unlink EPD from Listen Queue

		// Unlink the MSD from the EPD
		ASSERT(pEPD->pCommand == pMSD);
		pEPD->pCommand = NULL;

		DropLink(pEPD); // This releases EPLock

		Lock(&pMSD->CommandLock);
		RELEASE_MSD(pMSD, "EPD Ref");

		return;
	}

	Unlock(&pEPD->EPLock);
}

/*
**		Process Connected Response
**
**		A response to a connection request has arrived (or a response to
**	our connection response).  Now the connection is officially up (on
**	our end of the circuit).  Set the link-state according to our first
**	RTT sample and get ready to party.
**
**		If we are the originating party,  we will want to send a
**	CONNECTED frame to our partner, even though the connection is
**	complete from our perspective.  This will allow partner to establish
**	his baseline RTT and clock bias as we can do here.  In this case,  he
**	will have his POLL bit set in the frame we just received.
**
**		Now, we might get additional CONNECTED frames after the first one
**	where we startup the link.  This would most likely be due to our CONNECTED
**	response getting lost.  So if we get a CONNECTED frame with POLL set
**	after our link is up,  we will just go ahead and respond again without
**	adjusting our state.
**
**		Note about Locks:
**
**		This code is complicated by the precedence of CritSec ownership.  To simplify
**	as much as possible we will take the Listen command lock at the very start of the
**	procedure (when appropriate) because it has the highest level lock.  This prevents
**	us from completing the whole connection process and then finding that the Listen
**	went away so we can't indicate it to the user.
**
**		We keep a RefCnt on the Listen so it won't go away while a new session
**	is pending on it.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "ProcessConnectedResponse"

VOID ProcessConnectedResponse(PSPD pSPD, PEPD pEPD, PCFRAME pCFrame, DWORD tNow)
{
	PCHKPT		pCP;
	PMSD		pMSD;

	DPFX(DPFPREP,DPF_CALLIN_LVL, "CONNECT RESPONSE RECEIVED (pEPD=0x%p)", pEPD);

	Lock(&pEPD->EPLock);

	// If the link has not seen a CONNECT or issued a CONNECT, we do not expect a CONNECTED.  
	// Since this is the only reason this EPD was created, we will tear it down by rejecting
	// the connection.
	if (pEPD->ulEPFlags & EPFLAGS_STATE_DORMANT)
	{	
		DPFX(DPFPREP,1, "(%p) CONNECTED response received on a dormant link, dropping link", pEPD);
		RejectInvalidPacket(pEPD, TRUE); // This will release the EPLock
		return;
	}

	// There is a possibility that the link is in the terminating state.  If so, we don't
	// care about CONNECTED packets.
	if (pEPD->ulEPFlags & EPFLAGS_STATE_TERMINATING)
	{	
		DPFX(DPFPREP,1, "(%p) CONNECTED response received on a terminating link, ignoring", pEPD);
		Unlock(&pEPD->EPLock);
		return;
	}

	// At this point either we are connecting and this is a response, or someone has connected to us, and this is
	// the reply to our response.  Note that this could be a duplicate of one of these cases, so we may already
	// be in a connected state.  There is also the possiblity that these are malicious packets.
	ASSERT(pEPD->ulEPFlags & (EPFLAGS_STATE_CONNECTING | EPFLAGS_STATE_CONNECTED));

	// If the SessID does not match, ignore the CONNECTED packet.  This is either a malicious attempt at messing
	// up a legitimate connection, or our partner aborted and has come back in with a new session ID.
	if(pEPD->dwSessID != pCFrame->dwSessID)
	{	
		DPFX(DPFPREP,1, "(%p) CONNECTED response has bad SessID, ignoring", pEPD);
		Unlock(&pEPD->EPLock);
		return;
	}
		
	//	If we have completed our side of the connection then our only responsibility is to send responses
	// if our partner is still POLLING us.
	
	if(pEPD->ulEPFlags & EPFLAGS_STATE_CONNECTED)
	{
		// A Listen will set POLL on the CONNECTED packet, a Connect will not
		if(pCFrame->bCommand & PACKET_COMMAND_POLL)
		{	
			// This side must be a listen unless this packet is malicious

			DPFX(DPFPREP,5, "(%p) Duplicate CONNECTED frame, sending another response...", pEPD);

			// If this fails we will let the partner's retry catch it.
			(void) SendCommandFrame(pEPD, FRAME_EXOPCODE_CONNECTED, pCFrame->bMsgID);
		}
		Unlock(&pEPD->EPLock);
		return;
	}

	// Since we are not CONNECTED yet, we must be in a CONNECTING state in order to receive a 
	// CONNECTED response.
	ASSERT(pEPD->ulEPFlags & EPFLAGS_STATE_CONNECTING);

	// MSD should not be NULL if we are in the CONNECTING state
	pMSD = pEPD->pCommand;
	ASSERT_MSD(pMSD);
	LOCK_MSD(pMSD, "Hold For Lock");		// Place reference on Cmd until we can lock it
	Unlock(&pEPD->EPLock);

 	Lock(&pMSD->CommandLock);
	Lock(&pEPD->EPLock);

	// Since we left the EPLock, we must verify that we are still in the connecting state
	if (!(pEPD->ulEPFlags & EPFLAGS_STATE_CONNECTING))
	{	
		DPFX(DPFPREP,1, "(%p) EPD left the CONNECTING state while we were out of the lock, ignoring CONNECTED frame", pEPD);

		Unlock(&pEPD->EPLock);
		RELEASE_MSD(pMSD, "Hold For Lock"); // This releases the command lock
		return;
	}

	if(pMSD->ulMsgFlags1 & (MFLAGS_ONE_CANCELLED | MFLAGS_ONE_COMPLETE))
	{
		DPFX(DPFPREP,1, "(%p) Connect/Listen command cancelled or complete, ignoring CONNECTED frame", pEPD);

		// Whoever cancelled the Listen should be disconnecting this connection too
		// so all we have to do here is bail out.

		Unlock(&pEPD->EPLock);
		RELEASE_MSD(pMSD, "Hold For Lock"); // This releases the command lock
		return;
	}
		
	// Next, take care of this guy's reply if we still owe him one

	// A Listen will set POLL on the CONNECTED packet, a Connect will not
	if(pCFrame->bCommand & PACKET_COMMAND_POLL)
	{				
		// This side must be a listen unless this packet is malicious

		DPFX(DPFPREP,5, "(%p) Sending CONNECTED Frame", pEPD);
		if(SendCommandFrame(pEPD, FRAME_EXOPCODE_CONNECTED, pCFrame->bMsgID) != DPN_OK)
		{
			DPFX(DPFPREP,5, "(%p) Sending CONNECTED Frame Failed", pEPD);

			// We cannot complete the connection...  we will just let things time out
			RELEASE_MSD(pMSD, "Hold For Lock");
			Unlock(&pEPD->EPLock);					// Protect the pCommand field
			return;
		}
	}

	// Now we can setup our new link,  but only if this frame Correlates to a checkpoint we have outstanding
	// so we can seed our state variables.

	// Can we correlate resp?
	if((pCP = LookupCheckPoint(pEPD, pCFrame->bRspID)) != NULL)
	{
		// We are connected, so shut off retry timer
		if(pEPD->ConnectTimer != 0)
		{
			DPFX(DPFPREP,5, "(%p) Cancelling Connect Timer", pEPD);
			if(CancelMyTimer(pEPD->ConnectTimer, pEPD->ConnectTimerUnique) == DPN_OK)
			{
				DECREMENT_EPD(pEPD, "UNLOCK: (Conn Retry Timer - Connect Complete)");		//  remove reference for timer, SPLock not already held
			}
			else 
			{
				DPFX(DPFPREP,5, "(%p) Cancelling Connect Timer Failed", pEPD);
			}
			pEPD->ConnectTimer = 0;	// This will prevent timer from trying to do any work if it couldn't cancel
		}
	
		// Transition state
		ASSERT(pEPD->ulEPFlags & EPFLAGS_STATE_CONNECTING);
		pEPD->ulEPFlags &= ~(EPFLAGS_STATE_CONNECTING);
		pEPD->ulEPFlags |= EPFLAGS_STATE_CONNECTED | EPFLAGS_STREAM_UNBLOCKED;// Link is open for business

		DPFX(DPFPREP,1, "(%p) Partner Reported Version: %x, Our Version: %x, Initial RTT %d - %d = %d", pEPD, pCFrame->dwVersion, DNET_VERSION_NUMBER, tNow, pCP->tTimestamp, tNow - pCP->tTimestamp);

		if(pEPD->ulEPFlags & EPFLAGS_LINKED_TO_LISTEN)
		{
			pEPD->ulEPFlags &= ~(EPFLAGS_LINKED_TO_LISTEN);
			pEPD->blSPLinkage.RemoveFromList();							// Unlink EPD from Listen Queue
		}
		
		InitLinkParameters(pEPD, (tNow - pCP->tTimestamp), sizeof(CFRAME), (pCP->tTimestamp - pCFrame->tTimestamp), tNow);
		ChkPtPool->Release(ChkPtPool, pCP);

		DPFX(DPFPREP,5, "(%p) N(R) = 0, N(S) = 0", pEPD);
		pEPD->bNextSend = 0;
		pEPD->bNextReceive = 0;

		FlushCheckPoints(pEPD);									// Make sure we do this before the InitCheckPoint
		
		/*
		**	It turns out that the first RTT measurement is a very bad one (slow) because because
		**	it includes overhead for opening and binding a new socket,  endpoint creation,  etc.
		**	Therefore each side will take another quick sample right away.  The initial calculations
		**	above will still serve as an initial RTT until this better sample is available
		*/

		PerformCheckpoint(pEPD);								// Take another RTT sample

		// Cleanup connect operation
		if(pMSD->CommandID == COMMAND_ID_CONNECT)
		{
			// There was a CONNECT Command issued that now must be completed

			DECREMENT_MSD(pMSD, "Hold For Lock");				// Remove temporary reference from above.
			
			// This will not happen twice because both COMPLETE and CANCELLED are checked above, and the
			// call to CompleteConnect will set COMPLETE.

			// Unlink the MSD from the EPD
			ASSERT(pEPD->pCommand == pMSD);
			pEPD->pCommand = NULL;
			DECREMENT_MSD(pMSD, "EPD Ref");							// Release reference for EPD link

			Unlock(&pEPD->EPLock);

			CompleteConnect(pMSD, pSPD, pEPD, DPN_OK);			// This releases the MSD Lock
		}
		else 
		{		// LISTENING
			// We were the listener.  We will indicate a Connect event on the listen
			// command w/o completing the Listen

			ASSERT(pMSD->CommandID == COMMAND_ID_LISTEN);

			// We know this will only happen once because the person who does it will transition us out
			// of the CONNECTING state, and we can't get here unless we are in that state.

			// Unlink the MSD from the EPD
			ASSERT(pEPD->pCommand == pMSD);
			pEPD->pCommand = NULL;
			DECREMENT_MSD(pMSD, "EPD Ref");							// Release reference for EPD link

			Unlock(&pEPD->EPLock);

			Unlock(&pMSD->CommandLock);

			DPFX(DPFPREP,DPF_CALLOUT_LVL, "(%p) Calling Core->IndicateConnect, pMSD[%p], Core Context[%p]", pEPD, pMSD, pMSD->Context);
			pSPD->pPData->pfVtbl->IndicateConnect(pSPD->pPData->Parent, pMSD->Context, (PHANDLE) pEPD, &pEPD->Context);

			// Complete any receives that queued while waiting for IndicateConnect
			Lock(&pEPD->EPLock);
			ReceiveComplete(pEPD);	// releases EPLock

			// Release the final reference on the MSD AFTER indicating to the Core
			Lock(&pMSD->CommandLock);
			RELEASE_MSD(pMSD, "Hold For Lock");					// release temp MSD (releases lock)
		}		
	}
	else 
	{
		/*
		**		Uncorrelated CONNECTED frame.  How can this happen?  Parter's response must
		**	have been dropped,  so he is retrying his CONN frame.  Since we are trying to
		**	measure an accurate RTT we dont want to use his retry against our original
		**	request,  so he zeros out his Resp correlator.  We will eventually retry with
		**	new correlator and hopefully that frame will get through.
		*/

		DPFX(DPFPREP,1, "(%p) Uncorrelated CONNECTED frame arrives", pEPD);
		Unlock(&pEPD->EPLock);
		RELEASE_MSD(pMSD, "Hold For Lock");
	}
}

/*
**		Drop Link
**
**			For whatever reason we are dropping an active link.  This requires us to
**		Cancel any outstanding commands and give an indication to the user.
**
**
**		**  CALLED WITH EPD->EPLOCK HELD;  RETURNS WITH LOCK RELEASED  **
*/

#undef DPF_MODNAME
#define DPF_MODNAME "DropLink"

VOID DropLink(PEPD pEPD)
{
	PRCD				pRCD;
	PRCD				pNext;
	CBilink				*pLink;
	PSPRECEIVEDBUFFER	pRcvBuff = NULL;
	PProtocolData		pPData;
	BOOL				fIndicateDisconnect;

	DPFX(DPFPREP,2, "Drop Link %p (refcnt=%d)", pEPD, pEPD->lRefCnt);

	ASSERT_EPD(pEPD);
	AssertCriticalSectionIsTakenByThisThread(&pEPD->EPLock, TRUE);

	PSPD	pSPD = pEPD->pSPD;

	//	First set/clear flags to prevent any new commands from issueing

	// We will not indicate disconnect if the Core never knew about the connetion
	fIndicateDisconnect = (pEPD->ulEPFlags & EPFLAGS_STATE_CONNECTED);

	// Transition state
	pEPD->ulEPFlags &= ~(EPFLAGS_STATE_CONNECTING | EPFLAGS_STATE_DORMANT | EPFLAGS_STATE_CONNECTED | 
						 EPFLAGS_SDATA_READY | EPFLAGS_STREAM_UNBLOCKED);	// Link is now down
	pEPD->ulEPFlags |= EPFLAGS_STATE_TERMINATING; // Accept no new commands

	// I am creating a RefCnt bump for the send pipeline,  which means we will no longer pull EPDs off
	// the pipeline here.  The clearing of the flags above will cause the EPD to be dropped from the
	// pipeline the next time it is due to be serviced.  We CAN still clean up all the frames'n'stuff
	// because the send loop doesnt need to actually DO anything with this EPD.  This behavior allows
	// the SendThread to loop through the pipeline queue, surrendering locks, without having the queue
	// changing beneath it.

	//  Stop all timers (there are five now)

	if(pEPD->RetryTimer)
	{
		if(CancelMyTimer(pEPD->RetryTimer, pEPD->RetryTimerUnique) == DPN_OK)
		{
			DECREMENT_EPD(pEPD, "UNLOCK (DROP RETRY)"); // SPLock not already held
		}
		pEPD->RetryTimer = 0;
	}
	if(pEPD->ConnectTimer)
	{
		if(CancelMyTimer(pEPD->ConnectTimer, pEPD->ConnectTimerUnique) == DPN_OK)
		{
			DECREMENT_EPD(pEPD, "UNLOCK (DROP CONNECT RETRY)"); // SPLock not already held
		}
		pEPD->ConnectTimer = 0;
	}
	if(pEPD->DelayedAckTimer)
	{
		if(CancelMyTimer(pEPD->DelayedAckTimer, pEPD->DelayedAckTimerUnique) == DPN_OK)
		{
			DECREMENT_EPD(pEPD, "UNLOCK (DROP DELAYEDACK)"); // SPLock not already held
		}
		pEPD->DelayedAckTimer = 0;
	}
	if(pEPD->DelayedMaskTimer)
	{
		if(CancelMyTimer(pEPD->DelayedMaskTimer, pEPD->DelayedMaskTimerUnique) == DPN_OK)
		{
			DECREMENT_EPD(pEPD, "UNLOCK (DROP DELAYED MASK)"); // SPLock not already held
		}
		pEPD->DelayedMaskTimer = 0;
	}
	if(pEPD->SendTimer)
	{
		if(CancelMyTimer(pEPD->SendTimer, pEPD->SendTimerUnique) == DPN_OK)
		{
			DECREMENT_EPD(pEPD, "UNLOCK (DROP SENDTIMER)"); // SPLock not already held
			pEPD->SendTimer = 0;
		}
	}
	if(pEPD->BGTimer)
	{
		if(CancelMyTimer(pEPD->BGTimer, pEPD->BGTimerUnique) == DPN_OK)
		{
			DECREMENT_EPD(pEPD, "UNLOCK (DROP BG TIMER)"); // SPLock not already held
			pEPD->BGTimer = 0;
		}
	}

	AbortSendsOnConnection(pEPD);	// Cancel pending commands; releases EPLock

	Lock(&pEPD->EPLock);
	
	// Connects, Listens, and Disconnects are associated with an EPD through the pCommand member.  AbortSends will
	// have removed any Disconnects, and no Connects or Listens should still be hanging on when we call DropLink.
	ASSERT(pEPD->pCommand == NULL);

	// Now we clean up any receives in progress.  We throw away any partial or mis-ordered messages.
	while((pRCD = pEPD->pNewMessage) != NULL)
	{
		ASSERT_RCD(pRCD);

		pEPD->pNewMessage = pRCD->pMsgLink;
		if(pRCD->pRcvBuff == NULL)
		{
			ASSERT(pRCD->ulRFlags & (RFLAGS_FRAME_INDICATED_NONSEQ | RFLAGS_FRAME_LOST));
		}

		RELEASE_SP_BUFFER(pRCD->pRcvBuff);

		RELEASE_RCD(pRCD);
	}

	while(!pEPD->blOddFrameList.IsEmpty())
	{
		pLink = pEPD->blOddFrameList.GetNext();
		pRCD = CONTAINING_RECORD(pLink, RCD, blOddFrameLinkage);
		ASSERT_RCD(pRCD);

		pLink->RemoveFromList();

		if(pRCD->pRcvBuff == NULL)
		{
			ASSERT(pRCD->ulRFlags & (RFLAGS_FRAME_INDICATED_NONSEQ | RFLAGS_FRAME_LOST));
		}

		RELEASE_SP_BUFFER(pRCD->pRcvBuff);

		RELEASE_RCD(pRCD);
	}

	while(!pEPD->blCompleteList.IsEmpty())
	{
		pLink = pEPD->blCompleteList.GetNext();
		pRCD = CONTAINING_RECORD(pLink, RCD, blCompleteLinkage);
		ASSERT_RCD(pRCD);

		pLink->RemoveFromList();
		
		ASSERT(pEPD->uiCompleteMsgCount > 0);
		pEPD->uiCompleteMsgCount--;
		
		while(pRCD != NULL)
		{
			ASSERT_RCD(pRCD);
			pNext = pRCD->pMsgLink;
			
			RELEASE_SP_BUFFER(pRCD->pRcvBuff);
			
			RELEASE_RCD(pRCD);
			pRCD = pNext;
		}
	}

	pPData = pEPD->pSPD->pPData;
	IDP8ServiceProvider	*pSPIntf = pEPD->pSPD->IISPIntf;

	if (!(pEPD->ulEPFlags & EPFLAGS_INDICATED_DISCONNECT))
	{
		if (fIndicateDisconnect)
		{
			// Make sure we are the only one that indicates the disconnect
			pEPD->ulEPFlags |= EPFLAGS_INDICATED_DISCONNECT;
		}
	}
	else
	{
		// Someone else beat us to it.
		fIndicateDisconnect = FALSE;
	}

	// We need to make sure that we don't allow DNPRemoveServiceProvider to complete until we are out of the Core
	// and SP.  This reference will do that, and is released at the end of this function.
	LOCK_EPD(pEPD, "Drop Link Temp Ref");

	// Remove the base reference if it still exists
	if(!(pEPD->ulEPFlags & EPFLAGS_KILLED))
	{
		pEPD->ulEPFlags |= EPFLAGS_KILLED;

		RELEASE_EPD(pEPD, "UNLOCK (KILLCONN - Base Ref)"); // RELEASE the EPD, releases EPLock
	}
	else
	{
		Unlock(&pEPD->EPLock);
	}

	if(pRcvBuff)
	{
		DPFX(DPFPREP,DPF_CALLOUT_LVL, "(%p) Calling SP->ReturnReceiveBuffers, pSPD[%p], pRcvBuff[%p]", pEPD, pSPD, pRcvBuff);
		IDP8ServiceProvider_ReturnReceiveBuffers(pSPIntf, pRcvBuff);
	}

	// Tell user that session is over

	// If the Core previously knew about this endpoint, and we have not yet indicated disconnect to the 
	// Core, we need to do it now.
	if(fIndicateDisconnect)
	{
		DPFX(DPFPREP,DPF_CALLOUT_LVL, "(%p) Calling Core->IndicateConnectionTerminated, DPNERR_CONNECTIONLOST, Core Context[%p]", pEPD, pEPD->Context);
		pEPD->pSPD->pPData->pfVtbl->IndicateConnectionTerminated(pPData->Parent, pEPD->Context, DPNERR_CONNECTIONLOST);
	}

	Lock(&pEPD->EPLock);
	RELEASE_EPD(pEPD, "Drop Link Temp Ref");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\protocol\endpt.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		EndPt.cpp
 *  Content:	This file contains EndPoint management routines.
 *				An End Point is a DirectNet instance that we know about and may communicate
 *				with.  An End Point Descriptor (EPD) tracks each known End Point and was mapped
 *				onto an hEndPoint by a hash table. Now, the SP maintains the mapping and hands
 *				us our EPD address as a context with each indication ReceiveEvent.
 *
 *				In addition to EndPoint creation and destruction,  this file contains routines
 *				which handle link tuning.  This is described in detailed comments below.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  11/06/98	ejs		Created
 *  07/01/2000  masonb  Assumed Ownership
 *
 ****************************************************************************/

#include "dnproti.h"


VOID	RunAdaptiveAlg(PEPD, DWORD);
VOID	ThrottleBack(PEPD, DWORD);

#define 	USE_BURST_GAP		TRUE

/*
**		Crack EndPoint Descriptor
**
*/

#undef DPF_MODNAME
#define DPF_MODNAME "DNPCrackEndPointDescriptor"

HRESULT DNPCrackEndPointDescriptor(HANDLE hEndPoint, PSPGETADDRESSINFODATA pSPData)
{
	PEPD	pEPD = (PEPD) hEndPoint;
	HRESULT	hr = DPNERR_INVALIDENDPOINT;

	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: hEndPoint[%x], pSPData[%p]", hEndPoint, pSPData);
	
	ASSERT_EPD(pEPD);

	if(LOCK_EPD(pEPD, "LOCK (Crack EPD)"))
	{
		Lock(&pEPD->EPLock);
		if(pEPD->ulEPFlags & EPFLAGS_STATE_CONNECTED)
		{
			PSPD	pSPD = pEPD->pSPD;
			pSPData->hEndpoint = pEPD->hEndPt;
			
			RELEASE_EPD(pEPD, "UNLOCK (Crack EPD)"); // releases EPLock

			DPFX(DPFPREP,DPF_CALLOUT_LVL, "(%p) Calling SP->GetAddressInfo, pSPD[%p]", pEPD, pSPD);
			hr = IDP8ServiceProvider_GetAddressInfo(pSPD->IISPIntf, pSPData);
		}
		else
		{
			RELEASE_EPD(pEPD, "UNLOCK (Crack EPD)"); // releases EPLock
		}
	}
	else
	{
		DPFX(DPFPREP,1, "(%p) DNPCrackEndPointDescriptor called on unreferenced EPD, returning DPNERR_INVALIDENDPOINT", pEPD);
	}
	return hr;
}

/*
**		INTERNAL - EndPoint management functions
*/

/*
**		New End Point
**
**		Everytime a packet is indicated with an address that we dont recognize we will allocate
**	an EPD for it and add it to our tables.  It is a higher layer's responsibility to tell
**	us when it no longer wants to talk to the EP so that we can clear it out of our
**	(and the SP's) table.
**
*/

#undef DPF_MODNAME
#define DPF_MODNAME "NewEndPoint"

PEPD NewEndPoint(PSPD pSPD, HANDLE hEP)
{
	PEPD	pEPD;

	if((pEPD = static_cast<PEPD> (EPDPool->Get(EPDPool))) == NULL)
	{	
		DPFX(DPFPREP,0, "Failed to allocate new EPD");
		return NULL;
	}

	ASSERT(hEP != INVALID_HANDLE_VALUE);

	pEPD->hEndPt = hEP;								// Record ID in structure
	pEPD->pSPD = pSPD;

	pEPD->bNextMsgID = 0;
	
	pEPD->uiRTT = 0;
	pEPD->uiBytesAcked = 0;

	pEPD->uiQueuedMessageCount = 0;
#ifdef	DEBUG
	pEPD->bLastDataSeq = 0xFF;
#endif

	// We track a byte-window and a frame-window separately.  Start with 2 discreet frames,  but only 1 FULL frame.
													
	pEPD->uiWindowF = 2;							// start with 1 full-frame window (this could still be many frames)
	pEPD->uiWindowBIndex = 1;
	pEPD->uiWindowB = pSPD->uiFrameLength;			// ditto for bytes
	pEPD->uiUnackedFrames = 0;						// outstanding frame count
	pEPD->uiUnackedBytes = 0;						// outstanding byte count
	pEPD->uiBurstGap = 100;							// starting point 100ms/burst
	pEPD->dwSessID = 0;

	// ReceiveComplete flag prevents received data from being indicated to core until after new connection is indicated
	// Initialize state
	pEPD->ulEPFlags = EPFLAGS_END_POINT_IN_USE | EPFLAGS_STATE_DORMANT | EPFLAGS_IN_RECEIVE_COMPLETE; // Initialize state

	ASSERT(pEPD->lRefCnt == 0);					// WE NOW HAVE A -1 BASED REFCNT INSTEAD OF ZERO BASED (FOR EPDs)

	pEPD->SendTimer = 0;							// Timer for next send-burst opportunity
	pEPD->RetryTimer = 0;							// window to receive Ack
	pEPD->ConnectTimer = 0;
	pEPD->DelayedAckTimer = 0;						// wait for piggyback opportunity before sending Ack
	pEPD->DelayedMaskTimer = 0;						// wait for piggyback opportunity before sending Mask frame
	pEPD->BGTimer = 0;								// Periodic background timer
	pEPD->uiCompleteMsgCount = 0;

	LOCK_EPD(pEPD, "SP reference"); // We will not remove this reference until the SP tells us to go away.

	Lock(&pSPD->SPLock);
	pEPD->blActiveLinkage.InsertAfter( &pSPD->blEPDActiveList); // Place this guy in active list
	Unlock(&pSPD->SPLock);
	
	return pEPD;
}

/*
**		Initial Link Parameters
**
**		we have kept a checkpoint structure matching everying frame we sent in the Connect
**	handshake so that we can match a response to a specific frame or retry.  This allows us
**	to measure a single sample Round Trip Time (RTT),  which we will use below to generate
**	initial values for our link-state variables.
**
*/

#undef DPF_MODNAME
#define DPF_MODNAME "InitLinkParameters"

VOID InitLinkParameters(PEPD pEPD, UINT uiRTT, UINT normal_load, UINT bias, DWORD tNow)
{
	DWORD	dwTimerInterval;

	AssertCriticalSectionIsTakenByThisThread(&pEPD->EPLock, TRUE);

	if(uiRTT == 0)
	{
		uiRTT = 1;
	}
		
	pEPD->uiRTT = uiRTT;										// we know the base RTT
	pEPD->fpRTT = TO_FP(uiRTT);									// 16.16 fixed point version
	pEPD->uiDropCount = 0;
	pEPD->uiThrottleEvents = 0;									// Count times we throttle-back for all reasons
#ifdef	DEBUG
	pEPD->uiTotalThrottleEvents = 0;
#endif

	pEPD->uiBurstGap = 0;	// For now assume we dont need a burst gap

	pEPD->uiMsgSentHigh = 0;
	pEPD->uiMsgSentNorm = 0;
	pEPD->uiMsgSentLow = 0;
	pEPD->uiMsgTOHigh = 0;
	pEPD->uiMsgTONorm = 0;
	pEPD->uiMsgTOLow = 0;
	
	pEPD->uiMessagesReceived = 0;

	pEPD->uiGuaranteedFramesSent = 0;
	pEPD->uiGuaranteedBytesSent = 0;
	pEPD->uiDatagramFramesSent = 0;
	pEPD->uiDatagramBytesSent = 0;
	
	pEPD->uiGuaranteedFramesReceived = 0;
	pEPD->uiGuaranteedBytesReceived = 0;
	pEPD->uiDatagramFramesReceived = 0;
	pEPD->uiDatagramBytesReceived = 0;
	
	pEPD->uiGuaranteedFramesDropped = 0;
	pEPD->uiGuaranteedBytesDropped = 0;
	pEPD->uiDatagramFramesDropped = 0;
	pEPD->uiDatagramBytesDropped = 0;

	pEPD->uiGoodBurstGap = 0;									// No Known Good Gap!
	pEPD->uiGoodRTT = 60000; // We need this to initially be artificially high
	pEPD->uiGoodWindowF = 1;
	pEPD->uiGoodWindowBI = 1;
	pEPD->iBurstCredit = 0;
	pEPD->tLastDelta = tNow;
	pEPD->uiWindowFilled = 0;
	
	pEPD->tLastThruPutSample = tNow;

	pEPD->uiLastBytesAcked = 0;

	pEPD->uiPeriodAcksBytes = 0;
	pEPD->uiPeriodXmitTime = 0;

	pEPD->uiPeriodRateB = 0;
	pEPD->uiPeakRateB = 0;
	pEPD->uiLastRateB = 0;
	
	pEPD->ulReceiveMask = 0;
	pEPD->ulReceiveMask2 = 0;
	pEPD->tReceiveMaskDelta = 0;
	
	pEPD->ulSendMask = 0;
	pEPD->ulSendMask2 = 0;
	
	pEPD->Context = NULL;
	DPFX(DPFPREP,7, "CONNECTION ESTABLISHED pEPD = 0x%p RTT = %dms, BurstGap=%dms", pEPD, pEPD->uiRTT, pEPD->uiBurstGap);

	// We set the IdleThreshhold very low to generate a little bit of traffic for initial link tuning in case the
	// application doesnt do any right away

	pEPD->ulEPFlags |= EPFLAGS_USE_POLL_DELAY;					// always assume balanced traffic at start-up
	
	pEPD->uiAdaptAlgCount = 4;									// start running adpt alg fairly often
	
	// Calc a retry timeout value based upon the measured RTT (2.5 * RTT) + MAX_DELAY
	pEPD->uiRetryTimeout = ((pEPD->uiRTT + (pEPD->uiRTT >> 2)) * 2) + DELAYED_ACK_TIMEOUT;

	// don't want to get more aggressive because we drop a frame.
	if(pEPD->uiRetryTimeout < pEPD->uiBurstGap)
	{
		pEPD->uiRetryTimeout = pEPD->uiBurstGap;	
	}
	

	pEPD->uiUserFrameLength = pEPD->pSPD->uiUserFrameLength;
	
	if(pEPD->BGTimer == 0)
	{
		if (pEPD->pSPD->pPData->tIdleThreshhold > ENDPOINT_BACKGROUND_INTERVAL)
		{
			dwTimerInterval = ENDPOINT_BACKGROUND_INTERVAL;
		}
		else
		{
			dwTimerInterval = pEPD->pSPD->pPData->tIdleThreshhold;
		}

		DPFX(DPFPREP,7, "(%p) Setting Endpoint Background Timer for %u ms", pEPD, dwTimerInterval);
		SetMyTimer(dwTimerInterval, 1000, EndPointBackgroundProcess, (PVOID) pEPD, &pEPD->BGTimer, &pEPD->BGTimerUnique);
		LOCK_EPD(pEPD, "LOCK (BG Timer)");												// create reference for this timer
	}
}


/****************
*
*			Link Tuning
*
*		Here are current ideas about link tuning.  Idea is to track Round Trip Time of key-frames and throttle
*	based upon changes in this measured RTT when possible.  This would benefit us in determining link saturation
*	before packet loss occurs, instead of waiting for the inevitable packet loss before throttling back.
*
*		On high-speed media,  the average RTT is small compared to the standard deviations making it hard to
*	predict anything useful from them.  In these cases,  we must look at packet drops.  Except for one exception:
*	We will look for large spikes in RTT and we will respond to these with an immediate, temporary throttle back.
*	This will allow a bottle-neck to clear hopefully without packet-loss.  So far,  I have not been able to verfify
*	any benefit from this behavior on reliable links.  It is more likely to be beneficial with datagram traffic
*	where send windows do not limit write-ahead.
*
*		I would like to take a measurement of the through-put acheived compared to the transmission rate,  but I
*	havent yet come up with a good way to measure this.  What I do calculate is packet acknowledgement rate,  which
*	can be calculated without any additional input from the remote side.  We will store AckRates acheived at the
*	previous transmission rate,  so we can look for improvements in Acks as we increase Transmissions.  When we
*	no longer detect AckRate improvements then we assume we have plateaued and we stop trying to increase the rate.
*
*	TRANSMISSION RATE
*
*		Transmission rate is controlled by two distinct parameters: Insertion Rate and Window Size.  Where a
*	conventional protocol would dump a window full of packets onto the wire in one burst,  we would like to
*	spread the packet insertions out over the full RTT so that the window never completely fills and hence
*	blocks the link from transmitting.  This has a wide array of potential benefits:  Causes less congestions
*	throughout the network path; Allows more balanced access to the wire to all Endpoints (especially on
*	slower media); Allows MUCH more accurate measurements to be made of trasmission times when packets
*	spend less time enqueued locally;  Allows retry timers to be set much lower giving us quicker error
*	recovery (because there is less queue time fudged into the timer);  Allows recovery to be made more
*	quickly when we don't have a lot of data enqueued in SP (both our own data and other Endpoint's data).
*	...And I am sure there are more.
*
*		So,  we would like to trickle out packets just fast enough to fill the window as the next ACK is received.
*	We will grow the window fairly liberally and let the burst rate increase more cautiously.
*	
*		On high-speed media the insertion time becomes fairly small (near zero) and we are less likely to queue
*	up large quantities of data.  Therefore we may allow insertion rate to go max and use the window alone to
*	control flow. I will experiment with this more.
*
******************/

#define		RTT_SLOW_WEIGHT					8					// fpRTT gain = 1/8
#define		THROTTLE_EVENT_THRESHOLD		20

/*
**		Update Endpoint
**
**		We will let the sliding window control the flow
**	and increase the window as long as through-put continues to increase and frames continue to get delivered without
**	excessive droppage.
**	
**		We still calculate RTT for the purpose of determining RetryTimer values.  For cases with large RTTs we may still
**	implement an inter-packet gap,  but we will try to make it an aggressive gap (conservatively small) because we would
**	rather feed the pipe too quickly than artificially add latency by letting the pipe go idle with data ready to be sent.
**
**		** CALLED WITH EPD STATELOCK HELD **
*/

#undef DPF_MODNAME
#define DPF_MODNAME "UpdateEndPoint"

VOID UpdateEndPoint(PEPD pEPD, UINT uiRTT, UINT payload, UINT bias, DWORD tNow)
{
	UINT	fpRTT;
	INT		fpDiff;
	
	AssertCriticalSectionIsTakenByThisThread(&pEPD->EPLock, TRUE);

	// Don't allow zero RTTs
	if(uiRTT == 0)
	{												
		uiRTT = 1;
	}
	
	// Filter out HUGE samples,  they often popup during debug sessions
	else if(uiRTT > (pEPD->uiRTT * 128))
	{
		DPFX(DPFPREP,7, "Tossing huge sample (%dms)", uiRTT);
		return;
	}

	// Perform next iteration of math on new RTT sample in 16.16 fixed point

	fpRTT = TO_FP(uiRTT);										// Fixed point sample
	fpDiff = fpRTT - pEPD->fpRTT;								// Current Delta (signed)

	pEPD->fpRTT = pEPD->fpRTT + (fpDiff / RTT_SLOW_WEIGHT);		// .0625 weighted avg
	pEPD->uiRTT = FP_INT(pEPD->fpRTT);							// Store integer portion

	// Calc a retry timeout value based upon the measured RTT (2.5 * RTT) + MAX_DELAY
	pEPD->uiRetryTimeout = ((pEPD->uiRTT + (pEPD->uiRTT >> 2)) * 2) + DELAYED_ACK_TIMEOUT;

	// don't want to get more aggressive because we drop a frame.
	if(pEPD->uiRetryTimeout < pEPD->uiBurstGap)
	{
		pEPD->uiRetryTimeout = pEPD->uiBurstGap;	
	}
	
	DPFX(DPFPREP,7, "(%p) RTT SAMPLE: Size = %d; RTT = %d, Avg = %d <<<<", pEPD, payload, uiRTT, FP_INT(pEPD->fpRTT));

	// If throttle is engaged we will see if we can release it yet
	
	if(pEPD->ulEPFlags & EPFLAGS_THROTTLED_BACK)
	{
		if((tNow - pEPD->tThrottleTime) > (pEPD->uiRTT * 8)) 
		{
			pEPD->ulEPFlags &= ~(EPFLAGS_THROTTLED_BACK);
			pEPD->uiDropCount = 0;
			pEPD->uiBurstGap = pEPD->uiRestoreBurstGap;
			pEPD->uiWindowF =  pEPD->uiRestoreWindowF;
			pEPD->uiWindowBIndex = pEPD->uiRestoreWindowBI;
			pEPD->uiWindowB = pEPD->uiWindowBIndex * pEPD->pSPD->uiFrameLength;

			DPFX(DPFPREP,DPF_ADAPTIVE_LVL, "** (%p) RECOVER FROM THROTTLE EVENT: Window(F:%d,B:%d); Gap=%d", pEPD, pEPD->uiWindowF, pEPD->uiWindowBIndex, pEPD->uiBurstGap);
			pEPD->tLastDelta = tNow;							// Enforce waiting period after back-off before tuning up again
		}
	}
	// Throttle Event tracks how often a packet-drop has caused us to throttle back transmission rate.  We will let this value
	// decay over time.  If throttle events happen faster then the decay occurs then this value will grow un-bounded.  This
	// growth is what causes a decrease in the actual send window/transmit rate that will persist beyond the throttle event.
	
	else if(pEPD->uiThrottleEvents)
	{
		pEPD->uiThrottleEvents--;								// Let this decay...
	}

	if(--pEPD->uiAdaptAlgCount == 0)
	{
		RunAdaptiveAlg(pEPD, tNow);
	}
}

/*
**		Grow Send Window
**
**		The two parallel send windows,  frame-based and byte-based,  can grow and shrink independently.  In this
**	routine we will grow one or both windows.  We will grow each window providing that it has been filled in the
**	last period, during which we have determined that thru-put has increased.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "GrowSendWindow"

BOOL
GrowSendWindow(PEPD pEPD, DWORD tNow)
{
	UINT	delta = 0;

	pEPD->tLastDelta = tNow;

	// first store current good values for a restore
	pEPD->uiGoodWindowF = pEPD->uiWindowF;
	pEPD->uiGoodWindowBI = pEPD->uiWindowBIndex;
	pEPD->uiGoodRTT = pEPD->uiRTT;

#ifdef USE_BURST_GAP
	pEPD->uiGoodBurstGap=pEPD->uiBurstGap;

	if(pEPD->uiBurstGap)
	{
		// cut the burst gap by 25% if less than 3 ms go to 0.
		if(pEPD->uiBurstGap > 3)
		{
			pEPD->uiBurstGap -= pEPD->uiBurstGap >> 2;
		} 
		else 
		{
			pEPD->uiBurstGap = 0;
		}

		pEPD->uiLastRateB = pEPD->uiPeriodRateB;
		pEPD->uiPeriodAcksBytes = 0;
		pEPD->uiPeriodXmitTime = 0;

		DPFX(DPFPREP,DPF_ADAPTIVE_LVL, "(%p), burst gap set to %d ms", pEPD, pEPD->uiBurstGap);
	} 
	else 
	{
#endif
		if((pEPD->ulEPFlags & EPFLAGS_FILLED_WINDOW_FRAME) && (pEPD->uiWindowF < MAX_RECEIVE_RANGE))
		{
			pEPD->uiWindowF++;
			delta = 1;
		}
		if((pEPD->ulEPFlags & EPFLAGS_FILLED_WINDOW_BYTE) && (pEPD->uiWindowBIndex < MAX_RECEIVE_RANGE))
		{
			pEPD->uiWindowBIndex++;
			pEPD->uiWindowB += pEPD->pSPD->uiFrameLength;
			delta = 1;
		}

		pEPD->ulEPFlags &= ~(EPFLAGS_FILLED_WINDOW_FRAME | EPFLAGS_FILLED_WINDOW_BYTE);
		pEPD->uiWindowFilled = 0;

		if(delta)
		{
			pEPD->uiLastRateB = pEPD->uiPeriodRateB;
			pEPD->uiPeriodAcksBytes = 0;
			pEPD->uiPeriodXmitTime = 0;
			DPFX(DPFPREP,DPF_ADAPTIVE_LVL, "(%p) ** GROW SEND WINDOW to %d frames and %d (%d) bytes", pEPD, pEPD->uiWindowF, pEPD->uiWindowB, pEPD->uiWindowBIndex);
		}
		else 
		{
			// We get here if we have already max'd out the window
			DPFX(DPFPREP,DPF_ADAPTIVE_LVL, "(%p) GROW SEND WINDOW -- Nothing to grow. Transition to Stable!", pEPD);
			pEPD->ulEPFlags |= EPFLAGS_LINK_STABLE;

			return FALSE;
		}

#ifdef USE_BURST_GAP
	}
#endif	

	return TRUE;
}


#undef DPF_MODNAME
#define DPF_MODNAME "RunAdaptiveAlg"

VOID
RunAdaptiveAlg(PEPD pEPD, DWORD tNow)
{
	LONG	tDelta;											// Time the link was transmitting since last run of AdaptAlg
	UINT	uiBytesAcked;
	UINT	uiNewSum;

	// Calculate the time during which this link was actually transmitting to make sure we have enough
	// data to run the Adaptive Alg.  This is easy unless we are currently idle...

	tDelta = tNow - pEPD->tLastThruPutSample;

	DPFX(DPFPREP,DPF_ADAPTIVE_LVL, "(%p) Adaptive Alg tDelta = %d", pEPD, tDelta);

	// THIS PROBABLY IS UNNECESSARY NOW...
	if(tDelta <= 0)
	{
		DPFX(DPFPREP,DPF_ADAPTIVE_LVL, "DELAYING Adaptive Alg");
		pEPD->uiAdaptAlgCount = 4;
		return;
	}

	//  Calculate current throughput acheived
	//
	//		We will determine the amount of time the link was not idle and then number of bytes (& frames) which
	//	were acknowleged by our partner.
	//
	//	tDelta = Time since last calculation minus the time the link was idle.
	
	uiBytesAcked = pEPD->uiBytesAcked - pEPD->uiLastBytesAcked;

	uiNewSum = pEPD->uiPeriodAcksBytes + (uiBytesAcked * 256);

	if(uiNewSum < pEPD->uiPeriodAcksBytes)
	{
		DPFX(DPFPREP,DPF_ADAPTIVE_LVL, "THRUPUT is about to wrap. Correcting...");
		pEPD->uiPeriodAcksBytes /= 2;
		pEPD->uiPeriodXmitTime /= 2;
		pEPD->uiPeriodAcksBytes += (uiBytesAcked * 256);
	}
	else 
	{
		pEPD->uiPeriodAcksBytes = uiNewSum;
	}

	pEPD->uiPeriodXmitTime += tDelta;								// Track complete values for this period
	pEPD->tLastThruPutSample = tNow;
	
	pEPD->uiLastBytesAcked = pEPD->uiBytesAcked;
	pEPD->uiPeriodRateB = pEPD->uiPeriodAcksBytes / pEPD->uiPeriodXmitTime;

	if(pEPD->uiPeriodRateB > pEPD->uiPeakRateB)
	{
		pEPD->uiPeakRateB = pEPD->uiPeriodRateB;					// Track the largest value we ever measure
	}
	
	DPFX(DPFPREP,DPF_ADAPTIVE_LVL, "(%p) PERIOD COUNT BYTES = %u, XmitTime = %u, Thruput=(%u bytes/s), RTT=%u, Window=(%u,%u)", pEPD, pEPD->uiPeriodAcksBytes, pEPD->uiPeriodXmitTime, pEPD->uiPeriodRateB * 4, pEPD->uiRTT, pEPD->uiWindowF, pEPD->uiWindowB);

	if (pEPD->ulEPFlags & EPFLAGS_LINK_FROZEN)
	{
		DPFX(DPFPREP,DPF_ADAPTIVE_LVL, "(%p) Test App requests that dynamic algorithm not be run, skipping", pEPD);
		pEPD->uiAdaptAlgCount = 32; // Make sure the throughput numbers get updated from time to time
		return;
	}

	if(pEPD->ulEPFlags & EPFLAGS_LINK_STABLE)
	{
		/*		We are in a STABLE state,  meaning we think we are transmitting at an optimal
		**	rate for the current network conditions.  Conditions may change.  If things slow down
		**	or grow congested a Backoff will trigger normally.  Since conditions might also change
		**	for the better,  we will still want to periodically probe higher rates,  but much less
		**	often than when we are in DYNAMIC mode,  which means we are searching for an optimal rate.
		*/
		
		pEPD->uiAdaptAlgCount = 32;		// tNow + (pEPD->uiRTT * 32) + 32;

		if((tNow - pEPD->tLastDelta) > INITIAL_STATIC_PERIOD)
		{
			if(pEPD->ulEPFlags & (EPFLAGS_FILLED_WINDOW_FRAME | EPFLAGS_FILLED_WINDOW_BYTE))
			{
				DPFX(DPFPREP,DPF_ADAPTIVE_LVL, "(%p) RETURNING LINK TO DYNAMIC MODE", pEPD);
				
				pEPD->ulEPFlags &= ~(EPFLAGS_LINK_STABLE);

				pEPD->uiPeriodAcksBytes = 0;
				pEPD->uiPeriodXmitTime = 0;

				pEPD->uiWindowFilled = 0;
				pEPD->ulEPFlags &= ~(EPFLAGS_FILLED_WINDOW_FRAME | EPFLAGS_FILLED_WINDOW_BYTE);
				pEPD->uiAdaptAlgCount = 12;
			}
			else 
			{
				DPFX(DPFPREP,DPF_ADAPTIVE_LVL, "(%p) NO WINDOWS FILLED,  Not returning to Dynamic Mode", pEPD);
				pEPD->tLastDelta = tNow;
			}
		}
		else
		{
			DPFX(DPFPREP,DPF_ADAPTIVE_LVL, "(%p) STILL IN STATIC PERIOD, time=%u, period=%u", pEPD, tNow - pEPD->tLastDelta, INITIAL_STATIC_PERIOD);
		}
	}

	// DYNAMIC STATE LINK
	else 
	{  
		pEPD->uiAdaptAlgCount = 8;

		// Possibly increase transmission rates.  We will not do this if we have had a ThrottleEvent
		// in recent memory,  or if we have not been actually transmitting for enough of the interval
		// to have collected worthwhile data
		//
		//		Also,  we dont want to even consider growing the send window unless we are consistantly
		// filling it.  Since one job of the window is to prevent us from flooding the net during a backup,
		// we dont want to grow the window following each backup.  The best way to distinguish between a 
		// backup and too small of a window is that the small window should fill up regularly while the
		// backups should only occur intermittantly.  The hard part is coming up with the actual test.
		// Truth is,  we can be fairly lax about allowing growth because it will also have to meet the increased
		// bandwidth test before the larger window is accepted.  So a crude rule would be to fix a number like 3.
		// Yes, crude but probably effective.  Perhaps a more reasonable figure would be a ratio of the total
		// number of packets sent divided by the window size.  I.e., if your window size is 10 frames then one
		// packet in ten should fill the window.  Of course, this would have to be calculated in bytes...

		if((pEPD->uiWindowFilled > 12)&&(pEPD->uiThrottleEvents == 0))
		{
			DPFX(DPFPREP,DPF_ADAPTIVE_LVL, "(%p) DYNAMIC ALG: Window Fills: %d; B-Ack = (%x vs %x)", pEPD, pEPD->uiWindowFilled, pEPD->uiPeriodRateB, pEPD->uiLastRateB);
									
			pEPD->uiWindowFilled = 0;	

			if (!(pEPD->ulEPFlags & EPFLAGS_TESTING_GROWTH))
			{
				DPFX(DPFPREP,DPF_ADAPTIVE_LVL, "(%p) GROWING WINDOW", pEPD);
				
				// In the case that GrowSendWindow doesn't grow anything because we are already max'd out
				// it will return FALSE, and it should have transitioned us to STABLE.
				if (GrowSendWindow(pEPD, tNow))
				{
					pEPD->ulEPFlags |= EPFLAGS_TESTING_GROWTH;
				}
				else
				{
					ASSERT(pEPD->ulEPFlags & EPFLAGS_LINK_STABLE);
				}

				return;
			}
			
			// GETTING HERE means that we have used our current transmit parameters long enough
			// to have an idea of their performance.  We will now compare this to the performance
			// of the previous transmit parameters and we will either Revert to the previous set if
			// the perf is not improved,  or else we will advance to faster parameters if we did see
			// a jump.

			// In order to keep higher transmit parameters we need to see an increase in throughput 
			// with no corresponding rise in RTT.  We will want to see this twice just to be sure
			// since the cost of incorrect growth is so high on a modem.

			if( (pEPD->uiPeriodRateB > pEPD->uiLastRateB) && 
				(pEPD->uiRTT <= (pEPD->uiGoodRTT + 10))
				)
			{
				DPFX(DPFPREP,DPF_ADAPTIVE_LVL, "(%p) Throughput increased after window growth, keeping new parameters", pEPD);

				pEPD->ulEPFlags &= ~(EPFLAGS_TESTING_GROWTH);

				pEPD->uiPeriodAcksBytes = 0;
				pEPD->uiPeriodXmitTime = 0;
			}
			else 
			{
				// We did not see a thru-put improvement so we will back off the previous value
				// and transition the link to STABLE state.

				DPFX(DPFPREP,DPF_ADAPTIVE_LVL, "(%p) INSUFFICENT INCREASE IN THRUPUT, BACK OFF AND TRANSITION TO STABLE", pEPD);

				// Because we have over-transmitted for at least one period, we may have put excess data
				// on the link in a buffer.  This will have the effect of gradually growing our RTT if we
				// don't bleed that data off which we will do here by backing off two steps where we 
				// previously grew one step.

#ifdef USE_BURST_GAP
				if (pEPD->uiBurstGap != pEPD->uiGoodBurstGap)
				{
					// increase the burst gap by 25%
					pEPD->uiBurstGap = pEPD->uiGoodBurstGap + (pEPD->uiGoodBurstGap >> 2);
				}
#endif					
					
				if (pEPD->uiWindowF != pEPD->uiGoodWindowF)
				{
					if (pEPD->uiGoodWindowF > 2)
					{
						pEPD->uiWindowF = MAX(pEPD->uiGoodWindowF - 1, 1);
					}
					else
					{
						pEPD->uiWindowF = pEPD->uiGoodWindowF;
					}
				}
				if (pEPD->uiWindowBIndex != pEPD->uiGoodWindowBI)
				{
					pEPD->uiWindowBIndex = MAX(pEPD->uiGoodWindowBI - 1, 1);
					pEPD->uiWindowB = pEPD->uiWindowBIndex * pEPD->pSPD->uiFrameLength;
				}

				pEPD->ulEPFlags |= EPFLAGS_LINK_STABLE;				// TRANSITION TO STABLE STATE
				
				pEPD->ulEPFlags &= ~(EPFLAGS_TESTING_GROWTH);

				pEPD->uiPeriodAcksBytes = 0;
				pEPD->uiPeriodXmitTime = 0;
				
				DPFX(DPFPREP,DPF_ADAPTIVE_LVL, "(%p) ** TUNING LINK:  BurstGap=%d; FWindow=%d, BWindow=%d (%d)",pEPD, pEPD->uiBurstGap, pEPD->uiWindowF, pEPD->uiWindowB, pEPD->uiWindowBIndex);
			}
		}
		else 
		{
			DPFX(DPFPREP,DPF_ADAPTIVE_LVL, "(%p) DYN ALG -- Not trying to increase:  WindowFills = %d, ThrottleCount = %d", pEPD, pEPD->uiWindowFilled, pEPD->uiThrottleEvents);
		}
	}	// END IF DYNAMIC STATE LINK
}


/*
**		End Point Dropped Frame
**
**		We have two levels of Backoff.  We have an immediate BackOff implemented
**	upon first detection of a drop-event in order to relieve the congestion which
**	caused the drop.  An immediate backoff will resume transmitting at the original
**	rate without going through slow-start again after the congestion event has passed.
**	If we have multiple immediate-backoffs in a certain interval we will have a
**	hard backoff which will not restore.
**
**	CALLED WITH EPD->SPLock held (and sometimes with StateLock held too)
*/

#undef DPF_MODNAME
#define DPF_MODNAME "EndPointDroppedFrame"

VOID
EndPointDroppedFrame(PEPD pEPD, DWORD tNow)
{
	// If this is first drop in short interval
	if(!pEPD->uiDropCount++)
	{	
		DPFX(DPFPREP,7, "DROP EVENT INITIATED: Throttling Back");
		ThrottleBack(pEPD, tNow);
	}
	
	// Multiple drops reported in short order
	else 
	{		

		// There are two possibilities and trick is to distinguish them.  Either we are still xmitting too fast
		// OR we are seeing additional drops caused by the previous xmit rate.  In first case we must back off
		// further.  In second case we should do nothing.  As a heuristic,  we can say we will ignore the second
		// and third drop,  but backoff further by the fourth.  Kinda kludgy but will probably work pretty well.
		// Robust solution would be to try to calculate back-log ala aaron,  but I am not convinced that we could
		// do that efficiently.  Alternatively,  we could just fake the calc for the back-off and back off some
		// fudge based upon RTT and outstanding frames.

		// Throttle back every fourth drop!
		if((pEPD->uiDropCount & 3) == 0)
		{			
			DPFX(DPFPREP,7, "(%p) THROTTLING BACK FURTHER", pEPD);
			ThrottleBack(pEPD, tNow);
		}
	}
}

/*
**		Throttle Back
**
**		We suspect network congestion due to dropped frames ((or a spike in latency)).  We want
**	to quickly scale back our transmit rate to releive the congestion and avoid further packet drops.
**	This is a temporary backoff and we will resume our current transmit rate when the congestions
**	clears.
**
**		If we find that we are throttling back frequently then we may conclude that our current xmit
**	rate is higher then optimal and we will BackOff to a lower rate,  and transition to a STABLE link
**	state (if not already there) to indicate that we have plateaued.
**
**		A note on convergence.  The ThrottleEvents variable is incremented 10 points each time a throttle
**	event is triggered.  This variable also decays slowly when the link is running without events.  So if
**	the variable grows faster then it decays we will eventually trigger a switch to STABLE state
*/

#undef DPF_MODNAME
#define DPF_MODNAME "ThrottleBack"

VOID
ThrottleBack(PEPD pEPD, DWORD tNow)
{
	if (pEPD->ulEPFlags & EPFLAGS_LINK_FROZEN)
	{
		DPFX(DPFPREP,DPF_ADAPTIVE_LVL, "(%p) Test App requests that throttle code not be run, skipping", pEPD);
		return;
	}

	pEPD->ulEPFlags |= EPFLAGS_THROTTLED_BACK;		// Set link to THROTTLED state
	pEPD->uiThrottleEvents += 10;					// Count times we throttle-back for all reasons
	pEPD->tThrottleTime = tNow;						// Remember time that throttle was engaged
	
#ifdef	DEBUG
	pEPD->uiTotalThrottleEvents++;					// Count times we throttle-back for all reasons
#endif

	pEPD->uiRestoreBurstGap = pEPD->uiBurstGap;
	pEPD->uiRestoreWindowF = pEPD->uiWindowF;
	pEPD->uiRestoreWindowBI = pEPD->uiWindowBIndex;

#ifdef USE_BURST_GAP
	if(pEPD->uiWindowF == 1)
	{
		if(pEPD->uiBurstGap == 0)
		{
			pEPD->uiBurstGap = MAX(1,pEPD->uiRTT/2);
			DPFX(DPFPREP,DPF_ADAPTIVE_LVL, "(%p), first burst gap, set to %d ms", pEPD, pEPD->uiBurstGap);
		} 
		else 
		{
			pEPD->uiBurstGap = pEPD->uiBurstGap*2;						
			DPFX(DPFPREP,DPF_ADAPTIVE_LVL, "(%p), burst gap doubled to %d ms", pEPD, pEPD->uiBurstGap);
		}
		pEPD->uiBurstGap = MIN(pEPD->uiBurstGap, MAX_RETRY_INTERVAL/2);
		DPFX(DPFPREP,DPF_ADAPTIVE_LVL, "(%p), burst gap is now %d ms", pEPD, pEPD->uiBurstGap);
	}
#endif

	pEPD->uiWindowF = MAX(pEPD->uiWindowF / 2, 1);	// be sure window remains > 0.
	pEPD->uiWindowBIndex = MAX(pEPD->uiWindowBIndex / 2, 1);
	pEPD->uiWindowB = pEPD->uiWindowBIndex * pEPD->pSPD->uiFrameLength;
	DPFX(DPFPREP,DPF_ADAPTIVE_LVL, "(%p) THROTTLE ENGAGED (%d):  Backoff to Window=%d; Gap=%d", pEPD, pEPD->uiThrottleEvents, pEPD->uiWindowF, pEPD->uiBurstGap);
	
	if(pEPD->uiThrottleEvents > THROTTLE_EVENT_THRESHOLD)
	{
		DPFX(DPFPREP,DPF_ADAPTIVE_LVL, "(%p) ** DETECT TRANSMIT CEILING ** Reducing 'good' speed and marking link STABLE", pEPD);

		// We have already reduced our current transmit rates.  Here we will reduce the "good" rates that
		// we will restore to when we clear the throttled state.
		
		pEPD->uiThrottleEvents = 0;

		pEPD->uiRestoreWindowF = MAX((pEPD->uiRestoreWindowF - 1), 1);
		pEPD->uiRestoreWindowBI = MAX((pEPD->uiRestoreWindowBI - 1), 1);

#ifdef USE_BURST_GAP		
		if (pEPD->uiRestoreBurstGap)
		{
			UINT t;
			t=pEPD->uiRestoreBurstGap;
			pEPD->uiRestoreBurstGap = (t+1) + (t >> 2); // 1.25*pEPD->uiRestoreBurstGap
		}
#endif
		DPFX(DPFPREP,DPF_ADAPTIVE_LVL, "(%p) New Restore Values:  Window=%d; Gap=%d", pEPD, pEPD->uiRestoreWindowF, pEPD->uiRestoreBurstGap);

		pEPD->ulEPFlags |= EPFLAGS_LINK_STABLE;
		pEPD->ulEPFlags &= ~(EPFLAGS_TESTING_GROWTH);
	}
}


/*
**		EPD Pool Support Routines
**
**		These are the functions called by Fixed Pool Manager as it handles EPDs.
*/

//	Allocate is called when a new EPD is first created

#define	pELEMENT	((PEPD) pElement)

#undef DPF_MODNAME
#define DPF_MODNAME "EPD_Allocate"

BOOL EPD_Allocate(PVOID pElement)
{
	DPFX(DPFPREP,7, "(%p) Allocating new EPD", pELEMENT);
	
	pELEMENT->blHighPriSendQ.Initialize();				// Can you beleive there are SIX send queues per Endpoint?
	pELEMENT->blNormPriSendQ.Initialize();				// Six send queues.  
	pELEMENT->blLowPriSendQ.Initialize();				// Well,  it beats sorting the sends into the queues upon submission.
	pELEMENT->blCompleteSendList.Initialize();
	
	pELEMENT->blSendWindow.Initialize();
	pELEMENT->blRetryQueue.Initialize();
	pELEMENT->blCompleteList.Initialize();
	pELEMENT->blOddFrameList.Initialize();
	pELEMENT->blChkPtQueue.Initialize();

	pELEMENT->blSPLinkage.Initialize();

	if (DNInitializeCriticalSection(&pELEMENT->EPLock) == FALSE)
	{
		DPFX(DPFPREP, 0, "Failed to initialize endpoint CS");
		return FALSE;
	}
	DebugSetCriticalSectionRecursionCount(&pELEMENT->EPLock, 0);

	pELEMENT->Sign = EPD_SIGN;
	pELEMENT->pCurrentSend = NULL;
	pELEMENT->pCurrentFrame = NULL;
	pELEMENT->pCommand = NULL;

	pELEMENT->RetryTimer = 0;
	pELEMENT->ConnectTimer = 0;
	pELEMENT->DelayedAckTimer = 0;

	pELEMENT->ulEPFlags = 0;	// EPFLAGS_STATE_CLEAR - make this line show up in state searches

	return TRUE;
}

//	Get is called each time an EPD is used

#undef DPF_MODNAME
#define DPF_MODNAME "EPD_Get"

VOID EPD_Get(PVOID pElement)
{
	DPFX(DPFPREP,DPF_EP_REFCNT_FINAL_LVL, "CREATING EPD %p", pELEMENT);

	// NOTE: First sizeof(PVOID) bytes will have been overwritten by the pool code, 
	// we must set them to acceptable values.

	pELEMENT->hEndPt = INVALID_HANDLE_VALUE;
	pELEMENT->lRefCnt = 0; // We are -1 based, so place the first reference on the endpoint

	pELEMENT->pNewMessage = NULL;
	pELEMENT->pNewTail = NULL;
	
	ASSERT_EPD(pELEMENT);
}

#undef DPF_MODNAME
#define DPF_MODNAME "EPD_Release"

VOID EPD_Release(PVOID pElement)
{
	PCHKPT pCP;

	ASSERT_EPD(pELEMENT);

	DPFX(DPFPREP,DPF_EP_REFCNT_FINAL_LVL, "RELEASING EPD %p", pELEMENT);

	ASSERT((pELEMENT->ulEPFlags & EPFLAGS_LINKED_TO_LISTEN)==0);

	// Clear any checkpoints still waiting on EP

	while(!pELEMENT->blChkPtQueue.IsEmpty())
	{
		pCP = CONTAINING_RECORD(pELEMENT->blChkPtQueue.GetNext(), CHKPT, blLinkage);
		pCP->blLinkage.RemoveFromList();
		ChkPtPool->Release(ChkPtPool, pCP);
	}

	// These lists should be empty before End Point is released...
	ASSERT(pELEMENT->blOddFrameList.IsEmpty());
	ASSERT(pELEMENT->blCompleteList.IsEmpty());

	ASSERT(pELEMENT->blHighPriSendQ.IsEmpty());
	ASSERT(pELEMENT->blNormPriSendQ.IsEmpty());
	ASSERT(pELEMENT->blLowPriSendQ.IsEmpty());
	ASSERT(pELEMENT->blCompleteSendList.IsEmpty());
	
	ASSERT(pELEMENT->blSendWindow.IsEmpty());
	ASSERT(pELEMENT->blRetryQueue.IsEmpty());
	ASSERT(pELEMENT->blActiveLinkage.IsEmpty());
	ASSERT(pELEMENT->blSPLinkage.IsEmpty());
	ASSERT(pELEMENT->blChkPtQueue.IsEmpty());

	ASSERT(pELEMENT->pCurrentSend == NULL);
	ASSERT(pELEMENT->pCurrentFrame == NULL);

	pELEMENT->ulEPFlags = 0;	// EPFLAGS_STATE_CLEAR - make this line show up in state searches

	pELEMENT->pCommand = NULL;
	pELEMENT->Context = NULL;
}

#undef DPF_MODNAME
#define DPF_MODNAME "EPD_Free"

VOID EPD_Free(PVOID pElement)
{
	DNDeleteCriticalSection(&pELEMENT->EPLock);
}

#undef	ELEMENT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\protocol\enum.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		Enum.cpp
 *  Content:	This file contains support enuming sessions.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  01/10/00	jtk		Created
 *  07/01/2000  masonb  Assumed Ownership
 *
 ****************************************************************************/

#include "dnproti.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNPEnumQuery - enum sessions
//
// Entry:		Pointer to this interface
//				Pointer to device address
//				Pointer to host address
//				Pointer to user data buffers
//				Count of user data buffers
//				Retry count
//				Retry interval (milliseconds)
//				Timeout (milliseconds)
//				Command flags
//				Pointer to user context
//				Pointer to command handle destination
//
// Exit:		Boolean inficating whether the GUID is a serial GUID
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNPEnumQuery"

HRESULT DNPEnumQuery( PProtocolData pPData,
					  IDirectPlay8Address *const pHostAddress,
					  IDirectPlay8Address *const pDeviceAddress,
					  const HANDLE hSPHandle,
					  BUFFERDESC *const pBuffers,
					  const DWORD dwBufferCount,
					  const DWORD dwRetryCount,
					  const DWORD dwRetryInterval,
					  const DWORD dwTimeout,
					  const DWORD dwFlags,
					  void *const pUserContext,
					  HANDLE *const pCommandHandle )
{
	PSPD			pSPD;
	PMSD			pMSD;
	SPENUMQUERYDATA	EnumData;
	HRESULT			hr;

	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: pPData[%p], pHostAddr[%p], pDeviceAddr[%p], hSPHandle[%x], pBuffers[%p], dwBufferCount[%x], dwRetryCount[%x], dwRetryInterval[%x], dwTimeout[%x], dwFlags[%x], pUserContext[%p], pCommandHandle[%p]", pPData, pHostAddress, pDeviceAddress, hSPHandle, pBuffers, dwBufferCount, dwRetryCount, dwRetryInterval, dwTimeout, dwFlags, pUserContext, pCommandHandle);

	pSPD = (PSPD) hSPHandle;
	ASSERT_SPD(pSPD);

	// Core should not call any Protocol APIs after calling DNPRemoveServiceProvider
	ASSERT(!(pSPD->ulSPFlags & SPFLAGS_TERMINATING));

	// We use an MSD to describe this Op even tho it
	if((pMSD = static_cast<PMSD>( MSDPool->Get(MSDPool) )) == NULL)
	{	
		DPFX(DPFPREP,0, "Failed to allocate MSD");
		Unlock(&pSPD->SPLock);
		return DPNERR_OUTOFMEMORY;				// .. isnt technically a message
	}

	pMSD->CommandID = COMMAND_ID_ENUM;
	pMSD->pSPD = pSPD;
	pMSD->Context = pUserContext;

	EnumData.pAddressHost = pHostAddress;
	EnumData.pAddressDeviceInfo = pDeviceAddress;
	EnumData.pBuffers = pBuffers;
	EnumData.dwBufferCount = dwBufferCount;
	EnumData.dwTimeout = dwTimeout;
	EnumData.dwRetryCount = dwRetryCount;
	EnumData.dwRetryInterval = dwRetryInterval;

	EnumData.dwFlags = 0;
	if ( ( dwFlags & DN_ENUMQUERYFLAGS_OKTOQUERYFORADDRESSING ) != 0 )
	{
		EnumData.dwFlags |= DPNSPF_OKTOQUERY;
	}

	if ( ( dwFlags & DN_ENUMQUERYFLAGS_NOBROADCASTFALLBACK ) != 0 )
	{
		EnumData.dwFlags |= DPNSPF_NOBROADCASTFALLBACK;
	}

	if ( ( dwFlags & DN_ENUMQUERYFLAGS_ADDITIONALMULTIPLEXADAPTERS ) != 0 )
	{
		EnumData.dwFlags |= DPNSPF_ADDITIONALMULTIPLEXADAPTERS;
	}

	EnumData.pvContext = pMSD;
	EnumData.hCommand = NULL;

	*pCommandHandle = pMSD;

#ifdef DEBUG
	Lock(&pSPD->SPLock);
	pMSD->blSPLinkage.InsertBefore( &pSPD->blMessageList);		// Dont support timeouts for Listen
	pMSD->ulMsgFlags1 |= MFLAGS_ONE_ON_GLOBAL_LIST;
	Unlock(&pSPD->SPLock);
#endif

	pMSD->ulMsgFlags1 |= MFLAGS_ONE_IN_SERVICE_PROVIDER;
	LOCK_MSD(pMSD, "SP Ref");											// AddRef for SP
	LOCK_MSD(pMSD, "Temp Ref");

	DPFX(DPFPREP,DPF_CALLOUT_LVL, "Calling SP->EnumQuery, pSPD[%p], pMSD[%p]", pSPD, pMSD);
/**/hr = IDP8ServiceProvider_EnumQuery(pSPD->IISPIntf, &EnumData);		/** CALL SP **/

	if(hr != DPNERR_PENDING)
	{
		// This should always Pend or else be in error
		DPFX(DPFPREP,1, "Calling SP->EnumQuery Failed, return is not DPNERR_PENDING, hr[%x], pMSD[%p], pSPD[%p]", hr, pMSD, pSPD);

		Lock(&pMSD->CommandLock);
		pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_IN_SERVICE_PROVIDER);

#ifdef DEBUG
		Lock(&pSPD->SPLock);
		pMSD->blSPLinkage.RemoveFromList();					// knock this off the pending list
		pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_ON_GLOBAL_LIST);
		Unlock(&pSPD->SPLock);
#endif

		DECREMENT_MSD(pMSD, "Temp Ref");
		DECREMENT_MSD(pMSD, "SP Ref");				// release once for SP
		RELEASE_MSD(pMSD, "Release On Fail");		// release again to return resource

		return hr;
	}

	Lock(&pMSD->CommandLock);

	pMSD->hCommand = EnumData.hCommand;			// retain SP command handle
	pMSD->dwCommandDesc = EnumData.dwCommandDescriptor;

	RELEASE_MSD(pMSD, "Temp Ref"); // Unlocks CommandLock

	DPFX(DPFPREP,DPF_CALLIN_LVL, "Returning DPNERR_PENDING, pMSD[%p]", pMSD);
	return DPNERR_PENDING;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNPEnumRespond - respond to an enum query
//
// Entry:		Pointer to this interface
//				Handle of enum to respond to (pointer to SPIE_ENUMQUERY structure)
//				Pointer data buffers to send
//				Count of data buffers to send
//				Flags
//				User context for this operation
//				Pointer to command handle destination
//
// Exit:		Boolean inficating whether the GUID is a serial GUID
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNPEnumRespond"

HRESULT DNPEnumRespond( PProtocolData pPData,
					    const HANDLE hSPHandle,
						const HANDLE hQueryHandle,				// handle of enum query being responded to
						BUFFERDESC *const pResponseBuffers,	
						const DWORD dwResponseBufferCount,
						const DWORD dwFlags,
						void *const pUserContext,
						HANDLE *const pCommandHandle )
{
	PSPD				pSPD;
	PMSD				pMSD;
	SPENUMRESPONDDATA	EnumRespondData;
	HRESULT				hr;

	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: pPData[%p], hSPHandle[%x], hQueryHandle[%x], pResponseBuffers[%p], dwResponseBufferCount[%x], dwFlags[%x], pUserContext[%p], pCommandHandle[%p]", pPData, hSPHandle, hQueryHandle, pResponseBuffers, dwResponseBufferCount, dwFlags, pUserContext, pCommandHandle);
	EnumRespondData.pQuery = static_cast<SPIE_QUERY*>( hQueryHandle );
	DNASSERT( EnumRespondData.pQuery != NULL );

	pSPD = (PSPD) hSPHandle;
	ASSERT_SPD(pSPD);

	// Core should not call any Protocol APIs after calling DNPRemoveServiceProvider
	ASSERT(!(pSPD->ulSPFlags & SPFLAGS_TERMINATING));

	// We use an MSD to describe this Op even tho it
	if((pMSD = static_cast<PMSD>( MSDPool->Get(MSDPool) )) == NULL)
	{
		DPFX(DPFPREP,0, "Failed to allocate MSD");
		Unlock(&pSPD->SPLock);
		return DPNERR_OUTOFMEMORY;				// .. isnt technically a message
	}

	pMSD->CommandID = COMMAND_ID_ENUMRESP;
	pMSD->pSPD = pSPD;
	pMSD->Context = pUserContext;

	EnumRespondData.pBuffers = pResponseBuffers;
	EnumRespondData.dwBufferCount = dwResponseBufferCount;
	EnumRespondData.dwFlags = dwFlags;
	EnumRespondData.pvContext = pMSD;
	EnumRespondData.hCommand = NULL;

	*pCommandHandle = pMSD;

#ifdef DEBUG
	Lock(&pSPD->SPLock);
	pMSD->blSPLinkage.InsertBefore( &pSPD->blMessageList);
	pMSD->ulMsgFlags1 |= MFLAGS_ONE_ON_GLOBAL_LIST;
	Unlock(&pSPD->SPLock);
#endif

	pMSD->ulMsgFlags1 |= MFLAGS_ONE_IN_SERVICE_PROVIDER;
	LOCK_MSD(pMSD, "SP Ref");										// AddRef for SP
	LOCK_MSD(pMSD, "Temp Ref");

	DPFX(DPFPREP,DPF_CALLOUT_LVL, "Calling SP->EnumRespond, pSPD[%p], pMSD[%p]", pSPD, pMSD);
/**/hr = IDP8ServiceProvider_EnumRespond(pSPD->IISPIntf, &EnumRespondData);		/** CALL SP **/

	// This should always Pend or else be in error
	if(hr != DPNERR_PENDING)
	{
		DPFX(DPFPREP,1, "Calling SP->EnumRespond, return is not DPNERR_PENDING, hr[%x], pMSD[%p], pSPD[%p]", hr, pMSD, pSPD);

		Lock(&pMSD->CommandLock);
		pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_IN_SERVICE_PROVIDER);

#ifdef DEBUG
		Lock(&pSPD->SPLock);
		pMSD->blSPLinkage.RemoveFromList();					// knock this off the pending list
		pMSD->ulMsgFlags1 &= ~(MFLAGS_ONE_ON_GLOBAL_LIST);
		Unlock(&pSPD->SPLock);
#endif

		DECREMENT_MSD(pMSD, "Temp Ref");
		DECREMENT_MSD(pMSD, "SP Ref");				// release once for SP
		RELEASE_MSD(pMSD, "Release On Fail");		// release again to return resource

		return hr;
	}

	Lock(&pMSD->CommandLock);

	pMSD->hCommand = EnumRespondData.hCommand;				// retain SP command handle
	pMSD->dwCommandDesc = EnumRespondData.dwCommandDescriptor;

	RELEASE_MSD(pMSD, "Temp Ref"); // Unlocks CommandLock

	DPFX(DPFPREP,DPF_CALLIN_LVL, "Returning DPNERR_PENDING, pMSD[%p]", pMSD);
	return DPNERR_PENDING;
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\protocol\internal.h ===
/*
**		Direct Network Protocol
**
**		This file contains internal prototypes and global definitions.
*/

// Protocol Version History /////////////////////////////////////////////////////////////
//
//	1.0 - DPlay8 original
//	1.1 - Fix SACK frame bogus 2 bytes caused by bad packing (DPlay 8.1 beta period only)
//	1.2 - Revert to original sack behavior with packing fixed, ie same as DPlay 8.0 (shipped in DPlay 8.1)
/////////////////////////////////////////////////////////////////////////////////////////

//	Global Constants
#define		DNET_VERSION_NUMBER					0x00010002 // The current protocol version

#define		DELAYED_ACK_TIMEOUT				100			// Delay before sending dedicated ACK packet
#define		SHORT_DELAYED_ACK_TIMEOUT		20			// Delay before sending dedicated NACK packet
#define		DELAYED_SEND_TIMEOUT			40			// Delay before sending dedicated SEND_INFO packet

#define		CONNECT_DEFAULT_TIMEOUT			(200)		// At .1 we saw too many retries, users can set in SetCaps
#define		CONNECT_DEFAULT_RETRIES			14			// Users can set in SetCaps

#define		STANDARD_LONG_TIMEOUT_VALUE		30000
#define		DEFAULT_KEEPALIVE_INTERVAL		60000
#define		ENDPOINT_BACKGROUND_INTERVAL	STANDARD_LONG_TIMEOUT_VALUE		// this is really what its for...

#define DPF_TIMER_LVL			9 // The level at which to spew calls into the Protocol

#define DPF_CALLIN_LVL			2 // The level at which to spew calls into the Protocol
#define DPF_CALLOUT_LVL			3 // The level at which to spew calls out of the Protocol

#define DPF_ADAPTIVE_LVL		6 // The level at which to spew Adaptive Algorithm spew
#define DPF_FRAMECNT_LVL		7 // The level at which to spew Adaptive Algorithm spew

#define DPF_REFCNT_LVL			8 // The level at which to spew ref counts
#define DPF_REFCNT_FINAL_LVL	5 // The level at which to spew creation and destruction ref counts

// Separate ones for endpoints
#define DPF_EP_REFCNT_LVL		8 // The level at which to spew ref counts
#define DPF_EP_REFCNT_FINAL_LVL	2 // The level at which to spew creation and destruction ref counts

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_PROTOCOL

typedef	void CALLBACK LPCB(UINT, UINT, DWORD, DWORD, DWORD);

//	Global Variable definitions

extern LPFPOOL	ChkPtPool;
extern LPFPOOL	EPDPool;
extern LPFPOOL	MSDPool;
extern LPFPOOL	FMDPool;
extern LPFPOOL	RCDPool;
extern LPFPOOL	BufPool;
extern LPFPOOL	MedBufPool;
extern LPFPOOL	BigBufPool;

//	Internal function prototypes

VOID			AbortSendsOnConnection(PEPD);
ULONG WINAPI 	BackgroundThread(PVOID);
BOOL			Buf_Allocate(PVOID);
VOID			Buf_Get(PVOID);
VOID			Buf_GetMed(PVOID);
VOID			Buf_GetBig(PVOID);
HRESULT			DoCancel(PMSD, HRESULT);
VOID 			CompleteConnect(PMSD, PSPD, PEPD, HRESULT);
VOID			CompleteDisconnect(PMSD pMSD, PSPD pSPD, PEPD pEPD);
VOID 			CompleteDatagramSend(PSPD, PMSD, HRESULT);
VOID			CompleteReliableSend(PSPD, PMSD, HRESULT);
VOID			CompleteSPConnect(PMSD, PSPD, HRESULT);
VOID CALLBACK	ConnectRetryTimeout(PVOID, UINT, PVOID);
VOID CALLBACK	DelayedAckTimeout(PVOID, UINT, PVOID);
VOID			DisconnectConnection(PEPD);
VOID			DropLink(PEPD);
PMSD			BuildDisconnectFrame(PEPD);
VOID			EndPointDroppedFrame(PEPD, DWORD);
VOID CALLBACK	EndPointBackgroundProcess(PVOID, UINT, PVOID);
VOID			EnqueueMessage(PMSD, PEPD);
BOOL			EPD_Allocate(PVOID);
VOID			EPD_Free(PVOID);
VOID			EPD_Get(PVOID);
VOID			EPD_Release(PVOID);
VOID 			FlushCheckPoints(PEPD);
BOOL			FMD_Allocate(PVOID);
VOID			FMD_Free(PVOID);
VOID			FMD_Get(PVOID);
VOID			FMD_Release(PVOID);
VOID 			InitLinkParameters(PEPD, UINT, UINT, UINT, DWORD);
PCHKPT			LookupCheckPoint(PEPD, BYTE);
BOOL			MSD_Allocate(PVOID);
VOID			MSD_Free(PVOID);
VOID			MSD_Get(PVOID);
VOID			MSD_Release(PVOID);
PEPD			NewEndPoint(PSPD, HANDLE);
VOID			PerformCheckpoint(PEPD);
BOOL			RCD_Allocate(PVOID);
VOID			RCD_Free(PVOID);
VOID			RCD_Get(PVOID);
VOID			RCD_Release(PVOID);
VOID			ReceiveComplete(PEPD);
VOID CALLBACK	RetryTimeout(PVOID, UINT, PVOID);
VOID CALLBACK	ScheduledSend(PVOID, UINT, PVOID);
VOID			SendAckFrame(PEPD, BOOL, BOOL fFinalAck = FALSE);
HRESULT			SendCommandFrame(PEPD, BYTE, BYTE);
ULONG WINAPI 	SendThread(PVOID);
VOID			ServiceCmdTraffic(PSPD);
VOID			ServiceEPD(PSPD, PEPD);
VOID CALLBACK	TimeoutSend(PVOID, UINT, PVOID);
VOID 			UpdateEndPoint(PEPD, UINT, UINT, UINT, DWORD);
VOID			UpdateXmitState(PEPD, BYTE, ULONG, ULONG, DWORD);
VOID			RejectInvalidPacket(PEPD, BOOL);

//	Internal Macro definitions

#define	ASSERT(EXP)		DNASSERT(EXP)

#define	Lock(P)			DNEnterCriticalSection(P)
#define	Unlock(P)		DNLeaveCriticalSection(P)

#define	ASSERT_SPD(PTR)	ASSERT((PTR) != NULL); ASSERT((PTR)->Sign == SPD_SIGN)
#define	ASSERT_EPD(PTR)	ASSERT((PTR) != NULL); ASSERT((PTR)->Sign == EPD_SIGN)
#define	ASSERT_MSD(PTR)	ASSERT((PTR) != NULL); ASSERT((PTR)->Sign == MSD_SIGN)
#define	ASSERT_FMD(PTR)	ASSERT((PTR) != NULL); ASSERT((PTR)->Sign == FMD_SIGN)
#define	ASSERT_RCD(PTR)	ASSERT((PTR) != NULL); ASSERT((PTR)->Sign == RCD_SIGN)

#define	INTER_INC(PTR)	InterlockedIncrement(&(PTR)->lRefCnt)
#define	INTER_DEC(PTR)	InterlockedDecrement(&(PTR)->lRefCnt)

#ifdef DEBUG

BOOL	LockEPD(PEPD, PCHAR);
VOID	ReleaseEPD(PEPD, PCHAR);
VOID	DecrementEPD(PEPD, PCHAR);
VOID	LockMSD(PMSD, PCHAR);
VOID	ReleaseMSD(PMSD, PCHAR);
VOID	DecrementMSD(PMSD, PCHAR);
VOID	ReleaseFMD(PFMD, PCHAR);
VOID	LockFMD(PFMD, PCHAR);

#define	LOCK_EPD(a, b)				LockEPD(a, b)
#define	RELEASE_EPD(a, b)			ReleaseEPD(a, b)
#define	DECREMENT_EPD(a, b)			DecrementEPD(a, b)
#define	LOCK_MSD(a, b)				LockMSD(a, b)
#define  RELEASE_MSD(a, b)			ReleaseMSD(a, b)
#define  DECREMENT_MSD(a, b)			DecrementMSD(a, b)
#define	RELEASE_FMD(a, b)			ReleaseFMD(a, b)
#define	LOCK_FMD(a, b)				LockFMD(a, b)

#else // !DEBUG

BOOL	LockEPD(PEPD);
VOID	ReleaseEPD(PEPD);
VOID	DecrementEPD(PEPD);
VOID	LockMSD(PMSD);
VOID	ReleaseMSD(PMSD);
VOID	DecrementMSD(PMSD);
VOID	ReleaseFMD(PFMD);
VOID	LockFMD(PFMD);

#define	LOCK_EPD(a, b)				LockEPD(a)
#define	RELEASE_EPD(a, b)			ReleaseEPD(a)
#define	DECREMENT_EPD(a, b)			DecrementEPD(a)
#define	LOCK_MSD(a, b)				LockMSD(a)
#define  RELEASE_MSD(a, b)			ReleaseMSD(a)
#define  DECREMENT_MSD(a, b)			DecrementMSD(a)
#define	RELEASE_FMD(a, b)			ReleaseFMD(a)
#define	LOCK_FMD(a, b)				LockFMD(a)

#endif // DEBUG

#define	LOCK_RCD(PTR)		(INTER_INC(PTR))
#define	RELEASE_RCD(PTR)	ASSERT((PTR)->lRefCnt > 0); if( INTER_DEC(PTR) == 0) { RCDPool->Release(RCDPool, (PTR)); }

// This links the passed in pRcvBuff onto a local variable of the same name, and NULLs the passed in one.
#define		RELEASE_SP_BUFFER(PTR)	if((PTR) != NULL) { (PTR)->pNext = pRcvBuff; pRcvBuff = (PTR); (PTR) = NULL;}

#ifndef	CONTAINING_RECORD
#define CONTAINING_RECORD(address, type, field) ((type *)( \
                                                  (PCHAR)(address) - \
                                                  (UINT_PTR)(&((type *)0)->field)))
#endif

#define	RIGHT_SHIFT_64(HIGH_MASK, LOW_MASK) { ((LOW_MASK) >>= 1); if((HIGH_MASK) & 1){ (LOW_MASK) |= 0x80000000; } ((HIGH_MASK) >>= 1); }

#define	MAX(A, B)		( (A) > (B) ?  (A) : (B) )
#define	MIN(A, B)		( (A) < (B) ?  (A) : (B) )
#define	ABS(A)			( (A) < 0 ? -(A) : (A) )

//	CONVERT TO AND FROM 16.16 FIXED POINT REPRESENTATION

#define	TO_FP(X)		((X) << 16)
#define	FP_INT(X)		((X) >> 16)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\protocol\lower_mn.cpp ===
#include "dnproti.h"


//	Now, a little bit of probably unnecesary junk for our lower edge

/*
 * DNP_QueryInterface
 */
#undef DPF_MODNAME
#define DPF_MODNAME "DNSP_QueryInterface"

STDMETHODIMP DNSP_QueryInterface(
				IDP8SPCallback	*pDNPI,
                REFIID riid,
                LPVOID *ppvObj )
{
	HRESULT hr;
    *ppvObj = NULL;

    if( IsEqualIID(riid, IID_IDP8SPCallback) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = pDNPI;
		hr = S_OK;
    }
    else
    {
		hr = E_NOINTERFACE;
    }

	return hr;
}

/*
 * DNP_AddRef
 */
#undef DPF_MODNAME
#define DPF_MODNAME "DNSP_AddRef"

STDMETHODIMP_(ULONG) DNSP_AddRef( IDP8SPCallback *pDNPI)
{
    return 1;
}

/*
 * DNP_Release
 */
#undef DPF_MODNAME
#define DPF_MODNAME "DNSP_Release"

STDMETHODIMP_(ULONG) DNSP_Release( IDP8SPCallback *pDNPI )
{
	return 1;
}

IDP8SPCallbackVtbl DNPLowerEdgeVtbl =
{
        DNSP_QueryInterface,
        DNSP_AddRef,
        DNSP_Release,
		DNSP_IndicateEvent,
		DNSP_CommandComplete
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\protocol\frames.h ===
/*===
		Direct Network Protocl   --   Frame format header file


		Evan Schrier	10/98

*/



/*	
		Direct Network Protocol

| MEDIA HEADER | Var Len DN Header | Client Data |

There are two types of packets that may be exchanged between Direct Network
endpoints:

	Data Packets				(D Frame)	User data transmission
	Control Packets				(C Frame)	Internal link-state packets with no user data



*/

/*
	COMMAND FIELD

		The command field is the first byte of all frames.  The first BIT of the command frame is always
	the COMMAND FRAME vs DATA FRAME opcode.  The seven high bits of the Command field are flags.  We have
	a requirement that the command field of all protocol packets must never be all zeros.  Therefore,  when
	the opcode bit is zero (COMMAND FRAME) we must be sure that one flag bit is always set.  The highest flag bit,
	the USER2 flag is not relevant to COMMAND frames so we will always set the most significant bit when the opcode
	bit is zero.

		The seven command field flag bits are defined as follows:

	RELIABLE	-	Data delivery of this frame is guarenteed
	SEQUENTIAL	-	Data in this frame must be delivered in the order it was sent, with respect to other SEQ frames
	POLL		-	Protocol requests an immediate acknowledgement to this frame
	NEW MESSAGE	-	This frame is the first or only frame in a message
	END MESSAGE -	This frame is the last or only frame in a message
	USER1		-	First flag controlled by the higher layer (direct play core)
	USER2		-	Second flag controlled by core.  These flags are specified in the send API and are delivered with the data


	DATA FRAMES

		Data frames are between 4 and 20 bytes in length.  They should typically be only 4 bytes.  Following the
	Command byte in all data frames in the Control byte.  This byte contains a 3-bit retry counter and 5 additional
	flags.  The Control byte flags are defined as follows:

	END OF STREAM	-	This frame is the last data frame the transmitting partner will send.
	SACK_MASK_ONE	-	The low 32-bit Selective Acknowledgment mask is present in this header
	SACK_MASK_TWO	-	The high 32-bit Selective Acknowledgment mask is present in this header
	SEND_MASK_ONE	-	The low 32-bit Cancel Send mask is present in this header
	SEND_MASK_TWO	-	The high 32-bit Cancel Send mask is present in this header

		After Control byte come two one byte values:  Sequence number for this frame, and Next Receive sequence number
	expected by this partner.  After these two bytes comes zero through four bitmasks as specified by the control flags.
	After the bitmasks,  the rest of the frame is user data to be delivered to the direct play core.
*/
#ifndef	_DNET_FRAMES_
#define	_DNET_FRAMES_

/*
	Command FRAME Extended Opcodes

	A CFrame without an opcode is a vehicle for non-piggybacked acknowledgement
	information.  The following sub-commands are defined at this time:

	SACK			- Only Ack/Nack info present
	CONNECT 		- Initialize a reliable connection
	CONNECTED		- Response to CONNECT request, or CONNECTED depending on which side of the handshake
*/

#define		FRAME_EXOPCODE_CONNECT			1
#define		FRAME_EXOPCODE_CONNECTED		2
#define		FRAME_EXOPCODE_DISCONNECTED		4 // Used in DP8, but not anymore
#define		FRAME_EXOPCODE_SACK				6

// These structures are used to decode network data and so need to be packed

#pragma pack(push, 1)

typedef UNALIGNED struct packetheader		PacketHeader, *PPacketHeader;
typedef UNALIGNED struct dataframe			DFRAME, *PDFRAME;
typedef UNALIGNED struct cframe				CFRAME, *PCFRAME;
typedef UNALIGNED struct sackframe8			SACKFRAME8, *PSACKFRAME8;
typedef UNALIGNED struct sackframe_big8		SFBIG8, *PSFBIG8;

typedef	UNALIGNED struct dataframe_masks	DFMASKS, *PDFMASKS;
typedef	UNALIGNED struct dataframe_big		DFBIG, *PDFBIG;

//	Packet Header is common to all frame formats

#define	PACKET_COMMAND_DATA			0x01		// Frame contains user data
#define	PACKET_COMMAND_RELIABLE		0x02		// Frame should be delivered reliably
#define	PACKET_COMMAND_SEQUENTIAL	0x04		// Frame should be indicated sequentially
#define	PACKET_COMMAND_POLL			0x08		// Partner should acknowlege immediately
#define	PACKET_COMMAND_NEW_MSG		0x10		// Data frame is first in message
#define	PACKET_COMMAND_END_MSG		0x20		// Data frame is last in message
#define	PACKET_COMMAND_USER_1		0x40		// First user controlled flag
#define	PACKET_COMMAND_USER_2		0x80		// Second user controlled flag
#define	PACKET_COMMAND_CFRAME		0x80		// Set high-bit on command frames because first byte must never be zero

#define	PACKET_CONTROL_RETRY		0x01		// This flag designates this frame as a retry of a previously xmitted frame
#define	PACKET_CONTROL_CORRELATE	0x02		// Respond to this frame with a dedicated reply
#define	PACKET_CONTROL_RESPONSE		0x04		// THIS IS NOT CURRENTLY IMPLEMENTED - CORR RESPONSES WILL USE DEDICATED FRAMES
#define	PACKET_CONTROL_END_STREAM	0x08		// This packet serves as Disconnect frame.
#define	PACKET_CONTROL_SACK_MASK1	0x10		// The low 32-bit SACK mask is included in this frame.
#define	PACKET_CONTROL_SACK_MASK2	0x20		// The high 32 bit SACK mask is present
#define	PACKET_CONTROL_SEND_MASK1	0x40		// The low 32-bit SEND mask is included in this frame
#define	PACKET_CONTROL_SEND_MASK2	0x80		// The high 32-bit SEND mask is included in this frame

#define	PACKET_CONTROL_VARIABLE_MASKS	0xF0	// All four mask bits above

struct	packetheader 
{
	BYTE		bCommand;
};

/*		NEW DATA FRAMES
**
**		Here in the new unified world we have only two frame types!  CommandFrames and DataFrames...
**
*/

struct	dataframe 
{
	BYTE	bCommand;
	BYTE	bControl;
	BYTE	bSeq;
	BYTE	bNRcv;
};

//	Following the 4 byte dataframe header will be between zero and four 32-bit masks,  as defined by the CONTROL flags,
// representing either Specific Acks (SACK) or unreliable dropped sends (SEND MASK).

struct	dataframe_masks 
{
	ULONG	rgMask[1];			// Zero to four 32-bit masks of either SACK info or SEND info
};

struct dataframe_big 
{
	BYTE	bCommand;
	BYTE	bControl;
	BYTE	bSeq;
	BYTE	bNRcv;
	ULONG	rgMask[4];
};

/*	
**		COMMAND FRAMES
**
**		Command frames are everything that is not part of the reliable stream.  This is most of the control traffic
**	although some control traffic is part of the stream (keep-alive, End-of-Stream)
*/

struct	cframe 
{
	BYTE	bCommand;
	BYTE	bExtOpcode;				// CFrame sub-command
	BYTE	bMsgID;					// Correlator in case ExtOpcode requires a response
	BYTE	bRspID;					// Correlator in case this is a response
	DWORD	dwVersion;				// Protocol version #
	DWORD	dwSessID;				// Session identifier
	DWORD	tTimestamp;				// local tick count
};

/*	
**	Selective Acknowledgement packet format
**
**		When a specific acknowledgement frame is sent there may be two additional pieces
**	of data included with the frame.  One is a bitmask allowing selective acknowledgment
**	of non-sequential frames.  The other is timing information about the last frame acked
**  by this ACK (NRcv - 1).  Specifically,  it includes the lowest Retry number that this
**  node received,  and the ms delay between that packets arrival and the sending of this
**	Ack.
*/


#define		SACK_FLAGS_RESPONSE			0x01	// indicates that Retry and Timestamp fields are valid
#define		SACK_FLAGS_SACK_MASK1		0x02
#define		SACK_FLAGS_SACK_MASK2		0x04
#define		SACK_FLAGS_SEND_MASK1		0x08
#define		SACK_FLAGS_SEND_MASK2		0x10

//	First format is used when DATAGRAM_INFO flag is clear

struct	sackframe8 
{	
	BYTE		bCommand;				// As above
	BYTE		bExtOpcode;				// As above
	BYTE		bFlags;					// Additional flags for sack frame
	BYTE		bRetry;
	BYTE		bNSeq;					// Since this frame has no sequence number, this is the next Seq we will send
	BYTE		bNRcv;					// As above
	BYTE		bReserved1;				// We shipped DX8 with bad packing, so these were actually there
	BYTE		bReserved2;				// We shipped DX8 with bad packing, so these were actually there
	DWORD		tTimestamp;				// Local timestamp when packet (NRcv - 1) arrived
};

struct sackframe_big8
{
	BYTE		bCommand;				// As above
	BYTE		bExtOpcode;				// As above
	BYTE		bFlags;					// Additional flags for sack frame
	BYTE		bRetry;
	BYTE		bNSeq;					// Since this frame has no sequence number, this is the next Seq we
	BYTE		bNRcv;					// As above
	BYTE		bReserved1;				// We shipped DX8 with bad packing, so these were actually there
	BYTE		bReserved2;				// We shipped DX8 with bad packing, so these were actually there
	DWORD		tTimestamp;				// Local stamp when packet arrived
	ULONG		rgMask[4];
};

#pragma pack(pop)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\protocol\mytimer.h ===
/*++

Copyright (c) 1996,1997  Microsoft Corporation

Module Name:

    MYTIMER.H

Abstract:

	Include For
	Handle adjusting timer resolution for throttling and do thread pool

Author:

	Aaron Ogus (aarono)

Environment:

	Win32

Revision History:

	Date   Author  Description
   ======  ======  ============================================================
   6/04/98 aarono  Original

--*/

typedef void CALLBACK MYTIMERCALLBACK (PVOID uID, UINT uMsg, PVOID dwUser);

typedef enum _TimerState {
	NotInUse,
	WaitingForTimeout,
	QueuedForThread,
	InCallBack,
	End
} eTimerState;

typedef struct _MyTimer {
	CBilink	Bilink;
	eTimerState TimerState;
	DWORD	TimeOut;
	PVOID   Context;
	MYTIMERCALLBACK *CallBack;
	DWORD   Unique;
} MYTIMER, *PMYTIMER;

VOID 	SetMyTimer(DWORD dwTimeOut, DWORD TimerRes, MYTIMERCALLBACK TimerCallBack, PVOID UserContext, PVOID *pHandle, PUINT pUnique);
HRESULT InitTimerWorkaround(); // Instance level initialization
VOID 	FiniTimerWorkaround();
HRESULT CancelMyTimer(PVOID pTimer, DWORD Unique);
VOID	ScheduleTimerThread(MYTIMERCALLBACK, PVOID, PVOID *, PUINT);
HRESULT TimerInit();	// Module level initialization
VOID	TimerDeinit();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\protocol\initialize.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		Initialize.cpp
 *  Content:	This file contains code to both initialize and shutdown the
 *				protocol,  as well as to Add and Remove service providers
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  11/06/98	ejs		Created
 *  07/01/2000  masonb  Assumed Ownership
 *
 ****************************************************************************/

#include "dnproti.h"


/*
**		GLOBAL VARIABLES
**
**			There are two kinds of global variables.  Instance specific globals
**	(not really global,  i know) which are members of the ProtocolData structure,
**	and true globals which are shared among all instances.  The following
**	definitions are true globals,  such as FixedPools and Timers.
*/

LPFPOOL			ChkPtPool = NULL;	// Pool of CheckPoint data structure
LPFPOOL			EPDPool = NULL;		// Pool of End Point descriptors
LPFPOOL			MSDPool = NULL;		// Pool of Message Descriptors
LPFPOOL			FMDPool = NULL;		// Pool of Frame Descriptors
LPFPOOL			RCDPool = NULL;		// Pool of Receive Descriptors

LPFPOOL			BufPool = NULL;		// Pool of buffers to store rcvd frames
LPFPOOL			MedBufPool = NULL;
LPFPOOL			BigBufPool = NULL;

LONG			g_lProtocolObjects = 0;
DNCRITICAL_SECTION g_csProtocolGlobal;

BOOL			g_fTimerInited = FALSE;

/*
**		Pools Initialization
**
**		This procedure should be called once at Dll load
*/
#undef DPF_MODNAME
#define DPF_MODNAME "DNPPoolsInit"

BOOL  DNPPoolsInit()
{
	DPFX(DPFPREP,DPF_CALLIN_LVL, "Enter");

	if (DNInitializeCriticalSection(&g_csProtocolGlobal) == FALSE)
	{
		return FALSE;
	}
	if((ChkPtPool = FPM_Create(sizeof(CHKPT), NULL, NULL, NULL, NULL)) == NULL)
	{
		DNPPoolsDeinit();
		return FALSE;
	}
	if((EPDPool = FPM_Create(sizeof(EPD), EPD_Allocate, EPD_Get, EPD_Release, EPD_Free)) == NULL)
	{
		DNPPoolsDeinit();
		return FALSE;
	}
	if((MSDPool = FPM_Create(sizeof(MSD), MSD_Allocate, MSD_Get, MSD_Release, MSD_Free)) == NULL)
	{
		DNPPoolsDeinit();
		return FALSE;
	}
	if((FMDPool = FPM_Create(sizeof(FMD), FMD_Allocate, FMD_Get, FMD_Release, FMD_Free)) == NULL)
	{
		DNPPoolsDeinit();
		return FALSE;
	}
	if((RCDPool = FPM_Create(sizeof(RCD), RCD_Allocate, RCD_Get, RCD_Release, RCD_Free)) == NULL)
	{
		DNPPoolsDeinit();
		return FALSE;
	}
	if((BufPool = FPM_Create(sizeof(BUF), Buf_Allocate, Buf_Get, NULL, NULL)) == NULL)
	{
		DNPPoolsDeinit();
		return FALSE;
	}
	if((MedBufPool = FPM_Create(sizeof(MEDBUF), Buf_Allocate, Buf_GetMed, NULL, NULL)) == NULL)
	{
		DNPPoolsDeinit();
		return FALSE;
	}
	if((BigBufPool = FPM_Create(sizeof(BIGBUF), Buf_Allocate, Buf_GetBig, NULL, NULL)) == NULL)
	{
		DNPPoolsDeinit();
		return FALSE;
	}
	if (FAILED(TimerInit()))
	{
		DNPPoolsDeinit();
		return FALSE;
	}
	g_fTimerInited = TRUE;

    return TRUE;
}

/*
**		Pools Deinitialization
**
**		This procedure should be called by DllMain at shutdown time
*/
#undef DPF_MODNAME
#define DPF_MODNAME "DNPPoolsDeinit"

void  DNPPoolsDeinit()
{
	DPFX(DPFPREP,DPF_CALLIN_LVL, "Enter");

	if (g_fTimerInited)
	{
		TimerDeinit();
		g_fTimerInited = FALSE;
	}

	DNDeleteCriticalSection(&g_csProtocolGlobal);

	if(ChkPtPool != NULL)
	{
		ChkPtPool->Fini(ChkPtPool);
		ChkPtPool = NULL;
	}
	if(EPDPool != NULL)
	{
		EPDPool->Fini(EPDPool);
		EPDPool = NULL;
	}
	if(MSDPool != NULL)
	{
		MSDPool->Fini(MSDPool);
		MSDPool = NULL;
	}
	if(FMDPool != NULL){
		FMDPool->Fini(FMDPool);
		FMDPool = NULL;
	}
	if(RCDPool != NULL)
	{
		RCDPool->Fini(RCDPool);
		RCDPool = NULL;
	}
	if(BufPool != NULL)
	{
		BufPool->Fini(BufPool);
		BufPool = NULL;
	}
	if(MedBufPool != NULL)
	{
		MedBufPool->Fini(MedBufPool);
		MedBufPool = NULL;
	}
	if(BigBufPool != NULL)
	{
		BigBufPool->Fini(BigBufPool);
		BigBufPool = NULL;
	}
}


/*
**		Protocol Initialize
**
**		This procedure should be called by DirectPlay at startup time before
**	any other calls in the protocol are made.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "DNPProtocolInitialize"

HRESULT DNPProtocolInitialize(PVOID pCoreContext, PProtocolData pPData, PDN_PROTOCOL_INTERFACE_VTBL pVtbl)
{
	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: pCoreContext[%p], pPData[%p], pVtbl[%p]", pCoreContext, pPData, pVtbl);

//	DPFX(DPFPREP,0, "Sizes: endpointdesc[%d], framedesc[%d], messagedesc[%d], protocoldata[%d], recvdesc[%d], spdesc[%d], _MyTimer[%d]", sizeof(endpointdesc), sizeof(framedesc), sizeof(messagedesc), sizeof(protocoldata), sizeof(recvdesc), sizeof(spdesc), sizeof(_MyTimer));

	DNEnterCriticalSection(&g_csProtocolGlobal);
	g_lProtocolObjects++;
	if (g_lProtocolObjects == 1)
	{
		// We are the first, create everything
		DPFX(DPFPREP,5, "Initializing timers");
		if (FAILED(InitTimerWorkaround()))
		{
			DPFX(DPFPREP,0, "Protocol timer package failed to initialize");
			g_lProtocolObjects--;
			DNLeaveCriticalSection(&g_csProtocolGlobal);
			return DPNERR_GENERIC;
		}
	}
	DNLeaveCriticalSection(&g_csProtocolGlobal);

	pPData->ulProtocolFlags = 0;
	pPData->Parent = pCoreContext;
	pPData->pfVtbl = pVtbl;
	pPData->Sign = PD_SIGN;

	pPData->lSPActiveCount = 0;
	
	srand(GETTIMESTAMP());
	pPData->dwNextSessID = rand() | (rand() << 16);			// build a 32 bit value out of two 16 bit values

	pPData->tIdleThreshhold = DEFAULT_KEEPALIVE_INTERVAL;	// 60 second keep-alive interval
	pPData->dwConnectTimeout = CONNECT_DEFAULT_TIMEOUT;
	pPData->dwConnectRetries = CONNECT_DEFAULT_RETRIES;

#ifdef DEBUG
	pPData->ThreadsInReceive = 0;
	pPData->BuffersInReceive = 0;
#endif
	
	pPData->ulProtocolFlags |= PFLAGS_PROTOCOL_INITIALIZED;

	return DPN_OK;
}

/*
**		Protocol Shutdown
**
**		This procedure should be called at termination time,  and should be the
**	last call made to the protocol.
**
**		All SPs should have been removed prior to this call which in turn means
**	that we should not have any sends pending in a lower layer.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "DNPProtocolShutdown"

HRESULT DNPProtocolShutdown(PProtocolData pPData)
{
	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: pPData[%p]", pPData);

	DNEnterCriticalSection(&g_csProtocolGlobal);
	g_lProtocolObjects--;
	if (g_lProtocolObjects == 0)
	{
		// We are the last, destroy everything
		DPFX(DPFPREP,5, "Destroying timers");
		FiniTimerWorkaround();
	}
	DNLeaveCriticalSection(&g_csProtocolGlobal);
	
	if(pPData->lSPActiveCount != 0)
	{
		DPFX(DPFPREP,0, "Returning DPNERR_INVALIDCOMMAND - There are still active SPs, DNPRemoveSP wasn't called");
		return DPNERR_INVALIDCOMMAND;					// Must remove Service Providers first
	}

#ifdef DEBUG
	if (pPData->BuffersInReceive != 0)
	{
		DPFX(DPFPREP,0, "*** %d receive buffers were leaked", pPData->BuffersInReceive);	
	}
#endif

	pPData->ulProtocolFlags = 0;

	return	DPN_OK;
}

/*
**		Add Service Provider
**
**		This procedure is called by Direct Play to bind us to a service provider.
**	We can bind up to 256 service providers at one time,  although I would not ever
**	expect to do so.  This procedure will fail if Protocol Initialize has not
**	been called.
**
**
**		We check the size of the SP table to make sure we have a slot free.  If table
**	is full we double the table size until we reach maximum size.  If table cannot grow
**	then we fail the AddServiceProvider call.
*/

extern	IDP8SPCallbackVtbl DNPLowerEdgeVtbl;

#undef DPF_MODNAME
#define DPF_MODNAME "DNPAddServiceProvider"

HRESULT DNPAddServiceProvider(PProtocolData pPData, IDP8ServiceProvider *pISP, HANDLE *pContext)
{
	PSPD		pSPD=0;
	SPINITIALIZEDATA	SPInitData;
	SPGETCAPSDATA		SPCapsData;
	HRESULT		hr;

	*pContext = NULL;

	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: pPData[%p], pISP[%p], pContext[%p]", pPData, pISP, pContext);

	if(pPData->ulProtocolFlags & PFLAGS_PROTOCOL_INITIALIZED)
	{
		if ((pSPD = (PSPD)DNMalloc(sizeof(SPD))) == NULL)
		{
			DPFX(DPFPREP,0, "Returning DPNERR_OUTOFMEMORY - couldn't allocate SP Descriptor");
			return DPNERR_OUTOFMEMORY;
		}

		// MAKE THE INITIALIZE CALL TO THE Service Provider...  give him our Object

		memset(pSPD, 0, sizeof(SPD));				// init to zero

		pSPD->LowerEdgeVtable = &DNPLowerEdgeVtbl;	// Put Vtbl into the interface Object
		pSPD->Sign = SPD_SIGN;

		SPInitData.pIDP = (IDP8SPCallback *) pSPD;
		SPInitData.dwFlags = 0;

		if (DNInitializeCriticalSection(&pSPD->SPLock) == FALSE)
		{
			DPFX(DPFPREP,0, "Returning DPNERR_OUTOFMEMORY - couldn't initialize SP CS, pSPD[%p]", pSPD);
			DNFree(pSPD);
			return DPNERR_OUTOFMEMORY;
		}
		DebugSetCriticalSectionRecursionCount(&pSPD->SPLock, 0);

		DPFX(DPFPREP,DPF_CALLOUT_LVL, "Calling SP->Initialize, pSPD[%p]", pSPD);
		if((hr = IDP8ServiceProvider_Initialize(pISP, &SPInitData)) != DPN_OK)
		{
			DPFX(DPFPREP,0, "Returning hr=%x - SP->Initialize failed, pSPD[%p]", hr, pSPD);
			DNDeleteCriticalSection(&pSPD->SPLock);
			DNFree(pSPD);
			return hr;
		}

		pSPD->blSendQueue.Initialize();
		pSPD->blPendingQueue.Initialize();
		pSPD->blEPDActiveList.Initialize();
#ifdef DEBUG
		pSPD->blMessageList.Initialize();
#endif
		

		// MAKE THE SP GET CAPS CALL TO FIND FRAMESIZE AND LINKSPEED

		SPCapsData.dwSize = sizeof(SPCapsData);
		SPCapsData.hEndpoint = INVALID_HANDLE_VALUE;
		
		DPFX(DPFPREP,DPF_CALLOUT_LVL, "Calling SP->GetCaps, pSPD[%p]", pSPD);
		if((hr = IDP8ServiceProvider_GetCaps(pISP, &SPCapsData)) != DPN_OK)
		{
			DPFX(DPFPREP,DPF_CALLOUT_LVL, "SP->GetCaps failed - hr[%x], Calling SP->Close, pSPD[%p]", hr, pSPD);
			IDP8ServiceProvider_Close(pISP);
			DNDeleteCriticalSection(&pSPD->SPLock);

			DPFX(DPFPREP,0, "Returning hr=%x - SP->GetCaps failed, pSPD[%p]", hr, pSPD);

			DNFree(pSPD);
			return hr;
		}

		pSPD->uiLinkSpeed = SPCapsData.dwLocalLinkSpeed;
		pSPD->uiFrameLength = SPCapsData.dwUserFrameSize;
		pSPD->uiUserFrameLength = pSPD->uiFrameLength - DNP_MAX_HEADER_SIZE;

		//	Place new SP in table

		DPFX(DPFPREP,DPF_CALLOUT_LVL, "Calling SP->AddRef, pSPD[%p]", pSPD);
		IDP8ServiceProvider_AddRef(pISP);
		pSPD->IISPIntf = pISP;
		pSPD->pPData = pPData;
		InterlockedIncrement(&pPData->lSPActiveCount);
	}
	else
	{
		DPFX(DPFPREP,0, "Returning DPNERR_UNINITIALIZED - DNPProtocolInitialize has not been called");
		return DPNERR_UNINITIALIZED;
	}

	*pContext = pSPD;

	return DPN_OK;
}

/*
**		Remove Service Provider
**
**			It is higher layer's responsibility to make sure that there are no pending commands
**		when this function is called,  although we can do a certain amount of cleanup ourselves.
**		For the moment will we ASSERT that everything is in fact finished up.
**
**			SPTable stuff...  Since we use the table slot as the SP identiier,  we must not compact
**		the SP table upon removal.  Therefore,  we must have a way of validating the SP index,  and
**		we may not want to re-use table slots after an SP is removed.  Since we have virtually
**		unlimited space in the table,  and SPs are generally not intended to be transitory,  its
**		probably safe to invalidate the old table slot and just keep increasing the IDs.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "DNPRemoveServiceProvider"

HRESULT DNPRemoveServiceProvider(PProtocolData pPData,  HANDLE hSPHandle)
{
	PSPD	pSPD = NULL;
	PEPD	pEPD;
	PMSD	pMSD;
	PFMD	pFMD;

	pSPD = (PSPD) hSPHandle;

	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: pPData[%p], hSPHandle[%x]", pPData, hSPHandle);
	
	if(pSPD == NULL)
	{
		DPFX(DPFPREP,0, "Returning DPNERR_INVALIDOBJECT - SP Handle is NULL");
		return DPNERR_INVALIDOBJECT;
	}

	// There are several steps to shutdown:
	// 1. All Core initiated commands must be cancelled prior to this function being called.
	//    We will assert in debug that the Core has done this.
	// 2. All endpoints must be terminated by the Core prior to this function being called.
	//    We will assert in debug that the Core has done this.
	// Now there are things on the SPD->SendQueue and SPD->PendingQueue that are not owned
	// by any Command or Endpoint, and there may also be a SendThread Timer running held
	// on SPD->SendHandle.  No one else can clean these up, so these are our responsibility
	// to clean up here.  Items on the queues will be holding references to EPDs, so the 
	// EPDs will not be able to go away until we do this.
	// 3. Cancel SPD->SendHandle Send Timer.  This prevents items on the SendQueue from
	//    being submitted to the SP and moved to the PendingQueue.
	// 4. Empty the SendQueue.
	// 5. If we fail to cancel the SendHandle Send Timer, wait for it to run and figure out
	//    that we are going away.  We do this after emptying the SendQueue for simplicity
	//    since the RunSendThread code checks for an empty SendQueue to know if it has work
	//    to do.
	// 6. Wait for all messages to drain from the PendingQueue as the SP completes them.
	// 7. Wait for any active EPDs to go away.
	// 8. Call SP->Close only after all of the above so that we can ensure that we will make
	//    no calls to the SP after Close.

	Lock(&pSPD->SPLock);
	pSPD->ulSPFlags |= SPFLAGS_TERMINATING;				// Nothing new gets in...

#ifdef DEBUG

	// Check for uncancelled commands, SPLock held
	CBilink* pLink = pSPD->blMessageList.GetNext();
	while (pLink != &pSPD->blMessageList)
	{
		pMSD = CONTAINING_RECORD(pLink, MSD, blSPLinkage);
		ASSERT_MSD(pMSD);
		ASSERT(pMSD->ulMsgFlags1 & MFLAGS_ONE_ON_GLOBAL_LIST);
		DPFX(DPFPREP,0, "There are un-cancelled commands remaining on the Command List, Core didn't clean up properly - pMSD[%p], Context[%x]", pMSD, pMSD->Context);
		ASSERT(0); // This is fatal, we can't make the guarantees we need to below under these conditions.

		pLink = pLink->GetNext();
	}

	// Check for EPDs that have not been terminated, SPLock still held
	pLink = pSPD->blEPDActiveList.GetNext();
	while (pLink != &pSPD->blEPDActiveList)
	{
		pEPD = CONTAINING_RECORD(pLink, EPD, blActiveLinkage);
		ASSERT_EPD(pEPD);

		if (!(pEPD->ulEPFlags & EPFLAGS_STATE_TERMINATING))
		{
			DPFX(DPFPREP,0, "There are non-terminated endpoints remaining on the Endpoint List, Core didn't clean up properly - pEPD[%p], Context[%x]", pEPD, pEPD->Context);
			ASSERT(0); // This is fatal, we can't make the guarantees we need to below under these conditions.
		}

		pLink = pLink->GetNext();
	}

#endif

	// See if we still have a Send Event pending, SPLock still held
	if(pSPD->SendHandle != NULL)
	{
		DPFX(DPFPREP,1, "Shutting down with send event still pending, cancelling, pSPD=[%p]", pSPD);
		
		if(CancelMyTimer(pSPD->SendHandle, pSPD->SendHandleUnique) == DPN_OK)
		{
			pSPD->SendHandle = NULL;
			pSPD->ulSPFlags &= ~(SPFLAGS_SEND_THREAD_SCHEDULED);
		}
		else 
		{
			DPFX(DPFPREP,1, "Failed to cancel send event", pSPD);
		}
	}

	// Clean off the Send Queue, SPLock still held
	while(!pSPD->blSendQueue.IsEmpty())
	{
		pFMD = CONTAINING_RECORD(pSPD->blSendQueue.GetNext(), FMD, blQLinkage);
		ASSERT_FMD(pFMD);

		ASSERT_EPD(pFMD->pEPD);

		DPFX(DPFPREP,1, "Cleaning FMD off of SendQueue pSPD[%p], pFMD[%p], pEPD[%p]", pSPD, pFMD, pFMD->pEPD);

		pFMD->blQLinkage.RemoveFromList();

		// RELEASE_EPD will need to have the EPD lock, so we cannot hold the SPLock while calling it.
		Unlock(&pSPD->SPLock);

		Lock(&pFMD->pEPD->EPLock);
		RELEASE_EPD(pFMD->pEPD, "UNLOCK (Releasing Leftover CMD FMD)"); // releases EPLock
		RELEASE_FMD(pFMD, "SP Submit");

		Lock(&pSPD->SPLock);
	}

	// In case we failed to cancel the SendHandle Timer above, wait for the send thread to run and figure
	// out that we are going away.  We want to be outside the SPLock while doing this.
	while(pSPD->ulSPFlags & SPFLAGS_SEND_THREAD_SCHEDULED)
	{
		Unlock(&pSPD->SPLock);
		Sleep(0); // Give up our time slice
		Lock(&pSPD->SPLock);
	}

	// Clean off the Pending Queue, SPLock still held
	while (!pSPD->blPendingQueue.IsEmpty())
	{
		Unlock(&pSPD->SPLock);
		Sleep(0); // Give up our time slice
		Lock(&pSPD->SPLock);
	}

	// By now we are only waiting for the SP to do any final calls to CommandComplete that are needed to take
	// our EPD ref count down to nothing.  We will wait while the SP does this.
	while(!(pSPD->blEPDActiveList.IsEmpty()))
	{
		Unlock(&pSPD->SPLock);
		Sleep(0); // Give up our time slice
		Lock(&pSPD->SPLock);
	}

	// By this time everything pending had better be gone!
	ASSERT(pSPD->blEPDActiveList.IsEmpty());	// Should not be any Endpoints left
	ASSERT(pSPD->blSendQueue.IsEmpty());		// Should not be any frames on sendQ.
	ASSERT(pSPD->blPendingQueue.IsEmpty());		// Should not be any frame in SP either

	// Leave SPLock for the last time
	Unlock(&pSPD->SPLock);

	// Now that all frames are cleared out of SP,  there should be no more End Points waiting around to close.
	// We are clear to tell the SP to go away.

	DPFX(DPFPREP,DPF_CALLOUT_LVL, "Calling SP->Close, pSPD[%p]", pSPD);
	IDP8ServiceProvider_Close(pSPD->IISPIntf);
	DPFX(DPFPREP,DPF_CALLOUT_LVL, "Calling SP->Release, pSPD[%p]", pSPD);
	IDP8ServiceProvider_Release(pSPD->IISPIntf);

	// Clean up the SPD object
	DNDeleteCriticalSection(&pSPD->SPLock);
	DNFree(pSPD);

	// Remove the reference of this SP from the main Protocol object
	ASSERT(pPData->lSPActiveCount > 0);
	InterlockedDecrement(&pPData->lSPActiveCount);

	return DPN_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\protocol\send.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		Send.cpp
 *  Content:	This file contains code which implements the front end of the
 *				SendData API.  It also contains code to Get and Release Message
 *				Descriptors (MSD) with the FPM package.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  11/06/98	ejs		Created
 *  07/01/2000  masonb  Assumed Ownership
 *
 ****************************************************************************/

#include "dnproti.h"


/*
**		Direct Net Protocol  --  Send Data
**
**		Data is always address to a PlayerID,  which is represented internally
**	by an End Point Descriptor (EPD).
**
**		Data can be sent reliably or unreliably using the same API with the appropriate
**	class of service flag set.
**
**		Sends are never delivered directly to the SP because there will always be
**	a possibility that the thread might block.  So to guarentee immediate return
**	we will always queue the packet and submit it on our dedicated sending thread.
*/


#if (DN_SENDFLAGS_SET_USER_FLAG - PACKET_COMMAND_USER_1)
This will not compile.  Flags must be equal
#endif
#if (DN_SENDFLAGS_SET_USER_FLAG_TWO - PACKET_COMMAND_USER_2)
This will not compile.  Flags must be equal
#endif

//	locals

VOID	SendDatagram(PMSD, PEPD);
VOID	SendReliable(PMSD, PEPD);

#undef		DPF_MODNAME
#define		DPF_MODNAME		"PROTOCOL"

/*
**		Send Data
**
**		This routine will initiate a data transfer with the specified endpoint.  It will
**	normally start the operation and then return immediately,  returning a handle used to
**	indicate completion of the operation at a later time.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "DNPSendData"

HRESULT
DNPSendData(	PProtocolData pPData,
				HANDLE hDestination,
				UINT uiBufferCount,
				PBUFFERDESC pBufferDesc,
				UINT uiTimeout,
				ULONG ulFlags,
				PVOID pvContext,				// User context returned upon completion
				PHANDLE phHandle)				// Returned completion handle
{
	PEPD 			pEPD;
	PMSD			pMSD;
	PFMD			pFMD;
	UINT			i;
	UINT			Length = 0;
	PSPD			pSPD;
	ULONG			ulFrameFlags;
	BYTE			bCommand;
	//  Following variables are used for mapping buffers to frames
	PBUFFERDESC		FromBuffer, ToBuffer;
	UINT			TotalRemain, FromRemain, ToRemain, size;
	PCHAR			FromPtr;
#ifdef	DEBUG
	INT				FromBufferCount;
#endif
	// End of variables for mapping frames

	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: pPData[%p], hDestination[%x], uiBufferCount[%x], pBufferDesc[%p], uiTimeout[%x], ulFlags[%x], pvContext[%p], phHandle[%p]", pPData, hDestination, uiBufferCount, pBufferDesc, uiTimeout, ulFlags, pvContext, phHandle);

	// Unified Send Processing -- Do this for all classes of service

	// We will do all of the work to build up the frames and create the send command before we check
	// the state of the EPD, that way we don't have to have complicated code to handle an endpoint that
	// goes away between the top and bottom of this function and we don't have to hold the EPDLock while
	// we do all of the buffer manipulation.
	
	pEPD = (PEPD) hDestination;
	ASSERT_EPD(pEPD);
	
	// Bump reference count on this baby
	if(!LOCK_EPD(pEPD, "LOCK (SEND)"))
	{
		// This would only happen if the Core had this pointer around from earlier.  If this were the first
		// time this pointer was used, the Core would not have heard about it yet because Connect is not
		// complete.  Hitting this assert indicates a bug in the Core.
		ASSERT(0);

		DPFX(DPFPREP,0, "(%p) Rejecting Send on unreferenced EPD, returning DPNERR_INVALIDENDPOINT", pEPD);
		return DPNERR_INVALIDENDPOINT;
	}

	// Count the bytes in all user buffers
	for(i=0; i < uiBufferCount; i++)
	{
		Length += pBufferDesc[i].dwBufferSize;
	}
	ASSERT(Length != 0);

	// Allocate and fill out a Message Descriptor for this operation
	if( (pMSD = static_cast<PMSD>( MSDPool->Get(MSDPool) )) == NULL)
	{
		DPFX(DPFPREP,0, "Failed to allocate MSD, returning DPNERR_OUTOFMEMORY");
		Lock(&pEPD->EPLock);
		RELEASE_EPD(pEPD, "UNLOCK (SEND)");
		return DPNERR_OUTOFMEMORY;
	}

	// Copy SendData parameters into the Message Descriptor
	pMSD->ulSendFlags = ulFlags;					// Store the actual flags passed into the API call
	pMSD->Context = pvContext;
	pMSD->iMsgLength = Length;

	pMSD->uiFrameCount = (Length + pEPD->uiUserFrameLength - 1) / pEPD->uiUserFrameLength; // round up
	DPFX(DPFPREP, DPF_FRAMECNT_LVL, "Initialize Frame count, pMSD[%p], framecount[%u]", pMSD, pMSD->uiFrameCount);

	if(ulFlags & DN_SENDFLAGS_RELIABLE)
	{
		pMSD->CommandID = COMMAND_ID_SEND_RELIABLE;
		ulFrameFlags = FFLAGS_RELIABLE;
		bCommand = PACKET_COMMAND_DATA | PACKET_COMMAND_RELIABLE;
	}
	else 
	{
		pMSD->CommandID = COMMAND_ID_SEND_DATAGRAM;
		ulFrameFlags = 0;
		bCommand = PACKET_COMMAND_DATA;
	}

	if(!(ulFlags & DN_SENDFLAGS_NON_SEQUENTIAL))
	{
		bCommand |= PACKET_COMMAND_SEQUENTIAL;
	}

	bCommand |= (ulFlags & (DN_SENDFLAGS_SET_USER_FLAG | DN_SENDFLAGS_SET_USER_FLAG_TWO));	// preserve user flag values

	// Map user buffers directly into frame's buffer descriptors
	//
	//	We will loop through each required frame,  filling out buffer descriptors
	// from those provided as parameters.  Frames may span user buffers or vica-versa...

	TotalRemain = Length;
#ifdef	DEBUG
	FromBufferCount = uiBufferCount - 1;				// sanity check
#endif
	FromBuffer = pBufferDesc;
	FromRemain = FromBuffer->dwBufferSize;
	FromPtr = reinterpret_cast<PCHAR>( (FromBuffer++)->pBufferData );				// note post-increment to next descriptor
	
	for(i=0; i<pMSD->uiFrameCount; i++)
	{
		ASSERT(TotalRemain > 0);
		
		// Grab a new frame
		if( (pFMD = static_cast<PFMD>( FMDPool->Get(FMDPool) )) == NULL)
		{	
			// MSD_Release will clean up any previous frames if this isn't the first.
			Lock(&pMSD->CommandLock);
			RELEASE_MSD(pMSD, "Base Ref");	// MSD Release operation will also free frames
			Lock(&pEPD->EPLock);
			RELEASE_EPD(pEPD, "UNLOCK (SEND)");
			DPFX(DPFPREP,0, "Failed to allocate FMD, returning DPNERR_OUTOFMEMORY");
			return DPNERR_OUTOFMEMORY;
		}

		pFMD->pMSD = pMSD;								// Link frame back to message
		pFMD->pEPD = pEPD;
		pFMD->CommandID = pMSD->CommandID;
		pFMD->bPacketFlags = bCommand;					// save packet flags for each frame
		pFMD->blMSDLinkage.InsertBefore( &pMSD->blFrameList);
		ToRemain = pEPD->uiUserFrameLength;
		ToBuffer = pFMD->rgBufferList;					// Address first user buffer desc
		
		pFMD->uiFrameLength = pEPD->uiUserFrameLength;	// Assume we fill frame- only need to change size of last one
		pFMD->ulFFlags = ulFrameFlags;					// Set control flags for frame (Sequential, Reliable)

		// Until this frame is full
		while((ToRemain != 0) && (TotalRemain != 0))
		{	
 			size = MIN(FromRemain, ToRemain);			// choose smaller of framesize or buffersize
			FromRemain -= size;
			ToRemain -= size;
			TotalRemain -= size;

			ToBuffer->dwBufferSize = size;				// Fill in the next frame descriptor
			(ToBuffer++)->pBufferData = reinterpret_cast<BYTE*>( FromPtr );		// note post-increment
			pFMD->SendDataBlock.dwBufferCount++;		// Count buffers as we add them

			// Get next user buffer
			if((FromRemain == 0) && (TotalRemain != 0))
			{
				FromRemain = FromBuffer->dwBufferSize;
				FromPtr = reinterpret_cast<PCHAR>( (FromBuffer++)->pBufferData );	// note post-increment to next descriptor
#ifdef	DEBUG		
				FromBufferCount--;						// Keep this code honest...
				ASSERT(FromBufferCount >= 0);
#endif
			}
			else 
			{										// Either filled this frame,  or have mapped the whole send
				FromPtr += size;						// advance ptr to start next frame (if any)
				pFMD->uiFrameLength = pEPD->uiUserFrameLength - ToRemain;		// wont be full at end of message
			}
		}	// While (frame not full)
	}  // For (each frame in message)

	pFMD->ulFFlags |= FFLAGS_END_OF_MESSAGE;			// Mark last frame with EOM
	pFMD->bPacketFlags |= PACKET_COMMAND_END_MSG;		// Set EOM in frame
	
	ASSERT(FromBufferCount == 0);
	ASSERT(TotalRemain == 0);

	Lock(&pMSD->CommandLock);
	Lock(&pEPD->EPLock);

	// Don't allow sends if we are not connected or if a disconnect has been initiated
	if( ((pEPD->ulEPFlags & (EPFLAGS_END_POINT_IN_USE | EPFLAGS_STATE_CONNECTED)) !=
														(EPFLAGS_END_POINT_IN_USE | EPFLAGS_STATE_CONNECTED))
														|| (pEPD->ulEPFlags & EPFLAGS_SENT_DISCONNECT)) 
	{
		RELEASE_EPD(pEPD, "UNLOCK (SEND)"); // Releases EPLock

		pMSD->uiFrameCount = 0;

		// MSD_Release will clean up all of the frames
		RELEASE_MSD(pMSD, "Base Ref");	// MSD Release operation will also free frames

		DPFX(DPFPREP,0, "(%p) Rejecting Send on invalid EPD, returning DPNERR_INVALIDENDPOINT", pEPD);
		return DPNERR_INVALIDENDPOINT;
	}

	pSPD = pEPD->pSPD;
	ASSERT_SPD(pSPD);

	pMSD->pSPD = pSPD;
	pMSD->pEPD = pEPD;

	// hang the message off a global command queue

#ifdef DEBUG
	Lock(&pSPD->SPLock);
	pMSD->blSPLinkage.InsertBefore( &pSPD->blMessageList);
	pMSD->ulMsgFlags1 |= MFLAGS_ONE_ON_GLOBAL_LIST;
	Unlock(&pSPD->SPLock);
#endif

	*phHandle = pMSD;									// We will use the MSD as our handle.

	// Enqueue the message before setting the timeout
	EnqueueMessage(pMSD, pEPD);
	Unlock(&pEPD->EPLock);

	if(uiTimeout != 0)
	{
		LOCK_MSD(pMSD, "Send Timeout Timer");							// Add reference for timer
		DPFX(DPFPREP,7, "(%p) Setting Timeout Send Timer", pEPD);
		SetMyTimer(uiTimeout, 100, TimeoutSend, pMSD, &pMSD->TimeoutTimer, &pMSD->TimeoutTimerUnique);
	}

	Unlock(&pMSD->CommandLock);

	return DPNERR_PENDING;
}

/*
**		Enqueue Message
**
**		Add complete MSD to the appropriate send queue,  and kick start sending process if necessary.
**
**		** This routine is called and returns with EPD->EPLOCK held **
*/

#undef DPF_MODNAME
#define DPF_MODNAME "EnqueueMessage"

VOID
EnqueueMessage(PMSD pMSD, PEPD pEPD)
{
	//	Place Message in appriopriate priority queue.  Datagrams get enqueued twice (!).  They get put in the Master
	// queue where they are processed FIFO with all messages of the same priority.  Datagrams also get placed in a priority
	// specific queue of only datagrams which is drawn from when the reliable stream is blocked.
	
	AssertCriticalSectionIsTakenByThisThread(&pEPD->EPLock, TRUE);

	if(pMSD->ulSendFlags & DN_SENDFLAGS_HIGH_PRIORITY)
	{
		DPFX(DPFPREP,7, "(%p) Placing message on High Priority Q", pEPD);
		pMSD->blQLinkage.InsertBefore( &pEPD->blHighPriSendQ);
		pEPD->uiMsgSentHigh++;
	}
	else if (pMSD->ulSendFlags & DN_SENDFLAGS_LOW_PRIORITY)
	{
		DPFX(DPFPREP,7, "(%p) Placing message on Low Priority Q", pEPD);
		pMSD->blQLinkage.InsertBefore( &pEPD->blLowPriSendQ);
		pEPD->uiMsgSentLow++;
	}
	else
	{
		DPFX(DPFPREP,7, "(%p) Placing message on Normal Priority Q", pEPD);
		pMSD->blQLinkage.InsertBefore( &pEPD->blNormPriSendQ);
		pEPD->uiMsgSentNorm++;
	}

#ifdef DEBUG
	pMSD->ulMsgFlags2 |= MFLAGS_TWO_ENQUEUED;
#endif

	pEPD->uiQueuedMessageCount++;
	pEPD->ulEPFlags |= EPFLAGS_SDATA_READY;							// Note that there is *something* in one or more queues

	// If the session is not currently in the send pipeline then we will want to insert it here as long as the
	// the stream is not blocked.

	if(((pEPD->ulEPFlags & EPFLAGS_IN_PIPELINE)==0) && (pEPD->ulEPFlags & EPFLAGS_STREAM_UNBLOCKED))
	{
		ASSERT(pEPD->SendTimer == NULL);
		DPFX(DPFPREP,7, "(%p) Send On Idle Link -- Returning to pipeline", pEPD);
	
		pEPD->ulEPFlags |= EPFLAGS_IN_PIPELINE;
		LOCK_EPD(pEPD, "LOCK (pipeline)");								// Add Ref for pipeline Q

		// We dont call send on users thread,  but we dont have a dedicated send thread either. Use a thread
		// from the timer-worker pool to submit the sends to SP

		DPFX(DPFPREP,7, "(%p) Scheduling Send Thread", pEPD);
		ScheduleTimerThread(ScheduledSend, pEPD, &pEPD->SendTimer, &pEPD->SendTimerUnique);
	}
	else if ((pEPD->ulEPFlags & EPFLAGS_IN_PIPELINE)==0)
	{
		DPFX(DPFPREP,7, "(%p) Declining to re-enter pipeline on blocked stream", pEPD);
	}
	else
	{
		DPFX(DPFPREP,7, "(%p) Already in pipeline", pEPD);
	}
}


#undef DPF_MODNAME
#define DPF_MODNAME "TimeoutSend"

VOID CALLBACK
TimeoutSend(PVOID uID, UINT uMsg, PVOID dwUser)
{
	PMSD	pMSD = (PMSD) dwUser;
	PEPD	pEPD = pMSD->pEPD;

	DPFX(DPFPREP,7, "(%p) Timeout Send pMSD=%p,  RefCnt=%d", pEPD, pMSD, pMSD->lRefCnt);

	Lock(&pMSD->CommandLock);
	
	if((pMSD->TimeoutTimer != uID)||(pMSD->TimeoutTimerUnique != uMsg))
	{
		DPFX(DPFPREP,7, "(%p) Ignoring late send timeout timer, pMSD[%p]", pEPD, pMSD);
		RELEASE_MSD(pMSD, "Timeout Timer"); // releases EPLock
		return;
	}

	pMSD->TimeoutTimer = NULL;

	if(pMSD->ulMsgFlags1 & (MFLAGS_ONE_CANCELLED | MFLAGS_ONE_TIMEDOUT))
	{
		DPFX(DPFPREP,7, "(%p) Timed out send has completed already pMSD=%p", pEPD, pMSD);
		RELEASE_MSD(pMSD, "Send Timout Timer"); // Releases CommandLock
		return;
	}

	pMSD->ulMsgFlags1 |= MFLAGS_ONE_TIMEDOUT;

	DPFX(DPFPREP,7, "(%p) Calling DoCancel to cancel pMSD=%p", pEPD, pMSD);

	if(DoCancel(pMSD, DPNERR_TIMEDOUT) == DPN_OK) // Releases CommandLock
	{
		ASSERT_EPD(pEPD);

		if(pMSD->ulSendFlags & DN_SENDFLAGS_HIGH_PRIORITY)
		{
			pEPD->uiMsgTOHigh++;
		}
		else if(pMSD->ulSendFlags & DN_SENDFLAGS_LOW_PRIORITY)
		{
			pEPD->uiMsgTOLow++;
		}
		else
		{
			pEPD->uiMsgTONorm++;
		}
	}
	else
	{
		DPFX(DPFPREP,7, "(%p) DoCancel did not succeed pMSD=%p", pEPD, pMSD);
	}

	Lock(&pMSD->CommandLock);
	RELEASE_MSD(pMSD, "Send Timout Timer");							// Release Ref for timer
}


/***********************
========SPACER==========
************************/

/*
**		MSD Pool support routines
**
**		These are the functions called by Fixed Pool Manager as it handles MSDs.
*/

#define	pELEMENT		((PMSD) pElement)

#undef DPF_MODNAME
#define DPF_MODNAME "MSD_Allocate"

BOOL MSD_Allocate(PVOID pElement)
{
	DPFX(DPFPREP,7, "(%p) Allocating new MSD", pELEMENT);

	ZeroMemory(pELEMENT, sizeof(messagedesc));

	if (DNInitializeCriticalSection(&pELEMENT->CommandLock) == FALSE)
	{
		DPFX(DPFPREP,0, "Failed to initialize MSD CS");
		return FALSE;		
	}
	DebugSetCriticalSectionRecursionCount(&pELEMENT->CommandLock,0);
	
	pELEMENT->blFrameList.Initialize();
	pELEMENT->blQLinkage.Initialize();
	pELEMENT->blSPLinkage.Initialize();
	pELEMENT->Sign = MSD_SIGN;
	pELEMENT->lRefCnt = -1;

	// NOTE: pELEMENT->pEPD NULL'd by ZeroMemory above

	return TRUE;
}

//	Get is called each time an MSD is used


#undef DPF_MODNAME
#define DPF_MODNAME "MSD_Get"

VOID MSD_Get(PVOID pElement)
{
	DPFX(DPFPREP,DPF_REFCNT_FINAL_LVL, "CREATING MSD %p", pELEMENT);

	// NOTE: First sizeof(PVOID) bytes will have been overwritten by the pool code, 
	// we must set them to acceptable values.

	pELEMENT->CommandID = COMMAND_ID_NONE;
	pELEMENT->ulMsgFlags1 = MFLAGS_ONE_IN_USE;	// Dont need InUse flag since we have RefCnt
	pELEMENT->lRefCnt = 0; // One initial reference
	pELEMENT->hCommand = 0;

	ASSERT_MSD(pELEMENT);
}

/*
**	MSD Release
**
**		This is called with the CommandLock held.  The Lock should not be
**	freed until the INUSE flag is cleared.  This is to synchronize with
**	last minute Cancel threads waiting on lock.
**
**		When freeing a message desc we will free all frame descriptors
**	attached to it first.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "MSD_Release"

VOID MSD_Release(PVOID pElement)
{
	CBilink	*pLink;
	PFMD	pFMD;

	ASSERT_MSD(pELEMENT);

	AssertCriticalSectionIsTakenByThisThread(&pELEMENT->CommandLock, TRUE);

	DPFX(DPFPREP,DPF_REFCNT_FINAL_LVL, "RELEASING MSD %p", pELEMENT);

	ASSERT(pELEMENT->ulMsgFlags1 & MFLAGS_ONE_IN_USE);
	ASSERT(pELEMENT->lRefCnt == -1);
	ASSERT((pELEMENT->ulMsgFlags1 & MFLAGS_ONE_ON_GLOBAL_LIST)==0);

	while( (pLink = pELEMENT->blFrameList.GetNext()) != &pELEMENT->blFrameList)
	{
		pLink->RemoveFromList();							// remove from bilink

		pFMD = CONTAINING_RECORD(pLink, FMD, blMSDLinkage);
		ASSERT_FMD(pFMD);
		RELEASE_FMD(pFMD, "MSD Frame List");								// If this is still submitted it will be referenced and wont be released here.
	}

	ASSERT(pELEMENT->blFrameList.IsEmpty());
	ASSERT(pELEMENT->blQLinkage.IsEmpty());
	ASSERT(pELEMENT->blSPLinkage.IsEmpty());

	ASSERT(pELEMENT->uiFrameCount == 0);

	pELEMENT->ulMsgFlags1 = 0;
	pELEMENT->ulMsgFlags2 = 0;

	ASSERT(pELEMENT->pEPD == NULL); // This should have gotten cleaned up before here.

	Unlock(&pELEMENT->CommandLock);
}

#undef DPF_MODNAME
#define DPF_MODNAME "MSD_Free"

VOID MSD_Free(PVOID pElement)
{
	DNDeleteCriticalSection(&pELEMENT->CommandLock);
}

#undef	pELEMENT

/*
**		FMD Pool support routines
*/

#define	pELEMENT		((PFMD) pElement)

#undef DPF_MODNAME
#define DPF_MODNAME "FMD_Allocate"

BOOL FMD_Allocate(PVOID pElement)
{
	DPFX(DPFPREP,7, "(%p) Allocating new FMD", pELEMENT);

	pELEMENT->Sign = FMD_SIGN;
	pELEMENT->ulFFlags = 0;
	pELEMENT->lRefCnt = 0;

	pELEMENT->blMSDLinkage.Initialize();
	pELEMENT->blQLinkage.Initialize();
	pELEMENT->blWindowLinkage.Initialize();
	
	return TRUE;
}

//	Get is called each time an MSD is used
//
//	Probably dont need to do this everytime,  but some random SP might
//	munch the parameters someday and that could be bad if I dont...

#undef DPF_MODNAME
#define DPF_MODNAME "FMD_Get"

VOID FMD_Get(PVOID pElement)
{
	DPFX(DPFPREP,DPF_REFCNT_FINAL_LVL, "CREATING FMD %p", pELEMENT);

	// NOTE: First sizeof(PVOID) bytes will have been overwritten by the pool code, 
	// we must set them to acceptable values.

	pELEMENT->CommandID = 0;
	pELEMENT->lpImmediatePointer = (LPVOID) pELEMENT->ImmediateData;
	pELEMENT->SendDataBlock.pBuffers = (PBUFFERDESC) &pELEMENT->uiImmediateLength;
	pELEMENT->SendDataBlock.dwBufferCount = 1;				// always count one buffer for immediate data
	pELEMENT->SendDataBlock.dwFlags = 0;
	pELEMENT->SendDataBlock.pvContext = pElement;
	pELEMENT->SendDataBlock.hCommand = 0;
	pELEMENT->ulFFlags = 0;
	pELEMENT->bSubmitted = FALSE;
	pELEMENT->bPacketFlags = 0;
	
	pELEMENT->lRefCnt = 1;						// Assign first reference

	ASSERT_FMD(pELEMENT);
}

#undef DPF_MODNAME
#define DPF_MODNAME "FMD_Release"

VOID FMD_Release(PVOID pElement)
{
	DPFX(DPFPREP,DPF_REFCNT_FINAL_LVL, "RELEASING FMD %p", pELEMENT);

	ASSERT_FMD(pELEMENT);
	ASSERT(pELEMENT->lRefCnt == 0);
	ASSERT(pELEMENT->bSubmitted == FALSE);
	pELEMENT->pMSD = NULL;

	ASSERT(pELEMENT->blMSDLinkage.IsEmpty());
	ASSERT(pELEMENT->blQLinkage.IsEmpty());
	ASSERT(pELEMENT->blWindowLinkage.IsEmpty());
}

#undef DPF_MODNAME
#define DPF_MODNAME "FMD_Free"

VOID FMD_Free(PVOID pElement)
{
}

#undef	pELEMENT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\protocol\timer.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		Timer.cpp
 *  Content:	This file contains code to for the Protocol timers
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  06/04/98	aarono	Created
 *  07/01/00	masonb  Assumed Ownership
 *
 ****************************************************************************/

#include "dnproti.h"


/*
**		Quick Insert Optimizers
**
**		In a very high user system there are going to be many timers being set and cancelled.  Timer
**	cancels and timer fires are already optimized,  but as the timer list grows the SetTimer operations
**	become higher and higher overhead as we walk through a longer and longer chain for our insertion-sort.
**
**		Front First for Short Timers
**
**		When very short timers are being set we can assume that they will insert towards the front of the
**	timer list.  So it would be smarter to walk the list front-to-back instead of the back-to-front default
**	behavior which correctly assumes that most new timers will be firing after timers already set.  If the
**	the Timeout value of a new timer is near the current timer resolution then we will try the front-first
**	insertion-sort instead.  This will hopefully reduce short timer sets to fairly quick operations
**
**		Standard Long Timers
**
**		Standard means that they will all have the same duration.  If we keep a seperate chain
**	for all these timers with a constant duration they can be trivally inserted at the end of the chain.  This
**	will be used for the periodic background checks run on each endpoint every couple of seconds.
**
**		Quick Set Timer Array
**
**		The really big optimization is an array of timeout lists, with a current pointer.  Periodic timeout
**	will walk the array a number of slots corresponding to the interval since it was last run.  All events
**	on those lists will be scheduled.  This turns all SetTimer ops into constant time operations
**	no matter how many timers are running in the system.  This can be used for all timers within the
**	range of the array (resolution X number of slots) which may be 4ms * 256 slots or a 1K ms range.  We expect
**	most link timers to fall into this range, although it can be doubled or quadrupled quite trivially.
**
**	I plan to run QST algorithm on any server platform,  which will replace Front First Short Timers for
**	obvious reasons.  Client or Peer servers will use FFS instead.  Both configs will benefit from StdLTs
**	unless the range of the QST array grows to encompass the standard length timeout.
*/


#define DEFAULT_TIME_RESOLUTION 4	/* ms */
#define MAX_TIMER_THREADS_PER_PROCESSOR 8

DWORD WINAPI TimerWorkerThread(LPVOID);


CBilink g_blMyTimerList;				// Random Timer List
CBilink g_blStdTimerList;				// Standard Length Timer List
DNCRITICAL_SECTION g_csMyTimerListLock;	// One lock will guard both lists

LPFPOOL g_pTimerPool = NULL;
DWORD g_dwWorkaroundTimerID;

DWORD g_dwUnique = 0;

UINT g_uiTimeSetEventFlags = TIME_PERIODIC;

DNCRITICAL_SECTION g_csThreadListLock;		// locks ALL this stuff.

CBilink g_blThreadList;					// ThreadPool grabs work from here.

DWORD g_nThreads = 0;					// number of running threads.
DWORD g_dwActiveRequests = 0;			// number of requests being processed.
DWORD g_fShutDown = TRUE;
DWORD g_dwExtraSignals = 0;

HANDLE g_hWorkToDoSem = 0;

SYSTEM_INFO g_SystemInfo;
DWORD   g_dwMaxTimerThreads = MAX_TIMER_THREADS_PER_PROCESSOR;

HANDLE *g_phTimerThreadHandles = NULL;


/***
*
*	QUICK-START TIMER SUPPORT
*
***/

#define	QST_SLOTCOUNT		2048					// 2048 seperate timer queues
#define	QST_GRANULARITY		4						// 4 ms clock granularity * 2048 slots == 8192 ms max timeout value
#define	QST_MAX_TIMEOUT		(QST_SLOTCOUNT * QST_GRANULARITY)
#define	QST_MOD_MASK		(QST_SLOTCOUNT - 1)		// Calculate a quick modulo operation for wrapping around the array

#if	( (QST_GRANULARITY - 1) & QST_GRANULARITY )
This Will Not Compile -- ASSERT that QST_GRANULARITY is power of 2!
#endif
#if	( (QST_SLOTCOUNT - 1) & QST_SLOTCOUNT )
This Will Not Compile -- ASSERT that QST_SLOTCOUNT is power of 2!
#endif

CBilink g_rgblQSTimerArray[QST_SLOTCOUNT];
UINT	g_uiQSTCurrentIndex;			// Last array slot that was executed
DWORD	g_dwQSTLastRunTime;				// Tick count when QSTs last ran

/*
*	END OF QST SUPPORT
*/


#undef	Lock
#undef	Unlock
#define	Lock	DNEnterCriticalSection
#define	Unlock	DNLeaveCriticalSection

/*
**		Periodic Timer
**
**		This runs every RESOLUTION millisecs and checks for expired timers. It must check two lists
**	for expired timers,  plus a variable number of slots in the QST array.
*/
#undef DPF_MODNAME
#define DPF_MODNAME "PeriodicTimer"

void CALLBACK PeriodicTimer (UINT uID, UINT uMsg, DWORD_PTR dwUser, DWORD_PTR dw1, DWORD_PTR dw2)
{
	DWORD  		time;
	PMYTIMER  	pTimerWalker;
	CBilink 	*pBilink;
	DWORD 		dwReleaseCount = 0;

	INT 		interval;
	DWORD		slot_count;

	if(g_fShutDown)
	{
		return;
	}

	time = GETTIMESTAMP();
		
	Lock(&g_csMyTimerListLock);
	Lock(&g_csThreadListLock);

	time += (DEFAULT_TIME_RESOLUTION/2);

	// Service QST lists:  Calculate how many array slots have expired and
	// service any timers in those slots.

	interval = (INT) (time - g_dwQSTLastRunTime);

	if( (interval) > 0)
	{
		slot_count = ((DWORD) interval) / QST_GRANULARITY;
		slot_count = MIN(slot_count, QST_SLOTCOUNT);

		if(slot_count < QST_SLOTCOUNT)
		{
			g_dwQSTLastRunTime += (slot_count * QST_GRANULARITY);
		}
		else
		{
			// If there was a LONG delay in scheduling this, (longer then the range of the whole array)
			// then we must complete everything that is on the array and then re-synchronize the times

			slot_count = QST_SLOTCOUNT;
			g_dwQSTLastRunTime = time;
		}

		while(slot_count--)
		{
			while( (pBilink = g_rgblQSTimerArray[g_uiQSTCurrentIndex].GetNext()) != &g_rgblQSTimerArray[g_uiQSTCurrentIndex] )
			{
				pTimerWalker = CONTAINING_RECORD(pBilink, MYTIMER, Bilink);
				pBilink->RemoveFromList();

				pTimerWalker->Bilink.InsertBefore( &g_blThreadList);
				pTimerWalker->TimerState = QueuedForThread;
				dwReleaseCount++;
			}
			g_uiQSTCurrentIndex = (g_uiQSTCurrentIndex + 1) & QST_MOD_MASK;
		}

	}

	// Walk the sorted timer list.  Expired timers will all be at the front of the
	// list so we can stop checking as soon as we find any un-expired timer.

	pBilink = g_blMyTimerList.GetNext();

	while(pBilink != &g_blMyTimerList)
	{
		pTimerWalker = CONTAINING_RECORD(pBilink, MYTIMER, Bilink);
		pBilink = pBilink->GetNext();

		if(((INT)(time-pTimerWalker->TimeOut) > 0))
		{
			pTimerWalker->Bilink.RemoveFromList();
			pTimerWalker->Bilink.InsertBefore( &g_blThreadList);
			pTimerWalker->TimerState = QueuedForThread;
			dwReleaseCount++;
		} 
		else 
		{
			break;
		}
	}

	// Next walk the Standard Length list.   Same rules apply

	pBilink=g_blStdTimerList.GetNext();
	while(pBilink != &g_blStdTimerList)
	{
		pTimerWalker = CONTAINING_RECORD(pBilink, MYTIMER, Bilink);
		pBilink = pBilink->GetNext();

		if(((INT)(time-pTimerWalker->TimeOut) > 0))
		{
			pTimerWalker->Bilink.RemoveFromList();
			pTimerWalker->Bilink.InsertBefore( &g_blThreadList);
			pTimerWalker->TimerState = QueuedForThread;
			dwReleaseCount++;
		} 
		else 
		{
			break;
		}
	}

	g_dwActiveRequests += dwReleaseCount;

	Unlock(&g_csThreadListLock);
	Unlock(&g_csMyTimerListLock);

	ReleaseSemaphore(g_hWorkToDoSem,dwReleaseCount,NULL);
}

#undef DPF_MODNAME
#define DPF_MODNAME "ScheduleTimerThread"

VOID ScheduleTimerThread(MYTIMERCALLBACK TimerCallBack, PVOID UserContext, PVOID *pHandle, PUINT pUnique)
{
	PMYTIMER pTimer;

	if(g_fShutDown)
	{
		ASSERT(0);
		*pHandle = 0;
		*pUnique = 0;
		return;
	}

	pTimer = static_cast<PMYTIMER>( g_pTimerPool->Get(g_pTimerPool) );
	if (!pTimer)
	{
		*pHandle = 0;
		*pUnique = 0;
		return;
	}

	DPFX(DPFPREP,DPF_TIMER_LVL, "Parameters: TimerCallBack[%p], UserContext[%p] - Timer[%p]", TimerCallBack, UserContext, pTimer);

	pTimer->CallBack = TimerCallBack;
	pTimer->Context = UserContext;

	Lock(&g_csMyTimerListLock);
	Lock(&g_csThreadListLock);

	*pUnique = ++g_dwUnique;
	if(g_dwUnique == 0)
	{
		*pUnique = ++g_dwUnique;
	}
	pTimer->Unique = *pUnique;
	
	*pHandle = pTimer;

	pTimer->Bilink.InsertBefore( &g_blThreadList);
	pTimer->TimerState = QueuedForThread;

	g_dwActiveRequests++;
	
	Unlock(&g_csThreadListLock);
	Unlock(&g_csMyTimerListLock);

	ReleaseSemaphore(g_hWorkToDoSem,1,NULL);
}

#undef DPF_MODNAME
#define DPF_MODNAME "SetMyTimer"

VOID SetMyTimer(DWORD dwTimeOut, DWORD, MYTIMERCALLBACK TimerCallBack, PVOID UserContext, PVOID *pHandle, PUINT pUnique)
{
	CBilink*	pBilink;
	PMYTIMER	pMyTimerWalker, pTimer;
	DWORD		time;
	BOOL		fInserted=FALSE;
	UINT		Offset;
	UINT		Index;

	if (g_fShutDown)
	{
		ASSERT(0);
		*pHandle = 0;
		*pUnique = 0;
		return;
	}
	
	time = GETTIMESTAMP();

	pTimer = static_cast<PMYTIMER>( g_pTimerPool->Get(g_pTimerPool) );
	if (!pTimer)
	{
		*pHandle = 0;
		*pUnique = 0;
		return;
	}

	DPFX(DPFPREP,DPF_TIMER_LVL, "Parameters: dwTimeOut[%d], TimerCallBack[%p], UserContext[%p] - Timer[%p]", dwTimeOut, TimerCallBack, UserContext, pTimer);

	pTimer->CallBack = TimerCallBack;
	pTimer->Context = UserContext;

	Lock(&g_csMyTimerListLock);

	*pUnique = ++g_dwUnique;
	if(g_dwUnique == 0)
	{
		*pUnique = ++g_dwUnique;
	}
	pTimer->Unique = *pUnique;
	
	*pHandle = pTimer;

	pTimer->TimeOut=time+dwTimeOut;
	pTimer->TimerState=WaitingForTimeout;

	if(dwTimeOut < QST_MAX_TIMEOUT)
	{
		Offset = (dwTimeOut + (QST_GRANULARITY/2)) / QST_GRANULARITY;	// Round nearest and convert time to slot offset
		Index = (Offset + g_uiQSTCurrentIndex) & QST_MOD_MASK;				// Our index will be Current + Offset MOD TableSize
		pTimer->Bilink.InsertBefore( &g_rgblQSTimerArray[Index]);			// Its called Quick-Start for a reason.
	}
	
	// OPTIMIZE FOR STANDARD TIMER
	//
	// Rather then calling a special API for StandardLongTimers as described above,  we can just pull out
	// any timer with the correct Timeout value and stick it on the end of the StandardTimerList.  I believe
	// this is the most straightforward way to do it.  Now really,  we could put anything with a TO +/- resolution
	// on the standard list too,  but that might not be all that useful...

	else if(dwTimeOut == STANDARD_LONG_TIMEOUT_VALUE)
	{
		// This is a STANDARD TIMEOUT so add it to the end of the standard list.

		pTimer->Bilink.InsertBefore( &g_blStdTimerList);
	}

	// OPTIMIZE FOR SHORT TIMERS  !! DONT NEED TO DO THIS IF USING Quick Start Timers !!
	//
	// If the timer has a very small Timeout value (~20ms) lets insert from the head of the list
	// instead of from the tail.
	else
	{

	//	DEFAULT - Assume new timers will likely sort to the end of the list.
	//
	// Insert this guy in the sorted list by timeout time,  walking from the tail forward.

		pBilink=g_blMyTimerList.GetPrev();
		while(pBilink != &g_blMyTimerList)
		{
			pMyTimerWalker=CONTAINING_RECORD(pBilink, MYTIMER, Bilink);
			pBilink=pBilink->GetPrev();

			if((int)(pTimer->TimeOut-pMyTimerWalker->TimeOut) > 0 )
			{
				pTimer->Bilink.InsertAfter( &pMyTimerWalker->Bilink);
				fInserted=TRUE;
				break;
			}
		}

		if(!fInserted)
		{
			pTimer->Bilink.InsertAfter( &g_blMyTimerList);
		}
	}	
	Unlock(&g_csMyTimerListLock);

	return;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CancelMyTimer"

HRESULT CancelMyTimer(PVOID dwTimer, DWORD Unique)
{
	PMYTIMER pTimer = (PMYTIMER)dwTimer;
	HRESULT hr = DPNERR_GENERIC;

	if(pTimer == 0)
	{
		return DPN_OK;
	}

	DPFX(DPFPREP,DPF_TIMER_LVL, "Parameters: Timer[%p]", pTimer);

	Lock(&g_csMyTimerListLock);
	Lock(&g_csThreadListLock);

	if(pTimer->Unique == Unique)
	{
		switch(pTimer->TimerState)
		{
			case WaitingForTimeout:
				pTimer->Bilink.RemoveFromList();
				pTimer->TimerState = End;
				pTimer->Unique = 0;
				g_pTimerPool->Release(g_pTimerPool, pTimer);
				hr=DPN_OK;
				break;

			case QueuedForThread:
				pTimer->Bilink.RemoveFromList();
				pTimer->TimerState = End;
				pTimer->Unique = 0;
				g_pTimerPool->Release(g_pTimerPool, pTimer);
				if(g_dwActiveRequests)
				{
					g_dwActiveRequests--;
				}
				g_dwExtraSignals++;
				hr = DPN_OK;
				break;

			default:
				DPFX(DPFPREP,DPF_TIMER_LVL, "Couldn't cancel timer - Timer[%p]", pTimer);
				break;
		}
	}

	Unlock(&g_csThreadListLock);
	Unlock(&g_csMyTimerListLock);
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "TimerInit"
/*
	This function is for initialization that is done only once for the life of the module
*/
HRESULT TimerInit()
{
	DWORD	iSlot;

	DPFX(DPFPREP,DPF_TIMER_LVL, "Timer module-level initialization");

	if (DNOSIsXPOrGreater())
	{
		g_uiTimeSetEventFlags |= TIME_KILL_SYNCHRONOUS;
	}

	// Determine the maximum number of worker threads we will allow
	// Returns void, can't fail apparently
	GetSystemInfo(&g_SystemInfo);
    if (g_SystemInfo.dwNumberOfProcessors < 1)
	{
        g_SystemInfo.dwNumberOfProcessors = 1;
	}
	g_dwMaxTimerThreads = g_SystemInfo.dwNumberOfProcessors * MAX_TIMER_THREADS_PER_PROCESSOR;

    // Track thread handles in an array so we can wait on them at shutdown.
	g_phTimerThreadHandles = new HANDLE[g_dwMaxTimerThreads];
    if ( g_phTimerThreadHandles == NULL)
	{
		return DPNERR_OUTOFMEMORY;
	}

	g_blMyTimerList.Initialize();
	g_blStdTimerList.Initialize();
	g_blThreadList.Initialize();

	// Initialize all of the CBilink's
	for(iSlot = 0; iSlot < QST_SLOTCOUNT; iSlot++)
	{
		g_rgblQSTimerArray[iSlot].Initialize();
	}

	if (DNInitializeCriticalSection(&g_csMyTimerListLock) == FALSE)
	{
		delete[] g_phTimerThreadHandles;
		g_phTimerThreadHandles = NULL;
		return DPNERR_OUTOFMEMORY;
	}
	DebugSetCriticalSectionRecursionCount(&g_csMyTimerListLock,0);

	if (DNInitializeCriticalSection(&g_csThreadListLock) == FALSE)
	{
		DNDeleteCriticalSection(&g_csMyTimerListLock);
		delete[] g_phTimerThreadHandles;
		g_phTimerThreadHandles = NULL;
		return DPNERR_OUTOFMEMORY;
	}
	DebugSetCriticalSectionRecursionCount(&g_csThreadListLock,0);

	g_pTimerPool = FPM_Create(sizeof(MYTIMER),NULL,NULL,NULL,NULL);
	if(!g_pTimerPool)
	{
		DNDeleteCriticalSection(&g_csThreadListLock);
		DNDeleteCriticalSection(&g_csMyTimerListLock);
		delete[] g_phTimerThreadHandles;
		g_phTimerThreadHandles = NULL;
		return DPNERR_OUTOFMEMORY;
	}

	// Set our time resolution to 1ms, ignore failure.
	(VOID)timeBeginPeriod(1);

	return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "TimerDeinit"
/*
	This function is for initialization that is done only once for the life of the module
*/
VOID TimerDeinit()
{
	ASSERT(g_fShutDown);

	DPFX(DPFPREP,DPF_TIMER_LVL, "Timer module-level deinitialization");

	timeEndPeriod(1);

	DNDeleteCriticalSection(&g_csMyTimerListLock);
	DNDeleteCriticalSection(&g_csThreadListLock);

	if(g_pTimerPool)
	{
		g_pTimerPool->Fini(g_pTimerPool);
	}

	if (g_phTimerThreadHandles)
	{
		delete[] g_phTimerThreadHandles;
		g_phTimerThreadHandles = NULL;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "InitTimerWorkaround"

HRESULT InitTimerWorkaround()
{
	DWORD   dwJunk;
	DWORD	iSlot;

	DPFX(DPFPREP,DPF_TIMER_LVL, "Initialize Timer Package");

	// Reinitialize globals 
    g_nThreads = 0;				// number of running threads.
    g_dwActiveRequests = 0;		// number of requests being processed.
	g_dwExtraSignals = 0;

	ASSERT(g_phTimerThreadHandles);

    memset(g_phTimerThreadHandles, 0, sizeof(HANDLE) * g_dwMaxTimerThreads);

	ASSERT(g_blMyTimerList.IsEmpty());
	ASSERT(g_blStdTimerList.IsEmpty());
	ASSERT(g_blThreadList.IsEmpty());

#ifdef DEBUG
	for(iSlot = 0; iSlot < QST_SLOTCOUNT; iSlot++)
	{
		ASSERT(g_rgblQSTimerArray[iSlot].IsEmpty());
	}
#endif

	g_uiQSTCurrentIndex = 0;
	g_dwQSTLastRunTime = GETTIMESTAMP();

	g_hWorkToDoSem = CreateSemaphore(NULL, 0, 65535, NULL);
	if (!g_hWorkToDoSem)
	{
		return DPNERR_OUTOFMEMORY;
	}

	// Start the timer
	g_dwWorkaroundTimerID = timeSetEvent(DEFAULT_TIME_RESOLUTION, DEFAULT_TIME_RESOLUTION, PeriodicTimer, 0, g_uiTimeSetEventFlags);
	if(!g_dwWorkaroundTimerID)
	{
		FiniTimerWorkaround();
		return DPNERR_OUTOFMEMORY;
	}

	// We are up and running.  Do this before starting the thread.
    g_fShutDown = FALSE;

	g_nThreads = 1;
	g_phTimerThreadHandles[0] = CreateThread(NULL, 4096, TimerWorkerThread, 0, 0, &dwJunk);
	if( !g_phTimerThreadHandles[0])
    {
		g_nThreads = 0;
		FiniTimerWorkaround();
		return DPNERR_OUTOFMEMORY;
	}

	return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "PurgeTimerList"

VOID PurgeTimerList(CBilink *pList)
{
	PMYTIMER	pTimer;

	while(!pList->IsEmpty())
	{
		pTimer = CONTAINING_RECORD(pList->GetNext(), MYTIMER, Bilink);
		pTimer->Unique = 0;
		pTimer->TimerState = End;
		pTimer->Bilink.RemoveFromList();
		g_pTimerPool->Release(g_pTimerPool, pTimer);
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "FiniTimerWorkaround"

VOID FiniTimerWorkaround()
{
    DWORD   iSlot;

	DPFX(DPFPREP,DPF_TIMER_LVL, "Deinitialize Timer Package");

	// At this point:
	// 1) No one else will call SetMyTimer or ScheduleTimerThread
	// 2) The only timer left should be AdjustTimerResolution

	// Kill the timer so it never fires again
	if(g_dwWorkaroundTimerID)
	{
		// We have to do this outside the lock because on XP this will be waiting on the last timer to fire
		// which may be waiting for the lock.
		timeKillEvent(g_dwWorkaroundTimerID);

		if (!(g_uiTimeSetEventFlags & TIME_KILL_SYNCHRONOUS))
		{
			// The WinMM timer may try to fire again, so wait a little while for it
			DPFX(DPFPREP,DPF_TIMER_LVL, "OS is not XP or better, waiting for WinMM timer to finish");
			Sleep(2000);
		}
	}	
	
	// At this point:
	// 1) The winmm timer will not fire again and therefore PeriodicTimer will not be called again

	// Tell all remaining timer threads to shutdown
	Lock(&g_csThreadListLock);
	g_fShutDown = TRUE;
	Unlock(&g_csThreadListLock);

	ReleaseSemaphore(g_hWorkToDoSem, g_dwMaxTimerThreads, NULL);

	// At this point:
	// 1) No threads should be waiting in TimerWorkerThread and no new ones will be scheduled

    Lock(&g_csThreadListLock);
    for (iSlot = 0; iSlot < g_dwMaxTimerThreads; iSlot++)
    {
		// We can stop at the first NULL handle
        if (!g_phTimerThreadHandles[iSlot])
        {
			break;
		}

	    Unlock(&g_csThreadListLock);

		WaitForSingleObject(g_phTimerThreadHandles[iSlot], INFINITE);
		CloseHandle(g_phTimerThreadHandles[iSlot]);

		Lock(&g_csThreadListLock);

		g_phTimerThreadHandles[iSlot] = 0;
    }
    Unlock(&g_csThreadListLock);

	// At this point:
	// 1) All TimerWorkerThreads are gone

	CloseHandle(g_hWorkToDoSem);
	g_hWorkToDoSem = 0;

	PurgeTimerList(&g_blMyTimerList);
	PurgeTimerList(&g_blStdTimerList);
	PurgeTimerList(&g_blThreadList);

	for(iSlot = 0; iSlot < QST_SLOTCOUNT; iSlot++)
	{
		PurgeTimerList(&g_rgblQSTimerArray[iSlot]);
	}

	ASSERT(g_blMyTimerList.IsEmpty());
	ASSERT(g_blStdTimerList.IsEmpty());
	ASSERT(g_blThreadList.IsEmpty());

#ifdef DEBUG
	for(iSlot = 0; iSlot < QST_SLOTCOUNT; iSlot++)
	{
		ASSERT(g_rgblQSTimerArray[iSlot].IsEmpty());
	}
#endif
}


#undef DPF_MODNAME
#define DPF_MODNAME "TimerWorkerThread"

DWORD WINAPI TimerWorkerThread(LPVOID)
{
	CBilink    *pBilink;
	PMYTIMER    pTimer;
	DWORD       dwJunk;
    	DWORD       iThread;
	HRESULT		hr;

	DPFX(DPFPREP,DPF_TIMER_LVL, "Timer thread starting 0x%x", GetCurrentThreadId());

	if ((hr = COM_CoInitialize(NULL)) != S_OK)
	{
		DPFX(DPFPREP,0, "Timer thread failed to initialize COM hr=0x%x", hr);
		goto Exit;
	}

	while (1)
	{
		WaitForSingleObject(g_hWorkToDoSem, INFINITE);

		Lock(&g_csThreadListLock);

		if(g_fShutDown)
		{
			Unlock(&g_csThreadListLock);
			break;	
		}

		if(g_dwExtraSignals)
		{
			g_dwExtraSignals--;
			Unlock(&g_csThreadListLock);
			continue;
		}

		if (g_dwActiveRequests > g_nThreads && g_nThreads < g_dwMaxTimerThreads)
        {
			ASSERT(g_phTimerThreadHandles[0] != 0); // The first slot should never be empty

            // Find the first empty slot.
            for (iThread = 0; iThread < g_dwMaxTimerThreads; iThread++)
            {
                if (g_phTimerThreadHandles[iThread] == 0)
				{
					// NOTE: CreateThread takes a long time and we are stalling all work by having 
					// the lock when we call it.  Revise in future.
					g_phTimerThreadHandles[iThread] = CreateThread(NULL, 4096, TimerWorkerThread, 0, 0, &dwJunk);
					if (g_phTimerThreadHandles[iThread])
					{
						g_nThreads++;
					}

					// If CreateThread failed no harm is done we just don't get the extra help of
					// another worker thread.
				}
            }
		}

		pBilink = g_blThreadList.GetNext();

		if(pBilink == &g_blThreadList) 
		{
			Unlock(&g_csThreadListLock);
			continue;
		};

		pBilink->RemoveFromList();	// pull off the list.

		pTimer = CONTAINING_RECORD(pBilink, MYTIMER, Bilink);

		// Call a callback
		DPFX(DPFPREP,DPF_TIMER_LVL, "Servicing Timer Job - Timer[%p], Context[%p], Callback[%p]", pTimer, pTimer->Context, pTimer->CallBack);

		pTimer->TimerState=InCallBack;

		Unlock(&g_csThreadListLock);

		(pTimer->CallBack)(pTimer, (UINT) pTimer->Unique, pTimer->Context);

		pTimer->Unique = 0;
		pTimer->TimerState = End;
		g_pTimerPool->Release(g_pTimerPool, pTimer);

		Lock(&g_csThreadListLock);

		if(g_dwActiveRequests)
		{
			g_dwActiveRequests--;
		}

		Unlock(&g_csThreadListLock);
	}

	COM_CoUninitialize();

Exit:
    // Thread is terminating.
	DPFX(DPFPREP,DPF_TIMER_LVL, "Timer thread exiting 0x%x", GetCurrentThreadId());
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\protocol\receive.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		Receive.cpp
 *  Content:	This file contains code which receives indications of incoming data
 *				from a ServiceProvider,  cracks the data,  and handles it appropriately.
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  11/06/98	ejs		Created
 *  07/01/2000  masonb  Assumed Ownership
 *
 ****************************************************************************/

#include "dnproti.h"
#include <tchar.h>
#include <stdio.h>


// local protos

BOOL	CancelFrame(PEPD, BYTE, DWORD tNow);
VOID	CompleteSends(PEPD);
VOID 	DropReceive(PEPD, PRCD);
HRESULT IndicateReceive(PSPD, PSPIE_DATA);
HRESULT	IndicateConnect(PSPD, PSPIE_CONNECT);
HRESULT	ProcessEnumQuery( PSPD, PSPIE_QUERY );
HRESULT	ProcessQueryResponse( PSPD, PSPIE_QUERYRESPONSE );
VOID	ProcessConnectedResponse(PSPD, PEPD, PCFRAME, DWORD);
VOID	ProcessConnectRequest(PSPD, PEPD, PCFRAME);
VOID	ProcessEndOfStream(PEPD);
VOID	ProcessListenStatus(PSPD, PSPIE_LISTENSTATUS);
VOID	ProcessConnectAddressInfo(PSPD, PSPIE_CONNECTADDRESSINFO);
VOID	ProcessEnumAddressInfo(PSPD, PSPIE_ENUMADDRESSINFO);
VOID	ProcessListenAddressInfo(PSPD, PSPIE_LISTENADDRESSINFO);
VOID	ProcessSendMask(PEPD, BYTE, ULONG, ULONG, DWORD tNow);
VOID	ProcessSPDisconnect(PSPD, PSPIE_DISCONNECT);
VOID 	ReceiveInOrderFrame(PEPD, PRCD);
VOID 	ReceiveOutOfOrderFrame(PEPD, PRCD, ULONG);



HRESULT	CrackCommand(PSPD, PEPD, PSPRECEIVEDBUFFER, DWORD);
HRESULT	CrackDataFrame(PSPD, PEPD, PSPRECEIVEDBUFFER, DWORD);

 /*
**		Indicate Receive
**
**			Service Provider calls this entry when data arrives on the network.
**		We will quickly validate the frame and then figure what to do with it...
**
**			Poll/Response activity should be handled before data is indicated to
**		clients.  We want to measure the network latency up to delivery,  not including
**		delivery.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "DNSP_IndicateEvent"

HRESULT WINAPI DNSP_IndicateEvent(IDP8SPCallback *pIDNSP, SP_EVENT_TYPE Opcode, PVOID DataBlock)
{
	PSPD			pSPD = (PSPD) pIDNSP;
	ASSERT_SPD(pSPD);
	
	switch(Opcode)
	{
		case	SPEV_DATA:
			return IndicateReceive(pSPD, (PSPIE_DATA) DataBlock);

		case	SPEV_CONNECT:
			return IndicateConnect(pSPD, (PSPIE_CONNECT) DataBlock);

		case	SPEV_ENUMQUERY:
			return ProcessEnumQuery( pSPD, (PSPIE_QUERY) DataBlock );

		case	SPEV_QUERYRESPONSE:
			return ProcessQueryResponse( pSPD, (PSPIE_QUERYRESPONSE) DataBlock );

		case	SPEV_DISCONNECT:
			ProcessSPDisconnect(pSPD, (PSPIE_DISCONNECT) DataBlock);
			break;

		case	SPEV_LISTENSTATUS:
			ProcessListenStatus(pSPD, (PSPIE_LISTENSTATUS) DataBlock);
			break;

		case	SPEV_LISTENADDRESSINFO:
			ProcessListenAddressInfo(pSPD, (PSPIE_LISTENADDRESSINFO) DataBlock);
			break;

		case	SPEV_CONNECTADDRESSINFO:
			ProcessConnectAddressInfo(pSPD, (PSPIE_CONNECTADDRESSINFO) DataBlock);
			break;

		case	SPEV_ENUMADDRESSINFO:
			ProcessEnumAddressInfo(pSPD, (PSPIE_ENUMADDRESSINFO) DataBlock);
			break;

		//
		// SP passed something unexpected
		//
		default:
			DPFX(DPFPREP,0, "Unknown Event indicated by SP");
			ASSERT(0);
			break;
	}

	return DPN_OK;
}


/*
**	Indicate Connect
**
**		This event is indicated for both calling and listening sides.  The
**	calling side will do most of its work when the SP Connect call completes
**	and the listening side will do most of its work when the CONNECT frame
**	gets delivered.  All we do here is allocate the EPD and attach it to the
**	MSD (for calling case)
**
**		Since we have a connect protocol,  there will always be a CONNECT
**	frame following closely on the heels of this indication.  Therefore,
**	there is not a whole lot of stuff that we need to do here.  We will
**	allocate the EndPoint and leave it dormant.
**
**		Synchronization Issue:  We have decided that if an SP Listen command is cancelled,
**	the cancel call will not complete until all ConnectIndications have returned from the
**	protocol.  This means that we are GUARANTEED that the Listen command in the context
**	will be valid throughout this call.  This is important because now we can add a reference
**	to the Listen's MSD here and now and we will know that it wont disappear on us before we
**	do it.  Truth,  however,  is that there will be a race until SP fixes itself to follow
**	this behavior.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "IndicateConnect"

HRESULT	IndicateConnect(PSPD pSPD, PSPIE_CONNECT pConnData)
{
	PEPD	pEPD;
	PMSD	pMSD;

	pMSD = (PMSD) pConnData->pCommandContext;
	ASSERT_MSD(pMSD);
	ASSERT(pMSD->pSPD == pSPD);

	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: pSPD[%p], pConnData[%p] - pMSD[%p]", pSPD, pConnData, pMSD);

	Lock(&pMSD->CommandLock);
	
	LOCK_MSD(pMSD, "EPD Ref");				// Place a reference on the command object.  This prevents it from
											// going away during the Connect Protocol,  an assumption which simplifies
											// life extraordinarily.  We will want to ASSERT this fact,  however,  to make
											// sure that SP is playing by our rules.

	if ((pMSD->CommandID != COMMAND_ID_CONNECT) && (pMSD->CommandID != COMMAND_ID_LISTEN))
	{
		DPFX(DPFPREP,1, "Connect Rejected - CommandID is not Connect or Listen, returning DPNERR_ABORTED, pMSD[%p]", pMSD);
		RELEASE_MSD(pMSD, "EPD Ref"); // Releases CommandLock
		return DPNERR_ABORTED;
	}
	
	if ((pMSD->CommandID == COMMAND_ID_CONNECT) && (pMSD->pEPD != NULL))
	{
		DPFX(DPFPREP,1, "Connect Rejected - Connect command already has an endpoint, returning DPNERR_ABORTED, pMSD[%p], pEPD[%p]", pMSD, pMSD->pEPD);
		RELEASE_MSD(pMSD, "EPD Ref"); // Releases CommandLock
		return DPNERR_ABORTED;
	}

	if(pMSD->ulMsgFlags1 & MFLAGS_ONE_CANCELLED)
	{
		DPFX(DPFPREP,1, "Connect Rejected - Command is cancelled, returning DPNERR_ABORTED, pMSD[%p]", pMSD);
		RELEASE_MSD(pMSD, "EPD Ref"); // Releases CommandLock
		return DPNERR_ABORTED;
	}

	if((pEPD = NewEndPoint(pSPD, pConnData->hEndpoint)) == NULL)
	{
		DPFX(DPFPREP,0, "Failed to allocate new EPD, returning DPNERR_ABORTED, pMSD[%p]", pMSD);
		RELEASE_MSD(pMSD, "EPD Ref"); // Releases CommandLock
		return DPNERR_ABORTED;	// This error will implicitly DISCONNECT from Endpoint
	}

	// Associate either the Connect or Listen with this Endpoint, this will be removed when the connection is complete.
	// The EPD Ref placed above will be carried around until this is NULL'd.
	pEPD->pCommand = pMSD;	

	if(pMSD->CommandID == COMMAND_ID_CONNECT)
	{
		DPFX(DPFPREP,5, "INDICATE CONNECT (CALLING) -- EPD = %p, pMSD[%p]", pEPD, pMSD);
		pMSD->pEPD = pEPD;
	}
	else
	{
		DPFX(DPFPREP,5, "INDICATE CONNECT (LISTENING) -- EPD = %p, pMSD[%p]", pEPD, pMSD);

		ASSERT(pMSD->CommandID == COMMAND_ID_LISTEN);
		ASSERT((pEPD->ulEPFlags & EPFLAGS_LINKED_TO_LISTEN)==0);

		// For a Listen command, connecting endpoints are held on the blFrameList
		pEPD->blSPLinkage.InsertBefore( &pMSD->blFrameList);
		pEPD->ulEPFlags |= EPFLAGS_LINKED_TO_LISTEN;
	}

	pConnData->pEndpointContext = pEPD;

	Unlock(&pMSD->CommandLock);

	return DPN_OK;
}

/*
**		Indicate Receive
**
**		A frame has been delivered by the service provider.  We are Guaranteed to
**	have an active Endpoint in our hash table (or else something is wrong).  I have not
**	decided whether I will respond to POLL bits at this high level or else let
**	each handler repond in its own particular... eh...  idiom.
**
**		Our return value controls whether SP will recycle the receive buffer, or whether
**	we can keep the buffer around until we are ready to indicate it to higher levels
**	later on.   If we return DPN_OK then we are done with the buffer and it will be recycled.
**	If we return DPNERR_PENDING then we may hold on to the buffer until we release them later.
*/


#undef DPF_MODNAME
#define DPF_MODNAME "IndicateReceive"

#define MINDATAFRAMESIZE (sizeof(DFRAME))
#define MINCMDFRAMESIZE (MIN(sizeof(CFRAME), sizeof(SACKFRAME8)))

HRESULT IndicateReceive(PSPD pSPD, PSPIE_DATA pDataBlock)
{
	PEPD 			pEPD = static_cast<PEPD>( pDataBlock->pEndpointContext );
	HRESULT			hr;
	PPacketHeader	pFrame = (PPacketHeader) pDataBlock->pReceivedData->BufferDesc.pBufferData;
	DWORD			tNow = GETTIMESTAMP();
	DWORD			dwDataLength = pDataBlock->pReceivedData->BufferDesc.dwBufferSize;

	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: pSPD[%p], pDataBlock[%p] - pEPD[%p]", pSPD, pDataBlock, pEPD);

	if(pSPD->ulSPFlags & SPFLAGS_TERMINATING)
	{
		DPFX(DPFPREP,1, "(%p) SP is terminating, returning DPN_OK, pSPD[%p]", pEPD, pSPD);
		return DPN_OK;
	}

	ASSERT_EPD(pEPD);
	ASSERT(pEPD->pSPD == pSPD);

	if(LOCK_EPD(pEPD, "LOCK (IND RECEIVE)") == 0)
	{
		ASSERT(0);
		DPFX(DPFPREP,1, "(%p) Rejecting receive on unreferenced EPD, returning DPN_OK", pEPD);
		return DPN_OK;
	}

	pEPD->tLastPacket = tNow;								// Track last time each guy writes to us

#ifdef DEBUG
	// copy this frame to buffer in EPD so we can look after a break.
	DWORD dwLen = MIN(32, pDataBlock->pReceivedData->BufferDesc.dwBufferSize);
	memcpy(pEPD->LastPacket, pDataBlock->pReceivedData->BufferDesc.pBufferData, dwLen);
#endif

	// A valid data packet is one that meets the length requirements and has the Data flag set.
	// All other flags are allowed on a data frame (NOTE: even PACKET_COMMAND_CFRAME is allowed
	// as it shares its value with PACKET_COMMAND_USER_2).
	if( (dwDataLength >= MINDATAFRAMESIZE) &&				// Validate the length first
		(pFrame->bCommand & PACKET_COMMAND_DATA))			// Data goes this way
	{
		hr = CrackDataFrame(pSPD, pEPD, pDataBlock->pReceivedData, tNow);
	}
	else if ((dwDataLength >= MINCMDFRAMESIZE) &&			 // Validate the length first
		     ((pFrame->bCommand == PACKET_COMMAND_CFRAME) || // Only the CFRAME and POLL flags are allowed on a CFrame
			  (pFrame->bCommand == (PACKET_COMMAND_CFRAME|PACKET_COMMAND_POLL))))
	{
		hr = CrackCommand(pSPD, pEPD, pDataBlock->pReceivedData, tNow);
	}
	else
	{
		DPFX(DPFPREP,1, "(%p) Received frame that is neither Command nor Data, rejecting", pEPD);
		DNASSERTX(FALSE, 2);
		RejectInvalidPacket(pEPD, FALSE); // Lock not already held
		hr = DPN_OK;
	}

	Lock(&pEPD->EPLock);
	RELEASE_EPD(pEPD, "UNLOCK (IND RCV DONE)"); // Releases EPLock

	// This is either DPN_OK or DPNSUCCESS_PENDING.  If it is pending we have to return the buffer later.
	return hr;
}


/*
**		Process Enum Query
**
**		A frame has been delivered by the service provider representing an enumereation
**	query.
*/
#undef DPF_MODNAME
#define DPF_MODNAME "ProcessEnumQuery"

HRESULT ProcessEnumQuery( PSPD pSPD, PSPIE_QUERY pQueryBlock )
{
	MSD		*pMSD;
	PROTOCOL_ENUM_DATA	EnumData;

	pMSD = static_cast<MSD*>( pQueryBlock->pUserContext );
	ASSERT_MSD(pMSD);
	ASSERT(pMSD->pSPD == pSPD);

	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: pSPD[%p], pQueryBlock[%p] - pMSD[%p]", pSPD, pQueryBlock, pMSD);

	EnumData.pSenderAddress = pQueryBlock->pAddressSender;
	EnumData.pDeviceAddress = pQueryBlock->pAddressDevice;
	EnumData.ReceivedData.pBufferData = pQueryBlock->pReceivedData->BufferDesc.pBufferData;
	EnumData.ReceivedData.dwBufferSize = pQueryBlock->pReceivedData->BufferDesc.dwBufferSize;
	EnumData.hEnumQuery = pQueryBlock;

	DBG_CASSERT( sizeof( &EnumData ) == sizeof( PBYTE ) );

	DPFX(DPFPREP,DPF_CALLOUT_LVL, "(%p) Calling Core->IndicateEnumQuery, Core Context[%p]", pMSD, pMSD->Context);
	pSPD->pPData->pfVtbl->IndicateEnumQuery(	pSPD->pPData->Parent,
												pMSD->Context,
												pMSD,
												reinterpret_cast<PBYTE>( &EnumData ),
												sizeof( EnumData ));

	return	DPN_OK;
}

/*
**		Process Query Response
**
**		A frame has been delivered by the service provider representing a response to an enum.
*/
#undef DPF_MODNAME
#define DPF_MODNAME "ProcessQueryResponse"

HRESULT ProcessQueryResponse( PSPD pSPD, PSPIE_QUERYRESPONSE pQueryResponseBlock)
{
	MSD		*pMSD;
	PROTOCOL_ENUM_RESPONSE_DATA	EnumResponseData;

	pMSD = static_cast<MSD*>( pQueryResponseBlock->pUserContext );
	ASSERT_MSD(pMSD);
	ASSERT(pMSD->pSPD == pSPD);

	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: pSPD[%p], pQueryResponseBlock[%p] - pMSD[%p]", pSPD, pQueryResponseBlock, pMSD);

	EnumResponseData.pSenderAddress = pQueryResponseBlock->pAddressSender;
	EnumResponseData.pDeviceAddress = pQueryResponseBlock->pAddressDevice;
	EnumResponseData.ReceivedData.pBufferData = pQueryResponseBlock->pReceivedData->BufferDesc.pBufferData;
	EnumResponseData.ReceivedData.dwBufferSize = pQueryResponseBlock->pReceivedData->BufferDesc.dwBufferSize;
	EnumResponseData.dwRoundTripTime = pQueryResponseBlock->dwRoundTripTime;

	DBG_CASSERT( sizeof( &EnumResponseData ) == sizeof( PBYTE ) );
	
	DPFX(DPFPREP,DPF_CALLOUT_LVL, "(%p) Calling Core->IndicateEnumResponse, Core Context[%p]", pMSD, pMSD->Context);
	pSPD->pPData->pfVtbl->IndicateEnumResponse(	pSPD->pPData->Parent,
												pMSD,
												pMSD->Context,
												reinterpret_cast<PBYTE>( &EnumResponseData ),
												sizeof( EnumResponseData ));

	return	DPN_OK;
}

// *** Called with lock held or not depending on parameter, Returns with EPLock released

#undef DPF_MODNAME
#define DPF_MODNAME "RejectInvalidPacket"

VOID RejectInvalidPacket(PEPD pEPD, BOOL fLockHeld)
{
	PMSD pMSD;

	if (!fLockHeld)
	{
		Lock(&pEPD->EPLock);
	}
	else
	{
		AssertCriticalSectionIsTakenByThisThread(&pEPD->EPLock, TRUE);
	}

	if(pEPD->ulEPFlags & EPFLAGS_STATE_DORMANT)
	{
		// Unlink MSD from EPD, there should always be one if we are in the DORMANT state
		pMSD = pEPD->pCommand;
		ASSERT_MSD(pMSD);

		if (pMSD->CommandID == COMMAND_ID_LISTEN)
		{
			pEPD->pCommand = NULL;
			LOCK_EPD(pEPD, "Temp Ref");

			DPFX(DPFPREP,1, "(%p) Received invalid frame on a dormant, listening endpoint, dropping link", pEPD);
			DropLink(pEPD); // This will release the EPLock

			// The order here is important.  We call DropLink first without ever leaving the EPLock because
			// we need to ensure no new packets try to come in.  After calling DropLink we know we stay in the
			// TERMINATING state until returning to the pool, so state is not an issue after that call.

			Lock(&pMSD->CommandLock);
			Lock(&pEPD->EPLock);

			// If a cancel on a listen comes in at the same time as this happens, it is possible that the cancel came
			// through and already unlinked this EPD from the Listen while we were outside the lock.  If so, removing
			// it from the pMSD->blFrameList twice is harmless.
			pEPD->ulEPFlags &= ~(EPFLAGS_LINKED_TO_LISTEN);
			pEPD->blSPLinkage.RemoveFromList();							// Unlink EPD from Listen Queue

			RELEASE_EPD(pEPD, "Temp Ref");	// Releases EPLock
			RELEASE_MSD(pMSD, "EPD Ref");	// Releases CommandLock
		}
		else
		{
			DPFX(DPFPREP,1, "(%p) Received invalid frame on a dormant, connecting endpoint, ignoring", pEPD);
			Unlock(&pEPD->EPLock);
		}
	}
	else
	{
		DPFX(DPFPREP,1, "(%p) Received invalid frame on a non-dormant endpoint, ignoring", pEPD);
		Unlock(&pEPD->EPLock);
	}
}

/*
**		Crack Command
**
**			This frame is a maintainance frame containing no user data
**
*/
#undef DPF_MODNAME
#define DPF_MODNAME "CrackCommand"

HRESULT CrackCommand(PSPD pSPD, PEPD pEPD, PSPRECEIVEDBUFFER pRcvBuffer, DWORD tNow)
{
	DWORD 			dwDataLength = pRcvBuffer->BufferDesc.dwBufferSize;
	UNALIGNED ULONG	*array_ptr;
	ULONG			mask1, mask2;
	
	union 
	{
		PCFRAME			pCFrame;
		PSFBIG8			pSack;
	} pData;

	pData.pCFrame = (PCFRAME) pRcvBuffer->BufferDesc.pBufferData;

	switch(pData.pCFrame->bExtOpcode)
	{
		case FRAME_EXOPCODE_SACK:
			DPFX(DPFPREP,7, "(%p) SACK Frame Received", pEPD);

			Lock(&pEPD->EPLock);

			// Check state
			if(!(pEPD->ulEPFlags & EPFLAGS_STATE_CONNECTED))
			{				
				DPFX(DPFPREP,1, "(%p) Received SACK on non-connected endpoint, rejecting...", pEPD);
				DNASSERTX(FALSE, 4);
				RejectInvalidPacket(pEPD, TRUE); // TRUE means lock held, returns with lock released
				break;
			}

			// Drop short frames (should not happen)
			DWORD dwRequiredLength;
			dwRequiredLength = sizeof(SACKFRAME8);
			array_ptr = pData.pSack->rgMask;
			if (pData.pSack->bFlags & SACK_FLAGS_SACK_MASK1)
			{
				dwRequiredLength += sizeof(DWORD);
			}
			if (pData.pSack->bFlags & SACK_FLAGS_SACK_MASK2)
			{
				dwRequiredLength += sizeof(DWORD);
			}
			if (pData.pSack->bFlags & SACK_FLAGS_SEND_MASK1)
			{
				dwRequiredLength += sizeof(DWORD);
			}
			if (pData.pSack->bFlags & SACK_FLAGS_SEND_MASK2)
			{
				dwRequiredLength += sizeof(DWORD);
			}

			if (dwDataLength < dwRequiredLength)
			{
				DPFX(DPFPREP,1, "(%p) Dropping short frame on connected link", pEPD);
				DNASSERTX(FALSE, 2);
				Unlock(&pEPD->EPLock);
				return DPN_OK;					
			}

			if( pData.pSack->bFlags & SACK_FLAGS_RESPONSE )
			{
				DPFX(DPFPREP,7, "(%p) ACK RESP RCVD: Retry=%d, N(R)=0x%02x", pEPD, pData.pSack->bRetry, pData.pSack->bNRcv);
			}

			mask1 = pData.pSack->bFlags & SACK_FLAGS_SACK_MASK1 ? *array_ptr++ : 0;
			mask2 = pData.pSack->bFlags & SACK_FLAGS_SACK_MASK2 ? *array_ptr++ : 0;
			
			DPFX(DPFPREP,7, "(%p) UpdateXmitState - N(R) 0x%02x Mask 0x%08x 0x%08x", pEPD, (DWORD)pData.pSack->bNRcv, mask2, mask1);
			UpdateXmitState(pEPD, pData.pSack->bNRcv, mask1, mask2, tNow);

			mask1 = pData.pSack->bFlags & SACK_FLAGS_SEND_MASK1 ? *array_ptr++ : 0;
			mask2 = pData.pSack->bFlags & SACK_FLAGS_SEND_MASK2 ? *array_ptr++ : 0;

			if(mask1 | mask2)
			{
				DPFX(DPFPREP,7, "(%p) Processing Send Mask N(S) 0x%02x Mask 0x%08x 0x%08x", pEPD, (DWORD) pData.pSack->bNSeq, mask2, mask1);
				ProcessSendMask(pEPD, pData.pSack->bNSeq, mask1, mask2, tNow);
			}
			
			if( (!pEPD->blCompleteList.IsEmpty()) && ((pEPD->ulEPFlags & EPFLAGS_IN_RECEIVE_COMPLETE) == FALSE))
			{
				DPFX(DPFPREP,8, "(%p) Completing Receives...", pEPD);
				pEPD->ulEPFlags |= EPFLAGS_IN_RECEIVE_COMPLETE;	// ReceiveComplete will clear this flag when done
				ReceiveComplete(pEPD); 							// Deliver the goods,  returns with EPLock released
			}
			else 
			{
				Unlock(&pEPD->EPLock);
			}

			DPFX(DPFPREP,8, "(%p) Completing Sends...", pEPD);
			CompleteSends(pEPD);

			break;

		case FRAME_EXOPCODE_CONNECT:
			DPFX(DPFPREP,7, "(%p) CONNECT Frame Received", pEPD);
			if (dwDataLength < sizeof(CFRAME))
			{
				DPFX(DPFPREP,1, "(%p) Received short CONNECT frame, rejecting...", pEPD);
				DNASSERTX(FALSE, 2);
				RejectInvalidPacket(pEPD, FALSE); // FALSE means lock not held
				return DPN_OK;
			}
			ProcessConnectRequest(pSPD, pEPD, pData.pCFrame);
			break;

		case FRAME_EXOPCODE_CONNECTED:
			DPFX(DPFPREP,7, "(%p) CONNECTED Frame Received", pEPD);
			if (dwDataLength < sizeof(CFRAME))
			{
				DPFX(DPFPREP,1, "(%p) Received short CONNECTED frame, rejecting...", pEPD);
				DNASSERTX(FALSE, 2);
				RejectInvalidPacket(pEPD, FALSE); // FALSE means lock not held
				return DPN_OK;
			}
			ProcessConnectedResponse(pSPD, pEPD, pData.pCFrame, tNow);
			break;

		default:
			DPFX(DPFPREP,1, "(%p) Received invalid CFrame, rejecting...", pEPD);
			DNASSERTX(FALSE, 2);
			RejectInvalidPacket(pEPD, FALSE); // FALSE means lock not held
			break;
	}

	return DPN_OK;
}

/*
**		Crack Data Frame
**
**			In addition to delivering data contained in the frame,  we also must
**	use the included state info to drive the transmission process.  We will update
**	our link state according to this info and see if we need to put this session
**	back into the sending pipeline.
**
**		Of course, data will only be delivered if we have completed an entire message.
**
**	CRITICAL SECTION NOTE -- It might seem rather lavish the way we hold the EPD->StateLock
**		thru this entire routine,  but anything less would require an obscene level of complexity
**		to keep ironed out.  This is why I defer all ReceiveIndications and buffer mappings until
**		the end of the routine when the Lock can be released.
**
*/

#undef DPF_MODNAME
#define DPF_MODNAME "CrackDataFrame"

HRESULT CrackDataFrame(PSPD pSPD, PEPD pEPD, PSPRECEIVEDBUFFER pRcvBuffer, DWORD tNow)
{
	DWORD 	dwDataLength = pRcvBuffer->BufferDesc.dwBufferSize;
	PDFBIG	pFrame = (PDFBIG) (pRcvBuffer->BufferDesc.pBufferData);
	PRCD	pRCD;
	ULONG	bit;
	UINT	count;
	UNALIGNED ULONG	*array_ptr;
	ULONG	MaskArray[4];
	UINT	header_size;
	ULONG	mask;

	Lock(&pEPD->EPLock);
	
	//	Data on an unconnected link
	//
	//	There are two possibilities (as I see it today).  Either we have dropped our link because partner
	//	went silent,  but now he has started sending again.  OR We have disconnected and are now reconnecting
	//  but there are some old data frames bouncing around (less likely).
	//
	//	If we have dropped and partner is just figuring it out,  we must kill the endpoint or else it will hang
	//	around forever after partner stops bothering us.  We can help out partner by sending him a DISC frame
	//  so he knows that we arent playing anymore,  buts its not technically necessary.
	//
	//	In the second case,  we do not want to close the EP because that will crush the session startup that
	//	is supposedly in progress.  Therefore,  if we are not in a DORMANT state,  then we know a session
	//	startup is in progress,  and we will let the EP remain open.

	if(!(pEPD->ulEPFlags & EPFLAGS_STATE_CONNECTED))
	{				
		DPFX(DPFPREP,1, "(%p) Received data on non-connected endpoint, rejecting...", pEPD);
		DNASSERTX(FALSE, 4);
		RejectInvalidPacket(pEPD, TRUE); // TRUE means lock held, returns with lock released
		return DPN_OK;										// do not accept data before we have connected
	}

	BYTE	bSeq = pFrame->bSeq;

	DPFX(DPFPREP,7, "(%p) Data Frame Arrives Seq=%x; N(R)=%x", pEPD, bSeq, pEPD->bNextReceive);

	// Make sure that new frame is within our receive window
	if((BYTE)(bSeq - pEPD->bNextReceive) >= (BYTE) MAX_FRAME_OFFSET)
	{	
		DPFX(DPFPREP,1, "(%p) Rejecting frame that is out of receive window SeqN=%x, N(R)=%x", pEPD, bSeq, pEPD->bNextReceive);

		pEPD->ulEPFlags |= EPFLAGS_DELAY_ACKNOWLEDGE;

		if(pFrame->bCommand & PACKET_COMMAND_POLL)
		{
			// Is he asking for an immediate response
			DPFX(DPFPREP,7, "(%p) Sending Ack Frame", pEPD);
			SendAckFrame(pEPD, 1); 						// This unlocks the EPLock since param 2 is 1
		}
		else if(pEPD->DelayedAckTimer == 0)
		{	
			// If timer is not running better start it now
			LOCK_EPD(pEPD, "LOCK (DelayedAckTimer)");								// Bump RefCnt for new timer
			DPFX(DPFPREP,7, "(%p) Setting Delayed Ack Timer", pEPD);
			SetMyTimer(SHORT_DELAYED_ACK_TIMEOUT, 0, DelayedAckTimeout, (PVOID) pEPD, &pEPD->DelayedAckTimer, &pEPD->DelayedAckTimerUnique);
			Unlock(&pEPD->EPLock);		
		}
		else
		{
			Unlock(&pEPD->EPLock);		
		}
		return DPN_OK;
	}

	DWORD dwRequiredLength = sizeof(DFRAME);
	if (pFrame->bControl & PACKET_CONTROL_SACK_MASK1)
	{
		dwRequiredLength += sizeof(DWORD);
	}
	if (pFrame->bControl & PACKET_CONTROL_SACK_MASK2)
	{
		dwRequiredLength += sizeof(DWORD);
	}
	if (pFrame->bControl & PACKET_CONTROL_SEND_MASK1)
	{
		dwRequiredLength += sizeof(DWORD);
	}
	if (pFrame->bControl & PACKET_CONTROL_SEND_MASK2)
	{
		dwRequiredLength += sizeof(DWORD);
	}

	if (dwDataLength < dwRequiredLength)
	{
		DPFX(DPFPREP,1, "(%p) Dropping short frame on connected link", pEPD);
		DNASSERTX(FALSE, 2);
		Unlock(&pEPD->EPLock);
		return DPN_OK;					
	}

	// Determine how large the variable length header is
	mask = (pFrame->bControl & PACKET_CONTROL_VARIABLE_MASKS) / PACKET_CONTROL_SACK_MASK1;
	
	if(mask)
	{
		array_ptr = pFrame->rgMask;
		for(count = 0; count < 4; count++, mask >>= 1)
		{
			MaskArray[count] = (mask & 1) ? *array_ptr++ : 0;
		}
		
		header_size = (UINT) ((UINT_PTR) array_ptr - (UINT_PTR) pFrame);

		// See if this frame Acknowledges any of our outstanding data
		DPFX(DPFPREP,7, "(%p) UpdateXmitState - N(R) 0x%02x Mask 0x%08x 0x%08x", pEPD, (DWORD)pFrame->bNRcv, MaskArray[1], MaskArray[0]);
		UpdateXmitState(pEPD, pFrame->bNRcv, MaskArray[0], MaskArray[1], tNow);				// Do this before taking StateLock

		// Determine if there is a SendMask in this frame which identifies dropped frames as unreliable
		if(pFrame->bControl & (PACKET_CONTROL_SEND_MASK1 | PACKET_CONTROL_SEND_MASK2))
		{
			DPFX(DPFPREP,7, "(%p) Processing Send Mask N(S) 0x%02x Mask 0x%08x 0x%08x", pEPD, (DWORD)pFrame->bSeq, MaskArray[3], MaskArray[2]);
			ProcessSendMask(pEPD, pFrame->bSeq, MaskArray[2], MaskArray[3], tNow);

			// NOTE: ProcessSendMask may have advanced N(R)

			// Re-verify that the new frame is within our receive window
			if((BYTE)(bSeq - pEPD->bNextReceive) >= (BYTE) MAX_FRAME_OFFSET)
			{
				DPFX(DPFPREP,1, "(%p) ProcessSendMask advanced N(R) such that the current frame is out of window, rejecting receive, N(R)=0x%02x, Seq=0x%02x", pEPD, (DWORD)pEPD->bNextReceive, (DWORD)pFrame->bSeq);
				Unlock(&pEPD->EPLock);
				return DPN_OK;
			}
		}

	}
	else 
	{
		header_size = sizeof(DFRAME);
		DPFX(DPFPREP,7, "(%p) UpdateXmitState - N(R) 0x%02x No Mask", pEPD, (DWORD)pFrame->bNRcv);
		UpdateXmitState(pEPD, pFrame->bNRcv, 0, 0, tNow);			// Do this before taking StateLock
	}

	// We can receive this frame.   Copy relevant info into Receive descriptor
	if((pRCD = static_cast<PRCD>( RCDPool->Get(RCDPool) )) == NULL)
	{
		DPFX(DPFPREP,0, "(%p) Failed to allocate new RCD", pEPD);
		Unlock(&pEPD->EPLock);
		return DPN_OK;
	}

	pEPD->ulEPFlags |= EPFLAGS_DELAY_ACKNOWLEDGE;	// State has changed.  Make sure it gets sent.

 	pRCD->bSeq = bSeq;
	pRCD->bFrameFlags = pFrame->bCommand;
 	pRCD->bFrameControl = pFrame->bControl;
	pRCD->pbData = (PBYTE) (((PBYTE) pFrame) + header_size);
	pRCD->uiDataSize = dwDataLength - header_size;
	pRCD->tTimestamp = tNow;
	pRCD->pRcvBuff = pRcvBuffer;

	// Update our receiving state info.
	//
	//	RCDs go onto one of two queues.  If it is the next numbered (expected) frame then it is
	// placed on the ReceiveList (in EPD).  If this frame completes a message it can now be
	// indicated.  If this frame fills a hole left by previous frames then a condensation with
	// the second list must occur.
	//	If it is not the next numbered frame then it is placed,  in order,  on the MisOrdered frame
	// list,  and the bitmask is updated.
	//
	//	Condensation of lists is performed by testing the LSB of the ReceiveMask. Each time LSB is set,
	// the first frame on the list can be moved to the ReceiveList, and the mask is shifted right.
	// As each frame is moved to the ReceiveList,  the EOM flag must be checked for and if set,  then
	// everything on the ReceiveList should be moved to the CompleteList for indication to the user.

	BOOL fPoll = pFrame->bCommand & PACKET_COMMAND_POLL;
	BOOL fCorrelate = pFrame->bControl & PACKET_CONTROL_CORRELATE;

	if(bSeq == pEPD->bNextReceive)
	{
		// Frame is the next expected # in sequence

		DPFX(DPFPREP,8, "(%p) Receiving In-Order Frame, pRCD[%p]", pEPD, pRCD);
		ReceiveInOrderFrame(pEPD, pRCD);				// Build frame into message AND move adjacent frames off OddFrameList

		// NOTE: ReceiveInOrderFrame may have caused the frame to be freed via DropReceive
		// so we absolutely must not use pFrame past this point!

		// See if we need to respond right away...
		//
		//	Because there are lots of way to generate POLL bits (full window, empty queue, poll count) we sometimes find ourselves
		// generating too much dedicated ack-traffic.  Therefore,  we will treat the POLL not as Respond-Immediately but instead as
		// Respond-Soon. We will not wait the full Delayed_Ack_Timeout interval but we will wait long enough to allow a quick piggyback
		// response (say 5ms) (we may want this longer on a slow connection...)

		// Is he asking for an instant response?
		if(fCorrelate)
		{
			DPFX(DPFPREP,7, "(%p) Sending Ack Frame", pEPD);
			SendAckFrame(pEPD, 0);						// Send Ack w/timing info
		}
		// Is he asking for a response soon?
		else if(fPoll)
		{
			if(pEPD->ulEPFlags & EPFLAGS_USE_POLL_DELAY)
			{		
				if(pEPD->DelayedAckTimer != NULL)
				{
					DPFX(DPFPREP,7, "(%p) Cancelling Delayed Ack Timer", pEPD);
					if(CancelMyTimer(pEPD->DelayedAckTimer, pEPD->DelayedAckTimerUnique)!= DPN_OK)
					{
						DPFX(DPFPREP,7, "(%p) Cancelling Delayed Ack Timer Failed", pEPD);
						LOCK_EPD(pEPD, "LOCK (re-start delayed ack timer)");
					}
				}
				else 
				{
					LOCK_EPD(pEPD, "LOCK (start short delayed ack timer)");
				}
				DPFX(DPFPREP,7, "Delaying POLL RESP");
				pEPD->ulEPFlags |= EPFLAGS_DELAY_ACKNOWLEDGE;

				DPFX(DPFPREP,7, "(%p) Setting Delayed Ack Timer", pEPD);
				SetMyTimer(4, 4, DelayedAckTimeout, (PVOID) pEPD, &pEPD->DelayedAckTimer, &pEPD->DelayedAckTimerUnique);
			}
			else 
			{
				DPFX(DPFPREP,7, "(%p) Sending Ack Frame", pEPD);
				SendAckFrame(pEPD, 0);						// Send Ack w/timing info
			}
		}
		else if(pEPD->DelayedAckTimer == 0)
		{
			// If timer is not running better start it now
			LOCK_EPD(pEPD, "LOCK (DelayedAckTimer)");	// Bump RefCnt for timer
			SetMyTimer(DELAYED_ACK_TIMEOUT, 0, DelayedAckTimeout, (PVOID) pEPD, &pEPD->DelayedAckTimer, &pEPD->DelayedAckTimerUnique);
		}
	}		// IF frame is in order

	else 
	{	
		// Frame arrives out of order

		// bit location in mask for this frame
		bit = (BYTE) ((bSeq - pEPD->bNextReceive) - 1);						

		// Make sure this is not a duplicate frame
		if( ((bit < 32) && (pEPD->ulReceiveMask & (1 << bit))) || ((bit > 31) && (pEPD->ulReceiveMask2 & (1 << (bit - 32)))) ) 
		{
			DPFX(DPFPREP,7, "(%p) REJECT DUPLICATE OUT-OF-ORDER Frame Seq=%x", pEPD, bSeq);
		
			Unlock(&pEPD->EPLock);
			pRCD->pRcvBuff = NULL;
			RELEASE_RCD(pRCD);
			return DPN_OK;
		}
		
		DPFX(DPFPREP,8, "(%p) Receiving Out-of-Order Frame, pRCD[%p]", pEPD, pRCD);
		ReceiveOutOfOrderFrame(pEPD, pRCD, bit);

		// NOTE: ReceiveOutOfOrderFrame may have caused the frame to be freed via DropReceive
		// so we absolutely must not use pFrame past this point!

		if(fPoll)
		{
			if(pEPD->DelayedAckTimer != NULL)
			{
				DPFX(DPFPREP,7, "(%p) Cancelling Delayed Ack Timer", pEPD);
				if(CancelMyTimer(pEPD->DelayedAckTimer, pEPD->DelayedAckTimerUnique)!= DPN_OK)
				{
					DPFX(DPFPREP,7, "(%p) Cancelling Delayed Ack Timer Failed", pEPD);
					LOCK_EPD(pEPD, "LOCK (re-start delayed ack timer)");
				}

				// Start an abreviated delayed ack timer in case NACK gets cancelled
			}
			else 
			{
				LOCK_EPD(pEPD, "LOCK (start short delayed ack timer)");
			}

			DPFX(DPFPREP,7, "Delaying POLL RESP");
			pEPD->ulEPFlags |= EPFLAGS_DELAY_ACKNOWLEDGE;

			DPFX(DPFPREP,7, "(%p) Setting Delayed Ack Timer", pEPD);
			SetMyTimer(5, 5, DelayedAckTimeout, (PVOID) pEPD, &pEPD->DelayedAckTimer, &pEPD->DelayedAckTimerUnique);
		}

	}	
	// EPD->StateLock is still HELD
	//
	// We use a FLAG for exclusive access to ReceiveComplete routine. This is safe because the flag is only
	// tested and modified while holding the EPD->StateLock.  Lets be sure to keep it that way...

	if( (!pEPD->blCompleteList.IsEmpty()) && ((pEPD->ulEPFlags & EPFLAGS_IN_RECEIVE_COMPLETE) == FALSE))
	{
		DPFX(DPFPREP,8, "(%p) Completing Receives...", pEPD);
		pEPD->ulEPFlags |= EPFLAGS_IN_RECEIVE_COMPLETE;	// ReceiveComplete will clear this flag when done
		ReceiveComplete(pEPD); 							// Deliver the goods,  returns with EPLock released
	}
	else 
	{
		DPFX(DPFPREP,7, "(%p) Already in ReceiveComplete, letting other thread handle receives", pEPD);
		Unlock(&pEPD->EPLock);
	}

	DPFX(DPFPREP,8, "(%p) Completing Sends...", pEPD);
	CompleteSends(pEPD);

	return DPNERR_PENDING;
}

/*
**		Receive In Order Frame
**
**		The interesting part of this function is moving frames off of the OddFrameList that
**	the new frame adjoins.  This may also be called with a NULL frame which will happen when
**	a cancelled frame is the next-in-order receive.
**
**		One result of having cancelled frames running around is that we may miss the SOM or EOM
**	flags which delimit messages.  Therefore, we must watch as we assemble messages that we do not
**	see unexpected flags,  ie a new message w/o an SOM on first frame which means that part of the
**	message must have been lost,  and the whole thing must be trashed...
**
**	** EPLOCK is HELD through this entire function **
*/

#undef DPF_MODNAME
#define DPF_MODNAME "ReceiveInOrderFrame"

VOID
ReceiveInOrderFrame(PEPD pEPD, PRCD pRCD)
{
	CBilink	*pLink;
	UINT	flag;

	AssertCriticalSectionIsTakenByThisThread(&pEPD->EPLock, TRUE);

	// Condensing Loop  WHILE (Next In-Order Frame has been received)
	do 
	{	
		ASSERT(pRCD->bSeq == pEPD->bNextReceive);

		pEPD->tLastDataFrame = pRCD->tTimestamp;		// Always keep the receive time of (N(R) - 1)
		pEPD->bLastDataRetry = (pRCD->bFrameControl & PACKET_CONTROL_RETRY);
#ifdef	DEBUG
		pEPD->bLastDataSeq = pRCD->bSeq;
#endif
		pRCD->pMsgLink = NULL;
		if(pEPD->pNewMessage == NULL)
		{				
			// Add this frame to the in-order rcv list

			// pNewMessage implies we have no current message, head or tail
			ASSERT(pEPD->pNewTail ==  NULL);		

			if(!(pRCD->bFrameFlags & PACKET_COMMAND_NEW_MSG))
			{
				// There is no NEW_MESSAGE flag on the first frame we see. We must
				// have lost the first frame or this is an invalid packet.  We can throw
				// this frame away...
				DPFX(DPFPREP,1, "(%p) NEW_MESSAGE flag not set on first frame of message, scrapping frame (%x)", pEPD, pRCD->bSeq);

				pRCD->ulRFlags |= RFLAGS_FRAME_LOST;
				pRCD->bFrameFlags |= PACKET_COMMAND_END_MSG;			// Turn this on so we will release buffer right away
			}

			// Even if we get rid of it, we will need these below
			pEPD->pNewMessage = pRCD;				
			pEPD->pNewTail = pRCD;
			pRCD->uiFrameCount = 1;
			pRCD->uiMsgSize = pRCD->uiDataSize;

			DPFX(DPFPREP,8, "(%p) Queuing Frame (NEW MESSAGE) (%x)", pEPD, pRCD->bSeq);
		}
		else
		{
			if (pRCD->bFrameFlags & PACKET_COMMAND_NEW_MSG)
			{
				// We are getting the start of a new message in the start of an existing message, drop it all
				DPFX(DPFPREP,1, "(%p) NEW_MESSAGE flag set in the middle of existing message, scrapping message (%x, %x)", pEPD, pEPD->pNewMessage->bSeq, pRCD->bSeq);

				pRCD->ulRFlags |= RFLAGS_FRAME_LOST;
				pRCD->bFrameFlags |= PACKET_COMMAND_END_MSG;			// Turn this on so we will release buffer right away
			}

			ASSERT((pEPD->pNewTail->bSeq) == (BYTE)(pRCD->bSeq - 1)); // Make sure they stay sequential
			
			pEPD->pNewTail->pMsgLink = pRCD;
			pEPD->pNewMessage->uiFrameCount++;
			pEPD->pNewMessage->uiMsgSize += pRCD->uiDataSize;
			pEPD->pNewMessage->ulRFlags |= (pRCD->ulRFlags & RFLAGS_FRAME_LOST);// UNION FRAME_LOST flag from all frames of a message
			pEPD->pNewTail = pRCD;

			DPFX(DPFPREP,8, "(%p) Queuing Frame (ON TAIL) (%x)", pEPD, pRCD->bSeq);
		}

		if(pRCD->bFrameFlags & PACKET_COMMAND_END_MSG) 
		{
			// Either this frame completes a message or we decided to drop this one above

			// All frames on the ReceiveList should now be removed and delivered

			// Get either the message we are dropping above, or the beginning of the sequence of messages we are completing
			pRCD = pEPD->pNewMessage;
			pEPD->pNewMessage = NULL;

			if(pRCD->ulRFlags & RFLAGS_FRAME_LOST)
			{
				// We need to throw this away
				DPFX(DPFPREP,7, "(%p) Throwing away message with missing frames (%x, %x)", pEPD, pRCD->bSeq, pEPD->pNewTail->bSeq);
				pEPD->pNewTail = NULL;
				DropReceive(pEPD, pRCD);
			}
			else
			{
				// We need to complete this sequence
				pRCD->blCompleteLinkage.InsertBefore( &pEPD->blCompleteList);	// place on end of Completion list
				DPFX(DPFPREP,7, "(%p) Adding msg to complete list FirstSeq=%x, LastSeq=%x QueueSize=%d", 
										pEPD, pRCD->bSeq, pEPD->pNewTail->bSeq, pEPD->uiCompleteMsgCount);
				pEPD->pNewTail = NULL;
				pEPD->uiCompleteMsgCount++;
			}
		}

		// 		Since we are allowing out of order indication of receives it is possible that frames later than
		// the new one have already been indicated.  This means that there may be bits set in the ReceiveMask
		// whose correlating frames do not need to be indicated.  The most straightforward way to implement this
		// is to leave the early-indicated frames in the list,  but mark them as INDICATED_NONSEQ.  So inside this
		// master DO loop there will be an inner DO loop which passes over INDICATED frames and just takes them off
		// the list.
		//
		//		Now its possible that a NonSeq indicated frame is still sitting on the CompleteList awaiting indication,
		// so I am using a ref count.  An extra ref is added when a frame is completed non-seq.  When a completed frame
		// is removed below we will release one reference,  and the indication code will release one reference when it
		// finishes on that end.  Happily,  we can release the actual buffers while the RCD turd is still sitting on the
		// OddFrameList.

		BOOL fIndicatedNonSeq = FALSE;
		do 
		{
			flag = pEPD->ulReceiveMask & 1;				// set flag if next frame in stream is present

			pEPD->bNextReceive += 1;					// Update receive window
			RIGHT_SHIFT_64(pEPD->ulReceiveMask2, pEPD->ulReceiveMask);// shift mask because base has changed
			DPFX(DPFPREP,7, "(%p) N(R) incremented to %x, Mask %x %x", pEPD, pEPD->bNextReceive, pEPD->ulReceiveMask2, pEPD->ulReceiveMask);

			if(flag) 
			{
				// The next frame in the sequence has arrived already since low bit of ulReceiveMask was set

				// Several things can happen here:
				// 1) We are in the middle of a message, in which case, its next piece is on the out of order list
				// 2) We have just finished a message, which leaves two subcases:
				//		a) We are beginning a new message.  In this case our first piece is on the out of order list
				//		b) Out-of-order non-sequential messages have completed while we were completing our in-order message
				//		   In this case there are some already indicated RCDs on the out of order list, and a new partial
				//		   message may or may not follow.
				pLink = pEPD->blOddFrameList.GetNext();

				ASSERT(pLink != &pEPD->blOddFrameList); // Make sure we didn't run out of RCDs on the list
				pRCD = CONTAINING_RECORD(pLink, RCD, blOddFrameLinkage);
				ASSERT_RCD(pRCD);
				pLink->RemoveFromList();							// take next frame out of OddFrameList

				// Make sure everything previous got removed from the odd frame list, and it is sorted correctly
				ASSERT(pRCD->bSeq == pEPD->bNextReceive);

				if (pRCD->ulRFlags & RFLAGS_FRAME_INDICATED_NONSEQ)
				{
					if (pEPD->pNewMessage)
					{
						// We need to throw this away
						PRCD pRCDTemp = pEPD->pNewMessage;
						pEPD->pNewMessage = NULL;

						DPFX(DPFPREP,1, "(%p) Throwing away non-ended message (%x, %x)", pEPD, pRCDTemp->bSeq, pEPD->pNewTail->bSeq);

						pEPD->pNewTail = NULL;
						DropReceive(pEPD, pRCDTemp);
					}

					fIndicatedNonSeq = TRUE;

					DPFX(DPFPREP,7, "(%p) Pulling Indicated-NonSequential message off of Out-of-Order List Seq=%x", pEPD, pRCD->bSeq);

					pEPD->tLastDataFrame = pRCD->tTimestamp;		// Always keep the receive time of (N(R) - 1)
					pEPD->bLastDataRetry = (pRCD->bFrameControl & PACKET_CONTROL_RETRY);
					DEBUG_ONLY(pEPD->bLastDataSeq = pRCD->bSeq);

					RELEASE_RCD(pRCD);
				}
				else
				{
					// In the case of cancelling one of the messages in the middle of a large message,
					// we will drop all previous, drop that one, and then we will get to a situation where we aren't
					// currently working on a new message (pNewMessage was NULL'ed in the cancelling) and the current 
					// message does not have the NEW_MSG flag, in which case we scrap it above.

					ASSERT(!fIndicatedNonSeq || (pRCD->bFrameFlags & PACKET_COMMAND_NEW_MSG) ||
						(!pEPD->pNewMessage && !(pRCD->bFrameFlags & PACKET_COMMAND_NEW_MSG)));

					// go ahead and move this to the receive list
					DPFX(DPFPREP,7, "(%p) Moving OutOfOrder frame to received list Seq=%x", pEPD, pRCD->bSeq);

					ASSERT(pRCD->bSeq == pEPD->bNextReceive);

					break; // Back to the top
				} 
			}
		} 
		while (flag);	// DO WHILE (There are still in order frames that have already arrived with no incomplete messages)
	} 
	while (flag);		// DO WHILE (There are still in order frames that have already arrived with an incomplete message)

	if((pEPD->ulReceiveMask | pEPD->ulReceiveMask2)==0)
	{
		pEPD->ulEPFlags &= ~(EPFLAGS_DELAYED_NACK);
		if(((pEPD->ulEPFlags & EPFLAGS_DELAYED_SENDMASK)==0)&&(pEPD->DelayedMaskTimer != NULL))
		{
			DPFX(DPFPREP,7, "(%p) Cancelling Delayed Mask Timer", pEPD);
			if(CancelMyTimer(pEPD->DelayedMaskTimer, pEPD->DelayedMaskTimerUnique) == DPN_OK)
			{
				DECREMENT_EPD(pEPD, "UNLOCK (cancel DelayedMask)"); // SPLock not already held
				pEPD->DelayedMaskTimer = 0;
			}
			else
			{
				DPFX(DPFPREP,7, "(%p) Cancelling Delayed Mask Timer Failed", pEPD);
			}
		}
	}
}

/*
**		Receive Out Of Order Frame
**
**		Its like the title says.  We must set the appropriate bit in the 64-bit ReceiveMask
**	and then place it into the OddFrameList in its proper sorted place.  After that,  we must
**	scan to see if a complete message has been formed and see if we are able to indicate it
**	early.
**
**	** EPLOCK is HELD through this entire function **
*/

#undef DPF_MODNAME
#define DPF_MODNAME "ReceiveOutOfOrderFrame"

VOID
ReceiveOutOfOrderFrame(PEPD pEPD, PRCD pRCD, ULONG bit)
{
	PRCD	pRCD1;
	PRCD	pRCD2;
	CBilink	*pLink;
	BYTE	NextSeq;
	ULONG	highbit;
	ULONG	Mask;
	ULONG	WorkMaskHigh;
	ULONG	WorkMaskLow;
	ULONG	MaskHigh;
	ULONG	MaskLow;
	BOOL	nack = FALSE;
	UINT	count;
	BOOL	lost = FALSE;

	UINT	frame_count = 0;
	UINT	msg_length = 0;

	DPFX(DPFPREP,8,"(%p) Received out of order frame, Seq=%x, bit=%x", pEPD, pRCD->bSeq, bit);

	// Bit shouldn't be more than 64 (MAX_RECEIVE_RANGE)
	ASSERT(bit <= MAX_RECEIVE_RANGE);

	AssertCriticalSectionIsTakenByThisThread(&pEPD->EPLock, TRUE);

	//	RECEIVE OUT OF ORDER FRAME
	//
	//  DO WE SEND IMMEDIATE ACK FOR THIS OUT OF ORDER FRAME?
	//
	//		When we receive an OutOfOrder frame it is almost certainly because the missing frame has been lost.
	// So we can accelerate the re-transmission process greatly by telling partner right away that frames
	// are missing. HOWEVER,  with a large send window we will get many mis-ordered frames for each drop,
	// but we only want to send a Negative Ack once.  SO, we will only initiate a NACK here if we have
	// created a NEW HOLE in our receive mask!
	//
	// 		First,  we will not have created a new hole unless we added to the END of the OddFrameList.
	//		Second, we will not have created a new hole unless the FIRST BIT TO THE RIGHT of the new bit
	//	is CLEAR.
	//
	//	So we will only generate an immediate NACK frame if both of the above cases are true!
	//	NOTE - if this is the only OoO frame, then we should always send a NACK
	//
	//  ANOTHER NOTE.  SP  implementation has been changed so that it frequently misorders receives in close
	// proximity.  One effect of this is that we must not immediately send a NACK for an out of order frame, but
	// instead should wait a short period (say ~5ms) and see if the missing frame hasn't shown up.

	// Make sure this RCD is within the receive window
	// NOTE: Presume SACK arrives with bNSeq of 84, N(R) is 20, and all bits are set except the one representing 20.
	// In that case, pRCD->bSeq - pEPD->bNextReceive will be equal to 63 (ie MAX_FRAME_OFFSET).
	ASSERT((BYTE)(pRCD->bSeq - pEPD->bNextReceive) <= (BYTE)MAX_FRAME_OFFSET);
		
	// We will insert frame in OddFrameList maintaining sort by Seq number
	//
	// We can optimize for most likely case,  which is new frames are added to END of list.  We can
	// check for this first case by investigating whether the new bit is the left-most bit in the mask.
	// If it is LMB,  then it trivially gets added to the END of the list.
	//
	// Please note that both this and the following algorithms assume that we have already verified
	// that the new frame is NOT already in the list

	MaskLow = pEPD->ulReceiveMask;					// Get scratch copy of Mask
	MaskHigh = pEPD->ulReceiveMask2;

	if(bit < 32)
	{									
		// Frame is within 32 of N(Rcv)	
		WorkMaskLow = 1 << bit;						// Find bit in mask for new frame
		WorkMaskHigh = 0;
		pEPD->ulReceiveMask |= WorkMaskLow;			// Set appropriate bit in mask

		// check immediately preceeding bit for NACK determination
		if( (MaskLow & (WorkMaskLow >> 1)) == 0)
		{	
			nack = TRUE;							// preceeding bit is not set
		}
	}
	else 
	{
		highbit = bit - 32;
		WorkMaskHigh = 1 << highbit;
		WorkMaskLow = 0;
		pEPD->ulReceiveMask2 |= WorkMaskHigh;		// Set appropriate bit in mask

		if(highbit)
		{
			// check preceeding bit for NACK determination
			if( (MaskHigh & (WorkMaskHigh >> 1)) == 0)
			{	
				nack = TRUE;						// preceeding bit is not set
			}
		}
		else
		{
			if( (MaskLow & 0x80000000) == 0)
			{
				nack = TRUE;
			}
		}
	}

	// Insert frame in sorted OddFrameList.
	//
	//		First test for trivial insert at tail condition.  True if new bit is LEFTMOST set bit in
	// both masks.

	if( (WorkMaskHigh > MaskHigh) || ( (MaskHigh == 0) && (WorkMaskLow > MaskLow) ) )
	{	
		// TAIL INSERTION
		DPFX(DPFPREP,7, "(%p) Received %x OUT OF ORDER - INSERT AT TAIL NRcv=%x MaskL=%x MaskH=%x",
							pEPD, pRCD->bSeq, pEPD->bNextReceive, pEPD->ulReceiveMask, pEPD->ulReceiveMask2);
		pLink = &pEPD->blOddFrameList;

		// Make sure this is either the only RCD in the list, or it is farther in the window than the last one
		ASSERT(pLink->IsEmpty() || ((BYTE)(CONTAINING_RECORD(pLink->GetPrev(), RCD, blOddFrameLinkage))->bSeq - pEPD->bNextReceive) < (BYTE)(pRCD->bSeq - pEPD->bNextReceive));
		pRCD->blOddFrameLinkage.InsertBefore( pLink);

		// Check to see if we should NACK (negative acknowledge) any frames.  We only want to NACK a given
		// frame once so we will NACK if this is the first frame added to the OOF list, or if the immediately
		// preceeding frame is missing.  First condition is trivial to test.

		if( ((MaskLow | MaskHigh) == 0) || (nack == 1) )
		{
			pEPD->ulEPFlags |= EPFLAGS_DELAYED_NACK;
			
			if(pEPD->DelayedMaskTimer == 0)
			{
				DPFX(DPFPREP,7, "(%p) Setting Delayed Mask Timer", pEPD);
				LOCK_EPD(pEPD, "LOCK (DelayedMaskTimer)");	// Bump RefCnt for timer
				SetMyTimer(SHORT_DELAYED_ACK_TIMEOUT, 5, DelayedAckTimeout, (PVOID) pEPD, &pEPD->DelayedMaskTimer, &pEPD->DelayedMaskTimerUnique);
				pEPD->tReceiveMaskDelta = GETTIMESTAMP();
			}
			else 
			{
				DPFX(DPFPREP,7, "(%p) *** DELAYED NACK *** Timer already running", pEPD);
			}
		}
	}
	else 
	{	
		// NOT TAIL INSERTION

		// This is the non-trivial case,  ie new frame goes at beginning or in middle of OddFrameList.
		// So we need to count the ONE bits that are to the RIGHT of the new bit in the ReceiveMask.
		// We will mask off bits higher then the New Bit and then do a quick bit-count...

		DPFX(DPFPREP,7, "(%p) Receive OUT OF ORDER - Walking Frame List (Seq=%x, NRcv=%x) MaskL=%x MaskH=%x", 	pEPD, pRCD->bSeq, pEPD->bNextReceive, pEPD->ulReceiveMask, pEPD->ulReceiveMask2);

		// If we are inserting into high mask,  we must count all one-bits in low mask
		//
		// We will test for the special case of all-bits-set at the outset...

		pLink = pEPD->blOddFrameList.GetNext();			// pLink = First frame in list; we will walk list as we count

		if(WorkMaskHigh)
		{
			// new frame in high mask. only count bits to right of new bit
			WorkMaskHigh -= 1;						// Convert to mask preserving all bits to right of new bit
			WorkMaskHigh &= MaskHigh;				// WMH now represents all bits to right of new bit
			while(WorkMaskHigh)
			{
				// Make sure this is farther in the window than the one we are skipping
				ASSERT(((BYTE)(CONTAINING_RECORD(pLink, RCD, blOddFrameLinkage))->bSeq - pEPD->bNextReceive) < (BYTE)(pRCD->bSeq - pEPD->bNextReceive));

				// Count bits in WMH
				Mask = WorkMaskHigh - 1;
				WorkMaskHigh &= Mask;
				pLink = pLink->GetNext();
			}
			if(MaskLow == 0xFFFFFFFF)
			{
				// special case if low mask is full
				for(count = 0; count < 32; count++)
				{
					// Make sure this is farther in the window than the one we are skipping
					ASSERT(((BYTE)(CONTAINING_RECORD(pLink, RCD, blOddFrameLinkage))->bSeq - pEPD->bNextReceive) < (BYTE)(pRCD->bSeq - pEPD->bNextReceive));

					pLink = pLink->GetNext();
				}
			}
			else
			{					
				// else count all bits in lower mask
				while(MaskLow)
				{
					// Make sure this is farther in the window than the one we are skipping
					ASSERT(((BYTE)(CONTAINING_RECORD(pLink, RCD, blOddFrameLinkage))->bSeq - pEPD->bNextReceive) < (BYTE)(pRCD->bSeq - pEPD->bNextReceive));

					Mask = MaskLow - 1;
					MaskLow &= Mask;			// Mask off low 1-bit
					pLink = pLink->GetNext();
				}
			}
		}
		else 
		{
			WorkMaskLow -= 1;
			WorkMaskLow &= MaskLow;					// WML == bits to the right of new bit

			while(WorkMaskLow)
			{
				// Make sure this is farther in the window than the one we are skipping
				ASSERT(((BYTE)(CONTAINING_RECORD(pLink, RCD, blOddFrameLinkage))->bSeq - pEPD->bNextReceive) < (BYTE)(pRCD->bSeq - pEPD->bNextReceive));

				Mask = WorkMaskLow - 1;
				WorkMaskLow &= Mask;				// Mask off low 1-bit
				pLink = pLink->GetNext();
			}
		}

		// Make sure this is farther in the window than the last one
		ASSERT(((BYTE)(CONTAINING_RECORD(pLink->GetPrev(), RCD, blOddFrameLinkage))->bSeq - pEPD->bNextReceive) < (BYTE)(pRCD->bSeq - pEPD->bNextReceive));

		pRCD->blOddFrameLinkage.InsertBefore( pLink);		// Insert new frame in sorted list

	}  // Receive not at tail

#ifdef DEBUG
	// Dump the contents of the Out of Order Frame List for verification.  There are at most 64 frames.
	{
		BYTE bCurSeq = pEPD->bNextReceive + 1;
		ULONG64 ulMask = ((ULONG64)pEPD->ulReceiveMask2 << 32) | ((ULONG64)pEPD->ulReceiveMask);
		CBilink* pTemp;
		TCHAR szOOFL[256];
		szOOFL[0] = 0;
		pTemp = pEPD->blOddFrameList.GetNext();
		while (pTemp != &pEPD->blOddFrameList)
		{
			while (ulMask != 0 && !(ulMask & 1))
			{
				ulMask >>= 1;
				bCurSeq++;
			}
			ASSERT(ulMask != 0);

			PRCD pRCDTemp = CONTAINING_RECORD(pTemp, RCD, blOddFrameLinkage);
			ASSERT_RCD(pRCDTemp);

			ASSERT(bCurSeq == pRCDTemp->bSeq);

			_stprintf(szOOFL, _T("%s %02x"), szOOFL, pRCDTemp->bSeq);

			ulMask >>= 1;
			bCurSeq++;
			pTemp = pTemp->GetNext();
		}
		DPFX(DPFPREP, 7, "OOFL contents: %s", szOOFL);
	}
#endif // DEBUG

	// 	**	Non-Sequential Indication
	//
	//		This is the Non-Trivial implementation of non-sequential receive indication.
	//	We will work from the assumption that we  only need to complete messages that are touched by the new frame.
	//	So we must back up in the OddFrame list until we see either a gap or a Start of Message marker. Then we must work
	// 	forward looking for an End of Message...
	//
	//		One more complication is the fact that dropped packets might in the list via place-holding dummies.  Since we
	//	do not know what SOM/EOM flags would have been present on a dropped frame,  we can consider them to have BOTH flags.
	//	Then we also need to be aware that frames bordering on dropped frames without a delimiter (SOM or EOM) are fragments
	//	and therefore count as dropped data too.  I think to keep this from getting too complex,  we wont probe further for
	//	neighbors of lost data frames.  We will discover them when we are building a message later.
	//
	//	pLink = Item after new element in Out of Order list
	//	pRCD  = new Item

	// IF this frame is not marked as SEQUENTIAL
	if((pRCD->bFrameFlags & PACKET_COMMAND_SEQUENTIAL)==0)
	{	
		DPFX(DPFPREP,7, "(%p) Received Non-Seq %x out of order; flags=%x", pEPD, pRCD->bSeq, pRCD->bFrameFlags);
		NextSeq = pRCD->bSeq;
			
		// NOTE: The first pLink will be the passed in RCD so we will have included that in the frame_count and msg_length after leaving this while
		while ( (pLink = pLink->GetPrev()) != &pEPD->blOddFrameList )
		{
			pRCD1 = CONTAINING_RECORD(pLink, RCD, blOddFrameLinkage);
			ASSERT_RCD(pRCD1);

			frame_count++;
			msg_length += pRCD1->uiDataSize;

			if((pRCD1->bFrameFlags & PACKET_COMMAND_NEW_MSG) || (pRCD1->bSeq != NextSeq))
			{
				break;		// Stop probing when we find a NEW_MSG flag OR a gap in the frame sequence numbers
			}
			--NextSeq;
		}

		// We have either found a NEW_MSG or a sequence gap.  If its a NEW_MSG, then we probe forward for an END_MSG
		if((pRCD1->bFrameFlags & PACKET_COMMAND_NEW_MSG) && (pRCD1->bSeq == NextSeq))
		{
			// So far so good.  We have a sequential message start frame
			//
			//	pRCD  = frame just arrived
			//	pRCD1 = Start of message frame
			//	pLink = Start of message linkage

			pLink = &pRCD->blOddFrameLinkage;
			NextSeq = pRCD->bSeq;

			// Look for the message end or a sequence gap
			while ( ( (pRCD->bFrameFlags & PACKET_COMMAND_END_MSG)==0 ) && (pRCD->bSeq == NextSeq))
			{
				// Stop if we hit the end of the OddFrameList
				if((pLink = pLink->GetNext()) == &pEPD->blOddFrameList)
				{
					break;
				}

				// NOTE: the first pLink here will be the one after the passed in RCD.  If there is a gap that won't 
				// matter because we are out of here after the next if.  If it is the next message we will continue until
				// we hit the END_MSG and have a proper frame_count and msg_length.
				pRCD = CONTAINING_RECORD(pLink, RCD, blOddFrameLinkage);
				ASSERT_RCD(pRCD);
				frame_count++;
				msg_length += pRCD->uiDataSize;
				NextSeq++;
			}

			// pLink should not be used after this point due to the way the above while could have left it either valid
			// or at &pEPD->blOddFrameList.
			pLink = NULL;

			if((pRCD->bFrameFlags & PACKET_COMMAND_END_MSG) && (pRCD->bSeq == NextSeq))
			{
				// We have completed a message
				//
				// pRCD1 = First frame in message
				// pRCD = Last frame in message

				DPFX(DPFPREP,7, "(%p) Completed Non-Seq Msg: First=%x, Last=%x", pEPD, pRCD1->bSeq, pRCD->bSeq);

				lost = FALSE;

				pRCD->ulRFlags |= RFLAGS_FRAME_INDICATED_NONSEQ;
				pRCD->pMsgLink = NULL;
				lost |= pRCD->ulRFlags & RFLAGS_FRAME_LOST;
				
				// Get the pointer to the next to last message so we can remove the last
				pLink = pRCD->blOddFrameLinkage.GetPrev();
				LOCK_RCD(pRCD); // ReceiveInOrderFrame must remove this

				// Walk from the last message to the first message accumulating lost flags, linking messages, 
				// setting indicated flag, and pulling off of the odd frame list
				while (pRCD != pRCD1)
				{
					ASSERT(pLink != &pEPD->blOddFrameList); // Make sure we didn't run out of RCDs on the list
					pRCD2 = CONTAINING_RECORD(pLink, RCD, blOddFrameLinkage);
					ASSERT_RCD(pRCD2);
					pRCD2->pMsgLink = pRCD;
					LOCK_RCD(pRCD2); // ReceiveInOrderFrame must remove this

					pRCD2->ulRFlags |= RFLAGS_FRAME_INDICATED_NONSEQ;
					lost |= pRCD2->ulRFlags & RFLAGS_FRAME_LOST;
					pLink = pRCD2->blOddFrameLinkage.GetPrev();

					pRCD = pRCD2;
				}
				
				// Both RCD and RCD1 point to the first message now

				// If any were lost, drop the receive, otherwise complete it
				if(!lost)
				{
					pRCD->uiFrameCount = frame_count;
					pRCD->uiMsgSize = msg_length;
					DPFX(DPFPREP,7, "(%p) Adding msg to complete list FirstSeq=%x QueueSize=%d", pEPD, pRCD->bSeq, pEPD->uiCompleteMsgCount);
					pRCD->blCompleteLinkage.InsertBefore( &pEPD->blCompleteList);
					pEPD->uiCompleteMsgCount++;
				}
				else
				{
					DPFX(DPFPREP,7, "(%p) Complete Non-Seq MSG is dropped due to missing frames", pEPD);
					DropReceive(pEPD, pRCD);
				}
			}
		} // else  there is nothing to complete at this time...
	}	// IF NON SEQUENTIAL
}

/*
**		Drop Receive
**
**			One or more frames composing a message have been dropped,  so the entire message can be scrapped.
**		If this was determined during an out of order receive then the RCDs will remain on the OddFrameList
**		as usual.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "DropReceive"

VOID
DropReceive(PEPD pEPD, PRCD pRCD)
{
	PRCD 					pNext;
	PSPRECEIVEDBUFFER		pRcvBuff = NULL;
	
	while(pRCD != NULL)
	{
		ASSERT_RCD(pRCD);

		if (pRCD->bFrameFlags & PACKET_COMMAND_RELIABLE)
		{
			DPFX(DPFPREP,1, "(%p) Dropping G receive frame %x!!!", pEPD, pRCD->bSeq);
		}
		else
		{
			DPFX(DPFPREP,7, "(%p) Dropping NG receive frame %x", pEPD, pRCD->bSeq);
		}

		RELEASE_SP_BUFFER(pRCD->pRcvBuff);

		pNext = pRCD->pMsgLink;
		RELEASE_RCD(pRCD);
		pRCD = pNext;
	}
	if(pRcvBuff != NULL)
	{
		DPFX(DPFPREP,DPF_CALLOUT_LVL, "(%p) Calling SP->ReturnReceiveBuffers, pSPD[%p]", pEPD, pEPD->pSPD);
		IDP8ServiceProvider_ReturnReceiveBuffers(pEPD->pSPD->IISPIntf, pRcvBuff);
	}
}

/*
**		Receive Complete
**
**		We have received an entire reliable message,  potentially spanning
**	multiple messages.  We are still on the receive thread right now so depending
**	upon our desired indication behavior we will either indicate it directly or
**	else queue it to be indicated on a background thread of some sort.
**
**		Messages spanning multiple frames (for now) will be copied into a contiguous
**	buffer for delivery.  CODEWORK -- Server implementations should be able to receive
**	large messages as buffer chains (or arrays of BufDescs).
**
**		This is also where we must notice that an End Of Stream flag is set in a message,
**	indicating that the connection is being closed.
**
**	*** CALLED WITH EPD->STATELOCK HELD *** RETURNS WITH STATELOCK RELEASED  ***
*/

#undef DPF_MODNAME
#define DPF_MODNAME "ReceiveComplete"

VOID
ReceiveComplete(PEPD pEPD)
{
	CBilink					*pLink;
	PRCD					pRCD;
	PRCD					pNext;
	PSPRECEIVEDBUFFER		pRcvBuff = NULL;
	PBIGBUF					pBuf;
	PBYTE					write;
	UINT					length;
	UINT					frames;
	DWORD					flag;
	UINT					MsgSize;
	HRESULT					hr;

	AssertCriticalSectionIsTakenByThisThread(&pEPD->EPLock, TRUE);

	while((pLink = pEPD->blCompleteList.GetNext()) != &pEPD->blCompleteList)
	{
		pLink->RemoveFromList();
		ASSERT(pEPD->uiCompleteMsgCount > 0);
		pEPD->uiCompleteMsgCount--;
		
		Unlock(&pEPD->EPLock);
		pRCD = CONTAINING_RECORD(pLink, RCD, blCompleteLinkage);
		ASSERT_RCD(pRCD);
		
		// Handle easy case first
		if(pRCD->uiFrameCount == 1) // message is only 1 frame
		{						
			if(pRCD->uiDataSize > 0)
			{
				pEPD->uiMessagesReceived++;
				
				if(pRCD->bFrameFlags & PACKET_COMMAND_RELIABLE)
				{
					pEPD->uiGuaranteedFramesReceived++;
					pEPD->uiGuaranteedBytesReceived += pRCD->uiDataSize;
				}
				else
				{
					pEPD->uiDatagramFramesReceived++;
					pEPD->uiDatagramBytesReceived += pRCD->uiDataSize;
				}
				
				pRCD->pRcvBuff->dwProtocolData = RBT_SERVICE_PROVIDER_BUFFER;
				pRCD->pRcvBuff->pServiceProviderDescriptor = pEPD->pSPD;
				flag = (((DWORD) pRCD->bFrameFlags) & (PACKET_COMMAND_USER_1 | PACKET_COMMAND_USER_2)) * (DN_SENDFLAGS_SET_USER_FLAG / PACKET_COMMAND_USER_1);

				DEBUG_ONLY(InterlockedIncrement(&pEPD->pSPD->pPData->ThreadsInReceive));
				DEBUG_ONLY(InterlockedIncrement(&pEPD->pSPD->pPData->BuffersInReceive));
				DPFX(DPFPREP,DPF_CALLOUT_LVL, "(%p) Calling Core->IndicateReceive, pRCD[%p], Core Context[%p]", pEPD, pRCD, pEPD->Context);
				hr = pEPD->pSPD->pPData->pfVtbl->IndicateReceive(pEPD->pSPD->pPData->Parent, pEPD->Context, pRCD->pbData, pRCD->uiDataSize, pRCD->pRcvBuff, flag);
				if(hr == DPN_OK)
				{
					RELEASE_SP_BUFFER(pRCD->pRcvBuff);		// Really only queues it to be released
					DEBUG_ONLY(InterlockedDecrement(&pEPD->pSPD->pPData->BuffersInReceive));
				}
				else
				{
					ASSERT(hr == DPNERR_PENDING);

					// The Core owns it now and is responsible for calling DNPReleaseReceiveBuffer to free it
					pRCD->pRcvBuff = NULL;
				}
				DEBUG_ONLY(InterlockedDecrement(&pEPD->pSPD->pPData->ThreadsInReceive));
			}
			else 
			{
				//	If DataSize == 0 & EOS is not set,  then this was a keep alive message and is ignored
				if(pRCD->bFrameControl & PACKET_CONTROL_END_STREAM)
				{  
					// END OF STREAM indicated
					DPFX(DPFPREP,7, "(%p) Processing EndOfStream, pRCD[%p]", pEPD, pRCD);
					ProcessEndOfStream(pEPD);
				}
				
				RELEASE_SP_BUFFER(pRCD->pRcvBuff);			// Really only queues it to be released
			}
			
			RELEASE_RCD(pRCD);								// Release reference for Complete Processing
		}
		else // Message spans multiple frames
		{											
			// Multiple buffers.  Need to copy data into contiguous buffer.
			if((MsgSize = pRCD->uiMsgSize) <= SMALL_BUFFER_SIZE)
			{
				pBuf = static_cast<PBIGBUF>( BufPool->Get(BufPool) );
			}
			else if (MsgSize <= MEDIUM_BUFFER_SIZE)
			{
				pBuf = static_cast<PBIGBUF>( MedBufPool->Get(MedBufPool) );
			}
			else if (MsgSize <= LARGE_BUFFER_SIZE)
			{
				pBuf = static_cast<PBIGBUF>( BigBufPool->Get(BigBufPool) );
			}
			else
			{
				DPFX(DPFPREP,7, "(%p) RECEIVE HUGE MESSAGE", pEPD);
				// Receive is larger then our biggest static receive buffer.  This means we have to allocate a dynamic buffer.
				pBuf = (PBIGBUF) DNMalloc(MsgSize + sizeof(DYNBUF));
				if(pBuf)
				{
					pBuf->Type = RBT_DYNAMIC_BUFFER;
				}	
			}
			
			if(pBuf == NULL)
			{
				DPFX(DPFPREP,0, "MEMORY ALLOC FAILED.  Cannot deliver data");
				while(pRCD != NULL)
				{
					ASSERT_RCD(pRCD);
					pNext = pRCD->pMsgLink;
					RELEASE_SP_BUFFER(pRCD->pRcvBuff);
					RELEASE_RCD(pRCD);
					pRCD = pNext;
				}
				Lock(&pEPD->EPLock);
				continue;								// blow it off!
			}
			write = pBuf->data;							// initialize write pointer
			length = 0;
			frames = 0;
			while(pRCD != NULL)
			{
				ASSERT_RCD(pRCD);
				memcpy(write, pRCD->pbData, pRCD->uiDataSize);
				write += pRCD->uiDataSize;
				length += pRCD->uiDataSize;
				frames++;
				pNext = pRCD->pMsgLink;
				flag = (DWORD) pRCD->bFrameFlags;
				RELEASE_SP_BUFFER(pRCD->pRcvBuff);
				RELEASE_RCD(pRCD);
				pRCD = pNext;
			}
			
			pEPD->uiMessagesReceived++;
			if(flag & PACKET_COMMAND_RELIABLE)
			{
				pEPD->uiGuaranteedFramesReceived += frames;
				pEPD->uiGuaranteedBytesReceived += length;
			}
			else
			{
				pEPD->uiDatagramFramesReceived += frames;
				pEPD->uiDatagramBytesReceived += length;
			}
			
			flag = (flag & (PACKET_COMMAND_USER_1 | PACKET_COMMAND_USER_2)) * (DN_SENDFLAGS_SET_USER_FLAG / PACKET_COMMAND_USER_1);
			DPFX(DPFPREP,DPF_CALLOUT_LVL, "(%p) Calling Core->IndicateReceive, Core Context[%p]", pEPD, pEPD->Context);
			hr = pEPD->pSPD->pPData->pfVtbl->IndicateReceive(pEPD->pSPD->pPData->Parent, pEPD->Context, pBuf->data, length, pBuf, flag);

			if(hr == DPN_OK)
			{
				if(pBuf->Type == RBT_PROTOCOL_BUFFER)
				{
					pBuf->Owner->Release(pBuf->Owner, pBuf);
				}
				else 
				{
					DNFree(pBuf);
				}
			}
			else
			{
				ASSERT(hr == DPNERR_PENDING);
			}
		}
		Lock(&pEPD->EPLock);
	}

	ASSERT(pEPD->blCompleteList.IsEmpty());
	pEPD->ulEPFlags &= ~(EPFLAGS_IN_RECEIVE_COMPLETE);	// Clear this before releasing Lock final time
	Unlock(&pEPD->EPLock);

	if(pRcvBuff != NULL)
	{
		DPFX(DPFPREP,DPF_CALLOUT_LVL, "(%p) Calling SP->ReturnReceiveBuffers, pSPD[%p]", pEPD, pEPD->pSPD);
		IDP8ServiceProvider_ReturnReceiveBuffers(pEPD->pSPD->IISPIntf, pRcvBuff);
	}
}


/*
**		Process Send Mask
**
**		The send mask is what our partner uses to tell us to stop waiting for particular frames.
**	This will happen after an Unreliable frame is dropped.  Instead of retransmitting the unreliable
**	frame,  the sender will forward the appropriate bit in a send mask.  In this routine,  we attempt
**	to update our receive state pursuant to the newly received mask.
**
**		THIS IS CALLED WITH STATELOCK HELD AND RETURNS WITH STATELOCK HELD
**
**		suffice it to say that we should not release statelock anywhere in the following
*/

#undef DPF_MODNAME
#define DPF_MODNAME "ProcessSendMask"

VOID
ProcessSendMask(PEPD pEPD, BYTE bSeq, ULONG MaskLow, ULONG MaskHigh, DWORD tNow)
{
	INT		deltaS;
	ULONG	workmaskS;
	BYTE	bThisFrame;
	UINT	skip;

	ASSERT(MaskLow | MaskHigh);

	DPFX(DPFPREP,7, "(%p) PROCESS SEND MASK  N(R)=%x, bSeq=%x, MaskL=%x, MaskH=%x", pEPD, pEPD->bNextReceive, bSeq, MaskLow, MaskHigh);

	// The mask can only refer to frames earlier than the Seq number in this frame.  So if this frame
	// is the next In-Order then the mask can have nothing interesting in it.
	//
	// The SendMask is coded with decending frame numbers starting at the Seq in this frame - 1.
	// The ReceiveMask is coded with ascending frame numbers start at N(Rcv) + 1.
	//
	// We will walk forward through the rcvmask and backward through the sendmask looking for the magic combo
	// of a bit clear in the rcvmask and the corresponding bit set in the sendmask.  For each of these matches,
	// a dummy cancel frame can be 'received' for that sequence number.
	//
	// This would be fairly straightforward if it wasn't for the fact that both masks are 64 bits so the code has
	// to track which DWORD of each mask we are dealing with at any given time. 
	//
	// NOTE: It is perfectly legitimate for a SACK to come in with a bNSeq at MAX_FRAME_OFFSET from pEPD->bNextReceive.  Consider
	// the case where pEPD->bNextReceive is 0 and the sender has sent and timed out 0-63.  A SACK would arrive with a bNSeq of 64
	// and both masks fully set.

top:

	if (bSeq != pEPD->bNextReceive)
	{
		deltaS = (INT) (((BYTE)(bSeq - pEPD->bNextReceive)) - 1);			// count of frames between first missing frame and sequence base of mask
		bThisFrame = pEPD->bNextReceive;

		if ( deltaS <= MAX_FRAME_OFFSET ) 
		{
			// If the difference is greater then 32 frames then we need to look at the high mask first and
			// then fall through to the low mask.  Otherwise,  we can ignore the highmask and start with the low.
			while((deltaS > 31) && (MaskHigh)) // Any work to do in the upper bits?
			{
				workmaskS = 1 << (deltaS - 32); 	// walks bit positions backward in send mask
				
				// See if the next frame we are interested in is covered by this mask
				if(workmaskS & MaskHigh)
				{
					CancelFrame(pEPD, bThisFrame, tNow);
					MaskHigh &= ~workmaskS;

					// N(R) may have been bumped up multiple times by CancelFrame, reset to make sure we work with
					// up to date information.
					goto top;
				}
				else
				{
					bThisFrame++;
					deltaS--;
				}
			}

			if(deltaS > 31)
			{
				skip = deltaS - 31;								// how many bit positions did we skip
				bThisFrame += (BYTE) skip;
				deltaS -= skip;
			}

			while((deltaS >= 0) && (MaskLow)) // Any work to do in the lower bits?
			{
				workmaskS = 1 << deltaS;

				if(workmaskS & MaskLow)
				{
					CancelFrame(pEPD, bThisFrame, tNow);
					MaskLow &= ~workmaskS;

					// N(R) may have been bumped up multiple times by CancelFrame, reset to make sure we work with
					// up to date information.
					goto top;
				}
				else
				{
					bThisFrame++;
					deltaS--;
				}
			}
		}
	}

	// We need to ACK every time a send mask.  Consider the case of one way Non-Guaranteed traffic.  If data or an ACK gets lost,
	// this will be the only way we get back in sync with the other side.

	// If timer is not running better start it now
	if(pEPD->DelayedAckTimer == 0)
	{	
		LOCK_EPD(pEPD, "LOCK (DelayedAckTimer)");		// Bump RefCnt for timer
		pEPD->ulEPFlags |= EPFLAGS_DELAY_ACKNOWLEDGE;
		DPFX(DPFPREP,7, "(%p) Setting Delayed Ack Timer", pEPD);
		SetMyTimer(DELAYED_ACK_TIMEOUT, 0, DelayedAckTimeout, (PVOID) pEPD, &pEPD->DelayedAckTimer, &pEPD->DelayedAckTimerUnique);
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "BuildCancelledRCD"

PRCD
BuildCancelledRCD(PEPD pEPD, BYTE bSeq, DWORD tNow)
{
	PRCD	pRCD;
	
	if((pRCD = static_cast<PRCD> (RCDPool->Get(RCDPool))) == NULL)
	{
		DPFX(DPFPREP,0, "Failed to allocate RCD");
		return NULL;
	}
	
 	pRCD->bSeq = bSeq;
	pRCD->bFrameFlags = PACKET_COMMAND_NEW_MSG | PACKET_COMMAND_END_MSG;
 	pRCD->bFrameControl = 0;
	pRCD->pbData = NULL;
	pRCD->uiDataSize = 0;
	pRCD->tTimestamp = tNow;
	pRCD->pRcvBuff = NULL;
	pRCD->ulRFlags = RFLAGS_FRAME_LOST;

	return pRCD;
}

/*			Cancel Frame
**
**		An unreliable frame has been reported as lost by sender.  This means we should consider it acknowledged
**	and remove it from our receive window.  This may require us to place a dummy receive descriptor in the OddFrameList
**	to hold its place until the window moves past it.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "CancelFrame"

BOOL
CancelFrame(PEPD pEPD, BYTE bSeq, DWORD tNow)
{
	PRCD	pRCD;
	ULONG	bit;

	DPFX(DPFPREP,7, "(%p) CANCEL FRAME: Seq=%x", pEPD, bSeq);

	AssertCriticalSectionIsTakenByThisThread(&pEPD->EPLock, TRUE);

	// Trivial case is when the cancelled frame is at the front of the window.  In this case we can complete not only
	// this frame but any contiguous frames following it in the OddFrameList
	
	if(pEPD->bNextReceive == bSeq)
	{
		if((pRCD = BuildCancelledRCD(pEPD, bSeq, tNow)) == NULL)
		{
			return FALSE;
		}
		ReceiveInOrderFrame(pEPD, pRCD);
	}

	// Here we have to place a dummy node on the OddFrameList to represent this frame.
	else 
	{
		// bit location in mask for this frame
		bit = (BYTE) ((bSeq - pEPD->bNextReceive) - 1);						

		// Make sure this is not a duplicate frame
		if( ((bit < 32) && (pEPD->ulReceiveMask & (1 << bit))) || ((bit > 31) && (pEPD->ulReceiveMask2 & (1 << (bit - 32)))) ) 
		{
			DPFX(DPFPREP,7, "(%p) Received CancelMask for frame that's already received Seq=%x", pEPD, bSeq);
			return FALSE;
		}
		
		if((pRCD = BuildCancelledRCD(pEPD, bSeq, tNow)) == NULL)
		{
			return FALSE;
		}
		ReceiveOutOfOrderFrame(pEPD, pRCD, bit);
	}

	return TRUE;
}


/*
**		Release Receive Buffer
**
**		The core calls this function to return buffers previously handed
**	over in an IndicateUserData call.  This call may be made before the
**	actual indication returns.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "DNPReleaseReceiveBuffer"

HRESULT
DNPReleaseReceiveBuffer(HANDLE hBuffer)
{
	union 
	{
		PBIGBUF 			pBuf;
		PSPRECEIVEDBUFFER	pRcvBuff;
	}					pBuffer;

	PSPD				pSPD;

	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: hBuffer[%p]", hBuffer);

	pBuffer.pBuf = (PBIGBUF) hBuffer;
	
	switch(pBuffer.pBuf->Type)
	{
		case RBT_SERVICE_PROVIDER_BUFFER:
			pSPD = (PSPD) pBuffer.pRcvBuff->pServiceProviderDescriptor;
			ASSERT_SPD(pSPD);

			DEBUG_ONLY(InterlockedDecrement(&pSPD->pPData->BuffersInReceive));

			pBuffer.pRcvBuff->pNext = NULL;

			DPFX(DPFPREP,DPF_CALLOUT_LVL, "Calling SP->ReturnReceiveBuffers, pRcvBuff[%p], pSPD[%p]", pBuffer.pRcvBuff, pSPD);
			IDP8ServiceProvider_ReturnReceiveBuffers(pSPD->IISPIntf, pBuffer.pRcvBuff);
			break;
			
		case RBT_PROTOCOL_BUFFER:
			pBuffer.pBuf->Owner->Release(pBuffer.pBuf->Owner, pBuffer.pBuf);
			break;

		case RBT_DYNAMIC_BUFFER:
			DNFree(hBuffer);
			break;

		default:
			DPFX(DPFPREP,0, "RELEASE RECEIVE BUFFER CALLED WITH BAD PARAMETER");
			return DPNERR_INVALIDPARAM;
	}
	
	return DPN_OK;
}

/*
**		Complete Sends
**
**		Reliable sends are completed upon acknowlegement.  Acknowlegements are discovered inside
**	the UpdateXmitState routine while walking through the pending window.  Since the actual completion
**	event requires the user to be called,  state can change.  So the easiest thing to do is defer these
**	completion callbacks until we are finished walking and can release any state locks.  Also,  this way
**	we can defer the callbacks until after we have indicated any data which the acks were piggybacking on,
**	something which ought to have priority anyway.
**
**		So we will place all completed reliable sends onto a complete list and after all other processing
**	we will come here and callback everything on the list.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "CompleteSends"

VOID CompleteSends(PEPD pEPD)
{
	PMSD	pMSD;
	CBilink	*pLink;

	Lock(&pEPD->EPLock);

	pLink = pEPD->blCompleteSendList.GetNext();

	while((pEPD->ulEPFlags & EPFLAGS_COMPLETE_SENDS) &&
		  (pLink != &pEPD->blCompleteSendList))
	{
		pMSD = CONTAINING_RECORD(pLink, MSD, blQLinkage);
		ASSERT_MSD(pMSD);

		if(pMSD->CommandID != COMMAND_ID_SEND_DATAGRAM)
		{
			// Reliables, Keepalives, and Disconnects will come down this path
			if(pMSD->ulMsgFlags2 & (MFLAGS_TWO_SEND_COMPLETE|MFLAGS_TWO_ABORT))
			{
				if (pMSD->uiFrameCount == 0)
				{
					DPFX(DPFPREP, DPF_FRAMECNT_LVL, "Completing, pMSD[%p], framecount[%u]", pMSD, pMSD->uiFrameCount);
					pLink->RemoveFromList();

					Unlock(&pEPD->EPLock);
					Lock(&pMSD->CommandLock);
					CompleteReliableSend(pEPD->pSPD, pMSD, DPN_OK); // This releases the CommandLock
					
					Lock(&pEPD->EPLock);
				
					pLink = pEPD->blCompleteSendList.GetNext();
				}
				else
				{
					DPFX(DPFPREP, DPF_FRAMECNT_LVL, "Frames still out, pMSD[%p], framecount[%u]", pMSD, pMSD->uiFrameCount);
					pLink = pLink->GetNext();
				}
			}
			else 
			{
				DPFX(DPFPREP, DPF_FRAMECNT_LVL, "Message not yet complete, pMSD[%p], framecount[%u]", pMSD, pMSD->uiFrameCount);
				break;		// These will complete in order, so stop checking when we see one that's not Complete.
			}
		}
		else
		{
			// Datagrams will come down this path
			DPFX(DPFPREP, DPF_FRAMECNT_LVL, "Skipping datagram frame on complete list, pMSD[%p], framecount[%u]", pMSD, pMSD->uiFrameCount);
			pLink = pLink->GetNext();
		}
	}
#ifdef DEBUG
	// In DEBUG we want to assert that no one one the list could have been completed if we are leaving here
	pLink = pEPD->blCompleteSendList.GetNext();
	while(pLink != &pEPD->blCompleteSendList)
	{
		pMSD = CONTAINING_RECORD(pLink, MSD, blQLinkage);
		ASSERT_MSD(pMSD);

		ASSERT(!(pMSD->ulMsgFlags2 & (MFLAGS_TWO_SEND_COMPLETE|MFLAGS_TWO_ABORT)) || pMSD->uiFrameCount != 0);

		pLink = pLink->GetNext();
	}
#endif

	pEPD->ulEPFlags &= ~(EPFLAGS_COMPLETE_SENDS);
	
	Unlock(&pEPD->EPLock);
}

/*
**		Lookup CheckPoint
**
**		Walk the EndPoint's list of active CPs looking for one with the provided
**	response correlator.
**		We keep the CKPT queue sorted by age so the matches should be at the front
**	of the queue.  So as we pass by entries at the head we will check the age of each
**	and timeout the ones that are 4(RTT) or greater.
**		Since DG drops are reported by the partner,  we dont need to do any booking about
**	the orphaned checkpoints.
**
**		*!* This link's StateLock must be held on entry
*/

#ifdef	DEBUG
#undef DPF_MODNAME
#define DPF_MODNAME "DumpChkPtList"

VOID
DumpChkPtList(PEPD pEPD)
{
	CBilink	*pLink;
	PCHKPT	pCP;

	AssertCriticalSectionIsTakenByThisThread(&pEPD->EPLock, TRUE);

	DPFX(DPFPREP,1, "==== DUMPING CHECKPOINT LIST ==== (pEPD = %p)", pEPD);
	
	pLink = pEPD->blChkPtQueue.GetNext();
	while(pLink != &pEPD->blChkPtQueue) 
	{
		pCP = CONTAINING_RECORD(pLink, CHKPT, blLinkage);
		DPFX(DPFPREP,1, "(%p) MsgID=%x; Timestamp=%x", pEPD, pCP->bMsgID, pCP->tTimestamp);
		pLink = pLink->GetNext();
	}
}
#endif

#undef DPF_MODNAME
#define DPF_MODNAME "LookupCheckPoint"

PCHKPT LookupCheckPoint(PEPD pEPD, BYTE bRspID)
{
	CBilink	*pLink;
	PCHKPT	pCP;

	AssertCriticalSectionIsTakenByThisThread(&pEPD->EPLock, TRUE);

	pCP = CONTAINING_RECORD((pLink = pEPD->blChkPtQueue.GetNext()), CHKPT, blLinkage);
	while(pLink != &pEPD->blChkPtQueue) 
	{
		// Look for checkpoint that matches correlator
		if(pCP->bMsgID == bRspID)
		{	
			pLink->RemoveFromList();
			return pCP;		
		}
		// We have passed the spot for this correlator!		
		else if ((bRspID - pCP->bMsgID) & 0x80)
		{				
			DPFX(DPFPREP,1, "(%p) CHECKPOINT NOT FOUND - Later Chkpt found in list (%x)", pEPD, bRspID);
			return NULL;
		}
		else 
		{
			pLink = pLink->GetNext();								// Remove ChkPts prior to the one received
			pCP->blLinkage.RemoveFromList();							// ..target and remove the stale ones.
			ChkPtPool->Release(ChkPtPool, pCP);					// we expect them to complete in order of queue
			pCP = CONTAINING_RECORD(pLink, CHKPT, blLinkage);
		}
	}

	DPFX(DPFPREP,1, "(%p) CHECKPOINT NOT FOUND -  EXHAUSTED LIST W/O MATCH (%x)", pEPD, bRspID);
#ifdef	DEBUG
	DumpChkPtList(pEPD);
#endif
	return NULL;
}

#undef DPF_MODNAME
#define DPF_MODNAME "FlushCheckPoints"

VOID FlushCheckPoints(PEPD pEPD)
{
	PCHKPT	pCP;

	AssertCriticalSectionIsTakenByThisThread(&pEPD->EPLock, TRUE);

	while(!pEPD->blChkPtQueue.IsEmpty())
	{
		pCP = CONTAINING_RECORD(pEPD->blChkPtQueue.GetNext(), CHKPT, blLinkage);
		pCP->blLinkage.RemoveFromList();
		ChkPtPool->Release(ChkPtPool, pCP);
	}
}

/*
**		Process End Of Stream
**
**		Our partner has initiated an orderly link termination.  He will not be
**	sending us any more data.  We are allowed to finish sending any data in our
**	pipeline, but should not allow any new sends to be accepted.  When our send
**	pipeline is emptied,  we should send an EOS frame and take down our
**	link.  Easiest way to do this is enqueue the EOS at the end of send queue now.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "ProcessEndOfStream"

VOID ProcessEndOfStream(PEPD pEPD)
{
	PMSD	pMSD;

	Lock(&pEPD->EPLock);
	
	// Since an EOS comes in as a data packet, and we must be Connected to receive data, we know
	// we can now be in either the Connected or Terminating state.  If we are in the Terminating
	// state, someone is already attempting to destroy the link and we will ignore this EOS, and
	// let that termination finish.  Otherwise, we expect to be in the Connected state, and this
	// is a normal disconnect.
	if (pEPD->ulEPFlags & EPFLAGS_STATE_TERMINATING)
	{
		DPFX(DPFPREP,7, "(%p) Received EndOfStream on an already terminating link, ignoring", pEPD);
		Unlock(&pEPD->EPLock);
		return;
	}
	ASSERT(pEPD->ulEPFlags & EPFLAGS_STATE_CONNECTED);

	DPFX(DPFPREP,7, "(%p) Process EndOfStream", pEPD);

	// Have we started closing on this side?
	if(!(pEPD->ulEPFlags & EPFLAGS_RECEIVED_DISCONNECT))
	{			
		// Our side has not started closing yet,  so our partner must have initiated a Disconnect.
		// We are allowed to finish sending all data in our pipeline,  but we should not accept
		// any new data.  We must deliver an indication to the application telling him that
		// Disconnection is now underway.
		//
		// Please note that we do not set the TERMINATING flag until the Disconnecting indication
		// returns.  This allows the application to send any final messages (last words) before
		// the gate is slammed shut.

		DPFX(DPFPREP,7, "(%p) Partner Disconnect received (refcnt=%d)", pEPD, pEPD->lRefCnt);

		// Don't let anyone else in here again.
		pEPD->ulEPFlags |= EPFLAGS_RECEIVED_DISCONNECT;	

		// Force 3 disconnect ACKs now since we are going away.
		// Setting fFinalAck to TRUE on last ACK so CommandComplete will drop if appropriate
		DPFX(DPFPREP,7, "(%p) ACK'ing Partner's Disconnect", pEPD);
		SendAckFrame(pEPD, 0);	
		SendAckFrame(pEPD, 0);			
		SendAckFrame(pEPD, 0, TRUE);			

		// There is the possibility that this side initiated a disconnect, and is now receiving a
		// disconnect from the other side simultaneously.  In this case, we do not want to tell the
		// Core on our side about the disconnect, because the Core on our side is already disconnecting
		// anyway.  We also do not need to send an EOS, because we have sent one already, and can
		// just wait for that one to be ACK'd.
		if(!(pEPD->ulEPFlags & EPFLAGS_SENT_DISCONNECT))
		{
			// We know we won't get in here twice because of EPFLAGS_RECEIVED_DISCONNECT above.
			Unlock(&pEPD->EPLock);

			DPFX(DPFPREP,DPF_CALLOUT_LVL, "(%p) Calling Core->IndicateDisconnect, Core Context[%p]", pEPD, pEPD->Context);
			pEPD->pSPD->pPData->pfVtbl->IndicateDisconnect(pEPD->pSPD->pPData->Parent, pEPD->Context);

			Lock(&pEPD->EPLock);

			// This will prevent any new sends, so don't set it until after calling IndicateDisconnect.
			pEPD->ulEPFlags |= EPFLAGS_SENT_DISCONNECT;			

			if((pMSD = BuildDisconnectFrame(pEPD)) == NULL)
			{	
				DropLink(pEPD);									// DROPLINK will release EPLock for us
				return;
			}

			pMSD->CommandID = COMMAND_ID_DISC_RESPONSE;			// Mark MSD so we know its not a user command

			LOCK_EPD(pEPD, "LOCK (DISC RESP)");					// Add reference for this frame
			pEPD->pCommand = pMSD;								// Store the DisconnectResp on the Endpoint until it is complete

			DPFX(DPFPREP,7, "(%p) Responding to Disconnect. pMSD=0x%p", pEPD, pMSD);
			EnqueueMessage(pMSD, pEPD);							// Enqueue the DISC frame at end of sendQ
		}
	}

	Unlock(&pEPD->EPLock);
}

/*
**		Process SP Disconnect
**
**		Service Provider has told us that an endpoint has gone away.  This is probably
**	because we have Disconnected it ourselves, in which case the IN_USE flag will be
**	clear.  Otherwise,  we need to clean this thing up ourselves...
*/

#undef DPF_MODNAME
#define DPF_MODNAME "ProcessSPDisconnect"

VOID
ProcessSPDisconnect(PSPD pSPD, PSPIE_DISCONNECT pDataBlock)
{
	PEPD 	pEPD = static_cast<PEPD>( pDataBlock->pEndpointContext );
	ASSERT_EPD(pEPD);
	ASSERT(pEPD->pSPD == pSPD);
	PMSD	pMSD = NULL;

	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: pSPD[%p], pDataBlock[%p] - pEPD[%p]", pSPD, pDataBlock, pEPD);

	Lock(&pEPD->EPLock);

	// Make sure ReleaseEPD knows that this occurred
	pEPD->ulEPFlags |= EPFLAGS_SP_DISCONNECTED;

	if (!(pEPD->ulEPFlags & EPFLAGS_STATE_TERMINATING))
	{
		DECREMENT_EPD(pEPD, "SP reference"); // Remove the SP reference

		// If there is an outstanding connection, clean it up
		if (pEPD->ulEPFlags & (EPFLAGS_STATE_CONNECTING|EPFLAGS_STATE_DORMANT))
		{
			// Even if this is COMMAND_ID_CONNECT this is safe to do
			pEPD->ulEPFlags &= ~(EPFLAGS_LINKED_TO_LISTEN);
			pEPD->blSPLinkage.RemoveFromList();						// Unlink EPD from Listen Queue

			// We know this will only happen once because the person who does it will transition us out
			// of the CONNECTING state, and we can't get here unless we are in that state.
			pMSD = pEPD->pCommand;
			pEPD->pCommand = NULL;
		}

		DropLink(pEPD); // This will release the EPLock

		if (pMSD)
		{
			Lock(&pMSD->CommandLock);
			RELEASE_MSD(pMSD, "EPD Ref");
		}
	}
	else
	{
		RELEASE_EPD(pEPD, "SP reference"); // releases EPLock
	}
}

/*
**		Process Listen Status
**
**		This call tells us that a submitted Listen command has become active.  Truth is, we
**	dont care.  We are just interested in seeing the Connect indications as they arrive.  What we
**	do care about,  however, is the Endpoint handle associated with this listen in case we are
**	later asked about the address associated with the listen.  So we will pull it out of the
**	data block and save it in our MSD.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "ProcessListenStatus"

VOID
ProcessListenStatus(PSPD pSPD, PSPIE_LISTENSTATUS pDataBlock)
{
	PMSD	pMSD;
	
	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: pSPD[%p], pDataBlock[%p] - hr=%x", pSPD, pDataBlock, pDataBlock->hResult);

	pMSD = (PMSD) pDataBlock->pUserContext;

	ASSERT_MSD(pMSD);
	ASSERT(pMSD->pSPD == pSPD);
	ASSERT(pMSD->CommandID == COMMAND_ID_LISTEN);

	pMSD->hListenEndpoint = pDataBlock->hEndpoint;

	DPFX(DPFPREP,DPF_CALLOUT_LVL, "Calling Core->CompleteListen, pMSD[%p], Core Context[%p], hr[%x]", pMSD, pMSD->Context, pDataBlock->hResult);
	pSPD->pPData->pfVtbl->CompleteListen(pSPD->pPData->Parent, &pMSD->Context, pDataBlock->hResult, pDataBlock->hEndpoint);
	
	if(pDataBlock->hResult != DPN_OK)
	{
		// Release the final reference on the MSD AFTER indicating to the Core
		Lock(&pMSD->CommandLock);
		RELEASE_MSD(pMSD, "Release On Complete");
	}

	return;
}

/*
**		Process Connect Address Info
**
**		This call tells us what addressing information has been used to start a connect.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "ProcessConnectAddressInfo"

VOID
ProcessConnectAddressInfo(PSPD pSPD, PSPIE_CONNECTADDRESSINFO pDataBlock)
{
	PMSD	pMSD;
	
	pMSD = (PMSD) pDataBlock->pCommandContext;

	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: pSPD[%p], pDataBlock[%p] - pMSD[%p]", pSPD, pDataBlock, pMSD);

	ASSERT_MSD(pMSD);
	ASSERT(pMSD->pSPD == pSPD);
	ASSERT(pMSD->CommandID == COMMAND_ID_CONNECT);

	DPFX(DPFPREP,DPF_CALLOUT_LVL, "(%p) Calling Core->AddressInfoConnect, Core Context[%p]", pMSD, pMSD->Context);
	pSPD->pPData->pfVtbl->AddressInfoConnect( pSPD->pPData->Parent,
											  pMSD->Context,
											  pDataBlock->hCommandStatus,
											  pDataBlock->pHostAddress,
											  pDataBlock->pDeviceAddress );
	
	return;
}


/*
**		Process Enum Address Info
**
**		This call tells us what addressing information has been used to start an enum.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "ProcessEnumAddressInfo"

VOID
ProcessEnumAddressInfo(PSPD pSPD, PSPIE_ENUMADDRESSINFO pDataBlock)
{
	PMSD	pMSD;
	
	pMSD = (PMSD) pDataBlock->pCommandContext;

	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: pSPD[%p], pDataBlock[%p] - pMSD[%p]", pSPD, pDataBlock, pMSD);
	
	ASSERT_MSD(pMSD);
	ASSERT(pMSD->pSPD == pSPD);
	ASSERT(pMSD->CommandID == COMMAND_ID_ENUM );

	DPFX(DPFPREP,DPF_CALLOUT_LVL, "(%p) Calling Core->AddressInfoEnum, Core Context[%p]", pMSD, pMSD->Context);
	pSPD->pPData->pfVtbl->AddressInfoEnum( pSPD->pPData->Parent,
										   pMSD->Context,
										   pDataBlock->hCommandStatus,
										   pDataBlock->pHostAddress,
										   pDataBlock->pDeviceAddress );
	
	return;
}

/*
**		Process Listen Address Info
**
**		This call tells us what addressing information has been used to start a listen.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "ProcessListenAddressInfo"

VOID
ProcessListenAddressInfo(PSPD pSPD, PSPIE_LISTENADDRESSINFO pDataBlock)
{
	PMSD	pMSD;
	
	pMSD = (PMSD) pDataBlock->pCommandContext;

	DPFX(DPFPREP,DPF_CALLIN_LVL, "Parameters: pSPD[%p], pDataBlock[%p] - pMSD[%p]", pSPD, pDataBlock, pMSD);

	ASSERT_MSD(pMSD);
	ASSERT(pMSD->pSPD == pSPD);
	ASSERT(pMSD->CommandID == COMMAND_ID_LISTEN );

	DPFX(DPFPREP,DPF_CALLOUT_LVL, "(%p) Calling Core->AddressInfoListen, Core Context[%p]", pMSD, pMSD->Context);
	pSPD->pPData->pfVtbl->AddressInfoListen( pSPD->pPData->Parent,
											 pMSD->Context,
											 pDataBlock->hCommandStatus,
											 pDataBlock->pDeviceAddress );
	
	return;
}

/*************************************
**
**		RECEIVE BUFFER MANAGEMENT
**
**		When multiple frame messages arrive we *may* have to copy them in to a  single contiguous
**	buffer.  We are supporting an OPTIONAL scatter-receive option which would allow sophisticated
**	clients to receive a BUFFER_DESCRIPTOR array instead of a single cont-buffer,  and avoiding
**	a large datacopy.
**
**		For clients which dont support scatter-receive,  we need a pooling strategy for large receive
**	buffers.  We will only need buffers LARGER then our frame limit because smaller receives are delivered
**	in the SPs buffer.
**
**		Try placing receives into generally sized buffers.  If frame size is usu 1.4K bytes, 2K is a small
**	buffer, 4K, 16K, 32K, 64K.  If frame size is <1K we can have 1K buffers too.
**
**
*************************************/


/***********************
========SPACER==========
************************/

/*
**		RCD Pool support routines
**
**		These are the functions called by Fixed Pool Manager as it handles RCDs.
*/

#define	pELEMENT		((PRCD) pElement)

#undef DPF_MODNAME
#define DPF_MODNAME "RCD_Allocate"

BOOL RCD_Allocate(PVOID pElement)
{
	DPFX(DPFPREP,7, "(%p) Allocating new RCD", pELEMENT);

	pELEMENT->blOddFrameLinkage.Initialize();
	pELEMENT->blCompleteLinkage.Initialize();
	pELEMENT->Sign = RCD_SIGN;

	return TRUE;
}

//	Get is called each time an MSD is used

#undef DPF_MODNAME
#define DPF_MODNAME "RCD_Get"

VOID RCD_Get(PVOID pElement)
{
	DPFX(DPFPREP,DPF_REFCNT_FINAL_LVL, "CREATING RCD %p", pELEMENT);

	// NOTE: First sizeof(PVOID) bytes will have been overwritten by the pool code, 
	// we must set them to acceptable values.

	pELEMENT->pRcvBuff = NULL;
	pELEMENT->lRefCnt = 1;
	pELEMENT->ulRFlags = 0;

	ASSERT_RCD(pELEMENT);
}

//	RCD Release  --  This release call will release an entire chain of RCDs
// 	that are linked together... or then again maybe not.

#undef DPF_MODNAME
#define DPF_MODNAME "RCD_Release"

VOID RCD_Release(PVOID pElement)
{
	ASSERT_RCD(pELEMENT);

	ASSERT(pELEMENT->lRefCnt == 0);
	ASSERT(pELEMENT->pRcvBuff == NULL);

	DPFX(DPFPREP,DPF_REFCNT_FINAL_LVL, "RELEASING RCD %p", pELEMENT);
}

#undef DPF_MODNAME
#define DPF_MODNAME "RCD_Free"

VOID RCD_Free(PVOID pElement)
{
}

#undef	pELEMENT

/*
**		Buffer pool support
**
**
*/

#define	pELEMENT		((PBUF) pElement)

#undef DPF_MODNAME
#define DPF_MODNAME "Buf_Allocate"

BOOL	Buf_Allocate(PVOID pElement)
{
	DPFX(DPFPREP,7, "(%p) Allocating new Buf", pElement);

	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Buf_Get"

VOID Buf_Get(PVOID pElement)
{
	// NOTE: First sizeof(PVOID) bytes will have been overwritten by the pool code, 
	// we must set them to acceptable values.

	pELEMENT->Type = RBT_PROTOCOL_BUFFER;
	pELEMENT->Owner = BufPool;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Buf_GetMed"

VOID Buf_GetMed(PVOID pElement)
{
	// NOTE: First sizeof(PVOID) bytes will have been overwritten by the pool code, 
	// we must set them to acceptable values.

	pELEMENT->Type = RBT_PROTOCOL_BUFFER;
	pELEMENT->Owner = MedBufPool;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Buf_GetBig"

VOID Buf_GetBig(PVOID pElement)
{
	// NOTE: First sizeof(PVOID) bytes will have been overwritten by the pool code, 
	// we must set them to acceptable values.

	pELEMENT->Type = RBT_PROTOCOL_BUFFER;
	pELEMENT->Owner = BigBufPool;
}

#undef	pELEMENT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\serial\comport.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	   ComPort.cpp
 *  Content:	Serial communications port management class
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/98	jtk		Created
 ***************************************************************************/

#include "dnmdmi.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//
// number of BITS in a serial BYTE
//
#define	BITS_PER_BYTE	8

//
// maximum size of baud rate string
//
#define	MAX_BAUD_STRING_SIZE	7

//
// default size of buffers when parsing
//
#define	DEFAULT_COMPONENT_BUFFER_SIZE	1000

//
// device ID assigned to 'all adapters'
//
#define	ALL_ADAPTERS_DEVICE_ID	0

//
// NULL token
//
#define	NULL_TOKEN	'\0'

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComPort::CComPort - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
//
// Notes:	Do not allocate anything in a constructor
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"ComPort::ComPort"

CComPort::CComPort():
	m_pOwningPool( NULL )
{
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComPort::~CComPort - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"ComPort::~ComPort"

CComPort::~CComPort()
{
	DNASSERT( m_pOwningPool == NULL );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComPort::ReturnSelfToPool - return this item to the pool
//
// Entry:		Nothing
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"ComPort::ReturnSelfToPool"

void	CComPort::ReturnSelfToPool( void )
{
	DNASSERT( m_pOwningPool != NULL );
	m_pOwningPool->Release( this );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComPort::EnumAdapters - enumerate adapters
//
// Entry:		Pointer to enum adapters data
//				
// Exit:		Error code
//
// Note:	This function uses an array of valid endpoints and attempts to open
//			each comport.  COM0 is reserved as the 'all adapters' ID.
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"ComPort::EnumAdapters"

HRESULT	CComPort::EnumAdapters( SPENUMADAPTERSDATA *const pEnumAdaptersData ) const
{
	HRESULT		hr;
	HRESULT		hTempResult;
	BOOL		fPortAvailable[ MAX_DATA_PORTS ];
	DWORD		dwValidPortCount;
	WCHAR		*pWorkingString;
	INT_PTR		iIdx;
	INT_PTR		iOutputIdx;
	DWORD		dwRequiredDataSize = 0;
	DWORD		dwConvertedStringSize;
	DWORD		dwRemainingStringSize;


	DEBUG_ONLY( DNASSERT( m_fInitialized != FALSE ) );
	DNASSERT( pEnumAdaptersData != NULL );
	DNASSERT( ( pEnumAdaptersData->pAdapterData != NULL ) || ( pEnumAdaptersData->dwAdapterDataSize == 0 ) );

	//
	// initialize
	//
	hr = DPN_OK;

	hr = GenerateAvailableComPortList( fPortAvailable, LENGTHOF( fPortAvailable ) - 1, &dwValidPortCount );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Failed to generate list of available comports!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

	dwRequiredDataSize = sizeof( *pEnumAdaptersData->pAdapterData ) * dwValidPortCount;

	iIdx = LENGTHOF( fPortAvailable );
	while ( iIdx > 0 )
	{
		iIdx--;

		//
		// compute exact size based on the com port number
		//
		if ( fPortAvailable[ iIdx ] != FALSE )
		{
			if ( iIdx > 100 )
			{
				dwRequiredDataSize += sizeof( *pEnumAdaptersData->pAdapterData->pwszName ) * 7;
			}
			else
			{
				if ( iIdx > 10 )
				{
					dwRequiredDataSize += sizeof( *pEnumAdaptersData->pAdapterData->pwszName ) * 6;
				}
				else
				{
					dwRequiredDataSize += sizeof( *pEnumAdaptersData->pAdapterData->pwszName ) * 5;
				}
			}
		}
	}

	if ( pEnumAdaptersData->dwAdapterDataSize < dwRequiredDataSize )
	{
		hr = DPNERR_BUFFERTOOSMALL;
		pEnumAdaptersData->dwAdapterDataSize = dwRequiredDataSize;
		DPFX(DPFPREP,  8, "Buffer too small when enumerating comport adapters!" );
		goto Exit;
	}

	//
	// if there are no adapters, bail
	//
	if ( dwValidPortCount == 0 )
	{
		// debug me!
		DNASSERT( FALSE );
		DNASSERT( dwRequiredDataSize == 0 );
		DNASSERT( pEnumAdaptersData->dwAdapterCount == 0 );
		goto Exit;
	}

	DNASSERT( dwValidPortCount >= 1 );
	dwRemainingStringSize = ( dwRequiredDataSize - ( ( sizeof( *pEnumAdaptersData->pAdapterData ) ) * dwValidPortCount ) ) / sizeof( *pEnumAdaptersData->pAdapterData->pwszName );

	//
	// we've got enough space, start building structures
	//
	DEBUG_ONLY( memset( pEnumAdaptersData->pAdapterData, 0xAA, dwRequiredDataSize ) );
	pEnumAdaptersData->dwAdapterCount = dwValidPortCount;

	DBG_CASSERT( sizeof( &pEnumAdaptersData->pAdapterData[ dwValidPortCount ] ) == sizeof( WCHAR* ) );
	pWorkingString = reinterpret_cast<WCHAR*>( &pEnumAdaptersData->pAdapterData[ dwValidPortCount ] );

	iIdx = 1;
	iOutputIdx = 0;
	while ( iIdx < MAX_DATA_PORTS )
	{
		//
		// convert to guid if it's valid
		//
		if ( fPortAvailable[ iIdx ] != FALSE )
		{
			TCHAR	TempBuffer[ (COM_PORT_STRING_LENGTH + 1) ];


			//
			// convert device ID to a string and check for local buffer overrun
			//
			DEBUG_ONLY( TempBuffer[ LENGTHOF( TempBuffer ) - 1 ] = 0x5a );

			ComDeviceIDToString( TempBuffer, iIdx );
			DEBUG_ONLY( DNASSERT( TempBuffer[ LENGTHOF( TempBuffer ) - 1 ] == 0x5a ) );

#ifdef UNICODE
			dwConvertedStringSize = lstrlen(TempBuffer) + 1;
			lstrcpy(pWorkingString, TempBuffer);
#else
			dwConvertedStringSize = dwRemainingStringSize;
			hTempResult = AnsiToWide( TempBuffer, -1, pWorkingString, &dwConvertedStringSize );
			DNASSERT( hTempResult == DPN_OK );
#endif
			DNASSERT( dwRemainingStringSize >= dwConvertedStringSize );
			dwRemainingStringSize -= dwConvertedStringSize;

			pEnumAdaptersData->pAdapterData[ iOutputIdx ].dwFlags = 0;
			pEnumAdaptersData->pAdapterData[ iOutputIdx ].pvReserved = NULL;
			pEnumAdaptersData->pAdapterData[ iOutputIdx ].dwReserved = NULL;
			DeviceIDToGuid( &pEnumAdaptersData->pAdapterData[ iOutputIdx ].guid, iIdx, &g_SerialSPEncryptionGuid );
			pEnumAdaptersData->pAdapterData[ iOutputIdx ].pwszName = pWorkingString;

			pWorkingString = &pWorkingString[ dwConvertedStringSize ];
			iOutputIdx++;
			DEBUG_ONLY( dwValidPortCount-- );
		}

		iIdx++;
	}

	DEBUG_ONLY( DNASSERT( dwValidPortCount == 0 ) );
	DNASSERT( dwRemainingStringSize == 0 );

Exit:
	//
	// set size of output data
	//
	pEnumAdaptersData->dwAdapterDataSize = dwRequiredDataSize;

	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComPort::BindToNetwork - bind to the 'network'
//
// Entry:		Device ID
//				Pointer to device context (CComPortData)
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"ComPort::BindToNetwork"

HRESULT	CComPort::BindToNetwork( const DWORD dwDeviceID, const void *const pDeviceContext )
{
	HRESULT	hr;
	const CComPortData	*pComPortData;

	
	DNASSERT( pDeviceContext != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	pComPortData = static_cast<const CComPortData*>( pDeviceContext );
	m_ComPortData.Copy( pComPortData );

	//
	// open port
	//
	DNASSERT( m_hFile == INVALID_HANDLE_VALUE );
	m_hFile = CreateFile( m_ComPortData.ComPortName(),	// comm port
						  GENERIC_READ | GENERIC_WRITE,	// read/write access
						  0,							// don't share file with others
						  NULL,							// default sercurity descriptor
						  OPEN_EXISTING,				// comm port must exist to be opened
						  FILE_FLAG_OVERLAPPED,			// use overlapped I/O
						  NULL							// no handle for template file
						  );
	if ( m_hFile == INVALID_HANDLE_VALUE )
	{
		DWORD	dwError;


		hr = DPNERR_NOCONNECTION;
		dwError = GetLastError();
		DPFX(DPFPREP,  0, "CreateFile() failed!" );
		DisplayErrorCode( 0, dwError );
		goto Failure;
	}

	//
	// bind to completion port for NT
	//
#ifdef WINNT
	HANDLE	hCompletionPort;


	hCompletionPort = CreateIoCompletionPort( m_hFile,												// current file handle
											  GetSPData()->GetThreadPool()->GetIOCompletionPort(),	// handle of completion port
											  IO_COMPLETION_KEY_IO_COMPLETE,						// completion key
											  0														// number of concurrent threads (default to number of processors)
											  );
	if ( hCompletionPort == NULL )
	{
		DWORD	dwError;


		hr = DPNERR_OUTOFMEMORY;
		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Cannot bind comport to completion port!" );
		DisplayErrorCode( 0, dwError );
		goto Failure;
	}
	DNASSERT( hCompletionPort == GetSPData()->GetThreadPool()->GetIOCompletionPort() );
#endif

	//
	// set bit rate, etc.
	//
	hr = SetPortState();
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Problem with SetPortState" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

	//
	// set general comminications paramters (timeouts, etc.)
	//
	hr = SetPortCommunicationParameters();
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Failed to set communication paramters!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

	//
	// start receiving
	//
	hr = StartReceiving();
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Failed to start receiving!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

Exit:
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Problem with CComPort::Open" );
		DisplayDNError( 0, hr );
	}

	return hr;

Failure:
	if ( m_hFile != NULL )
	{
		CloseHandle( m_hFile );
		m_hFile = INVALID_HANDLE_VALUE;
	}
//	Close();
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComPort::UnbindFromNetwork - unbind to the 'network'
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"ComPort::UnbindFromNetwork"

void	CComPort::UnbindFromNetwork( void )
{
	CReadIOData *	pReadData;

	
	DPFX(DPFPREP, 6, "(0x%p) Enter", this);


	DNASSERT( GetState() == DATA_PORT_STATE_UNBOUND );

	if ( GetHandle() != INVALID_HANDLE_VALUE )
	{
		GetSPData()->GetThreadPool()->CloseDataPortHandle( this );
		DNASSERT( GetHandle() == INVALID_HANDLE_VALUE );
	}

	//
	// if there's a com file, purge all communications and close it
	//
	if ( m_hFile != INVALID_HANDLE_VALUE )
	{
		DPFX(DPFPREP, 6, "Flushing and closing COM port file handle 0x%p.", m_hFile);
	
		//
		// wait until all writes have completed
		//
		if ( FlushFileBuffers( m_hFile ) == FALSE )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Problem with FlushFileBuffers() when closing com port!" );
			DisplayErrorCode( 0, dwError );
		}


		//
		// force all communication to complete
		//
		if ( PurgeComm( m_hFile, ( PURGE_TXABORT | PURGE_RXABORT | PURGE_TXCLEAR | PURGE_RXCLEAR ) ) == FALSE )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Problem with PurgeComm() when closing com port!" );
			DisplayErrorCode( 0, dwError );
		}


#ifdef WIN95
		pReadData = this->GetActiveRead();
		
		//
		// if there is a pending read, wait until it completes
		//
		
		if ( pReadData != NULL )
		{
			//
			// pull it out of the list so the regular receive thread doesn't catch the completion
			//
			GetSPData()->GetThreadPool()->LockReadData();
			pReadData->m_OutstandingReadListLinkage.RemoveFromList();
			GetSPData()->GetThreadPool()->UnlockReadData();


			if ( pReadData->Win9xOperationPending() != FALSE )
			{
				DWORD	dwAttempt;


				dwAttempt = 0;
				
WaitAgain:
				DPFX(DPFPREP, 1, "Checking if read 0x%p has completed.", pReadData );
				
				if ( GetOverlappedResult( m_hFile,
										  pReadData->Overlap(),
										  &pReadData->jkm_dwOverlappedBytesReceived,
										  FALSE
										  ) != FALSE )
				{
					DBG_CASSERT( ERROR_SUCCESS == 0 );
					pReadData->m_dwWin9xReceiveErrorReturn = ERROR_SUCCESS;
				}
				else
				{
					DWORD	dwError;


					//
					// other error, stop if not 'known'
					//
					dwError = GetLastError();
					switch( dwError )
					{
						//
						// ERROR_IO_INCOMPLETE = treat as I/O complete.  Event isn't
						//						 signalled, but that's expected because
						//						 it's cleared before checking for I/O
						//
						case ERROR_IO_INCOMPLETE:
						{
							pReadData->jkm_dwOverlappedBytesReceived = pReadData->m_dwBytesToRead;
							pReadData->m_dwWin9xReceiveErrorReturn = ERROR_SUCCESS;
						    break;
						}

						//
						// ERROR_IO_PENDING = io still pending
						//
						case ERROR_IO_PENDING:
						{
							dwAttempt++;
							if (dwAttempt <= 6)
							{
								DPFX(DPFPREP, 1, "Read data 0x%p has not completed yet, waiting for %u ms.",
									pReadData, (dwAttempt * 100));

								SleepEx(dwAttempt, TRUE);

								goto WaitAgain;
							}
							
							DPFX(DPFPREP, 0, "Read data 0x%p still not marked as completed, ignoring.",
								pReadData);
							break;
						}

						//
						// ERROR_OPERATION_ABORTED = operation was cancelled (COM port closed)
						// ERROR_INVALID_HANDLE = operation was cancelled (COM port closed)
						//
						case ERROR_OPERATION_ABORTED:
						case ERROR_INVALID_HANDLE:
						{
							break;
						}

						default:
						{
							DisplayErrorCode( 0, dwError );
							DNASSERT( FALSE );
							break;
						}
					}

					pReadData->m_dwWin9xReceiveErrorReturn = dwError;
				}


				DNASSERT( pReadData->Win9xOperationPending() != FALSE );
				pReadData->SetWin9xOperationPending( FALSE );

				DNASSERT( pReadData->DataPort() == this );
				this->ProcessReceivedData( pReadData->jkm_dwOverlappedBytesReceived, pReadData->m_dwWin9xReceiveErrorReturn );
			}
		}
		else
		{
			//
			// it's not pending Win9x style, ignore it and hope a receive
			// thread picked up the completion
			//
			DPFX(DPFPREP, 8, "Read data 0x%p not pending Win9x style, assuming receive thread picked up completion." );
		}
#endif

		if ( CloseHandle( m_hFile ) == FALSE )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Problem with CloseHandle(): 0x%x", dwError );
		}

		m_hFile = INVALID_HANDLE_VALUE;
	}
	
	SetLinkDirection( LINK_DIRECTION_UNKNOWN );


	DPFX(DPFPREP, 6, "(0x%p) Leave", this);
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComPort::BindEndpoint - bind endpoint to this data port
//
// Entry:		Pointer to endpoint
//				Endpoint type
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"ComPort::BindEndpoint"
HRESULT	CComPort::BindEndpoint( CEndpoint *const pEndpoint, const ENDPOINT_TYPE EndpointType )
{
	HRESULT	hr;
	IDirectPlay8Address	*pDeviceAddress;
	IDirectPlay8Address	*pHostAddress;


	DNASSERT( pEndpoint != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	pDeviceAddress = NULL;
	pHostAddress = NULL;

	Lock();

	//
	// we're only allowed one endpoint of any given type so determine which
	// type end then bind the endpoint
	//
	switch ( EndpointType )
	{
		case ENDPOINT_TYPE_CONNECT:
		case ENDPOINT_TYPE_CONNECT_ON_LISTEN:
		{
			if ( m_hConnectEndpoint != INVALID_HANDLE_VALUE )
			{
				hr = DPNERR_ALREADYINITIALIZED;
				DPFX(DPFPREP,  0, "Attempted to bind connect endpoint when one already exists!" );
				goto Failure;
			}

			m_hConnectEndpoint = pEndpoint->GetHandle();
			
			if ( EndpointType == ENDPOINT_TYPE_CONNECT )
			{
				SPIE_CONNECTADDRESSINFO	ConnectAddressInfo;
				HRESULT	hTempResult;
				
				
				//
				// set addresses in addressing information
				//
				pDeviceAddress = ComPortData()->DP8AddressFromComPortData( ADDRESS_TYPE_LOCAL_ADAPTER );
				pHostAddress = ComPortData()->DP8AddressFromComPortData( ADDRESS_TYPE_REMOTE_HOST );

				memset( &ConnectAddressInfo, 0x00, sizeof( ConnectAddressInfo ) );
				ConnectAddressInfo.pDeviceAddress = pDeviceAddress;
				ConnectAddressInfo.pHostAddress = pHostAddress;
				ConnectAddressInfo.hCommandStatus = DPN_OK;
				ConnectAddressInfo.pCommandContext = pEndpoint->GetCommandData()->GetUserContext();	

				if ( ( ConnectAddressInfo.pDeviceAddress == NULL ) ||
					 ( ConnectAddressInfo.pHostAddress == NULL ) )
				{
					DPFX(DPFPREP,  0, "Failed to build addresses to indicate serial connect addressing!" );
					hr = DPNERR_OUTOFMEMORY;
					goto Failure;
				}

				hTempResult = IDP8SPCallback_IndicateEvent( GetSPData()->DP8SPCallbackInterface(),	// interface
															SPEV_CONNECTADDRESSINFO,				// event type
															&ConnectAddressInfo						// pointer to data
															);
				DNASSERT( hTempResult == DPN_OK );
			}

			break;
		}

		case ENDPOINT_TYPE_LISTEN:
		{
			SPIE_LISTENADDRESSINFO	ListenAddressInfo;
			HRESULT	hTempResult;


			if ( m_hListenEndpoint != INVALID_HANDLE_VALUE )
			{
				hr = DPNERR_ALREADYINITIALIZED;
				DPFX(DPFPREP,  0, "Attempted to bind listen endpoint when one already exists!" );
				goto Failure;
			}
			m_hListenEndpoint = pEndpoint->GetHandle();
			
			//
			// set addressing information
			//
			pDeviceAddress = ComPortData()->DP8AddressFromComPortData( ADDRESS_TYPE_LOCAL_ADAPTER );
			DNASSERT( pHostAddress == NULL );

			memset( &ListenAddressInfo, 0x00, sizeof( ListenAddressInfo ) );
			ListenAddressInfo.pDeviceAddress = pDeviceAddress;
			ListenAddressInfo.hCommandStatus = DPN_OK;
			ListenAddressInfo.pCommandContext = pEndpoint->GetCommandData()->GetUserContext();

			if ( ListenAddressInfo.pDeviceAddress == NULL )
			{
				DPFX(DPFPREP,  0, "Failed to build addresses to indicate serial listen addressing!" );
				hr = DPNERR_OUTOFMEMORY;
				goto Failure;
			}

			hTempResult = IDP8SPCallback_IndicateEvent( GetSPData()->DP8SPCallbackInterface(),	// interface
														SPEV_LISTENADDRESSINFO,					// event type
														&ListenAddressInfo						// pointer to data
														);
			DNASSERT( hTempResult == DPN_OK );

			break;
		}

		case ENDPOINT_TYPE_ENUM:
		{
			SPIE_ENUMADDRESSINFO	EnumAddressInfo;
			HRESULT	hTempResult;

			
			if ( m_hEnumEndpoint != INVALID_HANDLE_VALUE )
			{
				hr = DPNERR_ALREADYINITIALIZED;
				DPFX(DPFPREP,  0, "Attempted to bind enum endpoint when one already exists!" );
				goto Exit;
			}
			m_hEnumEndpoint = pEndpoint->GetHandle();
			
			//
			// indicate addressing to a higher layer
			//
			pDeviceAddress = ComPortData()->DP8AddressFromComPortData( ADDRESS_TYPE_LOCAL_ADAPTER );
			pHostAddress = ComPortData()->DP8AddressFromComPortData( ADDRESS_TYPE_REMOTE_HOST );
			
			memset( &EnumAddressInfo, 0x00, sizeof( EnumAddressInfo ) );
			EnumAddressInfo.pDeviceAddress = pDeviceAddress;
			EnumAddressInfo.pHostAddress = pHostAddress;
			EnumAddressInfo.hCommandStatus = DPN_OK;
			EnumAddressInfo.pCommandContext = pEndpoint->GetCommandData()->GetUserContext();

			if ( ( EnumAddressInfo.pDeviceAddress == NULL ) ||
				 ( EnumAddressInfo.pHostAddress == NULL ) )
			{
				DPFX(DPFPREP,  0, "Failed to build addresses to indicate serial enum addressing!" );
				hr = DPNERR_OUTOFMEMORY;
				goto Failure;
			}

			hTempResult = IDP8SPCallback_IndicateEvent( GetSPData()->DP8SPCallbackInterface(),
														SPEV_ENUMADDRESSINFO,
														&EnumAddressInfo
														);
			DNASSERT( hTempResult == DPN_OK );
			
			break;
		}

		//
		// invalid case, we should never be here
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

	//
	// add these references before the lock is released to prevent them from
	// being immediately cleaned
	//
	pEndpoint->SetDataPort( this );
	pEndpoint->AddRef();
	
	//
	// if this was a connect or enum, indicate that the outgoing connection is
	// ready.
	//
	if ( ( EndpointType == ENDPOINT_TYPE_CONNECT ) ||
		 ( EndpointType == ENDPOINT_TYPE_ENUM ) )
	{
		pEndpoint->OutgoingConnectionEstablished( DPN_OK );
	}

	Unlock();
	
Exit:
	if ( pHostAddress != NULL )
	{
		IDirectPlay8Address_Release( pHostAddress );
		pHostAddress = NULL;
	}

	if ( pDeviceAddress != NULL )
	{
		IDirectPlay8Address_Release( pDeviceAddress );
		pDeviceAddress = NULL;
	}
	
	return	hr;

Failure:
	Unlock();
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComPort::UnbindEndpoint - unbind endpoint from this data port
//
// Entry:		Pointer to endpoint
//				Endpoint type
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"ComPort::UnbindEndpoint"
void	CComPort::UnbindEndpoint( CEndpoint *const pEndpoint, const ENDPOINT_TYPE EndpointType )
{
	DNASSERT( pEndpoint != NULL );

	Lock();
	
	DNASSERT( pEndpoint->GetDataPort() == this );
	switch ( EndpointType )
	{
		case ENDPOINT_TYPE_CONNECT_ON_LISTEN:
		case ENDPOINT_TYPE_CONNECT:
		{
			DNASSERT( m_hConnectEndpoint != INVALID_HANDLE_VALUE );
			m_hConnectEndpoint = INVALID_HANDLE_VALUE;
			break;
		}

		case ENDPOINT_TYPE_LISTEN:
		{
			DNASSERT( m_hListenEndpoint != INVALID_HANDLE_VALUE );
			m_hListenEndpoint = INVALID_HANDLE_VALUE;
			break;
		}

		case ENDPOINT_TYPE_ENUM:
		{
			DNASSERT( m_hEnumEndpoint != INVALID_HANDLE_VALUE );
			m_hEnumEndpoint = INVALID_HANDLE_VALUE;
			break;
		}

		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}
	
	Unlock();

	pEndpoint->SetDataPort( NULL );
	pEndpoint->DecRef();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComPort::PoolAllocFunction - called when new pool item is allocated
//
// Entry:		Pointer to context
//
// Exit:		Boolean inidcating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"ComPort::PoolAllocFunction"

BOOL	CComPort::PoolAllocFunction( DATA_PORT_POOL_CONTEXT *pContext )
{
	DNASSERT( pContext != NULL );
	DNASSERT( pContext->pSPData->GetType() == TYPE_SERIAL );
	DNASSERT( GetActiveRead() == NULL );
	DNASSERT( GetHandle() == INVALID_HANDLE_VALUE );
	
	return TRUE;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComPort::PoolInitFunction - called when new pool item is removed from pool
//
// Entry:		Pointer to context
//
// Exit:		Boolean inidcating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"ComPort::PoolInitFunction"

BOOL	CComPort::PoolInitFunction( DATA_PORT_POOL_CONTEXT *pContext )
{
	BOOL	fReturn;
	HRESULT	hTempResult;

	
	DNASSERT( pContext != NULL );
	DNASSERT( pContext->pSPData->GetType() == TYPE_SERIAL );
	
	fReturn = TRUE;
	DNASSERT( GetActiveRead() == NULL );
	DNASSERT( GetHandle() == INVALID_HANDLE_VALUE );

	hTempResult = CDataPort::Initialize( pContext->pSPData );
	if ( hTempResult != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Failed to initalize DataPort base class!" );
		DisplayDNError( 0, hTempResult );
		fReturn = FALSE;
	}
	
	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComPort::PoolReleaseFunction - called when new pool item is returned to  pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"ComPort::PoolReleaseFunction"

void	CComPort::PoolReleaseFunction( void )
{
	CDataPort::Deinitialize();
	m_ComPortData.Reset();
	DNASSERT( GetActiveRead() == NULL );
	DNASSERT( GetHandle() == INVALID_HANDLE_VALUE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComPort::PoolDeallocFunction - called when new pool item is deallocated
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"ComPort::PoolDeallocFunction"

void	CComPort::PoolDeallocFunction( void )
{
	DNASSERT( GetActiveRead() == NULL );
	DNASSERT( GetHandle() == INVALID_HANDLE_VALUE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComPort::SetPortState - set communications port state
//		description
//
// Entry:		Nothing
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"ComPort::SetPortState"

HRESULT	CComPort::SetPortState( void )
{
	DCB	Dcb;
	HRESULT	hr;


	DNASSERT( m_hFile != INVALID_HANDLE_VALUE );

	//
	// initialize
	//
	hr = DPN_OK;
	memset( &Dcb, 0x00, sizeof( Dcb ) );
	Dcb.DCBlength = sizeof( Dcb );

	//
	// set parameters
	//
	Dcb.BaudRate = GetBaudRate();	// current baud rate
	Dcb.fBinary = TRUE;				// binary mode, no EOF check (MUST BE TRUE FOR WIN32!)

	//
	// parity
	//
	if ( GetParity() != NOPARITY )
	{
		Dcb.fParity = TRUE;
	}
	else
	{
		Dcb.fParity = FALSE;
	}

	//
	// are we using RTS?
	//
	if ( ( GetFlowControl() == FLOW_RTS ) ||
		 ( GetFlowControl() == FLOW_RTSDTR ) )
	{
		Dcb.fOutxCtsFlow = TRUE;					// allow RTS/CTS
		Dcb.fRtsControl = RTS_CONTROL_HANDSHAKE;	// handshake with RTS/CTS
	}
	else
	{
		Dcb.fOutxCtsFlow = FALSE;					// disable RTS/CTS
		Dcb.fRtsControl = RTS_CONTROL_ENABLE;		// always be transmit ready
	}

	//
	// are we using DTR?
	//
	if ( ( GetFlowControl() == FLOW_DTR ) ||
		 ( GetFlowControl() == FLOW_RTSDTR ) )
	{
		Dcb.fOutxDsrFlow = TRUE;					// allow DTR/DSR
		Dcb.fDtrControl = DTR_CONTROL_HANDSHAKE;	// handshake with DTR/DSR
	}
	else
	{
		Dcb.fOutxDsrFlow = FALSE;					// disable DTR/DSR
		Dcb.fDtrControl = DTR_CONTROL_ENABLE;		// always be ready
	}


	//
	// DSR sensitivity
	//
	Dcb.fDsrSensitivity = FALSE;	// TRUE = incoming data dropped if DTR is not set

	//
	// continue sending after Xoff
	//
	Dcb.fTXContinueOnXoff= FALSE;	// TRUE = continue to send data after XOFF has been received
									// and there's room in the buffer


	//
	// are we using Xon/Xoff?
	//
	if ( GetFlowControl() == FLOW_XONXOFF )
	{
		Dcb.fOutX = TRUE;
		Dcb.fInX = TRUE;
	}
	else
	{
		// disable Xon/Xoff
		Dcb.fOutX = FALSE;
		Dcb.fInX = FALSE;
	}

	//
	// replace erroneous bytes with 'Error Byte'
	//
	Dcb.fErrorChar = FALSE;			// TRUE = replace bytes with parity errors with
									// an error character

	//
	// drop NULL characters
	//
	Dcb.fNull = FALSE;				// TRUE = remove NULLs from input stream

	//
	// stop on error
	//
	Dcb.fAbortOnError = FALSE;		// TRUE = abort reads/writes on error

	//
	// reserved, set to zero!
	//
	Dcb.fDummy2 = NULL;				// reserved

	//
	// reserved
	//
	Dcb.wReserved = NULL;			// not currently used

	//
	// buffer size before sending Xon/Xoff
	//
	Dcb.XonLim = XON_LIMIT;			// transmit XON threshold
	Dcb.XoffLim = XOFF_LIMIT;		// transmit XOFF threshold

	//
	// size of a 'byte'
	//
	Dcb.ByteSize = BITS_PER_BYTE;	// number of bits/byte, 4-8

	//
	// set parity type
	//
	DNASSERT( GetParity() < 256 );
	Dcb.Parity = static_cast<BYTE>( GetParity() );

	//
	// stop bits
	//
	DNASSERT( GetStopBits() < 256 );
	Dcb.StopBits = static_cast<BYTE>( GetStopBits() );	// 0,1,2 = 1, 1.5, 2

	//
	// Xon/Xoff characters
	//
	Dcb.XonChar = ASCII_XON;		// Tx and Rx XON character
	Dcb.XoffChar = ASCII_XOFF;		// Tx and Rx XOFF character

	//
	// error replacement character
	//
	Dcb.ErrorChar = NULL_TOKEN;		// error replacement character

	//
	// EOF character
	//
	Dcb.EofChar = NULL_TOKEN;		// end of input character

	//
	// event signal character
	//
	Dcb.EvtChar = NULL_TOKEN;		// event character

	Dcb.wReserved1 = 0;				// reserved; do not use

	//
	// set the state of the communication port
	//
	if ( SetCommState( m_hFile, &Dcb ) == FALSE )
	{
		DWORD	dwError;


		hr = DPNERR_GENERIC;
		dwError = GetLastError();
		DPFX(DPFPREP,  0, "SetCommState failed!" );
		DisplayErrorCode( 0, dwError );
		goto Exit;
	}

Exit:
	return	hr;
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\serial\commanddata.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       CommandData.h
 *  Content:	Declaration of class representing a command
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	04/07/99	jtk		Derived from SPData.h
 ***************************************************************************/

#ifndef __COMMAND_DATA_H__
#define __COMMAND_DATA_H__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_MODEM


//**********************************************************************
// Constant definitions
//**********************************************************************

typedef	enum
{
	COMMAND_STATE_UNKNOWN,					// unknown state
	COMMAND_STATE_PENDING,					// command waiting to be processed
	COMMAND_STATE_INPROGRESS,				// command is executing
	COMMAND_STATE_INPROGRESS_CANNOT_CANCEL,	// command is executing, can't be cancelled
	COMMAND_STATE_CANCELLING,				// command is already being cancelled
} COMMAND_STATE;

typedef	enum
{	
	COMMAND_TYPE_UNKNOWN,		// unknown command
	COMMAND_TYPE_CONNECT,		// connect command
	COMMAND_TYPE_LISTEN,		// listen command
	COMMAND_TYPE_ENUM_QUERY,	// enum command
	COMMAND_TYPE_SEND,			// data send command (enum, enum query, send)
} COMMAND_TYPE;

#define	NULL_DESCRIPTOR		0

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward class and structure references
//
class	CEndpoint;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class definitions
//**********************************************************************

//
// class for command data
//
class	CCommandData : public CLockedPoolItem
{
	public:
		CCommandData();
		~CCommandData();

		void	Lock( void ) { DNEnterCriticalSection( &m_Lock ); }
		void	Unlock( void ) { DNLeaveCriticalSection( &m_Lock ); }

		DWORD	GetDescriptor( void ){ return m_dwDescriptor; }
		void	SetDescriptor( void )
		{
			m_dwDescriptor = m_dwNextDescriptor;
			m_dwNextDescriptor++;
			if ( m_dwNextDescriptor == NULL_DESCRIPTOR )
			{
				m_dwNextDescriptor++;
			}

			SetState( COMMAND_STATE_UNKNOWN );
		}

		COMMAND_STATE	GetState( void ) { return m_State; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CCommandData::SetState"
		void			SetState( const COMMAND_STATE State )
		{
			DNASSERT( ( ( m_State == COMMAND_STATE_UNKNOWN ) || ( State == COMMAND_STATE_UNKNOWN ) ) ||
					  ( ( m_State == COMMAND_STATE_PENDING ) && ( State == COMMAND_STATE_INPROGRESS ) ) ||
					  ( ( m_State == COMMAND_STATE_PENDING ) && ( State == COMMAND_STATE_INPROGRESS_CANNOT_CANCEL ) ) ||
					  ( ( m_State == COMMAND_STATE_PENDING ) && ( State == COMMAND_STATE_CANCELLING ) ) ||
					  ( ( m_State == COMMAND_STATE_INPROGRESS ) && ( State == COMMAND_STATE_CANCELLING ) ) );
			m_State = State;
		}

		COMMAND_TYPE	GetType( void ) { return m_Type; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CCommandData::SetType"
		void			SetType( const COMMAND_TYPE Type )
		{
			DNASSERT( ( m_Type == COMMAND_TYPE_UNKNOWN ) || ( Type == COMMAND_TYPE_UNKNOWN ) );
			m_Type = Type;
		}

		CEndpoint	*GetEndpoint( void ) { return m_pEndpoint; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CCommandData::SetEndpoint"
		void		SetEndpoint( CEndpoint *const pEndpoint )
		{
			DNASSERT( ( m_pEndpoint == NULL ) || ( pEndpoint == NULL ) );
			m_pEndpoint = pEndpoint;
		}

		void	*GetUserContext( void ){ return m_pUserContext; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CCommandData::SetUserContext"
		void	SetUserContext( void *const pUserContext )
		{
			DNASSERT( ( m_pUserContext == NULL ) || ( pUserContext == NULL ) );
			m_pUserContext = pUserContext;
		}

		void	AddToActiveCommandList( CBilink *const pLinkage ) { m_CommandListLinkage.InsertAfter( pLinkage ); }
		void	RemoveFromActiveCommandList( void ) { m_CommandListLinkage.RemoveFromList(); }

		void	Reset( void );

		//
		// pool functions
		//
		BOOL	PoolAllocFunction( void );
		BOOL	PoolInitFunction( void );
		void	PoolReleaseFunction( void );
		void	PoolDeallocFunction( void );
		void	ReturnSelfToPool( void );

		#undef DPF_MODNAME
		#define DPF_MODNAME "CCommandData::SetOwningPool"
		void	SetOwningPool( CLockedPool< CCommandData > *const pOwningPool )
		{
			DEBUG_ONLY( DNASSERT( ( m_pOwningPool == NULL ) || ( pOwningPool == NULL ) ) );
			m_pOwningPool = pOwningPool;
		}
	
	protected:

	private:
		DNCRITICAL_SECTION	m_Lock;
		CBilink				m_CommandListLinkage;

		volatile DWORD			m_dwDescriptor;
		volatile DWORD			m_dwNextDescriptor;
		volatile COMMAND_STATE	m_State;
		COMMAND_TYPE			m_Type;
		CEndpoint			*m_pEndpoint;
		void				*m_pUserContext;

		CLockedPool< CCommandData >	*m_pOwningPool;

		//
		// prevent unwarranted copies
		//
		CCommandData( const CCommandData & );
		CCommandData& operator=( const CCommandData & );
};

#undef DPF_MODNAME

#endif	// __COMMAND_DATA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\serial\comendpoint.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ComEndpoint.h
 *  Content:	DNSerial communications comport endpoint
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/98	jtk		Created
 ***************************************************************************/

#ifndef __COM_ENDPOINT_H__
#define __COM_ENDPOINT_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class definition
//**********************************************************************

class	CComEndpoint : public CEndpoint
{
	public:
		CComEndpoint();
		~CComEndpoint();


		#undef DPF_MODNAME
		#define DPF_MODNAME "CComEndpoint::SetOwningPool"
		void	SetOwningPool( CLockedContextFixedPool< CComEndpoint, ENDPOINT_POOL_CONTEXT* > *pOwningPool )
		{
			DEBUG_ONLY( DNASSERT( ( m_pOwningPool == NULL ) || ( pOwningPool == NULL ) ) );
			m_pOwningPool = pOwningPool;
		}
		void	ReturnSelfToPool( void );

		IDirectPlay8Address	*GetRemoteHostDP8Address( void ) const;
		IDirectPlay8Address	*GetLocalAdapterDP8Address( const ADDRESS_TYPE AddressType ) const;

		//
		// UI functions
		//
		HRESULT	ShowSettingsDialog( CThreadPool *const pThreadPool );
		HRESULT	ShowOutgoingSettingsDialog( CThreadPool *const pThreadPool ) { return ShowSettingsDialog( pThreadPool ); }
		HRESULT	ShowIncomingSettingsDialog( CThreadPool *const pThreadPool ) { return ShowSettingsDialog( pThreadPool ); }
		void	StopSettingsDialog( const HWND hDialog );

		//
		// port settings
		//
		DWORD	GetDeviceID( void ) const { return m_ComPortData.GetDeviceID(); }
		HRESULT	SetDeviceID( const DWORD dwDeviceID ) { return m_ComPortData.SetDeviceID( dwDeviceID ); }

		const CComPortData	*ComPortData( void ) const { return &m_ComPortData; }
		const SP_BAUD_RATE	GetBaudRate( void ) const { return m_ComPortData.GetBaudRate(); }
		HRESULT	SetBaudRate( const SP_BAUD_RATE BaudRate ) { return m_ComPortData.SetBaudRate( BaudRate ); }

		const SP_STOP_BITS	GetStopBits( void ) const { return m_ComPortData.GetStopBits(); }
		HRESULT	SetStopBits( const SP_STOP_BITS StopBits ) { return m_ComPortData.SetStopBits( StopBits ); }

		const SP_PARITY_TYPE	GetParity( void ) const  { return m_ComPortData.GetParity(); }
		HRESULT	SetParity( const SP_PARITY_TYPE Parity ) { return m_ComPortData.SetParity( Parity ); }

		const SP_FLOW_CONTROL	GetFlowControl( void ) const { return m_ComPortData.GetFlowControl(); }
		HRESULT	SetFlowControl( const SP_FLOW_CONTROL FlowControl ) { return m_ComPortData.SetFlowControl( FlowControl ); }

		const CComPortData	*GetComPortData( void ) const { return &m_ComPortData; }

		//
		// pool functions
		//
		BOOL	PoolAllocFunction( ENDPOINT_POOL_CONTEXT *pContext );
		BOOL	PoolInitFunction( ENDPOINT_POOL_CONTEXT *pContext );
		void	PoolReleaseFunction( void );
		void	PoolDeallocFunction( void );

	protected:
		
		const GUID	*GetEncryptionGuid( void ) const { return &g_SerialSPEncryptionGuid; }

	private:
		BYTE			m_Sig[4];	// debugging signature ('COEP')
		
		CLockedContextFixedPool< CComEndpoint, ENDPOINT_POOL_CONTEXT* >	*m_pOwningPool;
		CComPortData	m_ComPortData;

		HRESULT	Open( IDirectPlay8Address *const pHostAddress,
					  IDirectPlay8Address *const pAdapterAddress,
					  const LINK_DIRECTION LinkDirection,
					  const ENDPOINT_TYPE EndpointType );
		HRESULT	OpenOnListen( const CEndpoint *const pEndpoint );
		void	Close( const HRESULT hActiveCommandResult );
		DWORD	GetLinkSpeed( void );

		void	EnumComplete( const HRESULT hCompletionCode );
		const void	*GetDeviceContext( void ) const;

		//
		// make copy constructor and assignment operator private and unimplemented
		// to prevent illegal copies from being made
		//
		CComEndpoint( const CComEndpoint & );
		CComEndpoint& operator=( const CComEndpoint & );
};

#undef DPF_MODNAME

#endif	// __COM_ENDPOINT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\serial\commanddata.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       CommandData.cpp
 *  Content:	Class representing a command
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	04/07/1999	jtk		Derived from SPData.h
 *	04/16/2000	jtk		Derived from CommandData.h
 ***************************************************************************/

#include "dnmdmi.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CCommandData::CCommandData - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CCommandData::CCommandData"

CCommandData::CCommandData():
	m_State( COMMAND_STATE_UNKNOWN ),
	m_dwDescriptor( NULL_DESCRIPTOR ),
	m_dwNextDescriptor( NULL_DESCRIPTOR + 1 ),
	m_Type( COMMAND_TYPE_UNKNOWN ),
	m_pEndpoint( NULL ),
	m_pUserContext( NULL ),
	m_pOwningPool( NULL )
{
	m_CommandListLinkage.Initialize();
}
//**********************************************************************


//**********************************************************************
// -